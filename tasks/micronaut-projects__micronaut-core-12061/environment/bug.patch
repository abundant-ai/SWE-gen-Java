diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/Pool49.java b/http-client/src/main/java/io/micronaut/http/client/netty/Pool49.java
index d8a946198e..9c3f3079c4 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/Pool49.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/Pool49.java
@@ -23,6 +23,8 @@ import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.client.exceptions.HttpClientException;
 import io.micronaut.http.netty.channel.loom.EventLoopVirtualThreadScheduler;
+import io.micronaut.http.netty.channel.loom.PrivateLoomSupport;
+import io.micronaut.scheduling.LoomSupport;
 import io.netty.channel.EventLoop;
 import io.netty.channel.SingleThreadIoEventLoop;
 import io.netty.util.concurrent.EventExecutor;
@@ -187,9 +189,10 @@ final class Pool49 implements Pool {
 
             EventExecutor currentExecutor = null;
 
-            EventLoopVirtualThreadScheduler elvts = EventLoopVirtualThreadScheduler.current();
-            if (elvts != null) {
-                currentExecutor = elvts.eventLoop();
+            if (PrivateLoomSupport.isSupported() &&
+                LoomSupport.isVirtual(Thread.currentThread()) &&
+                PrivateLoomSupport.getScheduler(Thread.currentThread()) instanceof EventLoopVirtualThreadScheduler el) {
+                currentExecutor = el.eventLoop();
             }
 
             if (currentExecutor == null) {
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/EventLoopVirtualThreadScheduler.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/EventLoopVirtualThreadScheduler.java
index e0cd72d09a..3dd2d3250b 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/EventLoopVirtualThreadScheduler.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/EventLoopVirtualThreadScheduler.java
@@ -17,11 +17,11 @@ package io.micronaut.http.netty.channel.loom;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.scheduling.LoomSupport;
 import io.netty.util.AttributeMap;
 import io.netty.util.concurrent.EventExecutor;
 
+import java.util.concurrent.Executor;
+
 /**
  * Scheduler for a virtual thread, with metadata. Does not change throughout a virtual thread's
  * lifetime. This class allows for creating local shared resources, e.g. HTTP connections that
@@ -31,8 +31,8 @@ import io.netty.util.concurrent.EventExecutor;
  * @author Jonas Konrad
  */
 @Internal
-public sealed interface EventLoopVirtualThreadScheduler
-    permits LoomCarrierGroup.IoScheduler, LoomCarrierGroup.Runner, LoomCarrierGroup.StickyScheduler {
+public sealed interface EventLoopVirtualThreadScheduler extends Executor
+    permits LoomCarrierGroup.Runner, LoomCarrierGroup.StickyScheduler {
 
     /**
      * Get a shared {@link AttributeMap} for this scheduler.
@@ -49,35 +49,4 @@ public sealed interface EventLoopVirtualThreadScheduler
      */
     @NonNull
     EventExecutor eventLoop();
-
-    /**
-     * Get the virtual thread scheduler of the current thread, if available.
-     *
-     * @return The current scheduler or {@code null}
-     */
-    @Nullable
-    static EventLoopVirtualThreadScheduler current() {
-        if (LoomBranchSupport.isSupported()) {
-            if (!LoomSupport.isVirtual(Thread.currentThread())) {
-                return null;
-            }
-            if (LoomBranchSupport.currentScheduler() instanceof EventLoopVirtualThreadScheduler elvts) {
-                return elvts;
-            } else {
-                return null;
-            }
-        } else if (PrivateLoomSupport.isSupported()) {
-            Thread thread = Thread.currentThread();
-            if (!LoomSupport.isVirtual(thread)) {
-                return null;
-            }
-            if (PrivateLoomSupport.getScheduler(thread) instanceof EventLoopVirtualThreadScheduler elvts) {
-                return elvts;
-            } else {
-                return null;
-            }
-        } else {
-            return null;
-        }
-    }
 }
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomBranchSupport.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomBranchSupport.java
deleted file mode 100644
index da9f48c23a..0000000000
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomBranchSupport.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.netty.channel.loom;
-
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.util.SupplierUtil;
-import io.micronaut.scheduling.LoomSupport;
-
-import java.lang.invoke.LambdaMetafactory;
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
-import java.lang.invoke.MethodType;
-import java.util.concurrent.FutureTask;
-import java.util.function.Supplier;
-
-/**
- * Support for the <a href="https://github.com/openjdk/loom/">OpenJDK loom branch</a>.
- *
- * @since 4.10.0
- * @author Jonas Konrad
- */
-@Internal
-@Experimental
-public final class LoomBranchSupport {
-    private static final Supplier<VirtualThreadSchedulerProxy> DEFAULT_SCHEDULER;
-    private static final Thread DEFAULT_SCHEDULER_THREAD;
-    private static final MethodHandle TO_JDK_SCHEDULER;
-    private static final MethodHandle TO_OUR_SCHEDULER;
-    private static final MethodHandle CURRENT_SCHEDULER;
-    private static final MethodHandle JDK_EXECUTE;
-    private static final MethodHandle SET_SCHEDULER;
-    private static final Class<?> PROXY_LAMBDA_CLASS;
-
-    static {
-        MethodHandle toJdkScheduler;
-        MethodHandle toOurScheduler;
-        MethodHandle currentScheduler;
-        MethodHandle jdkExecute;
-        MethodHandle setScheduler;
-        try {
-            MethodType executeMethodType = MethodType.methodType(void.class, Thread.class, Runnable.class);
-            Class<?> jdkVirtualThreadScheduler = Class.forName("java.lang.Thread$VirtualThreadScheduler");
-
-            currentScheduler = MethodHandles.lookup().findStatic(jdkVirtualThreadScheduler, "current", MethodType.methodType(jdkVirtualThreadScheduler))
-                .asType(MethodType.methodType(Object.class));
-
-            jdkExecute = MethodHandles.lookup().findVirtual(jdkVirtualThreadScheduler, "execute", executeMethodType);
-            MethodHandle ourExecute = MethodHandles.lookup().findStatic(LoomBranchSupport.class, "executeOrUnwrap", MethodType.methodType(void.class, VirtualThreadSchedulerProxy.class, Thread.class, Runnable.class));
-            toJdkScheduler = LambdaMetafactory.metafactory(
-                MethodHandles.lookup(),
-                "execute",
-                MethodType.methodType(jdkVirtualThreadScheduler, VirtualThreadSchedulerProxy.class),
-                executeMethodType,
-                ourExecute,
-                executeMethodType
-            ).dynamicInvoker()
-                .asType(MethodType.methodType(Object.class, VirtualThreadSchedulerProxy.class));
-            toOurScheduler = LambdaMetafactory.metafactory(
-                MethodHandles.lookup(),
-                "execute",
-                MethodType.methodType(VirtualThreadSchedulerProxy.class, jdkVirtualThreadScheduler),
-                executeMethodType,
-                jdkExecute,
-                executeMethodType
-            ).dynamicInvoker()
-                .asType(MethodType.methodType(VirtualThreadSchedulerProxy.class, Object.class));
-            Class<?> ofVirtual = Class.forName("java.lang.Thread$Builder$OfVirtual");
-            setScheduler = MethodHandles.lookup().findVirtual(ofVirtual, "scheduler", MethodType.methodType(ofVirtual, jdkVirtualThreadScheduler))
-                .asType(MethodType.methodType(void.class, Object.class, Object.class));
-        } catch (Exception e) {
-            jdkExecute = null;
-            toJdkScheduler = null;
-            toOurScheduler = null;
-            currentScheduler = null;
-            setScheduler = null;
-        }
-
-        TO_JDK_SCHEDULER = toJdkScheduler;
-        TO_OUR_SCHEDULER = toOurScheduler;
-        CURRENT_SCHEDULER = currentScheduler;
-        JDK_EXECUTE = jdkExecute == null ? null : jdkExecute.asType(MethodType.methodType(void.class, Object.class, Thread.class, Runnable.class));
-        SET_SCHEDULER = setScheduler;
-        PROXY_LAMBDA_CLASS = TO_JDK_SCHEDULER != null ? toJdkScheduler((thread, runnable) -> {
-        }).getClass() : null;
-
-        if (isSupported()) {
-            FutureTask<Object> task = new FutureTask<>(LoomBranchSupport::currentPrivate);
-            DEFAULT_SCHEDULER_THREAD = LoomSupport.newVirtualThreadFactory("default-scheduler-exposer").newThread(task);
-            DEFAULT_SCHEDULER_THREAD.start();
-            DEFAULT_SCHEDULER = SupplierUtil.memoized(() -> {
-                try {
-                    return toOurScheduler(task.get());
-                } catch (Exception e) {
-                    throw new RuntimeException(e);
-                }
-            });
-        } else {
-            DEFAULT_SCHEDULER_THREAD = null;
-            DEFAULT_SCHEDULER = null;
-        }
-    }
-
-    public static boolean isSupported() {
-        return TO_OUR_SCHEDULER != null;
-    }
-
-    static void runOnDefaultScheduler(Runnable r) {
-        DEFAULT_SCHEDULER.get().execute(DEFAULT_SCHEDULER_THREAD, r);
-    }
-
-    static VirtualThreadSchedulerProxy currentScheduler() {
-        return toOurScheduler(currentPrivate());
-    }
-
-    private static Object currentPrivate() {
-        try {
-            return CURRENT_SCHEDULER.invokeExact();
-        } catch (Throwable e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    /**
-     * Transform the given VirtualThreadSchedulerProxy to a JDK VirtualThreadScheduler. The
-     * delegate is implemented using LambdaMetafactory.
-     *
-     * @param proxy The scheduler implementation
-     * @return The JDK delegate
-     */
-    static Object toJdkScheduler(VirtualThreadSchedulerProxy proxy) {
-        try {
-            return TO_JDK_SCHEDULER.invokeExact(proxy);
-        } catch (Throwable e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    /**
-     * Transform the given JDK VirtualThreadScheduler to a {@link VirtualThreadSchedulerProxy}. If
-     * the given scheduler was the result of {@link #toJdkScheduler}, the original proxy is
-     * returned. Otherwise, a wrapper is created.
-     *
-     * @param scheduler The JDK scheduler
-     * @return The scheduler proxy
-     */
-    static VirtualThreadSchedulerProxy toOurScheduler(Object scheduler) {
-        if (scheduler.getClass() == PROXY_LAMBDA_CLASS) {
-            UnwrapClass unwrapClass = new UnwrapClass();
-            try {
-                JDK_EXECUTE.invokeExact(scheduler, (Thread) null, (Runnable) unwrapClass);
-            } catch (Throwable e) {
-                throw new RuntimeException(e);
-            }
-            return unwrapClass.proxy;
-        } else {
-            try {
-                return (VirtualThreadSchedulerProxy) TO_OUR_SCHEDULER.invokeExact(scheduler);
-            } catch (Throwable e) {
-                throw new RuntimeException(e);
-            }
-        }
-    }
-
-    public static void setScheduler(Object builder, VirtualThreadSchedulerProxy scheduler) {
-        try {
-            SET_SCHEDULER.invokeExact(builder, toJdkScheduler(scheduler));
-        } catch (Throwable e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    private static void executeOrUnwrap(VirtualThreadSchedulerProxy target, Thread thread, Runnable task) {
-        if (task instanceof UnwrapClass uc) {
-            uc.proxy = target;
-            return;
-        }
-        target.execute(thread, task);
-    }
-
-    private static final class UnwrapClass implements Runnable {
-        VirtualThreadSchedulerProxy proxy;
-
-        @Override
-        public void run() {
-            throw new UnsupportedOperationException();
-        }
-    }
-
-    interface VirtualThreadSchedulerProxy {
-        void execute(Thread thread, Runnable task);
-    }
-}
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomCarrierGroup.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomCarrierGroup.java
index fa960bb78f..fcc88a9b0d 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomCarrierGroup.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomCarrierGroup.java
@@ -94,7 +94,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         }
     }
 
-    final class Runner implements Runnable, EventLoopVirtualThreadScheduler, ThreadFactory, Executor, LoomBranchSupport.VirtualThreadSchedulerProxy {
+    final class Runner implements Runnable, EventLoopVirtualThreadScheduler, ThreadFactory {
         final int id;
         final Factory factory;
         final ManualIoEventLoop delegate;
@@ -106,7 +106,6 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
          * The continuation of the virtual thread responsible for running the event loop.
          */
         Runnable ioContinuation;
-        Thread ioThread;
         /**
          * {@code true} when the {@link #ioContinuation} has been scheduled but has not run yet.
          */
@@ -211,15 +210,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         }
 
         private boolean isOnRunner(Thread thread) {
-            if (!LoomSupport.isVirtual(thread)) {
-                return false;
-            }
-            if (LoomBranchSupport.isSupported()) {
-                assert thread == Thread.currentThread();
-                return LoomBranchSupport.currentScheduler() == this;
-            } else {
-                return PrivateLoomSupport.getScheduler(thread) == Runner.this;
-            }
+            return LoomSupport.isVirtual(thread) && PrivateLoomSupport.getScheduler(thread) == Runner.this;
         }
 
         /**
@@ -236,9 +227,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
             return LoomSupport.unstarted("loom-on-netty-" + id + "-" + Long.toHexString(ThreadLocalRandom.current().nextLong()), b -> {
                 if (warmupTasks > 0) {
                     warmupTasks--;
-                    if (!LoomBranchSupport.isSupported()) {
-                        PrivateLoomSupport.setScheduler(b, PrivateLoomSupport.getDefaultScheduler());
-                    }
+                    PrivateLoomSupport.setScheduler(b, PrivateLoomSupport.getDefaultScheduler());
                     return;
                 }
 
@@ -254,11 +243,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
                         }
                     }
                 }
-                if (LoomBranchSupport.isSupported()) {
-                    LoomBranchSupport.setScheduler(b, new StickyScheduler(dst));
-                } else {
-                    PrivateLoomSupport.setScheduler(b, new StickyScheduler(dst));
-                }
+                PrivateLoomSupport.setScheduler(b, new StickyScheduler(dst));
             }, r);
         }
 
@@ -266,18 +251,11 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         public void run() {
             carrier = Thread.currentThread();
 
-            ioThread = LoomSupport.unstarted(
+            LoomSupport.unstarted(
                 "loom-on-netty-" + id + "-io",
-                b -> {
-                    if (LoomBranchSupport.isSupported()) {
-                        LoomBranchSupport.setScheduler(b, new IoScheduler(this));
-                    } else {
-                        PrivateLoomSupport.setScheduler(b, new IoScheduler(this));
-                    }
-                },
+                b -> PrivateLoomSupport.setScheduler(b, this::executeIo),
                 () -> FastThreadLocalThread.runWithFastThreadLocal(this::runIo)
-            );
-            ioThread.start();
+            ).start();
             assert ioContinuationScheduled;
 
             while (!delegate.isTerminated()) {
@@ -402,19 +380,6 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
             return ranAny;
         }
 
-        private void executeIo(Thread thread, Runnable command) {
-            if (thread == ioThread) {
-                Thread t = Thread.currentThread();
-                ioContinuation = command;
-                ioContinuationScheduled = true;
-                if (t != carrier && !isOnRunner(t)) {
-                    LockSupport.unpark(carrier);
-                }
-            } else {
-                LoomBranchSupport.runOnDefaultScheduler(command);
-            }
-        }
-
         private void executeIo(Runnable command) {
             // special handling for the continuation of the IO thread.
             Runnable ioContinuation = this.ioContinuation;
@@ -435,18 +400,9 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         }
 
         @Override
-        public void execute(Runnable task) {
-            execute(null, task);
-        }
-
-        @Override
-        public void execute(Thread thread, Runnable command) {
+        public void execute(Runnable command) {
             if (delegate.isShuttingDown()) {
-                if (LoomBranchSupport.isSupported()) {
-                    LoomBranchSupport.runOnDefaultScheduler(command);
-                } else {
-                    PrivateLoomSupport.getDefaultScheduler().execute(command);
-                }
+                PrivateLoomSupport.getDefaultScheduler().execute(command);
                 return;
             }
 
@@ -456,7 +412,6 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
                 scheduled = new ContinuationScheduled();
                 long hash = System.identityHashCode(command);
                 scheduled.hashCode = hash;
-                scheduled.virtualThreadName = thread == null ? null : thread.getName();
 
                 Runnable r = command;
                 command = () -> {
@@ -467,7 +422,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
 
                     started.end();
                     started.hashCode = hash;
-                    started.virtualThreadName = thread == null ? null : thread.getName();
+                    //started.taskQueueDepth = delegate.taskQueue.size();
                     started.commit();
                 };
             } else {
@@ -523,29 +478,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         }
     }
 
-    record IoScheduler(Runner runner) implements Executor, EventLoopVirtualThreadScheduler, LoomBranchSupport.VirtualThreadSchedulerProxy {
-        @Override
-        public @NonNull AttributeMap attributeMap() {
-            return runner.attributeMap();
-        }
-
-        @Override
-        public @NonNull EventExecutor eventLoop() {
-            return runner.eventLoop();
-        }
-
-        @Override
-        public void execute(Thread thread, Runnable task) {
-            runner.executeIo(thread, task);
-        }
-
-        @Override
-        public void execute(Runnable command) {
-            runner.executeIo(command);
-        }
-    }
-
-    record StickyScheduler(Runner io) implements Executor, EventLoopVirtualThreadScheduler, LoomBranchSupport.VirtualThreadSchedulerProxy {
+    record StickyScheduler(Runner io) implements Executor, EventLoopVirtualThreadScheduler {
         @Override
         public void execute(Runnable command) {
             Thread currentThread = Thread.currentThread();
@@ -561,26 +494,6 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
             dst.execute(command);
         }
 
-        @Override
-        public void execute(Thread thread, Runnable task) {
-            LoomBranchSupport.VirtualThreadSchedulerProxy dst;
-            if (LoomSupport.isVirtual(Thread.currentThread())) {
-                dst = LoomBranchSupport.currentScheduler();
-                if (dst instanceof EventLoopVirtualThreadScheduler) {
-                    if (dst instanceof IoScheduler s) {
-                        dst = s.runner;
-                    } else if (dst instanceof StickyScheduler s) {
-                        dst = s.io;
-                    }
-                } else {
-                    dst = (t, r) -> LoomBranchSupport.runOnDefaultScheduler(r);
-                }
-            } else {
-                dst = io;
-            }
-            dst.execute(thread, task);
-        }
-
         @Override
         public @NonNull AttributeMap attributeMap() {
             return io.attributeMap();
@@ -604,7 +517,6 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         static final ContinuationScheduled INSTANCE = new ContinuationScheduled();
 
         long hashCode;
-        String virtualThreadName;
         int scheduleMode;
         int queueDepth;
     }
@@ -613,7 +525,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
     @Enabled(false)
     static class ContinuationStarted extends Event {
         long hashCode;
-        String virtualThreadName;
+        int taskQueueDepth;
     }
 
     @StackTrace(false)
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/PrivateLoomSupport.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/PrivateLoomSupport.java
index d1c54301b6..c3467051ce 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/PrivateLoomSupport.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/PrivateLoomSupport.java
@@ -47,13 +47,14 @@ public final class PrivateLoomSupport {
     private static final Throwable FAILURE;
 
     static {
-        MethodHandles.Lookup lookup = MethodHandles.lookup();
-
         MethodHandle defaultScheduler;
         MethodHandle builderScheduler;
         MethodHandle threadScheduler;
+        MethodHandle carrierThread;
         Throwable failure;
         try {
+            MethodHandles.Lookup lookup = MethodHandles.lookup();
+
             Field defaultSchedulerField = Class.forName("java.lang.VirtualThread")
                 .getDeclaredField("DEFAULT_SCHEDULER");
             defaultSchedulerField.setAccessible(true);
@@ -71,30 +72,25 @@ public final class PrivateLoomSupport {
             threadScheduler = lookup.unreflectGetter(threadSchedulerField)
                     .asType(MethodType.methodType(Executor.class, Thread.class));
 
+            Field carrierThreadField = Class.forName("java.lang.VirtualThread")
+                .getDeclaredField("carrierThread");
+            carrierThreadField.setAccessible(true);
+            carrierThread = lookup.unreflectGetter(carrierThreadField)
+                    .asType(MethodType.methodType(Thread.class, Thread.class));
+
             failure = null;
         } catch (ReflectiveOperationException | InaccessibleObjectException roe) {
             defaultScheduler = null;
             builderScheduler = null;
             threadScheduler = null;
+            carrierThread = null;
             failure = roe;
         }
         DEFAULT_SCHEDULER = defaultScheduler;
         BUILDER_SCHEDULER = builderScheduler;
         THREAD_SCHEDULER = threadScheduler;
-        FAILURE = failure;
-
-        // carrierThread is also used for some LoomBranchSupport debugging, so let's initialize it separately
-        MethodHandle carrierThread;
-        try {
-            Field carrierThreadField = Class.forName("java.lang.VirtualThread")
-                .getDeclaredField("carrierThread");
-            carrierThreadField.setAccessible(true);
-            carrierThread = lookup.unreflectGetter(carrierThreadField)
-                .asType(MethodType.methodType(Thread.class, Thread.class));
-        } catch (Exception e) {
-            carrierThread = null;
-        }
         CARRIER_THREAD = carrierThread;
+        FAILURE = failure;
     }
 
     @NonNull
@@ -134,13 +130,13 @@ public final class PrivateLoomSupport {
     }
 
     public static boolean isSupported() {
-        return THREAD_SCHEDULER != null;
+        return CARRIER_THREAD != null;
     }
 
     static final class PrivateLoomCondition implements Condition {
         @Override
         public boolean matches(ConditionContext context) {
-            if (!isSupported() && !LoomBranchSupport.isSupported()) {
+            if (BUILDER_SCHEDULER == null) {
                 context.fail("Failed to access loom internals. Please make sure to add the `--add-opens=java.base/java.lang=ALL-UNNAMED` JVM argument. (" + FAILURE + ")");
                 return false;
             } else {
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/LoomCarrierSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/LoomCarrierSpec.groovy
index 04f0596d54..781e66a4de 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/LoomCarrierSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/LoomCarrierSpec.groovy
@@ -7,8 +7,6 @@ import io.micronaut.http.annotation.Controller
 import io.micronaut.http.annotation.Get
 import io.micronaut.http.client.HttpClient
 import io.micronaut.http.client.annotation.Client
-import io.micronaut.http.netty.channel.loom.EventLoopVirtualThreadScheduler
-import io.micronaut.http.netty.channel.loom.LoomBranchSupport
 import io.micronaut.http.netty.channel.loom.PrivateLoomSupport
 import io.micronaut.json.JsonMapper
 import io.micronaut.runtime.server.EmbeddedServer
@@ -118,18 +116,12 @@ class LoomCarrierSpec extends Specification {
         @ExecuteOn(TaskExecutors.BLOCKING)
         @Get("/loop-jdk")
         String loopJdk() {
-            def scheduler = EventLoopVirtualThreadScheduler.current()
+            def scheduler = PrivateLoomSupport.getScheduler(Thread.currentThread())
             try (java.net.http.HttpClient c = java.net.http.HttpClient.newBuilder()
                     .executor(new ThreadPerTaskExecutor(new ThreadFactory() {
                         @Override
                         Thread newThread(@NonNull Runnable r) {
-                            return LoomSupport.unstarted("jdkclient", (b) -> {
-                                if (LoomBranchSupport.isSupported()) {
-                                    LoomBranchSupport.setScheduler(b, scheduler)
-                                } else {
-                                    PrivateLoomSupport.setScheduler(b, scheduler)
-                                }
-                            }, r)
+                            return LoomSupport.unstarted("jdkclient", (b) -> PrivateLoomSupport.setScheduler(b, scheduler), r)
                         }
                     }))
                     .build()) {
