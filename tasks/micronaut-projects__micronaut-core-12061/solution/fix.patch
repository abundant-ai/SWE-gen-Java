diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/Pool49.java b/http-client/src/main/java/io/micronaut/http/client/netty/Pool49.java
index 9c3f3079c4..d8a946198e 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/Pool49.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/Pool49.java
@@ -23,8 +23,6 @@ import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.client.exceptions.HttpClientException;
 import io.micronaut.http.netty.channel.loom.EventLoopVirtualThreadScheduler;
-import io.micronaut.http.netty.channel.loom.PrivateLoomSupport;
-import io.micronaut.scheduling.LoomSupport;
 import io.netty.channel.EventLoop;
 import io.netty.channel.SingleThreadIoEventLoop;
 import io.netty.util.concurrent.EventExecutor;
@@ -189,10 +187,9 @@ final class Pool49 implements Pool {
 
             EventExecutor currentExecutor = null;
 
-            if (PrivateLoomSupport.isSupported() &&
-                LoomSupport.isVirtual(Thread.currentThread()) &&
-                PrivateLoomSupport.getScheduler(Thread.currentThread()) instanceof EventLoopVirtualThreadScheduler el) {
-                currentExecutor = el.eventLoop();
+            EventLoopVirtualThreadScheduler elvts = EventLoopVirtualThreadScheduler.current();
+            if (elvts != null) {
+                currentExecutor = elvts.eventLoop();
             }
 
             if (currentExecutor == null) {
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/EventLoopVirtualThreadScheduler.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/EventLoopVirtualThreadScheduler.java
index 3dd2d3250b..e0cd72d09a 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/EventLoopVirtualThreadScheduler.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/EventLoopVirtualThreadScheduler.java
@@ -17,11 +17,11 @@ package io.micronaut.http.netty.channel.loom;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
+import io.micronaut.scheduling.LoomSupport;
 import io.netty.util.AttributeMap;
 import io.netty.util.concurrent.EventExecutor;
 
-import java.util.concurrent.Executor;
-
 /**
  * Scheduler for a virtual thread, with metadata. Does not change throughout a virtual thread's
  * lifetime. This class allows for creating local shared resources, e.g. HTTP connections that
@@ -31,8 +31,8 @@ import java.util.concurrent.Executor;
  * @author Jonas Konrad
  */
 @Internal
-public sealed interface EventLoopVirtualThreadScheduler extends Executor
-    permits LoomCarrierGroup.Runner, LoomCarrierGroup.StickyScheduler {
+public sealed interface EventLoopVirtualThreadScheduler
+    permits LoomCarrierGroup.IoScheduler, LoomCarrierGroup.Runner, LoomCarrierGroup.StickyScheduler {
 
     /**
      * Get a shared {@link AttributeMap} for this scheduler.
@@ -49,4 +49,35 @@ public sealed interface EventLoopVirtualThreadScheduler extends Executor
      */
     @NonNull
     EventExecutor eventLoop();
+
+    /**
+     * Get the virtual thread scheduler of the current thread, if available.
+     *
+     * @return The current scheduler or {@code null}
+     */
+    @Nullable
+    static EventLoopVirtualThreadScheduler current() {
+        if (LoomBranchSupport.isSupported()) {
+            if (!LoomSupport.isVirtual(Thread.currentThread())) {
+                return null;
+            }
+            if (LoomBranchSupport.currentScheduler() instanceof EventLoopVirtualThreadScheduler elvts) {
+                return elvts;
+            } else {
+                return null;
+            }
+        } else if (PrivateLoomSupport.isSupported()) {
+            Thread thread = Thread.currentThread();
+            if (!LoomSupport.isVirtual(thread)) {
+                return null;
+            }
+            if (PrivateLoomSupport.getScheduler(thread) instanceof EventLoopVirtualThreadScheduler elvts) {
+                return elvts;
+            } else {
+                return null;
+            }
+        } else {
+            return null;
+        }
+    }
 }
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomBranchSupport.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomBranchSupport.java
new file mode 100644
index 0000000000..da9f48c23a
--- /dev/null
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomBranchSupport.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2017-2025 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.netty.channel.loom;
+
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.util.SupplierUtil;
+import io.micronaut.scheduling.LoomSupport;
+
+import java.lang.invoke.LambdaMetafactory;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.util.concurrent.FutureTask;
+import java.util.function.Supplier;
+
+/**
+ * Support for the <a href="https://github.com/openjdk/loom/">OpenJDK loom branch</a>.
+ *
+ * @since 4.10.0
+ * @author Jonas Konrad
+ */
+@Internal
+@Experimental
+public final class LoomBranchSupport {
+    private static final Supplier<VirtualThreadSchedulerProxy> DEFAULT_SCHEDULER;
+    private static final Thread DEFAULT_SCHEDULER_THREAD;
+    private static final MethodHandle TO_JDK_SCHEDULER;
+    private static final MethodHandle TO_OUR_SCHEDULER;
+    private static final MethodHandle CURRENT_SCHEDULER;
+    private static final MethodHandle JDK_EXECUTE;
+    private static final MethodHandle SET_SCHEDULER;
+    private static final Class<?> PROXY_LAMBDA_CLASS;
+
+    static {
+        MethodHandle toJdkScheduler;
+        MethodHandle toOurScheduler;
+        MethodHandle currentScheduler;
+        MethodHandle jdkExecute;
+        MethodHandle setScheduler;
+        try {
+            MethodType executeMethodType = MethodType.methodType(void.class, Thread.class, Runnable.class);
+            Class<?> jdkVirtualThreadScheduler = Class.forName("java.lang.Thread$VirtualThreadScheduler");
+
+            currentScheduler = MethodHandles.lookup().findStatic(jdkVirtualThreadScheduler, "current", MethodType.methodType(jdkVirtualThreadScheduler))
+                .asType(MethodType.methodType(Object.class));
+
+            jdkExecute = MethodHandles.lookup().findVirtual(jdkVirtualThreadScheduler, "execute", executeMethodType);
+            MethodHandle ourExecute = MethodHandles.lookup().findStatic(LoomBranchSupport.class, "executeOrUnwrap", MethodType.methodType(void.class, VirtualThreadSchedulerProxy.class, Thread.class, Runnable.class));
+            toJdkScheduler = LambdaMetafactory.metafactory(
+                MethodHandles.lookup(),
+                "execute",
+                MethodType.methodType(jdkVirtualThreadScheduler, VirtualThreadSchedulerProxy.class),
+                executeMethodType,
+                ourExecute,
+                executeMethodType
+            ).dynamicInvoker()
+                .asType(MethodType.methodType(Object.class, VirtualThreadSchedulerProxy.class));
+            toOurScheduler = LambdaMetafactory.metafactory(
+                MethodHandles.lookup(),
+                "execute",
+                MethodType.methodType(VirtualThreadSchedulerProxy.class, jdkVirtualThreadScheduler),
+                executeMethodType,
+                jdkExecute,
+                executeMethodType
+            ).dynamicInvoker()
+                .asType(MethodType.methodType(VirtualThreadSchedulerProxy.class, Object.class));
+            Class<?> ofVirtual = Class.forName("java.lang.Thread$Builder$OfVirtual");
+            setScheduler = MethodHandles.lookup().findVirtual(ofVirtual, "scheduler", MethodType.methodType(ofVirtual, jdkVirtualThreadScheduler))
+                .asType(MethodType.methodType(void.class, Object.class, Object.class));
+        } catch (Exception e) {
+            jdkExecute = null;
+            toJdkScheduler = null;
+            toOurScheduler = null;
+            currentScheduler = null;
+            setScheduler = null;
+        }
+
+        TO_JDK_SCHEDULER = toJdkScheduler;
+        TO_OUR_SCHEDULER = toOurScheduler;
+        CURRENT_SCHEDULER = currentScheduler;
+        JDK_EXECUTE = jdkExecute == null ? null : jdkExecute.asType(MethodType.methodType(void.class, Object.class, Thread.class, Runnable.class));
+        SET_SCHEDULER = setScheduler;
+        PROXY_LAMBDA_CLASS = TO_JDK_SCHEDULER != null ? toJdkScheduler((thread, runnable) -> {
+        }).getClass() : null;
+
+        if (isSupported()) {
+            FutureTask<Object> task = new FutureTask<>(LoomBranchSupport::currentPrivate);
+            DEFAULT_SCHEDULER_THREAD = LoomSupport.newVirtualThreadFactory("default-scheduler-exposer").newThread(task);
+            DEFAULT_SCHEDULER_THREAD.start();
+            DEFAULT_SCHEDULER = SupplierUtil.memoized(() -> {
+                try {
+                    return toOurScheduler(task.get());
+                } catch (Exception e) {
+                    throw new RuntimeException(e);
+                }
+            });
+        } else {
+            DEFAULT_SCHEDULER_THREAD = null;
+            DEFAULT_SCHEDULER = null;
+        }
+    }
+
+    public static boolean isSupported() {
+        return TO_OUR_SCHEDULER != null;
+    }
+
+    static void runOnDefaultScheduler(Runnable r) {
+        DEFAULT_SCHEDULER.get().execute(DEFAULT_SCHEDULER_THREAD, r);
+    }
+
+    static VirtualThreadSchedulerProxy currentScheduler() {
+        return toOurScheduler(currentPrivate());
+    }
+
+    private static Object currentPrivate() {
+        try {
+            return CURRENT_SCHEDULER.invokeExact();
+        } catch (Throwable e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Transform the given VirtualThreadSchedulerProxy to a JDK VirtualThreadScheduler. The
+     * delegate is implemented using LambdaMetafactory.
+     *
+     * @param proxy The scheduler implementation
+     * @return The JDK delegate
+     */
+    static Object toJdkScheduler(VirtualThreadSchedulerProxy proxy) {
+        try {
+            return TO_JDK_SCHEDULER.invokeExact(proxy);
+        } catch (Throwable e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Transform the given JDK VirtualThreadScheduler to a {@link VirtualThreadSchedulerProxy}. If
+     * the given scheduler was the result of {@link #toJdkScheduler}, the original proxy is
+     * returned. Otherwise, a wrapper is created.
+     *
+     * @param scheduler The JDK scheduler
+     * @return The scheduler proxy
+     */
+    static VirtualThreadSchedulerProxy toOurScheduler(Object scheduler) {
+        if (scheduler.getClass() == PROXY_LAMBDA_CLASS) {
+            UnwrapClass unwrapClass = new UnwrapClass();
+            try {
+                JDK_EXECUTE.invokeExact(scheduler, (Thread) null, (Runnable) unwrapClass);
+            } catch (Throwable e) {
+                throw new RuntimeException(e);
+            }
+            return unwrapClass.proxy;
+        } else {
+            try {
+                return (VirtualThreadSchedulerProxy) TO_OUR_SCHEDULER.invokeExact(scheduler);
+            } catch (Throwable e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    public static void setScheduler(Object builder, VirtualThreadSchedulerProxy scheduler) {
+        try {
+            SET_SCHEDULER.invokeExact(builder, toJdkScheduler(scheduler));
+        } catch (Throwable e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static void executeOrUnwrap(VirtualThreadSchedulerProxy target, Thread thread, Runnable task) {
+        if (task instanceof UnwrapClass uc) {
+            uc.proxy = target;
+            return;
+        }
+        target.execute(thread, task);
+    }
+
+    private static final class UnwrapClass implements Runnable {
+        VirtualThreadSchedulerProxy proxy;
+
+        @Override
+        public void run() {
+            throw new UnsupportedOperationException();
+        }
+    }
+
+    interface VirtualThreadSchedulerProxy {
+        void execute(Thread thread, Runnable task);
+    }
+}
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomCarrierGroup.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomCarrierGroup.java
index fcc88a9b0d..fa960bb78f 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomCarrierGroup.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/LoomCarrierGroup.java
@@ -94,7 +94,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         }
     }
 
-    final class Runner implements Runnable, EventLoopVirtualThreadScheduler, ThreadFactory {
+    final class Runner implements Runnable, EventLoopVirtualThreadScheduler, ThreadFactory, Executor, LoomBranchSupport.VirtualThreadSchedulerProxy {
         final int id;
         final Factory factory;
         final ManualIoEventLoop delegate;
@@ -106,6 +106,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
          * The continuation of the virtual thread responsible for running the event loop.
          */
         Runnable ioContinuation;
+        Thread ioThread;
         /**
          * {@code true} when the {@link #ioContinuation} has been scheduled but has not run yet.
          */
@@ -210,7 +211,15 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         }
 
         private boolean isOnRunner(Thread thread) {
-            return LoomSupport.isVirtual(thread) && PrivateLoomSupport.getScheduler(thread) == Runner.this;
+            if (!LoomSupport.isVirtual(thread)) {
+                return false;
+            }
+            if (LoomBranchSupport.isSupported()) {
+                assert thread == Thread.currentThread();
+                return LoomBranchSupport.currentScheduler() == this;
+            } else {
+                return PrivateLoomSupport.getScheduler(thread) == Runner.this;
+            }
         }
 
         /**
@@ -227,7 +236,9 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
             return LoomSupport.unstarted("loom-on-netty-" + id + "-" + Long.toHexString(ThreadLocalRandom.current().nextLong()), b -> {
                 if (warmupTasks > 0) {
                     warmupTasks--;
-                    PrivateLoomSupport.setScheduler(b, PrivateLoomSupport.getDefaultScheduler());
+                    if (!LoomBranchSupport.isSupported()) {
+                        PrivateLoomSupport.setScheduler(b, PrivateLoomSupport.getDefaultScheduler());
+                    }
                     return;
                 }
 
@@ -243,7 +254,11 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
                         }
                     }
                 }
-                PrivateLoomSupport.setScheduler(b, new StickyScheduler(dst));
+                if (LoomBranchSupport.isSupported()) {
+                    LoomBranchSupport.setScheduler(b, new StickyScheduler(dst));
+                } else {
+                    PrivateLoomSupport.setScheduler(b, new StickyScheduler(dst));
+                }
             }, r);
         }
 
@@ -251,11 +266,18 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         public void run() {
             carrier = Thread.currentThread();
 
-            LoomSupport.unstarted(
+            ioThread = LoomSupport.unstarted(
                 "loom-on-netty-" + id + "-io",
-                b -> PrivateLoomSupport.setScheduler(b, this::executeIo),
+                b -> {
+                    if (LoomBranchSupport.isSupported()) {
+                        LoomBranchSupport.setScheduler(b, new IoScheduler(this));
+                    } else {
+                        PrivateLoomSupport.setScheduler(b, new IoScheduler(this));
+                    }
+                },
                 () -> FastThreadLocalThread.runWithFastThreadLocal(this::runIo)
-            ).start();
+            );
+            ioThread.start();
             assert ioContinuationScheduled;
 
             while (!delegate.isTerminated()) {
@@ -380,6 +402,19 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
             return ranAny;
         }
 
+        private void executeIo(Thread thread, Runnable command) {
+            if (thread == ioThread) {
+                Thread t = Thread.currentThread();
+                ioContinuation = command;
+                ioContinuationScheduled = true;
+                if (t != carrier && !isOnRunner(t)) {
+                    LockSupport.unpark(carrier);
+                }
+            } else {
+                LoomBranchSupport.runOnDefaultScheduler(command);
+            }
+        }
+
         private void executeIo(Runnable command) {
             // special handling for the continuation of the IO thread.
             Runnable ioContinuation = this.ioContinuation;
@@ -400,9 +435,18 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         }
 
         @Override
-        public void execute(Runnable command) {
+        public void execute(Runnable task) {
+            execute(null, task);
+        }
+
+        @Override
+        public void execute(Thread thread, Runnable command) {
             if (delegate.isShuttingDown()) {
-                PrivateLoomSupport.getDefaultScheduler().execute(command);
+                if (LoomBranchSupport.isSupported()) {
+                    LoomBranchSupport.runOnDefaultScheduler(command);
+                } else {
+                    PrivateLoomSupport.getDefaultScheduler().execute(command);
+                }
                 return;
             }
 
@@ -412,6 +456,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
                 scheduled = new ContinuationScheduled();
                 long hash = System.identityHashCode(command);
                 scheduled.hashCode = hash;
+                scheduled.virtualThreadName = thread == null ? null : thread.getName();
 
                 Runnable r = command;
                 command = () -> {
@@ -422,7 +467,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
 
                     started.end();
                     started.hashCode = hash;
-                    //started.taskQueueDepth = delegate.taskQueue.size();
+                    started.virtualThreadName = thread == null ? null : thread.getName();
                     started.commit();
                 };
             } else {
@@ -478,7 +523,29 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         }
     }
 
-    record StickyScheduler(Runner io) implements Executor, EventLoopVirtualThreadScheduler {
+    record IoScheduler(Runner runner) implements Executor, EventLoopVirtualThreadScheduler, LoomBranchSupport.VirtualThreadSchedulerProxy {
+        @Override
+        public @NonNull AttributeMap attributeMap() {
+            return runner.attributeMap();
+        }
+
+        @Override
+        public @NonNull EventExecutor eventLoop() {
+            return runner.eventLoop();
+        }
+
+        @Override
+        public void execute(Thread thread, Runnable task) {
+            runner.executeIo(thread, task);
+        }
+
+        @Override
+        public void execute(Runnable command) {
+            runner.executeIo(command);
+        }
+    }
+
+    record StickyScheduler(Runner io) implements Executor, EventLoopVirtualThreadScheduler, LoomBranchSupport.VirtualThreadSchedulerProxy {
         @Override
         public void execute(Runnable command) {
             Thread currentThread = Thread.currentThread();
@@ -494,6 +561,26 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
             dst.execute(command);
         }
 
+        @Override
+        public void execute(Thread thread, Runnable task) {
+            LoomBranchSupport.VirtualThreadSchedulerProxy dst;
+            if (LoomSupport.isVirtual(Thread.currentThread())) {
+                dst = LoomBranchSupport.currentScheduler();
+                if (dst instanceof EventLoopVirtualThreadScheduler) {
+                    if (dst instanceof IoScheduler s) {
+                        dst = s.runner;
+                    } else if (dst instanceof StickyScheduler s) {
+                        dst = s.io;
+                    }
+                } else {
+                    dst = (t, r) -> LoomBranchSupport.runOnDefaultScheduler(r);
+                }
+            } else {
+                dst = io;
+            }
+            dst.execute(thread, task);
+        }
+
         @Override
         public @NonNull AttributeMap attributeMap() {
             return io.attributeMap();
@@ -517,6 +604,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
         static final ContinuationScheduled INSTANCE = new ContinuationScheduled();
 
         long hashCode;
+        String virtualThreadName;
         int scheduleMode;
         int queueDepth;
     }
@@ -525,7 +613,7 @@ public final class LoomCarrierGroup extends MultiThreadIoEventLoopGroup {
     @Enabled(false)
     static class ContinuationStarted extends Event {
         long hashCode;
-        int taskQueueDepth;
+        String virtualThreadName;
     }
 
     @StackTrace(false)
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/PrivateLoomSupport.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/PrivateLoomSupport.java
index c3467051ce..d1c54301b6 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/PrivateLoomSupport.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/loom/PrivateLoomSupport.java
@@ -47,14 +47,13 @@ public final class PrivateLoomSupport {
     private static final Throwable FAILURE;
 
     static {
+        MethodHandles.Lookup lookup = MethodHandles.lookup();
+
         MethodHandle defaultScheduler;
         MethodHandle builderScheduler;
         MethodHandle threadScheduler;
-        MethodHandle carrierThread;
         Throwable failure;
         try {
-            MethodHandles.Lookup lookup = MethodHandles.lookup();
-
             Field defaultSchedulerField = Class.forName("java.lang.VirtualThread")
                 .getDeclaredField("DEFAULT_SCHEDULER");
             defaultSchedulerField.setAccessible(true);
@@ -72,25 +71,30 @@ public final class PrivateLoomSupport {
             threadScheduler = lookup.unreflectGetter(threadSchedulerField)
                     .asType(MethodType.methodType(Executor.class, Thread.class));
 
-            Field carrierThreadField = Class.forName("java.lang.VirtualThread")
-                .getDeclaredField("carrierThread");
-            carrierThreadField.setAccessible(true);
-            carrierThread = lookup.unreflectGetter(carrierThreadField)
-                    .asType(MethodType.methodType(Thread.class, Thread.class));
-
             failure = null;
         } catch (ReflectiveOperationException | InaccessibleObjectException roe) {
             defaultScheduler = null;
             builderScheduler = null;
             threadScheduler = null;
-            carrierThread = null;
             failure = roe;
         }
         DEFAULT_SCHEDULER = defaultScheduler;
         BUILDER_SCHEDULER = builderScheduler;
         THREAD_SCHEDULER = threadScheduler;
-        CARRIER_THREAD = carrierThread;
         FAILURE = failure;
+
+        // carrierThread is also used for some LoomBranchSupport debugging, so let's initialize it separately
+        MethodHandle carrierThread;
+        try {
+            Field carrierThreadField = Class.forName("java.lang.VirtualThread")
+                .getDeclaredField("carrierThread");
+            carrierThreadField.setAccessible(true);
+            carrierThread = lookup.unreflectGetter(carrierThreadField)
+                .asType(MethodType.methodType(Thread.class, Thread.class));
+        } catch (Exception e) {
+            carrierThread = null;
+        }
+        CARRIER_THREAD = carrierThread;
     }
 
     @NonNull
@@ -130,13 +134,13 @@ public final class PrivateLoomSupport {
     }
 
     public static boolean isSupported() {
-        return CARRIER_THREAD != null;
+        return THREAD_SCHEDULER != null;
     }
 
     static final class PrivateLoomCondition implements Condition {
         @Override
         public boolean matches(ConditionContext context) {
-            if (BUILDER_SCHEDULER == null) {
+            if (!isSupported() && !LoomBranchSupport.isSupported()) {
                 context.fail("Failed to access loom internals. Please make sure to add the `--add-opens=java.base/java.lang=ALL-UNNAMED` JVM argument. (" + FAILURE + ")");
                 return false;
             } else {
