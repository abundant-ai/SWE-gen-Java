diff --git a/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java b/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java
index ddb9a8dcb..c55c82b99 100644
--- a/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java
+++ b/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java
@@ -4,30 +4,26 @@
  */
 package org.mockito.internal.stubbing;
 
-import static org.mockito.internal.exceptions.Reporter.notAnException;
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
-import static org.objenesis.ObjenesisHelper.newInstance;
-
 import org.mockito.internal.stubbing.answers.CallsRealMethods;
 import org.mockito.internal.stubbing.answers.Returns;
 import org.mockito.internal.stubbing.answers.ThrowsException;
+import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;
 import org.mockito.stubbing.OngoingStubbing;
 
 public abstract class BaseStubbing<T> implements OngoingStubbing<T> {
 
-    @Override
     public OngoingStubbing<T> thenReturn(T value) {
         return thenAnswer(new Returns(value));
     }
 
-    @Override
+    @SuppressWarnings({"unchecked","vararg"})
     public OngoingStubbing<T> thenReturn(T value, T... values) {
         OngoingStubbing<T> stubbing = thenReturn(value);
         if (values == null) {
-            // TODO below does not seem right
+            //TODO below does not seem right
             return stubbing.thenReturn(null);
         }
-        for (T v : values) {
+        for (T v: values) {
             stubbing = stubbing.thenReturn(v);
         }
         return stubbing;
@@ -37,13 +33,12 @@ public abstract class BaseStubbing<T> implements OngoingStubbing<T> {
         return thenAnswer(new ThrowsException(throwable));
     }
 
-    @Override
     public OngoingStubbing<T> thenThrow(Throwable... throwables) {
         if (throwables == null) {
             return thenThrow((Throwable) null);
         }
         OngoingStubbing<T> stubbing = null;
-        for (Throwable t : throwables) {
+        for (Throwable t: throwables) {
             if (stubbing == null) {
                 stubbing = thenThrow(t);
             } else {
@@ -53,31 +48,23 @@ public abstract class BaseStubbing<T> implements OngoingStubbing<T> {
         return stubbing;
     }
 
-    @Override
     public OngoingStubbing<T> thenThrow(Class<? extends Throwable> throwableType) {
-        if (throwableType == null) {
-            mockingProgress().reset();
-            throw notAnException();
-        }
-        return thenThrow(newInstance(throwableType));
+        return thenAnswer(new ThrowsExceptionClass(throwableType));
     }
 
-    @Override
+    @SuppressWarnings ({"unchecked", "varargs"})
     public OngoingStubbing<T> thenThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown) {
         if (nextToBeThrown == null) {
-            thenThrow((Class<Throwable>) null);
+            thenThrow((Throwable) null);
         }
         OngoingStubbing<T> stubbing = thenThrow(toBeThrown);
-        for (Class<? extends Throwable> t : nextToBeThrown) {
+        for (Class<? extends Throwable> t: nextToBeThrown) {
             stubbing = stubbing.thenThrow(t);
         }
         return stubbing;
     }
 
-    @Override
     public OngoingStubbing<T> thenCallRealMethod() {
         return thenAnswer(new CallsRealMethods());
     }
 }
-
-
diff --git a/src/main/java/org/mockito/internal/stubbing/OngoingStubbingImpl.java b/src/main/java/org/mockito/internal/stubbing/OngoingStubbingImpl.java
index 78a10270a..fd47434a7 100644
--- a/src/main/java/org/mockito/internal/stubbing/OngoingStubbingImpl.java
+++ b/src/main/java/org/mockito/internal/stubbing/OngoingStubbingImpl.java
@@ -20,7 +20,6 @@ public class OngoingStubbingImpl<T> extends BaseStubbing<T> {
         this.invocationContainer = invocationContainer;
     }
 
-    @Override
     public OngoingStubbing<T> thenAnswer(Answer<?> answer) {
         if(!invocationContainer.hasInvocationForPotentialStubbing()) {
             throw incorrectUseOfApi();
@@ -30,7 +29,6 @@ public class OngoingStubbingImpl<T> extends BaseStubbing<T> {
         return new ConsecutiveStubbing<T>(invocationContainer);
     }
 
-    @Override
     public OngoingStubbing<T> then(Answer<?> answer) {
         return thenAnswer(answer);
     }
@@ -40,11 +38,8 @@ public class OngoingStubbingImpl<T> extends BaseStubbing<T> {
         return invocationContainer.getInvocations();
     }
 
-    @Override
     @SuppressWarnings("unchecked")
     public <M> M getMock() {
         return (M) invocationContainer.invokedMock();
     }
 }
-
-
diff --git a/src/main/java/org/mockito/internal/stubbing/StubberImpl.java b/src/main/java/org/mockito/internal/stubbing/StubberImpl.java
index efe74880c..89255ab79 100644
--- a/src/main/java/org/mockito/internal/stubbing/StubberImpl.java
+++ b/src/main/java/org/mockito/internal/stubbing/StubberImpl.java
@@ -5,12 +5,8 @@
 package org.mockito.internal.stubbing;
 
 import static org.mockito.internal.exceptions.Reporter.notAMockPassedToWhenMethod;
-import static org.mockito.internal.exceptions.Reporter.notAnException;
 import static org.mockito.internal.exceptions.Reporter.nullPassedToWhenMethod;
-import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
 import static org.mockito.internal.stubbing.answers.DoesNothing.doesNothing;
-import static org.mockito.internal.util.MockUtil.isMock;
-import static org.objenesis.ObjenesisHelper.newInstance;
 
 import java.util.LinkedList;
 import java.util.List;
@@ -18,10 +14,12 @@ import java.util.List;
 import org.mockito.internal.stubbing.answers.CallsRealMethods;
 import org.mockito.internal.stubbing.answers.Returns;
 import org.mockito.internal.stubbing.answers.ThrowsException;
+import org.mockito.internal.stubbing.answers.ThrowsExceptionClass;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.Stubber;
 
+@SuppressWarnings("unchecked")
 public class StubberImpl implements Stubber {
 
     private final List<Answer<?>> answers = new LinkedList<Answer<?>>();
@@ -32,13 +30,11 @@ public class StubberImpl implements Stubber {
             throw nullPassedToWhenMethod();
         }
 
-        if (!isMock(mock)) {
-            throw notAMockPassedToWhenMethod();
-        }
-
-
-		    MockUtil.getInvocationContainer(mock).setAnswersForStubbing(answers);
+		if (!MockUtil.isMock(mock)) {
+			throw notAMockPassedToWhenMethod();
+		}
 
+		MockUtil.getInvocationContainer(mock).setAnswersForStubbing(answers);
         return mock;
     }
 
@@ -53,7 +49,7 @@ public class StubberImpl implements Stubber {
     }
 
     private StubberImpl doReturnValues(Object... toBeReturned) {
-        if (toBeReturned == null) {
+        if(toBeReturned == null) {
             answers.add(new Returns(null));
             return this;
         }
@@ -65,7 +61,7 @@ public class StubberImpl implements Stubber {
 
     @Override
     public Stubber doThrow(Throwable... toBeThrown) {
-        if (toBeThrown == null) {
+        if(toBeThrown == null) {
             answers.add(new ThrowsException(null));
             return this;
         }
@@ -77,34 +73,19 @@ public class StubberImpl implements Stubber {
 
     @Override
     public Stubber doThrow(Class<? extends Throwable> toBeThrown) {
-        if (toBeThrown == null) {
-            mockingProgress().reset();
-            throw notAnException();
-        }
-        Throwable e;
-        try {
-            e = newInstance(toBeThrown);
-        } catch (RuntimeException instanciationError) {
-            mockingProgress().reset();
-            throw instanciationError;
-        }
-        return doThrow(e);
+        return doThrowClasses(toBeThrown);
     }
 
     @Override
     public Stubber doThrow(Class<? extends Throwable> toBeThrown, Class<? extends Throwable>... nextToBeThrown) {
-        Stubber stubber = doThrow(toBeThrown);
-
-        if (nextToBeThrown == null) {
-            mockingProgress().reset();
-            throw notAnException();
-        }
+        return doThrowClasses(toBeThrown).doThrowClasses(nextToBeThrown);
+    }
 
-        for (Class<? extends Throwable> next : nextToBeThrown) {
-            stubber = stubber.doThrow(next);
+    private StubberImpl doThrowClasses(Class<? extends Throwable>... toBeThrown) {
+        for (Class<? extends Throwable> throwable: toBeThrown) {
+            answers.add(new ThrowsExceptionClass(throwable));
         }
-        return stubber;
-
+        return this;
     }
 
     @Override
@@ -125,5 +106,3 @@ public class StubberImpl implements Stubber {
         return this;
     }
 }
-
-
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java b/src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java
new file mode 100644
index 000000000..ef7baad76
--- /dev/null
+++ b/src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionClass.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+
+package org.mockito.internal.stubbing.answers;
+
+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+import org.objenesis.ObjenesisHelper;
+
+import static org.mockito.internal.exceptions.Reporter.notAnException;
+
+import java.io.Serializable;
+
+public class ThrowsExceptionClass implements Answer<Object>, Serializable {
+
+    private final Class<? extends Throwable> throwableClass;
+    private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
+
+    public ThrowsExceptionClass(Class<? extends Throwable> throwableClass) {
+        this.throwableClass = checkNonNullThrowable(throwableClass);
+    }
+
+    private Class<? extends Throwable> checkNonNullThrowable(Class<? extends Throwable> throwableClass) {
+        if(throwableClass == null || !Throwable.class.isAssignableFrom(throwableClass)) {
+            throw notAnException();
+        }
+        return throwableClass;
+    }
+
+    public Object answer(InvocationOnMock invocation) throws Throwable {
+        //TODO centralize the use of Objenesis. Why do we use ObjenesisHelper?
+        Throwable throwable = ObjenesisHelper.newInstance(throwableClass);
+        throwable.fillInStackTrace();
+        filter.filter(throwable);
+        throw throwable;
+    }
+
+    public Class<? extends Throwable> getThrowableClass() {
+        return throwableClass;
+    }
+}
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
index 1931bd1de..0ccf14f26 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
@@ -5,43 +5,29 @@
 
 package org.mockitousage.stubbing;
 
-import static junit.framework.TestCase.assertEquals;
-import static junit.framework.TestCase.assertNull;
-import static junit.framework.TestCase.assertTrue;
-import static junit.framework.TestCase.fail;
-import static org.hamcrest.CoreMatchers.sameInstance;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.verifyZeroInteractions;
-import static org.mockito.Mockito.when;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.Map;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.junit.rules.ExpectedException;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-@SuppressWarnings({ "serial", "unchecked", "rawtypes" })
+import java.io.IOException;
+import java.io.Reader;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
+
+import static junit.framework.TestCase.*;
+import static org.mockito.Mockito.*;
+
+@SuppressWarnings({"serial", "unchecked", "all", "deprecation"})
 public class StubbingWithThrowablesTest extends TestBase {
 
     private LinkedList mock;
 
     private Map mockTwo;
 
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
-
     @Before
     public void setup() {
         mock = mock(LinkedList.class);
@@ -53,9 +39,12 @@ public class StubbingWithThrowablesTest extends TestBase {
         IllegalArgumentException expected = new IllegalArgumentException("thrown by mock");
         when(mock.add("throw")).thenThrow(expected);
 
-        exception.expect(sameInstance(expected));
-        mock.add("throw");
-
+        try {
+            mock.add("throw");
+            fail();
+        } catch (IllegalArgumentException e) {
+            assertEquals(expected, e);
+        }
     }
 
     @Test
@@ -63,11 +52,12 @@ public class StubbingWithThrowablesTest extends TestBase {
         IllegalArgumentException expected = new IllegalArgumentException("thrown by mock");
 
         doThrow(expected).when(mock).clear();
-
-        exception.expect(sameInstance(expected));
-
-        mock.clear();
-
+        try {
+            mock.clear();
+            fail();
+        } catch (Exception e) {
+            assertEquals(expected, e);
+        }
     }
 
     @Test
@@ -75,18 +65,22 @@ public class StubbingWithThrowablesTest extends TestBase {
         doThrow(new ExceptionOne()).when(mock).clear();
         doThrow(new ExceptionTwo()).when(mock).clear();
 
-        exception.expect(ExceptionTwo.class);
-
-        mock.clear();
+        try {
+            mock.clear();
+            fail();
+        } catch (ExceptionTwo e) {
+        }
     }
 
     @Test
     public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation() throws Exception {
-        when(mock.size()).thenThrow(new ExceptionOne());
+        when(mock.get(1)).thenThrow(new ExceptionOne());
 
-        exception.expect(ExceptionOne.class);
-
-        when(mock.size()).thenThrow(new ExceptionTwo());
+        try {
+            when(mock.get(1)).thenThrow(new ExceptionTwo());
+            fail();
+        } catch (ExceptionOne e) {
+        }
     }
 
     @Test
@@ -96,9 +90,12 @@ public class StubbingWithThrowablesTest extends TestBase {
 
         when(reader.read()).thenThrow(ioException);
 
-        exception.expect(sameInstance(ioException));
-
-        reader.read();
+        try {
+            reader.read();
+            fail();
+        } catch (Exception e) {
+            assertEquals(ioException, e);
+        }
     }
 
     @Test
@@ -107,147 +104,49 @@ public class StubbingWithThrowablesTest extends TestBase {
 
         when(mock.add("quake")).thenThrow(error);
 
-        exception.expect(Error.class);
-
-        mock.add("quake");
+        try {
+            mock.add("quake");
+            fail();
+        } catch (Error e) {
+            assertEquals(error, e);
+        }
     }
 
-    @Test
+    @Test(expected = MockitoException.class)
     public void shouldNotAllowNullExceptionType() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot stub with null throwable");
-
         when(mock.add(null)).thenThrow((Exception) null);
     }
 
-    @Test
+
+    @Test(expected = NaughtyException.class)
     public void shouldInstantiateExceptionClassOnInteraction() {
         when(mock.add(null)).thenThrow(NaughtyException.class);
 
-        exception.expect(NaughtyException.class);
-
         mock.add(null);
     }
 
-    @Test
+    @Test(expected = NaughtyException.class)
     public void shouldInstantiateExceptionClassWithOngoingStubbingOnInteraction() {
         doThrow(NaughtyException.class).when(mock).add(null);
 
-        exception.expect(NaughtyException.class);
-
         mock.add(null);
     }
 
-    @Test
-    public void shouldNotAllowSettingInvalidCheckedException() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Checked exception is invalid for this method");
-
+    @Test(expected = MockitoException.class)
+    public void shouldNotAllowSettingInvalidCheckedException() throws Exception {
         when(mock.add("monkey island")).thenThrow(new Exception());
     }
 
-    @Test
-    public void shouldNotAllowSettingNullThrowable() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot stub with null throwable");
-
+    @Test(expected = MockitoException.class)
+    public void shouldNotAllowSettingNullThrowable() throws Exception {
         when(mock.add("monkey island")).thenThrow((Throwable) null);
     }
 
-    @Test
-    public void shouldNotAllowSettingNullThrowableArray() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Cannot stub with null throwable");
-
+    @Test(expected = MockitoException.class)
+    public void shouldNotAllowSettingNullThrowableArray() throws Exception {
         when(mock.add("monkey island")).thenThrow((Throwable[]) null);
     }
 
-    @Test
-    public void shouldNotAllowSettingNullThrowableClass() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        when(mock.isEmpty()).thenThrow((Class) null);
-    }
-
-    @Test
-    public void shouldNotAllowSettingNullThrowableClasses() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class[]) null);
-    }
-
-    @Test
-    public void shouldNotAllowSettingNullVarArgThrowableClass() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class) null);
-    }
-
-    @Test
-    public void doThrowShouldNotAllowSettingNullThrowableClass() {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        doThrow((Class) null).when(mock).isEmpty();
-    }
-
-    @Test
-    public void doThrowShouldNotAllowSettingNullThrowableClasses() throws Exception {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        doThrow(RuntimeException.class, (Class) null).when(mock).isEmpty();
-    }
-
-    @Test
-    public void doThrowShouldNotAllowSettingNullVarArgThrowableClasses() throws Exception {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        doThrow(RuntimeException.class, (Class[]) null).when(mock).isEmpty();
-    }
-
-    @Test
-    public void shouldNotAllowSettingNullVarArgsThrowableClasses() throws Exception {
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Exception type cannot be null");
-
-        when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class<RuntimeException>[]) null);
-    }
-
-    @Test
-    public void shouldNotAllowDifferntCheckedException() throws Exception {
-        IMethods mock = mock(IMethods.class);
-
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Checked exception is invalid for this method");
-
-        when(mock.throwsIOException(0)).thenThrow(CheckedException.class);
-    }
-
-    @Test
-    public void shouldNotAllowCheckedExceptionWhenErrorIsDeclared() throws Exception {
-        IMethods mock = mock(IMethods.class);
-
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Checked exception is invalid for this method");
-
-        when(mock.throwsError(0)).thenThrow(CheckedException.class);
-    }
-
-    @Test
-    public void shouldNotAllowCheckedExceptionWhenNothingIsDeclared() throws Exception {
-        IMethods mock = mock(IMethods.class);
-
-        exception.expect(MockitoException.class);
-        exception.expectMessage("Checked exception is invalid for this method");
-
-        when(mock.throwsNothing(true)).thenThrow(CheckedException.class);
-    }
-
     @Test
     public void shouldMixThrowablesAndReturnsOnDifferentMocks() throws Exception {
         when(mock.add("ExceptionOne")).thenThrow(new ExceptionOne());
@@ -337,23 +236,31 @@ public class StubbingWithThrowablesTest extends TestBase {
     }
 
     private class ExceptionOne extends RuntimeException {
+
     }
 
     private class ExceptionTwo extends RuntimeException {
+
     }
 
     private class ExceptionThree extends RuntimeException {
+
     }
 
     private class ExceptionFour extends RuntimeException {
-    }
 
-    private class CheckedException extends Exception {
     }
 
     public class NaughtyException extends RuntimeException {
+
         public NaughtyException() {
             throw new RuntimeException("boo!");
         }
     }
+
+    @Test(expected = NaughtyException.class)
+    public void shouldShowDecentMessageWhenExcepionIsNaughty() throws Exception {
+        when(mock.add("")).thenThrow(NaughtyException.class);
+        mock.add("");
+    }
 }
