diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 4d7f17504..10eb9d929 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -28,8 +28,6 @@ Project: jackson-databind
  (fix by @cowtowncoder, w/ Claude code)
 #5413: Add/support forward reference resolution for array values
  (contributed by HÃ©lios G)
-#5429: Formatting and Parsing of Large ISO-8601 Dates is inconsistent
- (reported by @DavTurns)
 
 2.20.2 (not yet released)
 
diff --git a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
index cf0452345..24a13b35c 100644
--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
@@ -49,14 +49,11 @@ public class StdDateFormat
 
     protected final static Pattern PATTERN_PLAIN = Pattern.compile(PATTERN_PLAIN_STR);
 
-    // [databind#5429]: Extended year format (4+ digits, optional +/- prefix)
-    protected final static String PATTERN_YEAR_STR = "(?:[+-]?\\d{4,})";
-
     protected final static Pattern PATTERN_ISO8601;
     static {
         Pattern p = null;
         try {
-            p = Pattern.compile(PATTERN_YEAR_STR + "[-]\\d\\d[-]\\d\\d"
+            p = Pattern.compile(PATTERN_PLAIN_STR
                     +"[T]\\d\\d[:]\\d\\d(?:[:]\\d\\d)?" // hours, minutes, optional seconds
                     +"(\\.\\d+)?" // optional second fractions
                     +"(Z|[+-]\\d\\d(?:[:]?\\d\\d)?)?" // optional timeoffset/Z
@@ -610,17 +607,13 @@ public class StdDateFormat
      */
     protected boolean looksLikeISO8601(String dateStr)
     {
-        if (dateStr.length() >= 7) { // really need 10, but...
-            final char c = dateStr.charAt(0);
-            // [databind#5429]: extended year may have +/- prefix
-            if (c == '+' || c == '-') {
-                return (dateStr.length() >= 11)
-                    && Character.isDigit(dateStr.charAt(1));
-            }
-            return Character.isDigit(c)
-                && Character.isDigit(dateStr.charAt(3))
-                && dateStr.charAt(4) == '-'
-                && Character.isDigit(dateStr.charAt(5));
+        if (dateStr.length() >= 7 // really need 10, but...
+            && Character.isDigit(dateStr.charAt(0))
+            && Character.isDigit(dateStr.charAt(3))
+            && dateStr.charAt(4) == '-'
+            && Character.isDigit(dateStr.charAt(5))
+            ) {
+            return true;
         }
         return false;
     }
@@ -677,20 +670,8 @@ public class StdDateFormat
         } else {
             Matcher m = PATTERN_ISO8601.matcher(dateStr);
             if (m.matches()) {
-                // [databind#5429]: handle extended year (5+ digits with optional +/- prefix)
-                // by locating where year ends (first hyphen for year-month separator)
-                int yearEnd = (dateStr.charAt(0) == '-') ? dateStr.indexOf('-', 1) : dateStr.indexOf('-');
-                int year = (yearEnd <= 4) ? _parse4D(dateStr, 0)
-                        : Integer.parseInt(dateStr.substring(0, yearEnd));
-                final int offset = yearEnd - 4; // adjustment for extended year
-                int month = _parse2D(dateStr, 5 + offset)-1;
-                int day = _parse2D(dateStr, 8 + offset);
-                int hour = _parse2D(dateStr, 11 + offset);
-                int minute = _parse2D(dateStr, 14 + offset);
-                int seconds = ((totalLen > (16 + offset)) && dateStr.charAt(16 + offset) == ':')
-                        ? _parse2D(dateStr, 17 + offset) : 0;
-
                 // Important! START with optional time zone; otherwise Calendar will explode
+
                 int start = m.start(2);
                 int end = m.end(2);
                 int len = end-start;
@@ -710,6 +691,21 @@ public class StdDateFormat
                     cal.set(Calendar.DST_OFFSET, 0);
                 }
 
+                int year = _parse4D(dateStr, 0);
+                int month = _parse2D(dateStr, 5)-1;
+                int day = _parse2D(dateStr, 8);
+
+                // So: 10 chars for date, then `T`, so starts at 11
+                int hour = _parse2D(dateStr, 11);
+                int minute = _parse2D(dateStr, 14);
+
+                // Seconds are actually optional... so
+                int seconds;
+                if ((totalLen > 16) && dateStr.charAt(16) == ':') {
+                    seconds = _parse2D(dateStr, 17);
+                } else {
+                    seconds = 0;
+                }
                 cal.set(year, month, day, hour, minute, seconds);
 
                 // Optional milliseconds
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateRoundtrip5429Test.java b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateRoundtrip5429Test.java
deleted file mode 100644
index 06f63b63d..000000000
--- a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/DateRoundtrip5429Test.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.fasterxml.jackson.databind.deser.jdk;
-
-import java.util.Date;
-
-import org.junit.jupiter.api.Test;
-
-import com.fasterxml.jackson.databind.*;
-import com.fasterxml.jackson.databind.json.JsonMapper;
-import com.fasterxml.jackson.databind.testutil.DatabindTestUtil;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-public class DateRoundtrip5429Test extends DatabindTestUtil
-{
-    private final ObjectMapper MAPPER = JsonMapper.builder()
-            .disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)
-            .build();
-
-    @Test
-    void testDateRoundTripWithMaxValue() throws Exception {
-
-        Date original = new Date(Long.MAX_VALUE);
-        String json = MAPPER.writeValueAsString(original);
-        Date parsed = MAPPER.readValue(json, Date.class);
-
-        assertEquals(original.getTime(), parsed.getTime());
-        // but also check actual serialization
-        assertEquals(q("+292278994-08-17T07:12:55.807+00:00"), json);
-    }
-
-    @Test
-    void testDateRoundTripWithMinValue() throws Exception {
-        Date original = new Date(Long.MIN_VALUE);
-        String json = MAPPER.writeValueAsString(original);
-        Date parsed = MAPPER.readValue(json, Date.class);
-
-        assertEquals(original.getTime(), parsed.getTime());
-        // but also check actual serialization
-        assertEquals(q("-292269054-12-02T16:47:04.192+00:00"), json);
-    }
-}
