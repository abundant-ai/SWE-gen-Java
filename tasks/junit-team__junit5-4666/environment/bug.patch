diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.2.adoc
index 5dc1cb896..667da2449 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.2.adoc
@@ -35,8 +35,7 @@ on GitHub.
 [[release-notes-5.13.2-junit-jupiter-bug-fixes]]
 ==== Bug Fixes
 
-* Stop reporting discovery issues for cyclic inner class hierarchies not annotated with
-  `@Nested`.
+* ‚ùì
 
 [[release-notes-5.13.2-junit-jupiter-deprecations-and-breaking-changes]]
 ==== Deprecations and Breaking Changes
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
index 7495b1414..4470da5a5 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
@@ -17,9 +17,9 @@ import static java.util.stream.Collectors.toSet;
 import static org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor.getEnclosingTestClasses;
 import static org.junit.platform.commons.support.HierarchyTraversalMode.TOP_DOWN;
 import static org.junit.platform.commons.support.ReflectionSupport.findMethods;
+import static org.junit.platform.commons.support.ReflectionSupport.streamNestedClasses;
 import static org.junit.platform.commons.util.FunctionUtils.where;
 import static org.junit.platform.commons.util.ReflectionUtils.isInnerClass;
-import static org.junit.platform.commons.util.ReflectionUtils.streamNestedClasses;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;
 import static org.junit.platform.engine.support.discovery.SelectorResolver.Resolution.unresolved;
 
@@ -46,7 +46,6 @@ import org.junit.jupiter.engine.descriptor.TestClassAware;
 import org.junit.jupiter.engine.discovery.predicates.TestClassPredicates;
 import org.junit.platform.commons.support.ReflectionSupport;
 import org.junit.platform.commons.util.ReflectionUtils;
-import org.junit.platform.commons.util.ReflectionUtils.CycleErrorHandling;
 import org.junit.platform.engine.DiscoveryIssue;
 import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.DiscoverySelector;
@@ -290,13 +289,9 @@ class ClassSelectorResolver implements SelectorResolver {
 			Stream<DiscoverySelector> methods = findMethods(testClass,
 				this.predicates.isTestOrTestFactoryOrTestTemplateMethod, TOP_DOWN).stream() //
 						.map(method -> selectMethod(testClasses, method));
-			Stream<Class<?>> annotatedNestedClasses = streamNestedClasses(testClass,
-				this.predicates.isAnnotatedWithNested);
-			Stream<Class<?>> notAnnotatedInnerClasses = streamNestedClasses(testClass,
-				this.predicates.isAnnotatedWithNested.negate().and(ReflectionUtils::isInnerClass),
-				CycleErrorHandling.ABORT_VISIT);
-			var nestedClasses = Stream.concat(annotatedNestedClasses, notAnnotatedInnerClasses) //
-					.map(nestedClass -> DiscoverySelectors.selectNestedClass(testClasses, nestedClass));
+			Stream<NestedClassSelector> nestedClasses = streamNestedClasses(testClass,
+				this.predicates.isAnnotatedWithNested.or(ReflectionUtils::isInnerClass)) //
+						.map(nestedClass -> DiscoverySelectors.selectNestedClass(testClasses, nestedClass));
 			return Stream.concat(methods, nestedClasses).collect(
 				toCollection((Supplier<Set<DiscoverySelector>>) LinkedHashSet::new));
 		};
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java
index c9ee44d5b..5e48b659f 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java
@@ -20,15 +20,12 @@ import static org.junit.platform.commons.util.ReflectionUtils.isMethodPresent;
 import static org.junit.platform.commons.util.ReflectionUtils.isNestedClassPresent;
 
 import java.lang.reflect.Method;
-import java.util.HashSet;
-import java.util.Set;
 import java.util.function.Predicate;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.ClassTemplate;
 import org.junit.jupiter.api.Nested;
 import org.junit.platform.commons.util.ReflectionUtils;
-import org.junit.platform.commons.util.ReflectionUtils.CycleErrorHandling;
 import org.junit.platform.engine.DiscoveryIssue;
 import org.junit.platform.engine.support.descriptor.ClassSource;
 import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
@@ -68,16 +65,9 @@ public class TestClassPredicates {
 	}
 
 	public boolean looksLikeIntendedTestClass(Class<?> candidate) {
-		return looksLikeIntendedTestClass(candidate, new HashSet<>());
-	}
-
-	private boolean looksLikeIntendedTestClass(Class<?> candidate, Set<Class<?>> seen) {
-		if (seen.add(candidate)) {
-			return this.isAnnotatedWithClassTemplate.test(candidate) //
-					|| hasTestOrTestFactoryOrTestTemplateMethods(candidate) //
-					|| hasNestedTests(candidate, seen);
-		}
-		return false;
+		return this.isAnnotatedWithClassTemplate.test(candidate) //
+				|| hasTestOrTestFactoryOrTestTemplateMethods(candidate) //
+				|| hasNestedTests(candidate);
 	}
 
 	public boolean isValidNestedTestClass(Class<?> candidate) {
@@ -94,17 +84,15 @@ public class TestClassPredicates {
 		return isMethodPresent(candidate, this.isTestOrTestFactoryOrTestTemplateMethod);
 	}
 
-	private boolean hasNestedTests(Class<?> candidate, Set<Class<?>> seen) {
-		var hasAnnotatedClass = isNestedClassPresent(candidate, this.isAnnotatedWithNested,
-			CycleErrorHandling.THROW_EXCEPTION);
-		if (hasAnnotatedClass) {
-			return true;
-		}
+	private boolean hasNestedTests(Class<?> candidate) {
 		return isNestedClassPresent( //
 			candidate, //
-			it -> isInnerClass(it) && looksLikeIntendedTestClass(it, seen), //
-			CycleErrorHandling.ABORT_VISIT //
-		);
+			isNotSame(candidate).and(
+				this.isAnnotatedWithNested.or(it -> isInnerClass(it) && looksLikeIntendedTestClass(it))));
+	}
+
+	private static Predicate<Class<?>> isNotSame(Class<?> candidate) {
+		return clazz -> candidate != clazz;
 	}
 
 	private static Condition<Class<?>> isNotPrivateUnlessAbstract(String prefix, DiscoveryIssueReporter issueReporter) {
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
index d9bd8e4b4..3836d2369 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
@@ -130,7 +130,7 @@ public final class ReflectionUtils {
 	 * <p>This serves as a cache to avoid repeated cycle detection for classes
 	 * that have already been checked.
 	 * @since 1.6
-	 * @see #detectInnerClassCycle(Class, CycleErrorHandling)
+	 * @see #detectInnerClassCycle(Class)
 	 */
 	private static final Set<String> noCyclesDetectedCache = ConcurrentHashMap.newKeySet();
 
@@ -1117,17 +1117,11 @@ public final class ReflectionUtils {
 	 * @see org.junit.platform.commons.support.ReflectionSupport#findNestedClasses(Class, Predicate)
 	 */
 	public static List<Class<?>> findNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate) {
-		return findNestedClasses(clazz, predicate, CycleErrorHandling.THROW_EXCEPTION);
-	}
-
-	@API(status = INTERNAL, since = "5.13.2")
-	public static List<Class<?>> findNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,
-			CycleErrorHandling errorHandling) {
 		Preconditions.notNull(clazz, "Class must not be null");
 		Preconditions.notNull(predicate, "Predicate must not be null");
 
 		Set<Class<?>> candidates = new LinkedHashSet<>();
-		visitAllNestedClasses(clazz, predicate, candidates::add, errorHandling);
+		visitAllNestedClasses(clazz, predicate, candidates::add);
 		return List.copyOf(candidates);
 	}
 
@@ -1150,15 +1144,13 @@ public final class ReflectionUtils {
 	 * @return {@code true} if such a nested class is present
 	 * @throws JUnitException if a cycle is detected within an inner class hierarchy
 	 */
-	@API(status = INTERNAL, since = "1.13.2")
-	public static boolean isNestedClassPresent(Class<?> clazz, Predicate<Class<?>> predicate,
-			CycleErrorHandling errorHandling) {
+	@API(status = INTERNAL, since = "1.13")
+	public static boolean isNestedClassPresent(Class<?> clazz, Predicate<Class<?>> predicate) {
 		Preconditions.notNull(clazz, "Class must not be null");
 		Preconditions.notNull(predicate, "Predicate must not be null");
-		Preconditions.notNull(errorHandling, "CycleErrorHandling must not be null");
 
 		AtomicBoolean foundNestedClass = new AtomicBoolean(false);
-		visitAllNestedClasses(clazz, predicate, __ -> foundNestedClass.setPlain(true), errorHandling);
+		visitAllNestedClasses(clazz, predicate, __ -> foundNestedClass.setPlain(true));
 		return foundNestedClass.getPlain();
 	}
 
@@ -1170,37 +1162,27 @@ public final class ReflectionUtils {
 		return findNestedClasses(clazz, predicate).stream();
 	}
 
-	@API(status = INTERNAL, since = "5.13.2")
-	public static Stream<Class<?>> streamNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,
-			CycleErrorHandling errorHandling) {
-		return findNestedClasses(clazz, predicate, errorHandling).stream();
-	}
-
 	/**
 	 * Visit <em>all</em> nested classes without support for short-circuiting
 	 * in order to ensure all of them are checked for class cycles.
 	 */
 	private static void visitAllNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,
-			Consumer<Class<?>> consumer, CycleErrorHandling errorHandling) {
+			Consumer<Class<?>> consumer) {
 
 		if (!isSearchable(clazz)) {
 			return;
 		}
 
 		if (isInnerClass(clazz) && predicate.test(clazz)) {
-			if (detectInnerClassCycle(clazz, errorHandling)) {
-				return;
-			}
+			detectInnerClassCycle(clazz);
 		}
 
 		try {
 			// Candidates in current class
 			for (Class<?> nestedClass : clazz.getDeclaredClasses()) {
 				if (predicate.test(nestedClass)) {
+					detectInnerClassCycle(nestedClass);
 					consumer.accept(nestedClass);
-					if (detectInnerClassCycle(nestedClass, errorHandling)) {
-						return;
-					}
 				}
 			}
 		}
@@ -1209,11 +1191,11 @@ public final class ReflectionUtils {
 		}
 
 		// Search class hierarchy
-		visitAllNestedClasses(clazz.getSuperclass(), predicate, consumer, errorHandling);
+		visitAllNestedClasses(clazz.getSuperclass(), predicate, consumer);
 
 		// Search interface hierarchy
 		for (Class<?> ifc : clazz.getInterfaces()) {
-			visitAllNestedClasses(ifc, predicate, consumer, errorHandling);
+			visitAllNestedClasses(ifc, predicate, consumer);
 		}
 	}
 
@@ -1221,8 +1203,10 @@ public final class ReflectionUtils {
 	 * Detect a cycle in the inner class hierarchy in which the supplied class
 	 * resides &mdash; from the supplied class up to the outermost enclosing class
 	 * &mdash; and throw a {@link JUnitException} if a cycle is detected.
+	 *
 	 * <p>This method does <strong>not</strong> detect cycles within inner class
 	 * hierarchies <em>below</em> the supplied class.
+	 *
 	 * <p>If the supplied class is not an inner class and does not have a
 	 * searchable superclass, this method is effectively a no-op.
 	 *
@@ -1230,26 +1214,25 @@ public final class ReflectionUtils {
 	 * @see #isInnerClass(Class)
 	 * @see #isSearchable(Class)
 	 */
-	private static boolean detectInnerClassCycle(Class<?> clazz, CycleErrorHandling errorHandling) {
+	private static void detectInnerClassCycle(Class<?> clazz) {
 		Preconditions.notNull(clazz, "Class must not be null");
 		String className = clazz.getName();
 
 		if (noCyclesDetectedCache.contains(className)) {
-			return false;
+			return;
 		}
 
 		Class<?> superclass = clazz.getSuperclass();
 		if (isInnerClass(clazz) && isSearchable(superclass)) {
 			for (Class<?> enclosing = clazz.getEnclosingClass(); enclosing != null; enclosing = enclosing.getEnclosingClass()) {
 				if (superclass.equals(enclosing)) {
-					errorHandling.handle(clazz, enclosing);
-					return true;
+					throw new JUnitException(String.format("Detected cycle in inner class hierarchy between %s and %s",
+						className, enclosing.getName()));
 				}
 			}
 		}
 
 		noCyclesDetectedCache.add(className);
-		return false;
 	}
 
 	/**
@@ -1953,25 +1936,4 @@ public final class ReflectionUtils {
 		return t;
 	}
 
-	@API(status = INTERNAL, since = "5.13.2")
-	public enum CycleErrorHandling {
-
-		THROW_EXCEPTION {
-			@Override
-			void handle(Class<?> clazz, Class<?> enclosing) {
-				throw new JUnitException(String.format("Detected cycle in inner class hierarchy between %s and %s",
-					clazz.getName(), enclosing.getName()));
-			}
-		},
-
-		ABORT_VISIT {
-			@Override
-			void handle(Class<?> clazz, Class<?> enclosing) {
-				// ignore
-			}
-		};
-
-		abstract void handle(Class<?> clazz, Class<?> enclosing);
-	}
-
 }
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java
index 395d47c27..26db9306a 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java
@@ -48,7 +48,6 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 import org.junit.platform.engine.DiscoveryIssue;
-import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.support.descriptor.ClassSource;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
@@ -290,35 +289,7 @@ class DiscoveryTests extends AbstractJupiterTestEngineTests {
 	}
 
 	@Test
-	void ignoresUnrelatedClassDefinitionCycles() {
-		var results = discoverTestsForClass(UnrelatedRecursiveHierarchyTestCase.class);
-
-		assertThat(results.getDiscoveryIssues()).isEmpty();
-	}
-
-	@Test
-	void ignoresRecursiveNonTestHierarchyCycles() {
-		var results = discoverTestsForClass(NonTestRecursiveHierarchyTestCase.class);
-
-		assertThat(results.getDiscoveryIssues()).isEmpty();
-	}
-
-	@Test
-	void reportsMissingNestedAnnotationOnRecursiveHierarchy() {
-		var results = discoverTestsForClass(RecursiveHierarchyWithoutNestedTestCase.class);
-
-		var discoveryIssues = results.getDiscoveryIssues();
-		assertThat(discoveryIssues).hasSize(1);
-		assertThat(discoveryIssues.getFirst().severity()) //
-				.isEqualTo(Severity.WARNING);
-		assertThat(discoveryIssues.getFirst().message()) //
-				.isEqualTo(
-					"Inner class '%s' looks like it was intended to be a test class but will not be executed. It must be static or annotated with @Nested.",
-					RecursiveHierarchyWithoutNestedTestCase.Inner.class.getName());
-	}
-
-	@Test
-	void reportsWarningsForInvalidTags() throws Exception {
+	void reportsWarningsForInvalidTags() throws NoSuchMethodException {
 
 		var results = discoverTestsForClass(InvalidTagsTestCase.class);
 
@@ -340,7 +311,7 @@ class DiscoveryTests extends AbstractJupiterTestEngineTests {
 	}
 
 	@Test
-	void reportsWarningsForBlankDisplayNames() throws Exception {
+	void reportsWarningsForBlankDisplayNames() throws NoSuchMethodException {
 
 		var results = discoverTestsForClass(BlankDisplayNamesTestCase.class);
 
@@ -470,39 +441,6 @@ class DiscoveryTests extends AbstractJupiterTestEngineTests {
 
 	}
 
-	@SuppressWarnings("JUnitMalformedDeclaration")
-	static class UnrelatedRecursiveHierarchyTestCase {
-
-		@Test
-		void test() {
-		}
-
-		@SuppressWarnings({ "InnerClassMayBeStatic", "unused" })
-		class Inner {
-			class Recursive extends Inner {
-			}
-		}
-	}
-
-	@SuppressWarnings("JUnitMalformedDeclaration")
-	static class RecursiveHierarchyWithoutNestedTestCase {
-
-		@Test
-		void test() {
-		}
-
-		@SuppressWarnings({ "InnerClassMayBeStatic", "unused" })
-		class Inner extends RecursiveHierarchyWithoutNestedTestCase {
-		}
-	}
-
-	@SuppressWarnings("unused")
-	static class NonTestRecursiveHierarchyTestCase {
-		@SuppressWarnings("InnerClassMayBeStatic")
-		class Inner extends NonTestRecursiveHierarchyTestCase {
-		}
-	}
-
 	@SuppressWarnings("JUnitMalformedDeclaration")
 	@Tag("")
 	static class InvalidTagsTestCase {
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java
index 3c280e29f..30ea70b31 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java
@@ -11,6 +11,7 @@
 package org.junit.jupiter.engine.discovery.predicates;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
@@ -23,6 +24,7 @@ import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.TestTemplate;
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.engine.DiscoveryIssue;
 import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.support.descriptor.ClassSource;
@@ -216,7 +218,11 @@ public class TestClassPredicatesTests {
 		 */
 		@Test
 		void recursiveHierarchies() {
-			assertTrue(predicates.looksLikeIntendedTestClass(TestCases.OuterClass.class));
+			assertThatExceptionOfType(JUnitException.class)//
+					.isThrownBy(() -> predicates.looksLikeIntendedTestClass(TestCases.OuterClass.class))//
+					.withMessage("Detected cycle in inner class hierarchy between %s and %s",
+						TestCases.OuterClass.RecursiveInnerClass.class.getName(), TestCases.OuterClass.class.getName());
+
 			assertTrue(predicates.isValidStandaloneTestClass(TestCases.OuterClass.class));
 			assertThat(discoveryIssues).isEmpty();
 
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
index 7b970410e..87872afbb 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
@@ -71,7 +71,6 @@ import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.platform.commons.support.Resource;
 import org.junit.platform.commons.test.TestClassLoader;
-import org.junit.platform.commons.util.ReflectionUtils.CycleErrorHandling;
 import org.junit.platform.commons.util.ReflectionUtilsTests.NestedClassTests.ClassWithNestedClasses.Nested1;
 import org.junit.platform.commons.util.ReflectionUtilsTests.NestedClassTests.ClassWithNestedClasses.Nested2;
 import org.junit.platform.commons.util.ReflectionUtilsTests.NestedClassTests.ClassWithNestedClasses.Nested3;
@@ -1055,10 +1054,9 @@ class ReflectionUtilsTests {
 		@Test
 		void isNestedClassPresentPreconditions() {
 			// @formatter:off
-			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, null, null));
-			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, clazz -> true, CycleErrorHandling.THROW_EXCEPTION));
-			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(getClass(), null, CycleErrorHandling.ABORT_VISIT));
-			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(getClass(), clazz -> true, null));
+			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, null));
+			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, clazz -> true));
+			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(getClass(), null));
 			// @formatter:on
 		}
 
@@ -1075,12 +1073,12 @@ class ReflectionUtilsTests {
 
 			assertThat(ReflectionUtils.findNestedClasses(ClassWithNestedClasses.class, clazz -> clazz.getName().contains("1")))
 					.containsExactly(Nested1.class);
-			assertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, clazz -> clazz.getName().contains("1"), CycleErrorHandling.THROW_EXCEPTION))
+			assertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, clazz -> clazz.getName().contains("1")))
 					.isTrue();
 
 			assertThat(ReflectionUtils.findNestedClasses(ClassWithNestedClasses.class, ReflectionUtils::isStatic))
 					.containsExactly(Nested3.class);
-			assertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, ReflectionUtils::isStatic, CycleErrorHandling.THROW_EXCEPTION))
+			assertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, ReflectionUtils::isStatic))
 					.isTrue();
 
 			assertThat(findNestedClasses(ClassExtendingClassWithNestedClasses.class))
@@ -1107,14 +1105,12 @@ class ReflectionUtilsTests {
 			// predicate should prevent cycle detection.
 			// See https://github.com/junit-team/junit5/issues/2249
 			assertThat(ReflectionUtils.findNestedClasses(OuterClass.class, clazz -> false)).isEmpty();
-			assertThat(ReflectionUtils.isNestedClassPresent(OuterClass.class, clazz -> false,
-				CycleErrorHandling.THROW_EXCEPTION)).isFalse();
+			assertThat(ReflectionUtils.isNestedClassPresent(OuterClass.class, clazz -> false)).isFalse();
 
 			// RecursiveInnerInnerClass is part of a recursive hierarchy, but the non-matching
 			// predicate should prevent cycle detection.
 			assertThat(ReflectionUtils.findNestedClasses(RecursiveInnerInnerClass.class, clazz -> false)).isEmpty();
-			assertThat(ReflectionUtils.isNestedClassPresent(RecursiveInnerInnerClass.class, clazz -> false,
-				CycleErrorHandling.THROW_EXCEPTION)).isFalse();
+			assertThat(ReflectionUtils.isNestedClassPresent(RecursiveInnerInnerClass.class, clazz -> false)).isFalse();
 
 			// Sibling types don't actually result in cycles.
 			assertThat(findNestedClasses(StaticNestedSiblingClass.class))//
@@ -1157,7 +1153,7 @@ class ReflectionUtilsTests {
 		}
 
 		private static boolean isNestedClassPresent(Class<?> clazz) {
-			return ReflectionUtils.isNestedClassPresent(clazz, c -> true, CycleErrorHandling.THROW_EXCEPTION);
+			return ReflectionUtils.isNestedClassPresent(clazz, c -> true);
 		}
 
 		private void assertNestedCycle(Class<?> from, Class<?> to) {
