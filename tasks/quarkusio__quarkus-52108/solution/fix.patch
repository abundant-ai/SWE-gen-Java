diff --git a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java
index 3bb8f69a9f2..2a41b4b2829 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java
@@ -186,33 +186,22 @@ private void buildUberJar0(Path runnerJar) throws IOException {
                         mergeResourcePaths);
             }
 
-            Map<Set<Dependency>, List<String>> explained = new HashMap<>();
+            Set<Set<Dependency>> explained = new HashSet<>();
             for (Map.Entry<String, Set<Dependency>> entry : duplicateCatcher.entrySet()) {
                 if (entry.getValue().size() > 1) {
-                    explained.computeIfAbsent(entry.getValue(), k -> new ArrayList<>()).add(entry.getKey());
-                }
-            }
-            if (!explained.isEmpty()) {
-                for (Map.Entry<Set<Dependency>, List<String>> entry : explained.entrySet()) {
-                    var msg = new StringBuilder().append("Dependencies:");
-                    for (var dep : entry.getKey()) {
-                        msg.append(System.lineSeparator()).append("- ").append(dep.toCompactCoords());
+                    if (explained.add(entry.getValue())) {
+                        LOG.warn("Dependencies with duplicate files detected. The dependencies " + entry.getValue()
+                                + " contain duplicate files, e.g. " + entry.getKey());
                     }
-                    msg.append(System.lineSeparator()).append("contain duplicate files:");
-                    for (var path : entry.getValue()) {
-                        msg.append(System.lineSeparator()).append("- ").append(path);
-                    }
-                    LOG.warn(msg);
                 }
             }
-
             copyCommonContent(archiveCreator, concatenatedEntries, allIgnoredEntriesPredicate);
             // now that all entries have been added, check if there's a META-INF/versions/ entry. If present,
             // mark this jar as multi-release jar. Strictly speaking, the jar spec expects META-INF/versions/N
             // directory where N is an integer greater than 8, but we don't do that level of checks here but that
             // should be OK.
             if (archiveCreator.isMultiVersion()) {
-                LOG.debug("Uber jar will be marked as multi-release jar");
+                LOG.debug("uber jar will be marked as multi-release jar");
                 archiveCreator.makeMultiVersion();
             }
         }
diff --git a/extensions/websockets-next/deployment/src/main/java/io/quarkus/websockets/next/deployment/WebSocketProcessor.java b/extensions/websockets-next/deployment/src/main/java/io/quarkus/websockets/next/deployment/WebSocketProcessor.java
index af36c3eb81a..0714e092c88 100644
--- a/extensions/websockets-next/deployment/src/main/java/io/quarkus/websockets/next/deployment/WebSocketProcessor.java
+++ b/extensions/websockets-next/deployment/src/main/java/io/quarkus/websockets/next/deployment/WebSocketProcessor.java
@@ -83,6 +83,7 @@
 import io.quarkus.deployment.Capabilities;
 import io.quarkus.deployment.Capability;
 import io.quarkus.deployment.GeneratedClassGizmo2Adaptor;
+import io.quarkus.deployment.IsTest;
 import io.quarkus.deployment.annotations.BuildProducer;
 import io.quarkus.deployment.annotations.BuildStep;
 import io.quarkus.deployment.annotations.Consume;
@@ -92,6 +93,7 @@
 import io.quarkus.deployment.builditem.GeneratedClassBuildItem;
 import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;
 import io.quarkus.deployment.builditem.RuntimeConfigSetupCompleteBuildItem;
+import io.quarkus.deployment.builditem.SystemPropertyBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;
 import io.quarkus.deployment.execannotations.ExecutionModelAnnotationsAllowedBuildItem;
@@ -917,6 +919,16 @@ void createSecurityIdentityAssociation(Capabilities capabilities,
         }
     }
 
+    @BuildStep(onlyIf = IsTest.class)
+    void delegateToWebSocketSecurityIdentityAssociationFromTestSecurity(Capabilities capabilities,
+            BuildProducer<SystemPropertyBuildItem> systemPropertyProducer) {
+        if (capabilities.isPresent(Capability.SECURITY)) {
+            systemPropertyProducer
+                    .produce(new SystemPropertyBuildItem("test.quarkus.test-security.delegate-identity-association",
+                            WebSocketSecurityIdentityAssociation.class.getName()));
+        }
+    }
+
     private static boolean identityUpdateNotSupported(IndexView index) {
         return index.getKnownUsers(WEBSOCKET_SECURITY_NAME).isEmpty();
     }
diff --git a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/SecuritySupport.java b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/SecuritySupport.java
index c2a6361948a..6c24a7ca682 100644
--- a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/SecuritySupport.java
+++ b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/SecuritySupport.java
@@ -1,6 +1,7 @@
 package io.quarkus.websockets.next.runtime;
 
 import static io.quarkus.vertx.http.runtime.security.HttpSecurityUtils.setRoutingContextAttribute;
+import static io.quarkus.vertx.http.runtime.security.QuarkusHttpUser.DEFERRED_IDENTITY_KEY;
 
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.TimeUnit;
@@ -15,6 +16,7 @@
 import io.quarkus.websockets.next.CloseReason;
 import io.quarkus.websockets.next.WebSocketServerException;
 import io.quarkus.websockets.next.runtime.spi.security.WebSocketIdentityUpdateRequest;
+import io.smallrye.mutiny.Uni;
 import io.vertx.ext.web.RoutingContext;
 
 public final class SecuritySupport {
@@ -24,11 +26,13 @@ public final class SecuritySupport {
     static final SecuritySupport NOOP = new SecuritySupport(null, null, null);
 
     private final RoutingContext routingContext;
+    private final WebSocketConnectionImpl connection;
     private volatile SecurityIdentity identity;
     private volatile Runnable onClose;
 
     SecuritySupport(SecurityIdentity identity, WebSocketConnectionImpl connection, RoutingContext routingContext) {
         this.identity = identity;
+        this.connection = connection;
         this.onClose = closeConnectionWhenIdentityExpired(routingContext, connection, this.identity);
         this.routingContext = routingContext;
     }
@@ -43,6 +47,40 @@ SecurityIdentity getIdentity() {
         return identity;
     }
 
+    /**
+     * Using deferred identity may be necessary as a fallback if and only if the {@link #getIdentity()} is not available.
+     * We should prefer the resolved identity because we detect the identity expiration there.
+     * The reason why we need it is that only deferred identity may be available with disabled proactive authentication
+     * when the identity is not required during the HTTP upgrade. We should not authenticate proactively unless something
+     * requires the authentication.
+     *
+     * @return deferred identity (the `Uni` item can be null) or null
+     */
+    Uni<SecurityIdentity> getDeferredIdentity() {
+        if (routingContext == null) {
+            return null;
+        }
+        Uni<SecurityIdentity> deferredIdentity = routingContext.get(DEFERRED_IDENTITY_KEY);
+        if (deferredIdentity == null) {
+            return null;
+        }
+        return deferredIdentity.map(resolvedIdentity -> {
+            if (resolvedIdentity != null && !resolvedIdentity.isAnonymous()) {
+                if (resolvedIdentity.getAttribute(QUARKUS_IDENTITY_EXPIRE_TIME) instanceof Long expireAt) {
+                    boolean isExpired = (TimeUnit.SECONDS.toMillis(expireAt) - System.currentTimeMillis()) <= 0;
+                    if (isExpired) {
+                        routingContext.remove(DEFERRED_IDENTITY_KEY);
+                        return null;
+                    }
+                }
+
+                this.identity = resolvedIdentity;
+                this.onClose = closeConnectionWhenIdentityExpired(routingContext, connection, resolvedIdentity);
+            }
+            return resolvedIdentity;
+        });
+    }
+
     CompletionStage<SecurityIdentity> updateSecurityIdentity(String accessToken, WebSocketConnectionImpl connection,
             IdentityProviderManager identityProviderManager) {
         var authenticationRequest = new WebSocketIdentityUpdateRequest(new TokenCredential(accessToken, "bearer"),
diff --git a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketSecurityIdentityAssociation.java b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketSecurityIdentityAssociation.java
index 85aa24df2be..dcc97bff741 100644
--- a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketSecurityIdentityAssociation.java
+++ b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketSecurityIdentityAssociation.java
@@ -5,6 +5,7 @@
 
 import org.eclipse.microprofile.config.inject.ConfigProperty;
 
+import io.quarkus.runtime.BlockingOperationControl;
 import io.quarkus.security.identity.CurrentIdentityAssociation;
 import io.quarkus.security.identity.IdentityProviderManager;
 import io.quarkus.security.identity.SecurityIdentity;
@@ -48,10 +49,18 @@ public Uni<SecurityIdentity> getDeferredIdentity() {
             return delegate.getDeferredIdentity();
         }
 
-        SecurityIdentity securityIdentity = getSecurityIdentityFromCtx();
-        if (securityIdentity != null) {
-            return Uni.createFrom().item(securityIdentity);
+        SecuritySupport securitySupport = getSecuritySupportFromCtx();
+        if (securitySupport != null) {
+            if (securitySupport.getIdentity() != null) {
+                return Uni.createFrom().item(securitySupport.getIdentity());
+            }
+            Uni<SecurityIdentity> deferredIdentity = securitySupport.getDeferredIdentity();
+            if (deferredIdentity != null) {
+                // calling to the delegate should return anonymous identity, so that we avoid NPEs
+                return deferredIdentity.onItem().ifNull().switchTo(delegate::getDeferredIdentity);
+            }
         }
+
         return delegate.getDeferredIdentity();
     }
 
@@ -73,18 +82,30 @@ public SecurityIdentity getIdentity() {
             return delegate.getIdentity();
         }
 
-        SecurityIdentity securityIdentity = getSecurityIdentityFromCtx();
-        if (securityIdentity != null) {
-            return securityIdentity;
+        SecuritySupport securitySupport = getSecuritySupportFromCtx();
+        if (securitySupport != null) {
+            if (securitySupport.getIdentity() != null) {
+                return securitySupport.getIdentity();
+            }
+            if (BlockingOperationControl.isBlockingAllowed()) {
+                Uni<SecurityIdentity> deferredIdentity = securitySupport.getDeferredIdentity();
+                if (deferredIdentity != null) {
+                    SecurityIdentity resolvedIdentity = deferredIdentity.await().indefinitely();
+                    if (resolvedIdentity != null) {
+                        return resolvedIdentity;
+                    }
+                }
+            }
         }
+
         return delegate.getIdentity();
     }
 
-    private static SecurityIdentity getSecurityIdentityFromCtx() {
+    private static SecuritySupport getSecuritySupportFromCtx() {
         Context context = Vertx.currentContext();
         if (context != null && VertxContext.isDuplicatedContext(context)) {
             if (context.getLocal(ContextSupport.WEB_SOCKET_CONN_KEY) instanceof WebSocketConnectionImpl connection) {
-                return connection.securitySupport().getIdentity();
+                return connection.securitySupport();
             }
         }
         return null;
diff --git a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketServerRecorder.java b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketServerRecorder.java
index cbe4cfc8ba5..8ce5753d460 100644
--- a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketServerRecorder.java
+++ b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketServerRecorder.java
@@ -210,6 +210,9 @@ private static Function<WebSocketConnectionImpl, SecuritySupport> getSecuritySup
             if (ctx.user() instanceof QuarkusHttpUser user) {
                 return connection -> new SecuritySupport(user.getSecurityIdentity(), connection, ctx);
             }
+            if (ctx.get(QuarkusHttpUser.DEFERRED_IDENTITY_KEY) != null) {
+                return connection -> new SecuritySupport(null, connection, ctx);
+            }
         }
         return ignored -> SecuritySupport.NOOP;
     }
diff --git a/independent-projects/bootstrap/app-model/src/main/java/io/quarkus/maven/dependency/ResolvedArtifactDependency.java b/independent-projects/bootstrap/app-model/src/main/java/io/quarkus/maven/dependency/ResolvedArtifactDependency.java
index 5eb65b167c3..348f2cfc624 100644
--- a/independent-projects/bootstrap/app-model/src/main/java/io/quarkus/maven/dependency/ResolvedArtifactDependency.java
+++ b/independent-projects/bootstrap/app-model/src/main/java/io/quarkus/maven/dependency/ResolvedArtifactDependency.java
@@ -104,7 +104,7 @@ public boolean equals(Object obj) {
             return false;
         if (!(obj instanceof ResolvableDependency other))
             return false;
-        return Objects.equals(paths, other.getResolvedPaths()) && Objects.equals(module, other.getWorkspaceModule());
+        return Objects.equals(module, other.getWorkspaceModule()) && Objects.equals(paths, other.getResolvedPaths());
     }
 
     @Override
