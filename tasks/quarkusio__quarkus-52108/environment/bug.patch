diff --git a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java
index 2a41b4b2829..3bb8f69a9f2 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java
@@ -186,22 +186,33 @@ private void buildUberJar0(Path runnerJar) throws IOException {
                         mergeResourcePaths);
             }
 
-            Set<Set<Dependency>> explained = new HashSet<>();
+            Map<Set<Dependency>, List<String>> explained = new HashMap<>();
             for (Map.Entry<String, Set<Dependency>> entry : duplicateCatcher.entrySet()) {
                 if (entry.getValue().size() > 1) {
-                    if (explained.add(entry.getValue())) {
-                        LOG.warn("Dependencies with duplicate files detected. The dependencies " + entry.getValue()
-                                + " contain duplicate files, e.g. " + entry.getKey());
+                    explained.computeIfAbsent(entry.getValue(), k -> new ArrayList<>()).add(entry.getKey());
+                }
+            }
+            if (!explained.isEmpty()) {
+                for (Map.Entry<Set<Dependency>, List<String>> entry : explained.entrySet()) {
+                    var msg = new StringBuilder().append("Dependencies:");
+                    for (var dep : entry.getKey()) {
+                        msg.append(System.lineSeparator()).append("- ").append(dep.toCompactCoords());
                     }
+                    msg.append(System.lineSeparator()).append("contain duplicate files:");
+                    for (var path : entry.getValue()) {
+                        msg.append(System.lineSeparator()).append("- ").append(path);
+                    }
+                    LOG.warn(msg);
                 }
             }
+
             copyCommonContent(archiveCreator, concatenatedEntries, allIgnoredEntriesPredicate);
             // now that all entries have been added, check if there's a META-INF/versions/ entry. If present,
             // mark this jar as multi-release jar. Strictly speaking, the jar spec expects META-INF/versions/N
             // directory where N is an integer greater than 8, but we don't do that level of checks here but that
             // should be OK.
             if (archiveCreator.isMultiVersion()) {
-                LOG.debug("uber jar will be marked as multi-release jar");
+                LOG.debug("Uber jar will be marked as multi-release jar");
                 archiveCreator.makeMultiVersion();
             }
         }
diff --git a/extensions/websockets-next/deployment/src/main/java/io/quarkus/websockets/next/deployment/WebSocketProcessor.java b/extensions/websockets-next/deployment/src/main/java/io/quarkus/websockets/next/deployment/WebSocketProcessor.java
index 0714e092c88..af36c3eb81a 100644
--- a/extensions/websockets-next/deployment/src/main/java/io/quarkus/websockets/next/deployment/WebSocketProcessor.java
+++ b/extensions/websockets-next/deployment/src/main/java/io/quarkus/websockets/next/deployment/WebSocketProcessor.java
@@ -83,7 +83,6 @@
 import io.quarkus.deployment.Capabilities;
 import io.quarkus.deployment.Capability;
 import io.quarkus.deployment.GeneratedClassGizmo2Adaptor;
-import io.quarkus.deployment.IsTest;
 import io.quarkus.deployment.annotations.BuildProducer;
 import io.quarkus.deployment.annotations.BuildStep;
 import io.quarkus.deployment.annotations.Consume;
@@ -93,7 +92,6 @@
 import io.quarkus.deployment.builditem.GeneratedClassBuildItem;
 import io.quarkus.deployment.builditem.GeneratedResourceBuildItem;
 import io.quarkus.deployment.builditem.RuntimeConfigSetupCompleteBuildItem;
-import io.quarkus.deployment.builditem.SystemPropertyBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveHierarchyBuildItem;
 import io.quarkus.deployment.execannotations.ExecutionModelAnnotationsAllowedBuildItem;
@@ -919,16 +917,6 @@ void createSecurityIdentityAssociation(Capabilities capabilities,
         }
     }
 
-    @BuildStep(onlyIf = IsTest.class)
-    void delegateToWebSocketSecurityIdentityAssociationFromTestSecurity(Capabilities capabilities,
-            BuildProducer<SystemPropertyBuildItem> systemPropertyProducer) {
-        if (capabilities.isPresent(Capability.SECURITY)) {
-            systemPropertyProducer
-                    .produce(new SystemPropertyBuildItem("test.quarkus.test-security.delegate-identity-association",
-                            WebSocketSecurityIdentityAssociation.class.getName()));
-        }
-    }
-
     private static boolean identityUpdateNotSupported(IndexView index) {
         return index.getKnownUsers(WEBSOCKET_SECURITY_NAME).isEmpty();
     }
diff --git a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/SecuritySupport.java b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/SecuritySupport.java
index 6c24a7ca682..c2a6361948a 100644
--- a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/SecuritySupport.java
+++ b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/SecuritySupport.java
@@ -1,7 +1,6 @@
 package io.quarkus.websockets.next.runtime;
 
 import static io.quarkus.vertx.http.runtime.security.HttpSecurityUtils.setRoutingContextAttribute;
-import static io.quarkus.vertx.http.runtime.security.QuarkusHttpUser.DEFERRED_IDENTITY_KEY;
 
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.TimeUnit;
@@ -16,7 +15,6 @@
 import io.quarkus.websockets.next.CloseReason;
 import io.quarkus.websockets.next.WebSocketServerException;
 import io.quarkus.websockets.next.runtime.spi.security.WebSocketIdentityUpdateRequest;
-import io.smallrye.mutiny.Uni;
 import io.vertx.ext.web.RoutingContext;
 
 public final class SecuritySupport {
@@ -26,13 +24,11 @@ public final class SecuritySupport {
     static final SecuritySupport NOOP = new SecuritySupport(null, null, null);
 
     private final RoutingContext routingContext;
-    private final WebSocketConnectionImpl connection;
     private volatile SecurityIdentity identity;
     private volatile Runnable onClose;
 
     SecuritySupport(SecurityIdentity identity, WebSocketConnectionImpl connection, RoutingContext routingContext) {
         this.identity = identity;
-        this.connection = connection;
         this.onClose = closeConnectionWhenIdentityExpired(routingContext, connection, this.identity);
         this.routingContext = routingContext;
     }
@@ -47,40 +43,6 @@ SecurityIdentity getIdentity() {
         return identity;
     }
 
-    /**
-     * Using deferred identity may be necessary as a fallback if and only if the {@link #getIdentity()} is not available.
-     * We should prefer the resolved identity because we detect the identity expiration there.
-     * The reason why we need it is that only deferred identity may be available with disabled proactive authentication
-     * when the identity is not required during the HTTP upgrade. We should not authenticate proactively unless something
-     * requires the authentication.
-     *
-     * @return deferred identity (the `Uni` item can be null) or null
-     */
-    Uni<SecurityIdentity> getDeferredIdentity() {
-        if (routingContext == null) {
-            return null;
-        }
-        Uni<SecurityIdentity> deferredIdentity = routingContext.get(DEFERRED_IDENTITY_KEY);
-        if (deferredIdentity == null) {
-            return null;
-        }
-        return deferredIdentity.map(resolvedIdentity -> {
-            if (resolvedIdentity != null && !resolvedIdentity.isAnonymous()) {
-                if (resolvedIdentity.getAttribute(QUARKUS_IDENTITY_EXPIRE_TIME) instanceof Long expireAt) {
-                    boolean isExpired = (TimeUnit.SECONDS.toMillis(expireAt) - System.currentTimeMillis()) <= 0;
-                    if (isExpired) {
-                        routingContext.remove(DEFERRED_IDENTITY_KEY);
-                        return null;
-                    }
-                }
-
-                this.identity = resolvedIdentity;
-                this.onClose = closeConnectionWhenIdentityExpired(routingContext, connection, resolvedIdentity);
-            }
-            return resolvedIdentity;
-        });
-    }
-
     CompletionStage<SecurityIdentity> updateSecurityIdentity(String accessToken, WebSocketConnectionImpl connection,
             IdentityProviderManager identityProviderManager) {
         var authenticationRequest = new WebSocketIdentityUpdateRequest(new TokenCredential(accessToken, "bearer"),
diff --git a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketSecurityIdentityAssociation.java b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketSecurityIdentityAssociation.java
index dcc97bff741..85aa24df2be 100644
--- a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketSecurityIdentityAssociation.java
+++ b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketSecurityIdentityAssociation.java
@@ -5,7 +5,6 @@
 
 import org.eclipse.microprofile.config.inject.ConfigProperty;
 
-import io.quarkus.runtime.BlockingOperationControl;
 import io.quarkus.security.identity.CurrentIdentityAssociation;
 import io.quarkus.security.identity.IdentityProviderManager;
 import io.quarkus.security.identity.SecurityIdentity;
@@ -49,18 +48,10 @@ public Uni<SecurityIdentity> getDeferredIdentity() {
             return delegate.getDeferredIdentity();
         }
 
-        SecuritySupport securitySupport = getSecuritySupportFromCtx();
-        if (securitySupport != null) {
-            if (securitySupport.getIdentity() != null) {
-                return Uni.createFrom().item(securitySupport.getIdentity());
-            }
-            Uni<SecurityIdentity> deferredIdentity = securitySupport.getDeferredIdentity();
-            if (deferredIdentity != null) {
-                // calling to the delegate should return anonymous identity, so that we avoid NPEs
-                return deferredIdentity.onItem().ifNull().switchTo(delegate::getDeferredIdentity);
-            }
+        SecurityIdentity securityIdentity = getSecurityIdentityFromCtx();
+        if (securityIdentity != null) {
+            return Uni.createFrom().item(securityIdentity);
         }
-
         return delegate.getDeferredIdentity();
     }
 
@@ -82,30 +73,18 @@ public SecurityIdentity getIdentity() {
             return delegate.getIdentity();
         }
 
-        SecuritySupport securitySupport = getSecuritySupportFromCtx();
-        if (securitySupport != null) {
-            if (securitySupport.getIdentity() != null) {
-                return securitySupport.getIdentity();
-            }
-            if (BlockingOperationControl.isBlockingAllowed()) {
-                Uni<SecurityIdentity> deferredIdentity = securitySupport.getDeferredIdentity();
-                if (deferredIdentity != null) {
-                    SecurityIdentity resolvedIdentity = deferredIdentity.await().indefinitely();
-                    if (resolvedIdentity != null) {
-                        return resolvedIdentity;
-                    }
-                }
-            }
+        SecurityIdentity securityIdentity = getSecurityIdentityFromCtx();
+        if (securityIdentity != null) {
+            return securityIdentity;
         }
-
         return delegate.getIdentity();
     }
 
-    private static SecuritySupport getSecuritySupportFromCtx() {
+    private static SecurityIdentity getSecurityIdentityFromCtx() {
         Context context = Vertx.currentContext();
         if (context != null && VertxContext.isDuplicatedContext(context)) {
             if (context.getLocal(ContextSupport.WEB_SOCKET_CONN_KEY) instanceof WebSocketConnectionImpl connection) {
-                return connection.securitySupport();
+                return connection.securitySupport().getIdentity();
             }
         }
         return null;
diff --git a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketServerRecorder.java b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketServerRecorder.java
index 8ce5753d460..cbe4cfc8ba5 100644
--- a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketServerRecorder.java
+++ b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/WebSocketServerRecorder.java
@@ -210,9 +210,6 @@ private static Function<WebSocketConnectionImpl, SecuritySupport> getSecuritySup
             if (ctx.user() instanceof QuarkusHttpUser user) {
                 return connection -> new SecuritySupport(user.getSecurityIdentity(), connection, ctx);
             }
-            if (ctx.get(QuarkusHttpUser.DEFERRED_IDENTITY_KEY) != null) {
-                return connection -> new SecuritySupport(null, connection, ctx);
-            }
         }
         return ignored -> SecuritySupport.NOOP;
     }
diff --git a/independent-projects/bootstrap/app-model/src/main/java/io/quarkus/maven/dependency/ResolvedArtifactDependency.java b/independent-projects/bootstrap/app-model/src/main/java/io/quarkus/maven/dependency/ResolvedArtifactDependency.java
index 348f2cfc624..5eb65b167c3 100644
--- a/independent-projects/bootstrap/app-model/src/main/java/io/quarkus/maven/dependency/ResolvedArtifactDependency.java
+++ b/independent-projects/bootstrap/app-model/src/main/java/io/quarkus/maven/dependency/ResolvedArtifactDependency.java
@@ -104,7 +104,7 @@ public boolean equals(Object obj) {
             return false;
         if (!(obj instanceof ResolvableDependency other))
             return false;
-        return Objects.equals(module, other.getWorkspaceModule()) && Objects.equals(paths, other.getResolvedPaths());
+        return Objects.equals(paths, other.getResolvedPaths()) && Objects.equals(module, other.getWorkspaceModule());
     }
 
     @Override
diff --git a/integration-tests/oidc-tenancy/src/test/java/io/quarkus/it/keycloak/TestSecurityWebSocketsNextTest.java b/integration-tests/oidc-tenancy/src/test/java/io/quarkus/it/keycloak/TestSecurityWebSocketsNextTest.java
deleted file mode 100644
index 59b5726d202..00000000000
--- a/integration-tests/oidc-tenancy/src/test/java/io/quarkus/it/keycloak/TestSecurityWebSocketsNextTest.java
+++ /dev/null
@@ -1,259 +0,0 @@
-package io.quarkus.it.keycloak;
-
-import static io.quarkus.it.keycloak.AnnotationBasedTenantTest.getTokenWithRole;
-import static org.junit.jupiter.api.Assertions.assertInstanceOf;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-
-import java.net.URI;
-import java.util.List;
-import java.util.concurrent.CopyOnWriteArrayList;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicReference;
-
-import jakarta.annotation.security.RolesAllowed;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Assertions;
-import org.junit.jupiter.api.Test;
-
-import io.quarkus.oidc.Tenant;
-import io.quarkus.security.Authenticated;
-import io.quarkus.security.ForbiddenException;
-import io.quarkus.security.PermissionChecker;
-import io.quarkus.security.PermissionsAllowed;
-import io.quarkus.security.identity.SecurityIdentity;
-import io.quarkus.test.common.http.TestHTTPResource;
-import io.quarkus.test.junit.QuarkusTest;
-import io.quarkus.test.security.TestSecurity;
-import io.quarkus.websockets.next.OnError;
-import io.quarkus.websockets.next.OnOpen;
-import io.quarkus.websockets.next.OnTextMessage;
-import io.quarkus.websockets.next.WebSocket;
-import io.vertx.core.Vertx;
-import io.vertx.core.http.HttpHeaders;
-import io.vertx.core.http.UpgradeRejectedException;
-import io.vertx.core.http.WebSocketClient;
-import io.vertx.core.http.WebSocketConnectOptions;
-
-@QuarkusTest
-public class TestSecurityWebSocketsNextTest {
-
-    @TestHTTPResource("/ws/echo/authenticated-http-upgrade")
-    URI authenticatedHttpUpgradeUri;
-
-    @TestHTTPResource("/ws/echo/payload-authorization")
-    URI payloadAuthorizationUri;
-
-    @TestHTTPResource("/ws/echo/security-identity-injection")
-    URI securityIdentityInjectionUri;
-
-    @TestHTTPResource("/ws/echo/authorized-security-identity-injection")
-    URI authorizedSecurityIdentityInjectionUri;
-
-    @Inject
-    Vertx vertx;
-
-    @Test
-    @TestSecurity(user = "Martin")
-    public void testHttpUpgradeAuthenticated() throws ExecutionException, InterruptedException, TimeoutException {
-        callWebSocketEndpoint(false, authenticatedHttpUpgradeUri);
-    }
-
-    @Test
-    public void testHttpUpgradeAuthenticated_failure() {
-        RuntimeException actualFailure = assertThrows(RuntimeException.class,
-                () -> callWebSocketEndpoint(true, authenticatedHttpUpgradeUri));
-        assertInstanceOf(UpgradeRejectedException.class, actualFailure.getCause());
-    }
-
-    @Test
-    @TestSecurity(user = "Martin")
-    public void testPayloadAuthorization() throws ExecutionException, InterruptedException, TimeoutException {
-        callWebSocketEndpoint(false, payloadAuthorizationUri);
-    }
-
-    @Test
-    @TestSecurity(user = "Martin")
-    public void testPayloadAuthorization_failure() throws ExecutionException, InterruptedException, TimeoutException {
-        callWebSocketEndpoint(false, payloadAuthorizationUri, "access denied");
-    }
-
-    @Test
-    @TestSecurity(user = "Martin")
-    public void testSecurityIdentityInjection() throws ExecutionException, InterruptedException, TimeoutException {
-        callWebSocketEndpoint(null, false, securityIdentityInjectionUri, "Martin", "Hey");
-    }
-
-    @Test
-    @TestSecurity(user = "Martin", authMechanism = "Bearer")
-    public void testInjectionPoint_bearerTokenMechanism() throws ExecutionException, InterruptedException, TimeoutException {
-        String aliceToken = getTokenWithRole("admin");
-        callWebSocketEndpoint(aliceToken, false, securityIdentityInjectionUri, "alice", "Hey");
-    }
-
-    @Test
-    @TestSecurity(user = "Martin", authMechanism = "Bearer")
-    public void testSecuredInjectionPoint_bearerTokenMechanism()
-            throws ExecutionException, InterruptedException, TimeoutException {
-        // the endpoint is unreachable with 'Martin', because he does not have the 'admin' role
-        // hence we know that the token overrides the @TestSecurity
-        String aliceToken = getTokenWithRole("admin");
-        callWebSocketEndpoint(aliceToken, false, authorizedSecurityIdentityInjectionUri, "alice", "Hey");
-    }
-
-    private void callWebSocketEndpoint(boolean expectFailure, URI endpointURI, String message)
-            throws ExecutionException, InterruptedException, TimeoutException {
-        callWebSocketEndpoint(null, expectFailure, endpointURI, null, message);
-    }
-
-    private void callWebSocketEndpoint(boolean expectFailure, URI endpointURI)
-            throws ExecutionException, InterruptedException, TimeoutException {
-        callWebSocketEndpoint(expectFailure, endpointURI, "hello");
-    }
-
-    private void callWebSocketEndpoint(String token, boolean expectFailure, URI endpointURI, String expectedPrincipal,
-            String expectedMessage) throws InterruptedException, ExecutionException, TimeoutException {
-        CountDownLatch connectedLatch = new CountDownLatch(1);
-        CountDownLatch messagesLatch = new CountDownLatch(2);
-        List<String> messages = new CopyOnWriteArrayList<>();
-        AtomicReference<io.vertx.core.http.WebSocket> ws1 = new AtomicReference<>();
-        WebSocketClient client = vertx.createWebSocketClient();
-        WebSocketConnectOptions options = new WebSocketConnectOptions();
-        options.setHost(endpointURI.getHost());
-        options.setPort(endpointURI.getPort());
-        options.setURI(endpointURI.getPath());
-        if (token != null) {
-            options.addHeader(HttpHeaders.AUTHORIZATION.toString(), "Bearer " + token);
-        }
-        CountDownLatch throwableLatch = new CountDownLatch(1);
-        AtomicReference<Throwable> throwable = new AtomicReference<>();
-        try {
-            var connection = client.connect(options);
-            connection
-                    .onComplete(r -> {
-                        if (r.succeeded()) {
-                            io.vertx.core.http.WebSocket ws = r.result();
-                            ws.textMessageHandler(msg -> {
-                                messages.add(msg);
-                                messagesLatch.countDown();
-                            });
-                            // We will use this socket to write a message later on
-                            ws1.set(ws);
-                            connectedLatch.countDown();
-                        } else {
-                            throwable.set(r.cause());
-                            throwableLatch.countDown();
-                        }
-                    });
-            if (expectFailure) {
-                throwableLatch.await(5, TimeUnit.SECONDS);
-                var cause = throwable.get();
-                if (cause != null) {
-                    throw new RuntimeException(throwable.get());
-                } else {
-                    Assertions.fail("Expected HTTP upgrade failure");
-                }
-            } else {
-                Assertions.assertTrue(connectedLatch.await(5, TimeUnit.SECONDS));
-                ws1.get().writeTextMessage(expectedMessage);
-                Assertions.assertTrue(messagesLatch.await(5, TimeUnit.SECONDS), "Messages: " + messages);
-                Assertions.assertEquals(2, messages.size(), "Messages: " + messages);
-                Assertions.assertEquals("ready", messages.get(0));
-                if (expectedPrincipal != null) {
-                    Assertions.assertEquals("message: " + expectedMessage + " " + expectedPrincipal, messages.get(1));
-                } else {
-                    Assertions.assertEquals("message: " + expectedMessage, messages.get(1));
-                }
-                ws1.get().close();
-            }
-        } finally {
-            if (ws1.get() != null && !ws1.get().isClosed()) {
-                ws1.get().close();
-            }
-            client.close().toCompletionStage().toCompletableFuture().get(5, TimeUnit.SECONDS);
-        }
-    }
-
-    @Authenticated
-    @WebSocket(path = "/ws/echo/authenticated-http-upgrade")
-    public static class AuthenticatedHttpUpgradeEndpoint {
-
-        @OnOpen
-        String open() {
-            return "ready";
-        }
-
-        @OnTextMessage
-        String echo(String message) {
-            return "message: " + message;
-        }
-
-    }
-
-    @WebSocket(path = "/ws/echo/payload-authorization")
-    public static class PayloadAuthorizationEndpoint {
-
-        @OnOpen
-        String open() {
-            return "ready";
-        }
-
-        @PermissionsAllowed("canReadMessage")
-        @OnTextMessage
-        String echo(String message) {
-            return "message: " + message;
-        }
-
-        @PermissionChecker("canReadMessage")
-        boolean canReadMessage(String message) {
-            return "hello".equals(message);
-        }
-
-        @OnError
-        String onError(ForbiddenException forbiddenException) {
-            return "message: access denied";
-        }
-    }
-
-    @Tenant("tenant-public-key")
-    @WebSocket(path = "/ws/echo/security-identity-injection")
-    public static class SecurityIdentityInjectionEndpoint {
-
-        @Inject
-        SecurityIdentity securityIdentity;
-
-        @OnOpen
-        String open() {
-            return "ready";
-        }
-
-        @OnTextMessage
-        String echo(String message) {
-            return "message: " + message + " " + securityIdentity.getPrincipal().getName();
-        }
-
-    }
-
-    @RolesAllowed("admin")
-    @Tenant("tenant-public-key")
-    @WebSocket(path = "/ws/echo/authorized-security-identity-injection")
-    public static class AuthorizedSecurityIdentityInjectionEndpoint {
-
-        @Inject
-        SecurityIdentity securityIdentity;
-
-        @OnOpen
-        String open() {
-            return "ready";
-        }
-
-        @OnTextMessage
-        String echo(String message) {
-            return "message: " + message + " " + securityIdentity.getPrincipal().getName();
-        }
-
-    }
-}
diff --git a/test-framework/security/src/main/java/io/quarkus/test/security/QuarkusSecurityTestExtension.java b/test-framework/security/src/main/java/io/quarkus/test/security/QuarkusSecurityTestExtension.java
index 38ee46f16bc..13856c5c2e2 100644
--- a/test-framework/security/src/main/java/io/quarkus/test/security/QuarkusSecurityTestExtension.java
+++ b/test-framework/security/src/main/java/io/quarkus/test/security/QuarkusSecurityTestExtension.java
@@ -18,17 +18,16 @@
 import java.util.stream.Stream;
 
 import jakarta.enterprise.inject.Instance;
+import jakarta.enterprise.inject.spi.CDI;
 
 import io.quarkus.arc.Arc;
 import io.quarkus.arc.ArcContainer;
 import io.quarkus.security.StringPermission;
-import io.quarkus.security.identity.AuthenticationRequestContext;
 import io.quarkus.security.identity.SecurityIdentity;
 import io.quarkus.security.identity.SecurityIdentityAugmentor;
 import io.quarkus.security.runtime.QuarkusPermissionSecurityIdentityAugmentor;
 import io.quarkus.security.runtime.QuarkusPrincipal;
 import io.quarkus.security.runtime.QuarkusSecurityIdentity;
-import io.quarkus.security.spi.runtime.BlockingSecurityExecutor;
 import io.quarkus.test.junit.callback.QuarkusTestAfterEachCallback;
 import io.quarkus.test.junit.callback.QuarkusTestBeforeEachCallback;
 import io.quarkus.test.junit.callback.QuarkusTestMethodContext;
@@ -68,7 +67,7 @@ public void beforeEach(QuarkusTestMethodContext context) {
             }
             Annotation[] allAnnotations = testSecurityContext.allAnnotations();
             TestSecurity testSecurity = testSecurityContext.annotationContainer.getAnnotation();
-            final ArcContainer container = Arc.requireContainer();
+            final ArcContainer container = Arc.container();
             container.select(TestAuthController.class).get().setEnabled(testSecurity.authorizationEnabled());
             if (testSecurity.user().isEmpty()) {
                 if (testSecurity.roles().length != 0) {
@@ -91,7 +90,7 @@ public void beforeEach(QuarkusTestMethodContext context) {
                             .collect(Collectors.toMap(s -> s.key(), s -> s.type().convert(s.value()))));
                 }
 
-                SecurityIdentity userIdentity = augment(user.build(), allAnnotations, container);
+                SecurityIdentity userIdentity = augment(user.build(), allAnnotations);
                 container.select(TestIdentityAssociation.class).get().setTestIdentity(userIdentity);
                 if (!testSecurity.authMechanism().isEmpty()) {
                     for (var testMechanism : container.select(AbstractTestHttpAuthenticationMechanism.class)) {
@@ -189,26 +188,12 @@ private TestSecurityContext getTestSecurityContext(QuarkusTestMethodContext cont
         return new TestSecurityContext(annotationContainerOptional.orElse(null), null);
     }
 
-    private SecurityIdentity augment(SecurityIdentity identity, Annotation[] annotations, ArcContainer container) {
-        SecurityIdentity augmentedIdentity = identity;
-
-        Instance<TestSecurityIdentityAugmentor> producer = container.select(TestSecurityIdentityAugmentor.class);
+    private SecurityIdentity augment(SecurityIdentity identity, Annotation[] annotations) {
+        Instance<TestSecurityIdentityAugmentor> producer = CDI.current().select(TestSecurityIdentityAugmentor.class);
         if (producer.isResolvable()) {
-            augmentedIdentity = producer.get().augment(identity, annotations);
+            return producer.get().augment(identity, annotations);
         }
-
-        try (var quarkusPermissionAugmentorInstance = container.instance(QuarkusPermissionSecurityIdentityAugmentor.class)) {
-            if (quarkusPermissionAugmentorInstance.isAvailable()) {
-                AuthenticationRequestContext authenticationRequestContext = blockingCode -> container
-                        .select(BlockingSecurityExecutor.class).get().executeBlocking(blockingCode);
-                augmentedIdentity = quarkusPermissionAugmentorInstance.get()
-                        .augment(augmentedIdentity, authenticationRequestContext,
-                                Map.of())
-                        .await().indefinitely();
-            }
-        }
-
-        return augmentedIdentity;
+        return identity;
     }
 
     private record TestSecurityContext(AnnotationContainer<TestSecurity> annotationContainer, Method method) {
diff --git a/test-framework/security/src/main/java/io/quarkus/test/security/TestIdentityAssociation.java b/test-framework/security/src/main/java/io/quarkus/test/security/TestIdentityAssociation.java
index a4d24239831..5ffd9f472a9 100644
--- a/test-framework/security/src/main/java/io/quarkus/test/security/TestIdentityAssociation.java
+++ b/test-framework/security/src/main/java/io/quarkus/test/security/TestIdentityAssociation.java
@@ -8,7 +8,6 @@
 import jakarta.inject.Inject;
 import jakarta.interceptor.Interceptor;
 
-import io.quarkus.arc.Arc;
 import io.quarkus.runtime.LaunchMode;
 import io.quarkus.security.identity.CurrentIdentityAssociation;
 import io.quarkus.security.identity.IdentityProviderManager;
@@ -21,11 +20,13 @@
 @ApplicationScoped
 public class TestIdentityAssociation implements CurrentIdentityAssociation {
 
-    /**
-     * {@link CurrentIdentityAssociation} delegate class name, if some extension needs to declare their own delegate.
-     * The main motivation is the WebSockets Next extension.
-     */
-    private static final String DELEGATE_IDENTITY_ASSOCIATION_KEY = "test.quarkus.test-security.delegate-identity-association";
+    @PostConstruct
+    public void check() {
+        if (LaunchMode.current() != LaunchMode.TEST) {
+            //paranoid check
+            throw new RuntimeException("TestAuthController can only be used in tests");
+        }
+    }
 
     private volatile SecurityIdentity testIdentity;
 
@@ -38,19 +39,8 @@ public class TestIdentityAssociation implements CurrentIdentityAssociation {
      * A request scoped delegate that allows the system to function as normal when
      * the user has not been explicitly overridden
      */
-    private final CurrentIdentityAssociation delegate;
-
-    TestIdentityAssociation(DelegateSecurityIdentityAssociation defaultDelegate) {
-        this.delegate = determineDelegate(defaultDelegate);
-    }
-
-    @PostConstruct
-    public void check() {
-        if (LaunchMode.current() != LaunchMode.TEST) {
-            //paranoid check
-            throw new RuntimeException("TestAuthController can only be used in tests");
-        }
-    }
+    @Inject
+    DelegateSecurityIdentityAssociation delegate;
 
     public SecurityIdentity getTestIdentity() {
         return testIdentity;
@@ -92,33 +82,12 @@ public SecurityIdentity getIdentity() {
                 return testIdentity;
             }
         }
-        return underlying;
+        return delegate.getIdentity();
     }
 
     void setPathBasedIdentity(boolean pathBasedIdentity) {
         isPathBasedIdentity = pathBasedIdentity;
     }
-
-    @SuppressWarnings("unchecked")
-    private static CurrentIdentityAssociation determineDelegate(DelegateSecurityIdentityAssociation defaultDelegate) {
-        String delegateIdentityAssociationClassName = System.getProperty(DELEGATE_IDENTITY_ASSOCIATION_KEY);
-        if (delegateIdentityAssociationClassName != null) {
-            final Class<? extends CurrentIdentityAssociation> delegateClass;
-            try {
-                delegateClass = (Class<? extends CurrentIdentityAssociation>) Thread.currentThread().getContextClassLoader()
-                        .loadClass(delegateIdentityAssociationClassName);
-            } catch (ClassNotFoundException e) {
-                throw new RuntimeException("Failed to load " + delegateIdentityAssociationClassName, e);
-            }
-
-            CurrentIdentityAssociation delegate = Arc.requireContainer().select(delegateClass).orNull();
-            if (delegate == null) {
-                throw new IllegalStateException("CDI bean " + delegateIdentityAssociationClassName + "is not available");
-            }
-            return delegate;
-        }
-        return defaultDelegate;
-    }
 }
 
 @RequestScoped
diff --git a/test-framework/security/src/test/java/io/quarkus/test/security/TestIdentityAssociationTest.java b/test-framework/security/src/test/java/io/quarkus/test/security/TestIdentityAssociationTest.java
index 5d38e463e0f..b1eeb6eab71 100644
--- a/test-framework/security/src/test/java/io/quarkus/test/security/TestIdentityAssociationTest.java
+++ b/test-framework/security/src/test/java/io/quarkus/test/security/TestIdentityAssociationTest.java
@@ -18,7 +18,8 @@ public class TestIdentityAssociationTest {
 
     @BeforeEach
     void init() {
-        sut = new TestIdentityAssociation(new DelegateSecurityIdentityAssociation());
+        sut = new TestIdentityAssociation();
+        sut.delegate = new DelegateSecurityIdentityAssociation();
 
         BlockingOperationControl.setIoThreadDetector(new IOThreadDetector[0]);
     }
