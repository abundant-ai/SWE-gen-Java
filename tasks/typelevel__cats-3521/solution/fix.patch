diff --git a/alleycats-core/src/main/scala/alleycats/std/map.scala b/alleycats-core/src/main/scala/alleycats/std/map.scala
index f7da50e9e..ee8e545ce 100644
--- a/alleycats-core/src/main/scala/alleycats/std/map.scala
+++ b/alleycats-core/src/main/scala/alleycats/std/map.scala
@@ -2,6 +2,7 @@ package alleycats
 package std
 
 import cats._
+import cats.data.Chain
 
 object map extends MapInstances
 
@@ -11,17 +12,12 @@ trait MapInstances {
   implicit def alleycatsStdInstancesForMap[K]: Traverse[Map[K, *]] =
     new Traverse[Map[K, *]] {
 
-      def traverse[G[_], A, B](fa: Map[K, A])(f: A => G[B])(implicit G: Applicative[G]): G[Map[K, B]] = {
-        val gba: Eval[G[Map[K, B]]] = Always(G.pure(Map.empty))
-        val gbb = Foldable
-          .iterateRight(fa, gba) { (kv, lbuf) =>
-            G.map2Eval(f(kv._2), lbuf) { (b, buf) =>
-              buf + (kv._1 -> b)
-            }
-          }
-          .value
-        G.map(gbb)(_.toMap)
-      }
+      def traverse[G[_], A, B](fa: Map[K, A])(f: A => G[B])(implicit G: Applicative[G]): G[Map[K, B]] =
+        if (fa.isEmpty) G.pure(Map.empty[K, B])
+        else
+          G.map(Chain.traverseViaChain(fa.iterator) {
+            case (k, a) => G.map(f(a))((k, _))
+          }) { chain => chain.foldLeft(Map.empty[K, B]) { case (m, (k, b)) => m.updated(k, b) } }
 
       override def map[A, B](fa: Map[K, A])(f: A => B): Map[K, B] =
         fa.map { case (k, a) => (k, f(a)) }
@@ -63,15 +59,15 @@ trait MapInstances {
     new TraverseFilter[Map[K, *]] {
       def traverse: Traverse[Map[K, *]] = alleycatsStdInstancesForMap
 
-      def traverseFilter[G[_], A, B](fa: Map[K, A])(f: A => G[Option[B]])(implicit G: Applicative[G]): G[Map[K, B]] = {
-        val gba: Eval[G[Map[K, B]]] = Always(G.pure(Map.empty))
-        Foldable
-          .iterateRight(fa, gba) { (kv, lbuf) =>
-            G.map2Eval(f(kv._2), lbuf) { (ob, buf) =>
-              ob.fold(buf)(b => buf + (kv._1 -> b))
-            }
-          }
-          .value
-      }
+      def traverseFilter[G[_], A, B](fa: Map[K, A])(f: A => G[Option[B]])(implicit G: Applicative[G]): G[Map[K, B]] =
+        if (fa.isEmpty) G.pure(Map.empty[K, B])
+        else
+          G.map(Chain.traverseFilterViaChain(fa.iterator) {
+            case (k, a) =>
+              G.map(f(a)) { optB =>
+                if (optB.isDefined) Some((k, optB.get))
+                else None
+              }
+          }) { chain => chain.foldLeft(Map.empty[K, B]) { case (m, (k, b)) => m.updated(k, b) } }
     }
 }
diff --git a/core/src/main/scala/cats/data/Chain.scala b/core/src/main/scala/cats/data/Chain.scala
index 5b4a1dbb1..27be28652 100644
--- a/core/src/main/scala/cats/data/Chain.scala
+++ b/core/src/main/scala/cats/data/Chain.scala
@@ -629,6 +629,106 @@ object Chain extends ChainInstances {
   def apply[A](as: A*): Chain[A] =
     fromSeq(as)
 
+  def traverseViaChain[G[_], A, B](iter: Iterator[A])(f: A => G[B])(implicit G: Applicative[G]): G[Chain[B]] =
+    if (!iter.hasNext) G.pure(Chain.nil)
+    else {
+      // we branch out by this factor
+      val width = 128
+      val as = collection.mutable.Buffer[A]()
+      as ++= iter
+      // By making a tree here we don't blow the stack
+      // even if the List is very long
+      // by construction, this is never called with start == end
+      def loop(start: Int, end: Int): Eval[G[Chain[B]]] =
+        if (end - start <= width) {
+          // Here we are at the leafs of the trees
+          // we don't use map2Eval since it is always
+          // at most width in size.
+          var flist = Eval.later(G.map(f(as(end - 1)))(_ :: Nil))
+          var idx = end - 2
+          while (start <= idx) {
+            val a = as(idx)
+            // don't capture a var in the defer
+            val right = flist
+            flist = Eval.defer(G.map2Eval(f(a), right)(_ :: _))
+            idx = idx - 1
+          }
+          flist.map { glist => G.map(glist)(Chain.fromSeq(_)) }
+        } else {
+          // we have width + 1 or more nodes left
+          val step = (end - start) / width
+
+          var fchain = Eval.defer(loop(start, start + step))
+          var start0 = start + step
+          var end0 = start0 + step
+
+          while (start0 < end) {
+            val end1 = math.min(end, end0)
+            val right = loop(start0, end1)
+            fchain = fchain.flatMap(G.map2Eval(_, right)(_.concat(_)))
+            start0 = start0 + step
+            end0 = end0 + step
+          }
+          fchain
+        }
+
+      loop(0, as.size).value
+    }
+
+  def traverseFilterViaChain[G[_], A, B](
+    iter: Iterator[A]
+  )(f: A => G[Option[B]])(implicit G: Applicative[G]): G[Chain[B]] =
+    if (!iter.hasNext) G.pure(Chain.nil)
+    else {
+      // we branch out by this factor
+      val width = 128
+      val as = collection.mutable.Buffer[A]()
+      as ++= iter
+      // By making a tree here we don't blow the stack
+      // even if the List is very long
+      // by construction, this is never called with start == end
+      def loop(start: Int, end: Int): Eval[G[Chain[B]]] =
+        if (end - start <= width) {
+          // Here we are at the leafs of the trees
+          // we don't use map2Eval since it is always
+          // at most width in size.
+          var flist = Eval.later(G.map(f(as(end - 1))) { optB =>
+            if (optB.isDefined) optB.get :: Nil
+            else Nil
+          })
+          var idx = end - 2
+          while (start <= idx) {
+            val a = as(idx)
+            // don't capture a var in the defer
+            val right = flist
+            flist = Eval.defer(G.map2Eval(f(a), right) { (optB, tail) =>
+              if (optB.isDefined) optB.get :: tail
+              else tail
+            })
+            idx = idx - 1
+          }
+          flist.map { glist => G.map(glist)(Chain.fromSeq(_)) }
+        } else {
+          // we have width + 1 or more nodes left
+          val step = (end - start) / width
+
+          var fchain = Eval.defer(loop(start, start + step))
+          var start0 = start + step
+          var end0 = start0 + step
+
+          while (start0 < end) {
+            val end1 = math.min(end, end0)
+            val right = loop(start0, end1)
+            fchain = fchain.flatMap(G.map2Eval(_, right)(_.concat(_)))
+            start0 = start0 + step
+            end0 = end0 + step
+          }
+          fchain
+        }
+
+      loop(0, as.size).value
+    }
+
   // scalastyle:off null
   private class ChainIterator[A](self: Chain[A]) extends Iterator[A] {
     private[this] var c: Chain[A] = if (self.isEmpty) null else self
@@ -761,9 +861,9 @@ sealed abstract private[data] class ChainInstances extends ChainInstances1 {
       }
 
       def traverse[G[_], A, B](fa: Chain[A])(f: A => G[B])(implicit G: Applicative[G]): G[Chain[B]] =
-        foldRight[A, G[Chain[B]]](fa, Always(G.pure(nil))) { (a, lglb) =>
-          G.map2Eval(f(a), lglb)(_ +: _)
-        }.value
+        if (fa.isEmpty) G.pure(Chain.nil)
+        else traverseViaChain(fa.iterator)(f)
+
       def empty[A]: Chain[A] = Chain.nil
       def combineK[A](c: Chain[A], c2: Chain[A]): Chain[A] = Chain.concat(c, c2)
       def pure[A](a: A): Chain[A] = Chain.one(a)
@@ -862,9 +962,8 @@ sealed abstract private[data] class ChainInstances extends ChainInstances1 {
     override def flattenOption[A](fa: Chain[Option[A]]): Chain[A] = fa.collect { case Some(a) => a }
 
     def traverseFilter[G[_], A, B](fa: Chain[A])(f: A => G[Option[B]])(implicit G: Applicative[G]): G[Chain[B]] =
-      traverse
-        .foldRight(fa, Eval.now(G.pure(Chain.empty[B])))((x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o)))
-        .value
+      if (fa.isEmpty) G.pure(Chain.nil)
+      else traverseFilterViaChain(fa.iterator)(f)
 
     override def filterA[G[_], A](fa: Chain[A])(f: A => G[Boolean])(implicit G: Applicative[G]): G[Chain[A]] =
       traverse
diff --git a/core/src/main/scala/cats/instances/list.scala b/core/src/main/scala/cats/instances/list.scala
index a0b271920..7d59d5413 100644
--- a/core/src/main/scala/cats/instances/list.scala
+++ b/core/src/main/scala/cats/instances/list.scala
@@ -1,7 +1,7 @@
 package cats
 package instances
 
-import cats.data.ZipList
+import cats.data.{Chain, ZipList}
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -83,14 +83,9 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
         loop(fa).value
       }
 
-      def traverse[G[_], A, B](fa: List[A])(f: A => G[B])(implicit G: Applicative[G]): G[List[B]] = {
-        def loop(fa: List[A]): Eval[G[List[B]]] =
-          fa match {
-            case h :: t => G.map2Eval(f(h), Eval.defer(loop(t)))(_ :: _)
-            case Nil    => Eval.now(G.pure(Nil))
-          }
-        loop(fa).value
-      }
+      def traverse[G[_], A, B](fa: List[A])(f: A => G[B])(implicit G: Applicative[G]): G[List[B]] =
+        if (fa.isEmpty) G.pure(Nil)
+        else G.map(Chain.traverseViaChain(fa.iterator)(f))(_.toList)
 
       def functor: Functor[List] = this
 
@@ -214,9 +209,8 @@ private[instances] trait ListInstancesBinCompat0 {
     override def flattenOption[A](fa: List[Option[A]]): List[A] = fa.flatten
 
     def traverseFilter[G[_], A, B](fa: List[A])(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[List[B]] =
-      traverse
-        .foldRight(fa, Eval.now(G.pure(List.empty[B])))((x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ :: o)))
-        .value
+      if (fa.isEmpty) G.pure(Nil)
+      else G.map(Chain.traverseFilterViaChain(fa.iterator)(f))(_.toList)
 
     override def filterA[G[_], A](fa: List[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[List[A]] =
       traverse
diff --git a/core/src/main/scala/cats/instances/queue.scala b/core/src/main/scala/cats/instances/queue.scala
index c65efa056..c75761d25 100644
--- a/core/src/main/scala/cats/instances/queue.scala
+++ b/core/src/main/scala/cats/instances/queue.scala
@@ -1,6 +1,7 @@
 package cats
 package instances
 
+import cats.data.Chain
 import cats.syntax.show._
 import scala.annotation.tailrec
 import scala.collection.immutable.Queue
@@ -79,9 +80,11 @@ trait QueueInstances extends cats.kernel.instances.QueueInstances {
         B.combineAll(fa.iterator.map(f))
 
       def traverse[G[_], A, B](fa: Queue[A])(f: A => G[B])(implicit G: Applicative[G]): G[Queue[B]] =
-        foldRight[A, G[Queue[B]]](fa, Always(G.pure(Queue.empty))) { (a, lglb) =>
-          G.map2Eval(f(a), lglb)(_ +: _)
-        }.value
+        if (fa.isEmpty) G.pure(Queue.empty[B])
+        else
+          G.map(Chain.traverseViaChain(fa.iterator)(f)) { chain =>
+            chain.foldLeft(Queue.empty[B])(_ :+ _)
+          }
 
       override def mapWithIndex[A, B](fa: Queue[A])(f: (A, Int) => B): Queue[B] = {
         val b = Queue.newBuilder[B]
@@ -172,9 +175,11 @@ private object QueueInstances {
     override def flattenOption[A](fa: Queue[Option[A]]): Queue[A] = fa.flatten
 
     def traverseFilter[G[_], A, B](fa: Queue[A])(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Queue[B]] =
-      traverse
-        .foldRight(fa, Eval.now(G.pure(Queue.empty[B])))((x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o)))
-        .value
+      if (fa.isEmpty) G.pure(Queue.empty[B])
+      else
+        G.map(Chain.traverseFilterViaChain(fa.iterator)(f)) { chain =>
+          chain.foldLeft(Queue.empty[B])(_ :+ _)
+        }
 
     override def filterA[G[_], A](fa: Queue[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Queue[A]] =
       traverse
diff --git a/core/src/main/scala/cats/instances/sortedMap.scala b/core/src/main/scala/cats/instances/sortedMap.scala
index 108f38cf9..6d24ccf8d 100644
--- a/core/src/main/scala/cats/instances/sortedMap.scala
+++ b/core/src/main/scala/cats/instances/sortedMap.scala
@@ -1,7 +1,7 @@
 package cats.instances
 
 import cats._
-import cats.data.Ior
+import cats.data.{Chain, Ior}
 import cats.kernel.{CommutativeMonoid, CommutativeSemigroup}
 
 import scala.annotation.tailrec
@@ -32,14 +32,12 @@ trait SortedMapInstances extends SortedMapInstances2 {
     new Traverse[SortedMap[K, *]] with FlatMap[SortedMap[K, *]] with Align[SortedMap[K, *]] {
 
       def traverse[G[_], A, B](fa: SortedMap[K, A])(f: A => G[B])(implicit G: Applicative[G]): G[SortedMap[K, B]] = {
-        val gba: Eval[G[SortedMap[K, B]]] = Always(G.pure(SortedMap.empty(fa.ordering)))
-        Foldable
-          .iterateRight(fa, gba) { (kv, lbuf) =>
-            G.map2Eval(f(kv._2), lbuf) { (b, buf) =>
-              buf + (kv._1 -> b)
-            }
-          }
-          .value
+        implicit val ordering: Ordering[K] = fa.ordering
+        if (fa.isEmpty) G.pure(SortedMap.empty[K, B])
+        else
+          G.map(Chain.traverseViaChain(fa.iterator) {
+            case (k, a) => G.map(f(a))((k, _))
+          }) { chain => chain.foldLeft(SortedMap.empty[K, B]) { case (m, (k, b)) => m.updated(k, b) } }
       }
 
       def flatMap[A, B](fa: SortedMap[K, A])(f: A => SortedMap[K, B]): SortedMap[K, B] = {
@@ -193,14 +191,16 @@ private[instances] trait SortedMapInstancesBinCompat0 {
       override def traverseFilter[G[_], A, B](
         fa: SortedMap[K, A]
       )(f: A => G[Option[B]])(implicit G: Applicative[G]): G[SortedMap[K, B]] = {
-        val gba: Eval[G[SortedMap[K, B]]] = Always(G.pure(SortedMap.empty(fa.ordering)))
-        Foldable
-          .iterateRight(fa, gba) { (kv, lbuf) =>
-            G.map2Eval(f(kv._2), lbuf) { (ob, buf) =>
-              ob.fold(buf)(b => buf + (kv._1 -> b))
-            }
-          }
-          .value
+        implicit val ordering: Ordering[K] = fa.ordering
+        if (fa.isEmpty) G.pure(SortedMap.empty[K, B])
+        else
+          G.map(Chain.traverseFilterViaChain(fa.iterator) {
+            case (k, a) =>
+              G.map(f(a)) { optB =>
+                if (optB.isDefined) Some((k, optB.get))
+                else None
+              }
+          }) { chain => chain.foldLeft(SortedMap.empty[K, B]) { case (m, (k, b)) => m.updated(k, b) } }
       }
 
       override def mapFilter[A, B](fa: SortedMap[K, A])(f: A => Option[B]): SortedMap[K, B] = {
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index e5828c9f7..a07669834 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -1,7 +1,7 @@
 package cats
 package instances
 
-import cats.data.ZipVector
+import cats.data.{Chain, ZipVector}
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -90,11 +90,53 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
         loop(0).value
       }
 
-      final override def traverse[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: Applicative[G]): G[Vector[B]] = {
-        def loop(i: Int): Eval[G[List[B]]] =
-          if (i < fa.length) G.map2Eval(f(fa(i)), Eval.defer(loop(i + 1)))(_ :: _) else Eval.now(G.pure(Nil))
-        G.map(loop(0).value)(_.toVector)
-      }
+      final override def traverse[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: Applicative[G]): G[Vector[B]] =
+        if (fa.isEmpty) G.pure(empty)
+        else {
+          // this is a specialized version of Chain.traverseViaChain since
+          // we don't need to materialize the Vector first
+
+          // we branch out by this factor
+          val width = 128
+          // By making a tree here we don't blow the stack
+          // even if the List is very long
+          // by construction, this is never called with start == end
+          def loop(start: Int, end: Int): Eval[G[Chain[B]]] =
+            if (end - start <= width) {
+              // Here we are at the leafs of the trees
+              // we don't use map2Eval since it is always
+              // at most width in size.
+              val aend = fa(end - 1)
+              var flist = Eval.later(G.map(f(aend))(_ :: Nil))
+              var idx = end - 2
+              while (start <= idx) {
+                val a = fa(idx)
+                // don't capture a var in the defer
+                val right = flist
+                flist = Eval.defer(G.map2Eval(f(a), right)(_ :: _))
+                idx = idx - 1
+              }
+              flist.map { glist => G.map(glist)(Chain.fromSeq(_)) }
+            } else {
+              // we have width + 1 or more nodes left
+              val step = (end - start) / width
+
+              var fchain = Eval.defer(loop(start, start + step))
+              var start0 = start + step
+              var end0 = start0 + step
+
+              while (start0 < end) {
+                val end1 = math.min(end, end0)
+                val right = loop(start0, end1)
+                fchain = fchain.flatMap(G.map2Eval(_, right)(_.concat(_)))
+                start0 = start0 + step
+                end0 = end0 + step
+              }
+              fchain
+            }
+
+          G.map(loop(0, fa.size).value)(_.toVector)
+        }
 
       override def mapWithIndex[A, B](fa: Vector[A])(f: (A, Int) => B): Vector[B] =
         fa.iterator.zipWithIndex.map(ai => f(ai._1, ai._2)).toVector
@@ -181,11 +223,55 @@ private[instances] trait VectorInstancesBinCompat0 {
     override def flattenOption[A](fa: Vector[Option[A]]): Vector[A] = fa.flatten
 
     def traverseFilter[G[_], A, B](fa: Vector[A])(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Vector[B]] =
-      traverse
-        .foldRight(fa, Eval.now(G.pure(Vector.empty[B])))((x, xse) =>
-          G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o))
-        )
-        .value
+      if (fa.isEmpty) G.pure(Vector.empty[B])
+      else {
+        // we branch out by this factor
+        val width = 128
+        // By making a tree here we don't blow the stack
+        // even if the List is very long
+        // by construction, this is never called with start == end
+        def loop(start: Int, end: Int): Eval[G[Chain[B]]] =
+          if (end - start <= width) {
+            // Here we are at the leafs of the trees
+            // we don't use map2Eval since it is always
+            // at most width in size.
+            val aend = fa(end - 1)
+            var flist = Eval.later(G.map(f(aend)) { optB =>
+              if (optB.isDefined) optB.get :: Nil
+              else Nil
+            })
+            var idx = end - 2
+            while (start <= idx) {
+              val a = fa(idx)
+              // don't capture a var in the defer
+              val right = flist
+              flist = Eval.defer(G.map2Eval(f(a), right) { (optB, tail) =>
+                if (optB.isDefined) optB.get :: tail
+                else tail
+              })
+              idx = idx - 1
+            }
+            flist.map { glist => G.map(glist)(Chain.fromSeq(_)) }
+          } else {
+            // we have width + 1 or more nodes left
+            val step = (end - start) / width
+
+            var fchain = Eval.defer(loop(start, start + step))
+            var start0 = start + step
+            var end0 = start0 + step
+
+            while (start0 < end) {
+              val end1 = math.min(end, end0)
+              val right = loop(start0, end1)
+              fchain = fchain.flatMap(G.map2Eval(_, right)(_.concat(_)))
+              start0 = start0 + step
+              end0 = end0 + step
+            }
+            fchain
+          }
+
+        G.map(loop(0, fa.size).value)(_.toVector)
+      }
 
     override def filterA[G[_], A](fa: Vector[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Vector[A]] =
       traverse
