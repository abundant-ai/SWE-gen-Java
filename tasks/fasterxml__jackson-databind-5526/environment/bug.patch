diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 3261e7fc7..c8d658e5a 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -131,13 +131,10 @@ Konstantin Labun (@kulabun)
   [3.1.0]
 
 @JacksonJang
- * Contributed fix for #650: `@JsonUnwrapped` prevents checks for
+* Contributed fix for #650: `@JsonUnwrapped` prevents checks for
   `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`
   [3.1.0]
- * Contributed fix for  #1497: Allow skipping `@JsonUnwrapped` values if no properties matched,
-  `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled
-  [3.1.0]
- * Contributed fix for #1516: Problem with multi-argument Creator with
+* Contributed fix for #1516: Problem with multi-argument Creator with
    `@JsonBackReference` property
   [3.1.0]
  * Contributed fix for #2686: `@JsonBackReference` does not work with a builder
@@ -160,11 +157,6 @@ Oliver Drotbohm (@odrotbohm)
  * Contributed #1196: Add opt-in error collection for deserialization
   [3.1.0]
 
-Victor Noël (@victornoel)
- * Requested #1497: Allow skipping `@JsonUnwrapped` values if no properties matched,
-  `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled
- [3.1.0]
-
 Viktor Szathmáry (@phraktle)
  * Reported #5115: `@JsonUnwrapped` Record deserialization can't handle name collision
  (reported by Viktor S)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index f3afb6f62..5cb155ad5 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -18,10 +18,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #1196: Add opt-in error collection for deserialization
  (requested by @odrotbohm)
  (contributed by @sri-adarsh-kumar)
-#1497: Allow skipping `@JsonUnwrapped` values if no properties matched,
-  `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled
- (requested by Victor N)
- (fix by @JacksonJang)
 #1516: Problem with multi-argument Creator with `@JsonBackReference` property
  (reported by @sarahlikesglitter)
  (fix by @JacksonJang)
diff --git a/src/main/java/tools/jackson/databind/DeserializationFeature.java b/src/main/java/tools/jackson/databind/DeserializationFeature.java
index 018340c18..065d3eb02 100644
--- a/src/main/java/tools/jackson/databind/DeserializationFeature.java
+++ b/src/main/java/tools/jackson/databind/DeserializationFeature.java
@@ -116,17 +116,6 @@ public enum DeserializationFeature implements ConfigFeature
      */
     USE_NULL_FOR_MISSING_REFERENCE_VALUES(false),
 
-    /**
-     * Feature that determines whether a POJO property annotated with
-     * {@link com.fasterxml.jackson.annotation.JsonUnwrapped} should remain {@code null}
-     * when no unwrapped properties are found in the input JSON.
-     * <p>
-     * Feature is disabled by default.
-     *
-     * @since 3.1
-     */
-    USE_NULL_FOR_EMPTY_UNWRAPPED(false),
-
     /*
     /**********************************************************************
     /* Error handling features
diff --git a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
index fe502627e..e80191fb0 100644
--- a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
@@ -897,7 +897,6 @@ public class BeanDeserializer
             injectValues(ctxt, bean);
         }
         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;
-        boolean hasUnwrappedContent = false;
 
         for (int ix = p.currentNameMatch(_propNameMatcher); ; ix = p.nextNameMatch(_propNameMatcher)) {
             if (ix >= 0) { // common case
@@ -932,7 +931,6 @@ public class BeanDeserializer
             //    we can do.
             // 19-Dec-2025: [databind#650] We can now distinguish the cases
             if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
-                hasUnwrappedContent = true;
                 tokens.writeName(propName);
                 tokens.copyCurrentStructure(p);
                 continue;
@@ -953,7 +951,7 @@ public class BeanDeserializer
             }
         }
         tokens.writeEndObject();
-        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens, hasUnwrappedContent);
+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
         return bean;
     }
 
@@ -969,8 +967,6 @@ public class BeanDeserializer
         TokenBuffer tokens = ctxt.bufferForInputBuffering(p);
         tokens.writeStartObject();
         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;
-        boolean hasUnwrappedContent = false;
-
         for (int ix = p.currentNameMatch(_propNameMatcher); ; ix = p.nextNameMatch(_propNameMatcher)) {
             if (ix >= 0) { // common case
                 p.nextToken();
@@ -1003,7 +999,6 @@ public class BeanDeserializer
             //    we can do.
             // 19-Dec-2025: [databind#650] We can now distinguish the cases
             if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
-                hasUnwrappedContent = true;
                 tokens.writeName(propName);
                 tokens.copyCurrentStructure(p);
             } else if (_anySetter == null) {
@@ -1021,7 +1016,7 @@ public class BeanDeserializer
             }
         }
         tokens.writeEndObject();
-        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens, hasUnwrappedContent);
+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
         return bean;
     }
 
@@ -1040,7 +1035,6 @@ public class BeanDeserializer
         tokens.writeStartObject();
 
         final boolean isRecord = _beanType.isRecordType();
-        boolean hasUnwrappedContent = false;
         JsonToken t = p.currentToken();
         for (; t == JsonToken.PROPERTY_NAME; t = p.nextToken()) {
             String propName = p.currentName();
@@ -1087,7 +1081,6 @@ public class BeanDeserializer
             // 19-Dec-2025: [databind#650] We can now distinguish the cases
             // but... others should be passed to unwrapped property deserializers
             if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
-                hasUnwrappedContent = true;
                 tokens.writeName(propName);
                 tokens.copyCurrentStructure(p);
             } else if (_anySetter == null) {
@@ -1142,7 +1135,7 @@ public class BeanDeserializer
             return ctxt.reportInputMismatch(_beanType,
                     "Cannot create polymorphic instances with unwrapped values");
         }
-        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens, hasUnwrappedContent);
+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
     }
 
     /*
diff --git a/src/main/java/tools/jackson/databind/deser/bean/BuilderBasedDeserializer.java b/src/main/java/tools/jackson/databind/deser/bean/BuilderBasedDeserializer.java
index 2ce420950..c537cc6ce 100644
--- a/src/main/java/tools/jackson/databind/deser/bean/BuilderBasedDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/bean/BuilderBasedDeserializer.java
@@ -657,8 +657,6 @@ public class BuilderBasedDeserializer
         }
 
         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;
-        boolean hasUnwrappedContent = false;
-
         for (int ix = p.currentNameMatch(_propertyNameMatcher); ; ix = p.nextNameMatch(_propertyNameMatcher)) {
             if (ix >= 0) { // common case
                 p.nextToken();
@@ -687,26 +685,21 @@ public class BuilderBasedDeserializer
                 handleIgnoredProperty(p, ctxt, bean, propName);
                 continue;
             }
-            // 29-Dec-2025: [databind#650] We can avoid buffering and passing to any props
-            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
-                hasUnwrappedContent = true;
-                tokens.writeName(propName);
-                tokens.copyCurrentStructure(p);
-                continue;
-            }
-            // how about any setter?
-            if (_anySetter == null) {
-                handleUnknownVanilla(p, ctxt, bean, propName);
+            // but... others should be passed to unwrapped property deserializers
+            tokens.writeName(propName);
+            tokens.copyCurrentStructure(p);
+            // how about any setter? We'll get copies but...
+            if (_anySetter != null) {
+                try {
+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);
+                } catch (Exception e) {
+                    throw wrapAndThrow(e, bean, propName, ctxt);
+                }
                 continue;
             }
-            try {
-                _anySetter.deserializeAndSet(p, ctxt, bean, propName);
-            } catch (Exception e) {
-                throw wrapAndThrow(e, bean, propName, ctxt);
-            }
         }
         tokens.writeEndObject();
-        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens, hasUnwrappedContent);
+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
     }
 
     protected Object deserializeWithUnwrapped(JsonParser p,
@@ -714,8 +707,6 @@ public class BuilderBasedDeserializer
         throws JacksonException
     {
         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;
-        boolean hasUnwrappedContent = false;
-
         for (int ix = p.currentNameMatch(_propertyNameMatcher); ; ix = p.nextNameMatch(_propertyNameMatcher)) {
             if (ix >= 0) { // common case
                 p.nextToken();
@@ -743,22 +734,16 @@ public class BuilderBasedDeserializer
                 handleIgnoredProperty(p, ctxt, builder, propName);
                 continue;
             }
-            // 29-Dec-2025: [databind#650] We can avoid buffering and passing to any props
-            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
-                hasUnwrappedContent = true;
-                tokens.writeName(propName);
-                tokens.copyCurrentStructure(p);
-                continue;
-            }
-            // how about any setter?
-            if (_anySetter == null) {
-                handleUnknownVanilla(p, ctxt, builder, propName);
-                continue;
+            // but... others should be passed to unwrapped property deserializers
+            tokens.writeName(propName);
+            tokens.copyCurrentStructure(p);
+            // how about any setter? We'll get copies but...
+            if (_anySetter != null) {
+                _anySetter.deserializeAndSet(p, ctxt, builder, propName);
             }
-            _anySetter.deserializeAndSet(p, ctxt, builder, propName);
         }
         tokens.writeEndObject();
-        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, builder, tokens, hasUnwrappedContent);
+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, builder, tokens);
     }
 
     @SuppressWarnings("resource")
@@ -772,7 +757,6 @@ public class BuilderBasedDeserializer
         TokenBuffer tokens = ctxt.bufferForInputBuffering(p);
         tokens.writeStartObject();
 
-        boolean hasUnwrappedContent = false;
         JsonToken t = p.currentToken();
         for (; t == JsonToken.PROPERTY_NAME; t = p.nextToken()) {
             String propName = p.currentName();
@@ -818,19 +802,12 @@ public class BuilderBasedDeserializer
                 handleIgnoredProperty(p, ctxt, handledType(), propName);
                 continue;
             }
-            // 29-Dec-2025: [databind#650] We can avoid buffering and passing to any props
-            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
-                hasUnwrappedContent = true;
-                tokens.writeName(propName);
-                tokens.copyCurrentStructure(p);
-                continue;
-            }
-            // how about any setter?
-            if (_anySetter == null) {
-                handleUnknownVanilla(p, ctxt, null, propName);
-                continue;
+            tokens.writeName(propName);
+            tokens.copyCurrentStructure(p);
+            // "any property"?
+            if (_anySetter != null) {
+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
             }
-            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
         }
         tokens.writeEndObject();
 
@@ -842,7 +819,7 @@ public class BuilderBasedDeserializer
             return wrapInstantiationProblem(ctxt, e);
 
         }
-        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, builder, tokens, hasUnwrappedContent);
+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, builder, tokens);
     }
 
     /*
diff --git a/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java b/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java
index 3452c0c2c..7bf17def7 100644
--- a/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java
+++ b/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java
@@ -4,7 +4,6 @@ import java.util.*;
 
 import tools.jackson.core.*;
 import tools.jackson.databind.DeserializationContext;
-import tools.jackson.databind.DeserializationFeature;
 import tools.jackson.databind.PropertyName;
 import tools.jackson.databind.ValueDeserializer;
 import tools.jackson.databind.deser.SettableBeanProperty;
@@ -129,44 +128,17 @@ public class UnwrappedPropertyHandler
         return values;
     }
 
-    /**
-     * Processes unwrapped properties from the buffered token stream.
-     *
-     * @param originalParser Parser from which input was originally read
-     * @param ctxt Deserialization context
-     * @param bean the target value object
-     * @param buffered the token buffer containing the JSON tokens to deserialize
-     *
-     * @return the bean with unwrapped properties set
-     *
-     * @since 3.1
-     */
+    @SuppressWarnings("resource")
     public Object processUnwrapped(JsonParser originalParser, DeserializationContext ctxt,
-            Object bean, TokenBuffer buffered, boolean hasUnwrappedContent)
+            Object bean, TokenBuffer buffered)
     {
-        if (hasUnwrappedContent
-                || _unwrappedPropertyNames.isEmpty()
-                // [databind#1709]: Skip deserialization if no unwrapped content.
-                || !ctxt.isEnabled(DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED)) {
-            for (SettableBeanProperty prop : _properties) {
-                try (JsonParser p = buffered.asParserOnFirstToken(ctxt)) {
-                    prop.deserializeAndSet(p, ctxt, bean);
-                }
-            }
+        for (SettableBeanProperty prop : _properties) {
+            JsonParser p = buffered.asParserOnFirstToken(ctxt);
+            prop.deserializeAndSet(p, ctxt, bean);
         }
         return bean;
     }
 
-    // !!! TODO: remove from 3.2 or later (internal API)
-    /**
-     * @deprecated Since 3.1 use {@link #processUnwrapped(JsonParser, DeserializationContext, Object, TokenBuffer, boolean)}
-     */
-    @Deprecated // @since 3.1
-    public Object processUnwrapped(JsonParser originalParser, DeserializationContext ctxt,
-            Object bean, TokenBuffer buffered) {
-        return processUnwrapped(originalParser, ctxt, bean, buffered, true);
-    }
-
     /**
      * Generates a placeholder name for creator properties that don't have a name,
      * but are marked with `@JsonUnwrapped` annotation.
diff --git a/src/test/java/tools/jackson/databind/struct/UnwrappedWithUnknown650Test.java b/src/test/java/tools/jackson/databind/deser/UnwrappedWithUnknown650Test.java
similarity index 99%
rename from src/test/java/tools/jackson/databind/struct/UnwrappedWithUnknown650Test.java
rename to src/test/java/tools/jackson/databind/deser/UnwrappedWithUnknown650Test.java
index 157af4251..e59332f90 100644
--- a/src/test/java/tools/jackson/databind/struct/UnwrappedWithUnknown650Test.java
+++ b/src/test/java/tools/jackson/databind/deser/UnwrappedWithUnknown650Test.java
@@ -1,4 +1,4 @@
-package tools.jackson.databind.struct;
+package tools.jackson.databind.deser;
 
 import org.junit.jupiter.api.Test;
 
diff --git a/src/test/java/tools/jackson/databind/struct/UnwrappedEmptyAsNull1709Test.java b/src/test/java/tools/jackson/databind/struct/UnwrappedEmptyAsNull1709Test.java
deleted file mode 100644
index 705b9d1e7..000000000
--- a/src/test/java/tools/jackson/databind/struct/UnwrappedEmptyAsNull1709Test.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package tools.jackson.databind.struct;
-
-import org.junit.jupiter.api.Test;
-
-import com.fasterxml.jackson.annotation.*;
-
-import tools.jackson.databind.DeserializationFeature;
-import tools.jackson.databind.ObjectMapper;
-import tools.jackson.databind.testutil.DatabindTestUtil;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertNull;
-
-// https://github.com/FasterXML/jackson-databind/issues/1709
-public class UnwrappedEmptyAsNull1709Test extends DatabindTestUtil
-{
-    @JsonInclude(JsonInclude.Include.NON_DEFAULT)
-    static class Container1709 {
-        public String name;
-        @JsonUnwrapped
-        public Unwrapped1709 u;
-    }
-
-    @JsonInclude(JsonInclude.Include.NON_DEFAULT)
-    static class Unwrapped1709 {
-        public String s;
-        public Integer n;
-    }
-
-    private final ObjectMapper MAPPER_ENABLED = jsonMapperBuilder()
-            .enable(DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED)
-            .build();
-
-    private final ObjectMapper MAPPER_DISABLED = jsonMapperBuilder()
-            .disable(DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED)
-            .build();
-
-    /*
-    /**********************************************************************
-    /* Tests with USE_NULL_FOR_EMPTY_UNWRAPPED enabled
-    /**********************************************************************
-    */
-
-    @Test
-    public void testEmptyUnwrappedAsNull() throws Exception {
-        String json = a2q("{'name':'test'}");
-        Container1709 result = MAPPER_ENABLED.readValue(json, Container1709.class);
-        assertNotNull(result);
-        assertEquals("test", result.name);
-        assertNull(result.u);
-    }
-
-    @Test
-    public void testEmptyJsonEmptyUnwrappedAsNull() throws Exception {
-        Container1709 result = MAPPER_ENABLED.readValue("{}", Container1709.class);
-        assertNotNull(result);
-        assertNull(result.name);
-        assertNull(result.u);
-    }
-
-    @Test
-    public void testNonNullUnwrappedPreserved() throws Exception {
-        String json = a2q("{'name':'test','s':'value'}");
-        Container1709 result = MAPPER_ENABLED.readValue(json, Container1709.class);
-        assertNotNull(result);
-        assertEquals("test", result.name);
-        assertNotNull(result.u);
-        assertEquals("value", result.u.s);
-    }
-
-    @Test
-    public void testPartialNonNullUnwrappedPreserved() throws Exception {
-        String json = a2q("{'s':'value'}");
-        Container1709 result = MAPPER_ENABLED.readValue(json, Container1709.class);
-        assertNotNull(result);
-        assertNotNull(result.u);
-        assertEquals("value", result.u.s);
-        assertNull(result.u.n);
-    }
-
-    /*
-    /**********************************************************************
-    /* Tests with USE_NULL_FOR_EMPTY_UNWRAPPED disabled
-    /**********************************************************************
-    */
-
-    @Test
-    public void testEmptyUnwrappedAsNullWhenDisabled() throws Exception {
-        String json = a2q("{'name':'test'}");
-        Container1709 result = MAPPER_DISABLED.readValue(json, Container1709.class);
-        assertNotNull(result);
-        assertEquals("test", result.name);
-        assertNotNull(result.u);
-        assertNull(result.u.s);
-        assertNull(result.u.n);
-    }
-
-    @Test
-    public void testEmptyJsonEmptyUnwrappedAsNullWhenDisabled() throws Exception {
-        Container1709 result = MAPPER_DISABLED.readValue("{}", Container1709.class);
-        assertNotNull(result);
-        assertNull(result.name);
-        assertNotNull(result.u);
-        assertNull(result.u.s);
-        assertNull(result.u.n);
-    }
-
-    @Test
-    public void testNonNullUnwrappedPreservedWhenDisabled() throws Exception {
-        String json = a2q("{'name':'test','s':'value'}");
-        Container1709 result = MAPPER_DISABLED.readValue(json, Container1709.class);
-        assertNotNull(result);
-        assertEquals("test", result.name);
-        assertNotNull(result.u);
-        assertEquals("value", result.u.s);
-    }
-
-    @Test
-    public void testPartialNonNullUnwrappedPreservedWhenDisabled() throws Exception {
-        String json = a2q("{'s':'value'}");
-        Container1709 result = MAPPER_DISABLED.readValue(json, Container1709.class);
-        assertNull(result.u.n);
-    }
-}
