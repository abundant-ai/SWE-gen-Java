diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index c8d658e5a..3261e7fc7 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -131,10 +131,13 @@ Konstantin Labun (@kulabun)
   [3.1.0]
 
 @JacksonJang
-* Contributed fix for #650: `@JsonUnwrapped` prevents checks for
+ * Contributed fix for #650: `@JsonUnwrapped` prevents checks for
   `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`
   [3.1.0]
-* Contributed fix for #1516: Problem with multi-argument Creator with
+ * Contributed fix for  #1497: Allow skipping `@JsonUnwrapped` values if no properties matched,
+  `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled
+  [3.1.0]
+ * Contributed fix for #1516: Problem with multi-argument Creator with
    `@JsonBackReference` property
   [3.1.0]
  * Contributed fix for #2686: `@JsonBackReference` does not work with a builder
@@ -157,6 +160,11 @@ Oliver Drotbohm (@odrotbohm)
  * Contributed #1196: Add opt-in error collection for deserialization
   [3.1.0]
 
+Victor Noël (@victornoel)
+ * Requested #1497: Allow skipping `@JsonUnwrapped` values if no properties matched,
+  `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled
+ [3.1.0]
+
 Viktor Szathmáry (@phraktle)
  * Reported #5115: `@JsonUnwrapped` Record deserialization can't handle name collision
  (reported by Viktor S)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 5cb155ad5..f3afb6f62 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -18,6 +18,10 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #1196: Add opt-in error collection for deserialization
  (requested by @odrotbohm)
  (contributed by @sri-adarsh-kumar)
+#1497: Allow skipping `@JsonUnwrapped` values if no properties matched,
+  `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled
+ (requested by Victor N)
+ (fix by @JacksonJang)
 #1516: Problem with multi-argument Creator with `@JsonBackReference` property
  (reported by @sarahlikesglitter)
  (fix by @JacksonJang)
diff --git a/src/main/java/tools/jackson/databind/DeserializationFeature.java b/src/main/java/tools/jackson/databind/DeserializationFeature.java
index 065d3eb02..018340c18 100644
--- a/src/main/java/tools/jackson/databind/DeserializationFeature.java
+++ b/src/main/java/tools/jackson/databind/DeserializationFeature.java
@@ -116,6 +116,17 @@ public enum DeserializationFeature implements ConfigFeature
      */
     USE_NULL_FOR_MISSING_REFERENCE_VALUES(false),
 
+    /**
+     * Feature that determines whether a POJO property annotated with
+     * {@link com.fasterxml.jackson.annotation.JsonUnwrapped} should remain {@code null}
+     * when no unwrapped properties are found in the input JSON.
+     * <p>
+     * Feature is disabled by default.
+     *
+     * @since 3.1
+     */
+    USE_NULL_FOR_EMPTY_UNWRAPPED(false),
+
     /*
     /**********************************************************************
     /* Error handling features
diff --git a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
index e80191fb0..fe502627e 100644
--- a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
@@ -897,6 +897,7 @@ public class BeanDeserializer
             injectValues(ctxt, bean);
         }
         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;
+        boolean hasUnwrappedContent = false;
 
         for (int ix = p.currentNameMatch(_propNameMatcher); ; ix = p.nextNameMatch(_propNameMatcher)) {
             if (ix >= 0) { // common case
@@ -931,6 +932,7 @@ public class BeanDeserializer
             //    we can do.
             // 19-Dec-2025: [databind#650] We can now distinguish the cases
             if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
+                hasUnwrappedContent = true;
                 tokens.writeName(propName);
                 tokens.copyCurrentStructure(p);
                 continue;
@@ -951,7 +953,7 @@ public class BeanDeserializer
             }
         }
         tokens.writeEndObject();
-        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens, hasUnwrappedContent);
         return bean;
     }
 
@@ -967,6 +969,8 @@ public class BeanDeserializer
         TokenBuffer tokens = ctxt.bufferForInputBuffering(p);
         tokens.writeStartObject();
         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;
+        boolean hasUnwrappedContent = false;
+
         for (int ix = p.currentNameMatch(_propNameMatcher); ; ix = p.nextNameMatch(_propNameMatcher)) {
             if (ix >= 0) { // common case
                 p.nextToken();
@@ -999,6 +1003,7 @@ public class BeanDeserializer
             //    we can do.
             // 19-Dec-2025: [databind#650] We can now distinguish the cases
             if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
+                hasUnwrappedContent = true;
                 tokens.writeName(propName);
                 tokens.copyCurrentStructure(p);
             } else if (_anySetter == null) {
@@ -1016,7 +1021,7 @@ public class BeanDeserializer
             }
         }
         tokens.writeEndObject();
-        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens, hasUnwrappedContent);
         return bean;
     }
 
@@ -1035,6 +1040,7 @@ public class BeanDeserializer
         tokens.writeStartObject();
 
         final boolean isRecord = _beanType.isRecordType();
+        boolean hasUnwrappedContent = false;
         JsonToken t = p.currentToken();
         for (; t == JsonToken.PROPERTY_NAME; t = p.nextToken()) {
             String propName = p.currentName();
@@ -1081,6 +1087,7 @@ public class BeanDeserializer
             // 19-Dec-2025: [databind#650] We can now distinguish the cases
             // but... others should be passed to unwrapped property deserializers
             if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
+                hasUnwrappedContent = true;
                 tokens.writeName(propName);
                 tokens.copyCurrentStructure(p);
             } else if (_anySetter == null) {
@@ -1135,7 +1142,7 @@ public class BeanDeserializer
             return ctxt.reportInputMismatch(_beanType,
                     "Cannot create polymorphic instances with unwrapped values");
         }
-        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens, hasUnwrappedContent);
     }
 
     /*
diff --git a/src/main/java/tools/jackson/databind/deser/bean/BuilderBasedDeserializer.java b/src/main/java/tools/jackson/databind/deser/bean/BuilderBasedDeserializer.java
index c537cc6ce..2ce420950 100644
--- a/src/main/java/tools/jackson/databind/deser/bean/BuilderBasedDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/bean/BuilderBasedDeserializer.java
@@ -657,6 +657,8 @@ public class BuilderBasedDeserializer
         }
 
         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;
+        boolean hasUnwrappedContent = false;
+
         for (int ix = p.currentNameMatch(_propertyNameMatcher); ; ix = p.nextNameMatch(_propertyNameMatcher)) {
             if (ix >= 0) { // common case
                 p.nextToken();
@@ -685,21 +687,26 @@ public class BuilderBasedDeserializer
                 handleIgnoredProperty(p, ctxt, bean, propName);
                 continue;
             }
-            // but... others should be passed to unwrapped property deserializers
-            tokens.writeName(propName);
-            tokens.copyCurrentStructure(p);
-            // how about any setter? We'll get copies but...
-            if (_anySetter != null) {
-                try {
-                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);
-                } catch (Exception e) {
-                    throw wrapAndThrow(e, bean, propName, ctxt);
-                }
+            // 29-Dec-2025: [databind#650] We can avoid buffering and passing to any props
+            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
+                hasUnwrappedContent = true;
+                tokens.writeName(propName);
+                tokens.copyCurrentStructure(p);
+                continue;
+            }
+            // how about any setter?
+            if (_anySetter == null) {
+                handleUnknownVanilla(p, ctxt, bean, propName);
                 continue;
             }
+            try {
+                _anySetter.deserializeAndSet(p, ctxt, bean, propName);
+            } catch (Exception e) {
+                throw wrapAndThrow(e, bean, propName, ctxt);
+            }
         }
         tokens.writeEndObject();
-        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);
+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens, hasUnwrappedContent);
     }
 
     protected Object deserializeWithUnwrapped(JsonParser p,
@@ -707,6 +714,8 @@ public class BuilderBasedDeserializer
         throws JacksonException
     {
         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;
+        boolean hasUnwrappedContent = false;
+
         for (int ix = p.currentNameMatch(_propertyNameMatcher); ; ix = p.nextNameMatch(_propertyNameMatcher)) {
             if (ix >= 0) { // common case
                 p.nextToken();
@@ -734,16 +743,22 @@ public class BuilderBasedDeserializer
                 handleIgnoredProperty(p, ctxt, builder, propName);
                 continue;
             }
-            // but... others should be passed to unwrapped property deserializers
-            tokens.writeName(propName);
-            tokens.copyCurrentStructure(p);
-            // how about any setter? We'll get copies but...
-            if (_anySetter != null) {
-                _anySetter.deserializeAndSet(p, ctxt, builder, propName);
+            // 29-Dec-2025: [databind#650] We can avoid buffering and passing to any props
+            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
+                hasUnwrappedContent = true;
+                tokens.writeName(propName);
+                tokens.copyCurrentStructure(p);
+                continue;
             }
+            // how about any setter?
+            if (_anySetter == null) {
+                handleUnknownVanilla(p, ctxt, builder, propName);
+                continue;
+            }
+            _anySetter.deserializeAndSet(p, ctxt, builder, propName);
         }
         tokens.writeEndObject();
-        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, builder, tokens);
+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, builder, tokens, hasUnwrappedContent);
     }
 
     @SuppressWarnings("resource")
@@ -757,6 +772,7 @@ public class BuilderBasedDeserializer
         TokenBuffer tokens = ctxt.bufferForInputBuffering(p);
         tokens.writeStartObject();
 
+        boolean hasUnwrappedContent = false;
         JsonToken t = p.currentToken();
         for (; t == JsonToken.PROPERTY_NAME; t = p.nextToken()) {
             String propName = p.currentName();
@@ -802,12 +818,19 @@ public class BuilderBasedDeserializer
                 handleIgnoredProperty(p, ctxt, handledType(), propName);
                 continue;
             }
-            tokens.writeName(propName);
-            tokens.copyCurrentStructure(p);
-            // "any property"?
-            if (_anySetter != null) {
-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
+            // 29-Dec-2025: [databind#650] We can avoid buffering and passing to any props
+            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
+                hasUnwrappedContent = true;
+                tokens.writeName(propName);
+                tokens.copyCurrentStructure(p);
+                continue;
+            }
+            // how about any setter?
+            if (_anySetter == null) {
+                handleUnknownVanilla(p, ctxt, null, propName);
+                continue;
             }
+            buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));
         }
         tokens.writeEndObject();
 
@@ -819,7 +842,7 @@ public class BuilderBasedDeserializer
             return wrapInstantiationProblem(ctxt, e);
 
         }
-        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, builder, tokens);
+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, builder, tokens, hasUnwrappedContent);
     }
 
     /*
diff --git a/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java b/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java
index 7bf17def7..3452c0c2c 100644
--- a/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java
+++ b/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java
@@ -4,6 +4,7 @@ import java.util.*;
 
 import tools.jackson.core.*;
 import tools.jackson.databind.DeserializationContext;
+import tools.jackson.databind.DeserializationFeature;
 import tools.jackson.databind.PropertyName;
 import tools.jackson.databind.ValueDeserializer;
 import tools.jackson.databind.deser.SettableBeanProperty;
@@ -128,17 +129,44 @@ public class UnwrappedPropertyHandler
         return values;
     }
 
-    @SuppressWarnings("resource")
+    /**
+     * Processes unwrapped properties from the buffered token stream.
+     *
+     * @param originalParser Parser from which input was originally read
+     * @param ctxt Deserialization context
+     * @param bean the target value object
+     * @param buffered the token buffer containing the JSON tokens to deserialize
+     *
+     * @return the bean with unwrapped properties set
+     *
+     * @since 3.1
+     */
     public Object processUnwrapped(JsonParser originalParser, DeserializationContext ctxt,
-            Object bean, TokenBuffer buffered)
+            Object bean, TokenBuffer buffered, boolean hasUnwrappedContent)
     {
-        for (SettableBeanProperty prop : _properties) {
-            JsonParser p = buffered.asParserOnFirstToken(ctxt);
-            prop.deserializeAndSet(p, ctxt, bean);
+        if (hasUnwrappedContent
+                || _unwrappedPropertyNames.isEmpty()
+                // [databind#1709]: Skip deserialization if no unwrapped content.
+                || !ctxt.isEnabled(DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED)) {
+            for (SettableBeanProperty prop : _properties) {
+                try (JsonParser p = buffered.asParserOnFirstToken(ctxt)) {
+                    prop.deserializeAndSet(p, ctxt, bean);
+                }
+            }
         }
         return bean;
     }
 
+    // !!! TODO: remove from 3.2 or later (internal API)
+    /**
+     * @deprecated Since 3.1 use {@link #processUnwrapped(JsonParser, DeserializationContext, Object, TokenBuffer, boolean)}
+     */
+    @Deprecated // @since 3.1
+    public Object processUnwrapped(JsonParser originalParser, DeserializationContext ctxt,
+            Object bean, TokenBuffer buffered) {
+        return processUnwrapped(originalParser, ctxt, bean, buffered, true);
+    }
+
     /**
      * Generates a placeholder name for creator properties that don't have a name,
      * but are marked with `@JsonUnwrapped` annotation.
