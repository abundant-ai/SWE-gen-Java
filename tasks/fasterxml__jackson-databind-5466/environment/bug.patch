diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index f74eac913..3699ac071 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -127,15 +127,7 @@ Oliver Drotbohm (@odrotbohm)
  * Contributed fix for #4629: `@JsonIncludeProperties` and `@JsonIgnoreProperties`
   ignored when deserializing Records
   [3.1.0]
- * Contributed fix for #5115: `@JsonUnwrapped` Record deserialization can't handle
-  name collision
-  [3.1.0]
-
-Viktor Szathmáry (@phraktle)
- * Reported #5115: `@JsonUnwrapped` Record deserialization can't handle name collision
- (reported by Viktor S)
-  [3.1.0]
-
+  
 Hélios Gilles (@RoiSoleil)
  * Contributed #5413: Add/support forward reference resolution for array values
   [3.1.0]
diff --git a/release-notes/VERSION b/release-notes/VERSION
index df9871385..e088f4874 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -24,9 +24,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
   creator property" when deserializing JSON with dup property to single-property Record
  (reported by @sseelmann)
  (fix contributed by @JacksonJang)
-#5115: `@JsonUnwrapped` Record deserialization can't handle name collision
- (reported by Viktor S)
- (fix contributed by @JacksonJang)
 #5184: `@JsonIgnore` on record method applied to record matching field
   at deserialization
  (reported by @emouty)
diff --git a/src/main/java/tools/jackson/databind/introspect/POJOPropertiesCollector.java b/src/main/java/tools/jackson/databind/introspect/POJOPropertiesCollector.java
index 25bf4967d..523eaad86 100644
--- a/src/main/java/tools/jackson/databind/introspect/POJOPropertiesCollector.java
+++ b/src/main/java/tools/jackson/databind/introspect/POJOPropertiesCollector.java
@@ -1054,38 +1054,33 @@ ctor.creator()));
             final PropertyName explName = ctor.explicitName(i);
             PropertyName implName = ctor.implicitName(i);
             final boolean hasExplicit = (explName != null);
-            final boolean hasImplicit = (implName != null);
+            final POJOPropertyBuilder prop;
+
+            //  neither implicit nor explicit name?
+            if (!hasExplicit && (implName == null)) {
+                boolean isUnwrapping = _annotationIntrospector.findUnwrappingNameTransformer(_config, param) != null;
 
-            // First: check "Unwrapped" unless explicit name
-            if (!hasExplicit) {
-                var unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(_config, param);
-                if (unwrapper != null) {
+                if (isUnwrapping) {
                     // If unwrapping, can use regardless of name; we will use a placeholder name
                     // anyway to try to avoid name conflicts.
                     PropertyName name = UnwrappedPropertyHandler.creatorParamName(param.getIndex());
-                    final POJOPropertyBuilder prop = _property(props, name);
+                    prop = _property(props, name);
                     prop.addCtor(param, name, false, true, false);
-                    creatorProps.add(prop);
-                    continue;
-                }
-                if (!hasImplicit) {
+                } else {
                     // Without name, cannot make use of this creator parameter -- may or may not
                     // be a problem, verified at a later point.
-                    creatorProps.add(null);
-                    continue;
+                    prop = null;
                 }
-            }
-
-            // 27-Dec-2019, tatu: [databind#2527] may need to rename according to field
-            final POJOPropertyBuilder prop;
-            if (hasImplicit) {
-                String n = _checkRenameByField(implName.getSimpleName());
-                implName = PropertyName.construct(n);
-                prop = _property(props, implName);
             } else {
-                prop = _property(props, explName);
+                // 27-Dec-2019, tatu: [databind#2527] may need to rename according to field
+                if (implName != null) {
+                    String n = _checkRenameByField(implName.getSimpleName());
+                    implName = PropertyName.construct(n);
+                }
+                prop = (implName == null)
+                        ? _property(props, explName) : _property(props, implName);
+                prop.addCtor(param, hasExplicit ? explName : implName, hasExplicit, true, false);
             }
-            prop.addCtor(param, hasExplicit ? explName : implName, hasExplicit, true, false);
             creatorProps.add(prop);
         }
         ctor.assignPropertyDefs(creatorProps);
diff --git a/src/test/java/tools/jackson/databind/records/RecordUnwrapped5115Test.java b/src/test/java/tools/jackson/databind/records/tofix/RecordUnwrapped5115Test.java
similarity index 93%
rename from src/test/java/tools/jackson/databind/records/RecordUnwrapped5115Test.java
rename to src/test/java/tools/jackson/databind/records/tofix/RecordUnwrapped5115Test.java
index b8ac42c30..4c95b54d5 100644
--- a/src/test/java/tools/jackson/databind/records/RecordUnwrapped5115Test.java
+++ b/src/test/java/tools/jackson/databind/records/tofix/RecordUnwrapped5115Test.java
@@ -1,11 +1,11 @@
-package tools.jackson.databind.records;
+package tools.jackson.databind.records.tofix;
 
 import org.junit.jupiter.api.Test;
 
 import com.fasterxml.jackson.annotation.JsonUnwrapped;
-
 import tools.jackson.databind.ObjectMapper;
 import tools.jackson.databind.testutil.DatabindTestUtil;
+import tools.jackson.databind.testutil.failure.JacksonTestFailureExpected;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
@@ -62,6 +62,7 @@ public class RecordUnwrapped5115Test
         assertEquals(input, output);
     }
 
+    @JacksonTestFailureExpected
     @Test
     void unwrappedRecordShouldRoundTrip() throws Exception
     {
