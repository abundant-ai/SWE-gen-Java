diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
index 0bbfe92ab..f20be0990 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
@@ -218,7 +218,6 @@ public final class io/ktor/server/plugins/di/DependencyRegistry : io/ktor/server
 	public fun named (Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 	public final fun require (Lio/ktor/server/plugins/di/DependencyKey;)V
 	public fun set (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function1;)V
-	public final fun validate ()V
 }
 
 public final class io/ktor/server/plugins/di/DependencyRegistryKt {
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
index 91a00b24b..8ce277fdd 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
@@ -233,7 +233,6 @@ final class io.ktor.server.plugins.di/DependencyRegistry : io.ktor.server.plugin
     final fun <#A1: kotlin/Any?> set(io.ktor.server.plugins.di/DependencyKey, kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1>) // io.ktor.server.plugins.di/DependencyRegistry.set|set(io.ktor.server.plugins.di.DependencyKey;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
     final fun contains(io.ktor.server.plugins.di/DependencyKey): kotlin/Boolean // io.ktor.server.plugins.di/DependencyRegistry.contains|contains(io.ktor.server.plugins.di.DependencyKey){}[0]
     final fun require(io.ktor.server.plugins.di/DependencyKey) // io.ktor.server.plugins.di/DependencyRegistry.require|require(io.ktor.server.plugins.di.DependencyKey){}[0]
-    final fun validate() // io.ktor.server.plugins.di/DependencyRegistry.validate|validate(){}[0]
     final inline fun <#A1: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyProvider).provide(kotlin.reflect/KClass<out #A1>) // io.ktor.server.plugins.di/DependencyRegistry.provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
     final inline fun <#A1: reified kotlin/Any?> provide(kotlin/String? = ..., noinline kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1?>) // io.ktor.server.plugins.di/DependencyRegistry.provide|provide(kotlin.String?;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0?>){0§<kotlin.Any?>}[0]
     final inline fun <#A1: reified kotlin/Any?> provideDelegate(kotlin/Any?, kotlin.reflect/KProperty<*>): kotlin.properties/ReadOnlyProperty<kotlin/Any?, #A1> // io.ktor.server.plugins.di/DependencyRegistry.provideDelegate|provideDelegate(kotlin.Any?;kotlin.reflect.KProperty<*>){0§<kotlin.Any?>}[0]
@@ -378,3 +377,4 @@ final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyR
 final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/create(kotlin.reflect/KClass<out #A>): #A // io.ktor.server.plugins.di/create|create@io.ktor.server.plugins.di.DependencyResolver(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/resolve(kotlin/String? = ...): #A // io.ktor.server.plugins.di/resolve|resolve@io.ktor.server.plugins.di.DependencyMap(kotlin.String?){0§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/provide(kotlin/String? = ..., noinline kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A?>) // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.String?;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0?>){0§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?> io.ktor.server.plugins.di/DependencyKey(kotlin/String? = ..., kotlin/Any? = ...): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/DependencyKey|DependencyKey(kotlin.String?;kotlin.Any?){0§<kotlin.Any?>}[0]
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
index ffbc567c7..0a5b60f27 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
@@ -80,12 +80,46 @@ public val DI: ApplicationPlugin<DependencyInjectionConfig> =
                 installReference(registry, reference)
             }
             monitor.subscribe(ApplicationModulesLoaded) {
-                registry.validate()
+                val exceptions = mutableListOf<Pair<DependencyKey, Throwable>>()
+                for ((key, source) in registry.requirements) {
+                    try {
+                        registry.get<Any>(key)
+                    } catch (e: Throwable) {
+                        environment.log.error("Cannot resolve $key\n${source.externalTrace()}")
+                        exceptions += key to e
+                    }
+                }
+                when (exceptions.size) {
+                    0 -> environment.log.debug("All dependencies resolved successfully")
+                    else -> {
+                        environment.log.error(
+                            buildString {
+                                append("Dependency resolution failed:")
+                                exceptions.forEach { (key, e) ->
+                                    append("\n  - $key: ${formatError(e)}")
+                                }
+                            }
+                        )
+                        throw DependencyInjectionException(
+                            "Some dependencies could not be resolved; check logs for details"
+                        )
+                    }
+                }
             }
+
             attributes.put(DependencyRegistryKey, registry)
         }
     }
 
+private fun formatError(e: Throwable): String =
+    when (e) {
+        is MissingDependencyException -> "Missing declaration"
+        is CircularDependencyException -> "Circular dependency: ${e.keys.joinToString(" -> ")}"
+        is DuplicateDependencyException -> "Conflicting declaration"
+        is AmbiguousDependencyException -> "Ambiguous dependency: ${e.keys.joinToString(", ")}"
+        else -> e.message ?: ("Unknown error" + e.stackTraceToString().let { "\n$it" })
+    }
+
 private fun PluginBuilder<*>.isTestEngine(): Boolean =
     application.engine::class.simpleName == "TestApplicationEngine"
 
@@ -206,6 +240,14 @@ public data class DependencyKey(
     }
 }
 
+/**
+ * Convenience function for `DependencyKey(typeInfo<T>(), name, qualifier)`.
+ */
+public inline fun <reified T> DependencyKey(
+    name: String? = null,
+    qualifier: Any? = null,
+): DependencyKey = DependencyKey(typeInfo<T>(), name, qualifier)
+
 /**
  * Determines if the type associated with a `DependencyKey` is nullable.
  *
@@ -236,7 +278,7 @@ public class DuplicateDependencyException(key: DependencyKey) :
 /**
  * Thrown when there are two or more implicit dependencies that match the given key.
  */
-public class AmbiguousDependencyException(key: DependencyKey, keys: Collection<DependencyKey>) :
+public class AmbiguousDependencyException(key: DependencyKey, internal val keys: Collection<DependencyKey>) :
     DependencyInjectionException("Cannot decide which value for $key. Possible implementations: $keys")
 
 /**
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
index aa29a2146..408173ba7 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
@@ -11,9 +11,8 @@ import io.ktor.server.plugins.di.DependencyConflictResult.KeepPrevious
 import io.ktor.server.plugins.di.DependencyConflictResult.Replace
 import io.ktor.util.logging.KtorSimpleLogger
 import io.ktor.util.logging.Logger
+import io.ktor.util.logging.debug
 import io.ktor.util.logging.trace
-import io.ktor.util.reflect.*
-import io.ktor.utils.io.*
 
 /**
  * Represents a provider for managing dependencies in a dependency injection mechanism.
@@ -51,7 +50,7 @@ public inline fun <reified T> DependencyProvider.provide(
     name: String? = null,
     noinline provide: DependencyResolver.() -> T?
 ) {
-    set(DependencyKey(typeInfo<T>(), name), provide)
+    set(DependencyKey<T>(name), provide)
 }
 
 /**
@@ -198,6 +197,9 @@ public open class MapDependencyProvider(
     public val onConflict: (DependencyKey) -> Unit = { throw DuplicateDependencyException(it) },
     private val log: Logger = KtorSimpleLogger("io.ktor.server.plugins.di.MapDependencyProvider"),
 ) : DependencyProvider {
+    private companion object {
+        private const val COVARIANT_LOG_LIMIT = 8
+    }
     private val map = mutableMapOf<DependencyKey, DependencyCreateFunction>()
 
     override val declarations: Map<DependencyKey, DependencyCreateFunction>
@@ -205,6 +207,7 @@ public open class MapDependencyProvider(
 
     override fun <T> set(key: DependencyKey, value: DependencyResolver.() -> T) {
         val create = ExplicitCreateFunction(key, value as DependencyResolver.() -> Any)
+        log.debug { "Provided $key ${DependencyReference().externalTraceLine()}" }
         trySet(key, create)
         insertCovariantKeys(create, key)
     }
@@ -238,9 +241,16 @@ public open class MapDependencyProvider(
         key: DependencyKey
     ) {
         val covariantKeys = keyMapping.map(key, 0).toList()
-        log.trace { "Inferred keys $key: $covariantKeys" }
+        log.trace { "Covariant keys: ${formatKeys(covariantKeys)}" }
         for ((key, distance) in covariantKeys) {
             trySet(key, createFunction.derived(distance))
         }
     }
+
+    private fun formatKeys(keys: List<KeyMatch>): String =
+        if (keys.size > COVARIANT_LOG_LIMIT) {
+            keys.take(COVARIANT_LOG_LIMIT).joinToString { it.key.toString() } + ", ..."
+        } else {
+            keys.joinToString { it.key.toString() }
+        }
 }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt
index b2ced8b33..b4b3d0bd9 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt
@@ -4,7 +4,6 @@
 
 package io.ktor.server.plugins.di
 
-import io.ktor.util.reflect.*
 import kotlin.reflect.KClass
 
 /**
@@ -42,4 +41,4 @@ public inline fun <reified T : Any> DependencyResolver.create(): T =
  * @return An instance of the specified type [T].
  */
 public inline fun <reified T : Any> DependencyResolver.create(kClass: KClass<out T>): T =
-    getOrPut(DependencyKey(typeInfo<T>())) { reflection.create(kClass, ::get) }
+    getOrPut(DependencyKey<T>()) { reflection.create(kClass, ::get) }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
index 9661d561d..0f8fc6384 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
@@ -6,7 +6,6 @@ package io.ktor.server.plugins.di
 
 import io.ktor.server.application.*
 import io.ktor.server.plugins.di.MutableDependencyMap.Companion.asResolver
-import io.ktor.util.reflect.typeInfo
 import io.ktor.utils.io.*
 import kotlin.properties.ReadOnlyProperty
 import kotlin.reflect.KClass
@@ -33,7 +32,7 @@ public class DependencyRegistry(
     public override val reflection: DependencyReflection,
 ) : DependencyProvider by provider, DependencyResolver {
 
-    private val requiredKeys = mutableSetOf<DependencyKey>()
+    internal val requirements = mutableMapOf<DependencyKey, DependencyReference>()
     private val resolver: Lazy<DependencyResolver> = lazy {
         resolution.resolve(provider, external, reflection)
     }
@@ -55,28 +54,17 @@ public class DependencyRegistry(
     /**
      * Indicates that the given dependency is required.
      *
-     * This is ensured after `validate()` is called.
+     * The DI plugin enforces this at startup.
      */
     public fun require(key: DependencyKey) {
-        requiredKeys += key
-    }
-
-    /**
-     * Performs resolutions, ensuring there are no missing dependencies.
-     *
-     * @throws DependencyInjectionException if there are invalid references in the configuration
-     */
-    public fun validate() {
-        for (key in requiredKeys) {
-            resolver.value.get<Any>(key)
-        }
+        requirements += key to DependencyReference()
     }
 
     /**
      * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
      */
     public inline fun <reified T> resolve(key: String? = null): T =
-        get(DependencyKey(typeInfo<T>(), key))
+        get(DependencyKey<T>(key))
 
     /**
      * Provides a delegated property for accessing a dependency from a [DependencyRegistry].
@@ -99,7 +87,7 @@ public class DependencyRegistry(
         thisRef: Any?,
         prop: KProperty<*>
     ): ReadOnlyProperty<Any?, T> {
-        val key = DependencyKey(typeInfo<T>())
+        val key = DependencyKey<T>()
             .also(::require)
         return ReadOnlyProperty { _, _ ->
             get(key)
@@ -123,7 +111,7 @@ public class DependencyRegistry(
      * Basic call for providing a dependency, like `provide<Service> { ServiceImpl() }`.
      */
     public inline fun <reified T> provide(name: String? = null, noinline provide: DependencyResolver.() -> T?) {
-        set(DependencyKey(typeInfo<T>(), name), provide)
+        set(DependencyKey<T>(name), provide)
     }
 }
 
@@ -220,3 +208,25 @@ public class ProcessingDependencyResolver(
             null
         }
 }
+
+/**
+ * Used for tracing references to dependency keys in the application.
+ *
+ * Both called for lazy `resolve` access and `provide` for easier debugging.
+ */
+internal class DependencyReference : Throwable() {
+
+    /**
+     * Gets the first external API line from the stack trace.
+     */
+    fun externalTraceLine(): String =
+        externalTrace().substringBefore('\n').trim()
+
+    /**
+     * Get the stack trace string from the point of the first external API frame.
+     */
+    fun externalTrace(): String =
+        stackTraceToString()
+            .substringAfterLast("io.ktor.server.plugins.di")
+            .substringAfter('\n')
+}
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
index 4f283fe69..cee4a81a4 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
@@ -6,7 +6,6 @@ package io.ktor.server.plugins.di
 
 import io.ktor.server.config.ApplicationConfig
 import io.ktor.server.config.SerializableConfigValue
-import io.ktor.util.reflect.*
 import kotlin.reflect.KProperty
 
 /**
@@ -173,7 +172,7 @@ public operator fun DependencyMap.plus(right: DependencyMap): DependencyMap =
  * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
  */
 public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
-    get(DependencyKey(typeInfo<T>(), key))
+    get(DependencyKey<T>(key))
 
 internal class MergedDependencyMap(
     private val left: DependencyMap,
@@ -231,5 +230,5 @@ public data class DependencyResolverContext(
      * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
      */
     public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
-        get(DependencyKey(typeInfo<T>(), key))
+        get(DependencyKey<T>(key))
 }
