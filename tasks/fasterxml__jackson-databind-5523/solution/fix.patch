diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 61a274881..c8d658e5a 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -163,7 +163,10 @@ Viktor Szathmáry (@phraktle)
   [3.1.0]
 
 Hélios Gilles (@RoiSoleil)
- * Contributed #5413: Add/support forward reference resolution for array values
+ * Contributed #5413: Add/support forward reference resolution for array value
   [3.1.0]
 
-   
\ No newline at end of file
+Jaeheon Kim (@jher235)
+ * Contributed #5522: `@JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)`
+   doesn't work on custom Collection subclass
+  [3.1.0]
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 01884ec9f..5cb155ad5 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -77,6 +77,9 @@ Versions: 3.x (for earlier see VERSION-2.x)
   `TRUNCATE_TO_MSECS_ON_READ`) for truncating `java.time` values before serialization,
   after deserialization
  (implemented by @cowtowncoder, w/ Claude code)
+#5522: `@JsonFormat(with = JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)`
+  doesn't work on custom Collection subclass
+ (contributed by Jaeheon K)
 #5528: `TreeBuildingGenerator#writeNumber(String)` writes Number as String
  (reported by @gaeljw)
 
diff --git a/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java
index 0feaee19e..257ffaeed 100644
--- a/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java
@@ -811,7 +811,8 @@ public abstract class BasicDeserializerFactory
                 if (!inst.canCreateUsingDefault()) {
                     // [databind#161]: No default constructor for ArrayBlockingQueue...
                     if (type.hasRawClass(ArrayBlockingQueue.class)) {
-                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst);
+                        return new ArrayBlockingQueueDeserializer(type,
+                                contentDeser, contentTypeDeser, inst, beanDescRef.getClassInfo());
                     }
                     // 10-Jan-2017, tatu: `java.util.Collections` types need help:
                     deser = JavaUtilCollectionsDeserializers.findForCollection(ctxt, type);
diff --git a/src/main/java/tools/jackson/databind/deser/jdk/ArrayBlockingQueueDeserializer.java b/src/main/java/tools/jackson/databind/deser/jdk/ArrayBlockingQueueDeserializer.java
index c9a971663..5c6d98315 100644
--- a/src/main/java/tools/jackson/databind/deser/jdk/ArrayBlockingQueueDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/jdk/ArrayBlockingQueueDeserializer.java
@@ -8,6 +8,7 @@ import tools.jackson.core.JsonParser;
 import tools.jackson.databind.*;
 import tools.jackson.databind.deser.NullValueProvider;
 import tools.jackson.databind.deser.ValueInstantiator;
+import tools.jackson.databind.introspect.AnnotatedClass;
 import tools.jackson.databind.jsontype.TypeDeserializer;
 
 /**
@@ -24,24 +25,29 @@ public class ArrayBlockingQueueDeserializer
     /**********************************************************************
      */
 
-     public ArrayBlockingQueueDeserializer(JavaType containerType,
+    // @since 3.1
+    public ArrayBlockingQueueDeserializer(JavaType containerType,
             ValueDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser,
-            ValueInstantiator valueInstantiator)
+            ValueInstantiator valueInstantiator,
+            AnnotatedClass classInfo)
     {
-        super(containerType, valueDeser, valueTypeDeser, valueInstantiator);
+        super(containerType, valueDeser, valueTypeDeser, valueInstantiator, classInfo);
     }
 
     /**
      * Constructor used when creating contextualized instances.
+     *
+     * @since 3.1
      */
      protected ArrayBlockingQueueDeserializer(JavaType containerType,
             ValueDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser,
             ValueInstantiator valueInstantiator,
             ValueDeserializer<Object> delegateDeser,
-            NullValueProvider nuller, Boolean unwrapSingle)
+            NullValueProvider nuller, Boolean unwrapSingle,
+            AnnotatedClass classInfo)
     {
         super(containerType, valueDeser, valueTypeDeser, valueInstantiator, delegateDeser,
-                nuller, unwrapSingle);
+                nuller, unwrapSingle, classInfo);
     }
 
     /**
@@ -64,7 +70,8 @@ public class ArrayBlockingQueueDeserializer
         return new ArrayBlockingQueueDeserializer(_containerType,
                 (ValueDeserializer<Object>) vd, vtd,
                 _valueInstantiator, (ValueDeserializer<Object>) dd,
-                nuller, unwrapSingle);
+                nuller, unwrapSingle,
+                _classInfo);
     }
 
     /*
diff --git a/src/main/java/tools/jackson/databind/deser/jdk/CollectionDeserializer.java b/src/main/java/tools/jackson/databind/deser/jdk/CollectionDeserializer.java
index 852eb5f02..1ed3eaa89 100644
--- a/src/main/java/tools/jackson/databind/deser/jdk/CollectionDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/jdk/CollectionDeserializer.java
@@ -13,6 +13,7 @@ import tools.jackson.databind.cfg.CoercionInputShape;
 import tools.jackson.databind.deser.*;
 import tools.jackson.databind.deser.ReadableObjectId.Referring;
 import tools.jackson.databind.deser.std.ContainerDeserializerBase;
+import tools.jackson.databind.introspect.AnnotatedClass;
 import tools.jackson.databind.jsontype.TypeDeserializer;
 import tools.jackson.databind.type.LogicalType;
 import tools.jackson.databind.util.ClassUtil;
@@ -53,6 +54,14 @@ public class CollectionDeserializer
      */
     protected final ValueDeserializer<Object> _delegateDeserializer;
 
+    /**
+     * Annotations defined on the actual Collection class; retained to avoid
+     * re-introspection overhead during {@link #createContextual} calls.
+     *
+     * @since 3.1
+     */
+    protected transient final AnnotatedClass _classInfo;
+
     // NOTE: no PropertyBasedCreator, as JSON Arrays have no properties
 
     /*
@@ -64,27 +73,43 @@ public class CollectionDeserializer
     /**
      * Constructor for context-free instances, where we do not yet know
      * which property is using this deserializer.
+     *
+     * @since 3.1
      */
+    public CollectionDeserializer(JavaType collectionType,
+            ValueDeserializer<Object> valueDeser,
+            TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator,
+            AnnotatedClass classInfo)
+    {
+        this(collectionType, valueDeser, valueTypeDeser, valueInstantiator,
+                null, null, null, classInfo);
+    }
+
+    @Deprecated // since 3.1
     public CollectionDeserializer(JavaType collectionType,
             ValueDeserializer<Object> valueDeser,
             TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator)
     {
-        this(collectionType, valueDeser, valueTypeDeser, valueInstantiator, null, null, null);
+        this(collectionType, valueDeser, valueTypeDeser, valueInstantiator,
+                null, null, null, null);
     }
 
     /**
      * Constructor used when creating contextualized instances.
+     *
+     * @since 3.1
      */
     protected CollectionDeserializer(JavaType collectionType,
             ValueDeserializer<Object> valueDeser, TypeDeserializer valueTypeDeser,
             ValueInstantiator valueInstantiator, ValueDeserializer<Object> delegateDeser,
-            NullValueProvider nuller, Boolean unwrapSingle)
+            NullValueProvider nuller, Boolean unwrapSingle, AnnotatedClass classInfo)
     {
         super(collectionType, nuller, unwrapSingle);
         _valueDeserializer = valueDeser;
         _valueTypeDeserializer = valueTypeDeser;
         _valueInstantiator = valueInstantiator;
         _delegateDeserializer = delegateDeser;
+        _classInfo = classInfo;
     }
 
     /**
@@ -98,6 +123,7 @@ public class CollectionDeserializer
         _valueTypeDeserializer = src._valueTypeDeserializer;
         _valueInstantiator = src._valueInstantiator;
         _delegateDeserializer = src._delegateDeserializer;
+        _classInfo = src._classInfo;
     }
 
     /**
@@ -111,9 +137,8 @@ public class CollectionDeserializer
             ValueDeserializer<Object> valueDeser,
             TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator)
     {
-        // !!! TODO: make use of `beanDescRef` wrt annotations (as necessary)
-        return new CollectionDeserializer(collectionType,
-                valueDeser, valueTypeDeser, valueInstantiator);
+        return new CollectionDeserializer(collectionType, valueDeser, valueTypeDeser,
+                valueInstantiator, beanDescRef.getClassInfo());
     }
 
     /**
@@ -127,7 +152,7 @@ public class CollectionDeserializer
         return new CollectionDeserializer(_containerType,
                 (ValueDeserializer<Object>) vd, vtd,
                 _valueInstantiator, (ValueDeserializer<Object>) dd,
-                nuller, unwrapSingle);
+                nuller, unwrapSingle, _classInfo);
     }
 
     // Important: do NOT cache if polymorphic values
@@ -153,8 +178,7 @@ public class CollectionDeserializer
 
     /**
      * Method called to finalize setup of this deserializer,
-     * when it is known for which property deserializer is needed
-     * for.
+     * when it is known for which property deserializer is needed for.
      */
     @Override
     public CollectionDeserializer createContextual(DeserializationContext ctxt,
@@ -187,6 +211,7 @@ _containerType,
         // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly
         //   comes down to "List vs Collection" I suppose... for now, pass Collection
         Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,
+                _classInfo,
                 JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
         // also, often value deserializer is resolved here:
         ValueDeserializer<?> valueDeser = _valueDeserializer;
@@ -531,7 +556,7 @@ _containerType,
                     "`java.util.Collection` of type %s does not accept `null` values",
                     ClassUtil.getTypeDescription(getValueType(ctxt)));
         }
-    }    
+    }
     /**
      * Helper class for dealing with Object Id references for values contained in
      * collections being deserialized.
@@ -611,4 +636,5 @@ _containerType,
             _parent.resolveForwardReference(ctxt, id, value);
         }
     }
+
 }
diff --git a/src/main/java/tools/jackson/databind/deser/jdk/StringCollectionDeserializer.java b/src/main/java/tools/jackson/databind/deser/jdk/StringCollectionDeserializer.java
index edf1b1c69..20f17b050 100644
--- a/src/main/java/tools/jackson/databind/deser/jdk/StringCollectionDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/jdk/StringCollectionDeserializer.java
@@ -13,6 +13,7 @@ import tools.jackson.databind.cfg.CoercionInputShape;
 import tools.jackson.databind.deser.NullValueProvider;
 import tools.jackson.databind.deser.ValueInstantiator;
 import tools.jackson.databind.deser.std.ContainerDeserializerBase;
+import tools.jackson.databind.introspect.AnnotatedClass;
 import tools.jackson.databind.introspect.AnnotatedWithParams;
 import tools.jackson.databind.jsontype.TypeDeserializer;
 import tools.jackson.databind.type.LogicalType;
@@ -47,6 +48,14 @@ public final class StringCollectionDeserializer
      */
     private final ValueDeserializer<Object> _delegateDeserializer;
 
+    /**
+     * Annotations defined on the actual Collection class; retained to avoid
+     * re-introspection overhead during {@link #createContextual} calls.
+     *
+     * @since 3.1
+     */
+    protected transient final AnnotatedClass _classInfo;
+
     // NOTE: no PropertyBasedCreator, as JSON Arrays have no properties
 
     /*
@@ -55,22 +64,26 @@ public final class StringCollectionDeserializer
     /**********************************************************************
      */
 
+    // @since 3.1
     public StringCollectionDeserializer(JavaType collectionType,
-            ValueDeserializer<?> valueDeser, ValueInstantiator valueInstantiator)
+            ValueDeserializer<?> valueDeser, ValueInstantiator valueInstantiator,
+            AnnotatedClass classInfo)
     {
-        this(collectionType, valueInstantiator, null, valueDeser, valueDeser, null);
+        this(collectionType, valueInstantiator, null, valueDeser, valueDeser, null, classInfo);
     }
 
+    // @since 3.1
     @SuppressWarnings("unchecked")
     protected StringCollectionDeserializer(JavaType collectionType,
             ValueInstantiator valueInstantiator, ValueDeserializer<?> delegateDeser,
             ValueDeserializer<?> valueDeser,
-            NullValueProvider nuller, Boolean unwrapSingle)
+            NullValueProvider nuller, Boolean unwrapSingle, AnnotatedClass classInfo)
     {
         super(collectionType, nuller, unwrapSingle);
         _valueDeserializer = (ValueDeserializer<String>) valueDeser;
         _valueInstantiator = valueInstantiator;
         _delegateDeserializer = (ValueDeserializer<Object>) delegateDeser;
+        _classInfo = classInfo;
     }
 
     /**
@@ -83,11 +96,10 @@ public final class StringCollectionDeserializer
             BeanDescription.Supplier beanDescRef,
             ValueDeserializer<Object> valueDeser, ValueInstantiator valueInstantiator)
     {
-        // !!! TODO: make use of `beanDescRef` wrt annotations (as necessary)
         return new StringCollectionDeserializer(collectionType,
-                valueDeser, valueInstantiator);
+                valueDeser, valueInstantiator, beanDescRef.getClassInfo());
     }
-    
+
     protected StringCollectionDeserializer withResolved(ValueDeserializer<?> delegateDeser,
             ValueDeserializer<?> valueDeser,
             NullValueProvider nuller, Boolean unwrapSingle)
@@ -97,7 +109,7 @@ public final class StringCollectionDeserializer
             return this;
         }
         return new StringCollectionDeserializer(_containerType, _valueInstantiator,
-                delegateDeser, valueDeser, nuller, unwrapSingle);
+                delegateDeser, valueDeser, nuller, unwrapSingle, _classInfo);
     }
 
     @Override
@@ -150,6 +162,7 @@ public final class StringCollectionDeserializer
         // 11-Dec-2015, tatu: Should we pass basic `Collection.class`, or more refined? Mostly
         //   comes down to "List vs Collection" I suppose... for now, pass Collection
         Boolean unwrapSingle = findFormatFeature(ctxt, property, Collection.class,
+                _classInfo,
                 JsonFormat.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
         NullValueProvider nuller = findContentNullProvider(ctxt, property, valueDeser);
         if (isDefaultDeserializer(valueDeser)) {
diff --git a/src/main/java/tools/jackson/databind/deser/std/StdDeserializer.java b/src/main/java/tools/jackson/databind/deser/std/StdDeserializer.java
index 12cd3809f..633c87cea 100644
--- a/src/main/java/tools/jackson/databind/deser/std/StdDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/std/StdDeserializer.java
@@ -20,6 +20,7 @@ import tools.jackson.databind.deser.bean.BeanDeserializerBase;
 import tools.jackson.databind.deser.impl.NullsAsEmptyProvider;
 import tools.jackson.databind.deser.impl.NullsConstantProvider;
 import tools.jackson.databind.deser.impl.NullsFailProvider;
+import tools.jackson.databind.introspect.AnnotatedClass;
 import tools.jackson.databind.introspect.AnnotatedMember;
 import tools.jackson.databind.jsontype.TypeDeserializer;
 import tools.jackson.databind.type.LogicalType;
@@ -1843,6 +1844,30 @@ inputDesc, _coercedTypeDesc(targetType));
         return ctxt.getDefaultPropertyFormat(typeForDefaults);
     }
 
+    /**
+     * Overloaded variant that also considers class annotations in addition
+     * of type defaults and property annotations.
+     *
+     * @since 3.1
+     */
+    protected JsonFormat.Value findFormatOverrides(DeserializationContext ctxt,
+            BeanProperty prop, Class<?> typeForDefaults,
+            AnnotatedClass clsAnnotations)
+    {
+        // Per-property annotations have highest precedence, followed by
+        // per-typ defaults
+        JsonFormat.Value overrides = (prop == null)
+                ? ctxt.getDefaultPropertyFormat(typeForDefaults)
+                : prop.findPropertyFormat(ctxt.getConfig(), typeForDefaults);
+        if (clsAnnotations != null) {
+            // Lowest precedence for Class annotations
+            JsonFormat.Value overrides2 = ctxt.getAnnotationIntrospector()
+                    .findFormat(ctxt.getConfig(), clsAnnotations);
+            overrides = JsonFormat.Value.merge(overrides2, overrides);
+        }
+        return overrides;
+    }
+
     /**
      * Convenience method that uses {@link #findFormatOverrides} to find possible
      * defaults and/of overrides, and then calls
@@ -1855,10 +1880,22 @@ inputDesc, _coercedTypeDesc(targetType));
             BeanProperty prop, Class<?> typeForDefaults, JsonFormat.Feature feat)
     {
         JsonFormat.Value format = findFormatOverrides(ctxt, prop, typeForDefaults);
-        if (format != null) {
-            return format.getFeature(feat);
-        }
-        return null;
+        return (format == null) ? null : format.getFeature(feat);
+    }
+
+    /**
+     * Overloaded variant that also considers class annotations in addition
+     * of type defaults and property annotations.
+     *
+     * @since 3.1
+     */
+    protected Boolean findFormatFeature(DeserializationContext ctxt,
+            BeanProperty prop, Class<?> typeForDefaults,
+            AnnotatedClass clsAnnotations,
+            JsonFormat.Feature feat)
+    {
+        JsonFormat.Value format = findFormatOverrides(ctxt, prop, typeForDefaults, clsAnnotations);
+        return (format == null) ? null : format.getFeature(feat);
     }
 
     /**
