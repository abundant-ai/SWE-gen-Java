diff --git a/context/src/main/java/io/micronaut/scheduling/processor/ScheduledMethodProcessor.java b/context/src/main/java/io/micronaut/scheduling/processor/ScheduledMethodProcessor.java
index 5e576074fe..dba29045a5 100644
--- a/context/src/main/java/io/micronaut/scheduling/processor/ScheduledMethodProcessor.java
+++ b/context/src/main/java/io/micronaut/scheduling/processor/ScheduledMethodProcessor.java
@@ -93,6 +93,7 @@ public class ScheduledMethodProcessor implements ExecutableMethodProcessor<Sched
         if (!(beanContext instanceof ApplicationContext)) {
             return;
         }
+
         List<AnnotationValue<Scheduled>> scheduledAnnotations = method.getAnnotationValuesByType(Scheduled.class);
         for (AnnotationValue<Scheduled> scheduledAnnotation : scheduledAnnotations) {
             String fixedRate = scheduledAnnotation.stringValue(MEMBER_FIXED_RATE).orElse(null);
diff --git a/context/src/test/groovy/io/micronaut/scheduling/Intercepted.java b/context/src/test/groovy/io/micronaut/scheduling/Intercepted.java
deleted file mode 100644
index 7786c9cca8..0000000000
--- a/context/src/test/groovy/io/micronaut/scheduling/Intercepted.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright 2017-2020 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.scheduling;
-
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * AOP Advice that can be applied to any method.
- *
- * @author graemerocher
- * @since 1.0
- */
-@java.lang.annotation.Documented
-@java.lang.annotation.Retention(RUNTIME)
-@java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.TYPE, java.lang.annotation.ElementType.ANNOTATION_TYPE})
-@io.micronaut.aop.Around
-@io.micronaut.context.annotation.Type(MethodInterceptor.class)
-public @interface Intercepted {
-
-}
diff --git a/context/src/test/groovy/io/micronaut/scheduling/MethodInterceptor.java b/context/src/test/groovy/io/micronaut/scheduling/MethodInterceptor.java
deleted file mode 100644
index 262123f122..0000000000
--- a/context/src/test/groovy/io/micronaut/scheduling/MethodInterceptor.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package io.micronaut.scheduling;
-
-import io.micronaut.aop.MethodInvocationContext;
-import io.micronaut.context.annotation.Requires;
-import jakarta.inject.Singleton;
-
-@Singleton
-@Requires(property = "spec.name", value = "ScheduledInterceptedSpec")
-public class MethodInterceptor implements io.micronaut.aop.MethodInterceptor<Object, Object> {
-    @Override
-    public Object intercept(MethodInvocationContext<Object, Object> context) {
-        return context.proceed();
-    }
-}
diff --git a/context/src/test/groovy/io/micronaut/scheduling/ScheduledInterceptedSpec.groovy b/context/src/test/groovy/io/micronaut/scheduling/ScheduledInterceptedSpec.groovy
deleted file mode 100644
index 25ba65de47..0000000000
--- a/context/src/test/groovy/io/micronaut/scheduling/ScheduledInterceptedSpec.groovy
+++ /dev/null
@@ -1,21 +0,0 @@
-package io.micronaut.scheduling
-
-import io.micronaut.context.ApplicationContext
-import spock.lang.Specification
-
-class ScheduledInterceptedSpec extends Specification {
-
-    void "test scheduled with an intercepted bean"() {
-        ApplicationContext ctx = ApplicationContext.run([
-                'spec.name': 'ScheduledInterceptedSpec'
-        ])
-
-        when:
-        ScheduledInterceptedSpecTask bean = ctx.getBean(ScheduledInterceptedSpecTask)
-        Thread.sleep(1000)
-
-        then:
-        bean.localCounter.get() <= 15
-    }
-
-}
diff --git a/context/src/test/groovy/io/micronaut/scheduling/ScheduledInterceptedSpecTask.java b/context/src/test/groovy/io/micronaut/scheduling/ScheduledInterceptedSpecTask.java
deleted file mode 100644
index f4c198b2ed..0000000000
--- a/context/src/test/groovy/io/micronaut/scheduling/ScheduledInterceptedSpecTask.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2017-2020 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.scheduling;
-
-import io.micronaut.context.annotation.Requires;
-import io.micronaut.scheduling.annotation.Scheduled;
-import jakarta.inject.Singleton;
-
-import java.util.concurrent.atomic.AtomicInteger;
-
-@Singleton
-@Requires(property = "spec.name", value = "ScheduledInterceptedSpec")
-public class ScheduledInterceptedSpecTask {
-
-    AtomicInteger localCounter = new AtomicInteger(0);
-
-    @Scheduled(fixedRate = "100ms")
-    @Intercepted
-    void run() {
-        localCounter.incrementAndGet();
-    }
-}
diff --git a/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java b/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java
index b128597b9b..74e79fa9f5 100644
--- a/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java
+++ b/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java
@@ -1337,7 +1337,7 @@ public class AopProxyWriter extends AbstractClassFileWriter implements ProxyingB
 
     @Override
     public boolean requiresMethodProcessing() {
-        return proxyBeanDefinitionWriter.requiresMethodProcessing() || (parentWriter != null && parentWriter.requiresMethodProcessing());
+        return proxyBeanDefinitionWriter.requiresMethodProcessing();
     }
 
     @Override
diff --git a/inject-groovy/build.gradle b/inject-groovy/build.gradle
index 774f5d66fa..0edc236dab 100644
--- a/inject-groovy/build.gradle
+++ b/inject-groovy/build.gradle
@@ -20,7 +20,6 @@ dependencies {
     testRuntimeOnly libs.jakarta.el
     testImplementation project(":http-server-netty")
     testImplementation project(":http-client")
-    testImplementation project(":retry")
     testImplementation project(":jackson-databind")
     testImplementation project(":inject-test-utils")
     testImplementation project(":inject-groovy-test")
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/executable/ExecutableBeanSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/executable/ExecutableBeanSpec.groovy
index d84f5fc7bf..dbaf5e7813 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/executable/ExecutableBeanSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/executable/ExecutableBeanSpec.groovy
@@ -25,45 +25,13 @@ import spock.lang.PendingFeature
 
 class ExecutableBeanSpec extends AbstractBeanDefinitionSpec {
 
-    void "test executable and aop"() {
-        given:
-        BeanDefinition definition = buildInterceptedBeanDefinition('test.Test$ExecutableController','''\
-package test
-
-import io.micronaut.aop.interceptors.Mutating
-import io.micronaut.context.annotation.Executable
-import io.micronaut.inject.annotation.*
-import io.micronaut.inject.executable.StartupExecutable
-import io.micronaut.retry.annotation.Retryable
-import io.micronaut.scheduling.annotation.Scheduled
-
-class Test {
-    @jakarta.inject.Singleton
-    static class ExecutableController {
-        String foo
-
-        @Scheduled(fixedDelay = "10ms")
-        @Retryable
-         String round(String foo) {
-            return foo
-        }
-    }
-}
-
-''')
-        expect:
-        definition != null
-        definition.executableMethods.size() == 1
-        definition.requiresMethodProcessing()
-    }
-
     void "test executable at class level"() {
         given:
         BeanDefinition definition = buildBeanDefinition('test.ExecutableController','''\
 package test
 
-import io.micronaut.context.annotation.Executable
-import io.micronaut.inject.annotation.*
+import io.micronaut.context.annotation.Executable;
+import io.micronaut.inject.annotation.*;
 
 @jakarta.inject.Singleton
 @Executable
@@ -71,12 +39,12 @@ class ExecutableController {
     String foo
 
     @Executable
-     int round(float num) {
-        return Math.round(num)
+    public int round(float num) {
+        return Math.round(num);
     }
 
     @Executable
-     int sum(int a, int b) {
+    public int sum(int a, int b) {
         return doSum()
     }
 
@@ -96,19 +64,19 @@ class ExecutableController {
         BeanDefinition definition = buildBeanDefinition('test.ExecutableController','''\
 package test
 
-import io.micronaut.context.annotation.Executable
-import io.micronaut.inject.annotation.*
+import io.micronaut.context.annotation.Executable;
+import io.micronaut.inject.annotation.*;
 
 @jakarta.inject.Singleton
 @Executable
 class ExecutableController {
     String foo
 
-    int round(float num) {
-        return Math.round(num)
+    public int round(float num) {
+        return Math.round(num);
     }
 
-    int sum(int a, int b) {
+    public int sum(int a, int b) {
         return doSum()
     }
 
@@ -126,18 +94,18 @@ class ExecutableController {
     void "test executable on stereotype"() {
         given:
         BeanDefinition definition = buildBeanDefinition('test.ExecutableController','''\
-package test
+package test;
 
-import io.micronaut.inject.annotation.*
-import io.micronaut.context.annotation.*
-import io.micronaut.http.annotation.Get
+import io.micronaut.inject.annotation.*;
+import io.micronaut.context.annotation.*;
+import io.micronaut.http.annotation.Get;
 
 @jakarta.inject.Singleton
 class ExecutableController {
 
     @Get("/round")
-     int round(float num) {
-        return Math.round(num)
+    public int round(float num) {
+        return Math.round(num);
     }
 }
 ''')
@@ -149,17 +117,17 @@ class ExecutableController {
     void "test executable method return types"() {
         given:
         BeanDefinition definition = buildBeanDefinition('test.ExecutableBean1','''\
-package test
+package test;
 
-import io.micronaut.inject.annotation.*
-import io.micronaut.context.annotation.*
+import io.micronaut.inject.annotation.*;
+import io.micronaut.context.annotation.*;
 
 @jakarta.inject.Singleton
 @Executable
 class ExecutableBean1 {
 
-    int round(float num) {
-        return Math.round(num)
+    public int round(float num) {
+        return Math.round(num);
     }
 }
 ''')
@@ -172,16 +140,16 @@ class ExecutableBean1 {
     void "bean definition should not be created for class with only executable methods"() {
         given:
         BeanDefinition definition = buildBeanDefinition('test.MyBean','''\
-package test
+package test;
 
-import io.micronaut.inject.annotation.*
-import io.micronaut.context.annotation.*
+import io.micronaut.inject.annotation.*;
+import io.micronaut.context.annotation.*;
 
 class MyBean {
 
     @Executable
-     int round(float num) {
-        return Math.round(num)
+    public int round(float num) {
+        return Math.round(num);
     }
 }
 
@@ -228,40 +196,40 @@ class MyBean  {
     void "test how annotations are preserved"() {
         given:
             BeanDefinition definition = buildBeanDefinition('test.MyBean','''\
-package test
+package test;
 
-import io.micronaut.inject.annotation.*
-import io.micronaut.context.annotation.*
-import jakarta.validation.Valid
-import java.util.List
-import io.micronaut.inject.executable.Book
+import io.micronaut.inject.annotation.*;
+import io.micronaut.context.annotation.*;
+import jakarta.validation.Valid;
+import java.util.List;
+import io.micronaut.inject.executable.Book;
 
 @jakarta.inject.Singleton
 class MyBean {
 
     @Executable
-     void saveAll(@Valid List<Book> books) {
+    public void saveAll(@Valid List<Book> books) {
     }
 
     @Executable
-     <T extends Book> void saveAll2(@Valid List<? extends T> book) {
+    public <T extends Book> void saveAll2(@Valid List<? extends T> book) {
     }
 
     @Executable
-     <T extends Book> void saveAll3(@Valid List<T> book) {
+    public <T extends Book> void saveAll3(@Valid List<T> book) {
     }
 
     @Executable
-     void save2(@Valid Book book) {
+    public void save2(@Valid Book book) {
     }
 
     @Executable
-     <T extends Book> void save3(@Valid T book) {
+    public <T extends Book> void save3(@Valid T book) {
     }
 
     @Executable
-     Book get() {
-        return null
+    public Book get() {
+        return null;
     }
 }
 
@@ -340,57 +308,57 @@ class MyBean {
     void "test how the type annotations from the type are preserved 2"() {
         given:
             BeanDefinition bd = buildBeanDefinition('test.MyBean', '''\
-package test
+package test;
 
-import io.micronaut.inject.annotation.*
-import io.micronaut.context.annotation.*
-import java.util.List
-import io.micronaut.inject.executable.Book
-import io.micronaut.inject.executable.TypeUseRuntimeAnn
+import io.micronaut.inject.annotation.*;
+import io.micronaut.context.annotation.*;
+import java.util.List;
+import io.micronaut.inject.executable.Book;
+import io.micronaut.inject.executable.TypeUseRuntimeAnn;
 
 @jakarta.inject.Singleton
 class MyBean {
 
     @Executable
-     void saveAll(List<@TypeUseRuntimeAnn Book> books) {
+    public void saveAll(List<@TypeUseRuntimeAnn Book> books) {
     }
 
     @Executable
-     <@TypeUseRuntimeAnn T extends Book> void saveAll2(List<? extends T> book) {
+    public <@TypeUseRuntimeAnn T extends Book> void saveAll2(List<? extends T> book) {
     }
 
     @Executable
-     <@TypeUseRuntimeAnn T extends Book> void saveAll3(List<T> book) {
+    public <@TypeUseRuntimeAnn T extends Book> void saveAll3(List<T> book) {
     }
 
     @Executable
-     <T extends Book> void saveAll4(List<@TypeUseRuntimeAnn ? extends T> book) {
+    public <T extends Book> void saveAll4(List<@TypeUseRuntimeAnn ? extends T> book) {
     }
 
     @Executable
-     <T extends Book> void saveAll5(List<? extends @TypeUseRuntimeAnn T> book) {
+    public <T extends Book> void saveAll5(List<? extends @TypeUseRuntimeAnn T> book) {
     }
 
     @Executable
-     void save2(@TypeUseRuntimeAnn Book book) {
+    public void save2(@TypeUseRuntimeAnn Book book) {
     }
 
     @Executable
-     <@TypeUseRuntimeAnn T extends Book> void save3(T book) {
+    public <@TypeUseRuntimeAnn T extends Book> void save3(T book) {
     }
 
     @Executable
-     <T extends @TypeUseRuntimeAnn Book> void save4(T book) {
+    public <T extends @TypeUseRuntimeAnn Book> void save4(T book) {
     }
 
     @Executable
-     <T extends Book> void save5(@TypeUseRuntimeAnn T book) {
+    public <T extends Book> void save5(@TypeUseRuntimeAnn T book) {
     }
 
     @TypeUseRuntimeAnn
     @Executable
-     Book get() {
-        return null
+    public Book get() {
+        return null;
     }
 }
 
@@ -460,19 +428,19 @@ class MyBean {
     void "test how the type annotations from the type are preserved - not working case"() {
         given:
             BeanDefinition bd = buildBeanDefinition('test.MyBean', '''\
-package test
+package test;
 
-import io.micronaut.inject.annotation.*
-import io.micronaut.context.annotation.*
-import java.util.List
-import io.micronaut.inject.executable.Book
-import io.micronaut.inject.executable.TypeUseRuntimeAnn
+import io.micronaut.inject.annotation.*;
+import io.micronaut.context.annotation.*;
+import java.util.List;
+import io.micronaut.inject.executable.Book;
+import io.micronaut.inject.executable.TypeUseRuntimeAnn;
 
 @jakarta.inject.Singleton
 class MyBean {
 
     @Executable
-     <@TypeUseRuntimeAnn T extends Book> void saveAll3(List<T> book) {
+    public <@TypeUseRuntimeAnn T extends Book> void saveAll3(List<T> book) {
     }
 }
 
@@ -488,21 +456,21 @@ class MyBean {
     void "test how the type annotations are preserved on a method"() {
         given:
             BeanDefinition bd = buildBeanDefinition('test.MyBean', '''\
-package test
+package test;
 
-import io.micronaut.inject.annotation.*
-import io.micronaut.context.annotation.*
-import java.util.List
-import io.micronaut.inject.executable.Book
-import io.micronaut.inject.executable.TypeUseRuntimeAnn
+import io.micronaut.inject.annotation.*;
+import io.micronaut.context.annotation.*;
+import java.util.List;
+import io.micronaut.inject.executable.Book;
+import io.micronaut.inject.executable.TypeUseRuntimeAnn;
 
 @jakarta.inject.Singleton
 class MyBean {
 
     @TypeUseRuntimeAnn
     @Executable
-     Book get() {
-        return null
+    public Book get() {
+        return null;
     }
 }
 
@@ -519,23 +487,23 @@ class MyBean {
     void "test how the type annotations from the type are preserved 3"() {
         given:
             BeanDefinition bd = buildBeanDefinition('test.MyBean', '''\
-package test
+package test;
 
-import io.micronaut.inject.annotation.*
-import io.micronaut.context.annotation.*
-import java.util.List
-import io.micronaut.inject.executable.Book
-import io.micronaut.inject.executable.TypeUseRuntimeAnn
+import io.micronaut.inject.annotation.*;
+import io.micronaut.context.annotation.*;
+import java.util.List;
+import io.micronaut.inject.executable.Book;
+import io.micronaut.inject.executable.TypeUseRuntimeAnn;
 
 @jakarta.inject.Singleton
 class MyBean {
 
     @Executable
-     <T extends Book> void saveAll5(List<? extends @TypeUseRuntimeAnn T> book) {
+    public <T extends Book> void saveAll5(List<? extends @TypeUseRuntimeAnn T> book) {
     }
 
     @Executable
-     <T extends Book> void save5(@TypeUseRuntimeAnn T book) {
+    public <T extends Book> void save5(@TypeUseRuntimeAnn T book) {
     }
 
 }
@@ -556,7 +524,7 @@ class MyBean {
 
     void validateBookArgument(Argument argument) {
         // The argument should only have type annotations
-        def am = argument.getAnnotationMetadata()
+        def am = argument.getAnnotationMetadata();
         assert am.hasAnnotation(TypeUseRuntimeAnn.class)
         assert !am.hasAnnotation(MyEntity.class)
         assert !am.hasAnnotation(Introspected.class)
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/executable/StartupExecutable.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/executable/StartupExecutable.groovy
deleted file mode 100644
index 14a1931ece..0000000000
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/executable/StartupExecutable.groovy
+++ /dev/null
@@ -1,8 +0,0 @@
-package io.micronaut.inject.executable
-
-import io.micronaut.context.annotation.Executable
-
-@Executable(processOnStartup = true)
-@interface StartupExecutable {
-
-}
diff --git a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
index 3e1d7cd378..784bb71c29 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
@@ -3293,6 +3293,9 @@ public class DefaultBeanContext implements InitializableBeanContext {
             if (beanDefinitionReference.isProxiedBean()) {
                 beanDefinitionProducer.referenceEnabled = false;
                 BeanDefinitionProducer proxyBeanProducer = new BeanDefinitionProducer(beanDefinitionReference);
+                if (beanDefinitionReference.requiresMethodProcessing()) {
+                    processedBeans.add(proxyBeanProducer);
+                }
                 // retain only if proxy target otherwise the target is never used
                 if (beanDefinitionReference.isProxyTarget()) {
                     proxyTargetBeans.add(proxyBeanProducer);
diff --git a/management/src/main/java/io/micronaut/management/health/monitor/HealthMonitorTask.java b/management/src/main/java/io/micronaut/management/health/monitor/HealthMonitorTask.java
index 2f120bf0ab..0dbf946e15 100644
--- a/management/src/main/java/io/micronaut/management/health/monitor/HealthMonitorTask.java
+++ b/management/src/main/java/io/micronaut/management/health/monitor/HealthMonitorTask.java
@@ -27,8 +27,6 @@ import io.micronaut.scheduling.annotation.Scheduled;
 import jakarta.inject.Inject;
 import jakarta.inject.Singleton;
 import org.reactivestreams.Publisher;
-import org.reactivestreams.Subscriber;
-import org.reactivestreams.Subscription;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import reactor.core.publisher.Flux;
@@ -82,51 +80,29 @@ public class HealthMonitorTask {
         if (LOG.isDebugEnabled()) {
             LOG.debug("Starting health monitor check");
         }
-        List<Publisher<HealthResult>> healthResults = healthIndicators
+        List<Publisher<HealthResult>> resultPublishers = healthIndicators
             .stream()
             .map(HealthIndicator::getResult)
             .collect(Collectors.toList());
 
-        Flux<HealthResult> reactiveSequence = Flux
-            .merge(healthResults)
-            .filter(healthResult -> {
-                    HealthStatus status = healthResult.getStatus();
-                    return status.equals(HealthStatus.DOWN) || !status.getOperational().orElse(true);
-                }
-            );
-
-        reactiveSequence.next().subscribe(new Subscriber<HealthResult>() {
-            @Override
-            public void onSubscribe(Subscription s) {
-
-            }
-
-            @Override
-            public void onNext(HealthResult healthResult) {
-                HealthStatus status = healthResult.getStatus();
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug("Health monitor check with status {}", status);
-                }
-                currentHealthStatus.update(status);
-            }
-
-            @Override
-            public void onError(Throwable e) {
+        Flux
+            .merge(resultPublishers)
+            .collectList()
+            .doOnError((e) -> {
                 if (LOG.isErrorEnabled()) {
                     LOG.error("Health monitor check failed with exception: " + e.getMessage(), e);
                 }
-
                 currentHealthStatus.update(HealthStatus.DOWN.describe("Error occurred running health check: " + e.getMessage()));
-            }
-
-            @Override
-            public void onComplete() {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug("Health monitor check passed.");
+            })
+            .subscribe(healthResults -> {
+                java.util.Optional<HealthResult> firstDown = healthResults.stream().filter(r -> r.getStatus().equals(io.micronaut.health.HealthStatus.DOWN) || !r.getStatus().getOperational().orElse(true))
+                    .findFirst();
+                if (firstDown.isPresent()) {
+                    currentHealthStatus.update(firstDown.get().getStatus());
+                } else {
+                    currentHealthStatus.update(HealthStatus.UP);
                 }
+            });
 
-                currentHealthStatus.update(HealthStatus.UP);
-            }
-        });
     }
 }
diff --git a/management/src/test/groovy/io/micronaut/management/endpoint/health/HealthMonitorTaskSpec.groovy b/management/src/test/groovy/io/micronaut/management/endpoint/health/HealthMonitorTaskSpec.groovy
new file mode 100644
index 0000000000..a65157ae0d
--- /dev/null
+++ b/management/src/test/groovy/io/micronaut/management/endpoint/health/HealthMonitorTaskSpec.groovy
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2017-2019 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.management.endpoint.health
+
+import io.micronaut.context.ApplicationContext
+import io.micronaut.health.CurrentHealthStatus
+import io.micronaut.health.HealthStatus
+import spock.lang.Specification
+
+class HealthMonitorTaskSpec extends Specification {
+
+    void "test CurrentHealthStatus is updated when check is down"() {
+        given:
+        ApplicationContext context = ApplicationContext.builder(['micronaut.health.monitor.enabled': true,
+                                                                 'endpoints.health.disk-space.threshold': 999999999999999999,
+                                                                 'micronaut.health.monitor.initial-delay': '0ms',
+                                                                 'micronaut.application.name': 'health-monitor-task-test']).build()
+        context.start()
+        Thread.sleep(1000)
+
+        expect:
+        context.getBean(CurrentHealthStatus).current().name == HealthStatus.NAME_DOWN
+
+        cleanup:
+        context.close()
+    }
+
+}
