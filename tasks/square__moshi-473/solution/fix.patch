diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
index 4f93169f..b0e9c66d 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
@@ -16,7 +16,6 @@
 package com.squareup.moshi
 
 import com.squareup.kotlinpoet.ARRAY
-import com.squareup.kotlinpoet.AnnotationSpec
 import com.squareup.kotlinpoet.ClassName
 import com.squareup.kotlinpoet.FileSpec
 import com.squareup.kotlinpoet.FunSpec
@@ -32,7 +31,6 @@ import com.squareup.kotlinpoet.asTypeName
 import org.jetbrains.kotlin.serialization.ProtoBuf
 import java.lang.reflect.Type
 import javax.lang.model.element.Element
-import javax.lang.model.element.TypeElement
 import javax.lang.model.util.Elements
 
 /** Generates a JSON adapter for a target type. */
@@ -83,7 +81,7 @@ internal class AdapterGenerator(
 
   val delegateAdapters = propertyList.distinctBy { it.delegateKey() }
 
-  fun generateFile(generatedOption: TypeElement?): FileSpec {
+  fun generateFile(): FileSpec {
     for (property in delegateAdapters) {
       property.reserveDelegateNames(nameAllocator)
     }
@@ -95,20 +93,12 @@ internal class AdapterGenerator(
     if (hasCompanionObject) {
       result.addFunction(generateJsonAdapterFun())
     }
-    result.addType(generateType(generatedOption))
+    result.addType(generateType())
     return result.build()
   }
 
-  private fun generateType(generatedOption: TypeElement?): TypeSpec {
+  private fun generateType(): TypeSpec {
     val result = TypeSpec.classBuilder(adapterName)
-
-    generatedOption?.let {
-      result.addAnnotation(AnnotationSpec.builder(it.asClassName())
-          .addMember("%S", JsonClassCodeGenProcessor::class.java.canonicalName)
-          .addMember("%S", "https://github.com/square/moshi")
-          .build())
-    }
-
     result.superclass(jsonAdapterTypeName)
 
     genericTypeNames?.let {
@@ -317,4 +307,4 @@ internal class AdapterGenerator(
 
     return result.build()
   }
-}
+}
\ No newline at end of file
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
index 82fc8f21..a894cae8 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
@@ -27,6 +27,7 @@ import me.eugeniomarletti.kotlin.metadata.KotlinClassMetadata
 import me.eugeniomarletti.kotlin.metadata.KotlinMetadataUtils
 import me.eugeniomarletti.kotlin.metadata.classKind
 import me.eugeniomarletti.kotlin.metadata.declaresDefaultValue
+import me.eugeniomarletti.kotlin.metadata.getPropertyOrNull
 import me.eugeniomarletti.kotlin.metadata.isDataClass
 import me.eugeniomarletti.kotlin.metadata.isPrimary
 import me.eugeniomarletti.kotlin.metadata.jvm.getJvmConstructorSignature
@@ -34,9 +35,9 @@ import me.eugeniomarletti.kotlin.metadata.kotlinMetadata
 import me.eugeniomarletti.kotlin.metadata.visibility
 import me.eugeniomarletti.kotlin.processing.KotlinAbstractProcessor
 import org.jetbrains.kotlin.serialization.ProtoBuf
+import org.jetbrains.kotlin.serialization.ProtoBuf.Property
 import org.jetbrains.kotlin.serialization.ProtoBuf.ValueParameter
 import java.io.File
-import javax.annotation.processing.ProcessingEnvironment
 import javax.annotation.processing.Processor
 import javax.annotation.processing.RoundEnvironment
 import javax.lang.model.SourceVersion
@@ -44,6 +45,7 @@ import javax.lang.model.element.AnnotationMirror
 import javax.lang.model.element.Element
 import javax.lang.model.element.ElementKind
 import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.Modifier
 import javax.lang.model.element.TypeElement
 import javax.lang.model.element.VariableElement
 import javax.tools.Diagnostic.Kind.ERROR
@@ -62,49 +64,18 @@ import javax.tools.Diagnostic.Kind.ERROR
 @AutoService(Processor::class)
 class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils {
 
-  companion object {
-    /**
-     * This annotation processing argument can be specified to have a `@Generated` annotation
-     * included in the generated code. It is not encouraged unless you need it for static analysis
-     * reasons and not enabled by default.
-     *
-     * Note that this can only be one of the following values:
-     *   * `"javax.annotation.processing.Generated"` (JRE 9+)
-     *   * `"javax.annotation.Generated"` (JRE <9)
-     */
-    const val OPTION_GENERATED = "moshi.generated"
-    private val POSSIBLE_GENERATED_NAMES = setOf(
-        "javax.annotation.processing.Generated",
-        "javax.annotation.Generated"
-    )
-  }
-
   private val annotation = JsonClass::class.java
-  private var generatedType: TypeElement? = null
 
   override fun getSupportedAnnotationTypes() = setOf(annotation.canonicalName)
 
   override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latest()
 
-  override fun getSupportedOptions() = setOf(OPTION_GENERATED)
-
-  override fun init(processingEnv: ProcessingEnvironment) {
-    super.init(processingEnv)
-    generatedType = processingEnv.options[OPTION_GENERATED]?.let {
-      if (it !in POSSIBLE_GENERATED_NAMES) {
-        throw IllegalArgumentException(
-            "Invalid option value for $OPTION_GENERATED. Found $it, allowable values are $POSSIBLE_GENERATED_NAMES.")
-      }
-      processingEnv.elementUtils.getTypeElement(it)
-    }
-  }
-
   override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
     for (type in roundEnv.getElementsAnnotatedWith(annotation)) {
       val jsonClass = type.getAnnotation(annotation)
       if (jsonClass.generateAdapter) {
         val adapterGenerator = processElement(type) ?: continue
-        adapterGenerator.generateAndWrite(generatedType)
+        adapterGenerator.generateAndWrite()
       }
     }
 
@@ -159,6 +130,14 @@ class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils
       nameResolver.getString(it.name)
     }
 
+    // The compiler might emit methods just so it has a place to put annotations. Find these.
+    val annotatedElements = mutableMapOf<Property, ExecutableElement>()
+    for (enclosedElement in element.enclosedElements) {
+      if (enclosedElement !is ExecutableElement) continue
+      val property = classData.getPropertyOrNull(enclosedElement) ?: continue
+      annotatedElements[property] = enclosedElement
+    }
+
     val propertyGenerators = mutableListOf<PropertyGenerator>()
     for (enclosedElement in element.enclosedElements) {
       if (enclosedElement !is VariableElement) continue
@@ -174,6 +153,8 @@ class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils
         null
       }
 
+      val annotatedElement = annotatedElements[property]
+
       if (property.visibility != ProtoBuf.Visibility.INTERNAL
           && property.visibility != ProtoBuf.Visibility.PROTECTED
           && property.visibility != ProtoBuf.Visibility.PUBLIC) {
@@ -181,15 +162,24 @@ class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils
         return null
       }
 
+      val hasDefault = parameter?.declaresDefaultValue ?: true
+
+      if (enclosedElement.modifiers.contains(Modifier.TRANSIENT)) {
+        if (!hasDefault) {
+          throw IllegalArgumentException("No default value for transient property $name")
+        }
+        continue
+      }
+
       propertyGenerators += PropertyGenerator(
           name,
-          serializedName(name, enclosedElement, parameterElement),
+          jsonName(name, enclosedElement, annotatedElement, parameterElement),
           parameter != null,
-          parameter?.declaresDefaultValue ?: true,
+          hasDefault,
           property.returnType.nullable,
           property.returnType.asTypeName(nameResolver, classProto::getTypeParameter),
           property.returnType.asTypeName(nameResolver, classProto::getTypeParameter, true),
-          jsonQualifiers(enclosedElement, parameterElement))
+          jsonQualifiers(enclosedElement, annotatedElement, parameterElement))
     }
 
     // Sort properties so that those with constructor parameters come first.
@@ -234,38 +224,39 @@ class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils
   /** Returns the JsonQualifiers on the field and parameter of a property. */
   private fun jsonQualifiers(
     field: VariableElement,
+    method: ExecutableElement?,
     parameter: VariableElement?
   ): Set<AnnotationMirror> {
-    val fieldJsonQualifiers = AnnotationMirrors.getAnnotatedAnnotations(
-        field, JsonQualifier::class.java)
-
-    val parameterJsonQualifiers: Set<AnnotationMirror> = if (parameter != null) {
-      AnnotationMirrors.getAnnotatedAnnotations(parameter, JsonQualifier::class.java)
-    } else {
-      setOf()
-    }
+    val fieldQualifiers = field.qualifiers
+    val methodQualifiers = method.qualifiers
+    val parameterQualifiers = parameter.qualifiers
 
     // TODO(jwilson): union the qualifiers somehow?
-    if (fieldJsonQualifiers.isNotEmpty()) {
-      return fieldJsonQualifiers
-    } else {
-      return parameterJsonQualifiers
+    return when {
+      fieldQualifiers.isNotEmpty() -> fieldQualifiers
+      methodQualifiers.isNotEmpty() -> methodQualifiers
+      parameterQualifiers.isNotEmpty() -> parameterQualifiers
+      else -> setOf()
     }
   }
 
   /** Returns the @Json name of a property, or `propertyName` if none is provided. */
-  private fun serializedName(
+  private fun jsonName(
     propertyName: String,
     field: VariableElement,
+    method: ExecutableElement?,
     parameter: VariableElement?
   ): String {
-    val fieldAnnotation = field.getAnnotation(Json::class.java)
-    if (fieldAnnotation != null) return fieldAnnotation.name
-
-    val parameterAnnotation = parameter?.getAnnotation(Json::class.java)
-    if (parameterAnnotation != null) return parameterAnnotation.name
-
-    return propertyName
+    val fieldJsonName = field.jsonName
+    val methodJsonName = method.jsonName
+    val parameterJsonName = parameter.jsonName
+
+    return when {
+      fieldJsonName != null -> fieldJsonName
+      methodJsonName != null -> methodJsonName
+      parameterJsonName != null -> parameterJsonName
+      else -> propertyName
+    }
   }
 
   private fun errorMustBeKotlinClass(element: Element) {
@@ -274,8 +265,8 @@ class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils
         element)
   }
 
-  private fun AdapterGenerator.generateAndWrite(generatedOption: TypeElement?) {
-    val fileSpec = generateFile(generatedOption)
+  private fun AdapterGenerator.generateAndWrite() {
+    val fileSpec = generateFile()
     val adapterName = fileSpec.members.filterIsInstance<TypeSpec>().first().name!!
     val outputDir = generatedDir ?: mavenGeneratedDir(adapterName)
     fileSpec.writeTo(outputDir)
@@ -287,5 +278,16 @@ class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils
     val file = filer.createSourceFile(adapterName).toUri().let(::File)
     return file.parentFile.also { file.delete() }
   }
-}
 
+  private val Element?.qualifiers: Set<AnnotationMirror>
+    get() {
+      if (this == null) return setOf()
+      return AnnotationMirrors.getAnnotatedAnnotations(this, JsonQualifier::class.java)
+    }
+
+  private val Element?.jsonName: String?
+    get() {
+      if (this == null) return null
+      return getAnnotation(Json::class.java)?.name
+    }
+}
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt
index 68b61d77..f6301102 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt
@@ -52,7 +52,7 @@ internal class PropertyGenerator(
 
   fun reserveDelegateNames(nameAllocator: NameAllocator) {
     val qualifierNames = jsonQualifiers.joinToString("") {
-      "at${it.annotationType.asElement().simpleName.toString().capitalize()}"
+      "At${it.annotationType.asElement().simpleName.toString().capitalize()}"
     }
     nameAllocator.newName("${unaliasedName.toVariableName()}${qualifierNames}Adapter",
         delegateKey())
