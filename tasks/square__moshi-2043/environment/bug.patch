diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index cdacd6b5..e05476ae 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -30,7 +30,6 @@ ksp = { module = "com.google.devtools.ksp:symbol-processing", version.ref = "ksp
 ksp-api = { module = "com.google.devtools.ksp:symbol-processing-api", version.ref = "ksp" }
 okio = "com.squareup.okio:okio:3.16.4"
 assertj = "org.assertj:assertj-core:3.27.6"
-assertk = "com.willowtreeapps.assertk:assertk:0.28.1"
 junit = "junit:junit:4.13.2"
 kotlinCompileTesting = { module = "dev.zacsweers.kctfork:core", version.ref = "kotlinCompileTesting" }
 kotlinCompileTesting-ksp = { module = "dev.zacsweers.kctfork:ksp", version.ref ="kotlinCompileTesting" }
diff --git a/moshi/build.gradle.kts b/moshi/build.gradle.kts
index 3d7990a0..46fafa47 100644
--- a/moshi/build.gradle.kts
+++ b/moshi/build.gradle.kts
@@ -64,9 +64,7 @@ dependencies {
   api(libs.okio)
 
   testCompileOnly(libs.jsr305)
-  testImplementation(libs.assertk)
   testImplementation(libs.junit)
-  testImplementation(libs.kotlin.reflect)
   testImplementation(libs.truth)
 }
 
diff --git a/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinExtensions.kt b/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinExtensions.kt
index 2daeab25..7878ef85 100644
--- a/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinExtensions.kt
+++ b/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinExtensions.kt
@@ -19,8 +19,8 @@ package com.squareup.moshi
 
 import com.squareup.moshi.internal.NonNullJsonAdapter
 import com.squareup.moshi.internal.NullSafeJsonAdapter
-import com.squareup.moshi.internal.javaType
 import kotlin.reflect.KType
+import kotlin.reflect.javaType
 import kotlin.reflect.typeOf
 
 /**
@@ -28,16 +28,19 @@ import kotlin.reflect.typeOf
  *         itself is handled, nested types (such as in generics) are not resolved.
  */
 @Deprecated("Use the Moshi instance version instead", level = DeprecationLevel.HIDDEN)
+@ExperimentalStdlibApi
 public inline fun <reified T> Moshi.adapter(): JsonAdapter<T> = adapter(typeOf<T>())
 
 @Deprecated("Use the Moshi instance version instead", level = DeprecationLevel.HIDDEN)
-public inline fun <reified T> Moshi.Builder.addAdapter(adapter: JsonAdapter<T>): Moshi.Builder = add(typeOf<T>(), adapter)
+@ExperimentalStdlibApi
+public inline fun <reified T> Moshi.Builder.addAdapter(adapter: JsonAdapter<T>): Moshi.Builder = add(typeOf<T>().javaType, adapter)
 
 /**
  * @return a [JsonAdapter] for [ktype], creating it if necessary. Note that while nullability of
  *         [ktype] itself is handled, nested types (such as in generics) are not resolved.
  */
 @Deprecated("Use the Moshi instance version instead", level = DeprecationLevel.HIDDEN)
+@ExperimentalStdlibApi
 public fun <T> Moshi.adapter(ktype: KType): JsonAdapter<T> {
   val adapter = adapter<T>(ktype.javaType)
   return if (adapter is NullSafeJsonAdapter || adapter is NonNullJsonAdapter) {
diff --git a/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinTypesExtensions.kt b/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinTypesExtensions.kt
index 553a3abb..96f387dc 100644
--- a/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinTypesExtensions.kt
+++ b/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinTypesExtensions.kt
@@ -16,12 +16,12 @@
 package com.squareup.moshi
 
 import com.squareup.moshi.internal.boxIfPrimitive
-import com.squareup.moshi.internal.javaType
 import java.lang.reflect.GenericArrayType
 import java.lang.reflect.Type
 import java.lang.reflect.WildcardType
 import kotlin.reflect.KClass
 import kotlin.reflect.KType
+import kotlin.reflect.javaType
 import kotlin.reflect.typeOf
 
 /** Returns the raw [Class] type of this type. */
@@ -34,44 +34,34 @@ public val Type.rawType: Class<*> get() = Types.getRawType(this)
 public inline fun <reified T : Annotation> Set<Annotation>.nextAnnotations(): Set<Annotation>? = Types.nextAnnotations(this, T::class.java)
 
 /**
- * Returns a type that represents an unknown type that extends [T]. For example, if [T] is
- * [CharSequence], this returns `out CharSequence`. If [T] is [Any], this returns `*`, which is
- * shorthand for `out Any?`.
+ * Returns a type that represents an unknown type that extends [T]. For example, if
+ * [T] is [CharSequence], this returns `out CharSequence`. If
+ * [T] is [Any], this returns `*`, which is shorthand for `out Any?`.
  */
-public inline fun <reified T> subtypeOf(): WildcardType = subtypeOf(typeOf<T>())
-
-/**
- * Returns a type that represents an unknown type that extends [type]. For example, if [type] is
- * [CharSequence], this returns `out CharSequence`. If [type] is [Any], this returns `*`, which is
- * shorthand for `out Any?`.
- */
-public fun subtypeOf(type: KType): WildcardType {
-  var javaType = type.javaType
-  if (javaType is Class<*>) {
-    javaType = javaType.boxIfPrimitive()
+@ExperimentalStdlibApi
+public inline fun <reified T> subtypeOf(): WildcardType {
+  var type = typeOf<T>().javaType
+  if (type is Class<*>) {
+    type = type.boxIfPrimitive()
   }
-  return Types.subtypeOf(javaType)
+  return Types.subtypeOf(type)
 }
 
 /**
  * Returns a type that represents an unknown supertype of [T] bound. For example, if [T] is
  * [String], this returns `in String`.
  */
-public inline fun <reified T> supertypeOf(): WildcardType = supertypeOf(typeOf<T>())
-
-/**
- * Returns a type that represents an unknown supertype of [type] bound. For example, if [type] is
- * [String], this returns `in String`.
- */
-public fun supertypeOf(type: KType): WildcardType {
-  var javaType = type.javaType
-  if (javaType is Class<*>) {
-    javaType = javaType.boxIfPrimitive()
+@ExperimentalStdlibApi
+public inline fun <reified T> supertypeOf(): WildcardType {
+  var type = typeOf<T>().javaType
+  if (type is Class<*>) {
+    type = type.boxIfPrimitive()
   }
-  return Types.supertypeOf(javaType)
+  return Types.supertypeOf(type)
 }
 
 /** Returns a [GenericArrayType] with [this] as its [GenericArrayType.getGenericComponentType]. */
+@ExperimentalStdlibApi
 public fun KType.asArrayType(): GenericArrayType = javaType.asArrayType()
 
 /** Returns a [GenericArrayType] with [this] as its [GenericArrayType.getGenericComponentType]. */
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.kt b/moshi/src/main/java/com/squareup/moshi/Moshi.kt
index 444e9ef3..c6322eca 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.kt
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.kt
@@ -28,12 +28,12 @@ import com.squareup.moshi.internal.StandardJsonAdapters
 import com.squareup.moshi.internal.canonicalize
 import com.squareup.moshi.internal.createJsonQualifierImplementation
 import com.squareup.moshi.internal.isAnnotationPresent
-import com.squareup.moshi.internal.javaType
 import com.squareup.moshi.internal.removeSubtypeWildcard
 import com.squareup.moshi.internal.toStringWithAnnotations
 import java.lang.reflect.Type
 import javax.annotation.CheckReturnValue
 import kotlin.reflect.KType
+import kotlin.reflect.javaType
 import kotlin.reflect.typeOf
 
 /**
@@ -84,6 +84,7 @@ public class Moshi private constructor(builder: Builder) {
    *         itself is handled, nested types (such as in generics) are not resolved.
    */
   @CheckReturnValue
+  @ExperimentalStdlibApi
   public inline fun <reified T> adapter(): JsonAdapter<T> = adapter(typeOf<T>())
 
   /**
@@ -91,6 +92,7 @@ public class Moshi private constructor(builder: Builder) {
    *         [ktype] itself is handled, nested types (such as in generics) are not resolved.
    */
   @CheckReturnValue
+  @ExperimentalStdlibApi
   public fun <T> adapter(ktype: KType): JsonAdapter<T> {
     val adapter = adapter<T>(ktype.javaType)
     return if (adapter is NullSafeJsonAdapter || adapter is NonNullJsonAdapter) {
@@ -190,13 +192,12 @@ public class Moshi private constructor(builder: Builder) {
     internal var lastOffset = 0
 
     @CheckReturnValue
-    public inline fun <reified T> addAdapter(adapter: JsonAdapter<T>): Builder = add(typeOf<T>(), adapter)
+    @ExperimentalStdlibApi
+    public inline fun <reified T> addAdapter(adapter: JsonAdapter<T>): Builder = add(typeOf<T>().javaType, adapter)
 
-    public fun <T> add(type: KType, jsonAdapter: JsonAdapter<T>): Builder =
-      add(type.javaType, jsonAdapter)
-
-    public fun <T> add(type: Type, jsonAdapter: JsonAdapter<T>): Builder =
+    public fun <T> add(type: Type, jsonAdapter: JsonAdapter<T>): Builder = apply {
       add(newAdapterFactory(type, jsonAdapter))
+    }
 
     public fun <T> add(
       type: Type,
diff --git a/moshi/src/main/java/com/squareup/moshi/Types.kt b/moshi/src/main/java/com/squareup/moshi/Types.kt
index eb6f694e..1c3b9737 100644
--- a/moshi/src/main/java/com/squareup/moshi/Types.kt
+++ b/moshi/src/main/java/com/squareup/moshi/Types.kt
@@ -22,7 +22,6 @@ import com.squareup.moshi.internal.GenericArrayTypeImpl
 import com.squareup.moshi.internal.ParameterizedTypeImpl
 import com.squareup.moshi.internal.WildcardTypeImpl
 import com.squareup.moshi.internal.getSupertype
-import java.lang.reflect.Array
 import java.lang.reflect.GenericArrayType
 import java.lang.reflect.ParameterizedType
 import java.lang.reflect.Type
@@ -100,7 +99,7 @@ public object Types {
     require(typeArguments.isNotEmpty()) {
       "Missing type arguments for $rawType"
     }
-    return ParameterizedTypeImpl(null, rawType, typeArguments)
+    return ParameterizedTypeImpl(null, rawType, *typeArguments)
   }
 
   /**
@@ -116,7 +115,7 @@ public object Types {
     require(typeArguments.isNotEmpty()) {
       "Missing type arguments for $rawType"
     }
-    return ParameterizedTypeImpl(ownerType, rawType, typeArguments)
+    return ParameterizedTypeImpl(ownerType, rawType, *typeArguments)
   }
 
   /** Returns an array type whose elements are all instances of `componentType`. */
@@ -171,7 +170,7 @@ public object Types {
 
       is GenericArrayType -> {
         val componentType = type.genericComponentType
-        Array.newInstance(getRawType(componentType), 0).javaClass
+        java.lang.reflect.Array.newInstance(getRawType(componentType), 0).javaClass
       }
 
       is TypeVariable<*> -> {
diff --git a/moshi/src/main/java/com/squareup/moshi/internal/KotlinReflectTypes.kt b/moshi/src/main/java/com/squareup/moshi/internal/KotlinReflectTypes.kt
deleted file mode 100644
index f08f2152..00000000
--- a/moshi/src/main/java/com/squareup/moshi/internal/KotlinReflectTypes.kt
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
- * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
- */
-
-package com.squareup.moshi.internal
-
-import java.lang.reflect.GenericDeclaration
-import java.lang.reflect.Modifier
-import java.lang.reflect.Type
-import java.lang.reflect.TypeVariable
-import kotlin.reflect.KClass
-import kotlin.reflect.KType
-import kotlin.reflect.KTypeParameter
-import kotlin.reflect.KTypeProjection
-import kotlin.reflect.KVariance
-
-/*
- * Moshi wants to offer something like `kotlin.reflect.KType.javaType` as a stable API, but that
- * function is `@ExperimentalStdlibApi`.
- *
- * This file contains a copy-paste of that code, implemented on only non-experimental APIs. It's
- * also modified to use Moshi's `Type` implementations.
- *
- * If/when Kotlin offers a non-experimental API to convert a `KType` to a Java `Type`, we should
- * migrate to that and delete this file.
- */
-@SinceKotlin("1.4")
-internal val KType.javaType: Type
-  get() = computeJavaType()
-
-private fun KType.computeJavaType(forceWrapper: Boolean = false): Type {
-  when (val classifier = classifier) {
-    is KTypeParameter -> return TypeVariableImpl(classifier)
-    is KClass<*> -> {
-      val jClass = if (forceWrapper) classifier.javaObjectType else classifier.java
-      val arguments = arguments
-      if (arguments.isEmpty()) return jClass
-
-      if (jClass.isArray) {
-        if (jClass.componentType.isPrimitive) return jClass
-
-        val (variance, elementType) = arguments.singleOrNull()
-          ?: throw IllegalArgumentException("kotlin.Array must have exactly one type argument: $this")
-        return when (variance) {
-          // Array<in ...> is always erased to Object[], and Array<*> is Object[].
-          null, KVariance.IN -> jClass
-          KVariance.INVARIANT, KVariance.OUT -> {
-            val javaElementType = elementType!!.computeJavaType()
-            if (javaElementType is Class<*>) jClass else GenericArrayTypeImpl(javaElementType)
-          }
-        }
-      }
-
-      return createPossiblyInnerType(jClass, arguments)
-    }
-    else -> throw UnsupportedOperationException("Unsupported type classifier: $this")
-  }
-}
-
-private fun createPossiblyInnerType(
-  jClass: Class<*>,
-  arguments: List<KTypeProjection>,
-): Type {
-  val ownerClass = jClass.declaringClass
-    ?: return ParameterizedTypeImpl(
-      ownerType = null,
-      rawType = jClass,
-      typeArguments = arguments.map(KTypeProjection::javaType).toTypedArray(),
-    )
-
-  if (Modifier.isStatic(jClass.modifiers)) {
-    return ParameterizedTypeImpl(
-      ownerType = ownerClass,
-      rawType = jClass,
-      typeArguments = arguments.map(KTypeProjection::javaType).toTypedArray(),
-    )
-  }
-
-  val n = jClass.typeParameters.size
-  return ParameterizedTypeImpl(
-    ownerType = createPossiblyInnerType(ownerClass, arguments.subList(n, arguments.size)),
-    rawType = jClass,
-    typeArguments = arguments.subList(0, n).map(KTypeProjection::javaType).toTypedArray(),
-  )
-}
-
-private val KTypeProjection.javaType: Type
-  get() {
-    val variance = variance ?: return WildcardTypeImpl(
-      upperBound = Any::class.java,
-      lowerBound = null,
-    )
-
-    val type = type!!
-    // TODO: JvmSuppressWildcards
-    return when (variance) {
-      KVariance.INVARIANT -> {
-        // TODO: declaration-site variance
-        type.computeJavaType(forceWrapper = true)
-      }
-      KVariance.IN -> WildcardTypeImpl(
-        upperBound = Any::class.java,
-        lowerBound = type.computeJavaType(forceWrapper = true),
-      )
-      KVariance.OUT -> WildcardTypeImpl(
-        upperBound = type.computeJavaType(forceWrapper = true),
-        lowerBound = null,
-      )
-    }
-  }
-
-// Suppression of the error is needed for `AnnotatedType[] getAnnotatedBounds()` which is impossible to implement on JDK 6
-// because `AnnotatedType` has only appeared in JDK 8.
-@Suppress("ABSTRACT_MEMBER_NOT_IMPLEMENTED")
-private class TypeVariableImpl(
-  private val typeParameter: KTypeParameter,
-) : TypeVariable<GenericDeclaration> {
-  override fun getName(): String = typeParameter.name
-
-  override fun getGenericDeclaration(): GenericDeclaration =
-    TODO("getGenericDeclaration() is not yet supported for type variables created from KType: $typeParameter")
-
-  override fun getBounds(): Array<Type> = typeParameter.upperBounds.map { it.computeJavaType(forceWrapper = true) }.toTypedArray()
-
-  override fun equals(other: Any?): Boolean =
-    other is TypeVariable<*> && name == other.name && genericDeclaration == other.genericDeclaration
-
-  override fun hashCode(): Int =
-    name.hashCode() xor genericDeclaration.hashCode()
-
-  override fun toString(): String = name
-}
diff --git a/moshi/src/main/java/com/squareup/moshi/internal/Util.kt b/moshi/src/main/java/com/squareup/moshi/internal/Util.kt
index 228441ce..fe750de8 100644
--- a/moshi/src/main/java/com/squareup/moshi/internal/Util.kt
+++ b/moshi/src/main/java/com/squareup/moshi/internal/Util.kt
@@ -164,12 +164,12 @@ internal fun InvocationTargetException.rethrowCause(): RuntimeException {
 internal fun Type.canonicalize(): Type {
   return when (this) {
     is Class<*> -> {
-      if (isArray) GenericArrayTypeImpl(componentType.canonicalize()) else this
+      if (isArray) GenericArrayTypeImpl(this@canonicalize.componentType.canonicalize()) else this
     }
 
     is ParameterizedType -> {
       if (this is ParameterizedTypeImpl) return this
-      ParameterizedTypeImpl(ownerType, rawType, actualTypeArguments)
+      ParameterizedTypeImpl(ownerType, rawType, *actualTypeArguments)
     }
 
     is GenericArrayType -> {
@@ -253,7 +253,7 @@ private fun Type.resolve(
             args[t] = resolvedTypeArgument
           }
         }
-        return if (changed) ParameterizedTypeImpl(newOwnerType, original.rawType, args) else original
+        return if (changed) ParameterizedTypeImpl(newOwnerType, original.rawType, *args) else original
       }
 
       toResolve is WildcardType -> {
@@ -587,33 +587,12 @@ internal inline fun <T : Any> checkNull(value: T?, lazyMessage: (T) -> Any) {
   }
 }
 
-internal class ParameterizedTypeImpl(
-  ownerType: Type?,
-  rawType: Type,
-  typeArguments: Array<out Type>,
-) : ParameterizedType {
-  private val ownerType: Type? = ownerType?.canonicalize()
-  private val rawType: Type = rawType.canonicalize()
-
+internal class ParameterizedTypeImpl private constructor(
+  private val ownerType: Type?,
+  private val rawType: Type,
   @JvmField
-  val typeArguments: Array<Type> = Array(typeArguments.size) { index ->
-    typeArguments[index].canonicalize()
-      .also { it.checkNotPrimitive() }
-  }
-
-  init {
-    // Require an owner type if the raw type needs it.
-    if (rawType is Class<*>) {
-      if (ownerType != null) {
-        require(ownerType.rawType == rawType.enclosingClass) {
-          "unexpected owner type for $rawType: $ownerType"
-        }
-      } else {
-        require(rawType.enclosingClass == null) { "unexpected owner type for $rawType: null" }
-      }
-    }
-  }
-
+  val typeArguments: Array<Type>,
+) : ParameterizedType {
   override fun getActualTypeArguments() = typeArguments.clone()
 
   override fun getRawType() = rawType
@@ -629,7 +608,6 @@ internal class ParameterizedTypeImpl(
   }
 
   override fun toString(): String {
-    // TODO(jwilson): include the owner type if it's non-null.
     val result = StringBuilder(30 * (typeArguments.size + 1))
     result.append(rawType.typeToString())
     if (typeArguments.isEmpty()) {
@@ -641,13 +619,36 @@ internal class ParameterizedTypeImpl(
     }
     return result.append(">").toString()
   }
-}
 
-internal class GenericArrayTypeImpl(
-  componentType: Type,
-) : GenericArrayType {
-  private val componentType: Type = componentType.canonicalize()
+  companion object {
+    @JvmName("create")
+    @JvmStatic
+    operator fun invoke(
+      ownerType: Type?,
+      rawType: Type,
+      vararg typeArguments: Type,
+    ): ParameterizedTypeImpl {
+      // Require an owner type if the raw type needs it.
+      if (rawType is Class<*>) {
+        val enclosingClass = rawType.enclosingClass
+        if (ownerType != null) {
+          require(enclosingClass != null && ownerType.rawType == enclosingClass) { "unexpected owner type for $rawType: $ownerType" }
+        } else {
+          require(enclosingClass == null) { "unexpected owner type for $rawType: null" }
+        }
+      }
+      @Suppress("UNCHECKED_CAST")
+      val finalTypeArgs = typeArguments.clone() as Array<Type>
+      for (t in finalTypeArgs.indices) {
+        finalTypeArgs[t].checkNotPrimitive()
+        finalTypeArgs[t] = finalTypeArgs[t].canonicalize()
+      }
+      return ParameterizedTypeImpl(ownerType?.canonicalize(), rawType.canonicalize(), finalTypeArgs)
+    }
+  }
+}
 
+internal class GenericArrayTypeImpl private constructor(private val componentType: Type) : GenericArrayType {
   override fun getGenericComponentType() = componentType
 
   @Suppress("NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS")
@@ -656,7 +657,15 @@ internal class GenericArrayTypeImpl(
 
   override fun hashCode() = componentType.hashCode()
 
-  override fun toString() = "${componentType.typeToString()}[]"
+  override fun toString() = componentType.typeToString() + "[]"
+
+  companion object {
+    @JvmName("create")
+    @JvmStatic
+    operator fun invoke(componentType: Type): GenericArrayTypeImpl {
+      return GenericArrayTypeImpl(componentType.canonicalize())
+    }
+  }
 }
 
 /**
@@ -664,25 +673,10 @@ internal class GenericArrayTypeImpl(
  * support what the Java 6 language needs - at most one bound. If a lower bound is set, the upper
  * bound must be Object.class.
  */
-internal class WildcardTypeImpl(
-  upperBound: Type,
-  lowerBound: Type?,
+internal class WildcardTypeImpl private constructor(
+  private val upperBound: Type,
+  private val lowerBound: Type?,
 ) : WildcardType {
-  private val upperBound: Type = upperBound.canonicalize()
-  private val lowerBound: Type? = lowerBound?.canonicalize()
-
-  constructor(
-    upperBounds: Array<Type>,
-    lowerBounds: Array<Type>,
-  ) : this(upperBounds.single(), lowerBounds.getOrNull(0)) {
-    require(lowerBounds.size <= 1)
-  }
-
-  init {
-    require(lowerBound == null || upperBound === Any::class.java)
-    upperBound.checkNotPrimitive()
-    lowerBound?.checkNotPrimitive()
-  }
 
   override fun getUpperBounds() = arrayOf(upperBound)
 
@@ -703,4 +697,30 @@ internal class WildcardTypeImpl(
       else -> "? extends ${upperBound.typeToString()}"
     }
   }
+
+  companion object {
+    @JvmStatic
+    @JvmName("create")
+    operator fun invoke(
+      upperBounds: Array<Type>,
+      lowerBounds: Array<Type>,
+    ): WildcardTypeImpl {
+      require(lowerBounds.size <= 1)
+      require(upperBounds.size == 1)
+      return if (lowerBounds.size == 1) {
+        lowerBounds[0].checkNotPrimitive()
+        require(upperBounds[0] === Any::class.java)
+        WildcardTypeImpl(
+          lowerBound = lowerBounds[0].canonicalize(),
+          upperBound = Any::class.java,
+        )
+      } else {
+        upperBounds[0].checkNotPrimitive()
+        WildcardTypeImpl(
+          lowerBound = null,
+          upperBound = upperBounds[0].canonicalize(),
+        )
+      }
+    }
+  }
 }
diff --git a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
index e2cd4742..81683ef0 100644
--- a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
@@ -46,7 +46,6 @@ import java.util.Set;
 import java.util.UUID;
 import javax.annotation.Nullable;
 import javax.crypto.KeyGenerator;
-import kotlin.reflect.KType;
 import okio.Buffer;
 import org.junit.Test;
 
@@ -616,7 +615,7 @@ public final class MoshiTest {
       assertThat(expected).hasMessageThat().contains("Parameter specified as non-null is null");
     }
     try {
-      builder.add((KType) null, null);
+      builder.add(null, null);
       fail();
     } catch (NullPointerException expected) {
       assertThat(expected).hasMessageThat().contains("Parameter specified as non-null is null");
diff --git a/moshi/src/test/java/com/squareup/moshi/internal/KotlinReflectTypesTest.kt b/moshi/src/test/java/com/squareup/moshi/internal/KotlinReflectTypesTest.kt
deleted file mode 100644
index e500b04d..00000000
--- a/moshi/src/test/java/com/squareup/moshi/internal/KotlinReflectTypesTest.kt
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (C) 2025 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi.internal
-
-import assertk.Assert
-import assertk.assertFailure
-import assertk.assertThat
-import assertk.assertions.containsExactly
-import assertk.assertions.isEmpty
-import assertk.assertions.isEqualTo
-import assertk.assertions.isInstanceOf
-import assertk.assertions.isNull
-import com.squareup.moshi.rawType
-import org.junit.Test
-import java.lang.reflect.GenericArrayType
-import java.lang.reflect.GenericDeclaration
-import java.lang.reflect.ParameterizedType
-import java.lang.reflect.TypeVariable
-import java.lang.reflect.WildcardType
-import kotlin.reflect.KFunction0
-import kotlin.reflect.typeOf
-import com.squareup.moshi.internal.javaType as moshiJavaType
-import kotlin.reflect.javaType as kotlinJavaType
-
-class KotlinReflectTypesTest {
-  @Test
-  fun regularClass() {
-    val kotlinType = typeOf<String>()
-    val javaType = kotlinType.moshiJavaType as Class<*>
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType).isEqualTo(String::class.java)
-  }
-
-  @Test
-  fun regularArray() {
-    val kotlinType = typeOf<Array<String>>()
-    val javaType = kotlinType.moshiJavaType
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType).isEqualTo(Array<String>::class.java)
-  }
-
-  @Test
-  fun varianceInArray() {
-    val kotlinType = typeOf<Array<in String>>()
-    val javaType = kotlinType.moshiJavaType
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType).isEqualTo(Array<String>::class.java)
-  }
-
-  @Test
-  fun varianceOutArray() {
-    val kotlinType = typeOf<Array<out String>>()
-    val javaType = kotlinType.moshiJavaType
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType).isEqualTo(Array<String>::class.java)
-  }
-
-  @Test
-  fun genericArray() {
-    val kotlinType = typeOf<Array<List<String>>>()
-    val javaType = kotlinType.moshiJavaType as GenericArrayType
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType.toString()).isEqualTo("java.util.List<java.lang.String>[]")
-    val componentType = javaType.genericComponentType as ParameterizedType
-    assertThat(componentType.rawType).isEqualTo(List::class.java)
-    assertThat(componentType.actualTypeArguments).containsExactly(String::class.java)
-    assertThat(componentType.ownerType).isNull()
-  }
-
-  @Test
-  fun parameterizedType() {
-    val kotlinType = typeOf<List<String>>()
-    val javaType = kotlinType.moshiJavaType as ParameterizedType
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType.toString()).isEqualTo("java.util.List<java.lang.String>")
-    assertThat(javaType.rawType).isEqualTo(List::class.java)
-    assertThat(javaType.actualTypeArguments).containsExactly(String::class.java)
-    assertThat(javaType.ownerType).isNull()
-  }
-
-  @Test
-  fun outWildcardType() {
-    val kotlinType = typeOf<MutableList<out String>>()
-    val javaType = kotlinType.moshiJavaType as ParameterizedType
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType.toString()).isEqualTo("java.util.List<? extends java.lang.String>")
-    assertThat(javaType.rawType).isEqualTo(List::class.java)
-
-    val wildcardType = javaType.actualTypeArguments.single() as WildcardType
-    assertThat(wildcardType.rawType).isEqualTo(String::class.java)
-    assertThat(wildcardType.upperBounds).containsExactly(String::class.java)
-    assertThat(wildcardType.lowerBounds).isEmpty()
-  }
-
-  @Test
-  fun inWildcardType() {
-    val kotlinType = typeOf<MutableList<in String>>()
-    val javaType = kotlinType.moshiJavaType as ParameterizedType
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType.toString()).isEqualTo("java.util.List<? super java.lang.String>")
-    assertThat(javaType.rawType).isEqualTo(List::class.java)
-
-    val wildcardType = javaType.actualTypeArguments.single() as WildcardType
-    assertThat(wildcardType.rawType).isEqualTo(Any::class.java)
-    assertThat(wildcardType.upperBounds).containsExactly(Any::class.java)
-    assertThat(wildcardType.lowerBounds).containsExactly(String::class.java)
-  }
-
-  @Test
-  fun starWildcardType() {
-    val kotlinType = typeOf<MutableList<*>>()
-    val javaType = kotlinType.moshiJavaType as ParameterizedType
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType.toString()).isEqualTo("java.util.List<?>")
-    assertThat(javaType.rawType).isEqualTo(List::class.java)
-
-    val wildcardType = javaType.actualTypeArguments.single() as WildcardType
-    assertThat(wildcardType.rawType).isEqualTo(Any::class.java)
-    assertThat(wildcardType.upperBounds).containsExactly(Any::class.java)
-    assertThat(wildcardType.lowerBounds).isEmpty()
-  }
-
-  @Test
-  fun primitiveType() {
-    val kotlinType = typeOf<Int>()
-    val javaType = kotlinType.moshiJavaType as Class<*>
-    assertThat(javaType).isSymmetricEqualTo(kotlinType.kotlinJavaType)
-    assertThat(javaType).isEqualTo(Int::class.java)
-  }
-
-  @Test
-  fun typeVariable() {
-    val function: KFunction0<String> = ::hello
-    val kotlinType = function.returnType
-    val javaType = kotlinType.moshiJavaType as TypeVariable<GenericDeclaration>
-    assertThat(javaType.bounds).containsExactly(Any::class.java)
-    assertFailure { javaType.genericDeclaration }.isInstanceOf<NotImplementedError>()
-    assertThat(javaType.name).isEqualTo("T")
-    assertThat(javaType.toString()).isEqualTo("T")
-  }
-
-  fun <T> hello(): T {
-    error("Unexpected call")
-  }
-
-  fun <T : Any> Assert<T>.isSymmetricEqualTo(expected: T) = given { actual ->
-    assertThat(actual).isEqualTo(expected)
-    assertThat(actual.hashCode(), "hashCode()").isEqualTo(expected.hashCode())
-    assertThat(expected, "symmetric equals").isEqualTo(actual)
-  }
-}
