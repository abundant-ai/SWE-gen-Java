diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index e05476ae..cdacd6b5 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -30,6 +30,7 @@ ksp = { module = "com.google.devtools.ksp:symbol-processing", version.ref = "ksp
 ksp-api = { module = "com.google.devtools.ksp:symbol-processing-api", version.ref = "ksp" }
 okio = "com.squareup.okio:okio:3.16.4"
 assertj = "org.assertj:assertj-core:3.27.6"
+assertk = "com.willowtreeapps.assertk:assertk:0.28.1"
 junit = "junit:junit:4.13.2"
 kotlinCompileTesting = { module = "dev.zacsweers.kctfork:core", version.ref = "kotlinCompileTesting" }
 kotlinCompileTesting-ksp = { module = "dev.zacsweers.kctfork:ksp", version.ref ="kotlinCompileTesting" }
diff --git a/moshi/build.gradle.kts b/moshi/build.gradle.kts
index 46fafa47..3d7990a0 100644
--- a/moshi/build.gradle.kts
+++ b/moshi/build.gradle.kts
@@ -64,7 +64,9 @@ dependencies {
   api(libs.okio)
 
   testCompileOnly(libs.jsr305)
+  testImplementation(libs.assertk)
   testImplementation(libs.junit)
+  testImplementation(libs.kotlin.reflect)
   testImplementation(libs.truth)
 }
 
diff --git a/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinExtensions.kt b/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinExtensions.kt
index 7878ef85..2daeab25 100644
--- a/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinExtensions.kt
+++ b/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinExtensions.kt
@@ -19,8 +19,8 @@ package com.squareup.moshi
 
 import com.squareup.moshi.internal.NonNullJsonAdapter
 import com.squareup.moshi.internal.NullSafeJsonAdapter
+import com.squareup.moshi.internal.javaType
 import kotlin.reflect.KType
-import kotlin.reflect.javaType
 import kotlin.reflect.typeOf
 
 /**
@@ -28,19 +28,16 @@ import kotlin.reflect.typeOf
  *         itself is handled, nested types (such as in generics) are not resolved.
  */
 @Deprecated("Use the Moshi instance version instead", level = DeprecationLevel.HIDDEN)
-@ExperimentalStdlibApi
 public inline fun <reified T> Moshi.adapter(): JsonAdapter<T> = adapter(typeOf<T>())
 
 @Deprecated("Use the Moshi instance version instead", level = DeprecationLevel.HIDDEN)
-@ExperimentalStdlibApi
-public inline fun <reified T> Moshi.Builder.addAdapter(adapter: JsonAdapter<T>): Moshi.Builder = add(typeOf<T>().javaType, adapter)
+public inline fun <reified T> Moshi.Builder.addAdapter(adapter: JsonAdapter<T>): Moshi.Builder = add(typeOf<T>(), adapter)
 
 /**
  * @return a [JsonAdapter] for [ktype], creating it if necessary. Note that while nullability of
  *         [ktype] itself is handled, nested types (such as in generics) are not resolved.
  */
 @Deprecated("Use the Moshi instance version instead", level = DeprecationLevel.HIDDEN)
-@ExperimentalStdlibApi
 public fun <T> Moshi.adapter(ktype: KType): JsonAdapter<T> {
   val adapter = adapter<T>(ktype.javaType)
   return if (adapter is NullSafeJsonAdapter || adapter is NonNullJsonAdapter) {
diff --git a/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinTypesExtensions.kt b/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinTypesExtensions.kt
index 96f387dc..553a3abb 100644
--- a/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinTypesExtensions.kt
+++ b/moshi/src/main/java/com/squareup/moshi/-MoshiKotlinTypesExtensions.kt
@@ -16,12 +16,12 @@
 package com.squareup.moshi
 
 import com.squareup.moshi.internal.boxIfPrimitive
+import com.squareup.moshi.internal.javaType
 import java.lang.reflect.GenericArrayType
 import java.lang.reflect.Type
 import java.lang.reflect.WildcardType
 import kotlin.reflect.KClass
 import kotlin.reflect.KType
-import kotlin.reflect.javaType
 import kotlin.reflect.typeOf
 
 /** Returns the raw [Class] type of this type. */
@@ -34,34 +34,44 @@ public val Type.rawType: Class<*> get() = Types.getRawType(this)
 public inline fun <reified T : Annotation> Set<Annotation>.nextAnnotations(): Set<Annotation>? = Types.nextAnnotations(this, T::class.java)
 
 /**
- * Returns a type that represents an unknown type that extends [T]. For example, if
- * [T] is [CharSequence], this returns `out CharSequence`. If
- * [T] is [Any], this returns `*`, which is shorthand for `out Any?`.
+ * Returns a type that represents an unknown type that extends [T]. For example, if [T] is
+ * [CharSequence], this returns `out CharSequence`. If [T] is [Any], this returns `*`, which is
+ * shorthand for `out Any?`.
  */
-@ExperimentalStdlibApi
-public inline fun <reified T> subtypeOf(): WildcardType {
-  var type = typeOf<T>().javaType
-  if (type is Class<*>) {
-    type = type.boxIfPrimitive()
+public inline fun <reified T> subtypeOf(): WildcardType = subtypeOf(typeOf<T>())
+
+/**
+ * Returns a type that represents an unknown type that extends [type]. For example, if [type] is
+ * [CharSequence], this returns `out CharSequence`. If [type] is [Any], this returns `*`, which is
+ * shorthand for `out Any?`.
+ */
+public fun subtypeOf(type: KType): WildcardType {
+  var javaType = type.javaType
+  if (javaType is Class<*>) {
+    javaType = javaType.boxIfPrimitive()
   }
-  return Types.subtypeOf(type)
+  return Types.subtypeOf(javaType)
 }
 
 /**
  * Returns a type that represents an unknown supertype of [T] bound. For example, if [T] is
  * [String], this returns `in String`.
  */
-@ExperimentalStdlibApi
-public inline fun <reified T> supertypeOf(): WildcardType {
-  var type = typeOf<T>().javaType
-  if (type is Class<*>) {
-    type = type.boxIfPrimitive()
+public inline fun <reified T> supertypeOf(): WildcardType = supertypeOf(typeOf<T>())
+
+/**
+ * Returns a type that represents an unknown supertype of [type] bound. For example, if [type] is
+ * [String], this returns `in String`.
+ */
+public fun supertypeOf(type: KType): WildcardType {
+  var javaType = type.javaType
+  if (javaType is Class<*>) {
+    javaType = javaType.boxIfPrimitive()
   }
-  return Types.supertypeOf(type)
+  return Types.supertypeOf(javaType)
 }
 
 /** Returns a [GenericArrayType] with [this] as its [GenericArrayType.getGenericComponentType]. */
-@ExperimentalStdlibApi
 public fun KType.asArrayType(): GenericArrayType = javaType.asArrayType()
 
 /** Returns a [GenericArrayType] with [this] as its [GenericArrayType.getGenericComponentType]. */
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.kt b/moshi/src/main/java/com/squareup/moshi/Moshi.kt
index c6322eca..444e9ef3 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.kt
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.kt
@@ -28,12 +28,12 @@ import com.squareup.moshi.internal.StandardJsonAdapters
 import com.squareup.moshi.internal.canonicalize
 import com.squareup.moshi.internal.createJsonQualifierImplementation
 import com.squareup.moshi.internal.isAnnotationPresent
+import com.squareup.moshi.internal.javaType
 import com.squareup.moshi.internal.removeSubtypeWildcard
 import com.squareup.moshi.internal.toStringWithAnnotations
 import java.lang.reflect.Type
 import javax.annotation.CheckReturnValue
 import kotlin.reflect.KType
-import kotlin.reflect.javaType
 import kotlin.reflect.typeOf
 
 /**
@@ -84,7 +84,6 @@ public class Moshi private constructor(builder: Builder) {
    *         itself is handled, nested types (such as in generics) are not resolved.
    */
   @CheckReturnValue
-  @ExperimentalStdlibApi
   public inline fun <reified T> adapter(): JsonAdapter<T> = adapter(typeOf<T>())
 
   /**
@@ -92,7 +91,6 @@ public class Moshi private constructor(builder: Builder) {
    *         [ktype] itself is handled, nested types (such as in generics) are not resolved.
    */
   @CheckReturnValue
-  @ExperimentalStdlibApi
   public fun <T> adapter(ktype: KType): JsonAdapter<T> {
     val adapter = adapter<T>(ktype.javaType)
     return if (adapter is NullSafeJsonAdapter || adapter is NonNullJsonAdapter) {
@@ -192,12 +190,13 @@ public class Moshi private constructor(builder: Builder) {
     internal var lastOffset = 0
 
     @CheckReturnValue
-    @ExperimentalStdlibApi
-    public inline fun <reified T> addAdapter(adapter: JsonAdapter<T>): Builder = add(typeOf<T>().javaType, adapter)
+    public inline fun <reified T> addAdapter(adapter: JsonAdapter<T>): Builder = add(typeOf<T>(), adapter)
 
-    public fun <T> add(type: Type, jsonAdapter: JsonAdapter<T>): Builder = apply {
+    public fun <T> add(type: KType, jsonAdapter: JsonAdapter<T>): Builder =
+      add(type.javaType, jsonAdapter)
+
+    public fun <T> add(type: Type, jsonAdapter: JsonAdapter<T>): Builder =
       add(newAdapterFactory(type, jsonAdapter))
-    }
 
     public fun <T> add(
       type: Type,
diff --git a/moshi/src/main/java/com/squareup/moshi/Types.kt b/moshi/src/main/java/com/squareup/moshi/Types.kt
index 1c3b9737..eb6f694e 100644
--- a/moshi/src/main/java/com/squareup/moshi/Types.kt
+++ b/moshi/src/main/java/com/squareup/moshi/Types.kt
@@ -22,6 +22,7 @@ import com.squareup.moshi.internal.GenericArrayTypeImpl
 import com.squareup.moshi.internal.ParameterizedTypeImpl
 import com.squareup.moshi.internal.WildcardTypeImpl
 import com.squareup.moshi.internal.getSupertype
+import java.lang.reflect.Array
 import java.lang.reflect.GenericArrayType
 import java.lang.reflect.ParameterizedType
 import java.lang.reflect.Type
@@ -99,7 +100,7 @@ public object Types {
     require(typeArguments.isNotEmpty()) {
       "Missing type arguments for $rawType"
     }
-    return ParameterizedTypeImpl(null, rawType, *typeArguments)
+    return ParameterizedTypeImpl(null, rawType, typeArguments)
   }
 
   /**
@@ -115,7 +116,7 @@ public object Types {
     require(typeArguments.isNotEmpty()) {
       "Missing type arguments for $rawType"
     }
-    return ParameterizedTypeImpl(ownerType, rawType, *typeArguments)
+    return ParameterizedTypeImpl(ownerType, rawType, typeArguments)
   }
 
   /** Returns an array type whose elements are all instances of `componentType`. */
@@ -170,7 +171,7 @@ public object Types {
 
       is GenericArrayType -> {
         val componentType = type.genericComponentType
-        java.lang.reflect.Array.newInstance(getRawType(componentType), 0).javaClass
+        Array.newInstance(getRawType(componentType), 0).javaClass
       }
 
       is TypeVariable<*> -> {
diff --git a/moshi/src/main/java/com/squareup/moshi/internal/KotlinReflectTypes.kt b/moshi/src/main/java/com/squareup/moshi/internal/KotlinReflectTypes.kt
new file mode 100644
index 00000000..f08f2152
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/internal/KotlinReflectTypes.kt
@@ -0,0 +1,133 @@
+/*
+ * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.
+ * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.
+ */
+
+package com.squareup.moshi.internal
+
+import java.lang.reflect.GenericDeclaration
+import java.lang.reflect.Modifier
+import java.lang.reflect.Type
+import java.lang.reflect.TypeVariable
+import kotlin.reflect.KClass
+import kotlin.reflect.KType
+import kotlin.reflect.KTypeParameter
+import kotlin.reflect.KTypeProjection
+import kotlin.reflect.KVariance
+
+/*
+ * Moshi wants to offer something like `kotlin.reflect.KType.javaType` as a stable API, but that
+ * function is `@ExperimentalStdlibApi`.
+ *
+ * This file contains a copy-paste of that code, implemented on only non-experimental APIs. It's
+ * also modified to use Moshi's `Type` implementations.
+ *
+ * If/when Kotlin offers a non-experimental API to convert a `KType` to a Java `Type`, we should
+ * migrate to that and delete this file.
+ */
+@SinceKotlin("1.4")
+internal val KType.javaType: Type
+  get() = computeJavaType()
+
+private fun KType.computeJavaType(forceWrapper: Boolean = false): Type {
+  when (val classifier = classifier) {
+    is KTypeParameter -> return TypeVariableImpl(classifier)
+    is KClass<*> -> {
+      val jClass = if (forceWrapper) classifier.javaObjectType else classifier.java
+      val arguments = arguments
+      if (arguments.isEmpty()) return jClass
+
+      if (jClass.isArray) {
+        if (jClass.componentType.isPrimitive) return jClass
+
+        val (variance, elementType) = arguments.singleOrNull()
+          ?: throw IllegalArgumentException("kotlin.Array must have exactly one type argument: $this")
+        return when (variance) {
+          // Array<in ...> is always erased to Object[], and Array<*> is Object[].
+          null, KVariance.IN -> jClass
+          KVariance.INVARIANT, KVariance.OUT -> {
+            val javaElementType = elementType!!.computeJavaType()
+            if (javaElementType is Class<*>) jClass else GenericArrayTypeImpl(javaElementType)
+          }
+        }
+      }
+
+      return createPossiblyInnerType(jClass, arguments)
+    }
+    else -> throw UnsupportedOperationException("Unsupported type classifier: $this")
+  }
+}
+
+private fun createPossiblyInnerType(
+  jClass: Class<*>,
+  arguments: List<KTypeProjection>,
+): Type {
+  val ownerClass = jClass.declaringClass
+    ?: return ParameterizedTypeImpl(
+      ownerType = null,
+      rawType = jClass,
+      typeArguments = arguments.map(KTypeProjection::javaType).toTypedArray(),
+    )
+
+  if (Modifier.isStatic(jClass.modifiers)) {
+    return ParameterizedTypeImpl(
+      ownerType = ownerClass,
+      rawType = jClass,
+      typeArguments = arguments.map(KTypeProjection::javaType).toTypedArray(),
+    )
+  }
+
+  val n = jClass.typeParameters.size
+  return ParameterizedTypeImpl(
+    ownerType = createPossiblyInnerType(ownerClass, arguments.subList(n, arguments.size)),
+    rawType = jClass,
+    typeArguments = arguments.subList(0, n).map(KTypeProjection::javaType).toTypedArray(),
+  )
+}
+
+private val KTypeProjection.javaType: Type
+  get() {
+    val variance = variance ?: return WildcardTypeImpl(
+      upperBound = Any::class.java,
+      lowerBound = null,
+    )
+
+    val type = type!!
+    // TODO: JvmSuppressWildcards
+    return when (variance) {
+      KVariance.INVARIANT -> {
+        // TODO: declaration-site variance
+        type.computeJavaType(forceWrapper = true)
+      }
+      KVariance.IN -> WildcardTypeImpl(
+        upperBound = Any::class.java,
+        lowerBound = type.computeJavaType(forceWrapper = true),
+      )
+      KVariance.OUT -> WildcardTypeImpl(
+        upperBound = type.computeJavaType(forceWrapper = true),
+        lowerBound = null,
+      )
+    }
+  }
+
+// Suppression of the error is needed for `AnnotatedType[] getAnnotatedBounds()` which is impossible to implement on JDK 6
+// because `AnnotatedType` has only appeared in JDK 8.
+@Suppress("ABSTRACT_MEMBER_NOT_IMPLEMENTED")
+private class TypeVariableImpl(
+  private val typeParameter: KTypeParameter,
+) : TypeVariable<GenericDeclaration> {
+  override fun getName(): String = typeParameter.name
+
+  override fun getGenericDeclaration(): GenericDeclaration =
+    TODO("getGenericDeclaration() is not yet supported for type variables created from KType: $typeParameter")
+
+  override fun getBounds(): Array<Type> = typeParameter.upperBounds.map { it.computeJavaType(forceWrapper = true) }.toTypedArray()
+
+  override fun equals(other: Any?): Boolean =
+    other is TypeVariable<*> && name == other.name && genericDeclaration == other.genericDeclaration
+
+  override fun hashCode(): Int =
+    name.hashCode() xor genericDeclaration.hashCode()
+
+  override fun toString(): String = name
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/internal/Util.kt b/moshi/src/main/java/com/squareup/moshi/internal/Util.kt
index fe750de8..228441ce 100644
--- a/moshi/src/main/java/com/squareup/moshi/internal/Util.kt
+++ b/moshi/src/main/java/com/squareup/moshi/internal/Util.kt
@@ -164,12 +164,12 @@ internal fun InvocationTargetException.rethrowCause(): RuntimeException {
 internal fun Type.canonicalize(): Type {
   return when (this) {
     is Class<*> -> {
-      if (isArray) GenericArrayTypeImpl(this@canonicalize.componentType.canonicalize()) else this
+      if (isArray) GenericArrayTypeImpl(componentType.canonicalize()) else this
     }
 
     is ParameterizedType -> {
       if (this is ParameterizedTypeImpl) return this
-      ParameterizedTypeImpl(ownerType, rawType, *actualTypeArguments)
+      ParameterizedTypeImpl(ownerType, rawType, actualTypeArguments)
     }
 
     is GenericArrayType -> {
@@ -253,7 +253,7 @@ private fun Type.resolve(
             args[t] = resolvedTypeArgument
           }
         }
-        return if (changed) ParameterizedTypeImpl(newOwnerType, original.rawType, *args) else original
+        return if (changed) ParameterizedTypeImpl(newOwnerType, original.rawType, args) else original
       }
 
       toResolve is WildcardType -> {
@@ -587,12 +587,33 @@ internal inline fun <T : Any> checkNull(value: T?, lazyMessage: (T) -> Any) {
   }
 }
 
-internal class ParameterizedTypeImpl private constructor(
-  private val ownerType: Type?,
-  private val rawType: Type,
-  @JvmField
-  val typeArguments: Array<Type>,
+internal class ParameterizedTypeImpl(
+  ownerType: Type?,
+  rawType: Type,
+  typeArguments: Array<out Type>,
 ) : ParameterizedType {
+  private val ownerType: Type? = ownerType?.canonicalize()
+  private val rawType: Type = rawType.canonicalize()
+
+  @JvmField
+  val typeArguments: Array<Type> = Array(typeArguments.size) { index ->
+    typeArguments[index].canonicalize()
+      .also { it.checkNotPrimitive() }
+  }
+
+  init {
+    // Require an owner type if the raw type needs it.
+    if (rawType is Class<*>) {
+      if (ownerType != null) {
+        require(ownerType.rawType == rawType.enclosingClass) {
+          "unexpected owner type for $rawType: $ownerType"
+        }
+      } else {
+        require(rawType.enclosingClass == null) { "unexpected owner type for $rawType: null" }
+      }
+    }
+  }
+
   override fun getActualTypeArguments() = typeArguments.clone()
 
   override fun getRawType() = rawType
@@ -608,6 +629,7 @@ internal class ParameterizedTypeImpl private constructor(
   }
 
   override fun toString(): String {
+    // TODO(jwilson): include the owner type if it's non-null.
     val result = StringBuilder(30 * (typeArguments.size + 1))
     result.append(rawType.typeToString())
     if (typeArguments.isEmpty()) {
@@ -619,36 +641,13 @@ internal class ParameterizedTypeImpl private constructor(
     }
     return result.append(">").toString()
   }
-
-  companion object {
-    @JvmName("create")
-    @JvmStatic
-    operator fun invoke(
-      ownerType: Type?,
-      rawType: Type,
-      vararg typeArguments: Type,
-    ): ParameterizedTypeImpl {
-      // Require an owner type if the raw type needs it.
-      if (rawType is Class<*>) {
-        val enclosingClass = rawType.enclosingClass
-        if (ownerType != null) {
-          require(enclosingClass != null && ownerType.rawType == enclosingClass) { "unexpected owner type for $rawType: $ownerType" }
-        } else {
-          require(enclosingClass == null) { "unexpected owner type for $rawType: null" }
-        }
-      }
-      @Suppress("UNCHECKED_CAST")
-      val finalTypeArgs = typeArguments.clone() as Array<Type>
-      for (t in finalTypeArgs.indices) {
-        finalTypeArgs[t].checkNotPrimitive()
-        finalTypeArgs[t] = finalTypeArgs[t].canonicalize()
-      }
-      return ParameterizedTypeImpl(ownerType?.canonicalize(), rawType.canonicalize(), finalTypeArgs)
-    }
-  }
 }
 
-internal class GenericArrayTypeImpl private constructor(private val componentType: Type) : GenericArrayType {
+internal class GenericArrayTypeImpl(
+  componentType: Type,
+) : GenericArrayType {
+  private val componentType: Type = componentType.canonicalize()
+
   override fun getGenericComponentType() = componentType
 
   @Suppress("NULLABILITY_MISMATCH_BASED_ON_JAVA_ANNOTATIONS")
@@ -657,15 +656,7 @@ internal class GenericArrayTypeImpl private constructor(private val componentTyp
 
   override fun hashCode() = componentType.hashCode()
 
-  override fun toString() = componentType.typeToString() + "[]"
-
-  companion object {
-    @JvmName("create")
-    @JvmStatic
-    operator fun invoke(componentType: Type): GenericArrayTypeImpl {
-      return GenericArrayTypeImpl(componentType.canonicalize())
-    }
-  }
+  override fun toString() = "${componentType.typeToString()}[]"
 }
 
 /**
@@ -673,10 +664,25 @@ internal class GenericArrayTypeImpl private constructor(private val componentTyp
  * support what the Java 6 language needs - at most one bound. If a lower bound is set, the upper
  * bound must be Object.class.
  */
-internal class WildcardTypeImpl private constructor(
-  private val upperBound: Type,
-  private val lowerBound: Type?,
+internal class WildcardTypeImpl(
+  upperBound: Type,
+  lowerBound: Type?,
 ) : WildcardType {
+  private val upperBound: Type = upperBound.canonicalize()
+  private val lowerBound: Type? = lowerBound?.canonicalize()
+
+  constructor(
+    upperBounds: Array<Type>,
+    lowerBounds: Array<Type>,
+  ) : this(upperBounds.single(), lowerBounds.getOrNull(0)) {
+    require(lowerBounds.size <= 1)
+  }
+
+  init {
+    require(lowerBound == null || upperBound === Any::class.java)
+    upperBound.checkNotPrimitive()
+    lowerBound?.checkNotPrimitive()
+  }
 
   override fun getUpperBounds() = arrayOf(upperBound)
 
@@ -697,30 +703,4 @@ internal class WildcardTypeImpl private constructor(
       else -> "? extends ${upperBound.typeToString()}"
     }
   }
-
-  companion object {
-    @JvmStatic
-    @JvmName("create")
-    operator fun invoke(
-      upperBounds: Array<Type>,
-      lowerBounds: Array<Type>,
-    ): WildcardTypeImpl {
-      require(lowerBounds.size <= 1)
-      require(upperBounds.size == 1)
-      return if (lowerBounds.size == 1) {
-        lowerBounds[0].checkNotPrimitive()
-        require(upperBounds[0] === Any::class.java)
-        WildcardTypeImpl(
-          lowerBound = lowerBounds[0].canonicalize(),
-          upperBound = Any::class.java,
-        )
-      } else {
-        upperBounds[0].checkNotPrimitive()
-        WildcardTypeImpl(
-          lowerBound = null,
-          upperBound = upperBounds[0].canonicalize(),
-        )
-      }
-    }
-  }
 }
