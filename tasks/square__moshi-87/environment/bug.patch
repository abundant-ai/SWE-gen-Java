diff --git a/adapters/pom.xml b/adapters/pom.xml
deleted file mode 100644
index 70a0e813..00000000
--- a/adapters/pom.xml
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.moshi</groupId>
-    <artifactId>moshi-parent</artifactId>
-    <version>1.0.0-SNAPSHOT</version>
-  </parent>
-
-  <artifactId>moshi-adapters</artifactId>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/adapters/src/main/java/com/squareup/moshi/Iso8601Utils.java b/adapters/src/main/java/com/squareup/moshi/Iso8601Utils.java
deleted file mode 100644
index 3ca492f5..00000000
--- a/adapters/src/main/java/com/squareup/moshi/Iso8601Utils.java
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Copyright (C) 2011 FasterXML, LLC
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.Locale;
-import java.util.TimeZone;
-
-/**
- * Jacksonâ€™s date formatter, pruned to Moshi's needs. Forked from this file:
- * https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
- *
- * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC
- * friendly than using SimpleDateFormat so highly suitable if you (un)serialize lots of date
- * objects.
- *
- * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]
- *
- * @see <a href="http://www.w3.org/TR/NOTE-datetime">this specification</a>
- */
-final class Iso8601Utils {
-  /** ID to represent the 'GMT' string */
-  static final String GMT_ID = "GMT";
-
-  /** The GMT timezone, prefetched to avoid more lookups. */
-  static final TimeZone TIMEZONE_Z = TimeZone.getTimeZone(GMT_ID);
-
-  /** Returns {@code date} formatted as yyyy-MM-ddThh:mm:ss.sssZ */
-  public static String format(Date date) {
-    Calendar calendar = new GregorianCalendar(TIMEZONE_Z, Locale.US);
-    calendar.setTime(date);
-
-    // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
-    int capacity = "yyyy-MM-ddThh:mm:ss.sssZ".length();
-    StringBuilder formatted = new StringBuilder(capacity);
-    padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length());
-    formatted.append('-');
-    padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length());
-    formatted.append('-');
-    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length());
-    formatted.append('T');
-    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length());
-    formatted.append(':');
-    padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length());
-    formatted.append(':');
-    padInt(formatted, calendar.get(Calendar.SECOND), "ss".length());
-    formatted.append('.');
-    padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length());
-    formatted.append('Z');
-    return formatted.toString();
-  }
-
-  /**
-   * Parse a date from ISO-8601 formatted string. It expects a format
-   * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]
-   *
-   * @param date ISO string to parse in the appropriate format.
-   * @return the parsed date
-   */
-  public static Date parse(String date) {
-    try {
-      int offset = 0;
-
-      // extract year
-      int year = parseInt(date, offset, offset += 4);
-      if (checkOffset(date, offset, '-')) {
-        offset += 1;
-      }
-
-      // extract month
-      int month = parseInt(date, offset, offset += 2);
-      if (checkOffset(date, offset, '-')) {
-        offset += 1;
-      }
-
-      // extract day
-      int day = parseInt(date, offset, offset += 2);
-      // default time value
-      int hour = 0;
-      int minutes = 0;
-      int seconds = 0;
-      int milliseconds =
-          0; // always use 0 otherwise returned date will include millis of current time
-
-      // if the value has no time component (and no time zone), we are done
-      boolean hasT = checkOffset(date, offset, 'T');
-
-      if (!hasT && (date.length() <= offset)) {
-        Calendar calendar = new GregorianCalendar(year, month - 1, day);
-
-        return calendar.getTime();
-      }
-
-      if (hasT) {
-
-        // extract hours, minutes, seconds and milliseconds
-        hour = parseInt(date, offset += 1, offset += 2);
-        if (checkOffset(date, offset, ':')) {
-          offset += 1;
-        }
-
-        minutes = parseInt(date, offset, offset += 2);
-        if (checkOffset(date, offset, ':')) {
-          offset += 1;
-        }
-        // second and milliseconds can be optional
-        if (date.length() > offset) {
-          char c = date.charAt(offset);
-          if (c != 'Z' && c != '+' && c != '-') {
-            seconds = parseInt(date, offset, offset += 2);
-            if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
-            // milliseconds can be optional in the format
-            if (checkOffset(date, offset, '.')) {
-              offset += 1;
-              int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
-              int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
-              int fraction = parseInt(date, offset, parseEndOffset);
-              milliseconds = (int) (Math.pow(10, 3 - (parseEndOffset - offset)) * fraction);
-              offset = endOffset;
-            }
-          }
-        }
-      }
-
-      // extract timezone
-      if (date.length() <= offset) {
-        throw new IllegalArgumentException("No time zone indicator");
-      }
-
-      TimeZone timezone;
-      char timezoneIndicator = date.charAt(offset);
-
-      if (timezoneIndicator == 'Z') {
-        timezone = TIMEZONE_Z;
-      } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
-        String timezoneOffset = date.substring(offset);
-        // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"
-        if ("+0000".equals(timezoneOffset) || "+00:00".equals(timezoneOffset)) {
-          timezone = TIMEZONE_Z;
-        } else {
-          // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
-          //    not sure why, but it is what it is.
-          String timezoneId = GMT_ID + timezoneOffset;
-          timezone = TimeZone.getTimeZone(timezoneId);
-          String act = timezone.getID();
-          if (!act.equals(timezoneId)) {
-            /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
-             *    one without. If so, don't sweat.
-             *   Yes, very inefficient. Hopefully not hit often.
-             *   If it becomes a perf problem, add 'loose' comparison instead.
-             */
-            String cleaned = act.replace(":", "");
-            if (!cleaned.equals(timezoneId)) {
-              throw new IndexOutOfBoundsException("Mismatching time zone indicator: "
-                  + timezoneId + " given, resolves to " + timezone.getID());
-            }
-          }
-        }
-      } else {
-        throw new IndexOutOfBoundsException(
-            "Invalid time zone indicator '" + timezoneIndicator + "'");
-      }
-
-      Calendar calendar = new GregorianCalendar(timezone);
-      calendar.setLenient(false);
-      calendar.set(Calendar.YEAR, year);
-      calendar.set(Calendar.MONTH, month - 1);
-      calendar.set(Calendar.DAY_OF_MONTH, day);
-      calendar.set(Calendar.HOUR_OF_DAY, hour);
-      calendar.set(Calendar.MINUTE, minutes);
-      calendar.set(Calendar.SECOND, seconds);
-      calendar.set(Calendar.MILLISECOND, milliseconds);
-
-      return calendar.getTime();
-      // If we get a ParseException it'll already have the right message/offset.
-      // Other exception types can convert here.
-    } catch (IndexOutOfBoundsException | IllegalArgumentException e) {
-      throw new JsonDataException("Not an RFC 3339 date: " + date);
-    }
-  }
-
-  /**
-   * Check if the expected character exist at the given offset in the value.
-   *
-   * @param value the string to check at the specified offset
-   * @param offset the offset to look for the expected character
-   * @param expected the expected character
-   * @return true if the expected character exist at the given offset
-   */
-  private static boolean checkOffset(String value, int offset, char expected) {
-    return (offset < value.length()) && (value.charAt(offset) == expected);
-  }
-
-  /**
-   * Parse an integer located between 2 given offsets in a string
-   *
-   * @param value the string to parse
-   * @param beginIndex the start index for the integer in the string
-   * @param endIndex the end index for the integer in the string
-   * @return the int
-   * @throws NumberFormatException if the value is not a number
-   */
-  private static int parseInt(String value, int beginIndex, int endIndex)
-      throws NumberFormatException {
-    if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {
-      throw new NumberFormatException(value);
-    }
-    // use same logic as in Integer.parseInt() but less generic we're not supporting negative values
-    int i = beginIndex;
-    int result = 0;
-    int digit;
-    if (i < endIndex) {
-      digit = Character.digit(value.charAt(i++), 10);
-      if (digit < 0) {
-        throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
-      }
-      result = -digit;
-    }
-    while (i < endIndex) {
-      digit = Character.digit(value.charAt(i++), 10);
-      if (digit < 0) {
-        throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
-      }
-      result *= 10;
-      result -= digit;
-    }
-    return -result;
-  }
-
-  /**
-   * Zero pad a number to a specified length
-   *
-   * @param buffer buffer to use for padding
-   * @param value the integer value to pad if necessary.
-   * @param length the length of the string we should zero pad
-   */
-  private static void padInt(StringBuilder buffer, int value, int length) {
-    String strValue = Integer.toString(value);
-    for (int i = length - strValue.length(); i > 0; i--) {
-      buffer.append('0');
-    }
-    buffer.append(strValue);
-  }
-
-  /**
-   * Returns the index of the first character in the string that is not a digit, starting at
-   * offset.
-   */
-  private static int indexOfNonDigit(String string, int offset) {
-    for (int i = offset; i < string.length(); i++) {
-      char c = string.charAt(i);
-      if (c < '0' || c > '9') return i;
-    }
-    return string.length();
-  }
-}
diff --git a/adapters/src/main/java/com/squareup/moshi/Rfc3339DateJsonAdapter.java b/adapters/src/main/java/com/squareup/moshi/Rfc3339DateJsonAdapter.java
deleted file mode 100644
index f1108c79..00000000
--- a/adapters/src/main/java/com/squareup/moshi/Rfc3339DateJsonAdapter.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.io.IOException;
-import java.util.Date;
-
-/**
- * Formats dates using <a href="https://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a>, which is
- * formatted like {@code 2015-09-26T18:23:50.250Z}.
- */
-public final class Rfc3339DateJsonAdapter extends JsonAdapter<Date> {
-  @Override public synchronized Date fromJson(JsonReader reader) throws IOException {
-    String string = reader.nextString();
-    return Iso8601Utils.parse(string);
-  }
-
-  @Override public synchronized void toJson(JsonWriter writer, Date value) throws IOException {
-    String string = Iso8601Utils.format(value);
-    writer.value(string);
-  }
-}
diff --git a/adapters/src/test/java/com/squareup/moshi/Rfc3339DateJsonAdapterTest.java b/adapters/src/test/java/com/squareup/moshi/Rfc3339DateJsonAdapterTest.java
deleted file mode 100644
index f7bab599..00000000
--- a/adapters/src/test/java/com/squareup/moshi/Rfc3339DateJsonAdapterTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class Rfc3339DateJsonAdapterTest {
-  private final JsonAdapter<Date> adapter = new Rfc3339DateJsonAdapter().lenient();
-
-  @Test public void fromJsonWithTwoDigitMillis() throws Exception {
-    assertThat(adapter.fromJson("\"1985-04-12T23:20:50.52Z\""))
-        .isEqualTo(newDate(1985, 4, 12, 23, 20, 50, 520, 0));
-  }
-
-  @Test public void fromJson() throws Exception {
-    assertThat(adapter.fromJson("\"1970-01-01T00:00:00.000Z\""))
-        .isEqualTo(newDate(1970, 1, 1, 0, 0, 0, 0, 0));
-    assertThat(adapter.fromJson("\"1985-04-12T23:20:50.520Z\""))
-        .isEqualTo(newDate(1985, 4, 12, 23, 20, 50, 520, 0));
-    assertThat(adapter.fromJson("\"1996-12-19T16:39:57-08:00\""))
-        .isEqualTo(newDate(1996, 12, 19, 16, 39, 57, 0, -8 * 60));
-    assertThat(adapter.fromJson("\"1990-12-31T23:59:60Z\""))
-        .isEqualTo(newDate(1990, 12, 31, 23, 59, 59, 0, 0));
-    assertThat(adapter.fromJson("\"1990-12-31T15:59:60-08:00\""))
-        .isEqualTo(newDate(1990, 12, 31, 15, 59, 59, 0, -8 * 60));
-    assertThat(adapter.fromJson("\"1937-01-01T12:00:27.870+00:20\""))
-        .isEqualTo(newDate(1937, 1, 1, 12, 0, 27, 870, 20));
-  }
-
-  @Test public void toJson() throws Exception {
-    assertThat(adapter.toJson(newDate(1970, 1, 1, 0, 0, 0, 0, 0)))
-        .isEqualTo("\"1970-01-01T00:00:00.000Z\"");
-    assertThat(adapter.toJson(newDate(1985, 4, 12, 23, 20, 50, 520, 0)))
-        .isEqualTo("\"1985-04-12T23:20:50.520Z\"");
-    assertThat(adapter.toJson(newDate(1996, 12, 19, 16, 39, 57, 0, -8 * 60)))
-        .isEqualTo("\"1996-12-20T00:39:57.000Z\"");
-    assertThat(adapter.toJson(newDate(1990, 12, 31, 23, 59, 59, 0, 0)))
-        .isEqualTo("\"1990-12-31T23:59:59.000Z\"");
-    assertThat(adapter.toJson(newDate(1990, 12, 31, 15, 59, 59, 0, -8 * 60)))
-        .isEqualTo("\"1990-12-31T23:59:59.000Z\"");
-    assertThat(adapter.toJson(newDate(1937, 1, 1, 12, 0, 27, 870, 20)))
-        .isEqualTo("\"1937-01-01T11:40:27.870Z\"");
-  }
-
-  private Date newDate(
-      int year, int month, int day, int hour, int minute, int second, int millis, int offset) {
-    Calendar calendar = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
-    calendar.set(year, month - 1, day, hour, minute, second);
-    calendar.set(Calendar.MILLISECOND, millis);
-    return new Date(calendar.getTimeInMillis() - TimeUnit.MINUTES.toMillis(offset));
-  }
-}
diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
index 6a3ec9cf..ba1a0dfc 100644
--- a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
@@ -34,7 +34,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
   }
 
   @Override public JsonAdapter<?> create(
-      Type type, Set<? extends Annotation> annotations, final Moshi moshi) {
+      final Type type, final Set<? extends Annotation> annotations, final Moshi moshi) {
     final AdapterMethod toAdapter = get(toAdapters, type, annotations);
     final AdapterMethod fromAdapter = get(fromAdapters, type, annotations);
     if (toAdapter == null && fromAdapter == null) return null;
@@ -87,6 +87,10 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
           }
         }
       }
+
+      @Override public String toString() {
+        return "JsonAdapter" + annotations + "(" + type + ")";
+      }
     };
   }
 
diff --git a/moshi/src/main/java/com/squareup/moshi/ClassFactory.java b/moshi/src/main/java/com/squareup/moshi/ClassFactory.java
index f7cba545..01a81709 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassFactory.java
@@ -44,6 +44,9 @@ abstract class ClassFactory<T> {
           Object[] args = null;
           return (T) constructor.newInstance(args);
         }
+        @Override public String toString() {
+          return rawType.getName();
+        }
       };
     } catch (NoSuchMethodException ignored) {
       // No no-args constructor. Fall back to something more magical...
@@ -64,6 +67,9 @@ abstract class ClassFactory<T> {
         @Override public T newInstance() throws InvocationTargetException, IllegalAccessException {
           return (T) allocateInstance.invoke(unsafe, rawType);
         }
+        @Override public String toString() {
+          return rawType.getName();
+        }
       };
     } catch (IllegalAccessException e) {
       throw new AssertionError();
@@ -89,6 +95,9 @@ abstract class ClassFactory<T> {
         @Override public T newInstance() throws InvocationTargetException, IllegalAccessException {
           return (T) newInstance.invoke(null, rawType, constructorId);
         }
+        @Override public String toString() {
+          return rawType.getName();
+        }
       };
     } catch (IllegalAccessException e) {
       throw new AssertionError();
diff --git a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
index 4f19e49d..2163620d 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
@@ -166,6 +166,10 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
     }
   }
 
+  @Override public String toString() {
+    return "JsonAdapter(" + classFactory + ")";
+  }
+
   static class FieldBinding<T> {
     private final Field field;
     private final JsonAdapter<T> adapter;
diff --git a/moshi/src/main/java/com/squareup/moshi/CollectionJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/CollectionJsonAdapter.java
index 39d87459..03d6623b 100644
--- a/moshi/src/main/java/com/squareup/moshi/CollectionJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/CollectionJsonAdapter.java
@@ -85,4 +85,8 @@ abstract class CollectionJsonAdapter<C extends Collection<T>, T> extends JsonAda
     }
     writer.endArray();
   }
+
+  @Override public String toString() {
+    return elementAdapter + ".collection()";
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
index 8e211de8..5d41fd1f 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
@@ -75,6 +75,9 @@ public abstract class JsonAdapter<T> {
           delegate.toJson(writer, value);
         }
       }
+      @Override public String toString() {
+        return delegate + ".nullSafe()";
+      }
     };
   }
 
@@ -100,6 +103,9 @@ public abstract class JsonAdapter<T> {
           writer.setLenient(lenient);
         }
       }
+      @Override public String toString() {
+        return delegate + ".lenient()";
+      }
     };
   }
 
@@ -124,6 +130,9 @@ public abstract class JsonAdapter<T> {
       @Override public void toJson(JsonWriter writer, T value) throws IOException {
         delegate.toJson(writer, value);
       }
+      @Override public String toString() {
+        return delegate + ".failOnUnknown()";
+      }
     };
   }
 
diff --git a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
index c4f15db1..b0bb34db 100644
--- a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
@@ -75,4 +75,8 @@ final class MapJsonAdapter<K, V> extends JsonAdapter<Map<K, V>> {
     reader.endObject();
     return result;
   }
+
+  @Override public String toString() {
+    return "JsonAdapter(" + keyAdapter + "=" + valueAdapter + ")";
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 00751756..4aa279ff 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -19,8 +19,11 @@ import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 /**
@@ -29,6 +32,7 @@ import java.util.Set;
 public final class Moshi {
   private final List<JsonAdapter.Factory> factories;
   private final ThreadLocal<List<DeferredAdapter<?>>> reentrantCalls = new ThreadLocal<>();
+  private final Map<Object, JsonAdapter<?>> adapterCache = new LinkedHashMap<>();
 
   private Moshi(Builder builder) {
     List<JsonAdapter.Factory> factories = new ArrayList<>();
@@ -47,52 +51,77 @@ public final class Moshi {
   }
 
   public <T> JsonAdapter<T> adapter(Class<T> type) {
-    // TODO: cache created JSON adapters.
     return adapter(type, Util.NO_ANNOTATIONS);
   }
 
+  @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
   public <T> JsonAdapter<T> adapter(Type type, Set<? extends Annotation> annotations) {
-    return createAdapter(0, type, annotations);
-  }
-
-  public <T> JsonAdapter<T> nextAdapter(JsonAdapter.Factory skipPast, Type type,
-      Set<? extends Annotation> annotations) {
-    return createAdapter(factories.indexOf(skipPast) + 1, type, annotations);
-  }
+    // If there's an equivalent adapter in the cache, we're done!
+    Object cacheKey = cacheKey(type, annotations);
+    synchronized (adapterCache) {
+      JsonAdapter<?> result = adapterCache.get(cacheKey);
+      if (result != null) return (JsonAdapter<T>) result;
+    }
 
-  @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
-  private <T> JsonAdapter<T> createAdapter(
-      int firstIndex, Type type, Set<? extends Annotation> annotations) {
+    // Short-circuit if this is a reentrant call.
     List<DeferredAdapter<?>> deferredAdapters = reentrantCalls.get();
-    if (deferredAdapters == null) {
-      deferredAdapters = new ArrayList<>();
-      reentrantCalls.set(deferredAdapters);
-    } else if (firstIndex == 0) {
-      // If this is a regular adapter lookup, check that this isn't a reentrant call.
-      for (DeferredAdapter<?> deferredAdapter : deferredAdapters) {
-        if (deferredAdapter.type.equals(type) && deferredAdapter.annotations.equals(annotations)) {
+    if (deferredAdapters != null) {
+      for (int i = 0, size = deferredAdapters.size(); i < size; i++) {
+        DeferredAdapter<?> deferredAdapter = deferredAdapters.get(i);
+        if (deferredAdapter.cacheKey.equals(cacheKey)) {
           return (JsonAdapter<T>) deferredAdapter;
         }
       }
+    } else {
+      deferredAdapters = new ArrayList<>();
+      reentrantCalls.set(deferredAdapters);
     }
 
-    DeferredAdapter<T> deferredAdapter = new DeferredAdapter<>(type, annotations);
+    // Prepare for re-entrant calls, then ask each factory to create a type adapter.
+    DeferredAdapter<T> deferredAdapter = new DeferredAdapter<>(cacheKey);
     deferredAdapters.add(deferredAdapter);
     try {
-      for (int i = firstIndex, size = factories.size(); i < size; i++) {
+      for (int i = 0, size = factories.size(); i < size; i++) {
         JsonAdapter<T> result = (JsonAdapter<T>) factories.get(i).create(type, annotations, this);
         if (result != null) {
           deferredAdapter.ready(result);
+          synchronized (adapterCache) {
+            adapterCache.put(cacheKey, result);
+          }
           return result;
         }
       }
     } finally {
       deferredAdapters.remove(deferredAdapters.size() - 1);
+      if (deferredAdapters.isEmpty()) {
+        reentrantCalls.remove();
+      }
     }
 
     throw new IllegalArgumentException("No JsonAdapter for " + type + " annotated " + annotations);
   }
 
+  @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
+  public <T> JsonAdapter<T> nextAdapter(JsonAdapter.Factory skipPast, Type type,
+      Set<? extends Annotation> annotations) {
+    int skipPastIndex = factories.indexOf(skipPast);
+    if (skipPastIndex == -1) {
+      throw new IllegalArgumentException("Unable to skip past unknown factory " + skipPast);
+    }
+    for (int i = skipPastIndex + 1, size = factories.size(); i < size; i++) {
+      JsonAdapter<T> result = (JsonAdapter<T>) factories.get(i).create(type, annotations, this);
+      if (result != null) return result;
+    }
+    throw new IllegalArgumentException("No next JsonAdapter for "
+        + type + " annotated " + annotations);
+  }
+
+  /** Returns an opaque object that's equal if the type and annotations are equal. */
+  private Object cacheKey(Type type, Set<? extends Annotation> annotations) {
+    if (annotations.isEmpty()) return type;
+    return Arrays.asList(type, annotations);
+  }
+
   public static final class Builder {
     private final List<JsonAdapter.Factory> factories = new ArrayList<>();
 
@@ -116,22 +145,24 @@ public final class Moshi {
       if (!annotation.isAnnotationPresent(JsonQualifier.class)) {
         throw new IllegalArgumentException(annotation + " does not have @JsonQualifier");
       }
+      if (annotation.getDeclaredMethods().length > 0) {
+        throw new IllegalArgumentException("Use JsonAdapter.Factory for annotations with elements");
+      }
 
       return add(new JsonAdapter.Factory() {
         @Override public JsonAdapter<?> create(
             Type targetType, Set<? extends Annotation> annotations, Moshi moshi) {
-          if (!Util.typesMatch(type, targetType)) return null;
-
-          // TODO: check for an annotations exact match.
-          if (!Util.isAnnotationPresent(annotations, annotation)) return null;
-
-          return jsonAdapter;
+          if (Util.typesMatch(type, targetType)
+              && annotations.size() == 1
+              && Util.isAnnotationPresent(annotations, annotation)) {
+            return jsonAdapter;
+          }
+          return null;
         }
       });
     }
 
     public Builder add(JsonAdapter.Factory jsonAdapter) {
-      // TODO: define precedence order. Last added wins? First added wins?
       factories.add(jsonAdapter);
       return this;
     }
@@ -154,21 +185,16 @@ public final class Moshi {
    * class that has a {@code List<Employee>} field for an organization's management hierarchy.
    */
   private static class DeferredAdapter<T> extends JsonAdapter<T> {
-    private Type type;
-    private Set<? extends Annotation> annotations;
+    private Object cacheKey;
     private JsonAdapter<T> delegate;
 
-    public DeferredAdapter(Type type, Set<? extends Annotation> annotations) {
-      this.type = type;
-      this.annotations = annotations;
+    public DeferredAdapter(Object cacheKey) {
+      this.cacheKey = cacheKey;
     }
 
     public void ready(JsonAdapter<T> delegate) {
       this.delegate = delegate;
-
-      // Null out the type and annotations so they can be garbage collected.
-      this.type = null;
-      this.annotations = null;
+      this.cacheKey = null;
     }
 
     @Override public T fromJson(JsonReader reader) throws IOException {
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index 7e9c7637..a3bc90bd 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -78,15 +78,23 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Boolean value) throws IOException {
       writer.value(value);
     }
+
+    @Override public String toString() {
+      return "JsonAdapter(Boolean)";
+    }
   };
 
   static final JsonAdapter<Byte> BYTE_JSON_ADAPTER = new JsonAdapter<Byte>() {
     @Override public Byte fromJson(JsonReader reader) throws IOException {
-      return (byte) rangeCheckNextInt(reader, "a byte", Byte.MIN_VALUE, 0xFF);
+      return (byte) rangeCheckNextInt(reader, "a byte", Byte.MIN_VALUE, 0xff);
     }
 
     @Override public void toJson(JsonWriter writer, Byte value) throws IOException {
-      writer.value(value.intValue() & 0xFF);
+      writer.value(value.intValue() & 0xff);
+    }
+
+    @Override public String toString() {
+      return "JsonAdapter(Byte)";
     }
   };
 
@@ -103,6 +111,10 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Character value) throws IOException {
       writer.value(value.toString());
     }
+
+    @Override public String toString() {
+      return "JsonAdapter(Character)";
+    }
   };
 
   static final JsonAdapter<Double> DOUBLE_JSON_ADAPTER = new JsonAdapter<Double>() {
@@ -113,6 +125,10 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Double value) throws IOException {
       writer.value(value.doubleValue());
     }
+
+    @Override public String toString() {
+      return "JsonAdapter(Double)";
+    }
   };
 
   static final JsonAdapter<Float> FLOAT_JSON_ADAPTER = new JsonAdapter<Float>() {
@@ -134,6 +150,10 @@ final class StandardJsonAdapters {
       // Use the Number overload so we write out float precision instead of double precision.
       writer.value(value);
     }
+
+    @Override public String toString() {
+      return "JsonAdapter(Float)";
+    }
   };
 
   static final JsonAdapter<Integer> INTEGER_JSON_ADAPTER = new JsonAdapter<Integer>() {
@@ -144,6 +164,10 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Integer value) throws IOException {
       writer.value(value.intValue());
     }
+
+    @Override public String toString() {
+      return "JsonAdapter(Integer)";
+    }
   };
 
   static final JsonAdapter<Long> LONG_JSON_ADAPTER = new JsonAdapter<Long>() {
@@ -154,6 +178,10 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Long value) throws IOException {
       writer.value(value.longValue());
     }
+
+    @Override public String toString() {
+      return "JsonAdapter(Long)";
+    }
   };
 
   static final JsonAdapter<Short> SHORT_JSON_ADAPTER = new JsonAdapter<Short>() {
@@ -164,6 +192,10 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Short value) throws IOException {
       writer.value(value.intValue());
     }
+
+    @Override public String toString() {
+      return "JsonAdapter(Short)";
+    }
   };
 
   static final JsonAdapter<String> STRING_JSON_ADAPTER = new JsonAdapter<String>() {
@@ -174,6 +206,10 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, String value) throws IOException {
       writer.value(value);
     }
+
+    @Override public String toString() {
+      return "JsonAdapter(String)";
+    }
   };
 
   static <T extends Enum<T>> JsonAdapter<T> enumAdapter(final Class<T> enumType) {
@@ -192,6 +228,10 @@ final class StandardJsonAdapters {
       @Override public void toJson(JsonWriter writer, T value) throws IOException {
         writer.value(value.name());
       }
+
+      @Override public String toString() {
+        return "JsonAdapter(" + enumType.getName() + ")";
+      }
     };
   }
 
@@ -271,5 +311,9 @@ final class StandardJsonAdapters {
       if (Collection.class.isAssignableFrom(valueClass)) return Collection.class;
       return valueClass;
     }
+
+    @Override public String toString() {
+      return "JsonAdapter(Object)";
+    }
   }
 }
diff --git a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
index cc07fabf..391d883c 100644
--- a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
@@ -735,6 +735,70 @@ public final class MoshiTest {
     }
   }
 
+  @Test public void qualifierWithElementsMayNotBeDirectlyRegistered() throws IOException {
+    try {
+      new Moshi.Builder()
+          .add(Boolean.class, Localized.class, StandardJsonAdapters.BOOLEAN_JSON_ADAPTER);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("Use JsonAdapter.Factory for annotations with elements");
+    }
+  }
+
+  @Test public void qualifierWithElements() throws IOException {
+    Moshi moshi = new Moshi.Builder()
+        .add(LocalizedBooleanAdapter.FACTORY)
+        .build();
+
+    Baguette baguette = new Baguette();
+    baguette.avecBeurre = true;
+    baguette.withButter = true;
+
+    JsonAdapter<Baguette> adapter = moshi.adapter(Baguette.class);
+    assertThat(adapter.toJson(baguette))
+        .isEqualTo("{\"avecBeurre\":\"oui\",\"withButter\":\"yes\"}");
+
+    Baguette decoded = adapter.fromJson("{\"avecBeurre\":\"oui\",\"withButter\":\"yes\"}");
+    assertThat(decoded.avecBeurre).isTrue();
+    assertThat(decoded.withButter).isTrue();
+  }
+
+  /** Note that this is the opposite of Gson's behavior, where later adapters are preferred. */
+  @Test public void adaptersRegisteredInOrderOfPrecedence() throws Exception {
+    JsonAdapter<String> adapter1 = new JsonAdapter<String>() {
+      @Override public String fromJson(JsonReader reader) throws IOException {
+        throw new AssertionError();
+      }
+      @Override public void toJson(JsonWriter writer, String value) throws IOException {
+        writer.value("one!");
+      }
+    };
+
+    JsonAdapter<String> adapter2 = new JsonAdapter<String>() {
+      @Override public String fromJson(JsonReader reader) throws IOException {
+        throw new AssertionError();
+      }
+      @Override public void toJson(JsonWriter writer, String value) throws IOException {
+        writer.value("two!");
+      }
+    };
+
+    Moshi moshi = new Moshi.Builder()
+        .add(String.class, adapter1)
+        .add(String.class, adapter2)
+        .build();
+    JsonAdapter<String> adapter = moshi.adapter(String.class).lenient();
+    assertThat(adapter.toJson("a")).isEqualTo("\"one!\"");
+  }
+
+  @Test public void cachingJsonAdapters() throws Exception {
+    Moshi moshi = new Moshi.Builder().build();
+
+    JsonAdapter<MealDeal> adapter1 = moshi.adapter(MealDeal.class);
+    JsonAdapter<MealDeal> adapter2 = moshi.adapter(MealDeal.class);
+    assertThat(adapter1).isSameAs(adapter2);
+  }
+
   static class Pizza {
     final int diameter;
     final boolean extraCheese;
@@ -858,4 +922,52 @@ public final class MoshiTest {
     PAPER,
     SCISSORS
   }
+
+  @Retention(RUNTIME)
+  @JsonQualifier
+  @interface Localized {
+    String value();
+  }
+
+  static class Baguette {
+    @Localized("en") boolean withButter;
+    @Localized("fr") boolean avecBeurre;
+  }
+
+  static class LocalizedBooleanAdapter extends JsonAdapter<Boolean> {
+    private static final JsonAdapter.Factory FACTORY = new JsonAdapter.Factory() {
+      @Override public JsonAdapter<?> create(
+          Type type, Set<? extends Annotation> annotations, Moshi moshi) {
+        if (type == boolean.class) {
+          for (Annotation annotation : annotations) {
+            if (annotation instanceof Localized) {
+              return new LocalizedBooleanAdapter(((Localized) annotation).value());
+            }
+          }
+        }
+        return null;
+      }
+    };
+
+    private final String trueString;
+    private final String falseString;
+
+    public LocalizedBooleanAdapter(String language) {
+      if (language.equals("fr")) {
+        trueString = "oui";
+        falseString = "non";
+      } else {
+        trueString = "yes";
+        falseString = "no";
+      }
+    }
+
+    @Override public Boolean fromJson(JsonReader reader) throws IOException {
+      return reader.nextString().equals(trueString);
+    }
+
+    @Override public void toJson(JsonWriter writer, Boolean value) throws IOException {
+      writer.value(value ? trueString : falseString);
+    }
+  }
 }
diff --git a/pom.xml b/pom.xml
index 5b74cead..91df51f8 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,7 +20,6 @@
   <modules>
     <module>moshi</module>
     <module>examples</module>
-    <module>adapters</module>
   </modules>
 
   <properties>
