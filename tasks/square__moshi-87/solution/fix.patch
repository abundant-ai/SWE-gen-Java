diff --git a/adapters/pom.xml b/adapters/pom.xml
new file mode 100644
index 00000000..70a0e813
--- /dev/null
+++ b/adapters/pom.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.moshi</groupId>
+    <artifactId>moshi-parent</artifactId>
+    <version>1.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>moshi-adapters</artifactId>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/adapters/src/main/java/com/squareup/moshi/Iso8601Utils.java b/adapters/src/main/java/com/squareup/moshi/Iso8601Utils.java
new file mode 100644
index 00000000..3ca492f5
--- /dev/null
+++ b/adapters/src/main/java/com/squareup/moshi/Iso8601Utils.java
@@ -0,0 +1,271 @@
+/*
+ * Copyright (C) 2011 FasterXML, LLC
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.Locale;
+import java.util.TimeZone;
+
+/**
+ * Jacksonâ€™s date formatter, pruned to Moshi's needs. Forked from this file:
+ * https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java
+ *
+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC
+ * friendly than using SimpleDateFormat so highly suitable if you (un)serialize lots of date
+ * objects.
+ *
+ * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh[:]mm]]
+ *
+ * @see <a href="http://www.w3.org/TR/NOTE-datetime">this specification</a>
+ */
+final class Iso8601Utils {
+  /** ID to represent the 'GMT' string */
+  static final String GMT_ID = "GMT";
+
+  /** The GMT timezone, prefetched to avoid more lookups. */
+  static final TimeZone TIMEZONE_Z = TimeZone.getTimeZone(GMT_ID);
+
+  /** Returns {@code date} formatted as yyyy-MM-ddThh:mm:ss.sssZ */
+  public static String format(Date date) {
+    Calendar calendar = new GregorianCalendar(TIMEZONE_Z, Locale.US);
+    calendar.setTime(date);
+
+    // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)
+    int capacity = "yyyy-MM-ddThh:mm:ss.sssZ".length();
+    StringBuilder formatted = new StringBuilder(capacity);
+    padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length());
+    formatted.append('-');
+    padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length());
+    formatted.append('-');
+    padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length());
+    formatted.append('T');
+    padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length());
+    formatted.append(':');
+    padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length());
+    formatted.append(':');
+    padInt(formatted, calendar.get(Calendar.SECOND), "ss".length());
+    formatted.append('.');
+    padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length());
+    formatted.append('Z');
+    return formatted.toString();
+  }
+
+  /**
+   * Parse a date from ISO-8601 formatted string. It expects a format
+   * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]
+   *
+   * @param date ISO string to parse in the appropriate format.
+   * @return the parsed date
+   */
+  public static Date parse(String date) {
+    try {
+      int offset = 0;
+
+      // extract year
+      int year = parseInt(date, offset, offset += 4);
+      if (checkOffset(date, offset, '-')) {
+        offset += 1;
+      }
+
+      // extract month
+      int month = parseInt(date, offset, offset += 2);
+      if (checkOffset(date, offset, '-')) {
+        offset += 1;
+      }
+
+      // extract day
+      int day = parseInt(date, offset, offset += 2);
+      // default time value
+      int hour = 0;
+      int minutes = 0;
+      int seconds = 0;
+      int milliseconds =
+          0; // always use 0 otherwise returned date will include millis of current time
+
+      // if the value has no time component (and no time zone), we are done
+      boolean hasT = checkOffset(date, offset, 'T');
+
+      if (!hasT && (date.length() <= offset)) {
+        Calendar calendar = new GregorianCalendar(year, month - 1, day);
+
+        return calendar.getTime();
+      }
+
+      if (hasT) {
+
+        // extract hours, minutes, seconds and milliseconds
+        hour = parseInt(date, offset += 1, offset += 2);
+        if (checkOffset(date, offset, ':')) {
+          offset += 1;
+        }
+
+        minutes = parseInt(date, offset, offset += 2);
+        if (checkOffset(date, offset, ':')) {
+          offset += 1;
+        }
+        // second and milliseconds can be optional
+        if (date.length() > offset) {
+          char c = date.charAt(offset);
+          if (c != 'Z' && c != '+' && c != '-') {
+            seconds = parseInt(date, offset, offset += 2);
+            if (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds
+            // milliseconds can be optional in the format
+            if (checkOffset(date, offset, '.')) {
+              offset += 1;
+              int endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit
+              int parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits
+              int fraction = parseInt(date, offset, parseEndOffset);
+              milliseconds = (int) (Math.pow(10, 3 - (parseEndOffset - offset)) * fraction);
+              offset = endOffset;
+            }
+          }
+        }
+      }
+
+      // extract timezone
+      if (date.length() <= offset) {
+        throw new IllegalArgumentException("No time zone indicator");
+      }
+
+      TimeZone timezone;
+      char timezoneIndicator = date.charAt(offset);
+
+      if (timezoneIndicator == 'Z') {
+        timezone = TIMEZONE_Z;
+      } else if (timezoneIndicator == '+' || timezoneIndicator == '-') {
+        String timezoneOffset = date.substring(offset);
+        // 18-Jun-2015, tatu: Minor simplification, skip offset of "+0000"/"+00:00"
+        if ("+0000".equals(timezoneOffset) || "+00:00".equals(timezoneOffset)) {
+          timezone = TIMEZONE_Z;
+        } else {
+          // 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...
+          //    not sure why, but it is what it is.
+          String timezoneId = GMT_ID + timezoneOffset;
+          timezone = TimeZone.getTimeZone(timezoneId);
+          String act = timezone.getID();
+          if (!act.equals(timezoneId)) {
+            /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given
+             *    one without. If so, don't sweat.
+             *   Yes, very inefficient. Hopefully not hit often.
+             *   If it becomes a perf problem, add 'loose' comparison instead.
+             */
+            String cleaned = act.replace(":", "");
+            if (!cleaned.equals(timezoneId)) {
+              throw new IndexOutOfBoundsException("Mismatching time zone indicator: "
+                  + timezoneId + " given, resolves to " + timezone.getID());
+            }
+          }
+        }
+      } else {
+        throw new IndexOutOfBoundsException(
+            "Invalid time zone indicator '" + timezoneIndicator + "'");
+      }
+
+      Calendar calendar = new GregorianCalendar(timezone);
+      calendar.setLenient(false);
+      calendar.set(Calendar.YEAR, year);
+      calendar.set(Calendar.MONTH, month - 1);
+      calendar.set(Calendar.DAY_OF_MONTH, day);
+      calendar.set(Calendar.HOUR_OF_DAY, hour);
+      calendar.set(Calendar.MINUTE, minutes);
+      calendar.set(Calendar.SECOND, seconds);
+      calendar.set(Calendar.MILLISECOND, milliseconds);
+
+      return calendar.getTime();
+      // If we get a ParseException it'll already have the right message/offset.
+      // Other exception types can convert here.
+    } catch (IndexOutOfBoundsException | IllegalArgumentException e) {
+      throw new JsonDataException("Not an RFC 3339 date: " + date);
+    }
+  }
+
+  /**
+   * Check if the expected character exist at the given offset in the value.
+   *
+   * @param value the string to check at the specified offset
+   * @param offset the offset to look for the expected character
+   * @param expected the expected character
+   * @return true if the expected character exist at the given offset
+   */
+  private static boolean checkOffset(String value, int offset, char expected) {
+    return (offset < value.length()) && (value.charAt(offset) == expected);
+  }
+
+  /**
+   * Parse an integer located between 2 given offsets in a string
+   *
+   * @param value the string to parse
+   * @param beginIndex the start index for the integer in the string
+   * @param endIndex the end index for the integer in the string
+   * @return the int
+   * @throws NumberFormatException if the value is not a number
+   */
+  private static int parseInt(String value, int beginIndex, int endIndex)
+      throws NumberFormatException {
+    if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {
+      throw new NumberFormatException(value);
+    }
+    // use same logic as in Integer.parseInt() but less generic we're not supporting negative values
+    int i = beginIndex;
+    int result = 0;
+    int digit;
+    if (i < endIndex) {
+      digit = Character.digit(value.charAt(i++), 10);
+      if (digit < 0) {
+        throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
+      }
+      result = -digit;
+    }
+    while (i < endIndex) {
+      digit = Character.digit(value.charAt(i++), 10);
+      if (digit < 0) {
+        throw new NumberFormatException("Invalid number: " + value.substring(beginIndex, endIndex));
+      }
+      result *= 10;
+      result -= digit;
+    }
+    return -result;
+  }
+
+  /**
+   * Zero pad a number to a specified length
+   *
+   * @param buffer buffer to use for padding
+   * @param value the integer value to pad if necessary.
+   * @param length the length of the string we should zero pad
+   */
+  private static void padInt(StringBuilder buffer, int value, int length) {
+    String strValue = Integer.toString(value);
+    for (int i = length - strValue.length(); i > 0; i--) {
+      buffer.append('0');
+    }
+    buffer.append(strValue);
+  }
+
+  /**
+   * Returns the index of the first character in the string that is not a digit, starting at
+   * offset.
+   */
+  private static int indexOfNonDigit(String string, int offset) {
+    for (int i = offset; i < string.length(); i++) {
+      char c = string.charAt(i);
+      if (c < '0' || c > '9') return i;
+    }
+    return string.length();
+  }
+}
diff --git a/adapters/src/main/java/com/squareup/moshi/Rfc3339DateJsonAdapter.java b/adapters/src/main/java/com/squareup/moshi/Rfc3339DateJsonAdapter.java
new file mode 100644
index 00000000..f1108c79
--- /dev/null
+++ b/adapters/src/main/java/com/squareup/moshi/Rfc3339DateJsonAdapter.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.io.IOException;
+import java.util.Date;
+
+/**
+ * Formats dates using <a href="https://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a>, which is
+ * formatted like {@code 2015-09-26T18:23:50.250Z}.
+ */
+public final class Rfc3339DateJsonAdapter extends JsonAdapter<Date> {
+  @Override public synchronized Date fromJson(JsonReader reader) throws IOException {
+    String string = reader.nextString();
+    return Iso8601Utils.parse(string);
+  }
+
+  @Override public synchronized void toJson(JsonWriter writer, Date value) throws IOException {
+    String string = Iso8601Utils.format(value);
+    writer.value(string);
+  }
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
index ba1a0dfc..6a3ec9cf 100644
--- a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
@@ -34,7 +34,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
   }
 
   @Override public JsonAdapter<?> create(
-      final Type type, final Set<? extends Annotation> annotations, final Moshi moshi) {
+      Type type, Set<? extends Annotation> annotations, final Moshi moshi) {
     final AdapterMethod toAdapter = get(toAdapters, type, annotations);
     final AdapterMethod fromAdapter = get(fromAdapters, type, annotations);
     if (toAdapter == null && fromAdapter == null) return null;
@@ -87,10 +87,6 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
           }
         }
       }
-
-      @Override public String toString() {
-        return "JsonAdapter" + annotations + "(" + type + ")";
-      }
     };
   }
 
diff --git a/moshi/src/main/java/com/squareup/moshi/ClassFactory.java b/moshi/src/main/java/com/squareup/moshi/ClassFactory.java
index 01a81709..f7cba545 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassFactory.java
@@ -44,9 +44,6 @@ abstract class ClassFactory<T> {
           Object[] args = null;
           return (T) constructor.newInstance(args);
         }
-        @Override public String toString() {
-          return rawType.getName();
-        }
       };
     } catch (NoSuchMethodException ignored) {
       // No no-args constructor. Fall back to something more magical...
@@ -67,9 +64,6 @@ abstract class ClassFactory<T> {
         @Override public T newInstance() throws InvocationTargetException, IllegalAccessException {
           return (T) allocateInstance.invoke(unsafe, rawType);
         }
-        @Override public String toString() {
-          return rawType.getName();
-        }
       };
     } catch (IllegalAccessException e) {
       throw new AssertionError();
@@ -95,9 +89,6 @@ abstract class ClassFactory<T> {
         @Override public T newInstance() throws InvocationTargetException, IllegalAccessException {
           return (T) newInstance.invoke(null, rawType, constructorId);
         }
-        @Override public String toString() {
-          return rawType.getName();
-        }
       };
     } catch (IllegalAccessException e) {
       throw new AssertionError();
diff --git a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
index 2163620d..4f19e49d 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
@@ -166,10 +166,6 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
     }
   }
 
-  @Override public String toString() {
-    return "JsonAdapter(" + classFactory + ")";
-  }
-
   static class FieldBinding<T> {
     private final Field field;
     private final JsonAdapter<T> adapter;
diff --git a/moshi/src/main/java/com/squareup/moshi/CollectionJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/CollectionJsonAdapter.java
index 03d6623b..39d87459 100644
--- a/moshi/src/main/java/com/squareup/moshi/CollectionJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/CollectionJsonAdapter.java
@@ -85,8 +85,4 @@ abstract class CollectionJsonAdapter<C extends Collection<T>, T> extends JsonAda
     }
     writer.endArray();
   }
-
-  @Override public String toString() {
-    return elementAdapter + ".collection()";
-  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
index 5d41fd1f..8e211de8 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
@@ -75,9 +75,6 @@ public abstract class JsonAdapter<T> {
           delegate.toJson(writer, value);
         }
       }
-      @Override public String toString() {
-        return delegate + ".nullSafe()";
-      }
     };
   }
 
@@ -103,9 +100,6 @@ public abstract class JsonAdapter<T> {
           writer.setLenient(lenient);
         }
       }
-      @Override public String toString() {
-        return delegate + ".lenient()";
-      }
     };
   }
 
@@ -130,9 +124,6 @@ public abstract class JsonAdapter<T> {
       @Override public void toJson(JsonWriter writer, T value) throws IOException {
         delegate.toJson(writer, value);
       }
-      @Override public String toString() {
-        return delegate + ".failOnUnknown()";
-      }
     };
   }
 
diff --git a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
index b0bb34db..c4f15db1 100644
--- a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
@@ -75,8 +75,4 @@ final class MapJsonAdapter<K, V> extends JsonAdapter<Map<K, V>> {
     reader.endObject();
     return result;
   }
-
-  @Override public String toString() {
-    return "JsonAdapter(" + keyAdapter + "=" + valueAdapter + ")";
-  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 4aa279ff..00751756 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -19,11 +19,8 @@ import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
-import java.util.LinkedHashMap;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 
 /**
@@ -32,7 +29,6 @@ import java.util.Set;
 public final class Moshi {
   private final List<JsonAdapter.Factory> factories;
   private final ThreadLocal<List<DeferredAdapter<?>>> reentrantCalls = new ThreadLocal<>();
-  private final Map<Object, JsonAdapter<?>> adapterCache = new LinkedHashMap<>();
 
   private Moshi(Builder builder) {
     List<JsonAdapter.Factory> factories = new ArrayList<>();
@@ -51,77 +47,52 @@ public final class Moshi {
   }
 
   public <T> JsonAdapter<T> adapter(Class<T> type) {
+    // TODO: cache created JSON adapters.
     return adapter(type, Util.NO_ANNOTATIONS);
   }
 
-  @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
   public <T> JsonAdapter<T> adapter(Type type, Set<? extends Annotation> annotations) {
-    // If there's an equivalent adapter in the cache, we're done!
-    Object cacheKey = cacheKey(type, annotations);
-    synchronized (adapterCache) {
-      JsonAdapter<?> result = adapterCache.get(cacheKey);
-      if (result != null) return (JsonAdapter<T>) result;
-    }
+    return createAdapter(0, type, annotations);
+  }
+
+  public <T> JsonAdapter<T> nextAdapter(JsonAdapter.Factory skipPast, Type type,
+      Set<? extends Annotation> annotations) {
+    return createAdapter(factories.indexOf(skipPast) + 1, type, annotations);
+  }
 
-    // Short-circuit if this is a reentrant call.
+  @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
+  private <T> JsonAdapter<T> createAdapter(
+      int firstIndex, Type type, Set<? extends Annotation> annotations) {
     List<DeferredAdapter<?>> deferredAdapters = reentrantCalls.get();
-    if (deferredAdapters != null) {
-      for (int i = 0, size = deferredAdapters.size(); i < size; i++) {
-        DeferredAdapter<?> deferredAdapter = deferredAdapters.get(i);
-        if (deferredAdapter.cacheKey.equals(cacheKey)) {
+    if (deferredAdapters == null) {
+      deferredAdapters = new ArrayList<>();
+      reentrantCalls.set(deferredAdapters);
+    } else if (firstIndex == 0) {
+      // If this is a regular adapter lookup, check that this isn't a reentrant call.
+      for (DeferredAdapter<?> deferredAdapter : deferredAdapters) {
+        if (deferredAdapter.type.equals(type) && deferredAdapter.annotations.equals(annotations)) {
           return (JsonAdapter<T>) deferredAdapter;
         }
       }
-    } else {
-      deferredAdapters = new ArrayList<>();
-      reentrantCalls.set(deferredAdapters);
     }
 
-    // Prepare for re-entrant calls, then ask each factory to create a type adapter.
-    DeferredAdapter<T> deferredAdapter = new DeferredAdapter<>(cacheKey);
+    DeferredAdapter<T> deferredAdapter = new DeferredAdapter<>(type, annotations);
     deferredAdapters.add(deferredAdapter);
     try {
-      for (int i = 0, size = factories.size(); i < size; i++) {
+      for (int i = firstIndex, size = factories.size(); i < size; i++) {
         JsonAdapter<T> result = (JsonAdapter<T>) factories.get(i).create(type, annotations, this);
         if (result != null) {
           deferredAdapter.ready(result);
-          synchronized (adapterCache) {
-            adapterCache.put(cacheKey, result);
-          }
           return result;
         }
       }
     } finally {
       deferredAdapters.remove(deferredAdapters.size() - 1);
-      if (deferredAdapters.isEmpty()) {
-        reentrantCalls.remove();
-      }
     }
 
     throw new IllegalArgumentException("No JsonAdapter for " + type + " annotated " + annotations);
   }
 
-  @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
-  public <T> JsonAdapter<T> nextAdapter(JsonAdapter.Factory skipPast, Type type,
-      Set<? extends Annotation> annotations) {
-    int skipPastIndex = factories.indexOf(skipPast);
-    if (skipPastIndex == -1) {
-      throw new IllegalArgumentException("Unable to skip past unknown factory " + skipPast);
-    }
-    for (int i = skipPastIndex + 1, size = factories.size(); i < size; i++) {
-      JsonAdapter<T> result = (JsonAdapter<T>) factories.get(i).create(type, annotations, this);
-      if (result != null) return result;
-    }
-    throw new IllegalArgumentException("No next JsonAdapter for "
-        + type + " annotated " + annotations);
-  }
-
-  /** Returns an opaque object that's equal if the type and annotations are equal. */
-  private Object cacheKey(Type type, Set<? extends Annotation> annotations) {
-    if (annotations.isEmpty()) return type;
-    return Arrays.asList(type, annotations);
-  }
-
   public static final class Builder {
     private final List<JsonAdapter.Factory> factories = new ArrayList<>();
 
@@ -145,24 +116,22 @@ public final class Moshi {
       if (!annotation.isAnnotationPresent(JsonQualifier.class)) {
         throw new IllegalArgumentException(annotation + " does not have @JsonQualifier");
       }
-      if (annotation.getDeclaredMethods().length > 0) {
-        throw new IllegalArgumentException("Use JsonAdapter.Factory for annotations with elements");
-      }
 
       return add(new JsonAdapter.Factory() {
         @Override public JsonAdapter<?> create(
             Type targetType, Set<? extends Annotation> annotations, Moshi moshi) {
-          if (Util.typesMatch(type, targetType)
-              && annotations.size() == 1
-              && Util.isAnnotationPresent(annotations, annotation)) {
-            return jsonAdapter;
-          }
-          return null;
+          if (!Util.typesMatch(type, targetType)) return null;
+
+          // TODO: check for an annotations exact match.
+          if (!Util.isAnnotationPresent(annotations, annotation)) return null;
+
+          return jsonAdapter;
         }
       });
     }
 
     public Builder add(JsonAdapter.Factory jsonAdapter) {
+      // TODO: define precedence order. Last added wins? First added wins?
       factories.add(jsonAdapter);
       return this;
     }
@@ -185,16 +154,21 @@ public final class Moshi {
    * class that has a {@code List<Employee>} field for an organization's management hierarchy.
    */
   private static class DeferredAdapter<T> extends JsonAdapter<T> {
-    private Object cacheKey;
+    private Type type;
+    private Set<? extends Annotation> annotations;
     private JsonAdapter<T> delegate;
 
-    public DeferredAdapter(Object cacheKey) {
-      this.cacheKey = cacheKey;
+    public DeferredAdapter(Type type, Set<? extends Annotation> annotations) {
+      this.type = type;
+      this.annotations = annotations;
     }
 
     public void ready(JsonAdapter<T> delegate) {
       this.delegate = delegate;
-      this.cacheKey = null;
+
+      // Null out the type and annotations so they can be garbage collected.
+      this.type = null;
+      this.annotations = null;
     }
 
     @Override public T fromJson(JsonReader reader) throws IOException {
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index a3bc90bd..7e9c7637 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -78,23 +78,15 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Boolean value) throws IOException {
       writer.value(value);
     }
-
-    @Override public String toString() {
-      return "JsonAdapter(Boolean)";
-    }
   };
 
   static final JsonAdapter<Byte> BYTE_JSON_ADAPTER = new JsonAdapter<Byte>() {
     @Override public Byte fromJson(JsonReader reader) throws IOException {
-      return (byte) rangeCheckNextInt(reader, "a byte", Byte.MIN_VALUE, 0xff);
+      return (byte) rangeCheckNextInt(reader, "a byte", Byte.MIN_VALUE, 0xFF);
     }
 
     @Override public void toJson(JsonWriter writer, Byte value) throws IOException {
-      writer.value(value.intValue() & 0xff);
-    }
-
-    @Override public String toString() {
-      return "JsonAdapter(Byte)";
+      writer.value(value.intValue() & 0xFF);
     }
   };
 
@@ -111,10 +103,6 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Character value) throws IOException {
       writer.value(value.toString());
     }
-
-    @Override public String toString() {
-      return "JsonAdapter(Character)";
-    }
   };
 
   static final JsonAdapter<Double> DOUBLE_JSON_ADAPTER = new JsonAdapter<Double>() {
@@ -125,10 +113,6 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Double value) throws IOException {
       writer.value(value.doubleValue());
     }
-
-    @Override public String toString() {
-      return "JsonAdapter(Double)";
-    }
   };
 
   static final JsonAdapter<Float> FLOAT_JSON_ADAPTER = new JsonAdapter<Float>() {
@@ -150,10 +134,6 @@ final class StandardJsonAdapters {
       // Use the Number overload so we write out float precision instead of double precision.
       writer.value(value);
     }
-
-    @Override public String toString() {
-      return "JsonAdapter(Float)";
-    }
   };
 
   static final JsonAdapter<Integer> INTEGER_JSON_ADAPTER = new JsonAdapter<Integer>() {
@@ -164,10 +144,6 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Integer value) throws IOException {
       writer.value(value.intValue());
     }
-
-    @Override public String toString() {
-      return "JsonAdapter(Integer)";
-    }
   };
 
   static final JsonAdapter<Long> LONG_JSON_ADAPTER = new JsonAdapter<Long>() {
@@ -178,10 +154,6 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Long value) throws IOException {
       writer.value(value.longValue());
     }
-
-    @Override public String toString() {
-      return "JsonAdapter(Long)";
-    }
   };
 
   static final JsonAdapter<Short> SHORT_JSON_ADAPTER = new JsonAdapter<Short>() {
@@ -192,10 +164,6 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, Short value) throws IOException {
       writer.value(value.intValue());
     }
-
-    @Override public String toString() {
-      return "JsonAdapter(Short)";
-    }
   };
 
   static final JsonAdapter<String> STRING_JSON_ADAPTER = new JsonAdapter<String>() {
@@ -206,10 +174,6 @@ final class StandardJsonAdapters {
     @Override public void toJson(JsonWriter writer, String value) throws IOException {
       writer.value(value);
     }
-
-    @Override public String toString() {
-      return "JsonAdapter(String)";
-    }
   };
 
   static <T extends Enum<T>> JsonAdapter<T> enumAdapter(final Class<T> enumType) {
@@ -228,10 +192,6 @@ final class StandardJsonAdapters {
       @Override public void toJson(JsonWriter writer, T value) throws IOException {
         writer.value(value.name());
       }
-
-      @Override public String toString() {
-        return "JsonAdapter(" + enumType.getName() + ")";
-      }
     };
   }
 
@@ -311,9 +271,5 @@ final class StandardJsonAdapters {
       if (Collection.class.isAssignableFrom(valueClass)) return Collection.class;
       return valueClass;
     }
-
-    @Override public String toString() {
-      return "JsonAdapter(Object)";
-    }
   }
 }
diff --git a/pom.xml b/pom.xml
index 91df51f8..5b74cead 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,6 +20,7 @@
   <modules>
     <module>moshi</module>
     <module>examples</module>
+    <module>adapters</module>
   </modules>
 
   <properties>
