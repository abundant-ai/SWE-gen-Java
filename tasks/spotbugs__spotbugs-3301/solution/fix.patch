diff --git a/CHANGELOG.md b/CHANGELOG.md
index 08449d03e..6e175f3ea 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -10,7 +10,7 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 ### Fixed
 - Fixed html bug descriptions for AT_STALE_THREAD_WRITE_OF_PRIMITIVE and AT_NONATOMIC_64BIT_PRIMITIVE ([#3303](https://github.com/spotbugs/spotbugs/issues/3303))
 - Fixed an `HSM_HIDING_METHOD` false positive when ECJ generates a synthetic method for an enum switch ([#3305](https://github.com/spotbugs/spotbugs/issues/3305))
-
+- Fix `AT_UNSAFE_RESOURCE_ACCESS_IN_THREAD` false negatives, detector depending on method order.
 
 ## 4.9.1 - 2025-02-02
 ### Added
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetector.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetector.java
index 264dc0bd8..40986c661 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetector.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetector.java
@@ -27,6 +27,7 @@ import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
+import edu.umd.cs.findbugs.ba.XFactory;
 import org.apache.bcel.Const;
 import org.apache.bcel.classfile.Attribute;
 import org.apache.bcel.classfile.BootstrapMethods;
@@ -38,10 +39,8 @@ import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.OpcodeStack;
 import edu.umd.cs.findbugs.ba.XField;
 import edu.umd.cs.findbugs.ba.XMethod;
-import edu.umd.cs.findbugs.bcel.BCELUtil;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
 import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
-import edu.umd.cs.findbugs.classfile.MethodDescriptor;
 import edu.umd.cs.findbugs.util.BootstrapMethodsUtil;
 import edu.umd.cs.findbugs.util.CollectionAnalysis;
 import edu.umd.cs.findbugs.util.MethodAnalysis;
@@ -60,7 +59,8 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
     private final BugReporter bugReporter;
 
     private final Set<XField> synchronizedCollectionTypedFields = new HashSet<>();
-    private final Set<MethodDescriptor> methodsUsedInThreads = new HashSet<>();
+    private final Map<XMethod, Set<XMethod>> calledMethodsByMethods = new HashMap<>();
+    private final Set<XMethod> methodsUsedInThreads = new HashSet<>();
     private final Map<XField, FieldData> fieldsUsedInThreads = new HashMap<>();
 
     private boolean synchronizedBlock = false;
@@ -104,14 +104,37 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
     }
 
     private void collectMethodsUsedInThreads(int seen) {
-        if (seen == Const.INVOKEDYNAMIC && getStack().getStackDepth() > 1
-                && "Ljava/lang/Thread;".equals(getStack().getStackItem(1).getSignature())
-                && !isJavaRuntimeMethod()) {
-            getMethodFromBootstrap(getThisClass(), (ConstantInvokeDynamic) getConstantRefOperand()).ifPresent(methodsUsedInThreads::add);
-        } else if ((seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE || seen == Const.INVOKESPECIAL || seen == Const.INVOKESTATIC)
-                && getXMethodOperand() != null && methodsUsedInThreads.contains(getMethodDescriptor())
-                && getClassDescriptor().equals(getXMethodOperand().getClassDescriptor())) {
-            methodsUsedInThreads.add(getMethodDescriptorOperand());
+        if (seen == Const.INVOKEDYNAMIC) {
+            JavaClass javaClass = getThisClass();
+            Optional<Method> lambdaMethod = getMethodFromBootstrap(javaClass, (ConstantInvokeDynamic) getConstantRefOperand());
+            if (lambdaMethod.isPresent()) {
+                XMethod lambdaXMethod = XFactory.createXMethod(javaClass, lambdaMethod.get());
+                calledMethodsByMethods.computeIfAbsent(getXMethod(), v -> new HashSet<>()).add(lambdaXMethod);
+
+                if (getStack().getStackDepth() > 1
+                        && "Ljava/lang/Thread;".equals(getStack().getStackItem(1).getSignature())
+                        && !isJavaRuntimeMethod()) {
+                    addToMethodsUsedInThreads(lambdaXMethod);
+                }
+            }
+
+        } else if ((seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE || seen == Const.INVOKESPECIAL || seen == Const.INVOKESTATIC)) {
+            XMethod calledMethod = getXMethodOperand();
+            if (calledMethod != null) {
+                calledMethodsByMethods.computeIfAbsent(getXMethod(), v -> new HashSet<>()).add(calledMethod);
+
+                if (methodsUsedInThreads.contains(getXMethod())
+                        && getClassDescriptor().equals(calledMethod.getClassDescriptor())) {
+                    addToMethodsUsedInThreads(calledMethod);
+                }
+            }
+        }
+    }
+
+    private void addToMethodsUsedInThreads(XMethod methodToAdd) {
+        methodsUsedInThreads.add(methodToAdd);
+        if (calledMethodsByMethods.containsKey(methodToAdd)) {
+            methodsUsedInThreads.addAll(calledMethodsByMethods.get(methodToAdd));
         }
     }
 
@@ -129,14 +152,11 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
                 .anyMatch(method -> "java.lang.Runtime".equals(method.getClassName()));
     }
 
-    private Optional<MethodDescriptor> getMethodFromBootstrap(JavaClass javaClass, ConstantInvokeDynamic constDyn) {
+    private Optional<Method> getMethodFromBootstrap(JavaClass javaClass, ConstantInvokeDynamic constDyn) {
         for (Attribute attr : javaClass.getAttributes()) {
             if (attr instanceof BootstrapMethods) {
-                Optional<Method> method = BootstrapMethodsUtil.getMethodFromBootstrap((BootstrapMethods) attr,
+                return BootstrapMethodsUtil.getMethodFromBootstrap((BootstrapMethods) attr,
                         constDyn.getBootstrapMethodAttrIndex(), getConstantPool(), javaClass);
-                if (method.isPresent()) {
-                    return Optional.of(BCELUtil.getMethodDescriptor(javaClass, method.get()));
-                }
             }
         }
         return Optional.empty();
@@ -145,18 +165,21 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
     private void collectFieldsUsedInThreads(int seen) throws CheckedAnalysisException {
         if ((seen == Const.PUTFIELD || seen == Const.PUTSTATIC) && getStack().getStackDepth() > 0
                 && !MethodAnalysis.isDuplicatedLocation(getMethodDescriptor(), getPC())
-                && methodsUsedInThreads.contains(getMethodDescriptor())) {
+                && methodsUsedInThreads.contains(getXMethod())) {
             OpcodeStack.Item stackItem = getStack().getStackItem(0);
-            if (stackItem.getReturnValueOf() != null && CollectionAnalysis.isSynchronizedCollection(stackItem.getReturnValueOf())) {
-                synchronizedCollectionTypedFields.add(getXFieldOperand());
-            } else if (!isAtomicTypedField(getXFieldOperand())
-                    && !(Const.CONSTRUCTOR_NAME.equals(getMethodName()) || Const.STATIC_INITIALIZER_NAME.equals(getMethodName()))) {
-                createOrUpdateFieldData(getXFieldOperand(), true, getMethod(), getXMethodOperand());
+            XField field = getXFieldOperand();
+            if (field != null) {
+                if (stackItem.getReturnValueOf() != null && CollectionAnalysis.isSynchronizedCollection(stackItem.getReturnValueOf())) {
+                    synchronizedCollectionTypedFields.add(field);
+                } else if (!isAtomicTypedField(field)
+                        && !(Const.CONSTRUCTOR_NAME.equals(getMethodName()) || Const.STATIC_INITIALIZER_NAME.equals(getMethodName()))) {
+                    createOrUpdateFieldData(field, true, getMethod(), getXMethodOperand());
+                }
             }
         } else if ((seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE || seen == Const.INVOKESPECIAL || seen == Const.INVOKESTATIC)
                 && getXMethodOperand() != null && getStack().getStackDepth() > 0
                 && !MethodAnalysis.isDuplicatedLocation(getMethodDescriptor(), getPC())
-                && methodsUsedInThreads.contains(getMethodDescriptor())) {
+                && methodsUsedInThreads.contains(getXMethod())) {
             // The field is accessed always be the last item in the stack, because the earlier elements are the arguments
             XField xField = getStack().getStackItem(getStack().getStackDepth() - 1).getXField();
             if (xField != null && !isAtomicTypedField(xField)) {
@@ -169,7 +192,7 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
         return xField.getSignature().contains("java/util/concurrent/atomic") || synchronizedCollectionTypedFields.contains(xField);
     }
 
-    private void createOrUpdateFieldData(XField xField, boolean putfield, Method method, XMethod xMethod) {
+    private void createOrUpdateFieldData(XField xField, boolean putfield, Method containerMethod, XMethod xMethod) {
         BugInstance bug = new BugInstance(this, "AT_UNSAFE_RESOURCE_ACCESS_IN_THREAD", LOW_PRIORITY)
                 .addClassAndMethod(this)
                 .addSourceLine(this)
@@ -179,10 +202,10 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
         }
 
         FieldData data = fieldsUsedInThreads.computeIfAbsent(xField, value -> new FieldData());
-        data.methodBugs.computeIfAbsent(method, value -> new HashSet<>()).add(bug);
+        data.methodBugs.computeIfAbsent(containerMethod, value -> new HashSet<>()).add(bug);
         data.onlySynchronized &= synchronizedBlock;
         data.onlyPutField &= putfield;
-        data.modified |= putfield || MutableClasses.looksLikeASetter(xMethod.getName());
+        data.modified |= putfield || (xMethod != null && MutableClasses.looksLikeASetter(xMethod.getName()));
     }
 
     @Override
@@ -211,5 +234,6 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
         synchronizedCollectionTypedFields.clear();
         methodsUsedInThreads.clear();
         fieldsUsedInThreads.clear();
+        calledMethodsByMethods.clear();
     }
 }
diff --git a/spotbugsTestCases/src/java/commonResources/UnsafeFieldUsage4.java b/spotbugsTestCases/src/java/commonResources/UnsafeFieldUsage4.java
new file mode 100644
index 000000000..b3415342c
--- /dev/null
+++ b/spotbugsTestCases/src/java/commonResources/UnsafeFieldUsage4.java
@@ -0,0 +1,22 @@
+package commonResources;
+
+public class UnsafeFieldUsage4 {
+
+    private Vehicle vehicle = new Vehicle();
+
+    private void runThread() {
+        createVehicle();
+    }
+
+    private void createVehicle() {
+        vehicle = new Vehicle();
+    }
+
+    public UnsafeFieldUsage4() {
+        Thread t1 = new Thread(() -> vehicle.setModel("Toyota"));
+        t1.start();
+
+        Thread t2 = new Thread(this::runThread);
+        t2.start();
+    }
+}
