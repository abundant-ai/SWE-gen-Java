diff --git a/CHANGELOG.md b/CHANGELOG.md
index 6e175f3ea..08449d03e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -10,7 +10,7 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 ### Fixed
 - Fixed html bug descriptions for AT_STALE_THREAD_WRITE_OF_PRIMITIVE and AT_NONATOMIC_64BIT_PRIMITIVE ([#3303](https://github.com/spotbugs/spotbugs/issues/3303))
 - Fixed an `HSM_HIDING_METHOD` false positive when ECJ generates a synthetic method for an enum switch ([#3305](https://github.com/spotbugs/spotbugs/issues/3305))
-- Fix `AT_UNSAFE_RESOURCE_ACCESS_IN_THREAD` false negatives, detector depending on method order.
+
 
 ## 4.9.1 - 2025-02-02
 ### Added
diff --git a/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetectorTest.java b/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetectorTest.java
index 4e84f7b19..bc238932c 100644
--- a/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetectorTest.java
+++ b/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetectorTest.java
@@ -55,16 +55,6 @@ class ResourceInMultipleThreadsDetectorTest extends AbstractIntegrationTest {
         assertBugInMethodAtLine("AT_UNSAFE_RESOURCE_ACCESS_IN_THREAD", "UnsafeFieldUsage3", "createVehicle", 8);
     }
 
-    @Test
-    void testUnsafeFieldUsages4() {
-        performAnalysis("commonResources/UnsafeFieldUsage4.class",
-                "commonResources/Vehicle.class",
-                "commonResources/Vehicle$Builder.class");
-        assertBugTypeCount("AT_UNSAFE_RESOURCE_ACCESS_IN_THREAD", 2);
-        assertBugInMethodAtLine("AT_UNSAFE_RESOURCE_ACCESS_IN_THREAD", "UnsafeFieldUsage4", "lambda$new$0", 16);
-        assertBugInMethodAtLine("AT_UNSAFE_RESOURCE_ACCESS_IN_THREAD", "UnsafeFieldUsage4", "createVehicle", 12);
-    }
-
     @Test
     void testSynchronizedUnsafeFieldUsage() {
         performAnalysis("commonResources/SynchronizedUnsafeFieldUsage.class",
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetector.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetector.java
index 40986c661..264dc0bd8 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetector.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ResourceInMultipleThreadsDetector.java
@@ -27,7 +27,6 @@ import java.util.Set;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 
-import edu.umd.cs.findbugs.ba.XFactory;
 import org.apache.bcel.Const;
 import org.apache.bcel.classfile.Attribute;
 import org.apache.bcel.classfile.BootstrapMethods;
@@ -39,8 +38,10 @@ import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.OpcodeStack;
 import edu.umd.cs.findbugs.ba.XField;
 import edu.umd.cs.findbugs.ba.XMethod;
+import edu.umd.cs.findbugs.bcel.BCELUtil;
 import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
 import edu.umd.cs.findbugs.classfile.CheckedAnalysisException;
+import edu.umd.cs.findbugs.classfile.MethodDescriptor;
 import edu.umd.cs.findbugs.util.BootstrapMethodsUtil;
 import edu.umd.cs.findbugs.util.CollectionAnalysis;
 import edu.umd.cs.findbugs.util.MethodAnalysis;
@@ -59,8 +60,7 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
     private final BugReporter bugReporter;
 
     private final Set<XField> synchronizedCollectionTypedFields = new HashSet<>();
-    private final Map<XMethod, Set<XMethod>> calledMethodsByMethods = new HashMap<>();
-    private final Set<XMethod> methodsUsedInThreads = new HashSet<>();
+    private final Set<MethodDescriptor> methodsUsedInThreads = new HashSet<>();
     private final Map<XField, FieldData> fieldsUsedInThreads = new HashMap<>();
 
     private boolean synchronizedBlock = false;
@@ -104,37 +104,14 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
     }
 
     private void collectMethodsUsedInThreads(int seen) {
-        if (seen == Const.INVOKEDYNAMIC) {
-            JavaClass javaClass = getThisClass();
-            Optional<Method> lambdaMethod = getMethodFromBootstrap(javaClass, (ConstantInvokeDynamic) getConstantRefOperand());
-            if (lambdaMethod.isPresent()) {
-                XMethod lambdaXMethod = XFactory.createXMethod(javaClass, lambdaMethod.get());
-                calledMethodsByMethods.computeIfAbsent(getXMethod(), v -> new HashSet<>()).add(lambdaXMethod);
-
-                if (getStack().getStackDepth() > 1
-                        && "Ljava/lang/Thread;".equals(getStack().getStackItem(1).getSignature())
-                        && !isJavaRuntimeMethod()) {
-                    addToMethodsUsedInThreads(lambdaXMethod);
-                }
-            }
-
-        } else if ((seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE || seen == Const.INVOKESPECIAL || seen == Const.INVOKESTATIC)) {
-            XMethod calledMethod = getXMethodOperand();
-            if (calledMethod != null) {
-                calledMethodsByMethods.computeIfAbsent(getXMethod(), v -> new HashSet<>()).add(calledMethod);
-
-                if (methodsUsedInThreads.contains(getXMethod())
-                        && getClassDescriptor().equals(calledMethod.getClassDescriptor())) {
-                    addToMethodsUsedInThreads(calledMethod);
-                }
-            }
-        }
-    }
-
-    private void addToMethodsUsedInThreads(XMethod methodToAdd) {
-        methodsUsedInThreads.add(methodToAdd);
-        if (calledMethodsByMethods.containsKey(methodToAdd)) {
-            methodsUsedInThreads.addAll(calledMethodsByMethods.get(methodToAdd));
+        if (seen == Const.INVOKEDYNAMIC && getStack().getStackDepth() > 1
+                && "Ljava/lang/Thread;".equals(getStack().getStackItem(1).getSignature())
+                && !isJavaRuntimeMethod()) {
+            getMethodFromBootstrap(getThisClass(), (ConstantInvokeDynamic) getConstantRefOperand()).ifPresent(methodsUsedInThreads::add);
+        } else if ((seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE || seen == Const.INVOKESPECIAL || seen == Const.INVOKESTATIC)
+                && getXMethodOperand() != null && methodsUsedInThreads.contains(getMethodDescriptor())
+                && getClassDescriptor().equals(getXMethodOperand().getClassDescriptor())) {
+            methodsUsedInThreads.add(getMethodDescriptorOperand());
         }
     }
 
@@ -152,11 +129,14 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
                 .anyMatch(method -> "java.lang.Runtime".equals(method.getClassName()));
     }
 
-    private Optional<Method> getMethodFromBootstrap(JavaClass javaClass, ConstantInvokeDynamic constDyn) {
+    private Optional<MethodDescriptor> getMethodFromBootstrap(JavaClass javaClass, ConstantInvokeDynamic constDyn) {
         for (Attribute attr : javaClass.getAttributes()) {
             if (attr instanceof BootstrapMethods) {
-                return BootstrapMethodsUtil.getMethodFromBootstrap((BootstrapMethods) attr,
+                Optional<Method> method = BootstrapMethodsUtil.getMethodFromBootstrap((BootstrapMethods) attr,
                         constDyn.getBootstrapMethodAttrIndex(), getConstantPool(), javaClass);
+                if (method.isPresent()) {
+                    return Optional.of(BCELUtil.getMethodDescriptor(javaClass, method.get()));
+                }
             }
         }
         return Optional.empty();
@@ -165,21 +145,18 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
     private void collectFieldsUsedInThreads(int seen) throws CheckedAnalysisException {
         if ((seen == Const.PUTFIELD || seen == Const.PUTSTATIC) && getStack().getStackDepth() > 0
                 && !MethodAnalysis.isDuplicatedLocation(getMethodDescriptor(), getPC())
-                && methodsUsedInThreads.contains(getXMethod())) {
+                && methodsUsedInThreads.contains(getMethodDescriptor())) {
             OpcodeStack.Item stackItem = getStack().getStackItem(0);
-            XField field = getXFieldOperand();
-            if (field != null) {
-                if (stackItem.getReturnValueOf() != null && CollectionAnalysis.isSynchronizedCollection(stackItem.getReturnValueOf())) {
-                    synchronizedCollectionTypedFields.add(field);
-                } else if (!isAtomicTypedField(field)
-                        && !(Const.CONSTRUCTOR_NAME.equals(getMethodName()) || Const.STATIC_INITIALIZER_NAME.equals(getMethodName()))) {
-                    createOrUpdateFieldData(field, true, getMethod(), getXMethodOperand());
-                }
+            if (stackItem.getReturnValueOf() != null && CollectionAnalysis.isSynchronizedCollection(stackItem.getReturnValueOf())) {
+                synchronizedCollectionTypedFields.add(getXFieldOperand());
+            } else if (!isAtomicTypedField(getXFieldOperand())
+                    && !(Const.CONSTRUCTOR_NAME.equals(getMethodName()) || Const.STATIC_INITIALIZER_NAME.equals(getMethodName()))) {
+                createOrUpdateFieldData(getXFieldOperand(), true, getMethod(), getXMethodOperand());
             }
         } else if ((seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE || seen == Const.INVOKESPECIAL || seen == Const.INVOKESTATIC)
                 && getXMethodOperand() != null && getStack().getStackDepth() > 0
                 && !MethodAnalysis.isDuplicatedLocation(getMethodDescriptor(), getPC())
-                && methodsUsedInThreads.contains(getXMethod())) {
+                && methodsUsedInThreads.contains(getMethodDescriptor())) {
             // The field is accessed always be the last item in the stack, because the earlier elements are the arguments
             XField xField = getStack().getStackItem(getStack().getStackDepth() - 1).getXField();
             if (xField != null && !isAtomicTypedField(xField)) {
@@ -192,7 +169,7 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
         return xField.getSignature().contains("java/util/concurrent/atomic") || synchronizedCollectionTypedFields.contains(xField);
     }
 
-    private void createOrUpdateFieldData(XField xField, boolean putfield, Method containerMethod, XMethod xMethod) {
+    private void createOrUpdateFieldData(XField xField, boolean putfield, Method method, XMethod xMethod) {
         BugInstance bug = new BugInstance(this, "AT_UNSAFE_RESOURCE_ACCESS_IN_THREAD", LOW_PRIORITY)
                 .addClassAndMethod(this)
                 .addSourceLine(this)
@@ -202,10 +179,10 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
         }
 
         FieldData data = fieldsUsedInThreads.computeIfAbsent(xField, value -> new FieldData());
-        data.methodBugs.computeIfAbsent(containerMethod, value -> new HashSet<>()).add(bug);
+        data.methodBugs.computeIfAbsent(method, value -> new HashSet<>()).add(bug);
         data.onlySynchronized &= synchronizedBlock;
         data.onlyPutField &= putfield;
-        data.modified |= putfield || (xMethod != null && MutableClasses.looksLikeASetter(xMethod.getName()));
+        data.modified |= putfield || MutableClasses.looksLikeASetter(xMethod.getName());
     }
 
     @Override
@@ -234,6 +211,5 @@ public class ResourceInMultipleThreadsDetector extends OpcodeStackDetector {
         synchronizedCollectionTypedFields.clear();
         methodsUsedInThreads.clear();
         fieldsUsedInThreads.clear();
-        calledMethodsByMethods.clear();
     }
 }
diff --git a/spotbugsTestCases/src/java/commonResources/UnsafeFieldUsage4.java b/spotbugsTestCases/src/java/commonResources/UnsafeFieldUsage4.java
deleted file mode 100644
index b3415342c..000000000
--- a/spotbugsTestCases/src/java/commonResources/UnsafeFieldUsage4.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package commonResources;
-
-public class UnsafeFieldUsage4 {
-
-    private Vehicle vehicle = new Vehicle();
-
-    private void runThread() {
-        createVehicle();
-    }
-
-    private void createVehicle() {
-        vehicle = new Vehicle();
-    }
-
-    public UnsafeFieldUsage4() {
-        Thread t1 = new Thread(() -> vehicle.setModel("Toyota"));
-        t1.start();
-
-        Thread t2 = new Thread(this::runThread);
-        t2.start();
-    }
-}
