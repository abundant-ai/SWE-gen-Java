diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
index 9f8337669..72401b1f4 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
@@ -67,12 +67,8 @@ on GitHub.
 
 ==== New Features and Improvements
 
-* `@TempDir` can now be used to create multiple temporary directories. Instead of creating
-  a single temporary directory per context (i.e. test class or method) every declaration
-  of the `@TempDir` annotation on a field or method parameter now results in a separate
-  temporary directory. To revert to the old behavior of using a single temporary directory
-  for the entire test class or method (depending on which level the annotation is used),
-  you can set the `junit.jupiter.tempdir.scope` configuration parameter to `per_context`.
+* `@TempDir` now supports creating multiple temporary directories via an identifier
+  specified on the annotation (e.g. `@TempDir("a")` and `@TempDir("b")`).
 * New `named()` static factory method in the `Named` interface that serves as an _alias_
   for `Named.of()`. `named()` is intended to be used via `import static`.
 * New `class` URI scheme for dynamic test sources. This allows tests to be located using
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 8cbc3e9fd..92512297e 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -2197,7 +2197,8 @@ its content.
 include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_parameter_injection]
 ----
 
-You can inject multiple temporary directories by specifying multiple annotated parameters.
+You can inject multiple temporary directories by specifying explicit identifiers via the
+annotation parameter.
 
 [source,java,indent=0]
 .A test method that requires multiple temporary directories
@@ -2205,19 +2206,13 @@ You can inject multiple temporary directories by specifying multiple annotated p
 include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_multiple_directories]
 ----
 
-WARNING: To revert to the old behavior of using a single temporary directory for the
-entire test class or method (depending on which level the annotation is used), you can set
-the `junit.jupiter.tempdir.scope` configuration parameter to `per_context`. However,
-please note that this option is deprecated and will be removed in a future release.
-
-`@TempDir` is not supported on constructor parameters. If you wish to retain a single
-reference to a temp directory across lifecycle methods and the current test method, please
-use field injection, by annotating a non-private instance field with `@TempDir`.
+WARNING: `@TempDir` is not supported on constructor parameters. If you wish to retain a
+single reference to a temp directory across lifecycle methods and the current test method,
+please use field injection, by annotating a non-private instance field with `@TempDir`.
 
 The following example stores a _shared_ temporary directory in a `static` field. This
 allows the same `sharedTempDir` to be used in all lifecycle methods and test methods of
-the test class. For better isolation, you should use an instance field so that each test
-method uses a separate directory.
+the test class.
 
 [source,java,indent=0]
 .A test class that shares a temporary directory across test methods
diff --git a/documentation/src/test/java/example/TempDirectoryDemo.java b/documentation/src/test/java/example/TempDirectoryDemo.java
index 1daba23a2..4eadfcb4a 100644
--- a/documentation/src/test/java/example/TempDirectoryDemo.java
+++ b/documentation/src/test/java/example/TempDirectoryDemo.java
@@ -12,7 +12,6 @@ package example;
 
 import static java.util.Collections.singletonList;
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotEquals;
 
 import java.io.IOException;
 import java.nio.file.Files;
@@ -38,13 +37,12 @@ class TempDirectoryDemo {
 
 	// tag::user_guide_multiple_directories[]
 	@Test
-	void copyFileFromSourceToTarget(@TempDir Path source, @TempDir Path target) throws IOException {
+	void copyFileFromSourceToTarget(@TempDir("from") Path source, @TempDir("to") Path target) throws IOException {
 		Path sourceFile = source.resolve("test.txt");
-		new ListWriter(sourceFile).write("a", "b", "c");
 
+		new ListWriter(sourceFile).write("a", "b", "c");
 		Path targetFile = Files.copy(sourceFile, target.resolve("test.txt"));
 
-		assertNotEquals(sourceFile, targetFile);
 		assertEquals(singletonList("a,b,c"), Files.readAllLines(targetFile));
 	}
 	// end::user_guide_multiple_directories[]
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java
index 282f6f797..40e5d1eef 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java
@@ -647,13 +647,13 @@ public interface ExtensionContext {
 		public static Namespace create(Object... parts) {
 			Preconditions.notEmpty(parts, "parts array must not be null or empty");
 			Preconditions.containsNoNullElements(parts, "individual parts must not be null");
-			return new Namespace(new ArrayList<>(Arrays.asList(parts)));
+			return new Namespace(parts);
 		}
 
-		private final List<Object> parts;
+		private final List<?> parts;
 
-		private Namespace(List<Object> parts) {
-			this.parts = parts;
+		private Namespace(Object... parts) {
+			this.parts = new ArrayList<>(Arrays.asList(parts));
 		}
 
 		@Override
@@ -673,22 +673,6 @@ public interface ExtensionContext {
 			return this.parts.hashCode();
 		}
 
-		/**
-		 * Create a new namespace by appending the supplied {@code parts} to the
-		 * existing sequence of parts in this namespace.
-		 *
-		 * @return new namespace; never {@code null}
-		 * @since 5.8
-		 */
-		@API(status = EXPERIMENTAL, since = "5.8")
-		public Namespace append(Object... parts) {
-			Preconditions.notEmpty(parts, "parts array must not be null or empty");
-			Preconditions.containsNoNullElements(parts, "individual parts must not be null");
-			ArrayList<Object> newParts = new ArrayList<>(this.parts.size() + parts.length);
-			newParts.addAll(this.parts);
-			Collections.addAll(newParts, parts);
-			return new Namespace(newParts);
-		}
 	}
 
 }
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDir.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDir.java
index 33ca4dc2c..ddd1ff243 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDir.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDir.java
@@ -30,51 +30,47 @@ import org.junit.jupiter.api.extension.ParameterResolutionException;
  * or a parameter in a lifecycle method or test method of type {@link Path} or
  * {@link File} that should be resolved into a temporary directory.
  *
+ * <p>Multiple temporary directories can be created by supplying different
+ * {@linkplain #value identifiers} on the annotation.
+ *
  * <p>Please note that {@code @TempDir} is not supported on constructor
  * parameters. Please use field injection instead, by annotating a non-private
  * instance field with {@code @TempDir}.
  *
- * <h3>Creation</h3>
+ * <h3>Temporary Directory Creation</h3>
  *
- * <p>The temporary directory is only created if a field in a test class or a
- * parameter in a lifecycle method or test method is annotated with
- * {@code @TempDir}. If the field type or parameter type is neither {@link Path}
- * nor {@link File} or if the temporary directory cannot be created, an
+ * <p>The temporary directory with the supplied {@linkplain #value identifier}
+ * is only created if a field in a test class or a parameter in a lifecycle
+ * method or test method is annotated with {@code @TempDir}. If the field type
+ * or parameter type is neither {@link Path} nor {@link File} or if the
+ * temporary directory cannot be created, an
  * {@link ExtensionConfigurationException} or a
  * {@link ParameterResolutionException} will be thrown as appropriate. In
  * addition, a {@code ParameterResolutionException} will be thrown for a
  * constructor parameter annotated with {@code @TempDir}.
  *
- * <h3>Scope</h3>
- *
- * <p>By default, a separate temporary directory is created for every
- * declaration of the {@code @TempDir} annotation. If you want to share a
- * temporary directory across all tests in a test class, you should declare the
- * annotation on a {@code static} field or on a parameter of a
- * {@link org.junit.jupiter.api.BeforeAll @BeforeAll} method.
+ * <h3>Temporary Directory Scope</h3>
  *
- * <h4>Old behavior</h4>
- * <p>You can revert to the old behavior of using a single temporary directory
- * by setting the {@code junit.jupiter.tempdir.scope} configuration parameter to
- * {@code per_context}. In that case, the scope of the temporary directory
- * depends on where the first {@code @TempDir} annotation is encountered when
- * executing a test class. The temporary directory will be shared by all tests
- * in a class when the annotation is present on a {@code static} field or on a
- * parameter of a {@link org.junit.jupiter.api.BeforeAll @BeforeAll} method.
- * Otherwise &mdash; for example, when {@code @TempDir} is only used on instance
- * fields or on parameters in test,
- * {@link org.junit.jupiter.api.BeforeEach @BeforeEach}, or
- * {@link org.junit.jupiter.api.AfterEach @AfterEach} methods &mdash; each test
- * will use its own temporary directory.
+ * <p>The scope of the temporary directory depends on where the first
+ * {@code @TempDir} annotation with the supplied {@linkplain #value identifier}
+ * is encountered when executing a test class. The temporary directory with that
+ * identifier will be shared by all tests in a class when the annotation is
+ * present with the same identifier on a {@code static} field or on a parameter
+ * of a {@link org.junit.jupiter.api.BeforeAll @BeforeAll} method. Otherwise –
+ * for example, when {@code @TempDir} is only used on instance fields or on
+ * parameters in test, {@link org.junit.jupiter.api.BeforeEach @BeforeEach}, or
+ * {@link org.junit.jupiter.api.AfterEach @AfterEach} methods – each test will
+ * use its own temporary directory.
  *
- * <h3>Deletion</h3>
+ * <h3>Temporary Directory Deletion</h3>
  *
- * <p>When the end of the scope of a temporary directory is reached, i.e. when
- * the test method or class has finished execution, JUnit will attempt to
- * recursively delete all files and directories in the temporary directory
- * and, finally, the temporary directory itself. In case deletion of a file or
- * directory fails, an {@link IOException} will be thrown that will cause the
- * test or test class to fail.
+ * <p>When the end of the scope of a temporary directory with a certain
+ * {@linkplain #value identifier} is reached, i.e. when the test method or class
+ * has finished execution, JUnit will attempt to recursively delete all files
+ * and directories in the temporary directory and, finally, the temporary
+ * directory itself. In case deletion of a file or directory fails, an
+ * {@link IOException} will be thrown that will cause the test or test class to
+ * fail.
  *
  * @since 5.4
  */
@@ -83,4 +79,10 @@ import org.junit.jupiter.api.extension.ParameterResolutionException;
 @Documented
 @API(status = EXPERIMENTAL, since = "5.4")
 public @interface TempDir {
+	/**
+	 * The identifier of the temporary directory.
+	 *
+	 * @since 5.8
+	 */
+	String value() default "";
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
index 23110828d..9c2c92bd1 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/Constants.java
@@ -10,7 +10,6 @@
 
 package org.junit.jupiter.engine;
 
-import static org.apiguardian.api.API.Status.DEPRECATED;
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 import static org.junit.platform.engine.support.hierarchical.DefaultParallelExecutionConfigurationStrategy.CONFIG_CUSTOM_CLASS_PROPERTY_NAME;
@@ -443,7 +442,7 @@ public final class Constants {
 	 * <li>{@code disabled_on_debug}: disables timeouts while debugging
 	 * </ul>
 	 *
-	 * <p>If not specified, the default is {@code enabled}.
+	 * <p>If not specified, the default is {@code "enabled"}.
 	 *
 	 * @since 5.6
 	 */
@@ -459,7 +458,7 @@ public final class Constants {
 	 * implement {@link org.junit.jupiter.api.MethodOrderer}.
 	 *
 	 * <p>If not specified, test methods will be ordered using an algorithm that
-	 * is deterministic but intentionally non-obvious.
+	 * is deterministic but intentionally nonobvious.
 	 */
 	@API(status = EXPERIMENTAL, since = "5.7")
 	public static final String DEFAULT_TEST_METHOD_ORDER_PROPERTY_NAME = JupiterConfiguration.DEFAULT_TEST_METHOD_ORDER_PROPERTY_NAME;
@@ -475,25 +474,6 @@ public final class Constants {
 	@API(status = EXPERIMENTAL, since = "5.8")
 	public static final String DEFAULT_TEST_CLASS_ORDER_PROPERTY_NAME = JupiterConfiguration.DEFAULT_TEST_CLASS_ORDER_PROPERTY_NAME;
 
-	/**
-	 * Property name used to set the scope of temporary directories created via
-	 * {@link org.junit.jupiter.api.io.TempDir @TempDir} annotation: {@value}
-	 *
-	 * <h3>Supported Values</h3>
-	 * <ul>
-	 * <li>{@code per_context}: creates a single temporary directory for the
-	 * entire test class or method, depending on where it's first declared
-	 * <li>{@code per_declaration}: creates separate temporary directories for
-	 * each declaration site of the {@code @TempDir} annotation.
-	 * </ul>
-	 *
-	 * <p>If not specified, the default is {@code per_declaration}.
-	 */
-	@SuppressWarnings("DeprecatedIsStillUsed")
-	@Deprecated
-	@API(status = DEPRECATED, since = "5.8")
-	public static final String TEMP_DIR_SCOPE_PROPERTY_NAME = JupiterConfiguration.TEMP_DIR_SCOPE_PROPERTY_NAME;
-
 	private Constants() {
 		/* no-op */
 	}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/EnumConfigurationParameterConverter.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/EnumConfigurationParameterConverter.java
index 8bb37ee49..47cfb8bad 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/EnumConfigurationParameterConverter.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/EnumConfigurationParameterConverter.java
@@ -10,13 +10,8 @@
 
 package org.junit.jupiter.engine.config;
 
-import static org.apiguardian.api.API.Status.INTERNAL;
-
-import java.util.Locale;
 import java.util.Optional;
-import java.util.function.Function;
 
-import org.apiguardian.api.API;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.commons.util.Preconditions;
@@ -25,15 +20,14 @@ import org.junit.platform.engine.ConfigurationParameters;
 /**
  * @since 5.4
  */
-@API(status = INTERNAL, since = "5.8")
-public class EnumConfigurationParameterConverter<E extends Enum<E>> {
+class EnumConfigurationParameterConverter<E extends Enum<E>> {
 
 	private static final Logger logger = LoggerFactory.getLogger(EnumConfigurationParameterConverter.class);
 
 	private final Class<E> enumType;
 	private final String enumDisplayName;
 
-	public EnumConfigurationParameterConverter(Class<E> enumType, String enumDisplayName) {
+	EnumConfigurationParameterConverter(Class<E> enumType, String enumDisplayName) {
 		this.enumType = enumType;
 		this.enumDisplayName = enumDisplayName;
 	}
@@ -41,21 +35,15 @@ public class EnumConfigurationParameterConverter<E extends Enum<E>> {
 	E get(ConfigurationParameters configParams, String key, E defaultValue) {
 		Preconditions.notNull(configParams, "ConfigurationParameters must not be null");
 
-		return get(key, configParams::get, defaultValue);
-	}
-
-	public E get(String key, Function<String, Optional<String>> lookup, E defaultValue) {
-
-		Optional<String> value = lookup.apply(key);
-
-		if (value.isPresent()) {
-			String constantName = null;
+		Optional<String> optional = configParams.get(key);
+		String constantName = null;
+		if (optional.isPresent()) {
 			try {
-				constantName = value.get().trim().toUpperCase(Locale.ROOT);
-				E result = Enum.valueOf(enumType, constantName);
+				constantName = optional.get().trim().toUpperCase();
+				E value = Enum.valueOf(enumType, constantName);
 				logger.info(() -> String.format("Using %s '%s' set via the '%s' configuration parameter.",
-					enumDisplayName, result, key));
-				return result;
+					enumDisplayName, value, key));
+				return value;
 			}
 			catch (Exception ex) {
 				// local copy necessary for use in lambda expression
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/JupiterConfiguration.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/JupiterConfiguration.java
index ce1c96704..2259d9673 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/JupiterConfiguration.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/JupiterConfiguration.java
@@ -41,7 +41,6 @@ public interface JupiterConfiguration {
 	String DEFAULT_DISPLAY_NAME_GENERATOR_PROPERTY_NAME = "junit.jupiter.displayname.generator.default";
 	String DEFAULT_TEST_METHOD_ORDER_PROPERTY_NAME = "junit.jupiter.testmethod.order.default";
 	String DEFAULT_TEST_CLASS_ORDER_PROPERTY_NAME = "junit.jupiter.testclass.order.default";
-	String TEMP_DIR_SCOPE_PROPERTY_NAME = "junit.jupiter.tempdir.scope";
 
 	String DEFAULT_TIMEOUT_PROPERTY_NAME = "junit.jupiter.execution.timeout.default";
 	String DEFAULT_TESTABLE_METHOD_TIMEOUT_PROPERTY_NAME = "junit.jupiter.execution.timeout.testable.method.default";
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java
index 3b1834312..0b4f84814 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java
@@ -12,14 +12,13 @@ package org.junit.jupiter.engine.extension;
 
 import static java.nio.file.FileVisitResult.CONTINUE;
 import static java.util.stream.Collectors.joining;
-import static org.junit.jupiter.engine.config.JupiterConfiguration.TEMP_DIR_SCOPE_PROPERTY_NAME;
 import static org.junit.platform.commons.util.AnnotationUtils.findAnnotatedFields;
+import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
 import static org.junit.platform.commons.util.ReflectionUtils.isPrivate;
 import static org.junit.platform.commons.util.ReflectionUtils.makeAccessible;
 
 import java.io.File;
 import java.io.IOException;
-import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Parameter;
@@ -45,7 +44,6 @@ import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.api.extension.ParameterResolver;
 import org.junit.jupiter.api.io.TempDir;
-import org.junit.jupiter.engine.config.EnumConfigurationParameterConverter;
 import org.junit.platform.commons.util.ExceptionUtils;
 import org.junit.platform.commons.util.ReflectionUtils;
 
@@ -63,7 +61,6 @@ import org.junit.platform.commons.util.ReflectionUtils;
 class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterResolver {
 
 	private static final Namespace NAMESPACE = Namespace.create(TempDirectory.class);
-	private static final String KEY = "temp.dir";
 	private static final String TEMP_DIR_PREFIX = "junit";
 
 	/**
@@ -100,8 +97,9 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 
 		findAnnotatedFields(testClass, TempDir.class, predicate).forEach(field -> {
 			assertValidFieldCandidate(field);
+			String id = findAnnotation(field, TempDir.class).map(TempDir::value).orElse("");
 			try {
-				makeAccessible(field).set(testInstance, getPathOrFile(field, field.getType(), context));
+				makeAccessible(field).set(testInstance, getPathOrFile(field.getType(), context, id));
 			}
 			catch (Throwable t) {
 				ExceptionUtils.throwAsUncheckedException(t);
@@ -138,7 +136,8 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
 		Class<?> parameterType = parameterContext.getParameter().getType();
 		assertSupportedType("parameter", parameterType);
-		return getPathOrFile(parameterContext.getParameter(), parameterType, extensionContext);
+		String id = parameterContext.findAnnotation(TempDir.class).map(TempDir::value).orElse("");
+		return getPathOrFile(parameterType, extensionContext, id);
 	}
 
 	private void assertSupportedType(String target, Class<?> type) {
@@ -148,26 +147,14 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 		}
 	}
 
-	private Object getPathOrFile(AnnotatedElement sourceElement, Class<?> type, ExtensionContext extensionContext) {
-		Namespace namespace = getScope(extensionContext) == Scope.PER_DECLARATION //
-				? NAMESPACE.append(sourceElement) //
-				: NAMESPACE;
-		Path path = extensionContext.getStore(namespace) //
-				.getOrComputeIfAbsent(KEY, __ -> createTempDir(), CloseablePath.class) //
+	private Object getPathOrFile(Class<?> type, ExtensionContext extensionContext, String id) {
+		Path path = extensionContext.getStore(NAMESPACE) //
+				.getOrComputeIfAbsent(id, __ -> createTempDir(), CloseablePath.class) //
 				.get();
 
 		return (type == Path.class) ? path : path.toFile();
 	}
 
-	private Scope getScope(ExtensionContext context) {
-		return context.getRoot().getStore(NAMESPACE).getOrComputeIfAbsent( //
-			Scope.class, //
-			__ -> new EnumConfigurationParameterConverter<>(Scope.class, "@TempDir scope") //
-					.get(TEMP_DIR_SCOPE_PROPERTY_NAME, context::getConfigurationParameter, Scope.PER_DECLARATION), //
-			Scope.class //
-		);
-	}
-
 	private static CloseablePath createTempDir() {
 		try {
 			return new CloseablePath(Files.createTempDirectory(TEMP_DIR_PREFIX));
@@ -310,12 +297,4 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 		}
 	}
 
-	enum Scope {
-
-		PER_CONTEXT,
-
-		PER_DECLARATION
-
-	}
-
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerDeclarationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerDeclarationTests.java
deleted file mode 100644
index c4f8b8482..000000000
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerDeclarationTests.java
+++ /dev/null
@@ -1,985 +0,0 @@
-/*
- * Copyright 2015-2021 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine.extension;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertSame;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
-import static org.junit.jupiter.api.Assumptions.assumeTrue;
-import static org.junit.jupiter.api.DynamicTest.dynamicTest;
-import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
-import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
-import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
-import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
-import static org.junit.platform.testkit.engine.TestExecutionResultConditions.cause;
-import static org.junit.platform.testkit.engine.TestExecutionResultConditions.instanceOf;
-import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;
-
-import java.io.File;
-import java.io.IOException;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.stream.Stream;
-
-import org.assertj.core.api.Condition;
-import org.junit.jupiter.api.AfterAll;
-import org.junit.jupiter.api.AfterEach;
-import org.junit.jupiter.api.BeforeAll;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.DisplayName;
-import org.junit.jupiter.api.DynamicTest;
-import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
-import org.junit.jupiter.api.Nested;
-import org.junit.jupiter.api.Order;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.TestFactory;
-import org.junit.jupiter.api.TestInfo;
-import org.junit.jupiter.api.TestInstance;
-import org.junit.jupiter.api.TestMethodOrder;
-import org.junit.jupiter.api.condition.DisabledOnOs;
-import org.junit.jupiter.api.condition.OS;
-import org.junit.jupiter.api.extension.ExtensionConfigurationException;
-import org.junit.jupiter.api.extension.ParameterResolutionException;
-import org.junit.jupiter.api.io.TempDir;
-import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
-import org.junit.jupiter.engine.Constants;
-import org.junit.platform.testkit.engine.EngineExecutionResults;
-
-/**
- * Integration tests for the new behavior of the {@link TempDirectory} extension
- * to create separate temp directories for each {@link TempDir} declaration.
- *
- * @since 5.8
- */
-@DisplayName("TempDirectory extension (per declaration)")
-class TempDirectoryPerDeclarationTests extends AbstractJupiterTestEngineTests {
-
-	@BeforeEach
-	@AfterEach
-	void resetStaticVariables() {
-		AllPossibleDeclarationLocationsTestCase.tempDirs.clear();
-	}
-
-	@TestFactory
-	@DisplayName("resolves separate temp dirs for each annotation declaration")
-	Stream<DynamicTest> resolvesSeparateTempDirsForEachAnnotationDeclaration() {
-		return Arrays.stream(TestInstance.Lifecycle.values()).map(
-			lifecycle -> dynamicTest("with " + lifecycle + " lifecycle", () -> {
-
-				var results = executeTests(request() //
-						.selectors(selectClass(AllPossibleDeclarationLocationsTestCase.class)) //
-						.configurationParameter(Constants.DEFAULT_TEST_INSTANCE_LIFECYCLE_PROPERTY_NAME,
-							lifecycle.toString()).build());
-
-				results.containerEvents().assertStatistics(stats -> stats.started(2).succeeded(2));
-				results.testEvents().assertStatistics(stats -> stats.started(2).succeeded(2));
-
-				assertThat(AllPossibleDeclarationLocationsTestCase.tempDirs).hasSize(3);
-
-				var classTempDirs = AllPossibleDeclarationLocationsTestCase.tempDirs.get("class");
-				assertThat(classTempDirs).containsOnlyKeys("staticField1", "staticField2", "beforeAll1", "beforeAll2",
-					"afterAll1", "afterAll2");
-				assertThat(classTempDirs.values()).hasSize(6).doesNotHaveDuplicates();
-
-				var testATempDirs = AllPossibleDeclarationLocationsTestCase.tempDirs.get("testA");
-				assertThat(testATempDirs).containsOnlyKeys("staticField1", "staticField2", "instanceField1",
-					"instanceField2", "beforeEach1", "beforeEach2", "test1", "test2", "afterEach1", "afterEach2");
-				assertThat(testATempDirs.values()).hasSize(10).doesNotHaveDuplicates();
-
-				var testBTempDirs = AllPossibleDeclarationLocationsTestCase.tempDirs.get("testB");
-				assertThat(testBTempDirs).containsOnlyKeys("staticField1", "staticField2", "instanceField1",
-					"instanceField2", "beforeEach1", "beforeEach2", "test1", "test2", "afterEach1", "afterEach2");
-				assertThat(testBTempDirs.values()).hasSize(10).doesNotHaveDuplicates();
-
-				assertThat(testATempDirs.get("staticField1")).isEqualTo(classTempDirs.get("staticField1"));
-				assertThat(testBTempDirs.get("staticField1")).isEqualTo(classTempDirs.get("staticField1"));
-				assertThat(testATempDirs.get("staticField2")).isEqualTo(classTempDirs.get("staticField2"));
-				assertThat(testBTempDirs.get("staticField2")).isEqualTo(classTempDirs.get("staticField2"));
-
-				assertThat(testATempDirs.get("instanceField1")).isNotEqualTo(testBTempDirs.get("instanceField1"));
-				assertThat(testATempDirs.get("instanceField2")).isNotEqualTo(testBTempDirs.get("instanceField2"));
-				assertThat(testATempDirs.get("beforeEach1")).isNotEqualTo(testBTempDirs.get("beforeEach1"));
-				assertThat(testATempDirs.get("beforeEach2")).isNotEqualTo(testBTempDirs.get("beforeEach2"));
-				assertThat(testATempDirs.get("test1")).isNotEqualTo(testBTempDirs.get("test1"));
-				assertThat(testATempDirs.get("test2")).isNotEqualTo(testBTempDirs.get("test2"));
-				assertThat(testATempDirs.get("afterEach1")).isNotEqualTo(testBTempDirs.get("afterEach1"));
-				assertThat(testATempDirs.get("afterEach2")).isNotEqualTo(testBTempDirs.get("afterEach2"));
-			}));
-	}
-
-	@Test
-	@DisplayName("does not prevent constructor parameter resolution")
-	void tempDirectoryDoesNotPreventConstructorParameterResolution() {
-		executeTestsForClass(TempDirectoryDoesNotPreventConstructorParameterResolutionTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(1).succeeded(1));
-	}
-
-	@Test
-	@DisplayName("does not prevent user from deleting the temp dir within a test")
-	void tempDirectoryDoesNotPreventUserFromDeletingTempDir() {
-		executeTestsForClass(UserTempDirectoryDeletionDoesNotCauseFailureTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(1).succeeded(1));
-	}
-
-	@Test
-	@DisplayName("is capable of removal of a read-only file")
-	void nonWritableFileDoesNotCauseFailure() {
-		executeTestsForClass(NonWritableFileDoesNotCauseFailureTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(1).succeeded(1));
-	}
-
-	@Test
-	@DisplayName("is capable of removal of non-executable, non-writable, or non-readable directories and folders")
-	void nonMintPermissionsContentDoesNotCauseFailure() {
-		executeTestsForClass(NonMintPermissionContentInTempDirectoryDoesNotCauseFailureTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(13).succeeded(13));
-	}
-
-	@Test
-	@DisplayName("is capable of removal when its permissions were been changed")
-	void nonMintPermissionsDoNotCauseFailure() {
-		executeTestsForClass(NonMintTempDirectoryPermissionsDoNotCauseFailureTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(42).succeeded(42));
-	}
-
-	@Test
-	@DisabledOnOs(OS.WINDOWS)
-	@DisplayName("is capable of removal of a read-only file in a read-only dir")
-	void readOnlyFileInReadOnlyDirDoesNotCauseFailure() {
-		executeTestsForClass(ReadOnlyFileInReadOnlyDirDoesNotCauseFailureTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(1).succeeded(1));
-	}
-
-	@Test
-	@DisabledOnOs(OS.WINDOWS)
-	@DisplayName("is capable of removal of a read-only file in a dir in a read-only dir")
-	void readOnlyFileInNestedReadOnlyDirDoesNotCauseFailure() {
-		executeTestsForClass(ReadOnlyFileInDirInReadOnlyDirDoesNotCauseFailureTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(1).succeeded(1));
-	}
-
-	@Test
-	@DisplayName("can be used via instance field inside nested test classes")
-	void canBeUsedViaInstanceFieldInsideNestedTestClasses() {
-		executeTestsForClass(TempDirUsageInsideNestedClassesTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(3).succeeded(3));
-	}
-
-	@Test
-	@DisplayName("can be used via static field inside nested test classes")
-	void canBeUsedViaStaticFieldInsideNestedTestClasses() {
-		executeTestsForClass(StaticTempDirUsageInsideNestedClassTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(2).succeeded(2));
-	}
-
-	@Nested
-	@DisplayName("reports failure")
-	@TestMethodOrder(OrderAnnotation.class)
-	class Failures {
-
-		@Test
-		@DisplayName("when @TempDir is used on private static field")
-		@Order(10)
-		void onlySupportsNonPrivateInstanceFields() {
-			var results = executeTestsForClass(AnnotationOnPrivateStaticFieldTestCase.class);
-
-			assertSingleFailedContainer(results, ExtensionConfigurationException.class, "must not be private");
-		}
-
-		@Test
-		@DisplayName("when @TempDir is used on private instance field")
-		@Order(11)
-		void onlySupportsNonPrivateStaticFields() {
-			var results = executeTestsForClass(AnnotationOnPrivateInstanceFieldTestCase.class);
-
-			assertSingleFailedTest(results, ExtensionConfigurationException.class, "must not be private");
-		}
-
-		@Test
-		@DisplayName("when @TempDir is used on static field of an unsupported type")
-		@Order(20)
-		void onlySupportsStaticFieldsOfTypePathAndFile() {
-			var results = executeTestsForClass(AnnotationOnStaticFieldWithUnsupportedTypeTestCase.class);
-
-			assertSingleFailedContainer(results, ExtensionConfigurationException.class,
-				"Can only resolve @TempDir field of type java.nio.file.Path or java.io.File");
-		}
-
-		@Test
-		@DisplayName("when @TempDir is used on instance field of an unsupported type")
-		@Order(21)
-		void onlySupportsInstanceFieldsOfTypePathAndFile() {
-			var results = executeTestsForClass(AnnotationOnInstanceFieldWithUnsupportedTypeTestCase.class);
-
-			assertSingleFailedTest(results, ExtensionConfigurationException.class,
-				"Can only resolve @TempDir field of type java.nio.file.Path or java.io.File");
-		}
-
-		@Test
-		@DisplayName("when @TempDir is used on parameter of an unsupported type")
-		@Order(22)
-		void onlySupportsParametersOfTypePathAndFile() {
-			var results = executeTestsForClass(InvalidTestCase.class);
-
-			// @formatter:off
-			TempDirectoryPerDeclarationTests.assertSingleFailedTest(results,
-				instanceOf(ParameterResolutionException.class),
-				message(m -> m.matches("Failed to resolve parameter \\[java.lang.String .+] in method \\[.+]: .+")),
-				cause(
-					instanceOf(ExtensionConfigurationException.class),
-					message("Can only resolve @TempDir parameter of type java.nio.file.Path or java.io.File but was: java.lang.String")));
-			// @formatter:on
-		}
-
-		@Test
-		@DisplayName("when @TempDir is used on constructor parameter")
-		@Order(30)
-		void doesNotSupportTempDirAnnotationOnConstructorParameter() {
-			var results = executeTestsForClass(AnnotationOnConstructorParameterTestCase.class);
-
-			assertSingleFailedTest(results, ParameterResolutionException.class,
-				"@TempDir is not supported on constructor parameters. Please use field injection instead.");
-		}
-
-		@Test
-		@DisplayName("when @TempDir is used on constructor parameter with @TestInstance(PER_CLASS)")
-		@Order(31)
-		void doesNotSupportTempDirAnnotationOnConstructorParameterWithTestInstancePerClass() {
-			var results = executeTestsForClass(AnnotationOnConstructorParameterWithTestInstancePerClassTestCase.class);
-
-			assertSingleFailedContainer(results, ParameterResolutionException.class,
-				"@TempDir is not supported on constructor parameters. Please use field injection instead.");
-		}
-
-	}
-
-	private static void assertSingleFailedContainer(EngineExecutionResults results, Class<? extends Throwable> clazz,
-			String message) {
-
-		assertSingleFailedContainer(results, instanceOf(clazz), message(actual -> actual.contains(message)));
-	}
-
-	@SafeVarargs
-	@SuppressWarnings("varargs")
-	private static void assertSingleFailedContainer(EngineExecutionResults results,
-			Condition<Throwable>... conditions) {
-
-		results.containerEvents()//
-				.assertStatistics(stats -> stats.started(2).failed(1).succeeded(1))//
-				.assertThatEvents().haveExactly(1, finishedWithFailure(conditions));
-	}
-
-	private static void assertSingleFailedTest(EngineExecutionResults results, Class<? extends Throwable> clazz,
-			String message) {
-
-		assertSingleFailedTest(results, instanceOf(clazz), message(actual -> actual.contains(message)));
-	}
-
-	@SafeVarargs
-	@SuppressWarnings("varargs")
-	private static void assertSingleFailedTest(EngineExecutionResults results, Condition<Throwable>... conditions) {
-		results.testEvents().assertStatistics(stats -> stats.started(1).failed(1).succeeded(0));
-		results.testEvents().assertThatEvents().haveExactly(1, finishedWithFailure(conditions));
-	}
-
-	// -------------------------------------------------------------------------
-
-	static class AnnotationOnPrivateInstanceFieldTestCase {
-
-		@SuppressWarnings("unused")
-		@TempDir
-		private Path tempDir;
-
-		@Test
-		void test() {
-		}
-
-	}
-
-	static class AnnotationOnPrivateStaticFieldTestCase {
-
-		@SuppressWarnings("unused")
-		@TempDir
-		private static Path tempDir;
-
-		@Test
-		void test() {
-		}
-
-	}
-
-	static class AnnotationOnStaticFieldWithUnsupportedTypeTestCase {
-
-		@SuppressWarnings("unused")
-		@TempDir
-		static String tempDir;
-
-		@Test
-		void test1() {
-		}
-
-	}
-
-	static class AnnotationOnInstanceFieldWithUnsupportedTypeTestCase {
-
-		@SuppressWarnings("unused")
-		@TempDir
-		String tempDir;
-
-		@Test
-		void test1() {
-		}
-
-	}
-
-	static class AnnotationOnConstructorParameterTestCase {
-
-		AnnotationOnConstructorParameterTestCase(@SuppressWarnings("unused") @TempDir Path tempDir) {
-			// never called
-		}
-
-		@Test
-		void test() {
-			// never called
-		}
-
-	}
-
-	@TestInstance(PER_CLASS)
-	static class AnnotationOnConstructorParameterWithTestInstancePerClassTestCase
-			extends AnnotationOnConstructorParameterTestCase {
-
-		AnnotationOnConstructorParameterWithTestInstancePerClassTestCase(@TempDir Path tempDir) {
-			super(tempDir);
-		}
-	}
-
-	static class InvalidTestCase {
-
-		@Test
-		void wrongParameterType(@SuppressWarnings("unused") @TempDir String ignored) {
-			fail("this should never be called");
-		}
-	}
-
-	@Nested
-	@DisplayName("resolves java.io.File injection type")
-	class FileAndPathInjection {
-
-		@TempDir
-		File fileTempDir;
-
-		@TempDir
-		Path pathTempDir;
-
-		@Test
-		@DisplayName("and injected File and Path reference the same temp directory")
-		void checkFile(@TempDir File tempDir, @TempDir Path ref) {
-			assertNotNull(tempDir);
-			assertNotNull(ref);
-			assertNotNull(this.fileTempDir);
-			assertNotNull(this.pathTempDir);
-		}
-
-	}
-
-	// https://github.com/junit-team/junit5/issues/1748
-	static class TempDirectoryDoesNotPreventConstructorParameterResolutionTestCase {
-
-		@TempDir
-		Path tempDir;
-
-		TempDirectoryDoesNotPreventConstructorParameterResolutionTestCase(TestInfo testInfo) {
-			assertNotNull(testInfo);
-		}
-
-		@Test
-		void test() {
-			assertNotNull(tempDir);
-		}
-
-	}
-
-	// https://github.com/junit-team/junit5/issues/1801
-	static class UserTempDirectoryDeletionDoesNotCauseFailureTestCase {
-
-		@Test
-		void deleteTempDir(@TempDir Path tempDir) throws IOException {
-			Files.delete(tempDir);
-			assertThat(tempDir).doesNotExist();
-		}
-
-	}
-
-	// https://github.com/junit-team/junit5/issues/2046
-	static class NonWritableFileDoesNotCauseFailureTestCase {
-
-		@Test
-		void createReadonlyFile(@TempDir Path tempDir) throws IOException {
-			// Removal of setWritable(false) files might fail (e.g. for Windows)
-			// The test verifies that @TempDir is capable of removing of such files
-			var path = Files.write(tempDir.resolve("test.txt"), new byte[0]);
-			assumeTrue(path.toFile().setWritable(false),
-				() -> "Unable to set file " + path + " readonly via .toFile().setWritable(false)");
-		}
-
-	}
-
-	// https://github.com/junit-team/junit5/issues/2171
-	static class ReadOnlyFileInReadOnlyDirDoesNotCauseFailureTestCase {
-
-		@Test
-		void createReadOnlyFileInReadOnlyDir(@TempDir File tempDir) throws IOException {
-			File file = tempDir.toPath().resolve("file").toFile();
-			assumeTrue(file.createNewFile());
-			assumeTrue(tempDir.setReadOnly());
-			assumeTrue(file.setReadOnly());
-		}
-
-	}
-
-	// https://github.com/junit-team/junit5/issues/2171
-	static class ReadOnlyFileInDirInReadOnlyDirDoesNotCauseFailureTestCase {
-
-		@Test
-		void createReadOnlyFileInReadOnlyDir(@TempDir File tempDir) throws IOException {
-			File file = tempDir.toPath().resolve("dir").resolve("file").toFile();
-			assumeTrue(file.getParentFile().mkdirs());
-			assumeTrue(file.createNewFile());
-			assumeTrue(tempDir.setReadOnly());
-			assumeTrue(file.getParentFile().setReadOnly());
-			assumeTrue(file.setReadOnly());
-		}
-
-	}
-
-	// https://github.com/junit-team/junit5/issues/2609
-	@SuppressWarnings("ResultOfMethodCallIgnored")
-	static class NonMintPermissionContentInTempDirectoryDoesNotCauseFailureTestCase {
-
-		@Test
-		void createFile(@TempDir Path tempDir) throws IOException {
-			Files.createFile(tempDir.resolve("test-file.txt")).toFile();
-		}
-
-		@Test
-		void createFolder(@TempDir Path tempDir) throws IOException {
-			Files.createFile(tempDir.resolve("test-file.txt")).toFile();
-		}
-
-		@Test
-		void createNonWritableFile(@TempDir Path tempDir) throws IOException {
-			Files.createFile(tempDir.resolve("test-file.txt")).toFile().setWritable(false);
-		}
-
-		@Test
-		void createNonReadableFile(@TempDir Path tempDir) throws IOException {
-			Files.createFile(tempDir.resolve("test-file.txt")).toFile().setReadable(false);
-		}
-
-		@Test
-		void createNonWritableDirectory(@TempDir Path tempDir) throws IOException {
-			Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setWritable(false);
-		}
-
-		@Test
-		void createNonReadableDirectory(@TempDir Path tempDir) throws IOException {
-			Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setReadable(false);
-		}
-
-		@Test
-		void createNonExecutableDirectory(@TempDir Path tempDir) throws IOException {
-			Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setExecutable(false);
-		}
-
-		@Test
-		void createNonEmptyNonWritableDirectory(@TempDir Path tempDir) throws IOException {
-			Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-			Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-			subDir.toFile().setWritable(false);
-		}
-
-		@Test
-		void createNonEmptyNonReadableDirectory(@TempDir Path tempDir) throws IOException {
-			Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-			Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-			subDir.toFile().setReadable(false);
-		}
-
-		@Test
-		void createNonEmptyNonExecutableDirectory(@TempDir Path tempDir) throws IOException {
-			Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-			Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-			subDir.toFile().setExecutable(false);
-		}
-
-		@Test
-		void createNonEmptyDirectory(@TempDir Path tempDir) throws IOException {
-			Files.createDirectory(tempDir.resolve("test-sub-dir"));
-			Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-		}
-
-		@Test
-		void createNonEmptyDirectoryWithNonWritableFile(@TempDir Path tempDir) throws IOException {
-			Files.createDirectory(tempDir.resolve("test-sub-dir"));
-			Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt")).toFile().setWritable(false);
-		}
-
-		@Test
-		void createNonEmptyDirectoryWithNonReadableFile(@TempDir Path tempDir) throws IOException {
-			Files.createDirectory(tempDir.resolve("test-sub-dir"));
-			Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt")).toFile().setReadable(false);
-		}
-	}
-
-	// https://github.com/junit-team/junit5/issues/2609
-	@SuppressWarnings("ResultOfMethodCallIgnored")
-	static class NonMintTempDirectoryPermissionsDoNotCauseFailureTestCase {
-
-		@Nested
-		class NonWritable {
-
-			@Test
-			void makeEmptyTempDirectoryNonWritable(@TempDir Path tempDir) {
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithFileNonWritable(@TempDir Path tempDir) throws IOException {
-				Files.createFile(tempDir.resolve("test-file.txt"));
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithEmptyFolderNonWritable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonWritableFileNonWritable(@TempDir Path tempDir) throws IOException {
-				Files.createFile(tempDir.resolve("test-file.txt")).toFile().setWritable(false);
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonReadableFileNonWritable(@TempDir Path tempDir) throws IOException {
-				Files.createFile(tempDir.resolve("test-file.txt")).toFile().setReadable(false);
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonWritableFolderNonWritable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setWritable(false);
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonReadableFolderNonWritable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setReadable(false);
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonExecutableFolderNonWritable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setExecutable(false);
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyNonReadableFolderNonWritable(@TempDir Path tempDir) throws IOException {
-				Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				subDir.toFile().setReadable(false);
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyNonWritableFolderNonWritable(@TempDir Path tempDir) throws IOException {
-				Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				subDir.toFile().setWritable(false);
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyNonExecutableFolderNonWritable(@TempDir Path tempDir) throws IOException {
-				Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				subDir.toFile().setExecutable(false);
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyFolderNonWritable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyFolderContainingNonWritableFileNonWritable(@TempDir Path tempDir)
-					throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt")).toFile().setWritable(false);
-				tempDir.toFile().setWritable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyFolderContainingNonReadableFileNonWritable(@TempDir Path tempDir)
-					throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt")).toFile().setReadable(false);
-				tempDir.toFile().setWritable(false);
-			}
-		}
-
-		@Nested
-		class NonReadable {
-
-			@Test
-			void makeEmptyTempDirectoryNonReadable(@TempDir Path tempDir) {
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithFileNonReadable(@TempDir Path tempDir) throws IOException {
-				Files.createFile(tempDir.resolve("test-file.txt"));
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithEmptyFolderNonReadable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonWritableFileNonReadable(@TempDir Path tempDir) throws IOException {
-				Files.createFile(tempDir.resolve("test-file.txt")).toFile().setWritable(false);
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonReadableFileNonReadable(@TempDir Path tempDir) throws IOException {
-				Files.createFile(tempDir.resolve("test-file.txt")).toFile().setReadable(false);
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonWritableFolderNonReadable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setWritable(false);
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonReadableFolderNonReadable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setReadable(false);
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonExecutableFolderNonReadable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setExecutable(false);
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyNonWritableFolderNonReadable(@TempDir Path tempDir) throws IOException {
-				Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				subDir.toFile().setWritable(false);
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyNonReadableFolderNonReadable(@TempDir Path tempDir) throws IOException {
-				Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				subDir.toFile().setReadable(false);
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyNonExecutableFolderNonReadable(@TempDir Path tempDir) throws IOException {
-				Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				subDir.toFile().setExecutable(false);
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyFolderNonReadable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyFolderContainingNonWritableFileNonReadable(@TempDir Path tempDir)
-					throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt")).toFile().setWritable(false);
-				tempDir.toFile().setReadable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyFolderContainingNonReadableFileNonReadable(@TempDir Path tempDir)
-					throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt")).toFile().setReadable(false);
-				tempDir.toFile().setReadable(false);
-			}
-		}
-
-		@Nested
-		class NonExecutable {
-
-			@Test
-			void makeEmptyTempDirectoryNonExecutable(@TempDir Path tempDir) {
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithFileNonExecutable(@TempDir Path tempDir) throws IOException {
-				Files.createFile(tempDir.resolve("test-file.txt"));
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithEmptyFolderNonExecutable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonWritableFileNonExecutable(@TempDir Path tempDir) throws IOException {
-				Files.createFile(tempDir.resolve("test-file.txt")).toFile().setWritable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonReadableFileNonExecutable(@TempDir Path tempDir) throws IOException {
-				Files.createFile(tempDir.resolve("test-file.txt")).toFile().setReadable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonWritableFolderNonExecutable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setWritable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonReadableFolderNonExecutable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setReadable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonExecutableFolderNonExecutable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir")).toFile().setExecutable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyNonWritableFolderNonExecutable(@TempDir Path tempDir) throws IOException {
-				Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				subDir.toFile().setWritable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyNonReadableFolderNonExecutable(@TempDir Path tempDir) throws IOException {
-				Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				subDir.toFile().setReadable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyNonExecutableFolderNonExecutable(@TempDir Path tempDir)
-					throws IOException {
-				Path subDir = Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				subDir.toFile().setExecutable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyFolderNonExecutable(@TempDir Path tempDir) throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt"));
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyFolderContainingNonWritableFileNonExecutable(@TempDir Path tempDir)
-					throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt")).toFile().setWritable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-
-			@Test
-			void makeTempDirectoryWithNonEmptyFolderContainingNonReadableFileNonExecutable(@TempDir Path tempDir)
-					throws IOException {
-				Files.createDirectory(tempDir.resolve("test-sub-dir"));
-				Files.createFile(tempDir.resolve("test-sub-dir/test-file.txt")).toFile().setReadable(false);
-				tempDir.toFile().setExecutable(false);
-			}
-		}
-	}
-
-	// https://github.com/junit-team/junit5/issues/2079
-	static class TempDirUsageInsideNestedClassesTestCase {
-
-		@TempDir
-		File tempDir;
-
-		@Test
-		void topLevel() {
-			assertNotNull(tempDir);
-			assertTrue(tempDir.exists());
-		}
-
-		@Nested
-		class NestedTestClass {
-
-			@Test
-			void nested() {
-				assertNotNull(tempDir);
-				assertTrue(tempDir.exists());
-			}
-
-			@Nested
-			class EvenDeeperNestedTestClass {
-
-				@Test
-				void deeplyNested() {
-					assertNotNull(tempDir);
-					assertTrue(tempDir.exists());
-				}
-			}
-		}
-	}
-
-	static class StaticTempDirUsageInsideNestedClassTestCase {
-
-		@TempDir
-		static File tempDir;
-
-		static File initialTempDir;
-
-		@Test
-		void topLevel() {
-			assertNotNull(tempDir);
-			assertTrue(tempDir.exists());
-			initialTempDir = tempDir;
-		}
-
-		@Nested
-		class NestedTestClass {
-
-			@Test
-			void nested() {
-				assertNotNull(tempDir);
-				assertTrue(tempDir.exists());
-				assertSame(initialTempDir, tempDir);
-			}
-		}
-	}
-
-	@DisplayName("class")
-	static class AllPossibleDeclarationLocationsTestCase {
-
-		static final Map<String, Map<String, Path>> tempDirs = new HashMap<>();
-
-		@TempDir
-		static Path staticField1;
-
-		@TempDir
-		static Path staticField2;
-
-		@TempDir
-		Path instanceField1;
-
-		@TempDir
-		Path instanceField2;
-
-		@BeforeAll
-		static void beforeAll(@TempDir Path param1, @TempDir Path param2, TestInfo testInfo) {
-			getTempDirs(testInfo).putAll(Map.of( //
-				"staticField1", staticField1, //
-				"staticField2", staticField2, //
-				"beforeAll1", param1, //
-				"beforeAll2", param2 //
-			));
-		}
-
-		@BeforeEach
-		void beforeEach(@TempDir Path param1, @TempDir Path param2, TestInfo testInfo) {
-			getTempDirs(testInfo).putAll(Map.of( //
-				"staticField1", staticField1, //
-				"staticField2", staticField2, //
-				"instanceField1", instanceField1, //
-				"instanceField2", instanceField2, //
-				"beforeEach1", param1, //
-				"beforeEach2", param2 //
-			));
-		}
-
-		@Test
-		@DisplayName("testA")
-		void testA(@TempDir Path param1, @TempDir Path param2, TestInfo testInfo) {
-			getTempDirs(testInfo).putAll(Map.of( //
-				"test1", param1, //
-				"test2", param2 //
-			));
-		}
-
-		@Test
-		@DisplayName("testB")
-		void testB(@TempDir Path param1, @TempDir Path param2, TestInfo testInfo) {
-			getTempDirs(testInfo).putAll(Map.of( //
-				"test1", param1, //
-				"test2", param2 //
-			));
-		}
-
-		@AfterEach
-		void afterEach(@TempDir Path param1, @TempDir Path param2, TestInfo testInfo) {
-			getTempDirs(testInfo).putAll(Map.of( //
-				"afterEach1", param1, //
-				"afterEach2", param2 //
-			));
-		}
-
-		@AfterAll
-		static void afterAll(@TempDir Path param1, @TempDir Path param2, TestInfo testInfo) {
-			getTempDirs(testInfo).putAll(Map.of( //
-				"afterAll1", param1, //
-				"afterAll2", param2 //
-			));
-		}
-
-		private static Map<String, Path> getTempDirs(TestInfo testInfo) {
-			return tempDirs.computeIfAbsent(testInfo.getDisplayName(), __ -> new LinkedHashMap<>());
-		}
-	}
-}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerContextTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryTests.java
similarity index 93%
rename from junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerContextTests.java
rename to junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryTests.java
index a5a81b610..c9d772765 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryPerContextTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryTests.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.engine.extension;
 
+import static java.util.Objects.requireNonNull;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
@@ -19,8 +20,6 @@ import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.fail;
 import static org.junit.jupiter.api.Assumptions.assumeTrue;
 import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
-import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
-import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
 import static org.junit.platform.testkit.engine.TestExecutionResultConditions.cause;
 import static org.junit.platform.testkit.engine.TestExecutionResultConditions.instanceOf;
@@ -53,28 +52,16 @@ import org.junit.jupiter.api.extension.ExtensionConfigurationException;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.api.io.TempDir;
 import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
-import org.junit.jupiter.engine.Constants;
 import org.junit.platform.testkit.engine.EngineExecutionResults;
 
 /**
- * Integration tests for the legacy behavior of the {@link TempDirectory}
- * extension to create a single temp directory per context, i.e. test class or
- * method.
+ * Integration tests for the {@link TempDirectory} extension.
  *
  * @since 5.4
  */
-@DisplayName("TempDirectory extension (per context)")
-class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
-
-	@SuppressWarnings("deprecation")
-	@Override
-	protected EngineExecutionResults executeTestsForClass(Class<?> testClass) {
-		return executeTests(request() //
-				.selectors(selectClass(testClass)) //
-				.configurationParameter(Constants.TEMP_DIR_SCOPE_PROPERTY_NAME,
-					TempDirectory.Scope.PER_CONTEXT.toString()) //
-				.build());
-	}
+@SuppressWarnings("ALL")
+@DisplayName("TempDirectory extension")
+class TempDirectoryTests extends AbstractJupiterTestEngineTests {
 
 	@BeforeEach
 	@AfterEach
@@ -85,6 +72,12 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 		BaseSeparateTempDirsParameterInjectionTestCase.tempDirs.clear();
 	}
 
+	@Test
+	void supportsMultipleTempDirs() {
+		executeTestsForClass(MultipleTempDirsTestCase.class).allEvents()//
+				.assertStatistics(stats -> stats.started(3).succeeded(3));
+	}
+
 	@Test
 	@DisplayName("does not prevent constructor parameter resolution")
 	void tempDirectoryDoesNotPreventConstructorParameterResolution() {
@@ -150,13 +143,6 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 				.assertStatistics(stats -> stats.started(2).succeeded(2));
 	}
 
-	@Test
-	@DisplayName("resolves java.io.File injection type")
-	void resolvesFileInstances() {
-		executeTestsForClass(FileInjectionTestCase.class).testEvents()//
-				.assertStatistics(stats -> stats.started(1).succeeded(1));
-	}
-
 	@Nested
 	@DisplayName("resolves shared temp dir")
 	@TestMethodOrder(OrderAnnotation.class)
@@ -337,9 +323,9 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 			var results = executeTestsForClass(InvalidTestCase.class);
 
 			// @formatter:off
-			TempDirectoryPerContextTests.assertSingleFailedTest(results,
+			TempDirectoryTests.assertSingleFailedTest(results,
 				instanceOf(ParameterResolutionException.class),
-				message(m -> m.matches("Failed to resolve parameter \\[java.lang.String .+] in method \\[.+]: .+")),
+				message(m -> m.matches("Failed to resolve parameter \\[java.lang.String .+\\] in method \\[.+\\]: .+")),
 				cause(
 					instanceOf(ExtensionConfigurationException.class),
 					message("Can only resolve @TempDir parameter of type java.nio.file.Path or java.io.File but was: java.lang.String")));
@@ -520,7 +506,6 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 
 	static class AnnotationOnPrivateInstanceFieldTestCase {
 
-		@SuppressWarnings("unused")
 		@TempDir
 		private Path tempDir;
 
@@ -532,7 +517,6 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 
 	static class AnnotationOnPrivateStaticFieldTestCase {
 
-		@SuppressWarnings("unused")
 		@TempDir
 		private static Path tempDir;
 
@@ -544,7 +528,6 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 
 	static class AnnotationOnStaticFieldWithUnsupportedTypeTestCase {
 
-		@SuppressWarnings("unused")
 		@TempDir
 		static String tempDir;
 
@@ -556,7 +539,6 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 
 	static class AnnotationOnInstanceFieldWithUnsupportedTypeTestCase {
 
-		@SuppressWarnings("unused")
 		@TempDir
 		String tempDir;
 
@@ -601,7 +583,7 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 
 	static class AnnotationOnConstructorParameterTestCase {
 
-		AnnotationOnConstructorParameterTestCase(@SuppressWarnings("unused") @TempDir Path tempDir) {
+		AnnotationOnConstructorParameterTestCase(@TempDir Path tempDir) {
 			// never called
 		}
 
@@ -770,7 +752,9 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 		}
 	}
 
-	static class FileInjectionTestCase {
+	@Nested
+	@DisplayName("resolves java.io.File injection type")
+	class FileAndPathInjection {
 
 		@TempDir
 		File fileTempDir;
@@ -865,7 +849,6 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 	}
 
 	// https://github.com/junit-team/junit5/issues/2609
-	@SuppressWarnings("ResultOfMethodCallIgnored")
 	static class NonMintPermissionContentInTempDirectoryDoesNotCauseFailureTestCase {
 
 		@Test
@@ -944,7 +927,6 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 	}
 
 	// https://github.com/junit-team/junit5/issues/2609
-	@SuppressWarnings("ResultOfMethodCallIgnored")
 	static class NonMintTempDirectoryPermissionsDoNotCauseFailureTestCase {
 
 		@Nested
@@ -1301,4 +1283,96 @@ class TempDirectoryPerContextTests extends AbstractJupiterTestEngineTests {
 			}
 		}
 	}
+
+	static class MultipleTempDirsTestCase {
+
+		@TempDir("a")
+		static Path A;
+		static Path B;
+
+		@BeforeAll
+		static void beforeAll(@TempDir("a") Path dir1, @TempDir("b") Path dir2) {
+			assertEquals(A, requireNonNull(dir1));
+			B = requireNonNull(dir2);
+			assertNotEquals(A, B);
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+		}
+
+		@TempDir("c")
+		Path c;
+		static Path C, D, E;
+
+		@BeforeEach
+		void beforeEach(@TempDir("d") Path dir1, @TempDir("b") Path dir2, @TempDir("c") Path dir3,
+				@TempDir("a") Path dir4) {
+			assertEquals(A, dir4);
+			assertEquals(B, dir2);
+			assertEquals(c, dir3);
+
+			C = requireNonNull(dir3);
+			assertNotEquals(A, C);
+			assertNotEquals(B, C);
+
+			D = requireNonNull(dir1);
+			assertNotEquals(A, D);
+			assertNotEquals(B, D);
+			assertNotEquals(C, D);
+
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+			assertTrue(Files.exists(C));
+			assertTrue(Files.exists(D));
+		}
+
+		@Test
+		void test(@TempDir("c") Path dir1, @TempDir("e") Path dir2, @TempDir("a") Path dir3, @TempDir("d") Path dir4,
+				@TempDir("b") Path dir5) {
+			assertEquals(A, dir3);
+			assertEquals(B, dir5);
+			assertEquals(C, dir1);
+			assertEquals(D, dir4);
+
+			E = requireNonNull(dir2);
+			assertNotEquals(A, E);
+			assertNotEquals(B, E);
+			assertNotEquals(C, E);
+			assertNotEquals(D, E);
+
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+			assertTrue(Files.exists(C));
+			assertTrue(Files.exists(D));
+			assertTrue(Files.exists(E));
+		}
+
+		@AfterEach
+		void afterEach(@TempDir("b") Path dir1, @TempDir("a") Path dir2, @TempDir("c") Path dir3,
+				@TempDir("e") Path dir4, @TempDir("d") Path dir5) {
+			assertEquals(A, dir2);
+			assertEquals(B, dir1);
+			assertEquals(C, dir3);
+			assertEquals(D, dir5);
+			assertEquals(E, dir4);
+
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+			assertTrue(Files.exists(C));
+			assertTrue(Files.exists(D));
+			assertTrue(Files.exists(E));
+		}
+
+		@AfterAll
+		static void afterAll(@TempDir("b") Path dir1, @TempDir("a") Path dir2) {
+			assertEquals(A, dir2);
+			assertEquals(B, dir1);
+
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+
+			assertTrue(Files.notExists(C));
+			assertTrue(Files.notExists(D));
+			assertTrue(Files.notExists(E));
+		}
+	}
 }
