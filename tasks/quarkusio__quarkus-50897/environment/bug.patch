diff --git a/bom/application/pom.xml b/bom/application/pom.xml
index 32b4c628100..627d70af014 100644
--- a/bom/application/pom.xml
+++ b/bom/application/pom.xml
@@ -50,14 +50,14 @@
         <smallrye-config.version>3.14.1</smallrye-config.version>
         <smallrye-health.version>4.2.0</smallrye-health.version>
         <smallrye-metrics.version>4.0.0</smallrye-metrics.version>
-        <smallrye-open-api.version>4.2.0</smallrye-open-api.version>
+        <smallrye-open-api.version>4.2.1</smallrye-open-api.version>
         <smallrye-graphql.version>2.16.0</smallrye-graphql.version>
         <smallrye-fault-tolerance.version>6.9.3</smallrye-fault-tolerance.version>
         <smallrye-jwt.version>4.6.2</smallrye-jwt.version>
         <smallrye-context-propagation.version>2.2.1</smallrye-context-propagation.version>
         <smallrye-reactive-streams-operators.version>1.0.13</smallrye-reactive-streams-operators.version>
         <smallrye-reactive-types-converter.version>3.0.3</smallrye-reactive-types-converter.version>
-        <smallrye-mutiny-vertx-binding.version>3.20.1</smallrye-mutiny-vertx-binding.version>
+        <smallrye-mutiny-vertx-binding.version>3.20.2</smallrye-mutiny-vertx-binding.version>
         <smallrye-reactive-messaging.version>4.30.0</smallrye-reactive-messaging.version>
         <smallrye-stork.version>2.7.3</smallrye-stork.version>
         <jakarta.activation.version>2.1.4</jakarta.activation.version>
diff --git a/docs/src/main/asciidoc/redis-reference.adoc b/docs/src/main/asciidoc/redis-reference.adoc
index 4c7bfa21c95..04b84641894 100644
--- a/docs/src/main/asciidoc/redis-reference.adoc
+++ b/docs/src/main/asciidoc/redis-reference.adoc
@@ -138,70 +138,6 @@ public class RedisExample {
 
 TIP: You can omit the `@Inject` annotation when using `@RedisClientName`.
 
-=== Activate or deactivate Redis Clients
-
-When a Redis Clients is configured at build time, and its URL is set at runtime, it is active by default. Quarkus
-starts the corresponding Redis Client when the application starts.
-
-To deactivate a Redis Client at runtime, either:
-
-* Do not set `quarkus.redis[.optional name].hosts` or `quarkus.redis[.optional name].hosts-provider-name`.
-* Set `quarkus.redis[.optional name].active` to `false`.
-
-If a Redis Client is not active:
-
-* The Redis Client does not attempt to connect to Redis during application startup.
-* The Redis Client does not contribute a <<redis-health-check,health check>>.
-* Static CDI injection points involving the Redis Client, such as `@Inject ReactiveRedisDataSource redis` or `@Inject RedisDataSource redis`, cause application startup to fail.
-* Dynamic retrieval of the Redis Client, such as through `CDI.getBeanContainer()`, `Arc.instance()`, or an injected `Instance<ReactiveRedisDataSource>`, causes an exception to be thrown.
-* Other Quarkus extensions that consume the Redis Client may cause application startup to fail.
-
-This feature is especially useful when the application must dynamically select a Redis Client from a predefined set at
-runtime.
-
-.An example of configuring multiple Redis Clients for runtime selection:
-
-[source,properties]
-----
-quarkus.redis.one.active=false
-quarkus.redis.one.hosts=redis://localhost:64251
-
-quarkus.redis.two.active=false
-quarkus.redis.two.hosts=redis://localhost:64251
-----
-
-[source,java]
-----
-import io.quarkus.arc.InjectableInstance;
-
-@ApplicationScoped
-public class MyConsumer {
-    @Inject
-    @RedisClientName("one")
-    InjectableInstance<ReactiveRedisDataSource> one;
-    @Inject
-    @RedisClientName("two")
-    InjectableInstance<ReactiveRedisDataSource> two;
-
-    public void doSomething() {
-        ReactiveRedisDataSource redis = one.getActive();
-        // ...
-    }
-}
-----
-
-Setting `quarkus.redis.one.active=true` xref:config-reference.adoc#configuration-sources[at runtime] makes only the
-Redis Client `one` available.
-Setting `quarkus.redis.two.active=true` at runtime makes only the Redis Client `two` available.
-
-[IMPORTANT]
-====
-A Redis Client (either default or named) must always be discoverable at build-time to be considered for runtime
-injection. This can be done by injecting the Redis Client name with `@RedisClientName`. If the Redis Client name may be
-active or inactive, it needs to use the wrapper `InjectableInstance<>`, or else Quarkus will throw an exception at
-startup time if the Redis Client is inactive. Alternatively, Redis Clients may also be discovered via configuration.
-====
-
 == Connect to the Redis server
 
 The Redis extension can operate in 4 distinct modes:
@@ -1078,7 +1014,6 @@ See xref:redis-dev-services.adoc[Redis Dev Service].
 
 == Configure Redis observability
 
-[[redis-health-check]]
 === Enable the health checks
 
 If you are using the `quarkus-smallrye-health` extension, `quarkus-redis` will automatically add a readiness health check to validate the connection to the Redis server.
diff --git a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/DevServicesRedisProcessor.java b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/DevServicesRedisProcessor.java
index dd12904190a..0a4fd899be2 100644
--- a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/DevServicesRedisProcessor.java
+++ b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/DevServicesRedisProcessor.java
@@ -2,14 +2,12 @@
 
 import static io.quarkus.devservices.common.ConfigureUtil.configureSharedServiceLabel;
 import static io.quarkus.devservices.common.ContainerLocator.locateContainerWithLabels;
-import static io.quarkus.redis.runtime.client.config.RedisConfig.HOSTS;
-import static io.quarkus.redis.runtime.client.config.RedisConfig.getPropertyName;
 
-import java.util.HashSet;
+import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.OptionalInt;
-import java.util.Set;
 
 import org.jboss.logging.Logger;
 import org.testcontainers.containers.GenericContainer;
@@ -30,6 +28,7 @@
 import io.quarkus.devservices.common.ComposeLocator;
 import io.quarkus.devservices.common.ConfigureUtil;
 import io.quarkus.devservices.common.ContainerLocator;
+import io.quarkus.redis.deployment.client.RedisBuildTimeConfig.DevServiceConfiguration;
 import io.quarkus.redis.runtime.client.config.RedisConfig;
 import io.quarkus.runtime.LaunchMode;
 import io.quarkus.runtime.configuration.ConfigUtils;
@@ -51,6 +50,9 @@ public class DevServicesRedisProcessor {
     private static final ContainerLocator redisContainerLocator = locateContainerWithLabels(REDIS_EXPOSED_PORT,
             DEV_SERVICE_LABEL);
 
+    private static final String QUARKUS = "quarkus.";
+    private static final String DOT = ".";
+
     @BuildStep
     public void startRedisContainers(LaunchModeBuildItem launchMode,
             DockerStatusBuildItem dockerStatusBuildItem,
@@ -60,21 +62,23 @@ public void startRedisContainers(LaunchModeBuildItem launchMode,
             BuildProducer<DevServicesResultBuildItem> devServicesResult,
             DevServicesConfig devServicesConfig) {
 
-        Set<String> names = new HashSet<>(config.clients().keySet());
-        names.add(RedisConfig.DEFAULT_CLIENT_NAME);
+        Map<String, DevServiceConfiguration> currentDevServicesConfiguration = new HashMap<>(config.additionalDevServices());
+        currentDevServicesConfiguration.put(RedisConfig.DEFAULT_CLIENT_NAME, config.defaultDevService());
 
         try {
-            for (String name : names) {
+            for (Entry<String, DevServiceConfiguration> entry : currentDevServicesConfiguration.entrySet()) {
+                String name = entry.getKey();
                 boolean useSharedNetwork = DevServicesSharedNetworkBuildItem.isSharedNetworkRequired(devServicesConfig,
                         devServicesSharedNetworkBuildItem);
 
-                io.quarkus.redis.deployment.client.DevServicesConfig redisConfig = config.clients().get(name).devservices();
-                if (redisDevServicesEnabled(dockerStatusBuildItem, name, redisConfig)) {
+                String configPrefix = getConfigPrefix(name);
+                io.quarkus.redis.deployment.client.DevServicesConfig redisConfig = entry.getValue().devservices();
+                if (redisDevServicesEnabled(dockerStatusBuildItem, name, redisConfig, configPrefix)) {
                     // If the dev services are disabled, we don't need to do anything
                     continue;
                 }
 
-                DevServicesResultBuildItem discovered = discoverRunningService(composeProjectBuildItem, name,
+                DevServicesResultBuildItem discovered = discoverRunningService(composeProjectBuildItem, configPrefix,
                         redisConfig, launchMode.getLaunchMode(), useSharedNetwork);
                 if (discovered != null) {
                     devServicesResult.produce(discovered);
@@ -93,14 +97,15 @@ public void startRedisContainers(LaunchModeBuildItem launchMode,
                                             // Dev Service discovery works using a global dev service label applied in DevServicesCustomizerBuildItem
                                             // for backwards compatibility we still add the custom label
                                             .withSharedServiceLabel(launchMode.getLaunchMode(), redisConfig.serviceName()))
-                                    .configProvider(
-                                            Map.of(getPropertyName(name, HOSTS), s -> REDIS_SCHEME + s.getConnectionInfo()))
+                                    .configProvider(Map.of(configPrefix + RedisConfig.HOSTS_CONFIG_NAME,
+                                            s -> REDIS_SCHEME + s.getConnectionInfo()))
                                     .build());
                 }
             }
         } catch (Throwable t) {
             throw new RuntimeException(t);
         }
+
     }
 
     /**
@@ -122,7 +127,7 @@ public void startRedisContainers(LaunchModeBuildItem launchMode,
      * extra sure we'd put on a special 'not external' label and filter for that, too
      */
     private DevServicesResultBuildItem discoverRunningService(DevServicesComposeProjectBuildItem composeProjectBuildItem,
-            String name,
+            String configPrefix,
             io.quarkus.redis.deployment.client.DevServicesConfig devServicesConfig,
             LaunchMode launchMode,
             boolean useSharedNetwork) {
@@ -135,13 +140,14 @@ private DevServicesResultBuildItem discoverRunningService(DevServicesComposeProj
                     return DevServicesResultBuildItem.discovered()
                             .feature(Feature.REDIS_CLIENT)
                             .containerId(containerAddress.getId())
-                            .config(Map.of(RedisConfig.getPropertyName(name, HOSTS), redisUrl))
+                            .config(Map.of(configPrefix + RedisConfig.HOSTS_CONFIG_NAME, redisUrl))
                             .build();
                 }).orElse(null);
     }
 
     private static boolean redisDevServicesEnabled(DockerStatusBuildItem dockerStatusBuildItem, String name,
-            io.quarkus.redis.deployment.client.DevServicesConfig devServicesConfig) {
+            io.quarkus.redis.deployment.client.DevServicesConfig devServicesConfig,
+            String configPrefix) {
         if (!devServicesConfig.enabled()) {
             // explicitly disabled
             log.debug("Not starting devservices for " + (RedisConfig.isDefaultClient(name) ? "default redis client" : name)
@@ -149,8 +155,7 @@ private static boolean redisDevServicesEnabled(DockerStatusBuildItem dockerStatu
             return true;
         }
 
-        // TODO - We shouldn't query runtime config during deployment
-        boolean needToStart = !ConfigUtils.isPropertyNonEmpty(RedisConfig.getPropertyName(name, HOSTS));
+        boolean needToStart = !ConfigUtils.isPropertyNonEmpty(configPrefix + RedisConfig.HOSTS_CONFIG_NAME);
         if (!needToStart) {
             log.debug("Not starting dev services for " + (RedisConfig.isDefaultClient(name) ? "default redis client" : name)
                     + " as hosts have been provided");
@@ -166,6 +171,14 @@ private static boolean redisDevServicesEnabled(DockerStatusBuildItem dockerStatu
         return false;
     }
 
+    private String getConfigPrefix(String name) {
+        String configPrefix = QUARKUS + RedisConfig.REDIS_CONFIG_ROOT_NAME + DOT;
+        if (!RedisConfig.isDefaultClient(name)) {
+            configPrefix = configPrefix + name + DOT;
+        }
+        return configPrefix;
+    }
+
     private static class QuarkusPortRedisContainer extends GenericContainer<QuarkusPortRedisContainer> implements Startable {
         private final OptionalInt fixedExposedPort;
         private final boolean useSharedNetwork;
diff --git a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisBuildTimeConfig.java b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisBuildTimeConfig.java
index 145401f3348..82aba9963d4 100644
--- a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisBuildTimeConfig.java
+++ b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisBuildTimeConfig.java
@@ -1,90 +1,57 @@
 package io.quarkus.redis.deployment.client;
 
-import static io.quarkus.redis.runtime.client.config.RedisConfig.DEFAULT_CLIENT_NAME;
-
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Map;
 
 import io.quarkus.runtime.annotations.ConfigDocMapKey;
+import io.quarkus.runtime.annotations.ConfigDocSection;
+import io.quarkus.runtime.annotations.ConfigGroup;
 import io.quarkus.runtime.annotations.ConfigPhase;
 import io.quarkus.runtime.annotations.ConfigRoot;
 import io.smallrye.config.ConfigMapping;
 import io.smallrye.config.WithDefault;
-import io.smallrye.config.WithDefaults;
 import io.smallrye.config.WithName;
 import io.smallrye.config.WithParentName;
-import io.smallrye.config.WithUnnamedKey;
 
 @ConfigMapping(prefix = "quarkus.redis")
 @ConfigRoot(phase = ConfigPhase.BUILD_TIME)
 public interface RedisBuildTimeConfig {
+
+    /**
+     * The default redis client
+     */
+    @WithParentName
+    RedisClientBuildTimeConfig defaultRedisClient();
+
     /**
-     * Configures the Redis clients.
+     * Configures additional (named) Redis clients.
      * <p>
-     * The default client does not have a name, and it is configured as:
-     *
-     * <pre>
-     * quarkus.redis.hosts = redis://localhost:6379
-     * </pre>
-     *
-     * And then use {@link jakarta.inject.Inject} to inject the client:
-     *
-     * <pre>
-     * &#64;Inject
-     * RedisAPI redis;
-     * </pre>
-     *
+     * Each client has a unique name which must be identified to select the right client.
+     * For example:
      * <p>
-     * Named clients must be identified to select the right client:
      *
      * <pre>
      * quarkus.redis.client1.hosts = redis://localhost:6379
      * quarkus.redis.client2.hosts = redis://localhost:6380
      * </pre>
-     *
-     * And then use the {@link io.quarkus.redis.client.RedisClientName} annotation to select any of the beans:
-     * <ul>
-     * <li>{@link io.vertx.mutiny.redis.client.Redis}</li>
-     * <li>{@link io.vertx.redis.client.Redis}</li>
-     * <li>{@link io.vertx.mutiny.redis.client.RedisAPI}</li>
-     * <li>{@link io.vertx.redis.client.RedisAPI}</li>
-     * <li>{@link io.quarkus.redis.datasource.RedisDataSource}</li>
-     * <li>{@link io.quarkus.redis.datasource.ReactiveRedisDataSource}</li>
-     * </ul>
-     * And inject the client:
+     * <p>
+     * And then use the {@link io.quarkus.redis.client.RedisClientName} annotation to select the
+     * {@link io.vertx.mutiny.redis.client.Redis},
+     * {@link io.vertx.redis.client.Redis}, {@link io.vertx.mutiny.redis.client.RedisAPI} and
+     * {@link io.vertx.redis.client.RedisAPI} beans.
+     * <p>
      *
      * <pre>
-     * &#64;RedisClientName("client1")
-     * &#64;Inject
-     * RedisAPI redis;
+     * {
+     *     &#64;code
+     *     &#64;RedisClientName("client1")
+     *     &#64;Inject
+     *     RedisAPI redis;
+     * }
      * </pre>
      */
     @WithParentName
-    @WithDefaults
-    @WithUnnamedKey(DEFAULT_CLIENT_NAME)
     @ConfigDocMapKey("redis-client-name")
-    Map<String, RedisClientBuildTimeConfig> clients();
-
-    /**
-     * Returns a {@code List} of Redis Client names. The first element of the list is the default Redis Client if
-     * available. The remaining order is unspecified.
-     *
-     * @return a {@code List} of Redis Client names
-     */
-    default List<String> clientsNames() {
-        List<String> names = new ArrayList<>();
-        if (clients().containsKey(DEFAULT_CLIENT_NAME)) {
-            names.add(DEFAULT_CLIENT_NAME);
-        }
-        for (String name : clients().keySet()) {
-            if (name.equals(DEFAULT_CLIENT_NAME)) {
-                continue;
-            }
-            names.add(name);
-        }
-        return names;
-    }
+    Map<String, RedisClientBuildTimeConfig> namedRedisClients();
 
     /**
      * Whether a health check is published in case the smallrye-health extension is present.
@@ -92,4 +59,28 @@ default List<String> clientsNames() {
     @WithName("health.enabled")
     @WithDefault("true")
     boolean healthEnabled();
+
+    /**
+     * Default Dev services configuration.
+     */
+    @WithParentName
+    DevServiceConfiguration defaultDevService();
+
+    /**
+     * Additional dev services configurations
+     */
+    @WithParentName
+    @ConfigDocMapKey("additional-redis-clients")
+    Map<String, DevServiceConfiguration> additionalDevServices();
+
+    @ConfigGroup
+    public interface DevServiceConfiguration {
+        /**
+         * Dev Services
+         * <p>
+         * Dev Services allows Quarkus to automatically start Redis in dev and test mode.
+         */
+        @ConfigDocSection(generated = true)
+        DevServicesConfig devservices();
+    }
 }
diff --git a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisClientBuildTimeConfig.java b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisClientBuildTimeConfig.java
index 1b338eea34c..11cdb13b136 100644
--- a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisClientBuildTimeConfig.java
+++ b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisClientBuildTimeConfig.java
@@ -4,7 +4,6 @@
 import java.util.Optional;
 
 import io.quarkus.runtime.annotations.ConfigDocDefault;
-import io.quarkus.runtime.annotations.ConfigDocSection;
 import io.quarkus.runtime.annotations.ConfigGroup;
 import io.quarkus.runtime.configuration.TrimmedStringConverter;
 import io.smallrye.config.WithConverter;
@@ -12,6 +11,7 @@
 
 @ConfigGroup
 public interface RedisClientBuildTimeConfig {
+
     /**
      * A list of files allowing to pre-load data into the Redis server.
      * The file is formatted as follows:
@@ -38,9 +38,4 @@ public interface RedisClientBuildTimeConfig {
     @WithDefault("true")
     boolean loadOnlyIfEmpty();
 
-    /**
-     * Dev Services allows Quarkus to automatically start Redis in dev and test mode.
-     */
-    @ConfigDocSection(generated = true)
-    DevServicesConfig devservices();
 }
diff --git a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisClientProcessor.java b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisClientProcessor.java
index 23be3f43526..c7125e56cb1 100644
--- a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisClientProcessor.java
+++ b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisClientProcessor.java
@@ -1,8 +1,6 @@
 package io.quarkus.redis.deployment.client;
 
 import static io.quarkus.redis.runtime.client.config.RedisConfig.DEFAULT_CLIENT_NAME;
-import static io.quarkus.redis.runtime.client.config.RedisConfig.HOSTS;
-import static io.quarkus.redis.runtime.client.config.RedisConfig.HOSTS_PROVIDER_NAME;
 
 import java.nio.file.Files;
 import java.nio.file.Path;
@@ -12,9 +10,10 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Set;
 import java.util.function.Supplier;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 
 import jakarta.enterprise.context.ApplicationScoped;
@@ -26,7 +25,6 @@
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.IndexView;
 
-import io.quarkus.arc.ActiveResult;
 import io.quarkus.arc.deployment.AdditionalBeanBuildItem;
 import io.quarkus.arc.deployment.BeanArchiveIndexBuildItem;
 import io.quarkus.arc.deployment.BeanDiscoveryFinishedBuildItem;
@@ -55,11 +53,9 @@
 import io.quarkus.redis.runtime.client.config.RedisConfig;
 import io.quarkus.runtime.LaunchMode;
 import io.quarkus.runtime.configuration.ConfigurationException;
-import io.quarkus.runtime.configuration.NameIterator;
 import io.quarkus.smallrye.health.deployment.spi.HealthBuildItem;
 import io.quarkus.tls.deployment.spi.TlsRegistryBuildItem;
 import io.quarkus.vertx.deployment.VertxBuildItem;
-import io.smallrye.config.SmallRyeConfig;
 import io.vertx.redis.client.impl.types.BulkType;
 
 public class RedisClientProcessor {
@@ -68,6 +64,9 @@ public class RedisClientProcessor {
 
     private static final String FEATURE = "redis-client";
 
+    private static final Pattern NAMED_CLIENT_PROPERTY_NAME_PATTERN = Pattern
+            .compile("^quarkus\\.redis\\.(.+)\\.hosts(-provider-name)?$");
+
     private static final List<DotName> SUPPORTED_INJECTION_TYPE = List.of(
             // Legacy types
             DotName.createSimple(RedisClient.class.getName()),
@@ -165,80 +164,70 @@ public void init(
 
         // Create the supplier and define the beans.
         for (String name : names) {
-            Supplier<ActiveResult> checkActive = recorder.checkActive(name);
-
             // Redis objects
             syntheticBeans.produce(configureAndCreateSyntheticBean(name, io.vertx.mutiny.redis.client.Redis.class,
-                    checkActive, recorder.getRedisClient(name)));
+                    recorder.getRedisClient(name)));
             syntheticBeans.produce(configureAndCreateSyntheticBean(name, io.vertx.redis.client.Redis.class,
-                    checkActive, recorder.getBareRedisClient(name)));
+                    recorder.getBareRedisClient(name)));
 
             // Redis API objects
             syntheticBeans.produce(configureAndCreateSyntheticBean(name, io.vertx.mutiny.redis.client.RedisAPI.class,
-                    checkActive, recorder.getRedisAPI(name)));
+                    recorder.getRedisAPI(name)));
             syntheticBeans.produce(configureAndCreateSyntheticBean(name, io.vertx.redis.client.RedisAPI.class,
-                    checkActive, recorder.getBareRedisAPI(name)));
+                    recorder.getBareRedisAPI(name)));
 
             // Legacy clients
-            syntheticBeans.produce(configureAndCreateSyntheticBean(name, RedisClient.class,
-                    checkActive, recorder.getLegacyRedisClient(name)));
+            syntheticBeans
+                    .produce(configureAndCreateSyntheticBean(name, RedisClient.class, recorder.getLegacyRedisClient(name)));
             syntheticBeans.produce(configureAndCreateSyntheticBean(name, ReactiveRedisClient.class,
-                    checkActive, recorder.getLegacyReactiveRedisClient(name)));
+                    recorder.getLegacyReactiveRedisClient(name)));
         }
 
         recorder.cleanup(shutdown);
 
         // Handle data import
-        for (String name : buildTimeConfig.clientsNames()) {
-            preloadRedisData(name, buildTimeConfig.clients().get(name), applicationArchivesBuildItem,
-                    launchMode.getLaunchMode(),
-                    nativeImageResources, hotDeploymentWatchedFiles, recorder);
+        preloadRedisData(DEFAULT_CLIENT_NAME, buildTimeConfig.defaultRedisClient(), applicationArchivesBuildItem,
+                launchMode.getLaunchMode(),
+                nativeImageResources, hotDeploymentWatchedFiles, recorder);
+
+        if (buildTimeConfig.namedRedisClients() != null) {
+            for (Map.Entry<String, RedisClientBuildTimeConfig> entry : buildTimeConfig.namedRedisClients().entrySet()) {
+                preloadRedisData(entry.getKey(), entry.getValue(), applicationArchivesBuildItem, launchMode.getLaunchMode(),
+                        nativeImageResources, hotDeploymentWatchedFiles, recorder);
+            }
         }
     }
 
     static Set<String> configuredClientNames(RedisBuildTimeConfig buildTimeConfig, Config config) {
         Set<String> names = new HashSet<>();
         // redis client names from dev services
-        for (Entry<String, RedisClientBuildTimeConfig> client : buildTimeConfig.clients().entrySet()) {
-            if (client.getValue().devservices().enabled()) {
-                names.add(client.getKey());
-            }
+        if (buildTimeConfig.defaultDevService().devservices().enabled()) {
+            names.add(DEFAULT_CLIENT_NAME);
         }
-
-        // TODO - We shouldn't query runtime config during deployment
-        Map<String, String> map = config.unwrap(SmallRyeConfig.class).getMapKeys("quarkus.redis");
-        for (Entry<String, String> entry : map.entrySet()) {
-            NameIterator nameIterator = new NameIterator(entry.getKey());
-
-            if (nameIterator.nextSegmentEquals(HOSTS) || nameIterator.nextSegmentEquals(HOSTS_PROVIDER_NAME)) {
+        names.addAll(buildTimeConfig.additionalDevServices().keySet());
+        // redis client names declared in config
+        for (String propertyName : config.getPropertyNames()) {
+            if (propertyName.equals("quarkus.redis.hosts")) {
                 names.add(DEFAULT_CLIENT_NAME);
                 continue;
             }
-
-            if (nameIterator.hasNext()) {
-                String candidateName = nameIterator.getNextSegment();
-                nameIterator.next();
-                if (nameIterator.hasNext()
-                        && (nameIterator.nextSegmentEquals(HOSTS) || nameIterator.nextSegmentEquals(HOSTS_PROVIDER_NAME))) {
-                    names.add(candidateName);
-                }
+            Matcher matcher = NAMED_CLIENT_PROPERTY_NAME_PATTERN.matcher(propertyName);
+            if (matcher.matches()) {
+                names.add(matcher.group(1));
             }
         }
-
         return names;
     }
 
-    static <T> SyntheticBeanBuildItem configureAndCreateSyntheticBean(String name, Class<T> type,
-            Supplier<ActiveResult> checkActive, Supplier<T> supplier) {
-
+    static <T> SyntheticBeanBuildItem configureAndCreateSyntheticBean(String name,
+            Class<T> type,
+            Supplier<T> supplier) {
         SyntheticBeanBuildItem.ExtendedBeanConfigurator configurator = SyntheticBeanBuildItem
                 .configure(type)
-                .checkActive(checkActive)
-                .startup()
-                .setRuntimeInit()
-                .unremovable()
                 .supplier(supplier)
-                .scope(ApplicationScoped.class);
+                .scope(ApplicationScoped.class)
+                .unremovable()
+                .setRuntimeInit();
 
         if (DEFAULT_CLIENT_NAME.equalsIgnoreCase(name)) {
             configurator.addQualifier(Default.class);
@@ -262,7 +251,7 @@ private void preloadRedisData(String name, RedisClientBuildTimeConfig clientConf
             } catch (RuntimeException e) {
                 throw new ConfigurationException(
                         "Unable to interpret path referenced in '"
-                                + RedisConfig.getPropertyName(name, "redis-load-script") + "="
+                                + RedisConfig.propertyKey(name, "redis-load-script") + "="
                                 + String.join(",", importFiles)
                                 + "': " + e.getMessage());
             }
@@ -274,7 +263,7 @@ private void preloadRedisData(String name, RedisClientBuildTimeConfig clientConf
                 //raise exception if explicit file is not present (i.e. not the default)
                 throw new ConfigurationException(
                         "Unable to find file referenced in '"
-                                + RedisConfig.getPropertyName(name, "redis-load-script") + "="
+                                + RedisConfig.propertyKey(name, "redis-load-script") + "="
                                 + String.join(", ", clientConfig.loadScript().get())
                                 + "'. Remove property or add file to your path.");
             }
diff --git a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisDatasourceProcessor.java b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisDatasourceProcessor.java
index b455f002537..884eee37b90 100644
--- a/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisDatasourceProcessor.java
+++ b/extensions/redis-client/deployment/src/main/java/io/quarkus/redis/deployment/client/RedisDatasourceProcessor.java
@@ -9,7 +9,6 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.function.Supplier;
 
 import org.eclipse.microprofile.config.ConfigProvider;
 import org.jboss.jandex.AnnotationInstance;
@@ -17,7 +16,6 @@
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.IndexView;
 
-import io.quarkus.arc.ActiveResult;
 import io.quarkus.arc.deployment.AdditionalBeanBuildItem;
 import io.quarkus.arc.deployment.BeanArchiveIndexBuildItem;
 import io.quarkus.arc.deployment.BeanDiscoveryFinishedBuildItem;
@@ -105,12 +103,11 @@ public void init(RedisClientRecorder recorder,
 
         // Create the supplier and define the beans.
         for (String name : names) {
-            Supplier<ActiveResult> checkActive = recorder.checkActive(name);
             // Data sources
             syntheticBeans.produce(configureAndCreateSyntheticBean(name, RedisDataSource.class,
-                    checkActive, recorder.getBlockingDataSource(name)));
+                    recorder.getBlockingDataSource(name)));
             syntheticBeans.produce(configureAndCreateSyntheticBean(name, ReactiveRedisDataSource.class,
-                    checkActive, recorder.getReactiveDataSource(name)));
+                    recorder.getReactiveDataSource(name)));
         }
 
         recorder.cleanup(shutdown);
diff --git a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisActiveClientsMissingConfigTest.java b/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisActiveClientsMissingConfigTest.java
deleted file mode 100644
index 3088b0daeed..00000000000
--- a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisActiveClientsMissingConfigTest.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package io.quarkus.redis.deployment.client;
-
-import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
-
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Assertions;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.InactiveBeanException;
-import io.quarkus.redis.client.RedisClientName;
-import io.quarkus.redis.datasource.ReactiveRedisDataSource;
-import io.quarkus.redis.datasource.RedisDataSource;
-import io.quarkus.test.QuarkusUnitTest;
-import io.quarkus.test.common.QuarkusTestResource;
-import io.vertx.mutiny.redis.client.Redis;
-import io.vertx.redis.client.RedisAPI;
-
-@QuarkusTestResource(RedisTestResource.class)
-public class RedisActiveClientsMissingConfigTest {
-    @RegisterExtension
-    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()
-            .assertException(e -> assertThat(e)// Can't use isInstanceOf due to weird classloading in tests
-                    .satisfies(t -> assertThat(t.getClass().getName()).isEqualTo(InactiveBeanException.class.getName()))
-                    .hasMessageContainingAll(
-                            """
-                                    Redis Client 'active' was deactivated automatically because neither the \
-                                    hosts nor the hostsProviderName is set. \
-                                    To activate the Redis Client, set the configuration property 'quarkus.redis.active.hosts' \
-                                    or 'quarkus.redis.active.hosts-provider-name'. \
-                                    Refer to https://quarkus.io/guides/redis-reference for guidance.
-                                    """));
-
-    @Inject
-    @RedisClientName("active")
-    Redis active;
-    @Inject
-    @RedisClientName("active")
-    io.vertx.redis.client.Redis activeBare;
-    @Inject
-    @RedisClientName("active")
-    RedisAPI activeApi;
-    @Inject
-    @RedisClientName("active")
-    io.vertx.redis.client.RedisAPI activeBareApi;
-    @Inject
-    @RedisClientName("active")
-    RedisDataSource activeDataSource;
-    @Inject
-    @RedisClientName("active")
-    ReactiveRedisDataSource activeReactiveDataSource;
-
-    @Test
-    void missingConfig() {
-        Assertions.fail();
-    }
-}
diff --git a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisActiveClientsTest.java b/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisActiveClientsTest.java
deleted file mode 100644
index 66615069b4e..00000000000
--- a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisActiveClientsTest.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package io.quarkus.redis.deployment.client;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.enterprise.inject.Any;
-import jakarta.inject.Inject;
-
-import org.jboss.shrinkwrap.api.ShrinkWrap;
-import org.jboss.shrinkwrap.api.spec.JavaArchive;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.InjectableInstance;
-import io.quarkus.redis.client.RedisClientName;
-import io.quarkus.redis.datasource.ReactiveRedisDataSource;
-import io.quarkus.redis.datasource.RedisDataSource;
-import io.quarkus.test.QuarkusUnitTest;
-import io.quarkus.test.common.QuarkusTestResource;
-import io.vertx.mutiny.redis.client.Redis;
-import io.vertx.redis.client.RedisAPI;
-
-@QuarkusTestResource(RedisTestResource.class)
-public class RedisActiveClientsTest {
-    @RegisterExtension
-    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()
-            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class))
-            .overrideConfigKey("quarkus.redis.active.hosts", "${quarkus.redis.tr}/1");
-
-    @Inject
-    InjectableInstance<Redis> defaultActive;
-    @Inject
-    InjectableInstance<io.vertx.redis.client.Redis> defaultActiveBare;
-    @Inject
-    InjectableInstance<RedisAPI> defaultActiveApi;
-    @Inject
-    InjectableInstance<io.vertx.redis.client.RedisAPI> defaultActiveBareApi;
-    @Inject
-    InjectableInstance<RedisDataSource> defaultActiveDataSource;
-    @Inject
-    InjectableInstance<ReactiveRedisDataSource> defaultActiveReactiveDataSource;
-
-    @Inject
-    @RedisClientName("active")
-    InjectableInstance<Redis> active;
-    @Inject
-    @RedisClientName("active")
-    InjectableInstance<io.vertx.redis.client.Redis> activeBare;
-    @Inject
-    @RedisClientName("active")
-    InjectableInstance<RedisAPI> activeApi;
-    @Inject
-    @RedisClientName("active")
-    InjectableInstance<io.vertx.redis.client.RedisAPI> activeBareApi;
-    @Inject
-    @RedisClientName("active")
-    InjectableInstance<RedisDataSource> activeDataSource;
-    @Inject
-    @RedisClientName("active")
-    InjectableInstance<ReactiveRedisDataSource> activeReactiveDataSource;
-
-    @Inject
-    @Any
-    InjectableInstance<Redis> all;
-    @Inject
-    @Any
-    InjectableInstance<io.vertx.redis.client.Redis> allBare;
-    @Inject
-    @Any
-    InjectableInstance<RedisAPI> allApi;
-    @Inject
-    @Any
-    InjectableInstance<io.vertx.redis.client.RedisAPI> allBareApi;
-    @Inject
-    @Any
-    InjectableInstance<RedisDataSource> allDataSource;
-    @Inject
-    @Any
-    InjectableInstance<ReactiveRedisDataSource> allReactiveDataSource;
-
-    @Test
-    void activeClients() {
-        assertEquals(1, defaultActive.listActive().size());
-        assertEquals(1, defaultActiveBare.listActive().size());
-        assertEquals(1, defaultActiveApi.listActive().size());
-        assertEquals(1, defaultActiveBareApi.listActive().size());
-        assertEquals(1, defaultActiveDataSource.listActive().size());
-        assertEquals(1, defaultActiveReactiveDataSource.listActive().size());
-
-        assertEquals(1, active.listActive().size());
-        assertEquals(1, activeBare.listActive().size());
-        assertEquals(1, activeApi.listActive().size());
-        assertEquals(1, activeBareApi.listActive().size());
-        assertEquals(1, activeDataSource.listActive().size());
-        assertEquals(1, activeReactiveDataSource.listActive().size());
-
-        assertEquals(2, all.listActive().size());
-        assertEquals(2, allBare.listActive().size());
-        assertEquals(2, allApi.listActive().size());
-        assertEquals(2, allBareApi.listActive().size());
-        assertEquals(2, allDataSource.listActive().size());
-        assertEquals(2, allReactiveDataSource.listActive().size());
-    }
-}
diff --git a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisConfigClientNamesTest.java b/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisConfigClientNamesTest.java
index 9db30405a9c..de4a7fd5402 100644
--- a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisConfigClientNamesTest.java
+++ b/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisConfigClientNamesTest.java
@@ -1,10 +1,7 @@
 package io.quarkus.redis.deployment.client;
 
-import static io.quarkus.redis.runtime.client.config.RedisConfig.DEFAULT_CLIENT_NAME;
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.OptionalInt;
@@ -14,6 +11,7 @@
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
 
+import io.quarkus.redis.deployment.client.RedisBuildTimeConfig.DevServiceConfiguration;
 import io.smallrye.config.SmallRyeConfig;
 import io.smallrye.config.SmallRyeConfigBuilder;
 import io.smallrye.config.common.MapBackedConfigSource;
@@ -41,7 +39,8 @@ void testWithEmptyConfig() {
         createConfig(Map.of());
 
         RedisBuildTimeConfig redisBuildTimeConfig = createRedisBuildTimeConfig(
-                Map.of(DEFAULT_CLIENT_NAME, createDevServiceConfiguration(false)));
+                createDevServiceConfiguration(false),
+                Map.of());
 
         Set<String> names = RedisClientProcessor.configuredClientNames(redisBuildTimeConfig, config);
         assertThat(names).isEmpty();
@@ -52,7 +51,8 @@ void testWithDefaultConfig() {
         createConfig(Map.of());
 
         RedisBuildTimeConfig redisBuildTimeConfig = createRedisBuildTimeConfig(
-                Map.of(DEFAULT_CLIENT_NAME, createDevServiceConfiguration(true)));
+                createDevServiceConfiguration(true),
+                Map.of());
 
         Set<String> names = RedisClientProcessor.configuredClientNames(redisBuildTimeConfig, config);
         assertThat(names).containsOnly("<default>");
@@ -63,8 +63,8 @@ void testWithAdditionalDevServices() {
         createConfig(Map.of());
 
         RedisBuildTimeConfig redisBuildTimeConfig = createRedisBuildTimeConfig(
-                Map.of(DEFAULT_CLIENT_NAME, createDevServiceConfiguration(true), "additional",
-                        createDevServiceConfiguration(true)));
+                createDevServiceConfiguration(true),
+                Map.of("additional", createDevServiceConfiguration(true)));
 
         Set<String> names = RedisClientProcessor.configuredClientNames(redisBuildTimeConfig, config);
         assertThat(names).containsOnly("<default>", "additional");
@@ -75,8 +75,8 @@ void testWithDisabledDefaultDevServiceConfig() {
         createConfig(Map.of());
 
         RedisBuildTimeConfig redisBuildTimeConfig = createRedisBuildTimeConfig(
-                Map.of(DEFAULT_CLIENT_NAME, createDevServiceConfiguration(false), "additional",
-                        createDevServiceConfiguration(true)));
+                createDevServiceConfiguration(false),
+                Map.of("additional", createDevServiceConfiguration(true)));
 
         Set<String> names = RedisClientProcessor.configuredClientNames(redisBuildTimeConfig, config);
         assertThat(names).containsOnly("additional");
@@ -87,7 +87,8 @@ void testWithDisabledDefaultDevServiceWithHostsConfig() {
         createConfig(Map.of("quarkus.redis.hosts", "redis://localhost:1234"));
 
         RedisBuildTimeConfig redisBuildTimeConfig = createRedisBuildTimeConfig(
-                Map.of(DEFAULT_CLIENT_NAME, createDevServiceConfiguration(false)));
+                createDevServiceConfiguration(false),
+                Map.of());
 
         Set<String> names = RedisClientProcessor.configuredClientNames(redisBuildTimeConfig, config);
         assertThat(names).containsOnly("<default>");
@@ -99,52 +100,49 @@ void testWithDisabledDefaultDevServiceWithAdditionalHostsConfig() {
                 "quarkus.redis.my-redis-2.hosts-provider-name", "my-redis-2-provider"));
 
         RedisBuildTimeConfig redisBuildTimeConfig = createRedisBuildTimeConfig(
-                Map.of(DEFAULT_CLIENT_NAME, createDevServiceConfiguration(false)));
+                createDevServiceConfiguration(false),
+                Map.of());
 
         Set<String> names = RedisClientProcessor.configuredClientNames(redisBuildTimeConfig, config);
         assertThat(names).containsOnly("my-redis", "my-redis-2");
     }
 
-    private static RedisBuildTimeConfig createRedisBuildTimeConfig(Map<String, DevServicesConfig> devServices) {
-        return new RedisBuildTimeConfig() {
+    private static RedisBuildTimeConfig createRedisBuildTimeConfig(DevServiceConfiguration defaultDevService,
+            Map<String, DevServiceConfiguration> additionalDevServices) {
+        RedisBuildTimeConfig redisBuildTimeConfig = new RedisBuildTimeConfig() {
+
+            @Override
+            public RedisClientBuildTimeConfig defaultRedisClient() {
+                return null;
+            }
+
             @Override
-            public Map<String, RedisClientBuildTimeConfig> clients() {
-                Map<String, RedisClientBuildTimeConfig> clients = new HashMap<>();
-                for (String name : devServices.keySet()) {
-                    clients.put(name, new RedisClientBuildTimeConfig() {
-                        @Override
-                        public Optional<List<String>> loadScript() {
-                            return Optional.empty();
-                        }
-
-                        @Override
-                        public boolean flushBeforeLoad() {
-                            return false;
-                        }
-
-                        @Override
-                        public boolean loadOnlyIfEmpty() {
-                            return false;
-                        }
-
-                        @Override
-                        public DevServicesConfig devservices() {
-                            return devServices.get(name);
-                        }
-                    });
-                }
-                return clients;
+            public Map<String, RedisClientBuildTimeConfig> namedRedisClients() {
+                return Map.of();
             }
 
             @Override
             public boolean healthEnabled() {
                 return false;
             }
+
+            @Override
+            public DevServiceConfiguration defaultDevService() {
+                return defaultDevService;
+            }
+
+            @Override
+            public Map<String, DevServiceConfiguration> additionalDevServices() {
+                return additionalDevServices;
+            }
         };
+
+        return redisBuildTimeConfig;
     }
 
-    private static DevServicesConfig createDevServiceConfiguration(boolean enabled) {
-        return new DevServicesConfig() {
+    private static DevServiceConfiguration createDevServiceConfiguration(boolean enabled) {
+        DevServicesConfig devServicesConfig = new DevServicesConfig() {
+
             @Override
             public boolean enabled() {
                 return enabled;
@@ -175,5 +173,15 @@ public Map<String, String> containerEnv() {
                 return Map.of();
             }
         };
+
+        DevServiceConfiguration devServiceConfiguration = new DevServiceConfiguration() {
+
+            @Override
+            public DevServicesConfig devservices() {
+                return devServicesConfig;
+            }
+        };
+
+        return devServiceConfiguration;
     }
 }
diff --git a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisInactiveClientsByConfigExceptionTest.java b/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisInactiveClientsByConfigExceptionTest.java
deleted file mode 100644
index 745d65dc971..00000000000
--- a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisInactiveClientsByConfigExceptionTest.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package io.quarkus.redis.deployment.client;
-
-import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
-
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.InactiveBeanException;
-import io.quarkus.redis.client.RedisClientName;
-import io.quarkus.redis.datasource.ReactiveRedisDataSource;
-import io.quarkus.redis.datasource.RedisDataSource;
-import io.quarkus.test.QuarkusUnitTest;
-import io.quarkus.test.common.QuarkusTestResource;
-import io.vertx.mutiny.redis.client.Redis;
-import io.vertx.redis.client.RedisAPI;
-
-@QuarkusTestResource(RedisTestResource.class)
-public class RedisInactiveClientsByConfigExceptionTest {
-    @RegisterExtension
-    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()
-            .overrideConfigKey("quarkus.redis.active.active", "false")
-            .overrideConfigKey("quarkus.redis.active.hosts", "${quarkus.redis.tr}/1")
-            .assertException(e -> assertThat(e)// Can't use isInstanceOf due to weird classloading in tests
-                    .satisfies(t -> assertThat(t.getClass().getName()).isEqualTo(InactiveBeanException.class.getName()))
-                    .hasMessageContainingAll(
-                            """
-                                    Redis Client 'active' was deactivated through configuration properties. \
-                                    To activate the Redis Client, set configuration property \
-                                    'quarkus.redis.active.active' to 'true' and configure the Redis Client 'active'. \
-                                    Refer to https://quarkus.io/guides/redis-reference for guidance.
-                                    """));
-
-    @Inject
-    @RedisClientName("active")
-    Redis active;
-    @Inject
-    @RedisClientName("active")
-    io.vertx.redis.client.Redis activeBare;
-    @Inject
-    @RedisClientName("active")
-    RedisAPI activeApi;
-    @Inject
-    @RedisClientName("active")
-    io.vertx.redis.client.RedisAPI activeBareApi;
-    @Inject
-    @RedisClientName("active")
-    RedisDataSource activeDataSource;
-    @Inject
-    @RedisClientName("active")
-    ReactiveRedisDataSource activeReactiveDataSource;
-
-    @Test
-    void inactive() {
-
-    }
-}
diff --git a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisInactiveClientsByConfigTest.java b/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisInactiveClientsByConfigTest.java
deleted file mode 100644
index 9ac944cbd0e..00000000000
--- a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisInactiveClientsByConfigTest.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package io.quarkus.redis.deployment.client;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.InjectableInstance;
-import io.quarkus.redis.client.RedisClientName;
-import io.quarkus.redis.datasource.ReactiveRedisDataSource;
-import io.quarkus.redis.datasource.RedisDataSource;
-import io.quarkus.test.QuarkusUnitTest;
-import io.quarkus.test.common.QuarkusTestResource;
-import io.vertx.mutiny.redis.client.Redis;
-import io.vertx.redis.client.RedisAPI;
-
-@QuarkusTestResource(RedisTestResource.class)
-public class RedisInactiveClientsByConfigTest {
-    @RegisterExtension
-    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()
-            .overrideConfigKey("quarkus.redis.inactive.active", "false")
-            .overrideConfigKey("quarkus.redis.inactive.hosts", "${quarkus.redis.tr}/1");
-
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<Redis> inactive;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<io.vertx.redis.client.Redis> inactiveBare;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<RedisAPI> inactiveApi;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<io.vertx.redis.client.RedisAPI> inactiveBareApi;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<RedisDataSource> inactiveDataSource;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<ReactiveRedisDataSource> inactiveReactiveDataSource;
-
-    @Test
-    void inactiveClients() {
-        assertEquals(0, inactive.listActive().size());
-        assertEquals(0, inactiveBare.listActive().size());
-        assertEquals(0, inactiveApi.listActive().size());
-        assertEquals(0, inactiveBareApi.listActive().size());
-        assertEquals(0, inactiveDataSource.listActive().size());
-        assertEquals(0, inactiveReactiveDataSource.listActive().size());
-    }
-}
diff --git a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisInactiveClientsTest.java b/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisInactiveClientsTest.java
deleted file mode 100644
index 66025c05cba..00000000000
--- a/extensions/redis-client/deployment/src/test/java/io/quarkus/redis/deployment/client/RedisInactiveClientsTest.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package io.quarkus.redis.deployment.client;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.inject.Inject;
-
-import org.jboss.shrinkwrap.api.ShrinkWrap;
-import org.jboss.shrinkwrap.api.spec.JavaArchive;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.InjectableInstance;
-import io.quarkus.redis.client.RedisClientName;
-import io.quarkus.redis.datasource.ReactiveRedisDataSource;
-import io.quarkus.redis.datasource.RedisDataSource;
-import io.quarkus.test.QuarkusUnitTest;
-import io.quarkus.test.common.QuarkusTestResource;
-import io.vertx.mutiny.redis.client.Redis;
-import io.vertx.redis.client.RedisAPI;
-
-@QuarkusTestResource(RedisTestResource.class)
-public class RedisInactiveClientsTest {
-    @RegisterExtension
-    static final QuarkusUnitTest unitTest = new QuarkusUnitTest()
-            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class));
-
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<Redis> inactive;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<io.vertx.redis.client.Redis> inactiveBare;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<RedisAPI> inactiveApi;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<io.vertx.redis.client.RedisAPI> inactiveBareApi;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<RedisDataSource> inactiveDataSource;
-    @Inject
-    @RedisClientName("inactive")
-    InjectableInstance<ReactiveRedisDataSource> inactiveReactiveDataSource;
-
-    @Test
-    void inactiveClients() {
-        assertEquals(0, inactive.listActive().size());
-        assertEquals(0, inactiveBare.listActive().size());
-        assertEquals(0, inactiveApi.listActive().size());
-        assertEquals(0, inactiveBareApi.listActive().size());
-        assertEquals(0, inactiveDataSource.listActive().size());
-        assertEquals(0, inactiveReactiveDataSource.listActive().size());
-    }
-}
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/RedisClientRecorder.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/RedisClientRecorder.java
index 2b9447cce1f..831a3cd9890 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/RedisClientRecorder.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/RedisClientRecorder.java
@@ -1,20 +1,18 @@
 package io.quarkus.redis.runtime.client;
 
-import static io.quarkus.redis.runtime.client.config.RedisConfig.HOSTS;
-import static io.quarkus.redis.runtime.client.config.RedisConfig.HOSTS_PROVIDER_NAME;
-import static io.quarkus.redis.runtime.client.config.RedisConfig.getPropertyName;
+import static io.quarkus.redis.runtime.client.config.RedisConfig.DEFAULT_CLIENT_NAME;
 
 import java.time.Duration;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import java.util.function.Supplier;
 
 import jakarta.enterprise.inject.Instance;
 import jakarta.enterprise.inject.spi.CDI;
 
-import io.quarkus.arc.ActiveResult;
 import io.quarkus.proxy.ProxyConfigurationRegistry;
 import io.quarkus.redis.client.RedisClient;
 import io.quarkus.redis.client.reactive.ReactiveRedisClient;
@@ -29,6 +27,7 @@
 import io.quarkus.runtime.RuntimeValue;
 import io.quarkus.runtime.ShutdownContext;
 import io.quarkus.runtime.annotations.Recorder;
+import io.quarkus.runtime.configuration.ConfigurationException;
 import io.quarkus.tls.TlsConfigurationRegistry;
 import io.vertx.mutiny.core.Vertx;
 import io.vertx.mutiny.redis.client.Command;
@@ -38,15 +37,16 @@
 
 @Recorder
 public class RedisClientRecorder {
+
     // Split client and DS recorders
-    private final RuntimeValue<RedisConfig> runtimeConfig;
+    private final RuntimeValue<RedisConfig> config;
     private static final Map<String, RedisClientAndApi> clients = new HashMap<>();
     private static final Map<String, ReactiveRedisDataSourceImpl> dataSources = new HashMap<>();
     private Vertx vertx;
     private ObservableRedisMetrics metrics;
 
-    public RedisClientRecorder(RuntimeValue<RedisConfig> runtimeConfig) {
-        this.runtimeConfig = runtimeConfig;
+    public RedisClientRecorder(RuntimeValue<RedisConfig> rc) {
+        this.config = rc;
     }
 
     public void initialize(RuntimeValue<io.vertx.core.Vertx> vertx, Set<String> names,
@@ -78,12 +78,47 @@ private static void _registerCodecs() {
     public void _initialize(io.vertx.core.Vertx vertx, Set<String> names, TlsConfigurationRegistry tlsRegistry,
             ProxyConfigurationRegistry proxyRegistry) {
         for (String name : names) {
-            if (checkActive(name).get().value()) {
-                RedisClientConfig redisClientConfig = runtimeConfig.getValue().clients().get(name);
-                clients.putIfAbsent(name, new RedisClientAndApi(name,
-                        VertxRedisClientFactory.create(name, vertx, redisClientConfig, tlsRegistry, proxyRegistry), metrics));
+            // Search if we have an associated config:
+            // - if default -> Default
+            // - if named -> Look for that config
+            // - if not found -> ConfigurationException
+            Optional<RedisClientConfig> maybe = getConfigForName(config.getValue(), name);
+            if (!RedisConfig.isDefaultClient(name)) {
+                RedisClientConfig actualConfig = maybe
+                        .orElseThrow(new Supplier<ConfigurationException>() {
+                            @Override
+                            public ConfigurationException get() {
+                                return new ConfigurationException("The application contains a " +
+                                        "@RedisClientName(\"" + name
+                                        + "\"), but the application configuration does not configure this " +
+                                        "redis client configuration with that name. " +
+                                        "You must at least configure `quarkus.redis." + name + ".hosts`.");
+                            }
+                        });
+                clients.computeIfAbsent(name, x -> new RedisClientAndApi(name,
+                        VertxRedisClientFactory.create(name, vertx, actualConfig, tlsRegistry, proxyRegistry),
+                        metrics));
+            } else if (DEFAULT_CLIENT_NAME.equalsIgnoreCase(name) && maybe.isPresent()) {
+                clients.computeIfAbsent(name, x -> new RedisClientAndApi(name,
+                        VertxRedisClientFactory.create(DEFAULT_CLIENT_NAME, vertx, maybe.get(), tlsRegistry, proxyRegistry),
+                        metrics));
+            }
+            // Do not throw an error. We would need to check if the default redis client is used.
+        }
+
+    }
+
+    static Optional<RedisClientConfig> getConfigForName(RedisConfig cfg, String name) {
+        if (RedisConfig.isDefaultClient(name)) {
+            return Optional.ofNullable(cfg.defaultRedisClient());
+        }
+
+        for (Map.Entry<String, RedisClientConfig> entry : cfg.namedRedisClients().entrySet()) {
+            if (entry.getKey().equalsIgnoreCase(name)) {
+                return Optional.of(entry.getValue());
             }
         }
+        return Optional.empty();
     }
 
     public Supplier<Redis> getRedisClient(String name) {
@@ -140,7 +175,7 @@ public Supplier<RedisDataSource> getBlockingDataSource(String name) {
         return new Supplier<RedisDataSource>() {
             @Override
             public RedisDataSource get() {
-                Duration timeout = runtimeConfig.getValue().clients().get(name).timeout();
+                Duration timeout = RedisClientRecorder.this.getTimeoutForClient(name);
                 return new BlockingRedisDataSourceImpl(
                         (ReactiveRedisDataSourceImpl) RedisClientRecorder.this.getReactiveDataSource(name).get(), timeout);
             }
@@ -152,7 +187,7 @@ public Supplier<RedisClient> getLegacyRedisClient(String name) {
         return new Supplier<RedisClient>() {
             @Override
             public RedisClient get() {
-                Duration timeout = runtimeConfig.getValue().clients().get(name).timeout();
+                Duration timeout = getTimeoutForClient(name);
                 return new RedisClientImpl(
                         RedisClientRecorder.this.getRedisClient(name).get(),
                         RedisClientRecorder.this.getRedisAPI(name).get(),
@@ -161,6 +196,16 @@ public RedisClient get() {
         };
     }
 
+    private Duration getTimeoutForClient(String name) {
+        Duration timeout;
+        if (RedisConfig.isDefaultClient(name)) {
+            timeout = config.getValue().defaultRedisClient().timeout();
+        } else {
+            timeout = config.getValue().namedRedisClients().get(name).timeout();
+        }
+        return timeout;
+    }
+
     public Supplier<ReactiveRedisClient> getLegacyReactiveRedisClient(String name) {
         return new Supplier<ReactiveRedisClient>() {
             @Override
@@ -171,34 +216,6 @@ public ReactiveRedisClient get() {
         };
     }
 
-    public Supplier<ActiveResult> checkActive(final String name) {
-        return new Supplier<>() {
-            @Override
-            public ActiveResult get() {
-                RedisClientConfig redisClientConfig = runtimeConfig.getValue().clients().get(name);
-                if (!redisClientConfig.active()) {
-                    return ActiveResult.inactive(String.format(
-                            """
-                                    Redis Client '%s' was deactivated through configuration properties. \
-                                    To activate the Redis Client, set configuration property '%s' to 'true' and configure the Redis Client '%s'. \
-                                    Refer to https://quarkus.io/guides/redis-reference for guidance.
-                                    """,
-                            name, getPropertyName(name, "active"), name));
-                }
-                if (redisClientConfig.hosts().isEmpty() && redisClientConfig.hostsProviderName().isEmpty()) {
-                    return ActiveResult.inactive(String.format(
-                            """
-                                    Redis Client '%s' was deactivated automatically because neither the hosts nor the hostsProviderName is set. \
-                                    To activate the Redis Client, set the configuration property '%s' or '%s'. \
-                                    Refer to https://quarkus.io/guides/redis-reference for guidance.
-                                    """,
-                            name, getPropertyName(name, HOSTS), getPropertyName(name, HOSTS_PROVIDER_NAME)));
-                }
-                return ActiveResult.active();
-            }
-        };
-    }
-
     public void cleanup(ShutdownContext context) {
         context.addShutdownTask(new Runnable() {
             @Override
@@ -246,4 +263,5 @@ private RedisClientAndApi(String name, io.vertx.redis.client.Redis redis, Observ
             this.api = RedisAPI.api(this.redis);
         }
     }
+
 }
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/config/RedisClientConfig.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/config/RedisClientConfig.java
index 24ae2ce6258..79888ec740a 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/config/RedisClientConfig.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/config/RedisClientConfig.java
@@ -19,11 +19,6 @@
 
 @ConfigGroup
 public interface RedisClientConfig {
-    /**
-     * Whether this Redis Client should be active at runtime.
-     */
-    @WithDefault("true")
-    boolean active();
 
     /**
      * The Redis hosts to use while connecting to the Redis server. Only the cluster and sentinel modes will consider more than
@@ -292,4 +287,5 @@ default String toDebugString() {
                 ", configureClientName=" + configureClientName() +
                 '}';
     }
+
 }
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/config/RedisConfig.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/config/RedisConfig.java
index dc4e714993d..9feca011000 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/config/RedisConfig.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/config/RedisConfig.java
@@ -6,72 +6,60 @@
 import io.quarkus.runtime.annotations.ConfigPhase;
 import io.quarkus.runtime.annotations.ConfigRoot;
 import io.smallrye.config.ConfigMapping;
-import io.smallrye.config.WithDefaults;
 import io.smallrye.config.WithParentName;
-import io.smallrye.config.WithUnnamedKey;
 
 @ConfigMapping(prefix = "quarkus.redis")
 @ConfigRoot(phase = ConfigPhase.RUN_TIME)
 public interface RedisConfig {
+    String REDIS_CONFIG_ROOT_NAME = "redis";
+    String HOSTS_CONFIG_NAME = "hosts";
     String DEFAULT_CLIENT_NAME = "<default>";
-    String HOSTS = "hosts";
-    String HOSTS_PROVIDER_NAME = "hosts-provider-name";
 
     /**
-     * Configures the Redis clients.
+     * The default redis client
+     */
+    @WithParentName
+    RedisClientConfig defaultRedisClient();
+
+    /**
+     * Configures additional (named) Redis clients.
      * <p>
-     * The default client does not have a name, and it is configured as:
-     *
-     * <pre>
-     * quarkus.redis.hosts = redis://localhost:6379
-     * </pre>
-     *
-     * And then use {@link jakarta.inject.Inject} to inject the client:
-     *
-     * <pre>
-     * &#64;Inject
-     * RedisAPI redis;
-     * </pre>
-     *
+     * Each client has a unique name which must be identified to select the right client.
+     * For example:
      * <p>
-     * Named clients must be identified to select the right client:
      *
      * <pre>
      * quarkus.redis.client1.hosts = redis://localhost:6379
      * quarkus.redis.client2.hosts = redis://localhost:6380
      * </pre>
-     *
-     * And then use the {@link io.quarkus.redis.client.RedisClientName} annotation to select any of the beans:
-     * <ul>
-     * <li>{@link io.vertx.mutiny.redis.client.Redis}</li>
-     * <li>{@link io.vertx.redis.client.Redis}</li>
-     * <li>{@link io.vertx.mutiny.redis.client.RedisAPI}</li>
-     * <li>{@link io.vertx.redis.client.RedisAPI}</li>
-     * <li>{@link io.quarkus.redis.datasource.RedisDataSource}</li>
-     * <li>{@link io.quarkus.redis.datasource.ReactiveRedisDataSource}</li>
-     * </ul>
-     * And inject the client:
+     * <p>
+     * And then use the {@link io.quarkus.redis.client.RedisClientName} annotation to select the
+     * {@link io.vertx.mutiny.redis.client.Redis},
+     * {@link io.vertx.redis.client.Redis}, {@link io.vertx.mutiny.redis.client.RedisAPI} and
+     * {@link io.vertx.redis.client.RedisAPI} beans.
+     * <p>
      *
      * <pre>
-     * &#64;RedisClientName("client1")
-     * &#64;Inject
-     * RedisAPI redis;
+     * {
+     *     &#64;code
+     *     &#64;RedisClientName("client1")
+     *     &#64;Inject
+     *     RedisAPI redis;
+     * }
      * </pre>
      */
     @WithParentName
-    @WithDefaults
-    @WithUnnamedKey(DEFAULT_CLIENT_NAME)
     @ConfigDocMapKey("redis-client-name")
-    Map<String, RedisClientConfig> clients();
+    Map<String, RedisClientConfig> namedRedisClients();
 
-    static boolean isDefaultClient(final String name) {
+    static boolean isDefaultClient(String name) {
         return DEFAULT_CLIENT_NAME.equalsIgnoreCase(name);
     }
 
-    static String getPropertyName(final String name, final String attribute) {
+    static String propertyKey(String name, String radical) {
         String prefix = DEFAULT_CLIENT_NAME.equals(name)
                 ? "quarkus.redis."
-                : "quarkus.redis." + (name.contains(".") ? "\"" + name + "\"" : name) + ".";
-        return prefix + attribute;
+                : "quarkus.redis.\"" + name + "\".";
+        return prefix + radical;
     }
 }
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/health/RedisHealthCheck.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/health/RedisHealthCheck.java
index 3bc652836fa..d30c2068ef7 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/health/RedisHealthCheck.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/client/health/RedisHealthCheck.java
@@ -1,6 +1,6 @@
 package io.quarkus.redis.runtime.client.health;
 
-import static io.quarkus.redis.runtime.client.config.RedisConfig.DEFAULT_CLIENT_NAME;
+import static io.quarkus.redis.runtime.client.VertxRedisClientFactory.DEFAULT_CLIENT;
 
 import java.time.Duration;
 import java.util.HashMap;
@@ -10,16 +10,17 @@
 import jakarta.enterprise.context.ApplicationScoped;
 import jakarta.enterprise.inject.Any;
 import jakarta.enterprise.inject.spi.Bean;
-import jakarta.inject.Inject;
 
 import org.eclipse.microprofile.health.HealthCheck;
 import org.eclipse.microprofile.health.HealthCheckResponse;
 import org.eclipse.microprofile.health.HealthCheckResponseBuilder;
 import org.eclipse.microprofile.health.Readiness;
 
-import io.quarkus.arc.InjectableInstance;
+import io.quarkus.arc.Arc;
 import io.quarkus.arc.InstanceHandle;
 import io.quarkus.redis.client.RedisClientName;
+import io.quarkus.redis.datasource.ReactiveRedisDataSource;
+import io.quarkus.redis.datasource.RedisDataSource;
 import io.quarkus.redis.runtime.client.config.RedisConfig;
 import io.smallrye.mutiny.TimeoutException;
 import io.vertx.mutiny.redis.client.Command;
@@ -32,52 +33,71 @@
 class RedisHealthCheck implements HealthCheck {
     private final Map<String, Redis> clients = new HashMap<>();
 
-    @Inject
-    RedisConfig config;
-    @Inject
-    @Any
-    InjectableInstance<Redis> redis;
+    private final RedisConfig config;
+
+    public RedisHealthCheck(RedisConfig config) {
+        this.config = config;
+    }
 
     @PostConstruct
     protected void init() {
-        for (InstanceHandle<Redis> handle : redis.handles()) {
-            if (handle.getBean().isActive()) {
-                clients.putIfAbsent(getClientName(handle.getBean()), handle.get());
+        for (InstanceHandle<Redis> handle : Arc.container().select(Redis.class, Any.Literal.INSTANCE).handles()) {
+            String clientName = getClientName(handle.getBean());
+            clients.putIfAbsent(clientName == null ? DEFAULT_CLIENT : clientName, handle.get());
+        }
+
+        for (InstanceHandle<ReactiveRedisDataSource> handle : Arc.container()
+                .select(ReactiveRedisDataSource.class, Any.Literal.INSTANCE).handles()) {
+            String clientName = getClientName(handle.getBean());
+            Redis redis = handle.get().getRedis();
+            clients.putIfAbsent(clientName == null ? DEFAULT_CLIENT : clientName, redis);
+        }
+
+        for (InstanceHandle<RedisDataSource> handle : Arc.container().select(RedisDataSource.class, Any.Literal.INSTANCE)
+                .handles()) {
+            String clientName = getClientName(handle.getBean());
+            Redis redis = handle.get().getReactive().getRedis();
+            clients.putIfAbsent(clientName == null ? DEFAULT_CLIENT : clientName, redis);
+        }
+    }
+
+    private String getClientName(Bean<?> bean) {
+        for (Object qualifier : bean.getQualifiers()) {
+            if (qualifier instanceof RedisClientName) {
+                return ((RedisClientName) qualifier).value();
             }
         }
+        return null;
+    }
+
+    private Duration getTimeout(String name) {
+        if (RedisConfig.isDefaultClient(name)) {
+            return config.defaultRedisClient().timeout();
+        } else {
+            return config.namedRedisClients().get(name).timeout();
+        }
     }
 
     @Override
     public HealthCheckResponse call() {
         HealthCheckResponseBuilder builder = HealthCheckResponse.named("Redis connection health check").up();
         for (Map.Entry<String, Redis> client : clients.entrySet()) {
-            String clientName = client.getKey().equals(DEFAULT_CLIENT_NAME) ? "default" : client.getKey();
-            Redis redisClient = client.getValue();
-            Duration timeout = config.clients().get(clientName).timeout();
             try {
+                boolean isDefault = DEFAULT_CLIENT.equals(client.getKey());
+                Redis redisClient = client.getValue();
+                String redisClientName = isDefault ? "default" : client.getKey();
+                Duration timeout = getTimeout(client.getKey());
                 Response response = redisClient.send(Request.cmd(Command.PING)).await().atMost(timeout);
-                builder.up().withData(clientName, response.toString());
+                builder.up().withData(redisClientName, response.toString());
             } catch (TimeoutException e) {
-                builder.down().withData(clientName,
-                        "Unable to execute the validation check for the Redis Client due to timeout");
+                return builder.down().withData("reason", "client [" + client.getKey() + "]: timeout").build();
             } catch (Exception e) {
                 if (e.getMessage() == null) {
-                    builder.down().withData(clientName, "Unable to execute the validation check for the Redis Client: " + e);
-                } else {
-                    builder.down().withData(clientName,
-                            "Unable to execute the validation check for the Redis Client: " + e.getMessage());
+                    return builder.down().withData("reason", "client [" + client.getKey() + "]: " + e).build();
                 }
+                return builder.down().withData("reason", "client [" + client.getKey() + "]: " + e.getMessage()).build();
             }
         }
         return builder.build();
     }
-
-    private static String getClientName(final Bean<?> bean) {
-        for (Object qualifier : bean.getQualifiers()) {
-            if (qualifier instanceof RedisClientName redisClientName) {
-                return redisClientName.value();
-            }
-        }
-        return DEFAULT_CLIENT_NAME;
-    }
 }
diff --git a/extensions/spring-web/resteasy-reactive/deployment/src/main/java/io/quarkus/spring/web/resteasy/reactive/deployment/SpringWebResteasyReactiveProcessor.java b/extensions/spring-web/resteasy-reactive/deployment/src/main/java/io/quarkus/spring/web/resteasy/reactive/deployment/SpringWebResteasyReactiveProcessor.java
index 3f3e6b624ed..d4e01042f37 100644
--- a/extensions/spring-web/resteasy-reactive/deployment/src/main/java/io/quarkus/spring/web/resteasy/reactive/deployment/SpringWebResteasyReactiveProcessor.java
+++ b/extensions/spring-web/resteasy-reactive/deployment/src/main/java/io/quarkus/spring/web/resteasy/reactive/deployment/SpringWebResteasyReactiveProcessor.java
@@ -303,15 +303,6 @@ public void transform(TransformationContext transformationContext) {
                             AnnotationValue defaultValue = annotation.value("defaultValue");
                             if (defaultValue != null) {
                                 defaultValueStr = defaultValue.asString();
-                            } else {
-                                AnnotationValue requiredValue = annotation.value("required");
-                                if (requiredValue != null) {
-                                    if (requiredValue.asBoolean()) {
-                                        throw new IllegalArgumentException(
-                                                "Using required @RequestMapping is not supported. Offending method is '"
-                                                        + methodInfo.declaringClass().name() + "#" + methodInfo.name() + "'");
-                                    }
-                                }
                             }
                             if (defaultValueStr != null) {
                                 transform.add(create(DEFAULT_VALUE, annotation.target(),
diff --git a/extensions/spring-web/resteasy-reactive/tests/src/test/java/io/quarkus/spring/web/requestparam/RequestParamController.java b/extensions/spring-web/resteasy-reactive/tests/src/test/java/io/quarkus/spring/web/requestparam/RequestParamController.java
index 9cdd0ba0712..a59ed04ce85 100644
--- a/extensions/spring-web/resteasy-reactive/tests/src/test/java/io/quarkus/spring/web/requestparam/RequestParamController.java
+++ b/extensions/spring-web/resteasy-reactive/tests/src/test/java/io/quarkus/spring/web/requestparam/RequestParamController.java
@@ -80,6 +80,11 @@ public String getFoosParamRequired(@RequestParam String id) {
         throw new IllegalStateException("Unexpected state. Should have not been called");
     }
 
+    @GetMapping("/api/foos/paramExplicitlyRequired")
+    public String getFoosParamExplicitlyRequired(@RequestParam(required = true) String id) {
+        throw new IllegalStateException("Unexpected state. Should have not been called");
+    }
+
     @RestControllerAdvice
     public static class RestExceptionHandler {
 
@@ -87,6 +92,7 @@ public static class RestExceptionHandler {
         public ResponseEntity<Object> handleException(Exception ex) {
             return new ResponseEntity<>(ex.getMessage(), HttpStatus.BAD_REQUEST);
         }
+
     }
 
 }
diff --git a/extensions/spring-web/resteasy-reactive/tests/src/test/java/io/quarkus/spring/web/requestparam/RequestParamControllerTest.java b/extensions/spring-web/resteasy-reactive/tests/src/test/java/io/quarkus/spring/web/requestparam/RequestParamControllerTest.java
index a6630e21f20..fd694f798c8 100644
--- a/extensions/spring-web/resteasy-reactive/tests/src/test/java/io/quarkus/spring/web/requestparam/RequestParamControllerTest.java
+++ b/extensions/spring-web/resteasy-reactive/tests/src/test/java/io/quarkus/spring/web/requestparam/RequestParamControllerTest.java
@@ -129,6 +129,10 @@ public void shouldFailWithBadRequestWhenMissingMandatoryParam() throws Exception
         when().get("/api/foos/paramRequired")
                 .then()
                 .statusCode(400).body(containsString("Missing required param in method"));
+
+        when().get("/api/foos/paramExplicitlyRequired")
+                .then()
+                .statusCode(400).body(containsString("Missing required param in method"));
     }
 
 }
diff --git a/independent-projects/bootstrap/maven4-resolver/pom.xml b/independent-projects/bootstrap/maven4-resolver/pom.xml
index f42737e1d40..f0f613332de 100644
--- a/independent-projects/bootstrap/maven4-resolver/pom.xml
+++ b/independent-projects/bootstrap/maven4-resolver/pom.xml
@@ -22,7 +22,7 @@
         <dependency>
             <groupId>org.eclipse.sisu</groupId>
             <artifactId>org.eclipse.sisu.inject</artifactId>
-            <version>0.9.0.M3</version>
+            <version>0.9.0.M4</version>
         </dependency>
         <dependency>
             <groupId>org.apache.maven</groupId>
diff --git a/pom.xml b/pom.xml
index 7a9a9a6bef0..9bbc302cbda 100644
--- a/pom.xml
+++ b/pom.xml
@@ -82,7 +82,7 @@
         <hibernate-tools.version>7.1.6.Final</hibernate-tools.version>
 
         <!-- Make sure to check compatibility between these 2 gRPC components before upgrade -->
-        <grpc.version>1.75.0</grpc.version> <!-- when updating, verify if following versions should not be updated too: -->
+        <grpc.version>1.76.0</grpc.version> <!-- when updating, verify if following versions should not be updated too: -->
                                             <!-- com.google.auth -->
                                             <!-- perfmark.version https://central.sonatype.com/artifact/io.grpc/grpc-core  -->
         <grpc-jprotoc.version>1.2.2</grpc-jprotoc.version>
