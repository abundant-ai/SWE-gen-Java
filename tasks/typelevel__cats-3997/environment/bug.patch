diff --git a/core/src/main/scala/cats/Alternative.scala b/core/src/main/scala/cats/Alternative.scala
index 1f8643d09..9054d9b10 100644
--- a/core/src/main/scala/cats/Alternative.scala
+++ b/core/src/main/scala/cats/Alternative.scala
@@ -6,15 +6,6 @@ import scala.annotation.implicitNotFound
 @implicitNotFound("Could not find an instance of Alternative for ${F}")
 @typeclass trait Alternative[F[_]] extends NonEmptyAlternative[F] with MonoidK[F] { self =>
 
-  // Note: `protected` is only necessary to enforce binary compatibility
-  // since neither `private` nor `private[cats]` work properly here.
-  @deprecated("use a FlatMap-constrained version instead", "2.6.2")
-  protected def unite[G[_], A](fga: F[G[A]])(FM: Monad[F], G: Foldable[G]): F[A] = {
-    implicit def FM0: FlatMap[F] = FM
-    implicit def G0: Foldable[G] = G
-    unite(fga)
-  }
-
   /**
    * Fold over the inner structure to combine all of the values with
    * our combine method inherited from MonoidK. The result is for us
@@ -24,34 +15,29 @@ import scala.annotation.implicitNotFound
    *
    * Example:
    * {{{
+   * scala> import cats.implicits._
    * scala> val x: List[Vector[Int]] = List(Vector(1, 2), Vector(3, 4))
    * scala> Alternative[List].unite(x)
    * res0: List[Int] = List(1, 2, 3, 4)
    * }}}
    */
-  def unite[G[_], A](fga: F[G[A]])(implicit FM: FlatMap[F], G: Foldable[G]): F[A] =
-    FM.flatMap(fga) { G.foldMapK(_)(pure)(self) }
-
-  // Note: `protected` is only necessary to enforce binary compatibility
-  // since neither `private` nor `private[cats]` work properly here.
-  @deprecated("use a FlatMap-constrained version instead", "2.6.2")
-  protected def separate[G[_, _], A, B](fgab: F[G[A, B]])(FM: Monad[F], G: Bifoldable[G]): (F[A], F[B]) = {
-    implicit def FM0: FlatMap[F] = FM
-    implicit def G0: Bifoldable[G] = G
-    separate(fgab)
-  }
+  def unite[G[_], A](fga: F[G[A]])(implicit FM: Monad[F], G: Foldable[G]): F[A] =
+    FM.flatMap(fga) { ga =>
+      G.foldLeft(ga, empty[A])((acc, a) => appendK(acc, a))
+    }
 
   /**
-   * Separate the inner foldable values into the "lefts" and "rights".
+   * Separate the inner foldable values into the "lefts" and "rights"
    *
    * Example:
    * {{{
+   * scala> import cats.implicits._
    * scala> val l: List[Either[String, Int]] = List(Right(1), Left("error"))
    * scala> Alternative[List].separate(l)
    * res0: (List[String], List[Int]) = (List(error),List(1))
    * }}}
    */
-  def separate[G[_, _], A, B](fgab: F[G[A, B]])(implicit FM: FlatMap[F], G: Bifoldable[G]): (F[A], F[B]) = {
+  def separate[G[_, _], A, B](fgab: F[G[A, B]])(implicit FM: Monad[F], G: Bifoldable[G]): (F[A], F[B]) = {
     val as = FM.flatMap(fgab)(gab => G.bifoldMap(gab)(pure, _ => empty[A])(algebra[A]))
     val bs = FM.flatMap(fgab)(gab => G.bifoldMap(gab)(_ => empty[B], pure)(algebra[B]))
     (as, bs)
@@ -59,9 +45,9 @@ import scala.annotation.implicitNotFound
 
   /**
    * Separate the inner foldable values into the "lefts" and "rights".
-   * 
-   * A variant of [[[separate[G[_,_],A,B](fgab:F[G[A,B]])(implicitFM:cats\.FlatMap[F]* separate]]]
-   * that is specialized for Fs that have Foldable instances which allows for a single-pass implementation
+   * A variant of [[separate]] that is specialized
+   * for Fs that have Foldable instances
+   * which allows for a single-pass implementation
    * (as opposed to {{{separate}}} which is 2-pass).
    *
    * Example:
@@ -129,11 +115,9 @@ object Alternative {
     def self: F[A]
     val typeClassInstance: TypeClassType
     def unite[G[_], B](implicit ev$1: A <:< G[B], FM: Monad[F], G: Foldable[G]): F[B] =
-      // Note: edited manually since seems Simulacrum is not able to handle the bin-compat redirection properly.
-      typeClassInstance.unite[G, B](self.asInstanceOf[F[G[B]]])
+      typeClassInstance.unite[G, B](self.asInstanceOf[F[G[B]]])(FM, G)
     def separate[G[_, _], B, C](implicit ev$1: A <:< G[B, C], FM: Monad[F], G: Bifoldable[G]): (F[B], F[C]) =
-      // Note: edited manually since seems Simulacrum is not able to handle the bin-compat redirection properly.
-      typeClassInstance.separate[G, B, C](self.asInstanceOf[F[G[B, C]]])
+      typeClassInstance.separate[G, B, C](self.asInstanceOf[F[G[B, C]]])(FM, G)
     def separateFoldable[G[_, _], B, C](implicit ev$1: A <:< G[B, C], G: Bifoldable[G], FF: Foldable[F]): (F[B], F[C]) =
       typeClassInstance.separateFoldable[G, B, C](self.asInstanceOf[F[G[B, C]]])(G, FF)
   }
diff --git a/core/src/main/scala/cats/syntax/alternative.scala b/core/src/main/scala/cats/syntax/alternative.scala
index 15306fba0..79ac72977 100644
--- a/core/src/main/scala/cats/syntax/alternative.scala
+++ b/core/src/main/scala/cats/syntax/alternative.scala
@@ -13,18 +13,11 @@ trait AlternativeSyntax {
     new GuardOps(b)
 }
 
-final class UniteOps[F[_], G[_], A](protected val fga: F[G[A]]) extends AnyVal with UniteOpsBinCompat0[F, G, A] {
-
-  @deprecated("use a FlatMap-constrained version instead", "2.6.2")
-  protected def unite(F: Monad[F], A: Alternative[F], G: Foldable[G]): F[A] =
-    A.unite(fga)(F, G)
-}
-
-sealed private[syntax] trait UniteOpsBinCompat0[F[_], G[_], A] extends Any { self: UniteOps[F, G, A] =>
+final class UniteOps[F[_], G[_], A](private val fga: F[G[A]]) extends AnyVal {
 
   /**
-   * See [[[Alternative.unite[G[_],A](fga:F[G[A]])(implicitFM:cats\.FlatMap[F]*]]]
-   * 
+   * @see [[Alternative.unite]]
+   *
    * Example:
    * {{{
    * scala> import cats.implicits._
@@ -33,55 +26,44 @@ sealed private[syntax] trait UniteOpsBinCompat0[F[_], G[_], A] extends Any { sel
    * res0: List[Int] = List(1, 2, 3, 4)
    * }}}
    */
-  def unite(implicit F: FlatMap[F], A: Alternative[F], G: Foldable[G]): F[A] =
-    A.unite[G, A](fga)
+  def unite(implicit F: Monad[F], A: Alternative[F], G: Foldable[G]): F[A] = A.unite[G, A](fga)
 }
 
-final class SeparateOps[F[_], G[_, _], A, B](protected val fgab: F[G[A, B]])
-    extends AnyVal
-    with SeparateOpsBinCompat0[F, G, A, B] {
-
-  @deprecated("use a FlatMap-constrained version instead", "2.6.2")
-  protected def separate(F: Monad[F], A: Alternative[F], G: Bifoldable[G]): (F[A], F[B]) =
-    A.separate[G, A, B](fgab)(F, G)
+final class SeparateOps[F[_], G[_, _], A, B](private val fgab: F[G[A, B]]) extends AnyVal {
 
   /**
-   * See [[Alternative.separateFoldable]]
-   * 
+   * @see [[Alternative.separate]]
+   *
    * Example:
    * {{{
    * scala> import cats.implicits._
    * scala> val l: List[Either[String, Int]] = List(Right(1), Left("error"))
-   * scala> l.separateFoldable
+   * scala> l.separate
    * res0: (List[String], List[Int]) = (List(error),List(1))
    * }}}
    */
-  def separateFoldable(implicit F: Foldable[F], A: Alternative[F], G: Bifoldable[G]): (F[A], F[B]) =
-    A.separateFoldable[G, A, B](fgab)
-}
-
-sealed private[syntax] trait SeparateOpsBinCompat0[F[_], G[_, _], A, B] extends Any { self: SeparateOps[F, G, A, B] =>
+  def separate(implicit F: Monad[F], A: Alternative[F], G: Bifoldable[G]): (F[A], F[B]) = A.separate[G, A, B](fgab)
 
   /**
-   * See [[[Alternative.separate[G[_,_],A,B](fgab:F[G[A,B]])(implicitFM:cats\.FlatMap[F]* Alternative.separate]]]
-   * 
+   * @see [[Alternative.separateFoldable]]
+   *
    * Example:
    * {{{
    * scala> import cats.implicits._
    * scala> val l: List[Either[String, Int]] = List(Right(1), Left("error"))
-   * scala> l.separate
+   * scala> l.separateFoldable
    * res0: (List[String], List[Int]) = (List(error),List(1))
    * }}}
    */
-  def separate(implicit F: FlatMap[F], A: Alternative[F], G: Bifoldable[G]): (F[A], F[B]) =
-    A.separate[G, A, B](fgab)
+  def separateFoldable(implicit F: Foldable[F], A: Alternative[F], G: Bifoldable[G]): (F[A], F[B]) =
+    A.separateFoldable[G, A, B](fgab)
 }
 
 final class GuardOps(private val condition: Boolean) extends AnyVal {
 
   /**
-   * See [[Alternative.guard]]
-   * 
+   * @see [[Alternative.guard]]
+   *
    * Example:
    * {{{
    * scala> import cats.implicits._
diff --git a/tests/src/test/scala/cats/tests/AlternativeSuite.scala b/tests/src/test/scala/cats/tests/AlternativeSuite.scala
index d715c7f5f..51b3dc617 100644
--- a/tests/src/test/scala/cats/tests/AlternativeSuite.scala
+++ b/tests/src/test/scala/cats/tests/AlternativeSuite.scala
@@ -1,7 +1,6 @@
 package cats.tests
 
 import cats.Alternative
-import cats.FlatMap
 import cats.laws.discipline.AlternativeTests
 import cats.syntax.eq._
 import org.scalacheck.Prop._
@@ -23,30 +22,16 @@ class AlternativeSuite extends CatsSuite {
       val expected = list.collect { case Some(s) => s }
 
       assert(Alternative[List].unite(list) === expected)
-
-      // See #3997: check that correct `unite` version is picked up.
-      implicit val listWrapperAlternative: Alternative[ListWrapper] = ListWrapper.alternative
-      implicit val listWrapperFlatMap: FlatMap[ListWrapper] = ListWrapper.flatMap
-
-      assert(Alternative[ListWrapper].unite(ListWrapper(list)).list === expected)
     }
   }
 
   property("separate") {
     forAll { (list: List[Either[Int, String]]) =>
-      val expectedInts = list.collect { case Left(i) => i }
-      val expectedStrings = list.collect { case Right(s) => s }
-      val expected = (expectedInts, expectedStrings)
+      val ints = list.collect { case Left(i) => i }
+      val strings = list.collect { case Right(s) => s }
+      val expected = (ints, strings)
 
       assert(Alternative[List].separate(list) === expected)
-
-      // See #3997: check that correct `separate` version is picked up.
-      implicit val listWrapperAlternative: Alternative[ListWrapper] = ListWrapper.alternative
-      implicit val listWrapperFlatMap: FlatMap[ListWrapper] = ListWrapper.flatMap
-
-      val (obtainedLwInts, obtainedLwStrings) = Alternative[ListWrapper].separate(ListWrapper(list))
-      assert(obtainedLwInts.list === expectedInts)
-      assert(obtainedLwStrings.list === expectedStrings)
     }
   }
 
diff --git a/tests/src/test/scala/cats/tests/SyntaxSuite.scala b/tests/src/test/scala/cats/tests/SyntaxSuite.scala
index 52a98b262..825d49a5c 100644
--- a/tests/src/test/scala/cats/tests/SyntaxSuite.scala
+++ b/tests/src/test/scala/cats/tests/SyntaxSuite.scala
@@ -370,7 +370,7 @@ object SyntaxSuite {
     val fa2: F[A] = fa.appendK(a)
   }
 
-  def testAlternativeFlatMap[F[_]: Alternative: FlatMap, G[_]: Foldable, H[_, _]: Bifoldable, A, B]: Unit = {
+  def testAlternativeMonad[F[_]: Alternative: Monad, G[_]: Foldable, H[_, _]: Bifoldable, A, B]: Unit = {
     val fga = mock[F[G[A]]]
     val fa = fga.unite
 
