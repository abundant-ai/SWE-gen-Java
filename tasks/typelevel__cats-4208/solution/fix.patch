diff --git a/core/src/main/scala/cats/Applicative.scala b/core/src/main/scala/cats/Applicative.scala
index 33887665d..864987c55 100644
--- a/core/src/main/scala/cats/Applicative.scala
+++ b/core/src/main/scala/cats/Applicative.scala
@@ -94,6 +94,35 @@ trait Applicative[F[_]] extends Apply[F] with InvariantMonoidal[F] { self =>
       })(identity)(this))(_.toList)
     }
 
+  /**
+   * Given `fa` and `n`, apply `fa` `n` times discarding results to return F[Unit].
+   *
+   * Example:
+   * {{{
+   * scala> import cats.data.State
+   *
+   * scala> type Counter[A] = State[Int, A]
+   * scala> val getAndIncrement: Counter[Int] = State { i => (i + 1, i) }
+   * scala> val getAndIncrement5: Counter[Unit] =
+   *      | Applicative[Counter].replicateA_(5, getAndIncrement)
+   * scala> getAndIncrement5.run(0).value
+   * res0: (Int, Unit) = (5,())
+   * }}}
+   */
+  def replicateA_[A](n: Int, fa: F[A]): F[Unit] = {
+    val fvoid = void(fa)
+    def loop(n: Int): F[Unit] =
+      if (n <= 0) unit
+      else if (n == 1) fvoid
+      else {
+        val half = loop(n >> 1)
+        val both = productR(half)(half)
+        if ((n & 1) == 1) productR(both)(fvoid)
+        else both
+      }
+    loop(n)
+  }
+
   /**
    * Compose an `Applicative[F]` and an `Applicative[G]` into an
    * `Applicative[λ[α => F[G[α]]]]`.
diff --git a/core/src/main/scala/cats/Parallel.scala b/core/src/main/scala/cats/Parallel.scala
index a8f618f4d..ac47c5bd2 100644
--- a/core/src/main/scala/cats/Parallel.scala
+++ b/core/src/main/scala/cats/Parallel.scala
@@ -466,6 +466,13 @@ object Parallel extends ParallelArityFunctions2 {
   def parReplicateA[M[_], A](n: Int, ma: M[A])(implicit P: Parallel[M]): M[List[A]] =
     P.sequential(P.applicative.replicateA(n, P.parallel(ma)))
 
+  /**
+   * Like `Applicative[F].replicateA_`, but uses the apply instance
+   * corresponding to the Parallel instance instead.
+   */
+  def parReplicateA_[M[_], A](n: Int, ma: M[A])(implicit P: Parallel[M]): M[Unit] =
+    P.sequential(P.applicative.replicateA_(n, P.parallel(ma)))
+
   /**
    * Provides an `ApplicativeError[F, E]` instance for any F, that has a `Parallel.Aux[M, F]`
    * and a `MonadError[M, E]` instance.
diff --git a/core/src/main/scala/cats/syntax/applicative.scala b/core/src/main/scala/cats/syntax/applicative.scala
index e3b917b6a..9954f1792 100644
--- a/core/src/main/scala/cats/syntax/applicative.scala
+++ b/core/src/main/scala/cats/syntax/applicative.scala
@@ -47,6 +47,7 @@ final class ApplicativeOps[F[_], A](private val fa: F[A]) extends AnyVal {
 
 final class ApplicativeByValueOps[F[_], A](private val fa: F[A]) extends AnyVal {
   def replicateA(n: Int)(implicit F: Applicative[F]): F[List[A]] = F.replicateA(n, fa)
+  def replicateA_(n: Int)(implicit F: Applicative[F]): F[Unit] = F.replicateA_(n, fa)
 }
 
 final class ApplicativeByNameOps[F[_], A](private val fa: () => F[A]) extends AnyVal {
diff --git a/core/src/main/scala/cats/syntax/parallel.scala b/core/src/main/scala/cats/syntax/parallel.scala
index 4fd585cb1..3624946c1 100644
--- a/core/src/main/scala/cats/syntax/parallel.scala
+++ b/core/src/main/scala/cats/syntax/parallel.scala
@@ -288,11 +288,16 @@ final class ParallelApOps[M[_], A](private val ma: M[A]) extends AnyVal {
 
   def parReplicateA(n: Int)(implicit P: Parallel[M]): M[List[A]] =
     Parallel.parReplicateA(n, ma)
+
+  def parReplicateA_(n: Int)(implicit P: Parallel[M]): M[Unit] =
+    Parallel.parReplicateA_(n, ma)
 }
 
 final class ParallelApOps1[M[_], A](private val ma: M[A]) extends AnyVal {
   def parReplicateA(n: Int)(implicit P: Parallel[M]): M[List[A]] =
     Parallel.parReplicateA(n, ma)
+  def parReplicateA_(n: Int)(implicit P: Parallel[M]): M[Unit] =
+    Parallel.parReplicateA_(n, ma)
 }
 
 final class NonEmptyParallelApOps[M[_], A](private val ma: M[A]) extends AnyVal {
diff --git a/laws/src/main/scala/cats/laws/ApplicativeLaws.scala b/laws/src/main/scala/cats/laws/ApplicativeLaws.scala
index 646727ccd..d2538fcc9 100644
--- a/laws/src/main/scala/cats/laws/ApplicativeLaws.scala
+++ b/laws/src/main/scala/cats/laws/ApplicativeLaws.scala
@@ -59,6 +59,9 @@ trait ApplicativeLaws[F[_]] extends ApplyLaws[F] {
   def applicativeUnit[A](a: A): IsEq[F[A]] =
     F.unit.map(_ => a) <-> F.pure(a)
 
+  def replicateAVoidReplicateA_Consistent[A](n: Int, fa: F[A]): IsEq[F[Unit]] =
+    F.replicateA_(n, fa) <-> F.replicateA(n, fa).void
+
   // The following are the lax monoidal functor identity laws - the associativity law is covered by
   // Semigroupal's associativity law.
 
diff --git a/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala b/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala
index 08bc6db9a..fc6ebbbe7 100644
--- a/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala
@@ -24,12 +24,15 @@ package laws
 package discipline
 
 import cats.laws.discipline.SemigroupalTests.Isomorphisms
-import org.scalacheck.{Arbitrary, Cogen, Prop}
-import Prop._
+import org.scalacheck.Prop._
+import org.scalacheck.{Arbitrary, Cogen, Gen}
 
 trait ApplicativeTests[F[_]] extends ApplyTests[F] {
   def laws: ApplicativeLaws[F]
 
+  private def makeEqFUnit[A](a: A)(implicit EqFA: Eq[F[A]]): Eq[F[Unit]] =
+    Eq.by(fa => laws.F.as(fa, a))
+
   def applicative[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
     ArbFA: Arbitrary[F[A]],
     ArbFB: Arbitrary[F[B]],
@@ -44,7 +47,7 @@ trait ApplicativeTests[F[_]] extends ApplyTests[F] {
     EqFC: Eq[F[C]],
     EqFABC: Eq[F[(A, B, C)]],
     iso: Isomorphisms[F]
-  ): RuleSet =
+  ): RuleSet = {
     new DefaultRuleSet(
       name = "applicative",
       parent = Some(apply[A, B, C]),
@@ -54,9 +57,15 @@ trait ApplicativeTests[F[_]] extends ApplyTests[F] {
       "applicative map" -> forAll(laws.applicativeMap[A, B] _),
       "applicative unit" -> forAll(laws.applicativeUnit[A] _),
       "ap consistent with product + map" -> forAll(laws.apProductConsistent[A, B] _),
+      "replicateA_ consistent with replicateA.void" -> forAll { (a: A) =>
+        // Should be an implicit parameter but that is not a binary-compatible change
+        implicit val eqFUnit: Eq[F[Unit]] = makeEqFUnit[A](a)
+        forAll(Gen.resize(4, ArbFA.arbitrary))(laws.replicateAVoidReplicateA_Consistent[A](4, _))
+      },
       "monoidal left identity" -> forAll((fa: F[A]) => iso.leftIdentity(laws.monoidalLeftIdentity(fa))),
       "monoidal right identity" -> forAll((fa: F[A]) => iso.rightIdentity(laws.monoidalRightIdentity(fa)))
     )
+  }
 }
 
 object ApplicativeTests {
