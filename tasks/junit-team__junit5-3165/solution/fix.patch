diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
index 534522496..859021071 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
@@ -54,6 +54,8 @@ repository on GitHub.
   actionable.
 * Extracted `NamespacedHierarchicalStore` from JUnit Jupiter engine for reuse by other
   test engines and their extensions.
+* New dry-run mode to simulate test execution without actually running tests. Please refer
+  to the <<../user-guide/index.adoc#launcher-api-dry-run-mode, User Guide>> for details.
 
 
 [[release-notes-5.10.0-M1-junit-jupiter]]
diff --git a/documentation/src/docs/asciidoc/user-guide/advanced-topics/launcher-api.adoc b/documentation/src/docs/asciidoc/user-guide/advanced-topics/launcher-api.adoc
index 8f98a7e82..6257d266c 100644
--- a/documentation/src/docs/asciidoc/user-guide/advanced-topics/launcher-api.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/advanced-topics/launcher-api.adoc
@@ -264,3 +264,14 @@ built-in fluent _builder_ API, as demonstrated in the following example.
 ----
 include::{testDir}/example/UsingTheLauncherDemo.java[tags=launcherConfig]
 ----
+
+[[launcher-api-dry-run-mode]]
+==== Dry-Run Mode
+
+When running tests via the `{Launcher}` API, you can enable _dry-run mode_ by setting the
+`junit.platform.execution.dryRun.enabled` <<running-tests-config-params,
+configuration parameter>> to `true`. In this mode, the `{Launcher}` will not actually
+execute any tests but will notify registered `{TestExecutionListener}` instances as if all
+tests had been executed successfully. This can be useful to test changes in the
+configuration of a build or to verify a listener is called as expected without having to
+wait for all tests to be executed.
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherConstants.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherConstants.java
index 8862cb28e..595c7698e 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherConstants.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/LauncherConstants.java
@@ -148,6 +148,22 @@ public class LauncherConstants {
 	@API(status = EXPERIMENTAL, since = "1.10")
 	public static final String ENABLE_LAUNCHER_INTERCEPTORS = "junit.platform.launcher.interceptors.enabled";
 
+	/**
+	 * Property name used to enable dry-run mode for test execution.
+	 *
+	 * <p>When dry-run mode is enabled, no tests will be executed. Instead, all
+	 * registered {@link TestExecutionListener TestExecutionListeners} will
+	 * receive started/finished events for all test descriptors that are part
+	 * of the discovered {@link TestPlan}. All tests will be reported as
+	 * successful. This can be useful to test changes in the configuration of a
+	 * build or to verify a listener is called as expected without having to
+	 * wait for all tests to be executed.
+	 *
+	 * <p>Value must either {@code true} or {@code false}; defaults to {@code false}.
+	 */
+	@API(status = EXPERIMENTAL, since = "1.10")
+	public static final String DRY_RUN_PROPERTY_NAME = "junit.platform.execution.dryRun.enabled";
+
 	private LauncherConstants() {
 		/* no-op */
 	}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java
index 35e174e46..8ec4a133c 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java
@@ -11,6 +11,7 @@
 package org.junit.platform.launcher.core;
 
 import static org.apiguardian.api.API.Status.INTERNAL;
+import static org.junit.platform.launcher.LauncherConstants.DRY_RUN_PROPERTY_NAME;
 import static org.junit.platform.launcher.core.ListenerRegistry.forEngineExecutionListeners;
 
 import java.util.Optional;
@@ -27,6 +28,7 @@ import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestEngine;
 import org.junit.platform.engine.TestExecutionResult;
 import org.junit.platform.launcher.TestExecutionListener;
+import org.junit.platform.launcher.TestIdentifier;
 import org.junit.platform.launcher.TestPlan;
 
 /**
@@ -82,13 +84,50 @@ public class EngineExecutionOrchestrator {
 		TestPlan testPlan = internalTestPlan.getDelegate();
 		LauncherDiscoveryResult discoveryResult = internalTestPlan.getDiscoveryResult();
 
+		testExecutionListener.testPlanExecutionStarted(testPlan);
+		if (isDryRun(internalTestPlan)) {
+			dryRun(testPlan, testExecutionListener);
+		}
+		else {
+			execute(discoveryResult,
+				buildEngineExecutionListener(parentEngineExecutionListener, testExecutionListener, testPlan));
+		}
+		testExecutionListener.testPlanExecutionFinished(testPlan);
+	}
+
+	private Boolean isDryRun(InternalTestPlan internalTestPlan) {
+		return internalTestPlan.getConfigurationParameters().getBoolean(DRY_RUN_PROPERTY_NAME).orElse(false);
+	}
+
+	private void dryRun(TestPlan testPlan, TestExecutionListener listener) {
+		testPlan.accept(new TestPlan.Visitor() {
+			@Override
+			public void preVisitContainer(TestIdentifier testIdentifier) {
+				listener.executionStarted(testIdentifier);
+			}
+
+			@Override
+			public void visit(TestIdentifier testIdentifier) {
+				if (!testIdentifier.isContainer()) {
+					listener.executionStarted(testIdentifier);
+					listener.executionFinished(testIdentifier, TestExecutionResult.successful());
+				}
+			}
+
+			@Override
+			public void postVisitContainer(TestIdentifier testIdentifier) {
+				listener.executionFinished(testIdentifier, TestExecutionResult.successful());
+			}
+		});
+	}
+
+	private static EngineExecutionListener buildEngineExecutionListener(
+			EngineExecutionListener parentEngineExecutionListener, TestExecutionListener testExecutionListener,
+			TestPlan testPlan) {
 		ListenerRegistry<EngineExecutionListener> engineExecutionListenerRegistry = forEngineExecutionListeners();
 		engineExecutionListenerRegistry.add(new ExecutionListenerAdapter(testPlan, testExecutionListener));
 		engineExecutionListenerRegistry.add(parentEngineExecutionListener);
-
-		testExecutionListener.testPlanExecutionStarted(testPlan);
-		execute(discoveryResult, engineExecutionListenerRegistry.getCompositeListener());
-		testExecutionListener.testPlanExecutionFinished(testPlan);
+		return engineExecutionListenerRegistry.getCompositeListener();
 	}
 
 	private void withInterceptedStreams(ConfigurationParameters configurationParameters,
