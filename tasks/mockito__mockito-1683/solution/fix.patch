diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index e0b3fb8d7..ea13fdfd1 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-4.10.2-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.3.1-bin.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/settings.gradle b/settings.gradle
index 37f0a5d79..25026f78a 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -7,6 +7,7 @@ include 'android'
 include 'junit-jupiter'
 include 'junitJupiterExtensionTest'
 include 'module-test'
+include 'memory-test'
 include 'errorprone'
 
 rootProject.name = 'mockito'
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
index 828b84899..88ec9d7cc 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
@@ -4,6 +4,16 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.Serializable;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.ref.SoftReference;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.concurrent.Callable;
 import net.bytebuddy.asm.Advice;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.type.TypeDescription;
@@ -21,19 +31,6 @@ import org.mockito.internal.invocation.mockref.MockReference;
 import org.mockito.internal.invocation.mockref.MockWeakReference;
 import org.mockito.internal.util.concurrent.WeakConcurrentMap;
 
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.Serializable;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.ref.SoftReference;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.Callable;
-
 public class MockMethodAdvice extends MockMethodDispatcher {
 
     private final WeakConcurrentMap<Object, MockMethodInterceptor> interceptors;
@@ -105,13 +102,11 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         } else {
             realMethod = new RealMethodCall(selfCallInfo, origin, instance, arguments);
         }
-        Throwable t = new Throwable();
-        t.setStackTrace(skipInlineMethodElement(t.getStackTrace()));
         return new ReturnValueWrapper(interceptor.doIntercept(instance,
                 origin,
                 arguments,
                 realMethod,
-                new LocationImpl(t)));
+                new LocationImpl(new Throwable(), true)));
     }
 
     @Override
@@ -222,21 +217,6 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         }
     }
 
-    // With inline mocking, mocks for concrete classes are not subclassed, so elements of the stubbing methods are not filtered out.
-    // Therefore, if the method is inlined, skip the element.
-    private static StackTraceElement[] skipInlineMethodElement(StackTraceElement[] elements) {
-        List<StackTraceElement> list = new ArrayList<StackTraceElement>(elements.length);
-        for (int i = 0; i < elements.length; i++) {
-            StackTraceElement element = elements[i];
-            list.add(element);
-            if (element.getClassName().equals(MockMethodAdvice.class.getName()) && element.getMethodName().equals("handle")) {
-                // If the current element is MockMethodAdvice#handle(), the next is assumed to be an inlined method.
-                i++;
-            }
-        }
-        return list.toArray(new StackTraceElement[list.size()]);
-    }
-
     private static class ReturnValueWrapper implements Callable<Object> {
 
         private final Object returned;
diff --git a/src/main/java/org/mockito/internal/debugging/LocationImpl.java b/src/main/java/org/mockito/internal/debugging/LocationImpl.java
index f1d14a69f..0a9ebde6a 100644
--- a/src/main/java/org/mockito/internal/debugging/LocationImpl.java
+++ b/src/main/java/org/mockito/internal/debugging/LocationImpl.java
@@ -11,45 +11,51 @@ import org.mockito.invocation.Location;
 public class LocationImpl implements Location, Serializable {
 
     private static final long serialVersionUID = -9054861157390980624L;
-    //Limit the amount of objects being created, as this class is heavily instantiated:
-    private static final StackTraceFilter defaultStackTraceFilter = new StackTraceFilter();
+    // Limit the amount of objects being created, as this class is heavily instantiated:
+    private static final StackTraceFilter stackTraceFilter = new StackTraceFilter();
 
-    private final Throwable stackTraceHolder;
-    private final StackTraceFilter stackTraceFilter;
-    private final String sourceFile;
+    private String stackTraceLine;
+    private String sourceFile;
 
     public LocationImpl() {
-        this(defaultStackTraceFilter);
+        this(new Throwable(), false);
     }
 
-    public LocationImpl(StackTraceFilter stackTraceFilter) {
-        this(stackTraceFilter, new Throwable());
+    public LocationImpl(Throwable stackTraceHolder, boolean isInline) {
+        this(stackTraceFilter, stackTraceHolder, isInline);
     }
 
-    public LocationImpl(Throwable stackTraceHolder) {
-        this(defaultStackTraceFilter, stackTraceHolder);
+    public LocationImpl(StackTraceFilter stackTraceFilter) {
+        this(stackTraceFilter, new Throwable(), false);
     }
 
-    private LocationImpl(StackTraceFilter stackTraceFilter, Throwable stackTraceHolder) {
-        this.stackTraceFilter = stackTraceFilter;
-        this.stackTraceHolder = stackTraceHolder;
-        if (stackTraceHolder.getStackTrace() == null || stackTraceHolder.getStackTrace().length == 0) {
-            //there are corner cases where exception can have a null or empty stack trace
-            //for example, a custom exception can override getStackTrace() method
-            this.sourceFile = "<unknown source file>";
-        } else {
-            this.sourceFile = stackTraceFilter.findSourceFile(stackTraceHolder.getStackTrace(), "<unknown source file>");
-        }
+    private LocationImpl(StackTraceFilter stackTraceFilter, Throwable stackTraceHolder, boolean isInline) {
+        computeStackTraceInformation(stackTraceFilter, stackTraceHolder, isInline);
     }
 
     @Override
     public String toString() {
-        //TODO SF perhaps store the results after invocation?
-        StackTraceElement[] filtered = stackTraceFilter.filter(stackTraceHolder.getStackTrace(), false);
-        if (filtered.length == 0) {
-            return "-> at <<unknown line>>";
+        return stackTraceLine;
+    }
+
+    /**
+     * Eagerly compute the stacktrace line from the stackTraceHolder. Storing the Throwable is
+     * memory-intensive for tests that have large stacktraces and have a lot of invocations on
+     * mocks.
+     */
+    private void computeStackTraceInformation(
+        StackTraceFilter stackTraceFilter, Throwable stackTraceHolder, boolean isInline) {
+        StackTraceElement filtered = stackTraceFilter.filterFirst(stackTraceHolder, isInline);
+
+        // there are corner cases where exception can have a null or empty stack trace
+        // for example, a custom exception can override getStackTrace() method
+        if (filtered == null) {
+            this.stackTraceLine = "-> at <<unknown line>>";
+            this.sourceFile = "<unknown source file>";
+        } else {
+            this.stackTraceLine = "-> at " + filtered.toString();
+            this.sourceFile = filtered.getFileName();
         }
-        return "-> at " + filtered[0].toString();
     }
 
     @Override
diff --git a/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java b/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java
index bf11d4c83..1691ddc10 100644
--- a/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java
+++ b/src/main/java/org/mockito/internal/exceptions/stacktrace/StackTraceFilter.java
@@ -5,6 +5,7 @@
 
 package org.mockito.internal.exceptions.stacktrace;
 
+import java.lang.reflect.Method;
 import org.mockito.exceptions.stacktrace.StackTraceCleaner;
 import org.mockito.internal.configuration.plugins.Plugins;
 
@@ -19,6 +20,24 @@ public class StackTraceFilter implements Serializable {
     private static final StackTraceCleaner CLEANER =
             Plugins.getStackTraceCleanerProvider().getStackTraceCleaner(new DefaultStackTraceCleaner());
 
+    private static Object JAVA_LANG_ACCESS;
+    private static Method GET_STACK_TRACE_ELEMENT;
+
+    static {
+        try {
+            JAVA_LANG_ACCESS =
+                Class.forName("sun.misc.SharedSecrets")
+                    .getMethod("getJavaLangAccess")
+                    .invoke(null);
+            GET_STACK_TRACE_ELEMENT =
+                Class.forName("sun.misc.JavaLangAccess")
+                    .getMethod("getStackTraceElement", Throwable.class, int.class);
+        } catch (Exception ignored) {
+            // Use the slow computational path for filtering stacktraces if fast path does not exist
+            // in JVM
+        }
+    }
+
     /**
      * Example how the filter works (+/- means good/bad):
      * [a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, d+, e+, g+]
@@ -38,6 +57,67 @@ public class StackTraceFilter implements Serializable {
         return filtered.toArray(result);
     }
 
+    /**
+     * This filtering strategy makes use of a fast-path computation to retrieve stackTraceElements
+     * from a Stacktrace of a Throwable. It does so, by taking advantage of {@link
+     * sun.misc.SharedSecrets} and {@link sun.misc.JavaLangAccess}.
+     *
+     * <p>The {@link sun.misc.SharedSecrets} provides a method to obtain an instance of an {@link
+     * sun.misc.JavaLangAccess}. The latter class has a method to fast-path into {@link
+     * Throwable#getStackTrace()} and retrieve a single {@link StackTraceElement}. This prevents the
+     * JVM from having to generate a full stacktrace, which could potentially be expensive if
+     * stacktraces become very large.
+     *
+     * @param target The throwable target to find the first {@link StackTraceElement} that should
+     *     not be filtered out per {@link StackTraceFilter#CLEANER}.
+     * @return The first {@link StackTraceElement} outside of the {@link StackTraceFilter#CLEANER}
+     */
+    public StackTraceElement filterFirst(Throwable target, boolean isInline) {
+        boolean shouldSkip = isInline;
+
+        if (GET_STACK_TRACE_ELEMENT != null) {
+            int i = 0;
+
+            // The assumption here is that the CLEANER filter will not filter out every single
+            // element. However, since we don't want to compute the full length of the stacktrace,
+            // we don't know the upper boundary. Therefore, simply increment the counter and go as
+            // far as we have to go, assuming that we get there. If, in the rare occassion, we
+            // don't, we fall back to the old slow path.
+            while (true) {
+                try {
+                    StackTraceElement stackTraceElement =
+                        (StackTraceElement)
+                            GET_STACK_TRACE_ELEMENT.invoke(JAVA_LANG_ACCESS, target, i);
+
+                    if (CLEANER.isIn(stackTraceElement)) {
+                        if (shouldSkip) {
+                            shouldSkip = false;
+                        } else {
+                            return stackTraceElement;
+                        }
+                    }
+                } catch (Exception e) {
+                    // Fall back to slow path
+                    break;
+                }
+                i++;
+            }
+        }
+
+        // If we can't use the fast path of retrieving stackTraceElements, use the slow path by
+        // iterating over the actual stacktrace
+        for (StackTraceElement stackTraceElement : target.getStackTrace()) {
+            if (CLEANER.isIn(stackTraceElement)) {
+                if (shouldSkip) {
+                    shouldSkip = false;
+                } else {
+                    return stackTraceElement;
+                }
+            }
+        }
+        return null;
+    }
+
     /**
      * Finds the source file of the target stack trace.
      * Returns the default value if source file cannot be found.
diff --git a/subprojects/memory-test/memory-test.gradle b/subprojects/memory-test/memory-test.gradle
new file mode 100644
index 000000000..a53d479a0
--- /dev/null
+++ b/subprojects/memory-test/memory-test.gradle
@@ -0,0 +1,19 @@
+plugins {
+    id 'java'
+}
+description = "Test suite memory usage of Mockito"
+
+apply from: "$rootDir/gradle/dependencies.gradle"
+
+dependencies {
+    compile project.rootProject
+    testCompile libraries.junit4
+    testCompile libraries.assertj
+}
+
+tasks.javadoc.enabled = false
+
+test {
+    maxHeapSize = "128m"
+    jvmArgs = ["-XX:MaxPermSize=128m"]
+}
