diff --git a/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java b/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java
index cd5a8345..9464dc56 100644
--- a/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java
@@ -62,8 +62,6 @@ final class BufferedSinkJsonWriter extends JsonWriter {
 
   private String deferredName;
 
-  private boolean promoteNameToValue;
-
   BufferedSinkJsonWriter(BufferedSink sink) {
     if (sink == null) {
       throw new NullPointerException("sink == null");
@@ -92,7 +90,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
   }
 
   @Override public JsonWriter endObject() throws IOException {
-    promoteNameToValue = false;
+    promoteValueToName = false;
     return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
   }
 
@@ -143,7 +141,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
     }
     deferredName = name;
     pathNames[stackSize - 1] = name;
-    promoteNameToValue = false;
+    promoteValueToName = false;
     return this;
   }
 
@@ -159,7 +157,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
     if (value == null) {
       return nullValue();
     }
-    if (promoteNameToValue) {
+    if (promoteValueToName) {
       return name(value);
     }
     writeDeferredName();
@@ -203,7 +201,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
     if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
-    if (promoteNameToValue) {
+    if (promoteValueToName) {
       return name(Double.toString(value));
     }
     writeDeferredName();
@@ -214,7 +212,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
   }
 
   @Override public JsonWriter value(long value) throws IOException {
-    if (promoteNameToValue) {
+    if (promoteValueToName) {
       return name(Long.toString(value));
     }
     writeDeferredName();
@@ -234,7 +232,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
         && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
-    if (promoteNameToValue) {
+    if (promoteValueToName) {
       return name(string);
     }
     writeDeferredName();
@@ -369,12 +367,4 @@ final class BufferedSinkJsonWriter extends JsonWriter {
         throw new IllegalStateException("Nesting problem.");
     }
   }
-
-  @Override void promoteNameToValue() throws IOException {
-    int context = peekScope();
-    if (context != NONEMPTY_OBJECT && context != EMPTY_OBJECT) {
-      throw new IllegalStateException("Nesting problem.");
-    }
-    promoteNameToValue = true;
-  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index e1787607..c0179951 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -20,6 +20,9 @@ import java.io.Flushable;
 import java.io.IOException;
 import okio.BufferedSink;
 
+import static com.squareup.moshi.JsonScope.EMPTY_OBJECT;
+import static com.squareup.moshi.JsonScope.NONEMPTY_OBJECT;
+
 /**
  * Writes a JSON (<a href="http://www.ietf.org/rfc/rfc7159.txt">RFC 7159</a>)
  * encoded value to a stream, one token at a time. The stream includes both
@@ -131,6 +134,7 @@ public abstract class JsonWriter implements Closeable, Flushable {
   String indent;
   boolean lenient;
   boolean serializeNulls;
+  boolean promoteValueToName;
 
   /** Returns a new instance that writes a JSON-encoded stream to {@code sink}. */
   public static JsonWriter of(BufferedSink sink) {
@@ -313,10 +317,16 @@ public abstract class JsonWriter implements Closeable, Flushable {
   public abstract JsonWriter value(Number value) throws IOException;
 
   /**
-   * Changes the reader to treat the next string value as a name. This is useful for map adapters so
-   * that arbitrary type adapters can use {@link #value(String)} to write a name value.
+   * Changes the writer to treat the next value as a string name. This is useful for map adapters so
+   * that arbitrary type adapters can use {@link #value} to write a name value.
    */
-  abstract void promoteNameToValue() throws IOException;
+  final void promoteValueToName() throws IOException {
+    int context = peekScope();
+    if (context != NONEMPTY_OBJECT && context != EMPTY_OBJECT) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    promoteValueToName = true;
+  }
 
   /**
    * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
diff --git a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
index 3158108b..8cf784d9 100644
--- a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
@@ -52,7 +52,7 @@ final class MapJsonAdapter<K, V> extends JsonAdapter<Map<K, V>> {
       if (entry.getKey() == null) {
         throw new JsonDataException("Map key is null at " + writer.getPath());
       }
-      writer.promoteNameToValue();
+      writer.promoteValueToName();
       keyAdapter.toJson(writer, entry.getKey());
       valueAdapter.toJson(writer, entry.getValue());
     }
diff --git a/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java b/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java
index 8f16fec4..0f30d888 100644
--- a/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java
@@ -273,10 +273,10 @@ final class ObjectJsonReader extends JsonReader {
   }
 
   @Override void promoteNameToValue() throws IOException {
-    Map.Entry<?, ?> peeked = require(Map.Entry.class, Token.NAME);
-
-    push(peeked.getKey());
-    stack[stackSize - 2] = peeked.getValue();
+    if (hasNext()) {
+      String name = nextName();
+      push(name);
+    }
   }
 
   @Override public void close() throws IOException {
diff --git a/moshi/src/main/java/com/squareup/moshi/ObjectJsonWriter.java b/moshi/src/main/java/com/squareup/moshi/ObjectJsonWriter.java
index a4b7c533..237d4624 100644
--- a/moshi/src/main/java/com/squareup/moshi/ObjectJsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ObjectJsonWriter.java
@@ -79,6 +79,7 @@ final class ObjectJsonWriter extends JsonWriter {
     if (peekScope() != EMPTY_OBJECT || deferredName != null) {
       throw new IllegalStateException("Nesting problem.");
     }
+    promoteValueToName = false;
     stackSize--;
     stack[stackSize] = null;
     pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
@@ -96,12 +97,16 @@ final class ObjectJsonWriter extends JsonWriter {
     if (peekScope() != EMPTY_OBJECT || deferredName != null) {
       throw new IllegalStateException("Nesting problem.");
     }
-    pathNames[stackSize - 1] = name;
     deferredName = name;
+    pathNames[stackSize - 1] = name;
+    promoteValueToName = false;
     return this;
   }
 
   @Override public JsonWriter value(String value) throws IOException {
+    if (promoteValueToName) {
+      return name(value);
+    }
     add(value);
     pathIndices[stackSize - 1]++;
     return this;
@@ -130,6 +135,9 @@ final class ObjectJsonWriter extends JsonWriter {
   }
 
   @Override public JsonWriter value(long value) throws IOException {
+    if (promoteValueToName) {
+      return name(Long.toString(value));
+    }
     add(value);
     pathIndices[stackSize - 1]++;
     return this;
@@ -142,15 +150,14 @@ final class ObjectJsonWriter extends JsonWriter {
         throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
       }
     }
+    if (promoteValueToName) {
+      return name(value.toString());
+    }
     add(value);
     pathIndices[stackSize - 1]++;
     return this;
   }
 
-  @Override void promoteNameToValue() throws IOException {
-    throw new UnsupportedOperationException();
-  }
-
   @Override public void close() throws IOException {
     int size = stackSize;
     if (size > 1 || size == 1 && scopes[size - 1] != NONEMPTY_DOCUMENT) {
