diff --git a/release-notes/VERSION b/release-notes/VERSION
index 6a99d3d7b..e038c5e98 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -34,8 +34,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
   with Jackson 3
  (reported by Andy W)
  (fix contributed by Fouad A)
-#5432: Jackson 3 ignores `@JsonProperty` when Enum value is used as Map key
- (reported by @jochenberger)
 
 3.0.2 (07-Nov-2025)
 
diff --git a/src/main/java/tools/jackson/databind/AnnotationIntrospector.java b/src/main/java/tools/jackson/databind/AnnotationIntrospector.java
index 5ddeb565d..4123839ae 100644
--- a/src/main/java/tools/jackson/databind/AnnotationIntrospector.java
+++ b/src/main/java/tools/jackson/databind/AnnotationIntrospector.java
@@ -939,7 +939,7 @@ public abstract class AnnotationIntrospector
     }
 
     /**
-     * Finds the explicitly defined names, if any, of the given set of {@code Enum} values.
+     * Finds the explicitly defined name of the given set of {@code Enum} values, if any.
      * The method overwrites entries in the incoming {@code names} array with the explicit
      * names found, if any, leaving other entries unmodified.
      *
@@ -947,9 +947,9 @@ public abstract class AnnotationIntrospector
      * @param annotatedClass the annotated class for which to find the explicit names
      * @param enumValues the set of {@code Enum} values to find the explicit names for
      * @param names the matching declared names of enumeration values (with indexes matching
-     *              {@code enumValues} entries); modified as necessary
+     *              {@code enumValues} entries)
      *
-     * @return an array of names to use (usually {@code names} passed as argument)
+     * @return an array of names to use (possibly {@code names} passed as argument)
      *
      * @since 2.16
      */
diff --git a/src/main/java/tools/jackson/databind/EnumNamingStrategy.java b/src/main/java/tools/jackson/databind/EnumNamingStrategy.java
index b0497c9ba..0d2e45aea 100644
--- a/src/main/java/tools/jackson/databind/EnumNamingStrategy.java
+++ b/src/main/java/tools/jackson/databind/EnumNamingStrategy.java
@@ -13,9 +13,9 @@ public interface EnumNamingStrategy {
      * Translates the given <code>enumName</code> into an external property name according to
      * the implementation of this {@link EnumNamingStrategy}.
      *
+     * @param enumName the name of the enum value to translate
      * @param config the mapper configuration
      * @param cls the Enum class
-     * @param enumName the name of the enum value to translate
      *
      * @return the external property name that corresponds to the given <code>enumName</code>
      * according to the implementation of this {@link EnumNamingStrategy}.
diff --git a/src/main/java/tools/jackson/databind/cfg/EnumFeature.java b/src/main/java/tools/jackson/databind/cfg/EnumFeature.java
index c7b05f433..7ba781f46 100644
--- a/src/main/java/tools/jackson/databind/cfg/EnumFeature.java
+++ b/src/main/java/tools/jackson/databind/cfg/EnumFeature.java
@@ -117,6 +117,7 @@ public enum EnumFeature implements DatatypeFeature
      */
     WRITE_ENUMS_TO_LOWERCASE(false),
 
+
     /**
      * Feature that determines standard serialization mechanism used for
      * Enum values: if enabled, return value of <code>Enum.toString()</code>
diff --git a/src/main/java/tools/jackson/databind/cfg/MapperConfig.java b/src/main/java/tools/jackson/databind/cfg/MapperConfig.java
index 040227b2a..798c4b70b 100644
--- a/src/main/java/tools/jackson/databind/cfg/MapperConfig.java
+++ b/src/main/java/tools/jackson/databind/cfg/MapperConfig.java
@@ -156,15 +156,11 @@ public abstract class MapperConfig<T extends MapperConfig<T>>
      *
      * @param src Text to represent
      *
-     * @return Optimized text object constructed, if {@code src} not {@code null};
-     *    {@code null} otherwise
+     * @return Optimized text object constructed
      */
     public SerializableString compileString(String src) {
         // 20-Jan-2014, tatu: For now we will just construct it directly but in distant
         //   future might want to allow overriding somehow?
-        if (src == null) {
-            return null;
-        }
         return new SerializedString(src);
     }
 
diff --git a/src/main/java/tools/jackson/databind/ser/jdk/JDKKeySerializers.java b/src/main/java/tools/jackson/databind/ser/jdk/JDKKeySerializers.java
index c411d8fc1..06b3563d2 100644
--- a/src/main/java/tools/jackson/databind/ser/jdk/JDKKeySerializers.java
+++ b/src/main/java/tools/jackson/databind/ser/jdk/JDKKeySerializers.java
@@ -11,8 +11,7 @@ import tools.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
 import tools.jackson.databind.ser.impl.PropertySerializerMap;
 import tools.jackson.databind.ser.std.StdSerializer;
 import tools.jackson.databind.util.ClassUtil;
-import tools.jackson.databind.util.EnumDefinition;
-import tools.jackson.databind.util.EnumValuesToWrite;
+import tools.jackson.databind.util.EnumValues;
 
 public abstract class JDKKeySerializers
 {
@@ -79,8 +78,9 @@ public abstract class JDKKeySerializers
 
     /**
      * Method called if no specified key serializer was located; will return a
-     * "default" key serializer except with special handling for {@code Enum}s
+     * "default" key serializer initialized by {@link EnumKeySerializer#construct(Class, EnumValues, EnumValues)}
      */
+    @SuppressWarnings("unchecked")
     public static ValueSerializer<Object> getFallbackKeySerializer(SerializationConfig config,
             Class<?> rawKeyType, AnnotatedClass annotatedClass)
     {
@@ -98,7 +98,8 @@ public abstract class JDKKeySerializers
             //    for subtypes.
             if (ClassUtil.isEnumType(rawKeyType)) {
                 return EnumKeySerializer.construct(rawKeyType,
-                        EnumDefinition.construct(config, annotatedClass).valuesToWrite(config));
+                    EnumValues.constructFromName(config, annotatedClass),
+                    EnumSerializer.constructEnumNamingStrategyValues(config, (Class<Enum<?>>) rawKeyType, annotatedClass));
             }
         }
         // 19-Oct-2016, tatu: Used to just return DEFAULT_KEY_SERIALIZER but why not:
@@ -264,36 +265,56 @@ public abstract class JDKKeySerializers
      */
     public static class EnumKeySerializer extends StdSerializer<Object>
     {
-        protected final EnumValuesToWrite _valuesToWrite;
+        protected final EnumValues _values;
 
-        protected EnumKeySerializer(Class<?> enumType, EnumValuesToWrite valuesToWrite)
-        {
+        /**
+         * Map with key as converted property class defined implementation of {@link EnumNamingStrategy}
+         * and with value as Enum names collected using <code>Enum.name()</code>.
+         */
+        protected final EnumValues _valuesByEnumNaming;
+
+        @Deprecated
+        protected EnumKeySerializer(Class<?> enumType, EnumValues values) {
+            this(enumType, values, null);
+        }
+
+        protected EnumKeySerializer(Class<?> enumType, EnumValues values, EnumValues valuesByEnumNaming) {
             super(enumType);
-            _valuesToWrite = valuesToWrite;
+            _values = values;
+            _valuesByEnumNaming = valuesByEnumNaming;
+        }
+
+        public static EnumKeySerializer construct(Class<?> enumType,
+                EnumValues enumValues)
+        {
+            return new EnumKeySerializer(enumType, enumValues);
         }
 
         public static EnumKeySerializer construct(Class<?> enumType,
-                EnumValuesToWrite valuesToWrite)
+                EnumValues enumValues, EnumValues valuesByEnumNaming)
         {
-            return new EnumKeySerializer(enumType, valuesToWrite);
+            return new EnumKeySerializer(enumType, enumValues, valuesByEnumNaming);
         }
 
         @Override
-        public void serialize(Object value, JsonGenerator g, SerializationContext ctxt)
+        public void serialize(Object value, JsonGenerator g, SerializationContext serializers)
             throws JacksonException
         {
-            final Enum<?> en = (Enum<?>) value;
-
-            // 26-Nov-2025, tatu: Should probably start with "using index" setting
-            //    (may change in 3.1?)
-            if (ctxt.isEnabled(EnumFeature.WRITE_ENUMS_USING_TO_STRING)) {
-                g.writeName(_valuesToWrite.fromToString(ctxt.getConfig(), en)); 
-            } else if (ctxt.isEnabled(EnumFeature.WRITE_ENUM_KEYS_USING_INDEX)) {
-                // 14-Sep-2019, tatu: [databind#2129] Use this specific feature
+            if (serializers.isEnabled(EnumFeature.WRITE_ENUMS_USING_TO_STRING)) {
+                g.writeName(value.toString());
+                return;
+            }
+            Enum<?> en = (Enum<?>) value;
+            if (_valuesByEnumNaming != null) {
+                g.writeName(_valuesByEnumNaming.serializedValueFor(en));
+                return;
+            }
+            // 14-Sep-2019, tatu: [databind#2129] Use this specific feature
+            if (serializers.isEnabled(EnumFeature.WRITE_ENUM_KEYS_USING_INDEX)) {
                 g.writeName(String.valueOf(en.ordinal()));
-            } else {
-                g.writeName(_valuesToWrite.fromName(ctxt.getConfig(), en)); 
+                return;
             }
+            g.writeName(_values.serializedValueFor(en));
         }
     }
 }
diff --git a/src/main/java/tools/jackson/databind/util/EnumDefinition.java b/src/main/java/tools/jackson/databind/util/EnumDefinition.java
deleted file mode 100644
index beaaa9884..000000000
--- a/src/main/java/tools/jackson/databind/util/EnumDefinition.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package tools.jackson.databind.util;
-
-import java.util.Arrays;
-import java.util.List;
-
-import tools.jackson.databind.AnnotationIntrospector;
-import tools.jackson.databind.EnumNamingStrategy;
-import tools.jackson.databind.cfg.MapperConfig;
-import tools.jackson.databind.introspect.AnnotatedClass;
-import tools.jackson.databind.introspect.EnumNamingStrategyFactory;
-
-/**
- * Encapsulation of a {@link java.lang.Enum} type definition with its elements
- * and explicitly annotated names for elements.
- *
- * @since 3.0.3
- */
-public class EnumDefinition
-{
-    private final AnnotatedClass _annotatedClass;
-    private final EnumNamingStrategy _enumNamingStrategy;
-    private final Enum<?>[] _enumConstants;
-    private final String[] _explicitNames;
-
-    private EnumDefinition(AnnotatedClass annotatedClass,
-            EnumNamingStrategy enumNamingStrategy,
-            Enum<?>[] enumConstants,
-            String[] explicitNames)
-    {
-        _annotatedClass = annotatedClass;
-        _enumNamingStrategy = enumNamingStrategy;
-        _enumConstants = enumConstants;
-        _explicitNames = explicitNames;
-    }
-
-    public static EnumDefinition construct(MapperConfig<?> config,
-            AnnotatedClass annotatedClass)
-    {
-        final Class<?> enumCls0 = annotatedClass.getRawType();
-        final Enum<?>[] enumConstants = _enumConstants(enumCls0);
-        String[] explicitNames = new String[enumConstants.length];
-
-        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
-        if (ai != null) {
-            explicitNames = ai.findEnumValues(config, annotatedClass, 
-                    enumConstants, explicitNames);
-        }
-        Object namingDef = config.getAnnotationIntrospector().findEnumNamingStrategy(config, annotatedClass);
-        EnumNamingStrategy enumNamingStrategy = EnumNamingStrategyFactory.createEnumNamingStrategyInstance(
-            namingDef, config.canOverrideAccessModifiers(), config.getEnumNamingStrategy());
-        
-        return new EnumDefinition(annotatedClass, enumNamingStrategy,
-                enumConstants, explicitNames);
-    }
-
-    public EnumValuesToWrite valuesToWrite(MapperConfig<?> config) {
-        return EnumValuesToWrite.construct(config, _annotatedClass,
-                _enumNamingStrategy,
-                _enumConstants, _explicitNames);
-    }
-    
-    public int size() {
-        return _enumConstants.length;
-    }
-
-    @SuppressWarnings("unchecked")
-    public Class<Enum<?>> enumClass() {
-        Class<?> cls = _annotatedClass.getRawType();
-        return (Class<Enum<?>>) cls;
-    }
-
-    public Enum<?>[] enumConstants() {
-        return _enumConstants;
-    }
-
-    public List<String> explicitNames() {
-        return Arrays.asList(_explicitNames);
-    }
-
-    private static Enum<?>[] _enumConstants(Class<?> enumCls) {
-        final Enum<?>[] enumValues = ClassUtil.findEnumType(enumCls).getEnumConstants();
-        if (enumValues == null) {
-            throw new IllegalArgumentException("Internal error: no Enum constants for Class "+enumCls.getName());
-        }
-        return enumValues;
-    }
-}
diff --git a/src/main/java/tools/jackson/databind/util/EnumValues.java b/src/main/java/tools/jackson/databind/util/EnumValues.java
index 229e70cbf..e1b42762d 100644
--- a/src/main/java/tools/jackson/databind/util/EnumValues.java
+++ b/src/main/java/tools/jackson/databind/util/EnumValues.java
@@ -34,11 +34,7 @@ public final class EnumValues
     /**
      * NOTE: do NOT call this if configuration may change, and choice between toString()
      *   and name() might change dynamically.
-     *
-     * @deprecated Since 3.1 call {@link #constructFromName} or {@link #constructFromToString}
-     *   instead.
      */
-    @Deprecated // since 3.1
     public static EnumValues construct(SerializationConfig config, AnnotatedClass enumClass) {
         if (config.isEnabled(EnumFeature.WRITE_ENUMS_USING_TO_STRING)) {
             return constructFromToString(config, enumClass);
@@ -46,40 +42,58 @@ public final class EnumValues
         return constructFromName(config, enumClass);
     }
 
-    public static EnumValues constructFromName(MapperConfig<?> config,
-            AnnotatedClass annotatedClass) 
+    /**
+     * @since 2.16
+     */
+    public static EnumValues constructFromName(MapperConfig<?> config, AnnotatedClass annotatedClass) 
     {
-        final EnumDefinition def = EnumDefinition.construct(config, annotatedClass);
-        final Class<Enum<?>> enumCls = def.enumClass();
-        final Enum<?>[] enumConstants = def.enumConstants();
+        // prepare data
+        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
+        final boolean useLowerCase = config.isEnabled(EnumFeature.WRITE_ENUMS_TO_LOWERCASE);
+        final Class<?> enumCls0 = annotatedClass.getRawType();
+        final Class<Enum<?>> enumCls = _enumClass(enumCls0);
+        final Enum<?>[] enumConstants = _enumConstants(enumCls0);
 
-        List<String> explicitNames = def.explicitNames();
+        // introspect
+        String[] names = ai.findEnumValues(config, annotatedClass, 
+                enumConstants, new String[enumConstants.length]);
+
+        // build
         SerializableString[] textual = new SerializableString[enumConstants.length];
-        final boolean useLowerCase = config.isEnabled(EnumFeature.WRITE_ENUMS_TO_LOWERCASE);
         for (int i = 0, len = enumConstants.length; i < len; ++i) {
             Enum<?> enumValue = enumConstants[i];
-            String name = _findNameToUse(explicitNames.get(i), enumValue.name(), useLowerCase);
+            String name = _findNameToUse(names[i], enumValue.name(), useLowerCase);
             textual[enumValue.ordinal()] = config.compileString(name);
         }
         return construct(enumCls, textual);
     }
 
-    public static EnumValues constructFromToString(MapperConfig<?> config,
-            AnnotatedClass annotatedClass)
+    /**
+     * @since 2.16
+     */
+    public static EnumValues constructFromToString(MapperConfig<?> config, AnnotatedClass annotatedClass)
     {
-        final EnumDefinition def = EnumDefinition.construct(config, annotatedClass);
-        final Class<Enum<?>> enumCls = def.enumClass();
-        final Enum<?>[] enumConstants = def.enumConstants();
+        // prepare data
+        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
+        final boolean useLowerCase = config.isEnabled(EnumFeature.WRITE_ENUMS_TO_LOWERCASE);
+        final Class<?> enumCls0 = annotatedClass.getRawType();
+        final Class<Enum<?>> enumCls = _enumClass(enumCls0);
+        final Enum<?>[] enumConstants = _enumConstants(enumCls0);
+
+        // introspect
+        String[] names = new String[enumConstants.length];
+        if (ai != null) {
+            ai.findEnumValues(config, annotatedClass, enumConstants, names);
+        }
 
-        List<String> explicitNames = def.explicitNames();
+        // build
         SerializableString[] textual = new SerializableString[enumConstants.length];
-        final boolean useLowerCase = config.isEnabled(EnumFeature.WRITE_ENUMS_TO_LOWERCASE);
         for (int i = 0; i < enumConstants.length; i++) {
             String enumToString = enumConstants[i].toString();
             // 01-Feb-2024, tatu: [databind#4355] Nulls not great but... let's
             //   coerce into "" for backwards compatibility
             enumToString = (enumToString == null) ? "" : enumToString;
-            String name = _findNameToUse(explicitNames.get(i), enumToString, useLowerCase);
+            String name = _findNameToUse(names[i], enumToString, useLowerCase);
             textual[i] = config.compileString(name);
         }
         return construct(enumCls, textual);
@@ -90,21 +104,31 @@ public final class EnumValues
      * <p>
      * The output {@link EnumValues} should contain values that are symmetric to
      * {@link EnumResolver#constructUsingEnumNamingStrategy(DeserializationConfig, AnnotatedClass, EnumNamingStrategy)}.
+     *
+     * @since 2.16
      */
     public static EnumValues constructUsingEnumNamingStrategy(MapperConfig<?> config,
             AnnotatedClass annotatedClass,
             EnumNamingStrategy namingStrategy)
     {
-        final EnumDefinition def = EnumDefinition.construct(config, annotatedClass);
-        final Class<Enum<?>> enumCls = def.enumClass();
-        final Enum<?>[] enumConstants = def.enumConstants();
+        // prepare data
+        final AnnotationIntrospector ai = config.getAnnotationIntrospector();
+        final boolean useLowerCase = config.isEnabled(EnumFeature.WRITE_ENUMS_TO_LOWERCASE);
+        final Class<?> enumCls0 = annotatedClass.getRawType();
+        final Class<Enum<?>> enumCls = _enumClass(enumCls0);
+        final Enum<?>[] enumConstants = _enumConstants(enumCls0);
+
+        // introspect
+        String[] names = new String[enumConstants.length];
+        if (ai != null) {
+            ai.findEnumValues(config, annotatedClass, enumConstants, names);
+        }
 
-        List<String> explicitNames = def.explicitNames();
+        // build
         SerializableString[] textual = new SerializableString[enumConstants.length];
-        final boolean useLowerCase = config.isEnabled(EnumFeature.WRITE_ENUMS_TO_LOWERCASE);
         for (int i = 0, len = enumConstants.length; i < len; i++) {
             Enum<?> enumValue = enumConstants[i];
-            String name = _findNameToUse(explicitNames.get(i), namingStrategy.convertEnumToExternalName(config,
+            String name = _findNameToUse(names[i], namingStrategy.convertEnumToExternalName(config,
                     annotatedClass, enumValue.name()), useLowerCase);
             textual[i] = config.compileString(name);
         }
@@ -191,7 +215,7 @@ public final class EnumValues
         EnumMap<?,SerializableString> result = _asMap;
         if (result == null) {
             // Alas, need to create it in a round-about way, due to typing constraints...
-            Map<Enum<?>,SerializableString> map = new LinkedHashMap<>();
+            Map<Enum<?>,SerializableString> map = new LinkedHashMap<Enum<?>,SerializableString>();
             for (Enum<?> en : _values) {
                 map.put(en, _textual[en.ordinal()]);
             }
diff --git a/src/main/java/tools/jackson/databind/util/EnumValuesToWrite.java b/src/main/java/tools/jackson/databind/util/EnumValuesToWrite.java
deleted file mode 100644
index d6e2aafdd..000000000
--- a/src/main/java/tools/jackson/databind/util/EnumValuesToWrite.java
+++ /dev/null
@@ -1,107 +0,0 @@
-package tools.jackson.databind.util;
-
-import java.util.function.Function;
-
-import tools.jackson.core.SerializableString;
-import tools.jackson.databind.EnumNamingStrategy;
-import tools.jackson.databind.cfg.EnumFeature;
-import tools.jackson.databind.cfg.MapperConfig;
-import tools.jackson.databind.introspect.AnnotatedClass;
-
-/**
- * @since 3.0.3
- */
-public class EnumValuesToWrite
-{
-    private final AnnotatedClass _annotatedClass;
-    private final EnumNamingStrategy _enumNamingStrategy;
-    private final Enum<?>[] _enumConstants;
-    private final SerializableString[] _explicitNames;
-
-    private volatile SerializableString[] _enumNames;
-    private volatile SerializableString[] _enumNamesLC;
-    private volatile SerializableString[] _enumToStrings;
-    private volatile SerializableString[] _enumToStringsLC;
-
-    private EnumValuesToWrite(AnnotatedClass annotatedClass,
-            EnumNamingStrategy enumNamingStrategy,
-            Enum<?>[] enumConstants, SerializableString[] explicitNames)
-    {
-        _annotatedClass = annotatedClass;
-        _enumNamingStrategy = enumNamingStrategy;
-        _enumConstants = enumConstants;
-        _explicitNames = explicitNames;
-    }
-
-    public static EnumValuesToWrite construct(MapperConfig<?> config,
-            AnnotatedClass annotatedClass,
-            EnumNamingStrategy enumNamingStrategy,
-            Enum<?>[] enumConstants, String[] explicitNames0)
-    {
-        final int len = explicitNames0.length;
-        SerializableString[] explicitNames = new SerializableString[len];
-        for (int i = 0; i < len; ++i) {
-            explicitNames[i] = config.compileString(explicitNames0[i]);
-        }
-        return new EnumValuesToWrite(annotatedClass,
-                enumNamingStrategy, enumConstants, explicitNames);
-    }
-
-    public SerializableString fromName(MapperConfig<?> config, Enum<?> en) {
-        SerializableString[] strs;
-        if (config.isEnabled(EnumFeature.WRITE_ENUMS_TO_LOWERCASE)) {
-            if ((strs = _enumNamesLC) == null) {
-                _enumNamesLC = strs = _fetch(config,
-                        e -> _nameWithStrategy(config, e),
-                        true);
-            }
-        } else {
-            if ((strs = _enumNames) == null) {
-                _enumNamesLC = strs = _fetch(config,
-                        e -> _nameWithStrategy(config, e),
-                        false);
-            }
-        }
-        return strs[en.ordinal()];
-    }
-
-    public SerializableString fromToString(MapperConfig<?> config, Enum<?> en) {
-        SerializableString[] strs;
-        if (config.isEnabled(EnumFeature.WRITE_ENUMS_TO_LOWERCASE)) {
-            if ((strs = _enumToStringsLC) == null) {
-                _enumToStringsLC = strs = _fetch(config, Enum::toString, true);
-            }
-        } else {
-            if ((strs = _enumToStrings) == null) {
-                _enumToStrings = strs = _fetch(config, Enum::toString, false);
-            }
-        }
-        return strs[en.ordinal()];
-    }
-
-    private String _nameWithStrategy(MapperConfig<?> config, Enum<?> en) {
-        String str = en.name();
-        if (_enumNamingStrategy != null) {
-            str = _enumNamingStrategy.convertEnumToExternalName(config, _annotatedClass, str);
-        }
-        return str;
-    }
-
-    private SerializableString[] _fetch(MapperConfig<?> config,
-            Function<Enum<?>,String> accessor, boolean lowerCase) {
-        final int len = _enumConstants.length;
-        SerializableString[] serStrs = new SerializableString[_enumConstants.length];
-        for (int i = 0; i < len; ++i) {
-            SerializableString ser = _explicitNames[i];
-            if (ser == null) {
-                String str = accessor.apply(_enumConstants[i]);
-                if (lowerCase) {
-                    str = str.toLowerCase();
-                }
-                ser = config.compileString(str);
-            }
-            serStrs[i] = ser;
-        }
-        return serStrs;
-    }
-}
diff --git a/src/test/java/tools/jackson/databind/deser/enums/EnumMapDeserializationTest.java b/src/test/java/tools/jackson/databind/deser/enums/EnumMapDeserializationTest.java
index 1b8c4c209..089b0d35f 100644
--- a/src/test/java/tools/jackson/databind/deser/enums/EnumMapDeserializationTest.java
+++ b/src/test/java/tools/jackson/databind/deser/enums/EnumMapDeserializationTest.java
@@ -1,6 +1,7 @@
 package tools.jackson.databind.deser.enums;
 
 import java.util.EnumMap;
+import java.util.LinkedHashMap;
 import java.util.Map;
 
 import org.junit.jupiter.api.Test;
@@ -95,6 +96,58 @@ public class EnumMapDeserializationTest
         public Enum1988 enumHolder;
     }
 
+    // [databind#2457]
+    enum MyEnum2457 {
+        A,
+        B() {
+            // just to ensure subclass construction
+            @Override
+            public void foo() { }
+        };
+
+        // needed to force subclassing
+        public void foo() { }
+
+        @Override
+        public String toString() { return name() + " as string"; }
+    }
+
+    // [databind#2457]
+    enum MyEnum2457Base {
+        @JsonProperty("a_base")
+        A,
+        @JsonProperty("b_base")
+        B() {
+            // just to ensure subclass construction
+            @Override
+            public void foo() { }
+        };
+        
+        // needed to force subclassing
+        public void foo() { }
+        
+        @Override
+        public String toString() { return name() + " as string"; }
+    }
+
+    // [databind#2457]
+    enum MyEnum2457Mixin {
+        @JsonProperty("a_mixin")
+        A,
+        @JsonProperty("b_mixin")
+        B() {
+            // just to ensure subclass construction
+            @Override
+            public void foo() { }
+        };
+
+        // needed to force subclassing
+        public void foo() { }
+
+        @Override
+        public String toString() { return name() + " as string"; }
+    }
+
     /*
     /**********************************************************
     /* Test methods, basic
@@ -252,6 +305,50 @@ public class EnumMapDeserializationTest
         assertEquals(EnumMap.class, value2.getClass());
     }
 
+    // [databind#2457]
+    @Test
+    public void testCustomEnumAsRootMapKey() throws Exception
+    {
+        final Map<MyEnum2457, String> map = new LinkedHashMap<>();
+        map.put(MyEnum2457.A, "1");
+        map.put(MyEnum2457.B, "2");
+        assertEquals(a2q("{'A':'1','B':'2'}"),
+                MAPPER.writer()
+                        .without(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
+                        .writeValueAsString(map));
+
+        // But should be able to override
+        assertEquals(a2q("{'"+MyEnum2457.A.toString()+"':'1','"+MyEnum2457.B.toString()+"':'2'}"),
+                MAPPER.writer()
+                    .with(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
+                    .writeValueAsString(map));
+    }
+
+    /**
+     * @see #testCustomEnumAsRootMapKey
+     */
+    // [databind#2457]
+    @Test
+    public void testCustomEnumAsRootMapKeyMixin() throws Exception
+    {
+        ObjectMapper mixinMapper = JsonMapper.builder()
+                .addMixIn(MyEnum2457Base.class, MyEnum2457Mixin.class)
+                .build();
+        final Map<MyEnum2457Base, String> map = new LinkedHashMap<>();
+        map.put(MyEnum2457Base.A, "1");
+        map.put(MyEnum2457Base.B, "2");
+        assertEquals(a2q("{'a_mixin':'1','b_mixin':'2'}"),
+                mixinMapper.writer()
+                        .without(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
+                        .writeValueAsString(map));
+
+        // But should be able to override
+        assertEquals(a2q("{'"+MyEnum2457Base.A.toString()+"':'1','"+MyEnum2457Base.B.toString()+"':'2'}"),
+                mixinMapper.writer()
+                        .with(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
+                        .writeValueAsString(map));
+    }
+
     /*
     /**********************************************************************
     /* Test methods: case-insensitive Enums
diff --git a/src/test/java/tools/jackson/databind/ser/enums/EnumAsMapKeySerializationTest.java b/src/test/java/tools/jackson/databind/ser/enums/EnumAsMapKeyTest.java
similarity index 56%
rename from src/test/java/tools/jackson/databind/ser/enums/EnumAsMapKeySerializationTest.java
rename to src/test/java/tools/jackson/databind/ser/enums/EnumAsMapKeyTest.java
index b2ac25e1e..3b0d0c78b 100644
--- a/src/test/java/tools/jackson/databind/ser/enums/EnumAsMapKeySerializationTest.java
+++ b/src/test/java/tools/jackson/databind/ser/enums/EnumAsMapKeyTest.java
@@ -2,25 +2,20 @@ package tools.jackson.databind.ser.enums;
 
 import java.util.*;
 
-import org.junit.jupiter.api.MethodOrderer;
 import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.TestMethodOrder;
 
 import com.fasterxml.jackson.annotation.JsonAnyGetter;
-import com.fasterxml.jackson.annotation.JsonProperty;
 import com.fasterxml.jackson.annotation.JsonValue;
 
 import tools.jackson.core.JsonGenerator;
 import tools.jackson.databind.*;
 import tools.jackson.databind.annotation.JsonSerialize;
 import tools.jackson.databind.cfg.EnumFeature;
-import tools.jackson.databind.json.JsonMapper;
 import tools.jackson.databind.testutil.DatabindTestUtil;
 
 import static org.junit.jupiter.api.Assertions.*;
 
-@TestMethodOrder(MethodOrderer.MethodName.class)
-public class EnumAsMapKeySerializationTest extends DatabindTestUtil
+public class EnumAsMapKeyTest extends DatabindTestUtil
 {
     static class MapBean {
         public Map<ABCEnum,Integer> map = new HashMap<>();
@@ -97,65 +92,6 @@ public class EnumAsMapKeySerializationTest extends DatabindTestUtil
         }
     }
 
-    // [databind#2457]
-    enum MyEnum2457 {
-        A,
-        B() {
-            // just to ensure subclass construction
-            @Override
-            public void foo() { }
-        };
-
-        // needed to force subclassing
-        public void foo() { }
-
-        @Override
-        public String toString() { return name() + " as string"; }
-    }
-
-    // [databind#2457]
-    enum MyEnum2457Base {
-        @JsonProperty("a_base")
-        A,
-        @JsonProperty("b_base")
-        B() {
-            // just to ensure subclass construction
-            @Override
-            public void foo() { }
-        },
-        C;
-        
-        // needed to force sub-classing
-        public void foo() { }
-        
-        @Override
-        public String toString() { return name() + " as string"; }
-    }
-
-    // [databind#2457]
-    enum MyEnum2457Mixin {
-        @JsonProperty("a_mixin")
-        A,
-        @JsonProperty("b_mixin")
-        B() {
-            // just to ensure subclass construction
-            @Override
-            public void foo() { }
-        };
-
-        // needed to force sub=classing
-        public void foo() { }
-
-        @Override
-        public String toString() { return name() + " as string"; }
-    }
-
-    // [databind#5432]
-    enum Color5432 {
-        @JsonProperty("red")
-        RED
-    }
-
     /*
     /**********************************************************************
     /* Test methods
@@ -163,8 +99,7 @@ public class EnumAsMapKeySerializationTest extends DatabindTestUtil
      */
 
     private final ObjectMapper MAPPER = jsonMapperBuilder()
-            .disable(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
-            .build();
+            .disable(EnumFeature.WRITE_ENUMS_USING_TO_STRING).build();
 
     @Test
     public void testMapWithEnumKeys() throws Exception
@@ -262,85 +197,4 @@ public class EnumAsMapKeySerializationTest extends DatabindTestUtil
                     .with(EnumFeature.WRITE_ENUMS_USING_INDEX)
                     .writeValueAsString(input));
     }
-
-    // [databind#2457]
-    @Test
-    public void testCustomEnumAsRootMapKey() throws Exception
-    {
-        final Map<MyEnum2457, String> map = new LinkedHashMap<>();
-        map.put(MyEnum2457.A, "1");
-        map.put(MyEnum2457.B, "2");
-        assertEquals(a2q("{'A':'1','B':'2'}"),
-                MAPPER.writer()
-                        .without(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
-                        .writeValueAsString(map));
-
-        // But should be able to override
-        assertEquals(a2q("{'"+MyEnum2457.A.toString()+"':'1','"+MyEnum2457.B.toString()+"':'2'}"),
-                MAPPER.writer()
-                    .with(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
-                    .writeValueAsString(map));
-    }
-
-    /**
-     * @see #testCustomEnumAsRootMapKey
-     */
-    // [databind#2457]
-    @Test
-    public void testCustomEnumAsRootMapKeyMixin() throws Exception
-    {
-        ObjectMapper mixinMapper = JsonMapper.builder()
-                .addMixIn(MyEnum2457Base.class, MyEnum2457Mixin.class)
-                .build();
-        final Map<MyEnum2457Base, String> map = new LinkedHashMap<>();
-        map.put(MyEnum2457Base.A, "1");
-        map.put(MyEnum2457Base.B, "2");
-        map.put(MyEnum2457Base.C, "3");
-        assertEquals(a2q("{'a_mixin':'1','b_mixin':'2','C':'3'}"),
-                mixinMapper.writer()
-                        .without(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
-                        .writeValueAsString(map));
-
-        // But should be able to override
-        assertEquals(a2q("{'a_mixin':'1','b_mixin':'2','"
-                +MyEnum2457Base.C.toString()+"':'3'}"
-                ),
-                mixinMapper.writer()
-                        .with(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
-                        .writeValueAsString(map));
-    }
-
-    // [databind#5432]
-    @Test
-    void enumKeyShouldSerializeUsingJsonPropertyAndToString() throws Exception
-    {
-        final ObjectMapper mapper = jsonMapperBuilder()
-                .enable(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
-                .build();
-
-        // Sanity check first
-        // assertEquals(q("red"), mapper.writeValueAsString(Color5432.RED));
-
-        // Then actual test
-        Map<Color5432, String> map = Collections.singletonMap(Color5432.RED, "#ff0000");
-        String json = mapper.writeValueAsString(map);
-        assertEquals("{\"red\":\"#ff0000\"}", json);
-    }
-
-    // [databind#5432]
-    @Test
-    void enumKeyShouldSerializeUsingJsonPropertyAndName() throws Exception
-    {
-        final ObjectMapper mapper = jsonMapperBuilder()
-                .disable(EnumFeature.WRITE_ENUMS_USING_TO_STRING)
-                .build();
-
-        // Sanity check first
-        assertEquals(q("red"), mapper.writeValueAsString(Color5432.RED));
-
-        // Then actual test
-        Map<Color5432, String> map = Collections.singletonMap(Color5432.RED, "#ff0000");
-        String json = mapper.writeValueAsString(map);
-        assertEquals("{\"red\":\"#ff0000\"}", json);
-    }
 }
diff --git a/src/test/java/tools/jackson/databind/ser/enums/EnumNamingSerializationTest.java b/src/test/java/tools/jackson/databind/ser/jdk/EnumNamingSerializationTest.java
similarity index 95%
rename from src/test/java/tools/jackson/databind/ser/enums/EnumNamingSerializationTest.java
rename to src/test/java/tools/jackson/databind/ser/jdk/EnumNamingSerializationTest.java
index 651c4d867..de9aea811 100644
--- a/src/test/java/tools/jackson/databind/ser/enums/EnumNamingSerializationTest.java
+++ b/src/test/java/tools/jackson/databind/ser/jdk/EnumNamingSerializationTest.java
@@ -1,4 +1,4 @@
-package tools.jackson.databind.ser.enums;
+package tools.jackson.databind.ser.jdk;
 
 import java.util.EnumMap;
 import java.util.EnumSet;
@@ -111,8 +111,8 @@ public class EnumNamingSerializationTest extends DatabindTestUtil
     }
 
     @Test
-    public void testEnumWithEnumMap() throws Exception {
-        EnumMap<EnumSauceB, String> enums = new EnumMap<>(EnumSauceB.class);
+    public void testDesrEnumWithEnumMap() throws Exception {
+        EnumMap<EnumSauceB, String> enums = new EnumMap<EnumSauceB, String>(EnumSauceB.class);
         enums.put(EnumSauceB.MAYO_NEZZ, "value");
 
         String str = MAPPER.writer()
diff --git a/src/test/java/tools/jackson/databind/ser/enums/EnumSerializationTest.java b/src/test/java/tools/jackson/databind/ser/jdk/EnumSerializationTest.java
similarity index 99%
rename from src/test/java/tools/jackson/databind/ser/enums/EnumSerializationTest.java
rename to src/test/java/tools/jackson/databind/ser/jdk/EnumSerializationTest.java
index ec8e1723f..607eee928 100644
--- a/src/test/java/tools/jackson/databind/ser/enums/EnumSerializationTest.java
+++ b/src/test/java/tools/jackson/databind/ser/jdk/EnumSerializationTest.java
@@ -1,4 +1,4 @@
-package tools.jackson.databind.ser.enums;
+package tools.jackson.databind.ser.jdk;
 
 import java.util.*;
 
diff --git a/src/test/java/tools/jackson/databind/util/EnumValuesTest.java b/src/test/java/tools/jackson/databind/util/EnumValuesTest.java
index 543d0053b..ec84a9e84 100644
--- a/src/test/java/tools/jackson/databind/util/EnumValuesTest.java
+++ b/src/test/java/tools/jackson/databind/util/EnumValuesTest.java
@@ -29,14 +29,14 @@ public class EnumValuesTest extends DatabindTestUtil
         public String toString() { return desc; }
     }
 
-    private final ObjectMapper MAPPER = newJsonMapper();
+    private final ObjectMapper MAPPER = new ObjectMapper();
 
     @Test
     public void testConstructFromName() {
         SerializationConfig cfg = MAPPER.serializationConfig()
                 .without(EnumFeature.WRITE_ENUMS_USING_TO_STRING);
         AnnotatedClass enumClass = resolve(MAPPER, ABC.class);
-        EnumValues values = EnumValues.constructFromName(cfg, enumClass);
+        EnumValues values = EnumValues.construct(cfg, enumClass);
         assertEquals("A", values.serializedValueFor(ABC.A).toString());
         assertEquals("B", values.serializedValueFor(ABC.B).toString());
         assertEquals("C", values.serializedValueFor(ABC.C).toString());
@@ -49,8 +49,7 @@ public class EnumValuesTest extends DatabindTestUtil
         SerializationConfig cfg = MAPPER.serializationConfig()
                 .with(EnumFeature.WRITE_ENUMS_USING_TO_STRING);
         AnnotatedClass enumClass = resolve(MAPPER, ABC.class);
-
-        EnumValues values = EnumValues.constructFromToString(cfg, enumClass);
+        EnumValues values = EnumValues.construct(cfg, enumClass);
         assertEquals("A", values.serializedValueFor(ABC.A).toString());
         assertEquals("b", values.serializedValueFor(ABC.B).toString());
         assertEquals("C", values.serializedValueFor(ABC.C).toString());
@@ -81,8 +80,7 @@ public class EnumValuesTest extends DatabindTestUtil
         SerializationConfig cfg = MAPPER.serializationConfig()
             .with(EnumFeature.WRITE_ENUMS_TO_LOWERCASE);
         AnnotatedClass enumClass = resolve(MAPPER, ABC.class);
-
-        EnumValues values = EnumValues.constructFromName(cfg, enumClass);
+        EnumValues values = EnumValues.construct(cfg, enumClass);
         assertEquals("a", values.serializedValueFor(ABC.A).toString());
         assertEquals("b", values.serializedValueFor(ABC.B).toString());
         assertEquals("c", values.serializedValueFor(ABC.C).toString());
