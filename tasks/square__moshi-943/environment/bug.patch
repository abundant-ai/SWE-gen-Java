diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/PropertyGenerator.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/PropertyGenerator.kt
index 13f46c47..07bf1bf3 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/PropertyGenerator.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/PropertyGenerator.kt
@@ -26,7 +26,7 @@ internal class PropertyGenerator(
   val isTransient: Boolean = false
 ) {
   val name = target.name
-  val jsonName = target.jsonName
+  val jsonName = target.jsonName ?: target.name
   val hasDefault = target.hasDefault
 
   lateinit var localName: String
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetParameter.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetParameter.kt
index b9e10bd5..828f25ce 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetParameter.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetParameter.kt
@@ -22,6 +22,6 @@ internal data class TargetParameter(
   val name: String,
   val index: Int,
   val hasDefault: Boolean,
-  val jsonName: String = name,
+  val jsonName: String? = null,
   val qualifiers: Set<AnnotationSpec>? = null
 )
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetProperty.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetProperty.kt
index 1c141d4f..dab0178d 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetProperty.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetProperty.kt
@@ -24,7 +24,7 @@ internal data class TargetProperty(
   val propertySpec: PropertySpec,
   val parameter: TargetParameter?,
   val visibility: KModifier,
-  val jsonName: String
+  val jsonName: String?
 ) {
   val name: String get() = propertySpec.name
   val type: TypeName get() = propertySpec.type
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
index ef1b8327..45764624 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
@@ -77,7 +77,7 @@ internal fun primaryConstructor(kotlinApi: TypeSpec, elements: Elements): Target
         index = index,
         hasDefault = parameter.defaultValue != null,
         qualifiers = parameter.annotations.qualifiers(elements),
-        jsonName = parameter.annotations.jsonName() ?: name.escapeDollarSigns()
+        jsonName = parameter.annotations.jsonName()
     )
   }
 
diff --git a/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/codegen/GeneratedAdaptersTest.kt b/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/codegen/GeneratedAdaptersTest.kt
index aa756fbb..9466831e 100644
--- a/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/codegen/GeneratedAdaptersTest.kt
+++ b/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/codegen/GeneratedAdaptersTest.kt
@@ -35,6 +35,7 @@ import org.junit.Assert.fail
 import org.junit.Ignore
 import org.junit.Test
 import java.util.Locale
+import kotlin.properties.Delegates
 import kotlin.reflect.full.memberProperties
 
 @ExperimentalStdlibApi
@@ -563,6 +564,38 @@ class GeneratedAdaptersTest {
     }
   }
 
+  @Test fun transientDelegateProperty() {
+    val jsonAdapter = moshi.adapter<TransientDelegateProperty>()
+
+    val encoded = TransientDelegateProperty()
+    encoded.a = 3
+    encoded.setB(4)
+    encoded.c = 5
+    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"c":5}""")
+
+    val decoded = jsonAdapter.fromJson("""{"a":4,"b":5,"c":6}""")!!
+    assertThat(decoded.a).isEqualTo(-1)
+    assertThat(decoded.getB()).isEqualTo(-1)
+    assertThat(decoded.c).isEqualTo(6)
+  }
+
+  @JsonClass(generateAdapter = true)
+  class TransientDelegateProperty {
+
+    private fun <T>delegate(initial: T) = Delegates.observable(initial) { _, _, _-> }
+
+    @delegate:Transient var a: Int by delegate(-1)
+    @delegate:Transient private var b: Int by delegate(-1)
+    var c: Int by delegate(-1)
+
+    @JvmName("getBPublic")
+    fun getB() = b
+    @JvmName("setBPublic")
+    fun setB(b: Int) {
+      this.b = b
+    }
+  }
+
   @Test fun manyProperties32() {
     val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter<ManyProperties32>()
@@ -1081,6 +1114,45 @@ class GeneratedAdaptersTest {
       assertThat(e).hasMessageContaining("Failed to find the generated JsonAdapter class")
     }
   }
+
+  // https://github.com/square/moshi/issues/921
+  @Test fun internalPropertyWithoutBackingField() {
+    val adapter = moshi.adapter<InternalPropertyWithoutBackingField>()
+
+    val test = InternalPropertyWithoutBackingField()
+    assertThat(adapter.toJson(test)).isEqualTo("""{"bar":5}""")
+
+    assertThat(adapter.fromJson("""{"bar":6}""")!!.bar).isEqualTo(6)
+  }
+
+  @JsonClass(generateAdapter = true)
+  class InternalPropertyWithoutBackingField {
+
+    @Transient
+    private var foo: Int = 5
+
+    internal var bar
+      get() = foo
+      set(f) {
+        foo = f
+      }
+  }
+
+  @JsonClass(generateAdapter = true)
+  data class ClassWithFieldJson(
+      @field:Json(name = "_links") val links: String
+  ) {
+    @field:Json(name = "_ids") var ids: String? = null
+  }
+
+  // Regression test to ensure annotations with field site targets still use the right name
+  @Test fun classWithFieldJsonTargets() {
+    val moshi = Moshi.Builder().build()
+    val adapter = moshi.adapter<ClassWithFieldJson>()
+    //language=JSON
+    val instance = adapter.fromJson("""{"_links": "link", "_ids": "id" }""")!!
+    assertThat(instance).isEqualTo(ClassWithFieldJson("link").apply { ids = "id" })
+  }
 }
 
 // Has to be outside to avoid Types seeing an owning class
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonScope.java b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
index 8f1b13c4..05f47ad3 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonScope.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
@@ -44,9 +44,6 @@ final class JsonScope {
   /** A document that's been closed and cannot be accessed. */
   static final int CLOSED = 8;
 
-  /** Sits above the actual state to indicate that a value is currently being streamed in. */
-  static final int STREAMING_VALUE = 9;
-
   /**
    * Renders the path in a JSON document to a string. The {@code pathNames} and {@code pathIndices}
    * parameters corresponds directly to stack: At indices where the stack contains an object
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
index e8d88be0..2a883776 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
@@ -17,11 +17,9 @@ package com.squareup.moshi;
 
 import java.io.IOException;
 import javax.annotation.Nullable;
-import okio.Buffer;
 import okio.BufferedSink;
-import okio.Okio;
+import okio.BufferedSource;
 import okio.Sink;
-import okio.Timeout;
 
 import static com.squareup.moshi.JsonScope.DANGLING_NAME;
 import static com.squareup.moshi.JsonScope.EMPTY_ARRAY;
@@ -30,7 +28,6 @@ import static com.squareup.moshi.JsonScope.EMPTY_OBJECT;
 import static com.squareup.moshi.JsonScope.NONEMPTY_ARRAY;
 import static com.squareup.moshi.JsonScope.NONEMPTY_DOCUMENT;
 import static com.squareup.moshi.JsonScope.NONEMPTY_OBJECT;
-import static com.squareup.moshi.JsonScope.STREAMING_VALUE;
 
 final class JsonUtf8Writer extends JsonWriter {
 
@@ -276,35 +273,16 @@ final class JsonUtf8Writer extends JsonWriter {
     return this;
   }
 
-  @Override public BufferedSink valueSink() throws IOException {
+  @Override public JsonWriter value(BufferedSource source) throws IOException {
     if (promoteValueToName) {
       throw new IllegalStateException(
-          "BufferedSink cannot be used as a map key in JSON at path " + getPath());
+          "BufferedSource cannot be used as a map key in JSON at path " + getPath());
     }
     writeDeferredName();
     beforeValue();
-    pushScope(STREAMING_VALUE);
-    return Okio.buffer(new Sink() {
-      @Override public void write(Buffer source, long byteCount) throws IOException {
-        sink.write(source, byteCount);
-      }
-
-      @Override public void close() {
-        if (peekScope() != STREAMING_VALUE) {
-          throw new AssertionError();
-        }
-        stackSize--; // Remove STREAMING_VALUE from the stack.
-        pathIndices[stackSize - 1]++;
-      }
-
-      @Override public void flush() throws IOException {
-        sink.flush();
-      }
-
-      @Override public Timeout timeout() {
-        return Timeout.NONE;
-      }
-    });
+    sink.writeAll(source);
+    pathIndices[stackSize - 1]++;
+    return this;
   }
 
   /**
@@ -402,7 +380,6 @@ final class JsonUtf8Writer extends JsonWriter {
    */
   @SuppressWarnings("fallthrough")
   private void beforeValue() throws IOException {
-    int nextTop;
     switch (peekScope()) {
       case NONEMPTY_DOCUMENT:
         if (!lenient) {
@@ -411,28 +388,26 @@ final class JsonUtf8Writer extends JsonWriter {
         }
         // fall-through
       case EMPTY_DOCUMENT: // first in document
-        nextTop = NONEMPTY_DOCUMENT;
+        replaceTop(NONEMPTY_DOCUMENT);
+        break;
+
+      case EMPTY_ARRAY: // first in array
+        replaceTop(NONEMPTY_ARRAY);
+        newline();
         break;
 
       case NONEMPTY_ARRAY: // another in array
         sink.writeByte(',');
-        // fall-through
-      case EMPTY_ARRAY: // first in array
         newline();
-        nextTop = NONEMPTY_ARRAY;
         break;
 
       case DANGLING_NAME: // value for name
-        nextTop = NONEMPTY_OBJECT;
         sink.writeUtf8(separator);
+        replaceTop(NONEMPTY_OBJECT);
         break;
 
-      case STREAMING_VALUE:
-        throw new IllegalStateException("Sink from valueSink() was not closed");
-
       default:
         throw new IllegalStateException("Nesting problem.");
     }
-    replaceTop(nextTop);
   }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
index 21fa06b9..6ab79eee 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
@@ -21,16 +21,12 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ForwardingSink;
-import okio.Okio;
+import okio.BufferedSource;
 
 import static com.squareup.moshi.JsonScope.EMPTY_ARRAY;
 import static com.squareup.moshi.JsonScope.EMPTY_DOCUMENT;
 import static com.squareup.moshi.JsonScope.EMPTY_OBJECT;
 import static com.squareup.moshi.JsonScope.NONEMPTY_DOCUMENT;
-import static com.squareup.moshi.JsonScope.STREAMING_VALUE;
 import static java.lang.Double.NEGATIVE_INFINITY;
 import static java.lang.Double.POSITIVE_INFINITY;
 
@@ -230,35 +226,21 @@ final class JsonValueWriter extends JsonWriter {
     return this;
   }
 
-  @Override public BufferedSink valueSink() {
+  @Override public JsonWriter value(BufferedSource source) throws IOException {
     if (promoteValueToName) {
       throw new IllegalStateException(
-          "BufferedSink cannot be used as a map key in JSON at path " + getPath());
+          "BufferedSource cannot be used as a map key in JSON at path " + getPath());
     }
-    if (peekScope() == STREAMING_VALUE) {
-      throw new IllegalStateException("Sink from valueSink() was not closed");
+    Object value = JsonReader.of(source).readJsonValue();
+    boolean serializeNulls = this.serializeNulls;
+    this.serializeNulls = true;
+    try {
+      add(value);
+    } finally {
+      this.serializeNulls = serializeNulls;
     }
-    pushScope(STREAMING_VALUE);
-
-    final Buffer buffer = new Buffer();
-    return Okio.buffer(new ForwardingSink(buffer) {
-      @Override public void close() throws IOException {
-        if (peekScope() != STREAMING_VALUE || stack[stackSize] != null) {
-          throw new AssertionError();
-        }
-        stackSize--; // Remove STREAMING_VALUE from the stack.
-
-        Object value = JsonReader.of(buffer).readJsonValue();
-        boolean serializeNulls = JsonValueWriter.this.serializeNulls;
-        JsonValueWriter.this.serializeNulls = true;
-        try {
-          add(value);
-        } finally {
-          JsonValueWriter.this.serializeNulls = serializeNulls;
-        }
-        pathIndices[stackSize - 1]++;
-      }
-    });
+    pathIndices[stackSize - 1]++;
+    return this;
   }
 
   @Override public void close() throws IOException {
@@ -302,9 +284,6 @@ final class JsonValueWriter extends JsonWriter {
       List<Object> list = (List<Object>) stack[stackSize - 1];
       list.add(newTop);
 
-    } else if (scope == STREAMING_VALUE) {
-      throw new IllegalStateException("Sink from valueSink() was not closed");
-
     } else {
       throw new IllegalStateException("Nesting problem.");
     }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index f5d49786..bc2b9bd4 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -359,32 +359,13 @@ public abstract class JsonWriter implements Closeable, Flushable {
   public abstract JsonWriter value(@Nullable Number value) throws IOException;
 
   /**
-   * Writes {@code source} directly without encoding its contents. Equivalent to
-   * {@code try (BufferedSink sink = writer.valueSink()) { source.readAll(sink): }}
+   * Writes {@code source} directly without encoding its contents.
+   * Since no validation is performed, {@link #setSerializeNulls} and other writer configurations
+   * are not respected.
    *
-   * @see #valueSink()
-   */
-  public final JsonWriter value(BufferedSource source) throws IOException {
-    if (promoteValueToName) {
-      throw new IllegalStateException(
-          "BufferedSource cannot be used as a map key in JSON at path " + getPath());
-    }
-    try (BufferedSink sink = valueSink()) {
-      source.readAll(sink);
-    }
-    return this;
-  }
-
-  /**
-   * Returns a {@link BufferedSink} into which arbitrary data can be written without any additional
-   * encoding. You <b>must</b> call {@link BufferedSink#close()} before interacting with this
-   * {@code JsonWriter} instance again.
-   * <p>
-   * Since no validation is performed, options like {@link #setSerializeNulls} and other writer
-   * configurations are not respected.
+   * @return this writer.
    */
-  @CheckReturnValue
-  public abstract BufferedSink valueSink() throws IOException;
+  public abstract JsonWriter value(BufferedSource source) throws IOException;
 
   /**
    * Changes the writer to treat the next value as a string name. This is useful for map adapters so
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonWriterTest.java b/moshi/src/test/java/com/squareup/moshi/JsonWriterTest.java
index 6fcfcd5a..2fe44b60 100644
--- a/moshi/src/test/java/com/squareup/moshi/JsonWriterTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/JsonWriterTest.java
@@ -19,7 +19,6 @@ import java.io.IOException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.List;
-import okio.BufferedSink;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
@@ -617,129 +616,4 @@ public final class JsonWriterTest {
       assertThat(expected).hasMessage("Dangling name: a");
     }
   }
-
-  @Test public void streamingValueInObject() throws IOException {
-    JsonWriter writer = factory.newWriter();
-    writer.beginObject();
-    writer.name("a");
-    BufferedSink value = writer.valueSink();
-    value.writeByte('"');
-    value.writeHexadecimalUnsignedLong(-1L);
-    value.writeUtf8("sup");
-    value.writeDecimalLong(-1L);
-    value.writeByte('"');
-    value.close();
-    writer.endObject();
-    assertThat(factory.json()).isEqualTo("{\"a\":\"ffffffffffffffffsup-1\"}");
-  }
-
-  @Test public void streamingValueInArray() throws IOException {
-    JsonWriter writer = factory.newWriter();
-    writer.beginArray();
-    writer.valueSink()
-        .writeByte('"')
-        .writeHexadecimalUnsignedLong(-1L)
-        .writeByte('"')
-        .close();
-    writer.valueSink()
-        .writeByte('"')
-        .writeUtf8("sup")
-        .writeByte('"')
-        .close();
-    writer.valueSink()
-        .writeUtf8("-1.0")
-        .close();
-    writer.endArray();
-    assertThat(factory.json()).isEqualTo("[\"ffffffffffffffff\",\"sup\",-1.0]");
-  }
-
-  @Test public void streamingValueTopLevel() throws IOException {
-    JsonWriter writer = factory.newWriter();
-    writer.valueSink()
-        .writeUtf8("-1.0")
-        .close();
-    assertThat(factory.json()).isEqualTo("-1.0");
-  }
-
-  @Test public void streamingValueTwiceBeforeCloseFails() throws IOException {
-    JsonWriter writer = factory.newWriter();
-    writer.beginObject();
-    writer.name("a");
-    BufferedSink sink = writer.valueSink();
-    try {
-      writer.valueSink();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Sink from valueSink() was not closed");
-    }
-  }
-
-  @Test public void streamingValueTwiceAfterCloseFails() throws IOException {
-    JsonWriter writer = factory.newWriter();
-    writer.beginObject();
-    writer.name("a");
-    writer.valueSink().writeByte('0').close();
-    try {
-      // TODO currently UTF-8 fails eagerly on valueSink() but value does not fail until close().
-      writer.valueSink().writeByte('0').close();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Nesting problem.");
-    }
-  }
-
-  @Test public void streamingValueAndScalarValueFails() throws IOException {
-    JsonWriter writer = factory.newWriter();
-    writer.beginObject();
-    writer.name("a");
-    BufferedSink sink = writer.valueSink();
-    try {
-      writer.value("b");
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Sink from valueSink() was not closed");
-    }
-  }
-
-  @Test public void streamingValueAndNameFails() throws IOException {
-    JsonWriter writer = factory.newWriter();
-    writer.beginObject();
-    writer.name("a");
-    BufferedSink sink = writer.valueSink();
-    try {
-      writer.name("b");
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Nesting problem.");
-    }
-  }
-
-  @Test public void streamingValueInteractionAfterCloseFails() throws IOException {
-    JsonWriter writer = factory.newWriter();
-    writer.beginObject();
-    writer.name("a");
-    BufferedSink sink = writer.valueSink();
-    sink.writeUtf8("1.0");
-    sink.close();
-    try {
-      sink.writeByte('1');
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("closed");
-    }
-  }
-
-  @Test public void streamingValueCloseIsIdempotent() throws IOException {
-    JsonWriter writer = factory.newWriter();
-    writer.beginObject();
-    writer.name("a");
-    BufferedSink sink = writer.valueSink();
-    sink.writeUtf8("1.0");
-    sink.close();
-    sink.close();
-    writer.endObject();
-    sink.close();
-    assertThat(factory.json()).isEqualTo("{\"a\":1.0}");
-    sink.close();
-  }
 }
diff --git a/moshi/src/test/java/com/squareup/moshi/PromoteNameToValueTest.java b/moshi/src/test/java/com/squareup/moshi/PromoteNameToValueTest.java
index 33a17700..02064c47 100644
--- a/moshi/src/test/java/com/squareup/moshi/PromoteNameToValueTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/PromoteNameToValueTest.java
@@ -351,21 +351,4 @@ public final class PromoteNameToValueTest {
     writer.endObject();
     assertThat(factory.json()).isEqualTo("{\"a\":\"a value\"}");
   }
-
-  @Test public void writerValueSinkFails() throws Exception {
-    JsonWriter writer = factory.newWriter();
-    writer.beginObject();
-    writer.promoteValueToName();
-    try {
-      writer.valueSink();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected).hasMessage(
-          "BufferedSink cannot be used as a map key in JSON at path $.");
-    }
-    writer.value("a");
-    writer.value("a value");
-    writer.endObject();
-    assertThat(factory.json()).isEqualTo("{\"a\":\"a value\"}");
-  }
 }
diff --git a/pom.xml b/pom.xml
index 8290c29c..a26d3cfb 100644
--- a/pom.xml
+++ b/pom.xml
@@ -45,7 +45,7 @@
     <assertj.version>3.11.1</assertj.version>
     <compile-testing.version>0.15</compile-testing.version>
     <junit.version>4.12</junit.version>
-    <kotlin-compile-testing.version>1.2.2</kotlin-compile-testing.version>
+    <kotlin-compile-testing.version>1.2.3</kotlin-compile-testing.version>
     <truth.version>1.0</truth.version>
   </properties>
 
