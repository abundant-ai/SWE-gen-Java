diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/PropertyGenerator.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/PropertyGenerator.kt
index 07bf1bf3..13f46c47 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/PropertyGenerator.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/PropertyGenerator.kt
@@ -26,7 +26,7 @@ internal class PropertyGenerator(
   val isTransient: Boolean = false
 ) {
   val name = target.name
-  val jsonName = target.jsonName ?: target.name
+  val jsonName = target.jsonName
   val hasDefault = target.hasDefault
 
   lateinit var localName: String
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetParameter.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetParameter.kt
index 828f25ce..b9e10bd5 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetParameter.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetParameter.kt
@@ -22,6 +22,6 @@ internal data class TargetParameter(
   val name: String,
   val index: Int,
   val hasDefault: Boolean,
-  val jsonName: String? = null,
+  val jsonName: String = name,
   val qualifiers: Set<AnnotationSpec>? = null
 )
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetProperty.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetProperty.kt
index dab0178d..1c141d4f 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetProperty.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetProperty.kt
@@ -24,7 +24,7 @@ internal data class TargetProperty(
   val propertySpec: PropertySpec,
   val parameter: TargetParameter?,
   val visibility: KModifier,
-  val jsonName: String?
+  val jsonName: String
 ) {
   val name: String get() = propertySpec.name
   val type: TypeName get() = propertySpec.type
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
index 45764624..ef1b8327 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
@@ -77,7 +77,7 @@ internal fun primaryConstructor(kotlinApi: TypeSpec, elements: Elements): Target
         index = index,
         hasDefault = parameter.defaultValue != null,
         qualifiers = parameter.annotations.qualifiers(elements),
-        jsonName = parameter.annotations.jsonName()
+        jsonName = parameter.annotations.jsonName() ?: name.escapeDollarSigns()
     )
   }
 
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonScope.java b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
index 05f47ad3..8f1b13c4 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonScope.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
@@ -44,6 +44,9 @@ final class JsonScope {
   /** A document that's been closed and cannot be accessed. */
   static final int CLOSED = 8;
 
+  /** Sits above the actual state to indicate that a value is currently being streamed in. */
+  static final int STREAMING_VALUE = 9;
+
   /**
    * Renders the path in a JSON document to a string. The {@code pathNames} and {@code pathIndices}
    * parameters corresponds directly to stack: At indices where the stack contains an object
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
index 2a883776..e8d88be0 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
@@ -17,9 +17,11 @@ package com.squareup.moshi;
 
 import java.io.IOException;
 import javax.annotation.Nullable;
+import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
+import okio.Okio;
 import okio.Sink;
+import okio.Timeout;
 
 import static com.squareup.moshi.JsonScope.DANGLING_NAME;
 import static com.squareup.moshi.JsonScope.EMPTY_ARRAY;
@@ -28,6 +30,7 @@ import static com.squareup.moshi.JsonScope.EMPTY_OBJECT;
 import static com.squareup.moshi.JsonScope.NONEMPTY_ARRAY;
 import static com.squareup.moshi.JsonScope.NONEMPTY_DOCUMENT;
 import static com.squareup.moshi.JsonScope.NONEMPTY_OBJECT;
+import static com.squareup.moshi.JsonScope.STREAMING_VALUE;
 
 final class JsonUtf8Writer extends JsonWriter {
 
@@ -273,16 +276,35 @@ final class JsonUtf8Writer extends JsonWriter {
     return this;
   }
 
-  @Override public JsonWriter value(BufferedSource source) throws IOException {
+  @Override public BufferedSink valueSink() throws IOException {
     if (promoteValueToName) {
       throw new IllegalStateException(
-          "BufferedSource cannot be used as a map key in JSON at path " + getPath());
+          "BufferedSink cannot be used as a map key in JSON at path " + getPath());
     }
     writeDeferredName();
     beforeValue();
-    sink.writeAll(source);
-    pathIndices[stackSize - 1]++;
-    return this;
+    pushScope(STREAMING_VALUE);
+    return Okio.buffer(new Sink() {
+      @Override public void write(Buffer source, long byteCount) throws IOException {
+        sink.write(source, byteCount);
+      }
+
+      @Override public void close() {
+        if (peekScope() != STREAMING_VALUE) {
+          throw new AssertionError();
+        }
+        stackSize--; // Remove STREAMING_VALUE from the stack.
+        pathIndices[stackSize - 1]++;
+      }
+
+      @Override public void flush() throws IOException {
+        sink.flush();
+      }
+
+      @Override public Timeout timeout() {
+        return Timeout.NONE;
+      }
+    });
   }
 
   /**
@@ -380,6 +402,7 @@ final class JsonUtf8Writer extends JsonWriter {
    */
   @SuppressWarnings("fallthrough")
   private void beforeValue() throws IOException {
+    int nextTop;
     switch (peekScope()) {
       case NONEMPTY_DOCUMENT:
         if (!lenient) {
@@ -388,26 +411,28 @@ final class JsonUtf8Writer extends JsonWriter {
         }
         // fall-through
       case EMPTY_DOCUMENT: // first in document
-        replaceTop(NONEMPTY_DOCUMENT);
-        break;
-
-      case EMPTY_ARRAY: // first in array
-        replaceTop(NONEMPTY_ARRAY);
-        newline();
+        nextTop = NONEMPTY_DOCUMENT;
         break;
 
       case NONEMPTY_ARRAY: // another in array
         sink.writeByte(',');
+        // fall-through
+      case EMPTY_ARRAY: // first in array
         newline();
+        nextTop = NONEMPTY_ARRAY;
         break;
 
       case DANGLING_NAME: // value for name
+        nextTop = NONEMPTY_OBJECT;
         sink.writeUtf8(separator);
-        replaceTop(NONEMPTY_OBJECT);
         break;
 
+      case STREAMING_VALUE:
+        throw new IllegalStateException("Sink from valueSink() was not closed");
+
       default:
         throw new IllegalStateException("Nesting problem.");
     }
+    replaceTop(nextTop);
   }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
index 6ab79eee..21fa06b9 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
@@ -21,12 +21,16 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.Nullable;
-import okio.BufferedSource;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ForwardingSink;
+import okio.Okio;
 
 import static com.squareup.moshi.JsonScope.EMPTY_ARRAY;
 import static com.squareup.moshi.JsonScope.EMPTY_DOCUMENT;
 import static com.squareup.moshi.JsonScope.EMPTY_OBJECT;
 import static com.squareup.moshi.JsonScope.NONEMPTY_DOCUMENT;
+import static com.squareup.moshi.JsonScope.STREAMING_VALUE;
 import static java.lang.Double.NEGATIVE_INFINITY;
 import static java.lang.Double.POSITIVE_INFINITY;
 
@@ -226,21 +230,35 @@ final class JsonValueWriter extends JsonWriter {
     return this;
   }
 
-  @Override public JsonWriter value(BufferedSource source) throws IOException {
+  @Override public BufferedSink valueSink() {
     if (promoteValueToName) {
       throw new IllegalStateException(
-          "BufferedSource cannot be used as a map key in JSON at path " + getPath());
+          "BufferedSink cannot be used as a map key in JSON at path " + getPath());
     }
-    Object value = JsonReader.of(source).readJsonValue();
-    boolean serializeNulls = this.serializeNulls;
-    this.serializeNulls = true;
-    try {
-      add(value);
-    } finally {
-      this.serializeNulls = serializeNulls;
+    if (peekScope() == STREAMING_VALUE) {
+      throw new IllegalStateException("Sink from valueSink() was not closed");
     }
-    pathIndices[stackSize - 1]++;
-    return this;
+    pushScope(STREAMING_VALUE);
+
+    final Buffer buffer = new Buffer();
+    return Okio.buffer(new ForwardingSink(buffer) {
+      @Override public void close() throws IOException {
+        if (peekScope() != STREAMING_VALUE || stack[stackSize] != null) {
+          throw new AssertionError();
+        }
+        stackSize--; // Remove STREAMING_VALUE from the stack.
+
+        Object value = JsonReader.of(buffer).readJsonValue();
+        boolean serializeNulls = JsonValueWriter.this.serializeNulls;
+        JsonValueWriter.this.serializeNulls = true;
+        try {
+          add(value);
+        } finally {
+          JsonValueWriter.this.serializeNulls = serializeNulls;
+        }
+        pathIndices[stackSize - 1]++;
+      }
+    });
   }
 
   @Override public void close() throws IOException {
@@ -284,6 +302,9 @@ final class JsonValueWriter extends JsonWriter {
       List<Object> list = (List<Object>) stack[stackSize - 1];
       list.add(newTop);
 
+    } else if (scope == STREAMING_VALUE) {
+      throw new IllegalStateException("Sink from valueSink() was not closed");
+
     } else {
       throw new IllegalStateException("Nesting problem.");
     }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index bc2b9bd4..f5d49786 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -359,13 +359,32 @@ public abstract class JsonWriter implements Closeable, Flushable {
   public abstract JsonWriter value(@Nullable Number value) throws IOException;
 
   /**
-   * Writes {@code source} directly without encoding its contents.
-   * Since no validation is performed, {@link #setSerializeNulls} and other writer configurations
-   * are not respected.
+   * Writes {@code source} directly without encoding its contents. Equivalent to
+   * {@code try (BufferedSink sink = writer.valueSink()) { source.readAll(sink): }}
    *
-   * @return this writer.
+   * @see #valueSink()
+   */
+  public final JsonWriter value(BufferedSource source) throws IOException {
+    if (promoteValueToName) {
+      throw new IllegalStateException(
+          "BufferedSource cannot be used as a map key in JSON at path " + getPath());
+    }
+    try (BufferedSink sink = valueSink()) {
+      source.readAll(sink);
+    }
+    return this;
+  }
+
+  /**
+   * Returns a {@link BufferedSink} into which arbitrary data can be written without any additional
+   * encoding. You <b>must</b> call {@link BufferedSink#close()} before interacting with this
+   * {@code JsonWriter} instance again.
+   * <p>
+   * Since no validation is performed, options like {@link #setSerializeNulls} and other writer
+   * configurations are not respected.
    */
-  public abstract JsonWriter value(BufferedSource source) throws IOException;
+  @CheckReturnValue
+  public abstract BufferedSink valueSink() throws IOException;
 
   /**
    * Changes the writer to treat the next value as a string name. This is useful for map adapters so
diff --git a/pom.xml b/pom.xml
index a26d3cfb..8290c29c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -45,7 +45,7 @@
     <assertj.version>3.11.1</assertj.version>
     <compile-testing.version>0.15</compile-testing.version>
     <junit.version>4.12</junit.version>
-    <kotlin-compile-testing.version>1.2.3</kotlin-compile-testing.version>
+    <kotlin-compile-testing.version>1.2.2</kotlin-compile-testing.version>
     <truth.version>1.0</truth.version>
   </properties>
 
