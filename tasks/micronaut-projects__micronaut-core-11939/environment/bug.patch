diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index dd54114d69..b921a8f2d8 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -165,7 +165,6 @@ managed-netty-transport-native-epoll = { module = "io.netty:netty-transport-nati
 managed-netty-transport-native-kqueue = { module = "io.netty:netty-transport-native-kqueue", version.ref = "managed-netty" }
 managed-netty-transport-native-iouring = { module = "io.netty:netty-transport-native-io_uring", version.ref = "managed-netty" }
 managed-netty-transport-native-unix-common = { module = "io.netty:netty-transport-native-unix-common", version.ref = "managed-netty" }
-managed-netty-pkitesting = { module = "io.netty:netty-pkitesting", version.ref = "managed-netty" }
 managed-netty-tcnative-boringssl-static = { module = "io.netty:netty-tcnative-boringssl-static", version.ref = "managed-netty-tcnative" }
 
 managed-reactive-streams = { module = "org.reactivestreams:reactive-streams", version.ref = "managed-reactive-streams" }
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ssl/NettyClientSslBuilder.java b/http-client/src/main/java/io/micronaut/http/client/netty/ssl/NettyClientSslBuilder.java
index 3fe2ea4284..9500beded6 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/ssl/NettyClientSslBuilder.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/ssl/NettyClientSslBuilder.java
@@ -27,10 +27,10 @@ import io.micronaut.http.ssl.ClientAuthentication;
 import io.micronaut.http.ssl.SslBuilder;
 import io.micronaut.http.ssl.SslConfiguration;
 import io.micronaut.http.ssl.SslConfigurationException;
-import io.netty.handler.codec.http2.Http2SecurityUtil;
 import io.netty.handler.codec.http3.Http3;
 import io.netty.handler.codec.quic.QuicSslContext;
 import io.netty.handler.codec.quic.QuicSslContextBuilder;
+import io.netty.handler.codec.http2.Http2SecurityUtil;
 import io.netty.handler.ssl.ApplicationProtocolConfig;
 import io.netty.handler.ssl.ClientAuth;
 import io.netty.handler.ssl.SslContext;
@@ -121,7 +121,7 @@ public class NettyClientSslBuilder extends SslBuilder<SslContext> implements Cli
             }
         }
         if (versionSelection.isAlpn()) {
-            SslProvider provider = ssl.isPreferOpenssl() && SslProvider.isAlpnSupported(SslProvider.OPENSSL) ? SslProvider.OPENSSL : SslProvider.JDK;
+            SslProvider provider = SslProvider.isAlpnSupported(SslProvider.OPENSSL) ? SslProvider.OPENSSL : SslProvider.JDK;
             sslBuilder.sslProvider(provider);
             sslBuilder.applicationProtocolConfig(new ApplicationProtocolConfig(
                 ApplicationProtocolConfig.Protocol.ALPN,
diff --git a/http-server-netty/build.gradle.kts b/http-server-netty/build.gradle.kts
index eb1a066db3..bc3783333e 100644
--- a/http-server-netty/build.gradle.kts
+++ b/http-server-netty/build.gradle.kts
@@ -63,7 +63,6 @@ dependencies {
     testImplementation(libs.spotbugs)
     testImplementation(projects.micronautHttpNettyHttp3)
     testImplementation(libs.bcpkix)
-    testImplementation(libs.managed.netty.pkitesting)
     testImplementation(projects.micronautJacksonDatabind)
     testImplementation(projects.micronautHttpTck)
 // Add Micronaut Jackson XML after v4 Migration
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/ssl/AbstractServerSslBuilder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/ssl/AbstractServerSslBuilder.java
index 4e08ec672c..adfd58b0f6 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/ssl/AbstractServerSslBuilder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/ssl/AbstractServerSslBuilder.java
@@ -25,10 +25,10 @@ import io.micronaut.http.ssl.ServerSslConfiguration;
 import io.micronaut.http.ssl.SslBuilder;
 import io.micronaut.http.ssl.SslConfiguration;
 import io.micronaut.http.ssl.SslConfigurationException;
-import io.netty.handler.codec.http2.Http2SecurityUtil;
 import io.netty.handler.codec.http3.Http3;
 import io.netty.handler.codec.quic.QuicSslContext;
 import io.netty.handler.codec.quic.QuicSslContextBuilder;
+import io.netty.handler.codec.http2.Http2SecurityUtil;
 import io.netty.handler.ssl.ApplicationProtocolConfig;
 import io.netty.handler.ssl.ApplicationProtocolNames;
 import io.netty.handler.ssl.ClientAuth;
@@ -158,9 +158,7 @@ public abstract class AbstractServerSslBuilder extends SslBuilder<SslContext> im
     @Override
     protected KeyManagerFactory getKeyManagerFactory(SslConfiguration ssl) {
         try {
-            return NettyTlsUtils.storeToFactory(ssl, getKeyStore(ssl).orElseThrow(() -> new SslConfigurationException("No key store configured")));
-        } catch (SslConfigurationException ex) {
-            throw ex;
+            return NettyTlsUtils.storeToFactory(ssl, getKeyStore(ssl).orElse(null));
         } catch (Exception ex) {
             throw new SslConfigurationException(ex);
         }
diff --git a/http-server-netty/src/test/java/io/micronaut/http/server/netty/ssl/PemSslConfigTest.java b/http-server-netty/src/test/java/io/micronaut/http/server/netty/ssl/PemSslConfigTest.java
deleted file mode 100644
index e8eb74d909..0000000000
--- a/http-server-netty/src/test/java/io/micronaut/http/server/netty/ssl/PemSslConfigTest.java
+++ /dev/null
@@ -1,268 +0,0 @@
-package io.micronaut.http.server.netty.ssl;
-
-import io.micronaut.context.ApplicationContext;
-import io.micronaut.context.annotation.Requires;
-import io.micronaut.http.annotation.Controller;
-import io.micronaut.http.annotation.Get;
-import io.micronaut.http.client.HttpClient;
-import io.micronaut.http.ssl.SslConfigurationException;
-import io.micronaut.runtime.server.EmbeddedServer;
-import io.netty.handler.ssl.OpenSsl;
-import io.netty.pkitesting.CertificateBuilder;
-import io.netty.pkitesting.X509Bundle;
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.Arguments;
-import org.junit.jupiter.params.provider.MethodSource;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.security.KeyStore;
-import java.util.ArrayList;
-import java.util.Base64;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.UUID;
-import java.util.function.Consumer;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertInstanceOf;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-
-public class PemSslConfigTest {
-    private static final Set<CertificateBuilder.Algorithm> PQC = Set.of(
-        CertificateBuilder.Algorithm.mlKem512,
-        CertificateBuilder.Algorithm.mlKem768,
-        CertificateBuilder.Algorithm.mlKem1024,
-        CertificateBuilder.Algorithm.mlDsa44,
-        CertificateBuilder.Algorithm.mlDsa65,
-        CertificateBuilder.Algorithm.mlDsa87
-    );
-
-    static List<Arguments> algorithms() {
-        List<Arguments> out = new ArrayList<>();
-        for (boolean openssl : new boolean[]{false, true}) {
-            if (openssl && !OpenSsl.isAvailable()) {
-                continue;
-            }
-            for (boolean separateProperties : new boolean[]{false, true}) {
-                List<List<CertificateBuilder.Algorithm>> algs = new ArrayList<>();
-
-                for (CertificateBuilder.Algorithm simple : List.of(
-                    CertificateBuilder.Algorithm.ecp256,
-                    CertificateBuilder.Algorithm.ecp384,
-                    CertificateBuilder.Algorithm.rsa2048,
-                    CertificateBuilder.Algorithm.rsa4096
-                )) {
-                    algs.add(List.of(simple));
-                }
-                if (!openssl) { // TODO: currently broken: https://github.com/netty/netty/pull/15467
-                    algs.add(List.of(CertificateBuilder.Algorithm.ed25519));
-                    algs.add(List.of(CertificateBuilder.Algorithm.ed448));
-                }
-
-                algs.add(List.of(CertificateBuilder.Algorithm.rsa2048, CertificateBuilder.Algorithm.rsa2048));
-
-                /* TODO: currently broken: https://github.com/netty/netty/pull/15467
-                if (PlatformDependent.javaVersion() >= 24 && openssl) {
-                    for (CertificateBuilder.Algorithm pqc : PQC) {
-                        if (pqc.supportSigning()) {
-                            algs.add(List.of(pqc));
-                        }
-                        algs.add(List.of(CertificateBuilder.Algorithm.rsa2048, pqc));
-                    }
-                }
-                 */
-
-                for (List<CertificateBuilder.Algorithm> alg : algs) {
-                    out.add(Arguments.of(alg, openssl, separateProperties));
-                }
-            }
-        }
-        return out;
-    }
-
-    @ParameterizedTest
-    @MethodSource("algorithms")
-    public void test(List<CertificateBuilder.Algorithm> algorithms, boolean openssl, boolean separateProperties) throws Exception {
-        X509Bundle root = null;
-        X509Bundle prev = null;
-        X509Bundle leaf = null;
-        for (int i = 0; i < algorithms.size(); i++) {
-            boolean isLeaf = i == algorithms.size() - 1;
-            CertificateBuilder builder = new CertificateBuilder()
-                .subject("CN=" + (isLeaf ? "localhost" : "ca" + i))
-                .setIsCertificateAuthority(!isLeaf || algorithms.size() == 1)
-                .algorithm(algorithms.get(i));
-            if (prev == null) {
-                root = builder.buildSelfSigned();
-                prev = root;
-            } else {
-                prev = builder.buildIssuedBy(prev);
-            }
-            if (isLeaf) {
-                leaf = prev;
-            }
-        }
-        assert leaf != null;
-
-        Map<String, Object> props = new HashMap<>();
-        props.put("spec.name", "PemSslConfigTest");
-        props.put("micronaut.ssl.prefer-openssl", openssl);
-        props.put("micronaut.ssl.protocols", "TLSv1.3");
-        props.put("micronaut.http.client.ssl.protocols", "TLSv1.3");
-        props.put("micronaut.server.ssl.port", -1);
-        props.put("micronaut.server.ssl.enabled", true);
-        if (separateProperties) {
-            props.put("micronaut.server.ssl.key-store.key-path", "string:" + leaf.getPrivateKeyPEM());
-            props.put("micronaut.server.ssl.key-store.certificate-path", "string:" + leaf.getCertificatePathPEM());
-        } else {
-            props.put("micronaut.server.ssl.key-store.path", "string:" + leaf.getPrivateKeyPEM() + leaf.getCertificatePathPEM());
-        }
-        props.put("micronaut.http.client.ssl.trust-store.path", "string:" + root.getCertificatePEM());
-        try (ApplicationContext ctx = ApplicationContext.run(props)) {
-            EmbeddedServer server = ctx.getBean(EmbeddedServer.class);
-            server.start();
-
-            try (HttpClient client = ctx.createBean(HttpClient.class, server.getURI())) {
-                assertEquals("hello", client.toBlocking().retrieve("/pem-ssl/hello"));
-            }
-        }
-    }
-
-    @Requires(property = "spec.name", value = "PemSslConfigTest")
-    @Controller("/pem-ssl")
-    static class MyController {
-        @Get("/hello")
-        String hello() {
-            return "hello";
-        }
-    }
-
-    private static final X509Bundle BUNDLE;
-    private static final String KEY_STORE_RESOURCE;
-    private static final String KEY_STORE_RESOURCE_PASSWORD = "password";
-
-    static {
-        try {
-            BUNDLE = new CertificateBuilder()
-                .algorithm(CertificateBuilder.Algorithm.ecp256)
-                .setIsCertificateAuthority(true)
-                .subject("CN=localhost")
-                .buildSelfSigned();
-
-            KeyStore ks = BUNDLE.toKeyStore(null);
-            ByteArrayOutputStream baos = new ByteArrayOutputStream();
-            ks.store(baos, KEY_STORE_RESOURCE_PASSWORD.toCharArray());
-            KEY_STORE_RESOURCE = "base64:" + Base64.getEncoder().encodeToString(baos.toByteArray());
-        } catch (Exception e) {
-            throw new RuntimeException(e);
-        }
-    }
-
-    static List<Arguments> simpleErrorConditions() {
-        String doesNotExist = "file:/tmp/" + UUID.randomUUID();
-        return List.of(
-            Arguments.of(Map.of(), "No key store configured"),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.path", "string:ks1", "micronaut.ssl.key-store.key-path", "string:k1"),
-                "Cannot specify key store path and key-path or certificate-path at the same time"),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.path", "string:ks1", "micronaut.ssl.key-store.certificate-path", "string:k1"),
-                "Cannot specify key store path and key-path or certificate-path at the same time"),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.certificate-path", "string:c1"),
-                "Must also specify key-path"),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.key-path", "string:k1"),
-                "Must also specify certificate-path"),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.path", doesNotExist),
-                "The resource " + doesNotExist + " could not be found"),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.key-path", doesNotExist, "micronaut.ssl.key-store.certificate-path", "string:c1"),
-                "The resource " + doesNotExist + " could not be found"),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.key-path", "string:" + BUNDLE.getPrivateKeyPEM(), "micronaut.ssl.key-store.certificate-path", doesNotExist),
-                "The resource " + doesNotExist + " could not be found"),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.key-path", "string:" + BUNDLE.getPrivateKeyPEM() + BUNDLE.getPrivateKeyPEM(), "micronaut.ssl.key-store.certificate-path", "string:" + BUNDLE.getCertificatePathPEM()),
-                "key-path contained more than one PEM object. It should only contain the private key."),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.key-path", "string:" + BUNDLE.getCertificatePathPEM(), "micronaut.ssl.key-store.certificate-path", "string:" + BUNDLE.getCertificatePathPEM()),
-                "key-path contained a certificate instead of a private key."),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.path", "string:" + BUNDLE.getPrivateKeyPEM() + BUNDLE.getPrivateKeyPEM() + BUNDLE.getCertificatePathPEM()),
-                "PEM must only contain the private key and a certificate chain")
-        );
-    }
-
-    @ParameterizedTest
-    @MethodSource("simpleErrorConditions")
-    public void simpleErrorConditions(Map<String, Object> cfg, String message) {
-        Map<String, Object> combined = new HashMap<>(cfg);
-        combined.put("micronaut.ssl.enabled", true);
-        try (ApplicationContext ctx = ApplicationContext.run(combined)) {
-            SslConfigurationException ex = assertThrows(
-                SslConfigurationException.class,
-                () -> ctx.getBean(CertificateProvidedSslBuilder.class).build()
-            );
-            try {
-                assertEquals(message, ex.getMessage());
-            } catch (Throwable e) {
-                e.addSuppressed(ex);
-                throw e;
-            }
-        }
-    }
-
-    static List<Arguments> extendedErrorConditions() {
-        return List.of(
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.path", KEY_STORE_RESOURCE, "micronaut.ssl.key-store.password", "wrong-password"),
-                (Consumer<SslConfigurationException>) e -> {
-                    assertEquals("keystore password was incorrect", e.getCause().getMessage());
-                    assertEquals(0, e.getSuppressed().length);
-                    assertEquals(0, e.getCause().getSuppressed().length);
-                }),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.path", "base64:ABCDEFG"),
-                (Consumer<SslConfigurationException>) e -> {
-                    Throwable cause = e.getCause();
-                    assertInstanceOf(IOException.class, cause);
-                    assertEquals(1, cause.getSuppressed().length);
-                    assertEquals("Also tried and failed to load the input as PEM", cause.getSuppressed()[0].getMessage());
-                    assertEquals("Missing start tag", cause.getSuppressed()[0].getCause().getMessage());
-                }),
-            Arguments.of(
-                Map.of("micronaut.ssl.key-store.path", "string:-----BEGIN PRIVATE KEY-----\nabcdef\n-----END PRIVATE KEY-----\n"),
-                (Consumer<SslConfigurationException>) e -> {
-                    Throwable cause = e.getCause();
-                    assertInstanceOf(IllegalArgumentException.class, cause);
-                    assertEquals(1, cause.getSuppressed().length);
-                    assertEquals("Also tried and failed to load the input as a key store", cause.getSuppressed()[0].getMessage());
-                    assertEquals("Invalid keystore format", cause.getSuppressed()[0].getCause().getMessage());
-                })
-        );
-    }
-
-    @ParameterizedTest
-    @MethodSource("extendedErrorConditions")
-    public void extendedErrorConditions(Map<String, Object> cfg, Consumer<SslConfigurationException> check) {
-        Map<String, Object> combined = new HashMap<>(cfg);
-        combined.put("micronaut.ssl.enabled", true);
-        try (ApplicationContext ctx = ApplicationContext.run(combined)) {
-            SslConfigurationException ex = assertThrows(
-                SslConfigurationException.class,
-                () -> ctx.getBean(CertificateProvidedSslBuilder.class).build()
-            );
-            try {
-                check.accept(ex);
-            } catch (Throwable e) {
-                e.addSuppressed(ex);
-                throw e;
-            }
-        }
-    }
-}
diff --git a/http/src/main/java/io/micronaut/http/ssl/PemParser.java b/http/src/main/java/io/micronaut/http/ssl/PemParser.java
deleted file mode 100644
index d16cd4d86f..0000000000
--- a/http/src/main/java/io/micronaut/http/ssl/PemParser.java
+++ /dev/null
@@ -1,538 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.ssl;
-
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.util.ArrayUtils;
-
-import javax.crypto.Cipher;
-import javax.crypto.EncryptedPrivateKeyInfo;
-import javax.crypto.SecretKey;
-import javax.crypto.SecretKeyFactory;
-import javax.crypto.spec.PBEKeySpec;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.security.GeneralSecurityException;
-import java.security.KeyFactory;
-import java.security.cert.CertificateFactory;
-import java.security.spec.PKCS8EncodedKeySpec;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Base64;
-import java.util.Collection;
-import java.util.List;
-
-/**
- * Generic PEM file parser with type detection. <b>Note that this class does not defend against DER
- * parser differential vulnerabilities, so it should not be used to verify untrusted PEMs.</b>
- *
- * @param provider The security provider to use for creating cryptographic data structures
- * @param password The configured password for encrypted private keys
- */
-record PemParser(
-    @Nullable String provider,
-    @Nullable String password
-) {
-    private static final String DASHES = "-----";
-    private static final String START = DASHES + "BEGIN ";
-    private static final String END = DASHES + "END ";
-
-    private static final String OID_RSA = "1.2.840.113549.1.1.1";
-    private static final String OID_EC = "1.2.840.10045.2.1";
-
-    /**
-     * Load the given PEM file.
-     *
-     * @param pem The PEM
-     * @return A list of {@link java.security.cert.X509Certificate} and
-     * {@link java.security.PrivateKey} instances
-     * @throws GeneralSecurityException On JDK parsing failure
-     * @throws IllegalArgumentException On MN parsing failure
-     * @throws NotPemException On MN parsing failure that points to the input likely not being PEM
-     * at all
-     */
-    List<Object> loadPem(String pem) throws GeneralSecurityException, IllegalArgumentException, NotPemException {
-        // PEM is a sequence of base64 encoded DER objects delimited by -----BEGIN/END lines
-        List<Object> list = new ArrayList<>();
-        int i = 0;
-        while (i < pem.length()) {
-            if (Character.isWhitespace(pem.charAt(i))) {
-                i++;
-                continue;
-            } else if (!pem.startsWith(START, i)) {
-                if (list.isEmpty()) {
-                    throw new NotPemException("Missing start tag");
-                } else {
-                    throw invalidPem(false);
-                }
-            }
-            i += START.length();
-            int labelEnd = pem.indexOf(DASHES, i);
-            if (labelEnd == -1) {
-                throw invalidPem(list.isEmpty());
-            }
-            String label = pem.substring(i, labelEnd);
-            i = labelEnd + DASHES.length();
-            String trailer = END + label + DASHES;
-            int sectionEnd = pem.indexOf(trailer, i);
-            if (sectionEnd == -1) {
-                throw invalidPem(list.isEmpty());
-            }
-            Decoder decoder = getDecoder(label);
-
-            String contentString = pem.substring(i, sectionEnd)
-                .replace("\r", "")
-                .replace("\n", "");
-            i = sectionEnd + trailer.length();
-            byte[] content = Base64.getDecoder().decode(contentString);
-            list.addAll(decoder.decode(content));
-        }
-        if (list.isEmpty()) {
-            throw new IllegalArgumentException("PEM file empty");
-        }
-        return list;
-    }
-
-    private static IllegalArgumentException invalidPem(boolean first) throws NotPemException {
-        if (first) {
-            throw new NotPemException("Invalid PEM");
-        }
-        return new IllegalArgumentException("Invalid PEM");
-    }
-
-    private Decoder getDecoder(String label) {
-        return switch (label) {
-            case "CERTIFICATE", "X509 CERTIFICATE" -> new CertificateDecoder();
-            case "ENCRYPTED PRIVATE KEY" -> new Pkcs8EncryptedPrivateKey();
-            case "PRIVATE KEY" -> new Pkcs8PrivateKey();
-            case "RSA PRIVATE KEY" -> new Pkcs1PrivateKey(false);
-            case "EC PRIVATE KEY" -> new Pkcs1PrivateKey(true);
-            default -> throw new IllegalArgumentException("Unsupported PEM label: " + label);
-        };
-    }
-
-    private sealed interface Decoder {
-        Collection<?> decode(byte[] der) throws GeneralSecurityException;
-    }
-
-    /**
-     * X.509 certificate decoder.
-     */
-    private final class CertificateDecoder implements Decoder {
-        @Override
-        public Collection<?> decode(byte[] der) throws GeneralSecurityException {
-            CertificateFactory factory = provider == null ? CertificateFactory.getInstance("X.509") : CertificateFactory.getInstance("X.509", provider);
-            return factory.generateCertificates(new ByteArrayInputStream(der));
-        }
-    }
-
-    /**
-     * PKCS#8 unencrypted private key decoder with algorithm detection.
-     */
-    private final class Pkcs8PrivateKey implements Decoder {
-        @Override
-        public Collection<?> decode(byte[] der) throws GeneralSecurityException {
-            // we need to figure out which key algorithm is used, so we parse the DER a bit.
-            DerInput outer = new DerInput(der);
-            DerInput privateKeyInfo = outer.readSequence();
-            // Version
-            privateKeyInfo.expect(0x02);
-            privateKeyInfo.expect(0x01);
-            privateKeyInfo.expect(0x00);
-            DerInput privateKeyAlgorithm = privateKeyInfo.readSequence();
-            String algOid = privateKeyAlgorithm.readOid();
-            String alg = switch (algOid) {
-                case OID_RSA -> "RSA";
-                case OID_EC -> "EC";
-                case "1.3.101.112" -> "Ed25519";
-                case "1.3.101.113" -> "Ed448";
-                case "2.16.840.1.101.3.4.3.17", "2.16.840.1.101.3.4.3.18",
-                     "2.16.840.1.101.3.4.3.19" -> "ML-DSA";
-                case "2.16.840.1.101.3.4.4.1", "2.16.840.1.101.3.4.4.2", "2.16.840.1.101.3.4.4.3" ->
-                    "ML-KEM";
-                default ->
-                    throw new IllegalArgumentException("Unrecognized PKCS#8 key algorithm " + algOid);
-            };
-
-            KeyFactory factory = provider == null ? KeyFactory.getInstance(alg) : KeyFactory.getInstance(alg, provider);
-            return List.of(factory.generatePrivate(new PKCS8EncodedKeySpec(der)));
-        }
-    }
-
-    private final class Pkcs8EncryptedPrivateKey implements Decoder {
-        @Override
-        public Collection<?> decode(byte[] der) throws GeneralSecurityException {
-            EncryptedPrivateKeyInfo keyInfo;
-            try {
-                keyInfo = new EncryptedPrivateKeyInfo(der);
-            } catch (IOException e) {
-                throw new GeneralSecurityException("Invalid DER", e);
-            }
-            String cipherAlg = keyInfo.getAlgName();
-            if (cipherAlg.equals("PBES2")) {
-                // Java >= 19 does this automatically
-                cipherAlg = keyInfo.getAlgParameters().toString();
-            }
-            SecretKeyFactory skf = provider == null ? SecretKeyFactory.getInstance(cipherAlg) : SecretKeyFactory.getInstance(cipherAlg, provider);
-            if (password == null) {
-                throw new IllegalArgumentException("Encrypted private key found but no password given");
-            }
-            SecretKey sk = skf.generateSecret(new PBEKeySpec(password.toCharArray()));
-            Cipher cipher = Cipher.getInstance(cipherAlg);
-            cipher.init(Cipher.DECRYPT_MODE, sk, keyInfo.getAlgParameters());
-            PKCS8EncodedKeySpec keySpec = keyInfo.getKeySpec(cipher);
-            String keyAlg = keySpec.getAlgorithm();
-            KeyFactory factory = provider == null ? KeyFactory.getInstance(keyAlg) : KeyFactory.getInstance(keyAlg, provider);
-            return List.of(factory.generatePrivate(keySpec));
-        }
-    }
-
-    private final class Pkcs1PrivateKey implements Decoder {
-        // for ellptic curves, this is specified in SEC.1, not PKCS#1
-        private final boolean ec;
-
-        Pkcs1PrivateKey(boolean ec) {
-            this.ec = ec;
-        }
-
-        @Override
-        public Collection<?> decode(byte[] der) throws GeneralSecurityException {
-            // build PKCS#8 from PKCS#1
-            DerOutput output = new DerOutput();
-            try (DerOutput.Value privateKeyInfo = output.writeValue(0x30)) {
-                try (DerOutput.Value version = output.writeValue(0x2)) {
-                    output.write(0);
-                }
-                try (DerOutput.Value privateKeyAlgorithm = output.writeValue(0x30)) {
-                    if (ec) {
-                        DerInput parameters = extractCurveParams(der);
-                        output.writeOid(OID_EC);
-                        output.write(parameters.data, parameters.i, parameters.limit - parameters.i);
-                    } else {
-                        output.writeOid(OID_RSA);
-                        output.writeValue(0x05).close(); // parameters
-                    }
-                }
-                try (DerOutput.Value privateKey = output.writeValue(0x04)) {
-                    output.write(der, 0, der.length);
-                }
-            }
-            byte[] pkcs8 = output.finish();
-            String algorithm = ec ? "EC" : "RSA";
-            KeyFactory factory = provider == null ? KeyFactory.getInstance(algorithm) : KeyFactory.getInstance(algorithm, provider);
-            return List.of(factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8)));
-        }
-
-        private DerInput extractCurveParams(byte[] der) {
-            DerInput input = new DerInput(der);
-            DerInput ecPrivateKey = input.readSequence();
-            // version
-            ecPrivateKey.expect(0x02);
-            ecPrivateKey.expect(0x01);
-            ecPrivateKey.expect(0x01);
-            ecPrivateKey.readValue(0x04); // privateKey
-            DerInput parameters = null;
-            while (ecPrivateKey.i < ecPrivateKey.limit) {
-                int tag = ecPrivateKey.peekTag();
-                DerInput value = ecPrivateKey.readValue(tag);
-                if (tag == 0xa0) {
-                    parameters = value;
-                }
-            }
-            if (parameters == null) {
-                throw new IllegalArgumentException("Curve parameters not found for EC private key");
-            }
-            return parameters;
-        }
-    }
-
-    /**
-     * Simple DER parser.
-     */
-    private static final class DerInput {
-        final byte[] data;
-        final int limit;
-        int i;
-
-        DerInput(byte[] data) {
-            this(data, 0, data.length);
-        }
-
-        private DerInput(byte[] data, int start, int limit) {
-            this.data = data;
-            this.i = start;
-            this.limit = limit;
-        }
-
-        /**
-         * Read a single byte.
-         *
-         * @return The byte value
-         */
-        byte read() {
-            if (i >= limit) {
-                throw invalidDer();
-            }
-            return data[i++];
-        }
-
-        /**
-         * Read a single byte, throwing an exception if it does not match the given value.
-         *
-         * @param value The expected byte
-         */
-        void expect(int value) {
-            if ((read() & 0xff) != value) {
-                throw invalidDer();
-            }
-        }
-
-        /**
-         * Read a DER tag length.
-         *
-         * @return The length
-         */
-        private int readLength() {
-            byte b = read();
-            if (b >= 0) {
-                return b;
-            }
-            b &= 0x7f;
-            // this is not as strict as it should be for DER, so don't use this for data where
-            // parsing differentials could be a problem
-            int length = 0;
-            while (b-- > 0) {
-                length <<= 8;
-                length |= read() & 0xff;
-                if (length < 0 || length > limit - i) {
-                    throw invalidDer();
-                }
-            }
-            return length;
-        }
-
-        /**
-         * Get the type of the next tag.
-         *
-         * @return The next tag
-         */
-        int peekTag() {
-            int tag = read() & 0xff;
-            i--;
-            return tag;
-        }
-
-        /**
-         * Read a DER value. This {@link DerInput} will continue after the value, while the
-         * returned {@link DerInput} will read the value contents.
-         *
-         * @param tag The expected tag
-         * @return The reader for the value contents
-         */
-        DerInput readValue(int tag) {
-            expect(tag);
-            int n = readLength();
-            int end = i + n;
-            DerInput sequence = new DerInput(data, i, end);
-            i = end;
-            return sequence;
-        }
-
-        /**
-         * Read a DER sequence.
-         *
-         * @return The reader for the sequence content
-         */
-        DerInput readSequence() {
-            return readValue(0x30);
-        }
-
-        String readOid() {
-            DerInput helper = readValue(0x06);
-            StringBuilder builder = new StringBuilder();
-            while (helper.i < helper.limit) {
-                long value = 0;
-                while (true) {
-                    byte b = helper.read();
-                    value <<= 7;
-                    value |= b & 0x7f;
-                    if (b >= 0) {
-                        break;
-                    }
-                }
-                if (builder.isEmpty()) {
-                    // first value
-                    if (value >= 80) {
-                        builder.append("2.").append(value - 80);
-                    } else {
-                        builder.append(value / 40).append('.').append(value % 40);
-                    }
-                } else {
-                    builder.append('.').append(value);
-                }
-            }
-            return builder.toString();
-        }
-
-        private static RuntimeException invalidDer() {
-            return new IllegalArgumentException("Invalid PKCS#8");
-        }
-    }
-
-    /**
-     * Writer for DER documents.
-     */
-    private static final class DerOutput {
-        private byte[] out = ArrayUtils.EMPTY_BYTE_ARRAY;
-        private int i;
-
-        private void ensureCapacity(int n) {
-            while (i + n > out.length) {
-                out = Arrays.copyOf(out, out.length == 0 ? 16 : out.length * 2);
-            }
-        }
-
-        /**
-         * Write a single byte.
-         *
-         * @param b The byte
-         */
-        void write(int b) {
-            ensureCapacity(1);
-            out[i++] = (byte) b;
-        }
-
-        /**
-         * Write a byte array.
-         *
-         * @param arr The array to write from
-         * @param start The starting offset in the array
-         * @param len The number of bytes to write
-         */
-        void write(byte[] arr, int start, int len) {
-            ensureCapacity(len);
-            System.arraycopy(arr, start, out, i, len);
-            i += len;
-        }
-
-        /**
-         * Finish this DER writer, returning the complete DER document as a byte array.
-         *
-         * @return The finished DER
-         */
-        byte[] finish() {
-            return Arrays.copyOf(out, i);
-        }
-
-        private static int varIntLength(int value) {
-            if (value < (1 << 7)) {
-                return 1;
-            } else if (value < (1 << 14)) {
-                return 2;
-            } else if (value < (1 << 21)) {
-                return 3;
-            } else if (value < (1 << 28)) {
-                return 4;
-            } else {
-                return 5;
-            }
-        }
-
-        private void writeVarInt(int value) {
-            // writes a value in the bit form `1xxxxxxx 1xxxxxxx 0xxxxxxx`
-            int len = varIntLength(value);
-            for (int i = len - 1; i >= 0; i--) {
-                write(((value >> (i * 7)) & 0x7f) | (i == 0 ? 0 : 0x80));
-            }
-        }
-
-        void writeOid(String oid) {
-            try (Value ignored = writeValue(0x06)) {
-                String[] parts = oid.split("\\.");
-                for (int j = 0; j < parts.length; j++) {
-                    int value = Integer.parseInt(parts[j]);
-                    if (j == 0) {
-                        int next = Integer.parseInt(parts[++j]);
-                        writeVarInt(value * 40 + next);
-                    } else {
-                        writeVarInt(value);
-                    }
-                }
-            }
-
-        }
-
-        /**
-         * Write a new DER value. The returned {@link Value} must be {@link Value#close() closed}
-         * when the value is complete, at which point the value length will be written.
-         *
-         * @param tag The value tag
-         * @return The value that must be closed to write the length
-         */
-        Value writeValue(int tag) {
-            write(tag);
-            return new Value();
-        }
-
-        final class Value implements AutoCloseable {
-            private final int lengthOffset;
-
-            private Value() {
-                lengthOffset = i;
-                write(0);
-            }
-
-            @Override
-            public void close() {
-                int length = i - lengthOffset - 1;
-                int lengthLength;
-                if (length < 0x80) {
-                    out[lengthOffset] = (byte) length;
-                    return;
-                } else if (length < (1 << 8)) {
-                    lengthLength = 1;
-                } else if (length < (1 << 16)) {
-                    lengthLength = 2;
-                } else if (length < (1 << 24)) {
-                    lengthLength = 3;
-                } else {
-                    lengthLength = 4;
-                }
-                out[lengthOffset] = (byte) (0x80 | lengthLength);
-                // make sure we have room, and update position
-                for (int i = 0; i < lengthLength; i++) {
-                    write(0);
-                }
-                System.arraycopy(out, lengthOffset + 1, out, lengthOffset + 1 + lengthLength, length);
-                int mark = i;
-                i = lengthOffset + 1;
-                for (int i = lengthLength - 1; i >= 0; i--) {
-                    write((length >> (i * 8)) & 0xff);
-                }
-                i = mark;
-            }
-        }
-    }
-
-    /**
-     * Thrown when the input does not look like PEM.
-     */
-    public static final class NotPemException extends Exception {
-        private NotPemException(String message) {
-            super(message);
-        }
-    }
-}
diff --git a/http/src/main/java/io/micronaut/http/ssl/SslBuilder.java b/http/src/main/java/io/micronaut/http/ssl/SslBuilder.java
index c82008524a..fef0804005 100644
--- a/http/src/main/java/io/micronaut/http/ssl/SslBuilder.java
+++ b/http/src/main/java/io/micronaut/http/ssl/SslBuilder.java
@@ -15,26 +15,14 @@
  */
 package io.micronaut.http.ssl;
 
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.io.ResourceResolver;
 import io.micronaut.http.HttpVersion;
 
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.TrustManagerFactory;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.charset.StandardCharsets;
-import java.security.GeneralSecurityException;
+import java.net.URL;
 import java.security.KeyStore;
-import java.security.KeyStoreException;
-import java.security.NoSuchProviderException;
-import java.security.PrivateKey;
-import java.security.UnrecoverableKeyException;
-import java.security.cert.X509Certificate;
-import java.util.List;
 import java.util.Optional;
-import java.util.function.Supplier;
 
 /**
  * A class to build a key store and a trust store for use in adding SSL support to a server.
@@ -77,8 +65,6 @@ public abstract class SslBuilder<T> {
         Optional<KeyStore> store;
         try {
             store = getTrustStore(ssl);
-        } catch (SslConfigurationException e) {
-            throw e;
         } catch (Exception e) {
             throw new SslConfigurationException(e);
         }
@@ -96,8 +82,6 @@ public abstract class SslBuilder<T> {
                 .getInstance(TrustManagerFactory.getDefaultAlgorithm());
             trustManagerFactory.init(store);
             return trustManagerFactory;
-        } catch (SslConfigurationException ex) {
-            throw ex;
         } catch (Exception ex) {
             throw new SslConfigurationException(ex);
         }
@@ -113,12 +97,8 @@ public abstract class SslBuilder<T> {
         SslConfiguration.TrustStoreConfiguration trustStore = ssl.getTrustStore();
         Optional<String> path = trustStore.getPath();
         if (path.isPresent()) {
-            return Optional.of(loadCompat(new KeyStoreBasedCertificateSpec(
-                trustStore.getType().orElse(null),
-                trustStore.getPassword().orElse(null),
-                trustStore.getProvider().orElse(null),
-                path.get()
-            )));
+            return Optional.of(load(trustStore.getType(),
+                path.get(), trustStore.getPassword()));
         } else {
             return Optional.empty();
         }
@@ -157,273 +137,33 @@ public abstract class SslBuilder<T> {
         SslConfiguration.KeyStoreConfiguration keyStore = ssl.getKeyStore();
         Optional<String> path = keyStore.getPath();
         if (path.isPresent()) {
-            if (keyStore.getKeyPath() != null || keyStore.getCertificatePath() != null) {
-                throw new SslConfigurationException("Cannot specify key store path and key-path or certificate-path at the same time");
-            }
-            return Optional.of(loadCompat(new KeyStoreBasedCertificateSpec(
-                keyStore.getType().orElse(null),
-                keyStore.getPassword().orElse(null),
-                keyStore.getProvider().orElse(null),
-                path.get()
-            )));
-        } else if (keyStore.getKeyPath() != null) {
-            if (keyStore.getCertificatePath() == null) {
-                throw new SslConfigurationException("Must also specify certificate-path");
-            }
-            return Optional.of(loadCompat(new PemBasedCertificateSpec(
-                keyStore.getType().orElse(null),
-                keyStore.getPassword().orElse(null),
-                keyStore.getProvider().orElse(null),
-                keyStore.getKeyPath(),
-                keyStore.getCertificatePath()
-            )));
-        } else if (keyStore.getCertificatePath() != null) {
-            throw new SslConfigurationException("Must also specify key-path");
+            return Optional.of(load(keyStore.getType(),
+                path.get(), keyStore.getPassword()));
         } else {
             return Optional.empty();
         }
     }
 
-    private KeyStore loadCompat(CertificateSpec spec) throws Exception {
-        if (spec instanceof KeyStoreBasedCertificateSpec ks && ks.getProvider() == null) {
-            // we need to call the old method to make sure we hit any overrides
-            return load(Optional.ofNullable(ks.getType()), ks.getPath(), Optional.ofNullable(ks.getPassword()));
-        } else {
-            return load(spec);
-        }
-    }
-
     /**
      * @param optionalType     The optional type
      * @param resource         The resource
      * @param optionalPassword The optional password
      * @return A {@link KeyStore}
      * @throws Exception if there is an error
-     * @deprecated Please override {@link #load(CertificateSpec)} instead
      */
-    @SuppressWarnings("OptionalUsedAsFieldOrParameterType")
-    @Deprecated(forRemoval = true)
     protected KeyStore load(Optional<String> optionalType,
                             String resource,
                             Optional<String> optionalPassword) throws Exception {
-        return load(new KeyStoreBasedCertificateSpec(optionalType.orElse(null), optionalPassword.orElse(null), null, resource));
-    }
-
-    private static Supplier<SslConfigurationException> resourceNotFound(String resource) {
-        return () -> new SslConfigurationException("The resource " + resource + " could not be found");
-    }
-
-    /**
-     * @param spec The configured certificate spec
-     * @return A {@link KeyStore}
-     * @throws Exception if there is an error
-     */
-    protected KeyStore load(CertificateSpec spec) throws Exception {
-        if (spec instanceof KeyStoreBasedCertificateSpec ks) {
-            KeyStore store = createEmptyKeyStore(spec.provider, spec.type == null ? "JKS" : spec.type);
-
-            InputStream stream = resourceResolver.getResourceAsStream(ks.path)
-                .orElseThrow(resourceNotFound(ks.path));
-            try {
-                store.load(stream, spec.password == null ? null : spec.password.toCharArray());
-            } catch (IOException e) {
-                if (!(e.getCause() instanceof UnrecoverableKeyException)) {
-                    try {
-                        if (spec.type == null) {
-                            // we can't add passwordless keys to a JKS key store
-                            store = createEmptyKeyStore(spec.provider, "PKCS12");
-                        }
-
-                        loadPem(ks.path, spec.password, spec.provider, store);
-                    } catch (PemParser.NotPemException f) {
-                        // probably should have been loaded as KS
-                        e.addSuppressed(new Exception("Also tried and failed to load the input as PEM", f));
-                        throw e;
-                    } catch (Exception f) {
-                        // probably should have been loaded as PEM
-                        f.addSuppressed(new Exception("Also tried and failed to load the input as a key store", e));
-                        throw f;
-                    }
-                } else {
-                    throw e;
-                }
-            }
-            return store;
-        } else if (spec instanceof PemBasedCertificateSpec pem) {
-            List<Object> keyItems;
-            try (InputStream s = resourceResolver.getResourceAsStream(pem.keyPath).orElseThrow(resourceNotFound(pem.keyPath))) {
-                keyItems = new PemParser(pem.provider, pem.password)
-                    .loadPem(new String(s.readAllBytes(), StandardCharsets.UTF_8));
-            }
-            List<Object> certItems;
-            try (InputStream s = resourceResolver.getResourceAsStream(pem.certificatePath).orElseThrow(resourceNotFound(pem.certificatePath))) {
-                certItems = new PemParser(pem.provider, pem.password)
-                    .loadPem(new String(s.readAllBytes(), StandardCharsets.UTF_8));
-            }
+        String type = optionalType.orElse("JKS");
+        String password = optionalPassword.orElse(null);
+        KeyStore store = KeyStore.getInstance(type);
 
-            if (keyItems.size() != 1) {
-                throw new SslConfigurationException("key-path contained more than one PEM object. It should only contain the private key.");
-            }
-            if (!(keyItems.get(0) instanceof PrivateKey pk)) {
-                throw new SslConfigurationException("key-path contained a certificate instead of a private key.");
-            }
-            KeyStore store = createEmptyKeyStore(spec.provider, spec.type == null ? "PKCS12" : spec.type);
-            store.load(null, null);
-            store.setKeyEntry(
-                "key",
-                pk,
-                null,
-                certificates(certItems).toArray(new X509Certificate[0])
-            );
+        Optional<URL> url = resourceResolver.getResource(resource);
+        if (url.isPresent()) {
+            store.load(url.get().openStream(), password == null ? null : password.toCharArray());
             return store;
         } else {
-            throw new AssertionError("Weird CertificateSpec");
-        }
-    }
-
-    private static @NonNull KeyStore createEmptyKeyStore(@Nullable String provider, String type) throws KeyStoreException, NoSuchProviderException {
-        return provider == null ? KeyStore.getInstance(type) : KeyStore.getInstance(type, provider);
-    }
-
-    private void loadPem(@NonNull String resource, @Nullable String password, @Nullable String provider, KeyStore store) throws IOException, GeneralSecurityException, PemParser.NotPemException {
-        List<Object> items;
-        try (InputStream s = resourceResolver.getResourceAsStream(resource).orElseThrow(resourceNotFound(resource))) {
-            items = new PemParser(provider, password)
-                .loadPem(new String(s.readAllBytes(), StandardCharsets.UTF_8));
-        }
-        if (items.get(0) instanceof PrivateKey pk) {
-            X509Certificate[] certs = certificates(items.subList(1, items.size())).toArray(new X509Certificate[0]);
-            store.load(null, null);
-            store.setKeyEntry("key", pk, null, certs);
-        } else if (items.get(0) instanceof X509Certificate) {
-            store.load(null, null);
-            List<X509Certificate> certificates = certificates(items);
-            for (int i = 0; i < certificates.size(); i++) {
-                store.setCertificateEntry("cert" + i, certificates.get(i));
-            }
-        } else {
-            throw new SslConfigurationException("Unrecognized PEM entries");
-        }
-    }
-
-    private static List<X509Certificate> certificates(List<Object> pemObjects) {
-        for (Object pemObject : pemObjects) {
-            if (!(pemObject instanceof X509Certificate)) {
-                throw new SslConfigurationException("PEM must only contain the private key and a certificate chain");
-            }
-        }
-        //noinspection unchecked,rawtypes
-        return (List) pemObjects;
-    }
-
-    /**
-     * Specification for building a {@link KeyStore}, either as a key store or a trust store.
-     *
-     * @since 4.10.0
-     */
-    protected abstract static sealed class CertificateSpec {
-        final String type;
-        final String password;
-        final String provider;
-
-        private CertificateSpec(String type, String password, String provider) {
-            this.type = type;
-            this.password = password;
-            this.provider = provider;
-        }
-
-        /**
-         * {@link KeyStore} type, e.g. JKS or PKCS12.
-         *
-         * @return Key store type
-         */
-        @Nullable
-        public String getType() {
-            return type;
-        }
-
-        /**
-         * Key store password.
-         *
-         * @return The password
-         */
-        @Nullable
-        public String getPassword() {
-            return password;
-        }
-
-        /**
-         * JCA provider for creating the key store and other objects.
-         *
-         * @return The JCA provider
-         */
-        @Nullable
-        public String getProvider() {
-            return provider;
-        }
-    }
-
-    /**
-     * Certificate spec based on {@link SslConfiguration.KeyStoreConfiguration#getPath()} or
-     * {@link SslConfiguration.TrustStoreConfiguration#getPath()}. Note that the path can still
-     * point to a PEM.
-     *
-     * @since 4.10.0
-     */
-    protected static final class KeyStoreBasedCertificateSpec extends CertificateSpec {
-        final String path;
-
-        private KeyStoreBasedCertificateSpec(String type, String password, String provider, String path) {
-            super(type, password, provider);
-            this.path = path;
-        }
-
-        /**
-         * The path to the JKS, PKCS12 or PEM file.
-         *
-         * @return The path
-         */
-        @NonNull
-        public String getPath() {
-            return path;
-        }
-    }
-
-    /**
-     * Certificate spec based on {@link SslConfiguration.KeyStoreConfiguration#getKeyPath()} and
-     * {@link SslConfiguration.KeyStoreConfiguration#getCertificatePath()}, both of which must
-     * contain a PEM.
-     *
-     * @since 4.10.0
-     */
-    protected static final class PemBasedCertificateSpec extends CertificateSpec {
-        final String keyPath;
-        final String certificatePath;
-
-        private PemBasedCertificateSpec(String type, String password, String provider, String keyPath, String certificatePath) {
-            super(type, password, provider);
-            this.keyPath = keyPath;
-            this.certificatePath = certificatePath;
-        }
-
-        /**
-         * The path to the PEM file containing the private key.
-         *
-         * @return The path
-         */
-        @NonNull
-        public String getKeyPath() {
-            return keyPath;
-        }
-
-        /**
-         * The path to the PEM file containing the certificate chain.
-         *
-         * @return The path
-         */
-        @NonNull
-        public String getCertificatePath() {
-            return certificatePath;
+            throw new SslConfigurationException("The resource " + resource + " could not be found");
         }
     }
 }
diff --git a/http/src/main/java/io/micronaut/http/ssl/SslConfiguration.java b/http/src/main/java/io/micronaut/http/ssl/SslConfiguration.java
index f14aabf6a5..72a7964961 100644
--- a/http/src/main/java/io/micronaut/http/ssl/SslConfiguration.java
+++ b/http/src/main/java/io/micronaut/http/ssl/SslConfiguration.java
@@ -17,7 +17,6 @@ package io.micronaut.http.ssl;
 
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.util.StringUtils;
 import io.micronaut.core.util.Toggleable;
 import org.slf4j.Logger;
@@ -372,18 +371,12 @@ public class SslConfiguration implements Toggleable {
     public static class KeyStoreConfiguration {
         public static final String PREFIX = "key-store";
         private String path;
-        private String keyPath;
-        private String certificatePath;
         private String password;
         private String type;
         private String provider;
 
         /**
-         * The path to the key store (typically .jks). Can also point to a PEM file containing
-         * a private key followed by the X.509 trust chain. Can use {@code classpath:},
-         * {@code file:}, {@code string:} or {@code base64:}.
-         *
-         * @return The resource containing the key store
+         * @return The path to the key store (typically .jks). Can use classpath: and file:.
          */
         public Optional<String> getPath() {
             return Optional.ofNullable(path);
@@ -411,11 +404,9 @@ public class SslConfiguration implements Toggleable {
         }
 
         /**
-         * The path to the key store (typically .jks). Can also point to a PEM file containing
-         * a private key followed by the X.509 trust chain. Can use {@code classpath:},
-         * {@code file:}, {@code string:} or {@code base64:}.
+         * Sets the path.
          *
-         * @param path The resource containing the key store
+         * @param path The path
          */
         public void setPath(String path) {
             this.path = path;
@@ -447,56 +438,6 @@ public class SslConfiguration implements Toggleable {
         public void setProvider(String provider) {
             this.provider = provider;
         }
-
-        /**
-         * A path to a PEM file containing the private key of the server. Can use
-         * {@code classpath:}, {@code file:}, {@code string:} or {@code base64:}. Cannot be set at
-         * the same time as the {@code path} property.
-         *
-         * @return The key path
-         * @since 4.10.0
-         */
-        @Nullable
-        public String getKeyPath() {
-            return keyPath;
-        }
-
-        /**
-         * A path to a PEM file containing the private key. Can use
-         * {@code classpath:}, {@code file:}, {@code string:} or {@code base64:}. Cannot be set at
-         * the same time as the {@code path} property.
-         *
-         * @param keyPath The key path
-         * @since 4.10.0
-         */
-        public void setKeyPath(@Nullable String keyPath) {
-            this.keyPath = keyPath;
-        }
-
-        /**
-         * A path to a PEM file containing the certificate chain. Can use
-         * {@code classpath:}, {@code file:}, {@code string:} or {@code base64:}. Cannot be set at
-         * the same time as the {@code path} property.
-         *
-         * @return The certificate chain path
-         * @since 4.10.0
-         */
-        @Nullable
-        public String getCertificatePath() {
-            return certificatePath;
-        }
-
-        /**
-         * A path to a PEM file containing the certificate chain. Can use
-         * {@code classpath:}, {@code file:}, {@code string:} or {@code base64:}. Cannot be set at
-         * the same time as the {@code path} property.
-         *
-         * @param certificatePath The certificate chain path
-         * @since 4.10.0
-         */
-        public void setCertificatePath(@Nullable String certificatePath) {
-            this.certificatePath = certificatePath;
-        }
     }
 
     /**
@@ -510,11 +451,7 @@ public class SslConfiguration implements Toggleable {
         private String provider;
 
         /**
-         * The path to the trust store (typically .jks). Can also point to a PEM file containing
-         * one or more X.509 certificates. Can use {@code classpath:}, {@code file:},
-         * {@code string:} or {@code base64:}.
-         *
-         * @return The resource containing the trust store
+         * @return The path to the trust store (typically .jks). Can use classpath: and file:.
          */
         public Optional<String> getPath() {
             return Optional.ofNullable(path);
@@ -542,11 +479,9 @@ public class SslConfiguration implements Toggleable {
         }
 
         /**
-         * The path to the trust store (typically .jks). Can also point to a PEM file containing
-         * one or more X.509 certificates. Can use {@code classpath:}, {@code file:},
-         * {@code string:} or {@code base64:}.
+         * Sets the path.
          *
-         * @param path The resource containing the trust store
+         * @param path The path
          */
         public void setPath(String path) {
             this.path = path;
diff --git a/http/src/main/java/io/micronaut/http/util/HttpHeadersUtil.java b/http/src/main/java/io/micronaut/http/util/HttpHeadersUtil.java
index 55946c77dd..2521faa123 100644
--- a/http/src/main/java/io/micronaut/http/util/HttpHeadersUtil.java
+++ b/http/src/main/java/io/micronaut/http/util/HttpHeadersUtil.java
@@ -39,7 +39,7 @@ import java.util.regex.Pattern;
  * @since 3.8.0
  */
 public final class HttpHeadersUtil {
-    private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
+    private final static Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
     private static final Supplier<Pattern> HEADER_MASK_PATTERNS = SupplierUtil.memoized(() ->
         Pattern.compile(".*(password|cred|cert|key|secret|token|auth|signat).*", Pattern.CASE_INSENSITIVE)
     );
diff --git a/http/src/test/java/io/micronaut/http/ssl/PemParserTest.java b/http/src/test/java/io/micronaut/http/ssl/PemParserTest.java
deleted file mode 100644
index 3d3f222f04..0000000000
--- a/http/src/test/java/io/micronaut/http/ssl/PemParserTest.java
+++ /dev/null
@@ -1,179 +0,0 @@
-package io.micronaut.http.ssl;
-
-import org.junit.jupiter.api.Test;
-
-import java.math.BigInteger;
-import java.security.interfaces.ECPrivateKey;
-import java.security.interfaces.RSAPrivateKey;
-import java.util.List;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertInstanceOf;
-
-class PemParserTest {
-    @Test
-    public void pkcs8Rsa() throws Exception {
-        List<Object> items = new PemParser(null, null).loadPem("""
-            -----BEGIN PRIVATE KEY-----
-            MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDQUMBfdIw9YCnu
-            FdXDV1cePcXwmc9C9z/BRBK8EmqtGHSGNUjpCHKKGPXJXUseQ7xZNeZdl9CEhZDv
-            LTLghIrKJXod/fh0K0FzukJUQwGXBMHxf5FUMUuzZ1FAVHYO44S3Qj+vTMd1BAbK
-            jjB+Od9bj5UN9Ab8zG4mTV6wXNX84bsbV6SXqakwR5gJ5GAeOYGf1uHG+o54LobY
-            C2857Bsa4bbtleCaXDhJ9K417iNTvP0I/F1C2fQyjwEcOvvI/UHj8nBdCSubiwgv
-            JRGv5NbJkZREUAffKiEZwfP1Jeb5/zBdELnlVNk9vjRrXQV5nwzijxFFVNwgC1KW
-            TNT2q7xhAgMBAAECggEADUXJ3gMbYNk4zrM8M5Yj5ji+HPx1ztDZUm9riKldO+Ji
-            IT9xoexgfOFGfsIXlEnxTRdQsk+nENyAPab59gFn5OWSpGjPPNqZMN4SFhOPXT+H
-            umL7/9rktX1smT5QZ9Yx+WmqjFkmX7OmGZ+J4i7+htNNBk6xJ8gAMCdPlEnT9gjP
-            1T4o5i7Bxo6bPKW20CKhHCoX6sLy9IyQbOVCm4ZM+/xQBDOIH06IpQzfTBtK8p5z
-            GAEmISBJdkIzVydZo++3PW5R33LORCuROLE8eO/FapxxHfXt/HFG67NKJHj0Mxks
-            PY3wEE5MMY3uEi4BpMXG4p1YbWAxiWWCcTdzO1t1uQKBgQD7vRuYRjbuLRJzoATR
-            6uyknUByxiRnwl1UyXpRNeikktb2h9CRjkkeofDUnR0O7Fc9xlplb+3F8xAnjAYy
-            fSG9EygMnnpaVTntkM9jjbfwWOLNL9TkbfkYh5+NXKx4+kGH9x64qY9QYVVx2dIx
-            7A9VJGlR/WULHK/Mod9lvqFtWQKBgQDT13jRnhjJSx0u8WnQxmW/P/2aRdL5Dwjj
-            Txr38O/d6P2IJ3KxBRdbQDwMXIWyrSg6BHV+/9AefTE2WMt+lRdeJtsfm1sk/hNI
-            BEElrnjPBxSUzEW+BfR+C98ziGXkeU63FzETdyRLSyuTDj0HimDUjn07PYHJ+PSM
-            +9RSBmg+SQKBgBWEqrEvf06Ip8UebosLC8Nedb3Z1g7QfG3c8wmyE/rNWnakUV2/
-            zdxCd3WVIIDADw0GwX9eO/Lpvf3DaFw0egfRdWDuwwKpulPmRvP5jzmKP4jOh+Im
-            zF4eabMJsux8Z9GZfBTI2alDSKx8tAz0YrMic6ZAhLyYbSaOx6vIyb+xAoGAXuZl
-            Mop/khV7Ql9VxvhJ9m5FPspO49IPaj0y2KXv3tqUUV1SrOiZ+QACposAPfYCUlNT
-            C4ywACiXVkBbER7bNAt2GGexYhYMLzPwt1+8sQn791i3WZQzXhAVcnGFK+AIGk9i
-            ZdT2xmArahpzzp/4FuCqS1KXhRJpA4uBJynFozkCgYBz+TyFWuhdML06ZEJPxKmC
-            e7LHsyxOXZGoIhTqB0XARXMA8gSt4wdrtrN8koQlmiWN5LfotAlfbykV2ZKpCdgX
-            eGmFzaDSoenJqIRAiI4OrK2ukrVaW9qD1Vff/md1Uzc1dYwUkWqNp8v7vPx2HQBC
-            ldYFCJQ8/XLS7ujXEiv0Ew==
-            -----END PRIVATE KEY-----
-            """);
-        assertEquals(1, items.size());
-        RSAPrivateKey key = assertInstanceOf(RSAPrivateKey.class, items.get(0));
-        assertEquals(
-            new BigInteger("26297387460268743102040457553165546239149094073239005348955226939098208217753988833267081884139652198696702484480896788225411092939518395692664601066047035464528971551454681842404423845080452443932201241792678847434609059497058970345580274942990400089461450945614514109876737615683212442747283594923682775945848729148001127174636677520541003716154359434674620933723722605237477921059532399313874922023205627380134050262110566006600639431959394448635199072282414496382001596281606276405706915358620713649067936308458079204732199243773136651525293676965024281822823055882102207432170133026926355690324977137843826310241"),
-            key.getModulus());
-    }
-
-    @Test
-    public void pkcs1Rsa() throws Exception {
-        List<Object> items = new PemParser(null, null).loadPem("""
-            -----BEGIN RSA PRIVATE KEY-----
-            MIIEogIBAAKCAQEA0FDAX3SMPWAp7hXVw1dXHj3F8JnPQvc/wUQSvBJqrRh0hjVI
-            6Qhyihj1yV1LHkO8WTXmXZfQhIWQ7y0y4ISKyiV6Hf34dCtBc7pCVEMBlwTB8X+R
-            VDFLs2dRQFR2DuOEt0I/r0zHdQQGyo4wfjnfW4+VDfQG/MxuJk1esFzV/OG7G1ek
-            l6mpMEeYCeRgHjmBn9bhxvqOeC6G2AtvOewbGuG27ZXgmlw4SfSuNe4jU7z9CPxd
-            Qtn0Mo8BHDr7yP1B4/JwXQkrm4sILyURr+TWyZGURFAH3yohGcHz9SXm+f8wXRC5
-            5VTZPb40a10FeZ8M4o8RRVTcIAtSlkzU9qu8YQIDAQABAoIBAA1Fyd4DG2DZOM6z
-            PDOWI+Y4vhz8dc7Q2VJva4ipXTviYiE/caHsYHzhRn7CF5RJ8U0XULJPpxDcgD2m
-            +fYBZ+TlkqRozzzamTDeEhYTj10/h7pi+//a5LV9bJk+UGfWMflpqoxZJl+zphmf
-            ieIu/obTTQZOsSfIADAnT5RJ0/YIz9U+KOYuwcaOmzylttAioRwqF+rC8vSMkGzl
-            QpuGTPv8UAQziB9OiKUM30wbSvKecxgBJiEgSXZCM1cnWaPvtz1uUd9yzkQrkTix
-            PHjvxWqccR317fxxRuuzSiR49DMZLD2N8BBOTDGN7hIuAaTFxuKdWG1gMYllgnE3
-            cztbdbkCgYEA+70bmEY27i0Sc6AE0erspJ1AcsYkZ8JdVMl6UTXopJLW9ofQkY5J
-            HqHw1J0dDuxXPcZaZW/txfMQJ4wGMn0hvRMoDJ56WlU57ZDPY4238FjizS/U5G35
-            GIefjVysePpBh/ceuKmPUGFVcdnSMewPVSRpUf1lCxyvzKHfZb6hbVkCgYEA09d4
-            0Z4YyUsdLvFp0MZlvz/9mkXS+Q8I408a9/Dv3ej9iCdysQUXW0A8DFyFsq0oOgR1
-            fv/QHn0xNljLfpUXXibbH5tbJP4TSARBJa54zwcUlMxFvgX0fgvfM4hl5HlOtxcx
-            E3ckS0srkw49B4pg1I59Oz2Byfj0jPvUUgZoPkkCgYAVhKqxL39OiKfFHm6LCwvD
-            XnW92dYO0Hxt3PMJshP6zVp2pFFdv83cQnd1lSCAwA8NBsF/Xjvy6b39w2hcNHoH
-            0XVg7sMCqbpT5kbz+Y85ij+IzofiJsxeHmmzCbLsfGfRmXwUyNmpQ0isfLQM9GKz
-            InOmQIS8mG0mjseryMm/sQKBgF7mZTKKf5IVe0JfVcb4SfZuRT7KTuPSD2o9Mtil
-            797alFFdUqzomfkAAqaLAD32AlJTUwuMsAAol1ZAWxEe2zQLdhhnsWIWDC8z8Ldf
-            vLEJ+/dYt1mUM14QFXJxhSvgCBpPYmXU9sZgK2oac86f+BbgqktSl4USaQOLgScp
-            xaM5AoGAc/k8hVroXTC9OmRCT8Spgnuyx7MsTl2RqCIU6gdFwEVzAPIEreMHa7az
-            fJKEJZoljeS36LQJX28pFdmSqQnYF3hphc2g0qHpyaiEQIiODqytrpK1Wlvag9VX
-            3/5ndVM3NXWMFJFqjafL+7z8dh0AQpXWBQiUPP1y0u7o1xIr9BM=
-            -----END RSA PRIVATE KEY-----""");
-        assertEquals(1, items.size());
-        RSAPrivateKey key = assertInstanceOf(RSAPrivateKey.class, items.get(0));
-        assertEquals(
-            new BigInteger("26297387460268743102040457553165546239149094073239005348955226939098208217753988833267081884139652198696702484480896788225411092939518395692664601066047035464528971551454681842404423845080452443932201241792678847434609059497058970345580274942990400089461450945614514109876737615683212442747283594923682775945848729148001127174636677520541003716154359434674620933723722605237477921059532399313874922023205627380134050262110566006600639431959394448635199072282414496382001596281606276405706915358620713649067936308458079204732199243773136651525293676965024281822823055882102207432170133026926355690324977137843826310241"),
-            key.getModulus());
-    }
-
-    @Test
-    public void pkcs8RsaEncrypted() throws Exception {
-        List<Object> items = new PemParser(null, "test").loadPem("""
-            -----BEGIN ENCRYPTED PRIVATE KEY-----
-            MIIFLTBXBgkqhkiG9w0BBQ0wSjApBgkqhkiG9w0BBQwwHAQI8fC1f/DgmSkCAggA
-            MAwGCCqGSIb3DQIJBQAwHQYJYIZIAWUDBAEqBBC8I/1f9JZBR1Qc7Zi10TsHBIIE
-            0KvNo6nkBWi0yP+x+GlZ9I+p6dSTb4mNWXEgG+Bl3EFBaNd6V5vmlKfkYaMEW9x8
-            jBaexEN8J/dxtkbn434dMQYdsn8l3wlA7NasirY4JQQrQqkf4UEN/+UH6xFeyb+W
-            clS/uvi9yuXWTN4XBfNntZAjlVBi4wgviLliqPJfB/ThmDfF+kF/ZItYvBpsZ9iz
-            TouONUs1evEHDSfyNz9ZPpH8ez8ea2v5NfmCUOP6fARuiff0r/uF5XH9zEiZtLpy
-            BgGN5KpWyzb8MWJumZMMJOhhjn72WV1lchRdHRT2a6Joag0d7INiF4oN3D1gnfHP
-            WDOdRxRwYD3eA1UB7OpVvDY7rTkITZrGXttLy9TnADlDhwDEeos6Rq3B1gJa1+u8
-            qjjhvyQLzs/8gmRYku0v+4l6yfbOp0MBKM3NxmDsHZdp3LGDtDsUk81guXYA4TdX
-            D+5nTkQEM728f/0Wj6u9GuKL2BNd1AIcxeh6QIMUAoceDrEoLslBHLSvLtYDgtuN
-            If+ZAJviCvfxkwTQdwdJqqAEr70up38d+JclO2OjI34n2CFaqSQV3HVbF5pe7lw4
-            adi/0vNzkVhCGu1KQFsTbBMzEmFjSnI0zECbXh+5BsGNITRQTq29zoc174ZMS0z7
-            C42nUQrbgSdieNax57dzGh1tnUz7FlJuyGEdCkaU/npLRKZOK3eQ6irFNaDY5M35
-            xm0B9ZlRBqZYsjMAhUrDY41FHE+WuLi98ha9IKi6D5Mdqapjb7D/fYyQkmORgYQM
-            kxsjpB2OM2tRLK5cPSFVlhz+uMdKUN9/y1YTrZ8tkjAcDdc6AIe62p9C5Hmmc0Eg
-            DvgEfHQ6QVxy7xv1o42P937NNWe7mAyERnRtxREtPoQKgGteWAHALn0r4J/oDqi+
-            vX9AD+6fAN68tIYOe/nDcd8ALeDQ0CdZAguhZdLNjPCN7h96+3Dhd1E09L3VQi2c
-            LNy6P1gBq2YYv1xbQgUDh7ukFyafA81MQirthzRh9W5auH7OH//astJ6F4Df1N77
-            lUVALbinBPdxiPZKTRdFRN09XABj8a8Pb5UtIobokthlsq134RSNqNIOh8qgfzOC
-            xB/ibpcdYJVg1rZyA2WDchAdxtsUO7y2wfeo9zhnL6Bc4uxaoDZioY2ZNnU/Ctv7
-            aEr/rmnYegelK+xTz4MoqzxnwtUoRXmXC/GkG9JzXbEy3hW53sl3lRNsxjHMTgqk
-            vyRO9TYjpfhh65p8z5NuxmBEC2rl8cYwAfm13F+eHrMRTSmd5vL6/XpqP3m40GB2
-            eR7vOGpWpodonLY/l8uAuGHrotC07N6aLcQrHC8O60l6I5Ngqr+oBKbe8+8eIavS
-            Z/u7QFgvA3iQaftad5uQ0yxIArl28Er5ARcnvvWoIOAjkGf2yKu8kILpq9BfooS4
-            uok3vpNQHXx68ZptFQebu9P+PRfoXL33CcVI9uL6aU2t4mejHWwBsc1jZ6iTw6yc
-            I6dV5c+U5+u18bbs8Q29kIqCy9WMexSQBzIwHMEqcI/Dqj/9ThQ66NqD3EgkQPz/
-            ngZdLXnLfn1TVXXOJYt+WnvuTqzoU+GOFTeIN074q8mRqwMxel2z6+rGTpV9aQES
-            Tt6cARs4hU2l4D+1Fli2oE2eWnyROI+lvF+jg+HPgUhm
-            -----END ENCRYPTED PRIVATE KEY-----""");
-        assertEquals(1, items.size());
-        RSAPrivateKey key = assertInstanceOf(RSAPrivateKey.class, items.get(0));
-        assertEquals(
-            new BigInteger("26297387460268743102040457553165546239149094073239005348955226939098208217753988833267081884139652198696702484480896788225411092939518395692664601066047035464528971551454681842404423845080452443932201241792678847434609059497058970345580274942990400089461450945614514109876737615683212442747283594923682775945848729148001127174636677520541003716154359434674620933723722605237477921059532399313874922023205627380134050262110566006600639431959394448635199072282414496382001596281606276405706915358620713649067936308458079204732199243773136651525293676965024281822823055882102207432170133026926355690324977137843826310241"),
-            key.getModulus());
-    }
-
-    @Test
-    public void pkcs8Ec() throws Exception {
-        List<Object> items = new PemParser(null, null).loadPem("""
-            -----BEGIN PRIVATE KEY-----
-            MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgbsCIeD2F110ZVzZI
-            KSSZ+96uasIw1LmMA+5OPexz0gahRANCAARF/wP8UhdiQFqdlKck8H9b6PpgYfpB
-            TgURPRWudxoA1vlKYYxT09FXyL0OOit5GSn/N1f9hBKT42sJ7nParbMi
-            -----END PRIVATE KEY-----
-            """);
-        assertEquals(1, items.size());
-        ECPrivateKey key = assertInstanceOf(ECPrivateKey.class, items.get(0));
-        assertEquals(
-            new BigInteger("6EC088783D85D75D19573648292499FBDEAE6AC230D4B98C03EE4E3DEC73D206", 16),
-            key.getS());
-    }
-
-    @Test
-    public void pkcs8EcEncrypted() throws Exception {
-        List<Object> items = new PemParser(null, "test").loadPem("""
-            -----BEGIN ENCRYPTED PRIVATE KEY-----
-            MIHsMFcGCSqGSIb3DQEFDTBKMCkGCSqGSIb3DQEFDDAcBAjg1EB+ARfutQICCAAw
-            DAYIKoZIhvcNAgkFADAdBglghkgBZQMEASoEEAhVYdST1gTXVLoOtJGRLdEEgZBN
-            rwo6vVFu/87G30sn2VJK97OKJTDBQOY52Sz/EUDqgpxFWmz7+DLhjN6YUCi+HO4r
-            lgoMk1J1pQLp7zZzaronV3P8tPo+LVyLN6sohGUvzAis1l/q59eokTPm1zl1T5f+
-            ZX3k3LQLdWEK8ifI66ssIrO5P2ksSxGll4hPz0fkWzH2mKAD5sBJ5vyoJ3mjqbI=
-            -----END ENCRYPTED PRIVATE KEY-----
-            """);
-        assertEquals(1, items.size());
-        ECPrivateKey key = assertInstanceOf(ECPrivateKey.class, items.get(0));
-        assertEquals(
-            new BigInteger("6EC088783D85D75D19573648292499FBDEAE6AC230D4B98C03EE4E3DEC73D206", 16),
-            key.getS());
-    }
-
-    @Test
-    public void pkcs1Ec() throws Exception {
-        List<Object> items = new PemParser(null, null).loadPem("""
-            -----BEGIN EC PRIVATE KEY-----
-            MHcCAQEEIG7AiHg9hdddGVc2SCkkmfvermrCMNS5jAPuTj3sc9IGoAoGCCqGSM49
-            AwEHoUQDQgAERf8D/FIXYkBanZSnJPB/W+j6YGH6QU4FET0VrncaANb5SmGMU9PR
-            V8i9DjoreRkp/zdX/YQSk+NrCe5z2q2zIg==
-            -----END EC PRIVATE KEY-----
-            """);
-        assertEquals(1, items.size());
-        ECPrivateKey key = assertInstanceOf(ECPrivateKey.class, items.get(0));
-        assertEquals(
-            new BigInteger("6EC088783D85D75D19573648292499FBDEAE6AC230D4B98C03EE4E3DEC73D206", 16),
-            key.getS());
-    }
-}
diff --git a/src/main/docs/guide/httpServer/serverConfiguration/https.adoc b/src/main/docs/guide/httpServer/serverConfiguration/https.adoc
index dc4fe8a362..04fd50bff3 100644
--- a/src/main/docs/guide/httpServer/serverConfiguration/https.adoc
+++ b/src/main/docs/guide/httpServer/serverConfiguration/https.adoc
@@ -28,42 +28,7 @@ image::https-warning.jpg[]
 
 == Using a valid x509 certificate
 
-It is also possible to configure a Micronaut application to use an existing valid x509 certificate, for example one created with https://letsencrypt.org/[Let's Encrypt]. You will need the `server.crt` and `server.key` files.
-
-.HTTPS Configuration Example
-[configuration]
-----
-micronaut:
-  ssl:
-    enabled: true
-    key-store:
-      key-path: classpath:server.key
-      certificate-path: classpath:server.crt
-----
-
-NOTE: Instead of `classpath:` or `file:`, the PEM can also be specified directly as a string using the `string:` prefix. See the <<resources,Resources>> section.
-
-With this configuration, if we start a Micronaut application and connect to `https://localhost:8443` we still see the warning in the browser, but if we inspect the certificate we can check that it is the one generated by Let's Encrypt.
-
-image::https-certificate.jpg[]
-
-Finally, we can test that the certificate is valid for the browser by adding an alias to the domain in `/etc/hosts` file:
-
-[source,bash]
-----
-$ cat /etc/hosts
-...
-127.0.0.1   my-domain.org
-...
-----
-
-Now we can connect to `https://my-domain.org:8443`:
-
-image::https-valid-certificate.jpg[]
-
-== Using a PKCS#12 key store
-
-The more traditional approach to managing certificates in Java is with a key store, either in PKCS#12 or the older JKS format. You can convert your PEM files to PKCS#12 as follows:
+It is also possible to configure a Micronaut application to use an existing valid x509 certificate, for example one created with https://letsencrypt.org/[Let's Encrypt]. You will need the `server.crt` and `server.key` files and to convert them to a PKCS #12 file.
 
 [source,bash]
 ----
@@ -79,7 +44,9 @@ $ openssl pkcs12 -export \
 <3> The `server.p12` file to create
 <4> The alias for the certificate
 
-The configuration:
+During the creation of the `server.p12` file it is necessary to define a password that will be required later when using the certificate in Micronaut.
+
+Now modify your configuration:
 
 .HTTPS Configuration Example
 [configuration]
@@ -95,9 +62,29 @@ micronaut:
 - Specify the `p12` file path. It can also be referenced as `file:/path/to/the/file`
 - Also provide the `password` defined during the export
 
-== Using a JKS key store
+With this configuration, if we start a Micronaut application and connect to `https://localhost:8443` we still see the warning in the browser, but if we inspect the certificate we can check that it is the one generated by Let's Encrypt.
+
+image::https-certificate.jpg[]
+
+Finally, we can test that the certificate is valid for the browser by adding an alias to the domain in `/etc/hosts` file:
+
+[source,bash]
+----
+$ cat /etc/hosts
+...
+127.0.0.1   my-domain.org
+...
+----
+
+Now we can connect to `https://my-domain.org:8443`:
+
+image::https-valid-certificate.jpg[]
+
+== Using Java Keystore (JKS)
+
+Using this type of certificate is not recommended because the format is proprietary - PKCS12 format is preferred. Regardless, the Micronaut framework also supports it.
 
-You can optionally convert the `p12` store to a JKS one:
+Convert the `p12` certificate to a JKS one:
 
 [source,bash]
 ----
