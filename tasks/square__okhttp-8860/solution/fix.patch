diff --git a/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt b/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt
index 3335e6943..d6813ff4b 100644
--- a/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt
+++ b/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt
@@ -102,9 +102,9 @@ internal fun mockwebserver3.RecordedRequest.unwrap(): RecordedRequest =
     sequenceNumber = sequenceNumber,
     failure = failure,
     method = method,
-    path = path,
+    path = url.encodedPath,
     handshake = handshake,
-    requestUrl = requestUrl,
+    requestUrl = url,
   )
 
 private fun MockResponse.wrapSocketPolicy(): mockwebserver3.SocketPolicy =
diff --git a/mockwebserver/api/mockwebserver3.api b/mockwebserver/api/mockwebserver3.api
index 9423c2c0a..0a0a9a58b 100644
--- a/mockwebserver/api/mockwebserver3.api
+++ b/mockwebserver/api/mockwebserver3.api
@@ -145,8 +145,8 @@ public class mockwebserver3/QueueDispatcher : mockwebserver3/Dispatcher {
 }
 
 public final class mockwebserver3/RecordedRequest {
-	public fun <init> (ILokhttp3/Handshake;Ljava/util/List;Lokhttp3/HttpUrl;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lokhttp3/Headers;Lokio/ByteString;JLjava/util/List;Ljava/io/IOException;)V
-	public synthetic fun <init> (ILokhttp3/Handshake;Ljava/util/List;Lokhttp3/HttpUrl;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lokhttp3/Headers;Lokio/ByteString;JLjava/util/List;Ljava/io/IOException;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun <init> (ILokhttp3/Handshake;Ljava/util/List;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lokhttp3/HttpUrl;Lokhttp3/Headers;Lokio/ByteString;JLjava/util/List;Ljava/io/IOException;)V
+	public synthetic fun <init> (ILokhttp3/Handshake;Ljava/util/List;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lokhttp3/HttpUrl;Lokhttp3/Headers;Lokio/ByteString;JLjava/util/List;Ljava/io/IOException;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
 	public final fun getBody ()Lokio/ByteString;
 	public final fun getBodySize ()J
 	public final fun getChunkSizes ()Ljava/util/List;
@@ -155,10 +155,11 @@ public final class mockwebserver3/RecordedRequest {
 	public final fun getHandshakeServerNames ()Ljava/util/List;
 	public final fun getHeaders ()Lokhttp3/Headers;
 	public final fun getMethod ()Ljava/lang/String;
-	public final fun getPath ()Ljava/lang/String;
 	public final fun getRequestLine ()Ljava/lang/String;
-	public final fun getRequestUrl ()Lokhttp3/HttpUrl;
 	public final fun getSequenceNumber ()I
+	public final fun getTarget ()Ljava/lang/String;
+	public final fun getUrl ()Lokhttp3/HttpUrl;
+	public final fun getVersion ()Ljava/lang/String;
 	public fun toString ()Ljava/lang/String;
 }
 
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
index 6695ba5ed..aeae2723a 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
@@ -63,9 +63,12 @@ import mockwebserver3.SocketPolicy.ShutdownInputAtEnd
 import mockwebserver3.SocketPolicy.ShutdownOutputAtEnd
 import mockwebserver3.SocketPolicy.ShutdownServerAfterResponse
 import mockwebserver3.SocketPolicy.StallSocketAtStart
+import mockwebserver3.internal.DEFAULT_REQUEST_LINE
 import mockwebserver3.internal.RecordedRequest
+import mockwebserver3.internal.RequestLine
 import mockwebserver3.internal.ThrottledSink
 import mockwebserver3.internal.TriggerSink
+import mockwebserver3.internal.decodeRequestLine
 import mockwebserver3.internal.sleepWhileOpen
 import okhttp3.Headers
 import okhttp3.Headers.Companion.headersOf
@@ -657,7 +660,7 @@ public class MockWebServer : Closeable {
   ) {
     val request =
       RecordedRequest(
-        "",
+        DEFAULT_REQUEST_LINE,
         headersOf(),
         emptyList(),
         0L,
@@ -678,7 +681,7 @@ public class MockWebServer : Closeable {
     sink: BufferedSink,
     sequenceNumber: Int,
   ): RecordedRequest {
-    var request = ""
+    var request: RequestLine = DEFAULT_REQUEST_LINE
     val headers = Headers.Builder()
     var contentLength = -1L
     var chunked = false
@@ -687,10 +690,11 @@ public class MockWebServer : Closeable {
     var failure: IOException? = null
 
     try {
-      request = source.readUtf8LineStrict()
-      if (request.isEmpty()) {
+      val requestLineString = source.readUtf8LineStrict()
+      if (requestLineString.isEmpty()) {
         throw ProtocolException("no request because the stream is exhausted")
       }
+      request = decodeRequestLine(requestLineString)
 
       while (true) {
         val header = source.readUtf8LineStrict()
@@ -753,8 +757,7 @@ public class MockWebServer : Closeable {
         }
       }
 
-      val method = request.substringBefore(' ')
-      require(!hasBody || HttpMethod.permitsRequestBody(method)) {
+      require(!hasBody || HttpMethod.permitsRequestBody(request.method)) {
         "Request must not have a body: $request"
       }
     } catch (e: IOException) {
@@ -829,7 +832,7 @@ public class MockWebServer : Closeable {
         minimumDeflateSize = 0L,
         webSocketCloseTimeout = RealWebSocket.CANCEL_AFTER_CLOSE_MILLIS,
       )
-    val name = "MockWebServer WebSocket ${request.path!!}"
+    val name = "MockWebServer WebSocket ${request.url.encodedPath}"
     webSocket.initReaderAndWriter(name, streams)
     try {
       webSocket.loopReader(fancyResponse)
@@ -1052,7 +1055,12 @@ public class MockWebServer : Closeable {
       }
 
       val body = Buffer()
-      val requestLine = "$method $path HTTP/1.1"
+      val requestLine =
+        RequestLine(
+          method = method,
+          target = path,
+          version = "HTTP/1.1",
+        )
       var exception: IOException? = null
       if (readBody && peek.socketHandler == null && peek.socketPolicy !is DoNotReadRequestBody) {
         try {
@@ -1171,7 +1179,12 @@ public class MockWebServer : Closeable {
         for ((name, value) in pushPromiseHeaders) {
           pushedHeaders.add(Header(name, value))
         }
-        val requestLine = "${pushPromise.method} ${pushPromise.path} HTTP/1.1"
+        val requestLine =
+          RequestLine(
+            method = pushPromise.method,
+            target = pushPromise.path,
+            version = "HTTP/1.1",
+          )
         val chunkSizes = emptyList<Int>() // No chunked encoding for HTTP/2.
         requestQueue.add(
           RecordedRequest(
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/RecordedRequest.kt b/mockwebserver/src/main/kotlin/mockwebserver3/RecordedRequest.kt
index 0271d6e3e..a9ebc77a2 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/RecordedRequest.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/RecordedRequest.kt
@@ -42,10 +42,24 @@ public class RecordedRequest(
    * cleartext and may be monitored or blocked by a proxy or other middlebox.
    */
   public val handshakeServerNames: List<String>,
-  public val requestUrl: HttpUrl?,
-  public val requestLine: String,
-  public val method: String?,
-  public val path: String?,
+  public val method: String,
+  /**
+   * The request target from the original HTTP request.
+   *
+   * For origin-form requests this is a path like `/index.html`, that is combined with the `Host`
+   * header to create the request URL.
+   *
+   * For HTTP proxy requests this will be either an absolute-form string like
+   * `http://example.com/index.html` (HTTP proxy) or an authority-form string like
+   * `example.com:443` (HTTPS proxy).
+   *
+   * For OPTIONS requests, this may be an asterisk, `*`.
+   */
+  public val target: String,
+  /** A string like `HTTP/1.1`. */
+  public val version: String,
+  /** The request URL built using the request line, headers, and local host name. */
+  public val url: HttpUrl,
   /** All headers. */
   public val headers: Headers,
   /** The body of this request, or [ByteString.EMPTY] if it has none. This may be truncated. */
@@ -63,5 +77,8 @@ public class RecordedRequest(
    */
   public val failure: IOException? = null,
 ) {
+  public val requestLine: String
+    get() = "$method $target $version"
+
   public override fun toString(): String = requestLine
 }
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/internal/RecordedRequestFactory.kt b/mockwebserver/src/main/kotlin/mockwebserver3/internal/RecordedRequestFactory.kt
index d832a525a..000de9712 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/internal/RecordedRequestFactory.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/internal/RecordedRequestFactory.kt
@@ -17,6 +17,7 @@ package mockwebserver3.internal
 
 import java.io.IOException
 import java.net.Inet6Address
+import java.net.ProtocolException
 import java.net.Socket
 import javax.net.ssl.SSLSocket
 import mockwebserver3.RecordedRequest
@@ -24,12 +25,13 @@ import okhttp3.Handshake
 import okhttp3.Handshake.Companion.handshake
 import okhttp3.Headers
 import okhttp3.HttpUrl
+import okhttp3.HttpUrl.Companion.toHttpUrl
 import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
 import okhttp3.internal.platform.Platform
 import okio.Buffer
 
 internal fun RecordedRequest(
-  requestLine: String,
+  requestLine: RequestLine,
   headers: Headers,
   chunkSizes: List<Int>,
   bodySize: Long,
@@ -52,45 +54,22 @@ internal fun RecordedRequest(
     handshakeServerNames = listOf()
   }
 
-  val requestUrl: HttpUrl?
-  val method: String?
-  val path: String?
-  if (requestLine.isNotEmpty()) {
-    val methodEnd = requestLine.indexOf(' ')
-    val urlEnd = requestLine.indexOf(' ', methodEnd + 1)
-    method = requestLine.substring(0, methodEnd)
-    var urlPart = requestLine.substring(methodEnd + 1, urlEnd)
-    if (!urlPart.startsWith("/")) {
-      urlPart = "/"
+  val requestUrl =
+    when (requestLine.method) {
+      "CONNECT" -> "${socket.scheme}://${requestLine.target}/".toHttpUrlOrNull()
+      else -> null
     }
-    path = urlPart
-
-    val scheme = if (socket is SSLSocket) "https" else "http"
-    val localPort = socket.localPort
-    val hostAndPort =
-      headers[":authority"]
-        ?: headers["Host"]
-        ?: when (val inetAddress = socket.localAddress) {
-          is Inet6Address -> "[${inetAddress.hostAddress}]:$localPort"
-          else -> "${inetAddress.hostAddress}:$localPort"
-        }
-
-    // Allow null in failure case to allow for testing bad requests
-    requestUrl = "$scheme://$hostAndPort$path".toHttpUrlOrNull()
-  } else {
-    requestUrl = null
-    method = null
-    path = null
-  }
+      ?: requestLine.target.toHttpUrlOrNull()
+      ?: requestUrl(socket, requestLine, headers)
 
   return RecordedRequest(
     sequenceNumber = sequenceNumber,
     handshake = handshake,
     handshakeServerNames = handshakeServerNames,
-    requestUrl = requestUrl,
-    requestLine = requestLine,
-    method = method,
-    path = path,
+    method = requestLine.method,
+    target = requestLine.target,
+    version = requestLine.version,
+    url = requestUrl,
     headers = headers,
     body = body.readByteString(),
     bodySize = bodySize,
@@ -98,3 +77,66 @@ internal fun RecordedRequest(
     failure = failure,
   )
 }
+
+internal fun decodeRequestLine(requestLine: String?): RequestLine {
+  val parts =
+    when {
+      requestLine != null -> requestLine.split(' ', limit = 3)
+      else -> return DEFAULT_REQUEST_LINE
+    }
+
+  if (parts.size != 3) {
+    throw ProtocolException("unexpected request line: $requestLine")
+  }
+
+  return RequestLine(
+    method = parts[0],
+    target = parts[1],
+    version = parts[2],
+  )
+}
+
+internal class RequestLine(
+  val method: String,
+  val target: String,
+  val version: String,
+) {
+  override fun toString() = "$method $target $version"
+}
+
+internal val DEFAULT_REQUEST_LINE =
+  RequestLine(
+    method = "GET",
+    target = "/",
+    version = "HTTP/1.1",
+  )
+
+private val Socket.scheme: String
+  get() =
+    when (this) {
+      is SSLSocket -> "https"
+      else -> "http"
+    }
+
+private fun requestUrl(
+  socket: Socket,
+  requestLine: RequestLine,
+  headers: Headers,
+): HttpUrl {
+  val hostAndPort =
+    headers[":authority"]
+      ?: headers["Host"]
+      ?: when (val inetAddress = socket.localAddress) {
+        is Inet6Address -> "[${inetAddress.hostAddress}]:${socket.localPort}"
+        else -> "${inetAddress.hostAddress}:${socket.localPort}"
+      }
+
+  // For OPTIONS, the request target may be a '*', like 'OPTIONS * HTTP/1.1'.
+  val path =
+    when {
+      requestLine.method == "OPTIONS" && requestLine.target == "*" -> "/"
+      else -> requestLine.target
+    }
+
+  return "${socket.scheme}://$hostAndPort$path".toHttpUrl()
+}
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RequestLine.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RequestLine.kt
index 6fd058ba7..426bfb4df 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RequestLine.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RequestLine.kt
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.http
 
-import java.net.HttpURLConnection
 import java.net.Proxy
 import okhttp3.HttpUrl
 import okhttp3.Request
