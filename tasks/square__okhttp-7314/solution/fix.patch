diff --git a/mockwebserver/api/mockwebserver3.api b/mockwebserver/api/mockwebserver3.api
index 3de174029..7a9a4b75c 100644
--- a/mockwebserver/api/mockwebserver3.api
+++ b/mockwebserver/api/mockwebserver3.api
@@ -28,6 +28,7 @@ public final class mockwebserver3/MockResponse : java/lang/Cloneable {
 	public final fun getHeaders ()Lokhttp3/Headers;
 	public final fun getHeadersDelay (Ljava/util/concurrent/TimeUnit;)J
 	public final fun getHttp2ErrorCode ()I
+	public final fun getInTunnel ()Z
 	public final fun getInformationalResponses ()Ljava/util/List;
 	public final fun getMessage ()Ljava/lang/String;
 	public final fun getPushPromises ()Ljava/util/List;
@@ -40,6 +41,7 @@ public final class mockwebserver3/MockResponse : java/lang/Cloneable {
 	public final fun getWebSocketListener ()Lokhttp3/WebSocketListener;
 	public final fun headers (Lokhttp3/Headers;)V
 	public final fun http2ErrorCode (I)V
+	public final fun inTunnel ()Lmockwebserver3/MockResponse;
 	public final fun isDuplex ()Z
 	public final fun removeHeader (Ljava/lang/String;)Lmockwebserver3/MockResponse;
 	public final fun setBody (Ljava/lang/String;)Lmockwebserver3/MockResponse;
@@ -181,7 +183,6 @@ public final class mockwebserver3/SocketPolicy : java/lang/Enum {
 	public static final field SHUTDOWN_OUTPUT_AT_END Lmockwebserver3/SocketPolicy;
 	public static final field SHUTDOWN_SERVER_AFTER_RESPONSE Lmockwebserver3/SocketPolicy;
 	public static final field STALL_SOCKET_AT_START Lmockwebserver3/SocketPolicy;
-	public static final field UPGRADE_TO_SSL_AT_END Lmockwebserver3/SocketPolicy;
 	public static fun valueOf (Ljava/lang/String;)Lmockwebserver3/SocketPolicy;
 	public static fun values ()[Lmockwebserver3/SocketPolicy;
 }
diff --git a/okhttp/src/jvmMain/kotlin/okhttp3/Route.kt b/okhttp/src/jvmMain/kotlin/okhttp3/Route.kt
index 78d33cfe0..bfd9093dd 100644
--- a/okhttp/src/jvmMain/kotlin/okhttp3/Route.kt
+++ b/okhttp/src/jvmMain/kotlin/okhttp3/Route.kt
@@ -64,12 +64,16 @@ class Route(
   fun socketAddress(): InetSocketAddress = socketAddress
 
   /**
-   * Returns true if this route tunnels HTTPS through an HTTP proxy.
+   * Returns true if this route tunnels HTTPS or HTTP/2 through an HTTP proxy.
    * See [RFC 2817, Section 5.2][rfc_2817].
    *
    * [rfc_2817]: http://www.ietf.org/rfc/rfc2817.txt
    */
-  fun requiresTunnel(): Boolean = address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP
+  fun requiresTunnel(): Boolean {
+    if (proxy.type() != Proxy.Type.HTTP) return false
+    return (address.sslSocketFactory != null) ||
+      (Protocol.H2_PRIOR_KNOWLEDGE in address.protocols)
+  }
 
   override fun equals(other: Any?): Boolean {
     return other is Route &&
diff --git a/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/ConnectPlan.kt b/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/ConnectPlan.kt
index e874ab95e..d39401524 100644
--- a/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/ConnectPlan.kt
+++ b/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/ConnectPlan.kt
@@ -160,6 +160,14 @@ class ConnectPlan(
       }
 
       if (route.address.sslSocketFactory != null) {
+        // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
+        // that happens, then we will have buffered bytes that are needed by the SSLSocket!
+        // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
+        // that it will almost certainly fail because the proxy has sent unexpected data.
+        if (source?.buffer?.exhausted() == false || sink?.buffer?.exhausted() == false) {
+          throw IOException("TLS tunnel buffered too many bytes!")
+        }
+
         eventListener.secureConnectStart(call)
 
         // Create the wrapper over the connected socket.
@@ -404,16 +412,7 @@ class ConnectPlan(
       tunnelCodec.skipConnectBody(response)
 
       when (response.code) {
-        HttpURLConnection.HTTP_OK -> {
-          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If
-          // that happens, then we will have buffered bytes that are needed by the SSLSocket!
-          // This check is imperfect: it doesn't tell us whether a handshake will succeed, just
-          // that it will almost certainly fail because the proxy has sent unexpected data.
-          if (!source.buffer.exhausted() || !sink.buffer.exhausted()) {
-            throw IOException("TLS tunnel buffered too many bytes!")
-          }
-          return null
-        }
+        HttpURLConnection.HTTP_OK -> return null
 
         HttpURLConnection.HTTP_PROXY_AUTH -> {
           nextRequest = route.address.proxyAuthenticator.authenticate(route, response)
