diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index acd76bf0..92941341 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -17,7 +17,6 @@ package retrofit2;
 
 import java.io.IOException;
 import java.lang.reflect.Array;
-import java.lang.reflect.Method;
 import java.util.Map;
 import javax.annotation.Nullable;
 import okhttp3.Headers;
@@ -56,18 +55,8 @@ abstract class ParameterHandler<T> {
   }
 
   static final class RelativeUrl extends ParameterHandler<Object> {
-    private final Method method;
-    private final int p;
-
-    RelativeUrl(Method method, int p) {
-      this.method = method;
-      this.p = p;
-    }
-
     @Override void apply(RequestBuilder builder, @Nullable Object value) {
-      if (value == null) {
-        throw Utils.parameterError(method, p, "@Url parameter is null.");
-      }
+      checkNotNull(value, "@Url parameter is null.");
       builder.setRelativeUrl(value);
     }
   }
@@ -92,16 +81,11 @@ abstract class ParameterHandler<T> {
   }
 
   static final class Path<T> extends ParameterHandler<T> {
-    private final Method method;
-    private final int p;
     private final String name;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
-
-    Path(Method method, int p, String name, Converter<T, String> valueConverter, boolean encoded) {
-      this.method = method;
-      this.p = p;
+    Path(String name, Converter<T, String> valueConverter, boolean encoded) {
       this.name = checkNotNull(name, "name == null");
       this.valueConverter = valueConverter;
       this.encoded = encoded;
@@ -109,8 +93,8 @@ abstract class ParameterHandler<T> {
 
     @Override void apply(RequestBuilder builder, @Nullable T value) throws IOException {
       if (value == null) {
-        throw Utils.parameterError(method, p,
-                "Path parameter \"" + name + "\" value must not be null.");
+        throw new IllegalArgumentException(
+            "Path parameter \"" + name + "\" value must not be null.");
       }
       builder.addPathParam(name, valueConverter.convert(value), encoded);
     }
@@ -153,14 +137,10 @@ abstract class ParameterHandler<T> {
   }
 
   static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Method method;
-    private final int p;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
-    QueryMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
-      this.method = method;
-      this.p = p;
+    QueryMap(Converter<T, String> valueConverter, boolean encoded) {
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
@@ -168,23 +148,23 @@ abstract class ParameterHandler<T> {
     @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
         throws IOException {
       if (value == null) {
-        throw Utils.parameterError(method, p, "Query map was null");
+        throw new IllegalArgumentException("Query map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
         if (entryKey == null) {
-          throw Utils.parameterError(method, p, "Query map contained null key.");
+          throw new IllegalArgumentException("Query map contained null key.");
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          throw Utils.parameterError(method, p,
-                  "Query map contained null value for key '" + entryKey + "'.");
+          throw new IllegalArgumentException(
+              "Query map contained null value for key '" + entryKey + "'.");
         }
 
         String convertedEntryValue = valueConverter.convert(entryValue);
         if (convertedEntryValue == null) {
-          throw Utils.parameterError(method, p, "Query map value '"
+          throw new IllegalArgumentException("Query map value '"
               + entryValue
               + "' converted to null by "
               + valueConverter.getClass().getName()
@@ -199,31 +179,27 @@ abstract class ParameterHandler<T> {
   }
 
   static final class HeaderMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Method method;
-    private final int p;
     private final Converter<T, String> valueConverter;
 
-    HeaderMap(Method method, int p, Converter<T, String> valueConverter) {
-      this.method = method;
-      this.p = p;
+    HeaderMap(Converter<T, String> valueConverter) {
       this.valueConverter = valueConverter;
     }
 
     @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
         throws IOException {
       if (value == null) {
-        throw Utils.parameterError(method, p, "Header map was null.");
+        throw new IllegalArgumentException("Header map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String headerName = entry.getKey();
         if (headerName == null) {
-          throw Utils.parameterError(method, p, "Header map contained null key.");
+          throw new IllegalArgumentException("Header map contained null key.");
         }
         T headerValue = entry.getValue();
         if (headerValue == null) {
-          throw Utils.parameterError(method, p,
-                  "Header map contained null value for key '" + headerName + "'.");
+          throw new IllegalArgumentException(
+              "Header map contained null value for key '" + headerName + "'.");
         }
         builder.addHeader(headerName, valueConverter.convert(headerValue));
       }
@@ -252,14 +228,10 @@ abstract class ParameterHandler<T> {
   }
 
   static final class FieldMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Method method;
-    private final int p;
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
 
-    FieldMap(Method method, int p, Converter<T, String> valueConverter, boolean encoded) {
-      this.method = method;
-      this.p = p;
+    FieldMap(Converter<T, String> valueConverter, boolean encoded) {
       this.valueConverter = valueConverter;
       this.encoded = encoded;
     }
@@ -267,23 +239,23 @@ abstract class ParameterHandler<T> {
     @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
         throws IOException {
       if (value == null) {
-        throw Utils.parameterError(method, p, "Field map was null.");
+        throw new IllegalArgumentException("Field map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
         if (entryKey == null) {
-          throw Utils.parameterError(method, p, "Field map contained null key.");
+          throw new IllegalArgumentException("Field map contained null key.");
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          throw Utils.parameterError(method, p,
-                  "Field map contained null value for key '" + entryKey + "'.");
+          throw new IllegalArgumentException(
+              "Field map contained null value for key '" + entryKey + "'.");
         }
 
         String fieldEntry = valueConverter.convert(entryValue);
         if (fieldEntry == null) {
-          throw Utils.parameterError(method, p, "Field map value '"
+          throw new IllegalArgumentException("Field map value '"
               + entryValue
               + "' converted to null by "
               + valueConverter.getClass().getName()
@@ -298,14 +270,10 @@ abstract class ParameterHandler<T> {
   }
 
   static final class Part<T> extends ParameterHandler<T> {
-    private final Method method;
-    private final int p;
     private final Headers headers;
     private final Converter<T, RequestBody> converter;
 
-    Part(Method method, int p, Headers headers, Converter<T, RequestBody> converter) {
-      this.method = method;
-      this.p = p;
+    Part(Headers headers, Converter<T, RequestBody> converter) {
       this.headers = headers;
       this.converter = converter;
     }
@@ -317,7 +285,7 @@ abstract class ParameterHandler<T> {
       try {
         body = converter.convert(value);
       } catch (IOException e) {
-        throw Utils.parameterError(method, p, "Unable to convert " + value + " to RequestBody", e);
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
       }
       builder.addPart(headers, body);
     }
@@ -337,15 +305,10 @@ abstract class ParameterHandler<T> {
   }
 
   static final class PartMap<T> extends ParameterHandler<Map<String, T>> {
-    private final Method method;
-    private final int p;
     private final Converter<T, RequestBody> valueConverter;
     private final String transferEncoding;
 
-    PartMap(Method method, int p,
-            Converter<T, RequestBody> valueConverter, String transferEncoding) {
-      this.method = method;
-      this.p = p;
+    PartMap(Converter<T, RequestBody> valueConverter, String transferEncoding) {
       this.valueConverter = valueConverter;
       this.transferEncoding = transferEncoding;
     }
@@ -353,18 +316,18 @@ abstract class ParameterHandler<T> {
     @Override void apply(RequestBuilder builder, @Nullable Map<String, T> value)
         throws IOException {
       if (value == null) {
-        throw Utils.parameterError(method, p, "Part map was null.");
+        throw new IllegalArgumentException("Part map was null.");
       }
 
       for (Map.Entry<String, T> entry : value.entrySet()) {
         String entryKey = entry.getKey();
         if (entryKey == null) {
-          throw Utils.parameterError(method, p, "Part map contained null key.");
+          throw new IllegalArgumentException("Part map contained null key.");
         }
         T entryValue = entry.getValue();
         if (entryValue == null) {
-          throw Utils.parameterError(method, p,
-                  "Part map contained null value for key '" + entryKey + "'.");
+          throw new IllegalArgumentException(
+              "Part map contained null value for key '" + entryKey + "'.");
         }
 
         Headers headers = Headers.of(
@@ -377,25 +340,21 @@ abstract class ParameterHandler<T> {
   }
 
   static final class Body<T> extends ParameterHandler<T> {
-    private final Method method;
-    private final int p;
     private final Converter<T, RequestBody> converter;
 
-    Body(Method method, int p, Converter<T, RequestBody> converter) {
-      this.method = method;
-      this.p = p;
+    Body(Converter<T, RequestBody> converter) {
       this.converter = converter;
     }
 
     @Override void apply(RequestBuilder builder, @Nullable T value) {
       if (value == null) {
-        throw Utils.parameterError(method, p, "Body parameter value must not be null.");
+        throw new IllegalArgumentException("Body parameter value must not be null.");
       }
       RequestBody body;
       try {
         body = converter.convert(value);
       } catch (IOException e) {
-        throw Utils.parameterError(method, e, p, "Unable to convert " + value + " to RequestBody");
+        throw new RuntimeException("Unable to convert " + value + " to RequestBody", e);
       }
       builder.setBody(body);
     }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index 78c6dd84..aaa00d46 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -344,7 +344,7 @@ final class RequestFactory {
             || type == String.class
             || type == URI.class
             || (type instanceof Class && "android.net.Uri".equals(((Class<?>) type).getName()))) {
-          return new ParameterHandler.RelativeUrl(method, p);
+          return new ParameterHandler.RelativeUrl();
         } else {
           throw parameterError(method, p,
               "@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.");
@@ -375,7 +375,7 @@ final class RequestFactory {
         validatePathName(p, name);
 
         Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-        return new ParameterHandler.Path<>(method, p, name, converter, path.encoded());
+        return new ParameterHandler.Path<>(name, converter, path.encoded());
 
       } else if (annotation instanceof Query) {
         validateResolvableType(p, type);
@@ -459,8 +459,7 @@ final class RequestFactory {
         Converter<?, String> valueConverter =
             retrofit.stringConverter(valueType, annotations);
 
-        return new ParameterHandler.QueryMap<>(method, p,
-                valueConverter, ((QueryMap) annotation).encoded());
+        return new ParameterHandler.QueryMap<>(valueConverter, ((QueryMap) annotation).encoded());
 
       } else if (annotation instanceof Header) {
         validateResolvableType(p, type);
@@ -511,7 +510,7 @@ final class RequestFactory {
         Converter<?, String> valueConverter =
             retrofit.stringConverter(valueType, annotations);
 
-        return new ParameterHandler.HeaderMap<>(method, p, valueConverter);
+        return new ParameterHandler.HeaderMap<>(valueConverter);
 
       } else if (annotation instanceof Field) {
         validateResolvableType(p, type);
@@ -573,8 +572,7 @@ final class RequestFactory {
             retrofit.stringConverter(valueType, annotations);
 
         gotField = true;
-        return new ParameterHandler.FieldMap<>(method, p,
-                valueConverter, ((FieldMap) annotation).encoded());
+        return new ParameterHandler.FieldMap<>(valueConverter, ((FieldMap) annotation).encoded());
 
       } else if (annotation instanceof Part) {
         validateResolvableType(p, type);
@@ -636,7 +634,7 @@ final class RequestFactory {
             }
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(iterableType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(method, p, headers, converter).iterable();
+            return new ParameterHandler.Part<>(headers, converter).iterable();
           } else if (rawParameterType.isArray()) {
             Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
             if (MultipartBody.Part.class.isAssignableFrom(arrayComponentType)) {
@@ -646,7 +644,7 @@ final class RequestFactory {
             }
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(arrayComponentType, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(method, p, headers, converter).array();
+            return new ParameterHandler.Part<>(headers, converter).array();
           } else if (MultipartBody.Part.class.isAssignableFrom(rawParameterType)) {
             throw parameterError(method, p,
                 "@Part parameters using the MultipartBody.Part must not "
@@ -654,7 +652,7 @@ final class RequestFactory {
           } else {
             Converter<?, RequestBody> converter =
                 retrofit.requestBodyConverter(type, annotations, methodAnnotations);
-            return new ParameterHandler.Part<>(method, p, headers, converter);
+            return new ParameterHandler.Part<>(headers, converter);
           }
         }
 
@@ -691,7 +689,7 @@ final class RequestFactory {
             retrofit.requestBodyConverter(valueType, annotations, methodAnnotations);
 
         PartMap partMap = (PartMap) annotation;
-        return new ParameterHandler.PartMap<>(method, p, valueConverter, partMap.encoding());
+        return new ParameterHandler.PartMap<>(valueConverter, partMap.encoding());
 
       } else if (annotation instanceof Body) {
         validateResolvableType(p, type);
@@ -711,7 +709,7 @@ final class RequestFactory {
           throw parameterError(method, e, p, "Unable to create @Body converter for %s", type);
         }
         gotBody = true;
-        return new ParameterHandler.Body<>(method, p, converter);
+        return new ParameterHandler.Body<>(converter);
       }
 
       return null; // Not a Retrofit annotation.
diff --git a/retrofit/src/test/java/retrofit2/RequestFactoryTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
index bf78a338..d6a6dc17 100644
--- a/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
@@ -488,8 +488,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map was null (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Query map was null.");
     }
   }
 
@@ -509,8 +508,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, queryParams);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null key. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Query map contained null key.");
     }
   }
 
@@ -530,8 +528,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, queryParams);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null value for key 'kit'. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Query map contained null value for key 'kit'.");
     }
   }
 
@@ -604,8 +601,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, (Map<String, String>) null);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map was null. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Header map was null.");
     }
   }
 
@@ -625,8 +621,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, headers);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null key. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Header map contained null key.");
     }
   }
 
@@ -646,8 +641,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, headers);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Header map contained null value for key 'Accept-Charset'.");
     }
   }
 
@@ -977,8 +971,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e.getMessage()).isEqualTo("Path parameter \"ping\" value must not be null.");
     }
   }
 
@@ -1463,9 +1456,8 @@ public final class RequestFactoryTest {
     try {
       buildRequest(Example.class, (HttpUrl) null);
       fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("@Url parameter is null. (parameter #1)\n" +
-              "    for method Example.method");
+    } catch (NullPointerException expected) {
+      assertThat(expected).hasMessage("@Url parameter is null.");
     }
   }
 
@@ -1690,8 +1682,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e.getMessage()).isEqualTo("Body parameter value must not be null.");
     }
   }
 
@@ -2191,8 +2182,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map was null. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Part map was null.");
     }
   }
 
@@ -2213,8 +2203,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, params);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null key. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Part map contained null key.");
     }
   }
 
@@ -2235,8 +2224,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, params);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null value for key 'kit'. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Part map contained null value for key 'kit'.");
     }
   }
 
@@ -2449,8 +2437,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, new Object[] { null });
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map was null. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Field map was null.");
     }
   }
 
@@ -2471,8 +2458,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, fieldMap);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null key. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Field map contained null key.");
     }
   }
 
@@ -2493,8 +2479,7 @@ public final class RequestFactoryTest {
       buildRequest(Example.class, fieldMap);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null value for key 'foo'. (parameter #1)\n" +
-              "    for method Example.method");
+      assertThat(e).hasMessage("Field map contained null value for key 'foo'.");
     }
   }
 
