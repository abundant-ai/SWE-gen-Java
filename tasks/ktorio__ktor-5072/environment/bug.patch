diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/sse/DefaultClientSSESession.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/sse/DefaultClientSSESession.kt
index d80d82085..22c23d003 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/sse/DefaultClientSSESession.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/sse/DefaultClientSSESession.kt
@@ -4,12 +4,10 @@
 
 package io.ktor.client.plugins.sse
 
-import io.ktor.client.network.sockets.SocketTimeoutException
 import io.ktor.client.request.*
 import io.ktor.http.*
 import io.ktor.sse.*
 import io.ktor.util.logging.*
-import io.ktor.util.rootCause
 import io.ktor.utils.io.*
 import io.ktor.utils.io.CancellationException
 import kotlinx.coroutines.*
@@ -149,12 +147,7 @@ public class DefaultClientSSESession(
     private suspend fun ByteReadChannel.tryParseEvent(): ServerSentEvent? =
         try {
             parseEvent()
-        } catch (cause: ClosedByteChannelException) {
-            val rootCause = cause.rootCause
-            if (rootCause is SocketTimeoutException) {
-                throw rootCause
-            }
-
+        } catch (_: ClosedByteChannelException) {
             // this is expected when the server disconnects
             null
         }
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/sse/SSEConfig.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/sse/SSEConfig.kt
index 7662f3964..1b3706f38 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/sse/SSEConfig.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/sse/SSEConfig.kt
@@ -20,6 +20,8 @@ public class SSEConfig {
      * The reconnection time. If the connection to the server is lost,
      * the client will wait for the specified time before attempting to reconnect.
      *
+     * Note: this parameter is not supported for some engines.
+     *
      * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.client.plugins.sse.SSEConfig.reconnectionTime)
      */
     public var reconnectionTime: Duration = 3000.milliseconds
diff --git a/ktor-client/ktor-client-okhttp/build.gradle.kts b/ktor-client/ktor-client-okhttp/build.gradle.kts
index 4bde8c70a..c35ae0135 100644
--- a/ktor-client/ktor-client-okhttp/build.gradle.kts
+++ b/ktor-client/ktor-client-okhttp/build.gradle.kts
@@ -12,6 +12,7 @@ kotlin {
         jvmMain.dependencies {
             api(projects.ktorClientCore)
             api(libs.okhttp)
+            api(libs.okhttp.sse)
             api(libs.okio)
         }
         jvmTest.dependencies {
diff --git a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt
index c18fff1ab..ee49324c3 100644
--- a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt
+++ b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt
@@ -65,7 +65,8 @@ public class OkHttpEngine(override val config: OkHttpConfig) : HttpClientEngineB
             ?: error("OkHttpClient can't be constructed because HttpTimeout plugin is not installed")
 
         return when {
-            data.isUpgradeRequest() -> executeWebSocketRequest(requestEngine, engineRequest, callContext, data)
+            data.isUpgradeRequest() -> executeWebSocketRequest(requestEngine, engineRequest, callContext)
+            data.isSseRequest() -> executeServerSendEventsRequest(requestEngine, engineRequest, callContext)
             else -> executeHttpRequest(requestEngine, engineRequest, callContext, data)
         }
     }
@@ -78,8 +79,7 @@ public class OkHttpEngine(override val config: OkHttpConfig) : HttpClientEngineB
     private suspend fun executeWebSocketRequest(
         engine: OkHttpClient,
         engineRequest: Request,
-        callContext: CoroutineContext,
-        requestData: HttpRequestData,
+        callContext: CoroutineContext
     ): HttpResponseData {
         val requestTime = GMTDate()
         val session = OkHttpWebsocketSession(
@@ -90,7 +90,23 @@ public class OkHttpEngine(override val config: OkHttpConfig) : HttpClientEngineB
         ).apply { start() }
 
         val originResponse = session.originResponse.await()
-        return buildResponseData(originResponse, requestTime, session, callContext, requestData)
+        return buildResponseData(originResponse, requestTime, session, callContext)
+    }
+
+    private suspend fun executeServerSendEventsRequest(
+        engine: OkHttpClient,
+        engineRequest: Request,
+        callContext: CoroutineContext
+    ): HttpResponseData {
+        val requestTime = GMTDate()
+        val session = OkHttpSSESession(
+            engine,
+            engineRequest,
+            callContext
+        )
+
+        val originResponse = session.originResponse.await()
+        return buildResponseData(originResponse, requestTime, session, callContext)
     }
 
     private suspend fun executeHttpRequest(
@@ -106,29 +122,20 @@ public class OkHttpEngine(override val config: OkHttpConfig) : HttpClientEngineB
         callContext.job.invokeOnCompletion { body.close() }
 
         val responseContent = body.source().toChannel(callContext, requestData)
-        return buildResponseData(response, requestTime, responseContent, callContext, requestData)
+        return buildResponseData(response, requestTime, responseContent, callContext)
     }
 
     private fun buildResponseData(
         response: Response,
         requestTime: GMTDate,
         body: Any,
-        callContext: CoroutineContext,
-        requestData: HttpRequestData
+        callContext: CoroutineContext
     ): HttpResponseData {
         val status = HttpStatusCode(response.code, response.message)
         val version = response.protocol.fromOkHttp()
         val headers = response.headers.fromOkHttp()
-        val responseBody: Any = when (body) {
-            is ByteReadChannel ->
-                requestData.attributes
-                    .getOrNull(ResponseAdapterAttributeKey)
-                    ?.adapt(requestData, status, headers, body, requestData.body, callContext)
-                    ?: body
-            else -> body
-        }
 
-        return HttpResponseData(status, requestTime, headers, version, responseBody, callContext)
+        return HttpResponseData(status, requestTime, headers, version, body, callContext)
     }
 
     private companion object {
diff --git a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpSSESession.kt b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpSSESession.kt
new file mode 100644
index 000000000..d2d9973f7
--- /dev/null
+++ b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpSSESession.kt
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2014-2024 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
+ */
+
+package io.ktor.client.engine.okhttp
+
+import io.ktor.client.plugins.sse.*
+import io.ktor.http.*
+import io.ktor.sse.*
+import io.ktor.utils.io.InternalAPI
+import kotlinx.coroutines.*
+import kotlinx.coroutines.channels.Channel
+import kotlinx.coroutines.channels.onFailure
+import kotlinx.coroutines.channels.trySendBlocking
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.consumeAsFlow
+import kotlinx.coroutines.flow.onCompletion
+import okhttp3.OkHttpClient
+import okhttp3.Request
+import okhttp3.Response
+import okhttp3.sse.EventSource
+import okhttp3.sse.EventSourceListener
+import okhttp3.sse.EventSources
+import kotlin.coroutines.CoroutineContext
+
+internal class OkHttpSSESession private constructor(
+    factory: EventSource.Factory,
+    engineRequest: Request,
+    override val coroutineContext: CoroutineContext,
+) : SSESession, EventSourceListener() {
+
+    constructor(
+        engine: OkHttpClient,
+        engineRequest: Request,
+        callContext: CoroutineContext,
+    ) : this(
+        factory = EventSources.createFactory(engine),
+        engineRequest = engineRequest,
+        coroutineContext = callContext + Job() + CoroutineName("OkHttpSSESession"),
+    )
+
+    @InternalAPI
+    override fun bodyBuffer(): ByteArray = ByteArray(0)
+
+    private val serverSentEventsSource = factory.newEventSource(engineRequest, this)
+
+    internal val originResponse: CompletableDeferred<Response> = CompletableDeferred()
+
+    private val _incoming = Channel<ServerSentEvent>(8)
+
+    override val incoming: Flow<ServerSentEvent> = _incoming.consumeAsFlow()
+        .onCompletion { cause ->
+            // Use onCompletion operator to handle CancellationExceptions which occur in downstream flow.
+            if (cause is CancellationException) close(cause = null)
+        }
+
+    init {
+        coroutineContext.job.invokeOnCompletion {
+            close(cause = null)
+        }
+    }
+
+    override fun onOpen(eventSource: EventSource, response: Response) {
+        originResponse.complete(response)
+    }
+
+    override fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
+        _incoming.trySendBlocking(ServerSentEvent(data, type, id))
+            .onFailure { if (it is CancellationException) throw it }
+    }
+
+    override fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
+        val statusCode = response?.code
+        val contentType = response?.headers?.get(HttpHeaders.ContentType)
+
+        if (response != null &&
+            (statusCode != HttpStatusCode.OK.value || contentType != ContentType.Text.EventStream.toString())
+        ) {
+            originResponse.complete(response)
+            close(cause = null)
+        } else {
+            val error = t?.let {
+                SSEClientException(
+                    message = "Exception during OkHttpSSESession: ${it.message}",
+                    cause = it
+                )
+            } ?: mapException(response)
+            originResponse.completeExceptionally(error)
+            close(cause = error)
+        }
+    }
+
+    override fun onClosed(eventSource: EventSource) {
+        close(cause = null)
+    }
+
+    private fun close(cause: Throwable?) {
+        _incoming.close(cause)
+        serverSentEventsSource.cancel()
+        // Cancel context last so 'invokeOnCompletion' doesn't override 'cause' for closing '_incoming'.
+        coroutineContext.cancel()
+    }
+
+    private fun mapException(response: Response?): SSEClientException {
+        fun unexpectedError() = SSEClientException(message = "Unexpected error occurred in OkHttpSSESession")
+
+        return when {
+            response == null -> unexpectedError()
+
+            response.code != HttpStatusCode.OK.value ->
+                SSEClientException(message = "Expected status code ${HttpStatusCode.OK.value} but was ${response.code}")
+
+            response.headers[HttpHeaders.ContentType]
+                ?.let { ContentType.parse(it) }?.withoutParameters() != ContentType.Text.EventStream ->
+                @Suppress("ktlint:standard:max-line-length")
+                SSEClientException(
+                    message = "Content type must be ${ContentType.Text.EventStream} but was ${response.headers[HttpHeaders.ContentType]}"
+                )
+
+            else -> unexpectedError()
+        }
+    }
+}
diff --git a/ktor-client/ktor-client-okhttp/jvm/test/io/ktor/client/engine/okhttp/OkHttpHttpClientTest.kt b/ktor-client/ktor-client-okhttp/jvm/test/io/ktor/client/engine/okhttp/OkHttpHttpClientTest.kt
index 0a0137db4..b5b7babee 100644
--- a/ktor-client/ktor-client-okhttp/jvm/test/io/ktor/client/engine/okhttp/OkHttpHttpClientTest.kt
+++ b/ktor-client/ktor-client-okhttp/jvm/test/io/ktor/client/engine/okhttp/OkHttpHttpClientTest.kt
@@ -5,89 +5,93 @@
 package io.ktor.client.engine.okhttp
 
 import io.ktor.client.*
-import io.ktor.client.network.sockets.*
 import io.ktor.client.plugins.sse.*
 import io.ktor.client.test.base.*
 import io.ktor.client.tests.*
+import io.ktor.network.sockets.*
 import kotlinx.coroutines.Job
 import kotlinx.coroutines.delay
 import kotlinx.coroutines.flow.collect
-import kotlinx.coroutines.job
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.test.runTest
 import okhttp3.OkHttpClient
 import org.junit.jupiter.api.assertInstanceOf
 import java.util.concurrent.TimeUnit
-import kotlin.test.*
+import kotlin.test.Test
+import kotlin.test.assertEquals
+import kotlin.test.fail
 
 class OkHttpHttpClientTest : HttpClientTest(OkHttp) {
     @Test
-    fun testCancelSseRequestIncomingCollect() = runTest {
+    fun testCancelSseRequestIncomingCollect() {
         val okHttpClient = OkHttpClient()
 
-        val client = HttpClient(OkHttp) {
+        HttpClient(OkHttp) {
             engine { preconfigured = okHttpClient }
             install(SSE)
-        }
-        var callJob: Job? = null
-        var request: Job? = null
-        request = launch {
-            client.sse("${TEST_SERVER}/sse/hello?times=20&interval=100") {
-                callJob = call.request.coroutineContext.job
-                request?.cancel() // Cancel the request once the connection is open.
-                incoming.collect() // Collect all messages.
+        }.use { client ->
+            runTest {
+                var request: Job? = null
+                request = launch {
+                    client.sse("${TEST_SERVER}/sse/hello?times=20&interval=100") {
+                        request?.cancel() // Cancel the request once the connection is open.
+                        incoming.collect() // Collect all messages.
+                    }
+                    fail("Request should be cancelled.")
+                }
+                request.join()
             }
-            fail("Request should be cancelled.")
         }
-        request.join()
-        callJob?.join()
 
         okHttpClient.connectionPool.evictAll() // Make sure idle connections are removed.
         assertEquals(0, okHttpClient.connectionPool.connectionCount())
     }
 
     @Test
-    fun testCancelSseRequestWithDelay() = runTest {
+    fun testCancelSseRequestWithDelay() {
         val okHttpClient = OkHttpClient()
 
-        val client = HttpClient(OkHttp) {
+        HttpClient(OkHttp) {
             engine { preconfigured = okHttpClient }
             install(SSE)
-        }
-        var callJob: Job? = null
-        var request: Job? = null
-        request = launch {
-            client.sse("${TEST_SERVER}/sse/hello?times=20&interval=100") {
-                callJob = call.request.coroutineContext.job
-                request?.cancel() // Cancel the request once the connection is open.
-                delay(1) // Never read from incoming.
+        }.use { client ->
+            runTest {
+                var request: Job? = null
+                request = launch {
+                    client.sse("${TEST_SERVER}/sse/hello?times=20&interval=100") {
+                        request?.cancel() // Cancel the request once the connection is open.
+                        delay(1) // Never read from incoming.
+                    }
+                    fail("Request should be cancelled.")
+                }
+                request.join()
             }
-            fail("Request should be cancelled.")
         }
-        request.join()
-        callJob?.join()
 
         okHttpClient.connectionPool.evictAll() // Make sure idle connections are removed.
         assertEquals(0, okHttpClient.connectionPool.connectionCount())
     }
 
-    @Ignore("Flaky test: KTOR-8854")
     @Test
-    fun testSSESessionTimeout() = runTest {
+    fun testSSESessionTimeout() {
         val okHttpClient = OkHttpClient.Builder().apply {
-            readTimeout(100, TimeUnit.MILLISECONDS)
+            readTimeout(1L, TimeUnit.SECONDS)
         }.build()
 
-        val client = HttpClient(OkHttp) {
+        HttpClient(OkHttp) {
             engine { preconfigured = okHttpClient }
             install(SSE)
-        }
-        assertFailsWith<SSEClientException> {
-            client.sse("$TEST_SERVER/sse/hello?delay=1000") {
-                incoming.collect()
+        }.use { client ->
+            runTest {
+                client.sse("$TEST_SERVER/sse/hello?delay=10000") {
+                    try {
+                        incoming.collect()
+                        fail("Request should error.")
+                    } catch (e: SSEClientException) {
+                        assertInstanceOf<SocketTimeoutException>(e.cause)
+                    }
+                }
             }
-        }.apply {
-            assertInstanceOf<SocketTimeoutException>(cause)
         }
     }
 }
diff --git a/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/plugins/ServerSentEventsTest.kt b/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/plugins/ServerSentEventsTest.kt
index 7c436c8f8..b7e558a50 100644
--- a/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/plugins/ServerSentEventsTest.kt
+++ b/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/plugins/ServerSentEventsTest.kt
@@ -229,7 +229,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testShowComments() = clientTests {
+    fun testShowComments() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 showCommentEvents()
@@ -253,7 +253,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testDifferentConfigs() = clientTests {
+    fun testDifferentConfigs() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 showCommentEvents()
@@ -380,8 +380,10 @@ class ServerSentEventsTest : ClientLoader() {
         }
     }
 
+    // Android, Darwin and Js engines don't support request body in GET request
+    // SSE in OkHttp and Curl doesn't send a request body for GET request
     @Test
-    fun testRequestBody() = clientTests {
+    fun testRequestBody() = clientTests(except("Android", "Darwin", "DarwinLegacy", "Js", "OkHttp", "Curl")) {
         config {
             install(SSE)
         }
@@ -390,7 +392,6 @@ class ServerSentEventsTest : ClientLoader() {
         val contentType = ContentType.Text.Plain
         test { client ->
             client.sse({
-                method = HttpMethod.Post
                 url("$TEST_SERVER/sse/echo")
                 setBody(body)
                 contentType(contentType)
@@ -402,7 +403,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testErrorForProtocolUpgradeRequestBody() = clientTests {
+    fun testErrorForProtocolUpgradeRequestBody() = clientTests(except("OkHttp")) {
         config {
             install(SSE)
         }
@@ -422,12 +423,9 @@ class ServerSentEventsTest : ClientLoader() {
         test { client ->
             assertFailsWith<SSEClientException> {
                 client.sse({
-                    method = HttpMethod.Post
                     url("$TEST_SERVER/sse/echo")
                     setBody(body)
                 }) {}
-            }.apply {
-                assertTrue { message!!.contains("Failed to write body") }
             }
         }
     }
@@ -581,7 +579,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testReconnection() = clientTests {
+    fun testReconnection() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 maxReconnectionAttempts = 1
@@ -605,7 +603,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testClientExceptionDuringSSESession() = clientTests {
+    fun testClientExceptionDuringSSESession() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 maxReconnectionAttempts = 1
@@ -637,7 +635,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testServerExceptionDuringSSESession() = clientTests {
+    fun testServerExceptionDuringSSESession() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 reconnectionTime = 100.milliseconds
@@ -666,7 +664,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testSeveralReconnections() = clientTests {
+    fun testSeveralReconnections() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 maxReconnectionAttempts = 2
@@ -695,7 +693,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testMaxRetries() = clientTests {
+    fun testMaxRetries() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 reconnectionTime = 10.milliseconds
@@ -725,7 +723,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testNoContent() = clientTests {
+    fun testNoContent() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 maxReconnectionAttempts = 1
@@ -753,7 +751,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun testNoContentStream() = clientTests {
+    fun testNoContentStream() = clientTests(except("OkHttp")) {
         config {
             install(SSE)
         }
@@ -767,7 +765,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun `test response body with BufferPolicy-All`() = clientTests {
+    fun `test response body with BufferPolicy-All`() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 bufferPolicy = SSEBufferPolicy.All
@@ -795,7 +793,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun `test local BufferPolicy wins`() = clientTests {
+    fun `test local BufferPolicy wins`() = clientTests(except("OkHttp")) {
         config {
             install(SSE) {
                 bufferPolicy = SSEBufferPolicy.All
@@ -817,7 +815,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun `test response body with BufferPolicy-LastLines`() = clientTests {
+    fun `test response body with BufferPolicy-LastLines`() = clientTests(except("OkHttp")) {
         config {
             install(SSE)
         }
@@ -849,7 +847,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun `test response body with BufferPolicy-LastEvent`() = clientTests {
+    fun `test response body with BufferPolicy-LastEvent`() = clientTests(except("OkHttp")) {
         config {
             install(SSE)
         }
@@ -880,7 +878,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun `test response body with BufferPolicy-LastEvents`() = clientTests {
+    fun `test response body with BufferPolicy-LastEvents`() = clientTests(except("OkHttp")) {
         config {
             install(SSE)
         }
@@ -915,7 +913,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun `test body contains only proceeded data`() = clientTests {
+    fun `test body contains only proceeded data`() = clientTests(except("OkHttp")) {
         config {
             install(SSE)
         }
@@ -934,7 +932,7 @@ class ServerSentEventsTest : ClientLoader() {
     }
 
     @Test
-    fun `test full response body in exception on non-200 status`() = clientTests {
+    fun `test full response body in exception on non-200 status`() = clientTests(except("OkHttp")) {
         config {
             install(SSE)
         }
diff --git a/ktor-test-server/src/main/kotlin/test/server/tests/ServerSentEvents.kt b/ktor-test-server/src/main/kotlin/test/server/tests/ServerSentEvents.kt
index e4105d7f7..c9ef32578 100644
--- a/ktor-test-server/src/main/kotlin/test/server/tests/ServerSentEvents.kt
+++ b/ktor-test-server/src/main/kotlin/test/server/tests/ServerSentEvents.kt
@@ -73,7 +73,7 @@ internal fun Application.serverSentEvents() {
                     writeSseEvents(events)
                 }
             }
-            post("/echo") {
+            get("/echo") {
                 call.respondSseEvents(
                     flow {
                         emit(SseEvent(call.receiveText()))
