diff --git a/src/main/java/org/mockito/internal/exceptions/Reporter.java b/src/main/java/org/mockito/internal/exceptions/Reporter.java
index 1b68fbb65..30513525f 100644
--- a/src/main/java/org/mockito/internal/exceptions/Reporter.java
+++ b/src/main/java/org/mockito/internal/exceptions/Reporter.java
@@ -299,17 +299,33 @@ public class Reporter {
         return join(description.toArray());
     }
 
-    public static AssertionError argumentsAreDifferent(String wanted, String actual, Location actualLocation) {
-        String message = join("Argument(s) are different! Wanted:",
-                              wanted,
-                              new LocationImpl(),
-                              "Actual invocation has different arguments:",
-                              actual,
-                              actualLocation,
-                              ""
-        );
+    public static AssertionError argumentsAreDifferent(String wanted, List<String> actualCalls, List<Location> actualLocations) {
+        if (actualCalls == null || actualLocations == null || actualCalls.size() != actualLocations.size()) {
+            throw new IllegalArgumentException("actualCalls and actualLocations list must match");
+        }
+
+
+        StringBuilder actualBuilder = new StringBuilder();
+        StringBuilder messageBuilder = new StringBuilder();
+        messageBuilder.append("\n")
+            .append("Argument(s) are different! Wanted:\n")
+            .append(wanted)
+            .append("\n")
+            .append(new LocationImpl())
+            .append("\n")
+            .append("Actual invocations have different arguments:\n");
+
+        for (int i = 0; i < actualCalls.size(); i++) {
+            actualBuilder.append(actualCalls.get(i))
+                .append("\n");
+
+            messageBuilder.append(actualCalls.get(i))
+                .append("\n")
+                .append(actualLocations.get(i))
+                .append("\n");
+        }
 
-        return ExceptionFactory.createArgumentsAreDifferentException(message, wanted, actual);
+        return ExceptionFactory.createArgumentsAreDifferentException(messageBuilder.toString(), wanted, actualBuilder.toString());
     }
 
     public static MockitoAssertionError wantedButNotInvoked(DescribedInvocation wanted) {
diff --git a/src/main/java/org/mockito/internal/reporting/SmartPrinter.java b/src/main/java/org/mockito/internal/reporting/SmartPrinter.java
index 8da053ddf..24d8367b0 100644
--- a/src/main/java/org/mockito/internal/reporting/SmartPrinter.java
+++ b/src/main/java/org/mockito/internal/reporting/SmartPrinter.java
@@ -8,6 +8,10 @@ package org.mockito.internal.reporting;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MatchableInvocation;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
 /**
  * Makes sure both wanted and actual are printed consistently (single line or multiline)
  * <p>
@@ -16,22 +20,40 @@ import org.mockito.invocation.MatchableInvocation;
 public class SmartPrinter {
 
     private final String wanted;
-    private final String actual;
+    private final List<String> actuals;
 
     public SmartPrinter(MatchableInvocation wanted, Invocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {
+        this(wanted, Collections.singletonList(actual), indexesOfMatchersToBeDescribedWithExtraTypeInfo);
+    }
+
+    public SmartPrinter(MatchableInvocation wanted, List<Invocation> allActualInvocations, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {
         PrintSettings printSettings = new PrintSettings();
-        printSettings.setMultiline(wanted.toString().contains("\n") || actual.toString().contains("\n"));
+        printSettings.setMultiline(isMultiLine(wanted, allActualInvocations));
         printSettings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchersToBeDescribedWithExtraTypeInfo);
 
         this.wanted = printSettings.print(wanted);
-        this.actual = printSettings.print(actual);
+
+        List<String> actuals = new ArrayList<String>();
+        for (Invocation actual : allActualInvocations) {
+            actuals.add(printSettings.print(actual));
+        }
+        this.actuals = Collections.unmodifiableList(actuals);
     }
 
     public String getWanted() {
         return wanted;
     }
 
-    public String getActual() {
-        return actual;
+    public List<String> getActuals() {
+        return actuals;
+    }
+
+    private static boolean isMultiLine(MatchableInvocation wanted, List<Invocation> allActualInvocations) {
+        boolean isWantedMultiline = wanted.toString().contains("\n");
+        boolean isAnyActualMultiline = false;
+        for (Invocation invocation : allActualInvocations) {
+            isAnyActualMultiline |= invocation.toString().contains("\n");
+        }
+        return isWantedMultiline || isAnyActualMultiline;
     }
 }
diff --git a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
index 3f89c7778..c13aa0098 100644
--- a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
+++ b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
@@ -17,8 +17,10 @@ import static org.mockito.internal.verification.argumentmatching.ArgumentMatchin
 import java.util.List;
 
 import org.mockito.internal.reporting.SmartPrinter;
+import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
+import org.mockito.invocation.Location;
 import org.mockito.invocation.MatchableInvocation;
 
 public class MissingInvocationChecker {
@@ -39,8 +41,15 @@ public class MissingInvocationChecker {
         }
 
         Integer[] indexesOfSuspiciousArgs = getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());
-        SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indexesOfSuspiciousArgs);
-        throw argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());
+        SmartPrinter smartPrinter = new SmartPrinter(wanted, invocations, indexesOfSuspiciousArgs);
+        List<Location> actualLocations = ListUtil.convert(invocations, new ListUtil.Converter<Invocation, Location>() {
+            @Override
+            public Location convert(Invocation invocation) {
+                return invocation.getLocation();
+            }
+        });
+
+        throw argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActuals(), actualLocations);
 
     }
 
