When using Ktorâ€™s ApplicationConfig merging, merged properties can be misinterpreted if the result of a merge is merged again. This causes incorrect loading of configuration values when configuration sources are combined more than once (for example, merging a base config with overrides, then merging that merged config again with another override layer). The issue is that a property produced by a previous merge is not correctly recognized during a subsequent merge, so after the second merge some properties end up with the wrong value/type or become inaccessible via normal lookup.

Reproduction scenario: create multiple ApplicationConfig instances containing overlapping nested keys (including nested objects and lists), merge them to get a combined config, and then merge that combined config again with another config. After the second merge, reading properties via dotted paths (for example using ApplicationConfig.propertyOrNull("auth.hashAlgorithm") and ApplicationConfig.propertyOrNull("auth.listValues")) should still return the expected values from the final merged result, and list-valued properties should still be returned as lists in the expected order. Instead, after merging more than once, some merged properties are interpreted incorrectly, causing lookups to return incorrect results (wrong value or null) or returning a value with an unexpected structure.

Fix ApplicationConfig merge behavior so that merging is associative for these use cases: merging multiple times must preserve correct interpretation of already-merged properties. After the fix, all of the following must behave consistently even after repeated merges: reading nested properties via config("...") and property("...")/propertyOrNull("..."), reading list properties via ApplicationConfigValue.getList(), and enumerating keys via ApplicationConfig.keys() so that keys reflect the fully merged nested structure (including nested object keys like "auth.data.value1"). Also ensure that explicit nulls in YAML-backed configs are handled such that propertyOrNull returns null for those keys (e.g., "auth.nullable" should be treated as absent/null rather than a string "null").