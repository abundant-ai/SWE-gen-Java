diff --git a/bom/application/pom.xml b/bom/application/pom.xml
index ad8489e0e5a..85ade855b99 100644
--- a/bom/application/pom.xml
+++ b/bom/application/pom.xml
@@ -97,7 +97,7 @@
              hibernate-search.version, antlr.version, bytebuddy.version -->
         <narayana.version>7.3.3.Final</narayana.version>
         <narayana-lra.version>1.0.3.Final</narayana-lra.version>
-        <agroal.version>2.8</agroal.version>
+        <agroal.version>3.0</agroal.version>
         <jboss-transaction-spi.version>8.0.0.Final</jboss-transaction-spi.version>
         <elasticsearch-opensource-components.version>9.2.3</elasticsearch-opensource-components.version>
         <rxjava.version>2.2.21</rxjava.version>
@@ -107,7 +107,7 @@
         <slf4j-jboss-logmanager.version>2.0.2.Final</slf4j-jboss-logmanager.version>
         <wildfly-common.version>2.0.1</wildfly-common.version>
         <wildfly-client-config.version>1.0.1.Final</wildfly-client-config.version>
-        <wildfly-elytron.version>2.7.1.Final</wildfly-elytron.version>
+        <wildfly-elytron.version>2.8.0.Final</wildfly-elytron.version>
         <jboss-marshalling.version>2.3.0</jboss-marshalling.version>
         <jboss-threads.version>3.9.2</jboss-threads.version>
         <vertx.version>4.5.24</vertx.version>
@@ -179,7 +179,7 @@
         <quarkus-security.version>2.3.2</quarkus-security.version>
         <keycloak-client.version>26.0.8</keycloak-client.version>
         <logstash-gelf.version>1.15.1</logstash-gelf.version>
-        <checker-qual.version>3.53.0</checker-qual.version>
+        <checker-qual.version>3.53.1</checker-qual.version>
         <error-prone-annotations.version>2.46.0</error-prone-annotations.version>
         <jib-core.version>0.28.1</jib-core.version>
         <google-http-client.version>1.47.1</google-http-client.version>
@@ -193,8 +193,7 @@
         <log4j2-api.version>2.25.3</log4j2-api.version>
         <log4j-jboss-logmanager.version>1.3.1.Final</log4j-jboss-logmanager.version>
         <avro.version>1.12.1</avro.version>
-        <apicurio-registry.version>2.6.13.Final</apicurio-registry.version>
-        <apicurio-common-rest-client.version>0.1.18.Final</apicurio-common-rest-client.version> <!-- must be the version Apicurio Registry uses -->
+        <apicurio-registry.version>3.1.7</apicurio-registry.version>
         <testcontainers.version>2.0.3</testcontainers.version> <!-- Make sure to also update docker-java.version to match its needs -->
         <docker-java.version>3.7.0</docker-java.version> <!-- must be the version Testcontainers use: https://central.sonatype.com/artifact/org.testcontainers/testcontainers -->
         <!-- Check the compatibility matrix (https://github.com/opensearch-project/opensearch-testcontainers) before upgrading: -->
@@ -3518,6 +3517,11 @@
                 <artifactId>quarkus-junit-config</artifactId>
                 <version>${project.version}</version>
             </dependency>
+            <dependency>
+                <groupId>io.quarkus</groupId>
+                <artifactId>quarkus-junit-common</artifactId>
+                <version>${project.version}</version>
+            </dependency>
             <dependency>
                 <groupId>io.quarkus</groupId>
                 <artifactId>quarkus-junit-component</artifactId>
@@ -3928,23 +3932,33 @@
             </dependency>
             <dependency>
                 <groupId>io.apicurio</groupId>
-                <artifactId>apicurio-registry-client</artifactId>
+                <artifactId>apicurio-registry-java-sdk</artifactId>
                 <version>${apicurio-registry.version}</version>
             </dependency>
             <dependency>
                 <groupId>io.apicurio</groupId>
-                <artifactId>apicurio-registry-serdes-avro-serde</artifactId>
+                <artifactId>apicurio-registry-avro-serde-kafka</artifactId>
                 <version>${apicurio-registry.version}</version>
             </dependency>
             <dependency>
                 <groupId>io.apicurio</groupId>
-                <artifactId>apicurio-registry-serdes-jsonschema-serde</artifactId>
+                <artifactId>apicurio-registry-jsonschema-serde-kafka</artifactId>
                 <version>${apicurio-registry.version}</version>
             </dependency>
             <dependency>
                 <groupId>io.apicurio</groupId>
-                <artifactId>apicurio-common-rest-client-vertx</artifactId>
-                <version>${apicurio-common-rest-client.version}</version>
+                <artifactId>apicurio-registry-serde-common</artifactId>
+                <version>${apicurio-registry.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>io.apicurio</groupId>
+                <artifactId>apicurio-registry-serde-kafka-common</artifactId>
+                <version>${apicurio-registry.version}</version>
+            </dependency>
+            <dependency>
+                <groupId>io.apicurio</groupId>
+                <artifactId>apicurio-registry-serde-common-jsonschema</artifactId>
+                <version>${apicurio-registry.version}</version>
             </dependency>
             <dependency>
                 <groupId>io.quarkus</groupId>
diff --git a/bom/dev-ui/pom.xml b/bom/dev-ui/pom.xml
index 6bd6da33bc2..93a70599f0f 100644
--- a/bom/dev-ui/pom.xml
+++ b/bom/dev-ui/pom.xml
@@ -35,7 +35,7 @@
         <echarts.version>6.0.0</echarts.version>
         <es-module-shims.version>2.0.10</es-module-shims.version>
         <path-to-regexp.version>6.3.0</path-to-regexp.version>
-        <type-fest.version>5.4.2</type-fest.version>
+        <type-fest.version>5.4.3</type-fest.version>
         <tagged-tag.version>1.0.0</tagged-tag.version>
         <codeblock.version>1.1.2</codeblock.version>
         <qomponent.version>1.0.4</qomponent.version>
diff --git a/build-parent/pom.xml b/build-parent/pom.xml
index e0cc736b901..4975b7bff60 100644
--- a/build-parent/pom.xml
+++ b/build-parent/pom.xml
@@ -114,7 +114,7 @@
         <!-- Dev Services Images -->
         <!-- TODO switch to apache/activemq-artemis to match the artemis version-->
         <amqp.image>quay.io/artemiscloud/activemq-artemis-broker:1.0.25</amqp.image>
-        <apicurio-registry.image>quay.io/apicurio/apicurio-registry-mem:2.6.13.Final</apicurio-registry.image>
+        <apicurio-registry.image>quay.io/apicurio/apicurio-registry:3.1.7</apicurio-registry.image>
         <narayana-lra.image>quay.io/jbosstm/lra-coordinator:latest</narayana-lra.image>
         <rabbitmq.image>docker.io/library/rabbitmq:3.12-management</rabbitmq.image>
         <pulsar.image>docker.io/apachepulsar/pulsar:3.2.4</pulsar.image>
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/builditem/DevServicesRegistryBuildItem.java b/core/deployment/src/main/java/io/quarkus/deployment/builditem/DevServicesRegistryBuildItem.java
index 656d0d38ead..272561256bb 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/builditem/DevServicesRegistryBuildItem.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/builditem/DevServicesRegistryBuildItem.java
@@ -84,22 +84,25 @@ public Map<String, String> getConfigForAllRunningServices() {
 
     public void startAll(Collection<DevServicesResultBuildItem> services,
             List<DevServicesCustomizerBuildItem> customizers,
+            List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems,
             ClassLoader augmentClassLoader) {
         closeRemainingRunningServices(services);
         Map<String, String> config = new ConcurrentHashMap<>();
-        startSelectedServices(services, customizers, augmentClassLoader, dr -> !dr.hasDependencies(), config);
+        startSelectedServices(services, customizers, additionalConfigBuildItems, augmentClassLoader,
+                dr -> !dr.hasDependencies(), config);
 
         // Now start everything with a dependency
         // This won't handle the case where the dependencies also have dependencies, but that can be a follow-on work item if people ask for it
         // I think we could implement it by getting the actual dependencies and seeing if any of them are also in the list of things we're starting, and then recursing
-        startSelectedServices(services, customizers, augmentClassLoader,
+        startSelectedServices(services, customizers, additionalConfigBuildItems, augmentClassLoader,
                 DevServicesResultBuildItem::hasDependencies, config);
 
     }
 
     private void startSelectedServices(Collection<DevServicesResultBuildItem> services,
-            List<DevServicesCustomizerBuildItem> customizers, ClassLoader augmentClassLoader,
-            Predicate<? super DevServicesResultBuildItem> filter, Map<String, String> config) {
+            List<DevServicesCustomizerBuildItem> customizers,
+            List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems,
+            ClassLoader augmentClassLoader, Predicate<? super DevServicesResultBuildItem> filter, Map<String, String> config) {
         // TODO Note that this does not handle chained dependencies; dependencies can only be one level deep for now
         // It would be easy to fix that, but let's wait until we need to
         CompletableFuture.allOf(services.stream()
@@ -112,13 +115,13 @@ private void startSelectedServices(Collection<DevServicesResultBuildItem> servic
                     } else {
                         Thread.currentThread().setContextClassLoader(serv.getClass().getClassLoader());
                     }
-                    this.start(serv, customizers, config);
+                    this.start(serv, customizers, additionalConfigBuildItems, config);
                 }))
                 .toArray(CompletableFuture[]::new)).join();
     }
 
     public void start(DevServicesResultBuildItem request, List<DevServicesCustomizerBuildItem> customizers,
-            Map<String, String> config) {
+            List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems, Map<String, String> config) {
         // RunningService class is loaded on parent classloader
         RunningService matchedDevService = this.getRunningServices(request.getName(), request.getServiceName(),
                 request.getServiceConfig());
@@ -128,12 +131,12 @@ public void start(DevServicesResultBuildItem request, List<DevServicesCustomizer
             // Let's get all the running dev services associated with this feature (+ launch mode plus named section), so we can close them
             closeAllRunningServices(request.getName(), request.getServiceName());
 
-            reallyStart(request, customizers, config);
+            reallyStart(request, customizers, additionalConfigBuildItems, config);
         }
     }
 
     private void reallyStart(DevServicesResultBuildItem request, List<DevServicesCustomizerBuildItem> customizers,
-            Map<String, String> configs) {
+            List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems, Map<String, String> configs) {
         StartupLogCompressor compressor = new StartupLogCompressor("Dev Services Startup", null, null);
         try {
             Supplier<Startable> startableSupplier = request.getStartableSupplier();
@@ -173,18 +176,23 @@ private void reallyStart(DevServicesResultBuildItem request, List<DevServicesCus
             }
 
             if (missingDependency == null) {
-
                 startable.start();
-
-                Map<String, String> config = request.getConfig(startable);
-                Map<String, String> overrideConfig = request.getOverrideConfig(startable);
-                configs.putAll(config);
-                configs.putAll(overrideConfig);
-
+                // We do not "copy" the config map here since it is created within the request.getConfig:
+                Map<String, String> combinedConfig = request.getConfig(startable);
+                // Some extensions may rely on adding/overriding config properties
+                //  depending on the results of the started dev services,
+                //  e.g. Hibernate Search/ORM may change the default schema management
+                //  if it detects that it runs over a dev service datasource/Elasticsearch distribution.
+                for (DevServicesAdditionalConfigBuildItem additionalConfigBuildItem : additionalConfigBuildItems) {
+                    Map<String, String> extraFromBuildItem = additionalConfigBuildItem.getConfigProvider()
+                            .provide(combinedConfig);
+                    if (!extraFromBuildItem.isEmpty()) {
+                        combinedConfig.putAll(extraFromBuildItem);
+                    }
+                }
                 RunningService service = new RunningService(request.getName(), request.getDescription(),
-                        config, overrideConfig, startable.getContainerId(), startable);
+                        combinedConfig, request.getOverrideConfig(startable), startable.getContainerId(), startable);
                 this.addRunningService(request.getName(), request.getServiceName(), request.getServiceConfig(), service);
-
                 compressor.close();
 
                 Consumer<Startable> postStartAction = request.getPostStartAction();
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/configuration/RunTimeConfigurationGenerator.java b/core/deployment/src/main/java/io/quarkus/deployment/configuration/RunTimeConfigurationGenerator.java
index 71dad0b117e..67170c68eb2 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/configuration/RunTimeConfigurationGenerator.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/configuration/RunTimeConfigurationGenerator.java
@@ -11,6 +11,7 @@
 import java.util.NoSuchElementException;
 import java.util.Set;
 
+import org.eclipse.microprofile.config.spi.ConfigProviderResolver;
 import org.objectweb.asm.Opcodes;
 
 import io.quarkus.deployment.configuration.matching.ConfigPatternMap;
@@ -22,6 +23,7 @@
 import io.quarkus.gizmo.MethodCreator;
 import io.quarkus.gizmo.MethodDescriptor;
 import io.quarkus.gizmo.ResultHandle;
+import io.quarkus.runtime.LaunchMode;
 import io.quarkus.runtime.ValueRegistryConfigSource;
 import io.quarkus.runtime.annotations.ConfigPhase;
 import io.quarkus.runtime.configuration.AbstractConfigBuilder;
@@ -37,6 +39,7 @@
 import io.smallrye.config.SmallRyeConfig;
 import io.smallrye.config.SmallRyeConfigBuilder;
 import io.smallrye.config.SmallRyeConfigBuilderCustomizer;
+import io.smallrye.config.SmallRyeConfigProviderResolver;
 
 /**
  *
@@ -115,6 +118,7 @@ private RunTimeConfigurationGenerator() {
 
     public static final class GenerateOperation implements AutoCloseable {
         final boolean liveReloadPossible;
+        final LaunchMode launchMode;
         final BuildTimeConfigurationReader.ReadResult buildTimeConfigResult;
         final ClassOutput classOutput;
         final ClassCreator cc;
@@ -125,6 +129,7 @@ public static final class GenerateOperation implements AutoCloseable {
 
         GenerateOperation(Builder builder) {
             liveReloadPossible = builder.liveReloadPossible;
+            launchMode = builder.getLaunchMode();
             buildTimeConfigResult = Assert.checkNotNullParam("buildTimeReadResult", builder.getBuildTimeReadResult());
             classOutput = Assert.checkNotNullParam("classOutput", builder.getClassOutput());
             cc = ClassCreator.builder().classOutput(classOutput).className(CONFIG_CLASS_NAME).setFinal(true).build();
@@ -166,6 +171,14 @@ public static final class GenerateOperation implements AutoCloseable {
         }
 
         public void run() {
+            if (!launchMode.isDevOrTest()) {
+                // Directly set the config resolver to avoid service loader. Test and Dev must set the resolver, so we cannot override it
+                clinit.invokeStaticMethod(
+                        MethodDescriptor.ofMethod(ConfigProviderResolver.class, "setInstance", void.class,
+                                ConfigProviderResolver.class),
+                        clinit.newInstance(MethodDescriptor.ofConstructor(SmallRyeConfigProviderResolver.class)));
+            }
+
             // in clinit, load the build-time config
             // make the build time config global until we read the run time config -
             // at run time (when we're ready) we update the factory and then release the build time config
@@ -415,12 +428,31 @@ public static Builder builder() {
 
         public static final class Builder {
             public boolean liveReloadPossible;
+            private LaunchMode launchMode;
             private ClassOutput classOutput;
             private BuildTimeConfigurationReader.ReadResult buildTimeReadResult;
 
             Builder() {
             }
 
+            public boolean isLiveReloadPossible() {
+                return liveReloadPossible;
+            }
+
+            public Builder setLiveReloadPossible(boolean liveReloadPossible) {
+                this.liveReloadPossible = liveReloadPossible;
+                return this;
+            }
+
+            public LaunchMode getLaunchMode() {
+                return launchMode;
+            }
+
+            public Builder setLaunchMode(LaunchMode launchMode) {
+                this.launchMode = launchMode;
+                return this;
+            }
+
             ClassOutput getClassOutput() {
                 return classOutput;
             }
@@ -430,11 +462,6 @@ public Builder setClassOutput(final ClassOutput classOutput) {
                 return this;
             }
 
-            public Builder setLiveReloadPossible(boolean liveReloadPossible) {
-                this.liveReloadPossible = liveReloadPossible;
-                return this;
-            }
-
             BuildTimeConfigurationReader.ReadResult getBuildTimeReadResult() {
                 return buildTimeReadResult;
             }
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedDevModeMain.java b/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedDevModeMain.java
index 5e774137a64..8602c23ee90 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedDevModeMain.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedDevModeMain.java
@@ -49,6 +49,7 @@
 import io.quarkus.dev.spi.HotReplacementSetup;
 import io.quarkus.runner.bootstrap.AugmentActionImpl;
 import io.quarkus.runtime.ApplicationLifecycleManager;
+import io.quarkus.runtime.JVMUnsafeWarningsControl;
 import io.quarkus.runtime.configuration.QuarkusConfigFactory;
 import io.quarkus.runtime.logging.LoggingSetupRecorder;
 
@@ -378,6 +379,9 @@ public void close() {
     //the main entry point, but loaded inside the augmentation class loader
     @Override
     public void accept(CuratedApplication o, Map<String, Object> params) {
+        // Ensure JVM warnings are suppressed for all dev mode entry points (idempotent)
+        JVMUnsafeWarningsControl.disableUnsafeRelatedWarnings();
+
         //setup the dev mode thread pool for NIO
         System.setProperty("java.nio.channels.DefaultThreadPool.threadFactory",
                 "io.quarkus.dev.io.NioThreadPoolThreadFactory");
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedTestModeMain.java b/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedTestModeMain.java
index 9fa94f1ff6a..d0e1765d84b 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedTestModeMain.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedTestModeMain.java
@@ -21,11 +21,13 @@
 import io.quarkus.deployment.dev.testing.TestHandler;
 import io.quarkus.deployment.dev.testing.TestSetupBuildItem;
 import io.quarkus.deployment.dev.testing.TestSupport;
+import io.quarkus.deployment.jvm.ResolvedJVMRequirements;
 import io.quarkus.deployment.logging.LoggingSetupBuildItem;
 import io.quarkus.deployment.steps.ClassTransformingBuildStep;
 import io.quarkus.dev.spi.DevModeType;
 import io.quarkus.dev.spi.HotReplacementSetup;
 import io.quarkus.runner.bootstrap.AugmentActionImpl;
+import io.quarkus.runtime.JVMUnsafeWarningsControl;
 import io.quarkus.runtime.Quarkus;
 
 /**
@@ -104,6 +106,9 @@ public void close() {
     //the main entry point, but loaded inside the augmentation class loader
     @Override
     public void accept(CuratedApplication o, Map<String, Object> params) {
+        // Ensure JVM warnings are suppressed for all dev mode entry points (idempotent)
+        JVMUnsafeWarningsControl.disableUnsafeRelatedWarnings();
+
         System.setProperty("java.nio.channels.DefaultThreadPool.threadFactory",
                 "io.quarkus.dev.io.NioThreadPoolThreadFactory");
         Timing.staticInitStarted(o.getOrCreateBaseRuntimeClassLoader(), false);
@@ -129,7 +134,8 @@ public void accept(CuratedApplication o, Map<String, Object> params) {
             }
             try {
                 augmentAction.performCustomBuild(TestHandler.class.getName(), null, TestSetupBuildItem.class.getName(),
-                        LoggingSetupBuildItem.class.getName(), ConsoleFormatterBannerBuildItem.class.getName());
+                        LoggingSetupBuildItem.class.getName(), ConsoleFormatterBannerBuildItem.class.getName(),
+                        ResolvedJVMRequirements.class.getName());
             } catch (Throwable t) {
                 //logging may not have been started, this is more reliable
                 System.err.println("Failed to start quarkus test mode");
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/dev/testing/TestHandler.java b/core/deployment/src/main/java/io/quarkus/deployment/dev/testing/TestHandler.java
index e56a57c7590..21de381d302 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/dev/testing/TestHandler.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/dev/testing/TestHandler.java
@@ -8,6 +8,8 @@
 import io.quarkus.banner.BannerConfig;
 import io.quarkus.builder.BuildResult;
 import io.quarkus.deployment.dev.testing.TestConfig.Mode;
+import io.quarkus.deployment.jvm.JvmModulesReconfigurer;
+import io.quarkus.deployment.jvm.ResolvedJVMRequirements;
 import io.quarkus.deployment.steps.BannerProcessor;
 import io.quarkus.dev.console.QuarkusConsole;
 import io.quarkus.runtime.BannerRecorder;
@@ -17,8 +19,16 @@
 import io.smallrye.config.SmallRyeConfig;
 
 public class TestHandler implements BiConsumer<Object, BuildResult> {
+
+    private static final JvmModulesReconfigurer jvmModulesReconfigurer = JvmModulesReconfigurer.getInstance();
+
     @Override
     public void accept(Object o, BuildResult buildResult) {
+        // Apply JVM module configuration for test mode (add-opens, etc.)
+        ResolvedJVMRequirements jvmRequirements = buildResult.consume(ResolvedJVMRequirements.class);
+        jvmRequirements.applyJavaModuleConfigurationToRuntime(jvmModulesReconfigurer,
+                Thread.currentThread().getContextClassLoader());
+
         QuarkusConsole.start();
         TestSupport.instance().get().start();
 
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/images/ContainerImages.java b/core/deployment/src/main/java/io/quarkus/deployment/images/ContainerImages.java
index 1ec78a5e142..d76b09045ec 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/images/ContainerImages.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/images/ContainerImages.java
@@ -4,6 +4,9 @@
 import io.quarkus.deployment.pkg.builditem.CompiledJavaVersionBuildItem.JavaVersion.Status;
 
 /**
+ * IMPORTANT: when updating this file, please also update
+ * {@code devtools/bom-descriptor-json/src/main/resources/catalog-overrides.json}
+ *
  * This class is used to define the container images that are used by Quarkus.
  * <p>
  * For each image, the image name and version are defined as constants:
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/jvm/JvmModulesReconfigurer.java b/core/deployment/src/main/java/io/quarkus/deployment/jvm/JvmModulesReconfigurer.java
index 5b31bc489ed..7f993b2e6ab 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/jvm/JvmModulesReconfigurer.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/jvm/JvmModulesReconfigurer.java
@@ -19,13 +19,21 @@ public interface JvmModulesReconfigurer {
     void openJavaModules(List<ModuleOpenBuildItem> addOpens, ModulesClassloaderContext referenceClassloader);
 
     /**
-     * Creates a new instance of {@link JvmModulesReconfigurer}.
-     * Initialization of such services is fairly costly: try
-     * to avoid it, and aim to reuse the produced instance.
-     *
-     * @return a new {@link JvmModulesReconfigurer} instance
+     * Thread-safe lazy holder for the singleton instance: this is expensive to create and tied to the JVM,
+     * so we like it to be lazy and shared.
      */
-    static JvmModulesReconfigurer create() {
+    final class Holder {
+        static final JvmModulesReconfigurer INSTANCE = JvmModulesReconfigurer.create();
+    }
+
+    /**
+     * @return the shared {@link JvmModulesReconfigurer} instance
+     */
+    static JvmModulesReconfigurer getInstance() {
+        return Holder.INSTANCE;
+    }
+
+    private static JvmModulesReconfigurer create() {
         final Logger logger = JVMDeploymentLogger.logger;
 
         //First thing to check, is if we have our agent connected; that would make things really simple and avoid any need
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/pkg/AotClassLoadingEnabled.java b/core/deployment/src/main/java/io/quarkus/deployment/pkg/AotClassLoadingEnabled.java
index 5f2070ad20e..aab7cf4d5a6 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/pkg/AotClassLoadingEnabled.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/pkg/AotClassLoadingEnabled.java
@@ -13,7 +13,6 @@ public class AotClassLoadingEnabled implements BooleanSupplier {
     @Override
     public boolean getAsBoolean() {
         return packageConfig.jar().enabled() &&
-                packageConfig.jar().appcds().enabled() &&
                 packageConfig.jar().appcds().useAot();
     }
 }
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/AbstractFastJarBuilder.java b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/AbstractFastJarBuilder.java
index 0ff69d81183..1e16f5cd9ad 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/AbstractFastJarBuilder.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/AbstractFastJarBuilder.java
@@ -160,7 +160,7 @@ public JarBuildItem build() throws IOException {
             fastJarJarsBuilder.setTransformedJar(transformedZip);
             try (ArchiveCreator archiveCreator = new ParallelCommonsCompressArchiveCreator(transformedZip,
                     packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null),
-                    outputTarget.getOutputDirectory(), executorService)) {
+                    executorService)) {
                 // we make sure the entries are added in a reproducible order
                 // we use Path#toString() to get a reproducible order on both Unix-based OSes and Windows
                 for (Entry<Path, Set<TransformedClass>> transformedClassEntry : transformedClasses
@@ -182,7 +182,7 @@ public JarBuildItem build() throws IOException {
         Path generatedZip = quarkus.resolve(FastJarFormat.GENERATED_BYTECODE_JAR);
         fastJarJarsBuilder.setGeneratedJar(generatedZip);
         try (ArchiveCreator archiveCreator = new ParallelCommonsCompressArchiveCreator(generatedZip,
-                packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null), outputTarget.getOutputDirectory(),
+                packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null),
                 executorService)) {
             // make sure we write the elements in order
             for (GeneratedClassBuildItem i : generatedClasses.stream()
@@ -216,7 +216,7 @@ public JarBuildItem build() throws IOException {
             Predicate<String> ignoredEntriesPredicate = getThinJarIgnoredEntriesPredicate(packageConfig);
             try (ArchiveCreator archiveCreator = new ParallelCommonsCompressArchiveCreator(runnerJar,
                     packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null),
-                    outputTarget.getOutputDirectory(), executorService)) {
+                    executorService)) {
                 copyFiles(applicationArchives.getRootArchive(), archiveCreator, null, ignoredEntriesPredicate);
             }
         }
@@ -287,7 +287,7 @@ public JarBuildItem build() throws IOException {
         if (!rebuild) {
             try (ArchiveCreator archiveCreator = new ParallelCommonsCompressArchiveCreator(initJar,
                     packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null),
-                    outputTarget.getOutputDirectory(), executorService)) {
+                    executorService)) {
                 ResolvedDependency appArtifact = curateOutcome.getApplicationModel().getAppArtifact();
                 generateManifest(archiveCreator, getClassPath(fastJarJars), packageConfig, appArtifact,
                         jvmRequirements,
@@ -465,7 +465,7 @@ private static void packageClasses(Path resolvedDep, final Path targetPath, Pack
             OutputTargetBuildItem outputTargetBuildItem, ExecutorService executorService) throws IOException {
         try (ArchiveCreator archiveCreator = new ParallelCommonsCompressArchiveCreator(targetPath,
                 packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null),
-                outputTargetBuildItem.getOutputDirectory(), executorService)) {
+                executorService)) {
             Files.walkFileTree(resolvedDep, EnumSet.of(FileVisitOption.FOLLOW_LINKS), Integer.MAX_VALUE,
                     new SimpleFileVisitor<Path>() {
                         @Override
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/AbstractLegacyThinJarBuilder.java b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/AbstractLegacyThinJarBuilder.java
index 1e9f8add40f..e8cd20d1285 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/AbstractLegacyThinJarBuilder.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/AbstractLegacyThinJarBuilder.java
@@ -54,7 +54,7 @@ public AbstractLegacyThinJarBuilder(CurateOutcomeBuildItem curateOutcome,
 
     protected void doBuild(Path runnerJar, Path libDir) throws IOException {
         try (ArchiveCreator archiveCreator = new ParallelCommonsCompressArchiveCreator(runnerJar,
-                packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null), outputTarget.getOutputDirectory(),
+                packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null),
                 executorService)) {
             final Map<String, String> seen = new HashMap<>();
             final StringBuilder classPath = new StringBuilder();
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/ParallelCommonsCompressArchiveCreator.java b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/ParallelCommonsCompressArchiveCreator.java
index 1749cb791d7..c16461255c2 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/ParallelCommonsCompressArchiveCreator.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/ParallelCommonsCompressArchiveCreator.java
@@ -61,7 +61,7 @@ public class ParallelCommonsCompressArchiveCreator implements ArchiveCreator {
     private Manifest manifest;
     private final Map<String, String> addedFiles = new HashMap<>();
 
-    ParallelCommonsCompressArchiveCreator(Path archivePath, boolean compressed, Instant entryTimestamp, Path outputTarget,
+    ParallelCommonsCompressArchiveCreator(Path archivePath, boolean compressed, Instant entryTimestamp,
             ExecutorService executorService) throws IOException {
         int compressionLevel;
         if (compressed) {
@@ -81,14 +81,14 @@ public class ParallelCommonsCompressArchiveCreator implements ArchiveCreator {
         this.entryTimestamp = entryTimestamp != null ? FileTime.from(entryTimestamp) : null;
         this.archive = new ZipArchiveOutputStream(archivePath);
         this.archive.setMethod(compressionMethod);
-        this.tempDirectory = Files.createTempDirectory(outputTarget, "zip-builder-files");
+        this.tempDirectory = Files.createTempDirectory("zip-builder-files");
 
         scatterZipCreator = new ParallelScatterZipCreator(
                 // we need to make sure our own executor won't be shut down by Commons Compress...
                 new DoNotShutdownDelegatingExecutorService(executorService),
                 new DefaultBackingStoreSupplier(this.tempDirectory),
                 compressionLevel);
-        directories = ScatterZipOutputStream.pathBased(Files.createTempFile(outputTarget, "zip-builder-dirs", ""),
+        directories = ScatterZipOutputStream.pathBased(Files.createTempFile("zip-builder-dirs", ""),
                 compressionLevel);
     }
 
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java
index 154a5281e64..d9608b977da 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/pkg/jar/UberJarBuilder.java
@@ -144,7 +144,7 @@ public JarBuildItem build() throws IOException {
     private void buildUberJar0(Path runnerJar) throws IOException {
 
         try (ArchiveCreator archiveCreator = new ParallelCommonsCompressArchiveCreator(runnerJar,
-                packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null), outputTarget.getOutputDirectory(),
+                packageConfig.jar().compress(), packageConfig.outputTimestamp().orElse(null),
                 executorService)) {
             LOG.info("Building uber jar: " + runnerJar);
 
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java b/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java
index 2de3d93c58a..80247fd792d 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java
@@ -366,6 +366,7 @@ void generateConfigClass(
 
         RunTimeConfigurationGenerator.GenerateOperation
                 .builder()
+                .setLaunchMode(launchModeBuildItem.getLaunchMode())
                 .setBuildTimeReadResult(configItem.getReadResult())
                 .setClassOutput(new GeneratedClassGizmoAdaptor(generatedClass, false))
                 .setLiveReloadPossible(launchModeBuildItem.getLaunchMode() == LaunchMode.DEVELOPMENT
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/steps/NativeImageFeatureStep.java b/core/deployment/src/main/java/io/quarkus/deployment/steps/NativeImageFeatureStep.java
index a99adf76a4a..60858424ada 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/steps/NativeImageFeatureStep.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/steps/NativeImageFeatureStep.java
@@ -93,6 +93,14 @@ void generateFeature(BuildProducer<GeneratedNativeImageClassBuildItem> nativeIma
                 mc.body(b0 -> b0.return_(Const.of("Auto-generated class by Quarkus from the existing extensions")));
             });
 
+            cc.method("duringSetup", mc -> {
+                mc.parameter("access", Feature.DuringSetupAccess.class);
+                mc.body(b0 -> {
+                    b0.invokeStatic(BUILD_TIME_INITIALIZATION, b0.newArray(String.class, Const.of("")));
+                    b0.return_();
+                });
+            });
+
             cc.method("beforeAnalysis", mc -> {
                 ParamVar access = mc.parameter("access", Feature.BeforeAnalysisAccess.class);
                 MethodDesc classForName3 = MethodDesc.of(Class.class, "forName", Class.class, String.class, boolean.class,
@@ -100,7 +108,6 @@ void generateFeature(BuildProducer<GeneratedNativeImageClassBuildItem> nativeIma
                 mc.body(b0 -> {
                     b0.try_(t1 -> {
                         t1.body(b2 -> {
-                            b2.invokeStatic(BUILD_TIME_INITIALIZATION, b2.newArray(String.class, Const.of("")));
                             LocalVar cl = b2.localVar("cl", b2.invokeVirtual(MD_Class.getClassLoader, Const.of(cc.type())));
                             if (localesBuildTimeConfig.defaultLocale().isPresent()) {
                                 Locale defaultLocale = localesBuildTimeConfig.defaultLocale().get();
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/steps/ReflectiveHierarchyStep.java b/core/deployment/src/main/java/io/quarkus/deployment/steps/ReflectiveHierarchyStep.java
index 9cd356ea98e..b86bbcf16fe 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/steps/ReflectiveHierarchyStep.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/steps/ReflectiveHierarchyStep.java
@@ -269,7 +269,7 @@ private void addClassTypeHierarchy(NativeConfig nativeConfig, CombinedIndexBuild
             }
             final Type fieldType = getFieldType(combinedIndexBuildItem, initialName, info, field);
             visits.addLast(
-                    () -> addReflectiveHierarchyRecursively(nativeConfig, combinedIndexBuildItem, capabilities,
+                    () -> addReflectiveHierarchy(nativeConfig, combinedIndexBuildItem, capabilities,
                             reflectiveHierarchyBuildItem, source,
                             fieldType,
                             processedReflectiveHierarchies,
@@ -283,7 +283,7 @@ private void addClassTypeHierarchy(NativeConfig nativeConfig, CombinedIndexBuild
                     method.returnType().kind() == Kind.VOID) {
                 continue;
             }
-            visits.addLast(() -> addReflectiveHierarchyRecursively(nativeConfig, combinedIndexBuildItem, capabilities,
+            visits.addLast(() -> addReflectiveHierarchy(nativeConfig, combinedIndexBuildItem, capabilities,
                     reflectiveHierarchyBuildItem, source,
                     method.returnType(),
                     processedReflectiveHierarchies,
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/util/ArtifactInfoUtil.java b/core/deployment/src/main/java/io/quarkus/deployment/util/ArtifactInfoUtil.java
index da56492b422..a5be46d2ad0 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/util/ArtifactInfoUtil.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/util/ArtifactInfoUtil.java
@@ -55,19 +55,37 @@ public static Map.Entry<String, String> groupIdAndArtifactId(Class<?> clazz,
                 // the jar to read the pom properties, which gets done as next attempt.
                 // This also acts as a fast path to prevent expensive path comparisons.
                 boolean isJar = pathAsString.endsWith(".jar");
+                // Check if this is a target/classes directory (workspace module loaded from classes)
+                boolean isTargetClasses = !isJar
+                        && pathAsString.endsWith("target" + path.getFileSystem().getSeparator() + "classes");
                 for (ResolvedDependency i : curateOutcomeBuildItem.getApplicationModel().getDependencies()) {
                     if (isJar && !pathAsString.contains(i.getArtifactId())) {
                         continue;
                     }
                     for (Path p : i.getResolvedPaths()) {
                         if (path.equals(p)) {
-
                             String artifactId = i.getArtifactId();
                             if (artifactId.endsWith(DEPLOYMENT)) {
                                 artifactId = artifactId.substring(0, artifactId.length() - DEPLOYMENT.length());
                             }
                             return new AbstractMap.SimpleEntry<>(i.getGroupId(), artifactId);
                         }
+                        // Handle case where class is loaded from target/classes but dependency points to target/*.jar
+                        // This happens in multi-module projects where workspace modules are resolved to their JAR files
+                        if (isTargetClasses && p.toString().endsWith(".jar")) {
+                            // Check if the JAR is in the same target directory as our classes
+                            // path: .../module/target/classes
+                            // p:    .../module/target/artifact-version.jar
+                            Path classesTargetDir = path.getParent(); // .../module/target
+                            Path jarParentDir = p.getParent(); // .../module/target (if JAR is in target dir)
+                            if (classesTargetDir != null && classesTargetDir.equals(jarParentDir)) {
+                                String artifactId = i.getArtifactId();
+                                if (artifactId.endsWith(DEPLOYMENT)) {
+                                    artifactId = artifactId.substring(0, artifactId.length() - DEPLOYMENT.length());
+                                }
+                                return new AbstractMap.SimpleEntry<>(i.getGroupId(), artifactId);
+                            }
+                        }
                     }
                 }
             }
@@ -90,10 +108,10 @@ public static Map.Entry<String, String> groupIdAndArtifactId(Class<?> clazz,
                 // Just try to locate the pom.properties file in the target/maven-archiver directory
                 // Note that this hack will not work if addMavenDescriptor=false or if the pomPropertiesFile is overridden
                 Path location = Paths.get(codeLocation.toURI());
-                while (!isDeploymentTargetClasses(location) && location.getParent() != null) {
+                while (!isTargetClasses(location) && location.getParent() != null) {
                     location = location.getParent();
                 }
-                if (location != null) {
+                if (isTargetClasses(location)) {
                     Path mavenArchiver = location.getParent().resolve("maven-archiver");
                     if (mavenArchiver.toFile().canRead()) {
                         Entry<String, String> ret = groupIdAndArtifactId(mavenArchiver);
@@ -116,19 +134,19 @@ public static Map.Entry<String, String> groupIdAndArtifactId(Class<?> clazz,
         }
     }
 
-    static boolean isDeploymentTargetClasses(Path location) {
-        if (!location.getFileName().toString().equals("classes")) {
-            return false;
-        }
-        Path target = location.getParent();
-        if (target == null || !target.getFileName().toString().equals("target")) {
+    /**
+     * Checks if the given path represents a Maven target/classes directory.
+     * This works for any module type (deployment, runtime, spi, etc.).
+     */
+    static boolean isTargetClasses(Path location) {
+        if (location == null || location.getFileName() == null) {
             return false;
         }
-        Path deployment = location.getParent().getParent();
-        if (deployment == null || !deployment.getFileName().toString().equals("deployment")) {
+        if (!location.getFileName().toString().equals("classes")) {
             return false;
         }
-        return true;
+        Path target = location.getParent();
+        return !(target == null || target.getFileName() == null || !target.getFileName().toString().equals("target"));
     }
 
     /**
diff --git a/core/deployment/src/main/java/io/quarkus/runner/bootstrap/AugmentActionImpl.java b/core/deployment/src/main/java/io/quarkus/runner/bootstrap/AugmentActionImpl.java
index 6037592a68d..2a0a0edba48 100644
--- a/core/deployment/src/main/java/io/quarkus/runner/bootstrap/AugmentActionImpl.java
+++ b/core/deployment/src/main/java/io/quarkus/runner/bootstrap/AugmentActionImpl.java
@@ -11,7 +11,6 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
-import java.util.ListIterator;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Properties;
@@ -282,23 +281,41 @@ private void writeArtifactResultMetadataFile(BuildSystemTargetBuildItem outputTa
     }
 
     private ArtifactResultBuildItem effectiveArtifact(List<ArtifactResultBuildItem> artifactResultBuildItems) {
-        // the native artifact should be considered first in case we build both a jar and a native image
-        Optional<ArtifactResultBuildItem> nativeArtifact = artifactResultBuildItems.stream()
-                .filter(a -> NativeImageBuildStep.ARTIFACT_RESULT_TYPE.equals(a.getType()))
-                .findFirst();
-        if (nativeArtifact.isPresent()) {
-            return nativeArtifact.get();
+
+        Optional<PrioritizedArtifactResultBuildItem> first = artifactResultBuildItems.stream()
+                .map(PrioritizedArtifactResultBuildItem::new)
+                .sorted(((o1, o2) -> Integer.compare(o2.getPriority(), o1.getPriority())))
+                .filter(bi -> bi.getPriority() > 0).findFirst();
+
+        if (first.isEmpty()) {
+            throw new IllegalStateException("Unable to locate effective artifact");
         }
 
-        ListIterator<ArtifactResultBuildItem> li = artifactResultBuildItems.listIterator(artifactResultBuildItems.size());
-        while (li.hasPrevious()) {
-            ArtifactResultBuildItem result = li.previous();
-            if ("appCDS".equals(result.getType())) {
-                continue;
+        return first.get().bi();
+    }
+
+    private record PrioritizedArtifactResultBuildItem(ArtifactResultBuildItem bi) {
+
+        public int getPriority() {
+            String type = bi.getType();
+            // max priority
+            if (type.endsWith("container")) {
+                return 1000;
             }
-            return result;
+
+            // native takes priority over jars
+            if (type.equals(NativeImageBuildStep.ARTIFACT_RESULT_TYPE)) {
+                return 100;
+            }
+
+            // least priority
+            if (type.equals("appCDS")) {
+                return 0;
+            }
+
+            // default
+            return 10;
         }
-        throw new IllegalStateException("Unable to locate effective artifact");
     }
 
     private static String artifactPathForResultMetadata(BuildSystemTargetBuildItem outputTargetBuildItem,
diff --git a/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java b/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java
index 3cf46a9d272..751ad55f4ec 100644
--- a/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java
+++ b/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java
@@ -31,6 +31,7 @@
 import io.quarkus.bootstrap.logging.InitialConfigurator;
 import io.quarkus.builder.BuildResult;
 import io.quarkus.deployment.builditem.ApplicationClassNameBuildItem;
+import io.quarkus.deployment.builditem.DevServicesAdditionalConfigBuildItem;
 import io.quarkus.deployment.builditem.DevServicesCustomizerBuildItem;
 import io.quarkus.deployment.builditem.DevServicesLauncherConfigResultBuildItem;
 import io.quarkus.deployment.builditem.DevServicesNetworkIdBuildItem;
@@ -62,12 +63,13 @@ public class StartupActionImpl implements StartupAction {
     private volatile boolean devServicesStarted = false;
     private final List<DevServicesResultBuildItem> devServicesResults;
     private final List<DevServicesCustomizerBuildItem> devServicesCustomizers;
+    private final List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems;
     private final String devServicesNetworkId;
     private final List<RuntimeApplicationShutdownBuildItem> runtimeApplicationShutdownBuildItems;
     private final List<Closeable> runtimeCloseTasks = new ArrayList<>();
     private final DevServicesRegistryBuildItem devServicesRegistry;
 
-    private static final JvmModulesReconfigurer jvmModulesReconfigurer = JvmModulesReconfigurer.create();
+    private static final JvmModulesReconfigurer jvmModulesReconfigurer = JvmModulesReconfigurer.getInstance();
 
     public StartupActionImpl(CuratedApplication curatedApplication, BuildResult buildResult) {
         this.curatedApplication = curatedApplication;
@@ -81,6 +83,7 @@ public StartupActionImpl(CuratedApplication curatedApplication, BuildResult buil
         devServicesResults = buildResult.consumeMulti(DevServicesResultBuildItem.class);
         devServicesRegistry = buildResult.consumeOptional(DevServicesRegistryBuildItem.class);
         devServicesCustomizers = buildResult.consumeMulti(DevServicesCustomizerBuildItem.class);
+        additionalConfigBuildItems = buildResult.consumeMulti(DevServicesAdditionalConfigBuildItem.class);
 
         Map<String, byte[]> transformedClasses = extractTransformedClasses(buildResult);
         QuarkusClassLoader baseClassLoader = curatedApplication.getOrCreateBaseRuntimeClassLoader();
@@ -105,7 +108,11 @@ public StartupActionImpl(CuratedApplication curatedApplication, BuildResult buil
         runtimeClassLoader.setStartupAction(this);
         // Adjust JVM module requirements for this app
         jvmRequirements = buildResult.consume(ResolvedJVMRequirements.class);
-        applyModuleConfigurationToClassloader(runtimeClassLoader);
+        // Apply to both base and runtime classloaders, as classes may be loaded from either
+        applyModuleConfigurationToClassloader(baseClassLoader);
+        if (runtimeClassLoader != baseClassLoader) {
+            applyModuleConfigurationToClassloader(runtimeClassLoader);
+        }
     }
 
     @Override
@@ -306,7 +313,8 @@ private void ensureDevServicesStarted() {
             if (augmentClassLoader == null) {
                 throw new IllegalStateException("Dev services cannot be started without an augmentation class loader.");
             }
-            devServicesRegistry.startAll(devServicesResults, devServicesCustomizers, augmentClassLoader);
+            devServicesRegistry.startAll(devServicesResults, devServicesCustomizers, additionalConfigBuildItems,
+                    augmentClassLoader);
 
             devServicesProperties.putAll(devServicesRegistry.getConfigForAllRunningServices());
         }
diff --git a/core/runtime/src/main/java/io/quarkus/runtime/configuration/Substitutions.java b/core/runtime/src/main/java/io/quarkus/runtime/configuration/Substitutions.java
index 9be7583257a..bfbdcdba0a1 100644
--- a/core/runtime/src/main/java/io/quarkus/runtime/configuration/Substitutions.java
+++ b/core/runtime/src/main/java/io/quarkus/runtime/configuration/Substitutions.java
@@ -19,10 +19,7 @@
 import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 
-import org.eclipse.microprofile.config.spi.ConfigProviderResolver;
-
 import com.oracle.svm.core.annotate.Alias;
-import com.oracle.svm.core.annotate.RecomputeFieldValue;
 import com.oracle.svm.core.annotate.Substitute;
 import com.oracle.svm.core.annotate.TargetClass;
 import com.oracle.svm.core.annotate.TargetElement;
@@ -33,13 +30,6 @@
 import io.smallrye.config.ConfigMappingMetadata;
 
 final class Substitutions {
-    @TargetClass(ConfigProviderResolver.class)
-    static final class Target_ConfigurationProviderResolver {
-
-        @Alias
-        @RecomputeFieldValue(kind = RecomputeFieldValue.Kind.Reset)
-        private static volatile ConfigProviderResolver instance;
-    }
 
     @TargetClass(ConfigMappingLoader.class)
     static final class Target_ConfigMappingLoader {
diff --git a/devtools/bom-descriptor-json/src/main/resources/catalog-overrides.json b/devtools/bom-descriptor-json/src/main/resources/catalog-overrides.json
index e266a01d64c..70724f5f409 100644
--- a/devtools/bom-descriptor-json/src/main/resources/catalog-overrides.json
+++ b/devtools/bom-descriptor-json/src/main/resources/catalog-overrides.json
@@ -145,8 +145,8 @@
     "project": {
       "default-codestart": "rest",
       "codestart-data": {
-        "tooling-dockerfiles.dockerfile.jvm.from-template": "registry.access.redhat.com/ubi9/openjdk-{java.version}:1.23",
-        "tooling-dockerfiles.dockerfile.jvm.from": "registry.access.redhat.com/ubi9/openjdk-${recommended-java-version}:1.23",
+        "tooling-dockerfiles.dockerfile.jvm.from-template": "registry.access.redhat.com/ubi9/openjdk-{java.version}-runtime:1.24",
+        "tooling-dockerfiles.dockerfile.jvm.from": "registry.access.redhat.com/ubi9/openjdk-21-runtime:1.24",
         "tooling-dockerfiles.dockerfile.native.from": "registry.access.redhat.com/ubi9/ubi-minimal:9.7",
         "tooling-dockerfiles.dockerfile.native-micro.from": "quay.io/quarkus/ubi9-quarkus-micro-image:2.0"
       },
diff --git a/devtools/maven/src/main/java/io/quarkus/maven/GenerateCodeMojo.java b/devtools/maven/src/main/java/io/quarkus/maven/GenerateCodeMojo.java
index 4af62b872b3..1f56887d2c8 100644
--- a/devtools/maven/src/main/java/io/quarkus/maven/GenerateCodeMojo.java
+++ b/devtools/maven/src/main/java/io/quarkus/maven/GenerateCodeMojo.java
@@ -122,7 +122,7 @@ void generateCode(PathCollection sourceParents, Consumer<Path> sourceRegistrar,
                             Properties properties = mavenProject().getProperties();
                             String argLine = properties.getProperty("argLine", "");
                             properties.setProperty("argLine", argLine +
-                                    " -D" + BootstrapConstants.SERIALIZED_TEST_APP_MODEL + "=\"" + serializedTestAppModelPath
+                                    " \"-D" + BootstrapConstants.SERIALIZED_TEST_APP_MODEL + "=" + serializedTestAppModelPath
                                     + "\"");
                         } catch (IOException e) {
                             getLog().warn("Failed to serialize application model", e);
diff --git a/devtools/maven/src/main/java/io/quarkus/maven/NativeImageAgentMojo.java b/devtools/maven/src/main/java/io/quarkus/maven/NativeImageAgentMojo.java
index e90e50d46bf..b9d4dbc3d33 100644
--- a/devtools/maven/src/main/java/io/quarkus/maven/NativeImageAgentMojo.java
+++ b/devtools/maven/src/main/java/io/quarkus/maven/NativeImageAgentMojo.java
@@ -93,7 +93,7 @@ protected void doExecute() throws MojoExecutionException, MojoFailureException {
                 throw new MojoExecutionException("Failed to transform native image agent configuration", e);
             }
         } else {
-            getLog().info("Missing " + dirName + " directory with native image agent configuration to transform");
+            getLog().debug("Missing " + dirName + " directory with native image agent configuration to transform");
         }
     }
 
diff --git a/devtools/project-core-extension-codestarts/src/main/resources/codestarts/quarkus/extension-codestarts/hibernate-orm-codestart/base/README.tpl.qute.md b/devtools/project-core-extension-codestarts/src/main/resources/codestarts/quarkus/extension-codestarts/hibernate-orm-codestart/base/README.tpl.qute.md
index 312518fd917..8872e3e1988 100644
--- a/devtools/project-core-extension-codestarts/src/main/resources/codestarts/quarkus/extension-codestarts/hibernate-orm-codestart/base/README.tpl.qute.md
+++ b/devtools/project-core-extension-codestarts/src/main/resources/codestarts/quarkus/extension-codestarts/hibernate-orm-codestart/base/README.tpl.qute.md
@@ -1,5 +1,9 @@
 {#include readme-header /}
 
+{#if input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-panache-next')}
+[Related Hibernate with Panache Next section...](https://quarkus.io/guides/hibernate-panache-next)
+{/if}
+
 {#if input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-orm-panache')}
 [Related Hibernate with Panache section...](https://quarkus.io/guides/hibernate-orm-panache)
 {/if}
diff --git a/devtools/project-core-extension-codestarts/src/main/resources/codestarts/quarkus/extension-codestarts/hibernate-orm-codestart/java/src/main/java/org/acme/MyEntity.tpl.qute.java b/devtools/project-core-extension-codestarts/src/main/resources/codestarts/quarkus/extension-codestarts/hibernate-orm-codestart/java/src/main/java/org/acme/MyEntity.tpl.qute.java
index de8acf86b6a..012a81150be 100644
--- a/devtools/project-core-extension-codestarts/src/main/resources/codestarts/quarkus/extension-codestarts/hibernate-orm-codestart/java/src/main/java/org/acme/MyEntity.tpl.qute.java
+++ b/devtools/project-core-extension-codestarts/src/main/resources/codestarts/quarkus/extension-codestarts/hibernate-orm-codestart/java/src/main/java/org/acme/MyEntity.tpl.qute.java
@@ -1,37 +1,33 @@
 package org.acme;
 
-{#if !input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-orm-panache')}
+{#if input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-panache-next')}
+import io.quarkus.hibernate.panache.PanacheEntity;
 import jakarta.persistence.Entity;
-import jakarta.persistence.GeneratedValue;
-import jakarta.persistence.Id;
+
 
 /**
- * Example JPA entity.
+ * Example JPA entity defined as a Panache Entity.
+ * An ID field of Long type is provided, if you want to define your own ID field extends <code>WithId</code> instead.
  *
- * To use it, get access to a JPA EntityManager via injection.
+ * Documentation: \{@see https://quarkus.io/guides/hibernate-panache-next}
  *
- * \{@code
- *     @Inject
- *     EntityManager em;
+ * Usage:
  *
+ * \{@code
  *     public void doSomething() {
  *         MyEntity entity1 = new MyEntity();
  *         entity1.field = "field-1";
- *         em.persist(entity1);
+ *         entity1.persist();
  *
- *         List<MyEntity> entities = em.createQuery("from MyEntity", MyEntity.class).getResultList();
+ *         List<MyEntity> entities = MyEntity_.managedBlocking().listAll();
  *     }
  * }
  */
 @Entity
-public class MyEntity {
-    @Id
-    @GeneratedValue
-    public Long id;
-
+public class MyEntity extends PanacheEntity {
     public String field;
 }
-{#else}
+{#else if input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-orm-panache')}
 import io.quarkus.hibernate.orm.panache.PanacheEntity;
 import jakarta.persistence.Entity;
 
@@ -41,9 +37,9 @@ public class MyEntity {
  * An ID field of Long type is provided, if you want to define your own ID field extends <code>PanacheEntityBase</code> instead.
  *
  * This uses the active record pattern, you can also use the repository pattern instead:
- * {@see https://quarkus.io/guides/hibernate-orm-panache#solution-2-using-the-repository-pattern}.
+ * \{@see https://quarkus.io/guides/hibernate-orm-panache#solution-2-using-the-repository-pattern}.
  *
- * Usage (more example on the documentation)
+ * Usage:
  *
  * \{@code
  *     public void doSomething() {
@@ -59,4 +55,35 @@ public class MyEntity {
 public class MyEntity extends PanacheEntity {
     public String field;
 }
+{#else}
+import jakarta.persistence.Entity;
+import jakarta.persistence.GeneratedValue;
+import jakarta.persistence.Id;
+
+/**
+ * Example JPA entity.
+ *
+ * To use it, get access to a JPA EntityManager via injection.
+ *
+ * \{@code
+ *     @Inject
+ *     EntityManager em;
+ *
+ *     public void doSomething() {
+ *         MyEntity entity1 = new MyEntity();
+ *         entity1.field = "field-1";
+ *         em.persist(entity1);
+ *
+ *         List<MyEntity> entities = em.createQuery("from MyEntity", MyEntity.class).getResultList();
+ *     }
+ * }
+ */
+@Entity
+public class MyEntity {
+    @Id
+    @GeneratedValue
+    public Long id;
+
+    public String field;
+}
 {/if}
diff --git a/docs/pom.xml b/docs/pom.xml
index f4fc7ee469f..761efc9d05d 100644
--- a/docs/pom.xml
+++ b/docs/pom.xml
@@ -27,7 +27,7 @@
         <asciidoctorj-pdf.version>2.3.23</asciidoctorj-pdf.version>
         <asciidoctor.fail-if>WARN</asciidoctor.fail-if>
         <roaster-jdt.version>2.26.0.Final</roaster-jdt.version>
-        <maven-model-helper.version>37</maven-model-helper.version>
+        <maven-model-helper.version>40</maven-model-helper.version>
         <eclipse-collections.version>13.0.0</eclipse-collections.version>
 
         <quarkus-home-url>https://quarkus.io</quarkus-home-url>
diff --git a/docs/src/main/asciidoc/_includes/apicurio-registry-v3-migration.adoc b/docs/src/main/asciidoc/_includes/apicurio-registry-v3-migration.adoc
new file mode 100644
index 00000000000..73b9946fe49
--- /dev/null
+++ b/docs/src/main/asciidoc/_includes/apicurio-registry-v3-migration.adoc
@@ -0,0 +1,96 @@
+== Migrating from Apicurio Registry 2.x to 3.x
+
+IMPORTANT: Apicurio Registry 3.x introduces a **breaking change in schema ID format** from 8-byte (long) to 4-byte (int) identifiers.
+This affects message compatibility between v2 and v3 producers/consumers.
+
+=== Schema ID Format Change
+
+Apicurio Registry 3.x changed the schema ID format from **8-byte (long)** to **4-byte (int)** identifiers.
+This means messages produced with v2 cannot be consumed by v3 applications (and vice versa) without explicit configuration.
+
+=== Migration Scenarios
+
+**New applications (no existing v2 messages):** No configuration needed. The v3 defaults will be used automatically.
+
+**Consuming existing v2 messages:** Configure the `Legacy8ByteIdHandler` for channels that need to read v2-produced messages:
+
+[source,properties]
+----
+# Per-channel configuration for consuming v2 messages
+mp.messaging.incoming.my-channel.apicurio.registry.id-handler=io.apicurio.registry.serde.Legacy8ByteIdHandler
+
+# Or configure globally for all channels
+mp.messaging.connector.smallrye-kafka.apicurio.registry.id-handler=io.apicurio.registry.serde.Legacy8ByteIdHandler
+----
+
+**Producing v2-compatible messages:** If downstream consumers still use v2, configure the producer:
+
+[source,properties]
+----
+mp.messaging.outgoing.my-channel.apicurio.registry.id-handler=io.apicurio.registry.serde.Legacy8ByteIdHandler
+----
+
+=== Standard ID Handlers: Fixed Format
+
+Both v2 (8-byte) and v3 (4-byte) formats use the same magic byte.
+The standard ID handlers (`Legacy8ByteIdHandler` and `Default4ByteIdHandler`) read a fixed number of bytes based on configurationthere is no per-message auto-detection.
+
+WARNING: If a single topic contains mixed messages (some with 8-byte IDs, some with 4-byte IDs), consumers using standard ID handlers will fail.
+A consumer configured with `Legacy8ByteIdHandler` always reads 8 bytes; one with `Default4ByteIdHandler` always reads 4 bytes.
+Mismatches cause corruption or deserialization errors.
+
+**With standard ID handlers, gradual migration only works when:**
+
+* Each topic has messages in ONE format (either v2 or v3, not both)
+* Per-channel configuration routes each topic to the correct ID handler
+
+You can have producers and consumers using both formats in the same Apicurio Registry instance, but not mixing them in the same topic.
+
+TIP: For topics with mixed v2/v3 messages, consider using the `OptimisticFallbackIdHandler` described in the <<Optimistic Fallback ID Handler>> section.
+
+=== Migration Paths for Topics with Existing v2 Messages
+
+For topics that already contain v2 messages, valid migration approaches are:
+
+1. **Stop and drain:** Stop producers  drain topic completely  upgrade all services  restart with v3 configuration
+2. **New topic migration:** Create a new v3 topic and migrate traffic to it
+3. **Accept transient failures:** Accept transient failures during the switchover period
+4. **Optimistic fallback handler:** Use the `OptimisticFallbackIdHandler` for gradual migration (see below)
+
+=== Optimistic Fallback ID Handler
+
+Apicurio Registry provides an `OptimisticFallbackIdHandler` that can help with gradual migration from v2 to v3.
+This handler:
+
+* **Writes** new messages with 4-byte (v3) IDs
+* **Reads** both 4-byte (v3) and 8-byte (v2) IDs
+
+[source,properties]
+----
+# Configure the optimistic fallback handler for migration
+mp.messaging.connector.smallrye-kafka.apicurio.registry.id-handler=io.apicurio.registry.serde.OptimisticFallbackIdHandler
+
+# Or per-channel
+mp.messaging.incoming.my-channel.apicurio.registry.id-handler=io.apicurio.registry.serde.OptimisticFallbackIdHandler
+----
+
+IMPORTANT: The `OptimisticFallbackIdHandler` makes the following assumption to distinguish between 4-byte and 8-byte IDs: schema IDs are greater than 0 and smaller than the maximum integer value.
+This is typically true for most use cases, but you should verify your schema IDs meet this constraint before using this handler.
+
+This approach enables a gradual migration where:
+
+1. Upgrade consumers first with `OptimisticFallbackIdHandler` (they can read both v2 and v3 messages)
+2. Then upgrade producers (they start writing v3 format)
+3. Once all v2 messages are consumed, optionally switch to `Default4ByteIdHandler`
+
+=== Compatibility with Apicurio Registry 2.x Server
+
+The Apicurio Registry 3.x client libraries continue to work with Apicurio Registry 2.x servers.
+However, note that Apicurio Registry 2.x is no longer actively maintained.
+
+=== Additional Resources
+
+* https://www.apicur.io/registry/docs/apicurio-registry/3.0.x/index.html[Apicurio Registry 3.x Documentation]
+* https://www.apicur.io/registry/docs/apicurio-registry/3.1.x/getting-started/assembly-migrating-registry-v2-v3.html[Apicurio Registry Deployment Migration Guide]
+* https://www.apicur.io/blog/2025/03/30/migrate-registry-2-to-3[Official Apicurio Migration Guide]
+* https://www.apicur.io/blog/2025/04/03/evolving-serialization[Apicurio SerDes Evolution Blog Post]
diff --git a/docs/src/main/asciidoc/apicurio-registry-dev-services.adoc b/docs/src/main/asciidoc/apicurio-registry-dev-services.adoc
index ea3461ba621..62c119fe02d 100644
--- a/docs/src/main/asciidoc/apicurio-registry-dev-services.adoc
+++ b/docs/src/main/asciidoc/apicurio-registry-dev-services.adoc
@@ -17,9 +17,9 @@ This automatic configuration only applies to serializers and deserializers from
 [source,properties]
 ----
 # for Apicurio Registry serde
-mp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v2
+mp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v3
 # for Confluent Schema Registry serde
-mp.messaging.connector.smallrye-kafka.schema.registry.url=http://localhost:8081/apis/ccompat/v6
+mp.messaging.connector.smallrye-kafka.schema.registry.url=http://localhost:8081/apis/ccompat/v7
 ----
 
 
@@ -72,12 +72,12 @@ Note that the Kafka channels in SmallRye Reactive messaging are automatically co
 
 == Configuring the image
 
-Dev Services for Apicurio Registry uses `apicurio/apicurio-registry-mem` images.
-You can select any 2.x version from https://hub.docker.com/r/apicurio/apicurio-registry-mem:
+Dev Services for Apicurio Registry uses `apicurio/apicurio-registry` images. These images use an in-memory h2 database by default.
+You can select any 3.x version from https://hub.docker.com/r/apicurio/apicurio-registry:
 
 [source,properties,subs=attributes+]
 ----
-quarkus.apicurio-registry.devservices.image-name={apicurio-registry-image}
+quarkus.apicurio-registry.devservices.image-name=apicurio/apicurio-registry:latest-snapshot
 ----
 
 [[Compose]]
diff --git a/docs/src/main/asciidoc/building-my-first-extension.adoc b/docs/src/main/asciidoc/building-my-first-extension.adoc
index 7ecb8af7788..82fa597b627 100644
--- a/docs/src/main/asciidoc/building-my-first-extension.adoc
+++ b/docs/src/main/asciidoc/building-my-first-extension.adoc
@@ -171,7 +171,7 @@ Your extension is a multi-module project. So let's start by checking out the par
     <module>runtime</module>
   </modules>
   <properties>
-    <compiler-plugin.version>3.14.1</compiler-plugin.version><!--2-->
+    <compiler-plugin.version>3.15.0</compiler-plugin.version><!--2-->
     <failsafe-plugin.version>${surefire-plugin.version}</failsafe-plugin.version>
     <maven.compiler.release>17</maven.compiler.release>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
@@ -871,7 +871,7 @@ $ mvn quarkus:dev
 [INFO] Building greeting-app 1.0.0-SNAPSHOT
 [INFO] --------------------------------[ jar ]---------------------------------
 [INFO]
-[INFO] --- maven-compiler-plugin:3.14.1:compile (default-compile) @ greeting-app ---
+[INFO] --- maven-compiler-plugin:3.15.0:compile (default-compile) @ greeting-app ---
 [INFO] Nothing to compile - all classes are up to date
 [INFO]
 [INFO] --- quarkus-maven-plugin:{quarkus-version}:dev (default-cli) @ greeting-app ---
diff --git a/docs/src/main/asciidoc/jreleaser.adoc b/docs/src/main/asciidoc/jreleaser.adoc
index 75003788a55..3e44f2e6b3a 100644
--- a/docs/src/main/asciidoc/jreleaser.adoc
+++ b/docs/src/main/asciidoc/jreleaser.adoc
@@ -635,7 +635,7 @@ As a reference, these are the full contents of the `pom.xml`:
   <properties>
     <executable-suffix/>
     <distribution.directory>${project.build.directory}/distributions</distribution.directory>
-    <compiler-plugin.version>3.14.1</compiler-plugin.version>
+    <compiler-plugin.version>3.15.0</compiler-plugin.version>
     <maven.compiler.parameters>true</maven.compiler.parameters>
     <maven.compiler.source>17</maven.compiler.source>
     <maven.compiler.target>17</maven.compiler.target>
diff --git a/docs/src/main/asciidoc/kafka-schema-registry-avro.adoc b/docs/src/main/asciidoc/kafka-schema-registry-avro.adoc
index 3bd1e50b4dc..bed319743ec 100644
--- a/docs/src/main/asciidoc/kafka-schema-registry-avro.adoc
+++ b/docs/src/main/asciidoc/kafka-schema-registry-avro.adoc
@@ -360,7 +360,7 @@ And run it in JVM mode with:
 
 [source, bash]
 ----
-java -Dmp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v2 -jar target/quarkus-app/quarkus-run.jar
+java -Dmp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v3 -jar target/quarkus-app/quarkus-run.jar
 ----
 
 NOTE: By default, the application tries to connect to a Kafka broker listening at `localhost:9092`.
@@ -370,7 +370,7 @@ Specifying the registry URL on the command line is not very convenient, so you c
 
 [source,properties]
 ----
-%prod.mp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v2
+%prod.mp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v3
 ----
 
 You can build a native executable with:
@@ -567,13 +567,13 @@ public class KafkaAndSchemaRegistryTestResource implements QuarkusTestResourceLi
     @Override
     public Map<String, String> start() {
         kafka.start();
-        registry = new GenericContainer<>("apicurio/apicurio-registry-mem:2.4.2.Final")
+        registry = new GenericContainer<>("apicurio/apicurio-registry:3.0.7")
                 .withExposedPorts(8080)
                 .withEnv("QUARKUS_PROFILE", "prod");
         registry.start();
         Map<String, String> properties = new HashMap<>();
         properties.put("mp.messaging.connector.smallrye-kafka.apicurio.registry.url",
-                "http://" + registry.getHost() + ":" + registry.getMappedPort(8080) + "/apis/registry/v2");
+                "http://" + registry.getHost() + ":" + registry.getMappedPort(8080) + "/apis/registry/v3");
         properties.put("kafka.bootstrap.servers", kafka.getBootstrapServers());
         return properties;
     }
@@ -595,115 +595,7 @@ public class MovieResourceTest {
 }
 ----
 
-[[apicurio-versions-compatibility]]
-== Using compatible versions of the Apicurio Registry
-
-The `quarkus-apicurio-registry-avro` extension depends on recent versions of Apicurio Registry client,
-and most versions of Apicurio Registry server and client are backwards compatible.
-For some you need to make sure that the client used by Serdes is compatible with the server.
-
-For example, with Apicurio Dev Service if you set the image name to use version `2.1.5.Final`:
-
-[source,properties]
-----
-quarkus.apicurio-registry.devservices.image-name=quay.io/apicurio/apicurio-registry-mem:2.1.5.Final
-----
-
-You need to make sure that `apicurio-registry-serdes-avro-serde` dependency
-and the REST client `apicurio-common-rest-client-vertx` dependency are set to compatible versions:
-
-[source,xml,role="primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven"]
-.pom.xml
-----
-<dependency>
-    <groupId>io.quarkus</groupId>
-    <artifactId>quarkus-apicurio-registry-avro</artifactId>
-    <exclusions>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-common-rest-client-vertx</artifactId>
-        </exclusion>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-registry-serdes-avro-serde</artifactId>
-        </exclusion>
-    </exclusions>
-</dependency>
-<dependency>
-    <groupId>io.apicurio</groupId>
-    <artifactId>apicurio-registry-client</artifactId>
-    <version>2.1.5.Final</version>
-</dependency>
-<dependency>
-    <groupId>io.apicurio</groupId>
-    <artifactId>apicurio-registry-common</artifactId>
-    <version>2.1.5.Final</version>
-</dependency>
-<dependency>
-    <groupId>io.apicurio</groupId>
-    <artifactId>apicurio-registry-serdes-avro-serde</artifactId>
-    <version>2.1.5.Final</version>
-    <exclusions>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-common-rest-client-jdk</artifactId>
-        </exclusion>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-registry-client</artifactId>
-        </exclusion>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-registry-common</artifactId>
-        </exclusion>
-    </exclusions>
-</dependency>
-<dependency>
-    <groupId>io.apicurio</groupId>
-    <artifactId>apicurio-common-rest-client-vertx</artifactId>
-    <version>0.1.5.Final</version>
-</dependency>
-----
-
-[source,gradle,role="secondary asciidoc-tabs-target-sync-gradle",subs=attributes+]
-.build.gradle
-----
-dependencies {
-    implementation(platform("{quarkus-platform-groupid}:quarkus-bom:2.12.3.Final"))
-
-    ...
-
-    implementation("io.quarkus:quarkus-apicurio-registry-avro")
-    implementation("io.apicurio:apicurio-registry-serdes-avro-serde") {
-        exclude group: "io.apicurio", module: "apicurio-common-rest-client-jdk"
-        exclude group: "io.apicurio", module: "apicurio-registry-client"
-        exclude group: "io.apicurio", module: "apicurio-registry-common"
-        version {
-            strictly "2.1.5.Final"
-        }
-    }
-    implementation("io.apicurio:apicurio-registry-client") {
-        version {
-            strictly "2.1.5.Final"
-        }
-    }
-    implementation("io.apicurio:apicurio-registry-common") {
-        version {
-            strictly "2.1.5.Final"
-        }
-    }
-    implementation("io.apicurio:apicurio-common-rest-client-vertx") {
-        version {
-            strictly "0.1.5.Final"
-        }
-    }
-}
-----
-
-Known previous compatible versions for `apicurio-registry-client` and `apicurio-common-rest-client-vertx` are the following
-
-- `apicurio-registry-client` 2.1.5.Final with `apicurio-common-rest-client-vertx` 0.1.5.Final
-- `apicurio-registry-client` 2.3.1.Final with `apicurio-common-rest-client-vertx` 0.1.13.Final
+include::_includes/apicurio-registry-v3-migration.adoc[]
 
 [[confluent]]
 == Using the Confluent Schema Registry
diff --git a/docs/src/main/asciidoc/kafka-schema-registry-json-schema.adoc b/docs/src/main/asciidoc/kafka-schema-registry-json-schema.adoc
index b37e194345c..a1e8f2612dc 100644
--- a/docs/src/main/asciidoc/kafka-schema-registry-json-schema.adoc
+++ b/docs/src/main/asciidoc/kafka-schema-registry-json-schema.adoc
@@ -388,7 +388,7 @@ And run it in JVM mode with:
 
 [source, bash]
 ----
-java -Dmp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v2 -jar target/quarkus-app/quarkus-run.jar
+java -Dmp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v3 -jar target/quarkus-app/quarkus-run.jar
 ----
 
 NOTE: By default, the application tries to connect to a Kafka broker listening at `localhost:9092`.
@@ -398,7 +398,7 @@ Specifying the registry URL on the command line is not very convenient, so you c
 
 [source,properties]
 ----
-%prod.mp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v2
+%prod.mp.messaging.connector.smallrye-kafka.apicurio.registry.url=http://localhost:8081/apis/registry/v3
 ----
 
 You can build a native executable with:
@@ -595,13 +595,13 @@ public class KafkaAndSchemaRegistryTestResource implements QuarkusTestResourceLi
     @Override
     public Map<String, String> start() {
         kafka.start();
-        registry = new GenericContainer<>("apicurio/apicurio-registry-mem:2.4.2.Final")
+        registry = new GenericContainer<>("apicurio/apicurio-registry:3.0.7")
                 .withExposedPorts(8080)
                 .withEnv("QUARKUS_PROFILE", "prod");
         registry.start();
         Map<String, String> properties = new HashMap<>();
         properties.put("mp.messaging.connector.smallrye-kafka.apicurio.registry.url",
-                "http://" + registry.getHost() + ":" + registry.getMappedPort(8080) + "/apis/registry/v2");
+                "http://" + registry.getHost() + ":" + registry.getMappedPort(8080) + "/apis/registry/v3");
         properties.put("kafka.bootstrap.servers", kafka.getBootstrapServers());
         return properties;
     }
@@ -623,115 +623,7 @@ public class MovieResourceTest {
 }
 ----
 
-[[apicurio-versions-compatibility]]
-== Using compatible versions of the Apicurio Registry
-
-The `quarkus-apicurio-registry-json-schema` extension depends on recent versions of Apicurio Registry client,
-and most versions of Apicurio Registry server and client are backwards compatible.
-For some you need to make sure that the client used by Serdes is compatible with the server.
-
-For example, with Apicurio Dev Service if you set the image name to use version `2.1.5.Final`:
-
-[source,properties]
-----
-quarkus.apicurio-registry.devservices.image-name=quay.io/apicurio/apicurio-registry-mem:2.1.5.Final
-----
-
-You need to make sure that `apicurio-registry-serdes-json-schema-serde` dependency
-and the REST client `apicurio-common-rest-client-vertx` dependency are set to compatible versions:
-
-[source,xml,role="primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven"]
-.pom.xml
-----
-<dependency>
-    <groupId>io.quarkus</groupId>
-    <artifactId>quarkus-apicurio-registry-json-schema</artifactId>
-    <exclusions>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-common-rest-client-vertx</artifactId>
-        </exclusion>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-registry-serdes-json-schema-serde</artifactId>
-        </exclusion>
-    </exclusions>
-</dependency>
-<dependency>
-    <groupId>io.apicurio</groupId>
-    <artifactId>apicurio-registry-client</artifactId>
-    <version>2.1.5.Final</version>
-</dependency>
-<dependency>
-    <groupId>io.apicurio</groupId>
-    <artifactId>apicurio-registry-common</artifactId>
-    <version>2.1.5.Final</version>
-</dependency>
-<dependency>
-    <groupId>io.apicurio</groupId>
-    <artifactId>apicurio-registry-serdes-json-schema-serde</artifactId>
-    <version>2.1.5.Final</version>
-    <exclusions>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-common-rest-client-jdk</artifactId>
-        </exclusion>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-registry-client</artifactId>
-        </exclusion>
-        <exclusion>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-registry-common</artifactId>
-        </exclusion>
-    </exclusions>
-</dependency>
-<dependency>
-    <groupId>io.apicurio</groupId>
-    <artifactId>apicurio-common-rest-client-vertx</artifactId>
-    <version>0.1.5.Final</version>
-</dependency>
-----
-
-[source,gradle,role="secondary asciidoc-tabs-target-sync-gradle",subs=attributes+]
-.build.gradle
-----
-dependencies {
-    implementation(platform("{quarkus-platform-groupid}:quarkus-bom:2.12.3.Final"))
-
-    ...
-
-    implementation("io.quarkus:quarkus-apicurio-registry-json-schema")
-    implementation("io.apicurio:apicurio-registry-serdes-json-schema-serde") {
-        exclude group: "io.apicurio", module: "apicurio-common-rest-client-jdk"
-        exclude group: "io.apicurio", module: "apicurio-registry-client"
-        exclude group: "io.apicurio", module: "apicurio-registry-common"
-        version {
-            strictly "2.1.5.Final"
-        }
-    }
-    implementation("io.apicurio:apicurio-registry-client") {
-        version {
-            strictly "2.1.5.Final"
-        }
-    }
-    implementation("io.apicurio:apicurio-registry-common") {
-        version {
-            strictly "2.1.5.Final"
-        }
-    }
-    implementation("io.apicurio:apicurio-common-rest-client-vertx") {
-        version {
-            strictly "0.1.5.Final"
-        }
-    }
-}
-----
-
-Known previous compatible versions for `apicurio-registry-client` and `apicurio-common-rest-client-vertx` are the following
-
-- `apicurio-registry-client` 2.1.5.Final with `apicurio-common-rest-client-vertx` 0.1.5.Final
-- `apicurio-registry-client` 2.3.1.Final with `apicurio-common-rest-client-vertx` 0.1.13.Final
+include::_includes/apicurio-registry-v3-migration.adoc[]
 
 [[confluent]]
 == Using the Confluent Schema Registry
diff --git a/docs/src/main/asciidoc/kafka.adoc b/docs/src/main/asciidoc/kafka.adoc
index c95e6325587..b49db919c3e 100644
--- a/docs/src/main/asciidoc/kafka.adoc
+++ b/docs/src/main/asciidoc/kafka.adoc
@@ -3437,11 +3437,11 @@ Then, you can configure the Quarkus application to connect to the schema registr
 [source, properties]
 ----
 mp.messaging.connector.smallrye-kafka.apicurio.registry.url=${RHOAS_SERVICE_REGISTRY_URL} <1>
-mp.messaging.connector.smallrye-kafka.apicurio.auth.service.token.endpoint=${RHOAS_OAUTH_TOKEN_ENDPOINT} <2>
-mp.messaging.connector.smallrye-kafka.apicurio.auth.client.id=${RHOAS_CLIENT_ID} <3>
-mp.messaging.connector.smallrye-kafka.apicurio.auth.client.secret=${RHOAS_CLIENT_ID} <4>
+mp.messaging.connector.smallrye-kafka.apicurio.registry.auth.service.token.endpoint=${RHOAS_OAUTH_TOKEN_ENDPOINT} <2>
+mp.messaging.connector.smallrye-kafka.apicurio.registry.auth.client.id=${RHOAS_CLIENT_ID} <3>
+mp.messaging.connector.smallrye-kafka.apicurio.registry.auth.client.secret=${RHOAS_CLIENT_ID} <4>
 ----
-<1> The service registry URL, given on the admin console, such as `https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v2`
+<1> The service registry URL, given on the admin console, such as `https://bu98.serviceregistry.rhcloud.com/t/0e95af2c-6e11-475e-82ee-f13bd782df24/apis/registry/v3`
 <2> The OAuth token endpoint URL, such as `https://identity.api.openshift.com/auth/realms/rhoas/protocol/openid-connect/token`
 <3> The client id (from the service account)
 <4> The client secret (from the service account)
diff --git a/docs/src/main/asciidoc/rest-client.adoc b/docs/src/main/asciidoc/rest-client.adoc
index 8049ecb323f..02c0a656a6c 100644
--- a/docs/src/main/asciidoc/rest-client.adoc
+++ b/docs/src/main/asciidoc/rest-client.adoc
@@ -1996,7 +1996,7 @@ An example logging configuration:
 quarkus.rest-client.logging.scope=request-response
 quarkus.rest-client.logging.body-limit=50
 
-quarkus.rest-client.extensions-api.scope=all
+quarkus.rest-client.extensions-api.logging.scope=all
 ----
 
 [TIP]
diff --git a/docs/src/main/asciidoc/tls-registry-reference.adoc b/docs/src/main/asciidoc/tls-registry-reference.adoc
index 398ab5ce0b6..857e46a2358 100644
--- a/docs/src/main/asciidoc/tls-registry-reference.adoc
+++ b/docs/src/main/asciidoc/tls-registry-reference.adoc
@@ -575,17 +575,24 @@ quarkus.tls.cipher-suites=TLS_AES_128_GCM_SHA256,TLS_AES_256_GCM_SHA384
 The TLS protocol versions are the list of protocols that can be used during the TLS handshake.
 Enabled TLS protocol versions are specified as an ordered list separated by commas.
 The relevant configuration property is `quarkus.tls.protocols` or `quarkus.tls.<name>.protocols` for named TLS configurations.
-It defaults to `TLSv1.3, TLSv1.2` if not configured.
+For improved security, it defaults to `TLSv1.3` only if not configured.
 
 The available options are `TLSv1`, `TLSv1.1`, `TLSv1.2`, and `TLSv1.3`.
 
-For example, to only enable `TLSv1.3`:
+For example, to enable both `TLSv1.3` and `TLSv1.2`:
 
 [source,properties]
 ----
-quarkus.tls.protocols=TLSv1.3
+quarkus.tls."services-requiring-v1.2".protocols=TLSv1.3,TLSv1.2
 ----
 
+[TIP]
+====
+If only certain services require `TLSv1.2`,
+it is recommended to configure a dedicated, named TLS configuration for those services
+and keep the default configuration for services that support `TLSv1.3`.
+====
+
 ==== Handshake timeout
 
 When a TLS connection is established, the handshake phase is the first step.
diff --git a/docs/src/main/asciidoc/writing-extensions.adoc b/docs/src/main/asciidoc/writing-extensions.adoc
index fe17347fc04..ca56fab9975 100644
--- a/docs/src/main/asciidoc/writing-extensions.adoc
+++ b/docs/src/main/asciidoc/writing-extensions.adoc
@@ -2229,6 +2229,55 @@ public class PersistenceAndQuarkusConfigTest {
 <1> This tells JUnit that the Quarkus deployment should fail with a specific exception
 
 
+[TIP]
+.Test coverage and `QuarkusUnitTest`
+====
+If you want to measure the test coverage of the runtime submodule, then a specific JaCoCo configuration is needed in the deployment module:
+
+[source,xml]
+----
+<profiles>
+    <profile>
+        <id>test-coverage</id>
+        <activation>
+            <property>
+                <name>jacoco</name> <1>
+            </property>
+        </activation>
+        <dependencies>
+            <dependency>
+                <groupId>io.quarkus</groupId>
+                <artifactId>quarkus-jacoco-deployment</artifactId> <2>
+                <scope>test</scope>
+            </dependency>
+        </dependencies>
+        <build>
+            <plugins>
+                <plugin>
+                    <artifactId>maven-surefire-plugin</artifactId>
+                    <configuration>
+                        <systemPropertyVariables>
+                            <quarkus.jacoco.instrument-artifacts.runtime.group-id>io.quarkus</quarkus.jacoco.instrument-artifacts.runtime.group-id> <3>
+                            <quarkus.jacoco.instrument-artifacts.runtime.artifact-id>quarkus-runtime-module-name</quarkus.jacoco.instrument-artifacts.runtime.artifact-id>
+                        </systemPropertyVariables>
+                    </configuration>
+                </plugin>
+            </plugins>
+        </build>
+    </profile>
+</profiles>
+----
+<1> This profile is activated with the `jacoco` property.
+<2> Add the `quarkus-jacoco-deployment` dependency with the `test` scope.
+<3> Instruct the JaCoCo plugin to instrument the `io.quarkus:quarkus-runtime-module-name` artifact.
+
+By default, JaCoCo will save the collected data in `target/jacoco-quarkus.exec` and the generated report is located in `target/jacoco-report`.
+For multi-module projects, more config properties will be needed. 
+Typically, `quarkus.jacoco.data-file=/path/to/shared/data-file`, `quarkus.jacoco.reuse-data-file=true` and `quarkus.jacoco.aggregate-report-data=true`.
+See xref:tests-with-coverage.adoc[Measuring the coverage of your tests] for more information. 
+====
+
+
 === Testing hot reload
 
 It is also possible to write tests that verify an extension works correctly in development mode and can correctly
diff --git a/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/DataSources.java b/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/DataSources.java
index 863fa09561a..1a25bc65653 100644
--- a/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/DataSources.java
+++ b/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/DataSources.java
@@ -1,8 +1,7 @@
 package io.quarkus.agroal.runtime;
 
-import java.sql.Connection;
 import java.sql.Driver;
-import java.sql.Statement;
+import java.time.Duration;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.Map;
@@ -338,22 +337,8 @@ private void applyNewConfiguration(String dataSourceName, AgroalDataSourceConfig
         }
         if (dataSourceJdbcRuntimeConfig.validationQuerySql().isPresent()) {
             String validationQuery = dataSourceJdbcRuntimeConfig.validationQuerySql().get();
-            poolConfiguration.connectionValidator(new ConnectionValidator() {
-
-                @Override
-                public boolean isValid(Connection connection) {
-                    try (Statement stmt = connection.createStatement()) {
-                        if (dataSourceJdbcRuntimeConfig.validationQueryTimeout().isPresent()) {
-                            stmt.setQueryTimeout((int) dataSourceJdbcRuntimeConfig.validationQueryTimeout().get().toSeconds());
-                        }
-                        stmt.execute(validationQuery);
-                        return true;
-                    } catch (Exception e) {
-                        log.warn("Connection validation failed", e);
-                    }
-                    return false;
-                }
-            });
+            int timeout = (int) dataSourceJdbcRuntimeConfig.validationQueryTimeout().orElse(Duration.ZERO).toSeconds();
+            poolConfiguration.connectionValidator(ConnectionValidator.sqlValidator(validationQuery, timeout));
         }
         poolConfiguration.validateOnBorrow(dataSourceJdbcRuntimeConfig.validateOnBorrow());
         poolConfiguration.reapTimeout(dataSourceJdbcRuntimeConfig.idleRemovalInterval());
diff --git a/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/OpenTelemetryAgroalDataSource.java b/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/OpenTelemetryAgroalDataSource.java
index 360b6059d68..01ac2cba68e 100644
--- a/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/OpenTelemetryAgroalDataSource.java
+++ b/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/OpenTelemetryAgroalDataSource.java
@@ -1,5 +1,6 @@
 package io.quarkus.agroal.runtime;
 
+import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.ShardingKeyBuilder;
 import java.util.Collection;
@@ -30,6 +31,11 @@ public boolean isHealthy(boolean newConnection) throws SQLException {
         return delegate.isHealthy(newConnection);
     }
 
+    @Override
+    public Connection getReadOnlyConnection() throws SQLException {
+        return delegate.getReadOnlyConnection();
+    }
+
     @Override
     public AgroalDataSourceConfiguration getConfiguration() {
         return delegate.getConfiguration();
diff --git a/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/UnconfiguredDataSource.java b/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/UnconfiguredDataSource.java
deleted file mode 100644
index 2fd1534bca4..00000000000
--- a/extensions/agroal/runtime/src/main/java/io/quarkus/agroal/runtime/UnconfiguredDataSource.java
+++ /dev/null
@@ -1,108 +0,0 @@
-package io.quarkus.agroal.runtime;
-
-import java.io.PrintWriter;
-import java.sql.Connection;
-import java.sql.SQLException;
-import java.sql.SQLFeatureNotSupportedException;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.logging.Logger;
-
-import io.agroal.api.AgroalDataSource;
-import io.agroal.api.AgroalDataSourceMetrics;
-import io.agroal.api.AgroalPoolInterceptor;
-import io.agroal.api.configuration.AgroalDataSourceConfiguration;
-import io.quarkus.runtime.configuration.ConfigurationException;
-
-/**
- * @deprecated This is never instantiated by Quarkus. Do not use.
- */
-@Deprecated(forRemoval = true)
-public class UnconfiguredDataSource implements AgroalDataSource {
-
-    private final String errorMessage;
-
-    public UnconfiguredDataSource(String errorMessage) {
-        this.errorMessage = errorMessage;
-    }
-
-    public void throwException() {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public AgroalDataSourceConfiguration getConfiguration() {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public AgroalDataSourceMetrics getMetrics() {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public void flush(FlushMode mode) {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public void setPoolInterceptors(Collection<? extends AgroalPoolInterceptor> arg0) {
-        //noop
-    }
-
-    @Override
-    public List<AgroalPoolInterceptor> getPoolInterceptors() {
-        return Collections.emptyList();
-    }
-
-    @Override
-    public void close() {
-
-    }
-
-    @Override
-    public Connection getConnection() throws SQLException {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public Connection getConnection(String username, String password) throws SQLException {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public PrintWriter getLogWriter() throws SQLException {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public void setLogWriter(PrintWriter out) throws SQLException {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public void setLoginTimeout(int seconds) throws SQLException {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public int getLoginTimeout() throws SQLException {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public <T> T unwrap(Class<T> iface) throws SQLException {
-        throw new ConfigurationException(errorMessage);
-    }
-
-    @Override
-    public boolean isWrapperFor(Class<?> iface) throws SQLException {
-        return false;
-    }
-}
diff --git a/extensions/amazon-lambda-http/maven-archetype/src/main/resources/archetype-resources/pom.xml b/extensions/amazon-lambda-http/maven-archetype/src/main/resources/archetype-resources/pom.xml
index 414566b382e..778a47cefd8 100644
--- a/extensions/amazon-lambda-http/maven-archetype/src/main/resources/archetype-resources/pom.xml
+++ b/extensions/amazon-lambda-http/maven-archetype/src/main/resources/archetype-resources/pom.xml
@@ -8,7 +8,7 @@
     <version>\${version}</version>
     <properties>
         <assembly-plugin.version>3.1.0</assembly-plugin.version>
-        <compiler-plugin.version>3.14.1</compiler-plugin.version>
+        <compiler-plugin.version>3.15.0</compiler-plugin.version>
         <maven.compiler.parameters>true</maven.compiler.parameters>
         <maven.compiler.target>17</maven.compiler.target>
         <maven.compiler.source>17</maven.compiler.source>
diff --git a/extensions/amazon-lambda-rest/maven-archetype/src/main/resources/archetype-resources/pom.xml b/extensions/amazon-lambda-rest/maven-archetype/src/main/resources/archetype-resources/pom.xml
index aab3604071a..3416886994c 100644
--- a/extensions/amazon-lambda-rest/maven-archetype/src/main/resources/archetype-resources/pom.xml
+++ b/extensions/amazon-lambda-rest/maven-archetype/src/main/resources/archetype-resources/pom.xml
@@ -8,7 +8,7 @@
     <version>\${version}</version>
     <properties>
         <assembly-plugin.version>3.1.0</assembly-plugin.version>
-        <compiler-plugin.version>3.14.1</compiler-plugin.version>
+        <compiler-plugin.version>3.15.0</compiler-plugin.version>
         <maven.compiler.parameters>true</maven.compiler.parameters>
         <maven.compiler.target>17</maven.compiler.target>
         <maven.compiler.source>17</maven.compiler.source>
diff --git a/extensions/amazon-lambda/maven-archetype/src/main/resources/archetype-resources/pom.xml b/extensions/amazon-lambda/maven-archetype/src/main/resources/archetype-resources/pom.xml
index fde35fbb42e..3b402693da3 100644
--- a/extensions/amazon-lambda/maven-archetype/src/main/resources/archetype-resources/pom.xml
+++ b/extensions/amazon-lambda/maven-archetype/src/main/resources/archetype-resources/pom.xml
@@ -7,7 +7,7 @@
     <artifactId>\${artifactId}</artifactId>
     <version>\${version}</version>
     <properties>
-        <compiler-plugin.version>3.14.1</compiler-plugin.version>
+        <compiler-plugin.version>3.15.0</compiler-plugin.version>
         <maven.compiler.parameters>true</maven.compiler.parameters>
         <maven.compiler.target>17</maven.compiler.target>
         <maven.compiler.source>17</maven.compiler.source>
diff --git a/extensions/container-image/container-image-jib/deployment/src/main/java/io/quarkus/container/image/jib/deployment/ContainerImageJibConfig.java b/extensions/container-image/container-image-jib/deployment/src/main/java/io/quarkus/container/image/jib/deployment/ContainerImageJibConfig.java
index 260fe60498a..d2962bf3a17 100644
--- a/extensions/container-image/container-image-jib/deployment/src/main/java/io/quarkus/container/image/jib/deployment/ContainerImageJibConfig.java
+++ b/extensions/container-image/container-image-jib/deployment/src/main/java/io/quarkus/container/image/jib/deployment/ContainerImageJibConfig.java
@@ -21,9 +21,12 @@ public interface ContainerImageJibConfig {
     /**
      * The base image to be used when a container image is being produced for the jar build.
      *
-     * When the application is built against Java 21 or higher, {@code registry.access.redhat.com/ubi9/openjdk-21-runtime:1.23}
+     * When the application is built against Java 25 or higher, {@code registry.access.redhat.com/ubi9/openjdk-25-runtime:1.24}
      * is used as the default.
-     * Otherwise {@code registry.access.redhat.com/ubi9/openjdk-17-runtime:1.23} is used as the default.
+     * Otherwise, when the application is built against Java 21 to Java 24,
+     * {@code registry.access.redhat.com/ubi9/openjdk-21-runtime:1.24}
+     * is used as the default.
+     * Otherwise {@code registry.access.redhat.com/ubi9/openjdk-17-runtime:1.24} is used as the default.
      */
     Optional<String> baseJvmImage();
 
diff --git a/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/ContainerImageOpenshiftConfig.java b/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/ContainerImageOpenshiftConfig.java
index f4960571c13..5fcfebe5d77 100644
--- a/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/ContainerImageOpenshiftConfig.java
+++ b/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/ContainerImageOpenshiftConfig.java
@@ -46,19 +46,22 @@ public static String getDefaultJvmImage(CompiledJavaVersionBuildItem.JavaVersion
 
     /**
      * The base image to be used when a container image is being produced for the jar build.
-     * The value of this property is used to create an ImageStream for the builder image used in the Openshift build.
-     * When it references images already available in the internal Openshift registry, the corresponding streams are used
+     * The value of this property is used to create an ImageStream for the builder image used in the OpenShift build.
+     * When it references images already available in the internal OpenShift registry, the corresponding streams are used
      * instead.
-     * When the application is built against Java 21 or higher, {@code registry.access.redhat.com/ubi9/openjdk-21:1.23}
+     * When the application is built against Java 25 or higher, {@code registry.access.redhat.com/ubi9/openjdk-25:1.24}
      * is used as the default.
-     * Otherwise {@code registry.access.redhat.com/ubi9/openjdk-17:1.23} is used as the default.
+     * Otherwise, when the application is built against Java 21 to Java 24,
+     * {@code registry.access.redhat.com/ubi9/openjdk-21:1.24}
+     * is used as the default.
+     * Otherwise {@code registry.access.redhat.com/ubi9/openjdk-17:1.24} is used as the default.
      */
     Optional<String> baseJvmImage();
 
     /**
      * The base image to be used when a container image is being produced for the native binary build.
-     * The value of this property is used to create an ImageStream for the builder image used in the Openshift build.
-     * When it references images already available in the internal Openshift registry, the corresponding streams are used
+     * The value of this property is used to create an ImageStream for the builder image used in the OpenShift build.
+     * When it references images already available in the internal OpenShift registry, the corresponding streams are used
      * instead.
      */
     @WithDefault(ContainerImages.QUARKUS_BINARY_S2I)
diff --git a/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DatasourceStartable.java b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DatasourceStartable.java
new file mode 100644
index 00000000000..d67f69615ca
--- /dev/null
+++ b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DatasourceStartable.java
@@ -0,0 +1,33 @@
+package io.quarkus.datasource.deployment.spi;
+
+import io.quarkus.deployment.builditem.Startable;
+
+public interface DatasourceStartable extends Startable {
+
+    /**
+     * Gets a record which can be used to interrogate the datasource, after it has been started.
+     * This should not be called before the container has been started.
+     * If the datasource has not been started, an IllegalStateException will be thrown.
+     *
+     * @return a RunningDevServicesDatasource, populated with the container id and urls and credentials of the running
+     *         datasource
+     */
+    default DevServicesDatasourceProvider.RunningDevServicesDatasource runningDevServicesDatasource() {
+        if (getContainerId() == null) {
+            throw new IllegalStateException(
+                    "Cannot create a RunningDevServicesDatasource before the datasource has been started.");
+        }
+        // It would be nice to cache this, but since this is an interface, it can't be done at this level, and would have to be done by every implementing class
+        return new DevServicesDatasourceProvider.RunningDevServicesDatasource(getContainerId(), getEffectiveJdbcUrl(),
+                getReactiveUrl(), getUsername(), getPassword());
+    }
+
+    String getPassword();
+
+    String getUsername();
+
+    String getReactiveUrl();
+
+    String getEffectiveJdbcUrl();
+
+}
diff --git a/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DeferredDevServicesDatasourceProvider.java b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DeferredDevServicesDatasourceProvider.java
new file mode 100644
index 00000000000..1dcf2462471
--- /dev/null
+++ b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DeferredDevServicesDatasourceProvider.java
@@ -0,0 +1,35 @@
+package io.quarkus.datasource.deployment.spi;
+
+import java.time.Duration;
+import java.util.Optional;
+
+import io.quarkus.deployment.builditem.DevServicesComposeProjectBuildItem;
+import io.quarkus.runtime.LaunchMode;
+
+public interface DeferredDevServicesDatasourceProvider extends GenericDevServicesDatasourceProvider {
+
+    /**
+     * Ecosystem implementations may not have access to a Feature object, so we return a String.
+     *
+     * @return the result of feature.getName(), or a String representing the feature name
+     */
+    String getFeature();
+
+    /**
+     * The DatasourceStartable should *not* have had `start()` called.
+     */
+    DatasourceStartable createDatasourceStartable(Optional<String> username,
+            Optional<String> password,
+            String datasourceName,
+            DevServicesDatasourceContainerConfig devServicesDatasourceContainerConfig,
+            LaunchMode launchMode, boolean useSharedNetwork,
+            Optional<Duration> startupTimeout);
+
+    Optional<DevServicesDatasourceProvider.RunningDevServicesDatasource> findRunningComposeDatasource(LaunchMode launchMode,
+            boolean useSharedNetwork, DevServicesDatasourceContainerConfig containerConfig,
+            DevServicesComposeProjectBuildItem composeProjectBuildItem);
+
+    default boolean isDockerRequired() {
+        return true;
+    }
+}
diff --git a/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceConfigurationHandlerBuildItem.java b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceConfigurationHandlerBuildItem.java
index 12ef414cab6..a6ac586b82b 100644
--- a/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceConfigurationHandlerBuildItem.java
+++ b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceConfigurationHandlerBuildItem.java
@@ -4,6 +4,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.function.BiFunction;
+import java.util.function.Function;
 import java.util.function.Predicate;
 
 import io.quarkus.builder.item.MultiBuildItem;
@@ -20,21 +21,39 @@ public final class DevServicesDatasourceConfigurationHandlerBuildItem extends Mu
      */
     private final String dbKind;
     /**
-     * The function that provides the runtime config given a running DevServices database
+     * The function that provides the runtime config given a running DevServices database, for old model and discovered services
      */
     private final BiFunction<String, DevServicesDatasourceProvider.RunningDevServicesDatasource, Map<String, String>> configProviderFunction;
 
+    // These two functions could possibly be consolidated
+    private final Function<String, Map<String, Function<DatasourceStartable, String>>> deferredConfigProviderFunction;
+
     /**
      * Function that checks if a given datasource has been configured. If it has been configured generally the
      * DevServices will not be started.
      */
     private final Predicate<String> checkConfiguredFunction;
 
+    /**
+     * Use the deferred constructor and the new dev services model.
+     */
+    @Deprecated(since = "3.32", forRemoval = true)
     public DevServicesDatasourceConfigurationHandlerBuildItem(String dbKind,
             BiFunction<String, DevServicesDatasourceProvider.RunningDevServicesDatasource, Map<String, String>> configProviderFunction,
             Predicate<String> checkConfiguredFunction) {
         this.dbKind = dbKind;
         this.configProviderFunction = configProviderFunction;
+        this.deferredConfigProviderFunction = null;
+        this.checkConfiguredFunction = checkConfiguredFunction;
+    }
+
+    public DevServicesDatasourceConfigurationHandlerBuildItem(String dbKind,
+            BiFunction<String, DevServicesDatasourceProvider.RunningDevServicesDatasource, Map<String, String>> configProviderFunction,
+            Function<String, Map<String, Function<DatasourceStartable, String>>> deferredConfigProviderFunction,
+            Predicate<String> checkConfiguredFunction) {
+        this.dbKind = dbKind;
+        this.configProviderFunction = configProviderFunction;
+        this.deferredConfigProviderFunction = deferredConfigProviderFunction;
         this.checkConfiguredFunction = checkConfiguredFunction;
     }
 
@@ -50,18 +69,30 @@ public Predicate<String> getCheckConfiguredFunction() {
         return checkConfiguredFunction;
     }
 
+    public Function<String, Map<String, Function<DatasourceStartable, String>>> getDeferredConfigProviderFunction() {
+        return deferredConfigProviderFunction;
+    }
+
+    /**
+     * Use {@link #deferredJdbc(String)}
+     */
+    @Deprecated(since = "3.32", forRemoval = true)
     public static DevServicesDatasourceConfigurationHandlerBuildItem jdbc(String dbKind) {
         return new DevServicesDatasourceConfigurationHandlerBuildItem(dbKind,
-                new BiFunction<String, DevServicesDatasourceProvider.RunningDevServicesDatasource, Map<String, String>>() {
-
+                jdbcProviderFunction(), new Predicate<>() {
                     @Override
-                    public Map<String, String> apply(String dsName,
-                            DevServicesDatasourceProvider.RunningDevServicesDatasource runningDevDb) {
-                        String jdbcUrl = runningDevDb.jdbcUrl();
-                        return fromKeys(datasourceURLPropNames(dsName), jdbcUrl);
+                    public boolean test(String dsName) {
+                        return ConfigUtils.isAnyPropertyPresent(datasourceURLPropNames(dsName));
                     }
+                });
+    }
 
-                }, new Predicate<String>() {
+    public static DevServicesDatasourceConfigurationHandlerBuildItem deferredJdbc(String dbKind) {
+        return new DevServicesDatasourceConfigurationHandlerBuildItem(dbKind, jdbcProviderFunction(), (dsName) -> {
+            Function<DatasourceStartable, String> function = s -> s.runningDevServicesDatasource().jdbcUrl();
+            return fromKeys(datasourceURLPropNames(dsName), function);
+        },
+                new Predicate<>() {
                     @Override
                     public boolean test(String dsName) {
                         return ConfigUtils.isAnyPropertyPresent(datasourceURLPropNames(dsName));
@@ -69,6 +100,30 @@ public boolean test(String dsName) {
                 });
     }
 
+    private static BiFunction<String, DevServicesDatasourceProvider.RunningDevServicesDatasource, Map<String, String>> jdbcProviderFunction() {
+        return new BiFunction<>() {
+
+            @Override
+            public Map<String, String> apply(String dsName,
+                    DevServicesDatasourceProvider.RunningDevServicesDatasource runningDevDb) {
+                String url = runningDevDb.jdbcUrl();
+                return fromKeys(datasourceURLPropNames(dsName), url);
+            }
+
+        };
+    }
+
+    private static BiFunction<String, DevServicesDatasourceProvider.RunningDevServicesDatasource, Map<String, String>> reactiveProviderFunction() {
+        return new BiFunction<>() {
+            @Override
+            public Map<String, String> apply(String dsName,
+                    DevServicesDatasourceProvider.RunningDevServicesDatasource runningDevDb) {
+                String url = runningDevDb.reactiveUrl();
+                return fromKeys(datasourceReactiveURLPropNames(dsName), url);
+            }
+        };
+    }
+
     private static List<String> datasourceURLPropNames(String dsName) {
         // we use datasourceURLPropNames to generate quoted and unquoted versions of the property key,
         // because depending on whether a user configured other JDBC properties
@@ -77,16 +132,27 @@ private static List<String> datasourceURLPropNames(String dsName) {
         return DataSourceUtil.dataSourcePropertyKeys(dsName, "jdbc.url");
     }
 
+    /**
+     * Use {@link #deferredReactive(String)}
+     */
+    @Deprecated(since = "3.32", forRemoval = true)
     public static DevServicesDatasourceConfigurationHandlerBuildItem reactive(String dbKind) {
         return new DevServicesDatasourceConfigurationHandlerBuildItem(dbKind,
-                new BiFunction<String, DevServicesDatasourceProvider.RunningDevServicesDatasource, Map<String, String>>() {
+                reactiveProviderFunction(), new Predicate<>() {
                     @Override
-                    public Map<String, String> apply(String dsName,
-                            DevServicesDatasourceProvider.RunningDevServicesDatasource runningDevDb) {
-                        String reactiveUrl = runningDevDb.reactiveUrl();
-                        return fromKeys(datasourceReactiveURLPropNames(dsName), reactiveUrl);
+                    public boolean test(String dsName) {
+                        return ConfigUtils.isAnyPropertyPresent(datasourceReactiveURLPropNames(dsName));
                     }
-                }, new Predicate<String>() {
+                });
+    }
+
+    public static DevServicesDatasourceConfigurationHandlerBuildItem deferredReactive(String dbKind) {
+        return new DevServicesDatasourceConfigurationHandlerBuildItem(dbKind, reactiveProviderFunction(),
+                (dsName) -> {
+                    Function<DatasourceStartable, String> reactiveUrl = s -> s.runningDevServicesDatasource().reactiveUrl();
+
+                    return fromKeys(datasourceReactiveURLPropNames(dsName), reactiveUrl);
+                }, new Predicate<>() {
                     @Override
                     public boolean test(String dsName) {
                         return ConfigUtils.isAnyPropertyPresent(datasourceReactiveURLPropNames(dsName));
diff --git a/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceProvider.java b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceProvider.java
index a66795363de..1d101652143 100644
--- a/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceProvider.java
+++ b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceProvider.java
@@ -7,7 +7,7 @@
 import io.quarkus.datasource.common.runtime.DataSourceUtil;
 import io.quarkus.runtime.LaunchMode;
 
-public interface DevServicesDatasourceProvider {
+public interface DevServicesDatasourceProvider extends GenericDevServicesDatasourceProvider {
 
     /**
      * @deprecated implement
@@ -40,8 +40,17 @@ default boolean isDockerRequired() {
     }
 
     record RunningDevServicesDatasource(String id, String jdbcUrl, String reactiveUrl, String username, String password,
-            Closeable closeTask) {
-
+            @Deprecated Closeable closeTask) {
+
+        //In the new dev services model, the RunningDevServicesDatasource is used, but its close() method is not
+        public RunningDevServicesDatasource(String id, String jdbcUrl, String reactiveUrl, String username, String password) {
+            this(id, jdbcUrl, reactiveUrl, username, password, new Closeable() {
+                @Override
+                public void close() {
+                    // No-op
+                }
+            });
+        }
     }
 
 }
diff --git a/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceProviderBuildItem.java b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceProviderBuildItem.java
index a75ec73e6d3..3ccb525ae24 100644
--- a/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceProviderBuildItem.java
+++ b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/DevServicesDatasourceProviderBuildItem.java
@@ -9,17 +9,41 @@ public final class DevServicesDatasourceProviderBuildItem extends MultiBuildItem
 
     private final String database;
     private final DevServicesDatasourceProvider devDBProvider;
+    private final DeferredDevServicesDatasourceProvider deferredDevServicesDatasourceProvider;
 
+    @Deprecated(since = "3.32", forRemoval = true)
     public DevServicesDatasourceProviderBuildItem(String database, DevServicesDatasourceProvider devDBProvider) {
         this.database = database;
         this.devDBProvider = devDBProvider;
+        this.deferredDevServicesDatasourceProvider = null;
+    }
+
+    public DevServicesDatasourceProviderBuildItem(String database,
+            DeferredDevServicesDatasourceProvider deferredDevServicesDatasourceProvider) {
+        this.database = database;
+        this.deferredDevServicesDatasourceProvider = deferredDevServicesDatasourceProvider;
+        this.devDBProvider = null;
     }
 
     public String getDatabase() {
         return database;
     }
 
+    /**
+     * May be null if the new-model dev services API is being used
+     *
+     */
+    @Deprecated(since = "3.32", forRemoval = true)
     public DevServicesDatasourceProvider getDevServicesProvider() {
         return devDBProvider;
     }
+
+    /**
+     * May be null if the old-model dev services API is being used
+     *
+     */
+    public DeferredDevServicesDatasourceProvider getDeferredDevServicesProvider() {
+        return deferredDevServicesDatasourceProvider;
+    }
+
 }
diff --git a/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/GenericDevServicesDatasourceProvider.java b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/GenericDevServicesDatasourceProvider.java
new file mode 100644
index 00000000000..e172143e58a
--- /dev/null
+++ b/extensions/datasource/deployment-spi/src/main/java/io/quarkus/datasource/deployment/spi/GenericDevServicesDatasourceProvider.java
@@ -0,0 +1,5 @@
+package io.quarkus.datasource.deployment.spi;
+
+public interface GenericDevServicesDatasourceProvider {
+    boolean isDockerRequired();
+}
diff --git a/extensions/datasource/deployment/src/main/java/io/quarkus/datasource/deployment/devservices/DevServicesDatasourceProcessor.java b/extensions/datasource/deployment/src/main/java/io/quarkus/datasource/deployment/devservices/DevServicesDatasourceProcessor.java
index f873a24e8a4..ad0780ec7fc 100644
--- a/extensions/datasource/deployment/src/main/java/io/quarkus/datasource/deployment/devservices/DevServicesDatasourceProcessor.java
+++ b/extensions/datasource/deployment/src/main/java/io/quarkus/datasource/deployment/devservices/DevServicesDatasourceProcessor.java
@@ -9,18 +9,22 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
+import java.util.function.Function;
 import java.util.stream.Collectors;
 
 import org.eclipse.microprofile.config.ConfigProvider;
 import org.jboss.logging.Logger;
 
 import io.quarkus.datasource.common.runtime.DataSourceUtil;
+import io.quarkus.datasource.deployment.spi.DatasourceStartable;
 import io.quarkus.datasource.deployment.spi.DefaultDataSourceDbKindBuildItem;
+import io.quarkus.datasource.deployment.spi.DeferredDevServicesDatasourceProvider;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceConfigurationHandlerBuildItem;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceContainerConfig;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceProvider;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceProviderBuildItem;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceResultBuildItem;
+import io.quarkus.datasource.deployment.spi.GenericDevServicesDatasourceProvider;
 import io.quarkus.datasource.runtime.DataSourceBuildTimeConfig;
 import io.quarkus.datasource.runtime.DataSourcesBuildTimeConfig;
 import io.quarkus.deployment.Capabilities;
@@ -51,10 +55,13 @@ public class DevServicesDatasourceProcessor {
     private static final Logger log = Logger.getLogger(DevServicesDatasourceProcessor.class);
     private static final int DOCKER_PS_ID_LENGTH = 12;
 
+    @Deprecated(since = "3.32", forRemoval = true) // Use the new model from https://github.com/orgs/quarkusio/projects/49, avoid statics in processors
     static volatile List<RunningDevService> databases;
 
+    @Deprecated(since = "3.32", forRemoval = true) // Use the new model from https://github.com/orgs/quarkusio/projects/49, avoid statics in processors
     static volatile Map<String, Object> cachedProperties;
 
+    @Deprecated(since = "3.32", forRemoval = true) // Use the new model from https://github.com/orgs/quarkusio/projects/49, avoid statics in processors
     static volatile boolean first = true;
 
     @BuildStep
@@ -78,7 +85,7 @@ DevServicesDatasourceResultBuildItem launchDatabases(
         boolean useSharedNetwork = DevServicesSharedNetworkBuildItem.isSharedNetworkRequired(devServicesConfig,
                 devServicesSharedNetworkBuildItem);
 
-        boolean shouldStartServices = !checkRunningDatabasesAreSuitableAndCloseIfNot(composeProjectBuildItem,
+        boolean shouldStartOldStyleServices = !checkRunningDatabasesAreSuitableAndCloseIfNot(composeProjectBuildItem,
                 dataSourcesBuildTimeConfig,
                 devServicesResultBuildItemBuildProducer);
 
@@ -90,7 +97,6 @@ DevServicesDatasourceResultBuildItem launchDatabases(
         //to keep things simpler for now we are only going to support this for the default datasource
         //support for named datasources will come later
 
-        Map<String, String> propertiesMap = new HashMap<>();
         List<RunningDevService> runningDevServices = new ArrayList<>();
         Map<String, List<DevServicesDatasourceConfigurationHandlerBuildItem>> configHandlersByDbType = configurationHandlerBuildItems
                 .stream()
@@ -103,14 +109,19 @@ DevServicesDatasourceResultBuildItem launchDatabases(
                             return ret;
                         }));
         Map<String, DevServicesDatasourceProvider> devDBProviderMap = devDBProviders.stream()
+                .filter(d -> d.getDevServicesProvider() != null)
                 .collect(Collectors.toMap(DevServicesDatasourceProviderBuildItem::getDatabase,
                         DevServicesDatasourceProviderBuildItem::getDevServicesProvider));
+        Map<String, DeferredDevServicesDatasourceProvider> deferredDevDBProviderMap = devDBProviders.stream()
+                .filter(d -> d.getDeferredDevServicesProvider() != null)
+                .collect(Collectors.toMap(DevServicesDatasourceProviderBuildItem::getDatabase,
+                        DevServicesDatasourceProviderBuildItem::getDeferredDevServicesProvider));
 
-        if (shouldStartServices) {
+        if (shouldStartOldStyleServices) {
             for (Map.Entry<String, DataSourceBuildTimeConfig> entry : dataSourcesBuildTimeConfig.dataSources().entrySet()) {
                 RunningDevService devService = startDevDb(entry.getKey(), capabilities, curateOutcomeBuildItem,
                         installedDrivers, dataSourcesBuildTimeConfig.hasNamedDataSources(),
-                        devDBProviderMap, entry.getValue(), configHandlersByDbType, propertiesMap,
+                        devDBProviderMap, deferredDevDBProviderMap, entry.getValue(), configHandlersByDbType,
                         dockerStatusBuildItem,
                         launchMode.getLaunchMode(), consoleInstalledBuildItem, loggingSetupBuildItem,
                         devServicesConfig, useSharedNetwork);
@@ -147,6 +158,21 @@ public void run() {
                 devServicesResultBuildItemBuildProducer.produce(database.toBuildItem());
             }
         }
+
+        Map<String, Object> newDatasourceConfigs = buildMapFromBuildConfig(dataSourcesBuildTimeConfig);
+
+        for (Map.Entry<String, DataSourceBuildTimeConfig> entry : dataSourcesBuildTimeConfig.dataSources().entrySet()) {
+            DevServicesResultBuildItem devService = deferredStartDevDb(entry.getKey(), capabilities, curateOutcomeBuildItem,
+                    installedDrivers, dataSourcesBuildTimeConfig.hasNamedDataSources(),
+                    devDBProviderMap, deferredDevDBProviderMap, entry.getValue(), configHandlersByDbType,
+                    dockerStatusBuildItem, composeProjectBuildItem,
+                    launchMode.getLaunchMode(), consoleInstalledBuildItem, loggingSetupBuildItem,
+                    devServicesConfig, useSharedNetwork, newDatasourceConfigs);
+            if (devService != null) {
+                devServicesResultBuildItemBuildProducer.produce(devService);
+            }
+        }
+
         return new DevServicesDatasourceResultBuildItem(results);
     }
 
@@ -226,6 +252,112 @@ private static Map<String, Object> buildMapFromBuildConfig(DataSourcesBuildTimeC
         return res;
     }
 
+    private DevServicesResultBuildItem deferredStartDevDb(
+            String dbName,
+            Capabilities capabilities,
+            CurateOutcomeBuildItem curateOutcomeBuildItem,
+            List<DefaultDataSourceDbKindBuildItem> installedDrivers,
+            boolean hasNamedDatasources,
+            Map<String, DevServicesDatasourceProvider> devDBProviderMap,
+            Map<String, DeferredDevServicesDatasourceProvider> devDBProviders,
+            DataSourceBuildTimeConfig dataSourceBuildTimeConfig,
+            Map<String, List<DevServicesDatasourceConfigurationHandlerBuildItem>> configurationHandlerBuildItems,
+            DockerStatusBuildItem dockerStatusBuildItem,
+            DevServicesComposeProjectBuildItem composeProjectBuildItem, LaunchMode launchMode,
+            Optional<ConsoleInstalledBuildItem> consoleInstalledBuildItem,
+            LoggingSetupBuildItem loggingSetupBuildItem, DevServicesConfig devServicesConfig, boolean useSharedNetwork,
+            Map<String, Object> configForWhichChangesShouldTriggerARestart) {
+
+        String dataSourcePrettyName = getDataSourcePrettyName(dbName);
+
+        if (!shouldStart(dbName, dataSourceBuildTimeConfig, useSharedNetwork, dataSourcePrettyName)) {
+            return null;
+        }
+
+        Optional<String> maybeDefaultDbKind = getDefaultDbKind(dbName, curateOutcomeBuildItem, installedDrivers,
+                hasNamedDatasources,
+                dataSourceBuildTimeConfig);
+
+        if (maybeDefaultDbKind.isEmpty()) {
+            //nothing we can do
+            log.warn("Unable to determine a database type for " + dataSourcePrettyName);
+            return null;
+        }
+
+        String defaultDbKind = maybeDefaultDbKind.get();
+
+        DeferredDevServicesDatasourceProvider devDbProvider = devDBProviders.get(defaultDbKind);
+        List<DevServicesDatasourceConfigurationHandlerBuildItem> configHandlers = configurationHandlerBuildItems
+                .get(defaultDbKind);
+
+        if (!shouldStartBasedOnConfigHandler(dbName, devDBProviderMap, devDBProviders, dataSourceBuildTimeConfig,
+                configurationHandlerBuildItems, dockerStatusBuildItem, launchMode, devDbProvider, configHandlers, defaultDbKind,
+                dataSourcePrettyName)) {
+            return null;
+        }
+
+        //ok, so we know we need to start one
+        StartupLogCompressor compressor = getCompressor(launchMode, consoleInstalledBuildItem, loggingSetupBuildItem,
+                dataSourcePrettyName, defaultDbKind);
+
+        try {
+            DevServicesDatasourceContainerConfig containerConfig = getContainerConfig(dataSourceBuildTimeConfig);
+
+            Map<String, Function<DatasourceStartable, String>> devDebProperties = new HashMap<>();
+            for (DevServicesDatasourceConfigurationHandlerBuildItem devDbConfigurationHandlerBuildItem : configHandlers) {
+                Map<String, Function<DatasourceStartable, String>> properties = devDbConfigurationHandlerBuildItem
+                        .getDeferredConfigProviderFunction().apply(
+                                dbName);
+                processConfigMap(capabilities, properties, devDebProperties);
+            }
+
+            Optional<String> usernameFromConfig = ConfigUtils.getFirstOptionalValue(
+                    DataSourceUtil.dataSourcePropertyKeys(dbName, "username"),
+                    String.class);
+            Optional<String> passwordFromConfig = ConfigUtils.getFirstOptionalValue(
+                    DataSourceUtil.dataSourcePropertyKeys(dbName, "password"),
+                    String.class);
+
+            String feature = devDbProvider.getFeature();
+
+            DevServicesResultBuildItem buildItem = devDbProvider
+                    .findRunningComposeDatasource(launchMode, useSharedNetwork, containerConfig, composeProjectBuildItem)
+                    .map(datasource -> DevServicesResultBuildItem.discovered().feature(feature).containerId(datasource.id())
+                            .config(makeConfigMapForRunningDatasource(dbName, capabilities, configHandlers, datasource))
+                            .build())
+                    .orElseGet(() -> {
+                        DatasourceStartable startable = devDbProvider
+                                .createDatasourceStartable(
+                                        usernameFromConfig,
+                                        passwordFromConfig,
+                                        dbName, containerConfig,
+                                        launchMode, useSharedNetwork, devServicesConfig.timeout());
+
+                        Map<String, String> credentials = new HashMap();
+                        setDataSourceProperties(credentials, dbName, "username", startable.getUsername());
+                        setDataSourceProperties(credentials, dbName, "password", startable.getPassword());
+
+                        return DevServicesResultBuildItem.owned().feature(feature).startable(() -> startable)
+                                .serviceName(dbName)
+                                .serviceConfig(configForWhichChangesShouldTriggerARestart)
+                                .config(credentials)
+                                .configProvider(devDebProperties)
+                                .postStartHook((s) -> {
+                                    String id = s.runningDevServicesDatasource().id();
+                                    logStart(id, dataSourcePrettyName, defaultDbKind);
+                                })
+                                .build();
+                    });
+
+            compressor.close();
+
+            return buildItem;
+        } catch (Throwable t) {
+            compressor.closeAndDumpCaptured();
+            throw new RuntimeException(t);
+        }
+    }
+
     private static void logStart(String id, String dataSourcePrettyName, String defaultDbKind) {
         if (id == null) {
             log.infof("Dev Services for %s (%s) started", dataSourcePrettyName, defaultDbKind);
@@ -268,9 +400,11 @@ private static String getDataSourcePrettyName(String dbName) {
 
     private static void maybeWarnAboutMissingProvider(Map<String, DevServicesDatasourceProvider> devDBProviderMap,
             Map<String, List<DevServicesDatasourceConfigurationHandlerBuildItem>> configurationHandlerBuildItems,
+            Map<String, DeferredDevServicesDatasourceProvider> deferredDevDBProviderMap,
             String defaultDbKind, String dataSourcePrettyName) {
-        // Before warning, check if there are providers and handlers on the other API path
-        boolean hasProvider = devDBProviderMap.containsKey(defaultDbKind);
+        // Before warning, check if there are providers and handlers on the deferred API path
+        boolean hasProvider = devDBProviderMap.containsKey(defaultDbKind)
+                || deferredDevDBProviderMap.containsKey(defaultDbKind);
         boolean hasConfigHandler = configurationHandlerBuildItems
                 .containsKey(defaultDbKind);
         if (!hasProvider || !hasConfigHandler) {
@@ -286,10 +420,9 @@ private RunningDevService startDevDb(
             List<DefaultDataSourceDbKindBuildItem> installedDrivers,
             boolean hasNamedDatasources,
             Map<String, DevServicesDatasourceProvider> devDBProviders,
+            Map<String, DeferredDevServicesDatasourceProvider> deferredDevDBProviderMap,
             DataSourceBuildTimeConfig dataSourceBuildTimeConfig,
             Map<String, List<DevServicesDatasourceConfigurationHandlerBuildItem>> configurationHandlerBuildItems,
-            Map<String, String> propertiesMap,
-
             DockerStatusBuildItem dockerStatusBuildItem,
             LaunchMode launchMode, Optional<ConsoleInstalledBuildItem> consoleInstalledBuildItem,
             LoggingSetupBuildItem loggingSetupBuildItem, DevServicesConfig devServicesConfig, boolean useSharedNetwork) {
@@ -315,13 +448,14 @@ private RunningDevService startDevDb(
         DevServicesDatasourceProvider devDbProvider = devDBProviders.get(defaultDbKind);
         List<DevServicesDatasourceConfigurationHandlerBuildItem> configHandlers = configurationHandlerBuildItems
                 .get(defaultDbKind);
-        if (!shouldStartBasedOnConfigHandler(dbName, devDBProviders, dataSourceBuildTimeConfig,
+        if (!shouldStartBasedOnConfigHandler(dbName, devDBProviders, deferredDevDBProviderMap, dataSourceBuildTimeConfig,
                 configurationHandlerBuildItems, dockerStatusBuildItem, launchMode, devDbProvider, configHandlers, defaultDbKind,
                 dataSourcePrettyName)) {
             return null;
         }
 
         //ok, so we know we need to start one
+        Map<String, String> propertiesMap = new HashMap<>();
         StartupLogCompressor compressor = getCompressor(launchMode, consoleInstalledBuildItem, loggingSetupBuildItem,
                 dataSourcePrettyName, defaultDbKind);
 
@@ -362,26 +496,8 @@ private RunningDevService startDevDb(
             setDataSourceProperties(propertiesMap, dbName, devServicesPrefix + "reuse",
                     String.valueOf(dataSourceBuildTimeConfig.devservices().reuse()));
 
-            Map<String, String> devDebProperties = new HashMap<>();
-            for (DevServicesDatasourceConfigurationHandlerBuildItem devDbConfigurationHandlerBuildItem : configHandlers) {
-                Map<String, String> properties = devDbConfigurationHandlerBuildItem.getConfigProviderFunction().apply(dbName,
-                        datasource);
-                for (Map.Entry<String, String> entry : properties.entrySet()) {
-                    if (entry.getKey().contains(".jdbc.") && entry.getKey().endsWith(".url")) {
-                        if (capabilities.isCapabilityWithPrefixPresent(Capability.AGROAL)) {
-                            devDebProperties.put(entry.getKey(), entry.getValue());
-                        }
-                    } else {
-                        devDebProperties.put(entry.getKey(), entry.getValue());
-                    }
-                }
-            }
-            if (datasource.username() != null) {
-                setDataSourceProperties(devDebProperties, dbName, "username", datasource.username());
-            }
-            if (datasource.password() != null) {
-                setDataSourceProperties(devDebProperties, dbName, "password", datasource.password());
-            }
+            Map<String, String> devDebProperties = makeConfigMapForRunningDatasource(dbName, capabilities, configHandlers,
+                    datasource);
             compressor.close();
             logStart(datasource.id(), dataSourcePrettyName, defaultDbKind);
 
@@ -400,16 +516,49 @@ private RunningDevService startDevDb(
         }
     }
 
+    private Map<String, String> makeConfigMapForRunningDatasource(String dbName, Capabilities capabilities,
+            List<DevServicesDatasourceConfigurationHandlerBuildItem> configHandlers,
+            DevServicesDatasourceProvider.RunningDevServicesDatasource datasource) {
+        Map<String, String> devDebProperties = new HashMap<>();
+        for (DevServicesDatasourceConfigurationHandlerBuildItem devDbConfigurationHandlerBuildItem : configHandlers) {
+            Map<String, String> properties = devDbConfigurationHandlerBuildItem.getConfigProviderFunction().apply(dbName,
+                    datasource);
+            processConfigMap(capabilities, properties, devDebProperties);
+        }
+        if (datasource.username() != null) {
+            setDataSourceProperties(devDebProperties, dbName, "username", datasource.username());
+        }
+        if (datasource.password() != null) {
+            setDataSourceProperties(devDebProperties, dbName, "password", datasource.password());
+        }
+        return devDebProperties;
+    }
+
+    private static <T> void processConfigMap(Capabilities capabilities, Map<String, T> properties,
+            Map<String, T> devDebProperties) {
+        for (Map.Entry<String, T> entry : properties.entrySet()) {
+            if (entry.getKey().contains(".jdbc.") && entry.getKey().endsWith(".url")) {
+                if (capabilities.isCapabilityWithPrefixPresent(Capability.AGROAL)) {
+                    devDebProperties.put(entry.getKey(), entry.getValue());
+                }
+            } else {
+                devDebProperties.put(entry.getKey(), entry.getValue());
+            }
+        }
+    }
+
     private static boolean shouldStartBasedOnConfigHandler(String dbName,
             Map<String, DevServicesDatasourceProvider> devDBProviders,
+            Map<String, DeferredDevServicesDatasourceProvider> deferredDevDBProviderMap,
             DataSourceBuildTimeConfig dataSourceBuildTimeConfig,
             Map<String, List<DevServicesDatasourceConfigurationHandlerBuildItem>> configurationHandlerBuildItems,
             DockerStatusBuildItem dockerStatusBuildItem, LaunchMode launchMode,
-            DevServicesDatasourceProvider devDbProvider,
+            GenericDevServicesDatasourceProvider devDbProvider,
             List<DevServicesDatasourceConfigurationHandlerBuildItem> configHandlers, String defaultDbKind,
             String dataSourcePrettyName) {
         if (devDbProvider == null || configHandlers == null) {
-            maybeWarnAboutMissingProvider(devDBProviders, configurationHandlerBuildItems, defaultDbKind,
+            maybeWarnAboutMissingProvider(devDBProviders, configurationHandlerBuildItems, deferredDevDBProviderMap,
+                    defaultDbKind,
                     dataSourcePrettyName);
             return false;
         }
@@ -492,6 +641,14 @@ private void setDataSourceProperties(Map<String, String> propertiesMap, String d
         }
     }
 
+    private void setDataSourceProperties(Map<String, Function<DatasourceStartable, String>> propertiesMap, String dbName,
+            String propertyKeyRadical,
+            Function<DatasourceStartable, String> value) {
+        for (String key : DataSourceUtil.dataSourcePropertyKeys(dbName, propertyKeyRadical)) {
+            propertiesMap.put(key, value);
+        }
+    }
+
     private DevServicesDatasourceResultBuildItem.DbResult toDbResult(RunningDevService devService) {
         if (devService == null) {
             return null;
diff --git a/extensions/datasource/runtime/pom.xml b/extensions/datasource/runtime/pom.xml
index 00593d62523..a91a12318a0 100644
--- a/extensions/datasource/runtime/pom.xml
+++ b/extensions/datasource/runtime/pom.xml
@@ -30,6 +30,10 @@
             <groupId>io.quarkus</groupId>
             <artifactId>quarkus-datasource-common</artifactId>
         </dependency>
+        <dependency>
+            <groupId>io.quarkus</groupId>
+            <artifactId>quarkus-devservices</artifactId>
+        </dependency>
         <dependency>
             <groupId>io.quarkus</groupId>
             <artifactId>quarkus-credentials</artifactId>
diff --git a/extensions/devservices/db2/src/main/java/io/quarkus/devservices/db2/deployment/DB2DevServicesProcessor.java b/extensions/devservices/db2/src/main/java/io/quarkus/devservices/db2/deployment/DB2DevServicesProcessor.java
index 5f9927195ec..ebec2c1eafe 100644
--- a/extensions/devservices/db2/src/main/java/io/quarkus/devservices/db2/deployment/DB2DevServicesProcessor.java
+++ b/extensions/devservices/db2/src/main/java/io/quarkus/devservices/db2/deployment/DB2DevServicesProcessor.java
@@ -12,7 +12,6 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.OptionalInt;
-import java.util.function.Supplier;
 
 import org.jboss.logging.Logger;
 import org.testcontainers.db2.Db2Container;
@@ -20,9 +19,12 @@
 
 import io.quarkus.datasource.common.runtime.DataSourceUtil;
 import io.quarkus.datasource.common.runtime.DatabaseKind;
+import io.quarkus.datasource.deployment.spi.DatasourceStartable;
+import io.quarkus.datasource.deployment.spi.DeferredDevServicesDatasourceProvider;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceContainerConfig;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceProvider;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceProviderBuildItem;
+import io.quarkus.deployment.Feature;
 import io.quarkus.deployment.annotations.BuildStep;
 import io.quarkus.deployment.builditem.DevServicesComposeProjectBuildItem;
 import io.quarkus.deployment.builditem.DevServicesSharedNetworkBuildItem;
@@ -30,7 +32,6 @@
 import io.quarkus.deployment.util.ContainerRuntimeUtil;
 import io.quarkus.devservices.common.ComposeLocator;
 import io.quarkus.devservices.common.ConfigureUtil;
-import io.quarkus.devservices.common.ContainerShutdownCloseable;
 import io.quarkus.devservices.common.JBossLoggingConsumer;
 import io.quarkus.devservices.common.Labels;
 import io.quarkus.devservices.common.Volumes;
@@ -70,14 +71,18 @@ DevServicesDatasourceProviderBuildItem setupDB2(
             List<DevServicesSharedNetworkBuildItem> devServicesSharedNetworkBuildItem,
             DevServicesComposeProjectBuildItem composeProjectBuildItem,
             DevServicesConfig devServicesConfig) {
-        return new DevServicesDatasourceProviderBuildItem(DatabaseKind.DB2, new DevServicesDatasourceProvider() {
+        return new DevServicesDatasourceProviderBuildItem(DatabaseKind.DB2, new DeferredDevServicesDatasourceProvider() {
+
+            @Override
+            public String getFeature() {
+                return Feature.JDBC_DB2.getName();
+            }
+
             @Override
-            public RunningDevServicesDatasource startDatabase(Optional<String> username, Optional<String> password,
+            public DatasourceStartable createDatasourceStartable(Optional<String> username, Optional<String> password,
                     String datasourceName, DevServicesDatasourceContainerConfig containerConfig,
-                    LaunchMode launchMode, Optional<Duration> startupTimeout) {
+                    LaunchMode launchMode, boolean useSharedNetwork, Optional<Duration> startupTimeout) {
 
-                boolean useSharedNetwork = DevServicesSharedNetworkBuildItem.isSharedNetworkRequired(devServicesConfig,
-                        devServicesSharedNetworkBuildItem);
                 String effectiveUsername = containerConfig.getUsername().orElse(username.orElse(DEFAULT_DATABASE_USERNAME));
                 String effectivePassword = containerConfig.getPassword().orElse(password.orElse(DEFAULT_DATABASE_PASSWORD));
                 String effectiveDbName = containerConfig.getDbName().orElseGet(() -> {
@@ -99,54 +104,50 @@ public RunningDevServicesDatasource startDatabase(Optional<String> username, Opt
                     return datasourceName;
                 });
 
-                Supplier<RunningDevServicesDatasource> maybe = () -> {
-                    // We just use this to enable a workaround, so:
-                    boolean podman = ContainerRuntimeUtil.detectContainerRuntime(
-                            false, // Don't fail if container runtime can't be found.
-                            true // Be silent.
-                    ).isPodman();
-                    QuarkusDb2Container container = new QuarkusDb2Container(containerConfig.getImageName(),
-                            containerConfig.getFixedExposedPort(), composeProjectBuildItem.getDefaultNetworkId(),
-                            useSharedNetwork, podman);
-                    startupTimeout.ifPresent(container::withStartupTimeout);
-
-                    container.withUsername(effectiveUsername)
-                            .withPassword(effectivePassword)
-                            .withDatabaseName(effectiveDbName)
-                            .withReuse(containerConfig.isReuse());
-                    Labels.addDataSourceLabel(container, datasourceName);
-                    Volumes.addVolumes(container, containerConfig.getVolumes());
-
-                    container.withEnv(containerConfig.getContainerEnv());
-
-                    containerConfig.getAdditionalJdbcUrlProperties().forEach(container::withUrlParam);
-                    containerConfig.getCommand().ifPresent(container::setCommand);
-                    containerConfig.getInitScriptPath().ifPresent(container::withInitScripts);
-                    if (containerConfig.isShowLogs()) {
-                        container.withLogConsumer(new JBossLoggingConsumer(LOG));
-                    }
-                    container.start();
+                // We just use this to enable a workaround, so:
+                boolean podman = ContainerRuntimeUtil.detectContainerRuntime(
+                        false, // Don't fail if container runtime can't be found.
+                        true // Be silent.
+                ).isPodman();
+                QuarkusDb2Container container = new QuarkusDb2Container(containerConfig.getImageName(),
+                        containerConfig.getFixedExposedPort(), composeProjectBuildItem.getDefaultNetworkId(),
+                        useSharedNetwork, podman);
+                startupTimeout.ifPresent(container::withStartupTimeout);
+
+                container.withUsername(effectiveUsername)
+                        .withPassword(effectivePassword)
+                        .withDatabaseName(effectiveDbName)
+                        .withReuse(containerConfig.isReuse());
+                Labels.addDataSourceLabel(container, datasourceName);
+                Volumes.addVolumes(container, containerConfig.getVolumes());
+
+                container.withEnv(containerConfig.getContainerEnv());
+
+                containerConfig.getAdditionalJdbcUrlProperties().forEach(container::withUrlParam);
+                containerConfig.getCommand().ifPresent(container::setCommand);
+                containerConfig.getInitScriptPath().ifPresent(container::withInitScripts);
+                if (containerConfig.isShowLogs()) {
+                    container.withLogConsumer(new JBossLoggingConsumer(LOG));
+                }
+
+                return container;
+            }
 
-                    LOG.info("Dev Services for IBM Db2 started.");
+            @Override
+            public Optional<DevServicesDatasourceProvider.RunningDevServicesDatasource> findRunningComposeDatasource(
+                    LaunchMode launchMode, boolean useSharedNetwork, DevServicesDatasourceContainerConfig containerConfig,
+                    DevServicesComposeProjectBuildItem composeProjectBuildItem) {
 
-                    return new RunningDevServicesDatasource(container.getContainerId(),
-                            container.getEffectiveJdbcUrl(),
-                            container.getReactiveUrl(),
-                            container.getUsername(),
-                            container.getPassword(),
-                            new ContainerShutdownCloseable(container, "IBM Db2"));
-                };
                 List<String> images = List.of(containerConfig.getImageName()
                         .orElseGet(() -> ConfigureUtil.getDefaultImageNameFor("db2")),
                         "db2");
                 return ComposeLocator.locateContainer(composeProjectBuildItem, images, DB2_PORT, launchMode, useSharedNetwork)
-                        .map(containerAddress -> configurator.composeRunningService(containerAddress, containerConfig))
-                        .orElseGet(maybe);
+                        .map(containerAddress -> configurator.composeRunningService(containerAddress, containerConfig));
             }
         });
     }
 
-    private static class QuarkusDb2Container extends Db2Container {
+    private static class QuarkusDb2Container extends Db2Container implements DatasourceStartable {
         private final OptionalInt fixedExposedPort;
         private final boolean useSharedNetwork;
         private final boolean podman;
@@ -207,5 +208,15 @@ public String getEffectiveJdbcUrl() {
         public String getReactiveUrl() {
             return getEffectiveJdbcUrl().replaceFirst("jdbc:", "vertx-reactive:");
         }
+
+        @Override
+        public String getConnectionInfo() {
+            return getEffectiveJdbcUrl();
+        }
+
+        @Override
+        public void close() {
+            super.close();
+        }
     }
 }
diff --git a/extensions/devservices/mssql/src/main/java/io/quarkus/devservices/mssql/deployment/MSSQLDevServicesProcessor.java b/extensions/devservices/mssql/src/main/java/io/quarkus/devservices/mssql/deployment/MSSQLDevServicesProcessor.java
index 5f13fd5d895..cab0e36ddd0 100644
--- a/extensions/devservices/mssql/src/main/java/io/quarkus/devservices/mssql/deployment/MSSQLDevServicesProcessor.java
+++ b/extensions/devservices/mssql/src/main/java/io/quarkus/devservices/mssql/deployment/MSSQLDevServicesProcessor.java
@@ -7,23 +7,23 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.OptionalInt;
-import java.util.function.Supplier;
 
 import org.jboss.logging.Logger;
 import org.testcontainers.mssqlserver.MSSQLServerContainer;
 import org.testcontainers.utility.DockerImageName;
 
 import io.quarkus.datasource.common.runtime.DatabaseKind;
+import io.quarkus.datasource.deployment.spi.DatasourceStartable;
+import io.quarkus.datasource.deployment.spi.DeferredDevServicesDatasourceProvider;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceContainerConfig;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceProvider;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceProviderBuildItem;
+import io.quarkus.deployment.Feature;
 import io.quarkus.deployment.annotations.BuildStep;
 import io.quarkus.deployment.builditem.DevServicesComposeProjectBuildItem;
 import io.quarkus.deployment.builditem.DevServicesSharedNetworkBuildItem;
-import io.quarkus.deployment.dev.devservices.DevServicesConfig;
 import io.quarkus.devservices.common.ComposeLocator;
 import io.quarkus.devservices.common.ConfigureUtil;
-import io.quarkus.devservices.common.ContainerShutdownCloseable;
 import io.quarkus.devservices.common.JBossLoggingConsumer;
 import io.quarkus.devservices.common.Labels;
 import io.quarkus.devservices.common.Volumes;
@@ -43,66 +43,61 @@ public class MSSQLDevServicesProcessor {
     @BuildStep
     DevServicesDatasourceProviderBuildItem setupMSSQL(
             List<DevServicesSharedNetworkBuildItem> devServicesSharedNetworkBuildItem,
-            DevServicesComposeProjectBuildItem composeProjectBuildItem,
-            DevServicesConfig devServicesConfig) {
-        return new DevServicesDatasourceProviderBuildItem(DatabaseKind.MSSQL, new DevServicesDatasourceProvider() {
-            @SuppressWarnings("unchecked")
+            DevServicesComposeProjectBuildItem composeProjectBuildItem) {
+
+        return new DevServicesDatasourceProviderBuildItem(DatabaseKind.MSSQL, new DeferredDevServicesDatasourceProvider() {
+            @Override
+            public String getFeature() {
+                return Feature.JDBC_MSSQL.getName();
+            }
+
             @Override
-            public RunningDevServicesDatasource startDatabase(Optional<String> username, Optional<String> password,
+            public DatasourceStartable createDatasourceStartable(Optional<String> username, Optional<String> password,
                     String datasourceName, DevServicesDatasourceContainerConfig containerConfig,
-                    LaunchMode launchMode, Optional<Duration> startupTimeout) {
-
-                boolean useSharedNetwork = DevServicesSharedNetworkBuildItem.isSharedNetworkRequired(devServicesConfig,
-                        devServicesSharedNetworkBuildItem);
-
-                Supplier<RunningDevServicesDatasource> startService = () -> {
-                    QuarkusMSSQLServerContainer container = new QuarkusMSSQLServerContainer(containerConfig.getImageName(),
-                            containerConfig.getFixedExposedPort(),
-                            composeProjectBuildItem.getDefaultNetworkId(),
-                            !devServicesSharedNetworkBuildItem.isEmpty());
-                    startupTimeout.ifPresent(container::withStartupTimeout);
-
-                    String effectivePassword = containerConfig.getPassword()
-                            .orElse(password.orElse(DEFAULT_DATABASE_STRONG_PASSWORD));
-
-                    // Defining the database name and the username is not supported by this container yet
-                    container.withPassword(effectivePassword)
-                            .withReuse(containerConfig.isReuse());
-                    Labels.addDataSourceLabel(container, datasourceName);
-                    Volumes.addVolumes(container, containerConfig.getVolumes());
-
-                    container.withEnv(containerConfig.getContainerEnv());
-
-                    containerConfig.getAdditionalJdbcUrlProperties().forEach(container::withUrlParam);
-                    containerConfig.getCommand().ifPresent(container::setCommand);
-                    containerConfig.getInitScriptPath().ifPresent(container::withInitScripts);
-                    if (containerConfig.isShowLogs()) {
-                        container.withLogConsumer(new JBossLoggingConsumer(LOG));
-                    }
-
-                    container.start();
-
-                    LOG.info("Dev Services for Microsoft SQL Server started.");
-
-                    return new RunningDevServicesDatasource(container.getContainerId(),
-                            container.getEffectiveJdbcUrl(),
-                            container.getReactiveUrl(),
-                            DEFAULT_USERNAME,
-                            container.getPassword(),
-                            new ContainerShutdownCloseable(container, "Microsoft SQL Server"));
-                };
+                    LaunchMode launchMode, boolean useSharedNetwork, Optional<Duration> startupTimeout) {
+
+                QuarkusMSSQLServerContainer container = new QuarkusMSSQLServerContainer(containerConfig.getImageName(),
+                        containerConfig.getFixedExposedPort(),
+                        composeProjectBuildItem.getDefaultNetworkId(),
+                        !devServicesSharedNetworkBuildItem.isEmpty());
+                startupTimeout.ifPresent(container::withStartupTimeout);
+
+                String effectivePassword = containerConfig.getPassword()
+                        .orElse(password.orElse(DEFAULT_DATABASE_STRONG_PASSWORD));
+
+                // Defining the database name and the username is not supported by this container yet
+                container.withPassword(effectivePassword)
+                        .withReuse(containerConfig.isReuse());
+                Labels.addDataSourceLabel(container, datasourceName);
+                Volumes.addVolumes(container, containerConfig.getVolumes());
+
+                container.withEnv(containerConfig.getContainerEnv());
+
+                containerConfig.getAdditionalJdbcUrlProperties().forEach(container::withUrlParam);
+                containerConfig.getCommand().ifPresent(container::setCommand);
+                containerConfig.getInitScriptPath().ifPresent(container::withInitScripts);
+                if (containerConfig.isShowLogs()) {
+                    container.withLogConsumer(new JBossLoggingConsumer(LOG));
+                }
+
+                return container;
+            }
+
+            @Override
+            public Optional<DevServicesDatasourceProvider.RunningDevServicesDatasource> findRunningComposeDatasource(
+                    LaunchMode launchMode, boolean useSharedNetwork, DevServicesDatasourceContainerConfig containerConfig,
+                    DevServicesComposeProjectBuildItem composeProjectBuildItem) {
                 List<String> images = List.of(
                         containerConfig.getImageName().orElseGet(() -> ConfigureUtil.getDefaultImageNameFor("mssql")),
                         "mssql");
                 return ComposeLocator
                         .locateContainer(composeProjectBuildItem, images, MS_SQL_SERVER_PORT, launchMode, useSharedNetwork)
-                        .map(containerAddress -> configurator.composeRunningService(containerAddress, containerConfig))
-                        .orElseGet(startService);
+                        .map(containerAddress -> configurator.composeRunningService(containerAddress, containerConfig));
             }
         });
     }
 
-    private static class QuarkusMSSQLServerContainer extends MSSQLServerContainer {
+    private static class QuarkusMSSQLServerContainer extends MSSQLServerContainer implements DatasourceStartable {
         private final OptionalInt fixedExposedPort;
         private final boolean useSharedNetwork;
 
@@ -156,5 +151,21 @@ public String getReactiveUrl() {
             }
             return url.toString();
         }
+
+        @Override
+        public String getUsername() {
+            // Defining the database name and the username is not supported by this container yet, so always return the default, with our case adjustments
+            return DEFAULT_USERNAME;
+        }
+
+        @Override
+        public String getConnectionInfo() {
+            return getEffectiveJdbcUrl();
+        }
+
+        @Override
+        public void close() {
+            super.close();
+        }
     }
 }
diff --git a/extensions/devservices/oracle/src/main/java/io/quarkus/devservices/oracle/deployment/OracleDevServicesProcessor.java b/extensions/devservices/oracle/src/main/java/io/quarkus/devservices/oracle/deployment/OracleDevServicesProcessor.java
index 30f109edfc6..2f9bf65a8bf 100644
--- a/extensions/devservices/oracle/src/main/java/io/quarkus/devservices/oracle/deployment/OracleDevServicesProcessor.java
+++ b/extensions/devservices/oracle/src/main/java/io/quarkus/devservices/oracle/deployment/OracleDevServicesProcessor.java
@@ -8,7 +8,6 @@
 import java.util.List;
 import java.util.Optional;
 import java.util.OptionalInt;
-import java.util.function.Supplier;
 
 import org.jboss.logging.Logger;
 import org.testcontainers.containers.OracleContainer;
@@ -17,16 +16,16 @@
 
 import io.quarkus.datasource.common.runtime.DataSourceUtil;
 import io.quarkus.datasource.common.runtime.DatabaseKind;
+import io.quarkus.datasource.deployment.spi.DatasourceStartable;
+import io.quarkus.datasource.deployment.spi.DeferredDevServicesDatasourceProvider;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceContainerConfig;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceProvider;
 import io.quarkus.datasource.deployment.spi.DevServicesDatasourceProviderBuildItem;
+import io.quarkus.deployment.Feature;
 import io.quarkus.deployment.annotations.BuildStep;
 import io.quarkus.deployment.builditem.DevServicesComposeProjectBuildItem;
-import io.quarkus.deployment.builditem.DevServicesSharedNetworkBuildItem;
-import io.quarkus.deployment.dev.devservices.DevServicesConfig;
 import io.quarkus.devservices.common.ComposeLocator;
 import io.quarkus.devservices.common.ConfigureUtil;
-import io.quarkus.devservices.common.ContainerShutdownCloseable;
 import io.quarkus.devservices.common.JBossLoggingConsumer;
 import io.quarkus.devservices.common.Labels;
 import io.quarkus.devservices.common.Volumes;
@@ -47,82 +46,81 @@ public class OracleDevServicesProcessor {
 
     @BuildStep
     DevServicesDatasourceProviderBuildItem setupOracle(
-            List<DevServicesSharedNetworkBuildItem> devServicesSharedNetworkBuildItem,
-            DevServicesComposeProjectBuildItem composeProjectBuildItem,
-            DevServicesConfig devServicesConfig) {
-        return new DevServicesDatasourceProviderBuildItem(DatabaseKind.ORACLE, new DevServicesDatasourceProvider() {
+            DevServicesComposeProjectBuildItem composeProjectBuildItem) {
+
+        return new DevServicesDatasourceProviderBuildItem(DatabaseKind.ORACLE, new DeferredDevServicesDatasourceProvider() {
             @Override
-            public RunningDevServicesDatasource startDatabase(Optional<String> username, Optional<String> password,
-                    String datasourceName, DevServicesDatasourceContainerConfig containerConfig,
-                    LaunchMode launchMode, Optional<Duration> startupTimeout) {
+            public String getFeature() {
+                return Feature.JDBC_ORACLE.getName();
+            }
 
-                boolean useSharedNetwork = DevServicesSharedNetworkBuildItem.isSharedNetworkRequired(devServicesConfig,
-                        devServicesSharedNetworkBuildItem);
+            @Override
+            public DatasourceStartable createDatasourceStartable(
+                    Optional<String> username,
+                    Optional<String> password,
+                    String datasourceName, DevServicesDatasourceContainerConfig containerConfig,
+                    LaunchMode launchMode, boolean useSharedNetwork, Optional<Duration> startupTimeout) {
 
                 String effectiveUsername = containerConfig.getUsername().orElse(username.orElse(DEFAULT_DATABASE_USERNAME));
                 String effectivePassword = containerConfig.getPassword().orElse(password.orElse(DEFAULT_DATABASE_PASSWORD));
                 String effectiveDbName = containerConfig.getDbName().orElse(
                         DataSourceUtil.isDefault(datasourceName) ? DEFAULT_DATABASE_NAME : datasourceName);
 
-                Supplier<RunningDevServicesDatasource> startService = () -> {
-
-                    QuarkusOracleServerContainer container = new QuarkusOracleServerContainer(containerConfig.getImageName(),
-                            containerConfig.getFixedExposedPort(),
-                            composeProjectBuildItem.getDefaultNetworkId(),
-                            useSharedNetwork);
-                    startupTimeout.ifPresent(container::withStartupTimeout);
-
-                    container.withUsername(effectiveUsername)
-                            .withPassword(effectivePassword)
-                            .withDatabaseName(effectiveDbName)
-                            .withReuse(containerConfig.isReuse());
-                    Labels.addDataSourceLabel(container, datasourceName);
-                    Volumes.addVolumes(container, containerConfig.getVolumes());
-
-                    container.withEnv(containerConfig.getContainerEnv());
-
-                    // We need to limit the maximum amount of CPUs being used by the container;
-                    // otherwise the hardcoded memory configuration of the DB might not be enough to successfully boot it.
-                    // See https://github.com/gvenzl/oci-oracle-xe/issues/64
-                    // I choose to limit it to "2 cpus": should be more than enough for any local testing needs,
-                    // and keeps things simple.
-                    container.withCreateContainerCmdModifier(cmd -> cmd.getHostConfig().withNanoCPUs(2_000_000_000l));
-
-                    containerConfig.getAdditionalJdbcUrlProperties().forEach(container::withUrlParam);
-                    containerConfig.getCommand().ifPresent(container::setCommand);
-                    containerConfig.getInitScriptPath().ifPresent(container::withInitScripts);
-                    if (containerConfig.getInitPrivilegedScriptPath().isPresent()) {
-                        for (String initScript : containerConfig.getInitPrivilegedScriptPath().get()) {
-                            container.withCopyFileToContainer(MountableFile.forClasspathResource(initScript),
-                                    "/container-entrypoint-startdb.d/" + initScript);
-                        }
+                QuarkusOracleServerContainer container = new QuarkusOracleServerContainer(containerConfig.getImageName(),
+                        containerConfig.getFixedExposedPort(),
+                        composeProjectBuildItem.getDefaultNetworkId(),
+                        useSharedNetwork);
+                startupTimeout.ifPresent(container::withStartupTimeout);
+
+                container.withUsername(effectiveUsername)
+                        .withPassword(effectivePassword)
+                        .withDatabaseName(effectiveDbName)
+                        .withReuse(containerConfig.isReuse());
+                Labels.addDataSourceLabel(container, datasourceName);
+                Volumes.addVolumes(container, containerConfig.getVolumes());
+
+                container.withEnv(containerConfig.getContainerEnv());
+
+                // We need to limit the maximum amount of CPUs being used by the container;
+                // otherwise the hardcoded memory configuration of the DB might not be enough to successfully boot it.
+                // See https://github.com/gvenzl/oci-oracle-xe/issues/64
+                // I choose to limit it to "2 cpus": should be more than enough for any local testing needs,
+                // and keeps things simple.
+                container.withCreateContainerCmdModifier(cmd -> cmd.getHostConfig().withNanoCPUs(2_000_000_000l));
+
+                containerConfig.getAdditionalJdbcUrlProperties().forEach(container::withUrlParam);
+                containerConfig.getCommand().ifPresent(container::setCommand);
+                containerConfig.getInitScriptPath().ifPresent(container::withInitScripts);
+                if (containerConfig.getInitPrivilegedScriptPath().isPresent()) {
+                    for (String initScript : containerConfig.getInitPrivilegedScriptPath().get()) {
+                        container.withCopyFileToContainer(MountableFile.forClasspathResource(initScript),
+                                "/container-entrypoint-startdb.d/" + initScript);
                     }
-                    if (containerConfig.isShowLogs()) {
-                        container.withLogConsumer(new JBossLoggingConsumer(LOG));
-                    }
-
-                    container.start();
+                }
+                if (containerConfig.isShowLogs()) {
+                    container.withLogConsumer(new JBossLoggingConsumer(LOG));
+                }
 
-                    LOG.info("Dev Services for Oracle started.");
+                return container;
+            }
 
-                    return new RunningDevServicesDatasource(container.getContainerId(),
-                            container.getEffectiveJdbcUrl(),
-                            container.getReactiveUrl(),
-                            container.getUsername(),
-                            container.getPassword(),
-                            new ContainerShutdownCloseable(container, "Oracle"));
-                };
+            @Override
+            public Optional<DevServicesDatasourceProvider.RunningDevServicesDatasource> findRunningComposeDatasource(
+                    LaunchMode launchMode,
+                    boolean useSharedNetwork, DevServicesDatasourceContainerConfig containerConfig,
+                    DevServicesComposeProjectBuildItem composeProjectBuildItem) {
                 List<String> images = List.of(
                         containerConfig.getImageName().orElseGet(() -> ConfigureUtil.getDefaultImageNameFor("oracle")),
                         "oracle");
+
                 return ComposeLocator.locateContainer(composeProjectBuildItem, images, PORT, launchMode, useSharedNetwork)
-                        .map(containerAddress -> configurator.composeRunningService(containerAddress, containerConfig))
-                        .orElseGet(startService);
+                        .map(containerAddress -> configurator.composeRunningService(containerAddress, containerConfig));
             }
+
         });
     }
 
-    private static class QuarkusOracleServerContainer extends OracleContainer {
+    private static class QuarkusOracleServerContainer extends OracleContainer implements DatasourceStartable {
         private final OptionalInt fixedExposedPort;
         private final boolean useSharedNetwork;
 
@@ -169,5 +167,16 @@ public String getEffectiveJdbcUrl() {
         public String getReactiveUrl() {
             return getEffectiveJdbcUrl().replaceFirst("jdbc:", "vertx-reactive:");
         }
+
+        @Override
+        public void close() {
+            super.close();
+        }
+
+        @Override
+        public String getConnectionInfo() {
+            return getEffectiveJdbcUrl();
+        }
+
     }
 }
diff --git a/extensions/funqy/funqy-amazon-lambda/maven-archetype/src/main/resources/archetype-resources/pom.xml b/extensions/funqy/funqy-amazon-lambda/maven-archetype/src/main/resources/archetype-resources/pom.xml
index 29f714c42b6..09b1cacb4e6 100644
--- a/extensions/funqy/funqy-amazon-lambda/maven-archetype/src/main/resources/archetype-resources/pom.xml
+++ b/extensions/funqy/funqy-amazon-lambda/maven-archetype/src/main/resources/archetype-resources/pom.xml
@@ -7,7 +7,7 @@
     <artifactId>\${artifactId}</artifactId>
     <version>\${version}</version>
     <properties>
-        <compiler-plugin.version>3.14.1</compiler-plugin.version>
+        <compiler-plugin.version>3.15.0</compiler-plugin.version>
         <maven.compiler.parameters>true</maven.compiler.parameters>
         <maven.compiler.target>17</maven.compiler.target>
         <maven.compiler.source>17</maven.compiler.source>
diff --git a/extensions/grpc/codegen/src/main/java/io/quarkus/grpc/codegen/GrpcCodeGen.java b/extensions/grpc/codegen/src/main/java/io/quarkus/grpc/codegen/GrpcCodeGen.java
index a067c8199d4..be527b8c0fc 100644
--- a/extensions/grpc/codegen/src/main/java/io/quarkus/grpc/codegen/GrpcCodeGen.java
+++ b/extensions/grpc/codegen/src/main/java/io/quarkus/grpc/codegen/GrpcCodeGen.java
@@ -235,8 +235,8 @@ private static void invocationEnvironmentTuning(final Map<String, String> enviro
             sb.append("-Dsun.stdout.encoding=UTF-8 ");
         }
 
-        //Do NOT set this property on Java 17, as it will fail with "unrecognized option":
-        if (Runtime.version().feature() > 21 && !existingValue.contains("--sun-misc-unsafe-memory-access=")) {
+        //Do NOT set this property on Java versions before 24, as it will fail with "unrecognized option":
+        if (Runtime.version().feature() >= 24 && !existingValue.contains("--sun-misc-unsafe-memory-access=")) {
             sb.append("--sun-misc-unsafe-memory-access=allow ");
         }
         sb.append(existingValue);
diff --git a/extensions/grpc/runtime/src/main/java/io/quarkus/grpc/runtime/supports/Channels.java b/extensions/grpc/runtime/src/main/java/io/quarkus/grpc/runtime/supports/Channels.java
index d722d7e66e0..ee87fe3fe0c 100644
--- a/extensions/grpc/runtime/src/main/java/io/quarkus/grpc/runtime/supports/Channels.java
+++ b/extensions/grpc/runtime/src/main/java/io/quarkus/grpc/runtime/supports/Channels.java
@@ -115,7 +115,12 @@ public static Channel createChannel(String name, Set<String> perClientIntercepto
         String host = clientConfig.host();
         int port = clientConfig.port();
         if (LaunchMode.current() == LaunchMode.TEST) {
-            port = clientConfig.testPort().orElse(grpcServer.getPort());
+            port = clientConfig.testPort().orElseGet(() -> {
+                LOGGER.info("LaunchMode TEST detected. Overriding existing port configuration for gRPC client/server. "
+                        + "Set quarkus.grpc.clients.\"client-name\".test-port to configure the test port");
+                return grpcServer.getPort();
+            });
+
             if (port == -1) {
                 // In same cases, a Channel may be created without the port being assigned
                 port = serverConfig.testPort();
diff --git a/extensions/jdbc/jdbc-db2/deployment/src/main/java/io/quarkus/jdbc/db2/deployment/JDBCDB2Processor.java b/extensions/jdbc/jdbc-db2/deployment/src/main/java/io/quarkus/jdbc/db2/deployment/JDBCDB2Processor.java
index d3e7605db20..aee9f44b0f6 100644
--- a/extensions/jdbc/jdbc-db2/deployment/src/main/java/io/quarkus/jdbc/db2/deployment/JDBCDB2Processor.java
+++ b/extensions/jdbc/jdbc-db2/deployment/src/main/java/io/quarkus/jdbc/db2/deployment/JDBCDB2Processor.java
@@ -72,7 +72,7 @@ void registerDriver(BuildProducer<JdbcDriverBuildItem> jdbcDriver,
 
     @BuildStep
     DevServicesDatasourceConfigurationHandlerBuildItem devDbHandler() {
-        return DevServicesDatasourceConfigurationHandlerBuildItem.jdbc(DatabaseKind.DB2);
+        return DevServicesDatasourceConfigurationHandlerBuildItem.deferredJdbc(DatabaseKind.DB2);
     }
 
     @BuildStep
diff --git a/extensions/jdbc/jdbc-mssql/deployment/src/main/java/io/quarkus/jdbc/mssql/deployment/MsSQLProcessor.java b/extensions/jdbc/jdbc-mssql/deployment/src/main/java/io/quarkus/jdbc/mssql/deployment/MsSQLProcessor.java
index c137a5f4983..5338925373d 100644
--- a/extensions/jdbc/jdbc-mssql/deployment/src/main/java/io/quarkus/jdbc/mssql/deployment/MsSQLProcessor.java
+++ b/extensions/jdbc/jdbc-mssql/deployment/src/main/java/io/quarkus/jdbc/mssql/deployment/MsSQLProcessor.java
@@ -42,7 +42,7 @@ void registerDriver(BuildProducer<JdbcDriverBuildItem> jdbcDriver,
 
     @BuildStep
     DevServicesDatasourceConfigurationHandlerBuildItem devDbHandler() {
-        return DevServicesDatasourceConfigurationHandlerBuildItem.jdbc(DatabaseKind.MSSQL);
+        return DevServicesDatasourceConfigurationHandlerBuildItem.deferredJdbc(DatabaseKind.MSSQL);
     }
 
     @BuildStep
diff --git a/extensions/jdbc/jdbc-oracle/deployment/src/main/java/io/quarkus/jdbc/oracle/deployment/OracleProcessor.java b/extensions/jdbc/jdbc-oracle/deployment/src/main/java/io/quarkus/jdbc/oracle/deployment/OracleProcessor.java
index 7e4d0d7b254..08a9d449383 100644
--- a/extensions/jdbc/jdbc-oracle/deployment/src/main/java/io/quarkus/jdbc/oracle/deployment/OracleProcessor.java
+++ b/extensions/jdbc/jdbc-oracle/deployment/src/main/java/io/quarkus/jdbc/oracle/deployment/OracleProcessor.java
@@ -39,7 +39,7 @@ void registerDriver(BuildProducer<JdbcDriverBuildItem> jdbcDriver) {
 
     @BuildStep
     DevServicesDatasourceConfigurationHandlerBuildItem devDbHandler() {
-        return DevServicesDatasourceConfigurationHandlerBuildItem.jdbc(DatabaseKind.ORACLE);
+        return DevServicesDatasourceConfigurationHandlerBuildItem.deferredJdbc(DatabaseKind.ORACLE);
     }
 
     @BuildStep
diff --git a/extensions/kafka-client/deployment/src/main/java/io/quarkus/kafka/client/deployment/KafkaProcessor.java b/extensions/kafka-client/deployment/src/main/java/io/quarkus/kafka/client/deployment/KafkaProcessor.java
index ac1ef1aca16..958d4b3f990 100644
--- a/extensions/kafka-client/deployment/src/main/java/io/quarkus/kafka/client/deployment/KafkaProcessor.java
+++ b/extensions/kafka-client/deployment/src/main/java/io/quarkus/kafka/client/deployment/KafkaProcessor.java
@@ -391,14 +391,14 @@ private void handleAvro(BuildProducer<ReflectiveClassBuildItem> reflectiveClass,
         if (QuarkusClassLoader.isClassPresentAtRuntime("io.apicurio.registry.serde.avro.AvroKafkaDeserializer")
                 && !capabilities.isPresent(Capability.APICURIO_REGISTRY_AVRO)) {
             throw new RuntimeException(
-                    "Apicurio Registry 2.x Avro classes detected, please use the quarkus-apicurio-registry-avro extension");
+                    "Apicurio Registry 3.x Avro classes detected, please use the quarkus-apicurio-registry-avro extension");
         }
 
         // --- Apicurio Registry 2.x Json Schema ---
         if (QuarkusClassLoader.isClassPresentAtRuntime("io.apicurio.registry.serde.avro.JsonKafkaDeserializer")
                 && !capabilities.isPresent(Capability.APICURIO_REGISTRY_JSON_SCHEMA)) {
             throw new RuntimeException(
-                    "Apicurio Registry 2.x Json classes detected, please use the quarkus-apicurio-registry-json extension");
+                    "Apicurio Registry 3.x Json classes detected, please use the quarkus-apicurio-registry-json extension");
         }
     }
 
diff --git a/extensions/panache/hibernate-panache-next/runtime/src/main/resources/META-INF/quarkus-extension.yaml b/extensions/panache/hibernate-panache-next/runtime/src/main/resources/META-INF/quarkus-extension.yaml
index c82176e1df5..ad8ed03e01f 100644
--- a/extensions/panache/hibernate-panache-next/runtime/src/main/resources/META-INF/quarkus-extension.yaml
+++ b/extensions/panache/hibernate-panache-next/runtime/src/main/resources/META-INF/quarkus-extension.yaml
@@ -17,3 +17,7 @@ metadata:
   config:
   - "quarkus.datasource."
   - "quarkus.hibernate-orm."
+  codestart:
+    name: "hibernate-orm"
+    languages: ["java"]
+    artifact: "io.quarkus:quarkus-project-core-extension-codestarts"
diff --git a/extensions/reactive-db2-client/deployment/src/main/java/io/quarkus/reactive/db2/client/deployment/ReactiveDB2ClientProcessor.java b/extensions/reactive-db2-client/deployment/src/main/java/io/quarkus/reactive/db2/client/deployment/ReactiveDB2ClientProcessor.java
index 9323e60d2ad..3c07f7c4668 100644
--- a/extensions/reactive-db2-client/deployment/src/main/java/io/quarkus/reactive/db2/client/deployment/ReactiveDB2ClientProcessor.java
+++ b/extensions/reactive-db2-client/deployment/src/main/java/io/quarkus/reactive/db2/client/deployment/ReactiveDB2ClientProcessor.java
@@ -124,7 +124,7 @@ ServiceStartBuildItem build(BuildProducer<FeatureBuildItem> feature,
 
     @BuildStep
     DevServicesDatasourceConfigurationHandlerBuildItem devDbHandler() {
-        return DevServicesDatasourceConfigurationHandlerBuildItem.reactive(DatabaseKind.DB2);
+        return DevServicesDatasourceConfigurationHandlerBuildItem.deferredReactive(DatabaseKind.DB2);
     }
 
     @BuildStep
diff --git a/extensions/reactive-mssql-client/deployment/src/main/java/io/quarkus/reactive/mssql/client/deployment/ReactiveMSSQLClientProcessor.java b/extensions/reactive-mssql-client/deployment/src/main/java/io/quarkus/reactive/mssql/client/deployment/ReactiveMSSQLClientProcessor.java
index 9a00d3e328b..5d507153019 100644
--- a/extensions/reactive-mssql-client/deployment/src/main/java/io/quarkus/reactive/mssql/client/deployment/ReactiveMSSQLClientProcessor.java
+++ b/extensions/reactive-mssql-client/deployment/src/main/java/io/quarkus/reactive/mssql/client/deployment/ReactiveMSSQLClientProcessor.java
@@ -124,7 +124,7 @@ ServiceStartBuildItem build(BuildProducer<FeatureBuildItem> feature,
 
     @BuildStep
     DevServicesDatasourceConfigurationHandlerBuildItem devDbHandler() {
-        return DevServicesDatasourceConfigurationHandlerBuildItem.reactive(DatabaseKind.MSSQL);
+        return DevServicesDatasourceConfigurationHandlerBuildItem.deferredReactive(DatabaseKind.MSSQL);
     }
 
     @BuildStep
@@ -253,16 +253,12 @@ private static boolean isReactiveMSSQLPoolDefined(DataSourcesBuildTimeConfig dat
                 !DataSourceUtil.isDefault(dataSourceName) || dataSourceBuildTimeConfig.devservices().enabled()
                         .orElse(!dataSourcesBuildTimeConfig.hasNamedDataSources()),
                 curateOutcomeBuildItem);
-        if (!dbKind.isPresent()) {
+        if (dbKind.isEmpty()) {
             return false;
         }
 
-        if (!DatabaseKind.isMsSQL(dbKind.get())
-                || !dataSourceReactiveBuildTimeConfig.enabled()) {
-            return false;
-        }
-
-        return true;
+        return DatabaseKind.isMsSQL(dbKind.get())
+                && dataSourceReactiveBuildTimeConfig.enabled();
     }
 
     private boolean hasPools(DataSourcesBuildTimeConfig dataSourcesBuildTimeConfig,
diff --git a/extensions/reactive-oracle-client/deployment/src/main/java/io/quarkus/reactive/oracle/client/deployment/ReactiveOracleClientProcessor.java b/extensions/reactive-oracle-client/deployment/src/main/java/io/quarkus/reactive/oracle/client/deployment/ReactiveOracleClientProcessor.java
index e52c279037f..eac4ace5e7d 100644
--- a/extensions/reactive-oracle-client/deployment/src/main/java/io/quarkus/reactive/oracle/client/deployment/ReactiveOracleClientProcessor.java
+++ b/extensions/reactive-oracle-client/deployment/src/main/java/io/quarkus/reactive/oracle/client/deployment/ReactiveOracleClientProcessor.java
@@ -124,7 +124,7 @@ ServiceStartBuildItem build(BuildProducer<FeatureBuildItem> feature,
 
     @BuildStep
     DevServicesDatasourceConfigurationHandlerBuildItem devDbHandler() {
-        return DevServicesDatasourceConfigurationHandlerBuildItem.reactive(DatabaseKind.ORACLE);
+        return DevServicesDatasourceConfigurationHandlerBuildItem.deferredReactive(DatabaseKind.ORACLE);
     }
 
     @BuildStep
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ReactiveTransactionalValueCommands.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ReactiveTransactionalValueCommands.java
index b6b1c20cc77..a406bc1264f 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ReactiveTransactionalValueCommands.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ReactiveTransactionalValueCommands.java
@@ -251,6 +251,36 @@
      */
     Uni<Void> set(K key, V value, SetArgs setArgs);
 
+    /**
+     * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * Returns whether the key was set. If you need to know the previous value
+     * of the key, use {@link #setGet(Object, Object) setGet()}.
+     * Summary: Set the string value of a key
+     * Group: string
+     * Requires Redis 1.0.0
+     *
+     * @param key the key
+     * @param value the value
+     * @return A {@code Uni} emitting {@code null} when the command has been enqueued successfully in the transaction, a failure
+     *         otherwise. In the case of failure, the transaction is discarded.
+     **/
+    Uni<Void> setAndChanged(K key, V value);
+
+    /**
+     * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * Returns whether the key was set. If you need to know the previous value
+     * of the key, use {@link #setGet(Object, Object, SetArgs) setGet()}.
+     * Summary: Set the string value of a key
+     * Group: string
+     * Requires Redis 1.0.0
+     *
+     * @param key the key
+     * @param value the value
+     * @return A {@code Uni} emitting {@code null} when the command has been enqueued successfully in the transaction, a failure
+     *         otherwise. In the case of failure, the transaction is discarded.
+     **/
+    Uni<Void> setAndChanged(K key, V value, SetArgs setArgs);
+
     /**
      * Execute the command <a href="https://redis.io/commands/set">SET</a>.
      * Summary: Set the string value of a key, and return the previous value
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ReactiveValueCommands.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ReactiveValueCommands.java
index e9ddc167549..88bfa279033 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ReactiveValueCommands.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ReactiveValueCommands.java
@@ -249,6 +249,34 @@
      **/
     Uni<Void> set(K key, V value, SetArgs setArgs);
 
+    /**
+     * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * Returns whether the key was set. If you need to know the previous value
+     * of the key, use {@link #setGet(Object, Object) setGet()}.
+     * Summary: Set the string value of a key
+     * Group: string
+     * Requires Redis 1.0.0
+     *
+     * @param key the key
+     * @param value the value
+     * @return {@code true} the key was set {@code false} the key was not set
+     **/
+    Uni<Boolean> setAndChanged(K key, V value);
+
+    /**
+     * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * Returns whether the key was set. If you need to know the previous value
+     * of the key, use {@link #setGet(Object, Object, SetArgs) setGet()}.
+     * Summary: Set the string value of a key
+     * Group: string
+     * Requires Redis 1.0.0
+     *
+     * @param key the key
+     * @param value the value
+     * @return {@code true} the key was set {@code false} the key was not set
+     **/
+    Uni<Boolean> setAndChanged(K key, V value, SetArgs setArgs);
+
     /**
      * Execute the command <a href="https://redis.io/commands/set">SET</a>.
      * Summary: Set the string value of a key, and return the previous value
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/TransactionalValueCommands.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/TransactionalValueCommands.java
index 5f049513019..28236de720c 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/TransactionalValueCommands.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/TransactionalValueCommands.java
@@ -212,6 +212,33 @@
      */
     void set(K key, V value, SetArgs setArgs);
 
+    /**
+     * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * Returns whether the key was set. If you need to know the previous value
+     * of the key, use {@link #setGet(Object, Object) setGet()}.
+     * Summary: Set the string value of a key
+     * Group: string
+     * Requires Redis 1.0.0
+     *
+     * @param key the key
+     * @param value the value
+     **/
+    void setAndChanged(K key, V value);
+
+    /**
+     * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * Returns whether the key was set. If you need to know the previous value
+     * of the key, use {@link #setGet(Object, Object, SetArgs) setGet()}.
+     * Summary: Set the string value of a key
+     * Group: string
+     * Requires Redis 1.0.0
+     *
+     * @param key the key
+     * @param value the value
+     * @param setArgs the set command extra-arguments
+     **/
+    void setAndChanged(K key, V value, SetArgs setArgs);
+
     /**
      * Execute the command <a href="https://redis.io/commands/set">SET</a>.
      * Summary: Set the string value of a key, and return the previous value
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ValueCommands.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ValueCommands.java
index 19d96700cfa..27f2b2c0280 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ValueCommands.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/datasource/value/ValueCommands.java
@@ -223,6 +223,8 @@
 
     /**
      * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * If you need to know whether the key was set, use {@link #setAndChanged(Object, Object) setAndChanged()}.
+     * If you need to know the previous value of the key, use {@link #setGet(Object, Object, SetArgs) setGet()}.
      * Summary: Set the string value of a key
      * Group: string
      * Requires Redis 1.0.0
@@ -234,6 +236,8 @@
 
     /**
      * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * If you need to know whether the key was set, use {@link #setAndChanged(Object, Object, SetArgs) setAndChanged()}.
+     * If you need to know the previous value of the key, use {@link #setGet(Object, Object, SetArgs) setGet()}.
      * Summary: Set the string value of a key
      * Group: string
      * Requires Redis 1.0.0
@@ -246,6 +250,35 @@
 
     /**
      * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * Returns whether the key was set. If you need to know the previous value
+     * of the key, use {@link #setGet(Object, Object) setGet()}.
+     * Summary: Set the string value of a key
+     * Group: string
+     * Requires Redis 1.0.0
+     *
+     * @param key the key
+     * @param value the value
+     * @return {@code true} the key was set {@code false} the key was not set
+     **/
+    boolean setAndChanged(K key, V value);
+
+    /**
+     * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * Returns whether the key was set. If you need to know the previous value
+     * of the key, use {@link #setGet(Object, Object, SetArgs) setGet()}.
+     * Summary: Set the string value of a key
+     * Group: string
+     * Requires Redis 1.0.0
+     *
+     * @param key the key
+     * @param value the value
+     * @param setArgs the set command extra-arguments
+     * @return {@code true} the key was set {@code false} the key was not set
+     **/
+    boolean setAndChanged(K key, V value, SetArgs setArgs);
+
+    /**
+     * Execute the command <a href="https://redis.io/commands/set">SET</a> with the {@code GET} argument.
      * Summary: Set the string value of a key, and return the previous value
      * Group: string
      * Requires Redis 1.0.0
@@ -257,7 +290,7 @@
     V setGet(K key, V value);
 
     /**
-     * Execute the command <a href="https://redis.io/commands/set">SET</a>.
+     * Execute the command <a href="https://redis.io/commands/set">SET</a> with the {@code GET} argument.
      * Summary: Set the string value of a key, and return the previous value
      * Group: string
      * Requires Redis 1.0.0
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/AbstractStringCommands.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/AbstractStringCommands.java
index be4ca05428d..d41566b715f 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/AbstractStringCommands.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/AbstractStringCommands.java
@@ -9,8 +9,6 @@
 import java.lang.reflect.Type;
 import java.util.Map;
 
-import io.quarkus.redis.datasource.string.GetExArgs;
-import io.quarkus.redis.datasource.string.SetArgs;
 import io.smallrye.mutiny.Uni;
 import io.vertx.mutiny.redis.client.Command;
 import io.vertx.mutiny.redis.client.Response;
@@ -33,7 +31,7 @@ Uni<Response> _set(K key, V value) {
         return execute(cmd);
     }
 
-    Uni<Response> _set(K key, V value, SetArgs setArgs) {
+    Uni<Response> _set(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         nonNull(key, "key");
         nonNull(value, "value");
         nonNull(setArgs, "setArgs");
@@ -61,7 +59,7 @@ Uni<Response> _setGet(K key, V value) {
         RedisCommand cmd = RedisCommand.of(Command.SET);
         cmd.put(marshaller.encode(key));
         cmd.put(marshaller.encode(value));
-        cmd.putArgs(new SetArgs().get());
+        cmd.putArgs(new io.quarkus.redis.datasource.string.SetArgs().get());
         return execute(cmd);
     }
 
@@ -69,7 +67,7 @@ V decodeV(Response r) {
         return marshaller.decode(typeOfValue, r);
     }
 
-    Uni<Response> _setGet(K key, V value, SetArgs setArgs) {
+    Uni<Response> _setGet(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         nonNull(key, "key");
         nonNull(value, "value");
         nonNull(setArgs, "setArgs");
@@ -160,7 +158,7 @@ Uni<Response> _getdel(K key) {
                 .put(marshaller.encode(key)));
     }
 
-    Uni<Response> _getex(K key, GetExArgs args) {
+    Uni<Response> _getex(K key, io.quarkus.redis.datasource.string.GetExArgs args) {
         nonNull(key, "key");
         nonNull(args, "args");
         RedisCommand cmd = RedisCommand.of(Command.GETEX);
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/BlockingStringCommandsImpl.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/BlockingStringCommandsImpl.java
index 44ea8cf91f6..70238eab7d9 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/BlockingStringCommandsImpl.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/BlockingStringCommandsImpl.java
@@ -4,8 +4,6 @@
 import java.util.Map;
 
 import io.quarkus.redis.datasource.RedisDataSource;
-import io.quarkus.redis.datasource.string.GetExArgs;
-import io.quarkus.redis.datasource.string.SetArgs;
 import io.quarkus.redis.datasource.string.StringCommands;
 import io.quarkus.redis.datasource.value.ReactiveValueCommands;
 import io.quarkus.redis.datasource.value.ValueCommands;
@@ -47,7 +45,7 @@ public V getdel(K key) {
     }
 
     @Override
-    public V getex(K key, GetExArgs args) {
+    public V getex(K key, io.quarkus.redis.datasource.string.GetExArgs args) {
         return reactive.getex(key, args)
                 .await().atMost(timeout);
     }
@@ -122,7 +120,7 @@ public void set(K key, V value) {
     }
 
     @Override
-    public void set(K key, V value, SetArgs setArgs) {
+    public void set(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         reactive.set(key, value, setArgs)
                 .await().atMost(timeout);
     }
@@ -133,6 +131,18 @@ public void set(K key, V value, io.quarkus.redis.datasource.value.SetArgs setArg
                 .await().atMost(timeout);
     }
 
+    @Override
+    public boolean setAndChanged(K key, V value) {
+        return reactive.setAndChanged(key, value)
+                .await().atMost(timeout);
+    }
+
+    @Override
+    public boolean setAndChanged(K key, V value, io.quarkus.redis.datasource.value.SetArgs setArgs) {
+        return reactive.setAndChanged(key, value, setArgs)
+                .await().atMost(timeout);
+    }
+
     @Override
     public V setGet(K key, V value) {
         return reactive.setGet(key, value)
@@ -140,7 +150,7 @@ public V setGet(K key, V value) {
     }
 
     @Override
-    public V setGet(K key, V value, SetArgs setArgs) {
+    public V setGet(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         return reactive.setGet(key, value, setArgs)
                 .await().atMost(timeout);
     }
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/BlockingTransactionalStringCommandsImpl.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/BlockingTransactionalStringCommandsImpl.java
index 4fe60f9a537..d6cf08abc30 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/BlockingTransactionalStringCommandsImpl.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/BlockingTransactionalStringCommandsImpl.java
@@ -3,8 +3,6 @@
 import java.time.Duration;
 import java.util.Map;
 
-import io.quarkus.redis.datasource.string.GetExArgs;
-import io.quarkus.redis.datasource.string.SetArgs;
 import io.quarkus.redis.datasource.string.TransactionalStringCommands;
 import io.quarkus.redis.datasource.transactions.TransactionalRedisDataSource;
 import io.quarkus.redis.datasource.value.ReactiveTransactionalValueCommands;
@@ -47,7 +45,7 @@ public void getdel(K key) {
     }
 
     @Override
-    public void getex(K key, GetExArgs args) {
+    public void getex(K key, io.quarkus.redis.datasource.string.GetExArgs args) {
         this.reactive.getex(key, args).await().atMost(this.timeout);
     }
 
@@ -117,7 +115,7 @@ public void set(K key, V value) {
     }
 
     @Override
-    public void set(K key, V value, SetArgs setArgs) {
+    public void set(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         this.reactive.set(key, value, setArgs).await().atMost(this.timeout);
     }
 
@@ -126,13 +124,23 @@ public void set(K key, V value, io.quarkus.redis.datasource.value.SetArgs setArg
         this.reactive.set(key, value, setArgs).await().atMost(this.timeout);
     }
 
+    @Override
+    public void setAndChanged(K key, V value) {
+        this.reactive.setAndChanged(key, value).await().atMost(this.timeout);
+    }
+
+    @Override
+    public void setAndChanged(K key, V value, io.quarkus.redis.datasource.value.SetArgs setArgs) {
+        this.reactive.setAndChanged(key, value, setArgs).await().atMost(this.timeout);
+    }
+
     @Override
     public void setGet(K key, V value) {
         this.reactive.setGet(key, value).await().atMost(this.timeout);
     }
 
     @Override
-    public void setGet(K key, V value, SetArgs setArgs) {
+    public void setGet(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         this.reactive.setGet(key, value, setArgs).await().atMost(this.timeout);
     }
 
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/ReactiveStringCommandsImpl.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/ReactiveStringCommandsImpl.java
index 3e96e4c0e29..64ac5e62dc9 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/ReactiveStringCommandsImpl.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/ReactiveStringCommandsImpl.java
@@ -2,11 +2,10 @@
 
 import java.lang.reflect.Type;
 import java.util.Map;
+import java.util.Objects;
 
 import io.quarkus.redis.datasource.ReactiveRedisDataSource;
-import io.quarkus.redis.datasource.string.GetExArgs;
 import io.quarkus.redis.datasource.string.ReactiveStringCommands;
-import io.quarkus.redis.datasource.string.SetArgs;
 import io.quarkus.redis.datasource.value.ReactiveValueCommands;
 import io.smallrye.mutiny.Uni;
 import io.vertx.mutiny.redis.client.Response;
@@ -33,7 +32,7 @@ public Uni<Void> set(K key, V value) {
     }
 
     @Override
-    public Uni<Void> set(K key, V value, SetArgs setArgs) {
+    public Uni<Void> set(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         return super._set(key, value, setArgs)
                 .replaceWithVoid();
     }
@@ -44,6 +43,18 @@ public Uni<Void> set(K key, V value, io.quarkus.redis.datasource.value.SetArgs s
                 .replaceWithVoid();
     }
 
+    @Override
+    public Uni<Boolean> setAndChanged(K key, V value) {
+        return super._set(key, value)
+                .map(Objects::nonNull);
+    }
+
+    @Override
+    public Uni<Boolean> setAndChanged(K key, V value, io.quarkus.redis.datasource.value.SetArgs setArgs) {
+        return super._set(key, value, setArgs)
+                .map(Objects::nonNull);
+    }
+
     @Override
     public Uni<V> setGet(K key, V value) {
         return super._setGet(key, value)
@@ -51,7 +62,7 @@ public Uni<V> setGet(K key, V value) {
     }
 
     @Override
-    public Uni<V> setGet(K key, V value, SetArgs setArgs) {
+    public Uni<V> setGet(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         return super._setGet(key, value, setArgs)
                 .map(this::decodeV);
     }
@@ -117,7 +128,7 @@ public Uni<V> getdel(K key) {
     }
 
     @Override
-    public Uni<V> getex(K key, GetExArgs args) {
+    public Uni<V> getex(K key, io.quarkus.redis.datasource.string.GetExArgs args) {
         return super._getex(key, args)
                 .map(this::decodeV);
     }
diff --git a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/ReactiveTransactionalStringCommandsImpl.java b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/ReactiveTransactionalStringCommandsImpl.java
index 7f5f3221d62..39cb3b43103 100644
--- a/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/ReactiveTransactionalStringCommandsImpl.java
+++ b/extensions/redis-client/runtime/src/main/java/io/quarkus/redis/runtime/datasource/ReactiveTransactionalStringCommandsImpl.java
@@ -1,10 +1,9 @@
 package io.quarkus.redis.runtime.datasource;
 
 import java.util.Map;
+import java.util.Objects;
 
-import io.quarkus.redis.datasource.string.GetExArgs;
 import io.quarkus.redis.datasource.string.ReactiveTransactionalStringCommands;
-import io.quarkus.redis.datasource.string.SetArgs;
 import io.quarkus.redis.datasource.transactions.ReactiveTransactionalRedisDataSource;
 import io.quarkus.redis.datasource.value.ReactiveTransactionalValueCommands;
 import io.smallrye.mutiny.Uni;
@@ -52,7 +51,7 @@ public Uni<Void> getdel(K key) {
     }
 
     @Override
-    public Uni<Void> getex(K key, GetExArgs args) {
+    public Uni<Void> getex(K key, io.quarkus.redis.datasource.string.GetExArgs args) {
         this.tx.enqueue(this.reactive::decodeV);
         return this.reactive._getex(key, args).invoke(this::queuedOrDiscard).replaceWithVoid();
     }
@@ -136,7 +135,7 @@ public Uni<Void> set(K key, V value) {
     }
 
     @Override
-    public Uni<Void> set(K key, V value, SetArgs setArgs) {
+    public Uni<Void> set(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         this.tx.enqueue(resp -> null);
         return this.reactive._set(key, value, setArgs).invoke(this::queuedOrDiscard).replaceWithVoid();
     }
@@ -147,6 +146,18 @@ public Uni<Void> set(K key, V value, io.quarkus.redis.datasource.value.SetArgs s
         return this.reactive._set(key, value, setArgs).invoke(this::queuedOrDiscard).replaceWithVoid();
     }
 
+    @Override
+    public Uni<Void> setAndChanged(K key, V value) {
+        this.tx.enqueue(Objects::nonNull);
+        return this.reactive._set(key, value).invoke(this::queuedOrDiscard).replaceWithVoid();
+    }
+
+    @Override
+    public Uni<Void> setAndChanged(K key, V value, io.quarkus.redis.datasource.value.SetArgs setArgs) {
+        this.tx.enqueue(Objects::nonNull);
+        return this.reactive._set(key, value, setArgs).invoke(this::queuedOrDiscard).replaceWithVoid();
+    }
+
     @Override
     public Uni<Void> setGet(K key, V value) {
         this.tx.enqueue(this.reactive::decodeV);
@@ -154,7 +165,7 @@ public Uni<Void> setGet(K key, V value) {
     }
 
     @Override
-    public Uni<Void> setGet(K key, V value, SetArgs setArgs) {
+    public Uni<Void> setGet(K key, V value, io.quarkus.redis.datasource.string.SetArgs setArgs) {
         this.tx.enqueue(this.reactive::decodeV);
         return this.reactive._setGet(key, value, setArgs).invoke(this::queuedOrDiscard).replaceWithVoid();
     }
diff --git a/extensions/redis-client/runtime/src/test/java/io/quarkus/redis/datasource/ValueCommandsTest.java b/extensions/redis-client/runtime/src/test/java/io/quarkus/redis/datasource/ValueCommandsTest.java
index d8b97cc798a..20c6b40a5f9 100644
--- a/extensions/redis-client/runtime/src/test/java/io/quarkus/redis/datasource/ValueCommandsTest.java
+++ b/extensions/redis-client/runtime/src/test/java/io/quarkus/redis/datasource/ValueCommandsTest.java
@@ -213,6 +213,28 @@ void setNegativePX() {
         assertThatThrownBy(() -> values.set(key, value, new SetArgs().px(-1000))).isInstanceOf(IllegalArgumentException.class);
     }
 
+    @Test
+    @RequiresRedis7OrHigher
+    void setAndChanged() {
+        assertThat(values.setAndChanged(key, value)).isTrue();
+        assertThat(values.setAndChanged(key, "value2")).isTrue();
+        assertThat(values.get(key)).isEqualTo("value2");
+    }
+
+    @Test
+    @RequiresRedis7OrHigher
+    void setAndChangedWithArgs() {
+        KeyCommands<String> keys = ds.key(String.class);
+
+        assertThat(values.setAndChanged(key, value)).isTrue();
+        assertThat(values.setAndChanged(key, "value2", new SetArgs().nx())).isFalse();
+        assertThat(values.get(key)).isEqualTo(value);
+        assertThat(keys.del(key)).isEqualTo(1);
+
+        assertThat(values.setAndChanged(key, value, new SetArgs().xx())).isFalse();
+        assertThat(values.get(key)).isNull();
+    }
+
     @Test
     @RequiresRedis7OrHigher
     void setGet() {
diff --git a/extensions/schema-registry/apicurio/avro/deployment/src/main/java/io/quarkus/apicurio/registry/avro/ApicurioRegistryAvroProcessor.java b/extensions/schema-registry/apicurio/avro/deployment/src/main/java/io/quarkus/apicurio/registry/avro/ApicurioRegistryAvroProcessor.java
index 1a5bb9aba25..cc866380754 100644
--- a/extensions/schema-registry/apicurio/avro/deployment/src/main/java/io/quarkus/apicurio/registry/avro/ApicurioRegistryAvroProcessor.java
+++ b/extensions/schema-registry/apicurio/avro/deployment/src/main/java/io/quarkus/apicurio/registry/avro/ApicurioRegistryAvroProcessor.java
@@ -1,6 +1,5 @@
 package io.quarkus.apicurio.registry.avro;
 
-import io.quarkus.bootstrap.classloading.QuarkusClassLoader;
 import io.quarkus.deployment.Feature;
 import io.quarkus.deployment.annotations.BuildProducer;
 import io.quarkus.deployment.annotations.BuildStep;
@@ -15,8 +14,7 @@ FeatureBuildItem feature() {
     }
 
     @BuildStep
-    public void apicurioRegistryAvro(BuildProducer<ReflectiveClassBuildItem> reflectiveClass,
-            BuildProducer<ExtensionSslNativeSupportBuildItem> sslNativeSupport) {
+    public void apicurioRegistryAvro(BuildProducer<ReflectiveClassBuildItem> reflectiveClass) {
 
         reflectiveClass.produce(ReflectiveClassBuildItem.builder("io.apicurio.registry.serde.avro.AvroKafkaDeserializer",
                 "io.apicurio.registry.serde.avro.AvroKafkaSerializer").methods().build());
@@ -25,22 +23,18 @@ public void apicurioRegistryAvro(BuildProducer<ReflectiveClassBuildItem> reflect
                 "io.apicurio.registry.serde.strategy.TopicIdStrategy",
                 "io.apicurio.registry.serde.avro.DefaultAvroDatumProvider",
                 "io.apicurio.registry.serde.avro.ReflectAvroDatumProvider",
+                "io.apicurio.registry.serde.avro.ReflectAllowNullAvroDatumProvider",
                 "io.apicurio.registry.serde.avro.strategy.RecordIdStrategy",
+                "io.apicurio.registry.serde.avro.strategy.QualifiedRecordIdStrategy",
                 "io.apicurio.registry.serde.avro.strategy.TopicRecordIdStrategy").methods().fields()
                 .build());
 
-        reflectiveClass.produce(ReflectiveClassBuildItem.builder("io.apicurio.registry.serde.DefaultIdHandler",
-                "io.apicurio.registry.serde.Legacy4ByteIdHandler",
+        reflectiveClass.produce(ReflectiveClassBuildItem.builder("io.apicurio.registry.serde.Default4ByteIdHandler",
+                "io.apicurio.registry.serde.Legacy8ByteIdHandler",
+                "io.apicurio.registry.serde.OptimisticFallbackIdHandler",
                 "io.apicurio.registry.serde.fallback.DefaultFallbackArtifactProvider",
-                "io.apicurio.registry.serde.headers.DefaultHeadersHandler").methods().fields()
+                "io.apicurio.registry.serde.kafka.headers.DefaultHeadersHandler").methods().fields()
                 .build());
-
-        String defaultSchemaResolver = "io.apicurio.registry.serde.DefaultSchemaResolver";
-        if (QuarkusClassLoader.isClassPresentAtRuntime(defaultSchemaResolver)) {
-            // Class not present after 2.2.0.Final
-            reflectiveClass.produce(ReflectiveClassBuildItem.builder(defaultSchemaResolver).methods()
-                    .fields().build());
-        }
     }
 
     @BuildStep
diff --git a/extensions/schema-registry/apicurio/avro/runtime/pom.xml b/extensions/schema-registry/apicurio/avro/runtime/pom.xml
index b083c9bf9f6..6cc6e1cfeb7 100644
--- a/extensions/schema-registry/apicurio/avro/runtime/pom.xml
+++ b/extensions/schema-registry/apicurio/avro/runtime/pom.xml
@@ -17,11 +17,11 @@
     <dependencies>
         <dependency>
             <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-registry-serdes-avro-serde</artifactId>
+            <artifactId>apicurio-registry-avro-serde-kafka</artifactId>
             <exclusions>
                 <exclusion>
-                    <groupId>io.apicurio</groupId>
-                    <artifactId>apicurio-common-rest-client-jdk</artifactId>
+                    <groupId>io.kiota</groupId>
+                    <artifactId>kiota-http-jdk</artifactId>
                 </exclusion>
             </exclusions>
         </dependency>
diff --git a/extensions/schema-registry/apicurio/common/deployment/src/main/java/io/quarkus/apicurio/registry/common/ApicurioRegistryClientProcessor.java b/extensions/schema-registry/apicurio/common/deployment/src/main/java/io/quarkus/apicurio/registry/common/ApicurioRegistryClientProcessor.java
index bb74ef643ac..ee6a5671ea4 100644
--- a/extensions/schema-registry/apicurio/common/deployment/src/main/java/io/quarkus/apicurio/registry/common/ApicurioRegistryClientProcessor.java
+++ b/extensions/schema-registry/apicurio/common/deployment/src/main/java/io/quarkus/apicurio/registry/common/ApicurioRegistryClientProcessor.java
@@ -1,45 +1,15 @@
 package io.quarkus.apicurio.registry.common;
 
-import java.io.IOException;
+import java.util.logging.Level;
 
-import io.apicurio.rest.client.spi.ApicurioHttpClientProvider;
 import io.quarkus.deployment.annotations.BuildProducer;
 import io.quarkus.deployment.annotations.BuildStep;
-import io.quarkus.deployment.annotations.ExecutionTime;
-import io.quarkus.deployment.annotations.Record;
-import io.quarkus.deployment.builditem.ExtensionSslNativeSupportBuildItem;
-import io.quarkus.deployment.builditem.LaunchModeBuildItem;
-import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;
-import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;
+import io.quarkus.deployment.builditem.LogCategoryBuildItem;
+import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;
 import io.quarkus.smallrye.openapi.deployment.spi.IgnoreStaticDocumentBuildItem;
-import io.quarkus.vertx.deployment.VertxBuildItem;
 
 public class ApicurioRegistryClientProcessor {
 
-    @BuildStep
-    public void apicurioRegistryClient(BuildProducer<ReflectiveClassBuildItem> reflectiveClass,
-            BuildProducer<ExtensionSslNativeSupportBuildItem> sslNativeSupport) {
-        reflectiveClass
-                .produce(ReflectiveClassBuildItem.builder("io.apicurio.rest.client.auth.exception.NotAuthorizedException",
-                        "io.apicurio.rest.client.auth.exception.ForbiddenException",
-                        "io.apicurio.rest.client.auth.exception.AuthException",
-                        "io.apicurio.rest.client.auth.exception.AuthErrorHandler",
-                        "io.apicurio.rest.client.auth.request.TokenRequestsProvider",
-                        "io.apicurio.rest.client.request.Request",
-                        "io.apicurio.rest.client.auth.AccessTokenResponse",
-                        "io.apicurio.rest.client.auth.Auth",
-                        "io.apicurio.rest.client.auth.BasicAuth",
-                        "io.apicurio.rest.client.auth.OidcAuth").methods().fields().build());
-    }
-
-    @BuildStep
-    void registerSPIClient(BuildProducer<ServiceProviderBuildItem> services) throws IOException {
-
-        services.produce(
-                new ServiceProviderBuildItem(ApicurioHttpClientProvider.class.getName(),
-                        "io.apicurio.rest.client.VertxHttpClientProvider"));
-    }
-
     @BuildStep
     void ignoreIncludedOpenAPIDocument(BuildProducer<IgnoreStaticDocumentBuildItem> ignoreStaticDocumentProducer) {
         // This will ignore the OpenAPI Document in META-INF/openapi.yaml in the apicurio-registry-common dependency
@@ -48,12 +18,21 @@ void ignoreIncludedOpenAPIDocument(BuildProducer<IgnoreStaticDocumentBuildItem>
     }
 
     @BuildStep
-    @Record(ExecutionTime.RUNTIME_INIT)
-    public void apicurioRegistryClient(VertxBuildItem vertx, ApicurioRegistryClient client, LaunchModeBuildItem launchMode) {
-        if (launchMode.getLaunchMode().isDevOrTest()) {
-            client.clearHttpClient();
-        }
-        client.setup(vertx.getVertx());
+    void logging(BuildProducer<LogCategoryBuildItem> log) {
+        // Reduce the log level of Apicurio Registry client to avoid verbose INFO messages
+        // See https://github.com/quarkusio/quarkus/issues/51008
+        log.produce(new LogCategoryBuildItem("io.apicurio.registry.client", Level.WARNING));
+    }
+
+    @BuildStep
+    void runtimeInitializedClasses(BuildProducer<RuntimeInitializedClassBuildItem> runtimeInitializedClass) {
+        // Initialize RegistryClientRequestAdapterFactory at runtime because it contains inner classes
+        // (JdkAuthenticatedRequestAdapter, JdkOAuth2RequestAdapter) that extend JDKRequestAdapter
+        // from kiota-http-jdk, which is excluded from the classpath. Runtime initialization prevents
+        // GraalVM from trying to analyze these classes at build time.
+        runtimeInitializedClass
+                .produce(new RuntimeInitializedClassBuildItem(
+                        "io.apicurio.registry.client.common.RegistryClientRequestAdapterFactory"));
     }
 
 }
diff --git a/extensions/schema-registry/apicurio/common/deployment/src/test/java/io/quarkus/apicurio/registry/common/ApicurioRegistryInternalsExpectationTest.java b/extensions/schema-registry/apicurio/common/deployment/src/test/java/io/quarkus/apicurio/registry/common/ApicurioRegistryInternalsExpectationTest.java
deleted file mode 100644
index ab2da367a32..00000000000
--- a/extensions/schema-registry/apicurio/common/deployment/src/test/java/io/quarkus/apicurio/registry/common/ApicurioRegistryInternalsExpectationTest.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package io.quarkus.apicurio.registry.common;
-
-import org.junit.jupiter.api.Test;
-
-import io.apicurio.rest.client.spi.ApicurioHttpClientFactory;
-
-public class ApicurioRegistryInternalsExpectationTest {
-    @Test
-    public void test() throws NoSuchFieldException {
-        // we need this to reset the client in continuous testing
-        ApicurioHttpClientFactory.class.getDeclaredField("providerReference");
-    }
-}
diff --git a/extensions/schema-registry/apicurio/common/runtime/pom.xml b/extensions/schema-registry/apicurio/common/runtime/pom.xml
index 5e04248f4f5..3b9ffc7f297 100644
--- a/extensions/schema-registry/apicurio/common/runtime/pom.xml
+++ b/extensions/schema-registry/apicurio/common/runtime/pom.xml
@@ -17,18 +17,26 @@
     <dependencies>
         <dependency>
             <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-registry-client</artifactId>
+            <artifactId>apicurio-registry-serde-common</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>io.apicurio</groupId>
+            <artifactId>apicurio-registry-java-sdk</artifactId>
             <exclusions>
                 <exclusion>
-                    <groupId>io.apicurio</groupId>
-                    <artifactId>apicurio-common-rest-client-jdk</artifactId>
+                    <groupId>io.kiota</groupId>
+                    <artifactId>kiota-http-jdk</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>com.microsoft.kiota</groupId>
+                    <artifactId>microsoft-kiota-abstractions</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>io.vertx</groupId>
+                    <artifactId>vertx-core</artifactId>
                 </exclusion>
             </exclusions>
         </dependency>
-        <dependency>
-            <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-common-rest-client-vertx</artifactId>
-        </dependency>
         <dependency>
             <groupId>org.apache.commons</groupId>
             <artifactId>commons-lang3</artifactId>
@@ -47,6 +55,12 @@
             <artifactId>quarkus-vertx</artifactId>
         </dependency>
 
+        <dependency>
+            <groupId>org.graalvm.sdk</groupId>
+            <artifactId>nativeimage</artifactId>
+            <scope>provided</scope>
+        </dependency>
+
         <dependency>
             <groupId>io.quarkus</groupId>
             <artifactId>quarkus-kubernetes-service-binding</artifactId>
diff --git a/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/binding/ServiceRegistryBindingConverter.java b/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/binding/ServiceRegistryBindingConverter.java
index 13914a24db9..14dffd02b9e 100644
--- a/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/binding/ServiceRegistryBindingConverter.java
+++ b/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/binding/ServiceRegistryBindingConverter.java
@@ -53,7 +53,7 @@ public Optional<ServiceBindingConfigSource> convert(List<ServiceBinding> service
                 oauthTokenUrl = binding.getProperties().get("oauthtokenurl");
             }
             if (oauthTokenUrl != null) {
-                properties.put(prefix + "apicurio.auth.service.token.endpoint", oauthTokenUrl);
+                properties.put(prefix + "apicurio.registry.auth.service.token.endpoint", oauthTokenUrl);
             }
 
             String clientId = binding.getProperties().get("clientId");
@@ -61,7 +61,7 @@ public Optional<ServiceBindingConfigSource> convert(List<ServiceBinding> service
                 clientId = binding.getProperties().get("clientid");
             }
             if (clientId != null) {
-                properties.put(prefix + "apicurio.auth.client.id", clientId);
+                properties.put(prefix + "apicurio.registry.auth.client.id", clientId);
             }
 
             String clientSecret = binding.getProperties().get("clientSecret");
@@ -69,7 +69,7 @@ public Optional<ServiceBindingConfigSource> convert(List<ServiceBinding> service
                 clientSecret = binding.getProperties().get("clientsecret");
             }
             if (clientSecret != null) {
-                properties.put(prefix + "apicurio.auth.client.secret", clientSecret);
+                properties.put(prefix + "apicurio.registry.auth.client.secret", clientSecret);
             }
             if (registryUrl != null) {
                 properties.put(prefix + "apicurio.registry.url", registryUrl);
diff --git a/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/common/ApicurioRegistryClient.java b/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/common/ApicurioRegistryClient.java
deleted file mode 100644
index 80a544a6397..00000000000
--- a/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/common/ApicurioRegistryClient.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package io.quarkus.apicurio.registry.common;
-
-import java.lang.reflect.Field;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.jboss.logging.Logger;
-
-import io.apicurio.registry.rest.client.RegistryClientFactory;
-import io.apicurio.rest.client.VertxHttpClientProvider;
-import io.apicurio.rest.client.spi.ApicurioHttpClientFactory;
-import io.quarkus.runtime.RuntimeValue;
-import io.quarkus.runtime.annotations.Recorder;
-import io.vertx.core.Vertx;
-
-@Recorder
-public class ApicurioRegistryClient {
-
-    private static final Logger log = Logger.getLogger(ApicurioRegistryClient.class);
-
-    public void setup(RuntimeValue<Vertx> vertx) {
-        RegistryClientFactory.setProvider(new VertxHttpClientProvider(vertx.getValue()));
-    }
-
-    public void clearHttpClient() {
-        try {
-            Field providerReference = ApicurioHttpClientFactory.class.getDeclaredField("providerReference");
-            providerReference.setAccessible(true);
-            AtomicReference ref = (AtomicReference) providerReference.get(null);
-            ref.set(null);
-        } catch (NoSuchFieldException | IllegalAccessException t) {
-            log.error("Failed to clear Apicurio Http Client provider", t);
-        }
-    }
-}
\ No newline at end of file
diff --git a/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/graal/Substitutions.java b/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/graal/Substitutions.java
new file mode 100644
index 00000000000..89a0d8537c5
--- /dev/null
+++ b/extensions/schema-registry/apicurio/common/runtime/src/main/java/io/quarkus/apicurio/registry/graal/Substitutions.java
@@ -0,0 +1,42 @@
+package io.quarkus.apicurio.registry.graal;
+
+import com.microsoft.kiota.RequestAdapter;
+import com.oracle.svm.core.annotate.Alias;
+import com.oracle.svm.core.annotate.RecomputeFieldValue;
+import com.oracle.svm.core.annotate.Substitute;
+import com.oracle.svm.core.annotate.TargetClass;
+
+import io.apicurio.registry.client.common.RegistryClientOptions;
+import io.quarkus.arc.Arc;
+import io.vertx.core.Vertx;
+
+@TargetClass(className = "io.apicurio.registry.client.common.DefaultVertxInstance$Holder")
+final class Target_io_apicurio_registry_client_DefaultVertxInstance_Holder {
+
+    @Alias
+    @RecomputeFieldValue(kind = RecomputeFieldValue.Kind.FromAlias)
+    private static Vertx INSTANCE = null;
+}
+
+@TargetClass(className = "io.apicurio.registry.client.common.RegistryClientRequestAdapterFactory")
+final class Target_RegistryClientRequestAdapterFactory {
+
+    @Substitute
+    static Vertx getVertxFromCDI(String CDIClassName, String InstanceClassName) {
+        try {
+            return Arc.container().instance(Vertx.class).get();
+        } catch (Throwable t) {
+            // Log and ignore
+            return null;
+        }
+    }
+
+    @Substitute
+    private static RequestAdapter createJdkAdapter(RegistryClientOptions options) {
+        // JDK HTTP adapter is not supported in native mode because kiota-http-jdk is excluded.
+        // Use Vertx adapter instead by setting the adapter type in RegistryClientOptions.
+        throw new UnsupportedOperationException(
+                "JDK HTTP adapter is not available in native mode. Please use the Vertx adapter by setting " +
+                        "the HTTP adapter type to VERTX in your RegistryClientOptions or configuration.");
+    }
+}
diff --git a/extensions/schema-registry/apicurio/json-schema/deployment/src/main/java/io/quarkus/apicurio/registry/jsonschema/ApicurioRegistryJsonSchemaProcessor.java b/extensions/schema-registry/apicurio/json-schema/deployment/src/main/java/io/quarkus/apicurio/registry/jsonschema/ApicurioRegistryJsonSchemaProcessor.java
index 83c6f0886bb..a9795789d55 100644
--- a/extensions/schema-registry/apicurio/json-schema/deployment/src/main/java/io/quarkus/apicurio/registry/jsonschema/ApicurioRegistryJsonSchemaProcessor.java
+++ b/extensions/schema-registry/apicurio/json-schema/deployment/src/main/java/io/quarkus/apicurio/registry/jsonschema/ApicurioRegistryJsonSchemaProcessor.java
@@ -1,6 +1,5 @@
 package io.quarkus.apicurio.registry.jsonschema;
 
-import io.quarkus.bootstrap.classloading.QuarkusClassLoader;
 import io.quarkus.deployment.Feature;
 import io.quarkus.deployment.annotations.BuildProducer;
 import io.quarkus.deployment.annotations.BuildStep;
@@ -15,32 +14,21 @@ FeatureBuildItem feature() {
     }
 
     @BuildStep
-    public void apicurioRegistryJsonSchema(BuildProducer<ReflectiveClassBuildItem> reflectiveClass,
-            BuildProducer<ExtensionSslNativeSupportBuildItem> sslNativeSupport) {
-
+    public void apicurioRegistryJsonSchema(BuildProducer<ReflectiveClassBuildItem> reflectiveClass) {
         reflectiveClass
                 .produce(ReflectiveClassBuildItem.builder("io.apicurio.registry.serde.jsonschema.JsonSchemaKafkaDeserializer",
                         "io.apicurio.registry.serde.jsonschema.JsonSchemaKafkaSerializer").methods().build());
 
         reflectiveClass.produce(ReflectiveClassBuildItem.builder("io.apicurio.registry.serde.strategy.SimpleTopicIdStrategy",
-                "io.apicurio.registry.serde.strategy.TopicIdStrategy",
-                "io.apicurio.registry.serde.strategy.QualifiedRecordIdStrategy",
-                "io.apicurio.registry.serde.strategy.RecordIdStrategy",
-                "io.apicurio.registry.serde.jsonschema.strategy.TopicRecordIdStrategy").methods().fields()
+                "io.apicurio.registry.serde.strategy.TopicIdStrategy").methods().fields()
                 .build());
 
-        reflectiveClass.produce(ReflectiveClassBuildItem.builder("io.apicurio.registry.serde.DefaultIdHandler",
-                "io.apicurio.registry.serde.Legacy4ByteIdHandler",
+        reflectiveClass.produce(ReflectiveClassBuildItem.builder("io.apicurio.registry.serde.Default4ByteIdHandler",
+                "io.apicurio.registry.serde.Legacy8ByteIdHandler",
+                "io.apicurio.registry.serde.OptimisticFallbackIdHandler",
                 "io.apicurio.registry.serde.fallback.DefaultFallbackArtifactProvider",
-                "io.apicurio.registry.serde.headers.DefaultHeadersHandler").methods().fields()
+                "io.apicurio.registry.serde.kafka.headers.DefaultHeadersHandler").methods().fields()
                 .build());
-
-        String defaultSchemaResolver = "io.apicurio.registry.serde.DefaultSchemaResolver";
-        if (QuarkusClassLoader.isClassPresentAtRuntime(defaultSchemaResolver)) {
-            // Class not present after 2.2.0.Final
-            reflectiveClass.produce(ReflectiveClassBuildItem.builder(defaultSchemaResolver).methods()
-                    .fields().build());
-        }
     }
 
     @BuildStep
diff --git a/extensions/schema-registry/apicurio/json-schema/runtime/pom.xml b/extensions/schema-registry/apicurio/json-schema/runtime/pom.xml
index cd42703d38d..7d481068f6e 100644
--- a/extensions/schema-registry/apicurio/json-schema/runtime/pom.xml
+++ b/extensions/schema-registry/apicurio/json-schema/runtime/pom.xml
@@ -17,11 +17,15 @@
     <dependencies>
         <dependency>
             <groupId>io.apicurio</groupId>
-            <artifactId>apicurio-registry-serdes-jsonschema-serde</artifactId>
+            <artifactId>apicurio-registry-jsonschema-serde-kafka</artifactId>
             <exclusions>
                 <exclusion>
-                    <groupId>io.apicurio</groupId>
-                    <artifactId>apicurio-common-rest-client-jdk</artifactId>
+                    <groupId>io.kiota</groupId>
+                    <artifactId>kiota-http-jdk</artifactId>
+                </exclusion>
+                <exclusion>
+                    <groupId>io.vertx</groupId>
+                    <artifactId>vertx-core</artifactId>
                 </exclusion>
             </exclusions>
         </dependency>
diff --git a/extensions/schema-registry/devservice/deployment/src/main/java/io/quarkus/apicurio/registry/devservice/ApicurioRegistryBuildTimeConfig.java b/extensions/schema-registry/devservice/deployment/src/main/java/io/quarkus/apicurio/registry/devservice/ApicurioRegistryBuildTimeConfig.java
index 98507fde782..d6532ca739a 100644
--- a/extensions/schema-registry/devservice/deployment/src/main/java/io/quarkus/apicurio/registry/devservice/ApicurioRegistryBuildTimeConfig.java
+++ b/extensions/schema-registry/devservice/deployment/src/main/java/io/quarkus/apicurio/registry/devservice/ApicurioRegistryBuildTimeConfig.java
@@ -40,8 +40,8 @@ interface ApicurioRegistryDevServicesBuildTimeConfig {
 
         /**
          * The Apicurio Registry image to use.
-         * Note that only Apicurio Registry 2.x images are supported.
-         * Specifically, the image repository must end with {@code apicurio/apicurio-registry-mem}.
+         * Note that only Apicurio Registry 3.x images are supported.
+         * Specifically, the image repository must end with {@code apicurio/apicurio-registry}.
          */
         @ConfigDocDefault(value = "`{apicurio-registry-image}`", escape = false)
         Optional<String> imageName();
diff --git a/extensions/schema-registry/devservice/deployment/src/main/java/io/quarkus/apicurio/registry/devservice/DevServicesApicurioRegistryProcessor.java b/extensions/schema-registry/devservice/deployment/src/main/java/io/quarkus/apicurio/registry/devservice/DevServicesApicurioRegistryProcessor.java
index 2b83d2a270e..ac553b81a42 100644
--- a/extensions/schema-registry/devservice/deployment/src/main/java/io/quarkus/apicurio/registry/devservice/DevServicesApicurioRegistryProcessor.java
+++ b/extensions/schema-registry/devservice/deployment/src/main/java/io/quarkus/apicurio/registry/devservice/DevServicesApicurioRegistryProcessor.java
@@ -7,7 +7,6 @@
 import java.time.Duration;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
 import java.util.Optional;
 
 import org.eclipse.microprofile.config.Config;
@@ -21,17 +20,13 @@
 import io.quarkus.deployment.IsDevServicesSupportedByLaunchMode;
 import io.quarkus.deployment.annotations.BuildStep;
 import io.quarkus.deployment.annotations.BuildSteps;
-import io.quarkus.deployment.builditem.CuratedApplicationShutdownBuildItem;
 import io.quarkus.deployment.builditem.DevServicesComposeProjectBuildItem;
 import io.quarkus.deployment.builditem.DevServicesResultBuildItem;
-import io.quarkus.deployment.builditem.DevServicesResultBuildItem.RunningDevService;
 import io.quarkus.deployment.builditem.DevServicesSharedNetworkBuildItem;
 import io.quarkus.deployment.builditem.DockerStatusBuildItem;
 import io.quarkus.deployment.builditem.LaunchModeBuildItem;
-import io.quarkus.deployment.console.ConsoleInstalledBuildItem;
-import io.quarkus.deployment.console.StartupLogCompressor;
+import io.quarkus.deployment.builditem.Startable;
 import io.quarkus.deployment.dev.devservices.DevServicesConfig;
-import io.quarkus.deployment.logging.LoggingSetupBuildItem;
 import io.quarkus.devservices.common.ComposeLocator;
 import io.quarkus.devservices.common.ConfigureUtil;
 import io.quarkus.devservices.common.ContainerLocator;
@@ -59,97 +54,33 @@ public class DevServicesApicurioRegistryProcessor {
     private static final ContainerLocator apicurioRegistryContainerLocator = locateContainerWithLabels(APICURIO_REGISTRY_PORT,
             DEV_SERVICE_LABEL);
 
-    static volatile RunningDevService devService;
-    static volatile ApicurioRegistryDevServiceCfg cfg;
-    static volatile boolean first = true;
-
     @BuildStep
     public DevServicesResultBuildItem startApicurioRegistryDevService(LaunchModeBuildItem launchMode,
             DockerStatusBuildItem dockerStatusBuildItem,
             DevServicesComposeProjectBuildItem composeProjectBuildItem,
             ApicurioRegistryBuildTimeConfig apicurioRegistryConfiguration,
             List<DevServicesSharedNetworkBuildItem> devServicesSharedNetworkBuildItem,
-            Optional<ConsoleInstalledBuildItem> consoleInstalledBuildItem,
-            CuratedApplicationShutdownBuildItem closeBuildItem,
-            LoggingSetupBuildItem loggingSetupBuildItem, DevServicesConfig devServicesConfig) {
-
-        ApicurioRegistryDevServiceCfg configuration = getConfiguration(apicurioRegistryConfiguration.devservices());
-
-        if (devService != null) {
-            boolean restartRequired = !configuration.equals(cfg);
-            if (!restartRequired) {
-                return devService.toBuildItem();
-            }
-            shutdownApicurioRegistry();
-            cfg = null;
-        }
-        StartupLogCompressor compressor = new StartupLogCompressor(
-                (launchMode.isTest() ? "(test) " : "") + "Apicurio Registry Dev Services Starting:",
-                consoleInstalledBuildItem, loggingSetupBuildItem);
-        try {
-            boolean useSharedNetwork = DevServicesSharedNetworkBuildItem.isSharedNetworkRequired(devServicesConfig,
-                    devServicesSharedNetworkBuildItem);
-            devService = startApicurioRegistry(dockerStatusBuildItem, composeProjectBuildItem, configuration, launchMode,
-                    useSharedNetwork, devServicesConfig.timeout());
-            compressor.close();
-        } catch (Throwable t) {
-            compressor.closeAndDumpCaptured();
-            throw new RuntimeException(t);
-        }
-
-        if (devService == null) {
-            return null;
-        }
-
-        cfg = configuration;
-
-        if (devService.isOwner()) {
-            log.infof("Dev Services for Apicurio Registry started. The registry is available at %s",
-                    devService.getConfig().get(APICURIO_REGISTRY_URL_CONFIG));
-        }
-
-        // Configure the watch dog
-        if (first) {
-            first = false;
-            Runnable closeTask = new Runnable() {
-                @Override
-                public void run() {
-                    if (devService != null) {
-                        shutdownApicurioRegistry();
-                    }
-                    first = true;
-                    devService = null;
-                    cfg = null;
-                }
-            };
-            closeBuildItem.addCloseTask(closeTask, true);
-        }
-        return devService.toBuildItem();
+            DevServicesConfig devServicesConfig) {
+        ApicurioRegistryDevServicesBuildTimeConfig cfg = apicurioRegistryConfiguration.devservices();
+        boolean useSharedNetwork = DevServicesSharedNetworkBuildItem.isSharedNetworkRequired(devServicesConfig,
+                devServicesSharedNetworkBuildItem);
+        return prepareApicurioRegistry(dockerStatusBuildItem, composeProjectBuildItem, cfg, launchMode,
+                useSharedNetwork, devServicesConfig.timeout());
     }
 
     private Map<String, String> getRegistryUrlConfigs(String baseUrl) {
         return Map.of(
-                APICURIO_REGISTRY_URL_CONFIG, baseUrl + "/apis/registry/v2",
-                CONFLUENT_SCHEMA_REGISTRY_URL_CONFIG, baseUrl + "/apis/ccompat/v6");
+                APICURIO_REGISTRY_URL_CONFIG, baseUrl + "/apis/registry/v3",
+                CONFLUENT_SCHEMA_REGISTRY_URL_CONFIG, baseUrl + "/apis/ccompat/v7");
     }
 
-    private void shutdownApicurioRegistry() {
-        if (devService != null) {
-            try {
-                devService.close();
-            } catch (Throwable e) {
-                log.error("Failed to stop Apicurio Registry", e);
-            } finally {
-                devService = null;
-            }
-        }
-    }
-
-    private RunningDevService startApicurioRegistry(DockerStatusBuildItem dockerStatusBuildItem,
+    private DevServicesResultBuildItem prepareApicurioRegistry(DockerStatusBuildItem dockerStatusBuildItem,
             DevServicesComposeProjectBuildItem composeProjectBuildItem,
-            ApicurioRegistryDevServiceCfg config, LaunchModeBuildItem launchMode,
-            boolean useSharedNetwork, Optional<Duration> timeout) {
-        if (!config.devServicesEnabled) {
+            ApicurioRegistryDevServicesBuildTimeConfig config,
+            LaunchModeBuildItem launchMode,
+            boolean useSharedNetwork,
+            Optional<Duration> timeout) {
+        if (!config.enabled().orElse(true)) {
             // explicitly disabled
             log.debug("Not starting dev services for Apicurio Registry, as it has been disabled in the config.");
             return null;
@@ -176,29 +107,36 @@ private RunningDevService startApicurioRegistry(DockerStatusBuildItem dockerStat
             return null;
         }
 
-        // Starting the broker
-        return apicurioRegistryContainerLocator.locateContainer(config.serviceName, config.shared, launchMode.getLaunchMode())
+        return apicurioRegistryContainerLocator
+                .locateContainer(config.serviceName(), config.shared(), launchMode.getLaunchMode())
                 .or(() -> ComposeLocator.locateContainer(composeProjectBuildItem,
-                        List.of(config.imageName, "apicurio"),
+                        List.of(config.imageName().orElseGet(() -> getDefaultImageNameFor("apicurio-registry")), "apicurio"),
                         APICURIO_REGISTRY_PORT, launchMode.getLaunchMode(), useSharedNetwork))
-                .map(address -> new RunningDevService(Feature.APICURIO_REGISTRY_AVRO.getName(),
-                        address.getId(), null,
+                .map(address -> DevServicesResultBuildItem.discovered()
+                        .feature(Feature.APICURIO_REGISTRY_AVRO)
+                        .containerId(address.getId())
                         // address does not have the URL Scheme - just the host:port, so prepend http://
-                        getRegistryUrlConfigs("http://" + address.getUrl())))
-                .orElseGet(() -> {
-                    ApicurioRegistryContainer container = new ApicurioRegistryContainer(
-                            DockerImageName.parse(config.imageName).asCompatibleSubstituteFor("apicurio/apicurio-registry-mem"),
-                            config.fixedExposedPort,
-                            launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT ? config.serviceName : null,
-                            composeProjectBuildItem.getDefaultNetworkId(),
-                            useSharedNetwork);
-                    timeout.ifPresent(container::withStartupTimeout);
-                    container.withEnv(config.containerEnv);
-                    container.start();
-
-                    return new RunningDevService(Feature.APICURIO_REGISTRY_AVRO.getName(), container.getContainerId(),
-                            container::close, getRegistryUrlConfigs(container.getUrl()));
-                });
+                        .config(getRegistryUrlConfigs("http://" + address.getUrl()))
+                        .build())
+                .orElseGet(() -> DevServicesResultBuildItem.owned()
+                        .feature(Feature.APICURIO_REGISTRY_AVRO)
+                        .startable(() -> new ApicurioRegistryContainer(
+                                DockerImageName
+                                        .parse(config.imageName().orElseGet(() -> getDefaultImageNameFor("apicurio-registry")))
+                                        .asCompatibleSubstituteFor("apicurio/apicurio-registry-mem"),
+                                config.port().orElse(0),
+                                launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT ? config.serviceName() : null,
+                                composeProjectBuildItem.getDefaultNetworkId(),
+                                useSharedNetwork,
+                                config.containerEnv(),
+                                timeout))
+                        .configProvider(Map.of(
+                                APICURIO_REGISTRY_URL_CONFIG, ApicurioRegistryContainer::getApicurioRegistryUrl,
+                                CONFLUENT_SCHEMA_REGISTRY_URL_CONFIG, ApicurioRegistryContainer::getConfluentRegistryUrl))
+                        .postStartHook(
+                                s -> log.infof("Dev Services for Apicurio Registry started. The registry is available at %s",
+                                        s.getApicurioRegistryUrl()))
+                        .build());
     }
 
     private boolean hasKafkaChannelWithoutRegistry() {
@@ -221,59 +159,21 @@ private boolean hasKafkaChannelWithoutRegistry() {
         return false;
     }
 
-    private ApicurioRegistryDevServiceCfg getConfiguration(ApicurioRegistryDevServicesBuildTimeConfig cfg) {
-        return new ApicurioRegistryDevServiceCfg(cfg);
-    }
-
-    private static final class ApicurioRegistryDevServiceCfg {
-        private final boolean devServicesEnabled;
-        private final String imageName;
-        private final Integer fixedExposedPort;
-        private final boolean shared;
-        private final String serviceName;
-        private final Map<String, String> containerEnv;
-
-        public ApicurioRegistryDevServiceCfg(ApicurioRegistryDevServicesBuildTimeConfig config) {
-            this.devServicesEnabled = config.enabled().orElse(true);
-            this.imageName = config.imageName().orElseGet(() -> getDefaultImageNameFor("apicurio-registry"));
-            this.fixedExposedPort = config.port().orElse(0);
-            this.shared = config.shared();
-            this.serviceName = config.serviceName();
-            this.containerEnv = config.containerEnv();
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-            ApicurioRegistryDevServiceCfg that = (ApicurioRegistryDevServiceCfg) o;
-            return devServicesEnabled == that.devServicesEnabled
-                    && Objects.equals(imageName, that.imageName)
-                    && Objects.equals(fixedExposedPort, that.fixedExposedPort)
-                    && shared == that.shared
-                    && Objects.equals(serviceName, that.serviceName)
-                    && Objects.equals(containerEnv, that.containerEnv);
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(devServicesEnabled, imageName, fixedExposedPort, shared, serviceName, containerEnv);
-        }
-    }
-
-    private static final class ApicurioRegistryContainer extends GenericContainer<ApicurioRegistryContainer> {
+    private static final class ApicurioRegistryContainer extends GenericContainer<ApicurioRegistryContainer>
+            implements Startable {
         private final int fixedExposedPort;
         private final boolean useSharedNetwork;
 
         private final String hostName;
 
+        private final boolean legacyImage;
+
         private ApicurioRegistryContainer(DockerImageName dockerImageName, int fixedExposedPort, String serviceName,
-                String defaultNetworkId, boolean useSharedNetwork) {
+                String defaultNetworkId, boolean useSharedNetwork,
+                Map<String, String> containerEnv,
+                Optional<Duration> timeout) {
             super(dockerImageName);
+            this.legacyImage = dockerImageName.getVersionPart().startsWith("2.");
             this.fixedExposedPort = fixedExposedPort;
             this.useSharedNetwork = useSharedNetwork;
 
@@ -282,10 +182,12 @@ private ApicurioRegistryContainer(DockerImageName dockerImageName, int fixedExpo
                 withLabel(QUARKUS_DEV_SERVICE, serviceName);
             }
             withEnv("QUARKUS_PROFILE", "prod");
-            if (!dockerImageName.getRepository().endsWith("apicurio/apicurio-registry-mem")) {
-                throw new IllegalArgumentException("Only apicurio/apicurio-registry-mem images are supported");
+            if (!dockerImageName.getRepository().contains("apicurio/apicurio-registry")) {
+                throw new IllegalArgumentException("Only apicurio/apicurio-registry images are supported");
             }
             this.hostName = ConfigureUtil.configureNetwork(this, defaultNetworkId, useSharedNetwork, "apicurio-registry");
+            withEnv(containerEnv);
+            timeout.ifPresent(this::withStartupTimeout);
         }
 
         @Override
@@ -303,6 +205,11 @@ protected void configure() {
             }
         }
 
+        @Override
+        public void close() {
+            super.close();
+        }
+
         public String getUrl() {
             return String.format("http://%s:%s", getHostToUse(), getPortToUse());
         }
@@ -314,5 +221,18 @@ private String getHostToUse() {
         private int getPortToUse() {
             return useSharedNetwork ? APICURIO_REGISTRY_PORT : getMappedPort(APICURIO_REGISTRY_PORT);
         }
+
+        @Override
+        public String getConnectionInfo() {
+            return getApicurioRegistryUrl();
+        }
+
+        public String getApicurioRegistryUrl() {
+            return getUrl() + (legacyImage ? "/apis/registry/v2" : "/apis/registry/v3");
+        }
+
+        public String getConfluentRegistryUrl() {
+            return getUrl() + (legacyImage ? "/apis/ccompat/v6" : "/apis/ccompat/v7");
+        }
     }
 }
diff --git a/extensions/smallrye-reactive-messaging-amqp/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/amqp/deployment/AmqpDevServicesProcessor.java b/extensions/smallrye-reactive-messaging-amqp/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/amqp/deployment/AmqpDevServicesProcessor.java
index a7d7ce9d31e..a0a6615d9cf 100644
--- a/extensions/smallrye-reactive-messaging-amqp/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/amqp/deployment/AmqpDevServicesProcessor.java
+++ b/extensions/smallrye-reactive-messaging-amqp/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/amqp/deployment/AmqpDevServicesProcessor.java
@@ -4,14 +4,8 @@
 import static io.quarkus.devservices.common.ContainerLocator.locateContainerWithLabels;
 import static io.quarkus.devservices.common.Labels.QUARKUS_DEV_SERVICE;
 
-import java.io.Closeable;
-import java.time.Duration;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.function.Supplier;
 
 import org.eclipse.microprofile.config.Config;
 import org.eclipse.microprofile.config.ConfigProvider;
@@ -24,21 +18,16 @@
 import io.quarkus.deployment.IsDevServicesSupportedByLaunchMode;
 import io.quarkus.deployment.annotations.BuildStep;
 import io.quarkus.deployment.annotations.BuildSteps;
-import io.quarkus.deployment.builditem.CuratedApplicationShutdownBuildItem;
 import io.quarkus.deployment.builditem.DevServicesComposeProjectBuildItem;
 import io.quarkus.deployment.builditem.DevServicesResultBuildItem;
-import io.quarkus.deployment.builditem.DevServicesResultBuildItem.RunningDevService;
 import io.quarkus.deployment.builditem.DevServicesSharedNetworkBuildItem;
 import io.quarkus.deployment.builditem.DockerStatusBuildItem;
 import io.quarkus.deployment.builditem.LaunchModeBuildItem;
-import io.quarkus.deployment.console.ConsoleInstalledBuildItem;
-import io.quarkus.deployment.console.StartupLogCompressor;
+import io.quarkus.deployment.builditem.Startable;
 import io.quarkus.deployment.dev.devservices.DevServicesConfig;
 import io.quarkus.deployment.dev.devservices.RunningContainer;
-import io.quarkus.deployment.logging.LoggingSetupBuildItem;
 import io.quarkus.devservices.common.ComposeLocator;
 import io.quarkus.devservices.common.ConfigureUtil;
-import io.quarkus.devservices.common.ContainerAddress;
 import io.quarkus.devservices.common.ContainerLocator;
 import io.quarkus.runtime.LaunchMode;
 import io.quarkus.runtime.configuration.ConfigUtils;
@@ -72,186 +61,77 @@ public class AmqpDevServicesProcessor {
     private static final String DEFAULT_USER = "admin";
     private static final String DEFAULT_PASSWORD = "admin";
 
-    static volatile RunningDevService devService;
-    static volatile AmqpDevServiceCfg cfg;
-    static volatile boolean first = true;
-
     @BuildStep
     public DevServicesResultBuildItem startAmqpDevService(
             DockerStatusBuildItem dockerStatusBuildItem,
-            DevServicesComposeProjectBuildItem composeProjectBuildItem,
+            DevServicesComposeProjectBuildItem compose,
             LaunchModeBuildItem launchMode,
-            AmqpBuildTimeConfig amqpClientBuildTimeConfig,
-            Optional<ConsoleInstalledBuildItem> consoleInstalledBuildItem,
-            CuratedApplicationShutdownBuildItem closeBuildItem,
-            LoggingSetupBuildItem loggingSetupBuildItem,
-            DevServicesConfig devServicesConfig,
-            List<DevServicesSharedNetworkBuildItem> devServicesSharedNetworkBuildItem) {
-
-        AmqpDevServiceCfg configuration = getConfiguration(amqpClientBuildTimeConfig);
-
-        if (devService != null && devService.isOwner()) {
-            boolean shouldShutdownTheBroker = !configuration.equals(cfg);
-            if (!shouldShutdownTheBroker) {
-                return devService.toBuildItem();
-            }
-            shutdownBroker();
-            cfg = null;
-        }
-
-        StartupLogCompressor compressor = new StartupLogCompressor(
-                (launchMode.isTest() ? "(test) " : "") + "AMQP Dev Services Starting:", consoleInstalledBuildItem,
-                loggingSetupBuildItem);
-        try {
-            RunningDevService newDevService = startAmqpBroker(dockerStatusBuildItem, composeProjectBuildItem, configuration,
-                    launchMode,
-                    devServicesConfig.timeout(), !devServicesSharedNetworkBuildItem.isEmpty());
-            if (newDevService != null) {
-                devService = newDevService;
-            }
-            if (devService == null) {
-                compressor.closeAndDumpCaptured();
-            } else {
-                compressor.close();
-            }
-        } catch (Throwable t) {
-            compressor.closeAndDumpCaptured();
-            throw new RuntimeException(t);
-        }
-
-        if (devService == null) {
-            return null;
-        }
-
-        // Configure the watch dog
-        if (first) {
-            first = false;
-            Runnable closeTask = () -> {
-                if (devService != null) {
-                    shutdownBroker();
-
-                    log.info("Dev Services for AMQP shut down.");
-                }
-                first = true;
-                devService = null;
-                cfg = null;
-            };
-            closeBuildItem.addCloseTask(closeTask, true);
-        }
-        cfg = configuration;
-
-        if (devService.isOwner()) {
-            Map<String, String> config = devService.getConfig();
-            log.infof("Dev Services for AMQP started. Other Quarkus applications in dev mode will find the "
-                    + "broker automatically. For Quarkus applications in production mode, you can connect to"
-                    + " this by starting your application with -Damqp.host=%s -Damqp.port=%s -Damqp.username=%s -Damqp.password=%s",
-                    config.get(AMQP_HOST_PROP), config.get(AMQP_PORT_PROP), config.get(AMQP_USER_PROP),
-                    config.get(AMQP_PASSWORD_PROP));
-        }
-
-        return devService.toBuildItem();
-    }
-
-    private void shutdownBroker() {
-        if (devService != null) {
-            try {
-                devService.close();
-            } catch (Throwable e) {
-                log.error("Failed to stop the AMQP broker", e);
-            } finally {
-                devService = null;
-            }
-        }
-    }
-
-    private RunningDevService startAmqpBroker(DockerStatusBuildItem dockerStatusBuildItem,
-            DevServicesComposeProjectBuildItem composeProjectBuildItem,
-            AmqpDevServiceCfg config,
-            LaunchModeBuildItem launchMode, Optional<Duration> timeout, boolean useSharedNetwork) {
-        if (!config.devServicesEnabled) {
-            // explicitly disabled
-            log.debug("Not starting Dev Services for AMQP, as it has been disabled in the config.");
-            return null;
-        }
-
-        // Check if amqp.port or amqp.host are set
-        if (ConfigUtils.isPropertyNonEmpty(AMQP_HOST_PROP) || ConfigUtils.isPropertyNonEmpty(AMQP_PORT_PROP)) {
-            log.debug("Not starting Dev Services for AMQP, the amqp.host and/or amqp.port are configured.");
-            return null;
-        }
-
-        // Verify that we have AMQP channels without host and port
-        if (!hasAmqpChannelWithoutHostAndPort()) {
-            log.debug("Not starting Dev Services for AMQP, all the channels are configured.");
-            return null;
-        }
+            AmqpBuildTimeConfig amqpBuildTimeConfig,
+            List<DevServicesSharedNetworkBuildItem> sharedNetwork,
+            DevServicesConfig devServicesConfig) {
 
-        if (!dockerStatusBuildItem.isContainerRuntimeAvailable()) {
-            log.warn("Docker isn't working, please configure the AMQP broker location.");
+        AmqpDevServicesBuildTimeConfig config = amqpBuildTimeConfig.devservices();
+        if (devServiceDisabled(dockerStatusBuildItem, config.enabled().orElse(true))) {
             return null;
         }
 
-        final Supplier<RunningDevService> defaultAmqpBrokerSupplier = () -> {
-            // Starting the broker
-            ArtemisContainer container = new ArtemisContainer(
-                    DockerImageName.parse(config.imageName).asCompatibleSubstituteFor("artemiscloud/activemq-artemis-broker"),
-                    config.extra,
-                    config.fixedExposedPort,
-                    launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT ? config.serviceName : null,
-                    composeProjectBuildItem.getDefaultNetworkId(),
-                    useSharedNetwork);
-
-            timeout.ifPresent(container::withStartupTimeout);
-            container.withEnv(config.containerEnv);
-            container.start();
-
-            return getRunningService(container.getContainerId(), container::close, container.getEffectiveHost(),
-                    container.getPort(), container.getMappedPort(), DEFAULT_USER, DEFAULT_PASSWORD);
-        };
-
-        return amqpContainerLocator.locateContainer(config.serviceName, config.shared, launchMode.getLaunchMode())
-                .map(containerAddress -> getRunningService(config, launchMode, containerAddress))
-                .or(() -> ComposeLocator.locateContainer(composeProjectBuildItem,
-                        List.of(config.imageName, "amqp", "activemq-artemis", "amq-broker", "rabbitmq"),
-                        AMQP_PORT,
-                        launchMode.getLaunchMode(), useSharedNetwork)
-                        .map(this::getRunningService))
-                .orElseGet(defaultAmqpBrokerSupplier);
+        boolean useSharedNetwork = DevServicesSharedNetworkBuildItem.isSharedNetworkRequired(devServicesConfig, sharedNetwork);
+
+        return amqpContainerLocator.locateContainer(config.serviceName(), config.shared(), launchMode.getLaunchMode())
+                .or(() -> ComposeLocator.locateContainer(compose,
+                        List.of(config.imageName().orElse(getDefaultImageNameFor("amqp")),
+                                "amqp", "activemq-artemis", "amq-broker", "rabbitmq"),
+                        AMQP_PORT, launchMode.getLaunchMode(), useSharedNetwork))
+                .map(containerAddress -> {
+                    // Discovered service
+                    RunningContainer container = containerAddress.getRunningContainer();
+                    if (container == null) {
+                        return null;
+                    }
+                    return DevServicesResultBuildItem.discovered()
+                            .feature(Feature.MESSAGING_AMQP)
+                            .containerId(containerAddress.getId())
+                            .config(Map.of(
+                                    AMQP_HOST_PROP, containerAddress.getHost(),
+                                    AMQP_PORT_PROP, String.valueOf(containerAddress.getPort()),
+                                    AMQP_MAPPED_PORT_PROP,
+                                    String.valueOf(container.getPortMapping(AMQP_CONSOLE_PORT).orElse(0)),
+                                    AMQP_USER_PROP, container.tryGetEnv("AMQP_USER", "ARTEMIS_USER", "RABBITMQ_DEFAULT_USER")
+                                            .orElse(DEFAULT_USER),
+                                    AMQP_PASSWORD_PROP,
+                                    container.tryGetEnv("AMQP_PASSWORD", "ARTEMIS_PASSWORD", "RABBITMQ_DEFAULT_PASS")
+                                            .orElse(DEFAULT_PASSWORD)))
+                            .build();
+                })
+                .orElseGet(() -> DevServicesResultBuildItem.owned()
+                        .feature(Feature.MESSAGING_AMQP)
+                        .serviceConfig(config)
+                        .startable(() -> new ArtemisContainer(
+                                DockerImageName.parse(config.imageName().orElse(getDefaultImageNameFor("amqp")))
+                                        .asCompatibleSubstituteFor("artemiscloud/activemq-artemis-broker"),
+                                config.extraArgs(),
+                                config.port().orElse(0),
+                                launchMode.getLaunchMode() == LaunchMode.DEVELOPMENT ? config.serviceName() : null,
+                                compose.getDefaultNetworkId(),
+                                useSharedNetwork)
+                                .withEnv(config.containerEnv())
+                                .withSharedServiceLabel(launchMode.getLaunchMode(), config.serviceName()))
+                        .postStartHook(this::logStarted)
+                        .config(Map.of(
+                                AMQP_USER_PROP, DEFAULT_USER,
+                                AMQP_PASSWORD_PROP, DEFAULT_PASSWORD))
+                        .configProvider(Map.of(
+                                AMQP_HOST_PROP, ArtemisContainer::getEffectiveHost,
+                                AMQP_PORT_PROP, s -> String.valueOf(s.getPort()),
+                                AMQP_MAPPED_PORT_PROP, s -> String.valueOf(s.getMappedConsolePort())))
+                        .build());
     }
 
-    private RunningDevService getRunningService(ContainerAddress address) {
-        RunningContainer container = address.getRunningContainer();
-        if (container == null) {
-            return null;
-        }
-        return getRunningService(address.getId(),
-                null,
-                address.getHost(),
-                address.getPort(),
-                container.getPortMapping(AMQP_CONSOLE_PORT).orElse(0),
-                container.tryGetEnv("AMQP_USER", "ARTEMIS_USER", "RABBITMQ_DEFAULT_USER").orElse(DEFAULT_USER),
-                container.tryGetEnv("AMQP_PASSWORD", "ARTEMIS_PASSWORD", "RABBITMQ_DEFAULT_PASS").orElse(DEFAULT_PASSWORD));
-    }
-
-    private RunningDevService getRunningService(AmqpDevServiceCfg config, LaunchModeBuildItem launchMode,
-            ContainerAddress address) {
-        Integer httpPort = amqpContainerLocator
-                .locatePublicPort(config.serviceName, config.shared, launchMode.getLaunchMode(), AMQP_CONSOLE_PORT)
-                .orElse(0);
-        return getRunningService(address.getId(),
-                null, address.getHost(),
-                address.getPort(), httpPort, DEFAULT_USER, DEFAULT_PASSWORD);
-    }
-
-    private RunningDevService getRunningService(String containerId, Closeable closeable, String host, int port,
-            int httpPort, String username, String password) {
-        Map<String, String> configMap = new HashMap<>();
-        configMap.put(AMQP_HOST_PROP, host);
-        configMap.put(AMQP_PORT_PROP, String.valueOf(port));
-        configMap.put(AMQP_MAPPED_PORT_PROP, String.valueOf(httpPort));
-        configMap.put(AMQP_USER_PROP, username);
-        configMap.put(AMQP_PASSWORD_PROP, password);
-        return new RunningDevService(Feature.MESSAGING_AMQP.getName(), containerId, closeable, configMap);
+    private void logStarted(ArtemisContainer container) {
+        log.infof("Dev Services for AMQP started. Other Quarkus applications in dev mode will find the "
+                + "broker automatically. For Quarkus applications in production mode, you can connect to"
+                + " this by starting your application with -Damqp-host=%s -Damqp-port=%s -Damqp-username=%s -Damqp-password=%s",
+                container.getEffectiveHost(), container.getPort(), DEFAULT_USER, DEFAULT_PASSWORD);
     }
 
     private boolean hasAmqpChannelWithoutHostAndPort() {
@@ -276,54 +156,37 @@ private boolean hasAmqpChannelWithoutHostAndPort() {
         return false;
     }
 
-    private AmqpDevServiceCfg getConfiguration(AmqpBuildTimeConfig cfg) {
-        AmqpDevServicesBuildTimeConfig devServicesConfig = cfg.devservices();
-        return new AmqpDevServiceCfg(devServicesConfig);
-    }
+    private boolean devServiceDisabled(DockerStatusBuildItem dockerStatusBuildItem, boolean devServicesEnabled) {
+        if (!devServicesEnabled) {
+            // explicitly disabled
+            log.debug("Not starting Dev Services for AMQP, as it has been disabled in the config.");
+            return true;
+        }
 
-    private static final class AmqpDevServiceCfg {
-        private final boolean devServicesEnabled;
-        private final String imageName;
-        private final Integer fixedExposedPort;
-        private final String extra;
-        private final boolean shared;
-        private final String serviceName;
-        private final Map<String, String> containerEnv;
-
-        public AmqpDevServiceCfg(AmqpDevServicesBuildTimeConfig devServicesConfig) {
-            this.devServicesEnabled = devServicesConfig.enabled().orElse(true);
-            this.imageName = devServicesConfig.imageName().orElseGet(() -> getDefaultImageNameFor("amqp"));
-            this.fixedExposedPort = devServicesConfig.port().orElse(0);
-            this.extra = devServicesConfig.extraArgs();
-            this.shared = devServicesConfig.shared();
-            this.serviceName = devServicesConfig.serviceName();
-            this.containerEnv = devServicesConfig.containerEnv();
+        // Check if amqp-host or amqp-port are set
+        if (ConfigUtils.isPropertyNonEmpty(AMQP_HOST_PROP) || ConfigUtils.isPropertyNonEmpty(AMQP_PORT_PROP)) {
+            log.debug("Not starting Dev Services for AMQP, the amqp-host and/or amqp-port are configured.");
+            return true;
         }
 
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-            AmqpDevServiceCfg that = (AmqpDevServiceCfg) o;
-            return devServicesEnabled == that.devServicesEnabled && Objects.equals(imageName, that.imageName)
-                    && Objects.equals(fixedExposedPort, that.fixedExposedPort)
-                    && Objects.equals(containerEnv, that.containerEnv);
+        // Verify that we have AMQP channels without host and port
+        if (!hasAmqpChannelWithoutHostAndPort()) {
+            log.debug("Not starting Dev Services for AMQP, all the channels are configured.");
+            return true;
         }
 
-        @Override
-        public int hashCode() {
-            return Objects.hash(devServicesEnabled, imageName, fixedExposedPort, containerEnv);
+        if (!dockerStatusBuildItem.isContainerRuntimeAvailable()) {
+            log.warn("Docker isn't working, please configure the AMQP broker location.");
+            return true;
         }
+
+        return false;
     }
 
     /**
      * Container configuring and starting the Artemis broker.
      */
-    private static final class ArtemisContainer extends GenericContainer<ArtemisContainer> {
+    private static final class ArtemisContainer extends GenericContainer<ArtemisContainer> implements Startable {
 
         private final int port;
         private final boolean useSharedNetwork;
@@ -365,20 +228,30 @@ protected void configure() {
             }
         }
 
-        public int getPort() {
-            if (useSharedNetwork) {
-                return AMQP_PORT;
-            }
+        @Override
+        public String getConnectionInfo() {
+            return String.format("amqp://%s:%d", getEffectiveHost(), getPort());
+        }
+
+        @Override
+        public void close() {
+            super.close();
+        }
 
-            return getMappedPort(AMQP_PORT);
+        public int getPort() {
+            return useSharedNetwork ? AMQP_PORT : getMappedPort(AMQP_PORT);
         }
 
         public String getEffectiveHost() {
-            return hostName;
+            return useSharedNetwork ? hostName : getHost();
         }
 
-        public int getMappedPort() {
+        public int getMappedConsolePort() {
             return getMappedPort(AMQP_CONSOLE_PORT);
         }
+
+        public ArtemisContainer withSharedServiceLabel(LaunchMode launchMode, String serviceName) {
+            return ConfigureUtil.configureSharedServiceLabel(this, launchMode, DEV_SERVICE_LABEL, serviceName);
+        }
     }
 }
diff --git a/extensions/smallrye-reactive-messaging-amqp/runtime/pom.xml b/extensions/smallrye-reactive-messaging-amqp/runtime/pom.xml
index 2474d91098e..5e80fa06669 100644
--- a/extensions/smallrye-reactive-messaging-amqp/runtime/pom.xml
+++ b/extensions/smallrye-reactive-messaging-amqp/runtime/pom.xml
@@ -56,6 +56,10 @@
             <groupId>jakarta.annotation</groupId>
             <artifactId>jakarta.annotation-api</artifactId>
         </dependency>
+        <dependency>
+            <groupId>io.quarkus</groupId>
+            <artifactId>quarkus-devservices</artifactId>
+        </dependency>
     </dependencies>
 
     <build>
diff --git a/extensions/smallrye-reactive-messaging-kafka/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/kafka/deployment/DefaultSerdeDiscoveryState.java b/extensions/smallrye-reactive-messaging-kafka/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/kafka/deployment/DefaultSerdeDiscoveryState.java
index 1441859a31c..2a15336da4d 100644
--- a/extensions/smallrye-reactive-messaging-kafka/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/kafka/deployment/DefaultSerdeDiscoveryState.java
+++ b/extensions/smallrye-reactive-messaging-kafka/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/kafka/deployment/DefaultSerdeDiscoveryState.java
@@ -36,9 +36,9 @@ class DefaultSerdeDiscoveryState {
     private Boolean connectorHasValueDeserializer;
 
     private Boolean hasConfluent;
-    private Boolean hasApicurio1;
-    private Boolean hasApicurio2Avro;
+    private Boolean hasApicurioAvro;
     private Boolean hasJsonb;
+    private boolean apicurioVersionWarningLogged;
 
     DefaultSerdeDiscoveryState(IndexView index) {
         this.index = index;
@@ -142,32 +142,30 @@ boolean hasConfluent() {
         return hasConfluent;
     }
 
-    boolean hasApicurio1() {
-        if (hasApicurio1 == null) {
+    boolean hasApicurioAvro() {
+        if (hasApicurioAvro == null) {
             try {
-                Class.forName("io.apicurio.registry.utils.serde.AvroKafkaDeserializer", false,
+                Class.forName("io.apicurio.registry.serde.avro.AvroKafkaDeserializer", false,
                         Thread.currentThread().getContextClassLoader());
-                hasApicurio1 = true;
+                hasApicurioAvro = true;
             } catch (ClassNotFoundException e) {
-                hasApicurio1 = false;
+                hasApicurioAvro = false;
             }
         }
 
-        return hasApicurio1;
+        return hasApicurioAvro;
     }
 
-    boolean hasApicurio2Avro() {
-        if (hasApicurio2Avro == null) {
-            try {
-                Class.forName("io.apicurio.registry.serde.avro.AvroKafkaDeserializer", false,
-                        Thread.currentThread().getContextClassLoader());
-                hasApicurio2Avro = true;
-            } catch (ClassNotFoundException e) {
-                hasApicurio2Avro = false;
-            }
+    /**
+     * Returns true if the Apicurio version warning should be logged (first call only).
+     * Subsequent calls return false to avoid duplicate warnings.
+     */
+    boolean shouldLogApicurioVersionWarning() {
+        if (!apicurioVersionWarningLogged && hasApicurioAvro()) {
+            apicurioVersionWarningLogged = true;
+            return true;
         }
-
-        return hasApicurio2Avro;
+        return false;
     }
 
     boolean hasJsonb() {
diff --git a/extensions/smallrye-reactive-messaging-kafka/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/kafka/deployment/SmallRyeReactiveMessagingKafkaProcessor.java b/extensions/smallrye-reactive-messaging-kafka/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/kafka/deployment/SmallRyeReactiveMessagingKafkaProcessor.java
index d7a95eeee24..b0b28d367cd 100644
--- a/extensions/smallrye-reactive-messaging-kafka/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/kafka/deployment/SmallRyeReactiveMessagingKafkaProcessor.java
+++ b/extensions/smallrye-reactive-messaging-kafka/deployment/src/main/java/io/quarkus/smallrye/reactivemessaging/kafka/deployment/SmallRyeReactiveMessagingKafkaProcessor.java
@@ -963,8 +963,7 @@ private Result serializerDeserializerFor(DefaultSerdeDiscoveryState discovery, T
         if (isAvroGenerated || DotNames.AVRO_GENERIC_RECORD.equals(typeName)) {
             int avroLibraries = 0;
             avroLibraries += discovery.hasConfluent() ? 1 : 0;
-            avroLibraries += discovery.hasApicurio1() ? 1 : 0;
-            avroLibraries += discovery.hasApicurio2Avro() ? 1 : 0;
+            avroLibraries += discovery.hasApicurioAvro() ? 1 : 0;
             if (avroLibraries > 1) {
                 LOGGER.debugf("Skipping Avro serde autodetection for %s, because multiple Avro serde libraries are present",
                         typeName);
@@ -976,12 +975,13 @@ private Result serializerDeserializerFor(DefaultSerdeDiscoveryState discovery, T
                         ? Result.of("io.confluent.kafka.serializers.KafkaAvroSerializer")
                         : Result.of("io.confluent.kafka.serializers.KafkaAvroDeserializer")
                                 .with(isAvroGenerated, "specific.avro.reader", "true");
-            } else if (discovery.hasApicurio1()) {
-                return serializer
-                        ? Result.of("io.apicurio.registry.utils.serde.AvroKafkaSerializer")
-                        : Result.of("io.apicurio.registry.utils.serde.AvroKafkaDeserializer")
-                                .with(isAvroGenerated, "apicurio.registry.use-specific-avro-reader", "true");
-            } else if (discovery.hasApicurio2Avro()) {
+            } else if (discovery.hasApicurioAvro()) {
+                if (discovery.shouldLogApicurioVersionWarning()) {
+                    LOGGER.info("Apicurio Registry Avro serde detected. Note: Apicurio Registry 3.x uses 4-byte schema IDs " +
+                            "by default, while 2.x used 8-byte IDs. If consuming messages produced by Apicurio Registry 2.x, " +
+                            "configure 'apicurio.registry.id-handler=io.apicurio.registry.serde.Legacy8ByteIdHandler' " +
+                            "on your consumer channels for compatibility.");
+                }
                 return serializer
                         ? Result.of("io.apicurio.registry.serde.avro.AvroKafkaSerializer")
                         : Result.of("io.apicurio.registry.serde.avro.AvroKafkaDeserializer")
diff --git a/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DirectConfigServerBaseUrlProvider.java b/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DirectConfigServerBaseUrlProvider.java
index e7c134b283f..4917924ca17 100644
--- a/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DirectConfigServerBaseUrlProvider.java
+++ b/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/DirectConfigServerBaseUrlProvider.java
@@ -3,9 +3,13 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 
+import org.jboss.logging.Logger;
+
 import io.quarkus.spring.cloud.config.client.runtime.util.UrlUtility;
 
 public class DirectConfigServerBaseUrlProvider implements ConfigServerBaseUrlProvider {
+
+    private static final Logger log = Logger.getLogger(DirectConfigServerBaseUrlProvider.class);
     private final SpringCloudConfigClientConfig config;
 
     public DirectConfigServerBaseUrlProvider(SpringCloudConfigClientConfig config) {
@@ -14,6 +18,7 @@ public DirectConfigServerBaseUrlProvider(SpringCloudConfigClientConfig config) {
 
     @Override
     public URI get() {
+        log.info("Getting config server URL with Direct ConfigServer BaseUrl");
         String url = config.url();
         validate(url);
         try {
diff --git a/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigClientConfigSourceFactory.java b/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigClientConfigSourceFactory.java
index a3aea57a965..2d649b250a8 100644
--- a/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigClientConfigSourceFactory.java
+++ b/extensions/spring-cloud-config-client/runtime/src/main/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigClientConfigSourceFactory.java
@@ -1,11 +1,12 @@
 package io.quarkus.spring.cloud.config.client.runtime;
 
-import static java.lang.String.join;
 import static java.util.Collections.emptyList;
 
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import org.eclipse.microprofile.config.spi.ConfigSource;
 import org.jboss.logging.Logger;
@@ -51,29 +52,45 @@ public Iterable<ConfigSource> getConfigSources(final ConfigSourceContext context
 
         VertxSpringCloudConfigGateway client = new VertxSpringCloudConfigGateway(config);
         try {
-            String profiles = determineProfiles(context, config);
+            List<Response> responses = new ArrayList<>();
+            List<String> profiles = determineProfiles(context, config);
             log.debug("The following profiles will be used to look up properties: " + profiles);
-            Response response;
-            if (connectionTimeoutIsGreaterThanZero || readTimeoutIsGreaterThanZero) {
-                response = client.exchange(applicationName, profiles).await()
-                        .atMost(config.connectionTimeout().plus(config.readTimeout().multipliedBy(2)));
-            } else {
-                response = client.exchange(applicationName, profiles).await().indefinitely();
+            for (String profile : profiles) {
+                Response response;
+                if (connectionTimeoutIsGreaterThanZero || readTimeoutIsGreaterThanZero) {
+                    response = client.exchange(applicationName, profile).await()
+                            .atMost(config.connectionTimeout().plus(config.readTimeout().multipliedBy(2)));
+                } else {
+                    response = client.exchange(applicationName, profile).await().indefinitely();
+                }
+
+                if (response.getProfiles().contains(profile)) {
+                    responses.add(response);
+                } else {
+                    log.debug("Response did not contain profile " + profile);
+                }
             }
 
-            List<PropertySource> propertySources = response.getPropertySources();
+            log.debug("Obtained " + responses.size() + " from the config server");
+
+            int ordinal = config.ordinal();
             // Profiles are looked from the highest ordinal to lowest, so we reverse the collection to build the source list
-            Collections.reverse(propertySources);
-
-            for (int i = 0, propertySourcesSize = propertySources.size(); i < propertySourcesSize; i++) {
-                int ordinal = config.ordinal() + i;
-                PropertySource propertySource = propertySources.get(i);
-                if (log.isDebugEnabled()) {
-                    log.debug("Adding PropertySource named '" + propertySource.getName() + "', with and ordinal of '" + ordinal
-                            + "' that contains the following keys: " + join(",", propertySource.getSource().keySet()));
+            Collections.reverse(responses);
+            for (Response response : responses) {
+                List<PropertySource> propertySources = response.getPropertySources();
+                // Same reverse rule here
+                Collections.reverse(propertySources);
+
+                for (PropertySource propertySource : propertySources) {
+                    int ord = ordinal++;
+                    if (log.isDebugEnabled()) {
+                        log.debug("Adding PropertySource named '" + propertySource.getName() + "', with and ordinal of '" + ord
+                                + "' that contains the following keys: "
+                                + String.join(",", propertySource.getSource().keySet()));
+                    }
+
+                    sources.add(SpringCloudPropertySource.from(propertySource, response.getProfiles(), ord));
                 }
-                sources.add(new MapBackedConfigSource(propertySource.getName(), propertySource.getSource(), ordinal) {
-                });
             }
 
             return sources;
@@ -91,13 +108,27 @@ public Iterable<ConfigSource> getConfigSources(final ConfigSourceContext context
         }
     }
 
-    private static String determineProfiles(ConfigSourceContext context, SpringCloudConfigClientConfig config) {
+    private static List<String> determineProfiles(ConfigSourceContext context, SpringCloudConfigClientConfig config) {
         if (config.profiles().isPresent()) {
-            return join(",", config.profiles().get());
+            return config.profiles().get();
+        }
+        return context.getProfiles();
+    }
+
+    private static class SpringCloudPropertySource extends MapBackedConfigSource {
+        private SpringCloudPropertySource(final String name, final Map<String, String> propertyMap, final int defaultOrdinal) {
+            super(name, propertyMap, defaultOrdinal);
+        }
+
+        static SpringCloudPropertySource from(PropertySource propertySource, List<String> profiles, int ordinal) {
+            Map<String, String> values = new HashMap<>();
+            Map<String, String> source = propertySource.getSource();
+            for (String profile : profiles) {
+                for (Map.Entry<String, String> entry : source.entrySet()) {
+                    values.put("%" + profile + "." + entry.getKey(), entry.getValue());
+                }
+            }
+            return new SpringCloudPropertySource(propertySource.getName(), values, ordinal);
         }
-        // The profile list starts with the profile overrides, but setting the property is done backwards
-        List<String> profiles = new ArrayList<>(context.getProfiles());
-        Collections.reverse(profiles);
-        return join(",", profiles);
     }
 }
diff --git a/extensions/spring-cloud-config-client/runtime/src/test/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigClientConfigSourceFactoryTest.java b/extensions/spring-cloud-config-client/runtime/src/test/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigClientConfigSourceFactoryTest.java
index 9bda041fce3..f854c9b81ab 100644
--- a/extensions/spring-cloud-config-client/runtime/src/test/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigClientConfigSourceFactoryTest.java
+++ b/extensions/spring-cloud-config-client/runtime/src/test/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigClientConfigSourceFactoryTest.java
@@ -3,8 +3,6 @@
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.assertj.core.api.Assertions.entry;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertIterableEquals;
 import static org.mockito.Mockito.when;
 
 import java.io.IOException;
@@ -14,7 +12,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
-import java.util.stream.StreamSupport;
 
 import org.apache.commons.io.IOUtils;
 import org.eclipse.microprofile.config.spi.ConfigSource;
@@ -28,8 +25,6 @@
 
 import io.quarkus.runtime.ApplicationLifecycleManager;
 import io.smallrye.config.ConfigSourceContext;
-import io.smallrye.config.SmallRyeConfig;
-import io.smallrye.config.SmallRyeConfigBuilder;
 
 class SpringCloudConfigClientConfigSourceFactoryTest {
 
@@ -158,30 +153,30 @@ void testBasic() throws IOException {
         assertThat(configSourceList.get(0)).satisfies(cs -> {
             assertThat(cs.getName()).isEqualTo("https://github.com/spring-cloud-samples/config-repo/application.yml");
             assertThat(cs.getOrdinal()).isEqualTo(450);
-            assertThat(cs.getProperties()).contains(entry("info.description", "Spring Cloud Samples"),
-                    entry("foo", "baz"), entry("info.url", "https://github.com/spring-cloud-samples"),
-                    entry("eureka.client.serviceUrl.defaultZone", "http://localhost:8761/eureka/"));
+            assertThat(cs.getProperties()).contains(entry("%dev.info.description", "Spring Cloud Samples"),
+                    entry("%dev.foo", "baz"), entry("%dev.info.url", "https://github.com/spring-cloud-samples"),
+                    entry("%dev.eureka.client.serviceUrl.defaultZone", "http://localhost:8761/eureka/"));
         });
 
         assertThat(configSourceList.get(1)).satisfies(cs -> {
             assertThat(cs.getName()).isEqualTo("https://github.com/spring-cloud-samples/config-repo/foo.properties");
             assertThat(cs.getOrdinal()).isEqualTo(451);
-            assertThat(cs.getProperties()).contains(entry("foo", "from foo props"),
-                    entry("democonfigclient.message", "hello spring io"));
+            assertThat(cs.getProperties()).contains(entry("%dev.foo", "from foo props"),
+                    entry("%dev.democonfigclient.message", "hello spring io"));
         });
 
         assertThat(configSourceList.get(2)).satisfies(cs -> {
             assertThat(cs.getName())
                     .isEqualTo("https://github.com/spring-cloud-samples/config-repo/application-dev.yml");
             assertThat(cs.getOrdinal()).isEqualTo(452);
-            assertThat(cs.getProperties()).contains(entry("my.prop", "from application-dev.yml"));
+            assertThat(cs.getProperties()).contains(entry("%dev.my.prop", "from application-dev.yml"));
         });
 
         assertThat(configSourceList.get(3)).satisfies(cs -> {
             assertThat(cs.getName()).isEqualTo("https://github.com/spring-cloud-samples/config-repo/foo-dev.yml");
             assertThat(cs.getOrdinal()).isEqualTo(453);
-            assertThat(cs.getProperties()).contains(entry("foo", "from foo development"),
-                    entry("democonfigclient.message", "hello from dev profile"), entry("bar", "spam"));
+            assertThat(cs.getProperties()).contains(entry("%dev.foo", "from foo development"),
+                    entry("%dev.democonfigclient.message", "hello from dev profile"), entry("%dev.bar", "spam"));
         });
     }
 
@@ -243,63 +238,34 @@ void testDiscovery() throws IOException {
         assertThat(configSourceList.get(0)).satisfies(cs -> {
             assertThat(cs.getName()).isEqualTo("https://github.com/spring-cloud-samples/config-repo/application.yml");
             assertThat(cs.getOrdinal()).isEqualTo(450);
-            assertThat(cs.getProperties()).contains(entry("info.description", "Spring Cloud Samples"),
-                    entry("foo", "baz"), entry("info.url", "https://github.com/spring-cloud-samples"));
+            assertThat(cs.getProperties()).contains(entry("%dev.info.description", "Spring Cloud Samples"),
+                    entry("%dev.foo", "baz"), entry("%dev.info.url", "https://github.com/spring-cloud-samples"));
         });
 
         assertThat(configSourceList.get(1)).satisfies(cs -> {
             assertThat(cs.getName()).isEqualTo("https://github.com/spring-cloud-samples/config-repo/foo.properties");
             assertThat(cs.getOrdinal()).isEqualTo(451);
-            assertThat(cs.getProperties()).contains(entry("foo", "from foo props"),
-                    entry("democonfigclient.message", "hello spring io"));
+            assertThat(cs.getProperties()).contains(entry("%dev.foo", "from foo props"),
+                    entry("%dev.democonfigclient.message", "hello spring io"));
         });
 
         assertThat(configSourceList.get(2)).satisfies(cs -> {
             assertThat(cs.getName())
                     .isEqualTo("https://github.com/spring-cloud-samples/config-repo/application-dev.yml");
             assertThat(cs.getOrdinal()).isEqualTo(452);
-            assertThat(cs.getProperties()).contains(entry("my.prop", "from application-dev.yml"));
+            assertThat(cs.getProperties()).contains(entry("%dev.my.prop", "from application-dev.yml"));
         });
 
         assertThat(configSourceList.get(3)).satisfies(cs -> {
             assertThat(cs.getName()).isEqualTo("https://github.com/spring-cloud-samples/config-repo/foo-dev.yml");
             assertThat(cs.getOrdinal()).isEqualTo(453);
-            assertThat(cs.getProperties()).contains(entry("foo", "from foo development"),
-                    entry("democonfigclient.message", "hello from dev profile"), entry("bar", "spam"));
+            assertThat(cs.getProperties()).contains(entry("%dev.foo", "from foo development"),
+                    entry("%dev.democonfigclient.message", "hello from dev profile"), entry("%dev.bar", "spam"));
         });
     }
 
-    @Test
-    void multipleProfiles() throws Exception {
-        String profile = "one,two,three";
-        ConfigSourceContext context = Mockito.mock(ConfigSourceContext.class);
-        SpringCloudConfigClientConfig clientConfig = configForTesting(true, "app", MOCK_SERVER_PORT, true, 450, false);
-        SpringCloudConfigClientConfigSourceFactory factory = new SpringCloudConfigClientConfigSourceFactory();
-
-        Mockito.when(context.getProfiles()).thenReturn(List.of("three", "two", "one"));
-        wireMockServer
-                .stubFor(WireMock.get(String.format("/%s/%s/%s", clientConfig.name(), profile, clientConfig.label().get()))
-                        .willReturn(WireMock.okJson(getJsonStringForApplicationAndProfile(clientConfig.name(), "multiple"))));
-
-        SmallRyeConfig config = new SmallRyeConfigBuilder()
-                .withSources(provider -> factory.getConfigSources(context, clientConfig))
-                .build();
-
-        assertEquals("one", config.getConfigValue("one").getValue());
-        assertEquals("two", config.getConfigValue("two").getValue());
-        assertEquals("three", config.getConfigValue("three").getValue());
-        assertEquals("none", config.getConfigValue("none").getValue());
-
-        List<String> expectedSources = List.of("app-three.yml", "app-two.yml", "app-one.yml", "app.yml",
-                "DefaultValuesConfigSource");
-        List<String> actualSources = StreamSupport.stream(config.getConfigSources().spliterator(), false)
-                .map(ConfigSource::getName)
-                .toList();
-        assertIterableEquals(expectedSources, actualSources);
-    }
-
-    private SpringCloudConfigClientConfig configForTesting(final boolean isEnabled, final String appName, final int serverPort,
-            final boolean isFailFastEnabled, final int ordinal, final boolean isDiscoveryEnabled) {
+    private SpringCloudConfigClientConfig configForTesting(final boolean isEnabled, final String appName,
+            final int serverPort, final boolean isFailFastEnabled, final int ordinal, final boolean isDiscoveryEnabled) {
 
         final SpringCloudConfigClientConfig config = Mockito.mock(SpringCloudConfigClientConfig.class);
         when(config.enabled()).thenReturn(isEnabled);
diff --git a/extensions/spring-cloud-config-client/runtime/src/test/resources/app-multiple.json b/extensions/spring-cloud-config-client/runtime/src/test/resources/app-multiple.json
deleted file mode 100644
index 57affab9733..00000000000
--- a/extensions/spring-cloud-config-client/runtime/src/test/resources/app-multiple.json
+++ /dev/null
@@ -1,38 +0,0 @@
-{
-  "name": "app",
-  "profiles": [
-    "one,two,three"
-  ],
-  "propertySources": [
-    {
-      "name": "app-three.yml",
-      "source": {
-        "three": "three"
-      }
-    },
-    {
-      "name": "app-two.yml",
-      "source": {
-        "two": "two",
-        "three": "two"
-      }
-    },
-    {
-      "name": "app-one.yml",
-      "source": {
-        "one": "one",
-        "two": "one",
-        "three": "one"
-      }
-    },
-    {
-      "name": "app.yml",
-      "source": {
-        "none": "none",
-        "one": "none",
-        "two": "none",
-        "three": "none"
-      }
-    }
-  ]
-}
\ No newline at end of file
diff --git a/extensions/tls-registry/cli/pom.xml b/extensions/tls-registry/cli/pom.xml
index 781314866ad..a2745af2ff1 100644
--- a/extensions/tls-registry/cli/pom.xml
+++ b/extensions/tls-registry/cli/pom.xml
@@ -45,6 +45,11 @@
             <artifactId>parsson</artifactId>
         </dependency>
 
+        <dependency>
+            <groupId>org.jboss.logmanager</groupId>
+            <artifactId>jboss-logmanager</artifactId>
+        </dependency>
+
         <dependency>
             <groupId>org.junit.jupiter</groupId>
             <artifactId>junit-jupiter-engine</artifactId>
diff --git a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/GenerateCACommand.java b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/GenerateCACommand.java
index cc62bcabb27..d7eb40f42e0 100644
--- a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/GenerateCACommand.java
+++ b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/GenerateCACommand.java
@@ -3,7 +3,6 @@
 import static io.quarkus.tls.cli.Constants.CA_FILE;
 import static io.quarkus.tls.cli.Constants.KEYSTORE_FILE;
 import static io.quarkus.tls.cli.Constants.PK_FILE;
-import static java.lang.System.Logger.Level.INFO;
 
 import java.io.File;
 import java.io.FileInputStream;
@@ -16,6 +15,8 @@
 import java.security.cert.X509Certificate;
 import java.util.concurrent.Callable;
 
+import org.jboss.logging.Logger;
+
 import io.smallrye.certs.ca.CaGenerator;
 import picocli.CommandLine;
 
@@ -34,19 +35,18 @@ public class GenerateCACommand implements Callable<Integer> {
             "--renew" }, description = "Update certificate if already created.", defaultValue = "false")
     boolean renew;
 
-    static System.Logger LOGGER = System.getLogger("generate-quarkus-ca");
+    static Logger LOGGER = Logger.getLogger(GenerateCACommand.class);
 
     @Override
     public Integer call() throws Exception {
-        LOGGER.log(INFO, " Generating Quarkus Dev CA certificate...");
+        LOGGER.info(" Generating Quarkus Dev CA certificate...");
         if (!Constants.BASE_DIR.exists()) {
             Constants.BASE_DIR.mkdirs();
         }
 
         if (CA_FILE.exists() && !renew) {
             if (!hasExpired()) {
-                LOGGER.log(INFO,
-                        " Quarkus Dev CA certificate already exists and has not yet expired. Use --renew to update.");
+                LOGGER.info(" Quarkus Dev CA certificate already exists and has not yet expired. Use --renew to update.");
                 return 0;
             }
         }
@@ -57,18 +57,18 @@ public Integer call() throws Exception {
                 .generate("quarkus-dev-root-ca", "Quarkus Development (" + username + ")", "Quarkus Development",
                         "home", "world", "universe");
         if (install) {
-            LOGGER.log(INFO, " Installing the CA certificate in the system truststore...");
+            LOGGER.info(" Installing the CA certificate in the system truststore...");
             generator.installToSystem();
         }
 
         if (truststore) {
-            LOGGER.log(INFO, " Generating p12 truststore...");
+            LOGGER.info(" Generating p12 truststore...");
             File ts = new File("quarkus-ca-truststore.p12");
             generator.generateTrustStore(ts);
-            LOGGER.log(INFO, " Truststore generated successfully.");
+            LOGGER.info(" Truststore generated successfully.");
         }
 
-        LOGGER.log(INFO, " Quarkus Dev CA certificate generated and installed");
+        LOGGER.info(" Quarkus Dev CA certificate generated and installed");
 
         return 0;
     }
@@ -78,7 +78,7 @@ private boolean hasExpired() throws Exception {
         try {
             cert.checkValidity();
         } catch (Exception e) {
-            LOGGER.log(INFO, " Certificate has expired. Renewing...");
+            LOGGER.info(" Certificate has expired. Renewing...");
             return true;
         }
         return false;
diff --git a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/GenerateCertificateCommand.java b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/GenerateCertificateCommand.java
index 8ce6dec5fce..674c777b90f 100644
--- a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/GenerateCertificateCommand.java
+++ b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/GenerateCertificateCommand.java
@@ -5,8 +5,6 @@
 import static io.quarkus.tls.cli.DotEnvHelper.addOrReplaceProperty;
 import static io.quarkus.tls.cli.DotEnvHelper.readDotEnvFile;
 import static io.quarkus.tls.cli.letsencrypt.LetsEncryptConstants.DOT_ENV_FILE;
-import static java.lang.System.Logger.Level.ERROR;
-import static java.lang.System.Logger.Level.INFO;
 
 import java.io.BufferedReader;
 import java.io.File;
@@ -27,6 +25,7 @@
 import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
 import org.bouncycastle.openssl.PEMParser;
 import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;
+import org.jboss.logging.Logger;
 
 import io.smallrye.certs.CertificateGenerator;
 import io.smallrye.certs.CertificateRequest;
@@ -65,25 +64,25 @@ public class GenerateCertificateCommand implements Callable<Integer> {
         Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
     }
 
-    static System.Logger LOGGER = System.getLogger("generate-certificate");
+    static Logger LOGGER = Logger.getLogger(GenerateCertificateCommand.class);
 
     @Override
     public Integer call() throws Exception {
-        LOGGER.log(INFO, "\uD83D\uDD0E Looking for the Quarkus Dev CA certificate...");
+        LOGGER.info("\uD83D\uDD0E Looking for the Quarkus Dev CA certificate...");
 
         if (!CA_FILE.exists() || !PK_FILE.exists() || selfSigned) {
-            LOGGER.log(INFO, "\uD83C\uDFB2 Quarkus Dev CA certificate not found. Generating a self-signed certificate...");
+            LOGGER.info("\uD83C\uDFB2 Quarkus Dev CA certificate not found. Generating a self-signed certificate...");
             generateSelfSignedCertificate();
             return 0;
         }
 
-        LOGGER.log(INFO, "\uD83D\uDCDC Quarkus Dev CA certificate found at {0}", CA_FILE.getAbsolutePath());
+        LOGGER.infof("\uD83D\uDCDC Quarkus Dev CA certificate found at %s", CA_FILE.getAbsolutePath());
         X509Certificate caCert = loadRootCertificate(CA_FILE);
         PrivateKey caPrivateKey = loadPrivateKey();
 
         createSignedCertificate(caCert, caPrivateKey);
 
-        LOGGER.log(INFO, " Signed Certificate generated successfully and exported into `{0}-keystore.p12`", name);
+        LOGGER.infof(" Signed Certificate generated successfully and exported into `%s-keystore.p12`", name);
         printConfig(directory.resolve(name + "-keystore.p12"), password);
 
         return 0;
@@ -99,7 +98,7 @@ private void generateSelfSignedCertificate() throws Exception {
                 .withPassword(password)
                 .withDuration(Duration.ofDays(365))
                 .withFormat(Format.PKCS12));
-        LOGGER.log(INFO, " Self-signed certificate generated successfully and exported into `{0}-keystore.p12`", name);
+        LOGGER.infof(" Self-signed certificate generated successfully and exported into `%s-keystore.p12`", name);
         printConfig(directory.resolve(name + "-keystore.p12"), password);
 
     }
@@ -116,13 +115,13 @@ private void printConfig(Path certificatePath, String password) {
             addOrReplaceProperty(dotEnvContent, "%dev.quarkus.tls.key-store.p12.password", password);
             Files.write(DOT_ENV_FILE.toPath(), dotEnvContent);
         } catch (IOException e) {
-            LOGGER.log(ERROR, "Failed to read .env file", e);
+            LOGGER.error("Failed to read .env file", e);
         }
 
-        LOGGER.log(INFO, """
+        LOGGER.infof("""
                  Required configuration added to the `.env` file:
-                %dev.quarkus.tls.key-store.p12.path={0}
-                %dev.quarkus.tls.key-store.p12.password={1}
+                %%dev.quarkus.tls.key-store.p12.path=%s
+                %%dev.quarkus.tls.key-store.p12.password=%s
                 """, certificatePathProperty, password);
     }
 
diff --git a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/TlsCommand.java b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/TlsCommand.java
index eabc08f2581..370303efd8e 100644
--- a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/TlsCommand.java
+++ b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/TlsCommand.java
@@ -21,6 +21,19 @@ public Integer call() {
     }
 
     public static void main(String[] args) {
+        // Configure JBoss LogManager
+        System.setProperty("java.util.logging.manager", "org.jboss.logmanager.LogManager");
+
+        // Load logging configuration from classpath
+        try {
+            var configUrl = TlsCommand.class.getClassLoader().getResource("logging.properties");
+            if (configUrl != null) {
+                System.setProperty("logging.configuration", configUrl.toString());
+            }
+        } catch (Exception e) {
+            // Ignore if configuration cannot be loaded
+        }
+
         int exitCode = new CommandLine(new TlsCommand()).execute(args);
         System.exit(exitCode);
     }
diff --git a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/AcmeClient.java b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/AcmeClient.java
index 2f788e0354b..8c96e0310af 100644
--- a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/AcmeClient.java
+++ b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/AcmeClient.java
@@ -1,13 +1,9 @@
 package io.quarkus.tls.cli.letsencrypt;
 
-import static java.lang.System.Logger.Level.DEBUG;
-import static java.lang.System.Logger.Level.ERROR;
-import static java.lang.System.Logger.Level.INFO;
-import static java.lang.System.Logger.Level.WARNING;
-
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 
+import org.jboss.logging.Logger;
 import org.wildfly.security.x500.cert.acme.AcmeAccount;
 import org.wildfly.security.x500.cert.acme.AcmeChallenge;
 import org.wildfly.security.x500.cert.acme.AcmeClientSpi;
@@ -24,7 +20,7 @@
 
 public class AcmeClient extends AcmeClientSpi {
 
-    static System.Logger LOGGER = System.getLogger("lets-encrypt-acme-client");
+    static Logger LOGGER = Logger.getLogger(AcmeClient.class);
 
     private static final String TOKEN_REGEX = "[A-Za-z0-9_-]+";
 
@@ -44,7 +40,7 @@ public AcmeClient(String managementUrl,
             String managementPassword,
             String managementKey) {
         this.vertx = Vertx.vertx();
-        LOGGER.log(INFO, "\uD83D\uDD35 Creating AcmeClient with {0}", managementUrl);
+        LOGGER.infof("\uD83D\uDD35 Creating AcmeClient with %s", managementUrl);
 
         // It will need to become configurable to support mTLS, etc
         options = new WebClientOptions();
@@ -67,7 +63,7 @@ public AcmeClient(String managementUrl,
     public boolean checkReadiness() {
 
         // Check status
-        LOGGER.log(INFO, "\uD83D\uDD35 Checking management challenge endpoint status using {0}", challengeUrl);
+        LOGGER.infof("\uD83D\uDD35 Checking management challenge endpoint status using %s", challengeUrl);
         HttpRequest<Buffer> request = managementClient.getAbs(challengeUrl);
         addKeyAndUser(request);
         try {
@@ -78,19 +74,18 @@ public boolean checkReadiness() {
                     return true;
                 }
                 case 404 -> {
-                    LOGGER.log(ERROR,
+                    LOGGER.error(
                             "\uFE0F Let's Encrypt challenge endpoint is not found, make sure that the build-time property `quarkus.tls.lets-encrypt.enabled` is set to `true`");
                     return false;
                 }
                 default -> {
-                    LOGGER.log(WARNING, "\uFE0F Unexpected status code from the management challenge endpoint: " + status);
+                    LOGGER.warn("\uFE0F Unexpected status code from the management challenge endpoint: " + status);
                     return false;
                 }
             }
         } catch (Exception e) {
-            LOGGER.log(DEBUG, "Failed to check the management challenge endpoint status", e);
-            LOGGER.log(ERROR,
-                    "\uFE0F Quarkus management endpoint is not ready, make sure the Quarkus application is running.");
+            LOGGER.debug("Failed to check the management challenge endpoint status", e);
+            LOGGER.error("\uFE0F Quarkus management endpoint is not ready, make sure the Quarkus application is running.");
             return false;
         }
 
@@ -104,7 +99,7 @@ public AcmeChallenge proveIdentifierControl(AcmeAccount account, List<AcmeChalle
         AcmeChallenge selectedChallenge = null;
         for (AcmeChallenge challenge : challenges) {
             if (challenge.getType() == AcmeChallenge.Type.HTTP_01) {
-                LOGGER.log(DEBUG, "HTTP 01 challenge is selected");
+                LOGGER.debug("HTTP 01 challenge is selected");
                 selectedChallenge = challenge;
                 break;
             }
@@ -119,7 +114,7 @@ public AcmeChallenge proveIdentifierControl(AcmeAccount account, List<AcmeChalle
             throw new RuntimeException("Invalid certificate authority challenge");
         }
 
-        LOGGER.log(DEBUG, "Preparing a selected challenge content for token {0}", token);
+        LOGGER.debugf("Preparing a selected challenge content for token %s", token);
         String selectedChallengeString = selectedChallenge.getKeyAuthorization(account);
 
         // respond to the http challenge
@@ -130,18 +125,17 @@ public AcmeChallenge proveIdentifierControl(AcmeAccount account, List<AcmeChalle
             HttpRequest<Buffer> request = managementClient.getAbs(challengeUrl);
             request.addQueryParam("challenge-resource", token).addQueryParam("challenge-content", selectedChallengeString);
             addKeyAndUser(request);
-            LOGGER.log(DEBUG, "Sending token {0} and challenge content to the management challenge endpoint", token,
+            LOGGER.debugf("Sending token %s and challenge content to the management challenge endpoint", token,
                     selectedChallengeString);
 
             HttpResponse<Buffer> response = await(request.send());
 
             if (response.statusCode() != 204) {
-                LOGGER.log(ERROR,
-                        "\uFE0F Failed to upload challenge content to the management challenge endpoint, status code: "
-                                + response.statusCode());
+                LOGGER.error("\uFE0F Failed to upload challenge content to the management challenge endpoint, status code: "
+                        + response.statusCode());
                 throw new RuntimeException("Failed to respond to certificate authority challenge");
             } else {
-                LOGGER.log(INFO, "\uD83D\uDD35 Challenge ready for token {0}, waiting for Let's Encrypt to validate...", token);
+                LOGGER.infof("\uD83D\uDD35 Challenge ready for token %s, waiting for Let's Encrypt to validate...", token);
             }
         }
         return selectedChallenge;
@@ -149,7 +143,7 @@ public AcmeChallenge proveIdentifierControl(AcmeAccount account, List<AcmeChalle
 
     @Override
     public void cleanupAfterChallenge(AcmeAccount account, AcmeChallenge challenge) throws AcmeException {
-        LOGGER.log(INFO, "\uD83D\uDD35 Performing cleanup after the challenge");
+        LOGGER.info("\uD83D\uDD35 Performing cleanup after the challenge");
 
         Assert.checkNotNullParam("account", account);
         Assert.checkNotNullParam("challenge", challenge);
@@ -159,7 +153,7 @@ public void cleanupAfterChallenge(AcmeAccount account, AcmeChallenge challenge)
             throw new RuntimeException("Invalid certificate authority challenge");
         }
 
-        LOGGER.log(DEBUG, "Requesting the management challenge endpoint to delete a challenge resource {0}", token);
+        LOGGER.debugf("Requesting the management challenge endpoint to delete a challenge resource %s", token);
 
         HttpRequest<Buffer> request = managementClient.deleteAbs(challengeUrl);
         addKeyAndUser(request);
@@ -170,7 +164,7 @@ public void cleanupAfterChallenge(AcmeAccount account, AcmeChallenge challenge)
     }
 
     public void certificateChainAndKeyAreReady() {
-        LOGGER.log(INFO,
+        LOGGER.info(
                 "\uD83D\uDD35 Notifying management challenge endpoint that a new certificate chain and private key are ready");
         HttpRequest<Buffer> request = managementClient.postAbs(certsUrl);
         addKeyAndUser(request);
diff --git a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptHelpers.java b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptHelpers.java
index 43d7188717b..500beaa2443 100644
--- a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptHelpers.java
+++ b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptHelpers.java
@@ -1,9 +1,5 @@
 package io.quarkus.tls.cli.letsencrypt;
 
-import static java.lang.System.Logger.Level.DEBUG;
-import static java.lang.System.Logger.Level.ERROR;
-import static java.lang.System.Logger.Level.INFO;
-
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.FileInputStream;
@@ -24,6 +20,7 @@
 
 import org.bouncycastle.util.io.pem.PemObject;
 import org.bouncycastle.util.io.pem.PemReader;
+import org.jboss.logging.Logger;
 import org.wildfly.security.x500.cert.X509CertificateChainAndSigningKey;
 import org.wildfly.security.x500.cert.acme.AcmeAccount;
 import org.wildfly.security.x500.cert.acme.AcmeException;
@@ -33,7 +30,7 @@
 
 public class LetsEncryptHelpers {
 
-    static System.Logger LOGGER = System.getLogger("lets-encrypt");
+    static Logger LOGGER = Logger.getLogger(LetsEncryptHelpers.class);
 
     public static void writePrivateKeyAndCertificateChainsAsPem(PrivateKey pk, X509Certificate[] chain, File privateKeyFile,
             File certificateChainFile) throws Exception {
@@ -73,7 +70,7 @@ public static String createAccount(AcmeClient acmeClient,
             String letsEncryptPath,
             boolean staging,
             String contactEmail) {
-        LOGGER.log(INFO, "\uD83D\uDD35 Creating {0} Let's Encrypt account", (staging ? "staging" : "production"));
+        LOGGER.infof("\uD83D\uDD35 Creating %s Let's Encrypt account", (staging ? "staging" : "production"));
 
         AcmeAccount acmeAccount = AcmeAccount.builder()
                 .setTermsOfServiceAgreed(true)
@@ -84,16 +81,16 @@ public static String createAccount(AcmeClient acmeClient,
 
         try {
             if (!acmeClient.createAccount(acmeAccount, staging)) {
-                LOGGER.log(INFO, "\uD83D\uDD35 {0} Let's Encrypt account {1} already exists",
+                LOGGER.infof("\uD83D\uDD35 %s Let's Encrypt account %s already exists",
                         (staging ? "Staging" : "Production"),
                         contactEmail);
             } else {
-                LOGGER.log(INFO, "\uD83D\uDD35 {0} Let's Encrypt account {1} has been created",
+                LOGGER.infof("\uD83D\uDD35 %s Let's Encrypt account %s has been created",
                         (staging ? "Staging" : "Production"),
                         contactEmail);
             }
         } catch (AcmeException ex) {
-            LOGGER.log(ERROR, "\uFE0F Failed to create Let's Encrypt account");
+            LOGGER.error("\uFE0F Failed to create Let's Encrypt account");
             throw new RuntimeException(ex);
         }
 
@@ -115,7 +112,7 @@ private static JsonObject convertAccountToJson(AcmeAccount acmeAccount) {
                 json.put("certificate", new String(Base64.getEncoder().encode(acmeAccount.getCertificate().getEncoded()),
                         StandardCharsets.US_ASCII));
             } catch (CertificateEncodingException ex) {
-                LOGGER.log(INFO, "\uFE0F Failed to get encoded certificate data");
+                LOGGER.info("\uFE0F Failed to get encoded certificate data");
                 throw new RuntimeException(ex);
             }
         }
@@ -127,7 +124,7 @@ private static JsonObject convertAccountToJson(AcmeAccount acmeAccount) {
     }
 
     private static void saveAccount(String letsEncryptPath, JsonObject accountJson) {
-        LOGGER.log(DEBUG, "Saving account to {0}", letsEncryptPath);
+        LOGGER.debugf("Saving account to %s", letsEncryptPath);
 
         // If more than one account must be supported, we can save accounts to unique files in .lets-encrypt/accounts
         // and require an account alias/id during operations requiring an account
@@ -154,7 +151,7 @@ public static void issueCertificate(
         } catch (AcmeException t) {
             throw new RuntimeException(t.getMessage());
         }
-        LOGGER.log(INFO, "\uD83D\uDD35 Certificate and private key issued, converting them to PEM files");
+        LOGGER.info("\uD83D\uDD35 Certificate and private key issued, converting them to PEM files");
 
         try {
             LetsEncryptHelpers.writePrivateKeyAndCertificateChainsAsPem(certChainAndPrivateKey.getSigningKey(),
@@ -165,7 +162,7 @@ public static void issueCertificate(
     }
 
     private static AcmeAccount getAccount(File letsEncryptPath) {
-        LOGGER.log(DEBUG, "Getting account from {0}", letsEncryptPath);
+        LOGGER.debugf("Getting account from %s", letsEncryptPath);
 
         JsonObject json = readAccountJson(letsEncryptPath);
         AcmeAccount.Builder builder = AcmeAccount.builder().setTermsOfServiceAgreed(true)
@@ -192,7 +189,7 @@ private static AcmeAccount getAccount(File letsEncryptPath) {
     }
 
     private static JsonObject readAccountJson(File letsEncryptPath) {
-        LOGGER.log(DEBUG, "Reading account information from {0}", letsEncryptPath);
+        LOGGER.debugf("Reading account information from %s", letsEncryptPath);
         java.nio.file.Path accountPath = Paths.get(letsEncryptPath + "/account.json");
         try (FileInputStream fis = new FileInputStream(accountPath.toString())) {
             return new JsonObject(new String(fis.readAllBytes(), StandardCharsets.US_ASCII));
@@ -228,17 +225,17 @@ public static void renewCertificate(AcmeClient acmeClient,
             String domain,
             File certChainPemLoc,
             File privateKeyPemLoc) {
-        LOGGER.log(INFO, "\uD83D\uDD35 Renewing {0} Let's Encrypt certificate chain and private key",
+        LOGGER.infof("\uD83D\uDD35 Renewing %s Let's Encrypt certificate chain and private key",
                 (staging ? "staging" : "production"));
         issueCertificate(acmeClient, letsEncryptPath, staging, domain, certChainPemLoc, privateKeyPemLoc);
     }
 
     public static void deactivateAccount(AcmeClient acmeClient, File letsEncryptPath, boolean staging) throws IOException {
         AcmeAccount acmeAccount = getAccount(letsEncryptPath);
-        LOGGER.log(INFO, "Deactivating {0} Let's Encrypt account", (staging ? "staging" : "production"));
+        LOGGER.infof("Deactivating %s Let's Encrypt account", (staging ? "staging" : "production"));
         acmeClient.deactivateAccount(acmeAccount, staging);
 
-        LOGGER.log(INFO, "Removing account file from {0}", letsEncryptPath);
+        LOGGER.infof("Removing account file from %s", letsEncryptPath);
 
         java.nio.file.Path accountPath = Paths.get(letsEncryptPath + "/account.json");
         Files.deleteIfExists(accountPath);
@@ -246,16 +243,16 @@ public static void deactivateAccount(AcmeClient acmeClient, File letsEncryptPath
 
     public static void adjustPermissions(File certFile, File keyFile) {
         if (!certFile.setReadable(true, false)) {
-            LOGGER.log(ERROR, "Failed to set certificate file readable");
+            LOGGER.error("Failed to set certificate file readable");
         }
         if (!certFile.setWritable(true, true)) {
-            LOGGER.log(ERROR, "Failed to set certificate file as not writable");
+            LOGGER.error("Failed to set certificate file as not writable");
         }
         if (!keyFile.setReadable(true, false)) {
-            LOGGER.log(ERROR, "Failed to set key file as readable");
+            LOGGER.error("Failed to set key file as readable");
         }
         if (!keyFile.setWritable(true, true)) {
-            LOGGER.log(ERROR, "Failed to set key file as not writable");
+            LOGGER.error("Failed to set key file as not writable");
         }
     }
 }
diff --git a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptIssueCommand.java b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptIssueCommand.java
index 8f1308317ec..b55c26c48d8 100644
--- a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptIssueCommand.java
+++ b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptIssueCommand.java
@@ -7,10 +7,11 @@
 import static io.quarkus.tls.cli.letsencrypt.LetsEncryptHelpers.adjustPermissions;
 import static io.quarkus.tls.cli.letsencrypt.LetsEncryptHelpers.createAccount;
 import static io.quarkus.tls.cli.letsencrypt.LetsEncryptHelpers.issueCertificate;
-import static java.lang.System.Logger.Level.INFO;
 
 import java.util.concurrent.Callable;
 
+import org.jboss.logging.Logger;
+
 import picocli.CommandLine;
 
 @CommandLine.Command(name = "issue-certificate", mixinStandardHelpOptions = true, description = "Issue a certificate from let's encrypt. This command runs the HTTP 01 challenge of let's encrypt. "
@@ -18,7 +19,7 @@
         "Make sure the application is running before running this command.")
 public class LetsEncryptIssueCommand implements Callable<Integer> {
 
-    static System.Logger LOGGER = System.getLogger("lets-encrypt-issue");
+    static Logger LOGGER = Logger.getLogger(LetsEncryptIssueCommand.class);
 
     @CommandLine.Option(names = { "-d",
             "--domain" }, description = "The domain for which the certificate will be generated", required = true)
@@ -56,20 +57,19 @@ public Integer call() throws Exception {
         // Step 0 - Verification
         // - Make sure the .letsencrypt directory exists
         if (!LETS_ENCRYPT_DIR.exists()) {
-            LOGGER.log(System.Logger.Level.ERROR,
+            LOGGER.error(
                     "The .letsencrypt directory does not exist, please run the `quarkus tls letsencrypt prepare` command first");
             return 1;
         }
         // - Make sure the cert and key files exist
         if (!CERT_FILE.isFile() || !KEY_FILE.isFile()) {
-            LOGGER.log(System.Logger.Level.ERROR,
+            LOGGER.error(
                     "The certificate and key files do not exist, please run the `quarkus tls letsencrypt prepare` command first");
             return 1;
         }
         // - Make sure the .env file exists
         if (!DOT_ENV_FILE.isFile()) {
-            LOGGER.log(System.Logger.Level.ERROR,
-                    "The .env file does not exist, please run the `quarkus tls letsencrypt prepare` command first");
+            LOGGER.error("The .env file does not exist, please run the `quarkus tls letsencrypt prepare` command first");
             return 1;
         }
         // - Make sure application is running
@@ -81,14 +81,14 @@ public Integer call() throws Exception {
         createAccount(client, LETS_ENCRYPT_DIR.getAbsolutePath(), staging, email);
 
         // Step 2 - run the challenge to obtain first certificate
-        LOGGER.log(INFO, "\uD83D\uDD35 Requesting initial certificate from {0} Let's Encrypt", (staging ? "staging" : ""));
+        LOGGER.infof("\uD83D\uDD35 Requesting initial certificate from %s Let's Encrypt", (staging ? "staging" : ""));
         issueCertificate(client, LETS_ENCRYPT_DIR, staging, domain, CERT_FILE, KEY_FILE);
         adjustPermissions(CERT_FILE, KEY_FILE);
 
         // Step 3 - Reload certificate
         client.certificateChainAndKeyAreReady();
 
-        LOGGER.log(INFO, " Successfully obtained certificate for {0}", domain);
+        LOGGER.infof(" Successfully obtained certificate for %s", domain);
 
         return 0;
     }
diff --git a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptPrepareCommand.java b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptPrepareCommand.java
index cea61fdd903..1ddc9c25dd5 100644
--- a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptPrepareCommand.java
+++ b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptPrepareCommand.java
@@ -14,6 +14,8 @@
 import java.util.List;
 import java.util.concurrent.Callable;
 
+import org.jboss.logging.Logger;
+
 import io.smallrye.certs.CertificateGenerator;
 import io.smallrye.certs.CertificateRequest;
 import io.smallrye.certs.Format;
@@ -23,7 +25,7 @@
         + " Make sure to restart the application after having run this command.")
 public class LetsEncryptPrepareCommand implements Callable<Integer> {
 
-    static System.Logger LOGGER = System.getLogger("lets-encrypt-prepare");
+    static Logger LOGGER = Logger.getLogger(LetsEncryptPrepareCommand.class);
 
     @CommandLine.Option(names = { "-d",
             "--domain" }, description = "The domain for which the certificate will be generated", required = true)
@@ -38,7 +40,7 @@ public Integer call() throws Exception {
         // Step 1 - Create .letsencrypt directory
         if (!LETS_ENCRYPT_DIR.exists()) {
             if (LETS_ENCRYPT_DIR.mkdir()) {
-                LOGGER.log(System.Logger.Level.INFO, " Created .letsencrypt directory: {0}",
+                LOGGER.infof(" Created .letsencrypt directory: %s",
                         LETS_ENCRYPT_DIR.getAbsolutePath());
             }
         }
@@ -53,7 +55,7 @@ public Integer call() throws Exception {
                 existing.checkValidity();
                 certExistingAndStillValid = true;
             } catch (Exception e) {
-                LOGGER.log(System.Logger.Level.INFO, "\uFE0F The existing certificate is expired, regenerating it...");
+                LOGGER.info("\uFE0F The existing certificate is expired, regenerating it...");
             }
         }
 
@@ -68,7 +70,7 @@ public Integer call() throws Exception {
                     .withName("lets-encrypt");
             generator.generate(request);
         } else {
-            LOGGER.log(System.Logger.Level.INFO, " Certificate already exists and is still valid: {0}",
+            LOGGER.infof(" Certificate already exists and is still valid: %s",
                     CERT_FILE.getAbsolutePath());
         }
 
@@ -88,9 +90,9 @@ public Integer call() throws Exception {
         addOrReplaceProperty(dotEnvContent, prefix + ".key-store.pem.acme.key", KEY_FILE.getAbsolutePath());
 
         Files.write(DOT_ENV_FILE.toPath(), dotEnvContent);
-        LOGGER.log(System.Logger.Level.INFO, " .env file configured for Let's Encrypt: {0}", DOT_ENV_FILE.getAbsolutePath());
-        LOGGER.log(System.Logger.Level.INFO,
-                "\uFE0F Start the application and run `quarkus tls lets-encrypt issue-certificate --domain={0}{1}` to complete the challenge",
+        LOGGER.infof(" .env file configured for Let's Encrypt: %s", DOT_ENV_FILE.getAbsolutePath());
+        LOGGER.infof(
+                "\uFE0F Start the application and run `quarkus tls lets-encrypt issue-certificate --domain=%s%s` to complete the challenge",
                 domain,
                 tlsConfigurationName != null ? " -tls-configuration-name=" + tlsConfigurationName : "");
         return 0;
diff --git a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptRenewCommand.java b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptRenewCommand.java
index e34717fc6c0..1025697824f 100644
--- a/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptRenewCommand.java
+++ b/extensions/tls-registry/cli/src/main/java/io/quarkus/tls/cli/letsencrypt/LetsEncryptRenewCommand.java
@@ -5,17 +5,18 @@
 import static io.quarkus.tls.cli.letsencrypt.LetsEncryptConstants.KEY_FILE;
 import static io.quarkus.tls.cli.letsencrypt.LetsEncryptConstants.LETS_ENCRYPT_DIR;
 import static io.quarkus.tls.cli.letsencrypt.LetsEncryptHelpers.*;
-import static java.lang.System.Logger.Level.INFO;
 
 import java.util.concurrent.Callable;
 
+import org.jboss.logging.Logger;
+
 import picocli.CommandLine;
 
 @CommandLine.Command(name = "renew-certificate", mixinStandardHelpOptions = true, description = "Renew a Let's Encrypt. This command re-runs the HTTP 01 challenge of let's encrypt to retrieve a new certificate. "
         + "Make sure the application is running before running this command.")
 public class LetsEncryptRenewCommand implements Callable<Integer> {
 
-    static System.Logger LOGGER = System.getLogger("lets-encrypt-issue");
+    static Logger LOGGER = Logger.getLogger(LetsEncryptRenewCommand.class);
 
     @CommandLine.Option(names = { "-d",
             "--domain" }, description = "The domain for which the certificate will be generated", required = true)
@@ -48,20 +49,19 @@ public Integer call() throws Exception {
         // Step 0 - Verification
         // - Make sure the .letsencrypt directory exists
         if (!LETS_ENCRYPT_DIR.exists()) {
-            LOGGER.log(System.Logger.Level.ERROR,
+            LOGGER.error(
                     "The .letsencrypt directory does not exist, please run the `quarkus tls letsencrypt prepare` command first");
             return 1;
         }
         // - Make sure the cert and key files exist
         if (!CERT_FILE.isFile() || !KEY_FILE.isFile()) {
-            LOGGER.log(System.Logger.Level.ERROR,
+            LOGGER.error(
                     "The certificate and key files do not exist, please run the `quarkus tls letsencrypt prepare` command first");
             return 1;
         }
         // - Make sure the .env file exists
         if (!DOT_ENV_FILE.isFile()) {
-            LOGGER.log(System.Logger.Level.ERROR,
-                    "The .env file does not exist, please run the `quarkus tls letsencrypt prepare` command first");
+            LOGGER.error("The .env file does not exist, please run the `quarkus tls letsencrypt prepare` command first");
             return 1;
         }
         // - Make sure application is running
@@ -76,7 +76,7 @@ public Integer call() throws Exception {
         // Step 2 - Reload certificate
         client.certificateChainAndKeyAreReady();
 
-        LOGGER.log(INFO, " Successfully renewed certificate for {0}", domain);
+        LOGGER.infof(" Successfully renewed certificate for %s", domain);
 
         return 0;
     }
diff --git a/extensions/tls-registry/cli/src/main/resources/logging.properties b/extensions/tls-registry/cli/src/main/resources/logging.properties
new file mode 100644
index 00000000000..09dbd804804
--- /dev/null
+++ b/extensions/tls-registry/cli/src/main/resources/logging.properties
@@ -0,0 +1,16 @@
+# Root logger
+logger.level=INFO
+logger.handlers=CONSOLE
+
+# Console handler
+handler.CONSOLE=org.jboss.logmanager.handlers.ConsoleHandler
+handler.CONSOLE.properties=autoFlush,target,formatter
+handler.CONSOLE.autoFlush=true
+handler.CONSOLE.target=SYSTEM_OUT
+handler.CONSOLE.level=INFO
+handler.CONSOLE.formatter=PATTERN
+
+# Pattern formatter
+formatter.PATTERN=org.jboss.logmanager.formatters.PatternFormatter
+formatter.PATTERN.properties=pattern
+formatter.PATTERN.pattern=%s%n
diff --git a/extensions/tls-registry/runtime/src/main/resources/META-INF/quarkus-extension.yaml b/extensions/tls-registry/runtime/src/main/resources/META-INF/quarkus-extension.yaml
index 43b04fda933..e055cc736e0 100644
--- a/extensions/tls-registry/runtime/src/main/resources/META-INF/quarkus-extension.yaml
+++ b/extensions/tls-registry/runtime/src/main/resources/META-INF/quarkus-extension.yaml
@@ -9,4 +9,4 @@ metadata:
   config:
   - "quarkus.tls."
   cli-plugins:
-  - "tls: ${project.groupId}:quarkus-tls-registry-cli:${project.version}"
+  - "tls: ${project.groupId}:quarkus-tls-registry-cli:${project.version}@jbang"
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Annotations.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Annotations.java
index 204d8892095..72e829ebf47 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Annotations.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Annotations.java
@@ -14,6 +14,7 @@
 import java.util.function.Function;
 
 import org.jboss.jandex.AnnotationInstance;
+import org.jboss.jandex.AnnotationInstanceEquivalenceProxy;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationTarget.Kind;
 import org.jboss.jandex.DotName;
@@ -201,6 +202,22 @@ public static Collection<AnnotationInstance> onlyRuntimeVisible(Collection<Annot
         return result;
     }
 
+    /**
+     * Returns a list of annotations created out of the given set such that the result does not have
+     * annotations that are identical except of the {@linkplain AnnotationInstance#target() annotation target}.
+     */
+    public static List<AnnotationInstance> uniqueAnnotations(Set<AnnotationInstance> annotations) {
+        Set<AnnotationInstanceEquivalenceProxy> proxies = new HashSet<>();
+        for (AnnotationInstance annotation : annotations) {
+            proxies.add(annotation.createEquivalenceProxy());
+        }
+        List<AnnotationInstance> result = new ArrayList<>(proxies.size());
+        for (AnnotationInstanceEquivalenceProxy proxy : proxies) {
+            result.add(proxy.get());
+        }
+        return result;
+    }
+
     public static org.jboss.jandex.AnnotationInstance jandexAnnotation(Annotation annotation) {
         Class<? extends Annotation> annotationType = annotationType(annotation);
 
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/AnnotationsTransformationContext.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/AnnotationsTransformationContext.java
index 1faa971a8a5..a17d4615ea2 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/AnnotationsTransformationContext.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/AnnotationsTransformationContext.java
@@ -82,7 +82,7 @@ private Collection<AnnotationInstance> getAllAnnotationForTarget(AnnotationTarge
         // Jandex overlay in compatible mode won't allow us to query for METHOD_PARAMETER
         // hence if the "target" is method param, we query whole method and filter it
         if (AnnotationTarget.Kind.METHOD_PARAMETER.equals(target.kind())) {
-            return Annotations.getParameterAnnotations(at -> annotationStore.getAnnotations(at),
+            return Annotations.getParameterAnnotations(annotationStore::getAnnotations,
                     target.asMethodParameter().method(), target.asMethodParameter().position());
         } else {
             return annotationStore.getAnnotations(target);
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanGenerator.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanGenerator.java
index c301f5779c9..12fa2991ec4 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanGenerator.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanGenerator.java
@@ -1,5 +1,6 @@
 package io.quarkus.arc.processor;
 
+import static io.quarkus.arc.processor.Annotations.uniqueAnnotations;
 import static io.quarkus.arc.processor.IndexClassLookupUtils.getClassByName;
 import static org.jboss.jandex.gizmo2.Jandex2Gizmo.classDescOf;
 import static org.jboss.jandex.gizmo2.Jandex2Gizmo.fieldDescOf;
@@ -445,42 +446,34 @@ protected void generateConstructor(ClassCreator cc, BeanInfo bean,
 
                 // Bean types
                 RuntimeTypeCreator rttc = RuntimeTypeCreator.of(bc).withTCCL(tccl);
-                Expr typesArray = bc.newArray(Object.class, bean.getTypes()
-                        .stream()
-                        .map(type -> {
-                            try {
-                                return rttc.create(type);
-                            } catch (IllegalArgumentException e) {
-                                throw new IllegalStateException("Unable to construct type for " + bean + ": " + e.getMessage());
-                            }
-                        })
-                        .toList());
-                bc.set(cc.this_().field(beanTypesField), bc.invokeStatic(MethodDescs.SETS_OF, typesArray));
+                Expr typesSet = bc.setOf(bean.getTypes().stream().toList(), type -> {
+                    try {
+                        return rttc.create(type);
+                    } catch (IllegalArgumentException e) {
+                        throw new IllegalStateException("Unable to construct type for " + bean + ": " + e.getMessage());
+                    }
+                });
+                bc.set(cc.this_().field(beanTypesField), typesSet);
 
                 // Qualifiers
                 if (!bean.getQualifiers().isEmpty() && !bean.hasDefaultQualifiers()) {
-                    Expr qualifiersArray = bc.newArray(Object.class, bean.getQualifiers()
-                            .stream()
-                            .map(qualifier -> {
-                                BuiltinQualifier builtinQualifier = BuiltinQualifier.of(qualifier);
-                                if (builtinQualifier != null) {
-                                    return builtinQualifier.getLiteralInstance();
-                                } else {
-                                    ClassInfo qualifierClass = bean.getDeployment().getQualifier(qualifier.name());
-                                    return annotationLiterals.create(bc, qualifierClass, qualifier);
-                                }
-                            })
-                            .toList());
-                    bc.set(cc.this_().field(qualifiersField), bc.invokeStatic(MethodDescs.SETS_OF, qualifiersArray));
+                    Expr qualifiersSet = bc.setOf(uniqueAnnotations(bean.getQualifiers()), qualifier -> {
+                        BuiltinQualifier builtinQualifier = BuiltinQualifier.of(qualifier);
+                        if (builtinQualifier != null) {
+                            return builtinQualifier.getLiteralInstance();
+                        } else {
+                            ClassInfo qualifierClass = bean.getDeployment().getQualifier(qualifier.name());
+                            return annotationLiterals.create(bc, qualifierClass, qualifier);
+                        }
+                    });
+                    bc.set(cc.this_().field(qualifiersField), qualifiersSet);
                 }
 
                 // Stereotypes
                 if (!bean.getStereotypes().isEmpty()) {
-                    Expr stereotypesArray = bc.newArray(Object.class, bean.getStereotypes()
-                            .stream()
-                            .map(stereotype -> Const.of(classDescOf(stereotype.getTarget())))
-                            .toList());
-                    bc.set(cc.this_().field(stereotypesField), bc.invokeStatic(MethodDescs.SETS_OF, stereotypesArray));
+                    Expr stereotypesSet = bc.setOf(bean.getStereotypes(),
+                            stereotype -> Const.of(classDescOf(stereotype.getTarget())));
+                    bc.set(cc.this_().field(stereotypesField), stereotypesSet);
                 }
 
                 int paramIdx = 0;
@@ -715,19 +708,16 @@ private void generateCreateForClassBean(ClassCreator cc, BeanInfo bean,
             }));
 
             // Interceptor bindings
-            LocalVar bindingsArray = bc.localVar("bindings",
-                    bc.newEmptyArray(Object.class, aroundConstructInterception.bindings.size()));
-            int bindingsIndex = 0;
-            for (AnnotationInstance binding : aroundConstructInterception.bindings) {
-                // Create annotation literals first
+            List<AnnotationInstance> bindings = uniqueAnnotations(aroundConstructInterception.bindings);
+            LocalVar bindingsSet = bc.localVar("bindings", bc.setOf(bindings, binding -> {
                 ClassInfo bindingClass = bean.getDeployment().getInterceptorBinding(binding.name());
-                bc.set(bindingsArray.elem(bindingsIndex++), annotationLiterals.create(bc, bindingClass, binding));
-            }
+                return annotationLiterals.create(bc, bindingClass, binding);
+            }));
             // ResultHandle of Object[] holding all constructor args
             LocalVar ctorArgsArray = bc.localVar("ctorArgs", bc.newArray(Object.class, injectableCtorParams));
             LocalVar invocationContext = bc.localVar("invocationContext", bc.invokeStatic(
                     MethodDescs.INVOCATION_CONTEXTS_AROUND_CONSTRUCT, constructor, ctorArgsArray, aroundConstructs,
-                    func, bc.invokeStatic(MethodDescs.SETS_OF, bindingsArray)));
+                    func, bindingsSet));
             instance = bc.localVar("instance", Const.ofNull(providerType.classDesc()));
             bc.try_(tc -> {
                 tc.body(b1 -> {
@@ -918,20 +908,14 @@ void generate(BlockCreator bc, Var instance) {
             }));
 
             // Interceptor bindings
-            LocalVar bindingsArray = bc.localVar("bindings",
-                    bc.newEmptyArray(Object.class, postConstructInterception.bindings.size()));
-            int bindingsIndex = 0;
-            for (AnnotationInstance binding : postConstructInterception.bindings) {
-                // Create annotation literals first
+            List<AnnotationInstance> bindings = uniqueAnnotations(postConstructInterception.bindings);
+            LocalVar bindingsSet = bc.localVar("bindings", bc.setOf(bindings, binding -> {
                 ClassInfo bindingClass = bean.getDeployment().getInterceptorBinding(binding.name());
-                bc.set(bindingsArray.elem(bindingsIndex++),
-                        annotationLiterals.create(bc, bindingClass, binding));
-            }
-
+                return annotationLiterals.create(bc, bindingClass, binding);
+            }));
             // InvocationContextImpl.postConstruct(instance,postConstructs).proceed()
-            LocalVar invocationContext = bc.localVar("invocationContext",
-                    bc.invokeStatic(MethodDescs.INVOCATION_CONTEXTS_POST_CONSTRUCT, instance, postConstructs,
-                            bc.invokeStatic(MethodDescs.SETS_OF, bindingsArray), runnable));
+            LocalVar invocationContext = bc.localVar("invocationContext", bc.invokeStatic(
+                    MethodDescs.INVOCATION_CONTEXTS_POST_CONSTRUCT, instance, postConstructs, bindingsSet, runnable));
             bc.try_(tc -> {
                 tc.body(b1 -> {
                     b1.invokeInterface(MethodDesc.of(InvocationContext.class, "proceed", Object.class),
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Decorators.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Decorators.java
index 5dd691f766a..d2ec49416c8 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Decorators.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Decorators.java
@@ -117,19 +117,36 @@ static DecoratorInfo createDecorator(ClassInfo decoratorClass, BeanDeployment be
         }
 
         if (Modifier.isAbstract(decoratorClass.flags())) {
-            // TODO this check is not precise: we check that decorators do not declare _any_ abstract methods,
-            //  but the spec says that decorators may not declare abstract methods that do not belong
-            //  to a decorated type
-            //  also, we only check methods declared on the decorator class itself, not inherited methods
-            List<MethodInfo> abstractMethods = new ArrayList<>();
-            for (MethodInfo method : decoratorClass.methods()) {
-                if (Modifier.isAbstract(method.flags())) {
-                    abstractMethods.add(method);
+            JandexTypeSystem ts = JandexTypeSystem.of(beanDeployment.getBeanArchiveIndex());
+
+            // 1. collect all abstract methods from decorated types
+            Set<JandexTypeSystem.MethodKey> abstractMethodsOnDecoratedTypes = new HashSet<>();
+            for (Type decoratedType : decoratedTypes) {
+                abstractMethodsOnDecoratedTypes.addAll(ts.methods(decoratedType, MethodInfo::isAbstract));
+            }
+
+            Set<JandexTypeSystem.MethodKey> badAbstractMethods = new HashSet<>();
+
+            // 2. for each abstract method from classes (not interfaces, those are decorated types)
+            for (Type superclassType : ts.typeWithSuperTypes(Types.getProviderType(decoratorClass), true)) {
+                // 3. verify that it is also present on at least one decorated type
+                for (JandexTypeSystem.MethodKey method : ts.methods(superclassType, MethodInfo::isAbstract)) {
+                    if (!abstractMethodsOnDecoratedTypes.contains(method)) {
+                        badAbstractMethods.add(method);
+                    }
                 }
             }
-            if (!abstractMethods.isEmpty()) {
-                throw new DefinitionException("An abstract decorator " + decoratorClass
-                        + " declares abstract methods: " + abstractMethods);
+
+            if (!badAbstractMethods.isEmpty()) {
+                StringBuilder message = new StringBuilder("Abstract decorator ")
+                        .append(decoratorClass.name())
+                        .append(" declares abstract method(s) not present on decorated interface(s):\n");
+                for (JandexTypeSystem.MethodKey method : badAbstractMethods) {
+                    message.append("\t- ");
+                    method.appendTo(message);
+                    message.append("\n");
+                }
+                throw new DefinitionException(message.toString());
             }
         }
 
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/JandexTypeSystem.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/JandexTypeSystem.java
new file mode 100644
index 00000000000..80b9c0c3fe5
--- /dev/null
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/JandexTypeSystem.java
@@ -0,0 +1,294 @@
+package io.quarkus.arc.processor;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+import org.jboss.jandex.ArrayType;
+import org.jboss.jandex.ClassInfo;
+import org.jboss.jandex.ClassType;
+import org.jboss.jandex.DotName;
+import org.jboss.jandex.IndexView;
+import org.jboss.jandex.MethodInfo;
+import org.jboss.jandex.ParameterizedType;
+import org.jboss.jandex.Type;
+import org.jboss.jandex.TypeVariable;
+import org.jboss.jandex.WildcardType;
+
+// first attempt at creating a type system API for Jandex, includes the bare minimum for validating decorators
+// it should be replaced by a proper API in Jandex one day, see https://github.com/smallrye/jandex/issues/625
+final class JandexTypeSystem {
+    private final IndexView index;
+
+    static JandexTypeSystem of(IndexView index) {
+        Objects.requireNonNull(index);
+        return new JandexTypeSystem(index);
+    }
+
+    private JandexTypeSystem(IndexView index) {
+        this.index = index;
+    }
+
+    /**
+     * Returns the given {@code type} and all its supertypes. In case a supertype is parameterized,
+     * the type parameters of the supertype's declaration are replaced by the type arguments
+     * of the supertype.
+     * <p>
+     * The result order is:
+     * <ol>
+     * <li>the given {@code type} (always)</li>
+     * <li>all superclass types in the bottom-up order (if the given {@code type} is a class type)</li>
+     * <li>superinterface types, in an unspecified order (if {@code skipInterfaces == false})</li>
+     * </ol>
+     */
+    List<Type> typeWithSuperTypes(Type type, boolean skipInterfaces) {
+        Objects.requireNonNull(type);
+        if (type.kind() != Type.Kind.CLASS && type.kind() != Type.Kind.PARAMETERIZED_TYPE) {
+            throw new IllegalArgumentException("Type must be class or parameterized, got " + type.kind() + ": " + type);
+        }
+
+        List<Type> result = new ArrayList<>();
+
+        result.add(type);
+        ClassInfo clazz = requireClass(type);
+        Function<String, Type> substitution = createSubstitution(clazz, type);
+
+        if (!clazz.isInterface()) {
+            while (!clazz.name().equals(DotName.OBJECT_NAME)) {
+                type = substituteTypeVariables(clazz.superClassType(), substitution);
+                result.add(type);
+                clazz = requireClass(type);
+                substitution = createSubstitution(clazz, type);
+            }
+        }
+
+        // at the moment, `result` contains the original type and all its superclass types
+        // (note that `result` contains only the original type if it is an interface type)
+
+        if (skipInterfaces) {
+            return result;
+        }
+
+        // it is enough to process each interface exactly once, because a type in Java
+        // may not inherit from multiple different instantiations of the same generic type
+        Set<DotName> seen = new HashSet<>();
+        Deque<Type> worklist = new ArrayDeque<>(result);
+        while (!worklist.isEmpty()) {
+            Type item = worklist.removeFirst();
+            clazz = requireClass(item);
+            substitution = createSubstitution(clazz, item);
+
+            for (Type interfaceType : clazz.interfaceTypes()) {
+                if (seen.add(interfaceType.name())) {
+                    interfaceType = substituteTypeVariables(interfaceType, substitution);
+                    result.add(interfaceType);
+                    worklist.add(interfaceType);
+                }
+            }
+        }
+
+        return result;
+    }
+
+    record MethodKey(String name, List<Type> parameterTypes, Type returnType) {
+        public void appendTo(StringBuilder str) {
+            str.append(returnType).append(" ").append(name).append("(");
+            boolean first = true;
+            for (Type parameterType : parameterTypes) {
+                if (!first) {
+                    str.append(", ");
+                }
+                str.append(parameterType);
+                first = false;
+            }
+            str.append(")");
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder str = new StringBuilder();
+            appendTo(str);
+            return str.toString();
+        }
+    }
+
+    /**
+     * Returns all methods declared directly in the class referred to by the given {@code type}.
+     * If the given {@code type} is a parameterized type, the class's type parameters in method
+     * signatures are replaced by the type arguments in the given {@code type}.
+     * <p>
+     * Methods that do not pass the given {@code filter} are omitted.
+     */
+    List<MethodKey> methods(Type type, Predicate<MethodInfo> filter) {
+        ClassInfo clazz = requireClass(type);
+        Function<String, Type> substitution = createSubstitution(clazz, type);
+
+        List<MethodInfo> methods = clazz.methods();
+        List<MethodKey> result = new ArrayList<>(methods.size());
+        for (MethodInfo method : methods) {
+            if (!filter.test(method)) {
+                continue;
+            }
+            // we ignore method type parameters here, though there's not much we can do
+            Type returnType = substituteTypeVariables(method.returnType(), substitution);
+            Type[] parameterTypes = new Type[method.parametersCount()];
+            for (int i = 0; i < method.parametersCount(); i++) {
+                parameterTypes[i] = substituteTypeVariables(method.parameterType(i), substitution);
+            }
+            result.add(new MethodKey(method.name(), Arrays.asList(parameterTypes), returnType));
+        }
+        return result;
+    }
+
+    private static final Type ERASURE = ClassType.create("ERASURE PLACEHOLDER");
+
+    private Function<String, Type> createSubstitution(ClassInfo declaration, Type type) {
+        if (!declaration.name().equals(type.name())) {
+            throw new IllegalArgumentException("Type must refer to the given declaration, got "
+                    + declaration.name() + " and " + type);
+        }
+
+        if (declaration.typeParameters().isEmpty()) {
+            return ignored -> null;
+        }
+        if (type.kind() != Type.Kind.PARAMETERIZED_TYPE) {
+            return ignored -> ERASURE;
+        }
+
+        List<TypeVariable> typeParameters = declaration.typeParameters();
+        List<Type> typeArguments = type.asParameterizedType().arguments();
+        if (typeParameters.size() != typeArguments.size()) {
+            // this branch is never taken when types come from actually compiled class files
+            throw new IllegalArgumentException("Declaration has " + typeParameters.size()
+                    + " type parameters, but its type use has " + typeArguments.size() + " type arguments");
+        }
+
+        if (typeParameters.isEmpty()) {
+            return ignored -> null;
+        } else if (typeParameters.size() == 1) {
+            String typeParamId = typeParameters.get(0).identifier();
+            Type typeArg = typeArguments.get(0);
+            return id -> id.equals(typeParamId) ? typeArg : null;
+        } else if (typeParameters.size() == 2) {
+            String typeParamId1 = typeParameters.get(0).identifier();
+            Type typeArg1 = typeArguments.get(0);
+            String typeParamId2 = typeParameters.get(1).identifier();
+            Type typeArg2 = typeArguments.get(1);
+            return id -> {
+                if (id.equals(typeParamId1)) {
+                    return typeArg1;
+                } else if (id.equals(typeParamId2)) {
+                    return typeArg2;
+                } else {
+                    return null;
+                }
+            };
+        } else {
+            Map<String, Type> data = new HashMap<>((int) (typeParameters.size() * 1.5));
+            for (int i = 0; i < typeParameters.size(); i++) {
+                data.put(typeParameters.get(i).identifier(), typeArguments.get(i));
+            }
+            return data::get;
+        }
+    }
+
+    /**
+     * Returns this type after performing a type variable substitution.
+     * <p>
+     * Type variables are substituted for other types provided by the given {@code substitution} function.
+     * The function is supposed to return another type for a given type variable identifier.
+     * If the substitution function returns {@code null} for some type variable identifier,
+     * no substitution happens and the type variable is used unmodified. If the substitution function
+     * returns {@link #ERASURE} for some type variable identifier, the type variable is substituted
+     * for its erasure (left-most bound, or {@code java.lang.Object} if unbounded).
+     *
+     * @param substitution the substitution function; must not be {@code null}
+     * @return this type after type variable substitution
+     */
+    private Type substituteTypeVariables(Type type, Function<String, Type> substitution) {
+        Objects.requireNonNull(substitution);
+        Type result = null;
+        switch (type.kind()) {
+            case VOID:
+            case PRIMITIVE:
+            case CLASS:
+                // no need to substitute anything
+                return type;
+            case ARRAY: {
+                ArrayType arrayType = type.asArrayType();
+                Type substitutedConstituent = substituteTypeVariables(arrayType.constituent(), substitution);
+                return ArrayType.create(substitutedConstituent, arrayType.dimensions());
+            }
+            case PARAMETERIZED_TYPE: {
+                ParameterizedType parameterizedType = type.asParameterizedType();
+                List<Type> typeArgs = parameterizedType.arguments();
+                Type[] substitutedTypeArgs = new Type[typeArgs.size()];
+                for (int i = 0; i < typeArgs.size(); i++) {
+                    substitutedTypeArgs[i] = substituteTypeVariables(typeArgs.get(i), substitution);
+                }
+                Type substitutedOwner = parameterizedType.owner() != null
+                        ? substituteTypeVariables(parameterizedType.owner(), substitution)
+                        : null;
+                return ParameterizedType.create(type.name(), substitutedTypeArgs, substitutedOwner);
+            }
+            case TYPE_VARIABLE: {
+                return callSubstitution(type.asTypeVariable().identifier(), type, substitution);
+            }
+            case TYPE_VARIABLE_REFERENCE: {
+                return callSubstitution(type.asTypeVariableReference().identifier(), type, substitution);
+            }
+            case UNRESOLVED_TYPE_VARIABLE: {
+                return callSubstitution(type.asUnresolvedTypeVariable().identifier(), type, substitution);
+            }
+            case WILDCARD_TYPE: {
+                WildcardType wildcardType = type.asWildcardType();
+                boolean isExtends = wildcardType.superBound() == null;
+                boolean hasImplicitObjectBound = isExtends && wildcardType.extendsBound() == ClassType.OBJECT_TYPE;
+                if (hasImplicitObjectBound) {
+                    // no need to substitute anything
+                    return type;
+                } else if (isExtends) {
+                    return WildcardType.createUpperBound(substituteTypeVariables(wildcardType.extendsBound(), substitution));
+                } else {
+                    return WildcardType.createLowerBound(substituteTypeVariables(wildcardType.superBound(), substitution));
+                }
+            }
+            default:
+                throw new IllegalArgumentException("Unsupported type: " + this);
+        }
+    }
+
+    private Type callSubstitution(String typeVarId, Type typeVar, Function<String, Type> substitution) {
+        Type substituted = substitution.apply(typeVarId);
+        if (substituted == null) {
+            return typeVar;
+        } else if (substituted == ERASURE) {
+            // the leftmost bound of a type variable is either a class type or a type variable
+            // since type variable erases to the erasure of its leftmost bound, it is eventually always a class type
+            return ClassType.create(typeVar.name());
+        } else {
+            return substituted;
+        }
+    }
+
+    private ClassInfo requireClass(Type type) {
+        return requireClass(type.name());
+    }
+
+    private ClassInfo requireClass(DotName name) {
+        ClassInfo clazz = index.getClassByName(name);
+        if (clazz == null) {
+            throw new IllegalStateException("Index does not include class " + name);
+        }
+        return clazz;
+    }
+}
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/MethodDescs.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/MethodDescs.java
index 48e13c649ec..9eebdd1211e 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/MethodDescs.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/MethodDescs.java
@@ -44,7 +44,6 @@
 import io.quarkus.arc.impl.MapValueSupplier;
 import io.quarkus.arc.impl.Reflections;
 import io.quarkus.arc.impl.RemovedBeanImpl;
-import io.quarkus.arc.impl.Sets;
 import io.quarkus.gizmo2.desc.ConstructorDesc;
 import io.quarkus.gizmo2.desc.MethodDesc;
 
@@ -161,8 +160,6 @@ private MethodDescs() {
     static final MethodDesc COLLECTIONS_SINGLETON_LIST = MethodDesc.of(Collections.class,
             "singletonList", List.class, Object.class);
 
-    static final MethodDesc SETS_OF = MethodDesc.of(Sets.class, "of", Set.class, Object[].class);
-
     static final MethodDesc ARC_REQUIRE_CONTAINER = MethodDesc.of(Arc.class, "requireContainer", ArcContainer.class);
 
     static final MethodDesc ARC_CONTAINER_BEAN = MethodDesc.of(ArcContainer.class,
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/ObserverGenerator.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/ObserverGenerator.java
index 86529bf0c02..0bb40c42e72 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/ObserverGenerator.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/ObserverGenerator.java
@@ -1,10 +1,10 @@
 package io.quarkus.arc.processor;
 
+import static io.quarkus.arc.processor.Annotations.uniqueAnnotations;
 import static io.quarkus.arc.processor.ClientProxyGenerator.MOCK_FIELD;
 import static org.jboss.jandex.gizmo2.Jandex2Gizmo.classDescOf;
 import static org.jboss.jandex.gizmo2.Jandex2Gizmo.methodDescOf;
 
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.Collection;
@@ -25,7 +25,6 @@
 import jakarta.enterprise.inject.spi.EventContext;
 import jakarta.enterprise.inject.spi.ObserverMethod;
 
-import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 
@@ -303,21 +302,17 @@ private void generateConstructor(ClassCreator cc, ObserverInfo observer,
 
                 bc.set(cc.this_().field(observedTypeField), RuntimeTypeCreator.of(bc).create(observer.getObservedType()));
 
-                Set<AnnotationInstance> qualifiers = observer.getQualifiers();
-                if (!qualifiers.isEmpty()) {
-                    LocalVar qualifiersArray = bc.localVar("qualifiers", bc.newEmptyArray(Annotation.class, qualifiers.size()));
-                    int i = 0;
-                    for (AnnotationInstance qualifier : qualifiers) {
+                if (observedQualifiersField != null) {
+                    Expr set = bc.setOf(uniqueAnnotations(observer.getQualifiers()), qualifier -> {
                         BuiltinQualifier builtin = BuiltinQualifier.of(qualifier);
                         if (builtin != null) {
-                            bc.set(qualifiersArray.elem(i), builtin.getLiteralInstance());
+                            return builtin.getLiteralInstance();
                         } else {
                             ClassInfo qualifierClass = observer.getBeanDeployment().getQualifier(qualifier.name());
-                            bc.set(qualifiersArray.elem(i), annotationLiterals.create(bc, qualifierClass, qualifier));
+                            return annotationLiterals.create(bc, qualifierClass, qualifier);
                         }
-                        i++;
-                    }
-                    bc.set(cc.this_().field(observedQualifiersField), bc.invokeStatic(MethodDescs.SETS_OF, qualifiersArray));
+                    });
+                    bc.set(cc.this_().field(observedQualifiersField), set);
                 }
 
                 if (mockField != null) {
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/SubclassGenerator.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/SubclassGenerator.java
index b026e692e4f..2fa800aba93 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/SubclassGenerator.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/SubclassGenerator.java
@@ -537,19 +537,8 @@ static Function<Set<AnnotationInstanceEquivalenceProxy>, String> createBindingsF
 
         return bindings -> {
             String key = "b" + bindingIdx.i++;
-            Expr value;
-            if (bindings.size() == 1) {
-                value = bc.invokeStatic(MethodDescs.COLLECTIONS_SINGLETON,
-                        bindingsLiterals.computeIfAbsent(bindings.iterator().next(), bindingsLiteralFun));
-            } else {
-                LocalVar bindingsArray = bc.localVar("bindings", bc.newEmptyArray(Object.class, bindings.size()));
-                int bindingsIndex = 0;
-                for (AnnotationInstanceEquivalenceProxy binding : bindings) {
-                    bc.set(bindingsArray.elem(bindingsIndex), bindingsLiterals.computeIfAbsent(binding, bindingsLiteralFun));
-                    bindingsIndex++;
-                }
-                value = bc.invokeStatic(MethodDescs.SETS_OF, bindingsArray);
-            }
+            Expr value = bc.setOf(bindings.stream().toList(),
+                    binding -> bindingsLiterals.computeIfAbsent(binding, bindingsLiteralFun));
             bc.withMap(bindingsMap).put(Const.of(key), value);
             return key;
         };
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/bcextensions/ExtensionInvoker.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/bcextensions/ExtensionInvoker.java
index 72dc4ef9ca3..89e13b306f3 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/bcextensions/ExtensionInvoker.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/bcextensions/ExtensionInvoker.java
@@ -46,7 +46,7 @@ class ExtensionInvoker {
     }
 
     List<ExtensionMethod> findExtensionMethods(DotName annotation) {
-        return extensionsIndex.getAllKnownImplementors(DotNames.BUILD_COMPATIBLE_EXTENSION)
+        return extensionsIndex.getAllKnownImplementations(DotNames.BUILD_COMPATIBLE_EXTENSION)
                 .stream()
                 .flatMap(it -> it.annotationsMap()
                         .getOrDefault(annotation, Collections.emptyList())
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/bcextensions/ExtensionPhaseEnhancement.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/bcextensions/ExtensionPhaseEnhancement.java
index 05933271b4c..ae9424cab11 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/bcextensions/ExtensionPhaseEnhancement.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/bcextensions/ExtensionPhaseEnhancement.java
@@ -116,7 +116,7 @@ private List<org.jboss.jandex.ClassInfo> matchingClasses(org.jboss.jandex.Method
 
             if (withSubtypes) {
                 Collection<org.jboss.jandex.ClassInfo> subtypes = Modifier.isInterface(clazz.flags())
-                        ? index.getAllKnownImplementors(jandexType.name())
+                        ? index.getAllKnownImplementations(jandexType.name())
                         : index.getAllKnownSubclasses(jandexType.name());
                 result.addAll(subtypes);
             }
diff --git a/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/Basics.java b/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/Basics.java
deleted file mode 100644
index 1f4cd9ad16e..00000000000
--- a/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/Basics.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package io.quarkus.arc.processor;
-
-import org.jboss.jandex.DotName;
-
-public final class Basics {
-
-    public static DotName name(Class<?> clazz) {
-        return DotName.createSimple(clazz.getName());
-    }
-
-}
diff --git a/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoInjectionsTest.java b/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoInjectionsTest.java
index fe9167d315c..3909157b02a 100644
--- a/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoInjectionsTest.java
+++ b/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoInjectionsTest.java
@@ -1,6 +1,5 @@
 package io.quarkus.arc.processor;
 
-import static io.quarkus.arc.processor.Basics.name;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.fail;
 
@@ -12,6 +11,7 @@
 import java.util.List;
 
 import org.jboss.jandex.ClassInfo;
+import org.jboss.jandex.ClassType;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.ParameterizedType;
 import org.jboss.jandex.Type;
@@ -32,12 +32,10 @@ public class BeanInfoInjectionsTest {
     public void testInjections() throws IOException {
 
         Index index = Index.of(Foo.class, Bar.class, FooQualifier.class, AbstractList.class, AbstractCollection.class,
-                Collection.class, List.class,
-                Iterable.class, Object.class, String.class);
+                Collection.class, List.class, Iterable.class, Object.class, String.class);
         ClassInfo barClass = index.getClassByName(Bar.class);
-        Type fooType = Type.create(name(Foo.class), Kind.CLASS);
-        Type listStringType = ParameterizedType.create(name(List.class),
-                new Type[] { Type.create(name(String.class), Kind.CLASS) }, null);
+        Type fooType = ClassType.create(Foo.class);
+        Type listStringType = ParameterizedType.builder(List.class).addArgument(ClassType.create(String.class)).build();
 
         BeanDeployment deployment = BeanProcessor.builder().setImmutableBeanArchiveIndex(index).build().getBeanDeployment();
         deployment.registerCustomContexts(Collections.emptyList());
diff --git a/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoQualifiersTest.java b/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoQualifiersTest.java
index 28d7cac0c0c..ba27918e608 100644
--- a/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoQualifiersTest.java
+++ b/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoQualifiersTest.java
@@ -1,6 +1,5 @@
 package io.quarkus.arc.processor;
 
-import static io.quarkus.arc.processor.Basics.name;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
@@ -13,7 +12,6 @@
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget.Kind;
 import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.junit.jupiter.api.Test;
 
@@ -31,16 +29,16 @@ public class BeanInfoQualifiersTest {
     public void testQualifiers() throws IOException {
         Index index = Index.of(Foo.class, Bar.class, FooQualifier.class, AbstractList.class, AbstractCollection.class,
                 List.class, Collection.class, Object.class, String.class, Iterable.class);
-        DotName fooName = name(Foo.class);
-        DotName fooQualifierName = name(FooQualifier.class);
-        ClassInfo fooClass = index.getClassByName(fooName);
+        ClassInfo fooClass = index.getClassByName(Foo.class);
 
         BeanInfo bean = Beans.createClassBean(fooClass,
                 BeanProcessor.builder().setImmutableBeanArchiveIndex(index).build().getBeanDeployment(),
                 null);
 
-        AnnotationInstance requiredFooQualifier = index.getAnnotations(fooQualifierName).stream()
-                .filter(a -> Kind.FIELD.equals(a.target().kind()) && a.target().asField().name().equals("foo")).findFirst()
+        AnnotationInstance requiredFooQualifier = index.getAnnotations(FooQualifier.class)
+                .stream()
+                .filter(a -> Kind.FIELD.equals(a.target().kind()) && a.target().asField().name().equals("foo"))
+                .findFirst()
                 .orElse(null);
 
         assertNotNull(requiredFooQualifier);
diff --git a/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoTypesTest.java b/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoTypesTest.java
index dc8b317d1fc..dda8bb6825f 100644
--- a/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoTypesTest.java
+++ b/independent-projects/arc/processor/src/test/java/io/quarkus/arc/processor/BeanInfoTypesTest.java
@@ -1,6 +1,5 @@
 package io.quarkus.arc.processor;
 
-import static io.quarkus.arc.processor.Basics.name;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
@@ -12,11 +11,10 @@
 import java.util.Set;
 
 import org.jboss.jandex.ClassInfo;
-import org.jboss.jandex.DotName;
+import org.jboss.jandex.ClassType;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.ParameterizedType;
 import org.jboss.jandex.Type;
-import org.jboss.jandex.Type.Kind;
 import org.junit.jupiter.api.Test;
 
 import io.quarkus.arc.processor.types.Bar;
@@ -33,28 +31,31 @@ public class BeanInfoTypesTest {
     public void testResolver() throws IOException {
 
         Index index = Index.of(Foo.class, Bar.class, FooQualifier.class, AbstractList.class, AbstractCollection.class,
-                Collection.class, List.class,
-                Iterable.class, Object.class, String.class);
+                Collection.class, List.class, Iterable.class, Object.class, String.class);
 
         BeanDeployment deployment = BeanProcessor.builder().setImmutableBeanArchiveIndex(index).build().getBeanDeployment();
-        DotName fooName = name(Foo.class);
 
-        ClassInfo fooClass = index.getClassByName(fooName);
+        ClassInfo fooClass = index.getClassByName(Foo.class);
         BeanInfo fooBean = Beans.createClassBean(fooClass, deployment, null);
         Set<Type> types = fooBean.getTypes();
         // Foo, AbstractList<String>, AbstractCollection<String>, List<String>, Collection<String>, Iterable<String>, Object
         assertEquals(7, types.size());
-        assertTrue(types.contains(Type.create(fooName, Kind.CLASS)));
-        assertTrue(types.contains(ParameterizedType.create(name(AbstractList.class),
-                new Type[] { Type.create(name(String.class), Kind.CLASS) }, null)));
-        assertTrue(types.contains(
-                ParameterizedType.create(name(List.class), new Type[] { Type.create(name(String.class), Kind.CLASS) }, null)));
-        assertTrue(types.contains(ParameterizedType.create(name(Collection.class),
-                new Type[] { Type.create(name(String.class), Kind.CLASS) }, null)));
-        assertTrue(types.contains(ParameterizedType.create(name(AbstractCollection.class),
-                new Type[] { Type.create(name(String.class), Kind.CLASS) }, null)));
-        assertTrue(types.contains(ParameterizedType.create(name(Iterable.class),
-                new Type[] { Type.create(name(String.class), Kind.CLASS) }, null)));
+        assertTrue(types.contains(ClassType.create(Foo.class)));
+        assertTrue(types.contains(ParameterizedType.builder(AbstractList.class)
+                .addArgument(ClassType.create(String.class))
+                .build()));
+        assertTrue(types.contains(ParameterizedType.builder(List.class)
+                .addArgument(ClassType.create(String.class))
+                .build()));
+        assertTrue(types.contains(ParameterizedType.builder(Collection.class)
+                .addArgument(ClassType.create(String.class))
+                .build()));
+        assertTrue(types.contains(ParameterizedType.builder(AbstractCollection.class)
+                .addArgument(ClassType.create(String.class))
+                .build()));
+        assertTrue(types.contains(ParameterizedType.builder(Iterable.class)
+                .addArgument(ClassType.create(String.class))
+                .build()));
 
     }
 
diff --git a/independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/Sets.java b/independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/Sets.java
index c32936e145d..00bae2f8ccc 100644
--- a/independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/Sets.java
+++ b/independent-projects/arc/runtime/src/main/java/io/quarkus/arc/impl/Sets.java
@@ -1,36 +1,12 @@
 package io.quarkus.arc.impl;
 
-import java.util.Arrays;
 import java.util.HashSet;
-import java.util.Set;
 
 public final class Sets {
 
     private Sets() {
     }
 
-    /**
-     * Unlike {@link Set#of(Object...)} this method does not throw an {@link IllegalArgumentException} if there are duplicate
-     * elements.
-     *
-     * @param <E>
-     * @param elements
-     * @return the set
-     */
-    @SafeVarargs
-    public static <E> Set<E> of(E... elements) {
-        switch (elements.length) {
-            case 0:
-                return Set.of();
-            case 1:
-                return Set.of(elements[0]);
-            case 2:
-                return elements[0].equals(elements[1]) ? Set.of(elements[0]) : Set.of(elements[0], elements[1]);
-            default:
-                return Set.copyOf(Arrays.asList(elements));
-        }
-    }
-
     public static <E> HashSet<E> singletonHashSet(E element) {
         HashSet<E> result = new HashSet<>();
         result.add(element);
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodTest.java
new file mode 100644
index 00000000000..af6c1008931
--- /dev/null
+++ b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodTest.java
@@ -0,0 +1,77 @@
+package io.quarkus.arc.test.decorators.validation;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import jakarta.annotation.Priority;
+import jakarta.decorator.Decorator;
+import jakarta.decorator.Delegate;
+import jakarta.enterprise.inject.spi.DefinitionException;
+import jakarta.inject.Inject;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.arc.test.ArcTestContainer;
+
+public class AbstractDecoratorDeclaringAbstractMethodTest {
+    @RegisterExtension
+    public ArcTestContainer container = ArcTestContainer.builder()
+            .beanClasses(Converter.class, MyGoodDecorator.class, MyBadDecorator.class)
+            .shouldFail()
+            .build();
+
+    @Test
+    public void trigger() {
+        Throwable error = container.getFailure();
+        assertNotNull(error);
+        assertInstanceOf(DefinitionException.class, error);
+        assertTrue(error.getMessage().contains("declares abstract method(s) not present on decorated interface(s)"));
+        assertTrue(error.getMessage().contains("MyBadDecorator"));
+        assertTrue(error.getMessage().contains("convert3"));
+        assertFalse(error.getMessage().contains("MyGoodDecorator"));
+        assertFalse(error.getMessage().contains("convert1"));
+        assertFalse(error.getMessage().contains("convert2"));
+    }
+
+    interface Converter {
+        String convert1(String value);
+
+        String convert2(String value);
+    }
+
+    // this is OK, the abstract method comes from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyGoodDecorator implements Converter {
+        @Inject
+        @Delegate
+        Converter delegate;
+
+        @Override
+        public String convert1(String value) {
+            return delegate.convert1(value);
+        }
+
+        @Override
+        public abstract String convert2(String value);
+    }
+
+    // this is NOT OK, the abstract method does not come from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyBadDecorator implements Converter {
+        @Inject
+        @Delegate
+        Converter delegate;
+
+        @Override
+        public String convert1(String value) {
+            return delegate.convert1(value);
+        }
+
+        public abstract String convert3(String value);
+    }
+}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodWithGenericsAndRawTypesTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodWithGenericsAndRawTypesTest.java
new file mode 100644
index 00000000000..641116ed201
--- /dev/null
+++ b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodWithGenericsAndRawTypesTest.java
@@ -0,0 +1,77 @@
+package io.quarkus.arc.test.decorators.validation;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import jakarta.annotation.Priority;
+import jakarta.decorator.Decorator;
+import jakarta.decorator.Delegate;
+import jakarta.enterprise.inject.spi.DefinitionException;
+import jakarta.inject.Inject;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.arc.test.ArcTestContainer;
+
+public class AbstractDecoratorDeclaringAbstractMethodWithGenericsAndRawTypesTest {
+    @RegisterExtension
+    public ArcTestContainer container = ArcTestContainer.builder()
+            .beanClasses(Converter.class, MyGoodDecorator.class, MyBadDecorator.class)
+            .shouldFail()
+            .build();
+
+    @Test
+    public void trigger() {
+        Throwable error = container.getFailure();
+        assertNotNull(error);
+        assertInstanceOf(DefinitionException.class, error);
+        assertTrue(error.getMessage().contains("declares abstract method(s) not present on decorated interface(s)"));
+        assertTrue(error.getMessage().contains("MyBadDecorator"));
+        assertTrue(error.getMessage().contains("convert3"));
+        assertFalse(error.getMessage().contains("MyGoodDecorator"));
+        assertFalse(error.getMessage().contains("convert1"));
+        assertFalse(error.getMessage().contains("convert2"));
+    }
+
+    interface Converter<S, T> {
+        T convert1(S value);
+
+        T convert2(S value);
+    }
+
+    // this is OK, the abstract method comes from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyGoodDecorator implements Converter {
+        @Inject
+        @Delegate
+        Converter delegate;
+
+        @Override
+        public Object convert1(Object value) {
+            return delegate.convert1(value);
+        }
+
+        @Override
+        public abstract Object convert2(Object value);
+    }
+
+    // this is NOT OK, the abstract method does not come from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyBadDecorator implements Converter {
+        @Inject
+        @Delegate
+        Converter delegate;
+
+        @Override
+        public Object convert1(Object value) {
+            return delegate.convert1(value);
+        }
+
+        public abstract Object convert3(Object value);
+    }
+}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodWithGenericsAndTypeVariablesTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodWithGenericsAndTypeVariablesTest.java
new file mode 100644
index 00000000000..e8062474ac4
--- /dev/null
+++ b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodWithGenericsAndTypeVariablesTest.java
@@ -0,0 +1,78 @@
+package io.quarkus.arc.test.decorators.validation;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import jakarta.annotation.Priority;
+import jakarta.decorator.Decorator;
+import jakarta.decorator.Delegate;
+import jakarta.enterprise.inject.spi.DefinitionException;
+import jakarta.inject.Inject;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.arc.test.ArcTestContainer;
+
+public class AbstractDecoratorDeclaringAbstractMethodWithGenericsAndTypeVariablesTest {
+    @RegisterExtension
+    public ArcTestContainer container = ArcTestContainer.builder()
+            .beanClasses(Converter.class, MyGoodDecorator.class, MyBadDecorator.class)
+            .shouldFail()
+            .build();
+
+    @Test
+    public void trigger() {
+        Throwable error = container.getFailure();
+        assertNotNull(error);
+        assertInstanceOf(DefinitionException.class, error);
+        System.out.println(error);
+        assertTrue(error.getMessage().contains("declares abstract method(s) not present on decorated interface(s)"));
+        assertTrue(error.getMessage().contains("MyBadDecorator"));
+        assertTrue(error.getMessage().contains("convert3"));
+        assertFalse(error.getMessage().contains("MyGoodDecorator"));
+        assertFalse(error.getMessage().contains("convert1"));
+        assertFalse(error.getMessage().contains("convert2"));
+    }
+
+    interface Converter<S, T> {
+        T convert1(S value);
+
+        T convert2(S value);
+    }
+
+    // this is OK, the abstract method comes from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyGoodDecorator<S, T> implements Converter<S, T> {
+        @Inject
+        @Delegate
+        Converter<S, T> delegate;
+
+        @Override
+        public T convert1(S value) {
+            return delegate.convert1(value);
+        }
+
+        @Override
+        public abstract T convert2(S value);
+    }
+
+    // this is NOT OK, the abstract method does not come from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyBadDecorator<S, T> implements Converter<S, T> {
+        @Inject
+        @Delegate
+        Converter<S, T> delegate;
+
+        @Override
+        public T convert1(S value) {
+            return delegate.convert1(value);
+        }
+
+        public abstract T convert3(S value);
+    }
+}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodWithGenericsTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodWithGenericsTest.java
new file mode 100644
index 00000000000..65b2c947c97
--- /dev/null
+++ b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorDeclaringAbstractMethodWithGenericsTest.java
@@ -0,0 +1,77 @@
+package io.quarkus.arc.test.decorators.validation;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import jakarta.annotation.Priority;
+import jakarta.decorator.Decorator;
+import jakarta.decorator.Delegate;
+import jakarta.enterprise.inject.spi.DefinitionException;
+import jakarta.inject.Inject;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.arc.test.ArcTestContainer;
+
+public class AbstractDecoratorDeclaringAbstractMethodWithGenericsTest {
+    @RegisterExtension
+    public ArcTestContainer container = ArcTestContainer.builder()
+            .beanClasses(Converter.class, MyGoodDecorator.class, MyBadDecorator.class)
+            .shouldFail()
+            .build();
+
+    @Test
+    public void trigger() {
+        Throwable error = container.getFailure();
+        assertNotNull(error);
+        assertInstanceOf(DefinitionException.class, error);
+        assertTrue(error.getMessage().contains("declares abstract method(s) not present on decorated interface(s)"));
+        assertTrue(error.getMessage().contains("MyBadDecorator"));
+        assertTrue(error.getMessage().contains("convert3"));
+        assertFalse(error.getMessage().contains("MyGoodDecorator"));
+        assertFalse(error.getMessage().contains("convert1"));
+        assertFalse(error.getMessage().contains("convert2"));
+    }
+
+    interface Converter<S, T> {
+        T convert1(S value);
+
+        T convert2(S value);
+    }
+
+    // this is OK, the abstract method comes from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyGoodDecorator implements Converter<Integer, String> {
+        @Inject
+        @Delegate
+        Converter<Integer, String> delegate;
+
+        @Override
+        public String convert1(Integer value) {
+            return delegate.convert1(value);
+        }
+
+        @Override
+        public abstract String convert2(Integer value);
+    }
+
+    // this is NOT OK, the abstract method does not come from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyBadDecorator implements Converter<Integer, String> {
+        @Inject
+        @Delegate
+        Converter<Integer, String> delegate;
+
+        @Override
+        public String convert1(Integer value) {
+            return delegate.convert1(value);
+        }
+
+        public abstract String convert3(Integer value);
+    }
+}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodTest.java
new file mode 100644
index 00000000000..e99971df4eb
--- /dev/null
+++ b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodTest.java
@@ -0,0 +1,80 @@
+package io.quarkus.arc.test.decorators.validation;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import jakarta.annotation.Priority;
+import jakarta.decorator.Decorator;
+import jakarta.decorator.Delegate;
+import jakarta.enterprise.inject.spi.DefinitionException;
+import jakarta.inject.Inject;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.arc.test.ArcTestContainer;
+
+public class AbstractDecoratorInheritingAbstractMethodTest {
+    @RegisterExtension
+    public ArcTestContainer container = ArcTestContainer.builder()
+            .beanClasses(Converter.class, MyGoodDecorator.class, MyBadDecorator.class)
+            .shouldFail()
+            .build();
+
+    @Test
+    public void trigger() {
+        Throwable error = container.getFailure();
+        assertNotNull(error);
+        assertInstanceOf(DefinitionException.class, error);
+        assertTrue(error.getMessage().contains("declares abstract method(s) not present on decorated interface(s)"));
+        assertTrue(error.getMessage().contains("MyBadDecorator"));
+        assertTrue(error.getMessage().contains("convert3"));
+        assertFalse(error.getMessage().contains("MyGoodDecorator"));
+        assertFalse(error.getMessage().contains("convert1"));
+        assertFalse(error.getMessage().contains("convert2"));
+    }
+
+    interface Converter {
+        String convert1(String value);
+
+        String convert2(String value);
+    }
+
+    static abstract class GoodAbstractDecorator {
+        abstract String convert2(String value);
+    }
+
+    static abstract class BadAbstractDecorator {
+        abstract String convert3(String value);
+    }
+
+    // this is OK, the abstract method comes from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyGoodDecorator extends GoodAbstractDecorator implements Converter {
+        @Inject
+        @Delegate
+        Converter delegate;
+
+        @Override
+        public String convert1(String value) {
+            return delegate.convert1(value);
+        }
+    }
+
+    // this is NOT OK, the abstract method does not come from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyBadDecorator extends BadAbstractDecorator implements Converter {
+        @Inject
+        @Delegate
+        Converter delegate;
+
+        @Override
+        public String convert1(String value) {
+            return delegate.convert1(value);
+        }
+    }
+}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodWithGenericsAndRawTypesTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodWithGenericsAndRawTypesTest.java
new file mode 100644
index 00000000000..49259b729c3
--- /dev/null
+++ b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodWithGenericsAndRawTypesTest.java
@@ -0,0 +1,80 @@
+package io.quarkus.arc.test.decorators.validation;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import jakarta.annotation.Priority;
+import jakarta.decorator.Decorator;
+import jakarta.decorator.Delegate;
+import jakarta.enterprise.inject.spi.DefinitionException;
+import jakarta.inject.Inject;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.arc.test.ArcTestContainer;
+
+public class AbstractDecoratorInheritingAbstractMethodWithGenericsAndRawTypesTest {
+    @RegisterExtension
+    public ArcTestContainer container = ArcTestContainer.builder()
+            .beanClasses(Converter.class, MyGoodDecorator.class, MyBadDecorator.class)
+            .shouldFail()
+            .build();
+
+    @Test
+    public void trigger() {
+        Throwable error = container.getFailure();
+        assertNotNull(error);
+        assertInstanceOf(DefinitionException.class, error);
+        assertTrue(error.getMessage().contains("declares abstract method(s) not present on decorated interface(s)"));
+        assertTrue(error.getMessage().contains("MyBadDecorator"));
+        assertTrue(error.getMessage().contains("convert3"));
+        assertFalse(error.getMessage().contains("MyGoodDecorator"));
+        assertFalse(error.getMessage().contains("convert1"));
+        assertFalse(error.getMessage().contains("convert2"));
+    }
+
+    interface Converter<S, T> {
+        T convert1(S value);
+
+        T convert2(S value);
+    }
+
+    static abstract class GoodAbstractDecorator {
+        abstract Object convert2(Object value);
+    }
+
+    static abstract class BadAbstractDecorator {
+        abstract Object convert3(Object value);
+    }
+
+    // this is OK, the abstract method comes from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyGoodDecorator extends GoodAbstractDecorator implements Converter {
+        @Inject
+        @Delegate
+        Converter delegate;
+
+        @Override
+        public Object convert1(Object value) {
+            return delegate.convert1(value);
+        }
+    }
+
+    // this is NOT OK, the abstract method does not come from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyBadDecorator extends BadAbstractDecorator implements Converter {
+        @Inject
+        @Delegate
+        Converter delegate;
+
+        @Override
+        public Object convert1(Object value) {
+            return delegate.convert1(value);
+        }
+    }
+}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodWithGenericsAndTypeVariablesTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodWithGenericsAndTypeVariablesTest.java
new file mode 100644
index 00000000000..79f6582fff6
--- /dev/null
+++ b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodWithGenericsAndTypeVariablesTest.java
@@ -0,0 +1,80 @@
+package io.quarkus.arc.test.decorators.validation;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import jakarta.annotation.Priority;
+import jakarta.decorator.Decorator;
+import jakarta.decorator.Delegate;
+import jakarta.enterprise.inject.spi.DefinitionException;
+import jakarta.inject.Inject;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.arc.test.ArcTestContainer;
+
+public class AbstractDecoratorInheritingAbstractMethodWithGenericsAndTypeVariablesTest {
+    @RegisterExtension
+    public ArcTestContainer container = ArcTestContainer.builder()
+            .beanClasses(Converter.class, MyGoodDecorator.class, MyBadDecorator.class)
+            .shouldFail()
+            .build();
+
+    @Test
+    public void trigger() {
+        Throwable error = container.getFailure();
+        assertNotNull(error);
+        assertInstanceOf(DefinitionException.class, error);
+        assertTrue(error.getMessage().contains("declares abstract method(s) not present on decorated interface(s)"));
+        assertTrue(error.getMessage().contains("MyBadDecorator"));
+        assertTrue(error.getMessage().contains("convert3"));
+        assertFalse(error.getMessage().contains("MyGoodDecorator"));
+        assertFalse(error.getMessage().contains("convert1"));
+        assertFalse(error.getMessage().contains("convert2"));
+    }
+
+    interface Converter<S, T> {
+        T convert1(S value);
+
+        T convert2(S value);
+    }
+
+    static abstract class GoodAbstractDecorator<S, T> {
+        abstract T convert2(S value);
+    }
+
+    static abstract class BadAbstractDecorator<S, T> {
+        abstract T convert3(S value);
+    }
+
+    // this is OK, the abstract method comes from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyGoodDecorator<S, T> extends GoodAbstractDecorator<S, T> implements Converter<S, T> {
+        @Inject
+        @Delegate
+        Converter<S, T> delegate;
+
+        @Override
+        public T convert1(S value) {
+            return delegate.convert1(value);
+        }
+    }
+
+    // this is NOT OK, the abstract method does not come from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyBadDecorator<S, T> extends BadAbstractDecorator<S, T> implements Converter<S, T> {
+        @Inject
+        @Delegate
+        Converter<S, T> delegate;
+
+        @Override
+        public T convert1(S value) {
+            return delegate.convert1(value);
+        }
+    }
+}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodWithGenericsTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodWithGenericsTest.java
new file mode 100644
index 00000000000..e45822ca8fc
--- /dev/null
+++ b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorInheritingAbstractMethodWithGenericsTest.java
@@ -0,0 +1,80 @@
+package io.quarkus.arc.test.decorators.validation;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import jakarta.annotation.Priority;
+import jakarta.decorator.Decorator;
+import jakarta.decorator.Delegate;
+import jakarta.enterprise.inject.spi.DefinitionException;
+import jakarta.inject.Inject;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.arc.test.ArcTestContainer;
+
+public class AbstractDecoratorInheritingAbstractMethodWithGenericsTest {
+    @RegisterExtension
+    public ArcTestContainer container = ArcTestContainer.builder()
+            .beanClasses(Converter.class, MyGoodDecorator.class, MyBadDecorator.class)
+            .shouldFail()
+            .build();
+
+    @Test
+    public void trigger() {
+        Throwable error = container.getFailure();
+        assertNotNull(error);
+        assertInstanceOf(DefinitionException.class, error);
+        assertTrue(error.getMessage().contains("declares abstract method(s) not present on decorated interface(s)"));
+        assertTrue(error.getMessage().contains("MyBadDecorator"));
+        assertTrue(error.getMessage().contains("convert3"));
+        assertFalse(error.getMessage().contains("MyGoodDecorator"));
+        assertFalse(error.getMessage().contains("convert1"));
+        assertFalse(error.getMessage().contains("convert2"));
+    }
+
+    interface Converter<S, T> {
+        T convert1(S value);
+
+        T convert2(S value);
+    }
+
+    static abstract class GoodAbstractDecorator<S, T> {
+        abstract T convert2(S value);
+    }
+
+    static abstract class BadAbstractDecorator<S, T> {
+        abstract T convert3(S value);
+    }
+
+    // this is OK, the abstract method comes from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyGoodDecorator extends GoodAbstractDecorator<Integer, String> implements Converter<Integer, String> {
+        @Inject
+        @Delegate
+        Converter<Integer, String> delegate;
+
+        @Override
+        public String convert1(Integer value) {
+            return delegate.convert1(value);
+        }
+    }
+
+    // this is NOT OK, the abstract method does not come from a decorated type
+    @Decorator
+    @Priority(1)
+    static abstract class MyBadDecorator extends BadAbstractDecorator<Integer, String> implements Converter<Integer, String> {
+        @Inject
+        @Delegate
+        Converter<Integer, String> delegate;
+
+        @Override
+        public String convert1(Integer value) {
+            return delegate.convert1(value);
+        }
+    }
+}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorWithAbstractMethodTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorWithAbstractMethodTest.java
deleted file mode 100644
index 7951757a334..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/validation/AbstractDecoratorWithAbstractMethodTest.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package io.quarkus.arc.test.decorators.validation;
-
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.test.ArcTestContainer;
-
-public class AbstractDecoratorWithAbstractMethodTest {
-
-    @RegisterExtension
-    public ArcTestContainer container = ArcTestContainer.builder()
-            .beanClasses(Converter.class, DecoratorWithAbstractMethod.class).shouldFail().build();
-
-    @Test
-    public void testFailure() {
-        assertNotNull(container.getFailure());
-        assertTrue(
-                container.getFailure().getMessage().contains("declares abstract methods:"),
-                container.getFailure().getMessage());
-    }
-
-    interface Converter<T, U> {
-
-        T convert(T value);
-
-    }
-
-    @Priority(1)
-    @Decorator
-    static abstract class DecoratorWithAbstractMethod implements Converter<String, String> {
-
-        @Inject
-        @Delegate
-        Converter<String, String> delegate;
-
-        @Override
-        public String convert(String value) {
-            return delegate.convert(value.trim());
-        }
-
-        // this method is not legal
-        abstract String anotherConvert();
-
-    }
-
-}
diff --git a/independent-projects/bootstrap/runner/src/main/java/io/quarkus/bootstrap/runner/JarResource.java b/independent-projects/bootstrap/runner/src/main/java/io/quarkus/bootstrap/runner/JarResource.java
index ba6423fd62a..631bebfd70f 100644
--- a/independent-projects/bootstrap/runner/src/main/java/io/quarkus/bootstrap/runner/JarResource.java
+++ b/independent-projects/bootstrap/runner/src/main/java/io/quarkus/bootstrap/runner/JarResource.java
@@ -48,7 +48,9 @@ public void init() {
             if (!path.startsWith("/")) {
                 path = '/' + path;
             }
-            URI uri = new URI("file", null, path, null);
+            // we use this particular constructor to work around https://bugs.openjdk.org/browse/JDK-8140634
+            // see https://github.com/quarkusio/quarkus/issues/52292
+            URI uri = new URI("file", null, path, null, null);
             url = new URL((URL) null, uri.toString(), new JarUrlStreamHandler(uri));
         } catch (URISyntaxException | MalformedURLException e) {
             throw new RuntimeException("Unable to create protection domain for " + jarPath, e);
@@ -152,7 +154,9 @@ private static URL getUrl(Path jarPath, String realName) throws MalformedURLExce
             ssp.append(jarUri.getPath());
             ssp.append("!/");
             ssp.append(realName);
-            return new URI(jarUri.getScheme(), ssp.toString(), null).toURL();
+            // we use this particular constructor to work around https://bugs.openjdk.org/browse/JDK-8140634
+            // see https://github.com/quarkusio/quarkus/issues/52292
+            return new URI(jarUri.getScheme(), null, ssp.toString(), null, null).toURL();
         }
     }
 
diff --git a/independent-projects/junit-virtual-threads/pom.xml b/independent-projects/junit-virtual-threads/pom.xml
index b8b63cdab37..68fa05d41df 100644
--- a/independent-projects/junit-virtual-threads/pom.xml
+++ b/independent-projects/junit-virtual-threads/pom.xml
@@ -38,7 +38,7 @@
     <properties>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
-        <compiler.plugin.version>3.14.1</compiler.plugin.version>
+        <compiler.plugin.version>3.15.0</compiler.plugin.version>
         <enforcer.plugin.version>3.2.1</enforcer.plugin.version>
         <surefire.plugin.version>3.5.4</surefire.plugin.version>
         <jandex.version>3.5.3</jandex.version>
diff --git a/independent-projects/parent/pom.xml b/independent-projects/parent/pom.xml
index 0245cc82899..5dcb9d93e5d 100644
--- a/independent-projects/parent/pom.xml
+++ b/independent-projects/parent/pom.xml
@@ -21,7 +21,7 @@
         <version.buildhelper.plugin>3.6.1</version.buildhelper.plugin>
         <version.buildnumber.plugin>3.3.0</version.buildnumber.plugin>
         <version.clean.plugin>3.5.0</version.clean.plugin>
-        <version.compiler.plugin>3.14.1</version.compiler.plugin>
+        <version.compiler.plugin>3.15.0</version.compiler.plugin>
         <version.dependency.plugin>3.8.1</version.dependency.plugin>
         <version.deploy.plugin>3.1.4</version.deploy.plugin>
         <version.enforcer.plugin>3.6.2</version.enforcer.plugin>
diff --git a/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/gradle-kotlin-dsl/base/build-layout.include.qute b/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/gradle-kotlin-dsl/base/build-layout.include.qute
index b0227cf8a47..30a3c7ce930 100644
--- a/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/gradle-kotlin-dsl/base/build-layout.include.qute
+++ b/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/gradle-kotlin-dsl/base/build-layout.include.qute
@@ -33,9 +33,15 @@ dependencies {
     implementation(enforcedPlatform("{it.groupId}:{it.artifactId}:{it.version}"))
     {/if}
 {/each}
+{#if input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-panache-next')}
+    annotationProcessor(enforcedPlatform("$\{quarkusPlatformGroupId}:$\{quarkusPlatformArtifactId}:$\{quarkusPlatformVersion}"))
+{/if}
 {#for dep in dependencies}
     implementation("{dep}")
 {/for}
+{#if input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-panache-next')}
+    annotationProcessor("org.hibernate.orm:hibernate-processor")
+{/if}
     testImplementation("io.quarkus:quarkus-junit")
 {#for dep in test-dependencies}
     testImplementation("{dep}")
diff --git a/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/gradle/base/build-layout.include.qute b/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/gradle/base/build-layout.include.qute
index 6db90af8f6f..65384400372 100644
--- a/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/gradle/base/build-layout.include.qute
+++ b/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/gradle/base/build-layout.include.qute
@@ -29,9 +29,15 @@ dependencies {
     implementation enforcedPlatform('{it.groupId}:{it.artifactId}:{it.version}')
     {/if}
 {/each}
+{#if input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-panache-next')}
+    annotationProcessor enforcedPlatform("$\{quarkusPlatformGroupId}:$\{quarkusPlatformArtifactId}:$\{quarkusPlatformVersion}")
+{/if}
 {#for dep in dependencies}
     implementation '{dep}'
 {/for}
+{#if input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-panache-next')}
+    annotationProcessor 'org.hibernate.orm:hibernate-processor'
+{/if}
     testImplementation 'io.quarkus:quarkus-junit'
 {#for dep in test-dependencies}
     testImplementation '{dep}'
diff --git a/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/maven/base/pom.tpl.qute.xml b/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/maven/base/pom.tpl.qute.xml
index a58fa4aa54d..acfba7cad8e 100644
--- a/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/maven/base/pom.tpl.qute.xml
+++ b/independent-projects/tools/base-codestarts/src/main/resources/codestarts/quarkus/buildtool/maven/base/pom.tpl.qute.xml
@@ -163,6 +163,22 @@
                 <configuration>
                     <parameters>true</parameters>
                 </configuration>
+                {#if input.selected-extensions-ga.contains('io.quarkus:quarkus-hibernate-panache-next')}
+                <executions>
+                    <execution>
+                        <id>default-compile</id>
+                        <configuration>
+                            <annotationProcessorPathsUseDepMgmt>true</annotationProcessorPathsUseDepMgmt>
+                            <annotationProcessorPaths>
+                                <annotationProcessorPath>
+                                    <groupId>org.hibernate.orm</groupId>
+                                    <artifactId>hibernate-processor</artifactId>
+                                </annotationProcessorPath>
+                            </annotationProcessorPaths>
+                        </configuration>
+                    </execution>
+                </executions>
+                {/if}
             </plugin>
             <!-- Run the tests in JVM mode -->
             <plugin>
diff --git a/independent-projects/tools/devtools-common/src/main/java/io/quarkus/cli/plugin/JBangSupport.java b/independent-projects/tools/devtools-common/src/main/java/io/quarkus/cli/plugin/JBangSupport.java
index e87e5a998df..99768a5d876 100644
--- a/independent-projects/tools/devtools-common/src/main/java/io/quarkus/cli/plugin/JBangSupport.java
+++ b/independent-projects/tools/devtools-common/src/main/java/io/quarkus/cli/plugin/JBangSupport.java
@@ -107,6 +107,7 @@ public List<String> execute(String... args) {
                 .arguments(args)
                 .output()
                 .processWith(br -> br.lines().limit(100000).map(s -> s.replaceAll("\u001B\\[[;\\d]*m", "")).toList())
+                .error().logOnSuccess(false)
                 .run();
     }
 
diff --git a/independent-projects/tools/devtools-common/src/main/java/io/quarkus/devtools/commands/CreateExtension.java b/independent-projects/tools/devtools-common/src/main/java/io/quarkus/devtools/commands/CreateExtension.java
index 91e4aab800f..25a6fe3fee2 100644
--- a/independent-projects/tools/devtools-common/src/main/java/io/quarkus/devtools/commands/CreateExtension.java
+++ b/independent-projects/tools/devtools-common/src/main/java/io/quarkus/devtools/commands/CreateExtension.java
@@ -92,7 +92,7 @@ public enum LayoutType {
     public static final String DEFAULT_QUARKIVERSE_GUIDE_URL = "https://docs.quarkiverse.io/%s/dev/";
 
     private static final String DEFAULT_SUREFIRE_PLUGIN_VERSION = "3.5.4";
-    private static final String DEFAULT_COMPILER_PLUGIN_VERSION = "3.14.1";
+    private static final String DEFAULT_COMPILER_PLUGIN_VERSION = "3.15.0";
 
     private final QuarkusExtensionCodestartProjectInputBuilder builder = QuarkusExtensionCodestartProjectInput.builder();
     private final Path baseDir;
diff --git a/independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/WrapperRunner.java b/independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/WrapperRunner.java
index 4ce07c3e725..e8ad18ed699 100644
--- a/independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/WrapperRunner.java
+++ b/independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/WrapperRunner.java
@@ -79,6 +79,8 @@ public static int run(Path projectDir, Wrapper wrapper) {
         var holder = new Object() {
             int exitCode;
         };
+        var out = new ArrayList<String>();
+        var err = new ArrayList<String>();
         System.out.printf("Running command: %s %s%n", command, args);
         ProcessBuilder.newBuilder(command)
                 .arguments(args)
@@ -87,9 +89,19 @@ public static int run(Path projectDir, Wrapper wrapper) {
                     holder.exitCode = ec;
                     return true;
                 })
-                .output().inherited()
-                .error().inherited()
+                .output().consumeLinesWith(Integer.MAX_VALUE, line -> out.add(line))
+                .error().consumeLinesWith(Integer.MAX_VALUE, line -> err.add(line))
                 .run();
+        if (holder.exitCode != 0) {
+            for (String line : out) {
+                System.out.print("[Codestart stdout] ");
+                System.out.println(line);
+            }
+            for (String line : err) {
+                System.out.print("[Codestart stderr] ");
+                System.out.println(line);
+            }
+        }
         return holder.exitCode;
     }
 
diff --git a/independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/codestarts/QuarkusCodestartTest.java b/independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/codestarts/QuarkusCodestartTest.java
index 6832f5d7d27..89ba9df6704 100644
--- a/independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/codestarts/QuarkusCodestartTest.java
+++ b/independent-projects/tools/devtools-testing/src/main/java/io/quarkus/devtools/testing/codestarts/QuarkusCodestartTest.java
@@ -290,13 +290,17 @@ public ListAssert<String> assertThatGeneratedTreeMatchSnapshots(Language languag
     }
 
     private AbstractPathAssert<?> checkGeneratedSource(String sourceDir, Language language, String className) throws Throwable {
-        final String modifiedClassName = className.replace(DEFAULT_PACKAGE_DIR, packageName).replace('.', '/');
+        final String modifiedClassName = repackagedClassName(className).replace('.', '/');
         final String fileRelativePath = "src/" + sourceDir + "/" + language.key() + "/" + modifiedClassName
                 + getSourceFileExtension(language);
         return assertThatGeneratedFileMatchSnapshot(language, fileRelativePath)
                 .satisfies(checkContains("package " + packageName));
     }
 
+    public String repackagedClassName(String className) {
+        return className.replace(DEFAULT_PACKAGE_DIR, packageName);
+    }
+
     private String getTestId() {
         final String id = Stream.of(
                 buildTool != null ? Stream.of(buildTool.getKey()) : Stream.<String> empty(),
@@ -335,7 +339,7 @@ private void generateProject(Path projectDir, Language language, Map<String, Obj
         getQuarkusCodestartCatalog().createProject(input).generate(projectDir);
     }
 
-    private Path getProjectWithRealDataDir(Language language) throws IOException {
+    public Path getProjectWithRealDataDir(Language language) throws IOException {
         final Path dir = targetDir.resolve("real-data").resolve(language.key());
         generateRealDataProjectIfNeeded(dir, language);
         return dir;
diff --git a/independent-projects/tools/pom.xml b/independent-projects/tools/pom.xml
index 520c4b8d3d0..4ffce76c348 100644
--- a/independent-projects/tools/pom.xml
+++ b/independent-projects/tools/pom.xml
@@ -44,7 +44,7 @@
         <gradle-wrapper.version>9.3.1</gradle-wrapper.version>
 
         <!-- These properties are needed in order for them to be resolvable by the generated projects -->
-        <compiler-plugin.version>3.14.1</compiler-plugin.version>
+        <compiler-plugin.version>3.15.0</compiler-plugin.version>
         <kotlin.version>1.6.0</kotlin.version>
         <scala.version>2.13.12</scala.version>
         <scala-plugin.version>4.4.0</scala-plugin.version>
@@ -58,7 +58,7 @@
         <jboss-logging.version>3.6.2.Final</jboss-logging.version>
         <mockito.version>5.21.0</mockito.version>
         <quarkus.version>${project.version}</quarkus.version>
-        <maven-model-helper.version>37</maven-model-helper.version>
+        <maven-model-helper.version>40</maven-model-helper.version>
         <jandex.version>3.5.3</jandex.version>
         <system-stubs-jupiter.version>2.0.2</system-stubs-jupiter.version>
         <awaitility.version>4.3.0</awaitility.version>
diff --git a/integration-tests/devtools/src/test/java/io/quarkus/devtools/codestarts/quarkus/HibernatePanacheNextCodestartIT.java b/integration-tests/devtools/src/test/java/io/quarkus/devtools/codestarts/quarkus/HibernatePanacheNextCodestartIT.java
new file mode 100644
index 00000000000..85f13c99f39
--- /dev/null
+++ b/integration-tests/devtools/src/test/java/io/quarkus/devtools/codestarts/quarkus/HibernatePanacheNextCodestartIT.java
@@ -0,0 +1,75 @@
+package io.quarkus.devtools.codestarts.quarkus;
+
+import static io.quarkus.devtools.codestarts.quarkus.QuarkusCodestartCatalog.Language.JAVA;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.devtools.project.BuildTool;
+import io.quarkus.devtools.testing.codestarts.QuarkusCodestartTest;
+import io.quarkus.maven.ArtifactKey;
+
+public class HibernatePanacheNextCodestartIT {
+
+    @RegisterExtension
+    public static QuarkusCodestartTest codestartMavenTest = QuarkusCodestartTest.builder()
+            .codestarts("hibernate-orm")
+            .extension(new ArtifactKey("io.quarkus", "quarkus-jdbc-h2"))
+            .extension(new ArtifactKey("io.quarkus", "quarkus-hibernate-panache-next"))
+            .languages(JAVA)
+            .build();
+
+    @RegisterExtension
+    public static QuarkusCodestartTest codestartGradleTest = QuarkusCodestartTest.builder()
+            .codestarts("hibernate-orm")
+            .extension(new ArtifactKey("io.quarkus", "quarkus-jdbc-h2"))
+            .extension(new ArtifactKey("io.quarkus", "quarkus-hibernate-panache-next"))
+            .buildTool(BuildTool.GRADLE)
+            .languages(JAVA)
+            .build();
+
+    @RegisterExtension
+    public static QuarkusCodestartTest codestartGradleKotlinTest = QuarkusCodestartTest.builder()
+            .codestarts("hibernate-orm")
+            .extension(new ArtifactKey("io.quarkus", "quarkus-jdbc-h2"))
+            .extension(new ArtifactKey("io.quarkus", "quarkus-hibernate-panache-next"))
+            .buildTool(BuildTool.GRADLE_KOTLIN_DSL)
+            .languages(JAVA)
+            .build();
+
+    @Test
+    void testMavenContent() throws Throwable {
+        codestartMavenTest.checkGeneratedSource("org.acme.MyEntity");
+        codestartMavenTest.assertThatGeneratedFileMatchSnapshot(JAVA, "src/main/resources/import.sql");
+    }
+
+    @Test
+    void testMavenBuild() throws Throwable {
+        codestartMavenTest.buildAllProjects();
+        Path metamodelPath = codestartMavenTest.getProjectWithRealDataDir(JAVA).resolve("target/generated-sources/annotations/"
+                + codestartMavenTest.repackagedClassName("org.acme.MyEntity_").replace('.', '/') + ".java");
+        Assertions.assertTrue(Files.exists(metamodelPath));
+    }
+
+    @Test
+    void testGradleBuild() throws Throwable {
+        codestartGradleTest.buildAllProjects();
+        Path metamodelPath = codestartGradleTest.getProjectWithRealDataDir(JAVA)
+                .resolve("build/generated/sources/annotationProcessor/java/main/"
+                        + codestartGradleTest.repackagedClassName("org.acme.MyEntity_").replace('.', '/') + ".java");
+        Assertions.assertTrue(Files.exists(metamodelPath));
+    }
+
+    @Test
+    void testGradleKotlinBuild() throws Throwable {
+        codestartGradleKotlinTest.buildAllProjects();
+        Path metamodelPath = codestartGradleKotlinTest.getProjectWithRealDataDir(JAVA)
+                .resolve("build/generated/sources/annotationProcessor/java/main/"
+                        + codestartGradleKotlinTest.repackagedClassName("org.acme.MyEntity_").replace('.', '/') + ".java");
+        Assertions.assertTrue(Files.exists(metamodelPath));
+    }
+}
diff --git a/integration-tests/devtools/src/test/resources/__snapshots__/HibernateOrmPanacheCodestartIT/testContent/src_main_java_ilove_quark_us_MyEntity.java b/integration-tests/devtools/src/test/resources/__snapshots__/HibernateOrmPanacheCodestartIT/testContent/src_main_java_ilove_quark_us_MyEntity.java
index e75f117fb82..11de58a5f65 100644
--- a/integration-tests/devtools/src/test/resources/__snapshots__/HibernateOrmPanacheCodestartIT/testContent/src_main_java_ilove_quark_us_MyEntity.java
+++ b/integration-tests/devtools/src/test/resources/__snapshots__/HibernateOrmPanacheCodestartIT/testContent/src_main_java_ilove_quark_us_MyEntity.java
@@ -9,9 +9,9 @@
  * An ID field of Long type is provided, if you want to define your own ID field extends <code>PanacheEntityBase</code> instead.
  *
  * This uses the active record pattern, you can also use the repository pattern instead:
- * .
+ * {@see https://quarkus.io/guides/hibernate-orm-panache#solution-2-using-the-repository-pattern}.
  *
- * Usage (more example on the documentation)
+ * Usage:
  *
  * {@code
  *     public void doSomething() {
diff --git a/integration-tests/devtools/src/test/resources/__snapshots__/HibernatePanacheNextCodestartIT/testMavenContent/src_main_java_ilove_quark_us_MyEntity.java b/integration-tests/devtools/src/test/resources/__snapshots__/HibernatePanacheNextCodestartIT/testMavenContent/src_main_java_ilove_quark_us_MyEntity.java
new file mode 100644
index 00000000000..22e47135de6
--- /dev/null
+++ b/integration-tests/devtools/src/test/resources/__snapshots__/HibernatePanacheNextCodestartIT/testMavenContent/src_main_java_ilove_quark_us_MyEntity.java
@@ -0,0 +1,28 @@
+package ilove.quark.us;
+
+import io.quarkus.hibernate.panache.PanacheEntity;
+import jakarta.persistence.Entity;
+
+
+/**
+ * Example JPA entity defined as a Panache Entity.
+ * An ID field of Long type is provided, if you want to define your own ID field extends <code>WithId</code> instead.
+ *
+ * Documentation: {@see https://quarkus.io/guides/hibernate-panache-next}
+ *
+ * Usage:
+ *
+ * {@code
+ *     public void doSomething() {
+ *         MyEntity entity1 = new MyEntity();
+ *         entity1.field = "field-1";
+ *         entity1.persist();
+ *
+ *         List<MyEntity> entities = MyEntity_.managedBlocking().listAll();
+ *     }
+ * }
+ */
+@Entity
+public class MyEntity extends PanacheEntity {
+    public String field;
+}
diff --git a/integration-tests/devtools/src/test/resources/__snapshots__/HibernatePanacheNextCodestartIT/testMavenContent/src_main_resources_import.sql b/integration-tests/devtools/src/test/resources/__snapshots__/HibernatePanacheNextCodestartIT/testMavenContent/src_main_resources_import.sql
new file mode 100644
index 00000000000..16aa5235ec2
--- /dev/null
+++ b/integration-tests/devtools/src/test/resources/__snapshots__/HibernatePanacheNextCodestartIT/testMavenContent/src_main_resources_import.sql
@@ -0,0 +1,6 @@
+-- This file allow to write SQL commands that will be emitted in test and dev.
+-- The commands are commented as their support depends of the database
+-- insert into myentity (id, field) values(1, 'field-1');
+-- insert into myentity (id, field) values(2, 'field-2');
+-- insert into myentity (id, field) values(3, 'field-3');
+-- alter sequence myentity_seq restart with 4;
\ No newline at end of file
diff --git a/integration-tests/kafka-avro-apicurio2/pom.xml b/integration-tests/kafka-avro-apicurio2/pom.xml
index aa7dac13ebd..88171362d31 100644
--- a/integration-tests/kafka-avro-apicurio2/pom.xml
+++ b/integration-tests/kafka-avro-apicurio2/pom.xml
@@ -10,11 +10,16 @@
     <modelVersion>4.0.0</modelVersion>
 
     <artifactId>quarkus-integration-test-kafka-avro-apicurio2</artifactId>
-    <name>Quarkus - Integration Tests - Kafka Avro with Apicurio 2.x</name>
-    <description>The Apache Kafka Avro with Apicurio Registry 2.x integration tests module</description>
+    <name>Quarkus - Integration Tests - Kafka Avro with Apicurio Registry</name>
+    <description>Apache Kafka Avro with Apicurio Registry 3.x integration tests - tests both v2 compatibility mode (Legacy8ByteIdHandler) and v3 native mode (Default4ByteIdHandler)</description>
 
     <!--
-      - This must be a separate Maven module, because adding Apicurio Registry 2.x
+      - This module tests Apicurio Registry 3.x libraries in multiple modes:
+      - 1. V2 compatibility mode: Uses Legacy8ByteIdHandler for backward compatibility with 8-byte schema IDs
+      - 2. V3 native mode: Uses Default4ByteIdHandler for new v3 4-byte schema IDs
+      - Tests include KafkaAvroMixedVersionTest which validates both modes work correctly.
+      -
+      - Note: This must be a separate Maven module, because adding Apicurio Registry
       - libraries to the `kafka-avro` module would lead to dependency divergence.
       - When we no longer care about Apicurio Registry 1.x, the `kafka-avro`
       - module can be deleted, as this module is a copy and hence also includes
diff --git a/integration-tests/kafka-avro-apicurio2/src/main/java/io/quarkus/it/kafka/avro/AvroKafkaCreator.java b/integration-tests/kafka-avro-apicurio2/src/main/java/io/quarkus/it/kafka/avro/AvroKafkaCreator.java
index bea7b82aee3..aaf606ef7f6 100644
--- a/integration-tests/kafka-avro-apicurio2/src/main/java/io/quarkus/it/kafka/avro/AvroKafkaCreator.java
+++ b/integration-tests/kafka-avro-apicurio2/src/main/java/io/quarkus/it/kafka/avro/AvroKafkaCreator.java
@@ -14,10 +14,10 @@
 import org.apache.kafka.common.serialization.IntegerSerializer;
 import org.eclipse.microprofile.config.inject.ConfigProperty;
 
-import io.apicurio.registry.serde.SerdeConfig;
 import io.apicurio.registry.serde.avro.AvroKafkaDeserializer;
-import io.apicurio.registry.serde.avro.AvroKafkaSerdeConfig;
 import io.apicurio.registry.serde.avro.AvroKafkaSerializer;
+import io.apicurio.registry.serde.avro.AvroSerdeConfig;
+import io.apicurio.registry.serde.config.SerdeConfig;
 import io.confluent.kafka.serializers.AbstractKafkaSchemaSerDeConfig;
 import io.confluent.kafka.serializers.KafkaAvroDeserializer;
 import io.confluent.kafka.serializers.KafkaAvroDeserializerConfig;
@@ -38,13 +38,21 @@ public class AvroKafkaCreator {
     @ConfigProperty(name = "mp.messaging.connector.smallrye-kafka.schema.registry.url")
     String confluentRegistryUrl;
 
+    Properties commonProperties = new Properties();
+
     public AvroKafkaCreator() {
     }
 
     public AvroKafkaCreator(String bootstrap, String apicurioRegistryUrl, String confluentRegistryUrl) {
+        this(bootstrap, apicurioRegistryUrl, confluentRegistryUrl, new Properties());
+    }
+
+    public AvroKafkaCreator(String bootstrap, String apicurioRegistryUrl, String confluentRegistryUrl,
+            Properties commonProperties) {
         this.bootstrap = bootstrap;
         this.apicurioRegistryUrl = apicurioRegistryUrl;
         this.confluentRegistryUrl = confluentRegistryUrl;
+        this.commonProperties = commonProperties;
     }
 
     public String getApicurioRegistryUrl() {
@@ -71,31 +79,31 @@ public KafkaProducer<Integer, Pet> createApicurioProducer(String clientId) {
         return createApicurioProducer(bootstrap, getApicurioRegistryUrl(), clientId);
     }
 
-    public static KafkaConsumer<Integer, Pet> createConfluentConsumer(String bootstrap, String confluent,
+    public KafkaConsumer<Integer, Pet> createConfluentConsumer(String bootstrap, String confluent,
             String groupdIdConfig, String subscribtionName) {
         Properties p = getConfluentConsumerProperties(bootstrap, confluent, groupdIdConfig);
         return createConsumer(p, subscribtionName);
     }
 
-    public static KafkaConsumer<Integer, Pet> createApicurioConsumer(String bootstrap, String apicurio,
+    public KafkaConsumer<Integer, Pet> createApicurioConsumer(String bootstrap, String apicurio,
             String groupdIdConfig, String subscribtionName) {
         Properties p = getApicurioConsumerProperties(bootstrap, apicurio, groupdIdConfig);
         return createConsumer(p, subscribtionName);
     }
 
-    public static KafkaProducer<Integer, Pet> createConfluentProducer(String bootstrap, String confluent,
+    public KafkaProducer<Integer, Pet> createConfluentProducer(String bootstrap, String confluent,
             String clientId) {
         Properties p = getConfluentProducerProperties(bootstrap, confluent, clientId);
         return createProducer(p);
     }
 
-    public static KafkaProducer<Integer, Pet> createApicurioProducer(String bootstrap, String apicurio,
+    public KafkaProducer<Integer, Pet> createApicurioProducer(String bootstrap, String apicurio,
             String clientId) {
         Properties p = getApicurioProducerProperties(bootstrap, apicurio, clientId);
         return createProducer(p);
     }
 
-    private static KafkaConsumer<Integer, Pet> createConsumer(Properties props, String subscribtionName) {
+    private KafkaConsumer<Integer, Pet> createConsumer(Properties props, String subscribtionName) {
         if (!props.containsKey(ConsumerConfig.CLIENT_ID_CONFIG)) {
             props.put(ConsumerConfig.CLIENT_ID_CONFIG, UUID.randomUUID().toString());
         }
@@ -104,14 +112,14 @@ private static KafkaConsumer<Integer, Pet> createConsumer(Properties props, Stri
         return consumer;
     }
 
-    private static KafkaProducer<Integer, Pet> createProducer(Properties props) {
+    private KafkaProducer<Integer, Pet> createProducer(Properties props) {
         if (!props.containsKey(ProducerConfig.CLIENT_ID_CONFIG)) {
             props.put(ProducerConfig.CLIENT_ID_CONFIG, UUID.randomUUID().toString());
         }
         return new KafkaProducer<>(props);
     }
 
-    private static Properties getConfluentConsumerProperties(String bootstrap, String confluent,
+    private Properties getConfluentConsumerProperties(String bootstrap, String confluent,
             String groupdIdConfig) {
         Properties props = getGenericConsumerProperties(bootstrap, groupdIdConfig);
         props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, KafkaAvroDeserializer.class.getName());
@@ -120,16 +128,17 @@ private static Properties getConfluentConsumerProperties(String bootstrap, Strin
         return props;
     }
 
-    public static Properties getApicurioConsumerProperties(String bootstrap, String apicurio, String groupdIdConfig) {
+    public Properties getApicurioConsumerProperties(String bootstrap, String apicurio, String groupdIdConfig) {
         Properties props = getGenericConsumerProperties(bootstrap, groupdIdConfig);
         props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, AvroKafkaDeserializer.class.getName());
         props.put(SerdeConfig.REGISTRY_URL, apicurio);
-        props.put(AvroKafkaSerdeConfig.USE_SPECIFIC_AVRO_READER, true);
+        props.put(AvroSerdeConfig.USE_SPECIFIC_AVRO_READER, true);
         return props;
     }
 
-    private static Properties getGenericConsumerProperties(String bootstrap, String groupdIdConfig) {
+    private Properties getGenericConsumerProperties(String bootstrap, String groupdIdConfig) {
         Properties props = new Properties();
+        props.putAll(commonProperties);
         props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrap);
         props.put(ConsumerConfig.GROUP_ID_CONFIG, groupdIdConfig);
         props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, IntegerDeserializer.class.getName());
@@ -139,14 +148,14 @@ private static Properties getGenericConsumerProperties(String bootstrap, String
         return props;
     }
 
-    private static Properties getConfluentProducerProperties(String bootstrap, String confluent, String clientId) {
+    private Properties getConfluentProducerProperties(String bootstrap, String confluent, String clientId) {
         Properties props = getGenericProducerProperties(bootstrap, clientId);
         props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, KafkaAvroSerializer.class.getName());
         props.put(AbstractKafkaSchemaSerDeConfig.SCHEMA_REGISTRY_URL_CONFIG, confluent);
         return props;
     }
 
-    private static Properties getApicurioProducerProperties(String bootstrap, String apicurio, String clientId) {
+    private Properties getApicurioProducerProperties(String bootstrap, String apicurio, String clientId) {
         Properties props = getGenericProducerProperties(bootstrap, clientId);
         props.put(ProducerConfig.ACKS_CONFIG, "all");
         props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, AvroKafkaSerializer.class.getName());
@@ -155,8 +164,9 @@ private static Properties getApicurioProducerProperties(String bootstrap, String
         return props;
     }
 
-    private static Properties getGenericProducerProperties(String bootstrap, String clientId) {
+    private Properties getGenericProducerProperties(String bootstrap, String clientId) {
         Properties props = new Properties();
+        props.putAll(commonProperties);
         props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrap);
         props.put(ProducerConfig.CLIENT_ID_CONFIG, clientId);
         props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, IntegerSerializer.class.getName());
diff --git a/integration-tests/kafka-avro-apicurio2/src/main/resources/application.properties b/integration-tests/kafka-avro-apicurio2/src/main/resources/application.properties
index b17213e7550..1e58a83094d 100644
--- a/integration-tests/kafka-avro-apicurio2/src/main/resources/application.properties
+++ b/integration-tests/kafka-avro-apicurio2/src/main/resources/application.properties
@@ -6,3 +6,9 @@ quarkus.log.category.\"org.apache.zookeeper\".level=WARN
 quarkus.kafka.health.enabled=true
 
 quarkus.apicurio-registry.devservices.image-name=${apicurio-registry.image}
+
+# Default configuration uses Legacy8ByteIdHandler for v2 compatibility mode
+# This allows Apicurio v3 libraries to work with 8-byte schema IDs (v2 format)
+# Note: KafkaAvroMixedVersionTest overrides this to test both v2 and v3 modes
+mp.messaging.connector.smallrye-kafka.apicurio.registry.id-handler=io.apicurio.registry.serde.Legacy8ByteIdHandler
+
diff --git a/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroIT.java b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroIT.java
index cde33e53f4a..7c18b1e4c27 100644
--- a/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroIT.java
+++ b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroIT.java
@@ -1,13 +1,8 @@
 package io.quarkus.it.kafka;
 
-import org.junit.jupiter.api.BeforeAll;
-
-import io.apicurio.registry.rest.client.RegistryClientFactory;
-import io.apicurio.rest.client.VertxHttpClientProvider;
 import io.quarkus.it.kafka.avro.AvroKafkaCreator;
 import io.quarkus.test.common.QuarkusTestResource;
 import io.quarkus.test.junit.QuarkusIntegrationTest;
-import io.vertx.core.Vertx;
 
 @QuarkusIntegrationTest
 @QuarkusTestResource(value = KafkaResource.class, restrictToAnnotatedClass = true)
@@ -20,10 +15,4 @@ AvroKafkaCreator creator() {
         return creator;
     }
 
-    @BeforeAll
-    public static void setUp() {
-        // this is for the test JVM, which also uses Kafka client, which in turn also interacts with the registry
-        RegistryClientFactory.setProvider(new VertxHttpClientProvider(Vertx.vertx()));
-    }
-
 }
diff --git a/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroMixedVersionTest.java b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroMixedVersionTest.java
new file mode 100644
index 00000000000..111f6586388
--- /dev/null
+++ b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroMixedVersionTest.java
@@ -0,0 +1,132 @@
+package io.quarkus.it.kafka;
+
+import static io.apicurio.registry.serde.avro.AvroSerdeConfig.USE_SPECIFIC_AVRO_READER;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.awaitility.Awaitility.await;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.hasItems;
+
+import java.time.Duration;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
+import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.OffsetResetStrategy;
+import org.apache.kafka.common.serialization.Serde;
+import org.apache.kafka.common.serialization.Serdes;
+import org.junit.jupiter.api.Test;
+
+import io.apicurio.registry.serde.avro.AvroKafkaDeserializer;
+import io.apicurio.registry.serde.avro.AvroKafkaSerializer;
+import io.quarkus.it.kafka.avro.Pet;
+import io.quarkus.test.common.WithTestResource;
+import io.quarkus.test.junit.QuarkusTest;
+import io.quarkus.test.kafka.InjectKafkaCompanion;
+import io.quarkus.test.kafka.KafkaCompanionResource;
+import io.smallrye.reactive.messaging.kafka.companion.ConsumerTask;
+import io.smallrye.reactive.messaging.kafka.companion.KafkaCompanion;
+
+/**
+ * Test demonstrating mixed version scenario:
+ * - Producer using v2 mode (8-byte schema IDs via Legacy8ByteIdHandler)
+ * - Consumer using v3 mode (4-byte schema IDs via Default4ByteIdHandler)
+ *
+ * This tests the critical migration path where a v2 producer sends messages
+ * that need to be consumed by a v3 consumer configured with Legacy8ByteIdHandler.
+ *
+ * Note: This test demonstrates the WORKING scenarios. The FAILING scenarios
+ * (mismatched ID handlers) would require plain Kafka clients instead of KafkaCompanion
+ * but are well documented in APICURIO_V3_SUMMARY.md
+ */
+@QuarkusTest
+@WithTestResource(value = KafkaCompanionResource.class)
+public class KafkaAvroMixedVersionTest {
+
+    private static final String MIXED_VERSION_TOPIC = "test-avro-mixed-version";
+
+    @InjectKafkaCompanion
+    KafkaCompanion kafkaCompanion;
+
+    @Test
+    public void testV2ProducerToV3Consumer() {
+        // This test uses Legacy8ByteIdHandler for both producer and consumer
+        // simulating v2 behavior where 8-byte schema IDs are used
+        Map<String, Object> v2Config = new HashMap<>(kafkaCompanion.getCommonClientConfig());
+        v2Config.put(USE_SPECIFIC_AVRO_READER, "true");
+        v2Config.put("apicurio.registry.id-handler", "io.apicurio.registry.serde.Legacy8ByteIdHandler");
+
+        Serde<Pet> v2Serde = Serdes.serdeFrom(
+                new AvroKafkaSerializer<>(),
+                new AvroKafkaDeserializer<>());
+        v2Serde.configure(v2Config, false);
+
+        kafkaCompanion.registerSerde(Pet.class, v2Serde);
+
+        // Produce messages using v2 mode (8-byte IDs)
+        kafkaCompanion.produce(Pet.class)
+                .fromRecords(
+                        new org.apache.kafka.clients.producer.ProducerRecord<>(MIXED_VERSION_TOPIC, "key1",
+                                createPet("Shadow", "black")),
+                        new org.apache.kafka.clients.producer.ProducerRecord<>(MIXED_VERSION_TOPIC, "key2",
+                                createPet("Whiskers", "white")));
+
+        // Consume messages using v2 mode (Legacy8ByteIdHandler)
+        ConsumerTask<String, Pet> consumer = kafkaCompanion.consume(Pet.class)
+                .withGroupId("test-group-mixed-" + UUID.randomUUID())
+                .withOffsetReset(OffsetResetStrategy.EARLIEST)
+                .fromTopics(MIXED_VERSION_TOPIC);
+
+        List<ConsumerRecord<String, Pet>> received = consumer.awaitRecords(2, Duration.ofSeconds(10L)).getRecords();
+
+        // Verify we can successfully use Legacy8ByteIdHandler (v2 mode)
+        await().atMost(10, SECONDS).until(() -> received.size() >= 2);
+        List<String> pets = received.stream().map(r -> r.value().getName()).toList();
+        assertThat(pets, hasItems("Shadow", "Whiskers"));
+    }
+
+    @Test
+    public void testV3ProducerToV3Consumer() {
+        // Both producer and consumer use v3 mode (4-byte schema IDs via Default4ByteIdHandler)
+        Map<String, Object> v3Config = new HashMap<>(kafkaCompanion.getCommonClientConfig());
+        v3Config.put(USE_SPECIFIC_AVRO_READER, "true");
+        // Use default 4-byte ID handler (v3 mode)
+        v3Config.put("apicurio.registry.id-handler", "io.apicurio.registry.serde.Default4ByteIdHandler");
+
+        Serde<Pet> v3Serde = Serdes.serdeFrom(
+                new AvroKafkaSerializer<>(),
+                new AvroKafkaDeserializer<>());
+        v3Serde.configure(v3Config, false);
+
+        kafkaCompanion.registerSerde(Pet.class, v3Serde);
+
+        // Produce messages using v3 mode (4-byte IDs)
+        kafkaCompanion.produce(Pet.class)
+                .fromRecords(
+                        new org.apache.kafka.clients.producer.ProducerRecord<>(MIXED_VERSION_TOPIC + "-v3", "key1",
+                                createPet("Rex", "brown")),
+                        new org.apache.kafka.clients.producer.ProducerRecord<>(MIXED_VERSION_TOPIC + "-v3", "key2",
+                                createPet("Luna", "gray")));
+
+        // Consume messages using v3 mode
+        ConsumerTask<String, Pet> consumer = kafkaCompanion.consume(Pet.class)
+                .withGroupId("test-group-v3-" + UUID.randomUUID())
+                .withOffsetReset(OffsetResetStrategy.EARLIEST)
+                .fromTopics(MIXED_VERSION_TOPIC + "-v3");
+
+        List<ConsumerRecord<String, Pet>> received = consumer.awaitRecords(2, Duration.ofSeconds(10L)).getRecords();
+
+        // Verify native v3-to-v3 communication works
+        await().atMost(10, SECONDS).until(() -> received.size() >= 2);
+        List<String> pets = received.stream().map(r -> r.value().getName()).toList();
+        assertThat(pets, hasItems("Rex", "Luna"));
+    }
+
+    private Pet createPet(String name, String color) {
+        Pet pet = new Pet();
+        pet.setName(name);
+        pet.setColor(color);
+        return pet;
+    }
+}
diff --git a/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroTestBase.java b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroTestBase.java
index 74e17f9f88d..9328eb076c8 100644
--- a/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroTestBase.java
+++ b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroTestBase.java
@@ -22,8 +22,8 @@ public abstract class KafkaAvroTestBase {
 
     @Test
     public void testUrls() {
-        Assertions.assertTrue(creator().getApicurioRegistryUrl().endsWith("/apis/registry/v2"));
-        Assertions.assertTrue(creator().getConfluentRegistryUrl().endsWith("/apis/ccompat/v6"));
+        Assertions.assertTrue(creator().getApicurioRegistryUrl().endsWith("/apis/registry/v3"));
+        Assertions.assertTrue(creator().getConfluentRegistryUrl().endsWith("/apis/ccompat/v7"));
     }
 
     @Test
diff --git a/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroWithKafkaCompanionTest.java b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroWithKafkaCompanionTest.java
index 4d7f7cf1eff..931204cd90d 100644
--- a/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroWithKafkaCompanionTest.java
+++ b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaAvroWithKafkaCompanionTest.java
@@ -1,6 +1,6 @@
 package io.quarkus.it.kafka;
 
-import static io.apicurio.registry.serde.avro.AvroKafkaSerdeConfig.USE_SPECIFIC_AVRO_READER;
+import static io.apicurio.registry.serde.avro.AvroSerdeConfig.USE_SPECIFIC_AVRO_READER;
 import static io.restassured.RestAssured.given;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.awaitility.Awaitility.await;
diff --git a/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaResource.java b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaResource.java
index 024b9b7dc31..f7fd6f274f1 100644
--- a/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaResource.java
+++ b/integration-tests/kafka-avro-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaResource.java
@@ -2,10 +2,13 @@
 
 import java.util.Collections;
 import java.util.Map;
+import java.util.Properties;
 
+import io.apicurio.registry.resolver.config.SchemaResolverConfig;
 import io.quarkus.it.kafka.avro.AvroKafkaCreator;
 import io.quarkus.test.common.DevServicesContext;
 import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;
+import io.vertx.core.Vertx;
 
 public class KafkaResource implements QuarkusTestResourceLifecycleManager, DevServicesContext.ContextAware {
 
@@ -18,7 +21,9 @@ public void setIntegrationTestContext(DevServicesContext context) {
         if (bootstrapServers != null) {
             String apicurioUrl = devServicesProperties.get("mp.messaging.connector.smallrye-kafka.apicurio.registry.url");
             String confluentUrl = devServicesProperties.get("mp.messaging.connector.smallrye-kafka.schema.registry.url");
-            creator = new AvroKafkaCreator(bootstrapServers, apicurioUrl, confluentUrl);
+            Properties commonProperties = new Properties();
+            commonProperties.put(SchemaResolverConfig.VERTX_INSTANCE, Vertx.vertx());
+            creator = new AvroKafkaCreator(bootstrapServers, apicurioUrl, confluentUrl, commonProperties);
         }
     }
 
diff --git a/integration-tests/kafka-json-schema-apicurio2/pom.xml b/integration-tests/kafka-json-schema-apicurio2/pom.xml
index 338b52e9843..d03248c2fe5 100644
--- a/integration-tests/kafka-json-schema-apicurio2/pom.xml
+++ b/integration-tests/kafka-json-schema-apicurio2/pom.xml
@@ -10,8 +10,14 @@
     <modelVersion>4.0.0</modelVersion>
 
     <artifactId>quarkus-integration-test-kafka-json-schema-apicurio2</artifactId>
-    <name>Quarkus - Integration Tests - Kafka Json Schema with Apicurio 2.x</name>
-    <description>The Apache Kafka Json Schema with Apicurio Registry 2.x integration tests module</description>
+    <name>Quarkus - Integration Tests - Kafka Json Schema with Apicurio Registry</name>
+    <description>Apache Kafka Json Schema with Apicurio Registry 3.x integration tests - tests both v2 compatibility mode (Legacy8ByteIdHandler) and v3 native mode (Default4ByteIdHandler)</description>
+
+    <!--
+      - This module tests Apicurio Registry 3.x libraries in multiple modes:
+      - 1. V2 compatibility mode: Uses Legacy8ByteIdHandler for backward compatibility with 8-byte schema IDs
+      - 2. V3 native mode: Uses Default4ByteIdHandler for new v3 4-byte schema IDs
+      -->
 
     <dependencyManagement>
         <dependencies>
diff --git a/integration-tests/kafka-json-schema-apicurio2/src/main/java/io/quarkus/it/kafka/jsonschema/JsonSchemaEndpoint.java b/integration-tests/kafka-json-schema-apicurio2/src/main/java/io/quarkus/it/kafka/jsonschema/JsonSchemaEndpoint.java
index 31c114e1b58..0beffb2a2fe 100644
--- a/integration-tests/kafka-json-schema-apicurio2/src/main/java/io/quarkus/it/kafka/jsonschema/JsonSchemaEndpoint.java
+++ b/integration-tests/kafka-json-schema-apicurio2/src/main/java/io/quarkus/it/kafka/jsonschema/JsonSchemaEndpoint.java
@@ -41,14 +41,18 @@ public void sendConfluent(Pet pet) {
     @GET
     @Path("/apicurio")
     public JsonObject getApicurio() {
-        return get(creator.createApicurioConsumer("test-json-schema-apicurio-consumer", "test-json-schema-apicurio-consumer"));
+        try (KafkaConsumer<Integer, Pet> consumer = creator.createApicurioConsumer("test-json-schema-apicurio-consumer",
+                "test-json-schema-apicurio-consumer")) {
+            return get(consumer);
+        }
     }
 
     @POST
     @Path("/apicurio")
     public void sendApicurio(Pet pet) {
-        KafkaProducer<Integer, Pet> p = creator.createApicurioProducer("test-json-schema-apicurio");
-        send(p, pet, "test-json-schema-apicurio-producer");
+        try (KafkaProducer<Integer, Pet> p = creator.createApicurioProducer("test-json-schema-apicurio")) {
+            send(p, pet, "test-json-schema-apicurio-producer");
+        }
     }
 
     private JsonObject get(KafkaConsumer<Integer, Pet> consumer) {
diff --git a/integration-tests/kafka-json-schema-apicurio2/src/main/java/io/quarkus/it/kafka/jsonschema/JsonSchemaKafkaCreator.java b/integration-tests/kafka-json-schema-apicurio2/src/main/java/io/quarkus/it/kafka/jsonschema/JsonSchemaKafkaCreator.java
index 119beaf8377..fa7b1522314 100644
--- a/integration-tests/kafka-json-schema-apicurio2/src/main/java/io/quarkus/it/kafka/jsonschema/JsonSchemaKafkaCreator.java
+++ b/integration-tests/kafka-json-schema-apicurio2/src/main/java/io/quarkus/it/kafka/jsonschema/JsonSchemaKafkaCreator.java
@@ -14,9 +14,10 @@
 import org.apache.kafka.common.serialization.IntegerSerializer;
 import org.eclipse.microprofile.config.inject.ConfigProperty;
 
-import io.apicurio.registry.serde.SerdeConfig;
+import io.apicurio.registry.serde.config.SerdeConfig;
 import io.apicurio.registry.serde.jsonschema.JsonSchemaKafkaDeserializer;
 import io.apicurio.registry.serde.jsonschema.JsonSchemaKafkaSerializer;
+import io.apicurio.registry.serde.kafka.config.KafkaSerdeConfig;
 import io.confluent.kafka.serializers.AbstractKafkaSchemaSerDeConfig;
 import io.confluent.kafka.serializers.KafkaJsonDeserializerConfig;
 import io.confluent.kafka.serializers.json.KafkaJsonSchemaDeserializer;
@@ -37,13 +38,21 @@ public class JsonSchemaKafkaCreator {
     @ConfigProperty(name = "mp.messaging.connector.smallrye-kafka.schema.registry.url")
     String confluentRegistryUrl;
 
+    Properties commonProperties = new Properties();
+
     public JsonSchemaKafkaCreator() {
     }
 
     public JsonSchemaKafkaCreator(String bootstrap, String apicurioRegistryUrl, String confluentRegistryUrl) {
+        this(bootstrap, apicurioRegistryUrl, confluentRegistryUrl, new Properties());
+    }
+
+    public JsonSchemaKafkaCreator(String bootstrap, String apicurioRegistryUrl, String confluentRegistryUrl,
+            Properties commonProperties) {
         this.bootstrap = bootstrap;
         this.apicurioRegistryUrl = apicurioRegistryUrl;
         this.confluentRegistryUrl = confluentRegistryUrl;
+        this.commonProperties = commonProperties;
     }
 
     public String getApicurioRegistryUrl() {
@@ -70,31 +79,31 @@ public KafkaProducer<Integer, Pet> createApicurioProducer(String clientId) {
         return createApicurioProducer(bootstrap, getApicurioRegistryUrl(), clientId);
     }
 
-    public static KafkaConsumer<Integer, Pet> createConfluentConsumer(String bootstrap, String confluent,
+    public KafkaConsumer<Integer, Pet> createConfluentConsumer(String bootstrap, String confluent,
             String groupdIdConfig, String subscribtionName) {
         Properties p = getConfluentConsumerProperties(bootstrap, confluent, groupdIdConfig);
         return createConsumer(p, subscribtionName);
     }
 
-    public static KafkaConsumer<Integer, Pet> createApicurioConsumer(String bootstrap, String apicurio,
+    public KafkaConsumer<Integer, Pet> createApicurioConsumer(String bootstrap, String apicurio,
             String groupdIdConfig, String subscribtionName) {
         Properties p = getApicurioConsumerProperties(bootstrap, apicurio, groupdIdConfig);
         return createConsumer(p, subscribtionName);
     }
 
-    public static KafkaProducer<Integer, Pet> createApicurioProducer(String bootstrap, String apicurio,
+    public KafkaProducer<Integer, Pet> createApicurioProducer(String bootstrap, String apicurio,
             String clientId) {
         Properties p = getApicurioProducerProperties(bootstrap, apicurio, clientId);
         return createProducer(p);
     }
 
-    public static KafkaProducer<Integer, Pet> createConfluentProducer(String bootstrap, String confluent,
+    public KafkaProducer<Integer, Pet> createConfluentProducer(String bootstrap, String confluent,
             String clientId) {
         Properties p = getConfluentProducerProperties(bootstrap, confluent, clientId);
         return createProducer(p);
     }
 
-    private static KafkaConsumer<Integer, Pet> createConsumer(Properties props, String subscribtionName) {
+    private KafkaConsumer<Integer, Pet> createConsumer(Properties props, String subscribtionName) {
         if (!props.containsKey(ConsumerConfig.CLIENT_ID_CONFIG)) {
             props.put(ConsumerConfig.CLIENT_ID_CONFIG, UUID.randomUUID().toString());
         }
@@ -103,14 +112,14 @@ private static KafkaConsumer<Integer, Pet> createConsumer(Properties props, Stri
         return consumer;
     }
 
-    private static KafkaProducer<Integer, Pet> createProducer(Properties props) {
+    private KafkaProducer<Integer, Pet> createProducer(Properties props) {
         if (!props.containsKey(ProducerConfig.CLIENT_ID_CONFIG)) {
             props.put(ProducerConfig.CLIENT_ID_CONFIG, UUID.randomUUID().toString());
         }
         return new KafkaProducer<>(props);
     }
 
-    private static Properties getConfluentConsumerProperties(String bootstrap, String confluent,
+    private Properties getConfluentConsumerProperties(String bootstrap, String confluent,
             String groupdIdConfig) {
         Properties props = getGenericConsumerProperties(bootstrap, groupdIdConfig);
         props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, KafkaJsonSchemaDeserializer.class.getName());
@@ -119,15 +128,17 @@ private static Properties getConfluentConsumerProperties(String bootstrap, Strin
         return props;
     }
 
-    public static Properties getApicurioConsumerProperties(String bootstrap, String apicurio, String groupdIdConfig) {
+    public Properties getApicurioConsumerProperties(String bootstrap, String apicurio, String groupdIdConfig) {
         Properties props = getGenericConsumerProperties(bootstrap, groupdIdConfig);
         props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonSchemaKafkaDeserializer.class.getName());
         props.put(SerdeConfig.REGISTRY_URL, apicurio);
+        props.put(KafkaSerdeConfig.ENABLE_HEADERS, "true");
         return props;
     }
 
-    private static Properties getGenericConsumerProperties(String bootstrap, String groupdIdConfig) {
+    private Properties getGenericConsumerProperties(String bootstrap, String groupdIdConfig) {
         Properties props = new Properties();
+        props.putAll(commonProperties);
         props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrap);
         props.put(ConsumerConfig.GROUP_ID_CONFIG, groupdIdConfig);
         props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, IntegerDeserializer.class.getName());
@@ -137,7 +148,7 @@ private static Properties getGenericConsumerProperties(String bootstrap, String
         return props;
     }
 
-    private static Properties getApicurioProducerProperties(String bootstrap, String apicurio, String clientId) {
+    private Properties getApicurioProducerProperties(String bootstrap, String apicurio, String clientId) {
         Properties props = getGenericProducerProperties(bootstrap, clientId);
         props.put(ProducerConfig.ACKS_CONFIG, "all");
         props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSchemaKafkaSerializer.class.getName());
@@ -145,18 +156,20 @@ private static Properties getApicurioProducerProperties(String bootstrap, String
         props.put(SerdeConfig.SCHEMA_LOCATION, "json-schema.json");
         props.put(SerdeConfig.VALIDATION_ENABLED, "true");
         props.put(SerdeConfig.REGISTRY_URL, apicurio);
+        props.put(KafkaSerdeConfig.ENABLE_HEADERS, "true");
         return props;
     }
 
-    private static Properties getConfluentProducerProperties(String bootstrap, String confluent, String clientId) {
+    private Properties getConfluentProducerProperties(String bootstrap, String confluent, String clientId) {
         Properties props = getGenericProducerProperties(bootstrap, clientId);
         props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, KafkaJsonSchemaSerializer.class.getName());
         props.put(AbstractKafkaSchemaSerDeConfig.SCHEMA_REGISTRY_URL_CONFIG, confluent);
         return props;
     }
 
-    private static Properties getGenericProducerProperties(String bootstrap, String clientId) {
+    private Properties getGenericProducerProperties(String bootstrap, String clientId) {
         Properties props = new Properties();
+        props.putAll(commonProperties);
         props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrap);
         props.put(ProducerConfig.CLIENT_ID_CONFIG, clientId);
         props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, IntegerSerializer.class.getName());
diff --git a/integration-tests/kafka-json-schema-apicurio2/src/main/resources/application.properties b/integration-tests/kafka-json-schema-apicurio2/src/main/resources/application.properties
index e1de76ce230..1ea90c4f24f 100644
--- a/integration-tests/kafka-json-schema-apicurio2/src/main/resources/application.properties
+++ b/integration-tests/kafka-json-schema-apicurio2/src/main/resources/application.properties
@@ -8,3 +8,7 @@ quarkus.native.resources.includes=json-schema.json
 quarkus.kafka.health.enabled=true
 
 quarkus.apicurio-registry.devservices.image-name=${apicurio-registry.image}
+
+# Default configuration uses Legacy8ByteIdHandler for v2 compatibility mode
+# This allows Apicurio v3 libraries to work with 8-byte schema IDs (v2 format)
+mp.messaging.connector.smallrye-kafka.apicurio.registry.id-handler=io.apicurio.registry.serde.Legacy8ByteIdHandler
\ No newline at end of file
diff --git a/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaJsonSchemaIT.java b/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaJsonSchemaIT.java
index 31ddb232969..e34f06656a4 100644
--- a/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaJsonSchemaIT.java
+++ b/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaJsonSchemaIT.java
@@ -1,13 +1,8 @@
 package io.quarkus.it.kafka;
 
-import org.junit.jupiter.api.BeforeAll;
-
-import io.apicurio.registry.rest.client.RegistryClientFactory;
-import io.apicurio.rest.client.VertxHttpClientProvider;
 import io.quarkus.it.kafka.jsonschema.JsonSchemaKafkaCreator;
 import io.quarkus.test.common.QuarkusTestResource;
 import io.quarkus.test.junit.QuarkusIntegrationTest;
-import io.vertx.core.Vertx;
 
 @QuarkusIntegrationTest
 @QuarkusTestResource(value = KafkaResource.class, restrictToAnnotatedClass = true)
@@ -20,10 +15,4 @@ JsonSchemaKafkaCreator creator() {
         return creator;
     }
 
-    @BeforeAll
-    public static void setUp() {
-        // this is for the test JVM, which also uses Kafka client, which in turn also interacts with the registry
-        RegistryClientFactory.setProvider(new VertxHttpClientProvider(Vertx.vertx()));
-    }
-
 }
diff --git a/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaJsonSchemaTestBase.java b/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaJsonSchemaTestBase.java
index 729b8956fd4..a503d3a54cc 100644
--- a/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaJsonSchemaTestBase.java
+++ b/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaJsonSchemaTestBase.java
@@ -3,6 +3,7 @@
 import java.time.Duration;
 
 import org.apache.kafka.clients.consumer.ConsumerRecord;
+import org.apache.kafka.clients.consumer.ConsumerRecords;
 import org.apache.kafka.clients.consumer.KafkaConsumer;
 import org.apache.kafka.clients.producer.KafkaProducer;
 import org.apache.kafka.clients.producer.ProducerRecord;
@@ -23,32 +24,32 @@ public abstract class KafkaJsonSchemaTestBase {
 
     @Test
     public void testUrls() {
-        Assertions.assertTrue(creator().getApicurioRegistryUrl().endsWith("/apis/registry/v2"));
+        Assertions.assertTrue(creator().getApicurioRegistryUrl().endsWith("/apis/registry/v3"));
     }
 
     @Test
     public void testApicurioJsonSchemaProducer() {
-        String subscriptionName = "test-json-schema-apicurio-producer";
-
-        KafkaConsumer<Integer, Pet> consumer = creator().createApicurioConsumer(
+        try (KafkaConsumer<Integer, Pet> consumer = creator().createApicurioConsumer(
                 "test-json-schema-apicurio",
-                subscriptionName);
-        testJsonSchemaProducer(consumer, APICURIO_PATH);
+                "test-json-schema-apicurio-producer")) {
+            testJsonSchemaProducer(consumer, APICURIO_PATH);
+        }
     }
 
     @Test
     public void testApicurioJsonSchemaConsumer() {
-        String topic = "test-json-schema-apicurio-consumer";
-        KafkaProducer<Integer, Pet> producer = creator().createApicurioProducer("test-json-schema-apicurio-test");
-        testJsonSchemaConsumer(producer, APICURIO_PATH, topic);
+        try (KafkaProducer<Integer, Pet> producer = creator().createApicurioProducer("test-json-schema-apicurio-test")) {
+            testJsonSchemaConsumer(producer, APICURIO_PATH, "test-json-schema-apicurio-consumer");
+        }
     }
 
     @Test
     public void testConfluentJsonSchemaProducer() {
-        KafkaConsumer<Integer, Pet> consumer = creator().createConfluentConsumer(
+        try (KafkaConsumer<Integer, Pet> consumer = creator().createConfluentConsumer(
                 "test-json-schema-confluent",
-                "test-json-schema-confluent-producer");
-        testJsonSchemaProducer(consumer, CONFLUENT_PATH);
+                "test-json-schema-confluent-producer")) {
+            testJsonSchemaProducer(consumer, CONFLUENT_PATH);
+        }
     }
 
     @Test
@@ -62,7 +63,9 @@ protected void testJsonSchemaProducer(KafkaConsumer<Integer, Pet> consumer, Stri
                 .header("content-type", "application/json")
                 .body("{\"name\":\"neo\", \"color\":\"tricolor\"}")
                 .post(path);
-        ConsumerRecord<Integer, Pet> records = consumer.poll(Duration.ofMillis(20000)).iterator().next();
+        ConsumerRecords<Integer, Pet> poll = consumer.poll(Duration.ofMillis(20000));
+        Assertions.assertEquals(1, poll.count());
+        ConsumerRecord<Integer, Pet> records = poll.iterator().next();
         Assertions.assertEquals(records.key(), (Integer) 0);
         Pet pet = records.value();
         Assertions.assertEquals("neo", pet.getName());
diff --git a/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaResource.java b/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaResource.java
index 652fdc47b96..8da211819f9 100644
--- a/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaResource.java
+++ b/integration-tests/kafka-json-schema-apicurio2/src/test/java/io/quarkus/it/kafka/KafkaResource.java
@@ -2,10 +2,13 @@
 
 import java.util.Collections;
 import java.util.Map;
+import java.util.Properties;
 
+import io.apicurio.registry.resolver.config.SchemaResolverConfig;
 import io.quarkus.it.kafka.jsonschema.JsonSchemaKafkaCreator;
 import io.quarkus.test.common.DevServicesContext;
 import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;
+import io.vertx.core.Vertx;
 
 public class KafkaResource implements QuarkusTestResourceLifecycleManager, DevServicesContext.ContextAware {
 
@@ -18,7 +21,9 @@ public void setIntegrationTestContext(DevServicesContext context) {
         if (bootstrapServers != null) {
             String apicurioUrl = devServicesProperties.get("mp.messaging.connector.smallrye-kafka.apicurio.registry.url");
             String confluentUrl = devServicesProperties.get("mp.messaging.connector.smallrye-kafka.schema.registry.url");
-            creator = new JsonSchemaKafkaCreator(bootstrapServers, apicurioUrl, confluentUrl);
+            Properties commonProperties = new Properties();
+            commonProperties.put(SchemaResolverConfig.VERTX_INSTANCE, Vertx.vertx());
+            creator = new JsonSchemaKafkaCreator(bootstrapServers, apicurioUrl, confluentUrl, commonProperties);
         }
     }
 
diff --git a/integration-tests/main/src/main/java/io/quarkus/it/corestuff/SerializationBuildTimeInitTestEndpoint.java b/integration-tests/main/src/main/java/io/quarkus/it/corestuff/SerializationBuildTimeInitTestEndpoint.java
new file mode 100644
index 00000000000..8f3050f8c0d
--- /dev/null
+++ b/integration-tests/main/src/main/java/io/quarkus/it/corestuff/SerializationBuildTimeInitTestEndpoint.java
@@ -0,0 +1,24 @@
+package io.quarkus.it.corestuff;
+
+import java.io.IOException;
+
+import jakarta.servlet.annotation.WebServlet;
+import jakarta.servlet.http.HttpServlet;
+import jakarta.servlet.http.HttpServletRequest;
+import jakarta.servlet.http.HttpServletResponse;
+
+import io.quarkus.it.corestuff.serialization.SerializationChildBuildTimeInit;
+import io.quarkus.it.corestuff.serialization.SerializationParentBuildTimeInit;
+
+/**
+ * Ensure that classes registered for serialization are build-time-initialized
+ */
+@WebServlet(name = "CoreSerializationBuildTimeInitTestEndpoint", urlPatterns = "/core/serialization-build-time-init")
+public class SerializationBuildTimeInitTestEndpoint extends HttpServlet {
+
+    @Override
+    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
+        resp.getWriter().write(SerializationParentBuildTimeInit.value + "\t" + SerializationChildBuildTimeInit.value);
+    }
+
+}
diff --git a/integration-tests/main/src/main/java/io/quarkus/it/corestuff/serialization/SerializationChildBuildTimeInit.java b/integration-tests/main/src/main/java/io/quarkus/it/corestuff/serialization/SerializationChildBuildTimeInit.java
new file mode 100644
index 00000000000..e320160f12e
--- /dev/null
+++ b/integration-tests/main/src/main/java/io/quarkus/it/corestuff/serialization/SerializationChildBuildTimeInit.java
@@ -0,0 +1,11 @@
+package io.quarkus.it.corestuff.serialization;
+
+import io.quarkus.bootstrap.graal.ImageInfo;
+import io.quarkus.runtime.annotations.RegisterForReflection;
+
+@RegisterForReflection(serialization = true)
+public class SerializationChildBuildTimeInit extends SerializationParentBuildTimeInit {
+
+    public final static String value = "Child: " + (ImageInfo.inImageBuildtimeCode() ? "BUILD_TIME" : "RUN_TIME");
+
+}
diff --git a/integration-tests/main/src/main/java/io/quarkus/it/corestuff/serialization/SerializationParentBuildTimeInit.java b/integration-tests/main/src/main/java/io/quarkus/it/corestuff/serialization/SerializationParentBuildTimeInit.java
new file mode 100644
index 00000000000..4aaf0664666
--- /dev/null
+++ b/integration-tests/main/src/main/java/io/quarkus/it/corestuff/serialization/SerializationParentBuildTimeInit.java
@@ -0,0 +1,11 @@
+package io.quarkus.it.corestuff.serialization;
+
+import java.io.Serializable;
+
+import io.quarkus.bootstrap.graal.ImageInfo;
+
+public class SerializationParentBuildTimeInit implements Serializable {
+
+    public final static String value = "Parent: " + (ImageInfo.inImageBuildtimeCode() ? "BUILD_TIME" : "RUN_TIME");
+
+}
diff --git a/integration-tests/main/src/main/java/io/quarkus/it/rest/TestResource.java b/integration-tests/main/src/main/java/io/quarkus/it/rest/TestResource.java
index b63a061b723..078342dea50 100644
--- a/integration-tests/main/src/main/java/io/quarkus/it/rest/TestResource.java
+++ b/integration-tests/main/src/main/java/io/quarkus/it/rest/TestResource.java
@@ -245,6 +245,13 @@ public MyInterface implementor() {
         return child;
     }
 
+    @GET
+    @Path("/record")
+    @Produces("application/json")
+    public MyRecord instance() {
+        return new MyRecord(MyInterfaceWithRecord.INSTANCE);
+    }
+
     @GET
     @Path("/response")
     @Produces("application/json")
@@ -542,6 +549,28 @@ public interface MyInterface {
         String getName();
     }
 
+    public record MyRecord(MyInterfaceWithRecord nestedInterface) {
+
+    }
+
+    public interface MyInterfaceWithRecord {
+
+        MyInterfaceWithRecord INSTANCE = new MyInterfaceWithRecord() {
+            @Override
+            public NestedRecord getRecord() {
+                return new NestedRecord();
+            }
+        };
+
+        Object getRecord();
+    }
+
+    public record NestedRecord(String recordProperty) {
+        public NestedRecord() {
+            this("record-property-value");
+        }
+    }
+
     public static class MyEntity {
         private String name;
         private String value;
diff --git a/integration-tests/main/src/test/java/io/quarkus/it/main/CoreSerializationBuildTimeInitInGraalITCase.java b/integration-tests/main/src/test/java/io/quarkus/it/main/CoreSerializationBuildTimeInitInGraalITCase.java
new file mode 100644
index 00000000000..69ca91260ec
--- /dev/null
+++ b/integration-tests/main/src/test/java/io/quarkus/it/main/CoreSerializationBuildTimeInitInGraalITCase.java
@@ -0,0 +1,19 @@
+package io.quarkus.it.main;
+
+import static org.hamcrest.Matchers.is;
+
+import org.junit.jupiter.api.Test;
+
+import io.quarkus.test.junit.QuarkusIntegrationTest;
+import io.restassured.RestAssured;
+
+@QuarkusIntegrationTest
+public class CoreSerializationBuildTimeInitInGraalITCase {
+
+    @Test
+    public void testBuildTimeInitOnRegisteredForSerializationClassServlet() throws Exception {
+        RestAssured.when().get("/core/serialization-build-time-init").then()
+                .body(is("Parent: BUILD_TIME\tChild: BUILD_TIME"));
+    }
+
+}
diff --git a/integration-tests/main/src/test/java/io/quarkus/it/main/JaxRSTestCase.java b/integration-tests/main/src/test/java/io/quarkus/it/main/JaxRSTestCase.java
index a59a2b6ec8f..bd66ad7fefd 100644
--- a/integration-tests/main/src/test/java/io/quarkus/it/main/JaxRSTestCase.java
+++ b/integration-tests/main/src/test/java/io/quarkus/it/main/JaxRSTestCase.java
@@ -160,6 +160,12 @@ public void testSubSubclass() {
                         "toy", is("your toy"));
     }
 
+    @Test
+    public void testRecord() {
+        RestAssured.when().get("/test/record").then()
+                .body("nestedInterface.record.recordProperty", is("record-property-value"));
+    }
+
     @Test
     public void testImplementor() {
         RestAssured.when().get("/test/implementor").then()
diff --git a/integration-tests/maven/src/test/resources/__snapshots__/CreateExtensionMojoIT/testCreateQuarkiverseExtension/quarkus-my-quarkiverse-ext_pom.xml b/integration-tests/maven/src/test/resources/__snapshots__/CreateExtensionMojoIT/testCreateQuarkiverseExtension/quarkus-my-quarkiverse-ext_pom.xml
index 719ffe4ac02..1679c1f0c80 100644
--- a/integration-tests/maven/src/test/resources/__snapshots__/CreateExtensionMojoIT/testCreateQuarkiverseExtension/quarkus-my-quarkiverse-ext_pom.xml
+++ b/integration-tests/maven/src/test/resources/__snapshots__/CreateExtensionMojoIT/testCreateQuarkiverseExtension/quarkus-my-quarkiverse-ext_pom.xml
@@ -25,7 +25,7 @@
     </scm>
 
     <properties>
-        <compiler-plugin.version>3.14.1</compiler-plugin.version>
+        <compiler-plugin.version>3.15.0</compiler-plugin.version>
         <maven.compiler.release>17</maven.compiler.release>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
         <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
diff --git a/integration-tests/maven/src/test/resources/__snapshots__/CreateExtensionMojoIT/testCreateStandaloneExtension/my-org-my-own-ext_pom.xml b/integration-tests/maven/src/test/resources/__snapshots__/CreateExtensionMojoIT/testCreateStandaloneExtension/my-org-my-own-ext_pom.xml
index 5bc15babc63..bde4b3667ad 100644
--- a/integration-tests/maven/src/test/resources/__snapshots__/CreateExtensionMojoIT/testCreateStandaloneExtension/my-org-my-own-ext_pom.xml
+++ b/integration-tests/maven/src/test/resources/__snapshots__/CreateExtensionMojoIT/testCreateStandaloneExtension/my-org-my-own-ext_pom.xml
@@ -13,7 +13,7 @@
     </modules>
 
     <properties>
-        <compiler-plugin.version>3.14.1</compiler-plugin.version>
+        <compiler-plugin.version>3.15.0</compiler-plugin.version>
         <failsafe-plugin.version>${surefire-plugin.version}</failsafe-plugin.version>
         <maven.compiler.release>17</maven.compiler.release>
         <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
diff --git a/integration-tests/smallrye-metrics/pom.xml b/integration-tests/smallrye-metrics/pom.xml
new file mode 100644
index 00000000000..e69de29bb2d
diff --git a/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/CommonAndTestProfilesTest.java b/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/CommonAndTestProfilesTest.java
index 4deb41a4a47..c577f996119 100644
--- a/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/CommonAndTestProfilesTest.java
+++ b/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/CommonAndTestProfilesTest.java
@@ -31,7 +31,7 @@ void ordinal() {
                 .then()
                 .statusCode(OK.getStatusCode())
                 .body("value", equalTo("from foo development"))
-                .body("sourceName", equalTo("app-test-prod.yml"));
+                .body("sourceName", equalTo("https://github.com/spring-cloud-samples/config-repo/testapp-prod.yml"));
 
         given()
                 .get("/config/{name}", "info.description")
@@ -47,6 +47,6 @@ void multiple() {
                 .then()
                 .statusCode(OK.getStatusCode())
                 .body("value", equalTo("common"))
-                .body("sourceName", equalTo("app-common.yml"));
+                .body("sourceName", equalTo("common"));
     }
 }
diff --git a/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/OnlyTestProfileTest.java b/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/OnlyTestProfileTest.java
index 05ac4341470..4956e277950 100644
--- a/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/OnlyTestProfileTest.java
+++ b/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/OnlyTestProfileTest.java
@@ -31,7 +31,7 @@ void ordinal() {
                 .then()
                 .statusCode(OK.getStatusCode())
                 .body("value", equalTo("from foo development"))
-                .body("sourceName", equalTo("app-test.yml"));
+                .body("sourceName", equalTo("https://github.com/spring-cloud-samples/config-repo/testapp-prod.yml"));
 
         given()
                 .get("/config/{name}", "info.description")
diff --git a/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigServerResource.java b/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigServerResource.java
index 9a971abb631..6914e7e5ba9 100644
--- a/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigServerResource.java
+++ b/integration-tests/spring-cloud-config-client/src/test/java/io/quarkus/spring/cloud/config/client/runtime/SpringCloudConfigServerResource.java
@@ -22,11 +22,10 @@ public Map<String, String> start() {
         int port = 8089;
         try {
             httpServer = HttpServer.create(new InetSocketAddress(port), 0);
-            httpServer.createContext("/base/a-bootiful-client/test", new SpringCloudConfigServerHandler("config-test.json"));
-            httpServer.createContext("/base/a-bootiful-client/common,prod",
-                    new SpringCloudConfigServerHandler("config-common-prod.json"));
-            httpServer.createContext("/base/a-bootiful-client/common,test",
-                    new SpringCloudConfigServerHandler("config-common-test.json"));
+            httpServer.createContext("/base/a-bootiful-client/test", new SpringCloudConfigServerHandler("config.json"));
+            httpServer.createContext("/base/a-bootiful-client/prod", new SpringCloudConfigServerHandler("config.json"));
+            httpServer.createContext("/base/a-bootiful-client/common",
+                    new SpringCloudConfigServerHandler("config-common.json"));
             httpServer.start();
         } catch (Exception e) {
             throw new RuntimeException(e);
diff --git a/integration-tests/spring-cloud-config-client/src/test/resources/config-common-prod.json b/integration-tests/spring-cloud-config-client/src/test/resources/config-common-prod.json
deleted file mode 100644
index a0d216aa6d8..00000000000
--- a/integration-tests/spring-cloud-config-client/src/test/resources/config-common-prod.json
+++ /dev/null
@@ -1,30 +0,0 @@
-{
-  "name": "app",
-  "profiles": [
-    "common,prod"
-  ],
-  "propertySources": [
-    {
-      "name": "app-test-prod.yml",
-      "source": {
-        "bar": "spam",
-        "foo": "from foo development",
-        "greeting.message": "hello from spring cloud config server"
-      }
-    },
-    {
-      "name": "app-common.yml",
-      "source": {
-        "foo": "common",
-        "common": "common"
-      }
-    },
-    {
-      "name": "app.yml",
-      "source": {
-        "info.description": "Sample",
-        "foo": "baz"
-      }
-    }
-  ]
-}
diff --git a/integration-tests/spring-cloud-config-client/src/test/resources/config-common-test.json b/integration-tests/spring-cloud-config-client/src/test/resources/config-common-test.json
deleted file mode 100644
index 552e8ee1907..00000000000
--- a/integration-tests/spring-cloud-config-client/src/test/resources/config-common-test.json
+++ /dev/null
@@ -1,30 +0,0 @@
-{
-  "name": "app",
-  "profiles": [
-    "common,test"
-  ],
-  "propertySources": [
-    {
-      "name": "app-test-prod.yml",
-      "source": {
-        "bar": "spam",
-        "foo": "from foo development",
-        "greeting.message": "hello from spring cloud config server"
-      }
-    },
-    {
-      "name": "app-common.yml",
-      "source": {
-        "foo": "common",
-        "common": "common"
-      }
-    },
-    {
-      "name": "app.yml",
-      "source": {
-        "info.description": "Sample",
-        "foo": "baz"
-      }
-    }
-  ]
-}
diff --git a/integration-tests/spring-cloud-config-client/src/test/resources/config-common.json b/integration-tests/spring-cloud-config-client/src/test/resources/config-common.json
new file mode 100644
index 00000000000..551470dd60b
--- /dev/null
+++ b/integration-tests/spring-cloud-config-client/src/test/resources/config-common.json
@@ -0,0 +1,18 @@
+{
+  "name": "common",
+  "profiles": [
+    "common"
+  ],
+  "label": "master",
+  "version": "bb51f4173258ae3481c61b95b503c13862ccfba7",
+  "state": null,
+  "propertySources": [
+    {
+      "name": "common",
+      "source": {
+        "foo": "common",
+        "common": "common"
+      }
+    }
+  ]
+}
diff --git a/integration-tests/spring-cloud-config-client/src/test/resources/config-test.json b/integration-tests/spring-cloud-config-client/src/test/resources/config.json
similarity index 70%
rename from integration-tests/spring-cloud-config-client/src/test/resources/config-test.json
rename to integration-tests/spring-cloud-config-client/src/test/resources/config.json
index f68761f5092..0768660a35c 100644
--- a/integration-tests/spring-cloud-config-client/src/test/resources/config-test.json
+++ b/integration-tests/spring-cloud-config-client/src/test/resources/config.json
@@ -1,14 +1,14 @@
 {
   "name": "a-bootiful-client",
   "profiles": [
-    "test"
+    "prod","test"
   ],
   "label": "master",
   "version": "bb51f4173258ae3481c61b95b503c13862ccfba7",
   "state": null,
   "propertySources": [
     {
-      "name": "app-test.yml",
+      "name": "https://github.com/spring-cloud-samples/config-repo/testapp-prod.yml",
       "source": {
         "bar": "spam",
         "foo": "from foo development",
@@ -16,7 +16,7 @@
       }
     },
     {
-      "name": "app.yml",
+      "name": "https://github.com/spring-cloud-samples/config-repo/application.yml",
       "source": {
         "info.description": "Sample",
         "foo": "baz"
diff --git a/pom.xml b/pom.xml
index ff188e5da5e..fd99c9c0352 100644
--- a/pom.xml
+++ b/pom.xml
@@ -71,17 +71,17 @@
         <jacoco.version>0.8.14</jacoco.version>
         <kubernetes-client.version>7.5.2</kubernetes-client.version> <!-- Please check with Java Operator SDK team before updating -->
         <rest-assured.version>5.5.6</rest-assured.version>
-        <hibernate-orm.version>7.2.2.Final</hibernate-orm.version> <!-- WARNING when updating, also align the versions below -->
+        <hibernate-orm.version>7.2.3.Final</hibernate-orm.version> <!-- WARNING when updating, also align the versions below -->
         <jakarta.persistence-api.version>3.2.0</jakarta.persistence-api.version> <!-- version controlled by Hibernate ORM's needs -->
         <jakarta.data-api.version>1.0.1</jakarta.data-api.version> <!-- version controlled by Hibernate ORM's needs -->
         <antlr.version>4.13.2</antlr.version> <!-- version controlled by Hibernate ORM's needs -->
         <bytebuddy.version>1.17.8</bytebuddy.version> <!-- version controlled by Hibernate ORM's needs -->
         <geolatte.version>1.10</geolatte.version> <!-- version controlled by Hibernate ORM's needs -->
         <hibernate-models.version>1.0.1</hibernate-models.version> <!-- version controlled by Hibernate ORM's needs -->
-        <hibernate-reactive.version>3.2.1.Final</hibernate-reactive.version> <!-- highly sensitive to Hibernate ORM upgrades -->
+        <hibernate-reactive.version>3.2.2.Final</hibernate-reactive.version> <!-- highly sensitive to Hibernate ORM upgrades -->
         <hibernate-validator.version>9.1.0.Final</hibernate-validator.version>
         <hibernate-search.version>8.2.1.Final</hibernate-search.version>
-        <hibernate-tools.version>7.2.2.Final</hibernate-tools.version>
+        <hibernate-tools.version>7.2.3.Final</hibernate-tools.version>
 
         <!-- Make sure to check compatibility between these 2 gRPC components before upgrade -->
         <grpc.version>1.78.0</grpc.version> <!-- when updating, verify if following versions should not be updated too: -->
@@ -91,7 +91,7 @@
         <protoc.version>4.33.2</protoc.version>
         <protobuf-java.version>${protoc.version}</protobuf-java.version>
         <protobuf-kotlin.version>${protoc.version}</protobuf-kotlin.version>
-        <proto-google-common-protos.version>2.65.0</proto-google-common-protos.version>
+        <proto-google-common-protos.version>2.65.1</proto-google-common-protos.version>
         <perfmark.version>0.27.0</perfmark.version><!-- dependency of io.grpc:grpc-core not managed in io.grpc:grpc-bom -->
 
         <!-- Used in the build parent and test BOM (for the JUnit plugin) and in the BOM (for the API) -->
diff --git a/test-framework/common/src/main/java/io/quarkus/test/common/TestHostLauncher.java b/test-framework/common/src/main/java/io/quarkus/test/common/TestHostLauncher.java
index 0c14a526432..7e28baa7754 100644
--- a/test-framework/common/src/main/java/io/quarkus/test/common/TestHostLauncher.java
+++ b/test-framework/common/src/main/java/io/quarkus/test/common/TestHostLauncher.java
@@ -3,6 +3,10 @@
 import java.io.IOException;
 import java.util.Map;
 import java.util.Optional;
+import java.util.OptionalInt;
+
+import org.eclipse.microprofile.config.Config;
+import org.eclipse.microprofile.config.ConfigProvider;
 
 /**
  * A launcher that simply sets the {@code quarkus.http.host} property based on the value {@code quarkus.http.test-host}
@@ -15,9 +19,23 @@ public class TestHostLauncher implements ArtifactLauncher {
 
     @Override
     public Optional<ListeningAddress> start() throws IOException {
+        Config config = ConfigProvider.getConfig();
+        // TODO - Remove this SystemProperty set / get
         // set 'quarkus.http.host' to ensure that RestAssured targets the proper host
         previousHost = System.setProperty("quarkus.http.host", System.getProperty("quarkus.http.test-host"));
-        return Optional.empty();
+
+        // We need to manually query and set defaults, because this runs in IT and VertxHttpConfig is not available
+        boolean testSslEnabled = config.getOptionalValue("quarkus.http.test-ssl-enabled", boolean.class).orElse(false);
+        int port;
+        String protocol;
+        if (testSslEnabled) {
+            port = config.getValue("quarkus.http.test-ssl-port", OptionalInt.class).orElse(8444);
+            protocol = "https";
+        } else {
+            port = config.getValue("quarkus.http.test-port", OptionalInt.class).orElse(8081);
+            protocol = "http";
+        }
+        return Optional.of(new ListeningAddress(port, protocol));
     }
 
     @Override
diff --git a/test-framework/jacoco/deployment/src/main/java/io/quarkus/jacoco/deployment/JacocoProcessor.java b/test-framework/jacoco/deployment/src/main/java/io/quarkus/jacoco/deployment/JacocoProcessor.java
index adb7e422a92..26c84f9a8bc 100644
--- a/test-framework/jacoco/deployment/src/main/java/io/quarkus/jacoco/deployment/JacocoProcessor.java
+++ b/test-framework/jacoco/deployment/src/main/java/io/quarkus/jacoco/deployment/JacocoProcessor.java
@@ -83,6 +83,7 @@ void transform(BuildProducer<BytecodeTransformerBuildItem> bytecodeTransformers,
             dataFilePath = outputDir.resolve(JacocoConfig.JACOCO_QUARKUS_EXEC);
         }
         String dataFile = dataFilePath.toString();
+        log.debugf("JaCoCo destFile: %s", dataFilePath);
 
         System.setProperty("jacoco-agent.destfile", dataFile);
         System.setProperty("jacoco-agent.jmx", "true");
@@ -94,6 +95,7 @@ void transform(BuildProducer<BytecodeTransformerBuildItem> bytecodeTransformers,
         Set<String> transformed = new HashSet<>();
         Collection<IndexDependencyConfig> instrumentArtifacts = config.instrumentArtifacts().values();
         Set<GAC> instrumented = new HashSet<>();
+
         if (instrumentArtifacts.isEmpty()) {
             // By default, instrument classes from all application archives
             for (ApplicationArchive archive : appArchives) {
@@ -140,11 +142,12 @@ void transform(BuildProducer<BytecodeTransformerBuildItem> bytecodeTransformers,
         // for a single test suite execution (all tests executed in a single module).
         // Note that for @QuarkusTest a new build can be triggered e.g. by @TestProfile.
         // And for @QuarkusUnitTest each test class triggers a separate build.
-        // So the system property check below will help.
-        // However, it will not help for multi-module projects:
+        // So the system property check below will help for single module.
+        // However, it will not help for multi-module projects if a shared data file is used:
         //
         // /my-extension-project
         // 
+        //  /target/jacoco-quarkus.exec
         //  /foo
         //     runtime
         //     deployment
@@ -182,14 +185,11 @@ void transform(BuildProducer<BytecodeTransformerBuildItem> bytecodeTransformers,
             } else {
                 reportDir = outputDir.resolve(JacocoConfig.JACOCO_REPORT);
             }
+            log.debugf("JaCoCo report dir: %s", reportDir);
+
             info.reportDir = reportDir.toString();
             info.errorFile = reportDir.resolve("error.txt");
             Files.deleteIfExists(info.errorFile);
-            Set<String> classes = new HashSet<>();
-            info.classFiles = classes;
-
-            Set<String> sources = new HashSet<>();
-            info.sourceDirectories = sources;
             info.artifactId = buildSystemTargetBuildItem.getBaseName();
 
             ReportCreator reportCreator = new ReportCreator(info, config);
@@ -200,20 +200,21 @@ void transform(BuildProducer<BytecodeTransformerBuildItem> bytecodeTransformers,
             // Add classes and sources for the current build
             if (instrumentArtifacts.isEmpty()) {
                 if (appModel.getApplicationModule() != null) {
-                    addDependency(appModel.getAppArtifact(), config, projectRoot, info, includes, excludes);
+                    addDependency(appModel.getAppArtifact(), config, projectRoot, info, includes, excludes, null);
                 }
                 for (ResolvedDependency d : appModel.getDependencies()) {
                     // we can't use d.isWorkspaceModule() for now for some Gradle projects, which is why we check whether a workspace module is not null
                     if (d.isRuntimeCp() && d.getWorkspaceModule() != null) {
-                        addDependency(d, config, projectRoot, info, includes, excludes);
+                        addDependency(d, config, projectRoot, info, includes, excludes, null);
                     }
                 }
             } else {
+                // For instrumented artifacts we always use the current data file when processing a dependency
                 for (ResolvedDependency d : appModel.getDependencies()) {
                     if (d.isRuntimeCp()
                             && d.getWorkspaceModule() != null
                             && instrumented.contains(new GAC(d.getGroupId(), d.getArtifactId(), d.getClassifier()))) {
-                        addDependency(d, config, projectRoot, info, includes, excludes);
+                        addDependency(d, config, projectRoot, info, includes, excludes, dataFilePath);
                     }
                 }
             }
@@ -248,10 +249,11 @@ void transform(BuildProducer<BytecodeTransformerBuildItem> bytecodeTransformers,
     }
 
     private void addDependency(ResolvedDependency module, JacocoConfig config, Path projectRoot, ReportInfo info,
-            String includes,
-            String excludes) throws Exception {
-        Path dataFile = getFilePath(config.dataFile(), projectRoot, module.getWorkspaceModule().getBuildDir().toPath(),
-                JacocoConfig.JACOCO_QUARKUS_EXEC);
+            String includes, String excludes, Path dataFile) throws Exception {
+        if (dataFile == null) {
+            dataFile = getFilePath(config.dataFile(), projectRoot, module.getWorkspaceModule().getBuildDir().toPath(),
+                    JacocoConfig.JACOCO_QUARKUS_EXEC);
+        }
         info.savedData.add(dataFile.toAbsolutePath().toString());
         if (module.getSources() == null) {
             return;
@@ -319,7 +321,7 @@ public byte[] apply(String className, byte[] bytes) {
 
     public static boolean archiveMatches(ArtifactKey key, String groupId, Optional<String> artifactId,
             Optional<String> classifier) {
-        if (Objects.equals(key.getGroupId(), groupId)
+        if (key != null && Objects.equals(key.getGroupId(), groupId)
                 && (artifactId.isEmpty() || Objects.equals(key.getArtifactId(), artifactId.get()))) {
             if (classifier.isPresent() && Objects.equals(key.getClassifier(), classifier.get())) {
                 return true;
@@ -357,7 +359,7 @@ private static Path findProjectRoot(Path outputDirectory) {
                     || Files.exists(currentPath.resolve(Paths.get("config", "application.yml")))) {
                 return currentPath.normalize();
             }
-            if (currentPath.getParent() != null && Files.exists(currentPath.getParent())) {
+            if (currentPath.getParent() != null) {
                 currentPath = currentPath.getParent();
             } else {
                 return null;
diff --git a/test-framework/jacoco/runtime/src/main/java/io/quarkus/jacoco/runtime/ReportCreator.java b/test-framework/jacoco/runtime/src/main/java/io/quarkus/jacoco/runtime/ReportCreator.java
index 51f767c06a8..b384ff86e59 100644
--- a/test-framework/jacoco/runtime/src/main/java/io/quarkus/jacoco/runtime/ReportCreator.java
+++ b/test-framework/jacoco/runtime/src/main/java/io/quarkus/jacoco/runtime/ReportCreator.java
@@ -26,8 +26,12 @@
 import org.jacoco.report.csv.CSVFormatter;
 import org.jacoco.report.html.HTMLFormatter;
 import org.jacoco.report.xml.XMLFormatter;
+import org.jboss.logging.Logger;
 
 public class ReportCreator implements Runnable {
+
+    private static final Logger LOG = Logger.getLogger(ReportCreator.class);
+
     private final ReportInfo reportInfo;
     private final JacocoConfig config;
     private final DataFileWatch dataFileWatch;
@@ -67,6 +71,7 @@ private void doRun() {
             for (String i : reportInfo.savedData) {
                 File file = new File(i);
                 if (file.exists()) {
+                    LOG.debugf("JaCoCo is loading data for report from: %s", file);
                     loader.load(file);
                 }
             }
diff --git a/test-framework/jacoco/runtime/src/main/java/io/quarkus/jacoco/runtime/ReportInfo.java b/test-framework/jacoco/runtime/src/main/java/io/quarkus/jacoco/runtime/ReportInfo.java
index 32f39fa136c..1f656ffa7da 100644
--- a/test-framework/jacoco/runtime/src/main/java/io/quarkus/jacoco/runtime/ReportInfo.java
+++ b/test-framework/jacoco/runtime/src/main/java/io/quarkus/jacoco/runtime/ReportInfo.java
@@ -21,8 +21,8 @@ public class ReportInfo {
     public String reportDir;
     public Path dataFile;
     public final List<String> savedData = new ArrayList<>();
-    public Set<String> sourceDirectories;
-    public Set<String> classFiles;
+    public Set<String> sourceDirectories = new HashSet<>();
+    public Set<String> classFiles = new HashSet<>();
     public String artifactId;
     public Path errorFile;
 
diff --git a/test-framework/junit-common/pom.xml b/test-framework/junit-common/pom.xml
new file mode 100644
index 00000000000..a05efa3bd5d
--- /dev/null
+++ b/test-framework/junit-common/pom.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>io.quarkus</groupId>
+        <artifactId>quarkus-test-framework</artifactId>
+        <version>999-SNAPSHOT</version>
+    </parent>
+
+    <artifactId>quarkus-junit-common</artifactId>
+    <name>Quarkus - Test Framework - JUnit common elements</name>
+
+    <description>Elements shared with quarkus-junit-internal and quarkus-junit</description>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.jboss.logging</groupId>
+            <artifactId>jboss-logging</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-api</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-params</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-engine</artifactId>
+        </dependency>
+    </dependencies>
+
+</project>
diff --git a/test-framework/junit-internal/src/main/java/io/quarkus/test/ClearCache.java b/test-framework/junit-common/src/main/java/io/quarkus/test/junit/common/ClearCache.java
similarity index 98%
rename from test-framework/junit-internal/src/main/java/io/quarkus/test/ClearCache.java
rename to test-framework/junit-common/src/main/java/io/quarkus/test/junit/common/ClearCache.java
index 179ef1d5e52..203464469fc 100644
--- a/test-framework/junit-internal/src/main/java/io/quarkus/test/ClearCache.java
+++ b/test-framework/junit-common/src/main/java/io/quarkus/test/junit/common/ClearCache.java
@@ -1,4 +1,4 @@
-package io.quarkus.test;
+package io.quarkus.test.junit.common;
 
 import java.beans.Introspector;
 import java.lang.reflect.Field;
diff --git a/test-framework/junit-internal/pom.xml b/test-framework/junit-internal/pom.xml
index b8edceccd0d..7dd7ca5785b 100644
--- a/test-framework/junit-internal/pom.xml
+++ b/test-framework/junit-internal/pom.xml
@@ -43,6 +43,10 @@
             <groupId>io.quarkus</groupId>
             <artifactId>quarkus-junit-config</artifactId>
         </dependency>
+        <dependency>
+            <groupId>io.quarkus</groupId>
+            <artifactId>quarkus-junit-common</artifactId>
+        </dependency>
         <dependency>
             <groupId>io.quarkus</groupId>
             <artifactId>quarkus-core</artifactId>
diff --git a/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusDevModeTest.java b/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusDevModeTest.java
index 682435d9b20..824fcc425f7 100644
--- a/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusDevModeTest.java
+++ b/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusDevModeTest.java
@@ -67,6 +67,7 @@
 import io.quarkus.test.common.TestResourceManager;
 import io.quarkus.test.common.http.TestHTTPResourceManager;
 import io.quarkus.test.config.TestConfigProviderResolver;
+import io.quarkus.test.junit.common.ClearCache;
 import io.quarkus.value.registry.ValueRegistry;
 
 /**
diff --git a/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusUnitTest.java b/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusUnitTest.java
index ce2d682cafb..10db1e0e729 100644
--- a/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusUnitTest.java
+++ b/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusUnitTest.java
@@ -75,6 +75,7 @@
 import io.quarkus.test.common.TestConfigUtil;
 import io.quarkus.test.common.TestResourceManager;
 import io.quarkus.test.common.http.TestHTTPResourceManager;
+import io.quarkus.test.junit.common.ClearCache;
 import io.quarkus.value.registry.ValueRegistry;
 
 /**
diff --git a/test-framework/junit/pom.xml b/test-framework/junit/pom.xml
index fc533e2a00a..fb6286bdc78 100644
--- a/test-framework/junit/pom.xml
+++ b/test-framework/junit/pom.xml
@@ -39,6 +39,10 @@
             <groupId>io.quarkus</groupId>
             <artifactId>quarkus-junit-config</artifactId>
         </dependency>
+        <dependency>
+            <groupId>io.quarkus</groupId>
+            <artifactId>quarkus-junit-common</artifactId>
+        </dependency>
         <dependency>
             <groupId>org.junit.jupiter</groupId>
             <artifactId>junit-jupiter</artifactId>
diff --git a/test-framework/junit/src/main/java/io/quarkus/test/junit/NativeDevServicesHandler.java b/test-framework/junit/src/main/java/io/quarkus/test/junit/NativeDevServicesHandler.java
index b4b32677504..6e7ae1353fb 100644
--- a/test-framework/junit/src/main/java/io/quarkus/test/junit/NativeDevServicesHandler.java
+++ b/test-framework/junit/src/main/java/io/quarkus/test/junit/NativeDevServicesHandler.java
@@ -5,6 +5,7 @@
 import java.util.function.BiConsumer;
 
 import io.quarkus.builder.BuildResult;
+import io.quarkus.deployment.builditem.DevServicesAdditionalConfigBuildItem;
 import io.quarkus.deployment.builditem.DevServicesCustomizerBuildItem;
 import io.quarkus.deployment.builditem.DevServicesLauncherConfigResultBuildItem;
 import io.quarkus.deployment.builditem.DevServicesNetworkIdBuildItem;
@@ -29,8 +30,10 @@ public void accept(Object o, BuildResult buildResult) {
         List<DevServicesResultBuildItem> devServices = buildResult.consumeMulti(DevServicesResultBuildItem.class);
         DevServicesRegistryBuildItem devServicesRegistry = buildResult.consumeOptional(DevServicesRegistryBuildItem.class);
         List<DevServicesCustomizerBuildItem> customizers = buildResult.consumeMulti(DevServicesCustomizerBuildItem.class);
+        List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems = buildResult
+                .consumeMulti(DevServicesAdditionalConfigBuildItem.class);
         if (devServicesRegistry != null) {
-            devServicesRegistry.startAll(devServices, customizers, null);
+            devServicesRegistry.startAll(devServices, customizers, additionalConfigBuildItems, null);
             for (Map.Entry<String, String> entry : devServicesRegistry.getConfigForAllRunningServices().entrySet()) {
                 propertyConsumer.accept(entry.getKey(), entry.getValue());
             }
diff --git a/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusIntegrationTestExtension.java b/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusIntegrationTestExtension.java
index ebfd8ee8e29..a94b005ba93 100644
--- a/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusIntegrationTestExtension.java
+++ b/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusIntegrationTestExtension.java
@@ -283,17 +283,17 @@ public void close() throws Exception {
                                     System.setProperty(i.getKey(), i.getValue());
                                 }
                                 // recalculate the property names that may have changed with the restore
-                                ConfigProvider.getConfig().unwrap(SmallRyeConfig.class).getLatestPropertyNames();
+                                config.getLatestPropertyNames();
                             }
                         }
                     });
             additionalProperties.putAll(resourceManagerProps);
             // recalculate the property names that may have changed with testProfileAndProperties.properties
-            ConfigProvider.getConfig().unwrap(SmallRyeConfig.class).getLatestPropertyNames();
+            config.getLatestPropertyNames();
 
             ArtifactLauncher<?> launcher;
-            String testHost = System.getProperty("quarkus.http.test-host");
-            if ((testHost != null) && !testHost.isEmpty()) {
+            Optional<String> testHost = config.getOptionalValue("quarkus.http.test-host", String.class);
+            if (testHost.isPresent()) {
                 launcher = new TestHostLauncher();
             } else {
                 String target = TestConfigUtil.runTarget(config);
diff --git a/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusTestExtension.java b/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusTestExtension.java
index 8636411fd1f..7564e8fb1d9 100644
--- a/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusTestExtension.java
+++ b/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusTestExtension.java
@@ -76,6 +76,7 @@
 import io.quarkus.test.common.http.TestHTTPResourceManager;
 import io.quarkus.test.junit.callback.QuarkusTestContext;
 import io.quarkus.test.junit.callback.QuarkusTestMethodContext;
+import io.quarkus.test.junit.common.ClearCache;
 import io.quarkus.value.registry.ValueRegistry;
 import io.smallrye.config.SmallRyeConfigProviderResolver;
 
@@ -619,6 +620,11 @@ private QuarkusTestExtensionState ensureStarted(ExtensionContext extensionContex
         }
         cl.getCuratedApplication().setEligibleForReuse(isSameCuratedApplication);
 
+        // Let's clear the class-based caches of JDK/libraries when we switch to another application
+        if (!isSameCuratedApplication) {
+            ClearCache.clearCaches();
+        }
+
         // TODO if classes are misordered, say because someone overrode the ordering, and there are profiles or resources,
         // we could try to start and application which has already been started, and fail with a mysterious error about
         // null shutdown contexts; we should try and detect that case, and give a friendlier error message
diff --git a/test-framework/junit/src/main/java/io/quarkus/test/junit/classloading/FacadeClassLoader.java b/test-framework/junit/src/main/java/io/quarkus/test/junit/classloading/FacadeClassLoader.java
index b1391b1c84d..504065c9112 100644
--- a/test-framework/junit/src/main/java/io/quarkus/test/junit/classloading/FacadeClassLoader.java
+++ b/test-framework/junit/src/main/java/io/quarkus/test/junit/classloading/FacadeClassLoader.java
@@ -623,6 +623,18 @@ private static void initialiseTestConfig(ClassLoader loader) throws ClassNotFoun
 
         configProviderResolverClass.getDeclaredMethod("setInstance", configProviderResolverClass)
                 .invoke(null, testConfigProviderResolver);
+
+        if (loader instanceof QuarkusClassLoader quarkusClassLoader) {
+            quarkusClassLoader.addCloseTask(() -> {
+                try {
+                    Method releaseMethod = testConfigProviderResolverClass.getMethod("releaseConfig",
+                            ClassLoader.class);
+                    releaseMethod.invoke(testConfigProviderResolver, quarkusClassLoader);
+                } catch (Exception e) {
+                    throw new IllegalStateException("Unable to release config of QuarkusTestConfigProviderResolver", e);
+                }
+            });
+        }
     }
 
     public boolean isServiceLoaderMechanism() {
diff --git a/test-framework/pom.xml b/test-framework/pom.xml
index 510383f3c0f..9b8dd7067c3 100644
--- a/test-framework/pom.xml
+++ b/test-framework/pom.xml
@@ -19,6 +19,7 @@
         <module>h2</module>
         <module>grpc</module>
         <module>kubernetes-client</module>
+        <module>junit-common</module>
         <module>junit-config</module>
         <module>junit-internal</module>
         <module>junit</module>
