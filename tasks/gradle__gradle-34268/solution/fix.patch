diff --git a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/BuildProgressArea.java b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/BuildProgressArea.java
index dbb4a0b376f..0f171a6ec84 100644
--- a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/BuildProgressArea.java
+++ b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/BuildProgressArea.java
@@ -21,7 +21,6 @@
 public interface BuildProgressArea {
     // TODO(ew): Consider whether this belongs in Console or here
     StyledLabel getProgressBar();
-    StyledLabel getCursorParkLine();
     List<StyledLabel> getBuildProgressLabels();
     void resizeBuildProgressTo(int numberOfLabels);
     void setVisible(boolean isVisible);
diff --git a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/MultiLineBuildProgressArea.java b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/MultiLineBuildProgressArea.java
index 533552d3944..dcebb54ff7a 100644
--- a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/MultiLineBuildProgressArea.java
+++ b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/MultiLineBuildProgressArea.java
@@ -25,23 +25,25 @@ public class MultiLineBuildProgressArea implements BuildProgressArea {
     private final List<DefaultRedrawableLabel> entries = new ArrayList<DefaultRedrawableLabel>(2);
     private final DefaultRedrawableLabel progressBarLabel;
 
-    private final List<StyledLabel> buildProgressLabels = new ArrayList<>();
+    private final List<StyledLabel> buildProgressLabels = new ArrayList<StyledLabel>();
     private final DefaultRedrawableLabel parkingLabel;
     private final Cursor statusAreaPos = new Cursor();
     private boolean isVisible;
     private boolean isPreviouslyVisible;
 
     public MultiLineBuildProgressArea() {
-        progressBarLabel = newLabel(0);
+        int row = 0;
+
+        progressBarLabel = newLabel(row--);
         entries.add(progressBarLabel);
 
         // Parking space for the write cursor
-        parkingLabel = newLabel(-1);
+        parkingLabel = newLabel(row--);
         entries.add(parkingLabel);
     }
 
-    private static DefaultRedrawableLabel newLabel(int row) {
-        return new DefaultRedrawableLabel(Cursor.at(row, 0));
+    private DefaultRedrawableLabel newLabel(int row) {
+        return new DefaultRedrawableLabel(Cursor.at(row--, 0));
     }
 
     @Override
@@ -54,11 +56,6 @@ public StyledLabel getProgressBar() {
         return progressBarLabel;
     }
 
-    @Override
-    public StyledLabel getCursorParkLine() {
-        return parkingLabel;
-    }
-
     /**
      * The location of the top left of this progress area.
      */
diff --git a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/WorkInProgressRenderer.java b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/WorkInProgressRenderer.java
index 9edd8723e08..9972471d25d 100644
--- a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/WorkInProgressRenderer.java
+++ b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/WorkInProgressRenderer.java
@@ -16,6 +16,7 @@
 
 package org.gradle.internal.logging.console;
 
+import com.google.common.base.Function;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import org.gradle.internal.logging.events.EndOutputEvent;
@@ -43,23 +44,23 @@ public class WorkInProgressRenderer implements OutputEventListener {
     private final DefaultWorkInProgressFormatter labelFormatter;
     private final ConsoleLayoutCalculator consoleLayoutCalculator;
 
-    private final List<OutputEvent> queue = new ArrayList<>();
+    private final List<OutputEvent> queue = new ArrayList<OutputEvent>();
 
     // Track all unused labels to display future progress operation
     private final Deque<StyledLabel> unusedProgressLabels;
 
     // Track currently associated label with its progress operation
-    private final Map<OperationIdentifier, AssociationLabel> operationIdToAssignedLabels = new HashMap<>();
+    private final Map<OperationIdentifier, AssociationLabel> operationIdToAssignedLabels = new HashMap<OperationIdentifier, AssociationLabel>();
 
     // Track any progress operation that either can't be display due to label shortage or child progress operation is already been displayed
-    private final Deque<ProgressOperation> unassignedProgressOperations = new ArrayDeque<>();
+    private final Deque<ProgressOperation> unassignedProgressOperations = new ArrayDeque<ProgressOperation>();
 
     public WorkInProgressRenderer(OutputEventListener listener, BuildProgressArea progressArea, DefaultWorkInProgressFormatter labelFormatter, ConsoleLayoutCalculator consoleLayoutCalculator) {
         this.listener = listener;
         this.progressArea = progressArea;
         this.labelFormatter = labelFormatter;
         this.consoleLayoutCalculator = consoleLayoutCalculator;
-        this.unusedProgressLabels = new ArrayDeque<>(progressArea.getBuildProgressLabels());
+        this.unusedProgressLabels = new ArrayDeque<StyledLabel>(progressArea.getBuildProgressLabels());
     }
 
     @Override
@@ -77,7 +78,12 @@ public void onOutput(OutputEvent event) {
 
     // Transform ProgressCompleteEvent into their corresponding progress OperationIdentifier.
     private Set<OperationIdentifier> toOperationIdSet(Iterable<ProgressCompleteEvent> events) {
-        return Sets.newHashSet(Iterables.transform(events, ProgressCompleteEvent::getProgressOperationId));
+        return Sets.newHashSet(Iterables.transform(events, new Function<ProgressCompleteEvent, OperationIdentifier>() {
+            @Override
+            public OperationIdentifier apply(ProgressCompleteEvent event) {
+                return event.getProgressOperationId();
+            }
+        }));
     }
 
     private void resizeTo(int newBuildProgressLabelCount) {
@@ -117,7 +123,6 @@ private void attach(ProgressOperation operation) {
         // Try to use a new label
         if (unusedProgressLabels.isEmpty()) {
             unassignedProgressOperations.add(operation);
-            reportLinesNotShown();
         } else {
             attach(operation, unusedProgressLabels.pop());
         }
@@ -140,7 +145,6 @@ private void detach(ProgressOperation operation) {
             attach(operation.getParent());
         } else if (!unassignedProgressOperations.isEmpty()) {
             attach(unassignedProgressOperations.pop());
-            reportLinesNotShown();
         }
     }
 
@@ -154,22 +158,6 @@ private void unshow(ProgressOperation operation) {
             unusedProgressLabels.push(association.label);
         }
         unassignedProgressOperations.remove(operation);
-        reportLinesNotShown();
-    }
-
-    private void reportLinesNotShown() {
-        int linesNotShown = unassignedProgressOperations.size();
-
-        String text;
-        if (linesNotShown == 0) {
-            text = "";
-        } else if (linesNotShown == 1) {
-            text = "  (1 line not showing)";
-        } else {
-            text = "  (" + linesNotShown + " lines not showing)";
-        }
-
-        progressArea.getCursorParkLine().setText(text);
     }
 
     // Any ProgressOperation in the parent chain has a message, the operation is considered renderable.
@@ -190,7 +178,7 @@ private void renderNow() {
 
         // Skip processing of any operations that both start and complete in the queue
         Set<OperationIdentifier> completeEventOperationIds = toOperationIdSet(Iterables.filter(queue, ProgressCompleteEvent.class));
-        Set<OperationIdentifier> operationIdsToSkip = new HashSet<>();
+        Set<OperationIdentifier> operationIdsToSkip = new HashSet<OperationIdentifier>();
 
         for (OutputEvent event : queue) {
             if (event instanceof ProgressStartEvent) {
diff --git a/platforms/documentation/docs/src/docs/release/notes.md b/platforms/documentation/docs/src/docs/release/notes.md
index 97bc8458f22..ca7b077a4d6 100644
--- a/platforms/documentation/docs/src/docs/release/notes.md
+++ b/platforms/documentation/docs/src/docs/release/notes.md
@@ -80,17 +80,6 @@ vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv -->
 #### Plain console with colors
 
 This release adds a new value for the `--console` command line option called `colored`, which enables color output for the console while omitting rich features such as progress bars.
-See ![this recording](release-notes-assets/colored-console.gif) for a demo.
-
-#### Off-screen lines reported in rich console
-
-This release adds a status line to the `rich` console that reports the number of in-progress events not currently visible on screen.
-
-\```console
-> (2 lines not showing)
-\```
-This occurs when there are more ongoing events than the console has lines available to display them.
-See ![this recording](release-notes-assets/off-screen-lines.gif) for a demo.
 
 
 ### Build authoring improvements
diff --git a/platforms/documentation/docs/src/docs/release/release-notes-assets/colored-console.gif b/platforms/documentation/docs/src/docs/release/release-notes-assets/colored-console.gif
deleted file mode 100644
index 26ceb70eebd..00000000000
Binary files a/platforms/documentation/docs/src/docs/release/release-notes-assets/colored-console.gif and /dev/null differ
diff --git a/platforms/documentation/docs/src/docs/release/release-notes-assets/off-screen-lines.gif b/platforms/documentation/docs/src/docs/release/release-notes-assets/off-screen-lines.gif
deleted file mode 100644
index c63e80fa9ac..00000000000
Binary files a/platforms/documentation/docs/src/docs/release/release-notes-assets/off-screen-lines.gif and /dev/null differ
diff --git a/platforms/documentation/docs/src/docs/userguide/reference/core-plugins/build_dashboard_plugin.adoc b/platforms/documentation/docs/src/docs/userguide/reference/core-plugins/build_dashboard_plugin.adoc
index 209b3fad152..b3c09a4c8f0 100644
--- a/platforms/documentation/docs/src/docs/userguide/reference/core-plugins/build_dashboard_plugin.adoc
+++ b/platforms/documentation/docs/src/docs/userguide/reference/core-plugins/build_dashboard_plugin.adoc
@@ -15,9 +15,6 @@
 [[build_dashboard_plugin]]
 = The Build Dashboard Plugin
 
-WARNING: The Build Dashboard Plugin is not fully compatible with the <<configuration_cache_status.adoc#config_cache:plugins:core,Configuration Cache>>.
-When applied, the Configuration Cache is automatically disabled.
-
 The Build Dashboard plugin can be used to generate a single HTML dashboard that provides a single point of access to all of the reports generated by a build.
 
 [[sec:build_dashboard_usage]]
diff --git a/platforms/jvm/java-platform/src/integTest/groovy/org/gradle/internal/component/model/JavaEcosystemAttributeMatcherTest.groovy b/platforms/jvm/java-platform/src/integTest/groovy/org/gradle/internal/component/model/JavaEcosystemAttributeMatcherTest.groovy
index 53b28e9daa6..f8534fe88ab 100644
--- a/platforms/jvm/java-platform/src/integTest/groovy/org/gradle/internal/component/model/JavaEcosystemAttributeMatcherTest.groovy
+++ b/platforms/jvm/java-platform/src/integTest/groovy/org/gradle/internal/component/model/JavaEcosystemAttributeMatcherTest.groovy
@@ -21,12 +21,11 @@ import org.gradle.api.attributes.LibraryElements
 import org.gradle.api.attributes.Usage
 import org.gradle.api.attributes.java.TargetJvmVersion
 import org.gradle.api.internal.artifacts.JavaEcosystemSupport
+import org.gradle.api.internal.attributes.AttributeContainerInternal
 import org.gradle.api.internal.attributes.AttributeDescriberRegistry
 import org.gradle.api.internal.attributes.ImmutableAttributes
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema
 import org.gradle.api.internal.attributes.matching.AttributeMatcher
-import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate
-import org.gradle.api.internal.attributes.matching.ImmutableAttributesBackedMatchingCandidate
 import org.gradle.util.AttributeTestUtil
 import org.gradle.util.TestUtil
 import spock.lang.Specification
@@ -324,10 +323,10 @@ class JavaEcosystemAttributeMatcherTest extends Specification {
      * @throws AssertionError If the first round of attribute matching failed to match a single configuration
      *      or the second round failed to match a single variant.
      */
-    def matchConfigurations(List<List<ImmutableAttributes>> candidates, ImmutableAttributes requested) {
+    def matchConfigurations(List<List<AttributeContainerInternal>> candidates, ImmutableAttributes requested) {
         // The first element in each configuration array is the implicit variant.
         def implicitVariants = candidates.collect { it.first() }
-        def configurationMatches = match(implicitVariants, requested)
+        def configurationMatches = matcher.matchMultipleCandidates(implicitVariants, requested)
 
         // This test is checking only for successful (single) matches. If we matched multiple configurations
         // in the first round, something is wrong here. Fail before attempting the second round of variant matching.
@@ -335,7 +334,7 @@ class JavaEcosystemAttributeMatcherTest extends Specification {
 
         // Get all the variants for the configuration which was selected and apply variant matching on them.
         def configurationVariants = candidates.get(implicitVariants.indexOf(configurationMatches.get(0)))
-        def variantMatches = match(configurationVariants, requested)
+        def variantMatches = matcher.matchMultipleCandidates(configurationVariants, requested)
 
         // Once again, the purpose of this test is for successful results. Something is wrong if we have
         // multiple matched variants.
@@ -343,11 +342,6 @@ class JavaEcosystemAttributeMatcherTest extends Specification {
         return variantMatches[0]
     }
 
-    private List<ImmutableAttributes> match(List<ImmutableAttributes> candidateAttributeSets, ImmutableAttributes requested) {
-        List<AttributeMatchingCandidate> candidates = candidateAttributeSets.collect { new ImmutableAttributesBackedMatchingCandidate(it) }
-        return matcher.matchMultipleCandidates(candidates, requested).collect { it.attributes }
-    }
-
     private static ImmutableAttributes attributes(String usage, String libraryElements, Integer targetJvm) {
         Map<Attribute<Object>, Object> attrs = [
             (Usage.USAGE_ATTRIBUTE): AttributeTestUtil.named(Usage, usage),
diff --git a/platforms/jvm/language-java/src/integTest/groovy/org/gradle/api/tasks/compile/JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest.groovy b/platforms/jvm/language-java/src/integTest/groovy/org/gradle/api/tasks/compile/JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest.groovy
index c18b2feca05..0b9c64cf96d 100644
--- a/platforms/jvm/language-java/src/integTest/groovy/org/gradle/api/tasks/compile/JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest.groovy
+++ b/platforms/jvm/language-java/src/integTest/groovy/org/gradle/api/tasks/compile/JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest.groovy
@@ -16,23 +16,11 @@
 
 package org.gradle.api.tasks.compile
 
-import org.apache.commons.io.FileUtils
 import org.gradle.integtests.fixtures.AbstractIntegrationSpec
-import org.gradle.integtests.fixtures.BuildCacheOperationFixtures
-import org.gradle.integtests.fixtures.BuildOperationsFixture
 import org.gradle.integtests.fixtures.DirectoryBuildCacheFixture
-import org.gradle.test.fixtures.dsl.GradleDsl
-import org.gradle.test.fixtures.maven.MavenFileRepository
-import org.gradle.test.fixtures.server.http.HttpServer
-import org.gradle.test.fixtures.server.http.MavenHttpRepository
-import org.junit.Rule
-import spock.lang.Issue
 
 class JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest extends AbstractIntegrationSpec implements DirectoryBuildCacheFixture {
 
-    @Rule
-    HttpServer server
-
     def "classes from cache are used when dependent class is changed in ABI compatible way"() {
         given:
         project_a_depends_on_project_b()
@@ -74,81 +62,6 @@ class JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest extends AbstractI
         executedAndNotSkipped ':b:jar', ':a:compileJava'
     }
 
-    @Issue("https://github.com/gradle/gradle/issues/32464")
-    def "kotlin library on build script classpath and Java classpath doesn't affect Java compilation build cache key"() {
-        given:
-        // We need to work with remote Kotlin libraries with inline functions to reproduce the cache issue
-        def repo = publishKotlinLibraryWithInlineFunctionToRemote()
-        def kotlinLibraryWithInlineFunction = "com.example:kotlin-library:1.0.0"
-
-        file("a/build.gradle") << """
-            plugins {
-                id("java-library")
-            }
-            repositories {
-                maven { url = uri("${repo.uri}") }
-            }
-            dependencies {
-                implementation("$kotlinLibraryWithInlineFunction")
-            }
-        """
-        file("a/settings.gradle") << """
-            rootProject.name = "a"
-        """
-        file('a/src/main/java/A.java') << '''
-            public class A {
-                public void foo() {
-                }
-            }
-        '''
-        file("a/gradle/init.gradle.kts") << """
-            initscript {
-                repositories {
-                    maven { url = uri("${repo.uri}") }
-                }
-                dependencies {
-                    classpath("$kotlinLibraryWithInlineFunction")
-                }
-            }
-            // We need to have some code in body of Kotlin init script
-            // to ensure that Kotlin buildscript classpath is snapshotted
-            println("Script body")
-        """
-        def aRelocated = file("a-relocated")
-        FileUtils.copyDirectory(file("a"), aRelocated)
-
-        when:
-        def firstOperations = new BuildCacheOperationFixtures(new BuildOperationsFixture(executer, testDirectoryProvider, "first-operations"))
-        result = executer
-            .withGradleUserHomeDir(testDirectoryProvider.getTestDirectory().file("first-user-home"))
-            .inDirectory(file("a"))
-            .withArgument("--init-script")
-            .withArgument("gradle/init.gradle.kts")
-            .withBuildCacheEnabled()
-            .withTasks("compileJava")
-            .run()
-
-        then:
-        executedAndNotSkipped ':compileJava'
-
-        when:
-        def secondOperations = new BuildCacheOperationFixtures(new BuildOperationsFixture(executer, testDirectoryProvider, "second-operations"))
-        result = executer
-            .withGradleUserHomeDir(testDirectoryProvider.getTestDirectory().file("second-user-home"))
-            .inDirectory(aRelocated)
-            .withBuildCacheEnabled()
-            .withTasks("compileJava")
-            .run()
-
-        then:
-        executedAndNotSkipped ':compileJava'
-
-        and:
-        def firstCacheKey = firstOperations.getCacheKeyForTask(":compileJava")
-        def secondCacheKey = secondOperations.getCacheKeyForTask(":compileJava")
-        firstCacheKey == secondCacheKey
-    }
-
     void make_abi_compatible_change_on_b() {
         file('b/src/main/java/B.java').text = '''
             public class B {
@@ -195,46 +108,4 @@ class JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest extends AbstractI
             }
         '''
     }
-
-
-    def publishKotlinLibraryWithInlineFunctionToRemote() {
-        file("kotlin-library/build.gradle.kts") << """
-            plugins {
-                `kotlin-dsl`
-                `maven-publish`
-            }
-            group = "com.example"
-            version = "1.0.0"
-
-            ${mavenCentralRepository(GradleDsl.KOTLIN)}
-
-            publishing {
-                repositories {
-                    maven {
-                        url = uri(layout.buildDirectory.dir("repo"))
-                    }
-                }
-            }
-        """
-        file("kotlin-library/settings.gradle") << """
-            rootProject.name = "kotlin-library"
-        """
-        file("kotlin-library/src/main/kotlin/MyClass.kt") << """
-            class MyClass {
-                private val availableCpuPermits: Int inline get() = availableCpuPermits(8)
-                public inline fun availableCpuPermits(state: Long): Int = state.toInt()
-            }
-        """
-
-        def repo = new MavenHttpRepository(server, "/repo", new MavenFileRepository(file("./kotlin-library/build/repo")))
-        repo.module("com.example", "kotlin-library", "1.0.0").allowAll()
-        server.start()
-
-        executer
-            .inDirectory(file("kotlin-library"))
-            .withTasks("publish")
-            .run()
-
-        return repo
-    }
 }
diff --git a/platforms/jvm/normalization-java/src/main/java/org/gradle/api/internal/changedetection/state/ZipHasher.java b/platforms/jvm/normalization-java/src/main/java/org/gradle/api/internal/changedetection/state/ZipHasher.java
index 40ed4d4ab38..6810a783826 100644
--- a/platforms/jvm/normalization-java/src/main/java/org/gradle/api/internal/changedetection/state/ZipHasher.java
+++ b/platforms/jvm/normalization-java/src/main/java/org/gradle/api/internal/changedetection/state/ZipHasher.java
@@ -57,11 +57,21 @@ public static boolean isZipFile(final String name) {
     }
 
     private final ResourceHasher resourceHasher;
+    private final ZipHasher fallbackZipHasher;
     private final HashingExceptionReporter hashingExceptionReporter;
 
     public ZipHasher(ResourceHasher resourceHasher) {
+        this(
+            resourceHasher,
+            null,
+            (s, e) -> LOGGER.debug("Malformed archive '{}'. Falling back to full content hash instead of entry hashing.", s.getName(), e)
+        );
+    }
+
+    public ZipHasher(ResourceHasher resourceHasher, @Nullable ZipHasher fallbackZipHasher, HashingExceptionReporter hashingExceptionReporter) {
         this.resourceHasher = resourceHasher;
-        this.hashingExceptionReporter = (s, e) -> LOGGER.debug("Malformed archive '{}'. Falling back to full content hash instead of entry hashing.", s.getName(), e);
+        this.fallbackZipHasher = fallbackZipHasher;
+        this.hashingExceptionReporter = hashingExceptionReporter;
     }
 
     @Nullable
@@ -88,6 +98,9 @@ private HashCode hashZipContents(RegularFileSnapshot zipFileSnapshot) {
             return hasher.hash();
         } catch (Exception e) {
             hashingExceptionReporter.report(zipFileSnapshot, e);
+            if (fallbackZipHasher != null) {
+                return fallbackZipHasher.hashZipContents(zipFileSnapshot);
+            }
             return zipFileSnapshot.getHash();
         }
     }
diff --git a/platforms/jvm/normalization-java/src/main/java/org/gradle/internal/fingerprint/classpath/impl/ClasspathFingerprintingStrategy.java b/platforms/jvm/normalization-java/src/main/java/org/gradle/internal/fingerprint/classpath/impl/ClasspathFingerprintingStrategy.java
index 370e86bdcd7..74a56948989 100644
--- a/platforms/jvm/normalization-java/src/main/java/org/gradle/internal/fingerprint/classpath/impl/ClasspathFingerprintingStrategy.java
+++ b/platforms/jvm/normalization-java/src/main/java/org/gradle/internal/fingerprint/classpath/impl/ClasspathFingerprintingStrategy.java
@@ -119,6 +119,18 @@ public static ClasspathFingerprintingStrategy compileClasspath(ResourceHasher cl
         return new ClasspathFingerprintingStrategy(COMPILE_CLASSPATH_IDENTIFIER, IGNORE, classpathResourceHasher, zipHasher, cacheService, stringInterner);
     }
 
+    public static ClasspathFingerprintingStrategy compileClasspathFallbackToRuntimeClasspath(
+        ResourceHasher classpathResourceHasher,
+        ResourceHasher runtimeClasspathResourceHasher,
+        ResourceSnapshotterCacheService cacheService,
+        Interner<String> stringInterner,
+        ZipHasher.HashingExceptionReporter hashingExceptionReporter
+    ) {
+        ZipHasher fallbackZipHasher = new ZipHasher(runtimeClasspathResourceHasher);
+        ZipHasher zipHasher = new ZipHasher(classpathResourceHasher, fallbackZipHasher, hashingExceptionReporter);
+        return new ClasspathFingerprintingStrategy(COMPILE_CLASSPATH_IDENTIFIER, IGNORE, classpathResourceHasher, zipHasher, cacheService, stringInterner);
+    }
+
     public static ResourceHasher runtimeClasspathResourceHasher(
         RuntimeClasspathResourceHasher runtimeClasspathResourceHasher,
         LineEndingSensitivity lineEndingSensitivity,
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/artifact/ResolvedVariant.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/artifact/ResolvedVariant.java
index 055841e0ec9..57bd1d95542 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/artifact/ResolvedVariant.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/artifact/ResolvedVariant.java
@@ -17,7 +17,8 @@
 package org.gradle.api.internal.artifacts.ivyservice.resolveengine.artifact;
 
 import org.gradle.api.Action;
-import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate;
+import org.gradle.api.attributes.HasAttributes;
+import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.internal.DisplayName;
 import org.gradle.internal.component.external.model.ImmutableCapabilities;
 import org.gradle.internal.component.model.VariantResolveMetadata;
@@ -27,8 +28,7 @@
  * A set of artifacts that may be selected from a variant. This would be better named
  * {@code ResolvedVariantArtifactCollection}.
  */
-public interface ResolvedVariant extends AttributeMatchingCandidate {
-
+public interface ResolvedVariant extends HasAttributes {
     DisplayName asDescribable();
 
     /**
@@ -37,8 +37,10 @@ public interface ResolvedVariant extends AttributeMatchingCandidate {
      */
     VariantResolveMetadata.@Nullable Identifier getIdentifier();
 
+    @Override
+    ImmutableAttributes getAttributes();
+
     ResolvedArtifactSet getArtifacts();
 
     ImmutableCapabilities getCapabilities();
-
 }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/ConsumerProvidedVariantFinder.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/ConsumerProvidedVariantFinder.java
index 204aca0bba0..a1d4a1c7416 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/ConsumerProvidedVariantFinder.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/ConsumerProvidedVariantFinder.java
@@ -236,7 +236,7 @@ private List<TransformedVariant> query(
         ) {
             List<ImmutableAttributes> variantAttributes = new ArrayList<>(sources.size());
             for (ResolvedVariant variant : sources) {
-                variantAttributes.add(variant.getAttributes());
+                variantAttributes.add(variant.getAttributes().asImmutable());
             }
             List<CachedVariant> cached = cache.computeIfAbsent(new CacheKey(variantAttributes, requested), key -> action.apply(key.variantAttributes, key.requested));
             List<TransformedVariant> output = new ArrayList<>(cached.size());
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/TransformedVariant.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/TransformedVariant.java
index 69655d7a24e..7584e290b73 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/TransformedVariant.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/TransformedVariant.java
@@ -16,16 +16,15 @@
 
 package org.gradle.api.internal.artifacts.transform;
 
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.artifacts.ivyservice.resolveengine.artifact.ResolvedVariant;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
-import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate;
 
 /**
  * Represents a variant which is produced as the result of applying an artifact transform chain
  * to a root producer variant.
  */
-public class TransformedVariant implements AttributeMatchingCandidate {
-
+public class TransformedVariant implements HasAttributes {
     private final ResolvedVariant root;
     private final VariantDefinition chain;
 
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatcher.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatcher.java
index a0e24caace7..8832698d773 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatcher.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatcher.java
@@ -17,9 +17,11 @@
 package org.gradle.api.internal.attributes.matching;
 
 import org.gradle.api.attributes.Attribute;
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.AttributeValue;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 
+import java.util.Collection;
 import java.util.List;
 
 public interface AttributeMatcher {
@@ -48,8 +50,8 @@ public interface AttributeMatcher {
      * criteria attributes. Then, if there is more than one match, performs disambiguation to attempt
      * to reduce the set of matches to a more preferred subset.
      */
-    <T extends AttributeMatchingCandidate> List<T> matchMultipleCandidates(
-        List<? extends T> candidates,
+    <T extends HasAttributes> List<T> matchMultipleCandidates(
+        Collection<? extends T> candidates,
         ImmutableAttributes requested
     );
 
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatchingCandidate.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatchingCandidate.java
deleted file mode 100644
index bb266c43ab9..00000000000
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatchingCandidate.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2024 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.gradle.api.internal.attributes.matching;
-
-import org.gradle.api.internal.attributes.ImmutableAttributes;
-
-import java.util.List;
-
-/**
- * Something that can participate in multiple-candidate attribute matching. During multiple-candidate
- * matching, candidates are compared based on their attributes and the best match is selected. Compatibility
- * and disambiguation rules from attribute schemas are used to determine the best match.
- *
- * @see AttributeMatcher#matchMultipleCandidates(List, ImmutableAttributes)
- */
-public interface AttributeMatchingCandidate {
-
-    /**
-     * Get the attributes that describe this candidate.
-     */
-    ImmutableAttributes getAttributes();
-
-}
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcher.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcher.java
index 3ba4dea1aad..b3f78510264 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcher.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcher.java
@@ -19,8 +19,11 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.primitives.Ints;
 import org.gradle.api.attributes.Attribute;
+import org.gradle.api.attributes.HasAttributes;
+import org.gradle.api.internal.attributes.AttributeContainerInternal;
 import org.gradle.api.internal.attributes.AttributeValue;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
+import org.gradle.internal.Cast;
 import org.gradle.internal.component.model.AttributeMatchingExplanationBuilder;
 import org.gradle.internal.model.InMemoryCacheFactory;
 import org.gradle.internal.model.InMemoryLoadingCache;
@@ -28,7 +31,7 @@
 import org.slf4j.LoggerFactory;
 
 import java.util.ArrayList;
-import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 
@@ -159,10 +162,7 @@ public List<AttributeMatcher.MatchingDescription<?>> describeMatching(ImmutableA
     }
 
     @Override
-    public <T extends AttributeMatchingCandidate> List<T> matchMultipleCandidates(
-        List<? extends T> candidates,
-        ImmutableAttributes requested
-    ) {
+    public <T extends HasAttributes> List<T> matchMultipleCandidates(Collection<? extends T> candidates, ImmutableAttributes requested) {
         AttributeMatchingExplanationBuilder explanationBuilder = AttributeMatchingExplanationBuilder.logging();
 
         if (candidates.isEmpty()) {
@@ -172,45 +172,47 @@ public <T extends AttributeMatchingCandidate> List<T> matchMultipleCandidates(
 
         if (candidates.size() == 1) {
             T candidate = candidates.iterator().next();
-            ImmutableAttributes candidateAttributes = candidate.getAttributes();
-            if (isMatchingCandidate(candidateAttributes, requested)) {
-                explanationBuilder.singleMatch(candidateAttributes, ImmutableList.of(candidateAttributes), requested);
+            ImmutableAttributes candidateAttrs = ((AttributeContainerInternal) candidate.getAttributes()).asImmutable();
+            if (isMatchingCandidate(candidateAttrs, requested)) {
+                explanationBuilder.singleMatch(candidate, candidates, requested);
                 return Collections.singletonList(candidate);
             }
-            explanationBuilder.candidateDoesNotMatchAttributes(candidateAttributes, requested);
+            explanationBuilder.candidateDoesNotMatchAttributes(candidate, requested);
             return ImmutableList.of();
         }
 
+        List<T> candidateList = (candidates instanceof List) ? Cast.uncheckedCast(candidates) : ImmutableList.copyOf(candidates);
+
         // Often times, collections of candidates will themselves differ even though their attributes are the same.
         // Disambiguating two different candidate lists which map to the same attribute lists in reality performs
         // the same work, so instead we cache disambiguation results based on the attributes being disambiguated.
         // The result of this is a list of indices into the original candidate list from which the
         // attributes-to-disambiguate are derived. When retrieving a result from the cache, we use the resulting
         // indices to index back into the original candidates list.
-        CachedQuery query = CachedQuery.from(requested, candidates);
+        CachedQuery query = CachedQuery.from(requested, candidateList);
         int[] indices = cachedQueries.get(query);
-        return CachedQuery.getMatchesFromCandidateIndices(indices, candidates);
+        return CachedQuery.getMatchesFromCandidateIndices(indices, candidateList);
     }
 
     private int[] doMatchMultipleCandidates(CachedQuery key) {
         AttributeMatchingExplanationBuilder explanationBuilder = AttributeMatchingExplanationBuilder.logging();
-        int[] matches = new MultipleCandidateMatcher(schema, key.candidates, key.requestedAttributes, explanationBuilder).getMatches();
+        int[] matches = new MultipleCandidateMatcher<>(schema, key.candidates, key.requestedAttributes, explanationBuilder).getMatches();
         LOGGER.debug("Selected matches {} from candidates {} for {}", Ints.asList(matches), key.candidates, key.requestedAttributes);
         return matches;
     }
 
     private static class CachedQuery {
         private final ImmutableAttributes requestedAttributes;
-        private final ImmutableAttributes[] candidates;
+        private final List<ImmutableAttributes> candidates;
         private final int hashCode;
 
-        private CachedQuery(ImmutableAttributes requestedAttributes, ImmutableAttributes[] candidates) {
+        private CachedQuery(ImmutableAttributes requestedAttributes, List<ImmutableAttributes> candidates) {
             this.requestedAttributes = requestedAttributes;
             this.candidates = candidates;
             this.hashCode = computeHashCode(requestedAttributes, candidates);
         }
 
-        private static int computeHashCode(ImmutableAttributes requestedAttributes, ImmutableAttributes[] candidates) {
+        private static int computeHashCode(ImmutableAttributes requestedAttributes, List<ImmutableAttributes> candidates) {
             int hash = requestedAttributes.hashCode();
             for (ImmutableAttributes candidate : candidates) {
                 hash = 31 * hash + candidate.hashCode();
@@ -218,17 +220,16 @@ private static int computeHashCode(ImmutableAttributes requestedAttributes, Immu
             return hash;
         }
 
-        public static <T extends AttributeMatchingCandidate> CachedQuery from(ImmutableAttributes requestedAttributes, List<T> candidates) {
-            int size = candidates.size();
-            ImmutableAttributes[] attributes = new ImmutableAttributes[size];
-            for (int i = 0; i < size; i++) {
-                attributes[i] = candidates.get(i).getAttributes();
+        public static <T extends HasAttributes> CachedQuery from(ImmutableAttributes requestedAttributes, List<T> candidates) {
+            List<ImmutableAttributes> attributes = new ArrayList<>(candidates.size());
+            for (T candidate : candidates) {
+                attributes.add(((AttributeContainerInternal) candidate.getAttributes()).asImmutable());
             }
             return new CachedQuery(requestedAttributes, attributes);
         }
 
         @SuppressWarnings("MixedMutabilityReturnType")
-        private static <T extends AttributeMatchingCandidate> List<T> getMatchesFromCandidateIndices(int[] indices, List<? extends T> candidates) {
+        private static <T extends HasAttributes> List<T> getMatchesFromCandidateIndices(int[] indices, List<? extends T> candidates) {
             if (indices.length == 0) {
                 return Collections.emptyList();
             }
@@ -252,7 +253,7 @@ public boolean equals(Object o) {
             CachedQuery that = (CachedQuery) o;
             return hashCode == that.hashCode &&
                 requestedAttributes.equals(that.requestedAttributes) &&
-                Arrays.equals(candidates, that.candidates);
+                candidates.equals(that.candidates);
         }
 
         @Override
@@ -264,7 +265,7 @@ public int hashCode() {
         public String toString() {
             return "CachedQuery{" +
                 "requestedAttributes=" + requestedAttributes +
-                ", candidates=" + Arrays.toString(candidates) +
+                ", candidates=" + candidates +
                 '}';
         }
     }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/ImmutableAttributesBackedMatchingCandidate.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/ImmutableAttributesBackedMatchingCandidate.java
deleted file mode 100644
index 7048235e96b..00000000000
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/ImmutableAttributesBackedMatchingCandidate.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2024 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.gradle.api.internal.attributes.matching;
-
-import org.gradle.api.internal.attributes.ImmutableAttributes;
-
-/**
- * Wraps a standalone {@link ImmutableAttributes} so that it can participate in
- * attribute matching.
- */
-public class ImmutableAttributesBackedMatchingCandidate implements AttributeMatchingCandidate {
-
-    private final ImmutableAttributes attributes;
-
-    public ImmutableAttributesBackedMatchingCandidate(ImmutableAttributes attributes) {
-        this.attributes = attributes;
-    }
-
-    @Override
-    public ImmutableAttributes getAttributes() {
-        return attributes;
-    }
-
-    @Override
-    public final boolean equals(Object o) {
-        if (this == o) {
-            return true;
-        }
-        if (!(o instanceof ImmutableAttributesBackedMatchingCandidate)) {
-            return false;
-        }
-
-        ImmutableAttributesBackedMatchingCandidate that = (ImmutableAttributesBackedMatchingCandidate) o;
-        return attributes.equals(that.attributes);
-    }
-
-    @Override
-    public int hashCode() {
-        return attributes.hashCode();
-    }
-
-}
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/MultipleCandidateMatcher.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/MultipleCandidateMatcher.java
index aa7148e6e8e..6b47a96496f 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/MultipleCandidateMatcher.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/MultipleCandidateMatcher.java
@@ -18,6 +18,8 @@
 
 import com.google.common.collect.Sets;
 import org.gradle.api.attributes.Attribute;
+import org.gradle.api.attributes.HasAttributes;
+import org.gradle.api.internal.attributes.AttributeContainerInternal;
 import org.gradle.api.internal.attributes.AttributeValue;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.internal.Cast;
@@ -66,10 +68,11 @@
  *
  * </p>
  */
-class MultipleCandidateMatcher {
+class MultipleCandidateMatcher<T extends HasAttributes> {
     private final AttributeSelectionSchema schema;
     private final ImmutableAttributes requested;
-    private final ImmutableAttributes[] candidates;
+    private final List<? extends T> candidates;
+    private final ImmutableAttributes[] candidateAttributeSets;
     private final AttributeMatchingExplanationBuilder explanationBuilder;
 
     private final List<Attribute<?>> requestedAttributes;
@@ -93,7 +96,7 @@ class MultipleCandidateMatcher {
 
     private BitSet remaining;
 
-    MultipleCandidateMatcher(AttributeSelectionSchema schema, ImmutableAttributes[] candidates, ImmutableAttributes requested, AttributeMatchingExplanationBuilder explanationBuilder) {
+    <E extends T> MultipleCandidateMatcher(AttributeSelectionSchema schema, List<E> candidates, ImmutableAttributes requested, AttributeMatchingExplanationBuilder explanationBuilder) {
         this.schema = schema;
         this.candidates = candidates;
         this.requested = requested;
@@ -102,10 +105,11 @@ class MultipleCandidateMatcher {
         this.requestedAttributes = requested.keySet().asList();
         this.requestedAttributeValues = getRequestedValues(requestedAttributes, requested);
 
-        this.candidateValues = new Object[candidates.length * requestedAttributes.size()];
+        this.candidateAttributeSets = getCandidateAttributeSets(this.candidates);
+        this.candidateValues = new Object[candidates.size() * requestedAttributes.size()];
 
-        this.compatible = new BitSet(candidates.length);
-        compatible.set(0, candidates.length);
+        this.compatible = new BitSet(candidates.size());
+        compatible.set(0, candidates.size());
     }
 
     public int[] getMatches() {
@@ -114,7 +118,7 @@ public int[] getMatches() {
             return getCandidates(compatible);
         }
         if (longestMatchIsSuperSetOfAllOthers()) {
-            ImmutableAttributes o = candidates[candidateWithLongestMatch];
+            T o = candidates.get(candidateWithLongestMatch);
             explanationBuilder.candidateIsSuperSetOfAllOthers(o);
             return new int[] {candidateWithLongestMatch};
         }
@@ -131,12 +135,20 @@ private static Object[] getRequestedValues(List<Attribute<?>> requestedAttribute
         return requestedAttributeValues;
     }
 
+    private static ImmutableAttributes[] getCandidateAttributeSets(List<? extends HasAttributes> candidates) {
+        ImmutableAttributes[] candidateAttributeSets = new ImmutableAttributes[candidates.size()];
+        for (int i = 0; i < candidates.size(); i++) {
+            candidateAttributeSets[i] = ((AttributeContainerInternal) candidates.get(i).getAttributes()).asImmutable();
+        }
+        return candidateAttributeSets;
+    }
+
     private void findCompatibleCandidates() {
         if (requested.isEmpty()) {
             // Avoid iterating on candidates if there's no requested attribute
             return;
         }
-        for (int c = 0; c < candidates.length; c++) {
+        for (int c = 0; c < candidates.size(); c++) {
             matchCandidate(c);
         }
     }
@@ -164,11 +176,11 @@ private void matchCandidate(int c) {
     private MatchResult recordAndMatchCandidateValue(int c, int a) {
         Object requestedValue = requestedAttributeValues[a];
         Attribute<?> attribute = requestedAttributes.get(a);
-        AttributeValue<?> candidateValue = candidates[c].findEntry(attribute.getName());
+        AttributeValue<?> candidateValue = candidateAttributeSets[c].findEntry(attribute.getName());
 
         if (!candidateValue.isPresent()) {
             setCandidateValue(c, a, null);
-            explanationBuilder.candidateAttributeMissing(candidates[c], attribute, requestedValue);
+            explanationBuilder.candidateAttributeMissing(candidates.get(c), attribute, requestedValue);
             return MatchResult.MISSING;
         }
 
@@ -178,7 +190,7 @@ private MatchResult recordAndMatchCandidateValue(int c, int a) {
         if (unsafeMatchValue(attribute, requestedValue, coercedValue)) {
             return MatchResult.MATCH;
         }
-        explanationBuilder.candidateAttributeDoesNotMatch(candidates[c], attribute, requestedValue, candidateValue);
+        explanationBuilder.candidateAttributeDoesNotMatch(candidates.get(c), attribute, requestedValue, candidateValue);
         return MatchResult.NO_MATCH;
     }
 
@@ -217,7 +229,7 @@ private boolean longestMatchIsSuperSetOfAllOthers() {
     }
 
     private int[] disambiguateCompatibleCandidates() {
-        remaining = new BitSet(candidates.length);
+        remaining = new BitSet(candidates.size());
         remaining.or(compatible);
 
         disambiguateWithRequestedAttributeValues();
@@ -227,7 +239,7 @@ private int[] disambiguateCompatibleCandidates() {
             return getCandidates(remaining);
         }
 
-        Attribute<?>[] extraAttributes = schema.collectExtraAttributes(candidates, requested);
+        Attribute<?>[] extraAttributes = schema.collectExtraAttributes(candidateAttributeSets, requested);
         if (remaining.cardinality() > 1) {
             disambiguateWithExtraAttributes(extraAttributes);
         }
@@ -245,10 +257,10 @@ private void disambiguateWithRequestedAttributeKeys(Attribute<?>[] extraAttribut
             // We consider only extra attributes which are NOT on every candidate:
             // Because they are EXTRA attributes, we consider that a
             // candidate which does NOT provide this value is a better match
-            int candidateCount = candidates.length;
+            int candidateCount = candidateAttributeSets.length;
             BitSet any = new BitSet(candidateCount);
             for (int c = 0; c < candidateCount; c++) {
-                ImmutableAttributes candidateAttributeSet = candidates[c];
+                ImmutableAttributes candidateAttributeSet = candidateAttributeSets[c];
                 if (candidateAttributeSet.findEntry(extraAttribute.getName()).isPresent()) {
                     any.set(c);
                 }
@@ -443,7 +455,7 @@ private int[] getCandidates(BitSet liveSet) {
 
     @Nullable
     private <E> E getCandidateValue(int c, Attribute<E> attribute) {
-        AttributeValue<?> attributeValue = candidates[c].findEntry(attribute.getName());
+        AttributeValue<?> attributeValue = candidateAttributeSets[c].findEntry(attribute.getName());
         return attributeValue.isPresent() ? attributeValue.coerce(attribute) : null;
     }
 
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/external/model/ExternalComponentResolveMetadata.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/external/model/ExternalComponentResolveMetadata.java
index 12fbfe9c1d1..92b87aab02e 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/external/model/ExternalComponentResolveMetadata.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/external/model/ExternalComponentResolveMetadata.java
@@ -19,6 +19,7 @@
 import com.google.common.collect.ImmutableList;
 import org.gradle.api.artifacts.ModuleVersionIdentifier;
 import org.gradle.api.artifacts.component.ComponentIdentifier;
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema;
 import org.gradle.internal.component.model.ComponentArtifactResolveMetadata;
@@ -44,7 +45,7 @@
  * @see ComponentArtifactResolveState
  * @see ComponentArtifactResolveMetadata
  */
-public interface ExternalComponentResolveMetadata {
+public interface ExternalComponentResolveMetadata extends HasAttributes {
     List<String> DEFAULT_STATUS_SCHEME = Arrays.asList("integration", "milestone", "release");
 
     /**
@@ -86,5 +87,6 @@ public interface ExternalComponentResolveMetadata {
 
     ImmutableList<? extends VirtualComponentIdentifier> getPlatformOwners();
 
+    @Override
     ImmutableAttributes getAttributes();
 }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/AttributeMatchingExplanationBuilder.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/AttributeMatchingExplanationBuilder.java
index 9651e877aa9..8a48f0d30ee 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/AttributeMatchingExplanationBuilder.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/AttributeMatchingExplanationBuilder.java
@@ -16,9 +16,9 @@
 package org.gradle.internal.component.model;
 
 import org.gradle.api.attributes.Attribute;
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.AttributeContainerInternal;
 import org.gradle.api.internal.attributes.AttributeValue;
-import org.gradle.api.internal.attributes.ImmutableAttributes;
 
 import java.util.Collection;
 
@@ -29,27 +29,27 @@ static AttributeMatchingExplanationBuilder logging() {
         return LoggingAttributeMatchingExplanationBuilder.logging();
     }
 
-    default void noCandidates(ImmutableAttributes requested) {
+    default <T extends HasAttributes> void noCandidates(AttributeContainerInternal requested) {
 
     }
 
-    default void singleMatch(ImmutableAttributes candidate, Collection<ImmutableAttributes> candidates, AttributeContainerInternal requested) {
+    default <T extends HasAttributes> void singleMatch(T candidate, Collection<? extends T> candidates, AttributeContainerInternal requested) {
 
     }
 
-    default void candidateDoesNotMatchAttributes(ImmutableAttributes candidate, AttributeContainerInternal requested) {
+    default <T extends HasAttributes> void candidateDoesNotMatchAttributes(T candidate, AttributeContainerInternal requested) {
 
     }
 
-    default void candidateAttributeDoesNotMatch(ImmutableAttributes candidate, Attribute<?> attribute, Object requestedValue, AttributeValue<?> candidateValue) {
+    default <T extends HasAttributes> void candidateAttributeDoesNotMatch(T candidate, Attribute<?> attribute, Object requestedValue, AttributeValue<?> candidateValue) {
 
     }
 
-    default void candidateAttributeMissing(ImmutableAttributes candidate, Attribute<?> attribute, Object requestedValue) {
+    default <T extends HasAttributes> void candidateAttributeMissing(T candidate, Attribute<?> attribute, Object requestedValue) {
 
     }
 
-    default void candidateIsSuperSetOfAllOthers(ImmutableAttributes candidate) {
+    default <T extends HasAttributes> void candidateIsSuperSetOfAllOthers(T candidate) {
 
     }
 }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/ConfigurationMetadata.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/ConfigurationMetadata.java
index 1155661e75e..c62eed734e7 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/ConfigurationMetadata.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/ConfigurationMetadata.java
@@ -18,6 +18,7 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.internal.DisplayName;
 import org.gradle.internal.component.external.model.ImmutableCapabilities;
@@ -35,7 +36,7 @@
  * @see VariantGraphResolveMetadata
  * @see ConfigurationGraphResolveMetadata
  */
-public interface ConfigurationMetadata {
+public interface ConfigurationMetadata extends HasAttributes {
     /**
      * The set of configurations that this configuration extends. Includes this configuration.
      *
@@ -49,6 +50,10 @@ public interface ConfigurationMetadata {
 
     DisplayName asDescribable();
 
+    /**
+     * Attributes are immutable on ConfigurationMetadata
+     */
+    @Override
     ImmutableAttributes getAttributes();
 
     /**
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/LoggingAttributeMatchingExplanationBuilder.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/LoggingAttributeMatchingExplanationBuilder.java
index 2b03a4d4f3a..256a8bbb032 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/LoggingAttributeMatchingExplanationBuilder.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/LoggingAttributeMatchingExplanationBuilder.java
@@ -16,9 +16,9 @@
 package org.gradle.internal.component.model;
 
 import org.gradle.api.attributes.Attribute;
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.AttributeContainerInternal;
 import org.gradle.api.internal.attributes.AttributeValue;
-import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.api.logging.Logger;
 import org.gradle.api.logging.Logging;
 
@@ -36,32 +36,32 @@ static AttributeMatchingExplanationBuilder logging() {
     }
 
     @Override
-    public void noCandidates(ImmutableAttributes requested) {
+    public <T extends HasAttributes> void noCandidates(AttributeContainerInternal requested) {
         LOGGER.debug("No candidates for {}. Select nothing.", requested);
     }
 
     @Override
-    public void singleMatch(ImmutableAttributes candidate, Collection<ImmutableAttributes> candidates, AttributeContainerInternal requested) {
+    public <T extends HasAttributes> void singleMatch(T candidate, Collection<? extends T> candidates, AttributeContainerInternal requested) {
         LOGGER.debug("Selected match {} from candidates {} for {}", candidate, candidates, requested);
     }
 
     @Override
-    public void candidateDoesNotMatchAttributes(ImmutableAttributes candidate, AttributeContainerInternal requested) {
+    public <T extends HasAttributes> void candidateDoesNotMatchAttributes(T candidate, AttributeContainerInternal requested) {
         LOGGER.debug("Candidate {} doesn't match attributes {}", candidate, requested);
     }
 
     @Override
-    public void candidateAttributeDoesNotMatch(ImmutableAttributes candidate, Attribute<?> attribute, Object requestedValue, AttributeValue<?> candidateValue) {
+    public <T extends HasAttributes> void candidateAttributeDoesNotMatch(T candidate, Attribute<?> attribute, Object requestedValue, AttributeValue<?> candidateValue) {
         LOGGER.debug("Candidate {} attribute {} value {} doesn't requested value {}", candidate, attribute, candidateValue, requestedValue);
     }
 
     @Override
-    public void candidateAttributeMissing(ImmutableAttributes candidate, Attribute<?> attribute, Object requestedValue) {
+    public <T extends HasAttributes> void candidateAttributeMissing(T candidate, Attribute<?> attribute, Object requestedValue) {
         LOGGER.debug("Candidate {} doesn't have attribute {}", candidate, attribute);
     }
 
     @Override
-    public void candidateIsSuperSetOfAllOthers(ImmutableAttributes candidate) {
+    public <T extends HasAttributes> void candidateIsSuperSetOfAllOthers(T candidate) {
         LOGGER.debug("Candidate {} selected because its attributes are a superset of all other candidate attributes", candidate);
     }
 }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveMetadata.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveMetadata.java
index 719942a3dd6..612f28829e0 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveMetadata.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveMetadata.java
@@ -16,6 +16,7 @@
 
 package org.gradle.internal.component.model;
 
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.internal.component.external.model.ImmutableCapabilities;
 
@@ -26,7 +27,7 @@
  * of this variant, as they may be expensive to resolve. Expensive information about this variant
  * can be accessed via the methods of {@link VariantGraphResolveState}.
  */
-public interface VariantGraphResolveMetadata {
+public interface VariantGraphResolveMetadata extends HasAttributes {
 
     /**
      * Returns the name for this variant, which is unique for the variants of its owning component.
@@ -46,6 +47,7 @@ default String getDisplayName() {
         return getName();
     }
 
+    @Override
     ImmutableAttributes getAttributes();
 
     ImmutableCapabilities getCapabilities();
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveState.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveState.java
index 846744245c4..36f50692f42 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveState.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveState.java
@@ -16,7 +16,8 @@
 
 package org.gradle.internal.component.model;
 
-import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate;
+import org.gradle.api.attributes.HasAttributes;
+import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.internal.component.external.model.ImmutableCapabilities;
 
 import java.util.List;
@@ -27,7 +28,7 @@
  * This state type manages expensive operations required to resolve a variant. These include
  * managing dependencies and artifacts, which may not be easily available from the metadata.
  */
-public interface VariantGraphResolveState extends AttributeMatchingCandidate {
+public interface VariantGraphResolveState extends HasAttributes {
 
     /**
      * A unique id for this variant within the current build tree. Note that this id is not stable across Gradle invocations.
@@ -36,6 +37,9 @@ public interface VariantGraphResolveState extends AttributeMatchingCandidate {
 
     String getName();
 
+    @Override
+    ImmutableAttributes getAttributes();
+
     ImmutableCapabilities getCapabilities();
 
     VariantGraphResolveMetadata getMetadata();
@@ -59,5 +63,4 @@ public interface VariantGraphResolveState extends AttributeMatchingCandidate {
      * when required.
      */
     VariantArtifactResolveState prepareForArtifactResolution();
-
 }
diff --git a/platforms/software/ivy/src/main/java/org/gradle/api/publish/ivy/internal/versionmapping/DefaultVersionMappingStrategy.java b/platforms/software/ivy/src/main/java/org/gradle/api/publish/ivy/internal/versionmapping/DefaultVersionMappingStrategy.java
index 607af341246..61a7e011c76 100644
--- a/platforms/software/ivy/src/main/java/org/gradle/api/publish/ivy/internal/versionmapping/DefaultVersionMappingStrategy.java
+++ b/platforms/software/ivy/src/main/java/org/gradle/api/publish/ivy/internal/versionmapping/DefaultVersionMappingStrategy.java
@@ -16,7 +16,6 @@
 package org.gradle.api.publish.ivy.internal.versionmapping;
 
 import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Multimap;
 import org.gradle.api.Action;
 import org.gradle.api.InvalidUserCodeException;
@@ -29,7 +28,6 @@
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema;
 import org.gradle.api.internal.attributes.matching.AttributeMatcher;
-import org.gradle.api.internal.attributes.matching.ImmutableAttributesBackedMatchingCandidate;
 import org.gradle.api.model.ObjectFactory;
 import org.gradle.api.publish.VariantVersionMappingStrategy;
 import org.gradle.api.publish.internal.versionmapping.DefaultVariantVersionMappingStrategy;
@@ -42,6 +40,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 public class DefaultVersionMappingStrategy implements VersionMappingStrategyInternal {
     private final ObjectFactory objectFactory;
@@ -51,8 +50,8 @@ public class DefaultVersionMappingStrategy implements VersionMappingStrategyInte
     private final AttributeSchemaServices attributeSchemaServices;
 
     private final List<Action<? super VariantVersionMappingStrategy>> mappingsForAllVariants = new ArrayList<>(2);
-    private final Map<ImmutableAttributesBackedMatchingCandidate, String> defaultConfigurations = new HashMap<>();
-    private final Multimap<ImmutableAttributesBackedMatchingCandidate, Action<? super VariantVersionMappingStrategy>> attributeBasedMappings = ArrayListMultimap.create();
+    private final Map<ImmutableAttributes, String> defaultConfigurations = new HashMap<>();
+    private final Multimap<ImmutableAttributes, Action<? super VariantVersionMappingStrategy>> attributeBasedMappings = ArrayListMultimap.create();
 
     private AttributeMatcher matcher;
 
@@ -78,8 +77,7 @@ public void allVariants(Action<? super VariantVersionMappingStrategy> action) {
 
     @Override
     public <T> void variant(Attribute<T> attribute, T attributeValue, Action<? super VariantVersionMappingStrategy> action) {
-        ImmutableAttributes attributes = attributesFactory.of(attribute, attributeValue);
-        attributeBasedMappings.put(new ImmutableAttributesBackedMatchingCandidate(attributes), action);
+        attributeBasedMappings.put(attributesFactory.of(attribute, attributeValue), action);
     }
 
     @Override
@@ -89,8 +87,7 @@ public void usage(String usage, Action<? super VariantVersionMappingStrategy> ac
 
     @Override
     public void defaultResolutionConfiguration(String usage, String defaultConfiguration) {
-        ImmutableAttributes attributes = attributesFactory.of(Usage.USAGE_ATTRIBUTE, objectFactory.named(Usage.class, usage));
-        defaultConfigurations.put(new ImmutableAttributesBackedMatchingCandidate(attributes), defaultConfiguration);
+        defaultConfigurations.put(attributesFactory.of(Usage.USAGE_ATTRIBUTE, objectFactory.named(Usage.class, usage)), defaultConfiguration);
     }
 
     @Override
@@ -103,8 +100,8 @@ public VariantVersionMappingStrategyInternal findStrategyForVariant(ImmutableAtt
 
         // Then use attribute specific mapping
         if (!attributeBasedMappings.isEmpty()) {
-            List<ImmutableAttributesBackedMatchingCandidate> candidates = ImmutableList.copyOf(attributeBasedMappings.keySet());
-            List<ImmutableAttributesBackedMatchingCandidate> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
+            Set<ImmutableAttributes> candidates = attributeBasedMappings.keySet();
+            List<ImmutableAttributes> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
             if (matches.size() == 1) {
                 Collection<Action<? super VariantVersionMappingStrategy>> actions = attributeBasedMappings.get(matches.get(0));
                 for (Action<? super VariantVersionMappingStrategy> action : actions) {
@@ -122,9 +119,9 @@ private DefaultVariantVersionMappingStrategy createDefaultMappingStrategy(Immuta
         if (!defaultConfigurations.isEmpty()) {
             // First need to populate the default variant version mapping strategy with the default values
             // provided by plugins
-            List<ImmutableAttributesBackedMatchingCandidate> candidates = ImmutableList.copyOf(defaultConfigurations.keySet());
-            List<ImmutableAttributesBackedMatchingCandidate> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
-            for (ImmutableAttributesBackedMatchingCandidate match : matches) {
+            Set<ImmutableAttributes> candidates = defaultConfigurations.keySet();
+            List<ImmutableAttributes> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
+            for (ImmutableAttributes match : matches) {
                 strategy.setDefaultResolutionConfiguration(configurations.getByName(defaultConfigurations.get(match)));
             }
         }
diff --git a/platforms/software/publish/src/main/java/org/gradle/api/publish/internal/versionmapping/DefaultVersionMappingStrategy.java b/platforms/software/publish/src/main/java/org/gradle/api/publish/internal/versionmapping/DefaultVersionMappingStrategy.java
index 02764e5804e..72a971b0cf2 100644
--- a/platforms/software/publish/src/main/java/org/gradle/api/publish/internal/versionmapping/DefaultVersionMappingStrategy.java
+++ b/platforms/software/publish/src/main/java/org/gradle/api/publish/internal/versionmapping/DefaultVersionMappingStrategy.java
@@ -16,7 +16,6 @@
 package org.gradle.api.publish.internal.versionmapping;
 
 import com.google.common.collect.ArrayListMultimap;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Multimap;
 import org.gradle.api.Action;
 import org.gradle.api.InvalidUserCodeException;
@@ -29,7 +28,6 @@
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema;
 import org.gradle.api.internal.attributes.matching.AttributeMatcher;
-import org.gradle.api.internal.attributes.matching.ImmutableAttributesBackedMatchingCandidate;
 import org.gradle.api.model.ObjectFactory;
 import org.gradle.api.publish.VariantVersionMappingStrategy;
 
@@ -39,6 +37,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 public class DefaultVersionMappingStrategy implements VersionMappingStrategyInternal {
     private final ObjectFactory objectFactory;
@@ -48,8 +47,8 @@ public class DefaultVersionMappingStrategy implements VersionMappingStrategyInte
     private final AttributeSchemaServices attributeSchemaServices;
 
     private final List<Action<? super VariantVersionMappingStrategy>> mappingsForAllVariants = new ArrayList<>(2);
-    private final Map<ImmutableAttributesBackedMatchingCandidate, String> defaultConfigurations = new HashMap<>();
-    private final Multimap<ImmutableAttributesBackedMatchingCandidate, Action<? super VariantVersionMappingStrategy>> attributeBasedMappings = ArrayListMultimap.create();
+    private final Map<ImmutableAttributes, String> defaultConfigurations = new HashMap<>();
+    private final Multimap<ImmutableAttributes, Action<? super VariantVersionMappingStrategy>> attributeBasedMappings = ArrayListMultimap.create();
 
     private AttributeMatcher matcher;
 
@@ -75,8 +74,7 @@ public void allVariants(Action<? super VariantVersionMappingStrategy> action) {
 
     @Override
     public <T> void variant(Attribute<T> attribute, T attributeValue, Action<? super VariantVersionMappingStrategy> action) {
-        ImmutableAttributes attributes = attributesFactory.of(attribute, attributeValue);
-        attributeBasedMappings.put(new ImmutableAttributesBackedMatchingCandidate(attributes), action);
+        attributeBasedMappings.put(attributesFactory.of(attribute, attributeValue), action);
     }
 
     @Override
@@ -86,8 +84,7 @@ public void usage(String usage, Action<? super VariantVersionMappingStrategy> ac
 
     @Override
     public void defaultResolutionConfiguration(String usage, String defaultConfiguration) {
-        ImmutableAttributes attributes = attributesFactory.of(Usage.USAGE_ATTRIBUTE, objectFactory.named(Usage.class, usage));
-        defaultConfigurations.put(new ImmutableAttributesBackedMatchingCandidate(attributes), defaultConfiguration);
+        defaultConfigurations.put(attributesFactory.of(Usage.USAGE_ATTRIBUTE, objectFactory.named(Usage.class, usage)), defaultConfiguration);
     }
 
     @Override
@@ -100,8 +97,8 @@ public VariantVersionMappingStrategyInternal findStrategyForVariant(ImmutableAtt
 
         // Then use attribute specific mapping
         if (!attributeBasedMappings.isEmpty()) {
-            List<ImmutableAttributesBackedMatchingCandidate> candidates = ImmutableList.copyOf(attributeBasedMappings.keySet());
-            List<ImmutableAttributesBackedMatchingCandidate> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
+            Set<ImmutableAttributes> candidates = attributeBasedMappings.keySet();
+            List<ImmutableAttributes> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
             if (matches.size() == 1) {
                 Collection<Action<? super VariantVersionMappingStrategy>> actions = attributeBasedMappings.get(matches.get(0));
                 for (Action<? super VariantVersionMappingStrategy> action : actions) {
@@ -119,9 +116,9 @@ private DefaultVariantVersionMappingStrategy createDefaultMappingStrategy(Immuta
         if (!defaultConfigurations.isEmpty()) {
             // First need to populate the default variant version mapping strategy with the default values
             // provided by plugins
-            List<ImmutableAttributesBackedMatchingCandidate> candidates = ImmutableList.copyOf(defaultConfigurations.keySet());
-            List<ImmutableAttributesBackedMatchingCandidate> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
-            for (ImmutableAttributesBackedMatchingCandidate match : matches) {
+            Set<ImmutableAttributes> candidates = defaultConfigurations.keySet();
+            List<ImmutableAttributes> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
+            for (ImmutableAttributes match : matches) {
                 strategy.setDefaultResolutionConfiguration(configurations.getByName(defaultConfigurations.get(match)));
             }
         }
diff --git a/platforms/software/reporting/build.gradle.kts b/platforms/software/reporting/build.gradle.kts
index 800f8112c83..cb26dea8b5d 100644
--- a/platforms/software/reporting/build.gradle.kts
+++ b/platforms/software/reporting/build.gradle.kts
@@ -32,7 +32,6 @@ dependencies {
     api(libs.jspecify)
 
     implementation(projects.fileCollections)
-    implementation(projects.logging)
 
     implementation(libs.guava)
     implementation(libs.jatl)
diff --git a/platforms/software/reporting/src/integTest/groovy/org/gradle/api/reporting/plugins/BuildDashboardPluginIntegrationTest.groovy b/platforms/software/reporting/src/integTest/groovy/org/gradle/api/reporting/plugins/BuildDashboardPluginIntegrationTest.groovy
index 5363b91c0f5..149560af8e7 100644
--- a/platforms/software/reporting/src/integTest/groovy/org/gradle/api/reporting/plugins/BuildDashboardPluginIntegrationTest.groovy
+++ b/platforms/software/reporting/src/integTest/groovy/org/gradle/api/reporting/plugins/BuildDashboardPluginIntegrationTest.groovy
@@ -17,6 +17,7 @@
 package org.gradle.api.reporting.plugins
 
 import org.gradle.api.JavaVersion
+import org.gradle.integtests.fixtures.ToBeFixedForConfigurationCache
 import org.gradle.integtests.fixtures.WellBehavedPluginTest
 import org.gradle.test.fixtures.file.TestFile
 import org.gradle.test.precondition.Requires
@@ -31,6 +32,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
 
     def setup() {
         writeBuildFile()
+        expectTaskProjectDeprecation = true
     }
 
     private void goodCode(TestFile root = testDirectory) {
@@ -119,8 +121,10 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         'buildDashboard'
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard for a project with no other reports lists just the dashboard'() {
         when:
+        expectTaskProjectDeprecation()
         run('buildDashboard')
 
         then:
@@ -129,12 +133,14 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         unavailableReports.empty
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard lists the enabled reports for the project'() {
         given:
         goodCode()
         goodTests()
 
         when:
+        expectTaskProjectDeprecation()
         run('check', 'buildDashboard')
 
         then:
@@ -144,12 +150,14 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':test', 'junitXml')
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard lists the reports which have not been generated'() {
         given:
         goodCode()
         goodTests()
 
         when:
+        expectTaskProjectDeprecation()
         run('buildDashboard')
 
         then:
@@ -160,12 +168,14 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasUnavailableReport(':test', 'junitXml')
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard is always generated after report generating tasks have executed'() {
         given:
         goodCode()
         goodTests()
 
         when:
+        expectTaskProjectDeprecation()
         run('buildDashboard', 'check')
 
         then:
@@ -175,12 +185,14 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':test', 'junitXml')
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'running a report generating task also generates build dashboard'() {
         given:
         goodCode()
         goodTests()
 
         when:
+        expectTaskProjectDeprecation()
         run('test')
 
         then:
@@ -190,12 +202,14 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':test', 'junitXml')
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard is generated even if report generating task fails'() {
         given:
         goodCode()
         badTests()
 
         when:
+        expectTaskProjectDeprecation()
         runAndFail('check')
 
         then:
@@ -243,17 +257,20 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         """
 
         when:
+        executer.withBuildJvmOpts("-Dorg.gradle.configuration-cache.internal.task-execution-access-pre-stable=true")
         run('buildDashboard')
 
         then:
         !buildDashboardFile.exists()
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'buildDashboard is incremental'() {
         given:
         goodCode()
 
         expect:
+        expectTaskProjectDeprecation()
         run('buildDashboard')
         executedAndNotSkipped(':buildDashboard')
 
@@ -264,10 +281,12 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         buildDashboardFile.delete()
 
         then:
+        expectTaskProjectDeprecation()
         run('buildDashboard')
         executedAndNotSkipped(':buildDashboard')
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     @Requires(UnitTestPreconditions.StableGroovy) // FIXME KM temporarily disabling while CodeNarc runs in Worker API with multiple Groovy runtimes
     void 'enabling an additional report renders buildDashboard out-of-date'() {
         given:
@@ -275,6 +294,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         withCodenarc()
 
         when:
+        expectTaskProjectDeprecation()
         run('check')
         executedAndNotSkipped(':buildDashboard')
 
@@ -291,6 +311,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         """
 
         and:
+        expectTaskProjectDeprecation()
         run('check')
         executedAndNotSkipped(':buildDashboard')
 
@@ -301,12 +322,14 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':codenarcMain', 'text')
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'generating a report that was previously not available renders buildDashboard out-of-date'() {
         given:
         goodCode()
         goodTests()
 
         when:
+        expectTaskProjectDeprecation()
         run('buildDashboard')
         executedAndNotSkipped(':buildDashboard')
 
@@ -318,6 +341,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasUnavailableReport(':test', 'junitXml')
 
         when:
+        expectTaskProjectDeprecation()
         run('test')
         executedAndNotSkipped(':buildDashboard')
 
@@ -329,6 +353,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         unavailableReports.empty
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'reports from subprojects are aggregated'() {
         given:
         goodCode()
@@ -336,6 +361,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         setupSubproject()
 
         when:
+        expectTaskProjectDeprecation()
         run('buildDashboard', 'check')
 
         then:
@@ -347,6 +373,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':subproject:test', 'junitXml')
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'dashboard includes JaCoCo reports'() {
         given:
         JacocoCoverage.assumeDefaultJacocoWorksOnCurrentJdk()
@@ -357,6 +384,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         """
 
         when:
+        expectTaskProjectDeprecation()
         run("test", "jacocoTestReport")
 
         then:
@@ -367,6 +395,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':jacocoTestReport', 'html')
     }
 
+    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     @Requires(UnitTestPreconditions.StableGroovy) // FIXME KM temporarily disabling while CodeNarc runs in Worker API with multiple Groovy runtimes
     void 'dashboard includes CodeNarc reports'() {
         given:
@@ -374,6 +403,7 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         withCodenarc()
 
         when:
+        expectTaskProjectDeprecation()
         run("check")
 
         then:
diff --git a/platforms/software/reporting/src/main/java/org/gradle/api/reporting/GenerateBuildDashboard.java b/platforms/software/reporting/src/main/java/org/gradle/api/reporting/GenerateBuildDashboard.java
index b036c8ef92e..5a5123d6a3b 100644
--- a/platforms/software/reporting/src/main/java/org/gradle/api/reporting/GenerateBuildDashboard.java
+++ b/platforms/software/reporting/src/main/java/org/gradle/api/reporting/GenerateBuildDashboard.java
@@ -23,7 +23,6 @@
 import org.gradle.api.NamedDomainObjectSet;
 import org.gradle.api.Project;
 import org.gradle.api.Task;
-import org.gradle.api.internal.ConfigurationCacheDegradation;
 import org.gradle.api.reporting.internal.BuildDashboardGenerator;
 import org.gradle.api.reporting.internal.DefaultBuildDashboardReports;
 import org.gradle.api.tasks.Input;
@@ -31,7 +30,6 @@
 import org.gradle.api.tasks.TaskAction;
 import org.gradle.internal.Cast;
 import org.gradle.internal.Describables;
-import org.gradle.internal.deprecation.DeprecationLogger;
 import org.gradle.internal.instrumentation.api.annotations.ToBeReplacedByLazyProperty;
 import org.gradle.util.internal.ClosureBackedAction;
 import org.gradle.util.internal.CollectionUtils;
@@ -54,7 +52,6 @@ public abstract class GenerateBuildDashboard extends DefaultTask implements Repo
     private final BuildDashboardReports reports;
 
     public GenerateBuildDashboard() {
-        ConfigurationCacheDegradation.requireDegradation(this, "Task is not compatible with the Configuration Cache");
         reports = getProject().getObjects().newInstance(DefaultBuildDashboardReports.class, Describables.quoted("Task", getIdentityPath()));
         reports.getHtml().getRequired().set(true);
     }
@@ -86,7 +83,7 @@ private Set<Report> getEnabledInputReports() {
 
     private Set<Reporting<? extends ReportContainer<?>>> getAggregatedTasks() {
         final Set<Reporting<? extends ReportContainer<?>>> reports = new HashSet<>();
-        DeprecationLogger.whileDisabled(this::getProject).allprojects(new Action<Project>() {
+        getProject().allprojects(new Action<Project>() {
             @Override
             public void execute(Project project) {
                 project.getTasks().all(new Action<Task>() {
diff --git a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/DependencyInsightReportTask.java b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/DependencyInsightReportTask.java
index 0b541e26090..b54ffbf2620 100644
--- a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/DependencyInsightReportTask.java
+++ b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/DependencyInsightReportTask.java
@@ -30,6 +30,7 @@
 import org.gradle.api.artifacts.result.ResolvedVariantResult;
 import org.gradle.api.attributes.Attribute;
 import org.gradle.api.attributes.AttributeContainer;
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.artifacts.configurations.ConfigurationInternal;
 import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionComparator;
 import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionParser;
@@ -49,9 +50,7 @@
 import org.gradle.api.tasks.diagnostics.internal.dsl.DependencyResultSpecNotationConverter;
 import org.gradle.api.tasks.diagnostics.internal.graph.DependencyGraphsRenderer;
 import org.gradle.api.tasks.diagnostics.internal.graph.NodeRenderer;
-import org.gradle.api.tasks.diagnostics.internal.graph.nodes.DependencyReportHeader;
 import org.gradle.api.tasks.diagnostics.internal.graph.nodes.RenderableDependency;
-import org.gradle.api.tasks.diagnostics.internal.graph.nodes.RequestedVersion;
 import org.gradle.api.tasks.diagnostics.internal.graph.nodes.Section;
 import org.gradle.api.tasks.diagnostics.internal.insight.DependencyInsightReporter;
 import org.gradle.api.tasks.diagnostics.internal.text.StyledTable;
@@ -517,11 +516,9 @@ private void printVariant(
         }
 
         private AttributeContainer getRequestedAttributes(RenderableDependency dependency) {
-            if (dependency instanceof DependencyReportHeader) {
-                AttributeContainer dependencyAttributes = ((DependencyReportHeader) dependency).getAttributes();
+            if (dependency instanceof HasAttributes) {
+                AttributeContainer dependencyAttributes = ((HasAttributes) dependency).getAttributes();
                 return concat(configurationAttributes, dependencyAttributes);
-            } else if (dependency instanceof RequestedVersion) {
-                return ((RequestedVersion) dependency).getAttributes();
             }
             return configurationAttributes;
         }
diff --git a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/DependencyReportHeader.java b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/DependencyReportHeader.java
index c11a41fd0ed..369fadc74d9 100644
--- a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/DependencyReportHeader.java
+++ b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/DependencyReportHeader.java
@@ -21,13 +21,14 @@
 import org.gradle.api.artifacts.component.ModuleComponentSelector;
 import org.gradle.api.artifacts.result.ResolvedVariantResult;
 import org.gradle.api.attributes.AttributeContainer;
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.jspecify.annotations.NonNull;
 import org.jspecify.annotations.Nullable;
 
 import java.util.List;
 
-public class DependencyReportHeader extends AbstractRenderableDependency {
+public class DependencyReportHeader extends AbstractRenderableDependency implements HasAttributes {
     private final DependencyEdge dependency;
     private final String description;
     private final List<ResolvedVariantResult> selectedVariants;
@@ -73,6 +74,7 @@ public List<ResolvedVariantResult> getAllVariants() {
         return allVariants;
     }
 
+    @Override
     public AttributeContainer getAttributes() {
         ComponentSelector requested = dependency.getRequested();
         return requested instanceof ModuleComponentSelector
diff --git a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/RequestedVersion.java b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/RequestedVersion.java
index 53b16a93eaa..029edbe6d2c 100644
--- a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/RequestedVersion.java
+++ b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/RequestedVersion.java
@@ -20,12 +20,13 @@
 import org.gradle.api.artifacts.component.ComponentSelector;
 import org.gradle.api.artifacts.component.ModuleComponentSelector;
 import org.gradle.api.attributes.AttributeContainer;
+import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 
 import java.util.LinkedHashSet;
 import java.util.Set;
 
-public class RequestedVersion extends AbstractRenderableDependencyResult {
+public class RequestedVersion extends AbstractRenderableDependencyResult implements HasAttributes {
     private final ComponentSelector requested;
     private final ComponentIdentifier actual;
     private final boolean resolvable;
@@ -61,6 +62,7 @@ public Set<RenderableDependency> getChildren() {
         return children;
     }
 
+    @Override
     public AttributeContainer getAttributes() {
         return requested instanceof ModuleComponentSelector
             ? requested.getAttributes()
diff --git a/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestCountLogger.java b/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestCountLogger.java
index c7f73f23f64..c4d2fb8c5c4 100644
--- a/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestCountLogger.java
+++ b/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestCountLogger.java
@@ -18,7 +18,6 @@
 
 import org.gradle.api.internal.DocumentationRegistry;
 import org.gradle.api.internal.tasks.testing.TestWorkerFailureException;
-import org.gradle.api.internal.tasks.testing.worker.ForkingTestClassProcessor;
 import org.gradle.api.tasks.testing.TestDescriptor;
 import org.gradle.api.tasks.testing.TestFailure;
 import org.gradle.api.tasks.testing.TestListener;
@@ -133,7 +132,7 @@ public void afterSuite(TestDescriptor suite, TestResult result) {
             // Looks like a test worker suite
             // TODO: Instead of assuming all failures at this level are worker failures, we should
             // identify worker failures in the TestFailureDetails
-            if (suite.getParent().getParent() == null && suite.getDisplayName().startsWith(ForkingTestClassProcessor.GRADLE_TEST_WORKER_NAME)) {
+            if (suite.getParent().getParent() == null) {
                 if (result.getResultType() == TestResult.ResultType.FAILURE) {
                     workerFailures.addAll(result.getFailures());
                 }
diff --git a/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/worker/ForkingTestClassProcessor.java b/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/worker/ForkingTestClassProcessor.java
index 0cd658cf3d7..577adb2978b 100644
--- a/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/worker/ForkingTestClassProcessor.java
+++ b/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/worker/ForkingTestClassProcessor.java
@@ -38,8 +38,6 @@
 import java.util.concurrent.locks.ReentrantLock;
 
 public class ForkingTestClassProcessor implements TestClassProcessor {
-    public static final String GRADLE_TEST_WORKER_NAME = "Gradle Test Executor";
-
     private final WorkerProcessFactory workerFactory;
     private final WorkerTestClassProcessorFactory processorFactory;
     private final JavaForkOptions options;
@@ -103,7 +101,7 @@ public void processTestClass(TestClassRunInfo testClass) {
 
     RemoteTestClassProcessor forkProcess() {
         WorkerProcessBuilder builder = workerFactory.create(new TestWorker(processorFactory));
-        builder.setBaseName(GRADLE_TEST_WORKER_NAME);
+        builder.setBaseName("Gradle Test Executor");
         builder.setImplementationClasspath(classpath.getImplementationClasspath());
         builder.applicationClasspath(classpath.getApplicationClasspath());
         builder.applicationModulePath(classpath.getApplicationModulepath());
diff --git a/released-versions.json b/released-versions.json
index 223408c96c8..18cc2fdc509 100644
--- a/released-versions.json
+++ b/released-versions.json
@@ -1,7 +1,7 @@
 {
   "latestReleaseSnapshot": {
-    "version": "9.0.0-20250715101636+0000",
-    "buildTime": "20250715101636+0000"
+    "version": "9.0.0-20250712014520+0000",
+    "buildTime": "20250712014520+0000"
   },
   "latestRc": {
     "version": "9.0.0-rc-2",
diff --git a/settings.gradle.kts b/settings.gradle.kts
index 98c2f2ed33b..b238b66a051 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -29,7 +29,7 @@ buildscript {
 plugins {
     id("gradlebuild.build-environment")
     id("gradlebuild.configuration-cache-compatibility")
-    id("com.gradle.develocity").version("4.1") // Run `java build-logic-settings/UpdateDevelocityPluginVersion.java <new-version>` to update
+    id("com.gradle.develocity").version("4.0.2") // Run `java build-logic-settings/UpdateDevelocityPluginVersion.java <new-version>` to update
     id("io.github.gradle.gradle-enterprise-conventions-plugin").version("0.10.2")
     id("org.gradle.toolchains.foojay-resolver-convention").version("1.0.0")
 }
diff --git a/subprojects/core/src/integTest/groovy/org/gradle/api/ProjectModuleIdentityIntegrationTest.groovy b/subprojects/core/src/integTest/groovy/org/gradle/api/ProjectModuleIdentityIntegrationTest.groovy
new file mode 100644
index 00000000000..726456c1a29
--- /dev/null
+++ b/subprojects/core/src/integTest/groovy/org/gradle/api/ProjectModuleIdentityIntegrationTest.groovy
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2025 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.gradle.api
+
+import org.gradle.integtests.fixtures.AbstractIntegrationSpec
+
+/**
+ * Tests project behavior related to module identity:
+ * <ul>
+ *     <li>{@link Project#getGroup()}</li>
+ *     <li>{@link Project#getVersion()}</li>
+ * <ul>
+ */
+class ProjectModuleIdentityIntegrationTest extends AbstractIntegrationSpec {
+
+    def "default group for root project is an empty string"() {
+        buildFile << """
+            assert group == ""
+        """
+
+        expect:
+        succeeds("help")
+    }
+
+    def "default group for subproject is based on project structure"() {
+        given:
+        settingsFile << """
+            rootProject.name = "root"
+            include(":sub")
+            include(":sub:subsub")
+        """
+
+        file("sub/build.gradle") << """
+            assert group == "root"
+        """
+        file("sub/subsub/build.gradle") << """
+            assert group == "root.sub"
+        """
+
+        expect:
+        succeeds("help")
+    }
+
+    def "default version for root project is 'unspecified'"() {
+        buildFile << """
+            assert version == "unspecified"
+        """
+
+        expect:
+        succeeds("help")
+    }
+
+}
diff --git a/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java b/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
index 9670d5cf54a..7967f60a37f 100644
--- a/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
+++ b/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
@@ -141,6 +141,8 @@
 import java.util.TreeMap;
 import java.util.TreeSet;
 import java.util.concurrent.Callable;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 
 import static com.google.common.base.Strings.isNullOrEmpty;
 import static java.util.Collections.singletonMap;
@@ -175,7 +177,7 @@ public abstract class DefaultProject extends AbstractPluginAware implements Proj
 
     private final String name;
 
-    private Object group;
+    private @Nullable Object group;
 
     private Object version;
 
@@ -474,15 +476,24 @@ public void setDescription(@Nullable String description) {
     @Override
     public Object getGroup() {
         onMutableStateAccess();
-        if (group != null) {
-            return group;
-        } else if (this == rootProject) {
-            return "";
+        if (group == null) {
+            group = getDefaultGroup();
         }
-        group = rootProject.getName() + (getParent() == rootProject ? "" : "." + getParent().getPath().substring(1).replace(':', '.'));
         return group;
     }
 
+    private String getDefaultGroup() {
+        ProjectInternal parent = getParent();
+        if (parent == null) {
+            return "";
+        }
+
+        return Stream.concat(
+            Stream.of(rootProject.getName()),
+            parent.getProjectIdentity().getProjectPath().segments().stream()
+        ).collect(Collectors.joining("."));
+    }
+
     @Override
     public void setGroup(Object group) {
         onMutableStateAccess();
diff --git a/subprojects/core/src/main/java/org/gradle/plugin/management/internal/autoapply/AutoAppliedDevelocityPlugin.java b/subprojects/core/src/main/java/org/gradle/plugin/management/internal/autoapply/AutoAppliedDevelocityPlugin.java
index a92ec99fb97..c167c4fe756 100644
--- a/subprojects/core/src/main/java/org/gradle/plugin/management/internal/autoapply/AutoAppliedDevelocityPlugin.java
+++ b/subprojects/core/src/main/java/org/gradle/plugin/management/internal/autoapply/AutoAppliedDevelocityPlugin.java
@@ -28,7 +28,7 @@ public final class AutoAppliedDevelocityPlugin {
 
     public static final String GROUP = "com.gradle";
     public static final String NAME = "develocity-gradle-plugin";
-    public static final String VERSION = "4.1";
+    public static final String VERSION = "4.0.2";
 
 
     public static final PluginId ID = new DefaultPluginId("com.gradle.develocity");
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/AllDistributionIntegrationSpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/AllDistributionIntegrationSpec.groovy
index d7593c02e75..d293c9e6ecc 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/AllDistributionIntegrationSpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/AllDistributionIntegrationSpec.groovy
@@ -38,7 +38,7 @@ class AllDistributionIntegrationSpec extends DistributionIntegrationSpec {
 
     @Override
     int getDistributionSizeMiB() {
-        return 218
+        return 216
     }
 
     @Requires(UnitTestPreconditions.StableGroovy) // cannot link to public javadocs of Groovy snapshots like https://docs.groovy-lang.org/docs/groovy-4.0.5-SNAPSHOT/html/gapi/
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/BinDistributionIntegrationSpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/BinDistributionIntegrationSpec.groovy
index d098b41d504..7deadee78e5 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/BinDistributionIntegrationSpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/BinDistributionIntegrationSpec.groovy
@@ -34,7 +34,7 @@ class BinDistributionIntegrationSpec extends DistributionIntegrationSpec {
 
     @Override
     int getDistributionSizeMiB() {
-        return 128
+        return 130
     }
 
     def binZipContents() {
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegrationSpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegrationSpec.groovy
index 3f31c83a1bb..af830880ad3 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegrationSpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegrationSpec.groovy
@@ -186,14 +186,11 @@ abstract class DistributionIntegrationSpec extends AbstractIntegrationSpec {
 
     def "distribution size should not change too much"() {
         expect:
-        def actualKB = (int) Math.ceil((double) getZip().size() / 1024)
-        def expectedKB = getDistributionSizeMiB() * 1024
+        def actual = (int) Math.ceil((double) getZip().size() / 1024 / 1024)
+        def expected = getDistributionSizeMiB()
 
-        int margin = buildContext.version.isSnapshot() ? 1024 : 2048 // Allow 1 MiB margin for current dev, 2 MiB for more stable releases (promotion builds)
-        def message = "content needs to be verified. Current size: ${(int) (actualKB / 1024)} MiB (${actualKB} KiB). Expected size: ${getDistributionSizeMiB()}  ${margin / 1024} MiB."
-
-        assert actualKB <= expectedKB + margin: "Distribution is unexpectedly larger, $message"
-        assert actualKB >= expectedKB - margin: "Distribution is unexpectedly smaller, $message"
+        assert actual <= expected + 1: "Distribution is at least 1MiB larger, content needs to be verified. Current size: ${actual} MiB. Expected size: ${expected} MiB."
+        assert actual >= expected - 1: "Distribution is  at least 1MiB smaller, content needs to be verified. Current size: ${actual} MiB. Expected size: ${expected} MiB."
     }
 
     def "no duplicate jar entries in distribution"() {
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegritySpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegritySpec.groovy
index 91a3782d2ee..41b2adf8c03 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegritySpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegritySpec.groovy
@@ -38,7 +38,7 @@ class DistributionIntegritySpec extends DistributionIntegrationSpec {
 
     @Override
     int getDistributionSizeMiB() {
-        return 128
+        return 130
     }
 
     /**
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/SrcDistributionIntegrationSpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/SrcDistributionIntegrationSpec.groovy
index a9804fb2ea9..ac9429dfe76 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/SrcDistributionIntegrationSpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/SrcDistributionIntegrationSpec.groovy
@@ -39,7 +39,7 @@ class SrcDistributionIntegrationSpec extends DistributionIntegrationSpec {
 
     @Override
     int getDistributionSizeMiB() {
-        return 66
+        return 65
     }
 
     @Override
diff --git a/testing/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/WellBehavedPluginTest.groovy b/testing/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/WellBehavedPluginTest.groovy
index 76cc0f9ca11..ba9870b6ede 100644
--- a/testing/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/WellBehavedPluginTest.groovy
+++ b/testing/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/WellBehavedPluginTest.groovy
@@ -43,6 +43,7 @@ abstract class WellBehavedPluginTest extends AbstractIntegrationSpec {
     }
 
     @ToBeFixedForConfigurationCache(bottomSpecs = [
+        "BuildDashboardPluginIntegrationTest",
         "ScalaPluginGoodBehaviourTest",
         "AntlrPluginIntegrationTest",
         "PlayApplicationPluginGoodBehaviourIntegrationTest",
@@ -70,6 +71,7 @@ abstract class WellBehavedPluginTest extends AbstractIntegrationSpec {
     }
 
     @ToBeFixedForConfigurationCache(bottomSpecs = [
+        "BuildDashboardPluginIntegrationTest",
         "ScalaPluginGoodBehaviourTest",
         "AntlrPluginIntegrationTest",
         "PlayApplicationPluginGoodBehaviourIntegrationTest",
diff --git a/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/AbstractSmokeTest.groovy b/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/AbstractSmokeTest.groovy
index 732fce62a5a..f1e9105522e 100644
--- a/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/AbstractSmokeTest.groovy
+++ b/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/AbstractSmokeTest.groovy
@@ -48,7 +48,7 @@ abstract class AbstractSmokeTest extends Specification {
     static class TestedVersions {
         /**
          * May also need to update
-         * @see DevelocityPluginSmokeTest
+         * @see BuildScanPluginSmokeTest
          */
 
         // https://plugins.gradle.org/plugin/biz.aQute.bnd
diff --git a/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/BuildScanPluginSmokeTest.groovy b/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/BuildScanPluginSmokeTest.groovy
new file mode 100644
index 00000000000..fd528764ef0
--- /dev/null
+++ b/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/BuildScanPluginSmokeTest.groovy
@@ -0,0 +1,483 @@
+/*
+ * Copyright 2017 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.gradle.smoketests
+
+import org.gradle.integtests.fixtures.executer.GradleContextualExecuter
+import org.gradle.internal.enterprise.core.GradleEnterprisePluginManager
+import org.gradle.plugin.management.internal.autoapply.AutoAppliedDevelocityPlugin
+import org.gradle.test.fixtures.file.TestFile
+import org.gradle.test.precondition.Requires
+import org.gradle.test.preconditions.IntegTestPreconditions
+import org.gradle.testkit.runner.BuildResult
+import org.gradle.testkit.runner.TaskOutcome
+import org.gradle.util.GradleVersion
+import org.gradle.util.internal.VersionNumber
+
+import java.nio.charset.StandardCharsets
+import java.util.concurrent.ConcurrentHashMap
+
+// https://plugins.gradle.org/plugin/com.gradle.develocity
+class BuildScanPluginSmokeTest extends AbstractSmokeTest {
+
+    enum CI {
+        TEAM_CITY(
+            AbstractSmokeTest.TestedVersions.teamCityGradlePluginRef,
+            "https://raw.githubusercontent.com/etiennestuder/teamcity-build-scan-plugin/%s/agent/src/main/resources/init-scripts/develocity-injection.init.gradle"
+        ),
+        JENKINS(
+            AbstractSmokeTest.TestedVersions.jenkinsGradlePluginRef,
+            "https://raw.githubusercontent.com/jenkinsci/gradle-plugin/%s/src/main/resources/hudson/plugins/gradle/injection/init-script.gradle"
+        ),
+        BAMBOO(
+            AbstractSmokeTest.TestedVersions.bambooGradlePluginRef,
+            "https://raw.githubusercontent.com/gradle/develocity-bamboo-plugin/refs/tags/%s/src/main/resources/develocity/gradle/develocity-init-script.gradle"
+        );
+
+        String gitRef
+        String urlTemplate
+
+        CI(String gitRef, String urlTemplate) {
+            this.gitRef = gitRef
+            this.urlTemplate = urlTemplate
+        }
+
+        String getUrl() {
+            return String.format(urlTemplate, gitRef)
+        }
+    }
+
+    private static final Map<CI, String> CI_INJECTION_SCRIPT_CONTENTS = new ConcurrentHashMap<>()
+
+    private static String getCiInjectionScriptContent(CI ci) {
+        return CI_INJECTION_SCRIPT_CONTENTS.computeIfAbsent(ci) { new URL(it.getUrl()).getText(StandardCharsets.UTF_8.name()) }
+    }
+
+    private static final List<String> LEGACY_UNSUPPORTED = [
+        "1.14",
+        "1.15",
+        "1.16",
+        "2.0",
+        "2.0.1",
+        "2.0.2",
+        "2.1",
+        "2.2",
+        "2.2.1",
+        "2.3",
+        "2.4",
+        "2.4.1",
+        "2.4.2"
+    ]
+
+    private static final List<String> UNSUPPORTED = [
+        "3.0",
+        "3.1",
+        "3.1.1",
+        "3.2",
+        "3.2.1",
+        "3.3",
+        "3.3.1",
+        "3.3.2",
+        "3.3.3",
+        "3.3.4",
+        "3.4",
+        "3.4.1",
+        "3.5",
+        "3.5.1",
+        "3.5.2",
+        "3.6",
+        "3.6.1",
+        "3.6.2",
+        "3.6.3",
+        "3.6.4",
+        "3.7",
+        "3.7.1",
+        "3.7.2",
+        "3.8",
+        "3.8.1",
+        "3.9",
+        "3.10",
+        "3.10.1",
+        "3.10.2",
+        "3.10.3",
+        // "3.11", This doesn't work on Java 8, so let's not test it.
+        "3.11.1",
+        "3.11.2",
+        "3.11.3",
+        "3.11.4",
+        "3.12",
+        "3.12.1",
+        "3.12.2",
+        "3.12.3",
+        "3.12.4",
+        "3.12.5",
+        "3.12.6",
+        "3.13"
+    ]
+
+    private static final List<String> SUPPORTED = [
+        "3.13.1",
+        "3.13.2",
+        "3.13.3",
+        "3.13.4",
+        "3.14",
+        "3.14.1",
+        "3.15",
+        "3.15.1",
+        "3.16",
+        "3.16.1",
+        "3.16.2",
+        "3.17",
+        "3.17.1",
+        "3.17.2",
+        "3.17.3",
+        "3.17.4",
+        "3.17.5",
+        "3.17.6",
+        "3.18",
+        "3.18.1",
+        "3.18.2",
+        "3.19",
+        "3.19.1",
+        "3.19.2",
+        "4.0",
+        "4.0.1",
+        "4.0.2"
+    ]
+
+    // Current injection scripts support Develocity plugin 3.6.4 and above
+    private static final List<String> SUPPORTED_BY_CI_INJECTION = SUPPORTED
+        .findAll { VersionNumber.parse("3.6.4") <= VersionNumber.parse(it) }
+
+    private static final VersionNumber FIRST_VERSION_SUPPORTING_ISOLATED_PROJECTS = VersionNumber.parse("3.15")
+    private static final VersionNumber FIRST_VERSION_SUPPORTING_ISOLATED_PROJECTS_FOR_TEST_ACCELERATION = VersionNumber.parse("3.17")
+    private static final VersionNumber FIRST_VERSION_SUPPORTING_SAFE_MODE = VersionNumber.parse("3.15")
+    private static final VersionNumber FIRST_VERSION_UNDER_DEVELOCITY_BRAND = VersionNumber.parse("3.17")
+
+    def "coverage at least up to auto-applied version"() {
+        expect:
+        VersionNumber.parse(AutoAppliedDevelocityPlugin.VERSION) <= VersionNumber.parse(SUPPORTED.last())
+    }
+
+    def "can use plugin #version"() {
+        when:
+        usePluginVersion version
+
+        then:
+        scanRunner()
+            .build().output.contains("Build scan written to")
+
+        where:
+        version << SUPPORTED
+    }
+
+    @Requires(value = IntegTestPreconditions.NotConfigCached, reason = "Isolated projects implies config cache")
+    def "can use plugin #version with isolated projects"() {
+        when:
+        usePluginVersion version
+
+        then:
+        scanRunner("-Dorg.gradle.unsafe.isolated-projects=true")
+            .build().output.contains("Build scan written to")
+
+        where:
+        version << SUPPORTED
+            .findAll { FIRST_VERSION_SUPPORTING_ISOLATED_PROJECTS <= VersionNumber.parse(it) }
+    }
+
+    @Requires(value = IntegTestPreconditions.NotConfigCached, reason = "Isolated projects implies config cache")
+    def "can use plugin #version with isolated projects and test acceleration features"() {
+        when:
+        usePluginVersion version
+        ["project1", "project2"].each { projectName ->
+            setupJavaProject(file(projectName)).with {
+                buildFile << """
+                    tasks.withType(Test).configureEach {
+                        develocity {
+                            testRetry {
+                                maxRetries = 3
+                            }
+                        }
+                    }
+
+                """
+            }
+            settingsFile << """
+                include ':${projectName}'
+            """
+        }
+        settingsFile << """
+            include ':project1'
+            include ':project2'
+        """
+
+
+        then:
+        scanRunner("-Dorg.gradle.unsafe.isolated-projects=true")
+            .build().output.contains("Build scan written to")
+
+        when:
+        createTest(file("project1"), "MyTest1")
+        createTest(file("project2"), "MyTest1")
+
+        then:
+        with(scanRunner("-Dorg.gradle.unsafe.isolated-projects=true")
+            .build()) {
+            output.contains("Build scan written to")
+            output.contains("Reusing configuration cache.")
+            task(":project1:test").outcome == TaskOutcome.SUCCESS
+            task(":project2:test").outcome == TaskOutcome.SUCCESS
+        }
+
+        when:
+        file("project1/build.gradle") << """
+            println("Change a project so it's reconfigured")
+        """
+        createTest(file("project1"), "MyTest2")
+        createTest(file("project2"), "MyTest2")
+
+        then:
+        with(scanRunner("-Dorg.gradle.unsafe.isolated-projects=true")
+            .build()) {
+            output.contains("Build scan written to")
+            task(":project1:test").outcome == TaskOutcome.SUCCESS
+            task(":project2:test").outcome == TaskOutcome.SUCCESS
+        }
+
+        where:
+        version << SUPPORTED
+            .findAll { VersionNumber.parse(it) >= FIRST_VERSION_SUPPORTING_ISOLATED_PROJECTS_FOR_TEST_ACCELERATION }
+    }
+
+    @Requires(value = IntegTestPreconditions.NotConfigCached, reason = "Isolated projects implies config cache")
+    def "cannot use plugin #version with isolated projects"() {
+        when:
+        usePluginVersion version
+
+        and:
+        def output = scanRunner("-Dorg.gradle.unsafe.isolated-projects=true")
+            .build().output
+
+        then:
+        output.contains("Gradle Enterprise plugin $version has been disabled as it is incompatible with Isolated Projects. Upgrade to Gradle Enterprise plugin 3.15 or newer to restore functionality.")
+        !output.contains("Build scan written to")
+
+        where:
+        version << SUPPORTED
+            .findAll { VersionNumber.parse(it) < FIRST_VERSION_SUPPORTING_ISOLATED_PROJECTS }
+    }
+
+    def "cannot use plugin #version"() {
+        when:
+        usePluginVersion version
+
+        and:
+        def output = runner("--stacktrace")
+            .buildAndFail().output
+
+        then:
+        output.contains(GradleEnterprisePluginManager.OLD_SCAN_PLUGIN_VERSION_MESSAGE)
+
+        where:
+        version << LEGACY_UNSUPPORTED
+    }
+
+    def "plugin is disabled for unsupported version #version"() {
+        def expectedToFailWithConfigCacheProblem =
+            GradleContextualExecuter.configCache && VersionNumber.parse(version) < VersionNumber.parse("3.4")
+
+        when:
+        usePluginVersion version
+
+        and:
+        def runner = scanRunner()
+        def buildResult = expectedToFailWithConfigCacheProblem ? runner.buildAndFail() : runner.build()
+        def output = buildResult.output
+
+        then:
+        output.contains("Gradle Enterprise plugin $version has been disabled as it is incompatible with this version of Gradle. Upgrade to Gradle Enterprise plugin 3.13.1 or newer to restore functionality.")
+        !output.contains("Build scan written to")
+
+        if (expectedToFailWithConfigCacheProblem) {
+            assert output.contains("1 problem was found storing the configuration cache.")
+            assert output =~ /.*registration of listener on '\S+' is unsupported.*/
+        }
+
+        where:
+        version << UNSUPPORTED
+    }
+
+    @Requires(IntegTestPreconditions.NotConfigCached)
+    def "can inject plugin #pluginVersion in #ci using '#ciScriptVersion' script version"() {
+        def versionNumber = VersionNumber.parse(pluginVersion)
+        def initScript = "init-script.gradle"
+        file(initScript) << getCiInjectionScriptContent(ci)
+
+        // URL is not relevant as long as it's valid due to the `-Dscan.dump` parameter
+        file("gradle.properties") << """
+            systemProp.develocity.plugin.version=$pluginVersion
+            systemProp.develocity.injection.init-script-name=$initScript
+            systemProp.develocity.url=http://localhost:5086
+            systemProp.develocity.injection-enabled=true
+
+            # since bamboo 2.3.0 and jenkins 2.15
+            systemProp.develocity-injection.develocity-plugin.version=$pluginVersion
+            systemProp.develocity-injection.init-script-name=$initScript
+            systemProp.develocity-injection.url=http://localhost:5086
+            systemProp.develocity-injection.enabled=true
+        """.stripIndent()
+
+        setupLocalBuildCache()
+        setupJavaProject()
+        if (supportsSafeMode(versionNumber)) {
+            new TestFile(buildFile).with {
+                touch()
+                prepend("""
+                    plugins {
+                        id "org.gradle.test-retry" version "${TestedVersions.testRetryPlugin}"
+                    }
+                """)
+            }
+        }
+
+        when:
+        def result = scanRunner("--init-script", initScript)
+            .maybeExpectLegacyDeprecationWarningIf(FIRST_VERSION_UNDER_DEVELOCITY_BRAND <= versionNumber,
+                "WARNING: The following functionality has been deprecated and will be removed in the next major release of the Develocity Gradle plugin:")
+            .maybeExpectLegacyDeprecationWarningIf(FIRST_VERSION_UNDER_DEVELOCITY_BRAND <= versionNumber,
+                "WARNING: The following functionality has been deprecated and will be removed in the next major release of the Develocity Gradle plugin. " +
+                    "For assistance with migration, see https://gradle.com/help/gradle-plugin-develocity-migration.")
+            .maybeExpectLegacyDeprecationWarningIf(FIRST_VERSION_UNDER_DEVELOCITY_BRAND <= versionNumber,
+                "WARNING: The following functionality has been deprecated and will be removed in the next major release of the Develocity Gradle plugin. Run with '-Ddevelocity.deprecation.captureOrigin=true' to see where the deprecated functionality is being used. " +
+                    "For assistance with migration, see https://gradle.com/help/gradle-plugin-develocity-migration.")
+            .maybeExpectLegacyDeprecationWarningIf(FIRST_VERSION_UNDER_DEVELOCITY_BRAND <= versionNumber,
+                "- The deprecated \"gradleEnterprise.server\" API has been replaced by \"develocity.server\"")
+            .maybeExpectLegacyDeprecationWarningIf(FIRST_VERSION_UNDER_DEVELOCITY_BRAND <= versionNumber,
+                "- The deprecated \"gradleEnterprise.allowUntrustedServer\" API has been replaced by \"develocity.allowUntrustedServer\"")
+            .maybeExpectLegacyDeprecationWarningIf(FIRST_VERSION_UNDER_DEVELOCITY_BRAND <= versionNumber,
+                "- The deprecated \"gradleEnterprise.buildScan.uploadInBackground\" API has been replaced by \"develocity.buildScan.uploadInBackground\"")
+            .maybeExpectLegacyDeprecationWarningIf(FIRST_VERSION_UNDER_DEVELOCITY_BRAND <= versionNumber,
+                "- The deprecated \"gradleEnterprise.buildScan.value\" API has been replaced by \"develocity.buildScan.value\"")
+            .maybeExpectLegacyDeprecationWarningIf(FIRST_VERSION_UNDER_DEVELOCITY_BRAND <= versionNumber && ci == CI.TEAM_CITY,
+                "- The deprecated \"gradleEnterprise.buildScan.buildScanPublished\" API has been replaced by \"develocity.buildScan.buildScanPublished\"")
+            .maybeExpectLegacyDeprecationWarning(
+                "Properties should be assigned using the 'propName = value' syntax. Setting a property via the Gradle-generated 'propName value' or 'propName(value)' syntax in Groovy DSL has been deprecated. " +
+                    "This is scheduled to be removed in Gradle 10. " +
+                    "Use assignment ('url = <value>') instead. " +
+                    "Consult the upgrading guide for further information: https://docs.gradle.org/${GradleVersion.current().version}/userguide/upgrading_version_8.html#groovy_space_assignment_syntax"
+            )
+            .build()
+
+        then:
+        result.output.contains("Build scan written to")
+
+        where:
+        [ci, pluginVersion] << [CI.values(), SUPPORTED_BY_CI_INJECTION].combinations()
+        ciScriptVersion = ci.gitRef
+    }
+
+    private static boolean supportsSafeMode(VersionNumber pluginVersion) {
+        pluginVersion >= FIRST_VERSION_SUPPORTING_SAFE_MODE
+    }
+
+    BuildResult build(String... args) {
+        scanRunner(args).build()
+    }
+
+    SmokeTestGradleRunner scanRunner(String... args) {
+        // Run with --build-cache to test also build cache events
+        runner("build", "-Dscan.dump", "--build-cache", *args)
+    }
+
+    void usePluginVersion(String version) {
+        def develocityPlugin = VersionNumber.parse(version) >= VersionNumber.parse("3.17")
+        def gradleEnterprisePlugin = VersionNumber.parse(version) >= VersionNumber.parse("3.0")
+        if (develocityPlugin) {
+            settingsFile << """
+                plugins {
+                    id "com.gradle.develocity" version "$version"
+                }
+
+                develocity {
+                    buildScan {
+                        termsOfUseUrl = 'https://gradle.com/help/legal-terms-of-use'
+                        termsOfUseAgree = 'yes'
+                    }
+                }
+            """
+        } else if (gradleEnterprisePlugin) {
+            settingsFile << """
+                plugins {
+                    id "com.gradle.enterprise" version "$version"
+                }
+
+                gradleEnterprise {
+                    buildScan {
+                        termsOfServiceUrl = 'https://gradle.com/terms-of-service'
+                        termsOfServiceAgree = 'yes'
+                    }
+                }
+            """
+        } else {
+            buildFile << """
+                plugins {
+                    id "com.gradle.build-scan" version "$version"
+                }
+
+                buildScan {
+                    termsOfServiceUrl = 'https://gradle.com/terms-of-service'
+                    termsOfServiceAgree = 'yes'
+                }
+            """
+        }
+
+        setupLocalBuildCache()
+        setupJavaProject()
+    }
+
+    private TestFile setupJavaProject(TestFile projectDir = new TestFile(testProjectDir)) {
+        projectDir.file("build.gradle") << """
+            apply plugin: 'java'
+            ${mavenCentralRepository()}
+
+            dependencies {
+                testImplementation 'junit:junit:4.13'
+            }
+        """
+
+        projectDir.file("src/main/java/MySource.java") << """
+            public class MySource {
+                public static boolean isTrue() { return true; }
+            }
+        """
+
+        createTest(projectDir, "MyTest")
+        projectDir
+    }
+
+    void createTest(TestFile projectDir, String testName) {
+        projectDir.file("src/test/java/${testName}.java") << """
+            import org.junit.*;
+
+            public class ${testName} {
+               @Test
+               public void test() {
+                  Assert.assertTrue(MySource.isTrue());
+               }
+            }
+        """
+    }
+}
