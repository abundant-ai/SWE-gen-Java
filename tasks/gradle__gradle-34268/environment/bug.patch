diff --git a/build-logic-commons/build-platform/build.gradle.kts b/build-logic-commons/build-platform/build.gradle.kts
index 1573d5ed5b7..805bda154d8 100644
--- a/build-logic-commons/build-platform/build.gradle.kts
+++ b/build-logic-commons/build-platform/build.gradle.kts
@@ -27,7 +27,7 @@ dependencies {
     constraints {
         api("org.gradle.guides:gradle-guides-plugin:0.24.0")
         api("org.apache.ant:ant:1.10.15") // Bump the version brought in transitively by gradle-guides-plugin
-        api("com.gradle:develocity-gradle-plugin:4.0.2") // Run `java build-logic-settings/UpdateDevelocityPluginVersion.java <new-version>` to update
+        api("com.gradle:develocity-gradle-plugin:4.1") // Run `java build-logic-settings/UpdateDevelocityPluginVersion.java <new-version>` to update
         api("com.gradle.publish:plugin-publish-plugin:1.3.1")
         api("gradle.plugin.org.jetbrains.gradle.plugin.idea-ext:gradle-idea-ext:1.1.10")
         api("me.champeau.gradle:japicmp-gradle-plugin:0.4.1")
diff --git a/build-logic-settings/settings.gradle.kts b/build-logic-settings/settings.gradle.kts
index d8cf476f678..4aa0d526245 100644
--- a/build-logic-settings/settings.gradle.kts
+++ b/build-logic-settings/settings.gradle.kts
@@ -39,7 +39,7 @@ pluginManagement {
 }
 
 plugins {
-    id("com.gradle.develocity").version("4.0.2") // Run `java build-logic-settings/UpdateDevelocityPluginVersion.java <new-version>` to update
+    id("com.gradle.develocity").version("4.1") // Run `java build-logic-settings/UpdateDevelocityPluginVersion.java <new-version>` to update
     id("io.github.gradle.gradle-enterprise-conventions-plugin").version("0.10.2")
     id("org.gradle.toolchains.foojay-resolver-convention").version("1.0.0")
 }
diff --git a/platforms/core-configuration/model-core/src/test/groovy/org/gradle/internal/extensibility/DefaultExtraPropertiesExtensionTest.groovy b/platforms/core-configuration/model-core/src/test/groovy/org/gradle/internal/extensibility/DefaultExtraPropertiesExtensionTest.groovy
index 96a4756c117..0883b20299c 100644
--- a/platforms/core-configuration/model-core/src/test/groovy/org/gradle/internal/extensibility/DefaultExtraPropertiesExtensionTest.groovy
+++ b/platforms/core-configuration/model-core/src/test/groovy/org/gradle/internal/extensibility/DefaultExtraPropertiesExtensionTest.groovy
@@ -22,4 +22,12 @@ class DefaultExtraPropertiesExtensionTest extends ExtraPropertiesExtensionTest<D
         new DefaultExtraPropertiesExtension()
     }
 
+    static class WithEmptyGradleProperties extends ExtraPropertiesExtensionTest<DefaultExtraPropertiesExtension> {
+
+        DefaultExtraPropertiesExtension createExtension() {
+            new DefaultExtraPropertiesExtension().tap {
+                it.setGradleProperties([:])
+            }
+        }
+    }
 }
diff --git a/platforms/core-configuration/model-core/src/test/groovy/org/gradle/internal/extensibility/ExtraPropertiesExtensionTest.groovy b/platforms/core-configuration/model-core/src/test/groovy/org/gradle/internal/extensibility/ExtraPropertiesExtensionTest.groovy
index ad32e924a1e..426cffd7215 100644
--- a/platforms/core-configuration/model-core/src/test/groovy/org/gradle/internal/extensibility/ExtraPropertiesExtensionTest.groovy
+++ b/platforms/core-configuration/model-core/src/test/groovy/org/gradle/internal/extensibility/ExtraPropertiesExtensionTest.groovy
@@ -120,14 +120,14 @@ abstract class ExtraPropertiesExtensionTest<T extends ExtraPropertiesExtension>
         thrown(MissingMethodException)
     }
 
-    def "can get properties as a detached map"() {
+    def "can get properties as a mutable detached map"() {
         given:
         extension.p1 = 1
         extension.p2 = 2
         extension.p3 = 3
 
         and:
-        def props = extension.properties.sort()
+        def props = extension.properties
 
         expect:
         props == [p1: 1, p2: 2, p3: 3]
diff --git a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/BuildProgressArea.java b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/BuildProgressArea.java
index 0f171a6ec84..dbb4a0b376f 100644
--- a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/BuildProgressArea.java
+++ b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/BuildProgressArea.java
@@ -21,6 +21,7 @@
 public interface BuildProgressArea {
     // TODO(ew): Consider whether this belongs in Console or here
     StyledLabel getProgressBar();
+    StyledLabel getCursorParkLine();
     List<StyledLabel> getBuildProgressLabels();
     void resizeBuildProgressTo(int numberOfLabels);
     void setVisible(boolean isVisible);
diff --git a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/MultiLineBuildProgressArea.java b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/MultiLineBuildProgressArea.java
index dcebb54ff7a..533552d3944 100644
--- a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/MultiLineBuildProgressArea.java
+++ b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/MultiLineBuildProgressArea.java
@@ -25,25 +25,23 @@ public class MultiLineBuildProgressArea implements BuildProgressArea {
     private final List<DefaultRedrawableLabel> entries = new ArrayList<DefaultRedrawableLabel>(2);
     private final DefaultRedrawableLabel progressBarLabel;
 
-    private final List<StyledLabel> buildProgressLabels = new ArrayList<StyledLabel>();
+    private final List<StyledLabel> buildProgressLabels = new ArrayList<>();
     private final DefaultRedrawableLabel parkingLabel;
     private final Cursor statusAreaPos = new Cursor();
     private boolean isVisible;
     private boolean isPreviouslyVisible;
 
     public MultiLineBuildProgressArea() {
-        int row = 0;
-
-        progressBarLabel = newLabel(row--);
+        progressBarLabel = newLabel(0);
         entries.add(progressBarLabel);
 
         // Parking space for the write cursor
-        parkingLabel = newLabel(row--);
+        parkingLabel = newLabel(-1);
         entries.add(parkingLabel);
     }
 
-    private DefaultRedrawableLabel newLabel(int row) {
-        return new DefaultRedrawableLabel(Cursor.at(row--, 0));
+    private static DefaultRedrawableLabel newLabel(int row) {
+        return new DefaultRedrawableLabel(Cursor.at(row, 0));
     }
 
     @Override
@@ -56,6 +54,11 @@ public StyledLabel getProgressBar() {
         return progressBarLabel;
     }
 
+    @Override
+    public StyledLabel getCursorParkLine() {
+        return parkingLabel;
+    }
+
     /**
      * The location of the top left of this progress area.
      */
diff --git a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/WorkInProgressRenderer.java b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/WorkInProgressRenderer.java
index 9972471d25d..9edd8723e08 100644
--- a/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/WorkInProgressRenderer.java
+++ b/platforms/core-runtime/logging/src/main/java/org/gradle/internal/logging/console/WorkInProgressRenderer.java
@@ -16,7 +16,6 @@
 
 package org.gradle.internal.logging.console;
 
-import com.google.common.base.Function;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Sets;
 import org.gradle.internal.logging.events.EndOutputEvent;
@@ -44,23 +43,23 @@ public class WorkInProgressRenderer implements OutputEventListener {
     private final DefaultWorkInProgressFormatter labelFormatter;
     private final ConsoleLayoutCalculator consoleLayoutCalculator;
 
-    private final List<OutputEvent> queue = new ArrayList<OutputEvent>();
+    private final List<OutputEvent> queue = new ArrayList<>();
 
     // Track all unused labels to display future progress operation
     private final Deque<StyledLabel> unusedProgressLabels;
 
     // Track currently associated label with its progress operation
-    private final Map<OperationIdentifier, AssociationLabel> operationIdToAssignedLabels = new HashMap<OperationIdentifier, AssociationLabel>();
+    private final Map<OperationIdentifier, AssociationLabel> operationIdToAssignedLabels = new HashMap<>();
 
     // Track any progress operation that either can't be display due to label shortage or child progress operation is already been displayed
-    private final Deque<ProgressOperation> unassignedProgressOperations = new ArrayDeque<ProgressOperation>();
+    private final Deque<ProgressOperation> unassignedProgressOperations = new ArrayDeque<>();
 
     public WorkInProgressRenderer(OutputEventListener listener, BuildProgressArea progressArea, DefaultWorkInProgressFormatter labelFormatter, ConsoleLayoutCalculator consoleLayoutCalculator) {
         this.listener = listener;
         this.progressArea = progressArea;
         this.labelFormatter = labelFormatter;
         this.consoleLayoutCalculator = consoleLayoutCalculator;
-        this.unusedProgressLabels = new ArrayDeque<StyledLabel>(progressArea.getBuildProgressLabels());
+        this.unusedProgressLabels = new ArrayDeque<>(progressArea.getBuildProgressLabels());
     }
 
     @Override
@@ -78,12 +77,7 @@ public void onOutput(OutputEvent event) {
 
     // Transform ProgressCompleteEvent into their corresponding progress OperationIdentifier.
     private Set<OperationIdentifier> toOperationIdSet(Iterable<ProgressCompleteEvent> events) {
-        return Sets.newHashSet(Iterables.transform(events, new Function<ProgressCompleteEvent, OperationIdentifier>() {
-            @Override
-            public OperationIdentifier apply(ProgressCompleteEvent event) {
-                return event.getProgressOperationId();
-            }
-        }));
+        return Sets.newHashSet(Iterables.transform(events, ProgressCompleteEvent::getProgressOperationId));
     }
 
     private void resizeTo(int newBuildProgressLabelCount) {
@@ -123,6 +117,7 @@ private void attach(ProgressOperation operation) {
         // Try to use a new label
         if (unusedProgressLabels.isEmpty()) {
             unassignedProgressOperations.add(operation);
+            reportLinesNotShown();
         } else {
             attach(operation, unusedProgressLabels.pop());
         }
@@ -145,6 +140,7 @@ private void detach(ProgressOperation operation) {
             attach(operation.getParent());
         } else if (!unassignedProgressOperations.isEmpty()) {
             attach(unassignedProgressOperations.pop());
+            reportLinesNotShown();
         }
     }
 
@@ -158,6 +154,22 @@ private void unshow(ProgressOperation operation) {
             unusedProgressLabels.push(association.label);
         }
         unassignedProgressOperations.remove(operation);
+        reportLinesNotShown();
+    }
+
+    private void reportLinesNotShown() {
+        int linesNotShown = unassignedProgressOperations.size();
+
+        String text;
+        if (linesNotShown == 0) {
+            text = "";
+        } else if (linesNotShown == 1) {
+            text = "  (1 line not showing)";
+        } else {
+            text = "  (" + linesNotShown + " lines not showing)";
+        }
+
+        progressArea.getCursorParkLine().setText(text);
     }
 
     // Any ProgressOperation in the parent chain has a message, the operation is considered renderable.
@@ -178,7 +190,7 @@ private void renderNow() {
 
         // Skip processing of any operations that both start and complete in the queue
         Set<OperationIdentifier> completeEventOperationIds = toOperationIdSet(Iterables.filter(queue, ProgressCompleteEvent.class));
-        Set<OperationIdentifier> operationIdsToSkip = new HashSet<OperationIdentifier>();
+        Set<OperationIdentifier> operationIdsToSkip = new HashSet<>();
 
         for (OutputEvent event : queue) {
             if (event instanceof ProgressStartEvent) {
diff --git a/platforms/core-runtime/logging/src/test/groovy/org/gradle/internal/logging/console/ConsoleStub.java b/platforms/core-runtime/logging/src/test/groovy/org/gradle/internal/logging/console/ConsoleStub.java
index c3220439366..912de1d96a0 100644
--- a/platforms/core-runtime/logging/src/test/groovy/org/gradle/internal/logging/console/ConsoleStub.java
+++ b/platforms/core-runtime/logging/src/test/groovy/org/gradle/internal/logging/console/ConsoleStub.java
@@ -22,12 +22,13 @@
 
 public class ConsoleStub implements Console {
     private final TestableBuildOutputTextArea buildOutputArea = new TestableBuildOutputTextArea();
-    private final TestableRedrawableLabel buildStatusLabel = new TestableRedrawableLabel("0");
+    private final TestableRedrawableLabel statusBar = new TestableRedrawableLabel("-1");
+    private final TestableRedrawableLabel progressBar = new TestableRedrawableLabel("0");
     private final TestableBuildProgressTextArea buildProgressArea = new TestableBuildProgressTextArea();
 
     @Override
     public StyledLabel getStatusBar() {
-        return buildStatusLabel;
+        return progressBar;
     }
 
     @Override
@@ -42,7 +43,8 @@ public TextArea getBuildOutputArea() {
 
     @Override
     public void flush() {
-        buildStatusLabel.redraw(null);
+        progressBar.redraw(null);
+        statusBar.redraw(null);
         buildProgressArea.redraw();
     }
 
@@ -74,12 +76,17 @@ public void redraw(AnsiContext ansi) {
     protected class TestableBuildProgressTextArea extends TestStyledTextOutput implements BuildProgressArea {
         boolean visible;
         int buildProgressLabelCount;
-        private final List<TestableRedrawableLabel> testableLabels = new ArrayList<TestableRedrawableLabel>();
-        private final List<StyledLabel> buildProgressLabels = new ArrayList<StyledLabel>();
+        private final List<TestableRedrawableLabel> testableLabels = new ArrayList<>();
+        private final List<StyledLabel> buildProgressLabels = new ArrayList<>();
 
         @Override
         public StyledLabel getProgressBar() {
-            return buildStatusLabel;
+            return progressBar;
+        }
+
+        @Override
+        public StyledLabel getCursorParkLine() {
+            return statusBar;
         }
 
         @Override
diff --git a/platforms/core-runtime/logging/src/test/groovy/org/gradle/internal/logging/console/WorkInProgressRendererTest.groovy b/platforms/core-runtime/logging/src/test/groovy/org/gradle/internal/logging/console/WorkInProgressRendererTest.groovy
index 3393deae1d4..843ec129142 100644
--- a/platforms/core-runtime/logging/src/test/groovy/org/gradle/internal/logging/console/WorkInProgressRendererTest.groovy
+++ b/platforms/core-runtime/logging/src/test/groovy/org/gradle/internal/logging/console/WorkInProgressRendererTest.groovy
@@ -28,11 +28,10 @@ class WorkInProgressRendererTest extends OutputSpecification {
     def metaData = Mock(ConsoleMetaData);
     def renderer = new WorkInProgressRenderer(listener, console.getBuildProgressArea(), new DefaultWorkInProgressFormatter(metaData), new ConsoleLayoutCalculator(metaData))
 
-    def setup() {
-        metaData.getRows() >> 2
-    }
-
     def "start and complete events in the same batch are ignored"() {
+        given:
+        metaData.getRows() >> 6
+
         when:
         renderer.onOutput(start(1, ":foo"))
         renderer.onOutput(start(2, ":bar"))
@@ -42,10 +41,13 @@ class WorkInProgressRendererTest extends OutputSpecification {
 
         then:
         progressArea.display == ["> :bar"]
+        cursorParkText == ""
     }
 
     def "events are forwarded to the listener even if are not rendered"() {
         given:
+        metaData.getRows() >> 6
+
         def startEvent = start(1, ":foo")
         def completeEvent = complete(1)
 
@@ -59,15 +61,22 @@ class WorkInProgressRendererTest extends OutputSpecification {
     }
 
     def "progress operation without message have no effect on progress area"() {
+        given:
+        metaData.getRows() >> 6
+
         when:
         renderer.onOutput(start(1))
         console.flush()
 
         then:
         progressArea.display == []
+        cursorParkText == ""
     }
 
     def "parent progress operation without message is ignored when renderable child completes"() {
+        given:
+        metaData.getRows() >> 2
+
         when:
         renderer.onOutput(start(1))
         renderer.onOutput(start(id: 2, parentId: 1, status: ":foo"))
@@ -89,6 +98,8 @@ class WorkInProgressRendererTest extends OutputSpecification {
 
     def "forward the event unmodified to the listener"() {
         given:
+        metaData.getRows() >> 6
+
         def event1 = event("event 1")
         def event2 = event("event 2")
 
@@ -102,7 +113,10 @@ class WorkInProgressRendererTest extends OutputSpecification {
         0 * _
     }
 
-    def "test completing children of offscreen parents"() {
+    def "completing children of offscreen parents"() {
+        given:
+        metaData.getRows() >> 2 // only a single line will be displayable
+
         // This test confirms that when a child task is completed for a
         // parent task that is currently offscreen, that we don't accumulate
         // additional copies of that pending parent task to show later
@@ -114,8 +128,9 @@ class WorkInProgressRendererTest extends OutputSpecification {
         console.flush()
 
         then:
-        // task 3 should not be shown because there should not be enough space for it
+        // task 2 should not be shown because there should not be enough space for it
         progressArea.display == ["> :one"]
+        cursorParkText == "  (1 line not showing)"
 
         and:
         // start a child for 2 while it's offscreen, and complete that child
@@ -133,6 +148,7 @@ class WorkInProgressRendererTest extends OutputSpecification {
         and:
         // note that task 2 is still not shown
         progressArea.display == ["> :one"]
+        cursorParkText == "  (1 line not showing)"
 
         then:
         // task 1 completes
@@ -143,6 +159,7 @@ class WorkInProgressRendererTest extends OutputSpecification {
         and:
         // task 2 should appear because there should be enough space for it now
         progressArea.display == ["> :two"]
+        cursorParkText == ""
 
         then:
         // task 2 completes
@@ -153,10 +170,79 @@ class WorkInProgressRendererTest extends OutputSpecification {
         then:
         // there should be no more copies of task 2 claiming to be running
         progressArea.display == ["> IDLE"]
+        cursorParkText == ""
+    }
+
+    def "multiple offscreen operations"() {
+        given:
+        metaData.getRows() >> 4 // only two active operations can be displayable
+
+        when:
+        renderer.onOutput(start(id: 1, status: ":one"))
+        renderer.onOutput(start(id: 2, status: ":two"))
+        renderer.onOutput(start(id: 3, status: ":three"))
+        renderer.onOutput(start(id: 4, status: ":four"))
+        renderer.onOutput(start(id: 5, status: ":five"))
+        renderer.onOutput(updateNow())
+        console.flush()
+
+        then:
+        progressArea.display == ["> :one", "> :two"]
+        cursorParkText == "  (3 lines not showing)"
+
+        and:
+        renderer.onOutput(complete(2))
+        renderer.onOutput(updateNow())
+        console.flush()
+
+        then:
+        progressArea.display == ["> :one", "> :three"]
+        cursorParkText == "  (2 lines not showing)"
+
+        and:
+        renderer.onOutput(complete(1))
+        renderer.onOutput(updateNow())
+        console.flush()
+
+        then:
+        progressArea.display == ["> :four", "> :three"]
+        cursorParkText == "  (1 line not showing)"
+
+        and:
+        renderer.onOutput(complete(3))
+        renderer.onOutput(updateNow())
+        console.flush()
+
+        then:
+        progressArea.display == ["> :four", "> :five"]
+        cursorParkText == ""
+
+        and:
+        renderer.onOutput(complete(4))
+        renderer.onOutput(updateNow())
+        console.flush()
+
+        then:
+        progressArea.display == ["> IDLE", "> :five"]
+        cursorParkText == ""
+
+        and:
+        renderer.onOutput(complete(5))
+        renderer.onOutput(updateNow())
+        console.flush()
+
+        then:
+        progressArea.display == ["> IDLE", "> IDLE"]
+        cursorParkText == ""
     }
 
 
     private ConsoleStub.TestableBuildProgressTextArea getProgressArea() {
         console.buildProgressArea as ConsoleStub.TestableBuildProgressTextArea
     }
+
+
+    private String getCursorParkText() {
+        (console.buildProgressArea.cursorParkLine as ConsoleStub.TestableRedrawableLabel).getDisplay()
+    }
 }
diff --git a/platforms/documentation/docs/src/docs/release/notes.md b/platforms/documentation/docs/src/docs/release/notes.md
index ca7b077a4d6..97bc8458f22 100644
--- a/platforms/documentation/docs/src/docs/release/notes.md
+++ b/platforms/documentation/docs/src/docs/release/notes.md
@@ -80,6 +80,17 @@ vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv -->
 #### Plain console with colors
 
 This release adds a new value for the `--console` command line option called `colored`, which enables color output for the console while omitting rich features such as progress bars.
+See ![this recording](release-notes-assets/colored-console.gif) for a demo.
+
+#### Off-screen lines reported in rich console
+
+This release adds a status line to the `rich` console that reports the number of in-progress events not currently visible on screen.
+
+\```console
+> (2 lines not showing)
+\```
+This occurs when there are more ongoing events than the console has lines available to display them.
+See ![this recording](release-notes-assets/off-screen-lines.gif) for a demo.
 
 
 ### Build authoring improvements
diff --git a/platforms/documentation/docs/src/docs/release/release-notes-assets/colored-console.gif b/platforms/documentation/docs/src/docs/release/release-notes-assets/colored-console.gif
new file mode 100644
index 00000000000..26ceb70eebd
Binary files /dev/null and b/platforms/documentation/docs/src/docs/release/release-notes-assets/colored-console.gif differ
diff --git a/platforms/documentation/docs/src/docs/release/release-notes-assets/off-screen-lines.gif b/platforms/documentation/docs/src/docs/release/release-notes-assets/off-screen-lines.gif
new file mode 100644
index 00000000000..c63e80fa9ac
Binary files /dev/null and b/platforms/documentation/docs/src/docs/release/release-notes-assets/off-screen-lines.gif differ
diff --git a/platforms/documentation/docs/src/docs/userguide/reference/core-plugins/build_dashboard_plugin.adoc b/platforms/documentation/docs/src/docs/userguide/reference/core-plugins/build_dashboard_plugin.adoc
index b3c09a4c8f0..209b3fad152 100644
--- a/platforms/documentation/docs/src/docs/userguide/reference/core-plugins/build_dashboard_plugin.adoc
+++ b/platforms/documentation/docs/src/docs/userguide/reference/core-plugins/build_dashboard_plugin.adoc
@@ -15,6 +15,9 @@
 [[build_dashboard_plugin]]
 = The Build Dashboard Plugin
 
+WARNING: The Build Dashboard Plugin is not fully compatible with the <<configuration_cache_status.adoc#config_cache:plugins:core,Configuration Cache>>.
+When applied, the Configuration Cache is automatically disabled.
+
 The Build Dashboard plugin can be used to generate a single HTML dashboard that provides a single point of access to all of the reports generated by a build.
 
 [[sec:build_dashboard_usage]]
diff --git a/platforms/jvm/java-platform/src/integTest/groovy/org/gradle/internal/component/model/JavaEcosystemAttributeMatcherTest.groovy b/platforms/jvm/java-platform/src/integTest/groovy/org/gradle/internal/component/model/JavaEcosystemAttributeMatcherTest.groovy
index f8534fe88ab..53b28e9daa6 100644
--- a/platforms/jvm/java-platform/src/integTest/groovy/org/gradle/internal/component/model/JavaEcosystemAttributeMatcherTest.groovy
+++ b/platforms/jvm/java-platform/src/integTest/groovy/org/gradle/internal/component/model/JavaEcosystemAttributeMatcherTest.groovy
@@ -21,11 +21,12 @@ import org.gradle.api.attributes.LibraryElements
 import org.gradle.api.attributes.Usage
 import org.gradle.api.attributes.java.TargetJvmVersion
 import org.gradle.api.internal.artifacts.JavaEcosystemSupport
-import org.gradle.api.internal.attributes.AttributeContainerInternal
 import org.gradle.api.internal.attributes.AttributeDescriberRegistry
 import org.gradle.api.internal.attributes.ImmutableAttributes
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema
 import org.gradle.api.internal.attributes.matching.AttributeMatcher
+import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate
+import org.gradle.api.internal.attributes.matching.ImmutableAttributesBackedMatchingCandidate
 import org.gradle.util.AttributeTestUtil
 import org.gradle.util.TestUtil
 import spock.lang.Specification
@@ -323,10 +324,10 @@ class JavaEcosystemAttributeMatcherTest extends Specification {
      * @throws AssertionError If the first round of attribute matching failed to match a single configuration
      *      or the second round failed to match a single variant.
      */
-    def matchConfigurations(List<List<AttributeContainerInternal>> candidates, ImmutableAttributes requested) {
+    def matchConfigurations(List<List<ImmutableAttributes>> candidates, ImmutableAttributes requested) {
         // The first element in each configuration array is the implicit variant.
         def implicitVariants = candidates.collect { it.first() }
-        def configurationMatches = matcher.matchMultipleCandidates(implicitVariants, requested)
+        def configurationMatches = match(implicitVariants, requested)
 
         // This test is checking only for successful (single) matches. If we matched multiple configurations
         // in the first round, something is wrong here. Fail before attempting the second round of variant matching.
@@ -334,7 +335,7 @@ class JavaEcosystemAttributeMatcherTest extends Specification {
 
         // Get all the variants for the configuration which was selected and apply variant matching on them.
         def configurationVariants = candidates.get(implicitVariants.indexOf(configurationMatches.get(0)))
-        def variantMatches = matcher.matchMultipleCandidates(configurationVariants, requested)
+        def variantMatches = match(configurationVariants, requested)
 
         // Once again, the purpose of this test is for successful results. Something is wrong if we have
         // multiple matched variants.
@@ -342,6 +343,11 @@ class JavaEcosystemAttributeMatcherTest extends Specification {
         return variantMatches[0]
     }
 
+    private List<ImmutableAttributes> match(List<ImmutableAttributes> candidateAttributeSets, ImmutableAttributes requested) {
+        List<AttributeMatchingCandidate> candidates = candidateAttributeSets.collect { new ImmutableAttributesBackedMatchingCandidate(it) }
+        return matcher.matchMultipleCandidates(candidates, requested).collect { it.attributes }
+    }
+
     private static ImmutableAttributes attributes(String usage, String libraryElements, Integer targetJvm) {
         Map<Attribute<Object>, Object> attrs = [
             (Usage.USAGE_ATTRIBUTE): AttributeTestUtil.named(Usage, usage),
diff --git a/platforms/jvm/language-java/src/integTest/groovy/org/gradle/api/tasks/compile/JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest.groovy b/platforms/jvm/language-java/src/integTest/groovy/org/gradle/api/tasks/compile/JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest.groovy
index 0b9c64cf96d..c18b2feca05 100644
--- a/platforms/jvm/language-java/src/integTest/groovy/org/gradle/api/tasks/compile/JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest.groovy
+++ b/platforms/jvm/language-java/src/integTest/groovy/org/gradle/api/tasks/compile/JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest.groovy
@@ -16,11 +16,23 @@
 
 package org.gradle.api.tasks.compile
 
+import org.apache.commons.io.FileUtils
 import org.gradle.integtests.fixtures.AbstractIntegrationSpec
+import org.gradle.integtests.fixtures.BuildCacheOperationFixtures
+import org.gradle.integtests.fixtures.BuildOperationsFixture
 import org.gradle.integtests.fixtures.DirectoryBuildCacheFixture
+import org.gradle.test.fixtures.dsl.GradleDsl
+import org.gradle.test.fixtures.maven.MavenFileRepository
+import org.gradle.test.fixtures.server.http.HttpServer
+import org.gradle.test.fixtures.server.http.MavenHttpRepository
+import org.junit.Rule
+import spock.lang.Issue
 
 class JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest extends AbstractIntegrationSpec implements DirectoryBuildCacheFixture {
 
+    @Rule
+    HttpServer server
+
     def "classes from cache are used when dependent class is changed in ABI compatible way"() {
         given:
         project_a_depends_on_project_b()
@@ -62,6 +74,81 @@ class JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest extends AbstractI
         executedAndNotSkipped ':b:jar', ':a:compileJava'
     }
 
+    @Issue("https://github.com/gradle/gradle/issues/32464")
+    def "kotlin library on build script classpath and Java classpath doesn't affect Java compilation build cache key"() {
+        given:
+        // We need to work with remote Kotlin libraries with inline functions to reproduce the cache issue
+        def repo = publishKotlinLibraryWithInlineFunctionToRemote()
+        def kotlinLibraryWithInlineFunction = "com.example:kotlin-library:1.0.0"
+
+        file("a/build.gradle") << """
+            plugins {
+                id("java-library")
+            }
+            repositories {
+                maven { url = uri("${repo.uri}") }
+            }
+            dependencies {
+                implementation("$kotlinLibraryWithInlineFunction")
+            }
+        """
+        file("a/settings.gradle") << """
+            rootProject.name = "a"
+        """
+        file('a/src/main/java/A.java') << '''
+            public class A {
+                public void foo() {
+                }
+            }
+        '''
+        file("a/gradle/init.gradle.kts") << """
+            initscript {
+                repositories {
+                    maven { url = uri("${repo.uri}") }
+                }
+                dependencies {
+                    classpath("$kotlinLibraryWithInlineFunction")
+                }
+            }
+            // We need to have some code in body of Kotlin init script
+            // to ensure that Kotlin buildscript classpath is snapshotted
+            println("Script body")
+        """
+        def aRelocated = file("a-relocated")
+        FileUtils.copyDirectory(file("a"), aRelocated)
+
+        when:
+        def firstOperations = new BuildCacheOperationFixtures(new BuildOperationsFixture(executer, testDirectoryProvider, "first-operations"))
+        result = executer
+            .withGradleUserHomeDir(testDirectoryProvider.getTestDirectory().file("first-user-home"))
+            .inDirectory(file("a"))
+            .withArgument("--init-script")
+            .withArgument("gradle/init.gradle.kts")
+            .withBuildCacheEnabled()
+            .withTasks("compileJava")
+            .run()
+
+        then:
+        executedAndNotSkipped ':compileJava'
+
+        when:
+        def secondOperations = new BuildCacheOperationFixtures(new BuildOperationsFixture(executer, testDirectoryProvider, "second-operations"))
+        result = executer
+            .withGradleUserHomeDir(testDirectoryProvider.getTestDirectory().file("second-user-home"))
+            .inDirectory(aRelocated)
+            .withBuildCacheEnabled()
+            .withTasks("compileJava")
+            .run()
+
+        then:
+        executedAndNotSkipped ':compileJava'
+
+        and:
+        def firstCacheKey = firstOperations.getCacheKeyForTask(":compileJava")
+        def secondCacheKey = secondOperations.getCacheKeyForTask(":compileJava")
+        firstCacheKey == secondCacheKey
+    }
+
     void make_abi_compatible_change_on_b() {
         file('b/src/main/java/B.java').text = '''
             public class B {
@@ -108,4 +195,46 @@ class JavaCompileAvoidanceWithBuildCacheServiceIntegrationTest extends AbstractI
             }
         '''
     }
+
+
+    def publishKotlinLibraryWithInlineFunctionToRemote() {
+        file("kotlin-library/build.gradle.kts") << """
+            plugins {
+                `kotlin-dsl`
+                `maven-publish`
+            }
+            group = "com.example"
+            version = "1.0.0"
+
+            ${mavenCentralRepository(GradleDsl.KOTLIN)}
+
+            publishing {
+                repositories {
+                    maven {
+                        url = uri(layout.buildDirectory.dir("repo"))
+                    }
+                }
+            }
+        """
+        file("kotlin-library/settings.gradle") << """
+            rootProject.name = "kotlin-library"
+        """
+        file("kotlin-library/src/main/kotlin/MyClass.kt") << """
+            class MyClass {
+                private val availableCpuPermits: Int inline get() = availableCpuPermits(8)
+                public inline fun availableCpuPermits(state: Long): Int = state.toInt()
+            }
+        """
+
+        def repo = new MavenHttpRepository(server, "/repo", new MavenFileRepository(file("./kotlin-library/build/repo")))
+        repo.module("com.example", "kotlin-library", "1.0.0").allowAll()
+        server.start()
+
+        executer
+            .inDirectory(file("kotlin-library"))
+            .withTasks("publish")
+            .run()
+
+        return repo
+    }
 }
diff --git a/platforms/jvm/normalization-java/src/main/java/org/gradle/api/internal/changedetection/state/ZipHasher.java b/platforms/jvm/normalization-java/src/main/java/org/gradle/api/internal/changedetection/state/ZipHasher.java
index 6810a783826..40ed4d4ab38 100644
--- a/platforms/jvm/normalization-java/src/main/java/org/gradle/api/internal/changedetection/state/ZipHasher.java
+++ b/platforms/jvm/normalization-java/src/main/java/org/gradle/api/internal/changedetection/state/ZipHasher.java
@@ -57,21 +57,11 @@ public static boolean isZipFile(final String name) {
     }
 
     private final ResourceHasher resourceHasher;
-    private final ZipHasher fallbackZipHasher;
     private final HashingExceptionReporter hashingExceptionReporter;
 
     public ZipHasher(ResourceHasher resourceHasher) {
-        this(
-            resourceHasher,
-            null,
-            (s, e) -> LOGGER.debug("Malformed archive '{}'. Falling back to full content hash instead of entry hashing.", s.getName(), e)
-        );
-    }
-
-    public ZipHasher(ResourceHasher resourceHasher, @Nullable ZipHasher fallbackZipHasher, HashingExceptionReporter hashingExceptionReporter) {
         this.resourceHasher = resourceHasher;
-        this.fallbackZipHasher = fallbackZipHasher;
-        this.hashingExceptionReporter = hashingExceptionReporter;
+        this.hashingExceptionReporter = (s, e) -> LOGGER.debug("Malformed archive '{}'. Falling back to full content hash instead of entry hashing.", s.getName(), e);
     }
 
     @Nullable
@@ -98,9 +88,6 @@ private HashCode hashZipContents(RegularFileSnapshot zipFileSnapshot) {
             return hasher.hash();
         } catch (Exception e) {
             hashingExceptionReporter.report(zipFileSnapshot, e);
-            if (fallbackZipHasher != null) {
-                return fallbackZipHasher.hashZipContents(zipFileSnapshot);
-            }
             return zipFileSnapshot.getHash();
         }
     }
diff --git a/platforms/jvm/normalization-java/src/main/java/org/gradle/internal/fingerprint/classpath/impl/ClasspathFingerprintingStrategy.java b/platforms/jvm/normalization-java/src/main/java/org/gradle/internal/fingerprint/classpath/impl/ClasspathFingerprintingStrategy.java
index 74a56948989..370e86bdcd7 100644
--- a/platforms/jvm/normalization-java/src/main/java/org/gradle/internal/fingerprint/classpath/impl/ClasspathFingerprintingStrategy.java
+++ b/platforms/jvm/normalization-java/src/main/java/org/gradle/internal/fingerprint/classpath/impl/ClasspathFingerprintingStrategy.java
@@ -119,18 +119,6 @@ public static ClasspathFingerprintingStrategy compileClasspath(ResourceHasher cl
         return new ClasspathFingerprintingStrategy(COMPILE_CLASSPATH_IDENTIFIER, IGNORE, classpathResourceHasher, zipHasher, cacheService, stringInterner);
     }
 
-    public static ClasspathFingerprintingStrategy compileClasspathFallbackToRuntimeClasspath(
-        ResourceHasher classpathResourceHasher,
-        ResourceHasher runtimeClasspathResourceHasher,
-        ResourceSnapshotterCacheService cacheService,
-        Interner<String> stringInterner,
-        ZipHasher.HashingExceptionReporter hashingExceptionReporter
-    ) {
-        ZipHasher fallbackZipHasher = new ZipHasher(runtimeClasspathResourceHasher);
-        ZipHasher zipHasher = new ZipHasher(classpathResourceHasher, fallbackZipHasher, hashingExceptionReporter);
-        return new ClasspathFingerprintingStrategy(COMPILE_CLASSPATH_IDENTIFIER, IGNORE, classpathResourceHasher, zipHasher, cacheService, stringInterner);
-    }
-
     public static ResourceHasher runtimeClasspathResourceHasher(
         RuntimeClasspathResourceHasher runtimeClasspathResourceHasher,
         LineEndingSensitivity lineEndingSensitivity,
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/artifact/ResolvedVariant.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/artifact/ResolvedVariant.java
index 57bd1d95542..055841e0ec9 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/artifact/ResolvedVariant.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/ivyservice/resolveengine/artifact/ResolvedVariant.java
@@ -17,8 +17,7 @@
 package org.gradle.api.internal.artifacts.ivyservice.resolveengine.artifact;
 
 import org.gradle.api.Action;
-import org.gradle.api.attributes.HasAttributes;
-import org.gradle.api.internal.attributes.ImmutableAttributes;
+import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate;
 import org.gradle.internal.DisplayName;
 import org.gradle.internal.component.external.model.ImmutableCapabilities;
 import org.gradle.internal.component.model.VariantResolveMetadata;
@@ -28,7 +27,8 @@
  * A set of artifacts that may be selected from a variant. This would be better named
  * {@code ResolvedVariantArtifactCollection}.
  */
-public interface ResolvedVariant extends HasAttributes {
+public interface ResolvedVariant extends AttributeMatchingCandidate {
+
     DisplayName asDescribable();
 
     /**
@@ -37,10 +37,8 @@ public interface ResolvedVariant extends HasAttributes {
      */
     VariantResolveMetadata.@Nullable Identifier getIdentifier();
 
-    @Override
-    ImmutableAttributes getAttributes();
-
     ResolvedArtifactSet getArtifacts();
 
     ImmutableCapabilities getCapabilities();
+
 }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/ConsumerProvidedVariantFinder.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/ConsumerProvidedVariantFinder.java
index a1d4a1c7416..204aca0bba0 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/ConsumerProvidedVariantFinder.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/ConsumerProvidedVariantFinder.java
@@ -236,7 +236,7 @@ private List<TransformedVariant> query(
         ) {
             List<ImmutableAttributes> variantAttributes = new ArrayList<>(sources.size());
             for (ResolvedVariant variant : sources) {
-                variantAttributes.add(variant.getAttributes().asImmutable());
+                variantAttributes.add(variant.getAttributes());
             }
             List<CachedVariant> cached = cache.computeIfAbsent(new CacheKey(variantAttributes, requested), key -> action.apply(key.variantAttributes, key.requested));
             List<TransformedVariant> output = new ArrayList<>(cached.size());
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/TransformedVariant.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/TransformedVariant.java
index 7584e290b73..69655d7a24e 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/TransformedVariant.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/artifacts/transform/TransformedVariant.java
@@ -16,15 +16,16 @@
 
 package org.gradle.api.internal.artifacts.transform;
 
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.artifacts.ivyservice.resolveengine.artifact.ResolvedVariant;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
+import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate;
 
 /**
  * Represents a variant which is produced as the result of applying an artifact transform chain
  * to a root producer variant.
  */
-public class TransformedVariant implements HasAttributes {
+public class TransformedVariant implements AttributeMatchingCandidate {
+
     private final ResolvedVariant root;
     private final VariantDefinition chain;
 
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatcher.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatcher.java
index 8832698d773..a0e24caace7 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatcher.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatcher.java
@@ -17,11 +17,9 @@
 package org.gradle.api.internal.attributes.matching;
 
 import org.gradle.api.attributes.Attribute;
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.AttributeValue;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 
-import java.util.Collection;
 import java.util.List;
 
 public interface AttributeMatcher {
@@ -50,8 +48,8 @@ public interface AttributeMatcher {
      * criteria attributes. Then, if there is more than one match, performs disambiguation to attempt
      * to reduce the set of matches to a more preferred subset.
      */
-    <T extends HasAttributes> List<T> matchMultipleCandidates(
-        Collection<? extends T> candidates,
+    <T extends AttributeMatchingCandidate> List<T> matchMultipleCandidates(
+        List<? extends T> candidates,
         ImmutableAttributes requested
     );
 
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatchingCandidate.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatchingCandidate.java
new file mode 100644
index 00000000000..bb266c43ab9
--- /dev/null
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/AttributeMatchingCandidate.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2024 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.gradle.api.internal.attributes.matching;
+
+import org.gradle.api.internal.attributes.ImmutableAttributes;
+
+import java.util.List;
+
+/**
+ * Something that can participate in multiple-candidate attribute matching. During multiple-candidate
+ * matching, candidates are compared based on their attributes and the best match is selected. Compatibility
+ * and disambiguation rules from attribute schemas are used to determine the best match.
+ *
+ * @see AttributeMatcher#matchMultipleCandidates(List, ImmutableAttributes)
+ */
+public interface AttributeMatchingCandidate {
+
+    /**
+     * Get the attributes that describe this candidate.
+     */
+    ImmutableAttributes getAttributes();
+
+}
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcher.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcher.java
index b3f78510264..3ba4dea1aad 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcher.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcher.java
@@ -19,11 +19,8 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.primitives.Ints;
 import org.gradle.api.attributes.Attribute;
-import org.gradle.api.attributes.HasAttributes;
-import org.gradle.api.internal.attributes.AttributeContainerInternal;
 import org.gradle.api.internal.attributes.AttributeValue;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
-import org.gradle.internal.Cast;
 import org.gradle.internal.component.model.AttributeMatchingExplanationBuilder;
 import org.gradle.internal.model.InMemoryCacheFactory;
 import org.gradle.internal.model.InMemoryLoadingCache;
@@ -31,7 +28,7 @@
 import org.slf4j.LoggerFactory;
 
 import java.util.ArrayList;
-import java.util.Collection;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
@@ -162,7 +159,10 @@ public List<AttributeMatcher.MatchingDescription<?>> describeMatching(ImmutableA
     }
 
     @Override
-    public <T extends HasAttributes> List<T> matchMultipleCandidates(Collection<? extends T> candidates, ImmutableAttributes requested) {
+    public <T extends AttributeMatchingCandidate> List<T> matchMultipleCandidates(
+        List<? extends T> candidates,
+        ImmutableAttributes requested
+    ) {
         AttributeMatchingExplanationBuilder explanationBuilder = AttributeMatchingExplanationBuilder.logging();
 
         if (candidates.isEmpty()) {
@@ -172,47 +172,45 @@ public <T extends HasAttributes> List<T> matchMultipleCandidates(Collection<? ex
 
         if (candidates.size() == 1) {
             T candidate = candidates.iterator().next();
-            ImmutableAttributes candidateAttrs = ((AttributeContainerInternal) candidate.getAttributes()).asImmutable();
-            if (isMatchingCandidate(candidateAttrs, requested)) {
-                explanationBuilder.singleMatch(candidate, candidates, requested);
+            ImmutableAttributes candidateAttributes = candidate.getAttributes();
+            if (isMatchingCandidate(candidateAttributes, requested)) {
+                explanationBuilder.singleMatch(candidateAttributes, ImmutableList.of(candidateAttributes), requested);
                 return Collections.singletonList(candidate);
             }
-            explanationBuilder.candidateDoesNotMatchAttributes(candidate, requested);
+            explanationBuilder.candidateDoesNotMatchAttributes(candidateAttributes, requested);
             return ImmutableList.of();
         }
 
-        List<T> candidateList = (candidates instanceof List) ? Cast.uncheckedCast(candidates) : ImmutableList.copyOf(candidates);
-
         // Often times, collections of candidates will themselves differ even though their attributes are the same.
         // Disambiguating two different candidate lists which map to the same attribute lists in reality performs
         // the same work, so instead we cache disambiguation results based on the attributes being disambiguated.
         // The result of this is a list of indices into the original candidate list from which the
         // attributes-to-disambiguate are derived. When retrieving a result from the cache, we use the resulting
         // indices to index back into the original candidates list.
-        CachedQuery query = CachedQuery.from(requested, candidateList);
+        CachedQuery query = CachedQuery.from(requested, candidates);
         int[] indices = cachedQueries.get(query);
-        return CachedQuery.getMatchesFromCandidateIndices(indices, candidateList);
+        return CachedQuery.getMatchesFromCandidateIndices(indices, candidates);
     }
 
     private int[] doMatchMultipleCandidates(CachedQuery key) {
         AttributeMatchingExplanationBuilder explanationBuilder = AttributeMatchingExplanationBuilder.logging();
-        int[] matches = new MultipleCandidateMatcher<>(schema, key.candidates, key.requestedAttributes, explanationBuilder).getMatches();
+        int[] matches = new MultipleCandidateMatcher(schema, key.candidates, key.requestedAttributes, explanationBuilder).getMatches();
         LOGGER.debug("Selected matches {} from candidates {} for {}", Ints.asList(matches), key.candidates, key.requestedAttributes);
         return matches;
     }
 
     private static class CachedQuery {
         private final ImmutableAttributes requestedAttributes;
-        private final List<ImmutableAttributes> candidates;
+        private final ImmutableAttributes[] candidates;
         private final int hashCode;
 
-        private CachedQuery(ImmutableAttributes requestedAttributes, List<ImmutableAttributes> candidates) {
+        private CachedQuery(ImmutableAttributes requestedAttributes, ImmutableAttributes[] candidates) {
             this.requestedAttributes = requestedAttributes;
             this.candidates = candidates;
             this.hashCode = computeHashCode(requestedAttributes, candidates);
         }
 
-        private static int computeHashCode(ImmutableAttributes requestedAttributes, List<ImmutableAttributes> candidates) {
+        private static int computeHashCode(ImmutableAttributes requestedAttributes, ImmutableAttributes[] candidates) {
             int hash = requestedAttributes.hashCode();
             for (ImmutableAttributes candidate : candidates) {
                 hash = 31 * hash + candidate.hashCode();
@@ -220,16 +218,17 @@ private static int computeHashCode(ImmutableAttributes requestedAttributes, List
             return hash;
         }
 
-        public static <T extends HasAttributes> CachedQuery from(ImmutableAttributes requestedAttributes, List<T> candidates) {
-            List<ImmutableAttributes> attributes = new ArrayList<>(candidates.size());
-            for (T candidate : candidates) {
-                attributes.add(((AttributeContainerInternal) candidate.getAttributes()).asImmutable());
+        public static <T extends AttributeMatchingCandidate> CachedQuery from(ImmutableAttributes requestedAttributes, List<T> candidates) {
+            int size = candidates.size();
+            ImmutableAttributes[] attributes = new ImmutableAttributes[size];
+            for (int i = 0; i < size; i++) {
+                attributes[i] = candidates.get(i).getAttributes();
             }
             return new CachedQuery(requestedAttributes, attributes);
         }
 
         @SuppressWarnings("MixedMutabilityReturnType")
-        private static <T extends HasAttributes> List<T> getMatchesFromCandidateIndices(int[] indices, List<? extends T> candidates) {
+        private static <T extends AttributeMatchingCandidate> List<T> getMatchesFromCandidateIndices(int[] indices, List<? extends T> candidates) {
             if (indices.length == 0) {
                 return Collections.emptyList();
             }
@@ -253,7 +252,7 @@ public boolean equals(Object o) {
             CachedQuery that = (CachedQuery) o;
             return hashCode == that.hashCode &&
                 requestedAttributes.equals(that.requestedAttributes) &&
-                candidates.equals(that.candidates);
+                Arrays.equals(candidates, that.candidates);
         }
 
         @Override
@@ -265,7 +264,7 @@ public int hashCode() {
         public String toString() {
             return "CachedQuery{" +
                 "requestedAttributes=" + requestedAttributes +
-                ", candidates=" + candidates +
+                ", candidates=" + Arrays.toString(candidates) +
                 '}';
         }
     }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/ImmutableAttributesBackedMatchingCandidate.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/ImmutableAttributesBackedMatchingCandidate.java
new file mode 100644
index 00000000000..7048235e96b
--- /dev/null
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/ImmutableAttributesBackedMatchingCandidate.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2024 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.gradle.api.internal.attributes.matching;
+
+import org.gradle.api.internal.attributes.ImmutableAttributes;
+
+/**
+ * Wraps a standalone {@link ImmutableAttributes} so that it can participate in
+ * attribute matching.
+ */
+public class ImmutableAttributesBackedMatchingCandidate implements AttributeMatchingCandidate {
+
+    private final ImmutableAttributes attributes;
+
+    public ImmutableAttributesBackedMatchingCandidate(ImmutableAttributes attributes) {
+        this.attributes = attributes;
+    }
+
+    @Override
+    public ImmutableAttributes getAttributes() {
+        return attributes;
+    }
+
+    @Override
+    public final boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof ImmutableAttributesBackedMatchingCandidate)) {
+            return false;
+        }
+
+        ImmutableAttributesBackedMatchingCandidate that = (ImmutableAttributesBackedMatchingCandidate) o;
+        return attributes.equals(that.attributes);
+    }
+
+    @Override
+    public int hashCode() {
+        return attributes.hashCode();
+    }
+
+}
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/MultipleCandidateMatcher.java b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/MultipleCandidateMatcher.java
index 6b47a96496f..aa7148e6e8e 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/MultipleCandidateMatcher.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/api/internal/attributes/matching/MultipleCandidateMatcher.java
@@ -18,8 +18,6 @@
 
 import com.google.common.collect.Sets;
 import org.gradle.api.attributes.Attribute;
-import org.gradle.api.attributes.HasAttributes;
-import org.gradle.api.internal.attributes.AttributeContainerInternal;
 import org.gradle.api.internal.attributes.AttributeValue;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.internal.Cast;
@@ -68,11 +66,10 @@
  *
  * </p>
  */
-class MultipleCandidateMatcher<T extends HasAttributes> {
+class MultipleCandidateMatcher {
     private final AttributeSelectionSchema schema;
     private final ImmutableAttributes requested;
-    private final List<? extends T> candidates;
-    private final ImmutableAttributes[] candidateAttributeSets;
+    private final ImmutableAttributes[] candidates;
     private final AttributeMatchingExplanationBuilder explanationBuilder;
 
     private final List<Attribute<?>> requestedAttributes;
@@ -96,7 +93,7 @@
 
     private BitSet remaining;
 
-    <E extends T> MultipleCandidateMatcher(AttributeSelectionSchema schema, List<E> candidates, ImmutableAttributes requested, AttributeMatchingExplanationBuilder explanationBuilder) {
+    MultipleCandidateMatcher(AttributeSelectionSchema schema, ImmutableAttributes[] candidates, ImmutableAttributes requested, AttributeMatchingExplanationBuilder explanationBuilder) {
         this.schema = schema;
         this.candidates = candidates;
         this.requested = requested;
@@ -105,11 +102,10 @@ <E extends T> MultipleCandidateMatcher(AttributeSelectionSchema schema, List<E>
         this.requestedAttributes = requested.keySet().asList();
         this.requestedAttributeValues = getRequestedValues(requestedAttributes, requested);
 
-        this.candidateAttributeSets = getCandidateAttributeSets(this.candidates);
-        this.candidateValues = new Object[candidates.size() * requestedAttributes.size()];
+        this.candidateValues = new Object[candidates.length * requestedAttributes.size()];
 
-        this.compatible = new BitSet(candidates.size());
-        compatible.set(0, candidates.size());
+        this.compatible = new BitSet(candidates.length);
+        compatible.set(0, candidates.length);
     }
 
     public int[] getMatches() {
@@ -118,7 +114,7 @@ public int[] getMatches() {
             return getCandidates(compatible);
         }
         if (longestMatchIsSuperSetOfAllOthers()) {
-            T o = candidates.get(candidateWithLongestMatch);
+            ImmutableAttributes o = candidates[candidateWithLongestMatch];
             explanationBuilder.candidateIsSuperSetOfAllOthers(o);
             return new int[] {candidateWithLongestMatch};
         }
@@ -135,20 +131,12 @@ private static Object[] getRequestedValues(List<Attribute<?>> requestedAttribute
         return requestedAttributeValues;
     }
 
-    private static ImmutableAttributes[] getCandidateAttributeSets(List<? extends HasAttributes> candidates) {
-        ImmutableAttributes[] candidateAttributeSets = new ImmutableAttributes[candidates.size()];
-        for (int i = 0; i < candidates.size(); i++) {
-            candidateAttributeSets[i] = ((AttributeContainerInternal) candidates.get(i).getAttributes()).asImmutable();
-        }
-        return candidateAttributeSets;
-    }
-
     private void findCompatibleCandidates() {
         if (requested.isEmpty()) {
             // Avoid iterating on candidates if there's no requested attribute
             return;
         }
-        for (int c = 0; c < candidates.size(); c++) {
+        for (int c = 0; c < candidates.length; c++) {
             matchCandidate(c);
         }
     }
@@ -176,11 +164,11 @@ private void matchCandidate(int c) {
     private MatchResult recordAndMatchCandidateValue(int c, int a) {
         Object requestedValue = requestedAttributeValues[a];
         Attribute<?> attribute = requestedAttributes.get(a);
-        AttributeValue<?> candidateValue = candidateAttributeSets[c].findEntry(attribute.getName());
+        AttributeValue<?> candidateValue = candidates[c].findEntry(attribute.getName());
 
         if (!candidateValue.isPresent()) {
             setCandidateValue(c, a, null);
-            explanationBuilder.candidateAttributeMissing(candidates.get(c), attribute, requestedValue);
+            explanationBuilder.candidateAttributeMissing(candidates[c], attribute, requestedValue);
             return MatchResult.MISSING;
         }
 
@@ -190,7 +178,7 @@ private MatchResult recordAndMatchCandidateValue(int c, int a) {
         if (unsafeMatchValue(attribute, requestedValue, coercedValue)) {
             return MatchResult.MATCH;
         }
-        explanationBuilder.candidateAttributeDoesNotMatch(candidates.get(c), attribute, requestedValue, candidateValue);
+        explanationBuilder.candidateAttributeDoesNotMatch(candidates[c], attribute, requestedValue, candidateValue);
         return MatchResult.NO_MATCH;
     }
 
@@ -229,7 +217,7 @@ private boolean longestMatchIsSuperSetOfAllOthers() {
     }
 
     private int[] disambiguateCompatibleCandidates() {
-        remaining = new BitSet(candidates.size());
+        remaining = new BitSet(candidates.length);
         remaining.or(compatible);
 
         disambiguateWithRequestedAttributeValues();
@@ -239,7 +227,7 @@ private int[] disambiguateCompatibleCandidates() {
             return getCandidates(remaining);
         }
 
-        Attribute<?>[] extraAttributes = schema.collectExtraAttributes(candidateAttributeSets, requested);
+        Attribute<?>[] extraAttributes = schema.collectExtraAttributes(candidates, requested);
         if (remaining.cardinality() > 1) {
             disambiguateWithExtraAttributes(extraAttributes);
         }
@@ -257,10 +245,10 @@ private void disambiguateWithRequestedAttributeKeys(Attribute<?>[] extraAttribut
             // We consider only extra attributes which are NOT on every candidate:
             // Because they are EXTRA attributes, we consider that a
             // candidate which does NOT provide this value is a better match
-            int candidateCount = candidateAttributeSets.length;
+            int candidateCount = candidates.length;
             BitSet any = new BitSet(candidateCount);
             for (int c = 0; c < candidateCount; c++) {
-                ImmutableAttributes candidateAttributeSet = candidateAttributeSets[c];
+                ImmutableAttributes candidateAttributeSet = candidates[c];
                 if (candidateAttributeSet.findEntry(extraAttribute.getName()).isPresent()) {
                     any.set(c);
                 }
@@ -455,7 +443,7 @@ private int[] getCandidates(BitSet liveSet) {
 
     @Nullable
     private <E> E getCandidateValue(int c, Attribute<E> attribute) {
-        AttributeValue<?> attributeValue = candidateAttributeSets[c].findEntry(attribute.getName());
+        AttributeValue<?> attributeValue = candidates[c].findEntry(attribute.getName());
         return attributeValue.isPresent() ? attributeValue.coerce(attribute) : null;
     }
 
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/external/model/ExternalComponentResolveMetadata.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/external/model/ExternalComponentResolveMetadata.java
index 92b87aab02e..12fbfe9c1d1 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/external/model/ExternalComponentResolveMetadata.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/external/model/ExternalComponentResolveMetadata.java
@@ -19,7 +19,6 @@
 import com.google.common.collect.ImmutableList;
 import org.gradle.api.artifacts.ModuleVersionIdentifier;
 import org.gradle.api.artifacts.component.ComponentIdentifier;
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema;
 import org.gradle.internal.component.model.ComponentArtifactResolveMetadata;
@@ -45,7 +44,7 @@
  * @see ComponentArtifactResolveState
  * @see ComponentArtifactResolveMetadata
  */
-public interface ExternalComponentResolveMetadata extends HasAttributes {
+public interface ExternalComponentResolveMetadata {
     List<String> DEFAULT_STATUS_SCHEME = Arrays.asList("integration", "milestone", "release");
 
     /**
@@ -87,6 +86,5 @@ public interface ExternalComponentResolveMetadata extends HasAttributes {
 
     ImmutableList<? extends VirtualComponentIdentifier> getPlatformOwners();
 
-    @Override
     ImmutableAttributes getAttributes();
 }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/AttributeMatchingExplanationBuilder.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/AttributeMatchingExplanationBuilder.java
index 8a48f0d30ee..9651e877aa9 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/AttributeMatchingExplanationBuilder.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/AttributeMatchingExplanationBuilder.java
@@ -16,9 +16,9 @@
 package org.gradle.internal.component.model;
 
 import org.gradle.api.attributes.Attribute;
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.AttributeContainerInternal;
 import org.gradle.api.internal.attributes.AttributeValue;
+import org.gradle.api.internal.attributes.ImmutableAttributes;
 
 import java.util.Collection;
 
@@ -29,27 +29,27 @@ static AttributeMatchingExplanationBuilder logging() {
         return LoggingAttributeMatchingExplanationBuilder.logging();
     }
 
-    default <T extends HasAttributes> void noCandidates(AttributeContainerInternal requested) {
+    default void noCandidates(ImmutableAttributes requested) {
 
     }
 
-    default <T extends HasAttributes> void singleMatch(T candidate, Collection<? extends T> candidates, AttributeContainerInternal requested) {
+    default void singleMatch(ImmutableAttributes candidate, Collection<ImmutableAttributes> candidates, AttributeContainerInternal requested) {
 
     }
 
-    default <T extends HasAttributes> void candidateDoesNotMatchAttributes(T candidate, AttributeContainerInternal requested) {
+    default void candidateDoesNotMatchAttributes(ImmutableAttributes candidate, AttributeContainerInternal requested) {
 
     }
 
-    default <T extends HasAttributes> void candidateAttributeDoesNotMatch(T candidate, Attribute<?> attribute, Object requestedValue, AttributeValue<?> candidateValue) {
+    default void candidateAttributeDoesNotMatch(ImmutableAttributes candidate, Attribute<?> attribute, Object requestedValue, AttributeValue<?> candidateValue) {
 
     }
 
-    default <T extends HasAttributes> void candidateAttributeMissing(T candidate, Attribute<?> attribute, Object requestedValue) {
+    default void candidateAttributeMissing(ImmutableAttributes candidate, Attribute<?> attribute, Object requestedValue) {
 
     }
 
-    default <T extends HasAttributes> void candidateIsSuperSetOfAllOthers(T candidate) {
+    default void candidateIsSuperSetOfAllOthers(ImmutableAttributes candidate) {
 
     }
 }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/ConfigurationMetadata.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/ConfigurationMetadata.java
index c62eed734e7..1155661e75e 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/ConfigurationMetadata.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/ConfigurationMetadata.java
@@ -18,7 +18,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.internal.DisplayName;
 import org.gradle.internal.component.external.model.ImmutableCapabilities;
@@ -36,7 +35,7 @@
  * @see VariantGraphResolveMetadata
  * @see ConfigurationGraphResolveMetadata
  */
-public interface ConfigurationMetadata extends HasAttributes {
+public interface ConfigurationMetadata {
     /**
      * The set of configurations that this configuration extends. Includes this configuration.
      *
@@ -50,10 +49,6 @@ public interface ConfigurationMetadata extends HasAttributes {
 
     DisplayName asDescribable();
 
-    /**
-     * Attributes are immutable on ConfigurationMetadata
-     */
-    @Override
     ImmutableAttributes getAttributes();
 
     /**
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/LoggingAttributeMatchingExplanationBuilder.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/LoggingAttributeMatchingExplanationBuilder.java
index 256a8bbb032..2b03a4d4f3a 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/LoggingAttributeMatchingExplanationBuilder.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/LoggingAttributeMatchingExplanationBuilder.java
@@ -16,9 +16,9 @@
 package org.gradle.internal.component.model;
 
 import org.gradle.api.attributes.Attribute;
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.AttributeContainerInternal;
 import org.gradle.api.internal.attributes.AttributeValue;
+import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.api.logging.Logger;
 import org.gradle.api.logging.Logging;
 
@@ -36,32 +36,32 @@ static AttributeMatchingExplanationBuilder logging() {
     }
 
     @Override
-    public <T extends HasAttributes> void noCandidates(AttributeContainerInternal requested) {
+    public void noCandidates(ImmutableAttributes requested) {
         LOGGER.debug("No candidates for {}. Select nothing.", requested);
     }
 
     @Override
-    public <T extends HasAttributes> void singleMatch(T candidate, Collection<? extends T> candidates, AttributeContainerInternal requested) {
+    public void singleMatch(ImmutableAttributes candidate, Collection<ImmutableAttributes> candidates, AttributeContainerInternal requested) {
         LOGGER.debug("Selected match {} from candidates {} for {}", candidate, candidates, requested);
     }
 
     @Override
-    public <T extends HasAttributes> void candidateDoesNotMatchAttributes(T candidate, AttributeContainerInternal requested) {
+    public void candidateDoesNotMatchAttributes(ImmutableAttributes candidate, AttributeContainerInternal requested) {
         LOGGER.debug("Candidate {} doesn't match attributes {}", candidate, requested);
     }
 
     @Override
-    public <T extends HasAttributes> void candidateAttributeDoesNotMatch(T candidate, Attribute<?> attribute, Object requestedValue, AttributeValue<?> candidateValue) {
+    public void candidateAttributeDoesNotMatch(ImmutableAttributes candidate, Attribute<?> attribute, Object requestedValue, AttributeValue<?> candidateValue) {
         LOGGER.debug("Candidate {} attribute {} value {} doesn't requested value {}", candidate, attribute, candidateValue, requestedValue);
     }
 
     @Override
-    public <T extends HasAttributes> void candidateAttributeMissing(T candidate, Attribute<?> attribute, Object requestedValue) {
+    public void candidateAttributeMissing(ImmutableAttributes candidate, Attribute<?> attribute, Object requestedValue) {
         LOGGER.debug("Candidate {} doesn't have attribute {}", candidate, attribute);
     }
 
     @Override
-    public <T extends HasAttributes> void candidateIsSuperSetOfAllOthers(T candidate) {
+    public void candidateIsSuperSetOfAllOthers(ImmutableAttributes candidate) {
         LOGGER.debug("Candidate {} selected because its attributes are a superset of all other candidate attributes", candidate);
     }
 }
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveMetadata.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveMetadata.java
index 612f28829e0..719942a3dd6 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveMetadata.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveMetadata.java
@@ -16,7 +16,6 @@
 
 package org.gradle.internal.component.model;
 
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.internal.component.external.model.ImmutableCapabilities;
 
@@ -27,7 +26,7 @@
  * of this variant, as they may be expensive to resolve. Expensive information about this variant
  * can be accessed via the methods of {@link VariantGraphResolveState}.
  */
-public interface VariantGraphResolveMetadata extends HasAttributes {
+public interface VariantGraphResolveMetadata {
 
     /**
      * Returns the name for this variant, which is unique for the variants of its owning component.
@@ -47,7 +46,6 @@ default String getDisplayName() {
         return getName();
     }
 
-    @Override
     ImmutableAttributes getAttributes();
 
     ImmutableCapabilities getCapabilities();
diff --git a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveState.java b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveState.java
index 36f50692f42..846744245c4 100644
--- a/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveState.java
+++ b/platforms/software/dependency-management/src/main/java/org/gradle/internal/component/model/VariantGraphResolveState.java
@@ -16,8 +16,7 @@
 
 package org.gradle.internal.component.model;
 
-import org.gradle.api.attributes.HasAttributes;
-import org.gradle.api.internal.attributes.ImmutableAttributes;
+import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate;
 import org.gradle.internal.component.external.model.ImmutableCapabilities;
 
 import java.util.List;
@@ -28,7 +27,7 @@
  * This state type manages expensive operations required to resolve a variant. These include
  * managing dependencies and artifacts, which may not be easily available from the metadata.
  */
-public interface VariantGraphResolveState extends HasAttributes {
+public interface VariantGraphResolveState extends AttributeMatchingCandidate {
 
     /**
      * A unique id for this variant within the current build tree. Note that this id is not stable across Gradle invocations.
@@ -37,9 +36,6 @@ public interface VariantGraphResolveState extends HasAttributes {
 
     String getName();
 
-    @Override
-    ImmutableAttributes getAttributes();
-
     ImmutableCapabilities getCapabilities();
 
     VariantGraphResolveMetadata getMetadata();
@@ -63,4 +59,5 @@ public interface VariantGraphResolveState extends HasAttributes {
      * when required.
      */
     VariantArtifactResolveState prepareForArtifactResolution();
+
 }
diff --git a/platforms/software/dependency-management/src/test/groovy/org/gradle/api/internal/artifacts/dsl/dependencies/GradlePluginVariantsSupportTest.groovy b/platforms/software/dependency-management/src/test/groovy/org/gradle/api/internal/artifacts/dsl/dependencies/GradlePluginVariantsSupportTest.groovy
index 1018dbda6d4..51710725dbc 100644
--- a/platforms/software/dependency-management/src/test/groovy/org/gradle/api/internal/artifacts/dsl/dependencies/GradlePluginVariantsSupportTest.groovy
+++ b/platforms/software/dependency-management/src/test/groovy/org/gradle/api/internal/artifacts/dsl/dependencies/GradlePluginVariantsSupportTest.groovy
@@ -20,6 +20,8 @@ import org.gradle.api.attributes.plugin.GradlePluginApiVersion
 import org.gradle.api.internal.attributes.ImmutableAttributes
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema
 import org.gradle.api.internal.attributes.matching.AttributeMatcher
+import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate
+import org.gradle.api.internal.attributes.matching.ImmutableAttributesBackedMatchingCandidate
 import org.gradle.util.AttributeTestUtil
 import org.gradle.util.TestUtil
 import spock.lang.Specification
@@ -42,12 +44,12 @@ class GradlePluginVariantsSupportTest extends Specification {
         def accepts = acceptsOrRejects == 'accepts'
 
         when:
-        def consumer = versionAttribute(currentGradleVersion)
+        def consumer = requestedVersion(currentGradleVersion)
         def producer = versionAttribute('7.0')
 
         then:
         accepts == (matcher.matchMultipleCandidates([producer], consumer) == [producer])
-        accepts == matcher.isMatchingCandidate(producer, consumer)
+        accepts == matcher.isMatchingCandidate(producer.attributes, consumer)
 
         where:
         currentGradleVersion       | acceptsOrRejects
@@ -65,7 +67,7 @@ class GradlePluginVariantsSupportTest extends Specification {
 
     def "chooses exact match API if available"() {
         when:
-        def consumer = versionAttribute('7.0')
+        def consumer = requestedVersion('7.0')
         def producer = [
             versionAttribute('6.0'),
             versionAttribute('7.0'),
@@ -81,7 +83,7 @@ class GradlePluginVariantsSupportTest extends Specification {
 
     def "chooses closest API"() {
         when:
-        def consumer = versionAttribute('7.2')
+        def consumer = requestedVersion('7.2')
         def producer = [
             versionAttribute('6.0'),
             versionAttribute('7.0'),
@@ -98,7 +100,7 @@ class GradlePluginVariantsSupportTest extends Specification {
 
     def "fails to select one candidate if there is no clear preference"() {
         when:
-        def consumer = versionAttribute('7.2')
+        def consumer = requestedVersion('7.2')
         def producer = [
             versionAttribute('6.0'),
             versionAttribute('7.0'),
@@ -111,9 +113,13 @@ class GradlePluginVariantsSupportTest extends Specification {
         matcher.matchMultipleCandidates(producer, consumer) == [versionAttribute('7.1'), versionAttribute('7.1')]
     }
 
-    private ImmutableAttributes versionAttribute(String version) {
+    private ImmutableAttributes requestedVersion(String version) {
+        versionAttribute(version).attributes
+    }
+
+    private AttributeMatchingCandidate versionAttribute(String version) {
         def attributes = attributes.mutable()
         attributes.attribute(GradlePluginApiVersion.GRADLE_PLUGIN_API_VERSION_ATTRIBUTE, objects.named(GradlePluginApiVersion, version))
-        attributes.asImmutable()
+        new ImmutableAttributesBackedMatchingCandidate(attributes.asImmutable())
     }
 }
diff --git a/platforms/software/dependency-management/src/test/groovy/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcherTest.groovy b/platforms/software/dependency-management/src/test/groovy/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcherTest.groovy
index 99b9b097d8c..318ec29de47 100644
--- a/platforms/software/dependency-management/src/test/groovy/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcherTest.groovy
+++ b/platforms/software/dependency-management/src/test/groovy/org/gradle/api/internal/attributes/matching/DefaultAttributeMatcherTest.groovy
@@ -22,7 +22,6 @@ import org.gradle.api.attributes.AttributeCompatibilityRule
 import org.gradle.api.attributes.AttributeDisambiguationRule
 import org.gradle.api.attributes.CompatibilityCheckDetails
 import org.gradle.api.attributes.MultipleCandidatesDetails
-import org.gradle.api.internal.attributes.AttributeContainerInternal
 import org.gradle.api.internal.attributes.DefaultAttributesSchema
 import org.gradle.api.internal.attributes.ImmutableAttributes
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema
@@ -39,24 +38,22 @@ import static org.gradle.util.TestUtil.objectFactory
 
 class DefaultAttributeMatcherTest extends Specification {
 
-    def factory = AttributeTestUtil.attributesFactory()
-
     def "selects candidate with same set of attributes and whose values match"() {
         given:
         def matcher = newMatcher {
             attribute(Attribute.of('usage', String))
         }
 
-        def candidate1 = attributes(usage: "match")
-        def candidate2 = attributes(usage: "no match")
+        def candidate1 = candidate(usage: "match")
+        def candidate2 = candidate(usage: "no match")
         def requested = attributes(usage: "match")
 
         expect:
         matcher.matchMultipleCandidates([candidate1, candidate2], requested) == [candidate1]
         matcher.matchMultipleCandidates([candidate2], requested) == []
 
-        matcher.isMatchingCandidate(candidate1, requested)
-        !matcher.isMatchingCandidate(candidate2, requested)
+        matcher.isMatchingCandidate(candidate1.attributes, requested)
+        !matcher.isMatchingCandidate(candidate2.attributes, requested)
     }
 
     def "selects candidate with subset of attributes and whose values match"() {
@@ -66,10 +63,10 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(Attribute.of('other', String))
         }
 
-        def candidate1 = attributes(usage: "match")
-        def candidate2 = attributes(usage: "no match")
-        def candidate3 = attributes(usage: "match", other: "no match")
-        def candidate4 = ImmutableAttributes.EMPTY
+        def candidate1 = candidate(usage: "match")
+        def candidate2 = candidate(usage: "no match")
+        def candidate3 = candidate(usage: "match", other: "no match")
+        def candidate4 = candidate()
 
         def requested = attributes(usage: "match", other: "match")
 
@@ -77,10 +74,10 @@ class DefaultAttributeMatcherTest extends Specification {
         matcher.matchMultipleCandidates([candidate1, candidate2, candidate3, candidate4], requested) == [candidate1]
         matcher.matchMultipleCandidates([candidate2, candidate3, candidate4], requested) == [candidate4]
 
-        matcher.isMatchingCandidate(candidate1, requested)
-        !matcher.isMatchingCandidate(candidate2, requested)
-        !matcher.isMatchingCandidate(candidate3, requested)
-        matcher.isMatchingCandidate(candidate4, requested)
+        matcher.isMatchingCandidate(candidate1.attributes, requested)
+        !matcher.isMatchingCandidate(candidate2.attributes, requested)
+        !matcher.isMatchingCandidate(candidate3.attributes, requested)
+        matcher.isMatchingCandidate(candidate4.attributes, requested)
     }
 
     def "selects candidate with additional attributes and whose values match"() {
@@ -90,16 +87,16 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(Attribute.of('other', String))
         }
 
-        def candidate1 = attributes(usage: "match", other: "dont care")
-        def candidate2 = attributes(usage: "no match")
+        def candidate1 = candidate(usage: "match", other: "dont care")
+        def candidate2 = candidate(usage: "no match")
         def requested = attributes(usage: "match")
 
         expect:
         matcher.matchMultipleCandidates([candidate1, candidate2], requested) == [candidate1]
         matcher.matchMultipleCandidates([candidate2], requested) == []
 
-        matcher.isMatchingCandidate(candidate1, requested)
-        !matcher.isMatchingCandidate(candidate2, requested)
+        matcher.isMatchingCandidate(candidate1.attributes, requested)
+        !matcher.isMatchingCandidate(candidate2.attributes, requested)
     }
 
     def "selects multiple candidates with compatible values"() {
@@ -109,11 +106,11 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(Attribute.of('other', String))
         }
 
-        def candidate1 = attributes(usage: "match")
-        def candidate2 = attributes(usage: "no match")
-        def candidate3 = attributes(other: "match")
-        def candidate4 = ImmutableAttributes.EMPTY
-        def candidate5 = attributes(usage: "match")
+        def candidate1 = candidate(usage: "match")
+        def candidate2 = candidate(usage: "no match")
+        def candidate3 = candidate(other: "match")
+        def candidate4 = candidate()
+        def candidate5 = candidate(usage: "match")
 
         def requested = attributes(usage: "match", other: "match")
 
@@ -137,11 +134,11 @@ class DefaultAttributeMatcherTest extends Specification {
             prefer(other, "best")
         }
 
-        def candidate1 = attributes(usage: "best", other: "compatible")
-        def candidate2 = attributes(usage: "no match", other: "no match")
-        def candidate3 = attributes(usage: "compatible", other: "best")
-        def candidate4 = attributes()
-        def candidate5 = attributes(usage: "best", other: "best")
+        def candidate1 = candidate(usage: "best", other: "compatible")
+        def candidate2 = candidate(usage: "no match", other: "no match")
+        def candidate3 = candidate(usage: "compatible", other: "best")
+        def candidate4 = candidate()
+        def candidate5 = candidate(usage: "best", other: "best")
 
         def requested = attributes(usage: "requested", other: "requested")
 
@@ -173,10 +170,10 @@ class DefaultAttributeMatcherTest extends Specification {
             accept(usage, "requested", "best")
         }
 
-        def candidate1 = attributes(usage: "compatible")
-        def candidate2 = attributes(usage: "no match")
-        def candidate3 = attributes(usage: "best")
-        def candidate4 = ImmutableAttributes.EMPTY
+        def candidate1 = candidate(usage: "compatible")
+        def candidate2 = candidate(usage: "no match")
+        def candidate3 = candidate(usage: "best")
+        def candidate4 = candidate()
         def requested1 = attributes(usage: "requested")
         def requested2 = ImmutableAttributes.EMPTY
 
@@ -204,9 +201,9 @@ class DefaultAttributeMatcherTest extends Specification {
             accept(usage, "requested", "compatible")
         }
 
-        def candidate1 = attributes(usage: "best")
-        def candidate2 = attributes(usage: "compatible")
-        def candidate3 = attributes()
+        def candidate1 = candidate(usage: "best")
+        def candidate2 = candidate(usage: "compatible")
+        def candidate3 = candidate()
         def requested = attributes(usage: "requested")
 
         expect:
@@ -220,12 +217,12 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(Attribute.of('other', String))
         }
 
-        def candidate1 = attributes(usage: "match")
-        def candidate2 = attributes(usage: "no match")
-        def candidate3 = attributes(other: "match")
-        def candidate4 = attributes()
-        def candidate5 = attributes(usage: "match", other: "match")
-        def candidate6 = attributes(usage: "match")
+        def candidate1 = candidate(usage: "match")
+        def candidate2 = candidate(usage: "no match")
+        def candidate3 = candidate(other: "match")
+        def candidate4 = candidate()
+        def candidate5 = candidate(usage: "match", other: "match")
+        def candidate6 = candidate(usage: "match")
         def requested = attributes(usage: "match", other: "match")
 
         expect:
@@ -245,8 +242,8 @@ class DefaultAttributeMatcherTest extends Specification {
             prefer(other, "best")
         }
 
-        def candidate1 = attributes(usage: "match", other: "ignored")
-        def candidate2 = attributes(usage: "match", other: "best")
+        def candidate1 = candidate(usage: "match", other: "ignored")
+        def candidate2 = candidate(usage: "match", other: "best")
         def requested = attributes(usage: "match")
 
         expect:
@@ -268,8 +265,8 @@ class DefaultAttributeMatcherTest extends Specification {
             prefer(other, "best")
         }
 
-        def candidate1 = attributes(usage: "compatible", other: "ignored")
-        def candidate2 = attributes(usage: "best", other: "best")
+        def candidate1 = candidate(usage: "compatible", other: "ignored")
+        def candidate2 = candidate(usage: "best", other: "best")
         def requested = attributes(usage: "foo")
 
         expect:
@@ -283,30 +280,30 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(Attribute.of("usage", String))
         }
 
-        def candidate1 = ImmutableAttributes.EMPTY
-        def candidate2 = attributes(usage: "ignored")
+        def candidate1 = candidate()
+        def candidate2 = candidate(usage: "ignored")
         def requested = ImmutableAttributes.EMPTY
 
         expect:
         matcher.matchMultipleCandidates([candidate1, candidate2], requested) == [candidate1, candidate2]
 
         matcher.matchMultipleCandidates([candidate1], requested) == [candidate1]
-        matcher.isMatchingCandidate(candidate1, requested)
+        matcher.isMatchingCandidate(candidate1.attributes, requested)
 
         matcher.matchMultipleCandidates([candidate2], requested) == [candidate2]
-        matcher.isMatchingCandidate(candidate2, requested)
+        matcher.isMatchingCandidate(candidate2.attributes, requested)
     }
 
     def "non-empty consumer attributes match empty producer attributes"() {
         given:
         def matcher = newMatcher()
 
-        def candidate = ImmutableAttributes.EMPTY
+        def candidate = candidate()
         def requested = attributes(usage: "dont care", other: "dont care")
 
         expect:
         matcher.matchMultipleCandidates([candidate], requested) == [candidate]
-        matcher.isMatchingCandidate(candidate, requested)
+        matcher.isMatchingCandidate(candidate.attributes, requested)
     }
 
     def "can match when consumer uses more general type for attribute"() {
@@ -318,8 +315,8 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(consumer)
         }
 
-        def candidate1 = attributesTyped((producer): 1)
-        def candidate2 = attributesTyped((producer): 2)
+        def candidate1 = candidateTyped((producer): 1)
+        def candidate2 = candidateTyped((producer): 2)
         def requested = attributesTyped((consumer): 1)
 
         expect:
@@ -335,8 +332,8 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(consumer)
         }
 
-        def candidate1 = attributesTyped((producer): "name1")
-        def candidate2 = attributesTyped((producer): "name2")
+        def candidate1 = candidateTyped((producer): "name1")
+        def candidate2 = candidateTyped((producer): "name2")
         def requested = attributesTyped((consumer): objectFactory().named(NamedTestAttribute, "name1"))
 
         expect:
@@ -352,8 +349,8 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(consumer)
         }
 
-        def candidate1 = attributesTyped((producer): objectFactory().named(NamedTestAttribute, "name1"))
-        def candidate2 = attributesTyped((producer): objectFactory().named(NamedTestAttribute, "name2"))
+        def candidate1 = candidateTyped((producer): objectFactory().named(NamedTestAttribute, "name1"))
+        def candidate2 = candidateTyped((producer): objectFactory().named(NamedTestAttribute, "name2"))
         def requested = attributesTyped((consumer): "name1")
 
         expect:
@@ -369,8 +366,8 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(consumer)
         }
 
-        def candidate1 = attributesTyped((producer): "NAME1")
-        def candidate2 = attributesTyped((producer): "NAME2")
+        def candidate1 = candidateTyped((producer): "NAME1")
+        def candidate2 = candidateTyped((producer): "NAME2")
         def requested = attributesTyped((consumer): EnumTestAttribute.NAME1)
 
         expect:
@@ -386,8 +383,8 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(consumer)
         }
 
-        def candidate1 = attributesTyped((producer): EnumTestAttribute.NAME1)
-        def candidate2 = attributesTyped((producer): EnumTestAttribute.NAME2)
+        def candidate1 = candidateTyped((producer): EnumTestAttribute.NAME1)
+        def candidate2 = candidateTyped((producer): EnumTestAttribute.NAME2)
         def requested = attributesTyped((consumer): "NAME1")
 
         expect:
@@ -403,8 +400,8 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(consumer)
         }
 
-        def candidate1 = attributesTyped((producer): "name1")
-        def candidate2 = attributesTyped((producer): "name2")
+        def candidate1 = candidateTyped((producer): "name1")
+        def candidate2 = candidateTyped((producer): "name2")
         def requested = attributesTyped((consumer): new NotSerializableInGradleMetadataAttribute("name1"))
 
         when:
@@ -424,8 +421,8 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(consumer)
         }
 
-        def candidate1 = attributesTyped((producer): new NotSerializableInGradleMetadataAttribute("name1"))
-        def candidate2 = attributesTyped((producer): new NotSerializableInGradleMetadataAttribute("name2"))
+        def candidate1 = candidateTyped((producer): new NotSerializableInGradleMetadataAttribute("name1"))
+        def candidate2 = candidateTyped((producer): new NotSerializableInGradleMetadataAttribute("name2"))
         def requested = attributesTyped((consumer): "name1")
 
         when:
@@ -445,7 +442,7 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(consumer)
         }
 
-        def candidate = attributesTyped((producer): 1)
+        def candidate = candidateTyped((producer): 1)
         def requested = attributesTyped((consumer): "1")
 
         when:
@@ -463,8 +460,8 @@ class DefaultAttributeMatcherTest extends Specification {
             attribute(Attribute.of("other", String))
         }
 
-        def candidate1 = attributes(usage: 'match')
-        def candidate2 = attributes(usage: 'match', other: 'foo')
+        def candidate1 = candidate(usage: 'match')
+        def candidate2 = candidate(usage: 'match', other: 'foo')
         def requested = attributes(usage: 'match')
 
         expect:
@@ -488,10 +485,10 @@ class DefaultAttributeMatcherTest extends Specification {
             prefer(usage, 'java-api-extra')
         }
 
-        def candidate1 = attributes(usage: 'java-api-extra', status: 'integration')
-        def candidate2 = attributes(usage: 'java-runtime-extra', status: 'integration')
-        def candidate3 = attributes(usage: 'java-api-extra', status: 'integration', bundling: value1)
-        def candidate4 = attributes(usage: 'java-runtime-extra', status: 'integration', bundling: value2)
+        def candidate1 = candidate(usage: 'java-api-extra', status: 'integration')
+        def candidate2 = candidate(usage: 'java-runtime-extra', status: 'integration')
+        def candidate3 = candidate(usage: 'java-api-extra', status: 'integration', bundling: value1)
+        def candidate4 = candidate(usage: 'java-runtime-extra', status: 'integration', bundling: value2)
         def requested = attributes(usage: 'java-api')
 
         when:
@@ -500,10 +497,10 @@ class DefaultAttributeMatcherTest extends Specification {
         result == [candidate1]
 
         when: // check with a different attribute order
-        candidate1 = attributes(usage: 'java-api-extra', status: 'integration')
-        candidate2 = attributes(usage: 'java-runtime-extra', status: 'integration')
-        candidate3 = attributes(usage: 'java-api-extra', bundling: value2, status: 'integration')
-        candidate4 = attributes(usage: 'java-runtime-extra', bundling: value1, status: 'integration')
+        candidate1 = candidate(usage: 'java-api-extra', status: 'integration')
+        candidate2 = candidate(usage: 'java-runtime-extra', status: 'integration')
+        candidate3 = candidate(usage: 'java-api-extra', bundling: value2, status: 'integration')
+        candidate4 = candidate(usage: 'java-runtime-extra', bundling: value1, status: 'integration')
 
         result = matcher.matchMultipleCandidates([candidate1, candidate2, candidate3, candidate4], requested)
 
@@ -511,10 +508,10 @@ class DefaultAttributeMatcherTest extends Specification {
         result == [candidate1]
 
         when: // yet another attribute order
-        candidate1 = attributes(status: 'integration', usage: 'java-api-extra')
-        candidate2 = attributes(usage: 'java-runtime-extra', status: 'integration')
-        candidate3 = attributes(bundling: value1, status: 'integration', usage: 'java-api-extra')
-        candidate4 = attributes(status: 'integration', usage: 'java-runtime-extra', bundling: value2)
+        candidate1 = candidate(status: 'integration', usage: 'java-api-extra')
+        candidate2 = candidate(usage: 'java-runtime-extra', status: 'integration')
+        candidate3 = candidate(bundling: value1, status: 'integration', usage: 'java-api-extra')
+        candidate4 = candidate(status: 'integration', usage: 'java-runtime-extra', bundling: value2)
 
         result = matcher.matchMultipleCandidates([candidate1, candidate2, candidate3, candidate4], requested)
 
@@ -528,8 +525,16 @@ class DefaultAttributeMatcherTest extends Specification {
         NamedTestAttribute  | "foo"         | "bar"
     }
 
-    private AttributeContainerInternal attributes() {
-        factory.mutable()
+    private static AttributeMatchingCandidate candidate() {
+        new ImmutableAttributesBackedMatchingCandidate(ImmutableAttributes.EMPTY)
+    }
+
+    private static AttributeMatchingCandidate candidate(Map<String, String> attributes) {
+        new ImmutableAttributesBackedMatchingCandidate(AttributeTestUtil.attributes(attributes))
+    }
+
+    private static AttributeMatchingCandidate candidateTyped(Map<Attribute<?>, Object> attributes) {
+        new ImmutableAttributesBackedMatchingCandidate(attributesTyped(attributes))
     }
 
     interface NamedTestAttribute extends Named { }
diff --git a/platforms/software/dependency-management/src/test/groovy/org/gradle/internal/component/model/AttributePrecedenceSchemaAttributeMatcherTest.groovy b/platforms/software/dependency-management/src/test/groovy/org/gradle/internal/component/model/AttributePrecedenceSchemaAttributeMatcherTest.groovy
index 7d00339667d..1fa3f509197 100644
--- a/platforms/software/dependency-management/src/test/groovy/org/gradle/internal/component/model/AttributePrecedenceSchemaAttributeMatcherTest.groovy
+++ b/platforms/software/dependency-management/src/test/groovy/org/gradle/internal/component/model/AttributePrecedenceSchemaAttributeMatcherTest.groovy
@@ -24,6 +24,8 @@ import org.gradle.api.attributes.MultipleCandidatesDetails
 import org.gradle.api.internal.attributes.ImmutableAttributes
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema
 import org.gradle.api.internal.attributes.matching.AttributeMatcher
+import org.gradle.api.internal.attributes.matching.AttributeMatchingCandidate
+import org.gradle.api.internal.attributes.matching.ImmutableAttributesBackedMatchingCandidate
 import org.gradle.util.AttributeTestUtil
 import spock.lang.Specification
 
@@ -118,9 +120,11 @@ class AttributePrecedenceSchemaAttributeMatcherTest extends Specification {
     }
 
     private static ImmutableAttributes requested(String highestValue, String middleValue, String lowestValue) {
-        return candidate(highestValue, middleValue, lowestValue)
+        return candidate(highestValue, middleValue, lowestValue).attributes
     }
-    private static ImmutableAttributes candidate(String highestValue, String middleValue, String lowestValue) {
-        return AttributeTestUtil.attributes([highest: highestValue, middle: middleValue, lowest: lowestValue])
+
+    private static AttributeMatchingCandidate candidate(String highestValue, String middleValue, String lowestValue) {
+        def attributes = AttributeTestUtil.attributes([highest: highestValue, middle: middleValue, lowest: lowestValue])
+        new ImmutableAttributesBackedMatchingCandidate(attributes)
     }
 }
diff --git a/platforms/software/ivy/src/main/java/org/gradle/api/publish/ivy/internal/versionmapping/DefaultVersionMappingStrategy.java b/platforms/software/ivy/src/main/java/org/gradle/api/publish/ivy/internal/versionmapping/DefaultVersionMappingStrategy.java
index 61a7e011c76..607af341246 100644
--- a/platforms/software/ivy/src/main/java/org/gradle/api/publish/ivy/internal/versionmapping/DefaultVersionMappingStrategy.java
+++ b/platforms/software/ivy/src/main/java/org/gradle/api/publish/ivy/internal/versionmapping/DefaultVersionMappingStrategy.java
@@ -16,6 +16,7 @@
 package org.gradle.api.publish.ivy.internal.versionmapping;
 
 import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Multimap;
 import org.gradle.api.Action;
 import org.gradle.api.InvalidUserCodeException;
@@ -28,6 +29,7 @@
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema;
 import org.gradle.api.internal.attributes.matching.AttributeMatcher;
+import org.gradle.api.internal.attributes.matching.ImmutableAttributesBackedMatchingCandidate;
 import org.gradle.api.model.ObjectFactory;
 import org.gradle.api.publish.VariantVersionMappingStrategy;
 import org.gradle.api.publish.internal.versionmapping.DefaultVariantVersionMappingStrategy;
@@ -40,7 +42,6 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 public class DefaultVersionMappingStrategy implements VersionMappingStrategyInternal {
     private final ObjectFactory objectFactory;
@@ -50,8 +51,8 @@ public class DefaultVersionMappingStrategy implements VersionMappingStrategyInte
     private final AttributeSchemaServices attributeSchemaServices;
 
     private final List<Action<? super VariantVersionMappingStrategy>> mappingsForAllVariants = new ArrayList<>(2);
-    private final Map<ImmutableAttributes, String> defaultConfigurations = new HashMap<>();
-    private final Multimap<ImmutableAttributes, Action<? super VariantVersionMappingStrategy>> attributeBasedMappings = ArrayListMultimap.create();
+    private final Map<ImmutableAttributesBackedMatchingCandidate, String> defaultConfigurations = new HashMap<>();
+    private final Multimap<ImmutableAttributesBackedMatchingCandidate, Action<? super VariantVersionMappingStrategy>> attributeBasedMappings = ArrayListMultimap.create();
 
     private AttributeMatcher matcher;
 
@@ -77,7 +78,8 @@ public void allVariants(Action<? super VariantVersionMappingStrategy> action) {
 
     @Override
     public <T> void variant(Attribute<T> attribute, T attributeValue, Action<? super VariantVersionMappingStrategy> action) {
-        attributeBasedMappings.put(attributesFactory.of(attribute, attributeValue), action);
+        ImmutableAttributes attributes = attributesFactory.of(attribute, attributeValue);
+        attributeBasedMappings.put(new ImmutableAttributesBackedMatchingCandidate(attributes), action);
     }
 
     @Override
@@ -87,7 +89,8 @@ public void usage(String usage, Action<? super VariantVersionMappingStrategy> ac
 
     @Override
     public void defaultResolutionConfiguration(String usage, String defaultConfiguration) {
-        defaultConfigurations.put(attributesFactory.of(Usage.USAGE_ATTRIBUTE, objectFactory.named(Usage.class, usage)), defaultConfiguration);
+        ImmutableAttributes attributes = attributesFactory.of(Usage.USAGE_ATTRIBUTE, objectFactory.named(Usage.class, usage));
+        defaultConfigurations.put(new ImmutableAttributesBackedMatchingCandidate(attributes), defaultConfiguration);
     }
 
     @Override
@@ -100,8 +103,8 @@ public VariantVersionMappingStrategyInternal findStrategyForVariant(ImmutableAtt
 
         // Then use attribute specific mapping
         if (!attributeBasedMappings.isEmpty()) {
-            Set<ImmutableAttributes> candidates = attributeBasedMappings.keySet();
-            List<ImmutableAttributes> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
+            List<ImmutableAttributesBackedMatchingCandidate> candidates = ImmutableList.copyOf(attributeBasedMappings.keySet());
+            List<ImmutableAttributesBackedMatchingCandidate> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
             if (matches.size() == 1) {
                 Collection<Action<? super VariantVersionMappingStrategy>> actions = attributeBasedMappings.get(matches.get(0));
                 for (Action<? super VariantVersionMappingStrategy> action : actions) {
@@ -119,9 +122,9 @@ private DefaultVariantVersionMappingStrategy createDefaultMappingStrategy(Immuta
         if (!defaultConfigurations.isEmpty()) {
             // First need to populate the default variant version mapping strategy with the default values
             // provided by plugins
-            Set<ImmutableAttributes> candidates = defaultConfigurations.keySet();
-            List<ImmutableAttributes> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
-            for (ImmutableAttributes match : matches) {
+            List<ImmutableAttributesBackedMatchingCandidate> candidates = ImmutableList.copyOf(defaultConfigurations.keySet());
+            List<ImmutableAttributesBackedMatchingCandidate> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
+            for (ImmutableAttributesBackedMatchingCandidate match : matches) {
                 strategy.setDefaultResolutionConfiguration(configurations.getByName(defaultConfigurations.get(match)));
             }
         }
diff --git a/platforms/software/publish/src/main/java/org/gradle/api/publish/internal/versionmapping/DefaultVersionMappingStrategy.java b/platforms/software/publish/src/main/java/org/gradle/api/publish/internal/versionmapping/DefaultVersionMappingStrategy.java
index 72a971b0cf2..02764e5804e 100644
--- a/platforms/software/publish/src/main/java/org/gradle/api/publish/internal/versionmapping/DefaultVersionMappingStrategy.java
+++ b/platforms/software/publish/src/main/java/org/gradle/api/publish/internal/versionmapping/DefaultVersionMappingStrategy.java
@@ -16,6 +16,7 @@
 package org.gradle.api.publish.internal.versionmapping;
 
 import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Multimap;
 import org.gradle.api.Action;
 import org.gradle.api.InvalidUserCodeException;
@@ -28,6 +29,7 @@
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.gradle.api.internal.attributes.immutable.ImmutableAttributesSchema;
 import org.gradle.api.internal.attributes.matching.AttributeMatcher;
+import org.gradle.api.internal.attributes.matching.ImmutableAttributesBackedMatchingCandidate;
 import org.gradle.api.model.ObjectFactory;
 import org.gradle.api.publish.VariantVersionMappingStrategy;
 
@@ -37,7 +39,6 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 
 public class DefaultVersionMappingStrategy implements VersionMappingStrategyInternal {
     private final ObjectFactory objectFactory;
@@ -47,8 +48,8 @@ public class DefaultVersionMappingStrategy implements VersionMappingStrategyInte
     private final AttributeSchemaServices attributeSchemaServices;
 
     private final List<Action<? super VariantVersionMappingStrategy>> mappingsForAllVariants = new ArrayList<>(2);
-    private final Map<ImmutableAttributes, String> defaultConfigurations = new HashMap<>();
-    private final Multimap<ImmutableAttributes, Action<? super VariantVersionMappingStrategy>> attributeBasedMappings = ArrayListMultimap.create();
+    private final Map<ImmutableAttributesBackedMatchingCandidate, String> defaultConfigurations = new HashMap<>();
+    private final Multimap<ImmutableAttributesBackedMatchingCandidate, Action<? super VariantVersionMappingStrategy>> attributeBasedMappings = ArrayListMultimap.create();
 
     private AttributeMatcher matcher;
 
@@ -74,7 +75,8 @@ public void allVariants(Action<? super VariantVersionMappingStrategy> action) {
 
     @Override
     public <T> void variant(Attribute<T> attribute, T attributeValue, Action<? super VariantVersionMappingStrategy> action) {
-        attributeBasedMappings.put(attributesFactory.of(attribute, attributeValue), action);
+        ImmutableAttributes attributes = attributesFactory.of(attribute, attributeValue);
+        attributeBasedMappings.put(new ImmutableAttributesBackedMatchingCandidate(attributes), action);
     }
 
     @Override
@@ -84,7 +86,8 @@ public void usage(String usage, Action<? super VariantVersionMappingStrategy> ac
 
     @Override
     public void defaultResolutionConfiguration(String usage, String defaultConfiguration) {
-        defaultConfigurations.put(attributesFactory.of(Usage.USAGE_ATTRIBUTE, objectFactory.named(Usage.class, usage)), defaultConfiguration);
+        ImmutableAttributes attributes = attributesFactory.of(Usage.USAGE_ATTRIBUTE, objectFactory.named(Usage.class, usage));
+        defaultConfigurations.put(new ImmutableAttributesBackedMatchingCandidate(attributes), defaultConfiguration);
     }
 
     @Override
@@ -97,8 +100,8 @@ public VariantVersionMappingStrategyInternal findStrategyForVariant(ImmutableAtt
 
         // Then use attribute specific mapping
         if (!attributeBasedMappings.isEmpty()) {
-            Set<ImmutableAttributes> candidates = attributeBasedMappings.keySet();
-            List<ImmutableAttributes> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
+            List<ImmutableAttributesBackedMatchingCandidate> candidates = ImmutableList.copyOf(attributeBasedMappings.keySet());
+            List<ImmutableAttributesBackedMatchingCandidate> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
             if (matches.size() == 1) {
                 Collection<Action<? super VariantVersionMappingStrategy>> actions = attributeBasedMappings.get(matches.get(0));
                 for (Action<? super VariantVersionMappingStrategy> action : actions) {
@@ -116,9 +119,9 @@ private DefaultVariantVersionMappingStrategy createDefaultMappingStrategy(Immuta
         if (!defaultConfigurations.isEmpty()) {
             // First need to populate the default variant version mapping strategy with the default values
             // provided by plugins
-            Set<ImmutableAttributes> candidates = defaultConfigurations.keySet();
-            List<ImmutableAttributes> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
-            for (ImmutableAttributes match : matches) {
+            List<ImmutableAttributesBackedMatchingCandidate> candidates = ImmutableList.copyOf(defaultConfigurations.keySet());
+            List<ImmutableAttributesBackedMatchingCandidate> matches = getMatcher().matchMultipleCandidates(candidates, variantAttributes);
+            for (ImmutableAttributesBackedMatchingCandidate match : matches) {
                 strategy.setDefaultResolutionConfiguration(configurations.getByName(defaultConfigurations.get(match)));
             }
         }
diff --git a/platforms/software/reporting/build.gradle.kts b/platforms/software/reporting/build.gradle.kts
index cb26dea8b5d..800f8112c83 100644
--- a/platforms/software/reporting/build.gradle.kts
+++ b/platforms/software/reporting/build.gradle.kts
@@ -32,6 +32,7 @@ dependencies {
     api(libs.jspecify)
 
     implementation(projects.fileCollections)
+    implementation(projects.logging)
 
     implementation(libs.guava)
     implementation(libs.jatl)
diff --git a/platforms/software/reporting/src/integTest/groovy/org/gradle/api/reporting/plugins/BuildDashboardPluginIntegrationTest.groovy b/platforms/software/reporting/src/integTest/groovy/org/gradle/api/reporting/plugins/BuildDashboardPluginIntegrationTest.groovy
index 149560af8e7..5363b91c0f5 100644
--- a/platforms/software/reporting/src/integTest/groovy/org/gradle/api/reporting/plugins/BuildDashboardPluginIntegrationTest.groovy
+++ b/platforms/software/reporting/src/integTest/groovy/org/gradle/api/reporting/plugins/BuildDashboardPluginIntegrationTest.groovy
@@ -17,7 +17,6 @@
 package org.gradle.api.reporting.plugins
 
 import org.gradle.api.JavaVersion
-import org.gradle.integtests.fixtures.ToBeFixedForConfigurationCache
 import org.gradle.integtests.fixtures.WellBehavedPluginTest
 import org.gradle.test.fixtures.file.TestFile
 import org.gradle.test.precondition.Requires
@@ -32,7 +31,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
 
     def setup() {
         writeBuildFile()
-        expectTaskProjectDeprecation = true
     }
 
     private void goodCode(TestFile root = testDirectory) {
@@ -121,10 +119,8 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         'buildDashboard'
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard for a project with no other reports lists just the dashboard'() {
         when:
-        expectTaskProjectDeprecation()
         run('buildDashboard')
 
         then:
@@ -133,14 +129,12 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         unavailableReports.empty
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard lists the enabled reports for the project'() {
         given:
         goodCode()
         goodTests()
 
         when:
-        expectTaskProjectDeprecation()
         run('check', 'buildDashboard')
 
         then:
@@ -150,14 +144,12 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':test', 'junitXml')
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard lists the reports which have not been generated'() {
         given:
         goodCode()
         goodTests()
 
         when:
-        expectTaskProjectDeprecation()
         run('buildDashboard')
 
         then:
@@ -168,14 +160,12 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasUnavailableReport(':test', 'junitXml')
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard is always generated after report generating tasks have executed'() {
         given:
         goodCode()
         goodTests()
 
         when:
-        expectTaskProjectDeprecation()
         run('buildDashboard', 'check')
 
         then:
@@ -185,14 +175,12 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':test', 'junitXml')
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'running a report generating task also generates build dashboard'() {
         given:
         goodCode()
         goodTests()
 
         when:
-        expectTaskProjectDeprecation()
         run('test')
 
         then:
@@ -202,14 +190,12 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':test', 'junitXml')
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'build dashboard is generated even if report generating task fails'() {
         given:
         goodCode()
         badTests()
 
         when:
-        expectTaskProjectDeprecation()
         runAndFail('check')
 
         then:
@@ -257,20 +243,17 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         """
 
         when:
-        executer.withBuildJvmOpts("-Dorg.gradle.configuration-cache.internal.task-execution-access-pre-stable=true")
         run('buildDashboard')
 
         then:
         !buildDashboardFile.exists()
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'buildDashboard is incremental'() {
         given:
         goodCode()
 
         expect:
-        expectTaskProjectDeprecation()
         run('buildDashboard')
         executedAndNotSkipped(':buildDashboard')
 
@@ -281,12 +264,10 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         buildDashboardFile.delete()
 
         then:
-        expectTaskProjectDeprecation()
         run('buildDashboard')
         executedAndNotSkipped(':buildDashboard')
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     @Requires(UnitTestPreconditions.StableGroovy) // FIXME KM temporarily disabling while CodeNarc runs in Worker API with multiple Groovy runtimes
     void 'enabling an additional report renders buildDashboard out-of-date'() {
         given:
@@ -294,7 +275,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         withCodenarc()
 
         when:
-        expectTaskProjectDeprecation()
         run('check')
         executedAndNotSkipped(':buildDashboard')
 
@@ -311,7 +291,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         """
 
         and:
-        expectTaskProjectDeprecation()
         run('check')
         executedAndNotSkipped(':buildDashboard')
 
@@ -322,14 +301,12 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':codenarcMain', 'text')
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'generating a report that was previously not available renders buildDashboard out-of-date'() {
         given:
         goodCode()
         goodTests()
 
         when:
-        expectTaskProjectDeprecation()
         run('buildDashboard')
         executedAndNotSkipped(':buildDashboard')
 
@@ -341,7 +318,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasUnavailableReport(':test', 'junitXml')
 
         when:
-        expectTaskProjectDeprecation()
         run('test')
         executedAndNotSkipped(':buildDashboard')
 
@@ -353,7 +329,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         unavailableReports.empty
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'reports from subprojects are aggregated'() {
         given:
         goodCode()
@@ -361,7 +336,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         setupSubproject()
 
         when:
-        expectTaskProjectDeprecation()
         run('buildDashboard', 'check')
 
         then:
@@ -373,7 +347,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':subproject:test', 'junitXml')
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     void 'dashboard includes JaCoCo reports'() {
         given:
         JacocoCoverage.assumeDefaultJacocoWorksOnCurrentJdk()
@@ -384,7 +357,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         """
 
         when:
-        expectTaskProjectDeprecation()
         run("test", "jacocoTestReport")
 
         then:
@@ -395,7 +367,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         hasReport(':jacocoTestReport', 'html')
     }
 
-    @ToBeFixedForConfigurationCache(because = ":buildDashboard")
     @Requires(UnitTestPreconditions.StableGroovy) // FIXME KM temporarily disabling while CodeNarc runs in Worker API with multiple Groovy runtimes
     void 'dashboard includes CodeNarc reports'() {
         given:
@@ -403,7 +374,6 @@ class BuildDashboardPluginIntegrationTest extends WellBehavedPluginTest {
         withCodenarc()
 
         when:
-        expectTaskProjectDeprecation()
         run("check")
 
         then:
diff --git a/platforms/software/reporting/src/main/java/org/gradle/api/reporting/GenerateBuildDashboard.java b/platforms/software/reporting/src/main/java/org/gradle/api/reporting/GenerateBuildDashboard.java
index 5a5123d6a3b..b036c8ef92e 100644
--- a/platforms/software/reporting/src/main/java/org/gradle/api/reporting/GenerateBuildDashboard.java
+++ b/platforms/software/reporting/src/main/java/org/gradle/api/reporting/GenerateBuildDashboard.java
@@ -23,6 +23,7 @@
 import org.gradle.api.NamedDomainObjectSet;
 import org.gradle.api.Project;
 import org.gradle.api.Task;
+import org.gradle.api.internal.ConfigurationCacheDegradation;
 import org.gradle.api.reporting.internal.BuildDashboardGenerator;
 import org.gradle.api.reporting.internal.DefaultBuildDashboardReports;
 import org.gradle.api.tasks.Input;
@@ -30,6 +31,7 @@
 import org.gradle.api.tasks.TaskAction;
 import org.gradle.internal.Cast;
 import org.gradle.internal.Describables;
+import org.gradle.internal.deprecation.DeprecationLogger;
 import org.gradle.internal.instrumentation.api.annotations.ToBeReplacedByLazyProperty;
 import org.gradle.util.internal.ClosureBackedAction;
 import org.gradle.util.internal.CollectionUtils;
@@ -52,6 +54,7 @@ public abstract class GenerateBuildDashboard extends DefaultTask implements Repo
     private final BuildDashboardReports reports;
 
     public GenerateBuildDashboard() {
+        ConfigurationCacheDegradation.requireDegradation(this, "Task is not compatible with the Configuration Cache");
         reports = getProject().getObjects().newInstance(DefaultBuildDashboardReports.class, Describables.quoted("Task", getIdentityPath()));
         reports.getHtml().getRequired().set(true);
     }
@@ -83,7 +86,7 @@ private Set<Report> getEnabledInputReports() {
 
     private Set<Reporting<? extends ReportContainer<?>>> getAggregatedTasks() {
         final Set<Reporting<? extends ReportContainer<?>>> reports = new HashSet<>();
-        getProject().allprojects(new Action<Project>() {
+        DeprecationLogger.whileDisabled(this::getProject).allprojects(new Action<Project>() {
             @Override
             public void execute(Project project) {
                 project.getTasks().all(new Action<Task>() {
diff --git a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/DependencyInsightReportTask.java b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/DependencyInsightReportTask.java
index b54ffbf2620..0b541e26090 100644
--- a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/DependencyInsightReportTask.java
+++ b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/DependencyInsightReportTask.java
@@ -30,7 +30,6 @@
 import org.gradle.api.artifacts.result.ResolvedVariantResult;
 import org.gradle.api.attributes.Attribute;
 import org.gradle.api.attributes.AttributeContainer;
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.artifacts.configurations.ConfigurationInternal;
 import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionComparator;
 import org.gradle.api.internal.artifacts.ivyservice.ivyresolve.strategy.VersionParser;
@@ -50,7 +49,9 @@
 import org.gradle.api.tasks.diagnostics.internal.dsl.DependencyResultSpecNotationConverter;
 import org.gradle.api.tasks.diagnostics.internal.graph.DependencyGraphsRenderer;
 import org.gradle.api.tasks.diagnostics.internal.graph.NodeRenderer;
+import org.gradle.api.tasks.diagnostics.internal.graph.nodes.DependencyReportHeader;
 import org.gradle.api.tasks.diagnostics.internal.graph.nodes.RenderableDependency;
+import org.gradle.api.tasks.diagnostics.internal.graph.nodes.RequestedVersion;
 import org.gradle.api.tasks.diagnostics.internal.graph.nodes.Section;
 import org.gradle.api.tasks.diagnostics.internal.insight.DependencyInsightReporter;
 import org.gradle.api.tasks.diagnostics.internal.text.StyledTable;
@@ -516,9 +517,11 @@ private void printVariant(
         }
 
         private AttributeContainer getRequestedAttributes(RenderableDependency dependency) {
-            if (dependency instanceof HasAttributes) {
-                AttributeContainer dependencyAttributes = ((HasAttributes) dependency).getAttributes();
+            if (dependency instanceof DependencyReportHeader) {
+                AttributeContainer dependencyAttributes = ((DependencyReportHeader) dependency).getAttributes();
                 return concat(configurationAttributes, dependencyAttributes);
+            } else if (dependency instanceof RequestedVersion) {
+                return ((RequestedVersion) dependency).getAttributes();
             }
             return configurationAttributes;
         }
diff --git a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/DependencyReportHeader.java b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/DependencyReportHeader.java
index 369fadc74d9..c11a41fd0ed 100644
--- a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/DependencyReportHeader.java
+++ b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/DependencyReportHeader.java
@@ -21,14 +21,13 @@
 import org.gradle.api.artifacts.component.ModuleComponentSelector;
 import org.gradle.api.artifacts.result.ResolvedVariantResult;
 import org.gradle.api.attributes.AttributeContainer;
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 import org.jspecify.annotations.NonNull;
 import org.jspecify.annotations.Nullable;
 
 import java.util.List;
 
-public class DependencyReportHeader extends AbstractRenderableDependency implements HasAttributes {
+public class DependencyReportHeader extends AbstractRenderableDependency {
     private final DependencyEdge dependency;
     private final String description;
     private final List<ResolvedVariantResult> selectedVariants;
@@ -74,7 +73,6 @@ public List<ResolvedVariantResult> getAllVariants() {
         return allVariants;
     }
 
-    @Override
     public AttributeContainer getAttributes() {
         ComponentSelector requested = dependency.getRequested();
         return requested instanceof ModuleComponentSelector
diff --git a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/RequestedVersion.java b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/RequestedVersion.java
index 029edbe6d2c..53b16a93eaa 100644
--- a/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/RequestedVersion.java
+++ b/platforms/software/software-diagnostics/src/main/java/org/gradle/api/tasks/diagnostics/internal/graph/nodes/RequestedVersion.java
@@ -20,13 +20,12 @@
 import org.gradle.api.artifacts.component.ComponentSelector;
 import org.gradle.api.artifacts.component.ModuleComponentSelector;
 import org.gradle.api.attributes.AttributeContainer;
-import org.gradle.api.attributes.HasAttributes;
 import org.gradle.api.internal.attributes.ImmutableAttributes;
 
 import java.util.LinkedHashSet;
 import java.util.Set;
 
-public class RequestedVersion extends AbstractRenderableDependencyResult implements HasAttributes {
+public class RequestedVersion extends AbstractRenderableDependencyResult {
     private final ComponentSelector requested;
     private final ComponentIdentifier actual;
     private final boolean resolvable;
@@ -62,7 +61,6 @@ public Set<RenderableDependency> getChildren() {
         return children;
     }
 
-    @Override
     public AttributeContainer getAttributes() {
         return requested instanceof ModuleComponentSelector
             ? requested.getAttributes()
diff --git a/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestCountLogger.java b/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestCountLogger.java
index c4d2fb8c5c4..c7f73f23f64 100644
--- a/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestCountLogger.java
+++ b/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestCountLogger.java
@@ -18,6 +18,7 @@
 
 import org.gradle.api.internal.DocumentationRegistry;
 import org.gradle.api.internal.tasks.testing.TestWorkerFailureException;
+import org.gradle.api.internal.tasks.testing.worker.ForkingTestClassProcessor;
 import org.gradle.api.tasks.testing.TestDescriptor;
 import org.gradle.api.tasks.testing.TestFailure;
 import org.gradle.api.tasks.testing.TestListener;
@@ -132,7 +133,7 @@ public void afterSuite(TestDescriptor suite, TestResult result) {
             // Looks like a test worker suite
             // TODO: Instead of assuming all failures at this level are worker failures, we should
             // identify worker failures in the TestFailureDetails
-            if (suite.getParent().getParent() == null) {
+            if (suite.getParent().getParent() == null && suite.getDisplayName().startsWith(ForkingTestClassProcessor.GRADLE_TEST_WORKER_NAME)) {
                 if (result.getResultType() == TestResult.ResultType.FAILURE) {
                     workerFailures.addAll(result.getFailures());
                 }
diff --git a/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/worker/ForkingTestClassProcessor.java b/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/worker/ForkingTestClassProcessor.java
index 577adb2978b..0cd658cf3d7 100644
--- a/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/worker/ForkingTestClassProcessor.java
+++ b/platforms/software/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/worker/ForkingTestClassProcessor.java
@@ -38,6 +38,8 @@
 import java.util.concurrent.locks.ReentrantLock;
 
 public class ForkingTestClassProcessor implements TestClassProcessor {
+    public static final String GRADLE_TEST_WORKER_NAME = "Gradle Test Executor";
+
     private final WorkerProcessFactory workerFactory;
     private final WorkerTestClassProcessorFactory processorFactory;
     private final JavaForkOptions options;
@@ -101,7 +103,7 @@ public void processTestClass(TestClassRunInfo testClass) {
 
     RemoteTestClassProcessor forkProcess() {
         WorkerProcessBuilder builder = workerFactory.create(new TestWorker(processorFactory));
-        builder.setBaseName("Gradle Test Executor");
+        builder.setBaseName(GRADLE_TEST_WORKER_NAME);
         builder.setImplementationClasspath(classpath.getImplementationClasspath());
         builder.applicationClasspath(classpath.getApplicationClasspath());
         builder.applicationModulePath(classpath.getApplicationModulepath());
diff --git a/released-versions.json b/released-versions.json
index 18cc2fdc509..223408c96c8 100644
--- a/released-versions.json
+++ b/released-versions.json
@@ -1,7 +1,7 @@
 {
   "latestReleaseSnapshot": {
-    "version": "9.0.0-20250712014520+0000",
-    "buildTime": "20250712014520+0000"
+    "version": "9.0.0-20250715101636+0000",
+    "buildTime": "20250715101636+0000"
   },
   "latestRc": {
     "version": "9.0.0-rc-2",
diff --git a/settings.gradle.kts b/settings.gradle.kts
index b238b66a051..98c2f2ed33b 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -29,7 +29,7 @@ buildscript {
 plugins {
     id("gradlebuild.build-environment")
     id("gradlebuild.configuration-cache-compatibility")
-    id("com.gradle.develocity").version("4.0.2") // Run `java build-logic-settings/UpdateDevelocityPluginVersion.java <new-version>` to update
+    id("com.gradle.develocity").version("4.1") // Run `java build-logic-settings/UpdateDevelocityPluginVersion.java <new-version>` to update
     id("io.github.gradle.gradle-enterprise-conventions-plugin").version("0.10.2")
     id("org.gradle.toolchains.foojay-resolver-convention").version("1.0.0")
 }
diff --git a/subprojects/core/src/integTest/groovy/org/gradle/api/ProjectModuleIdentityIntegrationTest.groovy b/subprojects/core/src/integTest/groovy/org/gradle/api/ProjectModuleIdentityIntegrationTest.groovy
deleted file mode 100644
index 726456c1a29..00000000000
--- a/subprojects/core/src/integTest/groovy/org/gradle/api/ProjectModuleIdentityIntegrationTest.groovy
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright 2025 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.gradle.api
-
-import org.gradle.integtests.fixtures.AbstractIntegrationSpec
-
-/**
- * Tests project behavior related to module identity:
- * <ul>
- *     <li>{@link Project#getGroup()}</li>
- *     <li>{@link Project#getVersion()}</li>
- * <ul>
- */
-class ProjectModuleIdentityIntegrationTest extends AbstractIntegrationSpec {
-
-    def "default group for root project is an empty string"() {
-        buildFile << """
-            assert group == ""
-        """
-
-        expect:
-        succeeds("help")
-    }
-
-    def "default group for subproject is based on project structure"() {
-        given:
-        settingsFile << """
-            rootProject.name = "root"
-            include(":sub")
-            include(":sub:subsub")
-        """
-
-        file("sub/build.gradle") << """
-            assert group == "root"
-        """
-        file("sub/subsub/build.gradle") << """
-            assert group == "root.sub"
-        """
-
-        expect:
-        succeeds("help")
-    }
-
-    def "default version for root project is 'unspecified'"() {
-        buildFile << """
-            assert version == "unspecified"
-        """
-
-        expect:
-        succeeds("help")
-    }
-
-}
diff --git a/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java b/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
index 7967f60a37f..9670d5cf54a 100644
--- a/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
+++ b/subprojects/core/src/main/java/org/gradle/api/internal/project/DefaultProject.java
@@ -141,8 +141,6 @@
 import java.util.TreeMap;
 import java.util.TreeSet;
 import java.util.concurrent.Callable;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import static com.google.common.base.Strings.isNullOrEmpty;
 import static java.util.Collections.singletonMap;
@@ -177,7 +175,7 @@ public abstract class DefaultProject extends AbstractPluginAware implements Proj
 
     private final String name;
 
-    private @Nullable Object group;
+    private Object group;
 
     private Object version;
 
@@ -476,22 +474,13 @@ public void setDescription(@Nullable String description) {
     @Override
     public Object getGroup() {
         onMutableStateAccess();
-        if (group == null) {
-            group = getDefaultGroup();
-        }
-        return group;
-    }
-
-    private String getDefaultGroup() {
-        ProjectInternal parent = getParent();
-        if (parent == null) {
+        if (group != null) {
+            return group;
+        } else if (this == rootProject) {
             return "";
         }
-
-        return Stream.concat(
-            Stream.of(rootProject.getName()),
-            parent.getProjectIdentity().getProjectPath().segments().stream()
-        ).collect(Collectors.joining("."));
+        group = rootProject.getName() + (getParent() == rootProject ? "" : "." + getParent().getPath().substring(1).replace(':', '.'));
+        return group;
     }
 
     @Override
diff --git a/subprojects/core/src/main/java/org/gradle/plugin/management/internal/autoapply/AutoAppliedDevelocityPlugin.java b/subprojects/core/src/main/java/org/gradle/plugin/management/internal/autoapply/AutoAppliedDevelocityPlugin.java
index c167c4fe756..a92ec99fb97 100644
--- a/subprojects/core/src/main/java/org/gradle/plugin/management/internal/autoapply/AutoAppliedDevelocityPlugin.java
+++ b/subprojects/core/src/main/java/org/gradle/plugin/management/internal/autoapply/AutoAppliedDevelocityPlugin.java
@@ -28,7 +28,7 @@ public final class AutoAppliedDevelocityPlugin {
 
     public static final String GROUP = "com.gradle";
     public static final String NAME = "develocity-gradle-plugin";
-    public static final String VERSION = "4.0.2";
+    public static final String VERSION = "4.1";
 
 
     public static final PluginId ID = new DefaultPluginId("com.gradle.develocity");
diff --git a/subprojects/core/src/test/groovy/org/gradle/api/internal/project/DefaultProjectTest.groovy b/subprojects/core/src/test/groovy/org/gradle/api/internal/project/DefaultProjectTest.groovy
index 91226f55bbb..0b33a404e3a 100644
--- a/subprojects/core/src/test/groovy/org/gradle/api/internal/project/DefaultProjectTest.groovy
+++ b/subprojects/core/src/test/groovy/org/gradle/api/internal/project/DefaultProjectTest.groovy
@@ -39,7 +39,6 @@ import org.gradle.api.internal.CollectionCallbackActionDecorator
 import org.gradle.api.internal.FactoryNamedDomainObjectContainer
 import org.gradle.api.internal.GradleInternal
 import org.gradle.api.internal.ProcessOperations
-import org.gradle.api.internal.artifacts.DefaultBuildIdentifier
 import org.gradle.api.internal.artifacts.configurations.RoleBasedConfigurationContainerInternal
 import org.gradle.api.internal.collections.DomainObjectCollectionFactory
 import org.gradle.api.internal.file.DefaultProjectLayout
@@ -289,40 +288,11 @@ class DefaultProjectTest extends Specification {
         }
     }
 
-    private DefaultProject defaultProject(
-        String name,
-        ProjectState owner,
-        ProjectInternal parent,
-        File rootDir,
-        ClassLoaderScope scope
-    ) {
-        def identityPath = parent == null ? Path.ROOT : parent.identityPath.child(name)
-        def projectPath = parent == null ? Path.ROOT : parent.projectPath.child(name)
-        def identity = new ProjectIdentity(
-            DefaultBuildIdentifier.ROOT,
-            identityPath,
-            projectPath,
-            name
-        )
-
-        _ * owner.identity >> identity
-        _ * owner.identityPath >> identity.buildTreePath
-        _ * owner.projectPath >> identity.projectPath
+    private DefaultProject defaultProject(String name, ProjectState owner, ProjectInternal parent, File rootDir, ClassLoaderScope scope) {
+        _ * owner.identityPath >> (parent == null ? Path.ROOT : parent.identityPath.child(name))
+        _ * owner.projectPath >> (parent == null ? Path.ROOT : parent.projectPath.child(name))
         _ * owner.depth >> owner.projectPath.segmentCount()
-
-        def project = TestUtil.instantiatorFactory().decorateLenient().newInstance(
-            DefaultProject,
-            name,
-            parent,
-            rootDir,
-            new File(rootDir, 'build.gradle'),
-            script,
-            build,
-            owner,
-            projectServiceRegistryFactoryMock,
-            scope,
-            baseClassLoaderScope
-        )
+        def project = TestUtil.instantiatorFactory().decorateLenient().newInstance(DefaultProject, name, parent, rootDir, new File(rootDir, 'build.gradle'), script, build, owner, projectServiceRegistryFactoryMock, scope, baseClassLoaderScope)
         _ * owner.applyToMutableState(_) >> { Consumer action -> action.accept(project) }
         return project
     }
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/AllDistributionIntegrationSpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/AllDistributionIntegrationSpec.groovy
index d293c9e6ecc..d7593c02e75 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/AllDistributionIntegrationSpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/AllDistributionIntegrationSpec.groovy
@@ -38,7 +38,7 @@ class AllDistributionIntegrationSpec extends DistributionIntegrationSpec {
 
     @Override
     int getDistributionSizeMiB() {
-        return 216
+        return 218
     }
 
     @Requires(UnitTestPreconditions.StableGroovy) // cannot link to public javadocs of Groovy snapshots like https://docs.groovy-lang.org/docs/groovy-4.0.5-SNAPSHOT/html/gapi/
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/BinDistributionIntegrationSpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/BinDistributionIntegrationSpec.groovy
index 7deadee78e5..d098b41d504 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/BinDistributionIntegrationSpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/BinDistributionIntegrationSpec.groovy
@@ -34,7 +34,7 @@ class BinDistributionIntegrationSpec extends DistributionIntegrationSpec {
 
     @Override
     int getDistributionSizeMiB() {
-        return 130
+        return 128
     }
 
     def binZipContents() {
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegrationSpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegrationSpec.groovy
index af830880ad3..3f31c83a1bb 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegrationSpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegrationSpec.groovy
@@ -186,11 +186,14 @@ abstract class DistributionIntegrationSpec extends AbstractIntegrationSpec {
 
     def "distribution size should not change too much"() {
         expect:
-        def actual = (int) Math.ceil((double) getZip().size() / 1024 / 1024)
-        def expected = getDistributionSizeMiB()
+        def actualKB = (int) Math.ceil((double) getZip().size() / 1024)
+        def expectedKB = getDistributionSizeMiB() * 1024
 
-        assert actual <= expected + 1: "Distribution is at least 1MiB larger, content needs to be verified. Current size: ${actual} MiB. Expected size: ${expected} MiB."
-        assert actual >= expected - 1: "Distribution is  at least 1MiB smaller, content needs to be verified. Current size: ${actual} MiB. Expected size: ${expected} MiB."
+        int margin = buildContext.version.isSnapshot() ? 1024 : 2048 // Allow 1 MiB margin for current dev, 2 MiB for more stable releases (promotion builds)
+        def message = "content needs to be verified. Current size: ${(int) (actualKB / 1024)} MiB (${actualKB} KiB). Expected size: ${getDistributionSizeMiB()}  ${margin / 1024} MiB."
+
+        assert actualKB <= expectedKB + margin: "Distribution is unexpectedly larger, $message"
+        assert actualKB >= expectedKB - margin: "Distribution is unexpectedly smaller, $message"
     }
 
     def "no duplicate jar entries in distribution"() {
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegritySpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegritySpec.groovy
index 41b2adf8c03..91a3782d2ee 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegritySpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/DistributionIntegritySpec.groovy
@@ -38,7 +38,7 @@ class DistributionIntegritySpec extends DistributionIntegrationSpec {
 
     @Override
     int getDistributionSizeMiB() {
-        return 130
+        return 128
     }
 
     /**
diff --git a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/SrcDistributionIntegrationSpec.groovy b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/SrcDistributionIntegrationSpec.groovy
index ac9429dfe76..a9804fb2ea9 100644
--- a/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/SrcDistributionIntegrationSpec.groovy
+++ b/testing/distributions-integ-tests/src/integTest/groovy/org/gradle/SrcDistributionIntegrationSpec.groovy
@@ -39,7 +39,7 @@ class SrcDistributionIntegrationSpec extends DistributionIntegrationSpec {
 
     @Override
     int getDistributionSizeMiB() {
-        return 65
+        return 66
     }
 
     @Override
diff --git a/testing/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/WellBehavedPluginTest.groovy b/testing/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/WellBehavedPluginTest.groovy
index ba9870b6ede..76cc0f9ca11 100644
--- a/testing/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/WellBehavedPluginTest.groovy
+++ b/testing/internal-integ-testing/src/main/groovy/org/gradle/integtests/fixtures/WellBehavedPluginTest.groovy
@@ -43,7 +43,6 @@ abstract class WellBehavedPluginTest extends AbstractIntegrationSpec {
     }
 
     @ToBeFixedForConfigurationCache(bottomSpecs = [
-        "BuildDashboardPluginIntegrationTest",
         "ScalaPluginGoodBehaviourTest",
         "AntlrPluginIntegrationTest",
         "PlayApplicationPluginGoodBehaviourIntegrationTest",
@@ -71,7 +70,6 @@ abstract class WellBehavedPluginTest extends AbstractIntegrationSpec {
     }
 
     @ToBeFixedForConfigurationCache(bottomSpecs = [
-        "BuildDashboardPluginIntegrationTest",
         "ScalaPluginGoodBehaviourTest",
         "AntlrPluginIntegrationTest",
         "PlayApplicationPluginGoodBehaviourIntegrationTest",
diff --git a/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/AbstractSmokeTest.groovy b/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/AbstractSmokeTest.groovy
index f1e9105522e..732fce62a5a 100644
--- a/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/AbstractSmokeTest.groovy
+++ b/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/AbstractSmokeTest.groovy
@@ -48,7 +48,7 @@ abstract class AbstractSmokeTest extends Specification {
     static class TestedVersions {
         /**
          * May also need to update
-         * @see BuildScanPluginSmokeTest
+         * @see DevelocityPluginSmokeTest
          */
 
         // https://plugins.gradle.org/plugin/biz.aQute.bnd
diff --git a/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/BuildScanPluginSmokeTest.groovy b/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/DevelocityPluginSmokeTest.groovy
similarity index 87%
rename from testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/BuildScanPluginSmokeTest.groovy
rename to testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/DevelocityPluginSmokeTest.groovy
index fd528764ef0..7956af78dc8 100644
--- a/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/BuildScanPluginSmokeTest.groovy
+++ b/testing/smoke-test/src/smokeTest/groovy/org/gradle/smoketests/DevelocityPluginSmokeTest.groovy
@@ -26,12 +26,13 @@ import org.gradle.testkit.runner.BuildResult
 import org.gradle.testkit.runner.TaskOutcome
 import org.gradle.util.GradleVersion
 import org.gradle.util.internal.VersionNumber
+import spock.lang.Issue
 
 import java.nio.charset.StandardCharsets
 import java.util.concurrent.ConcurrentHashMap
 
 // https://plugins.gradle.org/plugin/com.gradle.develocity
-class BuildScanPluginSmokeTest extends AbstractSmokeTest {
+class DevelocityPluginSmokeTest extends AbstractSmokeTest {
 
     enum CI {
         TEAM_CITY(
@@ -155,7 +156,8 @@ class BuildScanPluginSmokeTest extends AbstractSmokeTest {
         "3.19.2",
         "4.0",
         "4.0.1",
-        "4.0.2"
+        "4.0.2",
+        "4.1"
     ]
 
     // Current injection scripts support Develocity plugin 3.6.4 and above
@@ -184,6 +186,75 @@ class BuildScanPluginSmokeTest extends AbstractSmokeTest {
         version << SUPPORTED
     }
 
+    @Issue("https://github.com/gradle/gradle/issues/34252")
+    def "does not fail when using TD #version"() {
+        when:
+        usePluginVersion version
+
+        buildFile << """
+            dependencies {
+                testImplementation("org.testng:testng:7.5.1")
+                testRuntimeOnly("org.junit.support:testng-engine:1.0.6")
+            }
+
+            tasks.named("test") {
+                develocity {
+                    testDistribution {
+                        enabled = true
+                        maxRemoteExecutors = 0
+                    }
+                    testRetry {
+                        maxRetries = 1
+                    }
+                }
+            }
+        """
+
+        // The underlying problem is reproducible with a TestNG based test
+        file("src/test/java/MyFlakyTest.java").java """
+import org.testng.annotations.AfterSuite;
+import org.testng.annotations.Test;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+public class MyFlakyTest {
+
+    private static final Path LIFECYCLE_MARKER_FILE = Paths.get("flakyLifecycleMarker.txt");
+    private static final Path TEST_MARKER_FILE = Paths.get("flakyTestMarker.txt");
+
+    @AfterSuite
+    public static void flakyAfterSuite() throws IOException {
+        if (!Files.exists(LIFECYCLE_MARKER_FILE)) {
+            Files.createFile(LIFECYCLE_MARKER_FILE);
+            throw new RuntimeException("AfterSuite goes boom!");
+        }
+    }
+
+    @Test
+    public void flakyTest() throws IOException {
+        if (!Files.exists(TEST_MARKER_FILE)) {
+            Files.createFile(TEST_MARKER_FILE);
+            throw new RuntimeException("test goes boom!");
+        }
+    }
+
+    @Test
+    public void successfulTest() {
+
+    }
+}
+        """
+
+        then:
+        scanRunner("test").build()
+
+        where:
+        version << SUPPORTED.grep { String version -> VersionNumber.parse(version) >= FIRST_VERSION_UNDER_DEVELOCITY_BRAND }
+    }
+
     @Requires(value = IntegTestPreconditions.NotConfigCached, reason = "Isolated projects implies config cache")
     def "can use plugin #version with isolated projects"() {
         when:
@@ -453,8 +524,12 @@ class BuildScanPluginSmokeTest extends AbstractSmokeTest {
             apply plugin: 'java'
             ${mavenCentralRepository()}
 
-            dependencies {
-                testImplementation 'junit:junit:4.13'
+            testing {
+                suites {
+                    test {
+                        useJUnitJupiter()
+                    }
+                }
             }
         """
 
@@ -469,13 +544,14 @@ class BuildScanPluginSmokeTest extends AbstractSmokeTest {
     }
 
     void createTest(TestFile projectDir, String testName) {
-        projectDir.file("src/test/java/${testName}.java") << """
-            import org.junit.*;
+        projectDir.file("src/test/java/${testName}.java").java"""
+            import org.junit.jupiter.api.*;
+            import static org.junit.jupiter.api.Assertions.*;
 
             public class ${testName} {
                @Test
                public void test() {
-                  Assert.assertTrue(MySource.isTrue());
+                  assertTrue(MySource.isTrue());
                }
             }
         """
