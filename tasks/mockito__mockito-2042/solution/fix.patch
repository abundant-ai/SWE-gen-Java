diff --git a/doc/release-notes/official.md b/doc/release-notes/official.md
index 8601f484e..63b011342 100644
--- a/doc/release-notes/official.md
+++ b/doc/release-notes/official.md
@@ -1,10 +1,5 @@
 <sup><sup>*Release notes were automatically generated by [Shipkit](http://shipkit.org/)*</sup></sup>
 
-#### 3.5.11
- - 2020-09-17 - [2 commits](https://github.com/mockito/mockito/compare/v3.5.10...v3.5.11) by [Rafael Winterhalter](https://github.com/raphw) - published to [![Bintray](https://img.shields.io/badge/Bintray-3.5.11-green.svg)](https://bintray.com/mockito/maven/mockito/3.5.11)
- - Do not exclude synthetic constructors from instrumentation. Fixes #2040. [(#2046)](https://github.com/mockito/mockito/pull/2046)
- - Mockito.spy(Activity).getBaseContext() returns null on Robolectric 4.4 and Java8 [(#2040)](https://github.com/mockito/mockito/issues/2040)
-
 #### 3.5.10
  - 2020-09-03 - [2 commits](https://github.com/mockito/mockito/compare/v3.5.9...v3.5.10) by [Rafael Winterhalter](https://github.com/raphw) - published to [![Bintray](https://img.shields.io/badge/Bintray-3.5.10-green.svg)](https://bintray.com/mockito/maven/mockito/3.5.10)
  - Escape mock during method dispatch on mock to avoid premature garbage collection. [(#2034)](https://github.com/mockito/mockito/pull/2034)
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/PluginFinder.java b/src/main/java/org/mockito/internal/configuration/plugins/PluginFinder.java
index 7385afb18..3ca2ac5cd 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/PluginFinder.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/PluginFinder.java
@@ -6,6 +6,8 @@ package org.mockito.internal.configuration.plugins;
 
 import java.io.InputStream;
 import java.net.URL;
+import java.util.ArrayList;
+import java.util.List;
 
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.io.IOUtil;
@@ -43,4 +45,30 @@ class PluginFinder {
         }
         return null;
     }
+
+    List<String> findPluginClasses(Iterable<URL> resources) {
+        List<String> pluginClassNames = new ArrayList<>();
+        for (URL resource : resources) {
+            InputStream s = null;
+            try {
+                s = resource.openStream();
+                String pluginClassName = new PluginFileReader().readPluginClass(s);
+                if (pluginClassName == null) {
+                    // For backwards compatibility
+                    // If the resource does not have plugin class name we're ignoring it
+                    continue;
+                }
+                if (!pluginSwitch.isEnabled(pluginClassName)) {
+                    continue;
+                }
+                pluginClassNames.add(pluginClassName);
+            } catch (Exception e) {
+                throw new MockitoException(
+                        "Problems reading plugin implementation from: " + resource, e);
+            } finally {
+                IOUtil.closeQuietly(s);
+            }
+        }
+        return pluginClassNames;
+    }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/PluginInitializer.java b/src/main/java/org/mockito/internal/configuration/plugins/PluginInitializer.java
index 8f8f76edc..296397edc 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/PluginInitializer.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/PluginInitializer.java
@@ -6,7 +6,9 @@ package org.mockito.internal.configuration.plugins;
 
 import java.io.IOException;
 import java.net.URL;
+import java.util.ArrayList;
 import java.util.Enumeration;
+import java.util.List;
 
 import org.mockito.internal.util.collections.Iterables;
 import org.mockito.plugins.PluginSwitch;
@@ -56,4 +58,36 @@ class PluginInitializer {
                     "Failed to load " + service + " implementation declared in " + resources, e);
         }
     }
+
+    public <T> List<T> loadImpls(Class<T> service) {
+        ClassLoader loader = Thread.currentThread().getContextClassLoader();
+        if (loader == null) {
+            loader = ClassLoader.getSystemClassLoader();
+        }
+        Enumeration<URL> resources;
+        try {
+            resources = loader.getResources("mockito-extensions/" + service.getName());
+        } catch (IOException e) {
+            throw new IllegalStateException("Failed to load " + service, e);
+        }
+
+        try {
+            List<String> classesOrAliases =
+                    new PluginFinder(pluginSwitch)
+                            .findPluginClasses(Iterables.toIterable(resources));
+            List<T> impls = new ArrayList<>();
+            for (String classOrAlias : classesOrAliases) {
+                if (classOrAlias.equals(alias)) {
+                    classOrAlias = plugins.getDefaultPluginClass(alias);
+                }
+                Class<?> pluginClass = loader.loadClass(classOrAlias);
+                Object plugin = pluginClass.getDeclaredConstructor().newInstance();
+                impls.add(service.cast(plugin));
+            }
+            return impls;
+        } catch (Exception e) {
+            throw new IllegalStateException(
+                    "Failed to load " + service + " implementation declared in " + resources, e);
+        }
+    }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java b/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java
index 3d724aa49..e76bb9729 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/PluginLoader.java
@@ -7,6 +7,8 @@ package org.mockito.internal.configuration.plugins;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
+import java.util.Collections;
+import java.util.List;
 
 import org.mockito.plugins.PluginSwitch;
 
@@ -90,4 +92,32 @@ class PluginLoader {
                     });
         }
     }
+
+    /**
+     * Scans the classpath for given {@code pluginType} and returns a list of its instances.
+     *
+     * @return An list of {@code pluginType} or an empty list if none was found.
+     */
+    @SuppressWarnings("unchecked")
+    <T> List<T> loadPlugins(final Class<T> pluginType) {
+        try {
+            return initializer.loadImpls(pluginType);
+        } catch (final Throwable t) {
+            return Collections.singletonList(
+                    (T)
+                            Proxy.newProxyInstance(
+                                    pluginType.getClassLoader(),
+                                    new Class<?>[] {pluginType},
+                                    new InvocationHandler() {
+                                        @Override
+                                        public Object invoke(
+                                                Object proxy, Method method, Object[] args)
+                                                throws Throwable {
+                                            throw new IllegalStateException(
+                                                    "Could not initialize plugin: " + pluginType,
+                                                    t);
+                                        }
+                                    }));
+        }
+    }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/PluginRegistry.java b/src/main/java/org/mockito/internal/configuration/plugins/PluginRegistry.java
index ba7aae172..9a12d1755 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/PluginRegistry.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/PluginRegistry.java
@@ -7,6 +7,8 @@ package org.mockito.internal.configuration.plugins;
 import org.mockito.internal.creation.instance.InstantiatorProviderAdapter;
 import org.mockito.plugins.*;
 
+import java.util.List;
+
 class PluginRegistry {
 
     private final PluginSwitch pluginSwitch =
@@ -31,6 +33,9 @@ class PluginRegistry {
     private final MockitoLogger mockitoLogger =
             new PluginLoader(pluginSwitch).loadPlugin(MockitoLogger.class);
 
+    private final List<MockResolver> mockResolvers =
+            new PluginLoader(pluginSwitch).loadPlugins(MockResolver.class);
+
     PluginRegistry() {
         Object impl =
                 new PluginLoader(pluginSwitch)
@@ -100,4 +105,13 @@ class PluginRegistry {
     MockitoLogger getMockitoLogger() {
         return mockitoLogger;
     }
+
+    /**
+     * Returns a list of available mock resolvers if any.
+     *
+     * @return A list of available mock resolvers or an empty list if none are registered.
+     */
+    List<MockResolver> getMockResolvers() {
+        return mockResolvers;
+    }
 }
diff --git a/src/main/java/org/mockito/internal/configuration/plugins/Plugins.java b/src/main/java/org/mockito/internal/configuration/plugins/Plugins.java
index 603a03008..da225a288 100644
--- a/src/main/java/org/mockito/internal/configuration/plugins/Plugins.java
+++ b/src/main/java/org/mockito/internal/configuration/plugins/Plugins.java
@@ -6,6 +6,8 @@ package org.mockito.internal.configuration.plugins;
 
 import org.mockito.plugins.*;
 
+import java.util.List;
+
 /**
  * Access to Mockito behavior that can be reconfigured by plugins
  */
@@ -71,6 +73,15 @@ public class Plugins {
         return registry.getMockitoLogger();
     }
 
+    /**
+     * Returns a list of available mock resolvers if any.
+     *
+     * @return A list of available mock resolvers or an empty list if none are registered.
+     */
+    public static List<MockResolver> getMockResolvers() {
+        return registry.getMockResolvers();
+    }
+
     /**
      * @return instance of mockito plugins type
      */
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
index 2bf9d1576..067dea7a0 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
@@ -91,8 +91,7 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
                 new ByteBuddy()
                         .with(TypeValidation.DISABLED)
                         .with(Implementation.Context.Disabled.Factory.INSTANCE)
-                        .with(MethodGraph.Compiler.ForDeclaredMethods.INSTANCE)
-                        .ignore(isSynthetic().and(not(isConstructor())).or(isDefaultFinalizer()));
+                        .with(MethodGraph.Compiler.ForDeclaredMethods.INSTANCE);
         mocked = new WeakConcurrentSet<>(WeakConcurrentSet.Cleaner.INLINE);
         flatMocked = new WeakConcurrentSet<>(WeakConcurrentSet.Cleaner.INLINE);
         String identifier = RandomString.make();
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
index a12c70199..9323368a1 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
@@ -400,6 +400,9 @@ public class MockMethodAdvice extends MockMethodDispatcher {
                 boolean packagePrivate = true;
                 MethodDescription.InDefinedShape current = null;
                 for (MethodDescription.InDefinedShape constructor : constructors) {
+                    // We are choosing the shortest constructor with regards to arguments.
+                    // Yet, we prefer a non-package-private constructor since they require
+                    // the super class to be on the same class loader.
                     if (constructor.getParameters().size() < arguments
                             && (packagePrivate || !constructor.isPackagePrivate())) {
                         arguments = constructor.getParameters().size();
diff --git a/src/main/java/org/mockito/internal/util/DefaultMockingDetails.java b/src/main/java/org/mockito/internal/util/DefaultMockingDetails.java
index e9887a57b..1ad5a757f 100644
--- a/src/main/java/org/mockito/internal/util/DefaultMockingDetails.java
+++ b/src/main/java/org/mockito/internal/util/DefaultMockingDetails.java
@@ -73,7 +73,7 @@ public class DefaultMockingDetails implements MockingDetails {
         return toInspect;
     }
 
-    private MockHandler<Object> mockHandler() {
+    private MockHandler<?> mockHandler() {
         assertGoodMock();
         return MockUtil.getMockHandler(toInspect);
     }
diff --git a/src/main/java/org/mockito/internal/util/MockUtil.java b/src/main/java/org/mockito/internal/util/MockUtil.java
index 46e782cba..25a29d2c0 100644
--- a/src/main/java/org/mockito/internal/util/MockUtil.java
+++ b/src/main/java/org/mockito/internal/util/MockUtil.java
@@ -16,6 +16,7 @@ import org.mockito.mock.MockCreationSettings;
 import org.mockito.mock.MockName;
 import org.mockito.plugins.MockMaker;
 import org.mockito.plugins.MockMaker.TypeMockability;
+import org.mockito.plugins.MockResolver;
 
 import java.util.function.Function;
 
@@ -55,21 +56,25 @@ public class MockUtil {
         return mock;
     }
 
-    public static <T> void resetMock(T mock) {
+    public static void resetMock(Object mock) {
         MockHandler oldHandler = getMockHandler(mock);
         MockCreationSettings settings = oldHandler.getMockSettings();
         MockHandler newHandler = createMockHandler(settings);
 
+        mock = resolve(mock);
         mockMaker.resetMock(mock, newHandler, settings);
     }
 
-    public static <T> MockHandler<T> getMockHandler(T mock) {
+    public static MockHandler<?> getMockHandler(Object mock) {
         if (mock == null) {
             throw new NotAMockException("Argument should be a mock, but is null!");
         }
 
-        if (isMock(mock)) {
-            return mockMaker.getHandler(mock);
+        mock = resolve(mock);
+
+        MockHandler handler = mockMaker.getHandler(mock);
+        if (handler != null) {
+            return handler;
         } else {
             throw new NotAMockException("Argument should be a mock, but is: " + mock.getClass());
         }
@@ -96,7 +101,23 @@ public class MockUtil {
         // Potentially we could also move other methods to MockitoMock, some other candidates:
         // getInvocationContainer, isSpy, etc.
         // This also allows us to reuse our public API MockingDetails
-        return mock != null && mockMaker.getHandler(mock) != null;
+        if (mock == null) {
+            return false;
+        }
+
+        mock = resolve(mock);
+
+        return mockMaker.getHandler(mock) != null;
+    }
+
+    private static Object resolve(Object mock) {
+        if (mock instanceof Class<?>) { // static mocks are resolved by definition
+            return mock;
+        }
+        for (MockResolver mockResolver : Plugins.getMockResolvers()) {
+            mock = mockResolver.resolve(mock);
+        }
+        return mock;
     }
 
     public static MockName getMockName(Object mock) {
diff --git a/src/main/java/org/mockito/plugins/MockMaker.java b/src/main/java/org/mockito/plugins/MockMaker.java
index fbdaf1d0e..fcebbb3ae 100644
--- a/src/main/java/org/mockito/plugins/MockMaker.java
+++ b/src/main/java/org/mockito/plugins/MockMaker.java
@@ -85,7 +85,7 @@ public interface MockMaker {
      *                {@link #getHandler(Object)} will return this instance.
      * @param instance  The object to spy upon.
      * @param <T> Type of the mock to return, actually the <code>settings.getTypeToMock</code>.
-     * @return
+     * @return The spy instance, if this mock maker supports direct spy creation.
      * @since 3.5.0
      */
     default <T> Optional<T> createSpy(
diff --git a/src/main/java/org/mockito/plugins/MockResolver.java b/src/main/java/org/mockito/plugins/MockResolver.java
new file mode 100644
index 000000000..6eaa756f7
--- /dev/null
+++ b/src/main/java/org/mockito/plugins/MockResolver.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2020 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.plugins;
+
+/**
+ * A mock resolver offers an opportunity to resolve a mock from any instance that is
+ * provided to the {@link org.mockito.Mockito}-DSL. This mechanism can be used by
+ * frameworks that provide mocks that are implemented by Mockito but which are wrapped
+ * by other instances to enhance the proxy further.
+ */
+public interface MockResolver {
+
+    /**
+     * Returns the provided instance or the unwrapped mock that the provided
+     * instance represents. This method must not return {@code null}.
+     * @param instance The instance passed to the {@link org.mockito.Mockito}-DSL.
+     * @return The provided instance or the unwrapped mock.
+     */
+    Object resolve(Object instance);
+}
diff --git a/version.properties b/version.properties
index f7a642406..087c94e06 100644
--- a/version.properties
+++ b/version.properties
@@ -1,5 +1,5 @@
 # Currently building Mockito version
-version=3.5.12
+version=3.5.11
 
 # Previous version used to generate release notes delta
-previousVersion=3.5.11
+previousVersion=3.5.10
