diff --git a/docs/src/main/asciidoc/cdi-reference.adoc b/docs/src/main/asciidoc/cdi-reference.adoc
index 76a4f5cd53c..aaff0fa3caf 100644
--- a/docs/src/main/asciidoc/cdi-reference.adoc
+++ b/docs/src/main/asciidoc/cdi-reference.adoc
@@ -718,7 +718,8 @@ public class TracerConfiguration {
 
 NOTE: The runtime profile has absolutely no effect on the bean resolution using `@IfBuildProfile` and `@UnlessBuildProfile`.
 
-TIP: It is also possible to use `@IfBuildProfile` and `@UnlessBuildProfile` on stereotypes.
+TIP: `@IfBuildProfile` and `@UnlessBuildProfile` may be put on a stereotype.
+A bean will only be enabled if **all** the conditions defined by these annotations are satisfied.
 
 [[enable_build_properties]]
 === Enabling Beans for Quarkus Build Properties
@@ -748,7 +749,8 @@ public class TracerConfiguration {
 }
 ----
 
-TIP: `@IfBuildProperty` and `@UnlessBuildProperty` are repeatable annotations, i.e. a bean will only be enabled if **all** the conditions defined by these annotations are satisfied.
+TIP: `@IfBuildProperty` and `@UnlessBuildProperty` are repeatable annotations and may be put on a stereotype.
+A bean will only be enabled if **all** the conditions defined by these annotations are satisfied.
 
 If instead, it is required that the `RealTracer` bean is only used if the `some.tracer.enabled` property is not `false`, then `@UnlessBuildProperty` would be ideal. The code would look like:
 
@@ -771,9 +773,7 @@ public class TracerConfiguration {
 }
 ----
 
-NOTE: Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty`.
-
-TIP: It is also possible to use `@IfBuildProperty` and `@UnlessBuildProperty` on stereotypes.
+NOTE: Properties set at runtime have absolutely no effect on the bean resolution using `@IfBuildProperty` / `@UnlessBuildProperty`.
 
 === Declaring Selected Alternatives
 
@@ -1065,6 +1065,9 @@ Alternatively, you can use the `@LookupIfProperty` and `@LookupUnlessProperty` a
  }
 ----
 
+TIP: `@LookupIfProperty` and `@LookupUnlessProperty` are repeatable annotations and may be put on a stereotype.
+A bean will only be obtained if **all** the conditions defined by these annotations are satisfied.
+
 === Sorting beans obtained with programmatic lookup
 
 If there is more than one bean that matches the required type and qualifiers and is eligible for injection, it is possible to iterate (or stream) available bean instances.
diff --git a/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java b/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java
index 0aabb8a88f3..24c7f5baf9f 100644
--- a/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java
+++ b/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/BuildTimeEnabledProcessor.java
@@ -15,24 +15,27 @@
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
-import java.util.function.Function;
+import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
+import jakarta.enterprise.inject.Vetoed;
+
 import org.eclipse.microprofile.config.Config;
 import org.eclipse.microprofile.config.spi.ConfigProviderResolver;
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationTarget.Kind;
+import org.jboss.jandex.AnnotationTransformation;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
+import org.jboss.jandex.Declaration;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.EquivalenceKey;
 import org.jboss.jandex.IndexView;
 import org.jboss.logging.Logger;
 
-import io.quarkus.arc.processor.AnnotationsTransformer;
+import io.quarkus.arc.VetoedProducer;
 import io.quarkus.arc.processor.DotNames;
-import io.quarkus.arc.processor.Transformation;
 import io.quarkus.arc.profile.IfBuildProfile;
 import io.quarkus.arc.profile.UnlessBuildProfile;
 import io.quarkus.arc.properties.IfBuildProperty;
@@ -60,16 +63,13 @@ public class BuildTimeEnabledProcessor {
 
     @BuildStep
     BuildTimeEnabledStereotypesBuildItem findEnablementStereotypes(CombinedIndexBuildItem combinedIndex) {
-        IndexView index = combinedIndex.getIndex();
+        IndexView index = combinedIndex.getComputingIndex();
 
         // find all stereotypes
         Set<DotName> stereotypeNames = new HashSet<>();
         for (AnnotationInstance annotation : index.getAnnotations(DotNames.STEREOTYPE)) {
-            if (annotation.target() != null
-                    && annotation.target().kind() == Kind.CLASS
-                    && annotation.target().asClass().isAnnotation()) {
-                stereotypeNames.add(annotation.target().asClass().name());
-            }
+            // `Stereotype` is `@Target(ANNOTATION_TYPE)`
+            stereotypeNames.add(annotation.target().asClass().name());
         }
         // ideally, we would also consider all `StereotypeRegistrarBuildItem`s here,
         // but there is a build step cycle involving Spring DI and RESTEasy Reactive
@@ -85,10 +85,9 @@ BuildTimeEnabledStereotypesBuildItem findEnablementStereotypes(CombinedIndexBuil
             worklist.add(stereotypeToScan);
             while (!worklist.isEmpty()) {
                 DotName stereotype = worklist.poll();
-                if (alreadySeen.contains(stereotype)) {
+                if (!alreadySeen.add(stereotype)) {
                     continue;
                 }
-                alreadySeen.add(stereotype);
 
                 ClassInfo stereotypeClass = index.getClassByName(stereotype);
                 if (stereotypeClass == null) {
@@ -97,23 +96,11 @@ BuildTimeEnabledStereotypesBuildItem findEnablementStereotypes(CombinedIndexBuil
 
                 for (DotName enablementAnnotation : List.of(IF_BUILD_PROFILE, UNLESS_BUILD_PROFILE, IF_BUILD_PROPERTY,
                         UNLESS_BUILD_PROPERTY)) {
-                    AnnotationInstance ann = stereotypeClass.declaredAnnotation(enablementAnnotation);
-                    if (ann != null) {
+                    for (AnnotationInstance ann : stereotypeClass.declaredAnnotationsWithRepeatable(
+                            enablementAnnotation, index)) {
                         result.computeIfAbsent(enablementAnnotation, ignored -> new ArrayList<>()).add(ann);
                     }
                 }
-                for (Map.Entry<DotName, DotName> entry : Map.of(IF_BUILD_PROPERTY_CONTAINER, IF_BUILD_PROPERTY,
-                        UNLESS_BUILD_PROPERTY_CONTAINER, UNLESS_BUILD_PROPERTY).entrySet()) {
-                    DotName enablementContainerAnnotation = entry.getKey();
-                    DotName enablementAnnotation = entry.getValue();
-
-                    AnnotationInstance containerAnn = stereotypeClass.declaredAnnotation(enablementContainerAnnotation);
-                    if (containerAnn != null) {
-                        for (AnnotationInstance ann : containerAnn.value().asNestedArray()) {
-                            result.computeIfAbsent(enablementAnnotation, ignored -> new ArrayList<>()).add(ann);
-                        }
-                    }
-                }
 
                 for (AnnotationInstance metaAnn : stereotypeClass.declaredAnnotations()) {
                     if (stereotypeNames.contains(metaAnn.name())) {
@@ -136,10 +123,10 @@ BuildTimeEnabledStereotypesBuildItem findEnablementStereotypes(CombinedIndexBuil
     @BuildStep
     void ifBuildProfile(CombinedIndexBuildItem index, BuildTimeEnabledStereotypesBuildItem stereotypes,
             BuildProducer<BuildTimeConditionBuildItem> producer) {
-        enablementAnnotations(IF_BUILD_PROFILE, null, index.getIndex(), stereotypes, producer,
-                new Function<AnnotationInstance, Boolean>() {
+        enablementAnnotations(IF_BUILD_PROFILE, index.getComputingIndex(), stereotypes, producer,
+                new Predicate<AnnotationInstance>() {
                     @Override
-                    public Boolean apply(AnnotationInstance annotation) {
+                    public boolean test(AnnotationInstance annotation) {
                         return BuildProfile.from(annotation).enabled();
                     }
                 });
@@ -148,10 +135,10 @@ public Boolean apply(AnnotationInstance annotation) {
     @BuildStep
     void unlessBuildProfile(CombinedIndexBuildItem index, BuildTimeEnabledStereotypesBuildItem stereotypes,
             BuildProducer<BuildTimeConditionBuildItem> producer) {
-        enablementAnnotations(UNLESS_BUILD_PROFILE, null, index.getIndex(), stereotypes, producer,
-                new Function<AnnotationInstance, Boolean>() {
+        enablementAnnotations(UNLESS_BUILD_PROFILE, index.getComputingIndex(), stereotypes, producer,
+                new Predicate<AnnotationInstance>() {
                     @Override
-                    public Boolean apply(AnnotationInstance annotation) {
+                    public boolean test(AnnotationInstance annotation) {
                         return BuildProfile.from(annotation).disabled();
                     }
                 });
@@ -161,10 +148,10 @@ public Boolean apply(AnnotationInstance annotation) {
     void ifBuildProperty(CombinedIndexBuildItem index, BuildTimeEnabledStereotypesBuildItem stereotypes,
             BuildProducer<BuildTimeConditionBuildItem> conditions) {
         Config config = ConfigProviderResolver.instance().getConfig();
-        enablementAnnotations(IF_BUILD_PROPERTY, IF_BUILD_PROPERTY_CONTAINER, index.getIndex(), stereotypes, conditions,
-                new Function<AnnotationInstance, Boolean>() {
+        enablementAnnotations(IF_BUILD_PROPERTY, index.getComputingIndex(), stereotypes, conditions,
+                new Predicate<AnnotationInstance>() {
                     @Override
-                    public Boolean apply(AnnotationInstance annotation) {
+                    public boolean test(AnnotationInstance annotation) {
                         return BuildProperty.from(annotation).enabled(config);
                     }
                 });
@@ -174,24 +161,24 @@ public Boolean apply(AnnotationInstance annotation) {
     void unlessBuildProperty(CombinedIndexBuildItem index, BuildTimeEnabledStereotypesBuildItem stereotypes,
             BuildProducer<BuildTimeConditionBuildItem> conditions) {
         Config config = ConfigProviderResolver.instance().getConfig();
-        enablementAnnotations(UNLESS_BUILD_PROPERTY, UNLESS_BUILD_PROPERTY_CONTAINER, index.getIndex(), stereotypes, conditions,
-                new Function<AnnotationInstance, Boolean>() {
+        enablementAnnotations(UNLESS_BUILD_PROPERTY, index.getComputingIndex(), stereotypes, conditions,
+                new Predicate<AnnotationInstance>() {
                     @Override
-                    public Boolean apply(AnnotationInstance annotation) {
+                    public boolean test(AnnotationInstance annotation) {
                         return BuildProperty.from(annotation).disabled(config);
                     }
                 });
     }
 
-    private void enablementAnnotations(DotName annotationName, DotName containingAnnotationName, IndexView index,
+    private void enablementAnnotations(DotName annotationName, IndexView index,
             BuildTimeEnabledStereotypesBuildItem stereotypes, BuildProducer<BuildTimeConditionBuildItem> producer,
-            Function<AnnotationInstance, Boolean> test) {
+            Predicate<AnnotationInstance> predicate) {
 
         // instances of enablement annotation directly on affected declarations
-        List<AnnotationInstance> annotationInstances = getAnnotations(index, annotationName, containingAnnotationName);
+        List<AnnotationInstance> annotationInstances = getAnnotations(index, annotationName);
         for (AnnotationInstance annotation : annotationInstances) {
             AnnotationTarget target = annotation.target();
-            boolean enabled = test.apply(annotation);
+            boolean enabled = predicate.test(annotation);
             if (enabled) {
                 LOGGER.debugf("Enabling %s due to %s", target, annotation);
             } else {
@@ -207,7 +194,7 @@ private void enablementAnnotations(DotName annotationName, DotName containingAnn
             for (AnnotationInstance stereotypeUsage : getAnnotations(index, stereotype.name)) {
                 AnnotationTarget target = stereotypeUsage.target();
                 for (AnnotationInstance annotation : stereotype.getEnablementAnnotations(annotationName)) {
-                    boolean enabled = test.apply(annotation);
+                    boolean enabled = predicate.test(annotation);
                     if (enabled) {
                         LOGGER.debugf("Enabling %s  due to %s on stereotype %s", target, annotation, stereotype.name);
                     } else {
@@ -229,10 +216,9 @@ private void enablementAnnotations(DotName annotationName, DotName containingAnn
 
         // instances of stereotypes (with enablement annotation) inherited from a superclass
         for (ClassInfo clazz : classesWithPossiblyInheritedStereotype) {
-            if (processedClasses.contains(clazz.name())) {
+            if (!processedClasses.add(clazz.name())) {
                 continue;
             }
-            processedClasses.add(clazz.name());
 
             ClassInfo superclass = index.getClassByName(clazz.superName());
             Set<DotName> seenStereotypes = new HashSet<>(); // avoid "inheriting" the same annotation multiple times
@@ -249,7 +235,7 @@ private void enablementAnnotations(DotName annotationName, DotName containingAnn
                     }
 
                     for (AnnotationInstance annotation : stereotype.getEnablementAnnotations(annotationName)) {
-                        boolean enabled = test.apply(annotation);
+                        boolean enabled = predicate.test(annotation);
                         if (enabled) {
                             LOGGER.debugf("Enabling %s due to %s on stereotype %s inherited from %s",
                                     clazz, annotation, stereotype.name, superclass.name());
@@ -289,20 +275,18 @@ void conditionTransformer(List<BuildTimeConditionBuildItem> buildTimeConditions,
         }
 
         // the transformer just tries to match targets and then enables or disables the bean accordingly
-        annotationsTransformer.produce(new AnnotationsTransformerBuildItem(new AnnotationsTransformer() {
+        annotationsTransformer.produce(new AnnotationsTransformerBuildItem(new AnnotationTransformation() {
             @Override
-            public void transform(TransformationContext ctx) {
-                AnnotationTarget target = ctx.getTarget();
+            public void apply(TransformationContext ctx) {
+                Declaration target = ctx.declaration();
                 if (!enabled.getOrDefault(EquivalenceKey.of(target), Boolean.TRUE)) {
-                    Transformation transform = ctx.transform();
                     if (target.kind() == Kind.CLASS) {
                         // Veto the class
-                        transform.add(DotNames.VETOED);
+                        ctx.add(Vetoed.class);
                     } else {
                         // Veto the producer
-                        transform.add(DotNames.VETOED_PRODUCER);
+                        ctx.add(VetoedProducer.class);
                     }
-                    transform.done();
                 }
             }
         }));
@@ -329,7 +313,7 @@ BuildExclusionsBuildItem buildExclusions(List<BuildTimeConditionBuildItem> build
 
     private static List<AnnotationInstance> getAnnotations(IndexView index, DotName annotationName) {
         List<AnnotationInstance> result = new ArrayList<>();
-        for (AnnotationInstance annotation : index.getAnnotations(annotationName)) {
+        for (AnnotationInstance annotation : index.getAnnotationsWithRepeatable(annotationName, index)) {
             AnnotationTarget target = annotation.target();
             if (target != null && (target.kind() != Kind.CLASS || !target.asClass().isAnnotation())) {
                 result.add(annotation);
@@ -338,30 +322,6 @@ private static List<AnnotationInstance> getAnnotations(IndexView index, DotName
         return result;
     }
 
-    private static List<AnnotationInstance> getAnnotations(IndexView index, DotName annotationName,
-            DotName containingAnnotationName) {
-
-        // Single annotation
-        List<AnnotationInstance> annotationInstances = getAnnotations(index, annotationName);
-        if (containingAnnotationName == null) {
-            return annotationInstances;
-        }
-        // Collect containing annotation instances
-        // Note that we can't just use the IndexView.getAnnotationsWithRepeatable() method because the containing annotation is not part of the index
-        for (AnnotationInstance containingInstance : index.getAnnotations(containingAnnotationName)) {
-            AnnotationTarget target = containingInstance.target();
-            if (target != null && (target.kind() != Kind.CLASS || !target.asClass().isAnnotation())) {
-                for (AnnotationInstance nestedInstance : containingInstance.value().asNestedArray()) {
-                    // We need to set the target of the containing instance
-                    annotationInstances.add(
-                            AnnotationInstance.create(nestedInstance.name(), target, nestedInstance.values()));
-                }
-            }
-        }
-
-        return annotationInstances;
-    }
-
     private static class BuildProfile {
         private final Set<String> allOf;
         private final Set<String> anyOf;
diff --git a/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/LookupConditionsProcessor.java b/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/LookupConditionsProcessor.java
index ce433b34d37..8555c240c62 100644
--- a/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/LookupConditionsProcessor.java
+++ b/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/LookupConditionsProcessor.java
@@ -1,7 +1,9 @@
 package io.quarkus.arc.deployment;
 
+import java.util.ArrayDeque;
 import java.util.ArrayList;
-import java.util.Collections;
+import java.util.Deque;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
@@ -11,15 +13,19 @@
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
+import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.IndexView;
 
 import io.quarkus.arc.lookup.LookupIfProperty;
 import io.quarkus.arc.lookup.LookupUnlessProperty;
 import io.quarkus.arc.processor.BeanInfo;
+import io.quarkus.arc.processor.DotNames;
+import io.quarkus.arc.processor.StereotypeInfo;
 import io.quarkus.arc.runtime.SuppressConditions;
 import io.quarkus.deployment.annotations.BuildProducer;
 import io.quarkus.deployment.annotations.BuildStep;
+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;
 import io.quarkus.gizmo2.Const;
 import io.quarkus.gizmo2.Expr;
 import io.quarkus.gizmo2.creator.BlockCreator;
@@ -45,26 +51,89 @@ public class LookupConditionsProcessor {
     private static final MethodDesc SUPPRESS_UNLESS_PROPERTY = MethodDesc.of(SuppressConditions.class, "suppressUnlessProperty",
             boolean.class, String.class, String.class, boolean.class);
 
+    @BuildStep
+    LookupConditionsStereotypesBuildItem findLookupConditionStereotypes(CombinedIndexBuildItem combinedIndex) {
+        IndexView index = combinedIndex.getComputingIndex();
+
+        // find all stereotypes
+        Set<DotName> stereotypeNames = new HashSet<>();
+        for (AnnotationInstance annotation : index.getAnnotations(DotNames.STEREOTYPE)) {
+            // `Stereotype` is `@Target(ANNOTATION_TYPE)`
+            stereotypeNames.add(annotation.target().asClass().name());
+        }
+        // ideally, we would also consider all `StereotypeRegistrarBuildItem`s here,
+        // but there is a build step cycle involving Spring DI and RESTEasy Reactive
+        // that I'm not capable of breaking
+
+        // for each stereotype, find all lookup annotations, present either directly or transitively
+        List<LookupConditionsStereotypesBuildItem.LookupConditionsStereotype> lookupStereotypes = new ArrayList<>();
+        for (DotName stereotypeToScan : stereotypeNames) {
+            List<AnnotationInstance> ifAnnotations = new ArrayList<>();
+            List<AnnotationInstance> unlessAnnotations = new ArrayList<>();
+
+            Set<DotName> alreadySeen = new HashSet<>(); // to guard against hypothetical stereotype cycle
+            Deque<DotName> worklist = new ArrayDeque<>();
+            worklist.add(stereotypeToScan);
+            while (!worklist.isEmpty()) {
+                DotName stereotype = worklist.poll();
+                if (!alreadySeen.add(stereotype)) {
+                    continue;
+                }
+
+                ClassInfo stereotypeClass = index.getClassByName(stereotype);
+                if (stereotypeClass == null) {
+                    continue;
+                }
+
+                ifAnnotations.addAll(stereotypeClass.declaredAnnotationsWithRepeatable(LOOK_UP_IF_PROPERTY, index));
+                unlessAnnotations.addAll(stereotypeClass.declaredAnnotationsWithRepeatable(LOOK_UP_UNLESS_PROPERTY, index));
+
+                for (AnnotationInstance metaAnn : stereotypeClass.declaredAnnotations()) {
+                    if (stereotypeNames.contains(metaAnn.name())) {
+                        worklist.add(metaAnn.name());
+                    }
+                }
+            }
+
+            if (!ifAnnotations.isEmpty() || !unlessAnnotations.isEmpty()) {
+                lookupStereotypes.add(new LookupConditionsStereotypesBuildItem.LookupConditionsStereotype(stereotypeToScan,
+                        ifAnnotations, unlessAnnotations));
+            }
+        }
+
+        return new LookupConditionsStereotypesBuildItem(lookupStereotypes);
+    }
+
     @BuildStep
     void suppressConditionsGenerators(BuildProducer<SuppressConditionGeneratorBuildItem> generators,
+            LookupConditionsStereotypesBuildItem lookupConditionStereotypes,
             BeanArchiveIndexBuildItem beanArchiveIndex) {
         IndexView index = beanArchiveIndex.getIndex();
 
         generators.produce(new SuppressConditionGeneratorBuildItem(new Function<BeanInfo, Consumer<BlockCreator>>() {
-
             @Override
             public Consumer<BlockCreator> apply(BeanInfo bean) {
                 Optional<AnnotationTarget> maybeTarget = bean.getTarget();
                 if (maybeTarget.isPresent()) {
                     AnnotationTarget target = maybeTarget.get();
-                    List<AnnotationInstance> ifPropertyList = findAnnotations(target, LOOK_UP_IF_PROPERTY,
-                            LOOK_UP_IF_CONTAINER, index);
-                    List<AnnotationInstance> unlessPropertyList = findAnnotations(target, LOOK_UP_UNLESS_PROPERTY,
-                            LOOK_UP_UNLESS_PROPERTY_CONTAINER, index);
+                    List<AnnotationInstance> ifPropertyList = new ArrayList<>(
+                            target.declaredAnnotationsWithRepeatable(LOOK_UP_IF_PROPERTY, index));
+                    List<AnnotationInstance> unlessPropertyList = new ArrayList<>(
+                            target.declaredAnnotationsWithRepeatable(LOOK_UP_UNLESS_PROPERTY, index));
+                    for (StereotypeInfo stereotype : bean.getStereotypes()) {
+                        var conditions = lookupConditionStereotypes.get(stereotype.getName());
+                        if (conditions != null) {
+                            ifPropertyList.addAll(conditions.ifAnnotations());
+                            unlessPropertyList.addAll(conditions.unlessAnnotations());
+                        }
+                    }
                     if (!ifPropertyList.isEmpty() || !unlessPropertyList.isEmpty()) {
                         return new Consumer<BlockCreator>() {
                             @Override
                             public void accept(BlockCreator suppressed) {
+                                // if at least one condition fails, we mark the bean as suppressed
+                                // this means all conditions must pass, which is how we implement
+                                // the documented "logical AND of all conditions" behavior
                                 for (AnnotationInstance ifProperty : ifPropertyList) {
                                     String propertyName = ifProperty.value(NAME).asString();
                                     String expectedStringValue = ifProperty.value(STRING_VALUE).asString();
@@ -93,37 +162,4 @@ public void accept(BlockCreator suppressed) {
             }
         }));
     }
-
-    List<AnnotationInstance> findAnnotations(AnnotationTarget target, DotName annotationName, DotName containingAnnotationName,
-            IndexView index) {
-        AnnotationInstance annotation;
-        AnnotationInstance container;
-        switch (target.kind()) {
-            case CLASS -> {
-                annotation = target.asClass().declaredAnnotation(annotationName);
-                container = target.asClass().declaredAnnotation(containingAnnotationName);
-            }
-            case FIELD -> {
-                annotation = target.asField().annotation(annotationName);
-                container = target.asField().annotation(containingAnnotationName);
-            }
-            case METHOD -> {
-                annotation = target.asMethod().annotation(annotationName);
-                container = target.asMethod().annotation(containingAnnotationName);
-            }
-            default -> throw new IllegalStateException("Invalid bean target: " + target);
-        }
-        if (annotation == null && container == null) {
-            return Collections.emptyList();
-        }
-        List<AnnotationInstance> ret = new ArrayList<>();
-        if (annotation != null) {
-            ret.add(annotation);
-        }
-        if (container != null) {
-            Collections.addAll(ret, container.value().asNestedArray());
-        }
-        return ret;
-    }
-
 }
diff --git a/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/LookupConditionsStereotypesBuildItem.java b/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/LookupConditionsStereotypesBuildItem.java
new file mode 100644
index 00000000000..3e8c1265127
--- /dev/null
+++ b/extensions/arc/deployment/src/main/java/io/quarkus/arc/deployment/LookupConditionsStereotypesBuildItem.java
@@ -0,0 +1,32 @@
+package io.quarkus.arc.deployment;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.jboss.jandex.AnnotationInstance;
+import org.jboss.jandex.DotName;
+
+import io.quarkus.builder.item.SimpleBuildItem;
+
+final class LookupConditionsStereotypesBuildItem extends SimpleBuildItem {
+    private final Map<DotName, LookupConditionsStereotype> map;
+
+    LookupConditionsStereotypesBuildItem(List<LookupConditionsStereotype> lookupConditionsStereotypes) {
+        Map<DotName, LookupConditionsStereotype> map = new HashMap<>();
+        for (LookupConditionsStereotype lookupConditionsStereotype : lookupConditionsStereotypes) {
+            map.put(lookupConditionsStereotype.name, lookupConditionsStereotype);
+        }
+        this.map = map;
+    }
+
+    LookupConditionsStereotype get(DotName stereotype) {
+        return map.get(stereotype);
+    }
+
+    record LookupConditionsStereotype(
+            DotName name,
+            List<AnnotationInstance> ifAnnotations,
+            List<AnnotationInstance> unlessAnnotations) {
+    }
+}
diff --git a/extensions/arc/runtime/src/main/java/io/quarkus/arc/lookup/LookupIfProperty.java b/extensions/arc/runtime/src/main/java/io/quarkus/arc/lookup/LookupIfProperty.java
index a7de40972f6..fd5b0056c5c 100644
--- a/extensions/arc/runtime/src/main/java/io/quarkus/arc/lookup/LookupIfProperty.java
+++ b/extensions/arc/runtime/src/main/java/io/quarkus/arc/lookup/LookupIfProperty.java
@@ -11,8 +11,8 @@
 /**
  * Indicates that a bean should only be obtained by programmatic lookup if the property matches the provided value.
  * <p>
- * This annotation is repeatable. A bean will be included if all the conditions defined by the {@link LookupIfProperty} and
- * {@link LookupUnlessProperty} annotations are satisfied.
+ * This annotation is repeatable and may be put on a stereotype. A bean will be included if all the conditions
+ * defined by the {@link LookupIfProperty} and {@link LookupUnlessProperty} annotations are satisfied.
  *
  * <pre>
  * <code>
@@ -60,18 +60,19 @@
 public @interface LookupIfProperty {
 
     /**
-     * Name of the runtime property to check
+     * Name of the runtime property to check.
      */
     String name();
 
     /**
-     * Expected {@code String} value of the runtime property (specified by {@code name}) if the bean should be looked up at
-     * runtime.
+     * Expected {@code String} value of the runtime property (specified by {@code name})
+     * if the bean should be looked up at runtime.
      */
     String stringValue();
 
     /**
-     * Determines if the bean is to be looked up when the property name specified by {@code name} has not been specified at all
+     * Determines if the bean should be looked up when the property specified by {@code name}
+     * has not been specified at all.
      */
     boolean lookupIfMissing() default false;
 
diff --git a/extensions/arc/runtime/src/main/java/io/quarkus/arc/lookup/LookupUnlessProperty.java b/extensions/arc/runtime/src/main/java/io/quarkus/arc/lookup/LookupUnlessProperty.java
index ec1f7072afe..2ef987fac2f 100644
--- a/extensions/arc/runtime/src/main/java/io/quarkus/arc/lookup/LookupUnlessProperty.java
+++ b/extensions/arc/runtime/src/main/java/io/quarkus/arc/lookup/LookupUnlessProperty.java
@@ -11,8 +11,8 @@
 /**
  * Indicates that a bean should only be obtained by programmatic lookup if the property does not match the provided value.
  * <p>
- * This annotation is repeatable. A bean will be included if all the conditions defined by the {@link LookupUnlessProperty}
- * and {@link LookupIfProperty} annotations are satisfied.
+ * This annotation is repeatable and may be put on a stereotype. A bean will be included if all the conditions
+ * defined by the {@link LookupUnlessProperty} and {@link LookupIfProperty} annotations are satisfied.
  *
  * <pre>
  * <code>
@@ -60,19 +60,19 @@
 public @interface LookupUnlessProperty {
 
     /**
-     * Name of the runtime time property to check
+     * Name of the runtime property to check.
      */
     String name();
 
     /**
-     * Expected {@code String} value of the runtime time property (specified by {@code name}) if the bean should be skipped at
-     * runtime.
+     * Expected {@code String} value of the runtime property (specified by {@code name})
+     * if the bean should NOT be looked up at runtime.
      */
     String stringValue();
 
     /**
-     * Determines if the bean should be looked up when the property name specified by {@code name} has not been specified at
-     * all
+     * Determines if the bean should be looked up when the property specified by {@code name}
+     * has not been specified at all.
      */
     boolean lookupIfMissing() default false;
 
diff --git a/extensions/arc/runtime/src/main/java/io/quarkus/arc/profile/IfBuildProfile.java b/extensions/arc/runtime/src/main/java/io/quarkus/arc/profile/IfBuildProfile.java
index ddf7ca9532a..93f248b280e 100644
--- a/extensions/arc/runtime/src/main/java/io/quarkus/arc/profile/IfBuildProfile.java
+++ b/extensions/arc/runtime/src/main/java/io/quarkus/arc/profile/IfBuildProfile.java
@@ -6,7 +6,7 @@
 import java.lang.annotation.Target;
 
 /**
- * When applied to a bean class or producer method (or field), the bean will only be enabled
+ * When applied to a bean class or producer method or field, the bean will only be enabled
  * if the Quarkus build time profile matches the rules of the annotation values.
  *
  * <blockquote>
@@ -42,6 +42,9 @@
  * </pre>
  *
  * </blockquote>
+ *
+ * This annotation may be put on a stereotype. A bean will be enabled if all the conditions
+ * defined by the {@link IfBuildProfile} and {@link UnlessBuildProfile} annotations are satisfied.
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ ElementType.METHOD, ElementType.TYPE, ElementType.FIELD })
diff --git a/extensions/arc/runtime/src/main/java/io/quarkus/arc/profile/UnlessBuildProfile.java b/extensions/arc/runtime/src/main/java/io/quarkus/arc/profile/UnlessBuildProfile.java
index ddc3bdd8eb0..9719b03b832 100644
--- a/extensions/arc/runtime/src/main/java/io/quarkus/arc/profile/UnlessBuildProfile.java
+++ b/extensions/arc/runtime/src/main/java/io/quarkus/arc/profile/UnlessBuildProfile.java
@@ -6,7 +6,7 @@
 import java.lang.annotation.Target;
 
 /**
- * When applied to a bean class or producer method (or field), the bean will only be enabled
+ * When applied to a bean class or producer method or field, the bean will only be enabled
  * if the Quarkus build time profile does <b>not</b> match the rules of the annotation values.
  *
  * <blockquote>
@@ -43,6 +43,9 @@
  * </pre>
  *
  * </blockquote>
+ *
+ * This annotation may be put on a stereotype. A bean will be enabled if all the conditions
+ * defined by the {@link IfBuildProfile} and {@link UnlessBuildProfile} annotations are satisfied.
  */
 @Retention(RetentionPolicy.RUNTIME)
 @Target({ ElementType.METHOD, ElementType.TYPE, ElementType.FIELD })
diff --git a/extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/IfBuildProperty.java b/extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/IfBuildProperty.java
index 9dac62c08ab..174f784a75b 100644
--- a/extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/IfBuildProperty.java
+++ b/extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/IfBuildProperty.java
@@ -7,14 +7,14 @@
 import java.lang.annotation.Target;
 
 /**
- * When applied to a bean class or producer method (or field), the bean will only be enabled
+ * When applied to a bean class or producer method or field, the bean will only be enabled
  * if the Quarkus build time property matches the provided value.
  * <p>
  * By default, the bean is not enabled when the build time property is not defined at all, but this behavior is configurable
  * via the {@code enableIfMissing} property.
  * <p>
- * This annotation is repeatable. A bean will only be enabled if all the conditions defined by the {@link IfBuildProperty}
- * annotations are satisfied.
+ * This annotation is repeatable and may be put on a stereotype. A bean will be enabled if all the conditions
+ * defined by the {@link IfBuildProperty} and {@link UnlessBuildProperty} annotations are satisfied.
  */
 @Repeatable(IfBuildProperty.List.class)
 @Retention(RetentionPolicy.RUNTIME)
diff --git a/extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/UnlessBuildProperty.java b/extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/UnlessBuildProperty.java
index 6854eeb0ce7..feea546520d 100644
--- a/extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/UnlessBuildProperty.java
+++ b/extensions/arc/runtime/src/main/java/io/quarkus/arc/properties/UnlessBuildProperty.java
@@ -7,14 +7,14 @@
 import java.lang.annotation.Target;
 
 /**
- * When applied to a bean class or producer method (or field), the bean will only be enabled
+ * When applied to a bean class or producer method or field, the bean will only be enabled
  * if the Quarkus build time property does not match the provided value.
  * <p>
  * By default, the bean is not enabled when the build time property is not defined at all, but this behavior is configurable
  * via the {@code enableIfMissing} property.
  * <p>
- * This annotation is repeatable. A bean will only be enabled if all the conditions defined by the
- * {@link UnlessBuildProperty} annotations are satisfied.
+ * This annotation is repeatable and may be put on a stereotype. A bean will be enabled if all the conditions
+ * defined by the {@link IfBuildProperty} and {@link UnlessBuildProperty} annotations are satisfied.
  */
 @Repeatable(UnlessBuildProperty.List.class)
 @Retention(RetentionPolicy.RUNTIME)
