diff --git a/.travis.yml b/.travis.yml
index 1542878e8..0af6325cb 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -13,7 +13,6 @@ jdk:
 
 scala_version_212: &scala_version_212 2.12.11
 scala_version_213: &scala_version_213 2.13.2
-dotty_version: &dotty_version 0.24.0
 
 before_install:
  - export PATH=${PATH}:./vendor/bundle
@@ -77,14 +76,6 @@ jobs:
       name: Binary compatibility 2.13
       scala: *scala_version_213
 
-    # Note that we're currently only building some modules on Dotty, not running tests.
-    - &dotty_tests
-      stage: test
-      name: Dotty tests
-      env: TEST="Dotty tests"
-      script: sbt ++$TRAVIS_SCALA_VERSION! alleycatsLawsJVM/compile
-      scala: *dotty_version
-
     - stage: styling
       name: Linting
       env: TEST="linting"
diff --git a/build.sbt b/build.sbt
index 771e52e2c..54d9df3c9 100644
--- a/build.sbt
+++ b/build.sbt
@@ -20,8 +20,7 @@ isTravisBuild in Global := sys.env.get("TRAVIS").isDefined
 
 val scalaCheckVersion = "1.14.3"
 
-val scalatestVersion = "3.2.0"
-val scalatestplusScalaCheckVersion = "3.2.0.0"
+val scalatestplusScalaCheckVersion = "3.1.2.0"
 
 val disciplineVersion = "1.0.2"
 
@@ -44,9 +43,9 @@ def scalaVersionSpecificFolders(srcName: String, srcBaseDir: java.io.File, scala
     List(CrossType.Pure, CrossType.Full)
       .flatMap(_.sharedSrcDir(srcBaseDir, srcName).toList.map(f => file(f.getPath + suffix)))
   CrossVersion.partialVersion(scalaVersion) match {
-    case Some((2, y)) => extraDirs("-2.x") ++ (if (y >= 13) extraDirs("-2.13+") else Nil)
-    case Some((0, _)) => extraDirs("-2.13+") ++ extraDirs("-3.x")
-    case _            => Nil
+    case Some((2, y)) if y >= 13 =>
+      extraDirs("-2.13+")
+    case _ => Nil
   }
 }
 
@@ -59,11 +58,8 @@ commonScalaVersionSettings
 
 ThisBuild / mimaFailOnNoPrevious := false
 
-def doctestGenTestsDottyCompat(isDotty: Boolean, genTests: Seq[File]): Seq[File] =
-  if (isDotty) Nil else genTests
-
 lazy val commonSettings = commonScalaVersionSettings ++ Seq(
-  scalacOptions ++= commonScalacOptions(scalaVersion.value, isDotty.value),
+  scalacOptions ++= commonScalacOptions(scalaVersion.value),
   Compile / unmanagedSourceDirectories ++= scalaVersionSpecificFolders("main", baseDirectory.value, scalaVersion.value),
   Test / unmanagedSourceDirectories ++= scalaVersionSpecificFolders("test", baseDirectory.value, scalaVersion.value),
   resolvers ++= Seq(Resolver.sonatypeRepo("releases"), Resolver.sonatypeRepo("snapshots")),
@@ -72,26 +68,19 @@ lazy val commonSettings = commonScalaVersionSettings ++ Seq(
 ) ++ warnUnusedImport
 
 def macroDependencies(scalaVersion: String) =
-  if (scalaVersion.startsWith("2")) Seq("org.scala-lang" % "scala-reflect" % scalaVersion % Provided) else Nil
+  Seq("org.scala-lang" % "scala-reflect" % scalaVersion % Provided)
 
 lazy val catsSettings = Seq(
   incOptions := incOptions.value.withLogRecompileOnMacro(false),
-  libraryDependencies ++= (
-    if (isDotty.value) Nil
-    else
-      Seq(
-        compilerPlugin(("org.typelevel" %% "kind-projector" % kindProjectorVersion).cross(CrossVersion.full))
-      )
+  libraryDependencies ++= Seq(
+    compilerPlugin(("org.typelevel" %% "kind-projector" % kindProjectorVersion).cross(CrossVersion.full))
   ) ++ macroDependencies(scalaVersion.value)
 ) ++ commonSettings ++ publishSettings ++ scoverageSettings ++ simulacrumSettings
 
 lazy val simulacrumSettings = Seq(
-  libraryDependencies ++= (if (isDotty.value) Nil else Seq(compilerPlugin(scalafixSemanticdb))),
-  scalacOptions ++= (
-    if (isDotty.value) Nil else Seq(s"-P:semanticdb:targetroot:${baseDirectory.value}/target/.semanticdb", "-Yrangepos")
-  ),
-  libraryDependencies +=
-    ("org.typelevel" %% "simulacrum-scalafix-annotations" % "0.5.0").withDottyCompat(scalaVersion.value),
+  addCompilerPlugin(scalafixSemanticdb),
+  scalacOptions ++= Seq(s"-P:semanticdb:targetroot:${baseDirectory.value}/target/.semanticdb", "-Yrangepos"),
+  libraryDependencies += "org.typelevel" %% "simulacrum-scalafix-annotations" % "0.5.0",
   pomPostProcess := { (node: xml.Node) =>
     new RuleTransformer(new RewriteRule {
       override def transform(node: xml.Node): Seq[xml.Node] =
@@ -151,25 +140,15 @@ lazy val includeGeneratedSrc: Setting[_] = {
 }
 
 lazy val disciplineDependencies = Seq(
-  libraryDependencies ++= Seq(
-    "org.scalacheck" %%% "scalacheck" % scalaCheckVersion,
-    "org.typelevel" %%% "discipline-core" % disciplineVersion
-  ).map(_.withDottyCompat(scalaVersion.value))
+  libraryDependencies ++= Seq("org.scalacheck" %%% "scalacheck" % scalaCheckVersion,
+                              "org.typelevel" %%% "discipline-core" % disciplineVersion
+  )
 )
 
 lazy val testingDependencies = Seq(
   libraryDependencies ++= Seq(
-    "org.scalatest" %%% "scalatest-shouldmatchers" % scalatestVersion % Test,
-    "org.scalatest" %%% "scalatest-funsuite" % scalatestVersion % Test,
+    "org.typelevel" %%% "discipline-scalatest" % disciplineScalatestVersion % Test,
     "org.scalatestplus" %%% "scalacheck-1-14" % scalatestplusScalaCheckVersion % Test
-  ),
-  libraryDependencies ++= Seq(
-    ("org.typelevel" %%% "discipline-scalatest" % disciplineScalatestVersion % Test)
-  ).map(
-    _.exclude("org.scalatestplus", "scalacheck-1-14_2.13")
-      .exclude("org.scalactic", "scalactic_2.13")
-      .exclude("org.scalatest", "scalatest_2.13")
-      .withDottyCompat(scalaVersion.value)
   )
 )
 
@@ -415,7 +394,6 @@ lazy val docs = project
   .settings(docSettings)
   .settings(commonJvmSettings)
   .settings(
-    crossScalaVersions := crossScalaVersions.value.init,
     libraryDependencies ++= Seq(
       "org.typelevel" %%% "discipline-scalatest" % disciplineScalatestVersion
     ),
@@ -508,10 +486,7 @@ lazy val kernel = crossProject(JSPlatform, JVMPlatform)
   .settings(includeGeneratedSrc)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("cats-kernel"))
-  .settings(
-    libraryDependencies += ("org.scalacheck" %%% "scalacheck" % scalaCheckVersion % Test)
-      .withDottyCompat(scalaVersion.value)
-  )
+  .settings(libraryDependencies += "org.scalacheck" %%% "scalacheck" % scalaCheckVersion % Test)
 
 lazy val kernelLaws = crossProject(JSPlatform, JVMPlatform)
   .in(file("kernel-laws"))
@@ -534,18 +509,7 @@ lazy val core = crossProject(JSPlatform, JVMPlatform)
   .settings(catsSettings)
   .settings(sourceGenerators in Compile += (sourceManaged in Compile).map(Boilerplate.gen).taskValue)
   .settings(includeGeneratedSrc)
-  .settings(
-    libraryDependencies += ("org.scalacheck" %%% "scalacheck" % scalaCheckVersion % Test)
-      .withDottyCompat(scalaVersion.value),
-    doctestGenTests := doctestGenTestsDottyCompat(isDotty.value, doctestGenTests.value)
-  )
-  .settings(
-    scalacOptions in Compile :=
-      (scalacOptions in Compile).value.filter {
-        case "-Xfatal-warnings" if isDotty.value => false
-        case _                                   => true
-      }
-  )
+  .settings(libraryDependencies += "org.scalacheck" %%% "scalacheck" % scalaCheckVersion % Test)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("cats-core"))
 
@@ -782,8 +746,7 @@ addCommandAlias("validateJVM", ";fmtCheck;buildJVM;bench/test;validateBC;makeMic
 addCommandAlias("validateJS", ";catsJS/compile;testsJS/test;js/test")
 addCommandAlias("validateKernelJS", "kernelLawsJS/test")
 addCommandAlias("validateFreeJS", "freeJS/test") //separated due to memory constraint on travis
-addCommandAlias("validateDotty", ";++0.24.0!;alleycatsLawsJVM/compile")
-addCommandAlias("validate", ";clean;validateJS;validateKernelJS;validateFreeJS;validateJVM;validateDotty")
+addCommandAlias("validate", ";clean;validateJS;validateKernelJS;validateFreeJS;validateJVM")
 
 addCommandAlias("prePR", "fmt")
 
@@ -810,14 +773,21 @@ lazy val crossVersionSharedSources: Seq[Setting[_]] =
     }
   }
 
-def commonScalacOptions(scalaVersion: String, isDotty: Boolean) =
+def commonScalacOptions(scalaVersion: String) =
   Seq(
     "-encoding",
     "UTF-8",
     "-feature",
+    "-language:existentials",
+    "-language:higherKinds",
+    "-language:implicitConversions",
     "-unchecked",
+    "-Ywarn-dead-code",
+    "-Ywarn-numeric-widen",
+    "-Ywarn-value-discard",
     "-Xfatal-warnings",
-    "-deprecation"
+    "-deprecation",
+    "-Xlint:-unused,_"
   ) ++ (if (priorTo2_13(scalaVersion))
           Seq(
             "-Yno-adapted-args",
@@ -825,18 +795,7 @@ def commonScalacOptions(scalaVersion: String, isDotty: Boolean) =
             "-Xfuture"
           )
         else
-          Nil) ++ (if (isDotty)
-                     Seq("-language:implicitConversions", "-Ykind-projector", "-Xignore-scala2-macros")
-                   else
-                     Seq(
-                       "-language:existentials",
-                       "-language:higherKinds",
-                       "-language:implicitConversions",
-                       "-Ywarn-dead-code",
-                       "-Ywarn-numeric-widen",
-                       "-Ywarn-value-discard",
-                       "-Xlint:-unused,_"
-                     ))
+          Nil)
 
 def priorTo2_13(scalaVersion: String): Boolean =
   CrossVersion.partialVersion(scalaVersion) match {
@@ -877,7 +836,7 @@ lazy val sharedReleaseProcess = Seq(
 )
 
 lazy val warnUnusedImport = Seq(
-  scalacOptions ++= (if (isDotty.value) Nil else Seq("-Ywarn-unused:imports")),
+  scalacOptions ++= Seq("-Ywarn-unused:imports"),
   scalacOptions in (Compile, console) ~= { _.filterNot(Set("-Ywarn-unused-import", "-Ywarn-unused:imports")) },
   scalacOptions in (Test, console) := (scalacOptions in (Compile, console)).value
 )
diff --git a/core/src/main/scala-2.x/src/main/scala/cats/arrow/FunctionKMacros.scala b/core/src/main/scala-2.x/src/main/scala/cats/arrow/FunctionKMacros.scala
deleted file mode 100644
index 6e79d704e..000000000
--- a/core/src/main/scala-2.x/src/main/scala/cats/arrow/FunctionKMacros.scala
+++ /dev/null
@@ -1,102 +0,0 @@
-package cats
-package arrow
-
-import scala.language.experimental.macros
-import scala.reflect.macros.blackbox.Context
-
-private[arrow] class FunctionKMacroMethods {
-
-  /**
-   * Lifts function `f` of `F[A] => G[A]` into a `FunctionK[F, G]`.
-   *
-   * {{{
-   *   def headOption[A](list: List[A]): Option[A] = list.headOption
-   *   val lifted: FunctionK[List, Option] = FunctionK.lift(headOption)
-   * }}}
-   *
-   * Note: This method has a macro implementation that returns a new
-   * `FunctionK` instance as follows:
-   *
-   * {{{
-   *   new FunctionK[F, G] {
-   *     def apply[A](fa: F[A]): G[A] = f(fa)
-   *   }
-   * }}}
-   *
-   * Additionally, the type parameters on `f` must not be specified.
-   */
-  def lift[F[_], G[_]](f: (F[α] => G[α]) forSome { type α }): FunctionK[F, G] =
-    macro FunctionKMacros.lift[F, G]
-}
-
-private[arrow] object FunctionKMacros {
-
-  def lift[F[_], G[_]](c: Context)(
-    f: c.Expr[(F[α] => G[α]) forSome { type α }]
-  )(implicit
-    evF: c.WeakTypeTag[F[_]],
-    evG: c.WeakTypeTag[G[_]]
-  ): c.Expr[FunctionK[F, G]] =
-    c.Expr[FunctionK[F, G]](new Lifter[c.type](c).lift[F, G](f.tree))
-  // ^^note: extra space after c.type to appease scalastyle
-
-  private[this] class Lifter[C <: Context](val c: C) {
-    import c.universe._
-
-    def lift[F[_], G[_]](tree: Tree)(implicit
-      evF: c.WeakTypeTag[F[_]],
-      evG: c.WeakTypeTag[G[_]]
-    ): Tree =
-      unblock(tree) match {
-        case q"($param) => $trans[..$typeArgs](${arg: Ident})" if param.name == arg.name =>
-          typeArgs
-            .collect { case tt: TypeTree => tt }
-            .find(tt => Option(tt.original).isDefined)
-            .foreach { param =>
-              c.abort(param.pos,
-                      s"type parameter $param must not be supplied when lifting function $trans to FunctionK"
-              )
-            }
-
-          val F = punchHole(evF.tpe)
-          val G = punchHole(evG.tpe)
-
-          q"""
-        new _root_.cats.arrow.FunctionK[$F, $G] {
-          def apply[A](fa: $F[A]): $G[A] = $trans(fa)
-        }
-       """
-        case other =>
-          c.abort(other.pos, s"Unexpected tree $other when lifting to FunctionK")
-      }
-
-    private[this] def unblock(tree: Tree): Tree =
-      tree match {
-        case Block(Nil, expr) => expr
-        case _                => tree
-      }
-
-    private[this] def punchHole(tpe: Type): Tree =
-      tpe match {
-        case PolyType(undet :: Nil, underlying: TypeRef) =>
-          val α = TypeName("α")
-          def rebind(typeRef: TypeRef): Tree =
-            if (typeRef.sym == undet) tq"$α"
-            else {
-              val args = typeRef.args.map {
-                case ref: TypeRef => rebind(ref)
-                case arg          => tq"$arg"
-              }
-              tq"${typeRef.sym}[..$args]"
-            }
-          val rebound = rebind(underlying)
-          tq"""({type λ[$α] = $rebound})#λ"""
-        case TypeRef(pre, sym, Nil) =>
-          tq"$sym"
-        case _ =>
-          c.abort(c.enclosingPosition, s"Unexpected type $tpe when lifting to FunctionK")
-      }
-
-  }
-
-}
diff --git a/core/src/main/scala-3.x/src/main/scala/cats/arrow/FunctionKMacros.scala b/core/src/main/scala-3.x/src/main/scala/cats/arrow/FunctionKMacros.scala
deleted file mode 100644
index 639b6ccf7..000000000
--- a/core/src/main/scala-3.x/src/main/scala/cats/arrow/FunctionKMacros.scala
+++ /dev/null
@@ -1,4 +0,0 @@
-package cats
-package arrow
-
-private[arrow] class FunctionKMacroMethods
diff --git a/core/src/main/scala/cats/arrow/FunctionK.scala b/core/src/main/scala/cats/arrow/FunctionK.scala
index f2f6457ae..295605936 100644
--- a/core/src/main/scala/cats/arrow/FunctionK.scala
+++ b/core/src/main/scala/cats/arrow/FunctionK.scala
@@ -1,6 +1,9 @@
 package cats
 package arrow
 
+import scala.language.experimental.macros
+import scala.reflect.macros.blackbox.Context
+
 import cats.data.{EitherK, Tuple2K}
 
 /**
@@ -61,11 +64,105 @@ trait FunctionK[F[_], G[_]] extends Serializable { self =>
     new FunctionK[F, Tuple2K[G, H, *]] { def apply[A](fa: F[A]): Tuple2K[G, H, A] = Tuple2K(self(fa), h(fa)) }
 }
 
-object FunctionK extends FunctionKMacroMethods {
+object FunctionK {
 
   /**
    * The identity transformation of `F` to `F`
    */
   def id[F[_]]: FunctionK[F, F] = new FunctionK[F, F] { def apply[A](fa: F[A]): F[A] = fa }
 
+  /**
+   * Lifts function `f` of `F[A] => G[A]` into a `FunctionK[F, G]`.
+   *
+   * {{{
+   *   def headOption[A](list: List[A]): Option[A] = list.headOption
+   *   val lifted: FunctionK[List, Option] = FunctionK.lift(headOption)
+   * }}}
+   *
+   * Note: This method has a macro implementation that returns a new
+   * `FunctionK` instance as follows:
+   *
+   * {{{
+   *   new FunctionK[F, G] {
+   *     def apply[A](fa: F[A]): G[A] = f(fa)
+   *   }
+   * }}}
+   *
+   * Additionally, the type parameters on `f` must not be specified.
+   */
+  def lift[F[_], G[_]](f: (F[α] => G[α]) forSome { type α }): FunctionK[F, G] =
+    macro FunctionKMacros.lift[F, G]
+
+}
+
+private[arrow] object FunctionKMacros {
+
+  def lift[F[_], G[_]](c: Context)(
+    f: c.Expr[(F[α] => G[α]) forSome { type α }]
+  )(implicit
+    evF: c.WeakTypeTag[F[_]],
+    evG: c.WeakTypeTag[G[_]]
+  ): c.Expr[FunctionK[F, G]] =
+    c.Expr[FunctionK[F, G]](new Lifter[c.type](c).lift[F, G](f.tree))
+  // ^^note: extra space after c.type to appease scalastyle
+
+  private[this] class Lifter[C <: Context](val c: C) {
+    import c.universe._
+
+    def lift[F[_], G[_]](tree: Tree)(implicit
+      evF: c.WeakTypeTag[F[_]],
+      evG: c.WeakTypeTag[G[_]]
+    ): Tree =
+      unblock(tree) match {
+        case q"($param) => $trans[..$typeArgs](${arg: Ident})" if param.name == arg.name =>
+          typeArgs
+            .collect { case tt: TypeTree => tt }
+            .find(tt => Option(tt.original).isDefined)
+            .foreach { param =>
+              c.abort(param.pos,
+                      s"type parameter $param must not be supplied when lifting function $trans to FunctionK"
+              )
+            }
+
+          val F = punchHole(evF.tpe)
+          val G = punchHole(evG.tpe)
+
+          q"""
+        new _root_.cats.arrow.FunctionK[$F, $G] {
+          def apply[A](fa: $F[A]): $G[A] = $trans(fa)
+        }
+       """
+        case other =>
+          c.abort(other.pos, s"Unexpected tree $other when lifting to FunctionK")
+      }
+
+    private[this] def unblock(tree: Tree): Tree =
+      tree match {
+        case Block(Nil, expr) => expr
+        case _                => tree
+      }
+
+    private[this] def punchHole(tpe: Type): Tree =
+      tpe match {
+        case PolyType(undet :: Nil, underlying: TypeRef) =>
+          val α = TypeName("α")
+          def rebind(typeRef: TypeRef): Tree =
+            if (typeRef.sym == undet) tq"$α"
+            else {
+              val args = typeRef.args.map {
+                case ref: TypeRef => rebind(ref)
+                case arg          => tq"$arg"
+              }
+              tq"${typeRef.sym}[..$args]"
+            }
+          val rebound = rebind(underlying)
+          tq"""({type λ[$α] = $rebound})#λ"""
+        case TypeRef(pre, sym, Nil) =>
+          tq"$sym"
+        case _ =>
+          c.abort(c.enclosingPosition, s"Unexpected type $tpe when lifting to FunctionK")
+      }
+
+  }
+
 }
diff --git a/laws/src/main/scala/cats/laws/ApplicativeErrorLaws.scala b/laws/src/main/scala/cats/laws/ApplicativeErrorLaws.scala
index 438acec34..dd061468e 100644
--- a/laws/src/main/scala/cats/laws/ApplicativeErrorLaws.scala
+++ b/laws/src/main/scala/cats/laws/ApplicativeErrorLaws.scala
@@ -32,7 +32,7 @@ trait ApplicativeErrorLaws[F[_], E] extends ApplicativeLaws[F] {
     F.handleError(fa)(f) <-> F.recover(fa) { case x => f(x) }
 
   def recoverConsistentWithRecoverWith[A](fa: F[A], pf: PartialFunction[E, A]): IsEq[F[A]] =
-    F.recover(fa)(pf) <-> F.recoverWith(fa)(pf.andThen(F.pure(_)))
+    F.recover(fa)(pf) <-> F.recoverWith(fa)(pf.andThen(F.pure _))
 
   def attemptConsistentWithAttemptT[A](fa: F[A]): IsEq[EitherT[F, E, A]] =
     EitherT(F.attempt(fa)) <-> F.attemptT(fa)
diff --git a/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala b/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala
index 6955e5de8..e89d7d4ac 100644
--- a/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala
@@ -1,8 +1,6 @@
 package cats.laws
 
-// The `catsInstancesForId` import is necessary to work around a Dotty
-// issue related to https://github.com/lampepfl/dotty/issues/9067.
-import cats.{catsInstancesForId, Apply, Id, NonEmptyTraverse, Semigroup}
+import cats.{Apply, Id, NonEmptyTraverse, Semigroup}
 import cats.data.{Const, Nested}
 import cats.syntax.nonEmptyTraverse._
 import cats.syntax.reducible._
diff --git a/laws/src/main/scala/cats/laws/discipline/Eq.scala b/laws/src/main/scala/cats/laws/discipline/Eq.scala
index 3193131e1..4ae4f4a44 100644
--- a/laws/src/main/scala/cats/laws/discipline/Eq.scala
+++ b/laws/src/main/scala/cats/laws/discipline/Eq.scala
@@ -154,7 +154,7 @@ object eq {
    * and comparing the application of the two functions.
    */
   implicit def catsLawsEqForFn2[A, B, C](implicit A: Arbitrary[A], B: Arbitrary[B], C: Eq[C]): Eq[(A, B) => C] =
-    Eq.by((_: (A, B) => C).tupled)(catsLawsEqForFn1[(A, B), C])
+    Eq.by((_: (A, B) => C).tupled)(catsLawsEqForFn1)
 
   /**
    * `Eq[AndThen]` instance, built by piggybacking on [[catsLawsEqForFn1]].
diff --git a/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala b/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
index ef92f5e83..05fd98b31 100644
--- a/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
@@ -35,6 +35,6 @@ object NonEmptyParallelTests {
   def apply[M[_]](implicit ev: NonEmptyParallel[M]): NonEmptyParallelTests.Aux[M, ev.F] =
     apply[M, ev.F](ev, implicitly)
 
-  def apply[M[_], F0[_]](implicit ev: NonEmptyParallel.Aux[M, F0], D: DummyImplicit): NonEmptyParallelTests.Aux[M, F0] =
-    new NonEmptyParallelTests[M] { val laws: NonEmptyParallelLaws.Aux[M, F0] = NonEmptyParallelLaws[M](ev) }
+  def apply[M[_], F[_]](implicit ev: NonEmptyParallel.Aux[M, F], D: DummyImplicit): NonEmptyParallelTests.Aux[M, F] =
+    new NonEmptyParallelTests[M] { val laws = NonEmptyParallelLaws[M] }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala b/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
index 93fcb7dfa..d8827ce81 100644
--- a/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
@@ -31,6 +31,6 @@ object ParallelTests {
   def apply[M[_]](implicit ev: Parallel[M]): ParallelTests.Aux[M, ev.F] =
     apply[M, ev.F](ev, implicitly)
 
-  def apply[M[_], F0[_]](implicit ev: Parallel.Aux[M, F0], D: DummyImplicit): ParallelTests.Aux[M, F0] =
-    new ParallelTests[M] { val laws: ParallelLaws.Aux[M, F0] = ParallelLaws[M](ev) }
+  def apply[M[_], F[_]](implicit ev: Parallel.Aux[M, F], D: DummyImplicit): ParallelTests.Aux[M, F] =
+    new ParallelTests[M] { val laws = ParallelLaws[M] }
 }
diff --git a/project/plugins.sbt b/project/plugins.sbt
index ff3c366e5..6036712f2 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -1,4 +1,3 @@
-addSbtPlugin("ch.epfl.lamp" % "sbt-dotty" % "0.4.1")
 addSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "0.9.17")
 addSbtPlugin("com.eed3si9n" % "sbt-unidoc" % "0.4.3")
 addSbtPlugin("com.github.gseitz" %% "sbt-release" % "1.0.13")
diff --git a/tests/src/test/scala/cats/tests/SemigroupSuite.scala b/tests/src/test/scala/cats/tests/SemigroupSuite.scala
index b6546dd39..fcab9ee53 100644
--- a/tests/src/test/scala/cats/tests/SemigroupSuite.scala
+++ b/tests/src/test/scala/cats/tests/SemigroupSuite.scala
@@ -2,6 +2,7 @@ package cats.tests
 
 import cats.{Invariant, InvariantMonoidal, Semigroupal}
 import cats.kernel.Semigroup
+import org.scalatest._
 import org.scalatest.matchers.should.Matchers
 import org.scalatest.funsuite._
 import org.scalatestplus.scalacheck.ScalaCheckDrivenPropertyChecks
