diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
index e33e1f38..901c55c2 100644
--- a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
@@ -24,9 +24,6 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
-// TODO: support @Nullable
-// TODO: path in JsonWriter.
-
 final class AdapterMethodsFactory implements JsonAdapter.Factory {
   private final List<AdapterMethod> toAdapters;
   private final List<AdapterMethod> fromAdapters;
@@ -59,7 +56,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
             throw new AssertionError();
           } catch (InvocationTargetException e) {
             if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause() + " at " + writer.getPath());
+            throw new JsonDataException(e.getCause()); // TODO: more context?
           }
         }
       }
@@ -77,7 +74,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
             throw new AssertionError();
           } catch (InvocationTargetException e) {
             if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause() + " at " + reader.getPath());
+            throw new JsonDataException(e.getCause()); // TODO: more context?
           }
         }
       }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index d7d8ca55..f4d125dd 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -248,6 +248,14 @@ public final class JsonReader implements Closeable {
     stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
   }
 
+  /*
+   * The path members. It corresponds directly to stack: At indices where the
+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
+   * pathNames contains the name at this scope. Where it contains an array
+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
+   * that array. Otherwise the value is undefined, and we take advantage of that
+   * by incrementing pathIndices when doing so isn't useful.
+   */
   private String[] pathNames = new String[32];
   private int[] pathIndices = new int[32];
 
@@ -1198,11 +1206,8 @@ public final class JsonReader implements Closeable {
             return c;
         }
       } else if (c == '#') {
-        /*
-         * Skip a # hash end-of-line comment. The JSON RFC doesn't
-         * specify this behaviour, but it's required to parse
-         * existing documents. See http://b/2571423.
-         */
+        // Skip a # hash end-of-line comment. The JSON RFC doesn't specify this behaviour, but it's
+        // required to parse existing documents. See http://b/2571423.
         checkLenient();
         skipToEndOfLine();
         p = 0;
@@ -1259,7 +1264,30 @@ public final class JsonReader implements Closeable {
    * the current location in the JSON value.
    */
   public String getPath() {
-    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
+    StringBuilder result = new StringBuilder().append('$');
+    for (int i = 0, size = stackSize; i < size; i++) {
+      switch (stack[i]) {
+        case JsonScope.EMPTY_ARRAY:
+        case JsonScope.NONEMPTY_ARRAY:
+          result.append('[').append(pathIndices[i]).append(']');
+          break;
+
+        case JsonScope.EMPTY_OBJECT:
+        case JsonScope.DANGLING_NAME:
+        case JsonScope.NONEMPTY_OBJECT:
+          result.append('.');
+          if (pathNames[i] != null) {
+            result.append(pathNames[i]);
+          }
+          break;
+
+        case JsonScope.NONEMPTY_DOCUMENT:
+        case JsonScope.EMPTY_DOCUMENT:
+        case JsonScope.CLOSED:
+          break;
+      }
+    }
+    return result.toString();
   }
 
   /**
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonScope.java b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
index 180839ad..776d7251 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonScope.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
@@ -15,65 +15,53 @@
  */
 package com.squareup.moshi;
 
-/** Lexical scoping elements within a JSON reader or writer. */
+/**
+ * Lexical scoping elements within a JSON reader or writer.
+ */
 final class JsonScope {
 
-  /** An array with no elements requires no separators or newlines before it is closed. */
+  /**
+   * An array with no elements requires no separators or newlines before
+   * it is closed.
+   */
   static final int EMPTY_ARRAY = 1;
 
-  /** A array with at least one value requires a comma and newline before the next element. */
+  /**
+   * A array with at least one value requires a comma and newline before
+   * the next element.
+   */
   static final int NONEMPTY_ARRAY = 2;
 
-  /** An object with no name/value pairs requires no separators or newlines before it is closed. */
+  /**
+   * An object with no name/value pairs requires no separators or newlines
+   * before it is closed.
+   */
   static final int EMPTY_OBJECT = 3;
 
-  /** An object whose most recent element is a key. The next element must be a value. */
+  /**
+   * An object whose most recent element is a key. The next element must
+   * be a value.
+   */
   static final int DANGLING_NAME = 4;
 
-  /** An object with at least one name/value pair requires a separator before the next element. */
+  /**
+   * An object with at least one name/value pair requires a comma and
+   * newline before the next element.
+   */
   static final int NONEMPTY_OBJECT = 5;
 
-  /** No object or array has been started. */
+  /**
+   * No object or array has been started.
+   */
   static final int EMPTY_DOCUMENT = 6;
 
-  /** A document with at an array or object. */
+  /**
+   * A document with at an array or object.
+   */
   static final int NONEMPTY_DOCUMENT = 7;
 
-  /** A document that's been closed and cannot be accessed. */
-  static final int CLOSED = 8;
-
   /**
-   * Renders the path in a JSON document to a string. The {@code pathNames} and {@code pathIndices}
-   * parameters corresponds directly to stack: At indices where the stack contains an object
-   * (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT), pathNames contains the name at this scope.
-   * Where it contains an array (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index
-   * in that array. Otherwise the value is undefined, and we take advantage of that by incrementing
-   * pathIndices when doing so isn't useful.
+   * A document that's been closed and cannot be accessed.
    */
-  static String getPath(int stackSize, int[] stack, String[] pathNames, int[] pathIndices) {
-    StringBuilder result = new StringBuilder().append('$');
-    for (int i = 0, size = stackSize; i < size; i++) {
-      switch (stack[i]) {
-        case EMPTY_ARRAY:
-        case NONEMPTY_ARRAY:
-          result.append('[').append(pathIndices[i]).append(']');
-          break;
-
-        case EMPTY_OBJECT:
-        case DANGLING_NAME:
-        case NONEMPTY_OBJECT:
-          result.append('.');
-          if (pathNames[i] != null) {
-            result.append(pathNames[i]);
-          }
-          break;
-
-        case NONEMPTY_DOCUMENT:
-        case EMPTY_DOCUMENT:
-        case CLOSED:
-          break;
-      }
-    }
-    return result.toString();
-  }
+  static final int CLOSED = 8;
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index 78b44ede..da3de7bc 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -160,9 +160,6 @@ public final class JsonWriter implements Closeable, Flushable {
     push(EMPTY_DOCUMENT);
   }
 
-  private String[] pathNames = new String[32];
-  private int[] pathIndices = new int[32];
-
   /**
    * A string containing a full set of spaces for a single level of
    * indentation, or null for no pretty printing.
@@ -293,7 +290,6 @@ public final class JsonWriter implements Closeable, Flushable {
    */
   private JsonWriter open(int empty, String openBracket) throws IOException {
     beforeValue(true);
-    pathIndices[stackSize] = 0;
     push(empty);
     sink.writeUtf8(openBracket);
     return this;
@@ -314,8 +310,6 @@ public final class JsonWriter implements Closeable, Flushable {
     }
 
     stackSize--;
-    pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
-    pathIndices[stackSize - 1]++;
     if (context == nonempty) {
       newline();
     }
@@ -366,7 +360,6 @@ public final class JsonWriter implements Closeable, Flushable {
       throw new IllegalStateException();
     }
     deferredName = name;
-    pathNames[stackSize - 1] = name;
     return this;
   }
 
@@ -391,7 +384,6 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     string(value);
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -411,7 +403,6 @@ public final class JsonWriter implements Closeable, Flushable {
     }
     beforeValue(false);
     sink.writeUtf8("null");
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -424,7 +415,6 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(value ? "true" : "false");
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -442,7 +432,6 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Double.toString(value));
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -455,7 +444,6 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Long.toString(value));
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -479,7 +467,6 @@ public final class JsonWriter implements Closeable, Flushable {
     }
     beforeValue(false);
     sink.writeUtf8(string);
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -611,12 +598,4 @@ public final class JsonWriter implements Closeable, Flushable {
         throw new IllegalStateException("Nesting problem.");
     }
   }
-
-  /**
-   * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
-   * the current location in the JSON value.
-   */
-  public String getPath() {
-    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
-  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 059ecaf1..5cf94286 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -41,11 +41,11 @@ public final class Moshi {
     this.factories = Collections.unmodifiableList(factories);
   }
 
+  /** Returns a JSON adapter for {@code type}, creating it if necessary. */
   public <T> JsonAdapter<T> adapter(Type type) {
     return adapter(type, Util.NO_ANNOTATIONS);
   }
 
-  /** Returns a JSON adapter for {@code type}, creating it if necessary. */
   public <T> JsonAdapter<T> adapter(Class<T> type) {
     // TODO: cache created JSON adapters.
     return adapter(type, Util.NO_ANNOTATIONS);
@@ -60,10 +60,6 @@ public final class Moshi {
     return createAdapter(factories.indexOf(skipPast) + 1, type, annotations);
   }
 
-  public <T> JsonAdapter<T> nextAdapter(JsonAdapter.Factory skipPast, Type type) {
-    return nextAdapter(skipPast, type, Util.NO_ANNOTATIONS);
-  }
-
   @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
   private <T> JsonAdapter<T> createAdapter(
       int firstIndex, Type type, Set<? extends Annotation> annotations) {
@@ -125,7 +121,10 @@ public final class Moshi {
         @Override public JsonAdapter<?> create(
             Type targetType, Set<? extends Annotation> annotations, Moshi moshi) {
           if (!Util.typesMatch(type, targetType)) return null;
+
+          // TODO: check for an annotations exact match.
           if (!Util.isAnnotationPresent(annotations, annotation)) return null;
+
           return jsonAdapter;
         }
       });
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index baaa4ce2..9283680f 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -18,7 +18,11 @@ package com.squareup.moshi;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
 import java.util.Set;
 
 final class StandardJsonAdapters {
@@ -43,6 +47,7 @@ final class StandardJsonAdapters {
       if (type == Long.class) return LONG_JSON_ADAPTER.nullSafe();
       if (type == Short.class) return SHORT_JSON_ADAPTER.nullSafe();
       if (type == String.class) return STRING_JSON_ADAPTER.nullSafe();
+      if (type == Object.class) return new ObjectJsonAdapter(moshi).nullSafe();
 
       Class<?> rawType = Types.getRawType(type);
       if (rawType.isEnum()) {
@@ -189,4 +194,79 @@ final class StandardJsonAdapters {
       }
     };
   }
+
+  /**
+   * This adapter is used when the declared type is {@code java.lang.Object}. Typically the runtime
+   * type is something else, and when encoding JSON this delegates to the runtime type's adapter.
+   * For decoding (where there is no runtime type to inspect), this uses maps and lists.
+   *
+   * <p>This adapter needs a Moshi instance to look up the appropriate adapter for runtime types as
+   * they are encountered.
+   */
+  static final class ObjectJsonAdapter extends JsonAdapter<Object> {
+    private final Moshi moshi;
+
+    public ObjectJsonAdapter(Moshi moshi) {
+      this.moshi = moshi;
+    }
+
+    @Override public Object fromJson(JsonReader reader) throws IOException {
+      switch (reader.peek()) {
+        case BEGIN_ARRAY:
+          List<Object> list = new ArrayList<>();
+          reader.beginArray();
+          while (reader.hasNext()) {
+            list.add(fromJson(reader));
+          }
+          reader.endArray();
+          return list;
+
+        case BEGIN_OBJECT:
+          Map<String, Object> map = new LinkedHashTreeMap<>();
+          reader.beginObject();
+          while (reader.hasNext()) {
+            map.put(reader.nextName(), fromJson(reader));
+          }
+          reader.endObject();
+          return map;
+
+        case STRING:
+          return reader.nextString();
+
+        case NUMBER:
+          return reader.nextDouble();
+
+        case BOOLEAN:
+          return reader.nextBoolean();
+
+        default:
+          throw new IllegalStateException("Expected a value but was " + reader.peek()
+              + " at path " + reader.getPath());
+      }
+    }
+
+    @Override public void toJson(JsonWriter writer, Object value) throws IOException {
+      Class<?> valueClass = value.getClass();
+      if (valueClass == Object.class) {
+        // Don't recurse infinitely when the runtime type is also Object.class.
+        writer.beginObject();
+        writer.endObject();
+      } else {
+        moshi.adapter(toJsonType(valueClass), Util.NO_ANNOTATIONS).toJson(writer, value);
+      }
+    }
+
+    /**
+     * Returns the type to look up a type adapter for when writing {@code value} to JSON. Without
+     * this, attempts to emit standard types like `LinkedHashMap` would fail because Moshi doesn't
+     * provide built-in adapters for implementation types. It knows how to <strong>write</strong>
+     * those types, but lacks a mechanism to read them because it doesn't know how to find the
+     * appropriate constructor.
+     */
+    private Class<?> toJsonType(Class<?> valueClass) {
+      if (Map.class.isAssignableFrom(valueClass)) return Map.class;
+      if (Collection.class.isAssignableFrom(valueClass)) return Collection.class;
+      return valueClass;
+    }
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/Types.java b/moshi/src/main/java/com/squareup/moshi/Types.java
index 7f3fe71e..73b80cfa 100644
--- a/moshi/src/main/java/com/squareup/moshi/Types.java
+++ b/moshi/src/main/java/com/squareup/moshi/Types.java
@@ -48,18 +48,6 @@ final class Types {
     return new ParameterizedTypeImpl(null, rawType, typeArguments);
   }
 
-  /**
-   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and
-   * enclosed by {@code ownerType}.
-   */
-  public static ParameterizedType newParameterizedTypeWithOwner(
-      Type ownerType, Type rawType, Type... typeArguments) {
-    if (ownerType == null) {
-      throw new NullPointerException("ownerType");
-    }
-    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);
-  }
-
   /** Returns an array type whose elements are all instances of {@code componentType}. */
   public static GenericArrayType arrayOf(Type componentType) {
     return new GenericArrayTypeImpl(componentType);
