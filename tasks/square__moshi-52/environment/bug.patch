diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
index 901c55c2..e33e1f38 100644
--- a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
@@ -24,6 +24,9 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
+// TODO: support @Nullable
+// TODO: path in JsonWriter.
+
 final class AdapterMethodsFactory implements JsonAdapter.Factory {
   private final List<AdapterMethod> toAdapters;
   private final List<AdapterMethod> fromAdapters;
@@ -56,7 +59,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
             throw new AssertionError();
           } catch (InvocationTargetException e) {
             if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause()); // TODO: more context?
+            throw new JsonDataException(e.getCause() + " at " + writer.getPath());
           }
         }
       }
@@ -74,7 +77,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
             throw new AssertionError();
           } catch (InvocationTargetException e) {
             if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause()); // TODO: more context?
+            throw new JsonDataException(e.getCause() + " at " + reader.getPath());
           }
         }
       }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index f4d125dd..d7d8ca55 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -248,14 +248,6 @@ public final class JsonReader implements Closeable {
     stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
   }
 
-  /*
-   * The path members. It corresponds directly to stack: At indices where the
-   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
-   * pathNames contains the name at this scope. Where it contains an array
-   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
-   * that array. Otherwise the value is undefined, and we take advantage of that
-   * by incrementing pathIndices when doing so isn't useful.
-   */
   private String[] pathNames = new String[32];
   private int[] pathIndices = new int[32];
 
@@ -1206,8 +1198,11 @@ public final class JsonReader implements Closeable {
             return c;
         }
       } else if (c == '#') {
-        // Skip a # hash end-of-line comment. The JSON RFC doesn't specify this behaviour, but it's
-        // required to parse existing documents. See http://b/2571423.
+        /*
+         * Skip a # hash end-of-line comment. The JSON RFC doesn't
+         * specify this behaviour, but it's required to parse
+         * existing documents. See http://b/2571423.
+         */
         checkLenient();
         skipToEndOfLine();
         p = 0;
@@ -1264,30 +1259,7 @@ public final class JsonReader implements Closeable {
    * the current location in the JSON value.
    */
   public String getPath() {
-    StringBuilder result = new StringBuilder().append('$');
-    for (int i = 0, size = stackSize; i < size; i++) {
-      switch (stack[i]) {
-        case JsonScope.EMPTY_ARRAY:
-        case JsonScope.NONEMPTY_ARRAY:
-          result.append('[').append(pathIndices[i]).append(']');
-          break;
-
-        case JsonScope.EMPTY_OBJECT:
-        case JsonScope.DANGLING_NAME:
-        case JsonScope.NONEMPTY_OBJECT:
-          result.append('.');
-          if (pathNames[i] != null) {
-            result.append(pathNames[i]);
-          }
-          break;
-
-        case JsonScope.NONEMPTY_DOCUMENT:
-        case JsonScope.EMPTY_DOCUMENT:
-        case JsonScope.CLOSED:
-          break;
-      }
-    }
-    return result.toString();
+    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
   }
 
   /**
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonScope.java b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
index 776d7251..180839ad 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonScope.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
@@ -15,53 +15,65 @@
  */
 package com.squareup.moshi;
 
-/**
- * Lexical scoping elements within a JSON reader or writer.
- */
+/** Lexical scoping elements within a JSON reader or writer. */
 final class JsonScope {
 
-  /**
-   * An array with no elements requires no separators or newlines before
-   * it is closed.
-   */
+  /** An array with no elements requires no separators or newlines before it is closed. */
   static final int EMPTY_ARRAY = 1;
 
-  /**
-   * A array with at least one value requires a comma and newline before
-   * the next element.
-   */
+  /** A array with at least one value requires a comma and newline before the next element. */
   static final int NONEMPTY_ARRAY = 2;
 
-  /**
-   * An object with no name/value pairs requires no separators or newlines
-   * before it is closed.
-   */
+  /** An object with no name/value pairs requires no separators or newlines before it is closed. */
   static final int EMPTY_OBJECT = 3;
 
-  /**
-   * An object whose most recent element is a key. The next element must
-   * be a value.
-   */
+  /** An object whose most recent element is a key. The next element must be a value. */
   static final int DANGLING_NAME = 4;
 
-  /**
-   * An object with at least one name/value pair requires a comma and
-   * newline before the next element.
-   */
+  /** An object with at least one name/value pair requires a separator before the next element. */
   static final int NONEMPTY_OBJECT = 5;
 
-  /**
-   * No object or array has been started.
-   */
+  /** No object or array has been started. */
   static final int EMPTY_DOCUMENT = 6;
 
-  /**
-   * A document with at an array or object.
-   */
+  /** A document with at an array or object. */
   static final int NONEMPTY_DOCUMENT = 7;
 
+  /** A document that's been closed and cannot be accessed. */
+  static final int CLOSED = 8;
+
   /**
-   * A document that's been closed and cannot be accessed.
+   * Renders the path in a JSON document to a string. The {@code pathNames} and {@code pathIndices}
+   * parameters corresponds directly to stack: At indices where the stack contains an object
+   * (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT), pathNames contains the name at this scope.
+   * Where it contains an array (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index
+   * in that array. Otherwise the value is undefined, and we take advantage of that by incrementing
+   * pathIndices when doing so isn't useful.
    */
-  static final int CLOSED = 8;
+  static String getPath(int stackSize, int[] stack, String[] pathNames, int[] pathIndices) {
+    StringBuilder result = new StringBuilder().append('$');
+    for (int i = 0, size = stackSize; i < size; i++) {
+      switch (stack[i]) {
+        case EMPTY_ARRAY:
+        case NONEMPTY_ARRAY:
+          result.append('[').append(pathIndices[i]).append(']');
+          break;
+
+        case EMPTY_OBJECT:
+        case DANGLING_NAME:
+        case NONEMPTY_OBJECT:
+          result.append('.');
+          if (pathNames[i] != null) {
+            result.append(pathNames[i]);
+          }
+          break;
+
+        case NONEMPTY_DOCUMENT:
+        case EMPTY_DOCUMENT:
+        case CLOSED:
+          break;
+      }
+    }
+    return result.toString();
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index da3de7bc..78b44ede 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -160,6 +160,9 @@ public final class JsonWriter implements Closeable, Flushable {
     push(EMPTY_DOCUMENT);
   }
 
+  private String[] pathNames = new String[32];
+  private int[] pathIndices = new int[32];
+
   /**
    * A string containing a full set of spaces for a single level of
    * indentation, or null for no pretty printing.
@@ -290,6 +293,7 @@ public final class JsonWriter implements Closeable, Flushable {
    */
   private JsonWriter open(int empty, String openBracket) throws IOException {
     beforeValue(true);
+    pathIndices[stackSize] = 0;
     push(empty);
     sink.writeUtf8(openBracket);
     return this;
@@ -310,6 +314,8 @@ public final class JsonWriter implements Closeable, Flushable {
     }
 
     stackSize--;
+    pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
+    pathIndices[stackSize - 1]++;
     if (context == nonempty) {
       newline();
     }
@@ -360,6 +366,7 @@ public final class JsonWriter implements Closeable, Flushable {
       throw new IllegalStateException();
     }
     deferredName = name;
+    pathNames[stackSize - 1] = name;
     return this;
   }
 
@@ -384,6 +391,7 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     string(value);
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -403,6 +411,7 @@ public final class JsonWriter implements Closeable, Flushable {
     }
     beforeValue(false);
     sink.writeUtf8("null");
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -415,6 +424,7 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(value ? "true" : "false");
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -432,6 +442,7 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Double.toString(value));
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -444,6 +455,7 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Long.toString(value));
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -467,6 +479,7 @@ public final class JsonWriter implements Closeable, Flushable {
     }
     beforeValue(false);
     sink.writeUtf8(string);
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -598,4 +611,12 @@ public final class JsonWriter implements Closeable, Flushable {
         throw new IllegalStateException("Nesting problem.");
     }
   }
+
+  /**
+   * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
+   * the current location in the JSON value.
+   */
+  public String getPath() {
+    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 5cf94286..059ecaf1 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -41,11 +41,11 @@ public final class Moshi {
     this.factories = Collections.unmodifiableList(factories);
   }
 
-  /** Returns a JSON adapter for {@code type}, creating it if necessary. */
   public <T> JsonAdapter<T> adapter(Type type) {
     return adapter(type, Util.NO_ANNOTATIONS);
   }
 
+  /** Returns a JSON adapter for {@code type}, creating it if necessary. */
   public <T> JsonAdapter<T> adapter(Class<T> type) {
     // TODO: cache created JSON adapters.
     return adapter(type, Util.NO_ANNOTATIONS);
@@ -60,6 +60,10 @@ public final class Moshi {
     return createAdapter(factories.indexOf(skipPast) + 1, type, annotations);
   }
 
+  public <T> JsonAdapter<T> nextAdapter(JsonAdapter.Factory skipPast, Type type) {
+    return nextAdapter(skipPast, type, Util.NO_ANNOTATIONS);
+  }
+
   @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
   private <T> JsonAdapter<T> createAdapter(
       int firstIndex, Type type, Set<? extends Annotation> annotations) {
@@ -121,10 +125,7 @@ public final class Moshi {
         @Override public JsonAdapter<?> create(
             Type targetType, Set<? extends Annotation> annotations, Moshi moshi) {
           if (!Util.typesMatch(type, targetType)) return null;
-
-          // TODO: check for an annotations exact match.
           if (!Util.isAnnotationPresent(annotations, annotation)) return null;
-
           return jsonAdapter;
         }
       });
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index 9283680f..baaa4ce2 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -18,11 +18,7 @@ package com.squareup.moshi;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
 import java.util.Set;
 
 final class StandardJsonAdapters {
@@ -47,7 +43,6 @@ final class StandardJsonAdapters {
       if (type == Long.class) return LONG_JSON_ADAPTER.nullSafe();
       if (type == Short.class) return SHORT_JSON_ADAPTER.nullSafe();
       if (type == String.class) return STRING_JSON_ADAPTER.nullSafe();
-      if (type == Object.class) return new ObjectJsonAdapter(moshi).nullSafe();
 
       Class<?> rawType = Types.getRawType(type);
       if (rawType.isEnum()) {
@@ -194,79 +189,4 @@ final class StandardJsonAdapters {
       }
     };
   }
-
-  /**
-   * This adapter is used when the declared type is {@code java.lang.Object}. Typically the runtime
-   * type is something else, and when encoding JSON this delegates to the runtime type's adapter.
-   * For decoding (where there is no runtime type to inspect), this uses maps and lists.
-   *
-   * <p>This adapter needs a Moshi instance to look up the appropriate adapter for runtime types as
-   * they are encountered.
-   */
-  static final class ObjectJsonAdapter extends JsonAdapter<Object> {
-    private final Moshi moshi;
-
-    public ObjectJsonAdapter(Moshi moshi) {
-      this.moshi = moshi;
-    }
-
-    @Override public Object fromJson(JsonReader reader) throws IOException {
-      switch (reader.peek()) {
-        case BEGIN_ARRAY:
-          List<Object> list = new ArrayList<>();
-          reader.beginArray();
-          while (reader.hasNext()) {
-            list.add(fromJson(reader));
-          }
-          reader.endArray();
-          return list;
-
-        case BEGIN_OBJECT:
-          Map<String, Object> map = new LinkedHashTreeMap<>();
-          reader.beginObject();
-          while (reader.hasNext()) {
-            map.put(reader.nextName(), fromJson(reader));
-          }
-          reader.endObject();
-          return map;
-
-        case STRING:
-          return reader.nextString();
-
-        case NUMBER:
-          return reader.nextDouble();
-
-        case BOOLEAN:
-          return reader.nextBoolean();
-
-        default:
-          throw new IllegalStateException("Expected a value but was " + reader.peek()
-              + " at path " + reader.getPath());
-      }
-    }
-
-    @Override public void toJson(JsonWriter writer, Object value) throws IOException {
-      Class<?> valueClass = value.getClass();
-      if (valueClass == Object.class) {
-        // Don't recurse infinitely when the runtime type is also Object.class.
-        writer.beginObject();
-        writer.endObject();
-      } else {
-        moshi.adapter(toJsonType(valueClass), Util.NO_ANNOTATIONS).toJson(writer, value);
-      }
-    }
-
-    /**
-     * Returns the type to look up a type adapter for when writing {@code value} to JSON. Without
-     * this, attempts to emit standard types like `LinkedHashMap` would fail because Moshi doesn't
-     * provide built-in adapters for implementation types. It knows how to <strong>write</strong>
-     * those types, but lacks a mechanism to read them because it doesn't know how to find the
-     * appropriate constructor.
-     */
-    private Class<?> toJsonType(Class<?> valueClass) {
-      if (Map.class.isAssignableFrom(valueClass)) return Map.class;
-      if (Collection.class.isAssignableFrom(valueClass)) return Collection.class;
-      return valueClass;
-    }
-  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/Types.java b/moshi/src/main/java/com/squareup/moshi/Types.java
index 73b80cfa..7f3fe71e 100644
--- a/moshi/src/main/java/com/squareup/moshi/Types.java
+++ b/moshi/src/main/java/com/squareup/moshi/Types.java
@@ -48,6 +48,18 @@ final class Types {
     return new ParameterizedTypeImpl(null, rawType, typeArguments);
   }
 
+  /**
+   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType} and
+   * enclosed by {@code ownerType}.
+   */
+  public static ParameterizedType newParameterizedTypeWithOwner(
+      Type ownerType, Type rawType, Type... typeArguments) {
+    if (ownerType == null) {
+      throw new NullPointerException("ownerType");
+    }
+    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);
+  }
+
   /** Returns an array type whose elements are all instances of {@code componentType}. */
   public static GenericArrayType arrayOf(Type componentType) {
     return new GenericArrayTypeImpl(componentType);
diff --git a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java b/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
index f864f57d..2de853b6 100644
--- a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
@@ -233,6 +233,37 @@ public final class AdapterMethodsTest {
   @interface Nullable {
   }
 
+  @Test public void adapterThrows() throws Exception {
+    Moshi moshi = new Moshi.Builder()
+        .add(new ExceptionThrowingPointJsonAdapter())
+        .build();
+    JsonAdapter<Point[]> arrayOfPointAdapter = moshi.adapter(Point[].class).lenient();
+    try {
+      arrayOfPointAdapter.toJson(new Point[] { null, null, new Point(0, 0) });
+      fail();
+    } catch (JsonDataException expected) {
+      assertThat(expected.getMessage())
+          .isEqualTo("java.lang.Exception: pointToJson fail! at $[2]");
+    }
+    try {
+      arrayOfPointAdapter.fromJson("[null,null,[0,0]]");
+      fail();
+    } catch (JsonDataException expected) {
+      assertThat(expected.getMessage())
+          .isEqualTo("java.lang.Exception: pointFromJson fail! at $[2]");
+    }
+  }
+
+  static class ExceptionThrowingPointJsonAdapter {
+    @ToJson void pointToJson(JsonWriter writer, Point point) throws Exception {
+      throw new Exception("pointToJson fail!");
+    }
+
+    @FromJson Point pointFromJson(JsonReader reader) throws Exception {
+      throw new Exception("pointFromJson fail!");
+    }
+  }
+
   static class Point {
     final int x;
     final int y;
diff --git a/moshi/src/test/java/com/squareup/moshi/CircularAdaptersTest.java b/moshi/src/test/java/com/squareup/moshi/CircularAdaptersTest.java
index 14256f34..f5652e9f 100644
--- a/moshi/src/test/java/com/squareup/moshi/CircularAdaptersTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/CircularAdaptersTest.java
@@ -113,7 +113,7 @@ public final class CircularAdaptersTest {
         return null;
       }
 
-      final JsonAdapter<Node> delegate = moshi.nextAdapter(this, Node.class, Util.NO_ANNOTATIONS);
+      final JsonAdapter<Node> delegate = moshi.nextAdapter(this, Node.class);
 
       return new JsonAdapter<Node>() {
         @Override public void toJson(JsonWriter writer, Node value) throws IOException {
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonWriterPathTest.java b/moshi/src/test/java/com/squareup/moshi/JsonWriterPathTest.java
new file mode 100644
index 00000000..43badd39
--- /dev/null
+++ b/moshi/src/test/java/com/squareup/moshi/JsonWriterPathTest.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2014 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public final class JsonWriterPathTest {
+  @Test public void path() throws IOException {
+    JsonWriter writer = new JsonWriter(new Buffer());
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$.");
+    writer.name("a");
+    assertThat(writer.getPath()).isEqualTo("$.a");
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$.a[0]");
+    writer.value(2);
+    assertThat(writer.getPath()).isEqualTo("$.a[1]");
+    writer.value(true);
+    assertThat(writer.getPath()).isEqualTo("$.a[2]");
+    writer.value(false);
+    assertThat(writer.getPath()).isEqualTo("$.a[3]");
+    writer.nullValue();
+    assertThat(writer.getPath()).isEqualTo("$.a[4]");
+    writer.value("b");
+    assertThat(writer.getPath()).isEqualTo("$.a[5]");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$.a[5].");
+    writer.name("c");
+    assertThat(writer.getPath()).isEqualTo("$.a[5].c");
+    writer.value("d");
+    assertThat(writer.getPath()).isEqualTo("$.a[5].c");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$.a[6]");
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$.a[6][0]");
+    writer.value(3);
+    assertThat(writer.getPath()).isEqualTo("$.a[6][1]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$.a[7]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$.a");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$");
+  }
+
+  @Test public void arrayOfObjects() throws IOException {
+    JsonWriter writer = new JsonWriter(new Buffer());
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$[0]");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$[0].");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$[1]");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$[1].");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$[2]");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$[2].");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$[3]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$");
+  }
+
+  @Test public void arrayOfArrays() throws IOException {
+    JsonWriter writer = new JsonWriter(new Buffer());
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$[0]");
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$[0][0]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$[1]");
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$[1][0]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$[2]");
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$[2][0]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$[3]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$");
+  }
+
+  @Test public void objectPath() throws IOException {
+    JsonWriter writer = new JsonWriter(new Buffer());
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$.");
+    writer.name("a");
+    assertThat(writer.getPath()).isEqualTo("$.a");
+    writer.value(1);
+    assertThat(writer.getPath()).isEqualTo("$.a");
+    writer.name("b");
+    assertThat(writer.getPath()).isEqualTo("$.b");
+    writer.value(2);
+    assertThat(writer.getPath()).isEqualTo("$.b");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.close();
+    assertThat(writer.getPath()).isEqualTo("$");
+  }
+
+  @Test public void nestedObjects() throws IOException {
+    JsonWriter writer = new JsonWriter(new Buffer());
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$.");
+    writer.name("a");
+    assertThat(writer.getPath()).isEqualTo("$.a");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$.a.");
+    writer.name("b");
+    assertThat(writer.getPath()).isEqualTo("$.a.b");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$.a.b.");
+    writer.name("c");
+    assertThat(writer.getPath()).isEqualTo("$.a.b.c");
+    writer.nullValue();
+    assertThat(writer.getPath()).isEqualTo("$.a.b.c");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$.a.b");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$.a");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$");
+  }
+
+  @Test public void arrayPath() throws IOException {
+    JsonWriter writer = new JsonWriter(new Buffer());
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$[0]");
+    writer.value(1);
+    assertThat(writer.getPath()).isEqualTo("$[1]");
+    writer.value(true);
+    assertThat(writer.getPath()).isEqualTo("$[2]");
+    writer.value("a");
+    assertThat(writer.getPath()).isEqualTo("$[3]");
+    writer.value(5.5d);
+    assertThat(writer.getPath()).isEqualTo("$[4]");
+    writer.value(BigInteger.ONE);
+    assertThat(writer.getPath()).isEqualTo("$[5]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.close();
+    assertThat(writer.getPath()).isEqualTo("$");
+  }
+
+  @Test public void nestedArrays() throws IOException {
+    JsonWriter writer = new JsonWriter(new Buffer());
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$[0]");
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$[0][0]");
+    writer.beginArray();
+    assertThat(writer.getPath()).isEqualTo("$[0][0][0]");
+    writer.nullValue();
+    assertThat(writer.getPath()).isEqualTo("$[0][0][1]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$[0][1]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$[1]");
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.close();
+    assertThat(writer.getPath()).isEqualTo("$");
+  }
+
+  @Test public void multipleTopLevelValuesInOneDocument() throws IOException {
+    JsonWriter writer = new JsonWriter(new Buffer());
+    writer.setLenient(true);
+    writer.beginArray();
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.beginArray();
+    writer.endArray();
+    assertThat(writer.getPath()).isEqualTo("$");
+  }
+
+  @Test public void skipNulls() throws IOException {
+    JsonWriter writer = new JsonWriter(new Buffer());
+    writer.setSerializeNulls(false);
+    assertThat(writer.getPath()).isEqualTo("$");
+    writer.beginObject();
+    assertThat(writer.getPath()).isEqualTo("$.");
+    writer.name("a");
+    assertThat(writer.getPath()).isEqualTo("$.a");
+    writer.nullValue();
+    assertThat(writer.getPath()).isEqualTo("$.a");
+    writer.name("b");
+    assertThat(writer.getPath()).isEqualTo("$.b");
+    writer.nullValue();
+    assertThat(writer.getPath()).isEqualTo("$.b");
+    writer.endObject();
+    assertThat(writer.getPath()).isEqualTo("$");
+  }
+}
diff --git a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
index 433965f3..23c0d5bb 100644
--- a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
@@ -35,6 +35,7 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class MoshiTest {
+
   @Test public void booleanAdapter() throws Exception {
     Moshi moshi = new Moshi.Builder().build();
     JsonAdapter<Boolean> adapter = moshi.adapter(boolean.class).lenient();
@@ -791,8 +792,7 @@ public final class MoshiTest {
       if (!type.equals(String.class)) return null;
       if (!Util.isAnnotationPresent(annotations, Uppercase.class)) return null;
 
-      final JsonAdapter<String> stringAdapter
-          = moshi.nextAdapter(this, String.class, Util.NO_ANNOTATIONS);
+      final JsonAdapter<String> stringAdapter = moshi.nextAdapter(this, String.class);
       return new JsonAdapter<String>() {
         @Override public String fromJson(JsonReader reader) throws IOException {
           String s = stringAdapter.fromJson(reader);
diff --git a/moshi/src/test/java/com/squareup/moshi/ObjectAdapterTest.java b/moshi/src/test/java/com/squareup/moshi/ObjectAdapterTest.java
deleted file mode 100644
index eea26695..00000000
--- a/moshi/src/test/java/com/squareup/moshi/ObjectAdapterTest.java
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.util.AbstractCollection;
-import java.util.AbstractList;
-import java.util.AbstractMap;
-import java.util.AbstractSet;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class ObjectAdapterTest {
-  @Test public void toJsonUsesRuntimeType() throws Exception {
-    Delivery delivery = new Delivery();
-    delivery.address = "1455 Market St.";
-    Pizza pizza = new Pizza();
-    pizza.diameter = 12;
-    pizza.extraCheese = true;
-    delivery.items = Arrays.asList(pizza, "Pepsi");
-
-    Moshi moshi = new Moshi.Builder().build();
-    JsonAdapter<Object> adapter = moshi.adapter(Object.class);
-    assertThat(adapter.toJson(delivery)).isEqualTo("{"
-        + "\"address\":\"1455 Market St.\","
-        + "\"items\":["
-        + "{\"diameter\":12,\"extraCheese\":true},"
-        + "\"Pepsi\""
-        + "]"
-        + "}");
-  }
-
-  @Test public void toJsonJavaLangObject() throws Exception {
-    Moshi moshi = new Moshi.Builder().build();
-    JsonAdapter<Object> adapter = moshi.adapter(Object.class);
-    assertThat(adapter.toJson(new Object())).isEqualTo("{}");
-  }
-
-  @Test public void fromJsonReturnsMapsAndLists() throws Exception {
-    Map<Object, Object> delivery = new LinkedHashMap<>();
-    delivery.put("address", "1455 Market St.");
-    Map<Object, Object> pizza = new LinkedHashMap<>();
-    pizza.put("diameter", 12d);
-    pizza.put("extraCheese", true);
-    delivery.put("items", Arrays.asList(pizza, "Pepsi"));
-
-    Moshi moshi = new Moshi.Builder().build();
-    JsonAdapter<Object> adapter = moshi.adapter(Object.class);
-    assertThat(adapter.fromJson("{"
-        + "\"address\":\"1455 Market St.\","
-        + "\"items\":["
-        + "{\"diameter\":12,\"extraCheese\":true},"
-        + "\"Pepsi\""
-        + "]"
-        + "}")).isEqualTo(delivery);
-  }
-
-  @Test public void fromJsonUsesDoublesForNumbers() throws Exception {
-    Moshi moshi = new Moshi.Builder().build();
-    JsonAdapter<Object> adapter = moshi.adapter(Object.class);
-    assertThat(adapter.fromJson("[0, 1]")).isEqualTo(Arrays.asList(0d, 1d));
-  }
-
-  @Test public void toJsonCoercesRuntimeTypeForCollections() throws Exception {
-    Collection<String> collection = new AbstractCollection<String>() {
-      @Override public Iterator<String> iterator() {
-        return Collections.singleton("A").iterator();
-      }
-      @Override public int size() {
-        return 1;
-      }
-    };
-
-    Moshi moshi = new Moshi.Builder().build();
-    JsonAdapter<Object> adapter = moshi.adapter(Object.class);
-    assertThat(adapter.toJson(collection)).isEqualTo("[\"A\"]");
-  }
-
-  @Test public void toJsonCoercesRuntimeTypeForLists() throws Exception {
-    List<String> list = new AbstractList<String>() {
-      @Override public String get(int i) {
-        return "A";
-      }
-
-      @Override public int size() {
-        return 1;
-      }
-    };
-
-    Moshi moshi = new Moshi.Builder().build();
-    JsonAdapter<Object> adapter = moshi.adapter(Object.class);
-    assertThat(adapter.toJson(list)).isEqualTo("[\"A\"]");
-  }
-
-  @Test public void toJsonCoercesRuntimeTypeForSets() throws Exception {
-    Set<String> set = new AbstractSet<String>() {
-      @Override public Iterator<String> iterator() {
-        return Collections.singleton("A").iterator();
-      }
-      @Override public int size() {
-        return 1;
-      }
-    };
-
-    Moshi moshi = new Moshi.Builder().build();
-    JsonAdapter<Object> adapter = moshi.adapter(Object.class);
-    assertThat(adapter.toJson(set)).isEqualTo("[\"A\"]");
-  }
-
-  @Ignore // We don't support raw maps, like Map<Object, Object>. (Even if the keys are strings!)
-  @Test public void toJsonCoercesRuntimeTypeForMaps() throws Exception {
-    Map<String, Boolean> map = new AbstractMap<String, Boolean>() {
-      @Override public Set<Entry<String, Boolean>> entrySet() {
-        return Collections.singletonMap("A", true).entrySet();
-      }
-    };
-
-    Moshi moshi = new Moshi.Builder().build();
-    JsonAdapter<Object> adapter = moshi.adapter(Object.class);
-    assertThat(adapter.toJson(map)).isEqualTo("{\"A\":true}");
-  }
-
-  @Test public void toJsonUsesTypeAdapters() throws Exception {
-    Object dateAdapter = new Object() {
-      @ToJson Long dateToJson(Date d) {
-        return d.getTime();
-      }
-      @FromJson Date dateFromJson(Long millis) {
-        return new Date(millis);
-      }
-    };
-    Moshi moshi = new Moshi.Builder()
-        .add(dateAdapter)
-        .build();
-    JsonAdapter<Object> adapter = moshi.adapter(Object.class);
-    assertThat(adapter.toJson(Arrays.asList(new Date(1), new Date(2)))).isEqualTo("[1,2]");
-  }
-
-  static class Delivery {
-    String address;
-    List<Object> items;
-  }
-
-  static class Pizza {
-    int diameter;
-    boolean extraCheese;
-  }
-}
