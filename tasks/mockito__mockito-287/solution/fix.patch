diff --git a/src/main/java/org/mockito/junit/MockitoJUnit.java b/src/main/java/org/mockito/junit/MockitoJUnit.java
index f13b66779..b680079e8 100644
--- a/src/main/java/org/mockito/junit/MockitoJUnit.java
+++ b/src/main/java/org/mockito/junit/MockitoJUnit.java
@@ -16,4 +16,14 @@ public class MockitoJUnit {
     public static MockitoRule rule() {
         return new MockitoJUnitRule();
     }
+
+    /**
+     * Creates a rule instance that can perform lazy verifications.
+     *
+     * @see VerificationCollector
+     * @return the rule instance
+     */
+    public static VerificationCollector collector() {
+        return new VerificationCollectorImpl();
+    }
 }
diff --git a/src/main/java/org/mockito/junit/VerificationCollector.java b/src/main/java/org/mockito/junit/VerificationCollector.java
new file mode 100644
index 000000000..432dc55b3
--- /dev/null
+++ b/src/main/java/org/mockito/junit/VerificationCollector.java
@@ -0,0 +1,62 @@
+package org.mockito.junit;
+
+import org.junit.rules.TestRule;
+import org.mockito.exceptions.base.MockitoAssertionError;
+import org.mockito.verification.VerificationMode;
+
+/**
+ * Use this rule in order to collect multiple verification failures and report at once.
+ *
+ * In the example below, the verification failure thrown by {@code byteReturningMethod()} does not block
+ * verifying against the {@code simpleMethod()}. After the test is run, a report is generated stating all
+ * collect verification failures.
+ *
+ * <pre class="code"><code class="java">
+ *   &#064;Rule
+ *   public VerificationCollector collector = MockitoJUnit.collector();
+ *
+ *   &#064;Test
+ *   public void should_fail() {
+ *       IMethods methods = mock(IMethods.class);
+ *
+ *       collector.verify(methods).byteReturningMethod();
+ *       collector.verify(methods).simpleMethod();
+ *   }
+ * </code></pre>
+ *
+ * @see org.mockito.Mockito#verify(Object)
+ * @see org.mockito.Mockito#verify(Object, VerificationMode)
+ */
+public interface VerificationCollector extends TestRule {
+
+    /**
+     * Lazily verify certain behaviour happened once.
+     *
+     * @see org.mockito.Mockito#verify(Object)
+     *
+     * @param <T> The type of the mock
+     * @param mock to be verified
+     * @return mock object itself
+     */
+    <T> T verify(T mock);
+
+    /**
+     * Lazily verify certain behaviour happened at least once / exact number of times / never.
+     *
+     * @see org.mockito.Mockito#verify(Object, VerificationMode)
+     *
+     * @param mock to be verified
+     * @param mode times(x), atLeastOnce() or never()
+     * @param <T> The type of the mock
+     * @return mock object itself
+     */
+    <T> T verify(T mock, VerificationMode mode);
+
+    /**
+     * Collect all lazily verified behaviour. If there were failed verifications, it will
+     * throw a MockitoAssertionError containing all messages indicating the failed verifications.
+     *
+     * @throws MockitoAssertionError If there were failed verifications
+     */
+    void collectAndReport() throws MockitoAssertionError;
+}
diff --git a/src/main/java/org/mockito/junit/VerificationCollectorImpl.java b/src/main/java/org/mockito/junit/VerificationCollectorImpl.java
new file mode 100644
index 000000000..64b7ec269
--- /dev/null
+++ b/src/main/java/org/mockito/junit/VerificationCollectorImpl.java
@@ -0,0 +1,89 @@
+package org.mockito.junit;
+
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+import org.mockito.exceptions.base.MockitoAssertionError;
+import org.mockito.internal.MockitoCore;
+import org.mockito.internal.verification.api.VerificationData;
+import org.mockito.verification.VerificationMode;
+
+import static org.mockito.Mockito.times;
+
+/**
+ * Mockito implementation of VerificationCollector.
+ */
+class VerificationCollectorImpl implements VerificationCollector {
+
+    private static final MockitoCore MOCKITO_CORE = new MockitoCore();
+
+    private StringBuilder builder;
+    private int numberOfFailures;
+
+    public VerificationCollectorImpl() {
+        this.resetBuilder();
+    }
+
+    public Statement apply(final Statement base, final Description description) {
+        return new Statement() {
+            @Override
+            public void evaluate() throws Throwable {
+                base.evaluate();
+                VerificationCollectorImpl.this.collectAndReport();
+            }
+        };
+    }
+
+    public <T> T verify(T mock) {
+        return MOCKITO_CORE.verify(mock, new VerificationWrapper(times(1)));
+    }
+
+    public <T> T verify(T mock, VerificationMode mode) {
+        return MOCKITO_CORE.verify(mock, new VerificationWrapper(mode));
+    }
+
+    public void collectAndReport() throws MockitoAssertionError {
+        if (this.numberOfFailures > 0) {
+            String error = this.builder.toString();
+
+            this.resetBuilder();
+
+            throw new MockitoAssertionError(error);
+        }
+    }
+
+    private void resetBuilder() {
+        this.builder = new StringBuilder()
+                .append("There were multiple verification failures:");
+        this.numberOfFailures = 0;
+    }
+
+    private void append(String message) {
+        this.numberOfFailures++;
+        this.builder.append('\n')
+                .append(this.numberOfFailures).append(". ")
+                .append(message.substring(1, message.length()));
+    }
+
+    private class VerificationWrapper implements VerificationMode {
+
+        private final VerificationMode delegate;
+
+        private VerificationWrapper(VerificationMode delegate) {
+            this.delegate = delegate;
+        }
+
+        public void verify(VerificationData data) {
+            try {
+                this.delegate.verify(data);
+            } catch (MockitoAssertionError error) {
+                VerificationCollectorImpl.this.append(error.getMessage());
+            }
+        }
+
+        public VerificationMode description(String description) {
+            throw new IllegalStateException("Should not fail in this mode");
+        }
+    }
+
+}
