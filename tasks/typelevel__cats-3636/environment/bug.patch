diff --git a/.scalafmt.conf b/.scalafmt.conf
index 1c755c6b1..0d8ef1811 100644
--- a/.scalafmt.conf
+++ b/.scalafmt.conf
@@ -10,4 +10,3 @@ docstrings = JavaDoc
 newlines.afterCurlyLambda = preserve
 docstrings.style = Asterisk
 docstrings.oneline = unfold
-project.excludeFilters = [ "core/src/main/scala-3.x" ]
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index 7323e513f..9ae89998e 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -13,7 +13,7 @@ jdk:
 
 scala_version_212: &scala_version_212 2.12.12
 scala_version_213: &scala_version_213 2.13.3
-dotty_version: &dotty_version 0.27.0-RC1
+dotty_version: &dotty_version 0.24.0
 
 before_install:
  - export PATH=${PATH}:./vendor/bundle
@@ -53,6 +53,7 @@ jobs:
       scala: *scala_version_213
       after_success: codecov -F scala_version_213
 
+
     - stage: test
       name: Make Microsite on 2.12.10
       env: TEST="docs"
@@ -74,10 +75,11 @@ jobs:
       name: Binary compatibility 2.13
       scala: *scala_version_213
 
+    # Note that we're currently only building some modules on Dotty, not running tests.
     - stage: test
       name: Dotty tests
       env: TEST="Dotty tests"
-      script: sbt ++$TRAVIS_SCALA_VERSION! buildJVM bench/test
+      script: sbt ++$TRAVIS_SCALA_VERSION! alleycatsLawsJVM/compile
       scala: *dotty_version
 
     - stage: styling
diff --git a/build.sbt b/build.sbt
index 0ddccc242..edd902532 100644
--- a/build.sbt
+++ b/build.sbt
@@ -154,14 +154,17 @@ lazy val includeGeneratedSrc: Setting[_] = {
 
 lazy val disciplineDependencies = Seq(
   libraryDependencies ++= Seq(
+    "org.scalacheck" %%% "scalacheck" % scalaCheckVersion,
     "org.typelevel" %%% "discipline-core" % disciplineVersion
-  )
+  ).map(_.withDottyCompat(scalaVersion.value))
 )
 
 lazy val testingDependencies = Seq(
   libraryDependencies ++= Seq(
     "org.scalameta" %%% "munit-scalacheck" % munitVersion % Test,
     "org.typelevel" %%% "discipline-munit" % disciplineMunitVersion % Test
+  ).map(
+    _.withDottyCompat(scalaVersion.value)
   )
 )
 
@@ -781,7 +784,7 @@ addCommandAlias("validateKernelJS", "kernelLawsJS/test")
 addCommandAlias("validateFreeJS", "freeJS/test")
 addCommandAlias("validateAlleycatsJS", "alleycatsTestsJS/test")
 addCommandAlias("validateAllJS", "all testsJS/test js/test kernelLawsJS/test freeJS/test alleycatsTestsJS/test")
-addCommandAlias("validateDotty", ";++0.27.0-RC1!;alleycatsLawsJVM/compile")
+addCommandAlias("validateDotty", ";++0.24.0!;alleycatsLawsJVM/compile")
 addCommandAlias("validate", ";clean;validateJS;validateKernelJS;validateFreeJS;validateJVM;validateDotty")
 
 addCommandAlias("prePR", "fmt")
diff --git a/core/src/main/scala-2.x/src/main/scala/cats/syntax/MonadOps.scala b/core/src/main/scala-2.x/src/main/scala/cats/syntax/MonadOps.scala
deleted file mode 100644
index 009aea662..000000000
--- a/core/src/main/scala-2.x/src/main/scala/cats/syntax/MonadOps.scala
+++ /dev/null
@@ -1,12 +0,0 @@
-package cats.syntax
-
-import cats.{Alternative, Monad}
-
-final class MonadOps[F[_], A](private val fa: F[A]) extends AnyVal {
-  def whileM[G[_]](p: F[Boolean])(implicit M: Monad[F], G: Alternative[G]): F[G[A]] = M.whileM(p)(fa)
-  def whileM_(p: F[Boolean])(implicit M: Monad[F]): F[Unit] = M.whileM_(p)(fa)
-  def untilM[G[_]](p: F[Boolean])(implicit M: Monad[F], G: Alternative[G]): F[G[A]] = M.untilM(fa)(p)
-  def untilM_(p: F[Boolean])(implicit M: Monad[F]): F[Unit] = M.untilM_(fa)(p)
-  def iterateWhile(p: A => Boolean)(implicit M: Monad[F]): F[A] = M.iterateWhile(fa)(p)
-  def iterateUntil(p: A => Boolean)(implicit M: Monad[F]): F[A] = M.iterateUntil(fa)(p)
-}
diff --git a/core/src/main/scala-3.x/src/main/scala/cats/syntax/MonadOps.scala b/core/src/main/scala-3.x/src/main/scala/cats/syntax/MonadOps.scala
deleted file mode 100644
index ba4f2a431..000000000
--- a/core/src/main/scala-3.x/src/main/scala/cats/syntax/MonadOps.scala
+++ /dev/null
@@ -1,12 +0,0 @@
-package cats.syntax
-
-import cats.{Monad, Alternative}
-
-final class MonadOps[F[_], A](private val fa: F[A]) extends AnyVal {
-  def whileM[G[_]](using M: Monad[F], G: Alternative[G])(p: F[Boolean]): F[G[A]] = M.whileM(p)(fa)
-  def whileM_(using M: Monad[F])(p: F[Boolean]): F[Unit] = M.whileM_(p)(fa)
-  def untilM[G[_]](using M: Monad[F], G: Alternative[G])(p: F[Boolean]): F[G[A]] = M.untilM(fa)(p)
-  def untilM_(using M: Monad[F])(p: F[Boolean]): F[Unit] = M.untilM_(fa)(p)
-  def iterateWhile(using M: Monad[F])(p: A => Boolean): F[A] = M.iterateWhile(fa)(p)
-  def iterateUntil(using M: Monad[F])(p: A => Boolean): F[A] = M.iterateUntil(fa)(p)
-}
diff --git a/core/src/main/scala/cats/Invariant.scala b/core/src/main/scala/cats/Invariant.scala
index 7547a0749..8f2cf65b5 100644
--- a/core/src/main/scala/cats/Invariant.scala
+++ b/core/src/main/scala/cats/Invariant.scala
@@ -123,6 +123,7 @@ object Invariant extends ScalaVersionSpecificInvariantInstances with InvariantIn
   implicit def catsFlatMapForSortedMap[K]: FlatMap[SortedMap[K, *]] =
     cats.instances.sortedMap.catsStdInstancesForSortedMap[K]
   implicit def catsBimonadForFunction0: Bimonad[Function0] = cats.instances.function.catsStdBimonadForFunction0
+  implicit def catsMonadForFunction1[I]: Monad[I => *] = cats.instances.function.catsStdMonadForFunction1[I]
   implicit def catsContravariantMonoidalForFunction1[R: Monoid]: ContravariantMonoidal[* => R] =
     cats.instances.function.catsStdContravariantMonoidalForFunction1[R]
   implicit def catsFunctorForPair: Functor[λ[P => (P, P)]] = cats.instances.tuple.catsDataFunctorForPair
@@ -284,7 +285,7 @@ object Invariant extends ScalaVersionSpecificInvariantInstances with InvariantIn
 
 }
 
-private[cats] trait InvariantInstances0 extends InvariantInstances1 {
+private[cats] trait InvariantInstances0 extends TupleInstances0 {
   implicit def catsCommutativeMonadForTuple2[X](implicit X: CommutativeMonoid[X]): CommutativeMonad[(X, *)] =
     cats.instances.tuple.catsStdCommutativeMonadForTuple2[X]
   implicit def catsContravariantForFunction1[R]: Contravariant[* => R] =
@@ -292,21 +293,13 @@ private[cats] trait InvariantInstances0 extends InvariantInstances1 {
   implicit def catsDistributiveForFunction0: Distributive[Function0] = cats.instances.function.function0Distributive
   implicit def catsDistributiveForFunction1[I]: Distributive[I => *] =
     cats.instances.function.catsStdDistributiveForFunction1[I]
-
-}
-
-private trait InvariantInstances1 extends InvariantInstances2 {
-  implicit def catsMonadForFunction1[I]: Monad[I => *] = cats.instances.function.catsStdMonadForFunction1[I]
-}
-
-private[cats] trait InvariantInstances2 extends TupleInstances0 {
   implicit def catsApplicativeForArrow[F[_, _], A](implicit F: Arrow[F]): Applicative[F[A, *]] =
     new ArrowApplicative[F, A](F)
   implicit def catsInstancesForSeq: Monad[Seq] with Alternative[Seq] with CoflatMap[Seq] =
     cats.instances.seq.catsStdInstancesForSeq
 }
 
-private[cats] trait TupleInstances0 extends TupleInstances1 {
+private trait TupleInstances0 extends TupleInstances1 {
   implicit def catsCommutativeFlatMapForTuple2[X](implicit X: CommutativeSemigroup[X]): CommutativeFlatMap[(X, *)] =
     cats.instances.tuple.catsStdCommutativeFlatMapForTuple2[X]
 }
diff --git a/core/src/main/scala/cats/syntax/monad.scala b/core/src/main/scala/cats/syntax/monad.scala
index 396d06b56..b048827e7 100644
--- a/core/src/main/scala/cats/syntax/monad.scala
+++ b/core/src/main/scala/cats/syntax/monad.scala
@@ -8,6 +8,15 @@ trait MonadSyntax {
     new MonadIdOps[A](a)
 }
 
+final class MonadOps[F[_], A](private val fa: F[A]) extends AnyVal {
+  def whileM[G[_]](p: F[Boolean])(implicit M: Monad[F], G: Alternative[G]): F[G[A]] = M.whileM(p)(fa)
+  def whileM_(p: F[Boolean])(implicit M: Monad[F]): F[Unit] = M.whileM_(p)(fa)
+  def untilM[G[_]](p: F[Boolean])(implicit M: Monad[F], G: Alternative[G]): F[G[A]] = M.untilM(fa)(p)
+  def untilM_(p: F[Boolean])(implicit M: Monad[F]): F[Unit] = M.untilM_(fa)(p)
+  def iterateWhile(p: A => Boolean)(implicit M: Monad[F]): F[A] = M.iterateWhile(fa)(p)
+  def iterateUntil(p: A => Boolean)(implicit M: Monad[F]): F[A] = M.iterateUntil(fa)(p)
+}
+
 final class MonadIdOps[A](private val a: A) extends AnyVal {
 
   /**
diff --git a/free/src/main/scala-2.x/cats/free/FreeFoldStep.scala b/free/src/main/scala-2.x/cats/free/FreeFoldStep.scala
deleted file mode 100644
index 4dfcf283e..000000000
--- a/free/src/main/scala-2.x/cats/free/FreeFoldStep.scala
+++ /dev/null
@@ -1,39 +0,0 @@
-package cats.free
-
-import Free.{FlatMapped, Pure, Suspend}
-import cats.{Eval, Foldable}
-
-private[free] trait FreeFoldStep[S[_], A] {
-
-  def step: Free[S, A]
-
-  /**
-   * A combination of step and fold. May be used to define interpreters with custom
-   * (non-monoidial) control flow.
-   */
-  final def foldStep[B](
-    onPure: A => B,
-    onSuspend: S[A] => B,
-    onFlatMapped: ((S[X], X => Free[S, A]) forSome { type X }) => B
-  ): B =
-    this.step match {
-      case Pure(a)                    => onPure(a)
-      case Suspend(a)                 => onSuspend(a)
-      case FlatMapped(Suspend(fa), f) => onFlatMapped((fa, f))
-      case _                          => sys.error("FlatMapped should be right associative after step")
-    }
-
-  final def foldLeft[B](fa: Free[S, A], b: B)(f: (B, A) => B)(implicit F: Foldable[S]): B =
-    fa.foldStep(
-      a => f(b, a),
-      fa => F.foldLeft(fa, b)(f),
-      { case (fx, g) => F.foldLeft(fx, b)((bb, x) => foldLeft(g(x), bb)(f)) }
-    )
-
-  final def foldRight[B](fa: Free[S, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B])(implicit F: Foldable[S]): Eval[B] =
-    fa.foldStep(
-      a => f(a, lb),
-      fa => F.foldRight(fa, lb)(f),
-      { case (fx, g) => F.foldRight(fx, lb)((a, lbb) => foldRight(g(a), lbb)(f)) }
-    )
-}
diff --git a/free/src/main/scala-3.x/cats/free/FreeFoldStep.scala b/free/src/main/scala-3.x/cats/free/FreeFoldStep.scala
deleted file mode 100644
index f6fa75e7a..000000000
--- a/free/src/main/scala-3.x/cats/free/FreeFoldStep.scala
+++ /dev/null
@@ -1,41 +0,0 @@
-package cats.free
-
-import Free.{FlatMapped, Pure, Suspend}
-import cats.{Foldable, Eval}
-
-private[free] trait FreeFoldStep[S[_], A] {
-
-  def step: Free[S, A]
-
-  private type OnFlatMapped[X] = (S[X], X => Free[S, A])
-
-  /**
-   * A combination of step and fold. May be used to define interpreters with custom
-   * (non-monoidial) control flow.
-   */
-  final def foldStep[B](
-    onPure: A => B,
-    onSuspend: S[A] => B,
-    onFlatMapped: [X] => (S[X], X => Free[S, A]) => B
-  ): B =
-    this.step match {
-      case Pure(a)                    => onPure(a)
-      case Suspend(a)                 => onSuspend(a)
-      case FlatMapped(Suspend(fa), f) => onFlatMapped(fa, f)
-      case _                          => sys.error("FlatMapped should be right associative after step")
-    }
-
-  final def foldLeft[B](fa: Free[S, A], b: B)(f: (B, A) => B)(implicit F: Foldable[S]): B =
-    fa.foldStep(
-      a => f(b, a),
-      fa => F.foldLeft(fa, b)(f),
-      [X] => (sx: S[X], g: X => Free[S, A]) => F.foldLeft(sx, b)((bb, x) => foldLeft(g(x), bb)(f))
-    )
-
-  final def foldRight[B](fa: Free[S, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B])(implicit F: Foldable[S]): Eval[B] =
-    fa.foldStep(
-      a => f(a, lb),
-      fa => F.foldRight(fa, lb)(f),
-      [X] => (sx: S[X], g: X => Free[S, A]) => F.foldRight(sx, lb)((a, lbb) => foldRight(g(a), lbb)(f))
-    )
-}
\ No newline at end of file
diff --git a/free/src/main/scala/cats/free/Free.scala b/free/src/main/scala/cats/free/Free.scala
index c01b10ab3..01300b603 100644
--- a/free/src/main/scala/cats/free/Free.scala
+++ b/free/src/main/scala/cats/free/Free.scala
@@ -10,7 +10,7 @@ import cats.arrow.FunctionK
  * using the heap instead of the stack, allowing tail-call
  * elimination.
  */
-sealed abstract class Free[S[_], A] extends Product with Serializable with FreeFoldStep[S, A] {
+sealed abstract class Free[S[_], A] extends Product with Serializable {
 
   import Free.{FlatMapped, Pure, Suspend}
 
@@ -73,6 +73,22 @@ sealed abstract class Free[S[_], A] extends Product with Serializable with FreeF
         }
     }
 
+  /**
+   * A combination of step and fold. May be used to define interpreters with custom
+   * (non-monoidial) control flow.
+   */
+  final def foldStep[B](
+    onPure: A => B,
+    onSuspend: S[A] => B,
+    onFlatMapped: ((S[X], X => Free[S, A]) forSome { type X }) => B
+  ): B =
+    this.step match {
+      case Pure(a)                    => onPure(a)
+      case Suspend(a)                 => onSuspend(a)
+      case FlatMapped(Suspend(fa), f) => onFlatMapped((fa, f))
+      case _                          => sys.error("FlatMapped should be right associative after step")
+    }
+
   /**
    * Run to completion, using a function that extracts the resumption
    * from its suspension functor.
@@ -299,10 +315,18 @@ private trait FreeFoldable[F[_]] extends Foldable[Free[F, *]] {
   implicit def F: Foldable[F]
 
   final override def foldLeft[A, B](fa: Free[F, A], b: B)(f: (B, A) => B): B =
-    fa.foldLeft(fa, b)(f)
+    fa.foldStep(
+      a => f(b, a),
+      fa => F.foldLeft(fa, b)(f),
+      { case (fx, g) => F.foldLeft(fx, b)((bb, x) => foldLeft(g(x), bb)(f)) }
+    )
 
   final override def foldRight[A, B](fa: Free[F, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
-    fa.foldRight(fa, lb)(f)
+    fa.foldStep(
+      a => f(a, lb),
+      fa => F.foldRight(fa, lb)(f),
+      { case (fx, g) => F.foldRight(fx, lb)((a, lbb) => foldRight(g(a), lbb)(f)) }
+    )
 }
 
 private trait FreeTraverse[F[_]] extends Traverse[Free[F, *]] with FreeFoldable[F] {
diff --git a/free/src/test/scala/cats/free/FreeApplicativeSuite.scala b/free/src/test/scala/cats/free/FreeApplicativeSuite.scala
index db0e5f859..b4c12260a 100644
--- a/free/src/test/scala/cats/free/FreeApplicativeSuite.scala
+++ b/free/src/test/scala/cats/free/FreeApplicativeSuite.scala
@@ -12,7 +12,6 @@ import cats.syntax.eq._
 import org.scalacheck.Prop._
 import cats.tests.CatsSuite
 import org.scalacheck.{Arbitrary, Gen}
-import cats._
 
 class FreeApplicativeSuite extends CatsSuite {
   import FreeApplicativeSuite._
diff --git a/free/src/test/scala/cats/free/FreeSuite.scala b/free/src/test/scala/cats/free/FreeSuite.scala
index 6c81c8525..d45595bcb 100644
--- a/free/src/test/scala/cats/free/FreeSuite.scala
+++ b/free/src/test/scala/cats/free/FreeSuite.scala
@@ -1,6 +1,6 @@
 package cats.free
 
-import cats._
+import cats.{:<:, Foldable, Functor, Id, Monad, Traverse}
 import cats.arrow.FunctionK
 import cats.data.EitherK
 import cats.instances.all._
diff --git a/kernel/src/main/scala/cats/kernel/Eq.scala b/kernel/src/main/scala/cats/kernel/Eq.scala
index 7de7eb694..1a82f5c97 100644
--- a/kernel/src/main/scala/cats/kernel/Eq.scala
+++ b/kernel/src/main/scala/cats/kernel/Eq.scala
@@ -55,7 +55,7 @@ object Eq
     with EqToEquivConversion
     with ScalaVersionSpecificOrderInstances
     with instances.TupleOrderInstances
-    with OrderInstances0 {
+    with PartialOrderInstances {
 
   /**
    * Access an implicit `Eq[A]`.
@@ -194,6 +194,8 @@ object Eq
     cats.kernel.instances.option.catsKernelStdOrderForOption[A]
   implicit def catsKernelOrderForList[A: Order]: Order[List[A]] =
     cats.kernel.instances.list.catsKernelStdOrderForList[A]
+  implicit def catsKernelOrderForSeq[A: Order]: Order[Seq[A]] =
+    cats.kernel.instances.seq.catsKernelStdOrderForSeq[A]
   implicit def catsKernelOrderForVector[A: Order]: Order[Vector[A]] =
     cats.kernel.instances.vector.catsKernelStdOrderForVector[A]
   implicit def catsKernelOrderForQueue[A: Order]: Order[Queue[A]] =
@@ -219,16 +221,13 @@ object Eq
     }
 }
 
-private[kernel] trait OrderInstances0 extends PartialOrderInstances {
-  implicit def catsKernelOrderForSeq[A: Order]: Order[Seq[A]] =
-    cats.kernel.instances.seq.catsKernelStdOrderForSeq[A]
-}
-
-private[kernel] trait PartialOrderInstances extends PartialOrderInstances0 {
+private[kernel] trait PartialOrderInstances extends HashInstances {
   implicit def catsKernelPartialOrderForOption[A: PartialOrder]: PartialOrder[Option[A]] =
     cats.kernel.instances.option.catsKernelStdPartialOrderForOption[A]
   implicit def catsKernelPartialOrderForList[A: PartialOrder]: PartialOrder[List[A]] =
     cats.kernel.instances.list.catsKernelStdPartialOrderForList[A]
+  implicit def catsKernelPartialOrderForSeq[A: PartialOrder]: PartialOrder[Seq[A]] =
+    cats.kernel.instances.seq.catsKernelStdPartialOrderForSeq[A]
   implicit def catsKernelPartialOrderForVector[A: PartialOrder]: PartialOrder[Vector[A]] =
     cats.kernel.instances.vector.catsKernelStdPartialOrderForVector[A]
   implicit def catsKernelPartialOrderForQueue[A: PartialOrder]: PartialOrder[Queue[A]] =
@@ -237,16 +236,12 @@ private[kernel] trait PartialOrderInstances extends PartialOrderInstances0 {
     cats.kernel.instances.function.catsKernelPartialOrderForFunction0[A]
 }
 
-private[kernel] trait PartialOrderInstances0 extends HashInstances {
-  implicit def catsKernelPartialOrderForSeq[A: PartialOrder]: PartialOrder[Seq[A]] =
-    cats.kernel.instances.seq.catsKernelStdPartialOrderForSeq[A]
-}
-
-private[kernel] trait HashInstances extends HashInstances0 {
+private[kernel] trait HashInstances extends EqInstances {
   implicit def catsKernelHashForSet[A]: Hash[Set[A]] = cats.kernel.instances.set.catsKernelStdHashForSet[A]
   implicit def catsKernelHashForOption[A: Hash]: Hash[Option[A]] =
     cats.kernel.instances.option.catsKernelStdHashForOption[A]
   implicit def catsKernelHashForList[A: Hash]: Hash[List[A]] = cats.kernel.instances.list.catsKernelStdHashForList[A]
+  implicit def catsKernelHashForSeq[A: Hash]: Hash[Seq[A]] = cats.kernel.instances.seq.catsKernelStdHashForSeq[A]
   implicit def catsKernelHashForVector[A: Hash]: Hash[Vector[A]] =
     cats.kernel.instances.vector.catsKernelStdHashForVector[A]
   implicit def catsKernelHashForQueue[A: Hash]: Hash[Queue[A]] =
@@ -263,13 +258,10 @@ private[kernel] trait HashInstances extends HashInstances0 {
     cats.kernel.instances.either.catsStdHashForEither[A, B]
 }
 
-private[kernel] trait HashInstances0 extends EqInstances {
-  implicit def catsKernelHashForSeq[A: Hash]: Hash[Seq[A]] = cats.kernel.instances.seq.catsKernelStdHashForSeq[A]
-}
-
-private[kernel] trait EqInstances extends EqInstances0 {
+private[kernel] trait EqInstances {
   implicit def catsKernelEqForOption[A: Eq]: Eq[Option[A]] = cats.kernel.instances.option.catsKernelStdEqForOption[A]
   implicit def catsKernelEqForList[A: Eq]: Eq[List[A]] = cats.kernel.instances.list.catsKernelStdEqForList[A]
+  implicit def catsKernelEqForSeq[A: Eq]: Eq[Seq[A]] = cats.kernel.instances.seq.catsKernelStdEqForSeq[A]
   implicit def catsKernelEqForVector[A: Eq]: Eq[Vector[A]] = cats.kernel.instances.vector.catsKernelStdEqForVector[A]
   implicit def catsKernelEqForQueue[A: Eq]: Eq[Queue[A]] = cats.kernel.instances.queue.catsKernelStdEqForQueue[A]
   implicit def catsKernelEqForFunction0[A: Eq]: Eq[() => A] = cats.kernel.instances.function.catsKernelEqForFunction0[A]
@@ -279,7 +271,3 @@ private[kernel] trait EqInstances extends EqInstances0 {
   implicit def catsKernelEqForEither[A: Eq, B: Eq]: Eq[Either[A, B]] =
     cats.kernel.instances.either.catsStdEqForEither[A, B]
 }
-
-private[kernel] trait EqInstances0 {
-  implicit def catsKernelEqForSeq[A: Eq]: Eq[Seq[A]] = cats.kernel.instances.seq.catsKernelStdEqForSeq[A]
-}
diff --git a/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala b/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala
index 6dab5c8fa..e9ae4bbc8 100644
--- a/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala
+++ b/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala
@@ -10,7 +10,6 @@ import cats.syntax.parallel._
 import cats.syntax.traverse._
 import cats.syntax.eq._
 import org.scalacheck.Prop._
-import cats.catsInstancesForId
 
 trait ScalaVersionSpecificFoldableSuite { self: FoldableSuiteAdditional =>
   test("Foldable[LazyList].foldM stack safety") {
diff --git a/tests/src/test/scala-2.x/cats/tests/FunctionKLiftSuite.scala b/tests/src/test/scala-2.x/cats/tests/FunctionKLiftSuite.scala
deleted file mode 100644
index 200bd7795..000000000
--- a/tests/src/test/scala-2.x/cats/tests/FunctionKLiftSuite.scala
+++ /dev/null
@@ -1,50 +0,0 @@
-package cats.tests
-
-import cats.data.NonEmptyList
-import cats.arrow.FunctionK
-import cats.implicits._
-import org.scalacheck.Prop._
-import cats.laws.discipline.arbitrary._
-
-class FunctionKLiftSuite extends CatsSuite {
-
-  test("lift simple unary") {
-    def optionToList[A](option: Option[A]): List[A] = option.toList
-    val fOptionToList = FunctionK.lift(optionToList _)
-    forAll { (a: Option[Int]) =>
-      assert(fOptionToList(a) === (optionToList(a)))
-    }
-
-    val fO2I: FunctionK[Option, Iterable] = FunctionK.lift(Option.option2Iterable _)
-    forAll { (a: Option[String]) =>
-      assert(fO2I(a).toList === (Option.option2Iterable(a).toList))
-    }
-
-    val fNelFromListUnsafe = FunctionK.lift(NonEmptyList.fromListUnsafe _)
-    forAll { (a: NonEmptyList[Int]) =>
-      assert(fNelFromListUnsafe(a.toList) === (NonEmptyList.fromListUnsafe(a.toList)))
-    }
-  }
-
-  test("hygiene") {
-    trait FunctionK
-    def optionToList[A](option: Option[A]): List[A] = option.toList
-    val fOptionToList = cats.arrow.FunctionK.lift(optionToList _)
-    forAll { (a: Option[Int]) =>
-      assert(fOptionToList(a) === (optionToList(a)))
-    }
-  }
-
-  test("lift compound unary") {
-    val fNelFromList = FunctionK.lift[List, λ[α => Option[NonEmptyList[α]]]](NonEmptyList.fromList _)
-    forAll { (a: List[String]) =>
-      assert(fNelFromList(a) === (NonEmptyList.fromList(a)))
-    }
-  }
-
-  { // lifting concrete types should fail to compile
-    def sample[A](option: Option[A]): List[A] = option.toList
-    assert(compileErrors("FunctionK.lift(sample[String])").nonEmpty)
-    assert(compileErrors("FunctionK.lift(sample[Nothing])").nonEmpty)
-  }
-}
diff --git a/tests/src/test/scala-2.x/cats/tests/KleisliSuiteScala2.scala b/tests/src/test/scala-2.x/cats/tests/KleisliSuiteScala2.scala
deleted file mode 100644
index 2c818cb1e..000000000
--- a/tests/src/test/scala-2.x/cats/tests/KleisliSuiteScala2.scala
+++ /dev/null
@@ -1,13 +0,0 @@
-package cats.tests
-
-import cats._
-import cats.data.Kleisli
-
-// TODO should be fixed in Dotty 3.0.0-M1
-// <https://github.com/lampepfl/dotty/issues/9793>
-class KleisliSuiteScala2 extends CatsSuite {
-  test("Functor[Kleisli[F, Int, *]] is not ambiguous when an ApplicativeError and a FlatMap are in scope for F") {
-    def shouldCompile1[F[_], E](implicit F: ApplicativeError[F, E], FM: FlatMap[F]): Functor[Kleisli[F, Int, *]] =
-      Functor[Kleisli[F, Int, *]]
-  }
-}
diff --git a/tests/src/test/scala/cats/tests/ApplicativeErrorSuite.scala b/tests/src/test/scala/cats/tests/ApplicativeErrorSuite.scala
index 119a40365..5aeaef300 100644
--- a/tests/src/test/scala/cats/tests/ApplicativeErrorSuite.scala
+++ b/tests/src/test/scala/cats/tests/ApplicativeErrorSuite.scala
@@ -61,7 +61,7 @@ class ApplicativeErrorSuite extends CatsSuite {
     assert(compileErrors("e2.attemptNarrow[Num]").nonEmpty)
 
     val e3: Either[List[T[String]], Unit] = List(Str).asLeft[Unit]
-    //assertEquals(compileErrors("e3.attemptNarrow[List[Str.type]]"), "")
+    assert(compileErrors("e3.attemptNarrow[List[Str.type]]").nonEmpty)
   }
 
   test("attemptT syntax creates an EitherT") {
diff --git a/tests/src/test/scala/cats/tests/BinestedSuite.scala b/tests/src/test/scala/cats/tests/BinestedSuite.scala
index ed7223ebd..e8367dec9 100644
--- a/tests/src/test/scala/cats/tests/BinestedSuite.scala
+++ b/tests/src/test/scala/cats/tests/BinestedSuite.scala
@@ -75,9 +75,7 @@ class BinestedSuite extends CatsSuite {
 
   test("simple syntax-based usage") {
     forAll { (value: (Option[Int], List[Int])) =>
-      // TODO something is wrong with inference in Dotty here, bug?
-      val binested = value.binested
-      assert(binested.bimap(_.toString, _.toString).value === (value.bimap(_.map(_.toString), _.map(_.toString))))
+      assert(value.binested.bimap(_.toString, _.toString).value === (value.bimap(_.map(_.toString), _.map(_.toString))))
     }
   }
 }
diff --git a/tests/src/test/scala/cats/tests/ChainSuite.scala b/tests/src/test/scala/cats/tests/ChainSuite.scala
index f08223697..c8fd22042 100644
--- a/tests/src/test/scala/cats/tests/ChainSuite.scala
+++ b/tests/src/test/scala/cats/tests/ChainSuite.scala
@@ -265,13 +265,13 @@ class ChainSuite extends CatsSuite {
 
   test("== returns false for non-Chains") {
     forAll { (a: Chain[Int], b: Int) =>
-      assert((a.equals(b)) === false)
+      assert((a == b) === false)
     }
   }
 
   test("== returns false for Chains of different element types") {
     forAll { (a: Chain[Option[String]], b: Chain[String]) =>
-      assert((a.equals(b)) === (a.isEmpty && b.isEmpty))
+      assert((a == b) === (a.isEmpty && b.isEmpty))
     }
   }
 
diff --git a/tests/src/test/scala/cats/tests/ExtraRegressionSuite.scala b/tests/src/test/scala/cats/tests/ExtraRegressionSuite.scala
new file mode 100644
index 000000000..65c92e825
--- /dev/null
+++ b/tests/src/test/scala/cats/tests/ExtraRegressionSuite.scala
@@ -0,0 +1,25 @@
+package cats.tests
+
+import cats.Show
+import ExtraRegressionSuite._
+
+class ExtraRegressionSuite extends CatsSuite {
+
+  /**
+   * Placed here to work around scala/bug#6260 on scala 2.10
+   */
+  test("#1802 duplicated method name") {
+    Show[First[String]]
+  }
+}
+
+object ExtraRegressionSuite {
+  final case class First[A](getFirst: A) extends AnyVal
+  object First {
+    implicit def showInstance[A](implicit ev: Show[A]): Show[First[A]] =
+      new Show[First[A]] {
+        override def show(f: First[A]): String = s"First(${ev.show(f.getFirst)})"
+      }
+  }
+
+}
diff --git a/tests/src/test/scala/cats/tests/FoldableSuite.scala b/tests/src/test/scala/cats/tests/FoldableSuite.scala
index 59877e12f..011cedbaf 100644
--- a/tests/src/test/scala/cats/tests/FoldableSuite.scala
+++ b/tests/src/test/scala/cats/tests/FoldableSuite.scala
@@ -1,6 +1,6 @@
 package cats.tests
 
-import cats._
+import cats.{Eval, Foldable, Id, Now}
 import cats.data.{Const, EitherK, IdT, Ior, Nested, NonEmptyList, NonEmptyStream, NonEmptyVector, OneAnd, Validated}
 import cats.instances.order._
 import cats.kernel.{Eq, Monoid}
diff --git a/tests/src/test/scala/cats/tests/FunctionKSuite.scala b/tests/src/test/scala/cats/tests/FunctionKSuite.scala
index b42a32603..5297e3086 100644
--- a/tests/src/test/scala/cats/tests/FunctionKSuite.scala
+++ b/tests/src/test/scala/cats/tests/FunctionKSuite.scala
@@ -3,6 +3,8 @@ package cats.tests
 import cats.Id
 import cats.arrow.FunctionK
 import cats.data.EitherK
+import cats.data.NonEmptyList
+import cats.laws.discipline.arbitrary._
 import cats.syntax.eq._
 import org.scalacheck.Prop._
 
@@ -64,4 +66,44 @@ class FunctionKSuite extends CatsSuite {
     }
   }
 
+  test("lift simple unary") {
+    def optionToList[A](option: Option[A]): List[A] = option.toList
+    val fOptionToList = FunctionK.lift(optionToList _)
+    forAll { (a: Option[Int]) =>
+      assert(fOptionToList(a) === (optionToList(a)))
+    }
+
+    val fO2I: FunctionK[Option, Iterable] = FunctionK.lift(Option.option2Iterable _)
+    forAll { (a: Option[String]) =>
+      assert(fO2I(a).toList === (Option.option2Iterable(a).toList))
+    }
+
+    val fNelFromListUnsafe = FunctionK.lift(NonEmptyList.fromListUnsafe _)
+    forAll { (a: NonEmptyList[Int]) =>
+      assert(fNelFromListUnsafe(a.toList) === (NonEmptyList.fromListUnsafe(a.toList)))
+    }
+  }
+
+  test("hygiene") {
+    trait FunctionK
+    def optionToList[A](option: Option[A]): List[A] = option.toList
+    val fOptionToList = cats.arrow.FunctionK.lift(optionToList _)
+    forAll { (a: Option[Int]) =>
+      assert(fOptionToList(a) === (optionToList(a)))
+    }
+  }
+
+  test("lift compound unary") {
+    val fNelFromList = FunctionK.lift[List, λ[α => Option[NonEmptyList[α]]]](NonEmptyList.fromList _)
+    forAll { (a: List[String]) =>
+      assert(fNelFromList(a) === (NonEmptyList.fromList(a)))
+    }
+  }
+
+  { // lifting concrete types should fail to compile
+    def sample[A](option: Option[A]): List[A] = option.toList
+    assert(compileErrors("FunctionK.lift(sample[String])").nonEmpty)
+    assert(compileErrors("FunctionK.lift(sample[Nothing])").nonEmpty)
+  }
+
 }
diff --git a/tests/src/test/scala/cats/tests/IdSuite.scala b/tests/src/test/scala/cats/tests/IdSuite.scala
index c4bbb81e7..7a9c47c67 100644
--- a/tests/src/test/scala/cats/tests/IdSuite.scala
+++ b/tests/src/test/scala/cats/tests/IdSuite.scala
@@ -2,7 +2,6 @@ package cats.tests
 
 import cats.{Bimonad, CommutativeMonad, Id, Reducible, Traverse}
 import cats.laws.discipline._
-import cats.catsInstancesForId
 
 class IdSuite extends CatsSuite {
   implicit val iso: SemigroupalTests.Isomorphisms[Id] =
diff --git a/tests/src/test/scala/cats/tests/IndexedReaderWriterStateTSuite.scala b/tests/src/test/scala/cats/tests/IndexedReaderWriterStateTSuite.scala
index 43fd416ee..ccb02369f 100644
--- a/tests/src/test/scala/cats/tests/IndexedReaderWriterStateTSuite.scala
+++ b/tests/src/test/scala/cats/tests/IndexedReaderWriterStateTSuite.scala
@@ -1,6 +1,6 @@
 package cats.tests
 
-import cats._
+import cats.{~>, Bifunctor, Contravariant, Eval, Functor, Id, Monad, MonadError, SemigroupK}
 import cats.arrow.{Profunctor, Strong}
 import cats.data.{EitherT, IRWST, IndexedReaderWriterStateT, ReaderWriterState, ReaderWriterStateT}
 import cats.kernel.{Eq, Monoid}
diff --git a/tests/src/test/scala/cats/tests/IndexedStateTSuite.scala b/tests/src/test/scala/cats/tests/IndexedStateTSuite.scala
index 2f414c38a..e22ac31f6 100644
--- a/tests/src/test/scala/cats/tests/IndexedStateTSuite.scala
+++ b/tests/src/test/scala/cats/tests/IndexedStateTSuite.scala
@@ -496,8 +496,6 @@ class IndexedStateTSuite extends CatsSuite {
       IndexedStateT
         .catsDataAlternativeForIndexedStateT[ListWrapper, MiniInt](ListWrapper.monad, ListWrapper.alternative)
 
-    implicit val f: Isomorphisms[IndexedStateT[ListWrapper, MiniInt, MiniInt, *]] = Isomorphisms.invariant(SA)
-
     checkAll("IndexedStateT[ListWrapper, MiniInt, Int, Int]",
              AlternativeTests[IndexedStateT[ListWrapper, MiniInt, MiniInt, *]](SA).alternative[Int, Int, Int]
     )
@@ -508,7 +506,7 @@ class IndexedStateTSuite extends CatsSuite {
     Alternative[IndexedStateT[ListWrapper, Int, Int, *]]
     Applicative[IndexedStateT[ListWrapper, Int, Int, *]]
     Apply[IndexedStateT[ListWrapper, Int, Int, *]]
-    //Functor[IndexedStateT[ListWrapper, Int, Int, *]]
+    Functor[IndexedStateT[ListWrapper, Int, Int, *]]
     MonoidK[IndexedStateT[ListWrapper, Int, Int, *]]
     SemigroupK[IndexedStateT[ListWrapper, Int, Int, *]]
   }
diff --git a/tests/src/test/scala/cats/tests/IorTSuite.scala b/tests/src/test/scala/cats/tests/IorTSuite.scala
index 5007cecbe..af5c88518 100644
--- a/tests/src/test/scala/cats/tests/IorTSuite.scala
+++ b/tests/src/test/scala/cats/tests/IorTSuite.scala
@@ -1,6 +1,6 @@
 package cats.tests
 
-import cats._
+import cats.{~>, Bifunctor, Eval, Foldable, Functor, Id, Monad, MonadError, Traverse}
 import cats.data.{Ior, IorT}
 import cats.kernel.{Eq, Monoid, Order, Semigroup}
 import cats.kernel.laws.discipline.{EqTests, MonoidTests, SemigroupTests}
diff --git a/tests/src/test/scala/cats/tests/KleisliSuite.scala b/tests/src/test/scala/cats/tests/KleisliSuite.scala
index 6aa80797a..fa5713f37 100644
--- a/tests/src/test/scala/cats/tests/KleisliSuite.scala
+++ b/tests/src/test/scala/cats/tests/KleisliSuite.scala
@@ -9,7 +9,7 @@ import cats.laws.discipline.arbitrary._
 import cats.laws.discipline.eq._
 import cats.laws.discipline.SemigroupalTests.Isomorphisms
 import cats.laws.discipline.{DeferTests, MonoidKTests, SemigroupKTests}
-import cats.syntax.all._
+import cats.implicits._
 import cats.platform.Platform
 import cats.tests.Helpers.CSemi
 import org.scalacheck.Prop._
@@ -180,6 +180,11 @@ class KleisliSuite extends CatsSuite {
            SerializableTests.serializable(Contravariant[Kleisli[Option, *, Int]])
   )
 
+  test("Functor[Kleisli[F, Int, *]] is not ambiguous when an ApplicativeError and a FlatMap are in scope for F") {
+    def shouldCompile1[F[_], E](implicit F: ApplicativeError[F, E], FM: FlatMap[F]): Functor[Kleisli[F, Int, *]] =
+      Functor[Kleisli[F, Int, *]]
+  }
+
   test("local composes functions") {
     forAll { (f: Int => Option[String], g: Int => Int, i: Int) =>
       assert(f(g(i)) === (Kleisli.local[Option, String, Int](g)(Kleisli(f)).run(i)))
diff --git a/tests/src/test/scala/cats/tests/MonadSuite.scala b/tests/src/test/scala/cats/tests/MonadSuite.scala
index 7873b8e15..4f76a60ae 100644
--- a/tests/src/test/scala/cats/tests/MonadSuite.scala
+++ b/tests/src/test/scala/cats/tests/MonadSuite.scala
@@ -1,7 +1,6 @@
 package cats.tests
 
 import cats.{Eval, Id, Monad}
-import cats.catsInstancesForId
 import cats.data.{IndexedStateT, StateT}
 import cats.syntax.apply._
 import cats.syntax.monad._
@@ -112,7 +111,7 @@ class MonadSuite extends CatsSuite {
         i <- smallPosInt
       } yield b -> i
 
-    forAll(Gen.listOf(tupleGen)) { (xs: List[(Boolean, Int)]) =>
+    forAll(Gen.listOf(tupleGen)) { xs: List[(Boolean, Int)] =>
       val expected = xs.collectFirst { case (true, x) => x }.getOrElse(-1)
       val branches = xs.map { case (b, x) => (Eval.now(b), Eval.now(x)) }
       assert(Monad[Eval].ifElseM(branches: _*)(Eval.now(-1)).value === expected)
@@ -120,7 +119,7 @@ class MonadSuite extends CatsSuite {
   }
 
   test("ifElseM resorts to default") {
-    forAll(Gen.listOf(smallPosInt)) { (xs: List[Int]) =>
+    forAll(Gen.listOf(smallPosInt)) { xs: List[Int] =>
       val branches = xs.map(x => (Eval.now(false), Eval.now(x)))
       assert(Monad[Eval].ifElseM(branches: _*)(Eval.now(-1)).value === -1)
     }
diff --git a/tests/src/test/scala/cats/tests/OptionTSuite.scala b/tests/src/test/scala/cats/tests/OptionTSuite.scala
index 21767c40d..68facd12d 100644
--- a/tests/src/test/scala/cats/tests/OptionTSuite.scala
+++ b/tests/src/test/scala/cats/tests/OptionTSuite.scala
@@ -536,7 +536,7 @@ class OptionTSuite extends CatsSuite {
     Traverse[OptionT[List, *]]
 
     implicit val T: Traverse[ListWrapper] = ListWrapper.traverse
-    //implicit val M: Monad[ListWrapper] = ListWrapper.monad
+    implicit val M: Monad[ListWrapper] = ListWrapper.monad
     Functor[OptionT[ListWrapper, *]]
   }
 
diff --git a/tests/src/test/scala/cats/tests/ParallelSuite.scala b/tests/src/test/scala/cats/tests/ParallelSuite.scala
index 92d95092b..d9d4c291c 100644
--- a/tests/src/test/scala/cats/tests/ParallelSuite.scala
+++ b/tests/src/test/scala/cats/tests/ParallelSuite.scala
@@ -7,8 +7,16 @@ import cats.kernel.compat.scalaVersionSpecific._
 import cats.laws.discipline.{ApplicativeErrorTests, MiniInt, NonEmptyParallelTests, ParallelTests, SerializableTests}
 import cats.laws.discipline.eq._
 import cats.laws.discipline.arbitrary._
-import cats.implicits._
+import cats.syntax.bifunctor._
+import cats.syntax.bitraverse._
+import cats.syntax.either._
+import cats.syntax.flatMap._
+import cats.syntax.foldable._
+import cats.syntax.option._
+import cats.syntax.parallel._
+import cats.syntax.traverse._
 import scala.collection.immutable.SortedSet
+import cats.syntax.eq._
 import org.scalacheck.Prop._
 
 @suppressUnusedImportWarningForScalaVersionSpecific
@@ -52,22 +60,19 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
 
   test("ParTraverse_ identity should be equivalent to parSequence_") {
     forAll { (es: SortedSet[Either[String, Int]]) =>
-      assert(Parallel.parTraverse_(es)(identity) === (Parallel.parSequence_[SortedSet, Either[String, *], Int](es)))
+      assert(Parallel.parTraverse_(es)(identity) === (Parallel.parSequence_(es)))
     }
   }
 
   test("ParTraverse_ syntax should be equivalent to Parallel.parTraverse_") {
     forAll { (es: SortedSet[Either[String, Int]]) =>
-      assert(
-        Parallel.parTraverse_[SortedSet, Either[String, *], Either[String, Int], Int](es)(identity) === (es
-          .parTraverse_(identity))
-      )
+      assert(Parallel.parTraverse_(es)(identity) === (es.parTraverse_(identity)))
     }
   }
 
   test("ParSequence_ syntax should be equivalent to Parallel.parSequence_") {
     forAll { (es: SortedSet[Either[String, Int]]) =>
-      assert(Parallel.parSequence_[SortedSet, Either[String, *], Int](es) === (es.parSequence_))
+      assert(Parallel.parSequence_(es) === (es.parSequence_))
     }
   }
 
@@ -83,17 +88,17 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
     }
   }
 
-  case class ListTuple2[A, B](value: List[(A, B)])
+  type ListTuple2[A, B] = List[(A, B)]
   implicit val catsBitraverseForListTuple2: Bitraverse[ListTuple2] = new Bitraverse[ListTuple2] {
     def bifoldLeft[A, B, C](fab: ListTuple2[A, B], c: C)(f: (C, A) => C, g: (C, B) => C): C =
-      fab.value.foldLeft(c) { case (c, (a, b)) => g(f(c, a), b) }
+      fab.foldLeft(c) { case (c, (a, b)) => g(f(c, a), b) }
     def bifoldRight[A, B, C](fab: ListTuple2[A, B],
                              lc: Eval[C]
     )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] = {
       def loop(abs: ListTuple2[A, B]): Eval[C] =
-        abs.value match {
+        abs match {
           case Nil         => lc
-          case (a, b) :: t => f(a, g(b, Eval.defer(loop(ListTuple2(t)))))
+          case (a, b) :: t => f(a, g(b, Eval.defer(loop(t))))
         }
       Eval.defer(loop(fab))
     }
@@ -101,19 +106,16 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
       fab: ListTuple2[A, B]
     )(f: A => G[C], g: B => G[D])(implicit G: Applicative[G]): G[ListTuple2[C, D]] = {
       def loop(abs: ListTuple2[A, B]): Eval[G[ListTuple2[C, D]]] =
-        abs.value match {
-          case Nil => Now(G.pure(ListTuple2(List.empty)))
-          case (a, b) :: t =>
-            G.map2Eval(G.product(f(a), g(b)), Eval.defer(loop(ListTuple2(t))))((cur, acc) =>
-              ListTuple2(cur :: acc.value)
-            )
+        abs match {
+          case Nil         => Now(G.pure(List.empty))
+          case (a, b) :: t => G.map2Eval(G.product(f(a), g(b)), Eval.defer(loop(t)))(_ :: _)
         }
       loop(fab).value
     }
   }
 
   test("ParBisequence Either should accumulate errors") {
-    forAll { (es: List[(Either[String, Int], Either[String, Int])]) =>
+    forAll { (es: ListTuple2[Either[String, Int], Either[String, Int]]) =>
       val lefts = es
         .flatMap { case (a, b) =>
           List(a, b)
@@ -123,12 +125,12 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
         }
         .foldMap(identity)
 
-      assert(ListTuple2(es).parBisequence.fold(identity, i => Monoid[String].empty) === lefts)
+      assert(es.parBisequence.fold(identity, i => Monoid[String].empty) === lefts)
     }
   }
 
   test("ParBisequence Ior should accumulate errors") {
-    forAll { (es: List[(Ior[String, Int], Ior[String, Int])]) =>
+    forAll { (es: ListTuple2[Ior[String, Int], Ior[String, Int]]) =>
       val lefts = es
         .flatMap { case (a, b) =>
           List(a, b)
@@ -139,14 +141,13 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
         }
         .foldMap(identity)
 
-      assert(ListTuple2(es).parBisequence.left.getOrElse(Monoid[String].empty) === lefts)
+      assert(es.parBisequence.left.getOrElse(Monoid[String].empty) === lefts)
     }
   }
 
   test("ParBisequence Ior should bisequence values") {
-    forAll { (es: List[(Ior[String, Int], Ior[String, Int])]) =>
-      val wrapped = ListTuple2(es)
-      assert(wrapped.parBisequence.right.map(_.value) === wrapped.bimap(_.toOption, _.toOption).bisequence.map(_.value))
+    forAll { (es: ListTuple2[Ior[String, Int], Ior[String, Int]]) =>
+      assert(es.parBisequence.right === (es.bimap(_.toOption, _.toOption).bisequence))
     }
   }
 
@@ -157,19 +158,19 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
   }
 
   test("ParLeftSequence Either should accumulate errors") {
-    forAll { (es: List[(Either[String, Int], Int)]) =>
+    forAll { (es: ListTuple2[Either[String, Int], Int]) =>
       val lefts = es
         .collect { case (Left(e), _) =>
           e
         }
         .foldMap(identity)
 
-      assert(ListTuple2(es).parLeftSequence.fold(identity, i => Monoid[String].empty) === lefts)
+      assert(es.parLeftSequence.fold(identity, i => Monoid[String].empty) === lefts)
     }
   }
 
   test("ParLeftSequence Ior should accumulate errors") {
-    forAll { (es: List[(Ior[String, Int], Int)]) =>
+    forAll { (es: ListTuple2[Ior[String, Int], Int]) =>
       val lefts = es
         .map { case (a, b) =>
           a.left
@@ -179,16 +180,13 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
         }
         .foldMap(identity)
 
-      assert(ListTuple2(es).parLeftSequence.left.getOrElse(Monoid[String].empty) === lefts)
+      assert(es.parLeftSequence.left.getOrElse(Monoid[String].empty) === lefts)
     }
   }
 
   test("ParLeftSequence Ior should leftSequence values") {
-    forAll { (es: List[(Ior[String, Int], Int)]) =>
-      val wrapped = ListTuple2(es)
-      assert(
-        wrapped.parLeftSequence.right.map(_.value) === (wrapped.bimap(_.toOption, identity).leftSequence.map(_.value))
-      )
+    forAll { (es: ListTuple2[Ior[String, Int], Int]) =>
+      assert(es.parLeftSequence.right === (es.bimap(_.toOption, identity).leftSequence))
     }
   }
 
diff --git a/tests/src/test/scala/cats/tests/ReducibleSuite.scala b/tests/src/test/scala/cats/tests/ReducibleSuite.scala
index ac2793461..e368782c3 100644
--- a/tests/src/test/scala/cats/tests/ReducibleSuite.scala
+++ b/tests/src/test/scala/cats/tests/ReducibleSuite.scala
@@ -97,14 +97,14 @@ class ReducibleSuiteAdditional extends CatsSuite {
     val n = 100000
     val xs = NES(0, Stream.from(1))
 
-    assert(xs.reduceMapM(i => if (i < n) i.asRight[Int] else i.asLeft[Int]) === Left(n))
+    assert(xs.reduceMapM(i => if (i < n) Right(i) else Left(i)) === Left(n))
   }
 
   test("reduceMapA should be stack-safe and short-circuiting if reduceRightTo is sufficiently lazy") {
     val n = 100000
     val xs = NES(0, Stream.from(1))
 
-    assert(xs.reduceMapA(i => if (i < n) i.asRight[Int] else i.asLeft[Int]) === Left(n))
+    assert(xs.reduceMapA(i => if (i < n) Right(i) else Left(i)) === Left(n))
   }
 
   test("reduceA should be stack-safe and short-circuiting if reduceRightTo is sufficiently lazy") {
diff --git a/tests/src/test/scala/cats/tests/RegressionSuite.scala b/tests/src/test/scala/cats/tests/RegressionSuite.scala
index 2edf022df..d73cdbd9d 100644
--- a/tests/src/test/scala/cats/tests/RegressionSuite.scala
+++ b/tests/src/test/scala/cats/tests/RegressionSuite.scala
@@ -103,7 +103,7 @@ class RegressionSuite extends CatsSuite with ScalaVersionSpecificRegressionSuite
 
   test("#500: foldMap - traverse consistency") {
     assert(
-      List(1, 2, 3).traverse(i => Const[List[Int], List[Int]](List(i))).getConst == List(1, 2, 3).foldMap(List(_))
+      List(1, 2, 3).traverse(i => Const.of[List[Int]](List(i))).getConst == List(1, 2, 3).foldMap(List(_))
     )
   }
 
diff --git a/tests/src/test/scala/cats/tests/RepresentableSuite.scala b/tests/src/test/scala/cats/tests/RepresentableSuite.scala
index 763a2deec..d4440898c 100644
--- a/tests/src/test/scala/cats/tests/RepresentableSuite.scala
+++ b/tests/src/test/scala/cats/tests/RepresentableSuite.scala
@@ -1,6 +1,6 @@
 package cats.tests
 
-import cats._
+import cats.{Bimonad, Distributive, Eq, Eval, Id, Monad, Representable}
 import cats.data.Kleisli
 import cats.kernel.Monoid
 import cats.laws.discipline.SemigroupalTests.Isomorphisms
diff --git a/tests/src/test/scala/cats/tests/SyntaxSerializationSuite.scala b/tests/src/test/scala/cats/tests/SyntaxSerializationSuite.scala
index 1b3a27229..722fea0f1 100644
--- a/tests/src/test/scala/cats/tests/SyntaxSerializationSuite.scala
+++ b/tests/src/test/scala/cats/tests/SyntaxSerializationSuite.scala
@@ -1,7 +1,6 @@
 package cats.tests
 
 import cats.laws.discipline.SerializableTests
-import cats.syntax.either._
 
 /**
  * Test that our syntax implicits are serializable.
@@ -21,7 +20,7 @@ class SyntaxSerializationSuite extends CatsSuite {
   checkAll(
     "Tuple3ParallelOps[Either[String, ?], Boolean, Int, Long]",
     SerializableTests.serializable(
-      cats.syntax.all.catsSyntaxTuple3Parallel(("a".asLeft[Boolean], "b".asLeft[Int], "c".asLeft[Long]))
+      cats.syntax.all.catsSyntaxTuple3Parallel[Either[String, ?], Boolean, Int, Long]((Left("a"), Left("b"), Left("c")))
     )
   )
 }
diff --git a/tests/src/test/scala/cats/tests/UnorderedTraverseSuite.scala b/tests/src/test/scala/cats/tests/UnorderedTraverseSuite.scala
index 8e0b69645..8d8e63477 100644
--- a/tests/src/test/scala/cats/tests/UnorderedTraverseSuite.scala
+++ b/tests/src/test/scala/cats/tests/UnorderedTraverseSuite.scala
@@ -4,7 +4,6 @@ import cats.Id
 import cats.syntax.unorderedTraverse._
 import cats.syntax.eq._
 import org.scalacheck.Prop._
-import cats.catsInstancesForId
 
 class UnorderedTraverseSuite extends CatsSuite {
   test("UnorderedTraverse[Set[Int]].unorderedTraverse via syntax") {
