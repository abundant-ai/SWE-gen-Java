diff --git a/.scalafmt.conf b/.scalafmt.conf
index 0d8ef1811..1c755c6b1 100644
--- a/.scalafmt.conf
+++ b/.scalafmt.conf
@@ -10,3 +10,4 @@ docstrings = JavaDoc
 newlines.afterCurlyLambda = preserve
 docstrings.style = Asterisk
 docstrings.oneline = unfold
+project.excludeFilters = [ "core/src/main/scala-3.x" ]
\ No newline at end of file
diff --git a/.travis.yml b/.travis.yml
index 9ae89998e..7323e513f 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -13,7 +13,7 @@ jdk:
 
 scala_version_212: &scala_version_212 2.12.12
 scala_version_213: &scala_version_213 2.13.3
-dotty_version: &dotty_version 0.24.0
+dotty_version: &dotty_version 0.27.0-RC1
 
 before_install:
  - export PATH=${PATH}:./vendor/bundle
@@ -53,7 +53,6 @@ jobs:
       scala: *scala_version_213
       after_success: codecov -F scala_version_213
 
-
     - stage: test
       name: Make Microsite on 2.12.10
       env: TEST="docs"
@@ -75,11 +74,10 @@ jobs:
       name: Binary compatibility 2.13
       scala: *scala_version_213
 
-    # Note that we're currently only building some modules on Dotty, not running tests.
     - stage: test
       name: Dotty tests
       env: TEST="Dotty tests"
-      script: sbt ++$TRAVIS_SCALA_VERSION! alleycatsLawsJVM/compile
+      script: sbt ++$TRAVIS_SCALA_VERSION! buildJVM bench/test
       scala: *dotty_version
 
     - stage: styling
diff --git a/core/src/main/scala-2.x/src/main/scala/cats/syntax/MonadOps.scala b/core/src/main/scala-2.x/src/main/scala/cats/syntax/MonadOps.scala
new file mode 100644
index 000000000..009aea662
--- /dev/null
+++ b/core/src/main/scala-2.x/src/main/scala/cats/syntax/MonadOps.scala
@@ -0,0 +1,12 @@
+package cats.syntax
+
+import cats.{Alternative, Monad}
+
+final class MonadOps[F[_], A](private val fa: F[A]) extends AnyVal {
+  def whileM[G[_]](p: F[Boolean])(implicit M: Monad[F], G: Alternative[G]): F[G[A]] = M.whileM(p)(fa)
+  def whileM_(p: F[Boolean])(implicit M: Monad[F]): F[Unit] = M.whileM_(p)(fa)
+  def untilM[G[_]](p: F[Boolean])(implicit M: Monad[F], G: Alternative[G]): F[G[A]] = M.untilM(fa)(p)
+  def untilM_(p: F[Boolean])(implicit M: Monad[F]): F[Unit] = M.untilM_(fa)(p)
+  def iterateWhile(p: A => Boolean)(implicit M: Monad[F]): F[A] = M.iterateWhile(fa)(p)
+  def iterateUntil(p: A => Boolean)(implicit M: Monad[F]): F[A] = M.iterateUntil(fa)(p)
+}
diff --git a/core/src/main/scala-3.x/src/main/scala/cats/syntax/MonadOps.scala b/core/src/main/scala-3.x/src/main/scala/cats/syntax/MonadOps.scala
new file mode 100644
index 000000000..ba4f2a431
--- /dev/null
+++ b/core/src/main/scala-3.x/src/main/scala/cats/syntax/MonadOps.scala
@@ -0,0 +1,12 @@
+package cats.syntax
+
+import cats.{Monad, Alternative}
+
+final class MonadOps[F[_], A](private val fa: F[A]) extends AnyVal {
+  def whileM[G[_]](using M: Monad[F], G: Alternative[G])(p: F[Boolean]): F[G[A]] = M.whileM(p)(fa)
+  def whileM_(using M: Monad[F])(p: F[Boolean]): F[Unit] = M.whileM_(p)(fa)
+  def untilM[G[_]](using M: Monad[F], G: Alternative[G])(p: F[Boolean]): F[G[A]] = M.untilM(fa)(p)
+  def untilM_(using M: Monad[F])(p: F[Boolean]): F[Unit] = M.untilM_(fa)(p)
+  def iterateWhile(using M: Monad[F])(p: A => Boolean): F[A] = M.iterateWhile(fa)(p)
+  def iterateUntil(using M: Monad[F])(p: A => Boolean): F[A] = M.iterateUntil(fa)(p)
+}
diff --git a/core/src/main/scala/cats/Invariant.scala b/core/src/main/scala/cats/Invariant.scala
index 8f2cf65b5..7547a0749 100644
--- a/core/src/main/scala/cats/Invariant.scala
+++ b/core/src/main/scala/cats/Invariant.scala
@@ -123,7 +123,6 @@ object Invariant extends ScalaVersionSpecificInvariantInstances with InvariantIn
   implicit def catsFlatMapForSortedMap[K]: FlatMap[SortedMap[K, *]] =
     cats.instances.sortedMap.catsStdInstancesForSortedMap[K]
   implicit def catsBimonadForFunction0: Bimonad[Function0] = cats.instances.function.catsStdBimonadForFunction0
-  implicit def catsMonadForFunction1[I]: Monad[I => *] = cats.instances.function.catsStdMonadForFunction1[I]
   implicit def catsContravariantMonoidalForFunction1[R: Monoid]: ContravariantMonoidal[* => R] =
     cats.instances.function.catsStdContravariantMonoidalForFunction1[R]
   implicit def catsFunctorForPair: Functor[Î»[P => (P, P)]] = cats.instances.tuple.catsDataFunctorForPair
@@ -285,7 +284,7 @@ object Invariant extends ScalaVersionSpecificInvariantInstances with InvariantIn
 
 }
 
-private[cats] trait InvariantInstances0 extends TupleInstances0 {
+private[cats] trait InvariantInstances0 extends InvariantInstances1 {
   implicit def catsCommutativeMonadForTuple2[X](implicit X: CommutativeMonoid[X]): CommutativeMonad[(X, *)] =
     cats.instances.tuple.catsStdCommutativeMonadForTuple2[X]
   implicit def catsContravariantForFunction1[R]: Contravariant[* => R] =
@@ -293,13 +292,21 @@ private[cats] trait InvariantInstances0 extends TupleInstances0 {
   implicit def catsDistributiveForFunction0: Distributive[Function0] = cats.instances.function.function0Distributive
   implicit def catsDistributiveForFunction1[I]: Distributive[I => *] =
     cats.instances.function.catsStdDistributiveForFunction1[I]
+
+}
+
+private trait InvariantInstances1 extends InvariantInstances2 {
+  implicit def catsMonadForFunction1[I]: Monad[I => *] = cats.instances.function.catsStdMonadForFunction1[I]
+}
+
+private[cats] trait InvariantInstances2 extends TupleInstances0 {
   implicit def catsApplicativeForArrow[F[_, _], A](implicit F: Arrow[F]): Applicative[F[A, *]] =
     new ArrowApplicative[F, A](F)
   implicit def catsInstancesForSeq: Monad[Seq] with Alternative[Seq] with CoflatMap[Seq] =
     cats.instances.seq.catsStdInstancesForSeq
 }
 
-private trait TupleInstances0 extends TupleInstances1 {
+private[cats] trait TupleInstances0 extends TupleInstances1 {
   implicit def catsCommutativeFlatMapForTuple2[X](implicit X: CommutativeSemigroup[X]): CommutativeFlatMap[(X, *)] =
     cats.instances.tuple.catsStdCommutativeFlatMapForTuple2[X]
 }
diff --git a/core/src/main/scala/cats/syntax/monad.scala b/core/src/main/scala/cats/syntax/monad.scala
index b048827e7..396d06b56 100644
--- a/core/src/main/scala/cats/syntax/monad.scala
+++ b/core/src/main/scala/cats/syntax/monad.scala
@@ -8,15 +8,6 @@ trait MonadSyntax {
     new MonadIdOps[A](a)
 }
 
-final class MonadOps[F[_], A](private val fa: F[A]) extends AnyVal {
-  def whileM[G[_]](p: F[Boolean])(implicit M: Monad[F], G: Alternative[G]): F[G[A]] = M.whileM(p)(fa)
-  def whileM_(p: F[Boolean])(implicit M: Monad[F]): F[Unit] = M.whileM_(p)(fa)
-  def untilM[G[_]](p: F[Boolean])(implicit M: Monad[F], G: Alternative[G]): F[G[A]] = M.untilM(fa)(p)
-  def untilM_(p: F[Boolean])(implicit M: Monad[F]): F[Unit] = M.untilM_(fa)(p)
-  def iterateWhile(p: A => Boolean)(implicit M: Monad[F]): F[A] = M.iterateWhile(fa)(p)
-  def iterateUntil(p: A => Boolean)(implicit M: Monad[F]): F[A] = M.iterateUntil(fa)(p)
-}
-
 final class MonadIdOps[A](private val a: A) extends AnyVal {
 
   /**
diff --git a/free/src/main/scala-2.x/cats/free/FreeFoldStep.scala b/free/src/main/scala-2.x/cats/free/FreeFoldStep.scala
new file mode 100644
index 000000000..4dfcf283e
--- /dev/null
+++ b/free/src/main/scala-2.x/cats/free/FreeFoldStep.scala
@@ -0,0 +1,39 @@
+package cats.free
+
+import Free.{FlatMapped, Pure, Suspend}
+import cats.{Eval, Foldable}
+
+private[free] trait FreeFoldStep[S[_], A] {
+
+  def step: Free[S, A]
+
+  /**
+   * A combination of step and fold. May be used to define interpreters with custom
+   * (non-monoidial) control flow.
+   */
+  final def foldStep[B](
+    onPure: A => B,
+    onSuspend: S[A] => B,
+    onFlatMapped: ((S[X], X => Free[S, A]) forSome { type X }) => B
+  ): B =
+    this.step match {
+      case Pure(a)                    => onPure(a)
+      case Suspend(a)                 => onSuspend(a)
+      case FlatMapped(Suspend(fa), f) => onFlatMapped((fa, f))
+      case _                          => sys.error("FlatMapped should be right associative after step")
+    }
+
+  final def foldLeft[B](fa: Free[S, A], b: B)(f: (B, A) => B)(implicit F: Foldable[S]): B =
+    fa.foldStep(
+      a => f(b, a),
+      fa => F.foldLeft(fa, b)(f),
+      { case (fx, g) => F.foldLeft(fx, b)((bb, x) => foldLeft(g(x), bb)(f)) }
+    )
+
+  final def foldRight[B](fa: Free[S, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B])(implicit F: Foldable[S]): Eval[B] =
+    fa.foldStep(
+      a => f(a, lb),
+      fa => F.foldRight(fa, lb)(f),
+      { case (fx, g) => F.foldRight(fx, lb)((a, lbb) => foldRight(g(a), lbb)(f)) }
+    )
+}
diff --git a/free/src/main/scala-3.x/cats/free/FreeFoldStep.scala b/free/src/main/scala-3.x/cats/free/FreeFoldStep.scala
new file mode 100644
index 000000000..f6fa75e7a
--- /dev/null
+++ b/free/src/main/scala-3.x/cats/free/FreeFoldStep.scala
@@ -0,0 +1,41 @@
+package cats.free
+
+import Free.{FlatMapped, Pure, Suspend}
+import cats.{Foldable, Eval}
+
+private[free] trait FreeFoldStep[S[_], A] {
+
+  def step: Free[S, A]
+
+  private type OnFlatMapped[X] = (S[X], X => Free[S, A])
+
+  /**
+   * A combination of step and fold. May be used to define interpreters with custom
+   * (non-monoidial) control flow.
+   */
+  final def foldStep[B](
+    onPure: A => B,
+    onSuspend: S[A] => B,
+    onFlatMapped: [X] => (S[X], X => Free[S, A]) => B
+  ): B =
+    this.step match {
+      case Pure(a)                    => onPure(a)
+      case Suspend(a)                 => onSuspend(a)
+      case FlatMapped(Suspend(fa), f) => onFlatMapped(fa, f)
+      case _                          => sys.error("FlatMapped should be right associative after step")
+    }
+
+  final def foldLeft[B](fa: Free[S, A], b: B)(f: (B, A) => B)(implicit F: Foldable[S]): B =
+    fa.foldStep(
+      a => f(b, a),
+      fa => F.foldLeft(fa, b)(f),
+      [X] => (sx: S[X], g: X => Free[S, A]) => F.foldLeft(sx, b)((bb, x) => foldLeft(g(x), bb)(f))
+    )
+
+  final def foldRight[B](fa: Free[S, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B])(implicit F: Foldable[S]): Eval[B] =
+    fa.foldStep(
+      a => f(a, lb),
+      fa => F.foldRight(fa, lb)(f),
+      [X] => (sx: S[X], g: X => Free[S, A]) => F.foldRight(sx, lb)((a, lbb) => foldRight(g(a), lbb)(f))
+    )
+}
\ No newline at end of file
diff --git a/free/src/main/scala/cats/free/Free.scala b/free/src/main/scala/cats/free/Free.scala
index 01300b603..c01b10ab3 100644
--- a/free/src/main/scala/cats/free/Free.scala
+++ b/free/src/main/scala/cats/free/Free.scala
@@ -10,7 +10,7 @@ import cats.arrow.FunctionK
  * using the heap instead of the stack, allowing tail-call
  * elimination.
  */
-sealed abstract class Free[S[_], A] extends Product with Serializable {
+sealed abstract class Free[S[_], A] extends Product with Serializable with FreeFoldStep[S, A] {
 
   import Free.{FlatMapped, Pure, Suspend}
 
@@ -73,22 +73,6 @@ sealed abstract class Free[S[_], A] extends Product with Serializable {
         }
     }
 
-  /**
-   * A combination of step and fold. May be used to define interpreters with custom
-   * (non-monoidial) control flow.
-   */
-  final def foldStep[B](
-    onPure: A => B,
-    onSuspend: S[A] => B,
-    onFlatMapped: ((S[X], X => Free[S, A]) forSome { type X }) => B
-  ): B =
-    this.step match {
-      case Pure(a)                    => onPure(a)
-      case Suspend(a)                 => onSuspend(a)
-      case FlatMapped(Suspend(fa), f) => onFlatMapped((fa, f))
-      case _                          => sys.error("FlatMapped should be right associative after step")
-    }
-
   /**
    * Run to completion, using a function that extracts the resumption
    * from its suspension functor.
@@ -315,18 +299,10 @@ private trait FreeFoldable[F[_]] extends Foldable[Free[F, *]] {
   implicit def F: Foldable[F]
 
   final override def foldLeft[A, B](fa: Free[F, A], b: B)(f: (B, A) => B): B =
-    fa.foldStep(
-      a => f(b, a),
-      fa => F.foldLeft(fa, b)(f),
-      { case (fx, g) => F.foldLeft(fx, b)((bb, x) => foldLeft(g(x), bb)(f)) }
-    )
+    fa.foldLeft(fa, b)(f)
 
   final override def foldRight[A, B](fa: Free[F, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
-    fa.foldStep(
-      a => f(a, lb),
-      fa => F.foldRight(fa, lb)(f),
-      { case (fx, g) => F.foldRight(fx, lb)((a, lbb) => foldRight(g(a), lbb)(f)) }
-    )
+    fa.foldRight(fa, lb)(f)
 }
 
 private trait FreeTraverse[F[_]] extends Traverse[Free[F, *]] with FreeFoldable[F] {
diff --git a/kernel/src/main/scala/cats/kernel/Eq.scala b/kernel/src/main/scala/cats/kernel/Eq.scala
index 1a82f5c97..7de7eb694 100644
--- a/kernel/src/main/scala/cats/kernel/Eq.scala
+++ b/kernel/src/main/scala/cats/kernel/Eq.scala
@@ -55,7 +55,7 @@ object Eq
     with EqToEquivConversion
     with ScalaVersionSpecificOrderInstances
     with instances.TupleOrderInstances
-    with PartialOrderInstances {
+    with OrderInstances0 {
 
   /**
    * Access an implicit `Eq[A]`.
@@ -194,8 +194,6 @@ object Eq
     cats.kernel.instances.option.catsKernelStdOrderForOption[A]
   implicit def catsKernelOrderForList[A: Order]: Order[List[A]] =
     cats.kernel.instances.list.catsKernelStdOrderForList[A]
-  implicit def catsKernelOrderForSeq[A: Order]: Order[Seq[A]] =
-    cats.kernel.instances.seq.catsKernelStdOrderForSeq[A]
   implicit def catsKernelOrderForVector[A: Order]: Order[Vector[A]] =
     cats.kernel.instances.vector.catsKernelStdOrderForVector[A]
   implicit def catsKernelOrderForQueue[A: Order]: Order[Queue[A]] =
@@ -221,13 +219,16 @@ object Eq
     }
 }
 
-private[kernel] trait PartialOrderInstances extends HashInstances {
+private[kernel] trait OrderInstances0 extends PartialOrderInstances {
+  implicit def catsKernelOrderForSeq[A: Order]: Order[Seq[A]] =
+    cats.kernel.instances.seq.catsKernelStdOrderForSeq[A]
+}
+
+private[kernel] trait PartialOrderInstances extends PartialOrderInstances0 {
   implicit def catsKernelPartialOrderForOption[A: PartialOrder]: PartialOrder[Option[A]] =
     cats.kernel.instances.option.catsKernelStdPartialOrderForOption[A]
   implicit def catsKernelPartialOrderForList[A: PartialOrder]: PartialOrder[List[A]] =
     cats.kernel.instances.list.catsKernelStdPartialOrderForList[A]
-  implicit def catsKernelPartialOrderForSeq[A: PartialOrder]: PartialOrder[Seq[A]] =
-    cats.kernel.instances.seq.catsKernelStdPartialOrderForSeq[A]
   implicit def catsKernelPartialOrderForVector[A: PartialOrder]: PartialOrder[Vector[A]] =
     cats.kernel.instances.vector.catsKernelStdPartialOrderForVector[A]
   implicit def catsKernelPartialOrderForQueue[A: PartialOrder]: PartialOrder[Queue[A]] =
@@ -236,12 +237,16 @@ private[kernel] trait PartialOrderInstances extends HashInstances {
     cats.kernel.instances.function.catsKernelPartialOrderForFunction0[A]
 }
 
-private[kernel] trait HashInstances extends EqInstances {
+private[kernel] trait PartialOrderInstances0 extends HashInstances {
+  implicit def catsKernelPartialOrderForSeq[A: PartialOrder]: PartialOrder[Seq[A]] =
+    cats.kernel.instances.seq.catsKernelStdPartialOrderForSeq[A]
+}
+
+private[kernel] trait HashInstances extends HashInstances0 {
   implicit def catsKernelHashForSet[A]: Hash[Set[A]] = cats.kernel.instances.set.catsKernelStdHashForSet[A]
   implicit def catsKernelHashForOption[A: Hash]: Hash[Option[A]] =
     cats.kernel.instances.option.catsKernelStdHashForOption[A]
   implicit def catsKernelHashForList[A: Hash]: Hash[List[A]] = cats.kernel.instances.list.catsKernelStdHashForList[A]
-  implicit def catsKernelHashForSeq[A: Hash]: Hash[Seq[A]] = cats.kernel.instances.seq.catsKernelStdHashForSeq[A]
   implicit def catsKernelHashForVector[A: Hash]: Hash[Vector[A]] =
     cats.kernel.instances.vector.catsKernelStdHashForVector[A]
   implicit def catsKernelHashForQueue[A: Hash]: Hash[Queue[A]] =
@@ -258,10 +263,13 @@ private[kernel] trait HashInstances extends EqInstances {
     cats.kernel.instances.either.catsStdHashForEither[A, B]
 }
 
-private[kernel] trait EqInstances {
+private[kernel] trait HashInstances0 extends EqInstances {
+  implicit def catsKernelHashForSeq[A: Hash]: Hash[Seq[A]] = cats.kernel.instances.seq.catsKernelStdHashForSeq[A]
+}
+
+private[kernel] trait EqInstances extends EqInstances0 {
   implicit def catsKernelEqForOption[A: Eq]: Eq[Option[A]] = cats.kernel.instances.option.catsKernelStdEqForOption[A]
   implicit def catsKernelEqForList[A: Eq]: Eq[List[A]] = cats.kernel.instances.list.catsKernelStdEqForList[A]
-  implicit def catsKernelEqForSeq[A: Eq]: Eq[Seq[A]] = cats.kernel.instances.seq.catsKernelStdEqForSeq[A]
   implicit def catsKernelEqForVector[A: Eq]: Eq[Vector[A]] = cats.kernel.instances.vector.catsKernelStdEqForVector[A]
   implicit def catsKernelEqForQueue[A: Eq]: Eq[Queue[A]] = cats.kernel.instances.queue.catsKernelStdEqForQueue[A]
   implicit def catsKernelEqForFunction0[A: Eq]: Eq[() => A] = cats.kernel.instances.function.catsKernelEqForFunction0[A]
@@ -271,3 +279,7 @@ private[kernel] trait EqInstances {
   implicit def catsKernelEqForEither[A: Eq, B: Eq]: Eq[Either[A, B]] =
     cats.kernel.instances.either.catsStdEqForEither[A, B]
 }
+
+private[kernel] trait EqInstances0 {
+  implicit def catsKernelEqForSeq[A: Eq]: Eq[Seq[A]] = cats.kernel.instances.seq.catsKernelStdEqForSeq[A]
+}
