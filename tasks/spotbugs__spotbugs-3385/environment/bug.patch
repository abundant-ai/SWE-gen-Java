diff --git a/CHANGELOG.md b/CHANGELOG.md
index bdbbba083..24a9557a1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -21,8 +21,6 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 ### Added
 - Added the unnecessary annotation to the `US_USELESS_SUPPRESSION_ON_*` messages ([#3395](https://github.com/spotbugs/spotbugs/issues/3395))
 - Multi-threaded code checks can be skipped with `@NotThreadSafe` ([#3390](https://github.com/spotbugs/spotbugs/issues/3390))
-- New bug type `CWO_CLOSED_WITHOUT_OPENED` for locks that might be released without even being acquired. (See [SEI CERT rule LCK08-J](https://wiki.sei.cmu.edu/confluence/display/java/LCK08-J.+Ensure+actively+held+locks+are+released+on+exceptional+conditions)) ([#2055](https://github.com/spotbugs/spotbugs/pull/2055))
-  - Breaking change: changed values and new items in `ResourceValueFrame`.
 
 ## 4.9.3 - 2025-03-14
 ### Added
diff --git a/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/FindUnreleasedLockTest.java b/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/FindUnreleasedLockTest.java
deleted file mode 100644
index 6ec2de880..000000000
--- a/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/FindUnreleasedLockTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package edu.umd.cs.findbugs.detect;
-
-import edu.umd.cs.findbugs.AbstractIntegrationTest;
-import org.junit.jupiter.api.Test;
-
-class FindUnreleasedLockTest extends AbstractIntegrationTest {
-
-    @Test
-    void doesNotFindSSDBugIfLockIsClosedInAProperWay() {
-        performAnalysis("unreleasedLock/ProperlyClosedLock.class");
-        assertNoBugType("UL_UNRELEASED_LOCK");
-        assertNoBugType("UL_UNRELEASED_LOCK_EXCEPTION_PATH");
-        assertNoBugType("CWO_CLOSED_WITHOUT_OPENED");
-    }
-
-    @Test
-    void findPossibleUnlockCallWithoutLockCall() {
-        performAnalysis("unreleasedLock/ThrowExceptionAndUnlockBeforeLock.class");
-        assertNoBugType("UL_UNRELEASED_LOCK");
-        assertNoBugType("UL_UNRELEASED_LOCK_EXCEPTION_PATH");
-        assertBugTypeCount("CWO_CLOSED_WITHOUT_OPENED", 1);
-        assertBugInMethod("CWO_CLOSED_WITHOUT_OPENED", "ThrowExceptionAndUnlockBeforeLock", "doSomething");
-    }
-
-    @Test
-    void findUnresolvedLockOnExceptionalCondition() {
-        performAnalysis("unreleasedLock/UnreleasedLock.class");
-        assertNoBugType("UL_UNRELEASED_LOCK");
-        assertNoBugType("CWO_CLOSED_WITHOUT_OPENED");
-        assertBugTypeCount("UL_UNRELEASED_LOCK_EXCEPTION_PATH", 1);
-        assertBugInMethod("UL_UNRELEASED_LOCK_EXCEPTION_PATH", "UnreleasedLock", "doSomething");
-    }
-}
diff --git a/spotbugs/etc/findbugs.xml b/spotbugs/etc/findbugs.xml
index 42aa64768..e58e03d9f 100644
--- a/spotbugs/etc/findbugs.xml
+++ b/spotbugs/etc/findbugs.xml
@@ -502,8 +502,7 @@
           <Detector class="edu.umd.cs.findbugs.detect.FindUselessControlFlow" speed="fast"
                     reports="UCF_USELESS_CONTROL_FLOW,UCF_USELESS_CONTROL_FLOW_NEXT_LINE"/>
           <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock" speed="moderate"
-                    requirejre="1.5"
-                    reports="UL_UNRELEASED_LOCK,UL_UNRELEASED_LOCK_EXCEPTION_PATH,CWO_CLOSED_WITHOUT_OPENED"/>
+                    requirejre="1.5" reports="UL_UNRELEASED_LOCK,UL_UNRELEASED_LOCK_EXCEPTION_PATH"/>
           <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison" speed="slow"
                     reports="ES_COMPARING_STRINGS_WITH_EQ,ES_COMPARING_PARAMETER_STRING_WITH_EQ,RC_REF_COMPARISON,RC_REF_COMPARISON_BAD_PRACTICE,RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN,EC_UNRELATED_TYPES,EC_NULL_ARG,EC_UNRELATED_CLASS_AND_INTERFACE,EC_UNRELATED_INTERFACES,EC_ARRAY_AND_NONARRAY,EC_INCOMPATIBLE_ARRAY_COMPARE,EC_BAD_ARRAY_COMPARE,EC_UNRELATED_TYPES_USING_POINTER_EQUALITY,DMI_DOH"/>
           <Detector class="edu.umd.cs.findbugs.detect.FindMismatchedWaitOrNotify" speed="moderate"
@@ -1325,7 +1324,6 @@
           <BugPattern abbrev="SING" type="SING_SINGLETON_IMPLEMENTS_SERIALIZABLE" category="CORRECTNESS" cweid="543"/>
           <BugPattern abbrev="SING" type="SING_SINGLETON_GETTER_NOT_SYNCHRONIZED" category="CORRECTNESS" cweid="543"/>
           <BugPattern abbrev="ENV" type="ENV_USE_PROPERTY_INSTEAD_OF_ENV" category="BAD_PRACTICE" />
-          <BugPattern abbrev="CWO" type="CWO_CLOSED_WITHOUT_OPENED" category="MT_CORRECTNESS" cweid="833"/>
           <BugPattern abbrev="AT" type="AT_NONATOMIC_64BIT_PRIMITIVE" category="MT_CORRECTNESS" cweid="667"/>
           <BugPattern abbrev="AT" type="AT_STALE_THREAD_WRITE_OF_PRIMITIVE" category="MT_CORRECTNESS" cweid="413"/>
           <BugPattern abbrev="AT" type="AT_NONATOMIC_OPERATIONS_ON_SHARED_VARIABLE" category="MT_CORRECTNESS" cweid="413"/>
diff --git a/spotbugs/etc/messages.xml b/spotbugs/etc/messages.xml
index d37fdd7e4..919b74982 100644
--- a/spotbugs/etc/messages.xml
+++ b/spotbugs/etc/messages.xml
@@ -1086,14 +1086,13 @@ Returning a zero length array is generally preferred in this context to returnin
   </Detector>
   <Detector class="edu.umd.cs.findbugs.detect.FindUnreleasedLock">
     <Details>
-      <![CDATA[
-        <p> This detector looks for JSR-166 (<code>java.util.concurrent</code>)
-        locks which are acquired, but not released on all paths out of the method.&nbsp;
-        The detector also detects if a lock is released without even being opened in the first place.
-        It is a moderately fast detector.&nbsp; Note that in order to use this
-        detector, you need to have the <code>java.util.concurrent</code> package
-        in the auxiliary classpath (or be analyzing the package itself).</p>
-      ]]>
+<![CDATA[
+<p> This detector looks for JSR-166 (<code>java.util.concurrent</code>)
+locks which are acquired, but not released on all paths out of the method.&nbsp;
+It is a moderately fast detector.&nbsp; Note that in order to use this
+detector, you need to have the <code>java.util.concurrent</code> package
+in the auxiliary classpath (or be analyzing the package itself).</p>
+]]>
     </Details>
   </Detector>
   <Detector class="edu.umd.cs.findbugs.detect.FindRefComparison">
@@ -9644,32 +9643,6 @@ Using floating-point variables should not be used as loop counters, as they are
       </p>]]>
     </Details>
   </BugPattern>
-  <BugPattern type="CWO_CLOSED_WITHOUT_OPENED">
-    <ShortDescription>Method releases lock without opening it</ShortDescription>
-    <LongDescription>{1} releases lock without acquiring it in the first place</LongDescription>
-    <Details>
-      <![CDATA[
-        <p> This method releases a JSR-166 (<code>java.util.concurrent</code>) lock,
-        but it is possible that the lock is not even acquired at this point,
-        due to an exception thrower method before the locking, moreover even the
-        <code>lock()</code> function can throw an exception depending on the implementation.
-        See the relevant part from the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#lock--">Javadoc</a>:
-        "A Lock implementation may be able to detect erroneous use of the lock, such as an invocation that would cause deadlock,
-        and may throw an (unchecked) exception in such circumstances."
-        </p>
-        In general, the correct idiom for using a JSR-166 lock is:
-        </p>
-        <pre><code>Lock l = ...;
-        l.lock();
-        try {
-            // do something
-        } finally {
-            l.unlock();
-        }
-        </code></pre>
-      ]]>
-    </Details>
-  </BugPattern>
   <BugPattern type="AT_NONATOMIC_64BIT_PRIMITIVE">
     <ShortDescription>This write of this 64-bit primitive variable may not atomic</ShortDescription>
     <LongDescription>This write of the 64-bit primitive variable "{2.name}" may not atomic</LongDescription>
@@ -9960,7 +9933,6 @@ Using floating-point variables should not be used as loop counters, as they are
   <BugCode abbrev="AA">Misuse of assertions for checking arguments of public methods</BugCode>
   <BugCode abbrev="PI">Do not reuse public identifiers from Java Standard Library</BugCode>
   <BugCode abbrev="ENV">Environment variable is used instead of the corresponding Java property</BugCode>
-  <BugCode abbrev="CWO">Lock closed without being opened in the first place</BugCode>
   <BugCode abbrev="HSM">Avoid method hiding</BugCode>
   <BugCode abbrev="US">Useless suppression</BugCode>
 </MessageCollection>
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/ba/ResourceValueAnalysis.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/ba/ResourceValueAnalysis.java
index 0a209a5be..f64cdf591 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/ba/ResourceValueAnalysis.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/ba/ResourceValueAnalysis.java
@@ -106,9 +106,6 @@ public class ResourceValueAnalysis<Resource> extends FrameDataflowAnalysis<Resou
                 // If status is OPEN, downgrade to OPEN_ON_EXCEPTION_PATH
                 tmpFact = modifyFrame(fact, null);
                 tmpFact.setStatus(ResourceValueFrame.State.OPEN_ON_EXCEPTION_PATH);
-            } else {
-                tmpFact = modifyFrame(fact, null);
-                tmpFact.setStatus(ResourceValueFrame.State.NOT_OPEN_ON_EXCEPTION_PATH);
             }
 
             if (fact.isValid()) {
@@ -138,11 +135,6 @@ public class ResourceValueAnalysis<Resource> extends FrameDataflowAnalysis<Resou
                 tmpFact.clearStack();
                 tmpFact.pushValue(ResourceValue.notInstance());
             }
-        } else {
-            if (result.getStatus() == ResourceValueFrame.State.NOT_OPEN_ON_EXCEPTION_PATH && fact.getStatus() == ResourceValueFrame.State.CLOSED) {
-                tmpFact = modifyFrame(fact, null);
-                tmpFact.setStatus(ResourceValueFrame.State.CLOSED_WITHOUT_OPENED);
-            }
         }
 
         // Make the resource nonexistent if it is compared against null
@@ -196,6 +188,7 @@ public class ResourceValueAnalysis<Resource> extends FrameDataflowAnalysis<Resou
 
                         if (topValue.isInstance()
                                 && ((isNullCheck && edgeType == IFCMP_EDGE) || (isNonNullCheck && edgeType == FALL_THROUGH_EDGE))) {
+                            // System.out.println("**** making resource nonexistent on edge "+edge.getId());
                             tmpFact = modifyFrame(fact, tmpFact);
                             tmpFact.setStatus(ResourceValueFrame.State.NONEXISTENT);
                         }
@@ -221,7 +214,8 @@ public class ResourceValueAnalysis<Resource> extends FrameDataflowAnalysis<Resou
     }
 
     @Override
-    protected void mergeValues(ResourceValueFrame otherFrame, ResourceValueFrame resultFrame, int slot) {
+    protected void mergeValues(ResourceValueFrame otherFrame, ResourceValueFrame resultFrame, int slot)
+            throws DataflowAnalysisException {
         ResourceValue value = ResourceValue.merge(resultFrame.getValue(slot), otherFrame.getValue(slot));
         resultFrame.setValue(slot, value);
     }
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/ba/ResourceValueFrame.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/ba/ResourceValueFrame.java
index 0c44e6c51..7471468ca 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/ba/ResourceValueFrame.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/ba/ResourceValueFrame.java
@@ -39,31 +39,20 @@ public class ResourceValueFrame extends Frame<ResourceValue> {
          */
         OPEN_ON_EXCEPTION_PATH(2),
 
-        /**
-         * The resource is closed without being opened in the first place.
-         */
-        CLOSED_WITHOUT_OPENED(3),
-
         /**
          * The resource is closed (or unlocked, etc).
          */
-        CLOSED(4),
+        CLOSED(3),
 
         /**
          * The resource has been created, but is not open.
          */
-        CREATED(5),
+        CREATED(4),
 
         /**
          * The resource doesn't exist.
          */
-        NONEXISTENT(6),
-
-        /**
-         * The resource is NOT open (or locked, etc) on paths that include exception
-         * control flow.
-         */
-        NOT_OPEN_ON_EXCEPTION_PATH(7);
+        NONEXISTENT(5);
 
         State(int type) {
             this.type = type;
@@ -108,8 +97,8 @@ public class ResourceValueFrame extends Frame<ResourceValue> {
         this.status = other.status;
     }
 
-    private static final String[] statusList = { "(escaped)", "(open)", "(open_exception)", "(closed_without_opened)", "(closed)", "(created)",
-        "(nonexistent)", "(not_open_exception)" };
+    private static final String[] statusList = { "(escaped)", "(open)", "(open_exception)", "(closed)", "(created)",
+        "(nonexistent)" };
 
     @Override
     public String toString() {
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/FindUnreleasedLock.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/FindUnreleasedLock.java
index b4ae232b8..830e7be27 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/FindUnreleasedLock.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/FindUnreleasedLock.java
@@ -91,12 +91,15 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
 
         private final ValueNumberDataflow vnaDataflow;
 
+        // private IsNullValueDataflow isNullDataflow;
+
         public LockFrameModelingVisitor(ConstantPoolGen cpg, LockResourceTracker resourceTracker, Lock lock,
-                ValueNumberDataflow vnaDataflow) {
+                ValueNumberDataflow vnaDataflow, IsNullValueDataflow isNullDataflow) {
             super(cpg);
             this.resourceTracker = resourceTracker;
             this.lock = lock;
             this.vnaDataflow = vnaDataflow;
+            // this.isNullDataflow = isNullDataflow;
         }
 
         @Override
@@ -109,40 +112,28 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
             boolean updated = false;
 
             if (DEBUG) {
-                System.out.println("Before transferInstruction status of frame: " + frame.getStatus());
                 System.out.println("PC : " + handle.getPosition() + " " + ins);
-                if (ins instanceof InvokeInstruction) {
-                    System.out.println("  " + ins.toString(cpg.getConstantPool()));
-                }
-                System.out.println("resource frame before instruction: " + frame);
+            }
+            if (DEBUG && ins instanceof InvokeInstruction) {
+                System.out.println("  " + ins.toString(cpg.getConstantPool()));
+            }
+            if (DEBUG) {
+                System.out.println("resource frame before instruction: " + frame.toString());
             }
 
             // Is a lock acquired or released by this instruction?
             Location creationPoint = lock.getLocation();
-            if (frame.getStatus() == ResourceValueFrame.State.CLOSED_WITHOUT_OPENED) {
-                status = ResourceValueFrame.State.CLOSED_WITHOUT_OPENED;
-                if (DEBUG) {
-                    System.out.println("CLOSED WITHOUT OPENED");
-                }
-            } else if (handle == creationPoint.getHandle() && basicBlock == creationPoint.getBasicBlock()) {
+            if (handle == creationPoint.getHandle() && basicBlock == creationPoint.getBasicBlock()) {
                 status = ResourceValueFrame.State.OPEN;
                 updated = true;
                 if (DEBUG) {
                     System.out.println("OPEN");
                 }
             } else if (resourceTracker.isResourceClose(basicBlock, handle, cpg, lock, frame)) {
-                if (frame.getStatus() == ResourceValueFrame.State.NOT_OPEN_ON_EXCEPTION_PATH) {
-                    status = ResourceValueFrame.State.CLOSED_WITHOUT_OPENED;
-                    updated = true;
-                    if (DEBUG) {
-                        System.out.println("CLOSED WITHOUT OPENED");
-                    }
-                } else {
-                    status = ResourceValueFrame.State.CLOSED;
-                    updated = true;
-                    if (DEBUG) {
-                        System.out.println("CLOSE");
-                    }
+                status = ResourceValueFrame.State.CLOSED;
+                updated = true;
+                if (DEBUG) {
+                    System.out.println("CLOSE");
                 }
             }
 
@@ -182,7 +173,7 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
                 frame.setStatus(status);
             }
             if (DEBUG) {
-                System.out.println("resource frame after instruction: " + frame);
+                System.out.println("resource frame after instruction: " + frame.toString());
             }
 
         }
@@ -231,7 +222,9 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
                     ValueNumberFrame frame = vnaDataflow.getFactAtLocation(location);
                     ValueNumber lockValue = frame.getTopValue();
                     if (DEBUG) {
-                        System.out.println("Lock value is " + lockValue.getNumber() + ", frame=" + frame);
+                        System.out.println("Lock value is " + lockValue.getNumber() + ", frame=" + frame.toString());
+                    }
+                    if (DEBUG) {
                         ++numAcquires;
                     }
                     return new Lock(location, className, lockValue);
@@ -243,7 +236,8 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
         }
 
         @Override
-        public boolean mightCloseResource(BasicBlock basicBlock, InstructionHandle handle, ConstantPoolGen cpg) {
+        public boolean mightCloseResource(BasicBlock basicBlock, InstructionHandle handle, ConstantPoolGen cpg)
+                throws DataflowAnalysisException {
             InvokeInstruction inv = toInvokeInstruction(handle.getInstruction());
             if (inv == null) {
                 return false;
@@ -256,6 +250,7 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
             try {
                 if ("unlock".equals(methodName) && "()V".equals(methodSig)
                         && Hierarchy.isSubtype(className, "java.util.concurrent.locks.Lock")) {
+
                     return true;
                 }
             } catch (ClassNotFoundException e) {
@@ -279,7 +274,7 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
 
         @Override
         public ResourceValueFrameModelingVisitor createVisitor(Lock resource, ConstantPoolGen cpg) {
-            return new LockFrameModelingVisitor(cpg, this, resource, vnaDataflow);
+            return new LockFrameModelingVisitor(cpg, this, resource, vnaDataflow, isNullDataflow);
         }
 
         @Override
@@ -323,6 +318,7 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
                 } else if (ins instanceof InvokeInstruction) {
                     InvokeInstruction iins = (InvokeInstruction) ins;
                     String methodName = iins.getMethodName(cpg);
+                    // System.out.println("Method " + methodName);
                     if (methodName.startsWith("access$")) {
                         return true;
                     }
@@ -391,8 +387,8 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
         for (Constant c : jclass.getConstantPool().getConstantPool()) {
             if (c instanceof ConstantMethodref) {
                 ConstantMethodref m = (ConstantMethodref) c;
-                ConstantClass cl = jclass.getConstantPool().getConstant(m.getClassIndex());
-                ConstantUtf8 name = jclass.getConstantPool().getConstant(cl.getNameIndex());
+                ConstantClass cl = (ConstantClass) jclass.getConstantPool().getConstant(m.getClassIndex());
+                ConstantUtf8 name = (ConstantUtf8) jclass.getConstantPool().getConstant(cl.getNameIndex());
                 String nameAsString = name.getBytes();
                 if (nameAsString.startsWith("java/util/concurrent/locks")) {
                     sawUtilConcurrentLocks = true;
@@ -417,7 +413,7 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
 
         MethodGen methodGen = classContext.getMethodGen(method);
 
-        return methodGen != null && !methodGen.getName().toLowerCase().contains("lock")
+        return methodGen != null && methodGen.getName().toLowerCase().indexOf("lock") == -1
                 && (bytecodeSet.get(Const.INVOKEVIRTUAL) || bytecodeSet.get(Const.INVOKEINTERFACE));
     }
 
@@ -440,28 +436,24 @@ public class FindUnreleasedLock extends ResourceTrackingDetector<Lock, FindUnrel
         }
         ResourceValueFrame.State exitStatus = exitFrame.getStatus();
 
-        if (exitStatus == ResourceValueFrame.State.OPEN
-                || exitStatus == ResourceValueFrame.State.OPEN_ON_EXCEPTION_PATH
-                || exitStatus == ResourceValueFrame.State.CLOSED_WITHOUT_OPENED) {
-            String sourceFile = javaClass.getSourceFileName();
-            Location location = resource.getLocation();
-            InstructionHandle handle = location.getHandle();
-            InstructionHandle nextInstruction = handle.getNext();
-            if (nextInstruction.getInstruction() instanceof RETURN) {
-                return; // don't report as error; intentional
-            }
-
+        if (exitStatus == ResourceValueFrame.State.OPEN ||
+                exitStatus == ResourceValueFrame.State.OPEN_ON_EXCEPTION_PATH) {
             String bugType;
             int priority;
             if (exitStatus == ResourceValueFrame.State.OPEN) {
                 bugType = "UL_UNRELEASED_LOCK";
                 priority = HIGH_PRIORITY;
-            } else if (exitStatus == ResourceValueFrame.State.OPEN_ON_EXCEPTION_PATH) {
+            } else {
                 bugType = "UL_UNRELEASED_LOCK_EXCEPTION_PATH";
                 priority = NORMAL_PRIORITY;
-            } else {
-                bugType = "CWO_CLOSED_WITHOUT_OPENED";
-                priority = LOW_PRIORITY;
+            }
+
+            String sourceFile = javaClass.getSourceFileName();
+            Location location = resource.getLocation();
+            InstructionHandle handle = location.getHandle();
+            InstructionHandle nextInstruction = handle.getNext();
+            if (nextInstruction.getInstruction() instanceof RETURN) {
+                return; // don't report as error; intentional
             }
             bugAccumulator.accumulateBug(new BugInstance(this, bugType, priority).addClassAndMethod(methodGen, sourceFile),
                     SourceLineAnnotation.fromVisitedInstruction(classContext, methodGen, sourceFile, handle));
diff --git a/spotbugsTestCases/src/java/unreleasedLock/ProperlyClosedLock.java b/spotbugsTestCases/src/java/unreleasedLock/ProperlyClosedLock.java
deleted file mode 100644
index 3c2c5b652..000000000
--- a/spotbugsTestCases/src/java/unreleasedLock/ProperlyClosedLock.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package unreleasedLock;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-public class ProperlyClosedLock {
-    private final Lock lock = new ReentrantLock();
-
-    public void doSomething(File file) {
-        InputStream in = null;
-        lock.lock();
-        try {
-            in = new FileInputStream(file);
-            // Perform operations on the open file
-        } catch (FileNotFoundException fnf) {
-            // Forward to handler
-        } finally {
-            lock.unlock();
-            if (in != null) {
-                try {
-                    in.close();
-                } catch (IOException e) {
-                    // Forward to handler
-                }
-            }
-        }
-    }
-}
diff --git a/spotbugsTestCases/src/java/unreleasedLock/ThrowExceptionAndUnlockBeforeLock.java b/spotbugsTestCases/src/java/unreleasedLock/ThrowExceptionAndUnlockBeforeLock.java
deleted file mode 100644
index 949a34816..000000000
--- a/spotbugsTestCases/src/java/unreleasedLock/ThrowExceptionAndUnlockBeforeLock.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package unreleasedLock;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-public class ThrowExceptionAndUnlockBeforeLock {
-    private final Lock lock = new ReentrantLock();
-
-    public void doSomething(File file) {
-        InputStream in = null;
-        try {
-            in = new FileInputStream(file);
-            lock.lock();
-            // Perform operations on the open file
-        } catch (FileNotFoundException fnf) {
-            // Forward to handler
-        } finally {
-            lock.unlock();
-            if (in != null) {
-                try {
-                    in.close();
-                } catch (IOException e) {
-                    // Forward to handler
-                }
-            }
-        }
-    }
-}
diff --git a/spotbugsTestCases/src/java/unreleasedLock/UnreleasedLock.java b/spotbugsTestCases/src/java/unreleasedLock/UnreleasedLock.java
deleted file mode 100644
index 8141943e5..000000000
--- a/spotbugsTestCases/src/java/unreleasedLock/UnreleasedLock.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package unreleasedLock;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
-
-public class UnreleasedLock {
-    private final Lock lock = new ReentrantLock();
-
-    public void doSomething(File file) {
-        InputStream in = null;
-        try {
-            in = new FileInputStream(file);
-            lock.lock();
-
-            // Perform operations on the open file
-            byte[] bytes = new byte[10];
-            int a = in.read(bytes);
-            System.out.println("!!!!AFTER READ!!!!");
-            System.out.println(a);
-
-            lock.unlock();
-        } catch (IOException x) {
-            // Handle exception
-        } finally {
-            if (in != null) {
-                try {
-                    in.close();
-                } catch (IOException x) {
-                    // Handle exception
-                }
-
-            }
-        }
-    }
-}
\ No newline at end of file
