diff --git a/release-notes/VERSION b/release-notes/VERSION
index 7e75f1a14..83bf12b0a 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -136,8 +136,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #5583 Improve `asXxx()` method impls of `MissingNode`, `POJONode(null)`,
   to work like `NullNode`
  (implemented by @cowtowncoder, w/ Claude code)
-#5586: Change `IndexOutOfBoundsException` that `ArrayNode.set()`/`replace()`
-  throw to `JsonNodeException`
 
 3.0.4 (not yet released)
 
diff --git a/src/main/java/tools/jackson/databind/node/ArrayNode.java b/src/main/java/tools/jackson/databind/node/ArrayNode.java
index 83247c046..bcaacf2bc 100644
--- a/src/main/java/tools/jackson/databind/node/ArrayNode.java
+++ b/src/main/java/tools/jackson/databind/node/ArrayNode.java
@@ -426,7 +426,7 @@ public class ArrayNode
      *
      * @return This node after adding/replacing property value (to allow chaining)
      *
-     * @throws JsonNodeException If Array does not have specified element
+     * @throws IndexOutOfBoundsException If Array does not have specified element
      *  (that is, index is outside valid range of elements in array)
      */
     public ArrayNode set(int index, JsonNode value)
@@ -434,7 +434,11 @@ public class ArrayNode
         if (value == null) { // let's not store 'raw' nulls but nodes
             value = nullNode();
         }
-        return _set(index, value);
+        if (index < 0 || index >= _children.size()) {
+            throw new IndexOutOfBoundsException("Illegal index "+ index +", array size "+size());
+        }
+        _children.set(index, value);
+        return this;
     }
 
     /**
@@ -446,7 +450,7 @@ public class ArrayNode
      *
      * @return Old value of the element, if any; null if no such element existed.
      *
-     * @throws JsonNodeException If Array does not have specified element
+     * @throws IndexOutOfBoundsException If Array does not have specified element
      *  (that is, index is outside valid range of elements in array)
      */
     public JsonNode replace(int index, JsonNode value)
@@ -455,10 +459,8 @@ public class ArrayNode
             value = nullNode();
         }
         if (index < 0 || index >= _children.size()) {
-            throw JsonNodeException.from(this,
-                    "Illegal index %d, array size %d", index, size());
+            throw new IndexOutOfBoundsException("Illegal index "+ index +", array size "+size());
         }
-        // NOTE: cannot call `_set()` since it returns `this`, NOT old value
         return _children.set(index, value);
     }
 
diff --git a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
index bb34b0dc5..5ab2cd759 100644
--- a/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
+++ b/src/test/java/tools/jackson/databind/node/ArrayNodeTest.java
@@ -10,7 +10,6 @@ import org.junit.jupiter.api.Test;
 
 import tools.jackson.core.*;
 import tools.jackson.databind.*;
-import tools.jackson.databind.exc.JsonNodeException;
 import tools.jackson.databind.exc.MismatchedInputException;
 import tools.jackson.databind.testutil.DatabindTestUtil;
 import tools.jackson.databind.util.RawValue;
@@ -129,7 +128,7 @@ public class ArrayNodeTest
         try {
             n.set(2, NODE_F.nullNode());
             fail("Should not pass");
-        } catch (JsonNodeException e) {
+        } catch (IndexOutOfBoundsException e) {
             verifyException(e, "illegal index");
         }
         n.insert(1, (String) null);
@@ -220,11 +219,11 @@ public class ArrayNodeTest
         try {
             array.replace(100, null);
             fail("Should not pass");
-        } catch (JsonNodeException e) {
-            verifyException(e, "Illegal index 100, array size 1");
+        } catch (IndexOutOfBoundsException e) {
+            ;
         }
     }
-
+    
     @Test
     public void testArrayViaMapper()
     {
diff --git a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
index 8483ee5b0..bfadcd35d 100644
--- a/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
+++ b/src/test/java/tools/jackson/databind/node/TreeTraversingParserTest.java
@@ -1,6 +1,5 @@
 package tools.jackson.databind.node;
 
-import java.io.ByteArrayOutputStream;
 import java.math.BigInteger;
 import java.util.*;
 
@@ -69,9 +68,6 @@ public class TreeTraversingParserTest
         assertEquals("a", p.currentName());
         assertEquals(123, p.getIntValue());
         assertEquals((short) 123, p.getShortValue());
-        assertEquals(123, p.getValueAsInt(-1));
-        assertEquals(123L, p.getValueAsLong(42L));
-        assertEquals(BigInteger.valueOf(123L), p.getBigIntegerValue());
         assertEquals("123", p.getString());
 
         assertToken(JsonToken.PROPERTY_NAME, p.nextToken());
@@ -85,55 +81,18 @@ public class TreeTraversingParserTest
         assertToken(JsonToken.VALUE_NUMBER_FLOAT, p.nextToken());
         assertNull(p.currentName());
         assertEquals(12.25, p.getDoubleValue(), 0);
-        assertEquals(12.25f, p.getFloatValue(), 0);
         assertEquals(NumberType.DOUBLE, p.getNumberType());
         assertEquals(NumberTypeFP.DOUBLE64, p.getNumberTypeFP());
         assertFalse(p.isNaN());
-        try {
-            p.getShortValue();
-            fail("Should not pass");
-        } catch (InputCoercionException e) {
-            verifyException(e, "has fractional part; cannot convert to `short`");
-        }
-        try {
-            p.getIntValue();
-            fail("Should not pass");
-        } catch (InputCoercionException e) {
-            verifyException(e, "has fractional part; cannot convert to `int`");
-        }
-        assertEquals(12, p.getValueAsInt(1));
-        try {
-            p.getLongValue();
-            fail("Should not pass");
-        } catch (InputCoercionException e) {
-            verifyException(e, "has fractional part; cannot convert to `long`");
-        }
-        assertEquals(12L, p.getValueAsLong(2L));
         assertEquals("12.25", p.getString());
 
         assertToken(JsonToken.VALUE_NULL, p.nextToken());
         assertNull(p.currentName());
-        assertNull(p.getNumberType());
-        assertEquals(NumberTypeFP.UNKNOWN, p.getNumberTypeFP());
         assertEquals(JsonToken.VALUE_NULL.asString(), p.getString());
 
         assertToken(JsonToken.VALUE_TRUE, p.nextToken());
         assertNull(p.currentName());
         assertTrue(p.getBooleanValue());
-        try {
-            p.getValueAsInt(1);
-            fail("Should not pass");
-        } catch (InputCoercionException e) {
-            verifyException(e, "Current token (VALUE_TRUE) not numeric, cannot use numeric value accessors");
-        }
-        try {
-            p.getValueAsLong(2L);
-            fail("Should not pass");
-        } catch (InputCoercionException e) {
-            verifyException(e, "Current token (VALUE_TRUE) not numeric, cannot use numeric value accessors");
-        }
-        assertNull(p.getNumberType());
-        assertEquals(NumberTypeFP.UNKNOWN, p.getNumberTypeFP());
         assertEquals(JsonToken.VALUE_TRUE.asString(), p.getString());
 
         assertToken(JsonToken.START_OBJECT, p.nextToken());
@@ -232,21 +191,16 @@ public class TreeTraversingParserTest
     {
         byte[] inputBinary = new byte[] { 1, 2, 100 };
         POJONode n = new POJONode(inputBinary);
-        try (JsonParser p = n.traverse(ObjectReadContext.empty())) {
-            assertNull(p.currentToken());
-            assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, p.nextToken());
-            byte[] data = p.getBinaryValue();
-            assertNotNull(data);
-            assertArrayEquals(inputBinary, data);
-            Object pojo = p.getEmbeddedObject();
-            assertSame(data, pojo);
-
-            // and for code coverage
-            ByteArrayOutputStream bout = new ByteArrayOutputStream();
-            int count = p.readBinaryValue(Base64Variants.getDefaultVariant(), bout);
-            assertEquals(data.length, count);
-            assertArrayEquals(inputBinary, bout.toByteArray());
-        }
+        JsonParser p = n.traverse(ObjectReadContext.empty());
+
+        assertNull(p.currentToken());
+        assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, p.nextToken());
+        byte[] data = p.getBinaryValue();
+        assertNotNull(data);
+        assertArrayEquals(inputBinary, data);
+        Object pojo = p.getEmbeddedObject();
+        assertSame(data, pojo);
+        p.close();
     }
 
     @Test
