diff --git a/README.md b/README.md
index 1c6e9423..7268b5e1 100644
--- a/README.md
+++ b/README.md
@@ -498,7 +498,7 @@ Download [the latest JAR][dl] or depend via Maven:
 ```
 or Gradle:
 ```groovy
-implementation 'com.squareup.moshi:moshi:1.5.0'
+compile 'com.squareup.moshi:moshi:1.5.0'
 ```
 and for additional Kotlin support:
 ```xml
@@ -510,7 +510,7 @@ and for additional Kotlin support:
 ```
 or Gradle:
 ```groovy
-implementation 'com.squareup.moshi:moshi-kotlin:1.5.0'
+compile 'com.squareup.moshi:moshi-kotlin:1.5.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/adapters/README.md b/adapters/README.md
index d94849c2..d3808e51 100644
--- a/adapters/README.md
+++ b/adapters/README.md
@@ -25,7 +25,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-implementation 'com.squareup.moshi:moshi-adapters:latest.version'
+compile 'com.squareup.moshi:moshi-adapters:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
new file mode 100644
index 00000000..345919eb
--- /dev/null
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi
+
+import com.google.auto.common.AnnotationMirrors
+import com.google.auto.service.AutoService
+import com.squareup.kotlinpoet.KModifier.OUT
+import com.squareup.kotlinpoet.TypeSpec
+import com.squareup.kotlinpoet.TypeVariableName
+import me.eugeniomarletti.kotlin.metadata.KotlinClassMetadata
+import me.eugeniomarletti.kotlin.metadata.KotlinMetadataUtils
+import me.eugeniomarletti.kotlin.metadata.declaresDefaultValue
+import me.eugeniomarletti.kotlin.metadata.extractFullName
+import me.eugeniomarletti.kotlin.metadata.isDataClass
+import me.eugeniomarletti.kotlin.metadata.isPrimary
+import me.eugeniomarletti.kotlin.metadata.jvm.getJvmConstructorSignature
+import me.eugeniomarletti.kotlin.metadata.kotlinMetadata
+import me.eugeniomarletti.kotlin.metadata.visibility
+import me.eugeniomarletti.kotlin.processing.KotlinAbstractProcessor
+import org.jetbrains.kotlin.serialization.ProtoBuf
+import java.io.File
+import javax.annotation.processing.Processor
+import javax.annotation.processing.RoundEnvironment
+import javax.lang.model.SourceVersion
+import javax.lang.model.element.Element
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+import javax.tools.Diagnostic.Kind.ERROR
+
+/**
+ * An annotation processor that reads Kotlin data classes and generates Moshi JsonAdapters for them.
+ * This generates Kotlin code, and understands basic Kotlin language features like default values
+ * and companion objects.
+ *
+ * The generated class will match the visibility of the given data class (i.e. if it's internal, the
+ * adapter will also be internal).
+ *
+ * If you define a companion object, a jsonAdapter() extension function will be generated onto it.
+ * If you don't want this though, you can use the runtime [JsonClass] factory implementation.
+ */
+@AutoService(Processor::class)
+class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils {
+
+  private val annotation = JsonClass::class.java
+
+  override fun getSupportedAnnotationTypes() = setOf(annotation.canonicalName)
+
+  override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latest()
+
+  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
+    for (type in roundEnv.getElementsAnnotatedWith(annotation)) {
+      val jsonClass = type.getAnnotation(annotation)
+      if (jsonClass.generateAdapter) {
+        val adapterGenerator = processElement(type) ?: continue
+        adapterGenerator.generateAndWrite()
+      }
+    }
+
+    return true
+  }
+
+  private fun processElement(element: Element): AdapterGenerator? {
+    val metadata = element.kotlinMetadata
+
+    if (metadata !is KotlinClassMetadata) {
+      errorMustBeDataClass(element)
+      return null
+    }
+
+    val classData = metadata.data
+    val (nameResolver, classProto) = classData
+
+    fun ProtoBuf.Type.extractFullName() = extractFullName(classData)
+
+    if (!classProto.isDataClass) {
+      errorMustBeDataClass(element)
+      return null
+    }
+
+    val fqClassName = nameResolver.getString(classProto.fqName).replace('/', '.')
+
+    val packageName = nameResolver.getString(classProto.fqName).substringBeforeLast('/').replace(
+        '/', '.')
+
+    val hasCompanionObject = classProto.hasCompanionObjectName()
+    // todo allow custom constructor
+    val protoConstructor = classProto.constructorList
+        .single { it.isPrimary }
+    val constructorJvmSignature = protoConstructor.getJvmConstructorSignature(nameResolver,
+        classProto.typeTable)
+    val constructor = classProto.fqName
+        .let(nameResolver::getString)
+        .replace('/', '.')
+        .let(elementUtils::getTypeElement)
+        .enclosedElements
+        .mapNotNull {
+          it.takeIf { it.kind == ElementKind.CONSTRUCTOR }?.let { it as ExecutableElement }
+        }
+        .first()
+    // TODO Temporary until jvm method signature matching is better
+    //  .single { it.jvmMethodSignature == constructorJvmSignature }
+    val parameters = protoConstructor
+        .valueParameterList
+        .mapIndexed { index, valueParameter ->
+          val paramName = nameResolver.getString(valueParameter.name)
+
+          val nullable = valueParameter.type.nullable
+          val paramFqcn = valueParameter.type.extractFullName()
+              .replace("`", "")
+              .removeSuffix("?")
+
+          val actualElement = constructor.parameters[index]
+
+          val serializedName = actualElement.getAnnotation(Json::class.java)?.name
+              ?: paramName
+
+          val jsonQualifiers = AnnotationMirrors.getAnnotatedAnnotations(actualElement,
+              JsonQualifier::class.java)
+
+          PropertyGenerator(
+              name = paramName,
+              serializedName = serializedName,
+              hasDefault = valueParameter.declaresDefaultValue,
+              nullable = nullable,
+              typeName = valueParameter.type.asTypeName(nameResolver, classProto::getTypeParameter),
+              unaliasedName = valueParameter.type.asTypeName(nameResolver,
+                  classProto::getTypeParameter, true),
+              jsonQualifiers = jsonQualifiers)
+        }
+
+    val genericTypeNames = classProto.typeParameterList
+        .map {
+          val variance = it.variance.asKModifier().let {
+            // We don't redeclare out variance here
+            if (it == OUT) {
+              null
+            } else {
+              it
+            }
+          }
+          TypeVariableName(
+              name = nameResolver.getString(it.name),
+              bounds = *(it.upperBoundList
+                  .map { it.asTypeName(nameResolver, classProto::getTypeParameter) }
+                  .toTypedArray()),
+              variance = variance)
+              .reified(it.reified)
+        }.let {
+          if (it.isEmpty()) {
+            null
+          } else {
+            it
+          }
+        }
+
+    return AdapterGenerator(
+        fqClassName = fqClassName,
+        packageName = packageName,
+        propertyList = parameters,
+        originalElement = element,
+        hasCompanionObject = hasCompanionObject,
+        visibility = classProto.visibility!!,
+        genericTypeNames = genericTypeNames,
+        elements = elementUtils)
+  }
+
+  private fun errorMustBeDataClass(element: Element) {
+    messager.printMessage(ERROR,
+        "@${JsonClass::class.java.simpleName} can't be applied to $element: must be a Kotlin data class",
+        element)
+  }
+
+  private fun AdapterGenerator.generateAndWrite() {
+    val fileSpec = generateFile()
+    val adapterName = fileSpec.members.filterIsInstance<TypeSpec>().first().name!!
+    val outputDir = generatedDir ?: mavenGeneratedDir(adapterName)
+    fileSpec.writeTo(outputDir)
+  }
+
+  private fun mavenGeneratedDir(adapterName: String): File {
+    // Hack since the maven plugin doesn't supply `kapt.kotlin.generated` option
+    // Bug filed at https://youtrack.jetbrains.com/issue/KT-22783
+    val file = filer.createSourceFile(adapterName).toUri().let(::File)
+    return file.parentFile.also { file.delete() }
+  }
+}
+
diff --git a/kotlin-codegen/integration-test/pom.xml b/kotlin-codegen/integration-test/pom.xml
index 2ecc4b2d..8b24a4e9 100644
--- a/kotlin-codegen/integration-test/pom.xml
+++ b/kotlin-codegen/integration-test/pom.xml
@@ -18,11 +18,6 @@
       <artifactId>moshi</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi-kotlin-codegen-runtime</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>org.jetbrains.kotlin</groupId>
       <artifactId>kotlin-stdlib</artifactId>
@@ -57,7 +52,6 @@
             <configuration>
               <sourceDirs>
                 <sourceDir>src/main/kotlin</sourceDir>
-                <sourceDir>src/main/java</sourceDir>
               </sourceDirs>
               <annotationProcessorPaths>
                 <annotationProcessorPath>
diff --git a/kotlin-codegen/runtime/pom.xml b/kotlin-codegen/runtime/pom.xml
deleted file mode 100644
index 08b8e367..00000000
--- a/kotlin-codegen/runtime/pom.xml
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.moshi</groupId>
-    <artifactId>moshi-parent</artifactId>
-    <version>1.6.0-SNAPSHOT</version>
-    <relativePath>../../pom.xml</relativePath>
-  </parent>
-
-  <artifactId>moshi-kotlin-codegen-runtime</artifactId>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.jetbrains.kotlin</groupId>
-      <artifactId>kotlin-stdlib</artifactId>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.jetbrains.kotlin</groupId>
-        <artifactId>kotlin-maven-plugin</artifactId>
-        <version>${kotlin.version}</version>
-        <executions>
-          <execution>
-            <id>compile</id>
-            <phase>compile</phase>
-            <goals>
-              <goal>compile</goal>
-            </goals>
-          </execution>
-          <execution>
-            <id>test-compile</id>
-            <phase>test-compile</phase>
-            <goals>
-              <goal>test-compile</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <executions>
-          <execution>
-            <id>compile</id>
-            <phase>compile</phase>
-            <goals>
-              <goal>compile</goal>
-            </goals>
-          </execution>
-          <execution>
-            <id>testCompile</id>
-            <phase>test-compile</phase>
-            <goals>
-              <goal>testCompile</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/kotlin-codegen/runtime/src/main/java/com/squareup/moshi/MoshiSerializable.kt b/kotlin-codegen/runtime/src/main/java/com/squareup/moshi/MoshiSerializable.kt
deleted file mode 100644
index d6857659..00000000
--- a/kotlin-codegen/runtime/src/main/java/com/squareup/moshi/MoshiSerializable.kt
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi
-
-import java.lang.reflect.InvocationTargetException
-import java.lang.reflect.ParameterizedType
-import java.lang.reflect.Type
-import kotlin.annotation.AnnotationRetention.RUNTIME
-import kotlin.annotation.AnnotationTarget.CLASS
-
-@Retention(RUNTIME)
-@Target(CLASS)
-annotation class MoshiSerializable
-
-class MoshiSerializableFactory : JsonAdapter.Factory {
-
-  override fun create(type: Type, annotations: Set<Annotation>, moshi: Moshi): JsonAdapter<*>? {
-
-    val rawType = Types.getRawType(type)
-    if (!rawType.isAnnotationPresent(MoshiSerializable::class.java)) {
-      return null
-    }
-
-    val clsName = rawType.name.replace("$", "_")
-    val constructor = try {
-      @Suppress("UNCHECKED_CAST")
-      val bindingClass = rawType.classLoader
-          .loadClass(clsName + "JsonAdapter") as Class<out JsonAdapter<*>>
-      if (type is ParameterizedType) {
-        // This is generic, use the two param moshi + type constructor
-        bindingClass.getDeclaredConstructor(Moshi::class.java, Array<Type>::class.java)
-      } else {
-        // The standard single param moshi constructor
-        bindingClass.getDeclaredConstructor(Moshi::class.java)
-      }
-    } catch (e: ClassNotFoundException) {
-      throw RuntimeException("Unable to find generated Moshi adapter class for $clsName", e)
-    } catch (e: NoSuchMethodException) {
-      throw RuntimeException("Unable to find generated Moshi adapter constructor for $clsName", e)
-    }
-
-    try {
-      return when {
-        constructor.parameterTypes.size == 1 -> constructor.newInstance(moshi)
-        type is ParameterizedType -> constructor.newInstance(moshi, type.actualTypeArguments)
-        else -> throw IllegalStateException("Unable to handle type $type")
-      }
-    } catch (e: IllegalAccessException) {
-      throw RuntimeException("Unable to invoke $constructor", e)
-    } catch (e: InstantiationException) {
-      throw RuntimeException("Unable to invoke $constructor", e)
-    } catch (e: InvocationTargetException) {
-      val cause = e.cause
-      if (cause is RuntimeException) {
-        throw cause
-      }
-      if (cause is Error) {
-        throw cause
-      }
-      throw RuntimeException(
-          "Could not create generated JsonAdapter instance for type $rawType", cause)
-    }
-  }
-}
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonClass.java b/moshi/src/main/java/com/squareup/moshi/JsonClass.java
new file mode 100644
index 00000000..059f41bb
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/JsonClass.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Customizes how a type is encoded as JSON.
+ *
+ * <p>This annotation is currently only permitted on declarations of data classes in Kotlin.
+ */
+@Retention(RUNTIME)
+@Documented
+public @interface JsonClass {
+  boolean generateAdapter();
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index 5a7eb461..5b1be373 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -18,6 +18,9 @@ package com.squareup.moshi;
 import com.squareup.moshi.internal.Util;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.Arrays;
 import java.util.Collection;
@@ -53,6 +56,12 @@ final class StandardJsonAdapters {
       if (type == Object.class) return new ObjectJsonAdapter(moshi).nullSafe();
 
       Class<?> rawType = Types.getRawType(type);
+
+      JsonClass jsonClass = rawType.getAnnotation(JsonClass.class);
+      if (jsonClass != null && jsonClass.generateAdapter()) {
+        return generatedAdapter(moshi, type, rawType);
+      }
+
       if (rawType.isEnum()) {
         //noinspection unchecked
         return new EnumJsonAdapter<>((Class<? extends Enum>) rawType).nullSafe();
@@ -215,6 +224,45 @@ final class StandardJsonAdapters {
     }
   };
 
+  /**
+   * Loads the generated JsonAdapter for classes annotated {@link JsonClass}. This works because it
+   * uses the same naming conventions as {@code JsonClassCodeGenProcessor}.
+   */
+  static JsonAdapter<?> generatedAdapter(Moshi moshi, Type type, Class<?> rawType) {
+    String adapterClassName = rawType.getName().replace("$", "_") + "JsonAdapter";
+    try {
+      @SuppressWarnings("unchecked") // We generate types to match.
+      Class<? extends JsonAdapter<?>> adapterClass = (Class<? extends JsonAdapter<?>>)
+          Class.forName(adapterClassName, true, rawType.getClassLoader());
+      if (type instanceof ParameterizedType) {
+        Constructor<? extends JsonAdapter<?>> constructor
+            = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);
+        constructor.setAccessible(true);
+        return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments());
+      } else {
+        Constructor<? extends JsonAdapter<?>> constructor
+            = adapterClass.getDeclaredConstructor(Moshi.class);
+        constructor.setAccessible(true);
+        return constructor.newInstance(moshi);
+      }
+    } catch (ClassNotFoundException e) {
+      throw new RuntimeException(
+          "Failed to find the generated JsonAdapter class for " + rawType, e);
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException(
+          "Failed to find the generated JsonAdapter constructor for " + rawType, e);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException(
+          "Failed to access the generated JsonAdapter for " + rawType, e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(
+          "Failed to construct the generated JsonAdapter for " + rawType, e);
+    } catch (InstantiationException e) {
+      throw new RuntimeException(
+          "Failed to instantiate the generated JsonAdapter for " + rawType, e);
+    }
+  }
+
   static final class EnumJsonAdapter<T extends Enum<T>> extends JsonAdapter<T> {
     private final Class<T> enumType;
     private final String[] nameStrings;
diff --git a/pom.xml b/pom.xml
index 30b64163..d1d2a103 100644
--- a/pom.xml
+++ b/pom.xml
@@ -24,7 +24,6 @@
     <module>kotlin</module>
     <module>kotlin-codegen/compiler</module>
     <module>kotlin-codegen/integration-test</module>
-    <module>kotlin-codegen/runtime</module>
   </modules>
 
   <properties>
