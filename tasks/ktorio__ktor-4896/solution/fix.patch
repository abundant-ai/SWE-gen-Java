diff --git a/ktor-client/ktor-client-core/api/ktor-client-core.api b/ktor-client/ktor-client-core/api/ktor-client-core.api
index d9db64c0a..d56510221 100644
--- a/ktor-client/ktor-client-core/api/ktor-client-core.api
+++ b/ktor-client/ktor-client-core/api/ktor-client-core.api
@@ -647,6 +647,8 @@ public abstract interface class io/ktor/client/plugins/cache/storage/CacheStorag
 	public static final field Companion Lio/ktor/client/plugins/cache/storage/CacheStorage$Companion;
 	public abstract fun find (Lio/ktor/http/Url;Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
 	public abstract fun findAll (Lio/ktor/http/Url;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
+	public abstract fun remove (Lio/ktor/http/Url;Ljava/util/Map;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
+	public abstract fun removeAll (Lio/ktor/http/Url;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
 	public abstract fun store (Lio/ktor/http/Url;Lio/ktor/client/plugins/cache/storage/CachedResponseData;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
 }
 
diff --git a/ktor-client/ktor-client-core/api/ktor-client-core.klib.api b/ktor-client/ktor-client-core/api/ktor-client-core.klib.api
index 4a4a48773..dbf0ad6f3 100644
--- a/ktor-client/ktor-client-core/api/ktor-client-core.klib.api
+++ b/ktor-client/ktor-client-core/api/ktor-client-core.klib.api
@@ -62,6 +62,8 @@ abstract interface io.ktor.client.engine/HttpClientEngine : io.ktor.utils.io.cor
 abstract interface io.ktor.client.plugins.cache.storage/CacheStorage { // io.ktor.client.plugins.cache.storage/CacheStorage|null[0]
     abstract suspend fun find(io.ktor.http/Url, kotlin.collections/Map<kotlin/String, kotlin/String>): io.ktor.client.plugins.cache.storage/CachedResponseData? // io.ktor.client.plugins.cache.storage/CacheStorage.find|find(io.ktor.http.Url;kotlin.collections.Map<kotlin.String,kotlin.String>){}[0]
     abstract suspend fun findAll(io.ktor.http/Url): kotlin.collections/Set<io.ktor.client.plugins.cache.storage/CachedResponseData> // io.ktor.client.plugins.cache.storage/CacheStorage.findAll|findAll(io.ktor.http.Url){}[0]
+    abstract suspend fun remove(io.ktor.http/Url, kotlin.collections/Map<kotlin/String, kotlin/String>) // io.ktor.client.plugins.cache.storage/CacheStorage.remove|remove(io.ktor.http.Url;kotlin.collections.Map<kotlin.String,kotlin.String>){}[0]
+    abstract suspend fun removeAll(io.ktor.http/Url) // io.ktor.client.plugins.cache.storage/CacheStorage.removeAll|removeAll(io.ktor.http.Url){}[0]
     abstract suspend fun store(io.ktor.http/Url, io.ktor.client.plugins.cache.storage/CachedResponseData) // io.ktor.client.plugins.cache.storage/CacheStorage.store|store(io.ktor.http.Url;io.ktor.client.plugins.cache.storage.CachedResponseData){}[0]
 
     final object Companion { // io.ktor.client.plugins.cache.storage/CacheStorage.Companion|null[0]
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/DisabledCacheStorage.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/DisabledCacheStorage.kt
index 50b96be7f..fc048cf2c 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/DisabledCacheStorage.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/DisabledCacheStorage.kt
@@ -20,4 +20,6 @@ internal object DisabledStorage : CacheStorage {
     override suspend fun store(url: Url, data: CachedResponseData) {}
     override suspend fun find(url: Url, varyKeys: Map<String, String>): CachedResponseData? = null
     override suspend fun findAll(url: Url): Set<CachedResponseData> = emptySet()
+    override suspend fun remove(url: Url, varyKeys: Map<String, String>) {}
+    override suspend fun removeAll(url: Url) {}
 }
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/HttpCacheStorage.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/HttpCacheStorage.kt
index a5ba93990..162d3e0ea 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/HttpCacheStorage.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/HttpCacheStorage.kt
@@ -12,11 +12,9 @@ import io.ktor.client.plugins.cache.*
 import io.ktor.client.request.*
 import io.ktor.client.statement.*
 import io.ktor.http.*
-import io.ktor.util.*
 import io.ktor.util.date.*
 import io.ktor.utils.io.*
 import io.ktor.utils.io.core.*
-import kotlinx.coroutines.*
 import kotlin.coroutines.*
 
 /**
@@ -101,6 +99,20 @@ public interface CacheStorage {
      */
     public suspend fun findAll(url: Url): Set<CachedResponseData>
 
+    /**
+     * Remove from cache storage the entry matching [url] with additional [varyKeys].
+     *
+     * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.client.plugins.cache.storage.CacheStorage.remove)
+     */
+    public suspend fun remove(url: Url, varyKeys: Map<String, String>)
+
+    /**
+     * Remove all matched [HttpCacheEntry] for [url].
+     *
+     * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.client.plugins.cache.storage.CacheStorage.removeAll)
+     */
+    public suspend fun removeAll(url: Url)
+
     public companion object {
         /**
          * Default unlimited cache storage.
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/UnlimitedCacheStorage.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/UnlimitedCacheStorage.kt
index 917c0d149..93a70ff96 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/UnlimitedCacheStorage.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/cache/storage/UnlimitedCacheStorage.kt
@@ -50,4 +50,14 @@ internal class UnlimitedStorage : CacheStorage {
     }
 
     override suspend fun findAll(url: Url): Set<CachedResponseData> = store[url] ?: emptySet()
+
+    override suspend fun remove(url: Url, varyKeys: Map<String, String>) {
+        store[url]?.removeAll { entry ->
+            varyKeys.all { (key, value) -> entry.varyKeys[key] == value } && varyKeys.size == entry.varyKeys.size
+        }
+    }
+
+    override suspend fun removeAll(url: Url) {
+        store.remove(url)
+    }
 }
diff --git a/ktor-client/ktor-client-core/jvm/src/io/ktor/client/plugins/cache/storage/FileCacheStorage.kt b/ktor-client/ktor-client-core/jvm/src/io/ktor/client/plugins/cache/storage/FileCacheStorage.kt
index eaee95be8..db3c00d22 100644
--- a/ktor-client/ktor-client-core/jvm/src/io/ktor/client/plugins/cache/storage/FileCacheStorage.kt
+++ b/ktor-client/ktor-client-core/jvm/src/io/ktor/client/plugins/cache/storage/FileCacheStorage.kt
@@ -9,6 +9,7 @@ import io.ktor.http.*
 import io.ktor.util.*
 import io.ktor.util.collections.*
 import io.ktor.util.date.*
+import io.ktor.util.logging.*
 import io.ktor.utils.io.*
 import io.ktor.utils.io.jvm.javaio.*
 import kotlinx.coroutines.*
@@ -57,6 +58,16 @@ internal class CachingCacheStorage(
         }
         return store.getValue(url)
     }
+
+    override suspend fun remove(url: Url, varyKeys: Map<String, String>) {
+        delegate.remove(url, varyKeys)
+        store[url] = delegate.findAll(url)
+    }
+
+    override suspend fun removeAll(url: Url) {
+        delegate.removeAll(url)
+        store.remove(url)
+    }
 }
 
 private class FileCacheStorage(
@@ -72,8 +83,9 @@ private class FileCacheStorage(
 
     override suspend fun store(url: Url, data: CachedResponseData): Unit = withContext(dispatcher) {
         val urlHex = key(url)
-        val caches = readCache(urlHex).filterNot { it.varyKeys == data.varyKeys } + data
-        writeCache(urlHex, caches)
+        updateCache(urlHex) { caches ->
+            caches.filterNot { it.varyKeys == data.varyKeys } + data
+        }
     }
 
     override suspend fun findAll(url: Url): Set<CachedResponseData> {
@@ -87,50 +99,86 @@ private class FileCacheStorage(
         }
     }
 
+    override suspend fun remove(url: Url, varyKeys: Map<String, String>) {
+        val urlHex = key(url)
+        updateCache(urlHex) { caches ->
+            caches.filterNot { it.varyKeys == varyKeys }
+        }
+    }
+
+    override suspend fun removeAll(url: Url) {
+        val urlHex = key(url)
+        deleteCache(urlHex)
+    }
+
     private fun key(url: Url) = hex(MessageDigest.getInstance("SHA-256").digest(url.toString().encodeToByteArray()))
 
-    private suspend fun writeCache(urlHex: String, caches: List<CachedResponseData>) = coroutineScope {
+    private suspend fun readCache(urlHex: String): Set<CachedResponseData> {
+        val mutex = mutexes.computeIfAbsent(urlHex) { Mutex() }
+        return mutex.withLock { readCacheUnsafe(urlHex) }
+    }
+
+    private suspend inline fun updateCache(
+        urlHex: String,
+        transform: (Set<CachedResponseData>) -> List<CachedResponseData>
+    ) {
         val mutex = mutexes.computeIfAbsent(urlHex) { Mutex() }
         mutex.withLock {
-            val channel = ByteChannel()
-            try {
-                File(directory, urlHex).outputStream().buffered().use { output ->
-                    launch {
-                        channel.writeInt(caches.size)
-                        for (cache in caches) {
-                            writeCache(channel, cache)
-                        }
-                        channel.close()
-                    }
-                    channel.copyTo(output)
-                }
-            } catch (cause: Exception) {
-                LOGGER.trace("Exception during saving a cache to a file: ${cause.stackTraceToString()}")
-            }
+            val caches = readCacheUnsafe(urlHex)
+            writeCacheUnsafe(urlHex, transform(caches))
         }
     }
 
-    private suspend fun readCache(urlHex: String): Set<CachedResponseData> {
+    private suspend fun deleteCache(urlHex: String) {
         val mutex = mutexes.computeIfAbsent(urlHex) { Mutex() }
         mutex.withLock {
             val file = File(directory, urlHex)
-            if (!file.exists()) return emptySet()
+            if (!file.exists()) return@withLock
 
             try {
-                file.inputStream().buffered().use {
-                    val channel = it.toByteReadChannel()
-                    val requestsCount = channel.readInt()
-                    val caches = mutableSetOf<CachedResponseData>()
-                    for (i in 0 until requestsCount) {
-                        caches.add(readCache(channel))
+                file.delete()
+            } catch (cause: Exception) {
+                LOGGER.trace { "Exception during cache deletion in a file: ${cause.stackTraceToString()}" }
+            }
+        }
+    }
+
+    private suspend fun writeCacheUnsafe(urlHex: String, caches: List<CachedResponseData>) = coroutineScope {
+        val channel = ByteChannel()
+        try {
+            File(directory, urlHex).outputStream().buffered().use { output ->
+                launch {
+                    channel.writeInt(caches.size)
+                    for (cache in caches) {
+                        writeCache(channel, cache)
                     }
-                    channel.discard()
-                    return caches
+                    channel.close()
                 }
-            } catch (cause: Exception) {
-                LOGGER.trace("Exception during cache lookup in a file: ${cause.stackTraceToString()}")
-                return emptySet()
+                channel.copyTo(output)
+            }
+        } catch (cause: Exception) {
+            LOGGER.trace { "Exception during saving a cache to a file: ${cause.stackTraceToString()}" }
+        }
+    }
+
+    private suspend fun readCacheUnsafe(urlHex: String): Set<CachedResponseData> {
+        val file = File(directory, urlHex)
+        if (!file.exists()) return emptySet()
+
+        try {
+            file.inputStream().buffered().use {
+                val channel = it.toByteReadChannel()
+                val requestsCount = channel.readInt()
+                val caches = mutableSetOf<CachedResponseData>()
+                for (i in 0 until requestsCount) {
+                    caches.add(readCache(channel))
+                }
+                channel.discard()
+                return caches
             }
+        } catch (cause: Exception) {
+            LOGGER.trace { "Exception during cache lookup in a file: ${cause.stackTraceToString()}" }
+            return emptySet()
         }
     }
 
