diff --git a/release-notes/VERSION b/release-notes/VERSION
index 308b90f14..8f783bbf2 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -18,8 +18,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #1196: Add opt-in error collection for deserialization
  (requested by @odrotbohm)
  (contributed by @sri-adarsh-kumar)
-#1419: `JsonFormat.Shape.POJO`  does not work for `Map.Entry` via property annotation
- (fix by @cowtowncoder, w/ Claude code)
 #1497: Allow skipping `@JsonUnwrapped` values if no properties matched,
   `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled
  (requested by Victor N)
diff --git a/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java
index ca0d54761..257ffaeed 100644
--- a/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java
@@ -1403,10 +1403,17 @@ factory.toString()));
             return createCollectionDeserializer(ctxt, ct, beanDescRef);
         }
         if (rawType == CLASS_MAP_ENTRY) {
-            // [databind#1419]: Check if we should deserialize as POJO instead
-            JsonFormat.Value format = beanDescRef.findExpectedFormat(Map.Entry.class);
-            return MapEntryDeserializer.construct(ctxt, type,
-                    (format.getShape() == JsonFormat.Shape.POJO));
+            // 28-Apr-2015, tatu: TypeFactory does it all for us already so
+            JavaType kt = type.containedTypeOrUnknown(0);
+            JavaType vt = type.containedTypeOrUnknown(1);
+            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();
+            if (vts == null) {
+                vts = ctxt.findTypeDeserializer(vt);
+            }
+            @SuppressWarnings("unchecked")
+            ValueDeserializer<Object> valueDeser = (ValueDeserializer<Object>) vt.getValueHandler();
+            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();
+            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);
         }
         String clsName = rawType.getName();
         if (rawType.isPrimitive() || clsName.startsWith("java.")) {
diff --git a/src/main/java/tools/jackson/databind/deser/jdk/MapEntryDeserializer.java b/src/main/java/tools/jackson/databind/deser/jdk/MapEntryDeserializer.java
index 0dff28707..a05df30be 100644
--- a/src/main/java/tools/jackson/databind/deser/jdk/MapEntryDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/jdk/MapEntryDeserializer.java
@@ -1,19 +1,14 @@
 package tools.jackson.databind.deser.jdk;
 
-import java.lang.reflect.InvocationTargetException;
 import java.util.*;
 
-import com.fasterxml.jackson.annotation.JsonFormat;
-
 import tools.jackson.core.*;
 import tools.jackson.databind.*;
 import tools.jackson.databind.annotation.JacksonStdImpl;
 import tools.jackson.databind.deser.*;
 import tools.jackson.databind.deser.std.ContainerDeserializerBase;
-import tools.jackson.databind.deser.std.StdDeserializer;
 import tools.jackson.databind.jsontype.TypeDeserializer;
 import tools.jackson.databind.type.LogicalType;
-import tools.jackson.databind.util.ClassUtil;
 
 /**
  * Basic serializer that can take JSON "Object" structure and
@@ -28,6 +23,8 @@ import tools.jackson.databind.util.ClassUtil;
 public class MapEntryDeserializer
     extends ContainerDeserializerBase<Map.Entry<Object,Object>>
 {
+    // // Configuration: typing, deserializers
+
     /**
      * Key deserializer to use; either passed via constructor
      * (when indicated by annotations), or resolved when
@@ -65,6 +62,18 @@ public class MapEntryDeserializer
         _valueTypeDeserializer = valueTypeDeser;
     }
 
+    /**
+     * Copy-constructor that can be used by sub-classes to allow
+     * copy-on-write styling copying of settings of an existing instance.
+     */
+    protected MapEntryDeserializer(MapEntryDeserializer src)
+    {
+        super(src);
+        _keyDeserializer = src._keyDeserializer;
+        _valueDeserializer = src._valueDeserializer;
+        _valueTypeDeserializer = src._valueTypeDeserializer;
+    }
+
     protected MapEntryDeserializer(MapEntryDeserializer src,
             KeyDeserializer keyDeser, ValueDeserializer<Object> valueDeser,
             TypeDeserializer valueTypeDeser)
@@ -75,67 +84,15 @@ public class MapEntryDeserializer
         _valueTypeDeserializer = valueTypeDeser;
     }
 
-    /**
-     * Factory method for constructing initial (non-contextual) instances.
-     *
-     * @since 3.1
-     */
-    @SuppressWarnings("unchecked")
-    public static ValueDeserializer<Object> construct(DeserializationContext ctxt,
-            JavaType entryType,
-            boolean pojoWrappedFormat)
-    {
-        ValueDeserializer<?> deser = pojoWrappedFormat
-                ? constructAsPOJO(ctxt, entryType)
-                : constructDefault(ctxt, entryType);
-        return (ValueDeserializer<Object>) deser;
-    }
-
-    /**
-     * Factory method for initial instance using the default ("natural") format,
-     * in which an Object with a single entry is expected.
-     *
-     * @since 3.1
-     */
-    protected static MapEntryDeserializer constructDefault(DeserializationContext ctxt,
-            JavaType entryType)
-    {
-        final JavaType keyType = entryType.containedTypeOrUnknown(0);
-        final JavaType valueType = entryType.containedTypeOrUnknown(1);
-        // 28-Apr-2015, tatu: TypeFactory does it all for us already so
-        // 04-Jan-2025, tatu: Or does is? None of tests fails if following was
-        //    removed.
-        TypeDeserializer vts = (TypeDeserializer) valueType.getTypeHandler();
-        if (vts == null) {
-            vts = ctxt.findTypeDeserializer(valueType);
-        }
-        @SuppressWarnings("unchecked")
-        ValueDeserializer<Object> valueDeser = (ValueDeserializer<Object>) valueType.getValueHandler();
-        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();
-        return new MapEntryDeserializer(entryType, keyDes, valueDeser, vts);
-    }
-
-    /**
-     * Factory method for initial instance using the alternative ("as POJO" or
-     * "POJO-wrapped") format, in which an Object with 2 separate entries -- "key"
-     * and "value" -- are expected.
-     *
-     * @since 3.1
-     */
-    protected static POJOWrappedDeserializer constructAsPOJO(DeserializationContext ctxt,
-            JavaType entryType)
-    {
-        return new POJOWrappedDeserializer(entryType);
-    }
-
     /**
      * Fluent factory method used to create a copy with slightly
-     * different settings.
+     * different settings. When sub-classing, MUST be overridden.
      */
     @SuppressWarnings("unchecked")
     protected MapEntryDeserializer withResolved(KeyDeserializer keyDeser,
             TypeDeserializer valueTypeDeser, ValueDeserializer<?> valueDeser)
     {
+
         if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)
                 && (_valueTypeDeserializer == valueTypeDeser)) {
             return this;
@@ -146,12 +103,13 @@ public class MapEntryDeserializer
 
     @Override // since 2.12
     public LogicalType logicalType() {
+        // Slightly tricky, could consider POJO too?
         return LogicalType.Map;
     }
 
     /*
     /**********************************************************************
-    /* Validation, post-processing
+    /* Validation, post-processing (ResolvableDeserializer)
     /**********************************************************************
      */
 
@@ -162,19 +120,6 @@ public class MapEntryDeserializer
     @Override
     public ValueDeserializer<?> createContextual(DeserializationContext ctxt,
             BeanProperty property)
-    {
-        // [databind#1419]: Check if property has @JsonFormat(shape=POJO)
-        if (Boolean.TRUE.equals(_shouldDeserializeAsPOJO(ctxt, property))) {
-            return constructAsPOJO(ctxt, _containerType)
-                    ._createContextual2(ctxt, property);
-        }
-        return _createContextual2(ctxt, property);
-    }
-
-    // Method called from "createContextual()"s after determining if
-    // "shape-shifting" needed (and has been performed)
-    protected ValueDeserializer<?> _createContextual2(DeserializationContext ctxt,
-            BeanProperty property)
     {
         KeyDeserializer kd = _keyDeserializer;
         if (kd == null) {
@@ -199,23 +144,6 @@ public class MapEntryDeserializer
         return withResolved(kd, vtd, vd);
     }
 
-    protected static Boolean _shouldDeserializeAsPOJO(DeserializationContext ctxt,
-            BeanProperty property)
-    {
-        if (property != null) {
-            JsonFormat.Value format = property.findPropertyFormat(ctxt.getConfig(), Map.Entry.class);
-
-            switch (format.getShape()) {
-            case NATURAL:
-                return false;
-            case POJO:
-                return true;
-            default: // fall through
-            }
-        }
-        return null;
-    }
-
     /*
     /**********************************************************************
     /* ContainerDeserializerBase API
@@ -260,7 +188,7 @@ public class MapEntryDeserializer
         if (t != JsonToken.PROPERTY_NAME) {
             if (t == JsonToken.END_OBJECT) {
                 return ctxt.reportInputMismatch(this,
-                        "Cannot deserialize a `Map.Entry` out of empty Object");
+                        "Cannot deserialize a Map.Entry out of empty JSON Object");
             }
             return (Map.Entry<Object,Object>) ctxt.handleUnexpectedToken(getValueType(ctxt), p);
         }
@@ -319,230 +247,4 @@ public class MapEntryDeserializer
         // In future could check current token... for now this should be enough:
         return typeDeserializer.deserializeTypedFromObject(p, ctxt);
     }
-
-    /*
-    /**********************************************************************
-    /* Alternate handlers
-    /**********************************************************************
-     */
-
-    /**
-     * @since 3.1
-     */
-    protected static class POJOWrappedDeserializer
-        extends StdDeserializer<Map.Entry<Object, Object>>
-    {
-        protected final ValueDeserializer<Object> _keyDeserializer;
-        protected final TypeDeserializer _keyTypeDeserializer;
-
-        protected final ValueDeserializer<Object> _valueDeserializer;
-        protected final TypeDeserializer _valueTypeDeserializer;
-
-        /*
-        /**********************************************************************
-        /* Life-cycle
-        /**********************************************************************
-         */
-
-        public POJOWrappedDeserializer(JavaType type)
-        {
-            super(type);
-            _keyDeserializer = null;
-            _keyTypeDeserializer = null;
-            _valueDeserializer = null;
-            _valueTypeDeserializer = null;
-        }
-    
-        protected POJOWrappedDeserializer(POJOWrappedDeserializer src,
-                ValueDeserializer<Object> keyDeser, TypeDeserializer valueTypeDeser,
-                ValueDeserializer<Object> valueDeser, TypeDeserializer keyTypeDeser)
-        {
-            super(src);
-            _keyDeserializer = keyDeser;
-            _keyTypeDeserializer = keyTypeDeser;
-            _valueDeserializer = valueDeser;
-            _valueTypeDeserializer = valueTypeDeser;
-        }
-
-        /**
-         * Fluent factory method used to create a copy with slightly
-         * different settings.
-         */
-        @SuppressWarnings("unchecked")
-        protected POJOWrappedDeserializer withResolved(ValueDeserializer<?> keyDeser,
-                TypeDeserializer keyTypeDeser,
-                ValueDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)
-        {
-            if ((_keyDeserializer == keyDeser)
-                    && (_keyTypeDeserializer == keyTypeDeser)
-                    && (_valueDeserializer == valueDeser)
-                    && (_valueTypeDeserializer == valueTypeDeser)) {
-                return this;
-            }
-            return new POJOWrappedDeserializer(this,
-                    (ValueDeserializer<Object>) keyDeser, keyTypeDeser,
-                    (ValueDeserializer<Object>) valueDeser, valueTypeDeser);
-        }
-
-        @Override
-        public LogicalType logicalType() {
-            return LogicalType.POJO;
-        }
-
-        /*
-        /**********************************************************************
-        /* Validation, post-processing
-        /**********************************************************************
-         */
-
-        /**
-         * Method called to finalize setup of this deserializer,
-         * when it is known for which property deserializer is needed for.
-         */
-        @Override
-        public ValueDeserializer<?> createContextual(DeserializationContext ctxt,
-                BeanProperty property)
-        {
-            // May override back to standard too:
-            if (Boolean.FALSE.equals(_shouldDeserializeAsPOJO(ctxt, property))) {
-                return constructAsPOJO(ctxt, _valueType)
-                        ._createContextual2(ctxt, property);
-            }
-            return _createContextual2(ctxt, property);
-        }
-
-        // Method called from "createContextual()"s after determining if
-        // "shape-shifting" needed (and has been performed)
-        protected ValueDeserializer<?> _createContextual2(DeserializationContext ctxt,
-                BeanProperty property)
-        {
-            ValueDeserializer<?> kd = _keyDeserializer;
-            kd = findConvertingContentDeserializer(ctxt, property, kd);
-            JavaType keyType = _valueType.containedTypeOrUnknown(0);
-            if (kd == null) {
-                kd = ctxt.findContextualValueDeserializer(keyType, property);
-            } else { // if directly assigned, probably not yet contextual, so:
-                kd = ctxt.handleSecondaryContextualization(kd, property, keyType);
-            }
-            TypeDeserializer ktd = _keyTypeDeserializer;
-            if (ktd != null) {
-                ktd = ktd.forProperty(property);
-            }
-
-            ValueDeserializer<?> vd = _valueDeserializer;
-            vd = findConvertingContentDeserializer(ctxt, property, vd);
-            JavaType valueType = _valueType.containedType(1);
-            if (vd == null) {
-                vd = ctxt.findContextualValueDeserializer(valueType, property);
-            } else { // if directly assigned, probably not yet contextual, so:
-                vd = ctxt.handleSecondaryContextualization(vd, property, valueType);
-            }
-            TypeDeserializer vtd = _valueTypeDeserializer;
-            if (vtd != null) {
-                vtd = vtd.forProperty(property);
-            }
-            return withResolved(kd, ktd, vd, vtd);
-        }
-
-        /*
-        /**********************************************************************
-        /* ValueDeserializer API
-        /**********************************************************************
-         */
-
-        @SuppressWarnings("unchecked")
-        @Override
-        public Map.Entry<Object,Object> deserialize(JsonParser p, DeserializationContext ctxt)
-            throws JacksonException
-        {
-            JsonToken t = p.currentToken();
-            if (t == JsonToken.START_OBJECT) {
-                t = p.nextToken();
-            } else if (t != JsonToken.PROPERTY_NAME && t != JsonToken.END_OBJECT) {
-                if (t == JsonToken.START_ARRAY) {
-                    return _deserializeFromArray(p, ctxt);
-                }
-                return (Map.Entry<Object,Object>) ctxt.handleUnexpectedToken(_valueType, p);
-            }
-
-            Object key = null;
-            Object value = null;
-
-            // Read properties "key" and "value"
-            while (t == JsonToken.PROPERTY_NAME) {
-                String propName = p.currentName();
-                t = p.nextToken(); // move to value
-
-                if ("key".equals(propName)) {
-                    try {
-                        if (t == JsonToken.VALUE_NULL) {
-                            key = _keyDeserializer.getNullValue(ctxt);
-                        } else if (_keyTypeDeserializer != null) {
-                            key = _keyDeserializer.deserializeWithType(p, ctxt, _keyTypeDeserializer);
-                        } else {
-                            key = _keyDeserializer.deserialize(p, ctxt);
-                        }
-                    } catch (Exception e) {
-                        wrapAndThrow(ctxt, e, Map.Entry.class, propName);
-                    }
-                } else if ("value".equals(propName)) {
-                    try {
-                        if (t == JsonToken.VALUE_NULL) {
-                            value = _valueDeserializer.getNullValue(ctxt);
-                        } else if (_valueTypeDeserializer != null) {
-                            value = _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);
-                        } else {
-                            value = _valueDeserializer.deserialize(p, ctxt);
-                        }
-                    } catch (Exception e) {
-                        wrapAndThrow(ctxt, e, Map.Entry.class, propName);
-                    }
-                } else {
-                    // Unknown property: check if we should fail or skip
-                    handleUnknownProperty(p, ctxt, _valueType, propName);
-                }
-
-                t = p.nextToken(); // move to next property or END_OBJECT
-            }
-
-            if (t != JsonToken.END_OBJECT) {
-                ctxt.reportInputMismatch(this,
-                        "Problem deserializing `Map.Entry`; unexpected content after Object value: "
-                                +JsonToken.valueDescFor(t));
-            }
-
-            return new AbstractMap.SimpleEntry<>(key, value);
-        }
-        
-        @Override
-        public Map.Entry<Object,Object> deserialize(JsonParser p, DeserializationContext ctxt,
-                Map.Entry<Object,Object> result) throws JacksonException
-        {
-            throw new IllegalStateException("Cannot update `Map.Entry` values");
-        }
-
-        @Override
-        public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,
-                TypeDeserializer typeDeserializer)
-            throws JacksonException
-        {
-            // In future could check current token... for now this should be enough:
-            return typeDeserializer.deserializeTypedFromObject(p, ctxt);
-        }
-
-        // Copied from `ContainerDeserializerBase`
-        protected <BOGUS> BOGUS wrapAndThrow(DeserializationContext ctxt,
-                Throwable t, Object ref, String key) throws JacksonException
-        {
-            while (t instanceof InvocationTargetException && t.getCause() != null) {
-                t = t.getCause();
-            }
-            ClassUtil.throwIfError(t);
-            if (!ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS)) {
-                ClassUtil.throwIfRTE(t);
-            }
-            throw DatabindException.wrapWithPath(ctxt, t,
-                        new JacksonException.Reference(ref, ClassUtil.nonNull(key, "N/A")));
-        }
-    }
 }
diff --git a/src/test/java/tools/jackson/databind/format/MapEntryFormat1419Test.java b/src/test/java/tools/jackson/databind/format/MapEntryFormat1419Test.java
deleted file mode 100644
index 3ad6ef5e2..000000000
--- a/src/test/java/tools/jackson/databind/format/MapEntryFormat1419Test.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package tools.jackson.databind.format;
-
-import java.util.*;
-
-import org.junit.jupiter.api.Test;
-
-import com.fasterxml.jackson.annotation.JsonFormat;
-
-import tools.jackson.databind.*;
-import tools.jackson.databind.exc.UnrecognizedPropertyException;
-import tools.jackson.databind.testutil.DatabindTestUtil;
-
-import static org.junit.jupiter.api.Assertions.assertArrayEquals;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.fail;
-
-// for [databind#1419]
-public class MapEntryFormat1419Test extends DatabindTestUtil
-{
-    static class BeanWithMapEntryAsPOJO {
-        @JsonFormat(shape = JsonFormat.Shape.POJO)
-        public Map.Entry<String, String> entry;
-
-        protected BeanWithMapEntryAsPOJO() { }
-
-        protected BeanWithMapEntryAsPOJO(String key, String value) {
-            Map<String, String> map = new HashMap<>();
-            map.put(key, value);
-            entry = map.entrySet().iterator().next();
-        }
-
-        @Override
-        public String toString() {
-            return "[POJO: entry = "+entry+"]";
-        }
-    }
-
-    static class BeanWithComplexMapEntryAsPOJO {
-        @JsonFormat(shape = JsonFormat.Shape.POJO)
-        public Map.Entry<List<Integer>, String[]> entry;
-
-        protected BeanWithComplexMapEntryAsPOJO() { }
-
-        protected BeanWithComplexMapEntryAsPOJO(int key, String value) {
-            Map<List<Integer>, String[]> map = new HashMap<>();
-            map.put(Arrays.asList(42), new String[] { value });
-            entry = map.entrySet().iterator().next();
-        }
-
-        @Override
-        public String toString() {
-            return "[POJO: entry = "+entry+"]";
-        }
-    }
-
-    private final ObjectMapper MAPPER = jsonMapperBuilder()
-            .enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
-            .build();
-
-    @Test
-    void wrappedAsObjectRoundtrip() throws Exception
-    {
-        BeanWithMapEntryAsPOJO input = new BeanWithMapEntryAsPOJO("foo", "bar");
-        String json = MAPPER.writeValueAsString(input);
-        assertEquals(a2q("{'entry':{'key':'foo','value':'bar'}}"), json);
-        BeanWithMapEntryAsPOJO result = MAPPER.readValue(json, BeanWithMapEntryAsPOJO.class);
-        assertEquals("foo", result.entry.getKey());
-        assertEquals("bar", result.entry.getValue());
-    }
-
-    @Test
-    void wrappedAsComplexRoundtrip() throws Exception
-    {
-        BeanWithComplexMapEntryAsPOJO input = new BeanWithComplexMapEntryAsPOJO(42, "answer");
-        String json = MAPPER.writeValueAsString(input);
-        assertEquals(a2q("{'entry':{'key':[42],'value':['answer']}}"), json);
-        BeanWithComplexMapEntryAsPOJO result = MAPPER.readValue(json,
-                BeanWithComplexMapEntryAsPOJO.class);
-        assertEquals(Arrays.asList(42), result.entry.getKey());
-        assertArrayEquals(new String[] { "answer" }, result.entry.getValue());
-    }
-
-    @Test
-    void deserFailWithStructureMismatch() throws Exception
-    {
-        try {
-            BeanWithMapEntryAsPOJO result = MAPPER.readValue(a2q("{'entry':{'notKey': 'value'}}"),
-                    BeanWithMapEntryAsPOJO.class);
-            fail("Should not pass, got: "+result);
-        } catch (UnrecognizedPropertyException e) {
-            assertEquals("notKey", e.getPropertyName());
-        }
-    }
-}
diff --git a/src/test/java/tools/jackson/databind/tofix/MapEntryFormat1419Test.java b/src/test/java/tools/jackson/databind/tofix/MapEntryFormat1419Test.java
new file mode 100644
index 000000000..d1efd8086
--- /dev/null
+++ b/src/test/java/tools/jackson/databind/tofix/MapEntryFormat1419Test.java
@@ -0,0 +1,44 @@
+package tools.jackson.databind.tofix;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.junit.jupiter.api.Test;
+
+import com.fasterxml.jackson.annotation.JsonFormat;
+
+import tools.jackson.databind.*;
+import tools.jackson.databind.testutil.DatabindTestUtil;
+import tools.jackson.databind.testutil.failure.JacksonTestFailureExpected;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+// for [databind#1419]
+class MapEntryFormat1419Test extends DatabindTestUtil {
+    static class BeanWithMapEntryAsObject {
+        @JsonFormat(shape = JsonFormat.Shape.OBJECT)
+        public Map.Entry<String, String> entry;
+
+        protected BeanWithMapEntryAsObject() {
+        }
+
+        public BeanWithMapEntryAsObject(String key, String value) {
+            Map<String, String> map = new HashMap<>();
+            map.put(key, value);
+            entry = map.entrySet().iterator().next();
+        }
+    }
+
+    private final ObjectMapper MAPPER = newJsonMapper();
+
+    @JacksonTestFailureExpected
+    @Test
+    void wrappedAsObjectRoundtrip() throws Exception {
+        BeanWithMapEntryAsObject input = new BeanWithMapEntryAsObject("foo", "bar");
+        String json = MAPPER.writeValueAsString(input);
+        assertEquals(a2q("{'entry':{'key':'foo','value':'bar'}}"), json);
+        BeanWithMapEntryAsObject result = MAPPER.readValue(json, BeanWithMapEntryAsObject.class);
+        assertEquals("foo", result.entry.getKey());
+        assertEquals("bar", result.entry.getValue());
+    }
+}
