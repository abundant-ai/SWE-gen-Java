diff --git a/core/deployment/src/main/java/io/quarkus/deployment/configuration/BuildTimeConfigurationReader.java b/core/deployment/src/main/java/io/quarkus/deployment/configuration/BuildTimeConfigurationReader.java
index c9a20150dae..fa09f9cfb7a 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/configuration/BuildTimeConfigurationReader.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/configuration/BuildTimeConfigurationReader.java
@@ -13,6 +13,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Properties;
 import java.util.Set;
 import java.util.TreeMap;
@@ -20,7 +21,6 @@
 
 import org.eclipse.microprofile.config.Config;
 import org.eclipse.microprofile.config.spi.ConfigSource;
-import org.jboss.logging.Logger;
 
 import io.quarkus.deployment.configuration.tracker.ConfigTrackingInterceptor;
 import io.quarkus.deployment.util.ServiceUtil;
@@ -49,8 +49,6 @@
  * A configuration reader.
  */
 public final class BuildTimeConfigurationReader {
-    private static final Logger log = Logger.getLogger("io.quarkus.config.build");
-
     private static final String CONFIG_ROOTS_LIST = "META-INF/quarkus-config-roots.list";
 
     private static List<Class<?>> collectConfigRoots(ClassLoader classLoader) throws IOException, ClassNotFoundException {
@@ -241,6 +239,18 @@ public void accept(final ConfigSource configSource) {
                         }
                     });
 
+            // Set all defaults from build time runtime mappings as recorded build time runtime values
+            for (ConfigClass buildTimeRunTimeMapping : buildTimeRunTimeMappings) {
+                for (Entry<String, String> entry : buildTimeRunTimeMapping.getProperties().entrySet()) {
+                    buildTimeRunTimeValues.put(entry.getKey(),
+                            ConfigValue.builder()
+                                    .withName(entry.getKey())
+                                    .withValue(entry.getValue())
+                                    .withConfigSourceOrdinal(-Integer.MAX_VALUE)
+                                    .build());
+                }
+            }
+
             Set<PropertyName> buildTimeNames = mappingsToNames(buildTimeMappings).keySet();
             Set<PropertyName> buildTimeRunTimeNames = mappingsToNames(buildTimeRunTimeMappings).keySet();
             Set<PropertyName> runTimeNames = mappingsToNames(runTimeMappings).keySet();
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java b/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java
index e885bb804bb..aa5fdc53442 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java
@@ -29,7 +29,6 @@
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
-import java.util.TreeMap;
 
 import jakarta.annotation.Priority;
 
@@ -69,7 +68,6 @@
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveMethodBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;
-import io.quarkus.deployment.configuration.BuildTimeConfigurationReader;
 import io.quarkus.deployment.configuration.RunTimeConfigurationGenerator;
 import io.quarkus.deployment.configuration.tracker.ConfigTrackingConfig;
 import io.quarkus.deployment.configuration.tracker.ConfigTrackingWriter;
@@ -120,12 +118,10 @@
 import io.smallrye.config.SmallRyeConfigBuilderCustomizer;
 
 public class ConfigGenerationBuildStep {
-    private static final MethodDescriptor CONFIG_BUILDER = MethodDescriptor.ofMethod(
-            ConfigBuilder.class, "configBuilder",
-            SmallRyeConfigBuilder.class, SmallRyeConfigBuilder.class);
-    private static final MethodDescriptor WITH_SOURCES = MethodDescriptor.ofMethod(
-            SmallRyeConfigBuilder.class, "withSources",
-            SmallRyeConfigBuilder.class, ConfigSource[].class);
+    private static final MethodDescriptor CONFIG_BUILDER = MethodDescriptor.ofMethod(ConfigBuilder.class,
+            "configBuilder", SmallRyeConfigBuilder.class, SmallRyeConfigBuilder.class);
+    private static final MethodDescriptor WITH_SOURCES = MethodDescriptor.ofMethod(SmallRyeConfigBuilder.class,
+            "withSources", SmallRyeConfigBuilder.class, ConfigSource[].class);
 
     @BuildStep
     void nativeSupport(BuildProducer<RuntimeInitializedClassBuildItem> runtimeInitializedClassProducer) {
@@ -158,7 +154,10 @@ void buildTimeRunTimeConfig(
             ResultHandle map = clinit.newInstance(MethodDescriptor.ofConstructor(HashMap.class));
             MethodDescriptor put = MethodDescriptor.ofMethod(Map.class, "put", Object.class, Object.class, Object.class);
             for (Map.Entry<String, ConfigValue> entry : configItem.getReadResult().getBuildTimeRunTimeValues().entrySet()) {
-                clinit.invokeInterfaceMethod(put, map, clinit.load(entry.getKey()), clinit.load(entry.getValue().getValue()));
+                if (entry.getValue().getValue() != null) {
+                    clinit.invokeInterfaceMethod(put, map, clinit.load(entry.getKey()),
+                            clinit.load(entry.getValue().getValue()));
+                }
             }
 
             ResultHandle defaultValuesSource = clinit.newInstance(
@@ -273,14 +272,18 @@ void generateBuilders(
         allMappings.addAll(configItem.getReadResult().getRunTimeMappings());
         allMappings.removeAll(ignoreMappings);
 
+        Set<ConfigClass> buildTimeRuntimeMappings = new LinkedHashSet<>(
+                configItem.getReadResult().getBuildTimeRunTimeMappings());
+        buildTimeRuntimeMappings.removeAll(ignoreMappings);
+
         // Shared components
-        Map<Object, FieldDescriptor> sharedFields = generateSharedConfig(generatedClass, converters, allMappings);
+        Map<Object, FieldDescriptor> sharedFields = generateSharedConfig(
+                generatedClass,
+                combinedIndex,
+                converters, allMappings, buildTimeRuntimeMappings);
 
         // For Static Init Config
-        Set<ConfigClass> staticMappings = new LinkedHashSet<>();
-        staticMappings.addAll(staticSafeConfigMappings(configMappings));
-        staticMappings.addAll(configItem.getReadResult().getBuildTimeRunTimeMappings());
-        staticMappings.removeAll(ignoreMappings);
+        Set<ConfigClass> staticMappings = new LinkedHashSet<>(staticSafeConfigMappings(configMappings));
         Set<String> staticCustomizers = new LinkedHashSet<>(staticSafeServices(configCustomizers));
         staticCustomizers.add(StaticInitConfigBuilder.class.getName());
 
@@ -297,6 +300,7 @@ void generateBuilders(
                 staticSafeServices(configSourceFactories),
                 secretKeyHandlers,
                 staticSafeServices(secretKeyHandlerFactories),
+                buildTimeRuntimeMappings,
                 Set.of(),
                 staticMappings,
                 configItem.getReadResult().getMappingsIgnorePaths(),
@@ -330,6 +334,7 @@ void generateBuilders(
                 configSourceFactories,
                 secretKeyHandlers,
                 secretKeyHandlerFactories,
+                buildTimeRuntimeMappings,
                 staticMappings,
                 runTimeMappings,
                 configItem.getReadResult().getMappingsIgnorePaths(),
@@ -404,26 +409,18 @@ public void checkForBuildTimeConfigChange(
             excludedConfigKeys.add(item.getConfigKey());
         }
 
-        Map<String, ConfigValue> values = new TreeMap<>();
-        BuildTimeConfigurationReader.ReadResult readResult = configItem.getReadResult();
-        for (Map.Entry<String, ConfigValue> entry : readResult.getAllBuildTimeValues().entrySet()) {
+        List<ConfigValue> values = new ArrayList<>();
+        for (Map.Entry<String, ConfigValue> entry : configItem.getReadResult().getBuildTimeRunTimeValues().entrySet()) {
             if (excludedConfigKeys.contains(entry.getKey())) {
                 continue;
             }
-            if (readResult.getRunTimeValues().containsKey(entry.getKey())) {
-                continue;
-            }
-            values.putIfAbsent(entry.getKey(), entry.getValue());
-        }
 
-        for (Map.Entry<String, ConfigValue> entry : readResult.getBuildTimeRunTimeValues().entrySet()) {
-            if (excludedConfigKeys.contains(entry.getKey())) {
-                continue;
-            }
-            if (readResult.getRunTimeValues().containsKey(entry.getKey())) {
-                continue;
-            }
-            values.put(entry.getKey(), entry.getValue());
+            ConfigValue value = entry.getValue();
+            values.add(ConfigValue.builder()
+                    .withName(value.getName())
+                    .withValue(value.getValue())
+                    .withConfigSourceOrdinal(value.getConfigSourceOrdinal())
+                    .build());
         }
 
         recorder.handleConfigChange(values);
@@ -594,6 +591,11 @@ private static String getPathWithoutExtension(Path path) {
         return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);
     }
 
+    private static final MethodDescriptor NEW_BUILDER = MethodDescriptor.ofConstructor(SmallRyeConfigBuilder.class);
+    private static final MethodDescriptor BUILD = MethodDescriptor.ofMethod(SmallRyeConfigBuilder.class,
+            "build", SmallRyeConfig.class);
+    private static final MethodDescriptor GET_CONFIG_MAPPING = MethodDescriptor.ofMethod(SmallRyeConfig.class,
+            "getConfigMapping", Object.class, Class.class, String.class);
     private static final MethodDescriptor BUILDER_CUSTOMIZER = MethodDescriptor.ofMethod(SmallRyeConfigBuilderCustomizer.class,
             "configBuilder",
             void.class, SmallRyeConfigBuilder.class);
@@ -631,6 +633,10 @@ private static String getPathWithoutExtension(Path path) {
             "withMapping",
             void.class, SmallRyeConfigBuilder.class, ConfigClass.class);
     private static final MethodDescriptor WITH_MAPPING_INSTANCE = MethodDescriptor.ofMethod(AbstractConfigBuilder.class,
+            "withMappingInstance",
+            void.class, SmallRyeConfigBuilder.class, ConfigClass.class, Object.class);
+    private static final MethodDescriptor WITH_MAPPING_INSTANCE_FROM_CONFIG = MethodDescriptor.ofMethod(
+            AbstractConfigBuilder.class,
             "withMappingInstance",
             void.class, SmallRyeConfigBuilder.class, ConfigClass.class);
     private static final MethodDescriptor WITH_MAPPING_IGNORE = MethodDescriptor.ofMethod(AbstractConfigBuilder.class,
@@ -658,8 +664,10 @@ private static String getPathWithoutExtension(Path path) {
 
     private static Map<Object, FieldDescriptor> generateSharedConfig(
             BuildProducer<GeneratedClassBuildItem> generatedClass,
+            CombinedIndexBuildItem combinedIndex,
             Set<String> converters,
-            Set<ConfigClass> mappings) {
+            Set<ConfigClass> mappings,
+            Set<ConfigClass> staticMappings) {
 
         Map<Object, FieldDescriptor> fields = new HashMap<>();
         try (ClassCreator classCreator = ClassCreator.builder()
@@ -681,11 +689,12 @@ private static Map<Object, FieldDescriptor> generateSharedConfig(
                 fields.put(converter, converterField);
             }
 
-            int mappingIndex = 0;
+            int configClassIndex = 0;
             for (ConfigClass mapping : mappings) {
-                FieldDescriptor mappingField = classCreator.getFieldCreator("mapping$" + mappingIndex++, ConfigClass.class)
+                FieldDescriptor configClassField = classCreator
+                        .getFieldCreator("configClass$" + configClassIndex++, ConfigClass.class)
                         .setModifiers(ACC_STATIC).getFieldDescriptor();
-                clinit.writeStaticField(mappingField, clinit.invokeStaticMethod(CONFIG_CLASS,
+                clinit.writeStaticField(configClassField, clinit.invokeStaticMethod(CONFIG_CLASS,
                         clinit.load(mapping.getType().getName()), clinit.load(mapping.getPrefix())));
 
                 // Cache implementation types of nested elements
@@ -695,7 +704,37 @@ private static Map<Object, FieldDescriptor> generateSharedConfig(
                     clinit.invokeStaticMethod(ENSURE_LOADED, clinit.load(configMappingMetadata.getInterfaceType().getName()));
                 }
 
-                fields.put(mapping, mappingField);
+                fields.put(mapping, configClassField);
+            }
+
+            // init build and runtime fixed mappings
+            ResultHandle configBuilder = clinit.newInstance(NEW_BUILDER);
+            clinit.invokeStaticMethod(MethodDescriptor.ofMethod(AbstractConfigBuilder.class, "withSharedBuilder", void.class,
+                    SmallRyeConfigBuilder.class), configBuilder);
+            for (String converter : converters) {
+                ClassInfo converterClass = combinedIndex.getComputingIndex().getClassByName(converter);
+                Type type = getConverterType(converterClass, combinedIndex);
+                AnnotationInstance priorityAnnotation = converterClass.annotation(PRIORITY_NAME);
+                int priority = priorityAnnotation != null ? priorityAnnotation.value().asInt() : 100;
+
+                clinit.invokeStaticMethod(WITH_CONVERTER, configBuilder,
+                        clinit.load(type.name().toString()),
+                        clinit.load(priority),
+                        clinit.readStaticField(fields.get(converter)));
+            }
+            for (ConfigClass mapping : staticMappings) {
+                clinit.invokeStaticMethod(WITH_MAPPING, configBuilder, clinit.readStaticField(fields.get(mapping)));
+            }
+            clinit.invokeStaticMethod(WITH_BUILDER, configBuilder, clinit.newInstance(
+                    MethodDescriptor.ofConstructor("io.quarkus.runtime.generated.BuildTimeRunTimeFixedConfigSourceBuilder")));
+            ResultHandle config = clinit.invokeVirtualMethod(BUILD, configBuilder);
+            int mappingIndex = 0;
+            for (ConfigClass mapping : staticMappings) {
+                FieldDescriptor mappingField = classCreator.getFieldCreator("mapping$" + mappingIndex++, mapping.getType())
+                        .setModifiers(ACC_STATIC).getFieldDescriptor();
+                clinit.writeStaticField(mappingField, clinit.invokeVirtualMethod(GET_CONFIG_MAPPING, config,
+                        clinit.loadClass(mapping.getType()), clinit.load(mapping.getPrefix())));
+                fields.put(fields.get(mapping), mappingField);
             }
 
             clinit.returnVoid();
@@ -720,6 +759,7 @@ private static void generateConfigBuilder(
             Set<String> configSourceFactories,
             Set<String> secretKeyHandlers,
             Set<String> secretKeyHandlerFactories,
+            Set<ConfigClass> mappingsShared,
             Set<ConfigClass> mappingsInstances,
             Set<ConfigClass> mappings,
             Set<String> mappingsIgnorePaths,
@@ -808,9 +848,17 @@ private static void generateConfigBuilder(
                         method.newInstance(MethodDescriptor.ofConstructor(secretKeyHandlerFactory)));
             }
 
+            for (ConfigClass mappingShared : mappingsShared) {
+                FieldDescriptor configClassField = sharedFields.get(mappingShared);
+                FieldDescriptor mappingInstanceField = sharedFields.get(configClassField);
+                method.invokeStaticMethod(WITH_MAPPING_INSTANCE, configBuilder, method.readStaticField(configClassField),
+                        method.readStaticField(mappingInstanceField));
+            }
+
             for (ConfigClass mappingInstance : mappingsInstances) {
-                method.invokeStaticMethod(WITH_MAPPING_INSTANCE, configBuilder,
-                        method.readStaticField(sharedFields.get(mappingInstance)));
+                FieldDescriptor configClassField = sharedFields.get(mappingInstance);
+                method.invokeStaticMethod(WITH_MAPPING_INSTANCE_FROM_CONFIG, configBuilder,
+                        method.readStaticField(configClassField));
             }
 
             mappings.removeAll(mappingsInstances);
diff --git a/core/runtime/src/main/java/io/quarkus/runtime/configuration/AbstractConfigBuilder.java b/core/runtime/src/main/java/io/quarkus/runtime/configuration/AbstractConfigBuilder.java
index 98aa0347dc4..5ebd2393266 100644
--- a/core/runtime/src/main/java/io/quarkus/runtime/configuration/AbstractConfigBuilder.java
+++ b/core/runtime/src/main/java/io/quarkus/runtime/configuration/AbstractConfigBuilder.java
@@ -25,6 +25,10 @@
  */
 public abstract class AbstractConfigBuilder implements SmallRyeConfigBuilderCustomizer {
 
+    protected static void withSharedBuilder(SmallRyeConfigBuilder builder) {
+        builder.withMappingIgnore("quarkus.**");
+    }
+
     protected static void withDefaultValues(SmallRyeConfigBuilder builder, Map<String, String> values) {
         builder.withDefaultValues(values);
     }
@@ -88,6 +92,10 @@ protected static void withMapping(SmallRyeConfigBuilder builder, String mappingC
         }
     }
 
+    protected static void withMappingInstance(SmallRyeConfigBuilder builder, ConfigClass configClass, Object instance) {
+        builder.getMappingsBuilder().mappingInstance(configClass, instance);
+    }
+
     protected static void withMappingInstance(SmallRyeConfigBuilder builder, ConfigClass mapping) {
         SmallRyeConfig config = ConfigProvider.getConfig().unwrap(SmallRyeConfig.class);
         builder.getMappingsBuilder().mappingInstance(mapping, config.getConfigMapping(mapping.getType(), mapping.getPrefix()));
diff --git a/core/runtime/src/main/java/io/quarkus/runtime/configuration/ConfigRecorder.java b/core/runtime/src/main/java/io/quarkus/runtime/configuration/ConfigRecorder.java
index 8f35933bad0..59eed19775c 100644
--- a/core/runtime/src/main/java/io/quarkus/runtime/configuration/ConfigRecorder.java
+++ b/core/runtime/src/main/java/io/quarkus/runtime/configuration/ConfigRecorder.java
@@ -23,7 +23,7 @@
 public class ConfigRecorder {
     private static final Logger log = Logger.getLogger(ConfigRecorder.class);
 
-    public void handleConfigChange(Map<String, ConfigValue> buildTimeRuntimeValues) {
+    public void handleConfigChange(List<ConfigValue> buildTimeRuntimeValues) {
         SmallRyeConfig config = ConfigProvider.getConfig().unwrap(SmallRyeConfig.class);
         // Disable the BuildTime RunTime Fixed (has the highest ordinal), because a lookup will get the expected value,
         // and we have no idea if the user tried to override it in another source.
@@ -36,16 +36,20 @@ public void handleConfigChange(Map<String, ConfigValue> buildTimeRuntimeValues)
         }
 
         List<String> mismatches = new ArrayList<>();
-        for (Map.Entry<String, ConfigValue> entry : buildTimeRuntimeValues.entrySet()) {
-            ConfigValue currentValue = config.getConfigValue(entry.getKey());
-            // Check for changes. Also, we only have a change if the source ordinal is higher
-            // The config value can be null (for ex. if the property uses environment variables not available at build time)
-            if (currentValue.getValue() != null && !Objects.equals(entry.getValue().getValue(), currentValue.getValue())
-                    && entry.getValue().getSourceOrdinal() < currentValue.getSourceOrdinal()) {
+        for (ConfigValue buildTimeRuntimeValue : buildTimeRuntimeValues) {
+            String propertyName = buildTimeRuntimeValue.getName();
+            ConfigValue currentValue = config.getConfigValue(propertyName);
+            // Check for changes:
+            // - the config source position check tell us if the value is actually present in the config even if null
+            // - compare the ordinals of the recorded to the current value, if higher or equals there is a tentative override
+            // - compare the actual config values, if different there is a mismatch
+            if (currentValue.getConfigSourcePosition() > 0
+                    && currentValue.getSourceOrdinal() >= buildTimeRuntimeValue.getSourceOrdinal()
+                    && !Objects.equals(buildTimeRuntimeValue.getValue(), currentValue.getValue())) {
                 mismatches.add(
-                        " - " + entry.getKey() + " is set to '" + currentValue.getValue()
+                        " - " + propertyName + " is set to '" + currentValue.getValue()
                                 + "' but it is build time fixed to '"
-                                + entry.getValue().getValue() + "'. Did you change the property " + entry.getKey()
+                                + buildTimeRuntimeValue.getValue() + "'. Did you change the property " + propertyName
                                 + " after building the application?");
             }
         }
diff --git a/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/config/TestMappingBuildTimeRunTime.java b/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/config/TestMappingBuildTimeRunTime.java
index bb9c93acec5..72eed714b0b 100644
--- a/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/config/TestMappingBuildTimeRunTime.java
+++ b/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/config/TestMappingBuildTimeRunTime.java
@@ -1,6 +1,7 @@
 package io.quarkus.extest.runtime.config;
 
 import java.util.Map;
+import java.util.Optional;
 
 import io.quarkus.runtime.annotations.ConfigPhase;
 import io.quarkus.runtime.annotations.ConfigRoot;
@@ -24,6 +25,11 @@ public interface TestMappingBuildTimeRunTime {
      */
     Map<String, Map<String, String>> mapMap();
 
+    /**
+     * An Optional
+     */
+    Optional<String> optional();
+
     interface Group {
         /**
          * A Group value.
