diff --git a/core/deployment/src/main/java/io/quarkus/deployment/configuration/BuildTimeConfigurationReader.java b/core/deployment/src/main/java/io/quarkus/deployment/configuration/BuildTimeConfigurationReader.java
index fa09f9cfb7a..c9a20150dae 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/configuration/BuildTimeConfigurationReader.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/configuration/BuildTimeConfigurationReader.java
@@ -13,7 +13,6 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Properties;
 import java.util.Set;
 import java.util.TreeMap;
@@ -21,6 +20,7 @@
 
 import org.eclipse.microprofile.config.Config;
 import org.eclipse.microprofile.config.spi.ConfigSource;
+import org.jboss.logging.Logger;
 
 import io.quarkus.deployment.configuration.tracker.ConfigTrackingInterceptor;
 import io.quarkus.deployment.util.ServiceUtil;
@@ -49,6 +49,8 @@
  * A configuration reader.
  */
 public final class BuildTimeConfigurationReader {
+    private static final Logger log = Logger.getLogger("io.quarkus.config.build");
+
     private static final String CONFIG_ROOTS_LIST = "META-INF/quarkus-config-roots.list";
 
     private static List<Class<?>> collectConfigRoots(ClassLoader classLoader) throws IOException, ClassNotFoundException {
@@ -239,18 +241,6 @@ public void accept(final ConfigSource configSource) {
                         }
                     });
 
-            // Set all defaults from build time runtime mappings as recorded build time runtime values
-            for (ConfigClass buildTimeRunTimeMapping : buildTimeRunTimeMappings) {
-                for (Entry<String, String> entry : buildTimeRunTimeMapping.getProperties().entrySet()) {
-                    buildTimeRunTimeValues.put(entry.getKey(),
-                            ConfigValue.builder()
-                                    .withName(entry.getKey())
-                                    .withValue(entry.getValue())
-                                    .withConfigSourceOrdinal(-Integer.MAX_VALUE)
-                                    .build());
-                }
-            }
-
             Set<PropertyName> buildTimeNames = mappingsToNames(buildTimeMappings).keySet();
             Set<PropertyName> buildTimeRunTimeNames = mappingsToNames(buildTimeRunTimeMappings).keySet();
             Set<PropertyName> runTimeNames = mappingsToNames(runTimeMappings).keySet();
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java b/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java
index aa5fdc53442..e885bb804bb 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/steps/ConfigGenerationBuildStep.java
@@ -29,6 +29,7 @@
 import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
+import java.util.TreeMap;
 
 import jakarta.annotation.Priority;
 
@@ -68,6 +69,7 @@
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveMethodBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.RuntimeInitializedClassBuildItem;
+import io.quarkus.deployment.configuration.BuildTimeConfigurationReader;
 import io.quarkus.deployment.configuration.RunTimeConfigurationGenerator;
 import io.quarkus.deployment.configuration.tracker.ConfigTrackingConfig;
 import io.quarkus.deployment.configuration.tracker.ConfigTrackingWriter;
@@ -118,10 +120,12 @@
 import io.smallrye.config.SmallRyeConfigBuilderCustomizer;
 
 public class ConfigGenerationBuildStep {
-    private static final MethodDescriptor CONFIG_BUILDER = MethodDescriptor.ofMethod(ConfigBuilder.class,
-            "configBuilder", SmallRyeConfigBuilder.class, SmallRyeConfigBuilder.class);
-    private static final MethodDescriptor WITH_SOURCES = MethodDescriptor.ofMethod(SmallRyeConfigBuilder.class,
-            "withSources", SmallRyeConfigBuilder.class, ConfigSource[].class);
+    private static final MethodDescriptor CONFIG_BUILDER = MethodDescriptor.ofMethod(
+            ConfigBuilder.class, "configBuilder",
+            SmallRyeConfigBuilder.class, SmallRyeConfigBuilder.class);
+    private static final MethodDescriptor WITH_SOURCES = MethodDescriptor.ofMethod(
+            SmallRyeConfigBuilder.class, "withSources",
+            SmallRyeConfigBuilder.class, ConfigSource[].class);
 
     @BuildStep
     void nativeSupport(BuildProducer<RuntimeInitializedClassBuildItem> runtimeInitializedClassProducer) {
@@ -154,10 +158,7 @@ void buildTimeRunTimeConfig(
             ResultHandle map = clinit.newInstance(MethodDescriptor.ofConstructor(HashMap.class));
             MethodDescriptor put = MethodDescriptor.ofMethod(Map.class, "put", Object.class, Object.class, Object.class);
             for (Map.Entry<String, ConfigValue> entry : configItem.getReadResult().getBuildTimeRunTimeValues().entrySet()) {
-                if (entry.getValue().getValue() != null) {
-                    clinit.invokeInterfaceMethod(put, map, clinit.load(entry.getKey()),
-                            clinit.load(entry.getValue().getValue()));
-                }
+                clinit.invokeInterfaceMethod(put, map, clinit.load(entry.getKey()), clinit.load(entry.getValue().getValue()));
             }
 
             ResultHandle defaultValuesSource = clinit.newInstance(
@@ -272,18 +273,14 @@ void generateBuilders(
         allMappings.addAll(configItem.getReadResult().getRunTimeMappings());
         allMappings.removeAll(ignoreMappings);
 
-        Set<ConfigClass> buildTimeRuntimeMappings = new LinkedHashSet<>(
-                configItem.getReadResult().getBuildTimeRunTimeMappings());
-        buildTimeRuntimeMappings.removeAll(ignoreMappings);
-
         // Shared components
-        Map<Object, FieldDescriptor> sharedFields = generateSharedConfig(
-                generatedClass,
-                combinedIndex,
-                converters, allMappings, buildTimeRuntimeMappings);
+        Map<Object, FieldDescriptor> sharedFields = generateSharedConfig(generatedClass, converters, allMappings);
 
         // For Static Init Config
-        Set<ConfigClass> staticMappings = new LinkedHashSet<>(staticSafeConfigMappings(configMappings));
+        Set<ConfigClass> staticMappings = new LinkedHashSet<>();
+        staticMappings.addAll(staticSafeConfigMappings(configMappings));
+        staticMappings.addAll(configItem.getReadResult().getBuildTimeRunTimeMappings());
+        staticMappings.removeAll(ignoreMappings);
         Set<String> staticCustomizers = new LinkedHashSet<>(staticSafeServices(configCustomizers));
         staticCustomizers.add(StaticInitConfigBuilder.class.getName());
 
@@ -300,7 +297,6 @@ void generateBuilders(
                 staticSafeServices(configSourceFactories),
                 secretKeyHandlers,
                 staticSafeServices(secretKeyHandlerFactories),
-                buildTimeRuntimeMappings,
                 Set.of(),
                 staticMappings,
                 configItem.getReadResult().getMappingsIgnorePaths(),
@@ -334,7 +330,6 @@ void generateBuilders(
                 configSourceFactories,
                 secretKeyHandlers,
                 secretKeyHandlerFactories,
-                buildTimeRuntimeMappings,
                 staticMappings,
                 runTimeMappings,
                 configItem.getReadResult().getMappingsIgnorePaths(),
@@ -409,18 +404,26 @@ public void checkForBuildTimeConfigChange(
             excludedConfigKeys.add(item.getConfigKey());
         }
 
-        List<ConfigValue> values = new ArrayList<>();
-        for (Map.Entry<String, ConfigValue> entry : configItem.getReadResult().getBuildTimeRunTimeValues().entrySet()) {
+        Map<String, ConfigValue> values = new TreeMap<>();
+        BuildTimeConfigurationReader.ReadResult readResult = configItem.getReadResult();
+        for (Map.Entry<String, ConfigValue> entry : readResult.getAllBuildTimeValues().entrySet()) {
             if (excludedConfigKeys.contains(entry.getKey())) {
                 continue;
             }
+            if (readResult.getRunTimeValues().containsKey(entry.getKey())) {
+                continue;
+            }
+            values.putIfAbsent(entry.getKey(), entry.getValue());
+        }
 
-            ConfigValue value = entry.getValue();
-            values.add(ConfigValue.builder()
-                    .withName(value.getName())
-                    .withValue(value.getValue())
-                    .withConfigSourceOrdinal(value.getConfigSourceOrdinal())
-                    .build());
+        for (Map.Entry<String, ConfigValue> entry : readResult.getBuildTimeRunTimeValues().entrySet()) {
+            if (excludedConfigKeys.contains(entry.getKey())) {
+                continue;
+            }
+            if (readResult.getRunTimeValues().containsKey(entry.getKey())) {
+                continue;
+            }
+            values.put(entry.getKey(), entry.getValue());
         }
 
         recorder.handleConfigChange(values);
@@ -591,11 +594,6 @@ private static String getPathWithoutExtension(Path path) {
         return (dotIndex == -1) ? fileName : fileName.substring(0, dotIndex);
     }
 
-    private static final MethodDescriptor NEW_BUILDER = MethodDescriptor.ofConstructor(SmallRyeConfigBuilder.class);
-    private static final MethodDescriptor BUILD = MethodDescriptor.ofMethod(SmallRyeConfigBuilder.class,
-            "build", SmallRyeConfig.class);
-    private static final MethodDescriptor GET_CONFIG_MAPPING = MethodDescriptor.ofMethod(SmallRyeConfig.class,
-            "getConfigMapping", Object.class, Class.class, String.class);
     private static final MethodDescriptor BUILDER_CUSTOMIZER = MethodDescriptor.ofMethod(SmallRyeConfigBuilderCustomizer.class,
             "configBuilder",
             void.class, SmallRyeConfigBuilder.class);
@@ -633,10 +631,6 @@ private static String getPathWithoutExtension(Path path) {
             "withMapping",
             void.class, SmallRyeConfigBuilder.class, ConfigClass.class);
     private static final MethodDescriptor WITH_MAPPING_INSTANCE = MethodDescriptor.ofMethod(AbstractConfigBuilder.class,
-            "withMappingInstance",
-            void.class, SmallRyeConfigBuilder.class, ConfigClass.class, Object.class);
-    private static final MethodDescriptor WITH_MAPPING_INSTANCE_FROM_CONFIG = MethodDescriptor.ofMethod(
-            AbstractConfigBuilder.class,
             "withMappingInstance",
             void.class, SmallRyeConfigBuilder.class, ConfigClass.class);
     private static final MethodDescriptor WITH_MAPPING_IGNORE = MethodDescriptor.ofMethod(AbstractConfigBuilder.class,
@@ -664,10 +658,8 @@ private static String getPathWithoutExtension(Path path) {
 
     private static Map<Object, FieldDescriptor> generateSharedConfig(
             BuildProducer<GeneratedClassBuildItem> generatedClass,
-            CombinedIndexBuildItem combinedIndex,
             Set<String> converters,
-            Set<ConfigClass> mappings,
-            Set<ConfigClass> staticMappings) {
+            Set<ConfigClass> mappings) {
 
         Map<Object, FieldDescriptor> fields = new HashMap<>();
         try (ClassCreator classCreator = ClassCreator.builder()
@@ -689,12 +681,11 @@ private static Map<Object, FieldDescriptor> generateSharedConfig(
                 fields.put(converter, converterField);
             }
 
-            int configClassIndex = 0;
+            int mappingIndex = 0;
             for (ConfigClass mapping : mappings) {
-                FieldDescriptor configClassField = classCreator
-                        .getFieldCreator("configClass$" + configClassIndex++, ConfigClass.class)
+                FieldDescriptor mappingField = classCreator.getFieldCreator("mapping$" + mappingIndex++, ConfigClass.class)
                         .setModifiers(ACC_STATIC).getFieldDescriptor();
-                clinit.writeStaticField(configClassField, clinit.invokeStaticMethod(CONFIG_CLASS,
+                clinit.writeStaticField(mappingField, clinit.invokeStaticMethod(CONFIG_CLASS,
                         clinit.load(mapping.getType().getName()), clinit.load(mapping.getPrefix())));
 
                 // Cache implementation types of nested elements
@@ -704,37 +695,7 @@ private static Map<Object, FieldDescriptor> generateSharedConfig(
                     clinit.invokeStaticMethod(ENSURE_LOADED, clinit.load(configMappingMetadata.getInterfaceType().getName()));
                 }
 
-                fields.put(mapping, configClassField);
-            }
-
-            // init build and runtime fixed mappings
-            ResultHandle configBuilder = clinit.newInstance(NEW_BUILDER);
-            clinit.invokeStaticMethod(MethodDescriptor.ofMethod(AbstractConfigBuilder.class, "withSharedBuilder", void.class,
-                    SmallRyeConfigBuilder.class), configBuilder);
-            for (String converter : converters) {
-                ClassInfo converterClass = combinedIndex.getComputingIndex().getClassByName(converter);
-                Type type = getConverterType(converterClass, combinedIndex);
-                AnnotationInstance priorityAnnotation = converterClass.annotation(PRIORITY_NAME);
-                int priority = priorityAnnotation != null ? priorityAnnotation.value().asInt() : 100;
-
-                clinit.invokeStaticMethod(WITH_CONVERTER, configBuilder,
-                        clinit.load(type.name().toString()),
-                        clinit.load(priority),
-                        clinit.readStaticField(fields.get(converter)));
-            }
-            for (ConfigClass mapping : staticMappings) {
-                clinit.invokeStaticMethod(WITH_MAPPING, configBuilder, clinit.readStaticField(fields.get(mapping)));
-            }
-            clinit.invokeStaticMethod(WITH_BUILDER, configBuilder, clinit.newInstance(
-                    MethodDescriptor.ofConstructor("io.quarkus.runtime.generated.BuildTimeRunTimeFixedConfigSourceBuilder")));
-            ResultHandle config = clinit.invokeVirtualMethod(BUILD, configBuilder);
-            int mappingIndex = 0;
-            for (ConfigClass mapping : staticMappings) {
-                FieldDescriptor mappingField = classCreator.getFieldCreator("mapping$" + mappingIndex++, mapping.getType())
-                        .setModifiers(ACC_STATIC).getFieldDescriptor();
-                clinit.writeStaticField(mappingField, clinit.invokeVirtualMethod(GET_CONFIG_MAPPING, config,
-                        clinit.loadClass(mapping.getType()), clinit.load(mapping.getPrefix())));
-                fields.put(fields.get(mapping), mappingField);
+                fields.put(mapping, mappingField);
             }
 
             clinit.returnVoid();
@@ -759,7 +720,6 @@ private static void generateConfigBuilder(
             Set<String> configSourceFactories,
             Set<String> secretKeyHandlers,
             Set<String> secretKeyHandlerFactories,
-            Set<ConfigClass> mappingsShared,
             Set<ConfigClass> mappingsInstances,
             Set<ConfigClass> mappings,
             Set<String> mappingsIgnorePaths,
@@ -848,17 +808,9 @@ private static void generateConfigBuilder(
                         method.newInstance(MethodDescriptor.ofConstructor(secretKeyHandlerFactory)));
             }
 
-            for (ConfigClass mappingShared : mappingsShared) {
-                FieldDescriptor configClassField = sharedFields.get(mappingShared);
-                FieldDescriptor mappingInstanceField = sharedFields.get(configClassField);
-                method.invokeStaticMethod(WITH_MAPPING_INSTANCE, configBuilder, method.readStaticField(configClassField),
-                        method.readStaticField(mappingInstanceField));
-            }
-
             for (ConfigClass mappingInstance : mappingsInstances) {
-                FieldDescriptor configClassField = sharedFields.get(mappingInstance);
-                method.invokeStaticMethod(WITH_MAPPING_INSTANCE_FROM_CONFIG, configBuilder,
-                        method.readStaticField(configClassField));
+                method.invokeStaticMethod(WITH_MAPPING_INSTANCE, configBuilder,
+                        method.readStaticField(sharedFields.get(mappingInstance)));
             }
 
             mappings.removeAll(mappingsInstances);
diff --git a/core/runtime/src/main/java/io/quarkus/runtime/configuration/AbstractConfigBuilder.java b/core/runtime/src/main/java/io/quarkus/runtime/configuration/AbstractConfigBuilder.java
index 5ebd2393266..98aa0347dc4 100644
--- a/core/runtime/src/main/java/io/quarkus/runtime/configuration/AbstractConfigBuilder.java
+++ b/core/runtime/src/main/java/io/quarkus/runtime/configuration/AbstractConfigBuilder.java
@@ -25,10 +25,6 @@
  */
 public abstract class AbstractConfigBuilder implements SmallRyeConfigBuilderCustomizer {
 
-    protected static void withSharedBuilder(SmallRyeConfigBuilder builder) {
-        builder.withMappingIgnore("quarkus.**");
-    }
-
     protected static void withDefaultValues(SmallRyeConfigBuilder builder, Map<String, String> values) {
         builder.withDefaultValues(values);
     }
@@ -92,10 +88,6 @@ protected static void withMapping(SmallRyeConfigBuilder builder, String mappingC
         }
     }
 
-    protected static void withMappingInstance(SmallRyeConfigBuilder builder, ConfigClass configClass, Object instance) {
-        builder.getMappingsBuilder().mappingInstance(configClass, instance);
-    }
-
     protected static void withMappingInstance(SmallRyeConfigBuilder builder, ConfigClass mapping) {
         SmallRyeConfig config = ConfigProvider.getConfig().unwrap(SmallRyeConfig.class);
         builder.getMappingsBuilder().mappingInstance(mapping, config.getConfigMapping(mapping.getType(), mapping.getPrefix()));
diff --git a/core/runtime/src/main/java/io/quarkus/runtime/configuration/ConfigRecorder.java b/core/runtime/src/main/java/io/quarkus/runtime/configuration/ConfigRecorder.java
index 59eed19775c..8f35933bad0 100644
--- a/core/runtime/src/main/java/io/quarkus/runtime/configuration/ConfigRecorder.java
+++ b/core/runtime/src/main/java/io/quarkus/runtime/configuration/ConfigRecorder.java
@@ -23,7 +23,7 @@
 public class ConfigRecorder {
     private static final Logger log = Logger.getLogger(ConfigRecorder.class);
 
-    public void handleConfigChange(List<ConfigValue> buildTimeRuntimeValues) {
+    public void handleConfigChange(Map<String, ConfigValue> buildTimeRuntimeValues) {
         SmallRyeConfig config = ConfigProvider.getConfig().unwrap(SmallRyeConfig.class);
         // Disable the BuildTime RunTime Fixed (has the highest ordinal), because a lookup will get the expected value,
         // and we have no idea if the user tried to override it in another source.
@@ -36,20 +36,16 @@ public void handleConfigChange(List<ConfigValue> buildTimeRuntimeValues) {
         }
 
         List<String> mismatches = new ArrayList<>();
-        for (ConfigValue buildTimeRuntimeValue : buildTimeRuntimeValues) {
-            String propertyName = buildTimeRuntimeValue.getName();
-            ConfigValue currentValue = config.getConfigValue(propertyName);
-            // Check for changes:
-            // - the config source position check tell us if the value is actually present in the config even if null
-            // - compare the ordinals of the recorded to the current value, if higher or equals there is a tentative override
-            // - compare the actual config values, if different there is a mismatch
-            if (currentValue.getConfigSourcePosition() > 0
-                    && currentValue.getSourceOrdinal() >= buildTimeRuntimeValue.getSourceOrdinal()
-                    && !Objects.equals(buildTimeRuntimeValue.getValue(), currentValue.getValue())) {
+        for (Map.Entry<String, ConfigValue> entry : buildTimeRuntimeValues.entrySet()) {
+            ConfigValue currentValue = config.getConfigValue(entry.getKey());
+            // Check for changes. Also, we only have a change if the source ordinal is higher
+            // The config value can be null (for ex. if the property uses environment variables not available at build time)
+            if (currentValue.getValue() != null && !Objects.equals(entry.getValue().getValue(), currentValue.getValue())
+                    && entry.getValue().getSourceOrdinal() < currentValue.getSourceOrdinal()) {
                 mismatches.add(
-                        " - " + propertyName + " is set to '" + currentValue.getValue()
+                        " - " + entry.getKey() + " is set to '" + currentValue.getValue()
                                 + "' but it is build time fixed to '"
-                                + buildTimeRuntimeValue.getValue() + "'. Did you change the property " + propertyName
+                                + entry.getValue().getValue() + "'. Did you change the property " + entry.getKey()
                                 + " after building the application?");
             }
         }
diff --git a/integration-tests/test-extension/extension/deployment/src/test/java/io/quarkus/extest/OverrideBuildTimeConfigTest.java b/integration-tests/test-extension/extension/deployment/src/test/java/io/quarkus/extest/OverrideBuildTimeConfigTest.java
index 0bfd9780297..4d26d75ca3f 100644
--- a/integration-tests/test-extension/extension/deployment/src/test/java/io/quarkus/extest/OverrideBuildTimeConfigTest.java
+++ b/integration-tests/test-extension/extension/deployment/src/test/java/io/quarkus/extest/OverrideBuildTimeConfigTest.java
@@ -12,15 +12,14 @@
 public class OverrideBuildTimeConfigTest {
     @RegisterExtension
     static final QuarkusProdModeTest TEST = new QuarkusProdModeTest()
-            .setRuntimeProperties(Map.of("quarkus.application.name", "foo", "quarkus.mapping.btrt.optional", "value"))
+            .setRuntimeProperties(Map.of("quarkus.application.name", "foo"))
             .setRun(true);
 
     @Test
     void overrideBuildTimeConfigTest() {
         assertTrue(TEST.getStartupConsoleOutput()
-                .contains("- quarkus.application.name is set to 'foo' but it is build time fixed to " +
-                        "'quarkus-integration-test-test-extension-extension-deployment'."));
-        assertTrue(TEST.getStartupConsoleOutput()
-                .contains("- quarkus.mapping.btrt.optional is set to 'value' but it is build time fixed to 'null'."));
+                .contains(
+                        "- quarkus.application.name is set to 'foo' but it is build time fixed to " +
+                                "'quarkus-integration-test-test-extension-extension-deployment'."));
     }
 }
diff --git a/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/config/TestMappingBuildTimeRunTime.java b/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/config/TestMappingBuildTimeRunTime.java
index 72eed714b0b..bb9c93acec5 100644
--- a/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/config/TestMappingBuildTimeRunTime.java
+++ b/integration-tests/test-extension/extension/runtime/src/main/java/io/quarkus/extest/runtime/config/TestMappingBuildTimeRunTime.java
@@ -1,7 +1,6 @@
 package io.quarkus.extest.runtime.config;
 
 import java.util.Map;
-import java.util.Optional;
 
 import io.quarkus.runtime.annotations.ConfigPhase;
 import io.quarkus.runtime.annotations.ConfigRoot;
@@ -25,11 +24,6 @@ public interface TestMappingBuildTimeRunTime {
      */
     Map<String, Map<String, String>> mapMap();
 
-    /**
-     * An Optional
-     */
-    Optional<String> optional();
-
     interface Group {
         /**
          * A Group value.
