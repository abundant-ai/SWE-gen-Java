diff --git a/build.gradle b/build.gradle
index d7913f9a2..8bca9f432 100644
--- a/build.gradle
+++ b/build.gradle
@@ -10,7 +10,7 @@ buildscript {
 
         classpath "io.github.gradle-nexus:publish-plugin:1.1.0"
         classpath 'org.shipkit:shipkit-changelog:1.1.15'
-        classpath 'org.shipkit:shipkit-auto-version:1.1.16'
+        classpath 'org.shipkit:shipkit-auto-version:1.1.17'
 
         classpath 'com.google.googlejavaformat:google-java-format:1.10.0'
     }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
index 70abf95fb..3dadd3fa4 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
@@ -25,6 +25,7 @@ import static org.mockito.internal.util.StringUtil.join;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
@@ -97,10 +98,31 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
             // package private methods.
             return true;
         }
+        if (hasNonPublicTypeReference(features.mockedType)) {
+            return true;
+        }
+
         for (Class<?> iface : features.interfaces) {
             if (!Modifier.isPublic(iface.getModifiers())) {
                 return true;
             }
+            if (hasNonPublicTypeReference(iface)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static boolean hasNonPublicTypeReference(Class<?> iface) {
+        for (Method method : iface.getMethods()) {
+            if (!Modifier.isPublic(method.getReturnType().getModifiers())) {
+                return true;
+            }
+            for (Class<?> param : method.getParameterTypes()) {
+                if (!Modifier.isPublic(param.getModifiers())) {
+                    return true;
+                }
+            }
         }
         return false;
     }
diff --git a/src/main/java/org/mockito/internal/matchers/ContainsExtraTypeInfo.java b/src/main/java/org/mockito/internal/matchers/ContainsExtraTypeInfo.java
index 8c698fdcc..3b69fbcf9 100644
--- a/src/main/java/org/mockito/internal/matchers/ContainsExtraTypeInfo.java
+++ b/src/main/java/org/mockito/internal/matchers/ContainsExtraTypeInfo.java
@@ -9,25 +9,18 @@ package org.mockito.internal.matchers;
  * When ArgumentMatcher fails, chance is that the actual object has the same output of toString() than
  * the wanted object. This looks weird when failures are reported.
  * Therefore when matcher fails but toString() yields the same outputs,
- * we will try to use the {@link #toStringWithType(String)} method.
+ * we will try to use the {@link #toStringWithType()} method.
  */
 public interface ContainsExtraTypeInfo {
 
     /**
-     * @param className - name of the class to be printed in description
      * Returns more verbose description of the object which include type information
      */
-    String toStringWithType(String className);
+    String toStringWithType();
 
     /**
      * Checks if target target has matching type.
-     * If the type matches, there is no point in rendering result from {@link #toStringWithType(String)}
+     * If the type matches, there is no point in rendering result from {@link #toStringWithType()}
      */
     boolean typeMatches(Object target);
-
-    /**
-     *
-     * @return Returns the wanted argument
-     */
-    Object getWanted();
 }
diff --git a/src/main/java/org/mockito/internal/matchers/Equals.java b/src/main/java/org/mockito/internal/matchers/Equals.java
index 8b07b2da7..d04131d41 100644
--- a/src/main/java/org/mockito/internal/matchers/Equals.java
+++ b/src/main/java/org/mockito/internal/matchers/Equals.java
@@ -31,8 +31,7 @@ public class Equals implements ArgumentMatcher<Object>, ContainsExtraTypeInfo, S
         return ValuePrinter.print(object);
     }
 
-    @Override
-    public final Object getWanted() {
+    protected final Object getWanted() {
         return wanted;
     }
 
@@ -52,8 +51,8 @@ public class Equals implements ArgumentMatcher<Object>, ContainsExtraTypeInfo, S
     }
 
     @Override
-    public String toStringWithType(String className) {
-        return "(" + className + ") " + describe(wanted);
+    public String toStringWithType() {
+        return "(" + wanted.getClass().getSimpleName() + ") " + describe(wanted);
     }
 
     @Override
diff --git a/src/main/java/org/mockito/internal/matchers/text/MatchersPrinter.java b/src/main/java/org/mockito/internal/matchers/text/MatchersPrinter.java
index 9ceab3975..589b072ed 100644
--- a/src/main/java/org/mockito/internal/matchers/text/MatchersPrinter.java
+++ b/src/main/java/org/mockito/internal/matchers/text/MatchersPrinter.java
@@ -30,25 +30,8 @@ public class MatchersPrinter {
         List<FormattedText> out = new LinkedList<>();
         int i = 0;
         for (final ArgumentMatcher matcher : matchers) {
-            if (matcher instanceof ContainsExtraTypeInfo) {
-                ContainsExtraTypeInfo typeInfoMatcher = (ContainsExtraTypeInfo) matcher;
-                Object wanted = typeInfoMatcher.getWanted();
-                String simpleNameOfArgument =
-                        wanted != null ? wanted.getClass().getSimpleName() : "";
-                String fullyQualifiedClassName =
-                        wanted != null ? wanted.getClass().getCanonicalName() : "";
-
-                if (printSettings.extraTypeInfoFor(i)) {
-                    out.add(
-                            new FormattedText(
-                                    typeInfoMatcher.toStringWithType(simpleNameOfArgument)));
-                } else if (printSettings.fullyQualifiedNameFor(simpleNameOfArgument)) {
-                    out.add(
-                            new FormattedText(
-                                    typeInfoMatcher.toStringWithType(fullyQualifiedClassName)));
-                } else {
-                    out.add(new FormattedText(MatcherToString.toString(matcher)));
-                }
+            if (matcher instanceof ContainsExtraTypeInfo && printSettings.extraTypeInfoFor(i)) {
+                out.add(new FormattedText(((ContainsExtraTypeInfo) matcher).toStringWithType()));
             } else {
                 out.add(new FormattedText(MatcherToString.toString(matcher)));
             }
diff --git a/src/main/java/org/mockito/internal/reporting/PrintSettings.java b/src/main/java/org/mockito/internal/reporting/PrintSettings.java
index 41794adcb..2869ed316 100644
--- a/src/main/java/org/mockito/internal/reporting/PrintSettings.java
+++ b/src/main/java/org/mockito/internal/reporting/PrintSettings.java
@@ -5,10 +5,8 @@
 package org.mockito.internal.reporting;
 
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Set;
 
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.matchers.text.MatchersPrinter;
@@ -21,7 +19,6 @@ public class PrintSettings {
     public static final int MAX_LINE_LENGTH = 45;
     private boolean multiline;
     private List<Integer> withTypeInfo = new LinkedList<>();
-    private Set<String> withFullyQualifiedName = Collections.emptySet();
 
     public void setMultiline(boolean multiline) {
         this.multiline = multiline;
@@ -41,18 +38,10 @@ public class PrintSettings {
         return withTypeInfo.contains(argumentIndex);
     }
 
-    public boolean fullyQualifiedNameFor(String simpleClassName) {
-        return withFullyQualifiedName.contains(simpleClassName);
-    }
-
     public void setMatchersToBeDescribedWithExtraTypeInfo(Integer[] indexesOfMatchers) {
         this.withTypeInfo = Arrays.asList(indexesOfMatchers);
     }
 
-    public void setMatchersToBeDescribedWithFullName(Set<String> indexesOfMatchers) {
-        this.withFullyQualifiedName = indexesOfMatchers;
-    }
-
     public String print(List<ArgumentMatcher> matchers, Invocation invocation) {
         MatchersPrinter matchersPrinter = new MatchersPrinter();
         String qualifiedName =
diff --git a/src/main/java/org/mockito/internal/reporting/SmartPrinter.java b/src/main/java/org/mockito/internal/reporting/SmartPrinter.java
index f4b1f71d4..71a7c369a 100644
--- a/src/main/java/org/mockito/internal/reporting/SmartPrinter.java
+++ b/src/main/java/org/mockito/internal/reporting/SmartPrinter.java
@@ -7,7 +7,6 @@ package org.mockito.internal.reporting;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.Set;
 
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.MatchableInvocation;
@@ -29,20 +28,17 @@ public class SmartPrinter {
         this(
                 wanted,
                 Collections.singletonList(actual),
-                indexesOfMatchersToBeDescribedWithExtraTypeInfo,
-                Collections.emptySet());
+                indexesOfMatchersToBeDescribedWithExtraTypeInfo);
     }
 
     public SmartPrinter(
             MatchableInvocation wanted,
             List<Invocation> allActualInvocations,
-            Integer[] indexesOfMatchersToBeDescribedWithExtraTypeInfo,
-            Set<String> classNamesToBeDescribedWithFullName) {
+            Integer... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {
         PrintSettings printSettings = new PrintSettings();
         printSettings.setMultiline(isMultiLine(wanted, allActualInvocations));
         printSettings.setMatchersToBeDescribedWithExtraTypeInfo(
                 indexesOfMatchersToBeDescribedWithExtraTypeInfo);
-        printSettings.setMatchersToBeDescribedWithFullName(classNamesToBeDescribedWithFullName);
 
         this.wanted = printSettings.print(wanted);
 
diff --git a/src/main/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/main/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java
index 060ea0913..f13d98065 100644
--- a/src/main/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java
+++ b/src/main/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java
@@ -4,13 +4,8 @@
  */
 package org.mockito.internal.verification.argumentmatching;
 
-import java.util.HashMap;
-import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.stream.Collectors;
 
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.matchers.ContainsExtraTypeInfo;
@@ -53,37 +48,4 @@ public class ArgumentMatchingTool {
     private static boolean toStringEquals(ArgumentMatcher m, Object arg) {
         return m.toString().equals(String.valueOf(arg));
     }
-
-    /**
-     * Suspiciously not matching arguments are those that don't match, and the classes have same simple name.
-     */
-    public static Set<String> getNotMatchingArgsWithSameName(
-            List<ArgumentMatcher> matchers, Object[] arguments) {
-        Map<String, Set<String>> classesHavingSameName = new HashMap<>();
-        for (ArgumentMatcher m : matchers) {
-            if (m instanceof ContainsExtraTypeInfo) {
-                Object wanted = ((ContainsExtraTypeInfo) m).getWanted();
-                if (wanted == null) {
-                    continue;
-                }
-                Class wantedClass = wanted.getClass();
-                classesHavingSameName
-                        .computeIfAbsent(wantedClass.getSimpleName(), className -> new HashSet<>())
-                        .add(wantedClass.getCanonicalName());
-            }
-        }
-        for (Object argument : arguments) {
-            if (argument == null) {
-                continue;
-            }
-            Class wantedClass = argument.getClass();
-            classesHavingSameName
-                    .computeIfAbsent(wantedClass.getSimpleName(), className -> new HashSet<>())
-                    .add(wantedClass.getCanonicalName());
-        }
-        return classesHavingSameName.entrySet().stream()
-                .filter(classEntry -> classEntry.getValue().size() > 1)
-                .map(classEntry -> classEntry.getKey())
-                .collect(Collectors.toSet());
-    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
index aeb86b962..e34555621 100644
--- a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
+++ b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
@@ -11,11 +11,9 @@ import static org.mockito.internal.invocation.InvocationsFinder.findAllMatchingU
 import static org.mockito.internal.invocation.InvocationsFinder.findInvocations;
 import static org.mockito.internal.invocation.InvocationsFinder.findPreviousVerifiedInOrder;
 import static org.mockito.internal.invocation.InvocationsFinder.findSimilarInvocation;
-import static org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getNotMatchingArgsWithSameName;
 import static org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes;
 
 import java.util.List;
-import java.util.Set;
 
 import org.mockito.internal.reporting.SmartPrinter;
 import org.mockito.internal.util.collections.ListUtil;
@@ -43,11 +41,7 @@ public class MissingInvocationChecker {
 
         Integer[] indexesOfSuspiciousArgs =
                 getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());
-        Set<String> classesWithSameSimpleName =
-                getNotMatchingArgsWithSameName(wanted.getMatchers(), similar.getArguments());
-        SmartPrinter smartPrinter =
-                new SmartPrinter(
-                        wanted, invocations, indexesOfSuspiciousArgs, classesWithSameSimpleName);
+        SmartPrinter smartPrinter = new SmartPrinter(wanted, invocations, indexesOfSuspiciousArgs);
         List<Location> actualLocations =
                 ListUtil.convert(
                         invocations,
diff --git a/src/test/java/org/mockito/internal/matchers/EqualsTest.java b/src/test/java/org/mockito/internal/matchers/EqualsTest.java
index ba5c578b5..26f87c2db 100644
--- a/src/test/java/org/mockito/internal/matchers/EqualsTest.java
+++ b/src/test/java/org/mockito/internal/matchers/EqualsTest.java
@@ -28,21 +28,21 @@ public class EqualsTest extends TestBase {
 
     @Test
     public void shouldDescribeWithExtraTypeInfo() throws Exception {
-        String descStr = new Equals(100).toStringWithType(Integer.class.getSimpleName());
+        String descStr = new Equals(100).toStringWithType();
 
         assertEquals("(Integer) 100", descStr);
     }
 
     @Test
     public void shouldDescribeWithExtraTypeInfoOfLong() throws Exception {
-        String descStr = new Equals(100L).toStringWithType(Long.class.getSimpleName());
+        String descStr = new Equals(100L).toStringWithType();
 
         assertEquals("(Long) 100L", descStr);
     }
 
     @Test
     public void shouldDescribeWithTypeOfString() throws Exception {
-        String descStr = new Equals("x").toStringWithType(String.class.getSimpleName());
+        String descStr = new Equals("x").toStringWithType();
 
         assertEquals("(String) \"x\"", descStr);
     }
diff --git a/src/test/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java b/src/test/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java
index 5f55faf3b..d54c7f4cb 100644
--- a/src/test/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java
+++ b/src/test/java/org/mockito/internal/verification/argumentmatching/ArgumentMatchingToolTest.java
@@ -111,7 +111,7 @@ public class ArgumentMatchingToolTest extends TestBase {
             }
 
             @Override
-            public String toStringWithType(String className) {
+            public String toStringWithType() {
                 return "";
             }
 
@@ -119,11 +119,6 @@ public class ArgumentMatchingToolTest extends TestBase {
             public boolean typeMatches(Object target) {
                 return true;
             }
-
-            @Override
-            public Object getWanted() {
-                return "";
-            }
         }
 
         // given
diff --git a/src/test/java/org/mockitousage/IMethods.java b/src/test/java/org/mockitousage/IMethods.java
index 12897422d..5a12b47ba 100644
--- a/src/test/java/org/mockitousage/IMethods.java
+++ b/src/test/java/org/mockitousage/IMethods.java
@@ -238,52 +238,4 @@ public interface IMethods {
     String forObject(Object object);
 
     <T> String genericToString(T arg);
-
-    void overloadedMethodWithSameClassNameArguments(java.sql.Date javaDate, Date date);
-
-    void overloadedMethodWithSameClassNameArguments(Date date, java.sql.Date javaDate);
-
-    void overloadedMethodWithDifferentClassNameArguments(String String, Integer i);
-
-    void overloadedMethodWithDifferentClassNameArguments(Integer i, String string);
-
-    void overloadedMethodWithSameClassNameArguments(
-            java.sql.Date javaDate, String string, Date date);
-
-    void overloadedMethodWithSameClassNameArguments(
-            Date date, String string, java.sql.Date javaDate);
-
-    /**
-     * Using this class to test cases where two classes have same simple name
-     */
-    public static class Date {
-
-        private int value;
-
-        public Date(int value) {
-            this.value = value;
-        }
-
-        @Override
-        public String toString() {
-            return String.valueOf(value);
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) {
-                return true;
-            }
-            if (o == null || getClass() != o.getClass()) {
-                return false;
-            }
-            Date date = (Date) o;
-            return value == date.value;
-        }
-
-        @Override
-        public int hashCode() {
-            return Objects.hash(value);
-        }
-    }
 }
diff --git a/src/test/java/org/mockitousage/MethodsImpl.java b/src/test/java/org/mockitousage/MethodsImpl.java
index bb6965671..eafb91b09 100644
--- a/src/test/java/org/mockitousage/MethodsImpl.java
+++ b/src/test/java/org/mockitousage/MethodsImpl.java
@@ -448,24 +448,4 @@ public class MethodsImpl implements IMethods {
     public <T> String genericToString(T arg) {
         return null;
     }
-
-    @Override
-    public void overloadedMethodWithSameClassNameArguments(java.sql.Date javaDate, Date date) {}
-
-    @Override
-    public void overloadedMethodWithSameClassNameArguments(Date date, java.sql.Date javaDate) {}
-
-    @Override
-    public void overloadedMethodWithDifferentClassNameArguments(String string, Integer i) {}
-
-    @Override
-    public void overloadedMethodWithDifferentClassNameArguments(Integer i, String string) {}
-
-    @Override
-    public void overloadedMethodWithSameClassNameArguments(
-            java.sql.Date javaDate, String string, Date date) {}
-
-    @Override
-    public void overloadedMethodWithSameClassNameArguments(
-            Date date, String string, java.sql.Date javaDate) {}
 }
diff --git a/src/test/java/org/mockitousage/bugs/creation/PackagePrivateWithContextClassLoaderTest.java b/src/test/java/org/mockitousage/bugs/creation/PackagePrivateWithContextClassLoaderTest.java
index 4f6ffbee1..95095f32f 100644
--- a/src/test/java/org/mockitousage/bugs/creation/PackagePrivateWithContextClassLoaderTest.java
+++ b/src/test/java/org/mockitousage/bugs/creation/PackagePrivateWithContextClassLoaderTest.java
@@ -31,10 +31,24 @@ public class PackagePrivateWithContextClassLoaderTest {
         abstract void packagePrivateAbstractMethod();
     }
 
+    public interface PublicInterfaceWithPackagePrivateMethodParam {
+        void doSomething(PackagePrivateInterface i);
+    }
+
+    public interface PublicInterfaceWithPackagePrivateMethodReturn {
+        PackagePrivateInterface doSomething();
+    }
+
+    public interface PublicInterfaceOverridesPackagePrivateMethodReturn {
+        PublicChildOfPackagePrivate doSomething();
+    }
+
     public interface PublicInterface {}
 
     interface PackagePrivateInterface {}
 
+    public interface PublicChildOfPackagePrivate extends PackagePrivateInterface {}
+
     static class PackagePrivateClass {}
 
     @Before
@@ -55,6 +69,28 @@ public class PackagePrivateWithContextClassLoaderTest {
         assertThat(publicClass.packagePrivateMethod()).isEqualTo(3);
     }
 
+    @Test
+    public void should_be_able_to_mock_interface_method_package_private_param() throws Exception {
+        PublicInterfaceWithPackagePrivateMethodParam publicClass =
+                mock(PublicInterfaceWithPackagePrivateMethodParam.class);
+        publicClass.doSomething(null);
+    }
+
+    @Test
+    public void should_be_able_to_mock_interface_method_package_private_return() throws Exception {
+        PublicInterfaceWithPackagePrivateMethodReturn publicClass =
+                mock(PublicInterfaceWithPackagePrivateMethodReturn.class);
+        PackagePrivateInterface packagePrivateInterface = publicClass.doSomething();
+    }
+
+    @Test
+    public void should_be_able_to_mock_interface_method_package_private_return_override()
+            throws Exception {
+        PublicInterfaceOverridesPackagePrivateMethodReturn publicClass =
+                mock(PublicInterfaceOverridesPackagePrivateMethodReturn.class);
+        PackagePrivateInterface packagePrivateInterface = publicClass.doSomething();
+    }
+
     @Test
     public void should_be_able_to_mock_package_private_class() throws Exception {
         PackagePrivateClass mock = mock(PackagePrivateClass.class);
diff --git a/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java b/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java
index 94f660284..f0350f93c 100644
--- a/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java
+++ b/src/test/java/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java
@@ -9,8 +9,6 @@ import static org.junit.Assert.fail;
 import static org.mockito.AdditionalMatchers.aryEq;
 import static org.mockito.Mockito.*;
 
-import java.sql.Date;
-
 import org.junit.Before;
 import org.junit.Ignore;
 import org.junit.Test;
@@ -388,124 +386,6 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
         }
     }
 
-    @Test
-    public void should_print_fully_qualified_name_when_arguments_classes_have_same_simple_name() {
-        try {
-            mock.overloadedMethodWithSameClassNameArguments(new Date(0), new IMethods.Date(0));
-            verify(mock)
-                    .overloadedMethodWithSameClassNameArguments(new IMethods.Date(0), new Date(0));
-            fail();
-        } catch (Throwable e) {
-            String wanted =
-                    "\n"
-                            + "Argument(s) are different! Wanted:"
-                            + "\n"
-                            + "iMethods.overloadedMethodWithSameClassNameArguments("
-                            + "\n"
-                            + "    (org.mockitousage.IMethods.Date) 0,"
-                            + "\n"
-                            + "    (java.sql.Date) 1970-01-01"
-                            + "\n"
-                            + ");";
-
-            assertThat(e).hasMessageContaining(wanted);
-
-            String actual =
-                    "\n"
-                            + "Actual invocations have different arguments:"
-                            + "\n"
-                            + "iMethods.overloadedMethodWithSameClassNameArguments("
-                            + "\n"
-                            + "    (java.sql.Date) 1970-01-01,"
-                            + "\n"
-                            + "    (org.mockitousage.IMethods.Date) 0"
-                            + "\n"
-                            + ");";
-            assertThat(e).hasMessageContaining(actual);
-        }
-    }
-
-    @Test
-    public void
-            should_not_print_fully_qualified_name_when_arguments_classes_have_different_simple_name() {
-        try {
-            mock.overloadedMethodWithDifferentClassNameArguments("string", 0);
-            verify(mock).overloadedMethodWithDifferentClassNameArguments(0, "string");
-            fail();
-        } catch (Throwable e) {
-            String wanted =
-                    "\n"
-                            + "Argument(s) are different! Wanted:"
-                            + "\n"
-                            + "iMethods.overloadedMethodWithDifferentClassNameArguments("
-                            + "\n"
-                            + "    0,"
-                            + "\n"
-                            + "    \"string\""
-                            + "\n"
-                            + ");";
-
-            assertThat(e).hasMessageContaining(wanted);
-
-            String actual =
-                    "\n"
-                            + "Actual invocations have different arguments:"
-                            + "\n"
-                            + "iMethods.overloadedMethodWithDifferentClassNameArguments("
-                            + "\n"
-                            + "    \"string\","
-                            + "\n"
-                            + "    0"
-                            + "\n"
-                            + ");";
-            assertThat(e).hasMessageContaining(actual);
-        }
-    }
-
-    @Test
-    public void
-            should_print_fully_qualified_name_when_some_arguments_classes_have_same_simple_name() {
-        try {
-            mock.overloadedMethodWithSameClassNameArguments(
-                    new Date(0), "string", new IMethods.Date(0));
-            verify(mock)
-                    .overloadedMethodWithSameClassNameArguments(
-                            new IMethods.Date(0), "string", new Date(0));
-            fail();
-        } catch (Throwable e) {
-            String wanted =
-                    "\n"
-                            + "Argument(s) are different! Wanted:"
-                            + "\n"
-                            + "iMethods.overloadedMethodWithSameClassNameArguments("
-                            + "\n"
-                            + "    (org.mockitousage.IMethods.Date) 0,"
-                            + "\n"
-                            + "    \"string\","
-                            + "\n"
-                            + "    (java.sql.Date) 1970-01-01"
-                            + "\n"
-                            + ");";
-
-            assertThat(e).hasMessageContaining(wanted);
-
-            String actual =
-                    "\n"
-                            + "Actual invocations have different arguments:"
-                            + "\n"
-                            + "iMethods.overloadedMethodWithSameClassNameArguments("
-                            + "\n"
-                            + "    (java.sql.Date) 1970-01-01,"
-                            + "\n"
-                            + "    \"string\","
-                            + "\n"
-                            + "    (org.mockitousage.IMethods.Date) 0"
-                            + "\n"
-                            + ");";
-            assertThat(e).hasMessageContaining(actual);
-        }
-    }
-
     @Test
     @Ignore("issue 380 related")
     public void should_print_method_name_and_arguments_of_other_interactions_of_same_method()
