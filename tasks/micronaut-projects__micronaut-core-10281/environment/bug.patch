diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/ConstructorElement.java b/core-processor/src/main/java/io/micronaut/inject/ast/ConstructorElement.java
index 4ac2176019..9fa039961e 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/ConstructorElement.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/ConstructorElement.java
@@ -41,11 +41,6 @@ public interface ConstructorElement extends MethodElement {
         return false;
     }
 
-    @Override
-    default boolean hides(MethodElement hiddenMethod) {
-        return false;
-    }
-
     @Override
     default boolean overrides(MethodElement overridden) {
         return false;
diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java b/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java
index 8c85366b24..026b75dfc3 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java
@@ -76,7 +76,17 @@ public interface MemberElement extends Element {
      * @since 3.4.0
      */
     default boolean isReflectionRequired(@NonNull ClassElement callingType) {
-        return !isAccessible(callingType, false);
+        if (isPublic()) {
+            return false;
+        }
+        if (isPackagePrivate() || isProtected()) {
+            // the declaring type might be a super class in which
+            // case if the super class is in a different package then
+            // the method or field is not visible and hence reflection is required
+            final ClassElement declaringType = getDeclaringType();
+            return !declaringType.getPackageName().equals(callingType.getPackageName());
+        }
+        return isPrivate();
     }
 
     /**
@@ -94,61 +104,6 @@ public interface MemberElement extends Element {
         return isAccessible(getOwningType());
     }
 
-    /**
-     * Returns whether this member element can be invoked or retrieved at runtime.
-     * It can be accessible by a simple invocation
-     *
-     * <p>This method uses {@link #isReflectionRequired()} with a checks if the reflection access is allowed.
-     * By checking for {@link io.micronaut.core.annotation.ReflectiveAccess} annotation.
-     * </p>
-     *
-     * @param callingType The calling type
-     * @param allowReflection If reflection invocation can be used
-     * @return Will return {@code true} if is accessible.
-     * @since 4.3.0
-     */
-    default boolean isAccessible(@NonNull ClassElement callingType, boolean allowReflection) {
-        if (isPublic()) {
-            return true;
-        }
-        if (isProtected()) {
-            // the declaring type might be a super class in which
-            // case if the super class is in a different package then
-            // the method or field is not visible and hence reflection is required
-            final ClassElement declaringType = getDeclaringType();
-            String packageName = declaringType.getPackageName();
-            if (!packageName.equals(callingType.getPackageName())) {
-                return allowReflection && hasAnnotation(ReflectiveAccess.class);
-            }
-            return true;
-        }
-        if (isPackagePrivate()) {
-            // the declaring type might be a super class in which
-            // case if the super class is in a different package then
-            // the method or field is not visible and hence reflection is required
-            final ClassElement declaringType = getDeclaringType();
-            String packageName = declaringType.getPackageName();
-            if (!packageName.equals(callingType.getPackageName())) {
-                return allowReflection && hasAnnotation(ReflectiveAccess.class);
-            }
-            if (isPackagePrivate()) {
-                // Check if there is a subtype that breaks the package friendship
-                ClassElement superClass = getOwningType();
-                while (superClass != null && !superClass.equals(declaringType)) {
-                    if (!packageName.equals(superClass.getPackageName())) {
-                        return allowReflection && hasAnnotation(ReflectiveAccess.class);
-                    }
-                    superClass = superClass.getSuperType().orElse(null);
-                }
-            }
-            return true;
-        }
-        if (isPrivate()) {
-            return allowReflection && hasAnnotation(ReflectiveAccess.class);
-        }
-        return true;
-    }
-
     /**
      * Returns whether this member element can be invoked or retrieved at runtime.
      * It can be accessible by a simple invocation or a reflection invocation.
@@ -162,7 +117,7 @@ public interface MemberElement extends Element {
      * @since 3.7.0
      */
     default boolean isAccessible(@NonNull ClassElement callingType) {
-        return isAccessible(callingType, true);
+        return !isReflectionRequired(callingType) || hasAnnotation(ReflectiveAccess.class);
     }
 
     @Override
diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/MethodElement.java b/core-processor/src/main/java/io/micronaut/inject/ast/MethodElement.java
index 7498392ea0..c4764c8bad 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/MethodElement.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/MethodElement.java
@@ -20,7 +20,6 @@ import io.micronaut.core.annotation.AnnotationMetadataProvider;
 import io.micronaut.core.annotation.AnnotationValue;
 import io.micronaut.core.annotation.AnnotationValueBuilder;
 import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.NextMajorVersion;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.util.ArgumentUtils;
@@ -267,83 +266,84 @@ public interface MethodElement extends MemberElement {
      * @return true if this overrides passed method element
      * @since 3.1
      */
-    @NextMajorVersion("Review the package-private methods with broken access, those might need to be excluded completely")
     default boolean overrides(@NonNull MethodElement overridden) {
-        if (equals(overridden) || isStatic() || overridden.isStatic() || isPrivate() || overridden.isPrivate()) {
+        if (this.equals(overridden) || isStatic() || overridden.isStatic()) {
             return false;
         }
-        if (!isSubSignature(overridden)) {
+        ClassElement thisType = getDeclaringType();
+        ClassElement thatType = overridden.getDeclaringType();
+        if (thisType.getName().equals(thatType.getName())) {
+            return false;
+        }
+        if (!thisType.isAssignable(thatType)) {
+            // not a parent class
             return false;
         }
         MethodElement newMethod = this;
         if (newMethod.isAbstract() && !newMethod.isDefault() && (!overridden.isAbstract() || overridden.isDefault())) {
             return false;
         }
-        if (isPackagePrivate() && overridden.isPackagePrivate()) {
-            // This is a special case for identical package-private methods from the same package
-            // if the package is changed in the subclass in between; by Java rules those methods aren't overridden
-            // But this kind of non-overridden method in the subclass CANNOT be called by the reflection,
-            // it will always call the subclass method!
-            // In Micronaut 4 we mark this method as overridden, in the future we might want to exclude them completely
-            if (!getDeclaringType().getPackageName().equals(overridden.getDeclaringType().getPackageName())) {
+        if (!newMethod.getName().equals(overridden.getName()) || overridden.getParameters().length != newMethod.getParameters().length) {
+            return false;
+        }
+        for (int i = 0; i < overridden.getParameters().length; i++) {
+            ParameterElement existingParameter = overridden.getParameters()[i];
+            ParameterElement newParameter = newMethod.getParameters()[i];
+            ClassElement existingType = existingParameter.getGenericType();
+            ClassElement newType = newParameter.getGenericType();
+            if (!newType.isAssignable(existingType)) {
                 return false;
             }
         }
-        // Check if a parent class
-        return getDeclaringType().isAssignable(overridden.getDeclaringType());
-    }
-
-    @Override
-    default boolean hides(@NonNull MemberElement memberElement) {
-        if (memberElement instanceof MethodElement hidden) {
-            return hides(hidden);
-        }
-        return false;
-    }
-
-    /**
-     * Checks if this member element hides another.
-     *
-     * @param hiddenMethod The possibly hidden method
-     * @return true if this member element hides passed field element
-     * @since 4.3.0
-     */
-    default boolean hides(@NonNull MethodElement hiddenMethod) {
-        if (equals(hiddenMethod) || isStatic() || hiddenMethod.isStatic() || hiddenMethod.isPrivate()) {
+        ClassElement existingReturnType = overridden.getReturnType().getGenericType();
+        ClassElement newTypeReturn = newMethod.getReturnType().getGenericType();
+        if (!newTypeReturn.isAssignable(existingReturnType)) {
             return false;
         }
-        if (!isSubSignature(hiddenMethod)) {
+        // Cannot override existing private/package private methods even if the signature is the same
+        if (overridden.isPrivate()) {
             return false;
         }
-        if (!getDeclaringType().isAssignable(hiddenMethod.getDeclaringType())) {
-            // not a parent class
-            return false;
+        if (overridden.isPackagePrivate()) {
+            return newMethod.getDeclaringType().getPackageName().equals(overridden.getDeclaringType().getPackageName());
         }
-        if (hiddenMethod.isPackagePrivate()) {
-            return getDeclaringType().getPackageName().equals(hiddenMethod.getDeclaringType().getPackageName());
-        }
-        return hiddenMethod.isAccessible(getDeclaringType(), false);
+        return true;
     }
 
-    /**
-     * Is this method a sub signature of another.
-     * @param element The other method
-     * @return true if a sub signature
-     * @since 4.3.0
-     */
-    default boolean isSubSignature(MethodElement element) {
-        if (!getName().equals(element.getName()) || element.getParameters().length != this.getParameters().length) {
-            return false;
-        }
-        for (int i = 0; i < element.getParameters().length; i++) {
-            ParameterElement existingParameter = element.getParameters()[i];
-            ParameterElement newParameter = getParameters()[i];
-            ClassElement existingType = existingParameter.getGenericType();
-            if (!newParameter.getGenericType().isAssignable(existingType)) {
+    @Override
+    default boolean hides(@NonNull MemberElement memberElement) {
+        if (memberElement instanceof MethodElement hidden) {
+            if (equals(hidden) || isStatic() || hidden.isStatic() || hidden.isPrivate()) {
                 return false;
             }
+            MethodElement newMethod = this;
+            if (!newMethod.getName().equals(hidden.getName()) || hidden.getParameters().length != newMethod.getParameters().length) {
+                return false;
+            }
+            for (int i = 0; i < hidden.getParameters().length; i++) {
+                ParameterElement existingParameter = hidden.getParameters()[i];
+                ParameterElement newParameter = newMethod.getParameters()[i];
+                ClassElement existingType = existingParameter.getGenericType();
+                ClassElement newType = newParameter.getGenericType();
+                if (!newType.isAssignable(existingType)) {
+                    return false;
+                }
+            }
+            if (!getDeclaringType().isAssignable(memberElement.getDeclaringType())) {
+                // not a parent class
+                return false;
+            }
+            ClassElement existingReturnType = hidden.getReturnType().getGenericType();
+            ClassElement newTypeReturn = newMethod.getReturnType().getGenericType();
+            if (!newTypeReturn.isAssignable(existingReturnType)) {
+                return false;
+            }
+            if (hidden.isPackagePrivate()) {
+                return newMethod.getDeclaringType().getPackageName().equals(hidden.getDeclaringType().getPackageName());
+            }
+            return memberElement.isAccessible(getDeclaringType());
         }
-        return getReturnType().getGenericType().isAssignable(element.getReturnType().getGenericType());
+        return false;
     }
 
     /**
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaMethodElement.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaMethodElement.java
index 9aef0d2deb..98ca59b230 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaMethodElement.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaMethodElement.java
@@ -22,6 +22,7 @@ import io.micronaut.core.util.ArrayUtils;
 import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.inject.ast.ClassElement;
 import io.micronaut.inject.ast.GenericPlaceholderElement;
+import io.micronaut.inject.ast.MemberElement;
 import io.micronaut.inject.ast.MethodElement;
 import io.micronaut.inject.ast.ParameterElement;
 import io.micronaut.inject.ast.PrimitiveElement;
@@ -35,7 +36,6 @@ import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.type.WildcardType;
@@ -162,43 +162,28 @@ public class JavaMethodElement extends AbstractJavaElement implements MethodElem
 
     @Override
     public boolean overrides(MethodElement overridden) {
-        if (equals(overridden) || isStatic() || overridden.isStatic() || isPrivate() || overridden.isPrivate()) {
+        if (this.equals(overridden) || isStatic() || overridden.isStatic()) {
             return false;
         }
         if (overridden instanceof JavaMethodElement javaMethodElement) {
-            if (isPackagePrivate() && overridden.isPackagePrivate()) {
-                // Test special case of the default methods
-                return MethodElement.super.overrides(overridden);
-            }
-            return visitorContext.getElements().overrides(
+            boolean overrides = visitorContext.getElements().overrides(
                 executableElement,
                 javaMethodElement.executableElement,
                 owningType.classElement
             );
+            if (overrides) {
+                return true;
+            }
         }
         return MethodElement.super.overrides(overridden);
     }
 
     @Override
-    public boolean isSubSignature(MethodElement element) {
-        if (element instanceof JavaMethodElement javaMethodElement) {
-            return visitorContext.getTypes().isSubsignature(
-                    (ExecutableType) executableElement.asType(),
-                    (ExecutableType) javaMethodElement.executableElement.asType()
-            );
-        }
-        return MethodElement.super.isSubSignature(element);
-    }
-
-    @Override
-    public boolean hides(MethodElement hiddenMethod) {
+    public boolean hides(MemberElement hidden) {
         if (isStatic() && getDeclaringType().isInterface()) {
             return false;
         }
-        if (hiddenMethod instanceof JavaMethodElement javaMethodElement) {
-            return visitorContext.getElements().hides(getNativeType().element(), javaMethodElement.getNativeType().element());
-        }
-        return MethodElement.super.hides(hiddenMethod);
+        return visitorContext.getElements().hides(getNativeType().element(), ((JavaNativeElement.Method) hidden.getNativeType()).element());
     }
 
     @NonNull
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/beans/BeanDefinitionSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/beans/BeanDefinitionSpec.groovy
index b43447f1a3..f2973776b1 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/beans/BeanDefinitionSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/beans/BeanDefinitionSpec.groovy
@@ -10,7 +10,6 @@ import io.micronaut.core.type.GenericPlaceholder
 import io.micronaut.inject.BeanDefinition
 import io.micronaut.inject.qualifiers.Qualifiers
 import spock.lang.Issue
-import test.another.BeanWithPackagePrivate
 
 class BeanDefinitionSpec extends AbstractTypeElementSpec {
 
@@ -669,40 +668,6 @@ interface AInterface<K, V> {
             arguments[1].type == Long
     }
 
-    void "test package-private methods with different package are marked as overridden"() {
-        when:
-            def ctx = ApplicationContext.builder().build().start()
-            BeanDefinition definition = buildBeanDefinition('test.another.Test', '''
-package test.another;
-
-import test.Middle;
-import jakarta.inject.Singleton;
-
-@Singleton
-class Test extends Middle {
-    public boolean root;
-    void injectPackagePrivateMethod() {
-        root = true;
-    }
-}
-
-''')
-
-            def bean1 = ctx.getBean(BeanWithPackagePrivate)
-            def bean2 = ctx.getBean(definition)
-        then: """By Java rules the base method is not overriden and should have been injected too, but it's not possible to invoked using the reflection,
-so we mark it as overridden
-"""
-            !bean1.@root
-            bean1.@middle
-            !bean1.@base
-            !bean2.@root
-            bean2.@middle
-            !bean2.@base
-        cleanup:
-            ctx.close()
-    }
-
     void "test repeatable inner type annotation 1"() {
         when:
             def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
diff --git a/inject-java/src/test/groovy/io/micronaut/visitors/ClassElementSpec.groovy b/inject-java/src/test/groovy/io/micronaut/visitors/ClassElementSpec.groovy
index d0fe0ec5a9..cf3f4b790b 100644
--- a/inject-java/src/test/groovy/io/micronaut/visitors/ClassElementSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/visitors/ClassElementSpec.groovy
@@ -48,27 +48,6 @@ import java.util.function.Supplier
 
 class ClassElementSpec extends AbstractTypeElementSpec {
 
-    void "test package-private methods with broken different package"() {
-        when:
-        ClassElement classElement = buildClassElement('''
-package test.another;
-
-import test.Middle;
-
-class Test extends Middle {
-   private boolean testInjected;
-    void injectPackagePrivateMethod() {
-        testInjected = true;
-    }
-}
-
-''')
-
-            def elements = classElement.getEnclosedElements(ElementQuery.ALL_METHODS)
-        then: "A special case for the indentical methods with package-private access and broken package access in between"
-            elements.size() == 2
-    }
-
     void "test class element generics"() {
         given:
         ClassElement classElement = buildClassElement('''
diff --git a/inject-java/src/test/java/test/Middle.java b/inject-java/src/test/java/test/Middle.java
deleted file mode 100644
index 91fd32b55a..0000000000
--- a/inject-java/src/test/java/test/Middle.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package test;
-
-import jakarta.inject.Inject;
-import test.another.Base;
-
-public class Middle extends Base {
-    public boolean middle;
-    @Inject
-    void injectPackagePrivateMethod() {
-        middle = true;
-    }
-}
diff --git a/inject-java/src/test/java/test/another/Base.java b/inject-java/src/test/java/test/another/Base.java
deleted file mode 100644
index 04fa09e7e0..0000000000
--- a/inject-java/src/test/java/test/another/Base.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package test.another;
-
-import jakarta.inject.Inject;
-
-public class Base {
-    public boolean base;
-    @Inject
-    void injectPackagePrivateMethod() {
-        base = true;
-    }
-}
diff --git a/inject-java/src/test/java/test/another/BeanWithPackagePrivate.java b/inject-java/src/test/java/test/another/BeanWithPackagePrivate.java
deleted file mode 100644
index f0fe56aa84..0000000000
--- a/inject-java/src/test/java/test/another/BeanWithPackagePrivate.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package test.another;
-
-import jakarta.inject.Singleton;
-import test.Middle;
-
-@Singleton
-public class BeanWithPackagePrivate extends Middle {
-    public boolean root;
-    void injectPackagePrivateMethod() {
-        root = true;
-    }
-}
diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinMethodElement.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinMethodElement.kt
index 896a060176..ab4b3889e2 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinMethodElement.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinMethodElement.kt
@@ -120,10 +120,6 @@ internal abstract class AbstractKotlinMethodElement<T : KotlinNativeElement>(
         // not sure how to implement this correctly for Kotlin
         false
 
-    override fun hides(hiddenMethod: MethodElement?) =
-        // not sure how to implement this correctly for Kotlin
-        false
-
     override fun getName() = name
 
     override fun getOwningType() = owningType
diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinPropertyAccessorMethodElement.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinPropertyAccessorMethodElement.kt
index 225442fb83..b0ddc9c6d0 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinPropertyAccessorMethodElement.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinPropertyAccessorMethodElement.kt
@@ -62,8 +62,4 @@ internal abstract class AbstractKotlinPropertyAccessorMethodElement<T : KotlinNa
         // not sure how to implement this correctly for Kotlin
         false
 
-    override fun hides(hiddenMethod: MethodElement?) =
-        // not sure how to implement this correctly for Kotlin
-        false
-
 }
diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinConstructorElement.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinConstructorElement.kt
index 0fd84f40c3..185f1cf94b 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinConstructorElement.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinConstructorElement.kt
@@ -50,10 +50,6 @@ internal class KotlinConstructorElement(
         return false
     }
 
-    override fun hides(hiddenMethod: MethodElement?): Boolean {
-        return false
-    }
-
     override fun getName() = "<init>"
 
     override fun getReturnType(): ClassElement = declaringType
