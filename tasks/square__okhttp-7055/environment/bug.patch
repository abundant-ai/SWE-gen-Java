diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2b9499b7b..0cf1b13a2 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -656,7 +656,7 @@ _2019-06-03_
  [kotlin_1_5_31]: https://github.com/JetBrains/kotlin/releases/tag/v1.5.31
  [kotlin_1_6_10]: https://github.com/JetBrains/kotlin/releases/tag/v1.6.10
  [legacy_interceptor]: https://gist.github.com/swankjesse/80135f4e03629527e723ab3bcf64be0b
- [okhttp4_blog_post]: https://cashapp.github.io/2019-06-26/okhttp-4-goes-kotlin
+ [okhttp4_blog_post]: https://code.cash.app/okhttp-4-goes-kotlin
  [okio.FileSystem]: https://square.github.io/okio/file_system/
  [okio_2_6_0]: https://square.github.io/okio/changelog/#version-260
  [okio_2_7_0]: https://square.github.io/okio/changelog/#version-270
diff --git a/build.gradle.kts b/build.gradle.kts
index 595013c04..590a3e3e8 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -205,6 +205,9 @@ subprojects {
         packageListUrl.set(URL("https://square.github.io/okio/2.x/okio/package-list"))
       }
     }
+    if (name == "dokkaGfm") {
+      outputDirectory.set(file("${rootDir}/docs/4.x"))
+    }
   }
 
   plugins.withId("com.vanniktech.maven.publish.base") {
diff --git a/deploy_website.sh b/deploy_website.sh
index 43fb0f485..70e0e57d5 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -4,7 +4,7 @@
 # https://squidfunk.github.io/mkdocs-material/
 # It requires Python to run.
 # Install the packages with the following command:
-# pip install mkdocs mkdocs-material
+# pip install mkdocs mkdocs-material mkdocs-redirects
 
 set -ex
 
@@ -16,20 +16,23 @@ rm -rf $DIR
 
 # Clone the current repo into temp folder
 git clone $REPO $DIR
+# Replace `git clone` with these lines to hack on the website locally
+# cp -a . "../okhttp-website"
+# mv "../okhttp-website" "$DIR"
 
 # Move working directory into temp folder
 cd $DIR
 
 # Generate the API docs
 ./gradlew \
-  :mockwebserver:dokka \
-  :okhttp-brotli:dokka \
-  :okhttp-dnsoverhttps:dokka \
-  :okhttp-logging-interceptor:dokka \
-  :okhttp-sse:dokka \
-  :okhttp-tls:dokka \
-  :okhttp-urlconnection:dokka \
-  :okhttp:dokka
+  :mockwebserver:dokkaGfm \
+  :okhttp-brotli:dokkaGfm \
+  :okhttp-dnsoverhttps:dokkaGfm \
+  :logging-interceptor:dokkaGfm \
+  :okhttp-sse:dokkaGfm \
+  :okhttp-tls:dokkaGfm \
+  :okhttp-urlconnection:dokkaGfm \
+  :okhttp:dokkaGfm
 
 # Dokka filenames like `-http-url/index.md` don't work well with MkDocs <title> tags.
 # Assign metadata to the file's first Markdown heading.
@@ -45,7 +48,7 @@ title_markdown_file() {
 }
 
 set +x
-for MARKDOWN_FILE in $(find docs/4.x/ -name '*.md'); do
+for MARKDOWN_FILE in $(find docs/4.x -name '*.md'); do
   echo $MARKDOWN_FILE
   title_markdown_file $MARKDOWN_FILE
 done
@@ -53,8 +56,8 @@ set -x
 
 # Copy in special files that GitHub wants in the project root.
 cat README.md | grep -v 'project website' > docs/index.md
-cp CHANGELOG.md docs/changelog.md
-cp CONTRIBUTING.md docs/contributing.md
+cp CHANGELOG.md docs/changelogs/changelog.md
+cp CONTRIBUTING.md docs/contribute/contributing.md
 
 # Build the site and push the new files up to GitHub
 mkdocs gh-deploy
diff --git a/docs/assets/css/app.css b/docs/assets/css/app.css
new file mode 100644
index 000000000..77da0b6d1
--- /dev/null
+++ b/docs/assets/css/app.css
@@ -0,0 +1,61 @@
+:root {
+  --external-link-icon: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 512 512'%3E%3Clink xmlns='' type='text/css' rel='stylesheet' id='dark-mode-custom-link'/%3E%3Clink xmlns='' type='text/css' rel='stylesheet' id='dark-mode-general-link'/%3E%3Cstyle xmlns='' lang='en' type='text/css' id='dark-mode-custom-style'/%3E%3Cstyle xmlns='' lang='en' type='text/css' id='dark-mode-native-style'/%3E%3Cpath d='M432 320h-32a16 16 0 0 0-16 16v112H64V128h144a16 16 0 0 0 16-16V80a16 16 0 0 0-16-16H48a48 48 0 0 0-48 48v352a48 48 0 0 0 48 48h352a48 48 0 0 0 48-48V336a16 16 0 0 0-16-16zM488 0H360c-21.37 0-32.05 25.91-17 41l35.73 35.73L135 320.37a24 24 0 0 0 0 34L157.67 377a24 24 0 0 0 34 0l243.61-243.68L471 169c15 15 41 4.5 41-17V24a24 24 0 0 0-24-24z'/%3E%3C/svg%3E");
+}
+
+@font-face {
+    font-family: cash-market;
+    src: url("https://cash-f.squarecdn.com/static/fonts/cash-market/v2/CashMarket-Regular.woff2") format("woff2");
+    font-weight: 400;
+    font-style: normal
+}
+
+@font-face {
+    font-family: cash-market;
+    src: url("https://cash-f.squarecdn.com/static/fonts/cash-market/v2/CashMarket-Medium.woff2") format("woff2");
+    font-weight: 500;
+    font-style: normal
+}
+
+@font-face {
+    font-family: cash-market;
+    src: url("https://cash-f.squarecdn.com/static/fonts/cash-market/v2/CashMarket-Bold.woff2") format("woff2");
+    font-weight: 700;
+    font-style: normal
+}
+
+body, input {
+    font-family: cash-market,"Helvetica Neue",helvetica,sans-serif;
+}
+
+.md-typeset h1, .md-typeset h2, .md-typeset h3, .md-typeset h4 {
+    font-family: cash-market,"Helvetica Neue",helvetica,sans-serif;
+    line-height: normal;
+    font-weight: bold;
+}
+
+button.dl {
+  font-weight: 300;
+  font-size: 25px;
+  line-height: 40px;
+  padding: 3px 10px;
+  display: inline-block;
+  border-radius: 6px;
+  color: #f0f0f0;
+  margin: 5px 0;
+  width: auto;
+}
+
+.logo {
+  text-align: center;
+  margin-top: 150px;
+}
+
+a[href^="http" ]:not(.md-social__link, .md-button, [data-sub-html], .md-footer-social__link, .md-source, .md-search-result__link, .md-logo, [href*="squidfunk.github.io"]):after {
+    background: transparent var(--external-link-icon) 0 0 no-repeat;
+    content: "";
+    display: inline-block;
+    height: 12px;
+    margin-left: 3px;
+    width: 12px;
+    filter: invert(1);
+}
\ No newline at end of file
diff --git a/docs/images/disable_advanced_profiling@2x.png b/docs/assets/images/disable_advanced_profiling@2x.png
similarity index 100%
rename from docs/images/disable_advanced_profiling@2x.png
rename to docs/assets/images/disable_advanced_profiling@2x.png
diff --git a/docs/images/events@2x.png b/docs/assets/images/events@2x.png
similarity index 100%
rename from docs/images/events@2x.png
rename to docs/assets/images/events@2x.png
diff --git a/docs/images/events_with_failures@2x.png b/docs/assets/images/events_with_failures@2x.png
similarity index 100%
rename from docs/images/events_with_failures@2x.png
rename to docs/assets/images/events_with_failures@2x.png
diff --git a/docs/images/events_with_failures_and_retries@2x.png b/docs/assets/images/events_with_failures_and_retries@2x.png
similarity index 100%
rename from docs/images/events_with_failures_and_retries@2x.png
rename to docs/assets/images/events_with_failures_and_retries@2x.png
diff --git a/docs/images/icon-square.png b/docs/assets/images/icon-square.png
similarity index 100%
rename from docs/images/icon-square.png
rename to docs/assets/images/icon-square.png
diff --git a/docs/images/interceptors@2x.png b/docs/assets/images/interceptors@2x.png
similarity index 100%
rename from docs/images/interceptors@2x.png
rename to docs/assets/images/interceptors@2x.png
diff --git a/docs/images/logo-square.png b/docs/assets/images/logo-square.png
similarity index 100%
rename from docs/images/logo-square.png
rename to docs/assets/images/logo-square.png
diff --git a/docs/changelogs/changelog.md b/docs/changelogs/changelog.md
new file mode 100644
index 000000000..90e29fd51
--- /dev/null
+++ b/docs/changelogs/changelog.md
@@ -0,0 +1,138 @@
+Change Log
+==========
+
+## Version 5.0.0-alpha.4
+
+_2022-02-01_
+
+**This release introduces fast fallback to better support mixed IPv4+IPv6 networks.** Fast fallback
+is what we're calling our implementation of Happy Eyeballs, [RFC 8305][rfc_8305]. With this
+feature OkHttp will attempt both IPv6 and IPv4 connections concurrently, keeping whichever connects
+first. Fast fallback gives IPv6 connections a 250 ms head start so IPv6 is preferred on networks
+where it's available.
+
+To opt-in, configure your `OkHttpClient.Builder`:
+
+
+```
+OkHttpClient client = new OkHttpClient.Builder()
+    .fastFallback(true)
+    .build();
+```
+
+ *  New: Change the build from Kotlin-JVM to Kotlin-multiplatform (which includes JVM). Both
+    native and JavaScript platforms are unstable preview releases and subject to
+    backwards-incompatible changes in forthcoming releases.
+ *  Fix: Don't crash loading the public suffix database resource in obfuscated builds.
+ *  Fix: Don't silently ignore calls to `EventSource.cancel()` made from
+    `EventSourceListener.onOpen()`.
+ *  Fix: Enforce the max intermediates constraint when using pinned certificates with Conscrypt.
+    This impacts Conscrypt when the server's presented certificates form both a trusted-but-unpinned
+    chain and an untrusted-but-pinned chain.
+ *  Upgrade: [Kotlin 1.6.10][kotlin_1_6_10].
+
+
+## Version 5.0.0-alpha.3
+
+_2021-11-22_
+
+ *  Fix: Change `Headers.toString()` to redact authorization and cookie headers.
+ *  Fix: Don't do DNS to get the hostname for `RecordedRequest.requestUrl`. This was doing a DNS
+    lookup for the local hostname, but we really just wanted the `Host` header.
+ *  Fix: Don't crash with a `InaccessibleObjectException` when detecting the platform trust manager
+    on Java 17+.
+ *  Fix: Don't crash if a cookie's value is a lone double quote character.
+ *  Fix: Don't crash when canceling an event source created by `EventSources.processResponse()`.
+ *  New: `Cache` now has a public constructor that takes an [okio.FileSystem]. This should make it
+    possible to implement decorators for cache encryption or compression.
+ *  New: `Cookie.newBuilder()` to build upon an existing cookie.
+ *  New: Use TLSv1.3 when running on JDK 8u261 or newer.
+ *  New: `QueueDispatcher.clear()` may be used to reset a MockWebServer instance.
+ *  New: `FileDescriptor.toRequestBody()` may be particularly useful for users of Android's Storage
+    Access Framework.
+ *  Upgrade: [Kotlin 1.5.31][kotlin_1_5_31].
+ *  Upgrade: [Okio 3.0.0][okio_3_0_0].
+
+
+## Version 5.0.0-alpha.2
+
+_2021-01-30_
+
+**In this release MockWebServer has a new Maven coordinate and package name.** A longstanding
+problem with MockWebServer has been its API dependency on JUnit 4. We've reorganized things to
+remove that dependency while preserving backwards compatibility.
+
+| Maven Coordinate                                         | Package Name          | Description                       |
+| :------------------------------------------------------- | :-------------------- | :-------------------------------- |
+| com.squareup.okhttp3:mockwebserver3:5.0.0-alpha.2        | mockwebserver3        | Core module. No JUnit dependency! |
+| com.squareup.okhttp3:mockwebserver3-junit4:5.0.0-alpha.2 | mockwebserver3.junit4 | Optional JUnit 4 integration.     |
+| com.squareup.okhttp3:mockwebserver3-junit5:5.0.0-alpha.2 | mockwebserver3.junit5 | Optional JUnit 5 integration.     |
+| com.squareup.okhttp3:mockwebserver:5.0.0-alpha.2         | okhttp3.mockwebserver | Obsolete. Depends on JUnit 4.     |
+
+The new APIs use `mockwebserver3` in both the Maven coordinate and package name. This new API is
+**not stable** and will likely change before the final 5.0.0 release.
+
+If you have code that subclasses `okhttp3.mockwebserver.QueueDispatcher`, this update is not source
+or binary compatible. Migrating to the new `mockwebserver3` package will fix this problem.
+
+ *  New: DNS over HTTPS is now a stable feature of OkHttp. We introduced this as an experimental
+    module in 2018. We are confident in its stable API and solid implementation.
+ *  Fix: Work around a crash in Android 10 and 11 that may be triggered when two threads
+    concurrently close an SSL socket. This would have appeared in crash logs as
+    `NullPointerException: bio == null`.
+ *  Fix: Use plus `+` instead of `%20` to encode space characters in `FormBody`. This was a
+    longstanding bug in OkHttp. The fix makes OkHttp consistent with major web browsers.
+ *  Fix: Don't crash if Conscrypt returns a null version.
+ *  Fix: Include the public suffix data as a resource in GraalVM native images.
+ *  Fix: Fail fast when the cache is corrupted.
+ *  Fix: Fail fast when a private key cannot be encoded.
+ *  Fix: Fail fast when attempting to verify a non-ASCII hostname.
+ *  Upgrade: [GraalVM 21][graalvm_21].
+ *  Upgrade: [Kotlin 1.4.20][kotlin_1_4_20].
+
+
+## Version 5.0.0-alpha.1
+
+_2021-01-30_
+
+**This release adds initial support for [GraalVM][graalvm].**
+
+GraalVM is an exciting new platform and we're eager to adopt it. The startup time improvements over
+the JVM are particularly impressive. Try it with okcurl:
+
+```
+$ ./gradlew okcurl:nativeImage
+$ ./okcurl/build/graal/okcurl https://cash.app/robots.txt
+```
+
+This is our first release that supports GraalVM. Our code on this platform is less mature than JVM
+and Android! Please report any issues you encounter: we'll fix them urgently.
+
+ *  Fix: Attempt to read the response body even if the server canceled the request. This will cause
+    some calls to return nice error codes like `HTTP/1.1 429 Too Many Requests` instead of transport
+    errors like `SocketException: Connection reset` and `StreamResetException: stream was reset:
+    CANCEL`.
+ *  New: Support OSGi metadata.
+ *  Upgrade: [Okio 2.9.0][okio_2_9_0].
+
+    ```kotlin
+    implementation("com.squareup.okio:okio:2.9.0")
+    ```
+
+Note that this was originally released on 2020-10-06 as 4.10.0-RC1. The only change from that
+release is the version name.
+
+
+## Version 4.x
+
+[Change log](changelog_4x.md)
+
+
+ [graalvm]: https://www.graalvm.org/
+ [graalvm_21]: https://www.graalvm.org/release-notes/21_0/
+ [kotlin_1_4_20]: https://github.com/JetBrains/kotlin/releases/tag/v1.4.20
+ [kotlin_1_5_31]: https://github.com/JetBrains/kotlin/releases/tag/v1.5.31
+ [kotlin_1_6_10]: https://github.com/JetBrains/kotlin/releases/tag/v1.6.10
+ [okio_2_9_0]: https://square.github.io/okio/changelog/#version-290
+ [okio_3_0_0]: https://square.github.io/okio/changelog/#version-300
+ [rfc_8305]: https://tools.ietf.org/html/rfc8305
diff --git a/docs/changelog_1x.md b/docs/changelogs/changelog_1x.md
similarity index 100%
rename from docs/changelog_1x.md
rename to docs/changelogs/changelog_1x.md
diff --git a/docs/changelog_2x.md b/docs/changelogs/changelog_2x.md
similarity index 100%
rename from docs/changelog_2x.md
rename to docs/changelogs/changelog_2x.md
diff --git a/docs/changelog_3x.md b/docs/changelogs/changelog_3x.md
similarity index 99%
rename from docs/changelog_3x.md
rename to docs/changelogs/changelog_3x.md
index 388dec19c..a2a5e5377 100644
--- a/docs/changelog_3x.md
+++ b/docs/changelogs/changelog_3x.md
@@ -29,7 +29,7 @@ _2020-02-24_
 
 _2020-01-11_
 
- *  Fix: Don't crash if the connection is closed when sending a degraded ping. This fixes a 
+ *  Fix: Don't crash if the connection is closed when sending a degraded ping. This fixes a
     regression that was introduced in OkHttp 3.14.5.
 
 
@@ -38,7 +38,7 @@ _2020-01-11_
 _2020-01-03_
 
  *  Fix: Degrade HTTP/2 connections after a timeout. When an HTTP/2 stream times out it may impact
-    the stream only or the entire connection. With this fix OkHttp will now send HTTP/2 pings after 
+    the stream only or the entire connection. With this fix OkHttp will now send HTTP/2 pings after
     a stream timeout to determine whether the connection should remain eligible for pooling.
 
 
@@ -263,7 +263,7 @@ _2020-02-24_
 
 _2020-01-11_
 
- *  Fix: Don't crash if the connection is closed when sending a degraded ping. This fixes a 
+ *  Fix: Don't crash if the connection is closed when sending a degraded ping. This fixes a
     regression that was introduced in OkHttp 3.12.7.
 
 
@@ -272,7 +272,7 @@ _2020-01-11_
 _2020-01-03_
 
  *  Fix: Degrade HTTP/2 connections after a timeout. When an HTTP/2 stream times out it may impact
-    the stream only or the entire connection. With this fix OkHttp will now send HTTP/2 pings after 
+    the stream only or the entire connection. With this fix OkHttp will now send HTTP/2 pings after
     a stream timeout to determine whether the connection should remain eligible for pooling.
 
 
@@ -1128,6 +1128,6 @@ stuck on the old version.
  [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
  [public_suffix]: https://publicsuffix.org/
  [remove_cbc_ecdsa]: https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls
- [require_android_5]: https://cashapp.github.io/2019-02-05/okhttp-3-13-requires-android-5
+ [require_android_5]: https://code.cash.app/okhttp-3-13-requires-android-5
  [tls_configuration_history]: https://square.github.io/okhttp/tls_configuration_history/
  [upgrading_to_okhttp_4]: https://square.github.io/okhttp/upgrading_to_okhttp_4/
diff --git a/docs/changelogs/changelog_4x.md b/docs/changelogs/changelog_4x.md
new file mode 100644
index 000000000..048843c3b
--- /dev/null
+++ b/docs/changelogs/changelog_4x.md
@@ -0,0 +1,541 @@
+OkHttp 4.x Change Log
+=====================
+
+## Version 4.9.3
+
+_2021-11-21_
+
+ *  Fix: Don't fail HTTP/2 responses if they complete before a `RST_STREAM` is sent.
+
+
+## Version 4.9.2
+
+_2021-09-30_
+
+ *  Fix: Don't include potentially-sensitive header values in `Headers.toString()` or exceptions.
+    This applies to `Authorization`, `Cookie`, `Proxy-Authorization`, and `Set-Cookie` headers.
+ *  Fix: Don't crash with an `InaccessibleObjectException` when running on JDK17+ with strong
+    encapsulation enabled.
+ *  Fix: Strictly verify hostnames used with OkHttp's `HostnameVerifier`. Programs that make direct
+    manual calls to `HostnameVerifier` could be defeated if the hostnames they pass in are not
+    strictly ASCII. This issue is tracked as [CVE-2021-0341].
+
+
+## Version 4.9.1
+
+_2021-01-30_
+
+ *  Fix: Work around a crash in Android 10 and 11 that may be triggered when two threads
+    concurrently close an SSL socket. This would have appeared in crash logs as
+    `NullPointerException: bio == null`.
+
+
+## Version 4.9.0
+
+_2020-09-11_
+
+**With this release, `okhttp-tls` no longer depends on Bouncy Castle and doesn't install the
+Bouncy Castle security provider.** If you still need it, you can do it yourself:
+
+```
+Security.addProvider(BouncyCastleProvider())
+```
+
+You will also need to configure this dependency:
+
+```
+dependencies {
+  implementation "org.bouncycastle:bcprov-jdk15on:1.65"
+}
+```
+
+ *  Upgrade: [Kotlin 1.4.10][kotlin_1_4_10]. We now use Kotlin 1.4.x [functional
+    interfaces][fun_interface] for `Authenticator`, `Interceptor`, and others.
+ *  Upgrade: Build with Conscrypt 2.5.1.
+
+
+## Version 4.8.1
+
+_2020-08-06_
+
+ *  Fix: Don't crash in `HeldCertificate.Builder` when creating certificates on older versions of
+    Android, including Android 6. We were using a feature of `SimpleDateFormat` that wasn't
+    available in those versions!
+
+
+## Version 4.8.0
+
+_2020-07-11_
+
+ *  New: Change `HeldCertificate.Builder` to use its own ASN.1 certificate encoder. This is part
+    of our effort to remove the okhttp-tls module's dependency on Bouncy Castle. We think Bouncy
+    Castle is great! But it's a large dependency (6.5 MiB) and its security provider feature
+    impacts VM-wide behavior.
+
+ *  New: Reduce contention for applications that make a very high number of concurrent requests.
+    Previously OkHttp used its connection pool as a lock when making changes to connections and
+    calls. With this change each connection is locked independently.
+
+ *  Upgrade: [Okio 2.7.0][okio_2_7_0].
+
+    ```kotlin
+    implementation("com.squareup.okio:okio:2.7.0")
+    ```
+
+ *  Fix: Avoid log messages like "Didn't find class org.conscrypt.ConscryptHostnameVerifier" when
+    detecting the TLS capabilities of the host platform.
+
+ *  Fix: Don't crash in `HttpUrl.topPrivateDomain()` when the hostname is malformed.
+
+ *  Fix: Don't attempt Brotli decompression if the response body is empty.
+
+
+## Version 4.7.2
+
+_2020-05-20_
+
+ *  Fix: Don't crash inspecting whether the host platform is JVM or Android. With 4.7.0 and 4.7.1 we
+    had a crash `IllegalArgumentException: Not a Conscrypt trust manager` because we depended on
+    initialization order of companion objects.
+
+
+## Version 4.7.1
+
+_2020-05-18_
+
+ *  Fix: Pass the right arguments in the trust manager created for `addInsecureHost()`. Without the
+    fix insecure hosts crash with an `IllegalArgumentException` on Android.
+
+
+## Version 4.7.0
+
+_2020-05-17_
+
+ *  New: `HandshakeCertificates.Builder.addInsecureHost()` makes it easy to turn off security in
+    private development environments that only carry test data. Prefer this over creating an
+    all-trusting `TrustManager` because only hosts on the allowlist are insecure. From
+    [our DevServer sample][dev_server]:
+
+    ```kotlin
+    val clientCertificates = HandshakeCertificates.Builder()
+        .addPlatformTrustedCertificates()
+        .addInsecureHost("localhost")
+        .build()
+
+    val client = OkHttpClient.Builder()
+        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager)
+        .build()
+    ```
+
+ *  New: Add `cacheHit`, `cacheMiss`, and `cacheConditionalHit()` events to `EventListener`. Use
+    these in logs, metrics, and even test cases to confirm your cache headers are configured as
+    expected.
+
+ *  New: Constant string `okhttp3.VERSION`. This is a string like "4.5.0-RC1", "4.5.0", or
+    "4.6.0-SNAPSHOT" indicating the version of OkHttp in the current runtime. Use this to include
+    the OkHttp version in custom `User-Agent` headers.
+
+ *  Fix: Don't crash when running as a plugin in Android Studio Canary 4.1. To enable
+    platform-specific TLS features OkHttp must detect whether it's running in a JVM or in Android.
+    The upcoming Android Studio runs in a JVM but has classes from Android and that confused OkHttp!
+
+ *  Fix: Include the header `Accept: text/event-stream` for SSE calls. This header is not added if
+    the request already contains an `Accept` header.
+
+ *  Fix: Don't crash with a `NullPointerException` if a server sends a close while we're sending a
+    ping. OkHttp had a race condition bug.
+
+
+## Version 4.6.0
+
+_2020-04-28_
+
+ *  Fix: Follow HTTP 307 and 308 redirects on methods other than GET and POST. We're reluctant to
+    change OkHttp's behavior in handling common HTTP status codes, but this fix is overdue! The new
+    behavior is now consistent with [RFC 7231][rfc_7231_647], which is newer than OkHttp itself.
+    If you want this update with the old behavior use [this interceptor][legacy_interceptor].
+
+ *  Fix: Don't crash decompressing web sockets messages. We had a bug where we assumed deflated
+    bytes in would always yield deflated bytes out and this isn't always the case!
+
+ *  Fix: Reliably update and invalidate the disk cache on windows. As originally designed our
+    internal `DiskLruCache` assumes an inode-like file system, where it's fine to delete files that
+    are currently being read or written. On Windows the file system forbids this so we must be more
+    careful when deleting and renaming files.
+
+ *  Fix: Don't crash on Java 8u252 which introduces an API previously found only on Java 9 and
+    above. See [Jetty's overview][jetty_8_252] of the API change and its consequences.
+
+ *  New: `MultipartReader` is a streaming decoder for [MIME multipart (RFC 2045)][rfc_2045]
+    messages. It complements `MultipartBody` which is our streaming encoder.
+
+    ```kotlin
+    val response: Response = call.execute()
+    val multipartReader = MultipartReader(response.body!!)
+
+    multipartReader.use {
+      while (true) {
+        val part = multipartReader.nextPart() ?: break
+        process(part.headers, part.body)
+      }
+    }
+    ```
+
+ *  New: `MediaType.parameter()` gets a parameter like `boundary` from a media type like
+    `multipart/mixed; boundary="abc"`.
+
+ *  New: `Authenticator.JAVA_NET_AUTHENTICATOR` forwards authentication requests to
+    `java.net.Authenticator`. This obsoletes `JavaNetAuthenticator` in the `okhttp-urlconnection`
+    module.
+
+ *  New: `CertificatePinner` now offers an API for inspecting the configured pins.
+
+ *  Upgrade: [Okio 2.6.0][okio_2_6_0].
+
+    ```kotlin
+    implementation("com.squareup.okio:okio:2.6.0")
+    ```
+
+ *  Upgrade: [publicsuffix.org data][public_suffix]. This powers `HttpUrl.topPrivateDomain()`.
+    It's also how OkHttp knows which domains can share cookies with one another.
+
+ *  Upgrade: [Bouncy Castle 1.65][bouncy_castle_releases]. This dependency is required by the
+    `okhttp-tls` module.
+
+ *  Upgrade: [Kotlin 1.3.71][kotlin_1_3_71].
+
+
+## Version 4.5.0
+
+_2020-04-06_
+
+**This release fixes a severe bug where OkHttp incorrectly detected and recovered from unhealthy
+connections.** Stale or canceled connections were incorrectly attempted when they shouldn't have
+been, leading to rare cases of infinite retries. Please upgrade to this release!
+
+ *  Fix: don't return stale DNS entries in `DnsOverHttps`. We were caching DNS results indefinitely
+    rather than the duration specified in the response's cache-control header.
+ *  Fix: Verify certificate IP addresses in canonical form. When a server presents a TLS certificate
+    containing an IP address we must match that address against the URL's IP address, even when the
+    two addresses are encoded differently, such as `192.168.1.1` and `0::0:0:FFFF:C0A8:101`. Note
+    that OkHttp incorrectly rejected valid certificates resulting in a failure to connect; at no
+    point were invalid certificates accepted.
+ *  New: `OkHttpClient.Builder.minWebSocketMessageToCompress()` configures a threshold for
+    compressing outbound web socket messages. Configure this with 0L to always compress outbound
+    messages and `Long.MAX_VALUE` to never compress outbound messages. The default is 1024L which
+    compresses messages of size 1 KiB and larger. (Inbound messages are compressed or not based on
+    the web socket server's configuration.)
+ *  New: Defer constructing `Inflater` and `Deflater` instances until they are needed. This saves
+    memory if web socket compression is negotiated but not used.
+
+
+## Version 4.5.0-RC1
+
+_2020-03-17_
+
+**This release candidate turns on web socket compression.**
+
+The [spec][rfc_7692] includes a sophisticated mechanism for client and server to negotiate
+compression features. We strive to offer great performance in our default configuration and so we're
+making compression the default for everyone starting with this release candidate.
+
+Please be considerate of your servers and their operators as you roll out this release. Compression
+saves bandwidth but it costs CPU and memory! If you run into a problem you may need to adjust or
+disable the `permessage-deflate` compression settings on your server.
+
+Note that OkHttp won't use compression when sending messages smaller than 1 KiB.
+
+ *  Fix: Don't crash when the URL hostname contains an underscore on Android.
+ *  Fix: Change HTTP/2 to use a daemon thread for its socket reader. If you've ever seen a command
+    line application hang after all of the work is done, it may be due to a non-daemon thread like
+    this one.
+ *  New: Include suppressed exceptions when all routes to a target service fail.
+
+
+## Version 4.4.1
+
+_2020-03-08_
+
+ *  Fix: Don't reuse a connection on redirect if certs match but DNS does not. For better
+    locality and performance OkHttp attempts to use the same pooled connection across redirects and
+    follow-ups. It independently shares connections when the IP addresses and certificates match,
+    even if the host names do not. In 4.4.0 we introduced a regression where we shared a connection
+    when certificates matched but the DNS addresses did not. This would only occur when following a
+    redirect from one hostname to another, and where both hosts had common certificates.
+
+ *  Fix: Don't fail on a redirect when a client has configured a 'trust everything' trust manager.
+    Typically this would cause certain redirects to fail in debug and development configurations.
+
+
+## Version 4.4.0
+
+_2020-02-17_
+
+ *  New: Support `canceled()` as an event that can be observed by `EventListener`. This should be
+    useful for splitting out canceled calls in metrics.
+
+ *  New: Publish a [bill of materials (BOM)][bom] for OkHttp. Depend on this from Gradle or Maven to
+    keep all of your OkHttp artifacts on the same version, even if they're declared via transitive
+    dependencies. You can even omit versions when declaring other OkHttp dependencies.
+
+    ```kotlin
+    dependencies {
+       api(platform("com.squareup.okhttp3:okhttp-bom:4.4.0"))
+       api("com.squareup.okhttp3:okhttp")              // No version!
+       api("com.squareup.okhttp3:logging-interceptor") // No version!
+    }
+    ```
+
+ *  New: Upgrade to Okio 2.4.3.
+
+    ```kotlin
+    implementation("com.squareup.okio:okio:2.4.3")
+    ```
+
+ *  Fix: Limit retry attempts for HTTP/2 `REFUSED_STREAM` and `CANCEL` failures.
+ *  Fix: Retry automatically when incorrectly sharing a connection among multiple hostnames. OkHttp
+    shares connections when hosts share both IP addresses and certificates, such as `squareup.com`
+    and `www.squareup.com`. If a server refuses such sharing it will return HTTP 421 and OkHttp will
+    automatically retry on an unshared connection.
+ *  Fix: Don't crash if a TLS tunnel's response body is truncated.
+ *  Fix: Don't track unusable routes beyond their usefulness. We had a bug where we could track
+    certain bad routes indefinitely; now we only track the ones that could be necessary.
+ *  Fix: Defer proxy selection until a proxy is required. This saves calls to `ProxySelector` on
+    calls that use a pooled connection.
+
+
+## Version 4.3.1
+
+_2020-01-07_
+
+ *  Fix: Don't crash with a `NullPointerException` when a web socket is closed before it connects.
+    This regression was introduced in OkHttp 4.3.0.
+ *  Fix: Don't crash with an `IllegalArgumentException` when using custom trust managers on
+    Android 10. Android uses reflection to look up a magic `checkServerTrusted()` method and we
+    didn't have it.
+ *  Fix: Explicitly specify the remote server name when making HTTPS connections on Android 5. In
+    4.3.0 we introduced a regression where server name indication (SNI) was broken on Android 5.
+
+
+## Version 4.3.0
+
+_2019-12-31_
+
+ *  Fix: Degrade HTTP/2 connections after a timeout. When an HTTP/2 stream times out it may impact
+    the stream only or the entire connection. With this fix OkHttp will now send HTTP/2 pings after
+    a stream timeout to determine whether the connection should remain eligible for pooling.
+
+ *  Fix: Don't call `EventListener.responseHeadersStart()` or `responseBodyStart()` until bytes have
+    been received. Previously these events were incorrectly sent too early, when OkHttp was ready to
+    read the response headers or body, which mislead tracing tools. Note that the `responseFailed()`
+    event always used to follow one of these events; now it may be sent without them.
+
+ *  New: Upgrade to Kotlin 1.3.61.
+
+ *  New: Match any number of subdomains with two asterisks in `CertificatePinner`. For example,
+    `**.squareup.com` matches `us-west.www.squareup.com`, `www.squareup.com` and `squareup.com`.
+
+ *  New: Share threads more aggressively between OkHttp's HTTP/2 connections, connection pool,
+    web sockets, and cache. OkHttp has a new internal task runner abstraction for managed task
+    scheduling. In your debugger you will see new thread names and more use of daemon threads.
+
+ *  Fix: Don't drop callbacks on unexpected exceptions. When an interceptor throws an unchecked
+    exception the callback is now notified that the call was canceled. The exception is still sent
+    to the uncaught exception handler for reporting and recovery.
+
+ *  Fix: Un-deprecate `MockResponse.setHeaders()` and other setters. These were deprecated in OkHttp
+    4.0 but that broke method chaining for Java callers.
+
+ *  Fix: Don't crash on HTTP/2 HEAD requests when the `Content-Length` header is present but is not
+    consistent with the length of the response body.
+
+ *  Fix: Don't crash when converting a `HttpUrl` instance with an unresolvable hostname to a URI.
+    The new behavior strips invalid characters like `"` and `{` from the hostname before converting.
+
+ *  Fix: Undo a performance regression introduced in OkHttp 4.0 caused by differences in behavior
+    between Kotlin's `assert()` and Java's `assert()`. (Kotlin always evaluates the argument; Java
+    only does when assertions are enabled.)
+
+ *  Fix: Honor `RequestBody.isOneShot()` in `HttpLoggingInterceptor`.
+
+
+## Version 4.2.2
+
+_2019-10-06_
+
+ *  Fix: When closing a canceled HTTP/2 stream, don't send the `END_STREAM` flag. This could cause
+    the server to incorrectly interpret the stream as having completed normally. This is most useful
+    when a request body needs to cancel its own call.
+
+
+## Version 4.2.1
+
+_2019-10-02_
+
+ *  Fix: In 4.1.0 we introduced a performance regression that prevented connections from being
+    pooled in certain situations. We have good test coverage for connection pooling but we missed
+    this because it only occurs if you have proxy configured and you share a connection pool among
+    multiple `OkHttpClient` instances.
+
+    This particularly-subtle bug was caused by us assigning each `OkHttpClient` instance its own
+    `NullProxySelector` when an explicit proxy is configured. But we don't share connections when
+    the proxy selectors are different. Ugh!
+
+
+## Version 4.2.0
+
+_2019-09-10_
+
+ *  New: API to decode a certificate and private key to create a `HeldCertificate`. This accepts a
+    string containing both a certificate and PKCS #8-encoded private key.
+
+    ```kotlin
+    val heldCertificate = HeldCertificate.decode("""
+        |-----BEGIN CERTIFICATE-----
+        |MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl
+        |cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx
+        |MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h
+        |cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD
+        |ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw
+        |HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF
+        |AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT
+        |yyaoEufLKVXhrTQhRfodTeigi4RX
+        |-----END CERTIFICATE-----
+        |-----BEGIN PRIVATE KEY-----
+        |MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J
+        |lu/GJQZoU9lDrCPeUcQ28tzOWw==
+        |-----END PRIVATE KEY-----
+        """.trimMargin())
+    val handshakeCertificates = HandshakeCertificates.Builder()
+        .heldCertificate(heldCertificate)
+        .build()
+    val server = MockWebServer()
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
+    ```
+
+    Get these strings with `HeldCertificate.certificatePem()` and `privateKeyPkcs8Pem()`.
+
+ *  Fix: Handshake now returns peer certificates in canonical order: each certificate is signed by
+    the certificate that follows and the last certificate is signed by a trusted root.
+
+ *  Fix: Don't lose HTTP/2 flow control bytes when incoming data races with a stream close. If this
+    happened enough then eventually the connection would stall.
+
+ *  Fix: Acknowledge and apply inbound HTTP/2 settings atomically. Previously we had a race where we
+    could use new flow control capacity before acknowledging it, causing strict HTTP/2 servers to
+    fail the call.
+
+
+## Version 4.1.1
+
+_2019-09-05_
+
+ *  Fix: Don't drop repeated headers when validating cached responses. In our Kotlin upgrade we
+    introduced a regression where we iterated the number of unique header names rather than then
+    number of unique headers. If you're using OkHttp's response cache this may impact you.
+
+
+## Version 4.1.0
+
+_2019-08-12_
+
+ [brotli]: https://github.com/google/brotli
+
+ *  **OkHttp's new okhttp-brotli module implements Brotli compression.** Install the interceptor to
+    enable [Brotli compression][brotli], which compresses 5-20% smaller than gzip.
+
+    ```
+    val client = OkHttpClient.Builder()
+        .addInterceptor(BrotliInterceptor)
+        .build()
+    ```
+
+    This artifact has a dependency on Google's Brotli decoder (95 KiB).
+
+ *  New: `EventListener.proxySelectStart()`, `proxySelectEnd()` events give visibility into the
+    proxy selection process.
+ *  New: `Response.byteString()` reads the entire response into memory as a byte string.
+ *  New: `OkHttpClient.x509TrustManager` accessor.
+ *  New: Permit [new WebSocket response codes][iana_websocket]: 1012 (Service Restart), 1013 (Try
+    Again Later), and 1014 (invalid response from the upstream).
+ *  New: Build with Kotlin 1.3.41, BouncyCastle 1.62, and Conscrypt 2.2.1.
+ *  Fix: Recover gracefully when a coalesced connection immediately goes unhealthy.
+ *  Fix: Defer the `SecurityException` when looking up the default proxy selector.
+ *  Fix: Don't use brackets formatting IPv6 host names in MockWebServer.
+ *  Fix: Don't permit cache iterators to remove entries that are being written.
+
+
+## Version 4.0.1
+
+_2019-07-10_
+
+ *  Fix: Tolerate null-hostile lists in public API. Lists created with `List.of(...)` don't like it
+    when you call `contains(null)` on them!
+ *  Fix: Retain binary-compatibility in `okhttp3.internal.HttpHeaders.hasBody()`. Some unscrupulous
+    coders call this and we don't want their users to suffer.
+
+
+## Version 4.0.0
+
+_2019-06-26_
+
+**This release upgrades OkHttp to Kotlin.** We tried our best to make fast and safe to upgrade
+from OkHttp 3.x. We wrote an [upgrade guide][upgrading_to_okhttp_4] to help with the migration and a
+[blog post][okhttp4_blog_post] to explain it.
+
+ *  Fix: Target Java 8 bytecode for Java and Kotlin.
+
+
+## Version 4.0.0-RC3
+
+_2019-06-24_
+
+ *  Fix: Retain binary-compatibility in `okhttp3.internal.HttpMethod`. Naughty third party SDKs
+    import this and we want to ease upgrades for their users.
+
+
+## Version 4.0.0-RC2
+
+_2019-06-21_
+
+ *  New: Require Kotlin 1.3.40.
+ *  New: Change the Kotlin API from `File.toRequestBody()` to `File.asRequestBody()` and
+    `BufferedSource.toResponseBody()` to `BufferedSource.asResponseBody()`. If the returned value
+    is a view of what created it, we use _as_.
+ *  Fix: Permit response codes of zero for compatibility with OkHttp 3.x.
+ *  Fix: Change the return type of `MockWebServer.takeRequest()` to be nullable.
+ *  Fix: Make `Call.clone()` public to Kotlin callers.
+
+
+## Version 4.0.0-RC1
+
+_2019-06-03_
+
+ *  First stable preview of OkHttp 4.
+
+
+## Version 3.x
+
+[Change log](https://square.github.io/okhttp/changelog_3x/)
+
+
+ [bom]: https://docs.gradle.org/6.2/userguide/platforms.html#sub:bom_import
+ [bouncy_castle_releases]: https://www.bouncycastle.org/releasenotes.html
+ [CVE-2021-0341]: https://nvd.nist.gov/vuln/detail/CVE-2021-0341
+ [dev_server]: https://github.com/square/okhttp/blob/482f88300f78c3419b04379fc26c3683c10d6a9d/samples/guide/src/main/java/okhttp3/recipes/kt/DevServer.kt
+ [fun_interface]: https://kotlinlang.org/docs/reference/fun-interfaces.html
+ [iana_websocket]: https://www.iana.org/assignments/websocket/websocket.txt
+ [jetty_8_252]: https://webtide.com/jetty-alpn-java-8u252/
+ [kotlin_1_3_71]: https://github.com/JetBrains/kotlin/releases/tag/v1.3.71
+ [kotlin_1_4_10]: https://github.com/JetBrains/kotlin/releases/tag/v1.4.10
+ [legacy_interceptor]: https://gist.github.com/swankjesse/80135f4e03629527e723ab3bcf64be0b
+ [okhttp4_blog_post]: https://cashapp.github.io/2019-06-26/okhttp-4-goes-kotlin
+ [okio.FileSystem]: https://square.github.io/okio/file_system/
+ [okio_2_6_0]: https://square.github.io/okio/changelog/#version-260
+ [okio_2_7_0]: https://square.github.io/okio/changelog/#version-270
+ [public_suffix]: https://publicsuffix.org/
+ [rfc_2045]: https://tools.ietf.org/html/rfc2045
+ [rfc_7231_647]: https://tools.ietf.org/html/rfc7231#section-6.4.7
+ [rfc_7692]: https://tools.ietf.org/html/rfc7692
+ [semver]: https://semver.org/
+ [upgrading_to_okhttp_4]: https://square.github.io/okhttp/upgrading_to_okhttp_4/
diff --git a/docs/upgrading_to_okhttp_4.md b/docs/changelogs/upgrading_to_okhttp_4.md
similarity index 98%
rename from docs/upgrading_to_okhttp_4.md
rename to docs/changelogs/upgrading_to_okhttp_4.md
index ad17bc3fb..5a30f9782 100644
--- a/docs/upgrading_to_okhttp_4.md
+++ b/docs/changelogs/upgrading_to_okhttp_4.md
@@ -217,7 +217,7 @@ Android Studio’s Advanced Profiling feature rewrites OkHttp bytecode for instr
 Unfortunately it crashes on OkHttp 4.x’s bytecode. Until [Google’s bug][advanced_profiling_bug] is
 fixed you must disable advanced profiling in Android Studio.
 
-![Disable Advanced Profiling](images/disable_advanced_profiling@2x.png)
+![Disable Advanced Profiling](../assets/images/disable_advanced_profiling@2x.png)
 
 
 R8 / ProGuard
@@ -275,5 +275,5 @@ android {
  [kotlin_sams]: https://youtrack.jetbrains.com/issue/KT-11129
  [mockito]: https://site.mockito.org/
  [proguard_problems]: https://github.com/square/okhttp/issues/5167
- [require_android_5]: https://cashapp.github.io/2019-02-05/okhttp-3-13-requires-android-5
+ [require_android_5]: https://code.cash.app/okhttp-3-13-requires-android-5
  [r8]: https://developer.android.com/studio/releases#r8-default
diff --git a/docs/code_of_conduct.md b/docs/contribute/code_of_conduct.md
similarity index 100%
rename from docs/code_of_conduct.md
rename to docs/contribute/code_of_conduct.md
diff --git a/docs/concurrency.md b/docs/contribute/concurrency.md
similarity index 100%
rename from docs/concurrency.md
rename to docs/contribute/concurrency.md
diff --git a/docs/contribute/contributing.md b/docs/contribute/contributing.md
new file mode 100644
index 000000000..18ae83cfb
--- /dev/null
+++ b/docs/contribute/contributing.md
@@ -0,0 +1,62 @@
+Contributing
+============
+
+Keeping the project small and stable limits our ability to accept new contributors. We are not
+seeking new committers at this time, but some small contributions are welcome.
+
+If you've found a security problem, please follow our [bug bounty][security] program.
+
+If you've found a bug, please contribute a failing test case so we can study and fix it.
+
+If you have a new feature idea, please build it in an external library. There are
+[many libraries][works_with_okhttp] that sit on top or hook in via existing APIs. If you build
+something that integrates with OkHttp, tell us so that we can link it!
+
+Before code can be accepted all contributors must complete our
+[Individual Contributor License Agreement (CLA)][cla].
+
+
+Code Contributions
+------------------
+
+Get working code on a personal branch with tests passing before you submit a PR:
+
+```
+./gradlew clean check
+```
+
+Please make every effort to follow existing conventions and style in order to keep the code as
+readable as possible.
+
+Contribute code changes through GitHub by forking the repository and sending a pull request. We
+squash all pull requests on merge.
+
+
+Gradle Setup
+------------
+
+```
+$ cat local.properties
+sdk.dir=PATH_TO_ANDROID_HOME/sdk
+org.gradle.caching=true
+```
+
+Running Android Tests
+---------------------
+
+$ ANDROID_SDK_ROOT=PATH_TO_ANDROID_HOME/sdk ./gradlew :android-test:connectedCheck
+
+Committer's Guides
+------------------
+
+ * [Concurrency][concurrency]
+ * [Debug Logging][debug_logging]
+ * [Releasing][releasing]
+
+ [cla]: https://spreadsheets.google.com/spreadsheet/viewform?formkey=dDViT2xzUHAwRkI3X3k5Z0lQM091OGc6MQ&ndplr=1
+ [concurrency]: https://square.github.io/okhttp/concurrency/
+ [debug_logging]: https://square.github.io/okhttp/debug_logging/
+ [releasing]: https://square.github.io/okhttp/releasing/
+ [security]: https://square.github.io/okhttp/security/
+ [works_with_okhttp]: https://square.github.io/okhttp/works_with_okhttp/
+ [okhttp_build]: https://github.com/square/okhttp/blob/master/okhttp/build.gradle
diff --git a/docs/debug_logging.md b/docs/contribute/debug_logging.md
similarity index 100%
rename from docs/debug_logging.md
rename to docs/contribute/debug_logging.md
diff --git a/docs/css/app.css b/docs/css/app.css
deleted file mode 100644
index 48136b7ef..000000000
--- a/docs/css/app.css
+++ /dev/null
@@ -1,48 +0,0 @@
-@font-face {
-    font-family: cash-market;
-    src: url("https://cash-f.squarecdn.com/static/fonts/cash-market/v2/CashMarket-Regular.woff2") format("woff2");
-    font-weight: 400;
-    font-style: normal
-}
-
-@font-face {
-    font-family: cash-market;
-    src: url("https://cash-f.squarecdn.com/static/fonts/cash-market/v2/CashMarket-Medium.woff2") format("woff2");
-    font-weight: 500;
-    font-style: normal
-}
-
-@font-face {
-    font-family: cash-market;
-    src: url("https://cash-f.squarecdn.com/static/fonts/cash-market/v2/CashMarket-Bold.woff2") format("woff2");
-    font-weight: 700;
-    font-style: normal
-}
-
-body, input {
-    font-family: cash-market,"Helvetica Neue",helvetica,sans-serif;
-}
-
-.md-typeset h1, .md-typeset h2, .md-typeset h3, .md-typeset h4 {
-    font-family: cash-market,"Helvetica Neue",helvetica,sans-serif;
-    line-height: normal;
-    font-weight: bold;
-    color: #353535;
-}
-
-button.dl {
-  font-weight: 300;
-  font-size: 25px;
-  line-height: 40px;
-  padding: 3px 10px;
-  display: inline-block;
-  border-radius: 6px;
-  color: #f0f0f0;
-  margin: 5px 0;
-  width: auto;
-}
-
-.logo {
-  text-align: center;
-  margin-top: 150px;
-}
diff --git a/docs/caching.md b/docs/features/caching.md
similarity index 99%
rename from docs/caching.md
rename to docs/features/caching.md
index b6787fc14..37c11c051 100644
--- a/docs/caching.md
+++ b/docs/features/caching.md
@@ -70,7 +70,7 @@ The cache directory must be exclusively owned by a single instance.
 Deleting the cache when it is no longer needed can be done.  However this may delete the purpose of the cache
 which is designed to persist between app restarts.
 
-```
+```kotlin
 cache.delete()
 ```
  
@@ -78,14 +78,14 @@ cache.delete()
 
 Pruning the entire Cache to clear space temporarily can be done using evictAll.
 
-```
+```kotlin
 cache.evictAll()
 ```
 
 Removing individual items can be done using the urls iterator.
 This would be typical after a user initiates a force refresh by a pull to refresh type action.
 
-```
+```java
     val urlIterator = cache.urls()
     while (urlIterator.hasNext()) {
       if (urlIterator.next().startsWith("https://www.google.com/")) {
diff --git a/docs/calls.md b/docs/features/calls.md
similarity index 100%
rename from docs/calls.md
rename to docs/features/calls.md
diff --git a/docs/connections.md b/docs/features/connections.md
similarity index 100%
rename from docs/connections.md
rename to docs/features/connections.md
diff --git a/docs/events.md b/docs/features/events.md
similarity index 97%
rename from docs/events.md
rename to docs/features/events.md
index db8e34603..3d9bef9c9 100644
--- a/docs/events.md
+++ b/docs/features/events.md
@@ -10,7 +10,7 @@ Events allow you to capture metrics on your application’s HTTP calls. Use even
 
 Subclass [EventListener](https://square.github.io/okhttp/3.x/okhttp/okhttp3/EventListener.html) and override methods for the events you are interested in. In a successful HTTP call with no redirects or retries the sequence of events is described by this flow.
 
-![Events Diagram](images/events@2x.png)
+![Events Diagram](../assets/images/events@2x.png)
 
 Here’s a [sample event listener](https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java) that prints each event with a timestamp.
 
@@ -224,7 +224,7 @@ class MetricsEventListener extends EventListener {
 
 When an operation fails, a failure method is called. This is `connectFailed()` for failures while building a connection to the server, and `callFailed()` when the HTTP call fails permanently. When a failure happens it is possible that a `start` event won’t have a corresponding `end` event.
 
-![Events Diagram](images/events_with_failures@2x.png)
+![Events Diagram](../assets/images/events_with_failures@2x.png)
 
 ### Events with Retries and Follow-Ups
 
@@ -232,7 +232,7 @@ OkHttp is resilient and can automatically recover from some connectivity failure
 
 A single HTTP call may require follow-up requests to be made to handle authentication challenges, redirects, and HTTP-layer timeouts. In such cases multiple connections, requests, and responses may be attempted. Follow-ups are another reason a single call may trigger multiple events of the same type.
 
-![Events Diagram](images/events_with_failures_and_retries@2x.png)
+![Events Diagram](../assets/images/events_with_failures_and_retries@2x.png)
 
 ### Availability
 
diff --git a/docs/https.md b/docs/features/https.md
similarity index 97%
rename from docs/https.md
rename to docs/features/https.md
index 5cdd7889b..cad16f533 100644
--- a/docs/https.md
+++ b/docs/features/https.md
@@ -52,7 +52,7 @@ common cipher suite and TLS version, your call will fail like this:
 ```
 Caused by: javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0x7f2719a89e80:
     Failure in SSL library, usually a protocol error
-        error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake 
+        error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake
         failure (external/openssl/ssl/s23_clnt.c:770 0x7f2728a53ea0:0x00000000)
     at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method)
 ```
@@ -64,13 +64,13 @@ Applications expected to be installed on older Android devices should consider a
 [Google Play Services’ ProviderInstaller][provider_installer]. This will increase security for users
 and increase connectivity with web servers.
 
-### Certificate Pinning ([.kt][CertificatePinningKotlin], [.java][CertificatePinningJava]) 
+### Certificate Pinning ([.kt][CertificatePinningKotlin], [.java][CertificatePinningJava])
 
 By default, OkHttp trusts the certificate authorities of the host platform. This strategy maximizes connectivity, but it is subject to certificate authority attacks such as the [2011 DigiNotar attack](https://www.computerworld.com/article/2510951/cybercrime-hacking/hackers-spied-on-300-000-iranians-using-fake-google-certificate.html). It also assumes your HTTPS servers’ certificates are signed by a certificate authority.
 
 Use [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-certificate-pinner/) to restrict which certificates and certificate authorities are trusted. Certificate pinning increases security, but limits your server team’s abilities to update their TLS certificates. **Do not use certificate pinning without the blessing of your server’s TLS administrator!**
 
-=== "Kotlin"
+=== ":material-language-kotlin: Kotlin"
     ```kotlin
       private val client = OkHttpClient.Builder()
           .certificatePinner(
@@ -78,22 +78,22 @@ Use [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-cert
                   .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
                   .build())
           .build()
-    
+
       fun run() {
         val request = Request.Builder()
             .url("https://publicobject.com/robots.txt")
             .build()
-    
+
         client.newCall(request).execute().use { response ->
           if (!response.isSuccessful) throw IOException("Unexpected code $response")
-    
+
           for (certificate in response.handshake!!.peerCertificates) {
             println(CertificatePinner.pin(certificate))
           }
         }
       }
     ```
-=== "Java"
+=== ":material-language-java: Java"
     ```java
       private final OkHttpClient client = new OkHttpClient.Builder()
           .certificatePinner(
@@ -101,15 +101,15 @@ Use [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-cert
                   .add("publicobject.com", "sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
                   .build())
           .build();
-    
+
       public void run() throws Exception {
         Request request = new Request.Builder()
             .url("https://publicobject.com/robots.txt")
             .build();
-    
+
         try (Response response = client.newCall(request).execute()) {
           if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-    
+
           for (Certificate certificate : response.handshake().peerCertificates()) {
             System.out.println(CertificatePinner.pin(certificate));
           }
@@ -121,37 +121,37 @@ Use [CertificatePinner](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-cert
 
 The full code sample shows how to replace the host platform’s certificate authorities with your own set. As above, **do not use custom certificates without the blessing of your server’s TLS administrator!**
 
-=== "Kotlin"
+=== ":material-language-kotlin: Kotlin"
     ```kotlin
       private val client: OkHttpClient
-    
+
       init {
         val trustManager = trustManagerForCertificates(trustedCertificatesInputStream())
         val sslContext = SSLContext.getInstance("TLS")
         sslContext.init(null, arrayOf<TrustManager>(trustManager), null)
         val sslSocketFactory = sslContext.socketFactory
-    
+
         client = OkHttpClient.Builder()
             .sslSocketFactory(sslSocketFactory, trustManager)
             .build()
       }
-    
+
       fun run() {
         val request = Request.Builder()
             .url("https://publicobject.com/helloworld.txt")
             .build()
-    
+
         client.newCall(request).execute().use { response ->
           if (!response.isSuccessful) throw IOException("Unexpected code $response")
-    
+
           for ((name, value) in response.headers) {
             println("$name: $value")
           }
-    
+
           println(response.body!!.string())
         }
       }
-    
+
       /**
        * Returns an input stream containing one or more certificate PEM files. This implementation just
        * embeds the PEM files in Java strings; most applications will instead read this from a resource
@@ -160,15 +160,15 @@ The full code sample shows how to replace the host platform’s certificate auth
       private fun trustedCertificatesInputStream(): InputStream {
         ... // Full source omitted. See sample.
       }
-    
+
       private fun trustManagerForCertificates(inputStream: InputStream): X509TrustManager {
         ... // Full source omitted. See sample.
       }
     ```
-=== "Java"
+=== ":material-language-java: Java"
     ```java
       private final OkHttpClient client;
-    
+
       public CustomTrust() {
         X509TrustManager trustManager;
         SSLSocketFactory sslSocketFactory;
@@ -180,25 +180,25 @@ The full code sample shows how to replace the host platform’s certificate auth
         } catch (GeneralSecurityException e) {
           throw new RuntimeException(e);
         }
-    
+
         client = new OkHttpClient.Builder()
             .sslSocketFactory(sslSocketFactory, trustManager)
             .build();
       }
-    
+
       public void run() throws Exception {
         Request request = new Request.Builder()
             .url("https://publicobject.com/helloworld.txt")
             .build();
-    
+
         Response response = client.newCall(request).execute();
         System.out.println(response.body().string());
       }
-    
+
       private InputStream trustedCertificatesInputStream() {
         ... // Full source omitted. See sample.
       }
-    
+
       public SSLContext sslContextForTrustedCertificates(InputStream in) {
         ... // Full source omitted. See sample.
       }
diff --git a/docs/interceptors.md b/docs/features/interceptors.md
similarity index 99%
rename from docs/interceptors.md
rename to docs/features/interceptors.md
index 944045ae5..cf7d96d27 100644
--- a/docs/interceptors.md
+++ b/docs/features/interceptors.md
@@ -27,7 +27,7 @@ A call to `chain.proceed(request)` is a critical part of each interceptor’s im
 
 Interceptors can be chained. Suppose you have both a compressing interceptor and a checksumming interceptor: you'll need to decide whether data is compressed and then checksummed, or checksummed and then compressed. OkHttp uses lists to track interceptors, and interceptors are called in order.
 
-![Interceptors Diagram](images/interceptors@2x.png)
+![Interceptors Diagram](../assets/images/interceptors@2x.png)
 
 ### Application Interceptors
 
diff --git a/docs/r8_proguard.md b/docs/features/r8_proguard.md
similarity index 100%
rename from docs/r8_proguard.md
rename to docs/features/r8_proguard.md
diff --git a/docs/recipes.md b/docs/recipes.md
index 5895f51cb..19df7b677 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -1,5 +1,10 @@
-Recipes
-=======
+---
+title: Recipes
+description: A collection of common/useful code examples for Kotlin and Java
+---
+
+
+# Recipes
 
 We've written some recipes that demonstrate how to solve common problems with OkHttp. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that's what they're for.
  
@@ -9,109 +14,109 @@ Download a file, print its headers, and print its response body as a string.
 
 The `string()` method on response body is convenient and efficient for small documents. But if the response body is large (greater than 1 MiB), avoid `string()` because it will load the entire document into memory. In that case, prefer to process the body as a stream.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-
-fun run() {
-  val request = Request.Builder()
-      .url("https://publicobject.com/helloworld.txt")
-      .build()
-
-  client.newCall(request).execute().use { response ->
-    if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-    for ((name, value) in response.headers) {
-      println("$name: $value")
-    }
-
-    println(response.body!!.string())
-  }
-}
-```
-=== "Java"
-```java
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  Request request = new Request.Builder()
-      .url("https://publicobject.com/helloworld.txt")
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    Headers responseHeaders = response.headers();
-    for (int i = 0; i < responseHeaders.size(); i++) {
-      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-    }
-
-    System.out.println(response.body().string());
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+      
+      fun run() {
+        val request = Request.Builder()
+            .url("https://publicobject.com/helloworld.txt")
+            .build()
+        
+        client.newCall(request).execute().use { response ->
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+          
+          for ((name, value) in response.headers) {
+            println("$name: $value")
+          }
+          
+          println(response.body!!.string())
+        }
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      private final OkHttpClient client = new OkHttpClient();
+      
+      public void run() throws Exception {
+        Request request = new Request.Builder()
+            .url("https://publicobject.com/helloworld.txt")
+            .build();
+        
+        try (Response response = client.newCall(request).execute()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+          
+          Headers responseHeaders = response.headers();
+          for (int i = 0; i < responseHeaders.size(); i++) {
+            System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+          }
+          
+          System.out.println(response.body().string());
+        }
+      }
+    ```
  
 ### Asynchronous Get ([.kt][AsynchronousGetKotlin], [.java][AsynchronousGetJava])
 
 Download a file on a worker thread, and get called back when the response is readable. The callback is made after the response headers are ready. Reading the response body may still block. OkHttp doesn't currently offer asynchronous APIs to receive a response body in parts.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-
-fun run() {
-  val request = Request.Builder()
-      .url("http://publicobject.com/helloworld.txt")
-      .build()
-
-  client.newCall(request).enqueue(object : Callback {
-    override fun onFailure(call: Call, e: IOException) {
-      e.printStackTrace()
-    }
-
-    override fun onResponse(call: Call, response: Response) {
-      response.use {
-        if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-        for ((name, value) in response.headers) {
-          println("$name: $value")
-        }
-
-        println(response.body!!.string())
-      }
-    }
-  })
-}
-```
-=== "Java"
-```java
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  Request request = new Request.Builder()
-      .url("http://publicobject.com/helloworld.txt")
-      .build();
-
-  client.newCall(request).enqueue(new Callback() {
-    @Override public void onFailure(Call call, IOException e) {
-      e.printStackTrace();
-    }
-
-    @Override public void onResponse(Call call, Response response) throws IOException {
-      try (ResponseBody responseBody = response.body()) {
-        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-        Headers responseHeaders = response.headers();
-        for (int i = 0, size = responseHeaders.size(); i < size; i++) {
-          System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
-        }
-
-        System.out.println(responseBody.string());
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+      
+      fun run() {
+        val request = Request.Builder()
+            .url("http://publicobject.com/helloworld.txt")
+            .build()
+        
+        client.newCall(request).enqueue(object : Callback {
+          override fun onFailure(call: Call, e: IOException) {
+            e.printStackTrace()
+          }
+          
+          override fun onResponse(call: Call, response: Response) {
+            response.use {
+              if (!response.isSuccessful) throw IOException("Unexpected code $response")
+              
+              for ((name, value) in response.headers) {
+                println("$name: $value")
+              }
+              
+              println(response.body!!.string())
+            }
+          }
+        })
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      private final OkHttpClient client = new OkHttpClient();
+      
+      public void run() throws Exception {
+        Request request = new Request.Builder()
+            .url("http://publicobject.com/helloworld.txt")
+            .build();
+        
+        client.newCall(request).enqueue(new Callback() {
+          @Override public void onFailure(Call call, IOException e) {
+            e.printStackTrace();
+          }
+          
+          @Override public void onResponse(Call call, Response response) throws IOException {
+            try (ResponseBody responseBody = response.body()) {
+              if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+              
+              Headers responseHeaders = response.headers();
+              for (int i = 0, size = responseHeaders.size(); i < size; i++) {
+                System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+              }
+              
+              System.out.println(responseBody.string());
+            }
+          }
+        });
       }
-    }
-  });
-}
-```
+    ```
  
 ### Accessing Headers ([.kt][AccessHeadersKotlin], [.java][AccessHeadersJava])
 
@@ -123,368 +128,368 @@ When reading response a header, use `header(name)` to return the _last_ occurren
 
 To visit all headers, use the `Headers` class which supports access by index.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-
-fun run() {
-  val request = Request.Builder()
-      .url("https://api.github.com/repos/square/okhttp/issues")
-      .header("User-Agent", "OkHttp Headers.java")
-      .addHeader("Accept", "application/json; q=0.5")
-      .addHeader("Accept", "application/vnd.github.v3+json")
-      .build()
-
-  client.newCall(request).execute().use { response ->
-    if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-    println("Server: ${response.header("Server")}")
-    println("Date: ${response.header("Date")}")
-    println("Vary: ${response.headers("Vary")}")
-  }
-}
-```
-    
-=== "Java"
-```java
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  Request request = new Request.Builder()
-      .url("https://api.github.com/repos/square/okhttp/issues")
-      .header("User-Agent", "OkHttp Headers.java")
-      .addHeader("Accept", "application/json; q=0.5")
-      .addHeader("Accept", "application/vnd.github.v3+json")
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    System.out.println("Server: " + response.header("Server"));
-    System.out.println("Date: " + response.header("Date"));
-    System.out.println("Vary: " + response.headers("Vary"));
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+      
+      fun run() {
+        val request = Request.Builder()
+            .url("https://api.github.com/repos/square/okhttp/issues")
+            .header("User-Agent", "OkHttp Headers.java")
+            .addHeader("Accept", "application/json; q=0.5")
+            .addHeader("Accept", "application/vnd.github.v3+json")
+            .build()
+        
+        client.newCall(request).execute().use { response ->
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+          
+          println("Server: ${response.header("Server")}")
+          println("Date: ${response.header("Date")}")
+          println("Vary: ${response.headers("Vary")}")
+        }
+      }
+    ```
+    
+=== ":material-language-java: Java"
+    ```java
+      private final OkHttpClient client = new OkHttpClient();
+      
+      public void run() throws Exception {
+        Request request = new Request.Builder()
+            .url("https://api.github.com/repos/square/okhttp/issues")
+            .header("User-Agent", "OkHttp Headers.java")
+            .addHeader("Accept", "application/json; q=0.5")
+            .addHeader("Accept", "application/vnd.github.v3+json")
+            .build();
+        
+        try (Response response = client.newCall(request).execute()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+          
+          System.out.println("Server: " + response.header("Server"));
+          System.out.println("Date: " + response.header("Date"));
+          System.out.println("Vary: " + response.headers("Vary"));
+        }
+      }
+    ```
  
 ### Posting a String ([.kt][PostStringKotlin], [.java][PostStringJava])
 
 Use an HTTP POST to send a request body to a service. This example posts a markdown document to a web service that renders markdown as HTML. Because the entire request body is in memory simultaneously, avoid posting large (greater than 1 MiB) documents using this API.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-
-fun run() {
-  val postBody = """
-      |Releases
-      |--------
-      |
-      | * _1.0_ May 6, 2013
-      | * _1.1_ June 15, 2013
-      | * _1.2_ August 11, 2013
-      |""".trimMargin()
-
-  val request = Request.Builder()
-      .url("https://api.github.com/markdown/raw")
-      .post(postBody.toRequestBody(MEDIA_TYPE_MARKDOWN))
-      .build()
-
-  client.newCall(request).execute().use { response ->
-    if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-    println(response.body!!.string())
-  }
-}
-
-companion object {
-  val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
-}
-```
-=== "Java"
-```java
-public static final MediaType MEDIA_TYPE_MARKDOWN
-    = MediaType.parse("text/x-markdown; charset=utf-8");
-
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  String postBody = ""
-      + "Releases\n"
-      + "--------\n"
-      + "\n"
-      + " * _1.0_ May 6, 2013\n"
-      + " * _1.1_ June 15, 2013\n"
-      + " * _1.2_ August 11, 2013\n";
-
-  Request request = new Request.Builder()
-      .url("https://api.github.com/markdown/raw")
-      .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    System.out.println(response.body().string());
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+      
+      fun run() {
+        val postBody = """
+            |Releases
+            |--------
+            |
+            | * _1.0_ May 6, 2013
+            | * _1.1_ June 15, 2013
+            | * _1.2_ August 11, 2013
+            |""".trimMargin()
+        
+        val request = Request.Builder()
+            .url("https://api.github.com/markdown/raw")
+            .post(postBody.toRequestBody(MEDIA_TYPE_MARKDOWN))
+            .build()
+        
+        client.newCall(request).execute().use { response ->
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+          
+          println(response.body!!.string())
+        }
+      }
+      
+      companion object {
+        val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      public static final MediaType MEDIA_TYPE_MARKDOWN
+          = MediaType.parse("text/x-markdown; charset=utf-8");
+      
+      private final OkHttpClient client = new OkHttpClient();
+      
+      public void run() throws Exception {
+        String postBody = ""
+            + "Releases\n"
+            + "--------\n"
+            + "\n"
+            + " * _1.0_ May 6, 2013\n"
+            + " * _1.1_ June 15, 2013\n"
+            + " * _1.2_ August 11, 2013\n";
+        
+        Request request = new Request.Builder()
+            .url("https://api.github.com/markdown/raw")
+            .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
+            .build();
+        
+        try (Response response = client.newCall(request).execute()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+          
+          System.out.println(response.body().string());
+        }
+      }
+    ```
  
 ### Post Streaming ([.kt][PostStreamingKotlin], [.java][PostStreamingJava])
  
 Here we `POST` a request body as a stream. The content of this request body is being generated as it's being written. This example streams directly into the [Okio](https://github.com/square/okio) buffered sink. Your programs may prefer an `OutputStream`, which you can get from `BufferedSink.outputStream()`.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-
-fun run() {
-  val requestBody = object : RequestBody() {
-    override fun contentType() = MEDIA_TYPE_MARKDOWN
-
-    override fun writeTo(sink: BufferedSink) {
-      sink.writeUtf8("Numbers\n")
-      sink.writeUtf8("-------\n")
-      for (i in 2..997) {
-        sink.writeUtf8(String.format(" * $i = ${factor(i)}\n"))
-      }
-    }
-
-    private fun factor(n: Int): String {
-      for (i in 2 until n) {
-        val x = n / i
-        if (x * i == n) return "${factor(x)} × $i"
-      }
-      return n.toString()
-    }
-  }
-
-  val request = Request.Builder()
-      .url("https://api.github.com/markdown/raw")
-      .post(requestBody)
-      .build()
-
-  client.newCall(request).execute().use { response ->
-    if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-    println(response.body!!.string())
-  }
-}
-
-companion object {
-  val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
-}
-```
-=== "Java"
-```java
-public static final MediaType MEDIA_TYPE_MARKDOWN
-    = MediaType.parse("text/x-markdown; charset=utf-8");
-
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  RequestBody requestBody = new RequestBody() {
-    @Override public MediaType contentType() {
-      return MEDIA_TYPE_MARKDOWN;
-    }
-
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      sink.writeUtf8("Numbers\n");
-      sink.writeUtf8("-------\n");
-      for (int i = 2; i <= 997; i++) {
-        sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
-      }
-    }
-
-    private String factor(int n) {
-      for (int i = 2; i < n; i++) {
-        int x = n / i;
-        if (x * i == n) return factor(x) + " × " + i;
-      }
-      return Integer.toString(n);
-    }
-  };
-
-  Request request = new Request.Builder()
-      .url("https://api.github.com/markdown/raw")
-      .post(requestBody)
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    System.out.println(response.body().string());
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+    
+      fun run() {
+        val requestBody = object : RequestBody() {
+          override fun contentType() = MEDIA_TYPE_MARKDOWN
+    
+          override fun writeTo(sink: BufferedSink) {
+            sink.writeUtf8("Numbers\n")
+            sink.writeUtf8("-------\n")
+            for (i in 2..997) {
+              sink.writeUtf8(String.format(" * $i = ${factor(i)}\n"))
+            }
+          }
+    
+          private fun factor(n: Int): String {
+            for (i in 2 until n) {
+              val x = n / i
+              if (x * i == n) return "${factor(x)} × $i"
+            }
+            return n.toString()
+          }
+        }
+    
+        val request = Request.Builder()
+            .url("https://api.github.com/markdown/raw")
+            .post(requestBody)
+            .build()
+    
+        client.newCall(request).execute().use { response ->
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+    
+          println(response.body!!.string())
+        }
+      }
+    
+      companion object {
+        val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      public static final MediaType MEDIA_TYPE_MARKDOWN
+          = MediaType.parse("text/x-markdown; charset=utf-8");
+    
+      private final OkHttpClient client = new OkHttpClient();
+    
+      public void run() throws Exception {
+        RequestBody requestBody = new RequestBody() {
+          @Override public MediaType contentType() {
+            return MEDIA_TYPE_MARKDOWN;
+          }
+    
+          @Override public void writeTo(BufferedSink sink) throws IOException {
+            sink.writeUtf8("Numbers\n");
+            sink.writeUtf8("-------\n");
+            for (int i = 2; i <= 997; i++) {
+              sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+            }
+          }
+    
+          private String factor(int n) {
+            for (int i = 2; i < n; i++) {
+              int x = n / i;
+              if (x * i == n) return factor(x) + " × " + i;
+            }
+            return Integer.toString(n);
+          }
+        };
+    
+        Request request = new Request.Builder()
+            .url("https://api.github.com/markdown/raw")
+            .post(requestBody)
+            .build();
+    
+        try (Response response = client.newCall(request).execute()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    
+          System.out.println(response.body().string());
+        }
+      }
+    ```
  
 ### Posting a File ([.kt][PostFileKotlin], [.java][PostFileJava])
 
 It's easy to use a file as a request body.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-
-fun run() {
-  val file = File("README.md")
-
-  val request = Request.Builder()
-      .url("https://api.github.com/markdown/raw")
-      .post(file.asRequestBody(MEDIA_TYPE_MARKDOWN))
-      .build()
-
-  client.newCall(request).execute().use { response ->
-    if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-    println(response.body!!.string())
-  }
-}
-
-companion object {
-  val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
-}
-```
-=== "Java"
-```java
-public static final MediaType MEDIA_TYPE_MARKDOWN
-    = MediaType.parse("text/x-markdown; charset=utf-8");
-
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  File file = new File("README.md");
-
-  Request request = new Request.Builder()
-      .url("https://api.github.com/markdown/raw")
-      .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    System.out.println(response.body().string());
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+    
+      fun run() {
+        val file = File("README.md")
+    
+        val request = Request.Builder()
+            .url("https://api.github.com/markdown/raw")
+            .post(file.asRequestBody(MEDIA_TYPE_MARKDOWN))
+            .build()
+    
+        client.newCall(request).execute().use { response ->
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+    
+          println(response.body!!.string())
+        }
+      }
+    
+      companion object {
+        val MEDIA_TYPE_MARKDOWN = "text/x-markdown; charset=utf-8".toMediaType()
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      public static final MediaType MEDIA_TYPE_MARKDOWN
+          = MediaType.parse("text/x-markdown; charset=utf-8");
+    
+      private final OkHttpClient client = new OkHttpClient();
+    
+      public void run() throws Exception {
+        File file = new File("README.md");
+    
+        Request request = new Request.Builder()
+            .url("https://api.github.com/markdown/raw")
+            .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
+            .build();
+    
+        try (Response response = client.newCall(request).execute()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    
+          System.out.println(response.body().string());
+        }
+      }
+    ```
  
 ### Posting form parameters ([.kt][PostFormKotlin], [.java][PostFormJava])
 
 Use `FormBody.Builder` to build a request body that works like an HTML `<form>` tag. Names and values will be encoded using an HTML-compatible form URL encoding.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-
-fun run() {
-  val formBody = FormBody.Builder()
-      .add("search", "Jurassic Park")
-      .build()
-  val request = Request.Builder()
-      .url("https://en.wikipedia.org/w/index.php")
-      .post(formBody)
-      .build()
-
-  client.newCall(request).execute().use { response ->
-    if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-    println(response.body!!.string())
-  }
-}
-```
-=== "Java"
-```java
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  RequestBody formBody = new FormBody.Builder()
-      .add("search", "Jurassic Park")
-      .build();
-  Request request = new Request.Builder()
-      .url("https://en.wikipedia.org/w/index.php")
-      .post(formBody)
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    System.out.println(response.body().string());
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+    
+      fun run() {
+        val formBody = FormBody.Builder()
+            .add("search", "Jurassic Park")
+            .build()
+        val request = Request.Builder()
+            .url("https://en.wikipedia.org/w/index.php")
+            .post(formBody)
+            .build()
+    
+        client.newCall(request).execute().use { response ->
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+    
+          println(response.body!!.string())
+        }
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      private final OkHttpClient client = new OkHttpClient();
+    
+      public void run() throws Exception {
+        RequestBody formBody = new FormBody.Builder()
+            .add("search", "Jurassic Park")
+            .build();
+        Request request = new Request.Builder()
+            .url("https://en.wikipedia.org/w/index.php")
+            .post(formBody)
+            .build();
+    
+        try (Response response = client.newCall(request).execute()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    
+          System.out.println(response.body().string());
+        }
+      }
+    ```
  
 ### Posting a multipart request ([.kt][PostMultipartKotlin], [.java][PostMultipartJava])
 
 `MultipartBody.Builder` can build sophisticated request bodies compatible with HTML file upload forms. Each part of a multipart request body is itself a request body, and can define its own headers. If present, these headers should describe the part body, such as its `Content-Disposition`. The `Content-Length` and `Content-Type` headers are added automatically if they're available.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-
-fun run() {
-  // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
-  val requestBody = MultipartBody.Builder()
-      .setType(MultipartBody.FORM)
-      .addFormDataPart("title", "Square Logo")
-      .addFormDataPart("image", "logo-square.png",
-          File("docs/images/logo-square.png").asRequestBody(MEDIA_TYPE_PNG))
-      .build()
-
-  val request = Request.Builder()
-      .header("Authorization", "Client-ID $IMGUR_CLIENT_ID")
-      .url("https://api.imgur.com/3/image")
-      .post(requestBody)
-      .build()
-
-  client.newCall(request).execute().use { response ->
-    if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-    println(response.body!!.string())
-  }
-}
-
-companion object {
-  /**
-   * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
-   * these examples, please request your own client ID! https://api.imgur.com/oauth2
-   */
-  private val IMGUR_CLIENT_ID = "9199fdef135c122"
-  private val MEDIA_TYPE_PNG = "image/png".toMediaType()
-}
-```
-=== "Java"
-```java
-/**
- * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
- * these examples, please request your own client ID! https://api.imgur.com/oauth2
- */
-private static final String IMGUR_CLIENT_ID = "...";
-private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
-
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
-  RequestBody requestBody = new MultipartBody.Builder()
-      .setType(MultipartBody.FORM)
-      .addFormDataPart("title", "Square Logo")
-      .addFormDataPart("image", "logo-square.png",
-          RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
-      .build();
-
-  Request request = new Request.Builder()
-      .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
-      .url("https://api.imgur.com/3/image")
-      .post(requestBody)
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    System.out.println(response.body().string());
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+    
+      fun run() {
+        // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+        val requestBody = MultipartBody.Builder()
+            .setType(MultipartBody.FORM)
+            .addFormDataPart("title", "Square Logo")
+            .addFormDataPart("image", "logo-square.png",
+                File("docs/images/logo-square.png").asRequestBody(MEDIA_TYPE_PNG))
+            .build()
+    
+        val request = Request.Builder()
+            .header("Authorization", "Client-ID $IMGUR_CLIENT_ID")
+            .url("https://api.imgur.com/3/image")
+            .post(requestBody)
+            .build()
+    
+        client.newCall(request).execute().use { response ->
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+    
+          println(response.body!!.string())
+        }
+      }
+    
+      companion object {
+        /**
+         * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+         * these examples, please request your own client ID! https://api.imgur.com/oauth2
+         */
+        private val IMGUR_CLIENT_ID = "9199fdef135c122"
+        private val MEDIA_TYPE_PNG = "image/png".toMediaType()
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      /**
+       * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running
+       * these examples, please request your own client ID! https://api.imgur.com/oauth2
+       */
+      private static final String IMGUR_CLIENT_ID = "...";
+      private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+    
+      private final OkHttpClient client = new OkHttpClient();
+    
+      public void run() throws Exception {
+        // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+        RequestBody requestBody = new MultipartBody.Builder()
+            .setType(MultipartBody.FORM)
+            .addFormDataPart("title", "Square Logo")
+            .addFormDataPart("image", "logo-square.png",
+                RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
+            .build();
+    
+        Request request = new Request.Builder()
+            .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
+            .url("https://api.imgur.com/3/image")
+            .post(requestBody)
+            .build();
+    
+        try (Response response = client.newCall(request).execute()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    
+          System.out.println(response.body().string());
+        }
+      }
+    ```
  
 ### Parse a JSON Response With Moshi ([.kt][ParseResponseWithMoshiKotlin], [.java][ParseResponseWithMoshiJava])
   
@@ -492,64 +497,64 @@ public void run() throws Exception {
 
 Note that `ResponseBody.charStream()` uses the `Content-Type` response header to select which charset to use when decoding the response body. It defaults to `UTF-8` if no charset is specified.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-private val moshi = Moshi.Builder().build()
-private val gistJsonAdapter = moshi.adapter(Gist::class.java)
-
-fun run() {
-  val request = Request.Builder()
-      .url("https://api.github.com/gists/c2a7c39532239ff261be")
-      .build()
-  client.newCall(request).execute().use { response ->
-    if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-    val gist = gistJsonAdapter.fromJson(response.body!!.source())
-
-    for ((key, value) in gist!!.files!!) {
-      println(key)
-      println(value.content)
-    }
-  }
-}
-
-@JsonClass(generateAdapter = true)
-data class Gist(var files: Map<String, GistFile>?)
-
-@JsonClass(generateAdapter = true)
-data class GistFile(var content: String?)
-```
-=== "Java"
-```java
-private final OkHttpClient client = new OkHttpClient();
-private final Moshi moshi = new Moshi.Builder().build();
-private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
-
-public void run() throws Exception {
-  Request request = new Request.Builder()
-      .url("https://api.github.com/gists/c2a7c39532239ff261be")
-      .build();
-  try (Response response = client.newCall(request).execute()) {
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    Gist gist = gistJsonAdapter.fromJson(response.body().source());
-
-    for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
-      System.out.println(entry.getKey());
-      System.out.println(entry.getValue().content);
-    }
-  }
-}
-
-static class Gist {
-  Map<String, GistFile> files;
-}
-
-static class GistFile {
-  String content;
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+      private val moshi = Moshi.Builder().build()
+      private val gistJsonAdapter = moshi.adapter(Gist::class.java)
+    
+      fun run() {
+        val request = Request.Builder()
+            .url("https://api.github.com/gists/c2a7c39532239ff261be")
+            .build()
+        client.newCall(request).execute().use { response ->
+          if (!response.isSuccessful) throw IOException("Unexpected code $response")
+    
+          val gist = gistJsonAdapter.fromJson(response.body!!.source())
+    
+          for ((key, value) in gist!!.files!!) {
+            println(key)
+            println(value.content)
+          }
+        }
+      }
+    
+      @JsonClass(generateAdapter = true)
+      data class Gist(var files: Map<String, GistFile>?)
+    
+      @JsonClass(generateAdapter = true)
+      data class GistFile(var content: String?)
+    ```
+=== ":material-language-java: Java"
+    ```java
+      private final OkHttpClient client = new OkHttpClient();
+      private final Moshi moshi = new Moshi.Builder().build();
+      private final JsonAdapter<Gist> gistJsonAdapter = moshi.adapter(Gist.class);
+    
+      public void run() throws Exception {
+        Request request = new Request.Builder()
+            .url("https://api.github.com/gists/c2a7c39532239ff261be")
+            .build();
+        try (Response response = client.newCall(request).execute()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    
+          Gist gist = gistJsonAdapter.fromJson(response.body().source());
+    
+          for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
+            System.out.println(entry.getKey());
+            System.out.println(entry.getValue().content);
+          }
+        }
+      }
+    
+      static class Gist {
+        Map<String, GistFile> files;
+      }
+    
+      static class GistFile {
+        String content;
+      }
+    ```
  
 ### Response Caching ([.kt][CacheResponseKotlin], [.java][CacheResponseJava])
 
@@ -559,268 +564,269 @@ It is an error to have multiple caches accessing the same cache directory simult
 
 Response caching uses HTTP headers for all configuration. You can add request headers like `Cache-Control: max-stale=3600` and OkHttp's cache will honor them. Your webserver configures how long responses are cached with its own response headers, like `Cache-Control: max-age=9600`. There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET.
 
-=== "Kotlin"
-```kotlin
-private val client: OkHttpClient = OkHttpClient.Builder()
-    .cache(Cache(
-        directory = cacheDirectory,
-        maxSize = 10L * 1024L * 1024L // 10 MiB
-    ))
-    .build()
-
-fun run() {
-  val request = Request.Builder()
-      .url("http://publicobject.com/helloworld.txt")
-      .build()
-
-  val response1Body = client.newCall(request).execute().use {
-    if (!it.isSuccessful) throw IOException("Unexpected code $it")
-
-    println("Response 1 response:          $it")
-    println("Response 1 cache response:    ${it.cacheResponse}")
-    println("Response 1 network response:  ${it.networkResponse}")
-    return@use it.body!!.string()
-  }
-
-  val response2Body = client.newCall(request).execute().use {
-    if (!it.isSuccessful) throw IOException("Unexpected code $it")
-
-    println("Response 2 response:          $it")
-    println("Response 2 cache response:    ${it.cacheResponse}")
-    println("Response 2 network response:  ${it.networkResponse}")
-    return@use it.body!!.string()
-  }
-
-  println("Response 2 equals Response 1? " + (response1Body == response2Body))
-}
-```
-=== "Java"
-```java
-private final OkHttpClient client;
-
-public CacheResponse(File cacheDirectory) throws Exception {
-  int cacheSize = 10 * 1024 * 1024; // 10 MiB
-  Cache cache = new Cache(cacheDirectory, cacheSize);
-
-  client = new OkHttpClient.Builder()
-      .cache(cache)
-      .build();
-}
-
-public void run() throws Exception {
-  Request request = new Request.Builder()
-      .url("http://publicobject.com/helloworld.txt")
-      .build();
-
-  String response1Body;
-  try (Response response1 = client.newCall(request).execute()) {
-    if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
-
-    response1Body = response1.body().string();
-    System.out.println("Response 1 response:          " + response1);
-    System.out.println("Response 1 cache response:    " + response1.cacheResponse());
-    System.out.println("Response 1 network response:  " + response1.networkResponse());
-  }
-
-  String response2Body;
-  try (Response response2 = client.newCall(request).execute()) {
-    if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
-
-    response2Body = response2.body().string();
-    System.out.println("Response 2 response:          " + response2);
-    System.out.println("Response 2 cache response:    " + response2.cacheResponse());
-    System.out.println("Response 2 network response:  " + response2.networkResponse());
-  }
-
-  System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
-}
-```
-
-To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-n-e-t-w-o-r-k/). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](https://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-c-a-c-h-e/). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client: OkHttpClient = OkHttpClient.Builder()
+          .cache(Cache(
+              directory = cacheDirectory,
+              maxSize = 10L * 1024L * 1024L // 10 MiB
+          ))
+          .build()
+    
+      fun run() {
+        val request = Request.Builder()
+            .url("http://publicobject.com/helloworld.txt")
+            .build()
+    
+        val response1Body = client.newCall(request).execute().use {
+          if (!it.isSuccessful) throw IOException("Unexpected code $it")
+    
+          println("Response 1 response:          $it")
+          println("Response 1 cache response:    ${it.cacheResponse}")
+          println("Response 1 network response:  ${it.networkResponse}")
+          return@use it.body!!.string()
+        }
+    
+        val response2Body = client.newCall(request).execute().use {
+          if (!it.isSuccessful) throw IOException("Unexpected code $it")
+    
+          println("Response 2 response:          $it")
+          println("Response 2 cache response:    ${it.cacheResponse}")
+          println("Response 2 network response:  ${it.networkResponse}")
+          return@use it.body!!.string()
+        }
+    
+        println("Response 2 equals Response 1? " + (response1Body == response2Body))
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      private final OkHttpClient client;
+    
+      public CacheResponse(File cacheDirectory) throws Exception {
+        int cacheSize = 10 * 1024 * 1024; // 10 MiB
+        Cache cache = new Cache(cacheDirectory, cacheSize);
+    
+        client = new OkHttpClient.Builder()
+            .cache(cache)
+            .build();
+      }
+    
+      public void run() throws Exception {
+        Request request = new Request.Builder()
+            .url("http://publicobject.com/helloworld.txt")
+            .build();
+    
+        String response1Body;
+        try (Response response1 = client.newCall(request).execute()) {
+          if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
+    
+          response1Body = response1.body().string();
+          System.out.println("Response 1 response:          " + response1);
+          System.out.println("Response 1 cache response:    " + response1.cacheResponse());
+          System.out.println("Response 1 network response:  " + response1.networkResponse());
+        }
+    
+        String response2Body;
+        try (Response response2 = client.newCall(request).execute()) {
+          if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
+    
+          response2Body = response2.body().string();
+          System.out.println("Response 2 response:          " + response2);
+          System.out.println("Response 2 cache response:    " + response2.cacheResponse());
+          System.out.println("Response 2 network response:  " + response2.networkResponse());
+        }
+    
+        System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
+      }
+    ```
+
+To prevent a response from using the cache, use [`CacheControl.FORCE_NETWORK`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-n-e-t-w-o-r-k/). To prevent it from using the network, use [`CacheControl.FORCE_CACHE`](http://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache-control/-f-o-r-c-e_-c-a-c-h-e/). Be warned: if you use `FORCE_CACHE` and the response requires the network, OkHttp will return a `504 Unsatisfiable Request` response.
+
  
 ### Canceling a Call ([.kt][CancelCallKotlin], [.java][CancelCallJava])
 
 Use `Call.cancel()` to stop an ongoing call immediately. If a thread is currently writing a request or reading a response, it will receive an `IOException`. Use this to conserve the network when a call is no longer necessary; for example when your user navigates away from an application. Both synchronous and asynchronous calls can be canceled.
 
-=== "Kotlin"
-```kotlin
-private val executor = Executors.newScheduledThreadPool(1)
-private val client = OkHttpClient()
-
-fun run() {
-  val request = Request.Builder()
-      .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
-      .build()
-
-  val startNanos = System.nanoTime()
-  val call = client.newCall(request)
-
-  // Schedule a job to cancel the call in 1 second.
-  executor.schedule({
-    System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f)
-    call.cancel()
-    System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f)
-  }, 1, TimeUnit.SECONDS)
-
-  System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f)
-  try {
-    call.execute().use { response ->
-      System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
-          (System.nanoTime() - startNanos) / 1e9f, response)
-    }
-  } catch (e: IOException) {
-    System.out.printf("%.2f Call failed as expected: %s%n",
-        (System.nanoTime() - startNanos) / 1e9f, e)
-  }
-}
-```
-=== "Java"
-```java
-private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  Request request = new Request.Builder()
-      .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
-      .build();
-
-  final long startNanos = System.nanoTime();
-  final Call call = client.newCall(request);
-
-  // Schedule a job to cancel the call in 1 second.
-  executor.schedule(new Runnable() {
-    @Override public void run() {
-      System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
-      call.cancel();
-      System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
-    }
-  }, 1, TimeUnit.SECONDS);
-
-  System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
-  try (Response response = call.execute()) {
-    System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
-        (System.nanoTime() - startNanos) / 1e9f, response);
-  } catch (IOException e) {
-    System.out.printf("%.2f Call failed as expected: %s%n",
-        (System.nanoTime() - startNanos) / 1e9f, e);
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val executor = Executors.newScheduledThreadPool(1)
+      private val client = OkHttpClient()
+    
+      fun run() {
+        val request = Request.Builder()
+            .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+            .build()
+    
+        val startNanos = System.nanoTime()
+        val call = client.newCall(request)
+    
+        // Schedule a job to cancel the call in 1 second.
+        executor.schedule({
+          System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f)
+          call.cancel()
+          System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f)
+        }, 1, TimeUnit.SECONDS)
+    
+        System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f)
+        try {
+          call.execute().use { response ->
+            System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+                (System.nanoTime() - startNanos) / 1e9f, response)
+          }
+        } catch (e: IOException) {
+          System.out.printf("%.2f Call failed as expected: %s%n",
+              (System.nanoTime() - startNanos) / 1e9f, e)
+        }
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
+      private final OkHttpClient client = new OkHttpClient();
+    
+      public void run() throws Exception {
+        Request request = new Request.Builder()
+            .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+            .build();
+    
+        final long startNanos = System.nanoTime();
+        final Call call = client.newCall(request);
+    
+        // Schedule a job to cancel the call in 1 second.
+        executor.schedule(new Runnable() {
+          @Override public void run() {
+            System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
+            call.cancel();
+            System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
+          }
+        }, 1, TimeUnit.SECONDS);
+    
+        System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
+        try (Response response = call.execute()) {
+          System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+              (System.nanoTime() - startNanos) / 1e9f, response);
+        } catch (IOException e) {
+          System.out.printf("%.2f Call failed as expected: %s%n",
+              (System.nanoTime() - startNanos) / 1e9f, e);
+        }
+      }
+    ```
  
 ### Timeouts ([.kt][ConfigureTimeoutsKotlin], [.java][ConfigureTimeoutsJava])
 
 Use timeouts to fail a call when its peer is unreachable. Network partitions can be due to client connectivity problems, server availability problems, or anything between. OkHttp supports connect, write, read, and full call timeouts.
 
-=== "Kotlin"
-```kotlin
-private val client: OkHttpClient = OkHttpClient.Builder()
-    .connectTimeout(5, TimeUnit.SECONDS)
-    .writeTimeout(5, TimeUnit.SECONDS)
-    .readTimeout(5, TimeUnit.SECONDS)
-    .callTimeout(10, TimeUnit.SECONDS)
-    .build()
-
-fun run() {
-  val request = Request.Builder()
-      .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
-      .build()
-
-  client.newCall(request).execute().use { response ->
-    println("Response completed: $response")
-  }
-}
-```
-=== "Java"
-```java
-private final OkHttpClient client;
-
-public ConfigureTimeouts() throws Exception {
-  client = new OkHttpClient.Builder()
-      .connectTimeout(10, TimeUnit.SECONDS)
-      .writeTimeout(10, TimeUnit.SECONDS)
-      .readTimeout(30, TimeUnit.SECONDS)
-      .build();
-}
-
-public void run() throws Exception {
-  Request request = new Request.Builder()
-      .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    System.out.println("Response completed: " + response);
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client: OkHttpClient = OkHttpClient.Builder()
+          .connectTimeout(5, TimeUnit.SECONDS)
+          .writeTimeout(5, TimeUnit.SECONDS)
+          .readTimeout(5, TimeUnit.SECONDS)
+          .callTimeout(10, TimeUnit.SECONDS)
+          .build()
+    
+      fun run() {
+        val request = Request.Builder()
+            .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+            .build()
+    
+        client.newCall(request).execute().use { response ->
+          println("Response completed: $response")
+        }
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      private final OkHttpClient client;
+    
+      public ConfigureTimeouts() throws Exception {
+        client = new OkHttpClient.Builder()
+            .connectTimeout(10, TimeUnit.SECONDS)
+            .writeTimeout(10, TimeUnit.SECONDS)
+            .readTimeout(30, TimeUnit.SECONDS)
+            .build();
+      }
+    
+      public void run() throws Exception {
+        Request request = new Request.Builder()
+            .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+            .build();
+    
+        try (Response response = client.newCall(request).execute()) {
+          System.out.println("Response completed: " + response);
+        }
+      }
+    ```
  
 ### Per-call Configuration ([.kt][PerCallSettingsKotlin], [.java][PerCallSettingsJava])
 
 All the HTTP client configuration lives in `OkHttpClient` including proxy settings, timeouts, and caches. When you need to change the configuration of a single call, call `OkHttpClient.newBuilder()`. This returns a builder that shares the same connection pool, dispatcher, and configuration with the original client. In the example below, we make one request with a 500 ms timeout and another with a 3000 ms timeout.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient()
-
-fun run() {
-  val request = Request.Builder()
-      .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
-      .build()
-
-  // Copy to customize OkHttp for this request.
-  val client1 = client.newBuilder()
-      .readTimeout(500, TimeUnit.MILLISECONDS)
-      .build()
-  try {
-    client1.newCall(request).execute().use { response ->
-      println("Response 1 succeeded: $response")
-    }
-  } catch (e: IOException) {
-    println("Response 1 failed: $e")
-  }
-
-  // Copy to customize OkHttp for this request.
-  val client2 = client.newBuilder()
-      .readTimeout(3000, TimeUnit.MILLISECONDS)
-      .build()
-  try {
-    client2.newCall(request).execute().use { response ->
-      println("Response 2 succeeded: $response")
-    }
-  } catch (e: IOException) {
-    println("Response 2 failed: $e")
-  }
-}
-```
-=== "Java"
-```java
-private final OkHttpClient client = new OkHttpClient();
-
-public void run() throws Exception {
-  Request request = new Request.Builder()
-      .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
-      .build();
-
-  // Copy to customize OkHttp for this request.
-  OkHttpClient client1 = client.newBuilder()
-      .readTimeout(500, TimeUnit.MILLISECONDS)
-      .build();
-  try (Response response = client1.newCall(request).execute()) {
-    System.out.println("Response 1 succeeded: " + response);
-  } catch (IOException e) {
-    System.out.println("Response 1 failed: " + e);
-  }
-
-  // Copy to customize OkHttp for this request.
-  OkHttpClient client2 = client.newBuilder()
-      .readTimeout(3000, TimeUnit.MILLISECONDS)
-      .build();
-  try (Response response = client2.newCall(request).execute()) {
-    System.out.println("Response 2 succeeded: " + response);
-  } catch (IOException e) {
-    System.out.println("Response 2 failed: " + e);
-  }
-}
-```
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient()
+    
+      fun run() {
+        val request = Request.Builder()
+            .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+            .build()
+    
+        // Copy to customize OkHttp for this request.
+        val client1 = client.newBuilder()
+            .readTimeout(500, TimeUnit.MILLISECONDS)
+            .build()
+        try {
+          client1.newCall(request).execute().use { response ->
+            println("Response 1 succeeded: $response")
+          }
+        } catch (e: IOException) {
+          println("Response 1 failed: $e")
+        }
+    
+        // Copy to customize OkHttp for this request.
+        val client2 = client.newBuilder()
+            .readTimeout(3000, TimeUnit.MILLISECONDS)
+            .build()
+        try {
+          client2.newCall(request).execute().use { response ->
+            println("Response 2 succeeded: $response")
+          }
+        } catch (e: IOException) {
+          println("Response 2 failed: $e")
+        }
+      }
+    ```
+=== ":material-language-java: Java"
+    ```java
+      private final OkHttpClient client = new OkHttpClient();
+    
+      public void run() throws Exception {
+        Request request = new Request.Builder()
+            .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+            .build();
+    
+        // Copy to customize OkHttp for this request.
+        OkHttpClient client1 = client.newBuilder()
+            .readTimeout(500, TimeUnit.MILLISECONDS)
+            .build();
+        try (Response response = client1.newCall(request).execute()) {
+          System.out.println("Response 1 succeeded: " + response);
+        } catch (IOException e) {
+          System.out.println("Response 1 failed: " + e);
+        }
+    
+        // Copy to customize OkHttp for this request.
+        OkHttpClient client2 = client.newBuilder()
+            .readTimeout(3000, TimeUnit.MILLISECONDS)
+            .build();
+        try (Response response = client2.newCall(request).execute()) {
+          System.out.println("Response 2 succeeded: " + response);
+        } catch (IOException e) {
+          System.out.println("Response 2 failed: " + e);
+        }
+      }
+    ```
  
 ### Handling authentication ([.kt][AuthenticateKotlin], [.java][AuthenticateJava])
 
@@ -828,101 +834,95 @@ OkHttp can automatically retry unauthenticated requests. When a response is `401
 
 Use `Response.challenges()` to get the schemes and realms of any authentication challenges. When fulfilling a `Basic` challenge, use `Credentials.basic(username, password)` to encode the request header.
 
-=== "Kotlin"
-```kotlin
-private val client = OkHttpClient.Builder()
-    .authenticator(object : Authenticator {
-      @Throws(IOException::class)
-      override fun authenticate(route: Route?, response: Response): Request? {
-        if (response.request.header("Authorization") != null) {
-          return null // Give up, we've already attempted to authenticate.
-        }
-
-        println("Authenticating for response: $response")
-        println("Challenges: ${response.challenges()}")
-        val credential = Credentials.basic("jesse", "password1")
-        return response.request.newBuilder()
-            .header("Authorization", credential)
+=== ":material-language-kotlin: Kotlin"
+    ```kotlin
+      private val client = OkHttpClient.Builder()
+          .authenticator(object : Authenticator {
+            @Throws(IOException::class)
+            override fun authenticate(route: Route?, response: Response): Request? {
+              if (response.request.header("Authorization") != null) {
+                return null // Give up, we've already attempted to authenticate.
+              }
+    
+              println("Authenticating for response: $response")
+              println("Challenges: ${response.challenges()}")
+              val credential = Credentials.basic("jesse", "password1")
+              return response.request.newBuilder()
+                  .header("Authorization", credential)
+                  .build()
+            }
+          })
+          .build()
+    
+      fun run() {
+        val request = Request.Builder()
+            .url("http://publicobject.com/secrets/hellosecret.txt")
             .build()
       }
-    })
-    .build()
-
-fun run() {
-  val request = Request.Builder()
-      .url("http://publicobject.com/secrets/hellosecret.txt")
-      .build()
-
-  client.newCall(request).execute().use { response ->
-    if (!response.isSuccessful) throw IOException("Unexpected code $response")
-
-    println(response.body!!.string())
-  }
-}
-```
-=== "Java"
-```java
-private final OkHttpClient client;
-
-public Authenticate() {
-  client = new OkHttpClient.Builder()
-      .authenticator(new Authenticator() {
-        @Override public Request authenticate(Route route, Response response) throws IOException {
-          if (response.request().header("Authorization") != null) {
-            return null; // Give up, we've already attempted to authenticate.
-          }
-
-          System.out.println("Authenticating for response: " + response);
-          System.out.println("Challenges: " + response.challenges());
-          String credential = Credentials.basic("jesse", "password1");
-          return response.request().newBuilder()
-              .header("Authorization", credential)
-              .build();
+    ```
+=== ":material-language-java: Java"
+    ```java
+      private final OkHttpClient client;
+    
+      public Authenticate() {
+        client = new OkHttpClient.Builder()
+            .authenticator(new Authenticator() {
+              @Override public Request authenticate(Route route, Response response) throws IOException {
+                if (response.request().header("Authorization") != null) {
+                  return null; // Give up, we've already attempted to authenticate.
+                }
+    
+                System.out.println("Authenticating for response: " + response);
+                System.out.println("Challenges: " + response.challenges());
+                String credential = Credentials.basic("jesse", "password1");
+                return response.request().newBuilder()
+                    .header("Authorization", credential)
+                    .build();
+              }
+            })
+            .build();
+      }
+    
+      public void run() throws Exception {
+        Request request = new Request.Builder()
+            .url("http://publicobject.com/secrets/hellosecret.txt")
+            .build();
+    
+        try (Response response = client.newCall(request).execute()) {
+          if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+    
+          System.out.println(response.body().string());
+        }
+      }
+    ```
+    
+    To avoid making many retries when authentication isn't working, you can return null to give up. For example, you may want to skip the retry when these exact credentials have already been attempted:
+    
+    ```java
+      if (credential.equals(response.request().header("Authorization"))) {
+        return null; // If we already failed with these credentials, don't retry.
+       }
+    ```
+    
+    You may also skip the retry when you’ve hit an application-defined attempt limit:
+    
+    ```java
+      if (responseCount(response) >= 3) {
+        return null; // If we've failed 3 times, give up.
+      }
+    ```
+    
+    This above code relies on this `responseCount()` method:
+    
+    ```java
+      private int responseCount(Response response) {
+        int result = 1;
+        while ((response = response.priorResponse()) != null) {
+          result++;
         }
-      })
-      .build();
-}
-
-public void run() throws Exception {
-  Request request = new Request.Builder()
-      .url("http://publicobject.com/secrets/hellosecret.txt")
-      .build();
-
-  try (Response response = client.newCall(request).execute()) {
-    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
-
-    System.out.println(response.body().string());
-  }
-}
-```
-    
-  To avoid making many retries when authentication isn't working, you can return null to give up. For example, you may want to skip the retry when these exact credentials have already been attempted:
-
-```java
-if (credential.equals(response.request().header("Authorization"))) {
-  return null; // If we already failed with these credentials, don't retry.
- }
-```
-
-  You may also skip the retry when you’ve hit an application-defined attempt limit:
-
-```java
-if (responseCount(response) >= 3) {
-  return null; // If we've failed 3 times, give up.
-}
-```
-
-  This above code relies on this `responseCount()` method:
-
-```java
-private int responseCount(Response response) {
-  int result = 1;
-  while ((response = response.priorResponse()) != null) {
-    result++;
-  }
-  return result;
-}
-```
+        return result;
+      }
+    ```
 
  [SynchronousGetJava]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/SynchronousGet.java 
  [SynchronousGetKotlin]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/kt/SynchronousGet.kt
diff --git a/docs/security.md b/docs/security.md
deleted file mode 100644
index 3f8b72956..000000000
--- a/docs/security.md
+++ /dev/null
@@ -1,19 +0,0 @@
-Security Policy
-===============
-
-## Supported Versions
-
-| Version | Supported        | Notes          |
-| ------- | ---------------- | -------------- |
-| 4.x     | ✅               |  Android 5.0+ (API level 21+) and on Java 8+. |
-| 3.12.x  | Until 2021-12-31 | Android 2.3+ (API level 9+) and Java 7+. Platforms may not support TLSv1.2. |
-
-
-## Reporting a Vulnerability
-
-Square recognizes the important contributions the security research community
-can make. We therefore encourage reporting security issues with the code
-contained in this repository.
-
-If you believe you have discovered a security vulnerability, please follow the
-guidelines at https://bugcrowd.com/squareopensource
diff --git a/docs/security/security.md b/docs/security/security.md
new file mode 100644
index 000000000..8a2319947
--- /dev/null
+++ b/docs/security/security.md
@@ -0,0 +1,20 @@
+Security
+========
+
+## Supported Versions
+
+| Version | Supported           | Notes                                        |
+| ------- | ------------------- | -------------------------------------------- |
+| 5.x     | ✅                  | APIs subject to change in alpha releases.    |
+| 4.x     | ✅                  | Android 5.0+ (API level 21+) and on Java 8+. |
+| 3.x     | ❌ Ended 2021-12-31 | Android 2.3+ (API level 9+) and Java 7+.     |
+
+
+## Reporting a Vulnerability
+
+Square recognizes the important contributions the security research community
+can make. We therefore encourage reporting security issues with the code
+contained in this repository.
+
+If you believe you have discovered a security vulnerability, please follow the
+guidelines at https://bugcrowd.com/squareopensource
diff --git a/docs/security_providers.md b/docs/security/security_providers.md
similarity index 100%
rename from docs/security_providers.md
rename to docs/security/security_providers.md
diff --git a/docs/tls_configuration_history.md b/docs/security/tls_configuration_history.md
similarity index 100%
rename from docs/tls_configuration_history.md
rename to docs/security/tls_configuration_history.md
diff --git a/mkdocs.yml b/mkdocs.yml
index fc17ebfdf..ddf4856a8 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -2,75 +2,124 @@ site_name: OkHttp
 site_url: https://square.github.io/okhttp/
 repo_name: OkHttp
 repo_url: https://github.com/square/okhttp
-site_description: "An HTTP & HTTP/2 client for Android and Java applications"
+site_description: "Square’s meticulous HTTP client for the JVM, Android, and GraalVM"
 site_author: Square, Inc.
 remote_branch: gh-pages
 edit_uri: ""
 
-copyright: 'Copyright &copy; 2019 Square, Inc.'
+copyright: 'Copyright &copy; 2022 Block, Inc.'
 
 theme:
   name: 'material'
-  favicon: images/icon-square.png
-  logo: images/icon-square.png
+  favicon: assets/images/icon-square.png
+  logo: assets/images/icon-square.png
   palette:
-    primary: 'teal'
-    accent: 'white'
+    - media: "(prefers-color-scheme: light)"
+      scheme: default
+      primary: teal
+      accent: blue
+      toggle:
+        icon: octicons/sun-24
+        name: "Switch to Dark Mode"
+    - media: "(prefers-color-scheme: dark)"
+      scheme: slate
+      primary: teal
+      accent: blue
+      toggle:
+        icon: octicons/moon-24
+        name: "Switch to Light Mode"
+  features:
+  - navigation.tabs
 
 extra_css:
-  - 'css/app.css'
+  - 'assets/css/app.css'
 
 markdown_extensions:
   - smarty
-  - codehilite:
-      guess_lang: false
   - footnotes
   - meta
   - toc:
       permalink: true
+  - attr_list
   - pymdownx.betterem:
       smart_enable: all
   - pymdownx.caret
+  - pymdownx.emoji:
+      emoji_index: !!python/name:materialx.emoji.twemoji
+      emoji_generator: !!python/name:materialx.emoji.to_svg
   - pymdownx.inlinehilite
   - pymdownx.magiclink
   - pymdownx.smartsymbols
   - pymdownx.superfences
   - pymdownx.tilde
-  - pymdownx.tabbed
+  - pymdownx.tabbed:
+      alternate_style: true
   - tables
 
+plugins:
+  - search
+  - redirects:
+      redirect_maps:
+        # Redirect all feature pages to features/*
+        'caching.md': 'features/caching.md'
+        'calls.md': 'features/calls.md'
+        'connections.md': 'features/connections.md'
+        'events.md': 'features/events.md'
+        'https.md': 'features/events.md'
+        'interceptors.md': 'features/interceptors.md'
+        'r8_proguard.md': 'features/r8_proguard.md'
+        # Redirect all Security pages to security/*
+        'security.md': 'security/security.md'
+        'security_providers.md': 'security/security_providers.md'
+        'tls_configuration_history.md': 'security/tls_configuration_history.md'
+        # Redirect all changelog pages to changelog/*
+        'changelog.md': 'changelogs/changelog.md'
+        'upgrading_to_okhttp_4.md': 'changelogs/upgrading_to_okhttp_4.md'
+        'changelog_3x.md': 'changelogs/changelog_3x.md'
+        'changelog_2x.md': 'changelogs/changelog_2x.md'
+        'changelog_1x.md': 'changelogs/changelog_1x.md'
+        # Redirect all contributing pages to contribute/*
+        'contributing.md': 'contribute/contributing.md'
+        'code_of_conduct.md': 'contribute/code_of_conduct.md'
+        'concurrency.md': 'contribute/concurrency.md'
+        'debug_logging.md': 'contribute/debug_logging.md'
+
 nav:
-  - 'Overview': index.md
-  - 'Stack Overflow ⏏': https://stackoverflow.com/questions/tagged/okhttp?sort=active
-  - 'Calls': calls.md
-  - 'Caching': caching.md
-  - 'Connections': connections.md
-  - 'Events': events.md
-  - 'HTTPS': https.md
-  - 'Interceptors': interceptors.md
+  - 'Overview':
+    - 'Overview': index.md
+    - 'Stack Overflow': https://stackoverflow.com/questions/tagged/okhttp?sort=active
+  - 'Features':
+    - 'Calls': features/calls.md
+    - 'Caching': features/caching.md
+    - 'Connections': features/connections.md
+    - 'Events': features/events.md
+    - 'HTTPS': features/https.md
+    - 'Interceptors': features/interceptors.md
   - 'Recipes': recipes.md
-  - 'Security': security.md
-  - 'Security Providers': security_providers.md
+  - 'Security':
+    - 'Security': security/security.md
+    - 'Providers': security/security_providers.md
+    - 'Configuration History': security/tls_configuration_history.md
   - 'Works with OkHttp': works_with_okhttp.md
-  - 'Upgrading to OkHttp 4': upgrading_to_okhttp_4.md
-  - '4.x API':
+  - 'API':
     - 'okhttp': 4.x/okhttp/okhttp3/index.md
     - 'brotli': 4.x/okhttp-brotli/okhttp3.brotli/index.md
     - 'dnsoverhttps': 4.x/okhttp-dnsoverhttps/okhttp3.dnsoverhttps/index.md
-    - 'logging-interceptor': 4.x/okhttp-logging-interceptor/okhttp3.logging/index.md
+    - 'logging-interceptor': 4.x/logging-interceptor/okhttp3.logging/index.md
     - 'sse': 4.x/okhttp-sse/okhttp3.sse/index.md
     - 'tls': 4.x/okhttp-tls/okhttp3.tls/index.md
     - 'urlconnection': 4.x/okhttp-urlconnection/okhttp3/index.md
     - 'mockwebserver': 4.x/mockwebserver/okhttp3.mockwebserver/index.md
-  - '3.12.x API':
-    - 'okhttp ⏏': https://square.github.io/okhttp/3.x/okhttp/
-    - 'dnsoverhttps ⏏': https://square.github.io/okhttp/3.x/okhttp-dnsoverhttps/
-    - 'logging-interceptor ⏏': https://square.github.io/okhttp/3.x/logging-interceptor/
-    - 'sse ⏏': https://square.github.io/okhttp/3.x/okhttp-sse/
-    - 'tls ⏏': https://square.github.io/okhttp/3.x/okhttp-tls/
-    - 'urlconnection ⏏': https://square.github.io/okhttp/3.x/okhttp-urlconnection/
-    - 'mockwebserver ⏏': https://square.github.io/okhttp/3.x/mockwebserver/
-  - 'Change Log': changelog.md
-  - 'Contributing': contributing.md
-  - 'Code of Conduct': code_of_conduct.md
+  - 'Change Logs':
+    - 'Change Log': changelogs/changelog.md
+    - '4.x Change Log': changelogs/changelog_4x.md
+    - 'Upgrading to OkHttp 4': changelogs/upgrading_to_okhttp_4.md
+    - '3.x Change Log': changelogs/changelog_3x.md
+    - '2.x Change Log': changelogs/changelog_2x.md
+    - '1.x Change Log': changelogs/changelog_1x.md
+  - 'Contributing':
+    - 'Contributing': contribute/contributing.md
+    - 'Code of Conduct': contribute/code_of_conduct.md
+    - 'Concurrency': contribute/concurrency.md
+    - 'Debug Logging': contribute/debug_logging.md
 
diff --git a/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/ConnectionSpecSelector.kt b/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/ConnectionSpecSelector.kt
index 27e42cb59..96c30f721 100644
--- a/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/ConnectionSpecSelector.kt
+++ b/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/ConnectionSpecSelector.kt
@@ -18,8 +18,105 @@ package okhttp3.internal.connection
 import java.io.IOException
 import java.io.InterruptedIOException
 import java.net.ProtocolException
+import java.net.UnknownServiceException
 import java.security.cert.CertificateException
 import javax.net.ssl.SSLException
 import javax.net.ssl.SSLHandshakeException
 import javax.net.ssl.SSLPeerUnverifiedException
+import javax.net.ssl.SSLSocket
+import okhttp3.ConnectionSpec
 
+/**
+ * Handles the connection spec fallback strategy: When a secure socket connection fails due to a
+ * handshake / protocol problem the connection may be retried with different protocols. Instances
+ * are stateful and should be created and used for a single connection attempt.
+ */
+internal class ConnectionSpecSelector(
+  private val connectionSpecs: List<ConnectionSpec>
+) {
+  private var nextModeIndex: Int = 0
+  private var isFallbackPossible: Boolean = false
+  private var isFallback: Boolean = false
+
+  /**
+   * Configures the supplied [SSLSocket] to connect to the specified host using an appropriate
+   * [ConnectionSpec]. Returns the chosen [ConnectionSpec], never null.
+   *
+   * @throws IOException if the socket does not support any of the TLS modes available
+   */
+  @Throws(IOException::class)
+  fun configureSecureSocket(sslSocket: SSLSocket): ConnectionSpec {
+    var tlsConfiguration: ConnectionSpec? = null
+    for (i in nextModeIndex until connectionSpecs.size) {
+      val connectionSpec = connectionSpecs[i]
+      if (connectionSpec.isCompatible(sslSocket)) {
+        tlsConfiguration = connectionSpec
+        nextModeIndex = i + 1
+        break
+      }
+    }
+
+    if (tlsConfiguration == null) {
+      // This may be the first time a connection has been attempted and the socket does not support
+      // any the required protocols, or it may be a retry (but this socket supports fewer protocols
+      // than was suggested by a prior socket).
+      throw UnknownServiceException("Unable to find acceptable protocols. isFallback=$isFallback," +
+          " modes=$connectionSpecs," +
+          " supported protocols=${sslSocket.enabledProtocols!!.contentToString()}")
+    }
+
+    isFallbackPossible = isFallbackPossible(sslSocket)
+
+    tlsConfiguration.apply(sslSocket, isFallback)
+
+    return tlsConfiguration
+  }
+
+  /**
+   * Reports a failure to complete a connection. Determines the next [ConnectionSpec] to try,
+   * if any.
+   *
+   * @return true if the connection should be retried using [configureSecureSocket].
+   */
+  fun connectionFailed(e: IOException): Boolean {
+    // Any future attempt to connect using this strategy will be a fallback attempt.
+    isFallback = true
+
+    return when {
+      !isFallbackPossible -> false
+
+      // If there was a protocol problem, don't recover.
+      e is ProtocolException -> false
+
+      // If there was an interruption or timeout (SocketTimeoutException), don't recover.
+      // For the socket connect timeout case we do not try the same host with a different
+      // ConnectionSpec: we assume it is unreachable.
+      e is InterruptedIOException -> false
+
+      // If the problem was a CertificateException from the X509TrustManager, do not retry.
+      e is SSLHandshakeException && e.cause is CertificateException -> false
+
+      // e.g. a certificate pinning error.
+      e is SSLPeerUnverifiedException -> false
+
+      // Retry for all other SSL failures.
+      e is SSLException -> true
+
+      else -> false
+    }
+  }
+
+  /**
+   * Returns true if any later [ConnectionSpec] in the fallback strategy looks possible based on the
+   * supplied [SSLSocket]. It assumes that a future socket will have the same capabilities as the
+   * supplied socket.
+   */
+  private fun isFallbackPossible(socket: SSLSocket): Boolean {
+    for (i in nextModeIndex until connectionSpecs.size) {
+      if (connectionSpecs[i].isCompatible(socket)) {
+        return true
+      }
+    }
+    return false
+  }
+}
diff --git a/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/EquipPlan.kt b/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/EquipPlan.kt
deleted file mode 100644
index 27546efbe..000000000
--- a/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/EquipPlan.kt
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2022 Block, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection
-
-import java.io.InterruptedIOException
-import java.net.ProtocolException
-import java.net.UnknownServiceException
-import java.security.cert.CertificateException
-import java.util.Objects
-import javax.net.ssl.SSLException
-import javax.net.ssl.SSLHandshakeException
-import javax.net.ssl.SSLPeerUnverifiedException
-import javax.net.ssl.SSLSocket
-import okhttp3.ConnectionSpec
-import okhttp3.Request
-import okio.IOException
-
-/**
- * What to do once we have a socket but before we can make HTTP calls. This is usually a combination
- * of the following features:
- *
- *  * CONNECT tunnels. When using an HTTP proxy to reach an HTTPS server we must send a CONNECT
- *    request, and handle authorization challenges from the proxy.
- *
- *  * TLS handshakes.
- *
- * We might need many attempts at each of these steps. Tunnels fail due to authentication
- * challenges, and TLS handshakes fail due to mismatched protocol versions. When we need another
- * attempt, this class tracks what to try next.
- *
- * Unlike routes, we don't know that we'll need another equip plan until the current one fails.
- */
-internal data class EquipPlan(
-  val attempt: Int = 0,
-  val tunnelRequest: Request? = null,
-  val connectionSpecIndex: Int = -1,
-  val isTlsFallback: Boolean = false,
-) {
-
-  /** Returns this if its [connectionSpecIndex] is defined, or defines it otherwise. */
-  @Throws(IOException::class)
-  fun withCurrentOrInitialConnectionSpec(
-    connectionSpecs: List<ConnectionSpec>,
-    sslSocket: SSLSocket
-  ): EquipPlan {
-    if (connectionSpecIndex != -1) return this
-    return nextConnectionSpec(connectionSpecs, sslSocket)
-      ?: throw UnknownServiceException(
-        "Unable to find acceptable protocols." +
-          " isFallback=${isTlsFallback}," +
-          " modes=$connectionSpecs," +
-          " supported protocols=${sslSocket.enabledProtocols!!.contentToString()}"
-      )
-  }
-
-  /** Returns the next plan to use after this, or null if no more compatible plans are available. */
-  fun nextConnectionSpec(
-    connectionSpecs: List<ConnectionSpec>,
-    sslSocket: SSLSocket
-  ): EquipPlan? {
-    for (i in connectionSpecIndex + 1 until connectionSpecs.size) {
-      if (connectionSpecs[i].isCompatible(sslSocket)) {
-        return copy(connectionSpecIndex = i, isTlsFallback = (connectionSpecIndex != -1))
-      }
-    }
-    return null
-  }
-
-  override fun hashCode(): Int {
-    var result = 17
-    result = 31 * result + attempt
-    result = 31 * result + Objects.hashCode(tunnelRequest)
-    result = 31 * result + connectionSpecIndex
-    result = 31 * result + (if (isTlsFallback) 0 else 1)
-    return result
-  }
-}
-
-/** Returns true if a TLS connection should be retried after [e]. */
-fun retryTlsHandshake(e: IOException): Boolean {
-  return when {
-    // If there was a protocol problem, don't recover.
-    e is ProtocolException -> false
-
-    // If there was an interruption or timeout (SocketTimeoutException), don't recover.
-    // For the socket connect timeout case we do not try the same host with a different
-    // ConnectionSpec: we assume it is unreachable.
-    e is InterruptedIOException -> false
-
-    // If the problem was a CertificateException from the X509TrustManager, do not retry.
-    e is SSLHandshakeException && e.cause is CertificateException -> false
-
-    // e.g. a certificate pinning error.
-    e is SSLPeerUnverifiedException -> false
-
-    // Retry for all other SSL failures.
-    e is SSLException -> true
-
-    else -> false
-  }
-}
diff --git a/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/RealConnection.kt b/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/RealConnection.kt
index 53145aa9e..4a374b40a 100644
--- a/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/RealConnection.kt
+++ b/okhttp/src/jvmMain/kotlin/okhttp3/internal/connection/RealConnection.kt
@@ -150,7 +150,7 @@ class RealConnection(
   internal val isMultiplexed: Boolean
     get() = http2Connection != null
 
-  /** True if we haven't yet called [connectAndEquip] on this. */
+  /** True if we haven't yet called [connect] on this. */
   internal val isNew: Boolean
     get() = protocol == null
 
@@ -179,53 +179,14 @@ class RealConnection(
   ) {
     check(isNew) { "already connected" }
 
-    var equipPlan = firstEquipPlan()
     var firstException: IOException? = null
-    while (true) {
-      val (failure, nextPlan) = connectAndEquip(
-        connectTimeout = connectTimeout,
-        readTimeout = readTimeout,
-        writeTimeout = writeTimeout,
-        pingIntervalMillis = pingIntervalMillis,
-        connectionRetryEnabled = connectionRetryEnabled,
-        call = call,
-        eventListener = eventListener,
-        equipPlan = equipPlan
-      )
-
-      if (failure != null) {
-        // Accumulate failures.
-        if (firstException == null) {
-          firstException = failure
-        } else {
-          firstException.addSuppressed(failure)
-        }
-
-        if (nextPlan == null) throw firstException // Nothing left to try.
-      } else {
-        if (nextPlan == null) break // Success.
-      }
-
-      equipPlan = nextPlan
-    }
-
-    idleAtNs = System.nanoTime()
-  }
+    val connectionSpecs = route.address.connectionSpecs
+    val connectionSpecSelector = ConnectionSpecSelector(connectionSpecs)
 
-  /**
-   * Returns the initial plan for equipping a socket so it can carry HTTP. This doesn't include
-   * HTTPS connection spec information because that needs a [SSLSocket] and we don't have that
-   * yet.
-   *
-   * This throws if no plan is possible.
-   */
-  @Throws(IOException::class)
-  private fun firstEquipPlan(): EquipPlan {
     if (route.address.sslSocketFactory == null) {
-      if (ConnectionSpec.CLEARTEXT !in route.address.connectionSpecs) {
+      if (ConnectionSpec.CLEARTEXT !in connectionSpecs) {
         throw UnknownServiceException("CLEARTEXT communication not enabled for client")
       }
-
       val host = route.address.url.host
       if (!Platform.get().isCleartextTrafficPermitted(host)) {
         throw UnknownServiceException(
@@ -238,120 +199,81 @@ class RealConnection(
       }
     }
 
-    val tunnelRequest = when {
-      route.requiresTunnel() -> createTunnelRequest()
-      else -> null
+    while (true) {
+      try {
+        if (route.requiresTunnel()) {
+          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener)
+          if (rawSocket == null) {
+            // We were unable to connect the tunnel but properly closed down our resources.
+            break
+          }
+        } else {
+          connectSocket(connectTimeout, readTimeout, call, eventListener)
+        }
+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener)
+        eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
+        break
+      } catch (e: IOException) {
+        socket?.closeQuietly()
+        rawSocket?.closeQuietly()
+        socket = null
+        rawSocket = null
+        source = null
+        sink = null
+        handshake = null
+        protocol = null
+        http2Connection = null
+        allocationLimit = 1
+
+        eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
+
+        if (firstException == null) {
+          firstException = e
+        } else {
+          firstException.addSuppressed(e)
+        }
+
+        if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) {
+          throw firstException
+        }
+      }
     }
 
-    return EquipPlan(
-      tunnelRequest = tunnelRequest,
-    )
-  }
+    if (route.requiresTunnel() && rawSocket == null) {
+      throw ProtocolException(
+        "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS"
+      )
+    }
 
-  internal data class ConnectAndEquipResult(
-    val failure: IOException? = null,
-    val nextPlan: EquipPlan? = null,
-  )
+    idleAtNs = System.nanoTime()
+  }
 
   /**
-   * This returns a failure exception and also what to do about it.
-   *
-   * If the returned plan is not-null, another attempt should be made by following it. If the
-   * returned exception is non-null, it should be reported to the user should all further attempts
-   * fail.
-   *
-   * The two values are independent: results can contain both (recoverable error), neither
-   * (success), just an exception (permanent failure), or just a plan (non-exceptional retry).
+   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
+   * proxy server can issue an auth challenge and then close the connection.
    */
   @Throws(IOException::class)
-  private fun connectAndEquip(
+  private fun connectTunnel(
     connectTimeout: Int,
     readTimeout: Int,
     writeTimeout: Int,
-    pingIntervalMillis: Int,
-    connectionRetryEnabled: Boolean,
     call: Call,
-    eventListener: EventListener,
-    equipPlan: EquipPlan,
-  ): ConnectAndEquipResult {
-    val connectionSpecs = route.address.connectionSpecs
-    var nextTlsEquipPlan: EquipPlan? = null
-
-    try {
-      eventListener.connectStart(call, route.socketAddress, route.proxy)
-      connectSocket(connectTimeout, readTimeout)
-
-      if (equipPlan.tunnelRequest != null) {
-        val tunnelResult = connectTunnel(
-          readTimeout = readTimeout,
-          writeTimeout = writeTimeout,
-          call = call,
-          equipPlan = equipPlan,
-          eventListener = eventListener
-        )
-
-        // Tunnel didn't work. Start it all again.
-        if (tunnelResult.nextPlan != null || tunnelResult.failure != null) {
-          return tunnelResult
-        }
-      }
-
-      if (route.address.sslSocketFactory != null) {
-        eventListener.secureConnectStart(call)
-
-        // Create the wrapper over the connected socket.
-        val sslSocket = route.address.sslSocketFactory.createSocket(
-          rawSocket,
-          route.address.url.host,
-          route.address.url.port,
-          true /* autoClose */
-        ) as SSLSocket
-
-        val tlsEquipPlan = equipPlan.withCurrentOrInitialConnectionSpec(connectionSpecs, sslSocket)
-        val connectionSpec = connectionSpecs[tlsEquipPlan.connectionSpecIndex]
-
-        // Figure out the next connection spec in case we need a retry.
-        nextTlsEquipPlan = tlsEquipPlan.nextConnectionSpec(connectionSpecs, sslSocket)
-
-        connectionSpec.apply(sslSocket, isFallback = tlsEquipPlan.isTlsFallback)
-        connectTls(sslSocket, connectionSpec)
-        eventListener.secureConnectEnd(call, handshake)
-      } else {
-        socket = rawSocket
-        protocol = when {
-          Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols -> Protocol.H2_PRIOR_KNOWLEDGE
-          else -> Protocol.HTTP_1_1
-        }
-      }
-
-      if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
-        startHttp2(pingIntervalMillis)
-      }
-
-      eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
-      return ConnectAndEquipResult() // Success.
-    } catch (e: IOException) {
-      socket?.closeQuietly()
+    eventListener: EventListener
+  ) {
+    var tunnelRequest: Request = createTunnelRequest()
+    val url = tunnelRequest.url
+    for (i in 0 until MAX_TUNNEL_ATTEMPTS) {
+      connectSocket(connectTimeout, readTimeout, call, eventListener)
+      tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url)
+        ?: break // Tunnel successfully created.
+
+      // The proxy decided to close the connection after an auth challenge. We need to create a new
+      // connection, but this time with the auth credentials.
       rawSocket?.closeQuietly()
-      socket = null
       rawSocket = null
-      source = null
       sink = null
-      handshake = null
-      protocol = null
-      http2Connection = null
-      allocationLimit = 1
-
-      eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
-
-      if (!connectionRetryEnabled || !retryTlsHandshake(e)) {
-        nextTlsEquipPlan = null
-      }
-
-      return ConnectAndEquipResult(
-        failure = e,
-        nextPlan = nextTlsEquipPlan
-      )
+      source = null
+      eventListener.connectEnd(call, route.socketAddress, route.proxy, null)
     }
   }
 
@@ -360,6 +282,8 @@ class RealConnection(
   private fun connectSocket(
     connectTimeout: Int,
     readTimeout: Int,
+    call: Call,
+    eventListener: EventListener
   ) {
     val proxy = route.proxy
     val address = route.address
@@ -370,6 +294,7 @@ class RealConnection(
     }
     this.rawSocket = rawSocket
 
+    eventListener.connectStart(call, route.socketAddress, proxy)
     rawSocket.soTimeout = readTimeout
     try {
       Platform.get().connectSocket(rawSocket, route.socketAddress, connectTimeout)
@@ -393,53 +318,32 @@ class RealConnection(
     }
   }
 
-  /**
-   * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
-   * proxy server can issue an auth challenge and then close the connection.
-   *
-   * @return the next plan to attempt, or null if no further attempt should be made either because
-   *     we've successfully connected or because no further attempts should be made.
-   */
   @Throws(IOException::class)
-  internal fun connectTunnel(
-    readTimeout: Int,
-    writeTimeout: Int,
+  private fun establishProtocol(
+    connectionSpecSelector: ConnectionSpecSelector,
+    pingIntervalMillis: Int,
     call: Call,
-    equipPlan: EquipPlan,
-    eventListener: EventListener,
-  ): ConnectAndEquipResult {
-    val nextTunnelRequest = createTunnel(
-      readTimeout = readTimeout,
-      writeTimeout = writeTimeout,
-      tunnelRequest = equipPlan.tunnelRequest!!,
-      url = route.address.url
-    ) ?: return ConnectAndEquipResult() // Success.
-
-    // The proxy decided to close the connection after an auth challenge. We need to create a new
-    // connection, but this time with the auth credentials.
-    rawSocket?.closeQuietly()
-    rawSocket = null
-    sink = null
-    source = null
-
-    val nextAttempt = equipPlan.attempt + 1
-    return when {
-      nextAttempt < MAX_TUNNEL_ATTEMPTS -> {
-        eventListener.connectEnd(call, route.socketAddress, route.proxy, null)
-        ConnectAndEquipResult(
-          nextPlan = equipPlan.copy(
-            attempt = nextAttempt,
-            tunnelRequest = nextTunnelRequest,
-          )
-        )
-      }
-      else -> {
-        val failure = ProtocolException(
-          "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS"
-        )
-        eventListener.connectFailed(call, route.socketAddress, route.proxy, null, failure)
-        return ConnectAndEquipResult(failure = failure)
+    eventListener: EventListener
+  ) {
+    if (route.address.sslSocketFactory == null) {
+      if (Protocol.H2_PRIOR_KNOWLEDGE in route.address.protocols) {
+        socket = rawSocket
+        protocol = Protocol.H2_PRIOR_KNOWLEDGE
+        startHttp2(pingIntervalMillis)
+        return
       }
+
+      socket = rawSocket
+      protocol = Protocol.HTTP_1_1
+      return
+    }
+
+    eventListener.secureConnectStart(call)
+    connectTls(connectionSpecSelector)
+    eventListener.secureConnectEnd(call, handshake)
+
+    if (protocol === Protocol.HTTP_2) {
+      startHttp2(pingIntervalMillis)
     }
   }
 
@@ -460,10 +364,19 @@ class RealConnection(
   }
 
   @Throws(IOException::class)
-  private fun connectTls(sslSocket: SSLSocket, connectionSpec: ConnectionSpec) {
+  private fun connectTls(connectionSpecSelector: ConnectionSpecSelector) {
     val address = route.address
+    val sslSocketFactory = address.sslSocketFactory
     var success = false
+    var sslSocket: SSLSocket? = null
     try {
+      // Create the wrapper over the connected socket.
+      sslSocket = sslSocketFactory!!.createSocket(
+        rawSocket, address.url.host, address.url.port, true /* autoClose */
+      ) as SSLSocket
+
+      // Configure the socket's ciphers, TLS versions, and extensions.
+      val connectionSpec = connectionSpecSelector.configureSecureSocket(sslSocket)
       if (connectionSpec.supportsTlsExtensions) {
         Platform.get().configureTlsExtensions(sslSocket, address.url.host, address.protocols)
       }
@@ -524,9 +437,11 @@ class RealConnection(
       protocol = if (maybeProtocol != null) Protocol.get(maybeProtocol) else Protocol.HTTP_1_1
       success = true
     } finally {
-      Platform.get().afterHandshake(sslSocket)
+      if (sslSocket != null) {
+        Platform.get().afterHandshake(sslSocket)
+      }
       if (!success) {
-        sslSocket.closeQuietly()
+        sslSocket?.closeQuietly()
       }
     }
   }
diff --git a/okhttp/src/jvmTest/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp/src/jvmTest/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
new file mode 100644
index 000000000..b6b462c8b
--- /dev/null
+++ b/okhttp/src/jvmTest/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.connection;
+
+import java.io.IOException;
+import java.security.cert.CertificateException;
+import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLSocket;
+import okhttp3.ConnectionSpec;
+import okhttp3.TlsVersion;
+import okhttp3.tls.HandshakeCertificates;
+import org.junit.jupiter.api.Test;
+
+import static java.util.Arrays.asList;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class ConnectionSpecSelectorTest {
+  public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
+      "Simulated handshake exception");
+
+  private final HandshakeCertificates handshakeCertificates = localhost();
+
+  @Test
+  public void nonRetryableIOException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(
+        new IOException("Non-handshake exception"));
+    assertThat(retry).isFalse();
+    socket.close();
+  }
+
+  @Test
+  public void nonRetryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    SSLHandshakeException trustIssueException =
+        new SSLHandshakeException("Certificate handshake exception");
+    trustIssueException.initCause(new CertificateException());
+    boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
+    assertThat(retry).isFalse();
+    socket.close();
+  }
+
+  @Test
+  public void retryableSSLHandshakeException() throws Exception {
+    ConnectionSpecSelector connectionSpecSelector =
+        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
+    SSLSocket socket = createSocketWithEnabledProtocols(
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+    connectionSpecSelector.configureSecureSocket(socket);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertThat(retry).isTrue();
+    socket.close();
+  }
+
+  @Test
+  public void someFallbacksSupported() throws Exception {
+    ConnectionSpec sslV3 = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
+        .tlsVersions(TlsVersion.SSL_3_0)
+        .build();
+
+    ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
+        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
+
+    TlsVersion[] enabledSocketTlsVersions = {
+        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0
+    };
+    SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+
+    // MODERN_TLS is used here.
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2);
+
+    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertThat(retry).isTrue();
+    socket.close();
+
+    // COMPATIBLE_TLS is used here.
+    socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
+    connectionSpecSelector.configureSecureSocket(socket);
+    assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
+
+    retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
+    assertThat(retry).isFalse();
+    socket.close();
+
+    // sslV3 is not used because SSLv3 is not enabled on the socket.
+  }
+
+  private static ConnectionSpecSelector createConnectionSpecSelector(
+      ConnectionSpec... connectionSpecs) {
+    return new ConnectionSpecSelector(asList(connectionSpecs));
+  }
+
+  private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
+    SSLSocket socket = (SSLSocket) handshakeCertificates.sslSocketFactory().createSocket();
+    socket.setEnabledProtocols(javaNames(tlsVersions));
+    return socket;
+  }
+
+  private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
+    assertThat(socket.getEnabledProtocols()).containsExactlyInAnyOrder(javaNames(required));
+  }
+
+  private static String[] javaNames(TlsVersion... tlsVersions) {
+    String[] protocols = new String[tlsVersions.length];
+    for (int i = 0; i < tlsVersions.length; i++) {
+      protocols[i] = tlsVersions[i].javaName();
+    }
+    return protocols;
+  }
+}
diff --git a/okhttp/src/jvmTest/java/okhttp3/internal/connection/EquipPlanTest.kt b/okhttp/src/jvmTest/java/okhttp3/internal/connection/EquipPlanTest.kt
deleted file mode 100644
index 580287c81..000000000
--- a/okhttp/src/jvmTest/java/okhttp3/internal/connection/EquipPlanTest.kt
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection
-
-import java.io.IOException
-import java.security.cert.CertificateException
-import javax.net.ssl.SSLHandshakeException
-import javax.net.ssl.SSLSocket
-import okhttp3.ConnectionSpec
-import okhttp3.TlsVersion
-import okhttp3.tls.internal.TlsUtil.localhost
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.jupiter.api.Test
-
-class EquipPlanTest {
-  private val handshakeCertificates = localhost()
-  private val retryableException = SSLHandshakeException(
-    "Simulated handshake exception"
-  )
-
-  @Test fun nonRetryableIOException() {
-    val exception = IOException("Non-handshake exception")
-    assertThat(retryTlsHandshake(exception)).isFalse()
-  }
-
-  @Test fun nonRetryableSSLHandshakeException() {
-    val exception = SSLHandshakeException("Certificate handshake exception").apply {
-      initCause(CertificateException())
-    }
-    assertThat(retryTlsHandshake(exception)).isFalse()
-  }
-
-  @Test fun retryableSSLHandshakeException() {
-    assertThat(retryTlsHandshake(retryableException)).isTrue()
-  }
-
-  @Test fun someFallbacksSupported() {
-    val sslV3 = ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-      .tlsVersions(TlsVersion.SSL_3_0)
-      .build()
-    val equipPlan = EquipPlan(connectionSpecIndex = -1)
-    val connectionSpecs = listOf(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3)
-    val enabledSocketTlsVersions = arrayOf(
-      TlsVersion.TLS_1_2,
-      TlsVersion.TLS_1_1,
-      TlsVersion.TLS_1_0
-    )
-    var socket = createSocketWithEnabledProtocols(*enabledSocketTlsVersions)
-
-    // MODERN_TLS is used here.
-    val attempt0 = equipPlan.withCurrentOrInitialConnectionSpec(connectionSpecs, socket)
-    assertThat(attempt0.isTlsFallback).isFalse()
-    connectionSpecs[attempt0.connectionSpecIndex].apply(socket, attempt0.isTlsFallback)
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_2)
-    val attempt1 = attempt0.nextConnectionSpec(connectionSpecs, socket)
-    assertThat(attempt1).isNotNull()
-    assertThat(attempt1!!.isTlsFallback).isTrue()
-    socket.close()
-
-    // COMPATIBLE_TLS is used here.
-    socket = createSocketWithEnabledProtocols(*enabledSocketTlsVersions)
-    connectionSpecs[attempt1.connectionSpecIndex].apply(socket, attempt1.isTlsFallback)
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
-    val attempt2 = attempt1.nextConnectionSpec(connectionSpecs, socket)
-    assertThat(attempt2).isNull()
-    socket.close()
-
-    // sslV3 is not used because SSLv3 is not enabled on the socket.
-  }
-
-  private fun createSocketWithEnabledProtocols(vararg tlsVersions: TlsVersion): SSLSocket {
-    return (handshakeCertificates.sslSocketFactory().createSocket() as SSLSocket).apply {
-      enabledProtocols = javaNames(*tlsVersions)
-    }
-  }
-
-  private fun assertEnabledProtocols(socket: SSLSocket, vararg required: TlsVersion) {
-    assertThat(socket.enabledProtocols)
-      .containsExactlyInAnyOrder(*javaNames(*required))
-  }
-
-  private fun javaNames(vararg tlsVersions: TlsVersion) =
-    tlsVersions.map { it.javaName }.toTypedArray()
-}
