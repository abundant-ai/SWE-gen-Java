diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
index 726a71d73..70ca6abee 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
@@ -1,14 +1,13 @@
 public final class io/ktor/server/plugins/di/AmbiguousCreateFunction : io/ktor/server/plugins/di/DependencyCreateFunction {
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;)V
-	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;[Lio/ktor/server/plugins/di/DependencyCreateFunction;)V
 	public final fun component1 ()Lio/ktor/server/plugins/di/DependencyKey;
 	public final fun component2 ()Ljava/util/Set;
 	public final fun copy (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;)Lio/ktor/server/plugins/di/AmbiguousCreateFunction;
 	public static synthetic fun copy$default (Lio/ktor/server/plugins/di/AmbiguousCreateFunction;Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;ILjava/lang/Object;)Lio/ktor/server/plugins/di/AmbiguousCreateFunction;
 	public fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
 	public fun equals (Ljava/lang/Object;)Z
-	public final fun getFunctions ()Ljava/util/Set;
-	public fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
+	public final fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
+	public final fun getKeys ()Ljava/util/Set;
 	public fun hashCode ()I
 	public fun toString ()Ljava/lang/String;
 }
@@ -18,7 +17,7 @@ public final class io/ktor/server/plugins/di/AmbiguousDependencyException : java
 }
 
 public final class io/ktor/server/plugins/di/CircularDependencyException : java/lang/IllegalStateException {
-	public fun <init> (Ljava/util/Collection;)V
+	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;)V
 }
 
 public final class io/ktor/server/plugins/di/DependencyAbstractTypeConstructionException : io/ktor/server/plugins/di/DependencyConstructionException {
@@ -64,7 +63,6 @@ public class io/ktor/server/plugins/di/DependencyConstructionException : java/la
 
 public abstract interface class io/ktor/server/plugins/di/DependencyCreateFunction {
 	public abstract fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
-	public abstract fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
 }
 
 public final class io/ktor/server/plugins/di/DependencyInjectionConfig {
@@ -151,6 +149,7 @@ public final class io/ktor/server/plugins/di/DependencyProviderContext : io/ktor
 public final class io/ktor/server/plugins/di/DependencyProviderKt {
 	public static final fun ifImplicit (Lio/ktor/server/plugins/di/DependencyCreateFunction;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
 	public static final fun invoke (Lio/ktor/server/plugins/di/DependencyProvider;Lkotlin/jvm/functions/Function1;)V
+	public static final fun keys (Lio/ktor/server/plugins/di/DependencyCreateFunction;)Ljava/util/Set;
 }
 
 public abstract interface class io/ktor/server/plugins/di/DependencyReflection {
@@ -165,7 +164,6 @@ public class io/ktor/server/plugins/di/DependencyReflectionJvm : io/ktor/server/
 	public fun <init> ()V
 	public fun create (Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
 	public fun findConstructors (Lkotlin/reflect/KClass;)Ljava/util/Collection;
-	public fun mapParameters (Ljava/util/List;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
 	public fun toDependencyKey (Lkotlin/reflect/KParameter;)Lio/ktor/server/plugins/di/DependencyKey;
 }
 
@@ -220,20 +218,15 @@ public final class io/ktor/server/plugins/di/ExplicitCreateFunction : io/ktor/se
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function1;)V
 	public fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
 	public final fun derived ()Lio/ktor/server/plugins/di/ImplicitCreateFunction;
-	public fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
+	public final fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
 }
 
 public final class io/ktor/server/plugins/di/ImplicitCreateFunction : io/ktor/server/plugins/di/DependencyCreateFunction {
 	public fun <init> (Lio/ktor/server/plugins/di/ExplicitCreateFunction;)V
 	public fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
-	public fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
 	public final fun getOrigin ()Lio/ktor/server/plugins/di/ExplicitCreateFunction;
 }
 
-public final class io/ktor/server/plugins/di/InvalidDependencyReferenceException : io/ktor/server/plugins/di/DependencyConstructionException {
-	public synthetic fun <init> (Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
-}
-
 public class io/ktor/server/plugins/di/MapDependencyProvider : io/ktor/server/plugins/di/DependencyProvider {
 	public fun <init> ()V
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyKeyCovariance;Lio/ktor/server/plugins/di/DependencyConflictPolicy;Lkotlin/jvm/functions/Function1;)V
@@ -270,7 +263,6 @@ public final class io/ktor/server/plugins/di/ProcessingDependencyResolver : io/k
 	public fun get (Lio/ktor/server/plugins/di/DependencyKey;)Ljava/lang/Object;
 	public fun getOrPut (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
 	public fun getReflection ()Lio/ktor/server/plugins/di/DependencyReflection;
-	public final fun resolveAll ()Ljava/util/Map;
 }
 
 public final class io/ktor/server/plugins/di/utils/Types_jvmKt {
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
index 1aed5242d..251929213 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
@@ -59,24 +59,20 @@ sealed interface io.ktor.server.plugins.di/DependencyConflictResult { // io.ktor
 }
 
 sealed interface io.ktor.server.plugins.di/DependencyCreateFunction { // io.ktor.server.plugins.di/DependencyCreateFunction|null[0]
-    abstract val key // io.ktor.server.plugins.di/DependencyCreateFunction.key|{}key[0]
-        abstract fun <get-key>(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/DependencyCreateFunction.key.<get-key>|<get-key>(){}[0]
-
     abstract fun create(io.ktor.server.plugins.di/DependencyResolver): kotlin/Any // io.ktor.server.plugins.di/DependencyCreateFunction.create|create(io.ktor.server.plugins.di.DependencyResolver){}[0]
 }
 
 final class io.ktor.server.plugins.di/AmbiguousCreateFunction : io.ktor.server.plugins.di/DependencyCreateFunction { // io.ktor.server.plugins.di/AmbiguousCreateFunction|null[0]
-    constructor <init>(io.ktor.server.plugins.di/DependencyKey, kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction>) // io.ktor.server.plugins.di/AmbiguousCreateFunction.<init>|<init>(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyCreateFunction>){}[0]
-    constructor <init>(io.ktor.server.plugins.di/DependencyKey, kotlin/Array<out io.ktor.server.plugins.di/DependencyCreateFunction>...) // io.ktor.server.plugins.di/AmbiguousCreateFunction.<init>|<init>(io.ktor.server.plugins.di.DependencyKey;kotlin.Array<out|io.ktor.server.plugins.di.DependencyCreateFunction>...){}[0]
+    constructor <init>(io.ktor.server.plugins.di/DependencyKey, kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey>) // io.ktor.server.plugins.di/AmbiguousCreateFunction.<init>|<init>(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyKey>){}[0]
 
-    final val functions // io.ktor.server.plugins.di/AmbiguousCreateFunction.functions|{}functions[0]
-        final fun <get-functions>(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/AmbiguousCreateFunction.functions.<get-functions>|<get-functions>(){}[0]
     final val key // io.ktor.server.plugins.di/AmbiguousCreateFunction.key|{}key[0]
         final fun <get-key>(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/AmbiguousCreateFunction.key.<get-key>|<get-key>(){}[0]
+    final val keys // io.ktor.server.plugins.di/AmbiguousCreateFunction.keys|{}keys[0]
+        final fun <get-keys>(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey> // io.ktor.server.plugins.di/AmbiguousCreateFunction.keys.<get-keys>|<get-keys>(){}[0]
 
     final fun component1(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/AmbiguousCreateFunction.component1|component1(){}[0]
-    final fun component2(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/AmbiguousCreateFunction.component2|component2(){}[0]
-    final fun copy(io.ktor.server.plugins.di/DependencyKey = ..., kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> = ...): io.ktor.server.plugins.di/AmbiguousCreateFunction // io.ktor.server.plugins.di/AmbiguousCreateFunction.copy|copy(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyCreateFunction>){}[0]
+    final fun component2(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey> // io.ktor.server.plugins.di/AmbiguousCreateFunction.component2|component2(){}[0]
+    final fun copy(io.ktor.server.plugins.di/DependencyKey = ..., kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey> = ...): io.ktor.server.plugins.di/AmbiguousCreateFunction // io.ktor.server.plugins.di/AmbiguousCreateFunction.copy|copy(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyKey>){}[0]
     final fun create(io.ktor.server.plugins.di/DependencyResolver): kotlin/Any // io.ktor.server.plugins.di/AmbiguousCreateFunction.create|create(io.ktor.server.plugins.di.DependencyResolver){}[0]
     final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.server.plugins.di/AmbiguousCreateFunction.equals|equals(kotlin.Any?){}[0]
     final fun hashCode(): kotlin/Int // io.ktor.server.plugins.di/AmbiguousCreateFunction.hashCode|hashCode(){}[0]
@@ -88,7 +84,7 @@ final class io.ktor.server.plugins.di/AmbiguousDependencyException : kotlin/Ille
 }
 
 final class io.ktor.server.plugins.di/CircularDependencyException : kotlin/IllegalStateException { // io.ktor.server.plugins.di/CircularDependencyException|null[0]
-    constructor <init>(kotlin.collections/Collection<io.ktor.server.plugins.di/DependencyKey>) // io.ktor.server.plugins.di/CircularDependencyException.<init>|<init>(kotlin.collections.Collection<io.ktor.server.plugins.di.DependencyKey>){}[0]
+    constructor <init>(io.ktor.server.plugins.di/DependencyKey) // io.ktor.server.plugins.di/CircularDependencyException.<init>|<init>(io.ktor.server.plugins.di.DependencyKey){}[0]
 }
 
 final class io.ktor.server.plugins.di/DependencyAbstractTypeConstructionException : io.ktor.server.plugins.di/DependencyConstructionException { // io.ktor.server.plugins.di/DependencyAbstractTypeConstructionException|null[0]
@@ -204,16 +200,12 @@ final class io.ktor.server.plugins.di/ExplicitCreateFunction : io.ktor.server.pl
 final class io.ktor.server.plugins.di/ImplicitCreateFunction : io.ktor.server.plugins.di/DependencyCreateFunction { // io.ktor.server.plugins.di/ImplicitCreateFunction|null[0]
     constructor <init>(io.ktor.server.plugins.di/ExplicitCreateFunction) // io.ktor.server.plugins.di/ImplicitCreateFunction.<init>|<init>(io.ktor.server.plugins.di.ExplicitCreateFunction){}[0]
 
-    final val key // io.ktor.server.plugins.di/ImplicitCreateFunction.key|{}key[0]
-        final fun <get-key>(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/ImplicitCreateFunction.key.<get-key>|<get-key>(){}[0]
     final val origin // io.ktor.server.plugins.di/ImplicitCreateFunction.origin|{}origin[0]
         final fun <get-origin>(): io.ktor.server.plugins.di/ExplicitCreateFunction // io.ktor.server.plugins.di/ImplicitCreateFunction.origin.<get-origin>|<get-origin>(){}[0]
 
     final fun create(io.ktor.server.plugins.di/DependencyResolver): kotlin/Any // io.ktor.server.plugins.di/ImplicitCreateFunction.create|create(io.ktor.server.plugins.di.DependencyResolver){}[0]
 }
 
-final class io.ktor.server.plugins.di/InvalidDependencyReferenceException : io.ktor.server.plugins.di/DependencyConstructionException // io.ktor.server.plugins.di/InvalidDependencyReferenceException|null[0]
-
 final class io.ktor.server.plugins.di/MapDependencyResolver : io.ktor.server.plugins.di/DependencyResolver { // io.ktor.server.plugins.di/MapDependencyResolver|null[0]
     constructor <init>(io.ktor.server.plugins.di/DependencyReflection, kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, kotlin/Result<kotlin/Any>>) // io.ktor.server.plugins.di/MapDependencyResolver.<init>|<init>(io.ktor.server.plugins.di.DependencyReflection;kotlin.collections.Map<io.ktor.server.plugins.di.DependencyKey,kotlin.Result<kotlin.Any>>){}[0]
 
@@ -240,7 +232,6 @@ final class io.ktor.server.plugins.di/ProcessingDependencyResolver : io.ktor.ser
 
     final fun <#A1: kotlin/Any> get(io.ktor.server.plugins.di/DependencyKey): #A1 // io.ktor.server.plugins.di/ProcessingDependencyResolver.get|get(io.ktor.server.plugins.di.DependencyKey){0ยง<kotlin.Any>}[0]
     final fun <#A1: kotlin/Any> getOrPut(io.ktor.server.plugins.di/DependencyKey, kotlin/Function0<#A1>): #A1 // io.ktor.server.plugins.di/ProcessingDependencyResolver.getOrPut|getOrPut(io.ktor.server.plugins.di.DependencyKey;kotlin.Function0<0:0>){0ยง<kotlin.Any>}[0]
-    final fun resolveAll(): kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, kotlin/Result<kotlin/Any>> // io.ktor.server.plugins.di/ProcessingDependencyResolver.resolveAll|resolveAll(){}[0]
 }
 
 open class io.ktor.server.plugins.di/DependencyConstructionException : kotlin/IllegalArgumentException { // io.ktor.server.plugins.di/DependencyConstructionException|null[0]
@@ -289,6 +280,7 @@ final var io.ktor.server.plugins.di/dependencies // io.ktor.server.plugins.di/de
     final fun (io.ktor.server.application/Application).<get-dependencies>(): io.ktor.server.plugins.di/DependencyRegistry // io.ktor.server.plugins.di/dependencies.<get-dependencies>|<get-dependencies>@io.ktor.server.application.Application(){}[0]
     final fun (io.ktor.server.application/Application).<set-dependencies>(io.ktor.server.plugins.di/DependencyRegistry) // io.ktor.server.plugins.di/dependencies.<set-dependencies>|<set-dependencies>@io.ktor.server.application.Application(io.ktor.server.plugins.di.DependencyRegistry){}[0]
 
+final fun (io.ktor.server.plugins.di/DependencyCreateFunction).io.ktor.server.plugins.di/keys(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey> // io.ktor.server.plugins.di/keys|keys@io.ktor.server.plugins.di.DependencyCreateFunction(){}[0]
 final fun (io.ktor.server.plugins.di/DependencyKeyCovariance).io.ktor.server.plugins.di/plus(io.ktor.server.plugins.di/DependencyKeyCovariance): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/plus|plus@io.ktor.server.plugins.di.DependencyKeyCovariance(io.ktor.server.plugins.di.DependencyKeyCovariance){}[0]
 final fun (io.ktor.server.plugins.di/DependencyKeyCovariance).io.ktor.server.plugins.di/times(io.ktor.server.plugins.di/DependencyKeyCovariance): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/times|times@io.ktor.server.plugins.di.DependencyKeyCovariance(io.ktor.server.plugins.di.DependencyKeyCovariance){}[0]
 final fun (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/invoke(kotlin/Function1<io.ktor.server.plugins.di/DependencyProviderContext, kotlin/Unit>) // io.ktor.server.plugins.di/invoke|invoke@io.ktor.server.plugins.di.DependencyProvider(kotlin.Function1<io.ktor.server.plugins.di.DependencyProviderContext,kotlin.Unit>){}[0]
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
index d8f681649..8548567ae 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
@@ -6,8 +6,6 @@ package io.ktor.server.plugins.di
 
 import io.ktor.server.application.ApplicationPlugin
 import io.ktor.server.application.createApplicationPlugin
-import io.ktor.server.plugins.di.utils.ClasspathReference
-import io.ktor.server.plugins.di.utils.installReference
 import io.ktor.util.AttributeKey
 import io.ktor.util.reflect.TypeInfo
 import kotlin.reflect.KClass
@@ -19,59 +17,16 @@ import kotlin.reflect.KClass
  * 1. `provider`: the logic for registering new types
  * 2. `resolution`: the function for validating the provided types and creating the dependency map
  * 3. `reflection`: controls how objects are initialized from type references
- *
- * You can declare dependencies using the dependencies DSL:
- *
- * ```kotlin
- * fun Application.databaseModule() {
- *     dependencies {
- *         provide<Database> { PostgresDatabase(resolve("connectionUrl")) }
- *     }
- * }
- * ```
- *
- * Or through configuration:
- *
- * ```yaml
- * ktor:
- *   application:
- *     dependencies:
- *       - com.example.db.PostgresDatabase
- * ```
- *
- * Each item declared via configuration can be a reference to a class or a
- * top-level function.
- *
- * Resolving dependencies in application modules is also achieved through the DSL:
- *
- * ```kotlin
- * fun Application.routing() {
- *     val database: Database by dependencies
- *     val repository: MessagesRepository = dependencies.create()
- * }
- * ```
- *
- * Alternatively, they can be supplied automatically through parameters.
  */
 public val DI: ApplicationPlugin<DependencyInjectionConfig> =
     createApplicationPlugin("DI", ::DependencyInjectionConfig) {
-        val configuredDependencyReferences =
-            environment.config.propertyOrNull("ktor.application.dependencies")
-                ?.getList()
-                ?.map { ClasspathReference(it) }
-                .orEmpty()
-
         application.attributes.put(
             DependencyRegistryKey,
             DependencyRegistryImpl(
                 pluginConfig.provider,
                 pluginConfig.resolution,
                 pluginConfig.reflection,
-            ).also { registry ->
-                for (reference in configuredDependencyReferences) {
-                    installReference(application, registry, reference)
-                }
-            }
+            )
         )
     }
 
@@ -181,8 +136,8 @@ public class AmbiguousDependencyException(key: DependencyKey, keys: Collection<D
 /**
  * Thrown when resolving a given dependency loops back on itself.
  */
-public class CircularDependencyException(internal val keys: Collection<DependencyKey>) :
-    IllegalStateException("Circular dependency found: ${keys.joinToString(" -> ")}")
+public class CircularDependencyException(key: DependencyKey) :
+    IllegalStateException("Circular dependency found for dependency `$key`")
 
 /**
  * Thrown when attempting to provide a dependency AFTER the dependency map is created.
@@ -210,12 +165,3 @@ public open class DependencyReflectionDisabledException() :
 public class DependencyAbstractTypeConstructionException(
     qualifiedName: String,
 ) : DependencyConstructionException("Cannot instantiate abstract type: $qualifiedName")
-
-/**
- * Thrown when a static reference cannot be resolved from the configuration file.
- */
-public class InvalidDependencyReferenceException internal constructor(
-    message: String,
-    reference: ClasspathReference,
-    cause: Throwable? = null
-) : DependencyConstructionException("$message: $reference", cause)
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
index 260c35fcd..e947c4c67 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
@@ -47,7 +47,6 @@ public interface DependencyProvider {
  * Concrete types of this sealed interface are used to include some metadata regarding how they were registered.
  */
 public sealed interface DependencyCreateFunction {
-    public val key: DependencyKey
     public fun create(resolver: DependencyResolver): Any
 }
 
@@ -60,7 +59,7 @@ public sealed interface DependencyCreateFunction {
  * @property init A lambda that implements the creation logic for the dependency.
  */
 public class ExplicitCreateFunction(
-    public override val key: DependencyKey,
+    public val key: DependencyKey,
     private val init: DependencyResolver.() -> Any
 ) : DependencyCreateFunction {
     private var cached: Any? = null
@@ -78,9 +77,6 @@ public class ExplicitCreateFunction(
  * @property origin The instance of [ExplicitCreateFunction] that this class delegates creation logic to.
  */
 public class ImplicitCreateFunction(public val origin: ExplicitCreateFunction) : DependencyCreateFunction {
-    override val key: DependencyKey
-        get() = origin.key
-
     override fun create(resolver: DependencyResolver): Any =
         origin.create(resolver)
 }
@@ -96,20 +92,30 @@ public class ImplicitCreateFunction(public val origin: ExplicitCreateFunction) :
  * through the [create] method.
  */
 public data class AmbiguousCreateFunction(
-    public override val key: DependencyKey,
-    val functions: Set<DependencyCreateFunction>
+    val key: DependencyKey,
+    val keys: Set<DependencyKey>
 ) : DependencyCreateFunction {
-    init {
-        require(functions.isNotEmpty()) { "Functions must not be empty" }
-    }
-
-    public constructor(key: DependencyKey, vararg functions: DependencyCreateFunction) :
-        this(key, functions.flatMap { (it as? AmbiguousCreateFunction)?.functions ?: setOf(it) }.toSet())
-
     override fun create(resolver: DependencyResolver): Any =
-        throw AmbiguousDependencyException(key, functions.map { it.key })
+        throw AmbiguousDependencyException(key, keys)
 }
 
+/**
+ * Retrieves the set of dependency keys associated with this creation function.
+ *
+ * For `ExplicitCreateFunction`, it returns a single key associated with the explicit registration.
+ * For `ImplicitCreateFunction`, it returns the key of its origin `ExplicitCreateFunction`.
+ * For `AmbiguousCreateFunction`, it returns all the keys that caused the ambiguity.
+ *
+ * @return A set of `DependencyKey` instances representing the dependency keys for this creation function,
+ * depending on its specific implementation.
+ */
+public fun DependencyCreateFunction.keys(): Set<DependencyKey> =
+    when (this) {
+        is ExplicitCreateFunction -> setOf(key)
+        is ImplicitCreateFunction -> setOf(origin.key)
+        is AmbiguousCreateFunction -> keys
+    }
+
 /**
  * Executes the given block of code with the current instance if it is of type [ImplicitCreateFunction].
  *
@@ -152,14 +158,14 @@ public open class MapDependencyProvider(
         insertCovariantKeys(create, key)
     }
 
-    private fun trySet(key: DependencyKey, newFunction: DependencyCreateFunction) {
+    private fun trySet(key: DependencyKey, value: DependencyCreateFunction) {
         when (val previous = map[key]) {
-            null -> map[key] = newFunction
+            null -> map[key] = value
             else -> {
-                map[key] = when (val result = conflictPolicy.resolve(previous, newFunction)) {
-                    Ambiguous -> AmbiguousCreateFunction(key, previous, newFunction)
+                map[key] = when (val result = conflictPolicy.resolve(previous, value)) {
+                    Ambiguous -> AmbiguousCreateFunction(key, previous.keys() + value.keys())
                     Conflict -> throw DuplicateDependencyException(key)
-                    KeepNew -> newFunction
+                    KeepNew -> value
                     KeepPrevious -> previous
                     is Replace -> result.function
                 }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
index 1c5a1de2a..9a0029c1e 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
@@ -58,7 +58,10 @@ public class DependencyRegistryImpl(
 public val DefaultDependencyResolution: DependencyResolution =
     DependencyResolution { provider, reflection ->
         val injector = ProcessingDependencyResolver(reflection, provider)
-        MapDependencyResolver(reflection, injector.resolveAll())
+        val instances = provider.declarations.keys.associateWith { key ->
+            runCatching { injector.get(key) as Any }
+        }
+        MapDependencyResolver(reflection, instances)
     }
 
 /**
@@ -69,38 +72,17 @@ public class ProcessingDependencyResolver(
     override val reflection: DependencyReflection,
     private val provider: DependencyProvider,
 ) : DependencyResolver {
-    private val resolved = mutableMapOf<DependencyKey, Result<Any>>()
+    private val resolved = mutableMapOf<DependencyKey, Any>()
     private val visited = mutableSetOf<DependencyKey>()
 
-    public fun resolveAll(): Map<DependencyKey, Result<Any>> {
-        if (resolved.isNotEmpty()) return resolved.toMap()
-
-        for (key in provider.declarations.keys) {
-            get<Any>(key)
-        }
-        return resolved.toMap()
-    }
-
     override fun <T : Any> get(key: DependencyKey): T =
-        resolved.getOrPut(key) {
-            if (!visited.add(key)) throw CircularDependencyException(listOf(key))
-            try {
-                val createFunction = provider.declarations[key]
-                    ?: throw MissingDependencyException(key)
-                Result.success(createFunction.create(this))
-            } catch (cause: CircularDependencyException) {
-                // Always throw when encountering with circular references,
-                // capturing each key in the stack allows for better debugging
-                throw CircularDependencyException(listOf(key) + cause.keys)
-            } catch (cause: Throwable) {
-                Result.failure(cause)
-            }
-        }.getOrThrow() as T
+        getOrPut(key) {
+            if (!visited.add(key)) throw CircularDependencyException(key)
+            val result = provider.declarations[key]?.create(this)
+                ?: throw MissingDependencyException(key)
+            result as T
+        }
 
     override fun <T : Any> getOrPut(key: DependencyKey, defaultValue: () -> T): T =
-        resolved.getOrPut(key) {
-            runCatching {
-                defaultValue()
-            }
-        }.getOrThrow() as T
+        resolved.getOrPut(key, defaultValue) as T
 }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/utils/ClasspathReference.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/utils/ClasspathReference.kt
deleted file mode 100644
index 9b1d8aca4..000000000
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/utils/ClasspathReference.kt
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
- */
-
-package io.ktor.server.plugins.di.utils
-
-import io.ktor.server.application.Application
-import io.ktor.server.plugins.di.DependencyRegistry
-import kotlin.jvm.JvmInline
-
-@JvmInline
-internal value class ClasspathReference private constructor(val value: String) {
-    companion object {
-        operator fun invoke(value: String): ClasspathReference {
-            return ClasspathReference(value.replace('#', '.'))
-        }
-    }
-
-    /**
-     * Refers to the containing compiled type, i.e. "FileNameKt", when referring to inner classes and
-     * top-level functions.  Otherwise, it may be the package name.
-     */
-    val container: String get() = value.lastIndexOf('.').let { index ->
-        if (index == -1) return ""
-        value.substring(0, index)
-    }
-
-    /**
-     * The string value after the last delimiter (# or .) - generally the function name or class name.
-     */
-    val name: String get() = value.substringAfterLast('.')
-
-    override fun toString(): String = value
-}
-
-internal expect fun installReference(
-    application: Application,
-    registry: DependencyRegistry,
-    reference: ClasspathReference,
-)
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt
index eb8023a6d..039df7d48 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt
@@ -5,12 +5,17 @@
 package io.ktor.server.plugins.di
 
 import io.ktor.server.testing.*
-import io.ktor.util.reflect.*
+import io.ktor.util.reflect.typeInfo
 import kotlin.reflect.KClass
-import kotlin.test.*
+import kotlin.test.Test
+import kotlin.test.assertEquals
+import kotlin.test.assertFailsWith
+import kotlin.test.assertIs
+import kotlin.test.assertNotNull
+import kotlin.test.fail
 
 internal const val HELLO = "Hello, world!"
-internal const val HELLO_CUSTOMER = "Hello, customer!"
+private const val HELLO_CUSTOMER = "Hello, customer!"
 
 internal interface GreetingService {
     fun hello(): String
@@ -42,7 +47,7 @@ internal class BankServiceImpl : BankService {
 }
 
 internal data class BankTeller(
-    val greetingService: GreetingService = BankGreetingService(),
+    val greetingService: GreetingService,
     val bankService: BankService
 ) : GreetingService by greetingService, BankService by bankService
 
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/DependencyReflectionJvm.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/DependencyReflectionJvm.kt
index e5cbc43fd..49942f0dc 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/DependencyReflectionJvm.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/DependencyReflectionJvm.kt
@@ -4,7 +4,7 @@
 
 package io.ktor.server.plugins.di
 
-import io.ktor.util.reflect.*
+import io.ktor.util.reflect.TypeInfo
 import kotlin.reflect.KClass
 import kotlin.reflect.KFunction
 import kotlin.reflect.KParameter
@@ -15,7 +15,6 @@ import kotlin.reflect.jvm.jvmErasure
  * calls for inferring which constructors to use, and how to evaluate the parameters as dependency keys.
  */
 public open class DependencyReflectionJvm : DependencyReflection {
-
     override fun <T : Any> create(kClass: KClass<T>, init: (DependencyKey) -> Any): T {
         if (kClass.isAbstract || kClass.java.isInterface) {
             throw DependencyAbstractTypeConstructionException(kClass.qualifiedName ?: "<unknown>")
@@ -28,8 +27,8 @@ public open class DependencyReflectionJvm : DependencyReflection {
         val instanceFromConstructors = constructors.firstNotNullOfOrNull { constructor ->
             runCatching {
                 constructor.callBy(
-                    mapParameters(constructor.parameters) { param ->
-                        init(toDependencyKey(param))
+                    constructor.parameters.associateWith { parameter ->
+                        init(toDependencyKey(parameter))
                     }
                 )
             }.onFailure {
@@ -40,41 +39,14 @@ public open class DependencyReflectionJvm : DependencyReflection {
         // Throw if we were unable to create a new instance
         return instanceFromConstructors
             ?: throw DependencyConstructionException(
-                "No suitable constructor for type: ${kClass.qualifiedName}",
+                "Unable to find a suitable constructor for type: ${kClass.qualifiedName}",
                 lastFailure
             )
     }
 
-    /**
-     * List constructors of a class in order of preference.
-     */
     public open fun <T : Any> findConstructors(kClass: KClass<T>): Collection<KFunction<T>> =
         kClass.constructors
 
-    /**
-     * Resolves the list of parameters from the provided resolve function.
-     *
-     * When optional or nullable, failures to retrieve the values are ignored.
-     */
-    public open fun mapParameters(
-        parameters: List<KParameter>,
-        resolve: (KParameter) -> Any?
-    ): Map<KParameter, Any?> =
-        parameters.mapNotNull { parameter ->
-            parameter to try {
-                resolve(parameter)
-            } catch (cause: Exception) {
-                when {
-                    parameter.isOptional -> return@mapNotNull null // ignore
-                    parameter.type.isMarkedNullable -> null // let value = null
-                    else -> throw cause
-                }
-            }
-        }.toMap()
-
-    /**
-     * Maps a parameter to a [DependencyKey].
-     */
     public open fun toDependencyKey(parameter: KParameter): DependencyKey =
         DependencyKey(TypeInfo(parameter.type.jvmErasure, parameter.type))
 }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
deleted file mode 100644
index 2819a6005..000000000
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
- */
-
-package io.ktor.server.plugins.di.utils
-
-import io.ktor.server.application.*
-import io.ktor.server.plugins.di.*
-import io.ktor.util.reflect.*
-import kotlin.reflect.full.starProjectedType
-import kotlin.reflect.jvm.jvmErasure
-import kotlin.reflect.jvm.kotlinFunction
-
-internal actual fun installReference(
-    application: Application,
-    registry: DependencyRegistry,
-    reference: ClasspathReference,
-) {
-    val reflection = registry.reflection as? DependencyReflectionJvm ?: DependencyReflectionJvm()
-    val classLoader = Thread.currentThread().contextClassLoader
-    val clazz = classLoader.load(reference)
-
-    if (clazz.name == reference.value) {
-        // If this is a class reference,
-        // treat it as a `create(Object::class)` call
-        var kotlinType = clazz.kotlin
-        val classTypeInfo = TypeInfo(kotlinType, kotlinType.starProjectedType)
-
-        registry.set(DependencyKey(classTypeInfo)) {
-            reflection.create(kotlinType, ::get)
-        }
-    } else {
-        // Else, we assume this is a function reference
-        // where parameters are supplied by the DI container
-        // and the return type is used as the declaration
-        val matchingMethods = clazz.declaredMethods.filter { it.name == reference.name }
-        val functionCandidates = matchingMethods.mapNotNull { it.kotlinFunction }.takeIf { it.isNotEmpty() }
-            ?: throw InvalidDependencyReferenceException("Missing function reference", reference)
-        val returnType = functionCandidates.map { it.returnType }.distinct().singleOrNull()
-            ?: throw InvalidDependencyReferenceException("Ambiguous return types", reference)
-        val returnTypeInfo = TypeInfo(returnType.jvmErasure, returnType)
-
-        registry.set(DependencyKey(returnTypeInfo)) {
-            var lastError: Throwable? = null
-            for (function in functionCandidates) {
-                try {
-                    return@set function.callBy(
-                        reflection.mapParameters(function.parameters) { param ->
-                            when (param.type) {
-                                // special types, from application
-                                DependencyResolver::class.starProjectedType -> this@set
-                                ApplicationEnvironment::class.starProjectedType -> application.environment
-                                // regular types, from resolver
-                                else -> get<Any>(reflection.toDependencyKey(param))
-                            }
-                        }
-                    )
-                } catch (cause: Throwable) {
-                    lastError = cause
-                }
-            }
-            throw lastError!!
-        }
-    }
-}
-
-private fun ClassLoader.load(reference: ClasspathReference): Class<*> =
-    try {
-        loadClass(reference.value)
-    } catch (cause: Exception) {
-        runCatching {
-            loadClass(reference.container)
-        }.getOrElse {
-            throw InvalidDependencyReferenceException("Reference not found", reference, cause)
-        }
-    }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectTestModules.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectTestModules.kt
deleted file mode 100644
index e8fbb5d55..000000000
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectTestModules.kt
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
- */
-
-package io.ktor.server.plugins.di
-
-import io.ktor.server.application.*
-
-internal fun createGreetingService(): GreetingService =
-    GreetingServiceImpl()
-
-internal fun createBankService(): BankService =
-    BankServiceImpl()
-
-internal fun DependencyResolver.createBankTellerNoArgs(): BankTeller =
-    BankTeller(resolve(), resolve())
-
-internal fun createBankTellerWithArgs(
-    greetingService: GreetingService = BankGreetingService(),
-    bankService: BankService
-): BankTeller = BankTeller(greetingService, bankService)
-
-internal fun createBankTellerWithLogging(
-    environment: ApplicationEnvironment,
-    resolver: DependencyResolver,
-): BankTeller {
-    environment.log.info("Creating BankTeller with environment argument")
-    return BankTeller(BankGreetingService(), resolver.resolve())
-}
-
-internal fun createBankTellerWithNullables(
-    greetingService: GreetingService?,
-    bankService: BankService?
-): BankTeller =
-    BankTeller(
-        greetingService ?: BankGreetingService(),
-        bankService ?: BankServiceImpl()
-    )
-
-@Suppress("unused")
-private fun getBankServicePrivately(): BankService =
-    BankServiceImpl()
-
-internal class BankModule {
-    fun getBankServiceFromClass(): BankService =
-        BankServiceImpl()
-}
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt
index c8fbeda7c..ea9bb0464 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt
@@ -4,17 +4,10 @@
 
 package io.ktor.server.plugins.di
 
-import io.ktor.server.application.Application
-import io.ktor.server.config.MapApplicationConfig
 import io.ktor.server.testing.*
 import kotlin.reflect.KClass
-import kotlin.reflect.KFunction
-import kotlin.reflect.full.IllegalCallableAccessException
-import kotlin.reflect.jvm.javaMethod
-import kotlin.test.Ignore
 import kotlin.test.Test
 import kotlin.test.assertEquals
-import kotlin.test.assertFails
 import kotlin.test.assertFailsWith
 import kotlin.test.fail
 
@@ -65,7 +58,7 @@ class DependencyInjectionJvmTest {
     @Test
     fun `circular references from create`() = testApplication {
         application {
-            assertFailsWith<CircularDependencyException> {
+            val failure = assertFailsWith<CircularDependencyException> {
                 dependencies {
                     provide<WorkExperience> { WorkExperience(resolve()) }
                     provide<PaidWork> { PaidWork(resolve()) }
@@ -74,6 +67,10 @@ class DependencyInjectionJvmTest {
                 val workExperience: WorkExperience = dependencies.create()
                 fail("This should fail but returned $workExperience")
             }
+            assertEquals(
+                "Circular dependency found for dependency `io.ktor.server.plugins.di.WorkExperience`",
+                failure.message
+            )
         }
     }
 
@@ -134,164 +131,4 @@ class DependencyInjectionJvmTest {
             assertEquals(mySet, dependencies.resolve<Collection<String>>())
         }
     }
-
-    @Test
-    fun `install class from config`() {
-        testConfigFile(GreetingServiceImpl::class.qualifiedName!!) {
-            val service: GreetingService by dependencies
-            assertEquals(HELLO, service.hello())
-        }
-    }
-
-    /**
-     * [KTOR-8322 Handle delegate pattern](https://youtrack.jetbrains.com/issue/KTOR-8322/Dependency-injection-handle-delegate-pattern)
-     *     When declaring two classes that share an interface via delegation,
-     *     we should resolve the ambiguity automatically.
-     */
-    @Ignore
-    @Test
-    fun `install class ref with args from config`() {
-        testConfigFile(
-            BankServiceImpl::class.qualifiedName!!,
-            BankTeller::class.qualifiedName!!
-        ) {
-            val teller: BankTeller by dependencies
-            assertEquals(HELLO_CUSTOMER, teller.hello())
-        }
-    }
-
-    @Test
-    fun `install function ref from config`() {
-        testConfigFile(
-            ::createGreetingService.qualifiedName,
-            ::createBankService.qualifiedName,
-        ) {
-            val service: GreetingService by dependencies
-            assertEquals(HELLO, service.hello())
-        }
-    }
-
-    @Test
-    fun `install function ref using resolver`() {
-        testConfigFile(
-            ::createGreetingService.qualifiedName,
-            ::createBankService.qualifiedName,
-            DependencyResolver::createBankTellerNoArgs.qualifiedName,
-        ) {
-            val teller: BankTeller by dependencies
-            assertEquals(HELLO, teller.hello())
-        }
-    }
-
-    @Test
-    fun `install function ref missing args`() {
-        testConfigFile(
-            ::createBankTellerWithArgs.qualifiedName,
-        ) {
-            assertFails {
-                val teller: BankTeller by dependencies
-                fail("Should fail but resolved $teller")
-            }
-        }
-    }
-
-    @Test
-    fun `install from non-static functions`() {
-        testConfigFile(
-            BankModule::class.qualifiedName!!,
-            BankModule::getBankServiceFromClass.qualifiedName,
-        ) {
-            val bank: BankService by dependencies
-            assertEquals(0, bank.balance())
-        }
-    }
-
-    @Test
-    fun `install from private function fails`() {
-        testConfigFile(
-            ::createBankTellerWithArgs.qualifiedName.replace(
-                ::createBankTellerWithArgs.name,
-                "getBankServicePrivately"
-            ),
-        ) {
-            assertFailsWith<IllegalCallableAccessException> {
-                val bank: BankService by dependencies
-                fail("Should fail but resolved $bank")
-            }
-        }
-    }
-
-    @Test
-    fun `install function ref using args`() {
-        testConfigFile(
-            ::createBankService.qualifiedName,
-            ::createBankTellerWithArgs.qualifiedName,
-        ) {
-            val teller: BankTeller by dependencies
-            assertEquals(HELLO_CUSTOMER, teller.hello())
-        }
-    }
-
-    @Test
-    fun `install function refs out of order`() {
-        testConfigFile(
-            ::createBankTellerWithArgs.qualifiedName,
-            ::createBankService.qualifiedName,
-        ) {
-            val teller: BankTeller by dependencies
-            assertEquals(HELLO_CUSTOMER, teller.hello())
-        }
-    }
-
-    @Test
-    fun `install function ref with install from module`() {
-        testConfigFile(::createBankTellerWithArgs.qualifiedName,) {
-            dependencies {
-                provide<BankService> { BankServiceImpl() }
-            }
-            val teller: BankTeller by dependencies
-            assertEquals(HELLO_CUSTOMER, teller.hello())
-        }
-    }
-
-    @Test
-    fun `install function ref with special args`() {
-        testConfigFile(
-            ::createBankService.qualifiedName,
-            ::createBankTellerWithLogging.qualifiedName,
-        ) {
-            val teller: BankTeller by dependencies
-            assertEquals(HELLO_CUSTOMER, teller.hello())
-        }
-    }
-
-    @Test
-    fun `install function ref with nullable args`() {
-        testConfigFile(::createBankTellerWithNullables.qualifiedName) {
-            val teller: BankTeller by dependencies
-            assertEquals(HELLO_CUSTOMER, teller.hello())
-        }
-    }
-
-    private inline fun testConfigFile(
-        vararg references: String,
-        crossinline block: Application.() -> Unit
-    ) {
-        testApplication {
-            environment {
-                config = MapApplicationConfig().apply {
-                    put(
-                        "ktor.application.dependencies",
-                        listOf(*references)
-                    )
-                }
-            }
-            application {
-                block()
-            }
-        }
-    }
-
-    val KFunction<*>.qualifiedName: String get() =
-        "${javaMethod?.declaringClass?.name}#${javaMethod?.name}"
 }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/nonJvm/src/io/ktor/server/plugins/di/utils/ClasspathReferences.nonJvm.kt b/ktor-server/ktor-server-plugins/ktor-server-di/nonJvm/src/io/ktor/server/plugins/di/utils/ClasspathReferences.nonJvm.kt
deleted file mode 100644
index 555e57db9..000000000
--- a/ktor-server/ktor-server-plugins/ktor-server-di/nonJvm/src/io/ktor/server/plugins/di/utils/ClasspathReferences.nonJvm.kt
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
- */
-
-package io.ktor.server.plugins.di.utils
-
-import io.ktor.server.application.Application
-import io.ktor.server.plugins.di.*
-
-internal actual fun installReference(
-    application: Application,
-    registry: DependencyRegistry,
-    reference: ClasspathReference
-): Unit = error("Reflection is not supported on this platform.")
