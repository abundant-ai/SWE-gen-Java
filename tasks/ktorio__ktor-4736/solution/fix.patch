diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
index 70ca6abee..726a71d73 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
@@ -1,13 +1,14 @@
 public final class io/ktor/server/plugins/di/AmbiguousCreateFunction : io/ktor/server/plugins/di/DependencyCreateFunction {
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;)V
+	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;[Lio/ktor/server/plugins/di/DependencyCreateFunction;)V
 	public final fun component1 ()Lio/ktor/server/plugins/di/DependencyKey;
 	public final fun component2 ()Ljava/util/Set;
 	public final fun copy (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;)Lio/ktor/server/plugins/di/AmbiguousCreateFunction;
 	public static synthetic fun copy$default (Lio/ktor/server/plugins/di/AmbiguousCreateFunction;Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;ILjava/lang/Object;)Lio/ktor/server/plugins/di/AmbiguousCreateFunction;
 	public fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
 	public fun equals (Ljava/lang/Object;)Z
-	public final fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
-	public final fun getKeys ()Ljava/util/Set;
+	public final fun getFunctions ()Ljava/util/Set;
+	public fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
 	public fun hashCode ()I
 	public fun toString ()Ljava/lang/String;
 }
@@ -17,7 +18,7 @@ public final class io/ktor/server/plugins/di/AmbiguousDependencyException : java
 }
 
 public final class io/ktor/server/plugins/di/CircularDependencyException : java/lang/IllegalStateException {
-	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;)V
+	public fun <init> (Ljava/util/Collection;)V
 }
 
 public final class io/ktor/server/plugins/di/DependencyAbstractTypeConstructionException : io/ktor/server/plugins/di/DependencyConstructionException {
@@ -63,6 +64,7 @@ public class io/ktor/server/plugins/di/DependencyConstructionException : java/la
 
 public abstract interface class io/ktor/server/plugins/di/DependencyCreateFunction {
 	public abstract fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
+	public abstract fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
 }
 
 public final class io/ktor/server/plugins/di/DependencyInjectionConfig {
@@ -149,7 +151,6 @@ public final class io/ktor/server/plugins/di/DependencyProviderContext : io/ktor
 public final class io/ktor/server/plugins/di/DependencyProviderKt {
 	public static final fun ifImplicit (Lio/ktor/server/plugins/di/DependencyCreateFunction;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
 	public static final fun invoke (Lio/ktor/server/plugins/di/DependencyProvider;Lkotlin/jvm/functions/Function1;)V
-	public static final fun keys (Lio/ktor/server/plugins/di/DependencyCreateFunction;)Ljava/util/Set;
 }
 
 public abstract interface class io/ktor/server/plugins/di/DependencyReflection {
@@ -164,6 +165,7 @@ public class io/ktor/server/plugins/di/DependencyReflectionJvm : io/ktor/server/
 	public fun <init> ()V
 	public fun create (Lkotlin/reflect/KClass;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
 	public fun findConstructors (Lkotlin/reflect/KClass;)Ljava/util/Collection;
+	public fun mapParameters (Ljava/util/List;Lkotlin/jvm/functions/Function1;)Ljava/util/Map;
 	public fun toDependencyKey (Lkotlin/reflect/KParameter;)Lio/ktor/server/plugins/di/DependencyKey;
 }
 
@@ -218,15 +220,20 @@ public final class io/ktor/server/plugins/di/ExplicitCreateFunction : io/ktor/se
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function1;)V
 	public fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
 	public final fun derived ()Lio/ktor/server/plugins/di/ImplicitCreateFunction;
-	public final fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
+	public fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
 }
 
 public final class io/ktor/server/plugins/di/ImplicitCreateFunction : io/ktor/server/plugins/di/DependencyCreateFunction {
 	public fun <init> (Lio/ktor/server/plugins/di/ExplicitCreateFunction;)V
 	public fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
+	public fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
 	public final fun getOrigin ()Lio/ktor/server/plugins/di/ExplicitCreateFunction;
 }
 
+public final class io/ktor/server/plugins/di/InvalidDependencyReferenceException : io/ktor/server/plugins/di/DependencyConstructionException {
+	public synthetic fun <init> (Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+}
+
 public class io/ktor/server/plugins/di/MapDependencyProvider : io/ktor/server/plugins/di/DependencyProvider {
 	public fun <init> ()V
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyKeyCovariance;Lio/ktor/server/plugins/di/DependencyConflictPolicy;Lkotlin/jvm/functions/Function1;)V
@@ -263,6 +270,7 @@ public final class io/ktor/server/plugins/di/ProcessingDependencyResolver : io/k
 	public fun get (Lio/ktor/server/plugins/di/DependencyKey;)Ljava/lang/Object;
 	public fun getOrPut (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
 	public fun getReflection ()Lio/ktor/server/plugins/di/DependencyReflection;
+	public final fun resolveAll ()Ljava/util/Map;
 }
 
 public final class io/ktor/server/plugins/di/utils/Types_jvmKt {
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
index 251929213..1aed5242d 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
@@ -59,20 +59,24 @@ sealed interface io.ktor.server.plugins.di/DependencyConflictResult { // io.ktor
 }
 
 sealed interface io.ktor.server.plugins.di/DependencyCreateFunction { // io.ktor.server.plugins.di/DependencyCreateFunction|null[0]
+    abstract val key // io.ktor.server.plugins.di/DependencyCreateFunction.key|{}key[0]
+        abstract fun <get-key>(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/DependencyCreateFunction.key.<get-key>|<get-key>(){}[0]
+
     abstract fun create(io.ktor.server.plugins.di/DependencyResolver): kotlin/Any // io.ktor.server.plugins.di/DependencyCreateFunction.create|create(io.ktor.server.plugins.di.DependencyResolver){}[0]
 }
 
 final class io.ktor.server.plugins.di/AmbiguousCreateFunction : io.ktor.server.plugins.di/DependencyCreateFunction { // io.ktor.server.plugins.di/AmbiguousCreateFunction|null[0]
-    constructor <init>(io.ktor.server.plugins.di/DependencyKey, kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey>) // io.ktor.server.plugins.di/AmbiguousCreateFunction.<init>|<init>(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyKey>){}[0]
+    constructor <init>(io.ktor.server.plugins.di/DependencyKey, kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction>) // io.ktor.server.plugins.di/AmbiguousCreateFunction.<init>|<init>(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyCreateFunction>){}[0]
+    constructor <init>(io.ktor.server.plugins.di/DependencyKey, kotlin/Array<out io.ktor.server.plugins.di/DependencyCreateFunction>...) // io.ktor.server.plugins.di/AmbiguousCreateFunction.<init>|<init>(io.ktor.server.plugins.di.DependencyKey;kotlin.Array<out|io.ktor.server.plugins.di.DependencyCreateFunction>...){}[0]
 
+    final val functions // io.ktor.server.plugins.di/AmbiguousCreateFunction.functions|{}functions[0]
+        final fun <get-functions>(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/AmbiguousCreateFunction.functions.<get-functions>|<get-functions>(){}[0]
     final val key // io.ktor.server.plugins.di/AmbiguousCreateFunction.key|{}key[0]
         final fun <get-key>(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/AmbiguousCreateFunction.key.<get-key>|<get-key>(){}[0]
-    final val keys // io.ktor.server.plugins.di/AmbiguousCreateFunction.keys|{}keys[0]
-        final fun <get-keys>(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey> // io.ktor.server.plugins.di/AmbiguousCreateFunction.keys.<get-keys>|<get-keys>(){}[0]
 
     final fun component1(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/AmbiguousCreateFunction.component1|component1(){}[0]
-    final fun component2(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey> // io.ktor.server.plugins.di/AmbiguousCreateFunction.component2|component2(){}[0]
-    final fun copy(io.ktor.server.plugins.di/DependencyKey = ..., kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey> = ...): io.ktor.server.plugins.di/AmbiguousCreateFunction // io.ktor.server.plugins.di/AmbiguousCreateFunction.copy|copy(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyKey>){}[0]
+    final fun component2(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/AmbiguousCreateFunction.component2|component2(){}[0]
+    final fun copy(io.ktor.server.plugins.di/DependencyKey = ..., kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> = ...): io.ktor.server.plugins.di/AmbiguousCreateFunction // io.ktor.server.plugins.di/AmbiguousCreateFunction.copy|copy(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyCreateFunction>){}[0]
     final fun create(io.ktor.server.plugins.di/DependencyResolver): kotlin/Any // io.ktor.server.plugins.di/AmbiguousCreateFunction.create|create(io.ktor.server.plugins.di.DependencyResolver){}[0]
     final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.server.plugins.di/AmbiguousCreateFunction.equals|equals(kotlin.Any?){}[0]
     final fun hashCode(): kotlin/Int // io.ktor.server.plugins.di/AmbiguousCreateFunction.hashCode|hashCode(){}[0]
@@ -84,7 +88,7 @@ final class io.ktor.server.plugins.di/AmbiguousDependencyException : kotlin/Ille
 }
 
 final class io.ktor.server.plugins.di/CircularDependencyException : kotlin/IllegalStateException { // io.ktor.server.plugins.di/CircularDependencyException|null[0]
-    constructor <init>(io.ktor.server.plugins.di/DependencyKey) // io.ktor.server.plugins.di/CircularDependencyException.<init>|<init>(io.ktor.server.plugins.di.DependencyKey){}[0]
+    constructor <init>(kotlin.collections/Collection<io.ktor.server.plugins.di/DependencyKey>) // io.ktor.server.plugins.di/CircularDependencyException.<init>|<init>(kotlin.collections.Collection<io.ktor.server.plugins.di.DependencyKey>){}[0]
 }
 
 final class io.ktor.server.plugins.di/DependencyAbstractTypeConstructionException : io.ktor.server.plugins.di/DependencyConstructionException { // io.ktor.server.plugins.di/DependencyAbstractTypeConstructionException|null[0]
@@ -200,12 +204,16 @@ final class io.ktor.server.plugins.di/ExplicitCreateFunction : io.ktor.server.pl
 final class io.ktor.server.plugins.di/ImplicitCreateFunction : io.ktor.server.plugins.di/DependencyCreateFunction { // io.ktor.server.plugins.di/ImplicitCreateFunction|null[0]
     constructor <init>(io.ktor.server.plugins.di/ExplicitCreateFunction) // io.ktor.server.plugins.di/ImplicitCreateFunction.<init>|<init>(io.ktor.server.plugins.di.ExplicitCreateFunction){}[0]
 
+    final val key // io.ktor.server.plugins.di/ImplicitCreateFunction.key|{}key[0]
+        final fun <get-key>(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/ImplicitCreateFunction.key.<get-key>|<get-key>(){}[0]
     final val origin // io.ktor.server.plugins.di/ImplicitCreateFunction.origin|{}origin[0]
         final fun <get-origin>(): io.ktor.server.plugins.di/ExplicitCreateFunction // io.ktor.server.plugins.di/ImplicitCreateFunction.origin.<get-origin>|<get-origin>(){}[0]
 
     final fun create(io.ktor.server.plugins.di/DependencyResolver): kotlin/Any // io.ktor.server.plugins.di/ImplicitCreateFunction.create|create(io.ktor.server.plugins.di.DependencyResolver){}[0]
 }
 
+final class io.ktor.server.plugins.di/InvalidDependencyReferenceException : io.ktor.server.plugins.di/DependencyConstructionException // io.ktor.server.plugins.di/InvalidDependencyReferenceException|null[0]
+
 final class io.ktor.server.plugins.di/MapDependencyResolver : io.ktor.server.plugins.di/DependencyResolver { // io.ktor.server.plugins.di/MapDependencyResolver|null[0]
     constructor <init>(io.ktor.server.plugins.di/DependencyReflection, kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, kotlin/Result<kotlin/Any>>) // io.ktor.server.plugins.di/MapDependencyResolver.<init>|<init>(io.ktor.server.plugins.di.DependencyReflection;kotlin.collections.Map<io.ktor.server.plugins.di.DependencyKey,kotlin.Result<kotlin.Any>>){}[0]
 
@@ -232,6 +240,7 @@ final class io.ktor.server.plugins.di/ProcessingDependencyResolver : io.ktor.ser
 
     final fun <#A1: kotlin/Any> get(io.ktor.server.plugins.di/DependencyKey): #A1 // io.ktor.server.plugins.di/ProcessingDependencyResolver.get|get(io.ktor.server.plugins.di.DependencyKey){0ยง<kotlin.Any>}[0]
     final fun <#A1: kotlin/Any> getOrPut(io.ktor.server.plugins.di/DependencyKey, kotlin/Function0<#A1>): #A1 // io.ktor.server.plugins.di/ProcessingDependencyResolver.getOrPut|getOrPut(io.ktor.server.plugins.di.DependencyKey;kotlin.Function0<0:0>){0ยง<kotlin.Any>}[0]
+    final fun resolveAll(): kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, kotlin/Result<kotlin/Any>> // io.ktor.server.plugins.di/ProcessingDependencyResolver.resolveAll|resolveAll(){}[0]
 }
 
 open class io.ktor.server.plugins.di/DependencyConstructionException : kotlin/IllegalArgumentException { // io.ktor.server.plugins.di/DependencyConstructionException|null[0]
@@ -280,7 +289,6 @@ final var io.ktor.server.plugins.di/dependencies // io.ktor.server.plugins.di/de
     final fun (io.ktor.server.application/Application).<get-dependencies>(): io.ktor.server.plugins.di/DependencyRegistry // io.ktor.server.plugins.di/dependencies.<get-dependencies>|<get-dependencies>@io.ktor.server.application.Application(){}[0]
     final fun (io.ktor.server.application/Application).<set-dependencies>(io.ktor.server.plugins.di/DependencyRegistry) // io.ktor.server.plugins.di/dependencies.<set-dependencies>|<set-dependencies>@io.ktor.server.application.Application(io.ktor.server.plugins.di.DependencyRegistry){}[0]
 
-final fun (io.ktor.server.plugins.di/DependencyCreateFunction).io.ktor.server.plugins.di/keys(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyKey> // io.ktor.server.plugins.di/keys|keys@io.ktor.server.plugins.di.DependencyCreateFunction(){}[0]
 final fun (io.ktor.server.plugins.di/DependencyKeyCovariance).io.ktor.server.plugins.di/plus(io.ktor.server.plugins.di/DependencyKeyCovariance): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/plus|plus@io.ktor.server.plugins.di.DependencyKeyCovariance(io.ktor.server.plugins.di.DependencyKeyCovariance){}[0]
 final fun (io.ktor.server.plugins.di/DependencyKeyCovariance).io.ktor.server.plugins.di/times(io.ktor.server.plugins.di/DependencyKeyCovariance): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/times|times@io.ktor.server.plugins.di.DependencyKeyCovariance(io.ktor.server.plugins.di.DependencyKeyCovariance){}[0]
 final fun (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/invoke(kotlin/Function1<io.ktor.server.plugins.di/DependencyProviderContext, kotlin/Unit>) // io.ktor.server.plugins.di/invoke|invoke@io.ktor.server.plugins.di.DependencyProvider(kotlin.Function1<io.ktor.server.plugins.di.DependencyProviderContext,kotlin.Unit>){}[0]
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
index 8548567ae..d8f681649 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
@@ -6,6 +6,8 @@ package io.ktor.server.plugins.di
 
 import io.ktor.server.application.ApplicationPlugin
 import io.ktor.server.application.createApplicationPlugin
+import io.ktor.server.plugins.di.utils.ClasspathReference
+import io.ktor.server.plugins.di.utils.installReference
 import io.ktor.util.AttributeKey
 import io.ktor.util.reflect.TypeInfo
 import kotlin.reflect.KClass
@@ -17,16 +19,59 @@ import kotlin.reflect.KClass
  * 1. `provider`: the logic for registering new types
  * 2. `resolution`: the function for validating the provided types and creating the dependency map
  * 3. `reflection`: controls how objects are initialized from type references
+ *
+ * You can declare dependencies using the dependencies DSL:
+ *
+ * ```kotlin
+ * fun Application.databaseModule() {
+ *     dependencies {
+ *         provide<Database> { PostgresDatabase(resolve("connectionUrl")) }
+ *     }
+ * }
+ * ```
+ *
+ * Or through configuration:
+ *
+ * ```yaml
+ * ktor:
+ *   application:
+ *     dependencies:
+ *       - com.example.db.PostgresDatabase
+ * ```
+ *
+ * Each item declared via configuration can be a reference to a class or a
+ * top-level function.
+ *
+ * Resolving dependencies in application modules is also achieved through the DSL:
+ *
+ * ```kotlin
+ * fun Application.routing() {
+ *     val database: Database by dependencies
+ *     val repository: MessagesRepository = dependencies.create()
+ * }
+ * ```
+ *
+ * Alternatively, they can be supplied automatically through parameters.
  */
 public val DI: ApplicationPlugin<DependencyInjectionConfig> =
     createApplicationPlugin("DI", ::DependencyInjectionConfig) {
+        val configuredDependencyReferences =
+            environment.config.propertyOrNull("ktor.application.dependencies")
+                ?.getList()
+                ?.map { ClasspathReference(it) }
+                .orEmpty()
+
         application.attributes.put(
             DependencyRegistryKey,
             DependencyRegistryImpl(
                 pluginConfig.provider,
                 pluginConfig.resolution,
                 pluginConfig.reflection,
-            )
+            ).also { registry ->
+                for (reference in configuredDependencyReferences) {
+                    installReference(application, registry, reference)
+                }
+            }
         )
     }
 
@@ -136,8 +181,8 @@ public class AmbiguousDependencyException(key: DependencyKey, keys: Collection<D
 /**
  * Thrown when resolving a given dependency loops back on itself.
  */
-public class CircularDependencyException(key: DependencyKey) :
-    IllegalStateException("Circular dependency found for dependency `$key`")
+public class CircularDependencyException(internal val keys: Collection<DependencyKey>) :
+    IllegalStateException("Circular dependency found: ${keys.joinToString(" -> ")}")
 
 /**
  * Thrown when attempting to provide a dependency AFTER the dependency map is created.
@@ -165,3 +210,12 @@ public open class DependencyReflectionDisabledException() :
 public class DependencyAbstractTypeConstructionException(
     qualifiedName: String,
 ) : DependencyConstructionException("Cannot instantiate abstract type: $qualifiedName")
+
+/**
+ * Thrown when a static reference cannot be resolved from the configuration file.
+ */
+public class InvalidDependencyReferenceException internal constructor(
+    message: String,
+    reference: ClasspathReference,
+    cause: Throwable? = null
+) : DependencyConstructionException("$message: $reference", cause)
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
index e947c4c67..260c35fcd 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
@@ -47,6 +47,7 @@ public interface DependencyProvider {
  * Concrete types of this sealed interface are used to include some metadata regarding how they were registered.
  */
 public sealed interface DependencyCreateFunction {
+    public val key: DependencyKey
     public fun create(resolver: DependencyResolver): Any
 }
 
@@ -59,7 +60,7 @@ public sealed interface DependencyCreateFunction {
  * @property init A lambda that implements the creation logic for the dependency.
  */
 public class ExplicitCreateFunction(
-    public val key: DependencyKey,
+    public override val key: DependencyKey,
     private val init: DependencyResolver.() -> Any
 ) : DependencyCreateFunction {
     private var cached: Any? = null
@@ -77,6 +78,9 @@ public class ExplicitCreateFunction(
  * @property origin The instance of [ExplicitCreateFunction] that this class delegates creation logic to.
  */
 public class ImplicitCreateFunction(public val origin: ExplicitCreateFunction) : DependencyCreateFunction {
+    override val key: DependencyKey
+        get() = origin.key
+
     override fun create(resolver: DependencyResolver): Any =
         origin.create(resolver)
 }
@@ -92,30 +96,20 @@ public class ImplicitCreateFunction(public val origin: ExplicitCreateFunction) :
  * through the [create] method.
  */
 public data class AmbiguousCreateFunction(
-    val key: DependencyKey,
-    val keys: Set<DependencyKey>
+    public override val key: DependencyKey,
+    val functions: Set<DependencyCreateFunction>
 ) : DependencyCreateFunction {
+    init {
+        require(functions.isNotEmpty()) { "Functions must not be empty" }
+    }
+
+    public constructor(key: DependencyKey, vararg functions: DependencyCreateFunction) :
+        this(key, functions.flatMap { (it as? AmbiguousCreateFunction)?.functions ?: setOf(it) }.toSet())
+
     override fun create(resolver: DependencyResolver): Any =
-        throw AmbiguousDependencyException(key, keys)
+        throw AmbiguousDependencyException(key, functions.map { it.key })
 }
 
-/**
- * Retrieves the set of dependency keys associated with this creation function.
- *
- * For `ExplicitCreateFunction`, it returns a single key associated with the explicit registration.
- * For `ImplicitCreateFunction`, it returns the key of its origin `ExplicitCreateFunction`.
- * For `AmbiguousCreateFunction`, it returns all the keys that caused the ambiguity.
- *
- * @return A set of `DependencyKey` instances representing the dependency keys for this creation function,
- * depending on its specific implementation.
- */
-public fun DependencyCreateFunction.keys(): Set<DependencyKey> =
-    when (this) {
-        is ExplicitCreateFunction -> setOf(key)
-        is ImplicitCreateFunction -> setOf(origin.key)
-        is AmbiguousCreateFunction -> keys
-    }
-
 /**
  * Executes the given block of code with the current instance if it is of type [ImplicitCreateFunction].
  *
@@ -158,14 +152,14 @@ public open class MapDependencyProvider(
         insertCovariantKeys(create, key)
     }
 
-    private fun trySet(key: DependencyKey, value: DependencyCreateFunction) {
+    private fun trySet(key: DependencyKey, newFunction: DependencyCreateFunction) {
         when (val previous = map[key]) {
-            null -> map[key] = value
+            null -> map[key] = newFunction
             else -> {
-                map[key] = when (val result = conflictPolicy.resolve(previous, value)) {
-                    Ambiguous -> AmbiguousCreateFunction(key, previous.keys() + value.keys())
+                map[key] = when (val result = conflictPolicy.resolve(previous, newFunction)) {
+                    Ambiguous -> AmbiguousCreateFunction(key, previous, newFunction)
                     Conflict -> throw DuplicateDependencyException(key)
-                    KeepNew -> value
+                    KeepNew -> newFunction
                     KeepPrevious -> previous
                     is Replace -> result.function
                 }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
index 9a0029c1e..1c5a1de2a 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
@@ -58,10 +58,7 @@ public class DependencyRegistryImpl(
 public val DefaultDependencyResolution: DependencyResolution =
     DependencyResolution { provider, reflection ->
         val injector = ProcessingDependencyResolver(reflection, provider)
-        val instances = provider.declarations.keys.associateWith { key ->
-            runCatching { injector.get(key) as Any }
-        }
-        MapDependencyResolver(reflection, instances)
+        MapDependencyResolver(reflection, injector.resolveAll())
     }
 
 /**
@@ -72,17 +69,38 @@ public class ProcessingDependencyResolver(
     override val reflection: DependencyReflection,
     private val provider: DependencyProvider,
 ) : DependencyResolver {
-    private val resolved = mutableMapOf<DependencyKey, Any>()
+    private val resolved = mutableMapOf<DependencyKey, Result<Any>>()
     private val visited = mutableSetOf<DependencyKey>()
 
-    override fun <T : Any> get(key: DependencyKey): T =
-        getOrPut(key) {
-            if (!visited.add(key)) throw CircularDependencyException(key)
-            val result = provider.declarations[key]?.create(this)
-                ?: throw MissingDependencyException(key)
-            result as T
+    public fun resolveAll(): Map<DependencyKey, Result<Any>> {
+        if (resolved.isNotEmpty()) return resolved.toMap()
+
+        for (key in provider.declarations.keys) {
+            get<Any>(key)
         }
+        return resolved.toMap()
+    }
+
+    override fun <T : Any> get(key: DependencyKey): T =
+        resolved.getOrPut(key) {
+            if (!visited.add(key)) throw CircularDependencyException(listOf(key))
+            try {
+                val createFunction = provider.declarations[key]
+                    ?: throw MissingDependencyException(key)
+                Result.success(createFunction.create(this))
+            } catch (cause: CircularDependencyException) {
+                // Always throw when encountering with circular references,
+                // capturing each key in the stack allows for better debugging
+                throw CircularDependencyException(listOf(key) + cause.keys)
+            } catch (cause: Throwable) {
+                Result.failure(cause)
+            }
+        }.getOrThrow() as T
 
     override fun <T : Any> getOrPut(key: DependencyKey, defaultValue: () -> T): T =
-        resolved.getOrPut(key, defaultValue) as T
+        resolved.getOrPut(key) {
+            runCatching {
+                defaultValue()
+            }
+        }.getOrThrow() as T
 }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/utils/ClasspathReference.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/utils/ClasspathReference.kt
new file mode 100644
index 000000000..9b1d8aca4
--- /dev/null
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/utils/ClasspathReference.kt
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
+ */
+
+package io.ktor.server.plugins.di.utils
+
+import io.ktor.server.application.Application
+import io.ktor.server.plugins.di.DependencyRegistry
+import kotlin.jvm.JvmInline
+
+@JvmInline
+internal value class ClasspathReference private constructor(val value: String) {
+    companion object {
+        operator fun invoke(value: String): ClasspathReference {
+            return ClasspathReference(value.replace('#', '.'))
+        }
+    }
+
+    /**
+     * Refers to the containing compiled type, i.e. "FileNameKt", when referring to inner classes and
+     * top-level functions.  Otherwise, it may be the package name.
+     */
+    val container: String get() = value.lastIndexOf('.').let { index ->
+        if (index == -1) return ""
+        value.substring(0, index)
+    }
+
+    /**
+     * The string value after the last delimiter (# or .) - generally the function name or class name.
+     */
+    val name: String get() = value.substringAfterLast('.')
+
+    override fun toString(): String = value
+}
+
+internal expect fun installReference(
+    application: Application,
+    registry: DependencyRegistry,
+    reference: ClasspathReference,
+)
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/DependencyReflectionJvm.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/DependencyReflectionJvm.kt
index 49942f0dc..e5cbc43fd 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/DependencyReflectionJvm.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/DependencyReflectionJvm.kt
@@ -4,7 +4,7 @@
 
 package io.ktor.server.plugins.di
 
-import io.ktor.util.reflect.TypeInfo
+import io.ktor.util.reflect.*
 import kotlin.reflect.KClass
 import kotlin.reflect.KFunction
 import kotlin.reflect.KParameter
@@ -15,6 +15,7 @@ import kotlin.reflect.jvm.jvmErasure
  * calls for inferring which constructors to use, and how to evaluate the parameters as dependency keys.
  */
 public open class DependencyReflectionJvm : DependencyReflection {
+
     override fun <T : Any> create(kClass: KClass<T>, init: (DependencyKey) -> Any): T {
         if (kClass.isAbstract || kClass.java.isInterface) {
             throw DependencyAbstractTypeConstructionException(kClass.qualifiedName ?: "<unknown>")
@@ -27,8 +28,8 @@ public open class DependencyReflectionJvm : DependencyReflection {
         val instanceFromConstructors = constructors.firstNotNullOfOrNull { constructor ->
             runCatching {
                 constructor.callBy(
-                    constructor.parameters.associateWith { parameter ->
-                        init(toDependencyKey(parameter))
+                    mapParameters(constructor.parameters) { param ->
+                        init(toDependencyKey(param))
                     }
                 )
             }.onFailure {
@@ -39,14 +40,41 @@ public open class DependencyReflectionJvm : DependencyReflection {
         // Throw if we were unable to create a new instance
         return instanceFromConstructors
             ?: throw DependencyConstructionException(
-                "Unable to find a suitable constructor for type: ${kClass.qualifiedName}",
+                "No suitable constructor for type: ${kClass.qualifiedName}",
                 lastFailure
             )
     }
 
+    /**
+     * List constructors of a class in order of preference.
+     */
     public open fun <T : Any> findConstructors(kClass: KClass<T>): Collection<KFunction<T>> =
         kClass.constructors
 
+    /**
+     * Resolves the list of parameters from the provided resolve function.
+     *
+     * When optional or nullable, failures to retrieve the values are ignored.
+     */
+    public open fun mapParameters(
+        parameters: List<KParameter>,
+        resolve: (KParameter) -> Any?
+    ): Map<KParameter, Any?> =
+        parameters.mapNotNull { parameter ->
+            parameter to try {
+                resolve(parameter)
+            } catch (cause: Exception) {
+                when {
+                    parameter.isOptional -> return@mapNotNull null // ignore
+                    parameter.type.isMarkedNullable -> null // let value = null
+                    else -> throw cause
+                }
+            }
+        }.toMap()
+
+    /**
+     * Maps a parameter to a [DependencyKey].
+     */
     public open fun toDependencyKey(parameter: KParameter): DependencyKey =
         DependencyKey(TypeInfo(parameter.type.jvmErasure, parameter.type))
 }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
new file mode 100644
index 000000000..2819a6005
--- /dev/null
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
+ */
+
+package io.ktor.server.plugins.di.utils
+
+import io.ktor.server.application.*
+import io.ktor.server.plugins.di.*
+import io.ktor.util.reflect.*
+import kotlin.reflect.full.starProjectedType
+import kotlin.reflect.jvm.jvmErasure
+import kotlin.reflect.jvm.kotlinFunction
+
+internal actual fun installReference(
+    application: Application,
+    registry: DependencyRegistry,
+    reference: ClasspathReference,
+) {
+    val reflection = registry.reflection as? DependencyReflectionJvm ?: DependencyReflectionJvm()
+    val classLoader = Thread.currentThread().contextClassLoader
+    val clazz = classLoader.load(reference)
+
+    if (clazz.name == reference.value) {
+        // If this is a class reference,
+        // treat it as a `create(Object::class)` call
+        var kotlinType = clazz.kotlin
+        val classTypeInfo = TypeInfo(kotlinType, kotlinType.starProjectedType)
+
+        registry.set(DependencyKey(classTypeInfo)) {
+            reflection.create(kotlinType, ::get)
+        }
+    } else {
+        // Else, we assume this is a function reference
+        // where parameters are supplied by the DI container
+        // and the return type is used as the declaration
+        val matchingMethods = clazz.declaredMethods.filter { it.name == reference.name }
+        val functionCandidates = matchingMethods.mapNotNull { it.kotlinFunction }.takeIf { it.isNotEmpty() }
+            ?: throw InvalidDependencyReferenceException("Missing function reference", reference)
+        val returnType = functionCandidates.map { it.returnType }.distinct().singleOrNull()
+            ?: throw InvalidDependencyReferenceException("Ambiguous return types", reference)
+        val returnTypeInfo = TypeInfo(returnType.jvmErasure, returnType)
+
+        registry.set(DependencyKey(returnTypeInfo)) {
+            var lastError: Throwable? = null
+            for (function in functionCandidates) {
+                try {
+                    return@set function.callBy(
+                        reflection.mapParameters(function.parameters) { param ->
+                            when (param.type) {
+                                // special types, from application
+                                DependencyResolver::class.starProjectedType -> this@set
+                                ApplicationEnvironment::class.starProjectedType -> application.environment
+                                // regular types, from resolver
+                                else -> get<Any>(reflection.toDependencyKey(param))
+                            }
+                        }
+                    )
+                } catch (cause: Throwable) {
+                    lastError = cause
+                }
+            }
+            throw lastError!!
+        }
+    }
+}
+
+private fun ClassLoader.load(reference: ClasspathReference): Class<*> =
+    try {
+        loadClass(reference.value)
+    } catch (cause: Exception) {
+        runCatching {
+            loadClass(reference.container)
+        }.getOrElse {
+            throw InvalidDependencyReferenceException("Reference not found", reference, cause)
+        }
+    }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/nonJvm/src/io/ktor/server/plugins/di/utils/ClasspathReferences.nonJvm.kt b/ktor-server/ktor-server-plugins/ktor-server-di/nonJvm/src/io/ktor/server/plugins/di/utils/ClasspathReferences.nonJvm.kt
new file mode 100644
index 000000000..555e57db9
--- /dev/null
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/nonJvm/src/io/ktor/server/plugins/di/utils/ClasspathReferences.nonJvm.kt
@@ -0,0 +1,14 @@
+/*
+ * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
+ */
+
+package io.ktor.server.plugins.di.utils
+
+import io.ktor.server.application.Application
+import io.ktor.server.plugins.di.*
+
+internal actual fun installReference(
+    application: Application,
+    registry: DependencyRegistry,
+    reference: ClasspathReference
+): Unit = error("Reflection is not supported on this platform.")
