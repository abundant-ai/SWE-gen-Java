diff --git a/release-notes/VERSION b/release-notes/VERSION
index 8cfc07936..f6672b523 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -98,9 +98,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
   for Record-valued properties
  (reported by @JBodkin-Amphora)
  (implemented by @cowtowncoder, w/ Claude code)
-#5285: Generics using wildcard not correctly resolved
- (reported by @wimdeblauwe)
- (implemented by @cowtowncoder, w/ Claude code)
 #5350: Add `DeserializationFeature.USE_NULL_FOR_MISSING_REFERENCE_VALUES` for
   selecting `null` vs "empty/absent" value when deserializing missing `Optional` value
 #5361: Fix Maven SBOM publishing (worked in 3.0.0-rc4 but not in rc5 or later)
diff --git a/src/main/java/tools/jackson/databind/type/TypeFactory.java b/src/main/java/tools/jackson/databind/type/TypeFactory.java
index a6b4b63eb..c0e7d8e18 100644
--- a/src/main/java/tools/jackson/databind/type/TypeFactory.java
+++ b/src/main/java/tools/jackson/databind/type/TypeFactory.java
@@ -1538,36 +1538,9 @@ ClassUtil.nameOf(rawClass), pc, (pc == 1) ? "" : "s", bindings));
         if (paramCount == 0) {
             newBindings = EMPTY_BINDINGS;
         } else {
-            boolean anyWildcards = false;
-
             JavaType[] pt = new JavaType[paramCount];
             for (int i = 0; i < paramCount; ++i) {
-                if (args[i] instanceof WildcardType wt) {
-                    anyWildcards = true;
-                    // [databind#5285] Resolve wildcards using best available bound:
-                    // use the type variable's declared upper bound when the wildcard
-                    // itself is unbounded and the variable has a non-Object bound.
-                    // Self-referential parameters excluded (handled below, [databind#4118]).
-                    Type effectiveBound = wt.getUpperBounds()[0];
-                    if (effectiveBound == Object.class) {
-                        Type[] lowerBounds = wt.getLowerBounds();
-                        if (lowerBounds == null || lowerBounds.length == 0) {
-                            TypeVariable<? extends Class<?>> typeVar = rawType.getTypeParameters()[i];
-                            if (!_isSelfReferentialTypeParameter(typeVar, rawType)) {
-                                final Type[] varBounds;
-                                synchronized (typeVar) {
-                                    varBounds = typeVar.getBounds();
-                                }
-                                if (varBounds.length > 0 && varBounds[0] != Object.class) {
-                                    effectiveBound = varBounds[0];
-                                }
-                            }
-                        }
-                    }
-                    pt[i] = _fromAny(context, effectiveBound, parentBindings);
-                } else {
-                    pt[i] = _fromAny(context, args[i], parentBindings);
-                }
+                pt[i] = _fromAny(context, args[i], parentBindings);
             }
             newBindings = TypeBindings.create(rawType, pt);
 
@@ -1575,16 +1548,14 @@ ClassUtil.nameOf(rawClass), pc, (pc == 1) ? "" : "s", bindings));
             // to allow deserializers to use the class definition's bounds instead of Object.
             // [databind#4147] Only unbind for self-referential parameters to avoid
             // breaking multi-parameter types like Either<L, R> where only some are wildcards.
-            if (anyWildcards) {
-                for (int i = 0; i < paramCount; ++i) {
-                    if (args[i] instanceof WildcardType && !pt[i].hasGenericTypes()) {
-                        TypeVariable<? extends Class<?>> typeVariable = rawType.getTypeParameters()[i];
-    
-                        // Only unbind if this is a (direct) self-referential type parameter
-                        if (_isSelfReferentialTypeParameter(typeVariable, rawType)) {
-                            if (pt[i].getRawClass().isAssignableFrom(rawClass(typeVariable))) {
-                                newBindings = newBindings.withoutVariable(typeVariable.getName());
-                            }
+            for (int i = 0; i < paramCount; ++i) {
+                if (args[i] instanceof WildcardType && !pt[i].hasGenericTypes()) {
+                    TypeVariable<? extends Class<?>> typeVariable = rawType.getTypeParameters()[i];
+
+                    // Only unbind if this is a (direct) self-referential type parameter
+                    if (_isSelfReferentialTypeParameter(typeVariable, rawType)) {
+                        if (pt[i].getRawClass().isAssignableFrom(rawClass(typeVariable))) {
+                            newBindings = newBindings.withoutVariable(typeVariable.getName());
                         }
                     }
                 }
diff --git a/src/test/java/tools/jackson/databind/type/WildcardBoundResolve5285Test.java b/src/test/java/tools/jackson/databind/type/WildcardBoundResolve5285Test.java
deleted file mode 100644
index 68b2d9cd1..000000000
--- a/src/test/java/tools/jackson/databind/type/WildcardBoundResolve5285Test.java
+++ /dev/null
@@ -1,125 +0,0 @@
-package tools.jackson.databind.type;
-
-import java.lang.reflect.Type;
-
-import org.junit.jupiter.api.Test;
-
-import com.fasterxml.jackson.annotation.JsonSubTypes;
-import com.fasterxml.jackson.annotation.JsonTypeInfo;
-
-import tools.jackson.databind.*;
-import tools.jackson.databind.testutil.DatabindTestUtil;
-
-import static org.junit.jupiter.api.Assertions.*;
-
-// Tests for [databind#5285]: unbounded wildcards should resolve to
-// the type variable's declared upper bound, not Object.
-class WildcardBoundResolve5285Test extends DatabindTestUtil
-{
-    // -- Test type hierarchy from the original issue report --
-
-    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
-    @JsonSubTypes({
-        @JsonSubTypes.Type(value = EmailSettings.class, name = "EMAIL"),
-        @JsonSubTypes.Type(value = PhoneSettings.class, name = "PHONE")
-    })
-    interface Settings { }
-
-    record EmailSettings(String email) implements Settings { }
-
-    record PhoneSettings(String phoneNumber) implements Settings { }
-
-    record MessageWrapper<T extends Settings>(T settings, String message) { }
-
-    // Container to obtain ParameterizedType via field reflection
-    static class Holder {
-        MessageWrapper<?> wildcardWrapper;
-        MessageWrapper<EmailSettings> specificWrapper;
-    }
-
-    // -- Additional test types --
-
-    static class Box<T extends Number> {
-        public T value;
-    }
-
-    static class BoxHolder {
-        Box<?> wildcardBox;
-    }
-
-    static class Pair<L, R> {
-        public L left;
-        public R right;
-    }
-
-    @SuppressWarnings("unused")
-    static class PairHolder {
-        Pair<String, ?> wildcardPair;
-    }
-
-    // -- Tests --
-
-    private final ObjectMapper MAPPER = newJsonMapper();
-
-    // Core issue: wildcard type resolution should use declared bound
-    @Test
-    void wildcardResolvesToDeclaredBound() throws Exception {
-        Type genericType = Holder.class.getDeclaredField("wildcardWrapper").getGenericType();
-        JavaType jacksonType = MAPPER.constructType(genericType);
-
-        // Should resolve to MessageWrapper<Settings>, NOT MessageWrapper<Object>
-        assertEquals(MessageWrapper.class, jacksonType.getRawClass());
-        assertEquals(1, jacksonType.containedTypeCount());
-        assertEquals(Settings.class, jacksonType.containedType(0).getRawClass());
-    }
-
-    // Specific type should still work unchanged
-    @Test
-    void specificTypeUnchanged() throws Exception {
-        Type genericType = Holder.class.getDeclaredField("specificWrapper").getGenericType();
-        JavaType jacksonType = MAPPER.constructType(genericType);
-
-        assertEquals(MessageWrapper.class, jacksonType.getRawClass());
-        assertEquals(1, jacksonType.containedTypeCount());
-        assertEquals(EmailSettings.class, jacksonType.containedType(0).getRawClass());
-    }
-
-    // Serialization with wildcard type should include @JsonTypeInfo discriminator
-    @Test
-    void serializationPreservesTypeInfo() throws Exception {
-        MessageWrapper<EmailSettings> wrapper = new MessageWrapper<>(
-                new EmailSettings("me@me.com"), "Sample Message");
-        Type genericType = Holder.class.getDeclaredField("wildcardWrapper").getGenericType();
-        JavaType jacksonType = MAPPER.constructType(genericType);
-        String json = MAPPER.writerFor(jacksonType).writeValueAsString(wrapper);
-
-        assertTrue(json.contains("\"type\":\"EMAIL\""),
-                "JSON should contain type discriminator, got: " + json);
-        assertTrue(json.contains("\"email\":\"me@me.com\""),
-                "JSON should contain email field, got: " + json);
-    }
-
-    // Non-regression: Box<T extends Number> with Box<?> should resolve to Number
-    @Test
-    void wildcardResolvesToNumberBound() throws Exception {
-        Type genericType = BoxHolder.class.getDeclaredField("wildcardBox").getGenericType();
-        JavaType jacksonType = MAPPER.constructType(genericType);
-
-        assertEquals(Box.class, jacksonType.getRawClass());
-        assertEquals(1, jacksonType.containedTypeCount());
-        assertEquals(Number.class, jacksonType.containedType(0).getRawClass());
-    }
-
-    // Non-regression: Pair<L, R> (no explicit bounds) with Pair<String, ?> keeps Object for R
-    @Test
-    void unboundedTypeParamStaysObject() throws Exception {
-        Type genericType = PairHolder.class.getDeclaredField("wildcardPair").getGenericType();
-        JavaType jacksonType = MAPPER.constructType(genericType);
-
-        assertEquals(Pair.class, jacksonType.getRawClass());
-        assertEquals(2, jacksonType.containedTypeCount());
-        assertEquals(String.class, jacksonType.containedType(0).getRawClass());
-        // R has no explicit bound, so ? should stay as Object
-        assertEquals(Object.class, jacksonType.containedType(1).getRawClass());
-    }
-}
