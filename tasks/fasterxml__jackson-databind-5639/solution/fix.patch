diff --git a/release-notes/VERSION b/release-notes/VERSION
index f6672b523..8cfc07936 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -98,6 +98,9 @@ Versions: 3.x (for earlier see VERSION-2.x)
   for Record-valued properties
  (reported by @JBodkin-Amphora)
  (implemented by @cowtowncoder, w/ Claude code)
+#5285: Generics using wildcard not correctly resolved
+ (reported by @wimdeblauwe)
+ (implemented by @cowtowncoder, w/ Claude code)
 #5350: Add `DeserializationFeature.USE_NULL_FOR_MISSING_REFERENCE_VALUES` for
   selecting `null` vs "empty/absent" value when deserializing missing `Optional` value
 #5361: Fix Maven SBOM publishing (worked in 3.0.0-rc4 but not in rc5 or later)
diff --git a/src/main/java/tools/jackson/databind/type/TypeFactory.java b/src/main/java/tools/jackson/databind/type/TypeFactory.java
index c0e7d8e18..a6b4b63eb 100644
--- a/src/main/java/tools/jackson/databind/type/TypeFactory.java
+++ b/src/main/java/tools/jackson/databind/type/TypeFactory.java
@@ -1538,9 +1538,36 @@ ClassUtil.nameOf(rawClass), pc, (pc == 1) ? "" : "s", bindings));
         if (paramCount == 0) {
             newBindings = EMPTY_BINDINGS;
         } else {
+            boolean anyWildcards = false;
+
             JavaType[] pt = new JavaType[paramCount];
             for (int i = 0; i < paramCount; ++i) {
-                pt[i] = _fromAny(context, args[i], parentBindings);
+                if (args[i] instanceof WildcardType wt) {
+                    anyWildcards = true;
+                    // [databind#5285] Resolve wildcards using best available bound:
+                    // use the type variable's declared upper bound when the wildcard
+                    // itself is unbounded and the variable has a non-Object bound.
+                    // Self-referential parameters excluded (handled below, [databind#4118]).
+                    Type effectiveBound = wt.getUpperBounds()[0];
+                    if (effectiveBound == Object.class) {
+                        Type[] lowerBounds = wt.getLowerBounds();
+                        if (lowerBounds == null || lowerBounds.length == 0) {
+                            TypeVariable<? extends Class<?>> typeVar = rawType.getTypeParameters()[i];
+                            if (!_isSelfReferentialTypeParameter(typeVar, rawType)) {
+                                final Type[] varBounds;
+                                synchronized (typeVar) {
+                                    varBounds = typeVar.getBounds();
+                                }
+                                if (varBounds.length > 0 && varBounds[0] != Object.class) {
+                                    effectiveBound = varBounds[0];
+                                }
+                            }
+                        }
+                    }
+                    pt[i] = _fromAny(context, effectiveBound, parentBindings);
+                } else {
+                    pt[i] = _fromAny(context, args[i], parentBindings);
+                }
             }
             newBindings = TypeBindings.create(rawType, pt);
 
@@ -1548,14 +1575,16 @@ ClassUtil.nameOf(rawClass), pc, (pc == 1) ? "" : "s", bindings));
             // to allow deserializers to use the class definition's bounds instead of Object.
             // [databind#4147] Only unbind for self-referential parameters to avoid
             // breaking multi-parameter types like Either<L, R> where only some are wildcards.
-            for (int i = 0; i < paramCount; ++i) {
-                if (args[i] instanceof WildcardType && !pt[i].hasGenericTypes()) {
-                    TypeVariable<? extends Class<?>> typeVariable = rawType.getTypeParameters()[i];
-
-                    // Only unbind if this is a (direct) self-referential type parameter
-                    if (_isSelfReferentialTypeParameter(typeVariable, rawType)) {
-                        if (pt[i].getRawClass().isAssignableFrom(rawClass(typeVariable))) {
-                            newBindings = newBindings.withoutVariable(typeVariable.getName());
+            if (anyWildcards) {
+                for (int i = 0; i < paramCount; ++i) {
+                    if (args[i] instanceof WildcardType && !pt[i].hasGenericTypes()) {
+                        TypeVariable<? extends Class<?>> typeVariable = rawType.getTypeParameters()[i];
+    
+                        // Only unbind if this is a (direct) self-referential type parameter
+                        if (_isSelfReferentialTypeParameter(typeVariable, rawType)) {
+                            if (pt[i].getRawClass().isAssignableFrom(rawClass(typeVariable))) {
+                                newBindings = newBindings.withoutVariable(typeVariable.getName());
+                            }
                         }
                     }
                 }
