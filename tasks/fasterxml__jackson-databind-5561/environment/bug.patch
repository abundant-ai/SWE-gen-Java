diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index a27dcb615..38ef7795c 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -167,11 +167,6 @@ Victor NoÃ«l (@victornoel)
   `DeserializationFeature.USE_NULL_FOR_EMPTY_UNWRAPPED` enabled
  [3.1.0]
 
-Garret Wilson (@garretwilson)
- * Suggested #4157: Add `MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY` to ignore
-   getter method auto-detection for Records
- [3.1.0]
-
 James Mudd (@jamesmudd)
  * Reported #4277: Deserialization `@JsonFormat(shape = JsonFormat.Shape.ARRAY)` POJO with
   `JsonTypeInfo.As.EXTERNAL_PROPERTY` does not work
diff --git a/release-notes/VERSION b/release-notes/VERSION
index c0667c0dd..6422f3a2b 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -48,10 +48,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
   resolve `?` into expected bounds, resulting in `LinkedHashMap`
  (reported by @Mariusz)
  (fix by @cowtowncoder, w/ Claude code)
-#4157: Add `MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY` to ignore
-  getter method auto-detection for Records
- (suggested by Garret W)
- (fix by @cowtowncoder, w/ Claude code)
 #4277: Deserialization `@JsonFormat(shape = JsonFormat.Shape.ARRAY)` POJO with
   `JsonTypeInfo.As.EXTERNAL_PROPERTY` does not work
  (reported by James M)
diff --git a/src/main/java/tools/jackson/databind/MapperFeature.java b/src/main/java/tools/jackson/databind/MapperFeature.java
index 4e326f6c2..d521fc1af 100644
--- a/src/main/java/tools/jackson/databind/MapperFeature.java
+++ b/src/main/java/tools/jackson/databind/MapperFeature.java
@@ -126,35 +126,6 @@ public enum MapperFeature
      */
     ALLOW_IS_GETTERS_FOR_NON_BOOLEAN(false),
 
-    /**
-     * Feature that determines whether, for Java {@code Record} types, Jackson should
-     * only infer getter methods from actual Record components, or whether
-     * getter methods should be auto-detected based on name (and within limits
-     * of Jackson visibility as per {@code @JsonAutoDetect} and defaults).
-     * <p>
-     * When enabled (true), only getter methods matching Record component names will ever
-     * be auto-detected for serialization; helper methods like {@code getDisplayName()} on a
-     * Record with component {@code name} will NOT be serialized unless explicitly
-     * annotated with {@code @JsonProperty}.
-     * <p>
-     * When disabled (false, the default), public getter methods following JavaBean
-     * conventions may be auto-detected, which may include helper methods that are not
-     * Record components.
-     * <p>
-     * Note that:
-     * <ul>
-     *  <li>Explicit annotations ({@code @JsonProperty}, {@code @JsonGetter}, etc.)
-     *      always take precedence and will work regardless of this setting</li>
-     *  <li>This setting only affects getter detection for Records; it does NOT affect
-     *      setter or field detection, and has no effect on regular POJOs</li>
-     * </ul>
-     * <p>
-     * Feature is disabled by default for backward compatibility.
-     *
-     * @since 3.1
-     */
-    INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY(false),
-
     /**
      * Feature that determines whether nominal property type of {@link Void} is
      * allowed for Getter methods to indicate {@code null} valued pseudo-property
diff --git a/src/main/java/tools/jackson/databind/introspect/DefaultAccessorNamingStrategy.java b/src/main/java/tools/jackson/databind/introspect/DefaultAccessorNamingStrategy.java
index 2f4d369e4..7106d6e35 100644
--- a/src/main/java/tools/jackson/databind/introspect/DefaultAccessorNamingStrategy.java
+++ b/src/main/java/tools/jackson/databind/introspect/DefaultAccessorNamingStrategy.java
@@ -432,10 +432,6 @@ public class DefaultAccessorNamingStrategy
         @Override
         public AccessorNamingStrategy forRecord(MapperConfig<?> config, AnnotatedClass recordClass)
         {
-            // [databind#4157]: If configured to restrict to components only, use stricter strategy
-            if (config.isEnabled(MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY)) {
-                return new RecordNamingStrict(config, recordClass);
-            }
             return new RecordNaming(config, recordClass);
         }
     }
@@ -549,53 +545,4 @@ public class DefaultAccessorNamingStrategy
             return super.findNameForRegularGetter(am, name);
         }
     }
-
-    /**
-     * Stricter {@link RecordNaming} implementation used when
-     * {@link MapperFeature#INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY} is enabled.
-     * Unlike the default {@link RecordNaming}, this strategy does NOT fall back to
-     * standard getter/setter detection for methods that don't match Record component names.
-     *<p>
-     * This prevents helper methods like {@code getDisplayName()} from being auto-detected
-     * and serialized when they are not actual Record components.
-     *
-     * @since 3.1
-     */
-    public static class RecordNamingStrict
-        extends RecordNaming
-    {
-        public RecordNamingStrict(MapperConfig<?> config, AnnotatedClass forClass) {
-            super(config, forClass);
-        }
-
-        @Override
-        public String findNameForRegularGetter(AnnotatedMethod am, String name)
-        {
-            // Only allow exact component name matches, no "get" prefix detection
-            if (_fieldNames.contains(name)) {
-                return name;
-            }
-            return null;
-        }
-
-        @Override
-        public String findNameForIsGetter(AnnotatedMethod am, String name)
-        {
-            // Only allow exact component name matches, no "is" prefix detection
-            if (_fieldNames.contains(name)) {
-                return name;
-            }
-            return null;
-        }
-
-        @Override
-        public String findNameForMutator(AnnotatedMethod am, String name)
-        {
-            // Only allow exact component name matches, no "set"/"with" prefix detection
-            if (_fieldNames.contains(name)) {
-                return name;
-            }
-            return null;
-        }
-    }
 }
diff --git a/src/test/java/tools/jackson/databind/records/RecordIgnoreGetters4157Test.java b/src/test/java/tools/jackson/databind/records/RecordIgnoreGetters4157Test.java
deleted file mode 100644
index aaffda4fa..000000000
--- a/src/test/java/tools/jackson/databind/records/RecordIgnoreGetters4157Test.java
+++ /dev/null
@@ -1,286 +0,0 @@
-package tools.jackson.databind.records;
-
-import org.junit.jupiter.api.Test;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
-import com.fasterxml.jackson.annotation.JsonPropertyOrder;
-
-import tools.jackson.databind.ObjectMapper;
-import tools.jackson.databind.MapperFeature;
-import tools.jackson.databind.testutil.DatabindTestUtil;
-
-import static org.junit.jupiter.api.Assertions.*;
-
-/**
- * Tests for {@link MapperFeature#INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY}
- * which controls whether only Record component getters are auto-detected
- * or if all JavaBean-style getters are detected (backward compatible behavior).
- */
-public class RecordIgnoreGetters4157Test extends DatabindTestUtil
-{
-    // Test Case 1: Basic record with helper getter
-    record PersonRecord(String name, int age) {
-        // Helper method that is NOT a record component
-        public String getDisplayName() {
-            return name.toUpperCase();
-        }
-    }
-
-    // Test Case 2: Record implementing interface with getter
-    interface Identifiable {
-        String getId();
-    }
-
-    @JsonPropertyOrder({"name", "id"})
-    record UserRecord(String name) implements Identifiable {
-        @Override
-        public String getId() {
-            return "ID:" + name;
-        }
-    }
-
-    // Test Case 3: Record with explicit annotation on helper method
-    record AnnotatedHelperRecord(String name) {
-        @JsonProperty("display")
-        public String getDisplayName() {
-            return name.toUpperCase();
-        }
-    }
-
-    // Test Case 4: Record with is-getter helper
-    record BooleanHelperRecord(String name, boolean active) {
-        // Helper method - not a component
-        public boolean isSpecial() {
-            return name.startsWith("Special");
-        }
-    }
-
-    // Test Case 5: Record with both component getter and helper
-    record MixedRecord(int value) {
-        // Component accessor - should always work
-        @Override
-        public int value() {
-            return value;
-        }
-
-        // Helper - behavior depends on feature
-        public int getDoubleValue() {
-            return value * 2;
-        }
-    }
-
-    // Test Case 6: Empty record with static getter
-    record EmptyWithStatic() {
-        public static String getStaticValue() {
-            return "static";
-        }
-    }
-
-    private final ObjectMapper MAPPER_DEFAULT = newJsonMapper();
-
-    private final ObjectMapper MAPPER_RESTRICTED = jsonMapperBuilder()
-            .enable(MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY)
-            .build();
-
-    /*
-     * Test: Feature is DISABLED by default (backward compatibility)
-     */
-    @Test
-    public void testFeatureDisabledByDefault() throws Exception {
-        assertFalse(MAPPER_DEFAULT.isEnabled(MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY));
-    }
-
-    /*
-     * Test: With feature DISABLED, helper getters ARE serialized
-     */
-    @Test
-    public void testHelperGetterIncluded_FeatureDisabled() throws Exception {
-        PersonRecord person = new PersonRecord("john", 30);
-        String json = MAPPER_DEFAULT.writeValueAsString(person);
-
-        // Should include helper method
-        assertTrue(json.contains("displayName"), "Should include displayName with feature disabled");
-        assertTrue(json.contains("JOHN"), "Should have uppercase name");
-        assertTrue(json.contains("name"), "Should include actual component");
-        assertTrue(json.contains("age"), "Should include actual component");
-    }
-
-    /*
-     * Test: With feature ENABLED, helper getters are NOT serialized
-     */
-    @Test
-    public void testHelperGetterExcluded_FeatureEnabled() throws Exception {
-        PersonRecord person = new PersonRecord("john", 30);
-        String json = MAPPER_RESTRICTED.writeValueAsString(person);
-
-        // Should NOT include helper method
-        assertFalse(json.contains("displayName"), "Should NOT include displayName with feature enabled");
-        assertFalse(json.contains("JOHN"), "Should NOT have uppercase name");
-        // Should still include actual components
-        assertTrue(json.contains("name"), "Should include actual component");
-        assertTrue(json.contains("john"), "Should have original name");
-        assertTrue(json.contains("age"), "Should include actual component");
-    }
-
-    /*
-     * Test: Interface getter excluded when feature enabled
-     */
-    @Test
-    public void testInterfaceGetterExcluded_FeatureEnabled() throws Exception {
-        UserRecord user = new UserRecord("alice");
-        String json = MAPPER_RESTRICTED.writeValueAsString(user);
-
-        assertEquals(a2q("{'name':'alice'}"), json);
-        assertFalse(json.contains("id"), "Should NOT include interface getter");
-    }
-
-    /*
-     * Test: Interface getter included when feature disabled
-     */
-    @Test
-    public void testInterfaceGetterIncluded_FeatureDisabled() throws Exception {
-        UserRecord user = new UserRecord("alice");
-        String json = MAPPER_DEFAULT.writeValueAsString(user);
-
-        assertTrue(json.contains("id"), "Should include interface getter");
-        assertTrue(json.contains("ID:alice"), "Should have computed id");
-    }
-
-    /*
-     * Test: Explicit @JsonProperty ALWAYS works regardless of feature
-     */
-    @Test
-    public void testExplicitAnnotation_AlwaysWorks_FeatureEnabled() throws Exception {
-        AnnotatedHelperRecord record = new AnnotatedHelperRecord("test");
-        String json = MAPPER_RESTRICTED.writeValueAsString(record);
-
-        assertTrue(json.contains("display"), "Explicit @JsonProperty should always work");
-        assertTrue(json.contains("TEST"), "Should have uppercase value");
-    }
-
-    @Test
-    public void testExplicitAnnotation_AlwaysWorks_FeatureDisabled() throws Exception {
-        AnnotatedHelperRecord record = new AnnotatedHelperRecord("test");
-        String json = MAPPER_DEFAULT.writeValueAsString(record);
-
-        assertTrue(json.contains("display"), "Explicit @JsonProperty should always work");
-        assertTrue(json.contains("TEST"), "Should have uppercase value");
-    }
-
-    /*
-     * Test: Is-getter helpers excluded when feature enabled
-     */
-    @Test
-    public void testIsGetterHelper_FeatureEnabled() throws Exception {
-        BooleanHelperRecord record = new BooleanHelperRecord("Special Case", true);
-        String json = MAPPER_RESTRICTED.writeValueAsString(record);
-
-        assertTrue(json.contains("active"), "Should include actual boolean component");
-        assertFalse(json.contains("special"), "Should NOT include is-getter helper");
-    }
-
-    @Test
-    public void testIsGetterHelper_FeatureDisabled() throws Exception {
-        BooleanHelperRecord record = new BooleanHelperRecord("Special Case", true);
-        String json = MAPPER_DEFAULT.writeValueAsString(record);
-
-        assertTrue(json.contains("active"), "Should include actual boolean component");
-        assertTrue(json.contains("special"), "Should include is-getter helper with feature disabled");
-    }
-
-    /*
-     * Test: Component accessor with same name as helper
-     */
-    @Test
-    public void testComponentAccessor_AlwaysWorks() throws Exception {
-        MixedRecord record = new MixedRecord(42);
-
-        // Feature enabled - only component
-        String jsonRestricted = MAPPER_RESTRICTED.writeValueAsString(record);
-        assertTrue(jsonRestricted.contains("value"), "Component should be included");
-        assertTrue(jsonRestricted.contains("42"), "Should have value 42");
-        assertFalse(jsonRestricted.contains("doubleValue"), "Helper should be excluded");
-
-        // Feature disabled - both
-        String jsonDefault = MAPPER_DEFAULT.writeValueAsString(record);
-        assertTrue(jsonDefault.contains("value"), "Component should be included");
-        assertTrue(jsonDefault.contains("doubleValue"), "Helper should be included");
-        assertTrue(jsonDefault.contains("84"), "Should have doubled value");
-    }
-
-    /*
-     * Test: Round-trip with feature enabled maintains data integrity
-     */
-    @Test
-    public void testRoundTrip_FeatureEnabled() throws Exception {
-        PersonRecord original = new PersonRecord("alice", 25);
-
-        String json = MAPPER_RESTRICTED.writeValueAsString(original);
-        PersonRecord deserialized = MAPPER_RESTRICTED.readValue(json, PersonRecord.class);
-
-        assertEquals(original, deserialized, "Round-trip should preserve data");
-        assertEquals("alice", deserialized.name());
-        assertEquals(25, deserialized.age());
-    }
-
-    /*
-     * Test: Deserialization ignores extra properties (helper getters not in components)
-     */
-    @Test
-    public void testDeserialization_IgnoresNonComponentProperties() throws Exception {
-        // JSON with helper property that was serialized with feature disabled
-        String json = a2q("{'name':'bob','age':30,'displayName':'BOB'}");
-
-        PersonRecord deserialized = MAPPER_RESTRICTED.readValue(json, PersonRecord.class);
-
-        assertEquals("bob", deserialized.name());
-        assertEquals(30, deserialized.age());
-        // displayName is ignored during deserialization (not a component)
-    }
-
-    /*
-     * Test: Static methods are never included (baseline behavior)
-     */
-    @Test
-    public void testStaticGetter_NeverIncluded() throws Exception {
-        EmptyWithStatic record = new EmptyWithStatic();
-
-        String jsonRestricted = MAPPER_RESTRICTED.writeValueAsString(record);
-        String jsonDefault = MAPPER_DEFAULT.writeValueAsString(record);
-
-        assertEquals("{}", jsonRestricted, "Static getter should not be included");
-        assertEquals("{}", jsonDefault, "Static getter should not be included");
-    }
-
-    /*
-     * Test: Feature configuration via builder
-     */
-    @Test
-    public void testFeatureConfiguration_ViaBuilder() throws Exception {
-        ObjectMapper mapper = jsonMapperBuilder()
-                .enable(MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY)
-                .build();
-
-        assertTrue(mapper.isEnabled(MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY));
-
-        PersonRecord person = new PersonRecord("test", 1);
-        String json = mapper.writeValueAsString(person);
-        assertFalse(json.contains("displayName"));
-    }
-
-    /*
-     * Test: Feature can be disabled explicitly
-     */
-    @Test
-    public void testFeatureConfiguration_ExplicitDisable() throws Exception {
-        ObjectMapper mapper = jsonMapperBuilder()
-                .disable(MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY)
-                .build();
-
-        assertFalse(mapper.isEnabled(MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY));
-
-        PersonRecord person = new PersonRecord("test", 1);
-        String json = mapper.writeValueAsString(person);
-        assertTrue(json.contains("displayName"));
-    }
-}
diff --git a/src/test/java/tools/jackson/databind/records/RecordIgnoreNonAccessorGetterTest.java b/src/test/java/tools/jackson/databind/records/RecordIgnoreNonAccessorGetterTest.java
index 58c9f932d..d99e5d240 100644
--- a/src/test/java/tools/jackson/databind/records/RecordIgnoreNonAccessorGetterTest.java
+++ b/src/test/java/tools/jackson/databind/records/RecordIgnoreNonAccessorGetterTest.java
@@ -6,7 +6,6 @@ import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
 import com.fasterxml.jackson.annotation.JsonPropertyOrder;
 import com.fasterxml.jackson.annotation.PropertyAccessor;
 
-import tools.jackson.databind.MapperFeature;
 import tools.jackson.databind.ObjectMapper;
 import tools.jackson.databind.testutil.DatabindTestUtil;
 
@@ -42,39 +41,24 @@ public class RecordIgnoreNonAccessorGetterTest extends DatabindTestUtil {
     }
 
     @Test
-    public void testSerializeIgnoreInterfaceGetter_WithoutUsingVisibilityConfig()
-    {
-        final ObjectMapper mapper = newJsonMapper();
-        String json = mapper.writeValueAsString(new RecordWithInterfaceWithGetter("Bob"));
+    public void testSerializeIgnoreInterfaceGetter_WithoutUsingVisibilityConfig() throws Exception {
+        final ObjectMapper MAPPER = newJsonMapper();
+        String json = MAPPER.writeValueAsString(new RecordWithInterfaceWithGetter("Bob"));
+
         assertEquals("{\"id\":\"ID:Bob\",\"name\":\"Bob\",\"count\":999}", json);
     }
 
     @Test
-    public void testSerializeIgnoreInterfaceGetter_UsingVisibilityConfig()
-    {
-        final ObjectMapper mapper = jsonMapperBuilder()
+    public void testSerializeIgnoreInterfaceGetter_UsingVisibilityConfig() throws Exception {
+        final ObjectMapper MAPPER = jsonMapperBuilder()
                 .changeDefaultVisibility(vc ->
                     vc.withVisibility(PropertyAccessor.GETTER, Visibility.NONE)
                         .withVisibility(PropertyAccessor.FIELD, Visibility.ANY)
                 )
                 .build();
 
-        String json = mapper.writeValueAsString(new RecordWithInterfaceWithGetter("Bob"));
-
-        assertEquals("{\"name\":\"Bob\"}", json);
-    }
-
-    // [databind#4157]
-    @Test
-    public void testWithInferGettersFromComponentsOnlyFeature()
-    {
-        final ObjectMapper mapper = jsonMapperBuilder()
-                .enable(MapperFeature.INFER_RECORD_GETTERS_FROM_COMPONENTS_ONLY)
-                .build();
-
-        String json = mapper.writeValueAsString(new RecordWithInterfaceWithGetter("Bob"));
+        String json = MAPPER.writeValueAsString(new RecordWithInterfaceWithGetter("Bob"));
 
-        // With feature enabled, only the actual record component should be serialized
         assertEquals("{\"name\":\"Bob\"}", json);
     }
 }
