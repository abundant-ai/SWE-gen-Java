diff --git a/retrofit/src/main/java/retrofit/MethodInfo.java b/retrofit/src/main/java/retrofit/MethodInfo.java
index 89b9c7df..2792856a 100644
--- a/retrofit/src/main/java/retrofit/MethodInfo.java
+++ b/retrofit/src/main/java/retrofit/MethodInfo.java
@@ -15,7 +15,6 @@
  */
 package retrofit;
 
-import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
@@ -60,22 +59,27 @@ final class MethodInfo {
     FORM_URL_ENCODED
   }
 
-  private final Method method;
-  private final CallAdapter.Factory adapterFactory;
-  private final Converter.Factory converterFactory;
+  final Method method;
+  final CallAdapter.Factory adapterFactory;
+  final Converter.Factory converterFactory;
 
+  // Method-level details
   CallAdapter<?> adapter;
   Converter<?> responseConverter;
+
+  Type requestType;
   BodyEncoding bodyEncoding = BodyEncoding.NONE;
   String requestMethod;
   boolean requestHasBody;
   String requestUrl;
+  Set<String> requestUrlParamNames;
   String requestQuery;
   com.squareup.okhttp.Headers headers;
-  MediaType mediaType;
-  RequestBuilderAction[] requestBuilderActions;
+  String contentTypeHeader;
+  boolean isStreaming;
 
-  private Set<String> requestUrlParamNames;
+  // Parameter-level details
+  Annotation[] requestParamAnnotations;
 
   MethodInfo(Method method, CallAdapter.Factory adapterFactory,
       Converter.Factory converterFactory) {
@@ -134,6 +138,8 @@ final class MethodInfo {
           throw methodError("Only one encoding annotation is allowed.");
         }
         bodyEncoding = BodyEncoding.FORM_URL_ENCODED;
+      } else if (annotationType == Streaming.class) {
+        isStreaming = true;
       }
     }
 
@@ -198,7 +204,7 @@ final class MethodInfo {
       String headerName = header.substring(0, colon);
       String headerValue = header.substring(colon + 1).trim();
       if ("Content-Type".equalsIgnoreCase(headerName)) {
-        mediaType = MediaType.parse(headerValue);
+        contentTypeHeader = headerValue;
       } else {
         builder.add(headerName, headerValue);
       }
@@ -227,7 +233,6 @@ final class MethodInfo {
 
     Type responseType = adapter.responseType();
     if (responseType == ResponseBody.class) {
-      boolean isStreaming = method.isAnnotationPresent(Streaming.class);
       responseConverter = new OkHttpResponseBodyConverter(isStreaming);
     } else {
       if (converterFactory == null) {
@@ -242,93 +247,66 @@ final class MethodInfo {
   }
 
   /**
-   * Loads {@link #requestBuilderActions}. Must be called after {@link #parseMethodAnnotations()}.
+   * Loads {@link #requestParamAnnotations}. Must be called after {@link #parseMethodAnnotations()}.
    */
   private void parseParameters() {
     Type[] methodParameterTypes = method.getGenericParameterTypes();
+
     Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
+    int count = methodParameterAnnotationArrays.length;
+    Annotation[] requestParamAnnotations = new Annotation[count];
 
     boolean gotField = false;
     boolean gotPart = false;
     boolean gotBody = false;
 
-    int count = methodParameterAnnotationArrays.length;
-    RequestBuilderAction[] requestBuilderActions = new RequestBuilderAction[count];
     for (int i = 0; i < count; i++) {
       Type methodParameterType = methodParameterTypes[i];
       Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
       if (methodParameterAnnotations != null) {
         for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
-          if (requestBuilderActions[i] != null) {
-            throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
-          }
+          Class<? extends Annotation> methodAnnotationType =
+              methodParameterAnnotation.annotationType();
 
-          if (methodParameterAnnotation instanceof Path) {
-            Path path = (Path) methodParameterAnnotation;
-            String name = path.value();
+          if (methodAnnotationType == Path.class) {
+            String name = ((Path) methodParameterAnnotation).value();
             validatePathName(i, name);
-            requestBuilderActions[i] = new RequestBuilderAction.Path(name, path.encoded());
-
-          } else if (methodParameterAnnotation instanceof Query) {
-            Query query = (Query) methodParameterAnnotation;
-            requestBuilderActions[i] =
-                new RequestBuilderAction.Query(query.value(), query.encoded());
-
-          } else if (methodParameterAnnotation instanceof QueryMap) {
+          } else if (methodAnnotationType == Query.class) {
+            // Nothing to do.
+          } else if (methodAnnotationType == QueryMap.class) {
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
               throw parameterError(i, "@QueryMap parameter type must be Map.");
             }
-            QueryMap queryMap = (QueryMap) methodParameterAnnotation;
-            requestBuilderActions[i] = new RequestBuilderAction.QueryMap(queryMap.encoded());
-
-          } else if (methodParameterAnnotation instanceof Header) {
-            Header header = (Header) methodParameterAnnotation;
-            requestBuilderActions[i] = new RequestBuilderAction.Header(header.value());
-
-          } else if (methodParameterAnnotation instanceof Field) {
+          } else if (methodAnnotationType == Header.class) {
+            // Nothing to do.
+          } else if (methodAnnotationType == Field.class) {
             if (bodyEncoding != BodyEncoding.FORM_URL_ENCODED) {
               throw parameterError(i, "@Field parameters can only be used with form encoding.");
             }
-            Field field = (Field) methodParameterAnnotation;
-            requestBuilderActions[i] =
-                new RequestBuilderAction.Field(field.value(), field.encoded());
-            gotField = true;
 
-          } else if (methodParameterAnnotation instanceof FieldMap) {
+            gotField = true;
+          } else if (methodAnnotationType == FieldMap.class) {
             if (bodyEncoding != BodyEncoding.FORM_URL_ENCODED) {
               throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
             }
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
               throw parameterError(i, "@FieldMap parameter type must be Map.");
             }
-            FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
-            requestBuilderActions[i] = new RequestBuilderAction.FieldMap(fieldMap.encoded());
-            gotField = true;
 
-          } else if (methodParameterAnnotation instanceof Part) {
+            gotField = true;
+          } else if (methodAnnotationType == Part.class) {
             if (bodyEncoding != BodyEncoding.MULTIPART) {
               throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
             }
-            Part part = (Part) methodParameterAnnotation;
-            com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
-                "Content-Disposition", "name=\"" + part.value() + "\"",
-                "Content-Transfer-Encoding", part.encoding());
-            Converter<?> converter;
-            if (methodParameterType == RequestBody.class) {
-              converter = new OkHttpRequestBodyConverter();
-            } else {
-              if (converterFactory == null) {
-                throw parameterError(i, "@Part parameter is "
-                    + methodParameterType
-                    + " but no converter registered. "
-                    + "Either add a converter to the Retrofit instance or use RequestBody.");
-              }
-              converter = converterFactory.get(methodParameterType);
+            if (converterFactory == null && methodParameterType != BodyEncoding.class) {
+              throw parameterError(i, "@Part parameter is "
+                  + methodParameterType
+                  + " but no converter registered. "
+                  + "Either add a converter to the Retrofit instance or use RequestBody.");
             }
-            requestBuilderActions[i] = new RequestBuilderAction.Part<>(headers, converter);
-            gotPart = true;
 
-          } else if (methodParameterAnnotation instanceof PartMap) {
+            gotPart = true;
+          } else if (methodAnnotationType == PartMap.class) {
             if (bodyEncoding != BodyEncoding.MULTIPART) {
               throw parameterError(i,
                   "@PartMap parameters can only be used with multipart encoding.");
@@ -336,12 +314,9 @@ final class MethodInfo {
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
               throw parameterError(i, "@PartMap parameter type must be Map.");
             }
-            PartMap partMap = (PartMap) methodParameterAnnotation;
-            requestBuilderActions[i] =
-                new RequestBuilderAction.PartMap(converterFactory, partMap.encoding());
-            gotPart = true;
 
-          } else if (methodParameterAnnotation instanceof Body) {
+            gotPart = true;
+          } else if (methodAnnotationType == Body.class) {
             if (bodyEncoding != BodyEncoding.NONE) {
               throw parameterError(i,
                   "@Body parameters cannot be used with form or multi-part encoding.");
@@ -349,33 +324,37 @@ final class MethodInfo {
             if (gotBody) {
               throw methodError("Multiple @Body method annotations found.");
             }
-
-            Converter<?> converter;
-            if (methodParameterType == RequestBody.class) {
-              converter = new OkHttpRequestBodyConverter();
-            } else {
-              if (converterFactory == null) {
-                throw parameterError(i, "@Body parameter is "
-                    + methodParameterType
-                    + " but no converter registered. "
-                    + "Either add a converter to the Retrofit instance or use RequestBody.");
-              }
-              converter = converterFactory.get(methodParameterType);
+            if (converterFactory == null && methodParameterType != RequestBody.class) {
+              throw parameterError(i, "@Body parameter is "
+                  + methodParameterType
+                  + " but no converter registered. "
+                  + "Either add a converter to the Retrofit instance or use RequestBody.");
             }
 
-            requestBuilderActions[i] = new RequestBuilderAction.Body<>(converter);
+            requestType = methodParameterType;
             gotBody = true;
+          } else {
+            // This is a non-Retrofit annotation. Skip to the next one.
+            continue;
+          }
+
+          if (requestParamAnnotations[i] != null) {
+            throw parameterError(i,
+                "Multiple Retrofit annotations found, only one allowed: @%s, @%s.",
+                requestParamAnnotations[i].annotationType().getSimpleName(),
+                methodAnnotationType.getSimpleName());
           }
+          requestParamAnnotations[i] = methodParameterAnnotation;
         }
       }
 
-      if (requestBuilderActions[i] == null) {
+      if (requestParamAnnotations[i] == null) {
         throw parameterError(i, "No Retrofit annotation found.");
       }
     }
 
     if (bodyEncoding == BodyEncoding.NONE && !requestHasBody && gotBody) {
-      throw methodError("Non-body HTTP method cannot contain @Body.");
+      throw methodError("Non-body HTTP method cannot contain @Body or @TypedOutput.");
     }
     if (bodyEncoding == BodyEncoding.FORM_URL_ENCODED && !gotField) {
       throw methodError("Form-encoded method must contain at least one @Field.");
@@ -384,7 +363,7 @@ final class MethodInfo {
       throw methodError("Multipart method must contain at least one @Part.");
     }
 
-    this.requestBuilderActions = requestBuilderActions;
+    this.requestParamAnnotations = requestParamAnnotations;
   }
 
   private void validatePathName(int index, String name) {
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index 0c33f230..ff9d0f82 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -111,15 +111,7 @@ final class OkHttpCall<T> implements Call<T> {
   private com.squareup.okhttp.Call createRawCall() {
     HttpUrl url = endpoint.url();
     RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo);
-
-    Object[] args = this.args;
-    if (args != null) {
-      RequestBuilderAction[] actions = methodInfo.requestBuilderActions;
-      for (int i = 0, count = args.length; i < count; i++) {
-        actions[i].perform(requestBuilder, args[i]);
-      }
-    }
-
+    requestBuilder.setArguments(args);
     Request request = requestBuilder.build();
 
     return client.newCall(request);
diff --git a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
deleted file mode 100644
index ad2434e4..00000000
--- a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.RequestBody;
-import com.squareup.okhttp.ResponseBody;
-import java.io.IOException;
-
-final class OkHttpRequestBodyConverter implements Converter<RequestBody> {
-  @Override public RequestBody fromBody(ResponseBody body) throws IOException {
-    throw new UnsupportedOperationException();
-  }
-
-  @Override public RequestBody toBody(RequestBody value) {
-    return value;
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index 7e7d73ba..f9991422 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -24,35 +24,57 @@ import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Array;
+import java.lang.reflect.Type;
 import java.net.URLEncoder;
+import java.util.Map;
 import okio.BufferedSink;
+import retrofit.http.Body;
+import retrofit.http.Field;
+import retrofit.http.FieldMap;
+import retrofit.http.Header;
+import retrofit.http.Part;
+import retrofit.http.PartMap;
+import retrofit.http.Path;
+import retrofit.http.Query;
+import retrofit.http.QueryMap;
 
 final class RequestBuilder {
+  private static final Headers NO_HEADERS = Headers.of();
+  private static final byte[] NO_BODY = new byte[0];
+
+  private final Converter.Factory converterFactory;
+  private final Annotation[] paramAnnotations;
   private final String requestMethod;
   private final boolean requestHasBody;
+  private final Type requestType;
   private final HttpUrl.Builder urlBuilder;
-  private final Request.Builder requestBuilder;
 
   private MultipartBuilder multipartBuilder;
   private FormEncodingBuilder formEncodingBuilder;
   private RequestBody body;
 
   private String relativeUrl;
-  private MediaType mediaType;
+  private Headers.Builder headers;
+  private String contentTypeHeader;
 
   RequestBuilder(HttpUrl url, MethodInfo methodInfo) {
+    converterFactory = methodInfo.converterFactory;
+
+    paramAnnotations = methodInfo.requestParamAnnotations;
     requestMethod = methodInfo.requestMethod;
     requestHasBody = methodInfo.requestHasBody;
-    mediaType = methodInfo.mediaType;
+    requestType = methodInfo.requestType;
+
+    if (methodInfo.headers != null) {
+      headers = methodInfo.headers.newBuilder();
+    }
+    contentTypeHeader = methodInfo.contentTypeHeader;
+
     relativeUrl = methodInfo.requestUrl;
 
     urlBuilder = url.newBuilder();
-    requestBuilder = new Request.Builder();
-
-    Headers headers = methodInfo.headers;
-    if (headers != null) {
-      requestBuilder.headers(headers);
-    }
 
     String requestQuery = methodInfo.requestQuery;
     if (requestQuery != null) {
@@ -76,15 +98,30 @@ final class RequestBuilder {
     }
   }
 
-  void addHeader(String name, String value) {
+  public void addHeader(String name, String value) {
+    if (name == null) {
+      throw new IllegalArgumentException("Header name must not be null.");
+    }
     if ("Content-Type".equalsIgnoreCase(name)) {
-      mediaType = MediaType.parse(value);
-    } else {
-      requestBuilder.addHeader(name, value);
+      contentTypeHeader = value;
+      return;
+    }
+
+    Headers.Builder headers = this.headers;
+    if (headers == null) {
+      this.headers = headers = new Headers.Builder();
     }
+    headers.add(name, value);
   }
 
-  void addPathParam(String name, String value, boolean encoded) {
+  private void addPathParam(String name, String value, boolean encoded) {
+    if (name == null) {
+      throw new IllegalArgumentException("Path replacement name must not be null.");
+    }
+    if (value == null) {
+      throw new IllegalArgumentException(
+          "Path replacement \"" + name + "\" value must not be null.");
+    }
     try {
       if (!encoded) {
         String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
@@ -102,7 +139,26 @@ final class RequestBuilder {
     }
   }
 
-  void addQueryParam(String name, String value, boolean encoded) {
+  private void addQueryParam(String name, Object value, boolean encoded) {
+    if (value instanceof Iterable) {
+      for (Object iterableValue : (Iterable<?>) value) {
+        if (iterableValue != null) { // Skip null values
+          addQueryParam(name, iterableValue.toString(), encoded);
+        }
+      }
+    } else if (value.getClass().isArray()) {
+      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+        Object arrayValue = Array.get(value, x);
+        if (arrayValue != null) { // Skip null values
+          addQueryParam(name, arrayValue.toString(), encoded);
+        }
+      }
+    } else {
+      addQueryParam(name, value.toString(), encoded);
+    }
+  }
+
+  private void addQueryParam(String name, String value, boolean encoded) {
     if (encoded) {
       urlBuilder.addEncodedQueryParameter(name, value);
     } else {
@@ -110,7 +166,21 @@ final class RequestBuilder {
     }
   }
 
-  void addFormField(String name, String value, boolean encoded) {
+  private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encoded) {
+    for (Map.Entry<?, ?> entry : map.entrySet()) {
+      Object entryKey = entry.getKey();
+      if (entryKey == null) {
+        throw new IllegalArgumentException(
+            "Parameter #" + (parameterNumber + 1) + " query map contained null key.");
+      }
+      Object entryValue = entry.getValue();
+      if (entryValue != null) { // Skip null values.
+        addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
+      }
+    }
+  }
+
+  private void addFormField(String name, String value, boolean encoded) {
     if (encoded) {
       formEncodingBuilder.addEncoded(name, value);
     } else {
@@ -118,12 +188,156 @@ final class RequestBuilder {
     }
   }
 
-  void addPart(Headers headers, RequestBody body) {
-    multipartBuilder.addPart(headers, body);
-  }
+  void setArguments(Object[] args) {
+    if (args == null) {
+      return;
+    }
+    for (int i = 0; i < args.length; i++) {
+      Object value = args[i];
 
-  void setBody(RequestBody body) {
-    this.body = body;
+      Annotation annotation = paramAnnotations[i];
+      Class<? extends Annotation> annotationType = annotation.annotationType();
+      if (annotationType == Path.class) {
+        Path path = (Path) annotation;
+        String name = path.value();
+        if (value == null) {
+          throw new IllegalArgumentException(
+              "Path parameter \"" + name + "\" value must not be null.");
+        }
+        addPathParam(name, value.toString(), path.encoded());
+      } else if (annotationType == Query.class) {
+        if (value != null) { // Skip null values.
+          Query query = (Query) annotation;
+          addQueryParam(query.value(), value, query.encoded());
+        }
+      } else if (annotationType == QueryMap.class) {
+        if (value != null) { // Skip null values.
+          QueryMap queryMap = (QueryMap) annotation;
+          addQueryParamMap(i, (Map<?, ?>) value, queryMap.encoded());
+        }
+      } else if (annotationType == Header.class) {
+        if (value != null) { // Skip null values.
+          String name = ((Header) annotation).value();
+          if (value instanceof Iterable) {
+            for (Object iterableValue : (Iterable<?>) value) {
+              if (iterableValue != null) { // Skip null values.
+                addHeader(name, iterableValue.toString());
+              }
+            }
+          } else if (value.getClass().isArray()) {
+            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+              Object arrayValue = Array.get(value, x);
+              if (arrayValue != null) { // Skip null values.
+                addHeader(name, arrayValue.toString());
+              }
+            }
+          } else {
+            addHeader(name, value.toString());
+          }
+        }
+      } else if (annotationType == Field.class) {
+        if (value != null) { // Skip null values.
+          Field field = (Field) annotation;
+          String name = field.value();
+          boolean encoded = field.encoded();
+          if (value instanceof Iterable) {
+            for (Object iterableValue : (Iterable<?>) value) {
+              if (iterableValue != null) { // Skip null values.
+                addFormField(name, iterableValue.toString(), encoded);
+              }
+            }
+          } else if (value.getClass().isArray()) {
+            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+              Object arrayValue = Array.get(value, x);
+              if (arrayValue != null) { // Skip null values.
+                addFormField(name, arrayValue.toString(), encoded);
+              }
+            }
+          } else {
+            addFormField(name, value.toString(), encoded);
+          }
+        }
+      } else if (annotationType == FieldMap.class) {
+        if (value != null) { // Skip null values.
+          FieldMap fieldMap = (FieldMap) annotation;
+          boolean encoded = fieldMap.encoded();
+          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+            Object entryKey = entry.getKey();
+            if (entryKey == null) {
+              throw new IllegalArgumentException(
+                  "Parameter #" + (i + 1) + " field map contained null key.");
+            }
+            Object entryValue = entry.getValue();
+            if (entryValue != null) { // Skip null values.
+              addFormField(entryKey.toString(), entryValue.toString(), encoded);
+            }
+          }
+        }
+      } else if (annotationType == Part.class) {
+        if (value != null) { // Skip null values.
+          String name = ((Part) annotation).value();
+          String transferEncoding = ((Part) annotation).encoding();
+          Headers headers = Headers.of(
+              "Content-Disposition", "name=\"" + name + "\"",
+              "Content-Transfer-Encoding", transferEncoding);
+          if (value instanceof RequestBody) {
+            multipartBuilder.addPart(headers, (RequestBody) value);
+          } else if (value instanceof String) {
+            multipartBuilder.addPart(headers,
+                RequestBody.create(MediaType.parse("text/plain"), (String) value));
+          } else {
+            //noinspection unchecked
+            Converter<Object> converter =
+                (Converter<Object>) converterFactory.get(value.getClass());
+            multipartBuilder.addPart(headers, converter.toBody(value));
+          }
+        }
+      } else if (annotationType == PartMap.class) {
+        if (value != null) { // Skip null values.
+          String transferEncoding = ((PartMap) annotation).encoding();
+          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+            Object entryKey = entry.getKey();
+            if (entryKey == null) {
+              throw new IllegalArgumentException(
+                  "Parameter #" + (i + 1) + " part map contained null key.");
+            }
+            String entryName = entryKey.toString();
+            Object entryValue = entry.getValue();
+            Headers headers = Headers.of(
+                "Content-Disposition", "name=\"" + entryName + "\"",
+                "Content-Transfer-Encoding", transferEncoding);
+            if (entryValue != null) { // Skip null values.
+              if (entryValue instanceof RequestBody) {
+                multipartBuilder.addPart(headers, (RequestBody) entryValue);
+              } else if (entryValue instanceof String) {
+                multipartBuilder.addPart(headers,
+                    RequestBody.create(MediaType.parse("text/plain"), (String) entryValue));
+              } else {
+                //noinspection unchecked
+                Converter<Object> converter =
+                    (Converter<Object>) converterFactory.get(entryValue.getClass());
+                multipartBuilder.addPart(headers, converter.toBody(entryValue));
+              }
+            }
+          }
+        }
+      } else if (annotationType == Body.class) {
+        if (value == null) {
+          throw new IllegalArgumentException("Body parameter value must not be null.");
+        }
+        if (requestType == RequestBody.class
+            || (requestType == Object.class && value instanceof RequestBody)) {
+          body = (RequestBody) value;
+        } else {
+          //noinspection unchecked
+          Converter<Object> converter = (Converter<Object>) converterFactory.get(requestType);
+          body = converter.toBody(value);
+        }
+      } else {
+        throw new IllegalArgumentException(
+            "Unknown annotation: " + annotationType.getCanonicalName());
+      }
+    }
   }
 
   Request build() {
@@ -138,22 +352,27 @@ final class RequestBuilder {
         body = multipartBuilder.build();
       } else if (requestHasBody) {
         // Body is absent, make an empty body.
-        body = RequestBody.create(null, new byte[0]);
+        body = RequestBody.create(null, NO_BODY);
       }
     }
 
-    MediaType mediaType = this.mediaType;
-    if (mediaType != null) {
+    Headers.Builder headerBuilder = this.headers;
+    if (contentTypeHeader != null) {
       if (body != null) {
-        body = new MediaTypeOverridingRequestBody(body, mediaType);
+        body = new MediaTypeOverridingRequestBody(body, contentTypeHeader);
       } else {
-        requestBuilder.addHeader("Content-Type", mediaType.toString());
+        if (headerBuilder == null) {
+          headerBuilder = new Headers.Builder();
+        }
+        headerBuilder.add("Content-Type", contentTypeHeader);
       }
     }
+    Headers headers = headerBuilder != null ? headerBuilder.build() : NO_HEADERS;
 
-    return requestBuilder
+    return new Request.Builder()
         .url(urlBuilder.build())
         .method(requestMethod, body)
+        .headers(headers)
         .build();
   }
 
@@ -161,9 +380,9 @@ final class RequestBuilder {
     private final RequestBody delegate;
     private final MediaType mediaType;
 
-    MediaTypeOverridingRequestBody(RequestBody delegate, MediaType mediaType) {
+    MediaTypeOverridingRequestBody(RequestBody delegate, String mediaType) {
       this.delegate = delegate;
-      this.mediaType = mediaType;
+      this.mediaType = MediaType.parse(mediaType);
     }
 
     @Override public MediaType contentType() {
diff --git a/retrofit/src/main/java/retrofit/RequestBuilderAction.java b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
deleted file mode 100644
index f837b3a5..00000000
--- a/retrofit/src/main/java/retrofit/RequestBuilderAction.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.Headers;
-import java.lang.reflect.Array;
-import java.util.Map;
-
-import static retrofit.Utils.checkNotNull;
-
-abstract class RequestBuilderAction {
-  abstract void perform(RequestBuilder builder, Object value);
-
-  static final class Header extends RequestBuilderAction {
-    private final String name;
-
-    Header(String name) {
-      this.name = checkNotNull(name, "name == null");
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      if (value instanceof Iterable) {
-        for (Object iterableValue : (Iterable<?>) value) {
-          if (iterableValue != null) { // Skip null values.
-            builder.addHeader(name, iterableValue.toString());
-          }
-        }
-      } else if (value.getClass().isArray()) {
-        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-          Object arrayValue = Array.get(value, x);
-          if (arrayValue != null) { // Skip null values.
-            builder.addHeader(name, arrayValue.toString());
-          }
-        }
-      } else {
-        builder.addHeader(name, value.toString());
-      }
-    }
-  }
-
-  static final class Path extends RequestBuilderAction {
-    private final String name;
-    private final boolean encoded;
-
-    Path(String name, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) {
-        throw new IllegalArgumentException(
-            "Path parameter \"" + name + "\" value must not be null.");
-      }
-      builder.addPathParam(name, value.toString(), encoded);
-    }
-  }
-
-  static final class Query extends RequestBuilderAction {
-    private final String name;
-    private final boolean encoded;
-
-    Query(String name, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      if (value instanceof Iterable) {
-        for (Object iterableValue : (Iterable<?>) value) {
-          if (iterableValue != null) { // Skip null values.
-            builder.addQueryParam(name, iterableValue.toString(), encoded);
-          }
-        }
-      } else if (value.getClass().isArray()) {
-        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-          Object arrayValue = Array.get(value, x);
-          if (arrayValue != null) { // Skip null values.
-            builder.addQueryParam(name, arrayValue.toString(), encoded);
-          }
-        }
-      } else {
-        builder.addQueryParam(name, value.toString(), encoded);
-      }
-    }
-  }
-
-  static final class QueryMap extends RequestBuilderAction {
-    private final boolean encoded;
-
-    QueryMap(boolean encoded) {
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      Map<?, ?> map = (Map<?, ?>) value;
-      for (Map.Entry<?, ?> entry : map.entrySet()) {
-        Object entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Query map contained null key.");
-        }
-        Object entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
-        }
-      }
-    }
-  }
-
-  static final class Field extends RequestBuilderAction {
-    private final String name;
-    private final boolean encoded;
-
-    Field(String name, boolean encoded) {
-      this.name = checkNotNull(name, "name == null");
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      if (value instanceof Iterable) {
-        for (Object iterableValue : (Iterable<?>) value) {
-          if (iterableValue != null) { // Skip null values.
-            builder.addFormField(name, iterableValue.toString(), encoded);
-          }
-        }
-      } else if (value.getClass().isArray()) {
-        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-          Object arrayValue = Array.get(value, x);
-          if (arrayValue != null) { // Skip null values.
-            builder.addFormField(name, arrayValue.toString(), encoded);
-          }
-        }
-      } else {
-        builder.addFormField(name, value.toString(), encoded);
-      }
-    }
-  }
-
-  static final class FieldMap extends RequestBuilderAction {
-    private final boolean encoded;
-
-    FieldMap(boolean encoded) {
-      this.encoded = encoded;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      Map<?, ?> map = (Map<?, ?>) value;
-      for (Map.Entry<?, ?> entry : map.entrySet()) {
-        Object entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Field map contained null key.");
-        }
-        Object entryValue = entry.getValue();
-        if (entryValue != null) { // Skip null values.
-          builder.addFormField(entryKey.toString(), entryValue.toString(), encoded);
-        }
-      }
-    }
-  }
-
-  static final class Part<T> extends RequestBuilderAction {
-    private final Headers headers;
-    private final Converter<T> converter;
-
-    Part(Headers headers, Converter<T> converter) {
-      this.headers = headers;
-      this.converter = converter;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      //noinspection unchecked
-      builder.addPart(headers, converter.toBody((T) value));
-    }
-  }
-
-  static final class PartMap extends RequestBuilderAction {
-    private final Converter.Factory converterFactory;
-    private final String transferEncoding;
-
-    PartMap(Converter.Factory converterFactory, String transferEncoding) {
-      this.converterFactory = converterFactory;
-      this.transferEncoding = transferEncoding;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) return; // Skip null values.
-
-      Map<?, ?> map = (Map<?, ?>) value;
-      for (Map.Entry<?, ?> entry : map.entrySet()) {
-        Object entryKey = entry.getKey();
-        if (entryKey == null) {
-          throw new IllegalArgumentException("Part map contained null key.");
-        }
-        Object entryValue = entry.getValue();
-        if (entryValue == null) {
-          continue; // Skip null values.
-        }
-
-        Headers headers = Headers.of(
-            "Content-Disposition", "name=\"" + entryKey + "\"",
-            "Content-Transfer-Encoding", transferEncoding);
-        //noinspection unchecked
-        Converter<Object> converter =
-            (Converter<Object>) converterFactory.get(entryValue.getClass());
-        builder.addPart(headers, converter.toBody(entryValue));
-      }
-    }
-  }
-
-  static final class Body<T> extends RequestBuilderAction {
-    private final Converter<T> converter;
-
-    Body(Converter<T> converter) {
-      this.converter = converter;
-    }
-
-    @Override void perform(RequestBuilder builder, Object value) {
-      if (value == null) {
-        throw new IllegalArgumentException("Body parameter value must not be null.");
-      }
-      //noinspection unchecked
-      builder.setBody(converter.toBody((T) value));
-    }
-  }
-}
diff --git a/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java
index b29aa05e..0197e982 100644
--- a/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java
@@ -70,7 +70,7 @@ public final class DefaultCallAdapterFactoryTest {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
     CallAdapter adapter = factory.get(returnType);
     final Response<Object> response = Response.fakeSuccess("Hi");
-    Call<Object> call = (Call<Object>) adapter.adapt(new EmptyCall() {
+    Call call = (Call) adapter.adapt(new EmptyCall() {
       @Override public Response<Object> execute() throws IOException {
         return response;
       }
diff --git a/retrofit/src/test/java/retrofit/MethodInfoTest.java b/retrofit/src/test/java/retrofit/MethodInfoTest.java
index 4e58bb93..011d2b60 100644
--- a/retrofit/src/test/java/retrofit/MethodInfoTest.java
+++ b/retrofit/src/test/java/retrofit/MethodInfoTest.java
@@ -1,12 +1,24 @@
 // Copyright 2013 Square, Inc.
 package retrofit;
 
+import com.google.common.reflect.TypeToken;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.List;
 import java.util.Set;
+import java.util.concurrent.Executors;
 import org.junit.Test;
+import retrofit.http.Body;
+import retrofit.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+@SuppressWarnings("unused") // Lots of unused parameters for example code.
 public final class MethodInfoTest {
+  private static CallAdapter.Factory CALL_ADAPTER_FACTORY =
+      new DefaultCallAdapterFactory(Executors.newSingleThreadExecutor());
+  private static Converter.Factory CONVERTER_FACTORY = new ToStringConverterFactory();
+
   @Test public void pathParameterParsing() throws Exception {
     expectParams("/");
     expectParams("/foo");
@@ -33,4 +45,45 @@ public final class MethodInfoTest {
       assertThat(calculated).containsExactly(expected);
     }
   }
+
+  static class Dummy {
+  }
+
+  @Test public void concreteBodyType() {
+    class Example {
+      @POST("/foo") Call<Object> a(@Body Dummy body) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method, CALL_ADAPTER_FACTORY, CONVERTER_FACTORY);
+    assertThat(methodInfo.requestType).isEqualTo(Dummy.class);
+  }
+
+  @Test public void genericBodyType() {
+    class Example {
+      @POST("/foo") Call<Object> a(@Body List<Dummy> body) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method, CALL_ADAPTER_FACTORY, CONVERTER_FACTORY);
+    Type expected = new TypeToken<List<Dummy>>() {}.getType();
+    assertThat(methodInfo.requestType).isEqualTo(expected);
+  }
+
+  @Test public void wildcardBodyType() {
+    class Example {
+      @POST("/foo") Call<Object> a(@Body List<? super String> body) {
+        return null;
+      }
+    }
+
+    Method method = TestingUtils.onlyMethod(Example.class);
+    MethodInfo methodInfo = new MethodInfo(method, CALL_ADAPTER_FACTORY, CONVERTER_FACTORY);
+    Type expected = new TypeToken<List<? super String>>() {}.getType();
+    assertThat(methodInfo.requestType).isEqualTo(expected);
+  }
 }
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index 7497d90a..1619ad40 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -5,6 +5,7 @@ import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.math.BigInteger;
@@ -154,7 +155,8 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Example.method: Multiple Retrofit annotations found, only one allowed. (parameter #1)");
+          "Example.method: Multiple Retrofit annotations found, only one allowed:"
+              + " @Body, @Query. (parameter #1)");
     }
   }
 
@@ -411,7 +413,8 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Example.method: Non-body HTTP method cannot contain @Body.");
+      assertThat(e).hasMessage(
+          "Example.method: Non-body HTTP method cannot contain @Body or @TypedOutput.");
     }
   }
 
@@ -446,7 +449,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class, queryParams);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Query map contained null key.");
+      assertThat(e).hasMessage("Parameter #1 query map contained null key.");
     }
   }
 
@@ -857,7 +860,7 @@ public final class RequestBuilderTest {
   @Test public void normalPostWithPathParam() {
     class Example {
       @POST("/foo/bar/{ping}/") //
-      Call<Object> method(@Path("ping") String ping, @Body RequestBody body) {
+      Call<Object> method(@Path("ping") String ping, @Body Object body) {
         return null;
       }
     }
@@ -931,7 +934,7 @@ public final class RequestBuilderTest {
   @Test public void bodyWithPathParams() {
     class Example {
       @POST("/foo/bar/{ping}/{kit}/") //
-      Call<Object> method(@Path("ping") String ping, @Body RequestBody body, @Path("kit") String kit) {
+      Call<Object> method(@Path("ping") String ping, @Body Object body, @Path("kit") String kit) {
         return null;
       }
     }
@@ -947,7 +950,7 @@ public final class RequestBuilderTest {
     class Example {
       @Multipart //
       @POST("/foo/bar/") //
-      Call<Object> method(@Part("ping") String ping, @Part("kit") RequestBody kit) {
+      Call<Object> method(@Part("ping") String ping, @Part("kit") ResponseBody kit) {
         return null;
       }
     }
@@ -977,7 +980,7 @@ public final class RequestBuilderTest {
       @Multipart //
       @POST("/foo/bar/") //
       Call<Object> method(@Part(value = "ping", encoding = "8-bit") String ping,
-          @Part(value = "kit", encoding = "7-bit") RequestBody kit) {
+          @Part(value = "kit", encoding = "7-bit") ResponseBody kit) {
         return null;
       }
     }
@@ -1013,7 +1016,7 @@ public final class RequestBuilderTest {
 
     Map<String, Object> params = new LinkedHashMap<>();
     params.put("ping", "pong");
-    params.put("kit", "kat");
+    params.put("kit", RequestBody.create(MediaType.parse("text/plain"), "kat"));
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("POST");
@@ -1045,7 +1048,7 @@ public final class RequestBuilderTest {
 
     Map<String, Object> params = new LinkedHashMap<>();
     params.put("ping", "pong");
-    params.put("kit", "kat");
+    params.put("kit", RequestBody.create(MediaType.parse("text/plain"), "kat"));
 
     Request request = buildRequest(Example.class, params);
     assertThat(request.method()).isEqualTo("POST");
@@ -1083,7 +1086,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class, params);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Part map contained null key.");
+      assertThat(e).hasMessage("Parameter #1 part map contained null key.");
     }
   }
 
@@ -1258,7 +1261,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class, fieldMap);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Field map contained null key.");
+      assertThat(e).hasMessage("Parameter #1 field map contained null key.");
     }
   }
 
@@ -1423,15 +1426,7 @@ public final class RequestBuilderTest {
     MethodInfo methodInfo = new MethodInfo(method, callAdapterFactory, converterFactory);
 
     RequestBuilder builder = new RequestBuilder(url, methodInfo);
-
-    RequestBuilderAction[] actions = methodInfo.requestBuilderActions;
-    if (args.length != actions.length) {
-      throw new IllegalStateException("Wrong number of arguments.");
-    }
-    for (int i = 0, count = args.length; i < count; i++) {
-      actions[i].perform(builder, args[i]);
-    }
-
+    builder.setArguments(args);
     return builder.build();
   }
 }
