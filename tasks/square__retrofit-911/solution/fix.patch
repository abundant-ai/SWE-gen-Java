diff --git a/retrofit/src/main/java/retrofit/MethodInfo.java b/retrofit/src/main/java/retrofit/MethodInfo.java
index 2792856a..89b9c7df 100644
--- a/retrofit/src/main/java/retrofit/MethodInfo.java
+++ b/retrofit/src/main/java/retrofit/MethodInfo.java
@@ -15,6 +15,7 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
@@ -59,27 +60,22 @@ final class MethodInfo {
     FORM_URL_ENCODED
   }
 
-  final Method method;
-  final CallAdapter.Factory adapterFactory;
-  final Converter.Factory converterFactory;
+  private final Method method;
+  private final CallAdapter.Factory adapterFactory;
+  private final Converter.Factory converterFactory;
 
-  // Method-level details
   CallAdapter<?> adapter;
   Converter<?> responseConverter;
-
-  Type requestType;
   BodyEncoding bodyEncoding = BodyEncoding.NONE;
   String requestMethod;
   boolean requestHasBody;
   String requestUrl;
-  Set<String> requestUrlParamNames;
   String requestQuery;
   com.squareup.okhttp.Headers headers;
-  String contentTypeHeader;
-  boolean isStreaming;
+  MediaType mediaType;
+  RequestBuilderAction[] requestBuilderActions;
 
-  // Parameter-level details
-  Annotation[] requestParamAnnotations;
+  private Set<String> requestUrlParamNames;
 
   MethodInfo(Method method, CallAdapter.Factory adapterFactory,
       Converter.Factory converterFactory) {
@@ -138,8 +134,6 @@ final class MethodInfo {
           throw methodError("Only one encoding annotation is allowed.");
         }
         bodyEncoding = BodyEncoding.FORM_URL_ENCODED;
-      } else if (annotationType == Streaming.class) {
-        isStreaming = true;
       }
     }
 
@@ -204,7 +198,7 @@ final class MethodInfo {
       String headerName = header.substring(0, colon);
       String headerValue = header.substring(colon + 1).trim();
       if ("Content-Type".equalsIgnoreCase(headerName)) {
-        contentTypeHeader = headerValue;
+        mediaType = MediaType.parse(headerValue);
       } else {
         builder.add(headerName, headerValue);
       }
@@ -233,6 +227,7 @@ final class MethodInfo {
 
     Type responseType = adapter.responseType();
     if (responseType == ResponseBody.class) {
+      boolean isStreaming = method.isAnnotationPresent(Streaming.class);
       responseConverter = new OkHttpResponseBodyConverter(isStreaming);
     } else {
       if (converterFactory == null) {
@@ -247,66 +242,93 @@ final class MethodInfo {
   }
 
   /**
-   * Loads {@link #requestParamAnnotations}. Must be called after {@link #parseMethodAnnotations()}.
+   * Loads {@link #requestBuilderActions}. Must be called after {@link #parseMethodAnnotations()}.
    */
   private void parseParameters() {
     Type[] methodParameterTypes = method.getGenericParameterTypes();
-
     Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
-    int count = methodParameterAnnotationArrays.length;
-    Annotation[] requestParamAnnotations = new Annotation[count];
 
     boolean gotField = false;
     boolean gotPart = false;
     boolean gotBody = false;
 
+    int count = methodParameterAnnotationArrays.length;
+    RequestBuilderAction[] requestBuilderActions = new RequestBuilderAction[count];
     for (int i = 0; i < count; i++) {
       Type methodParameterType = methodParameterTypes[i];
       Annotation[] methodParameterAnnotations = methodParameterAnnotationArrays[i];
       if (methodParameterAnnotations != null) {
         for (Annotation methodParameterAnnotation : methodParameterAnnotations) {
-          Class<? extends Annotation> methodAnnotationType =
-              methodParameterAnnotation.annotationType();
+          if (requestBuilderActions[i] != null) {
+            throw parameterError(i, "Multiple Retrofit annotations found, only one allowed.");
+          }
 
-          if (methodAnnotationType == Path.class) {
-            String name = ((Path) methodParameterAnnotation).value();
+          if (methodParameterAnnotation instanceof Path) {
+            Path path = (Path) methodParameterAnnotation;
+            String name = path.value();
             validatePathName(i, name);
-          } else if (methodAnnotationType == Query.class) {
-            // Nothing to do.
-          } else if (methodAnnotationType == QueryMap.class) {
+            requestBuilderActions[i] = new RequestBuilderAction.Path(name, path.encoded());
+
+          } else if (methodParameterAnnotation instanceof Query) {
+            Query query = (Query) methodParameterAnnotation;
+            requestBuilderActions[i] =
+                new RequestBuilderAction.Query(query.value(), query.encoded());
+
+          } else if (methodParameterAnnotation instanceof QueryMap) {
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
               throw parameterError(i, "@QueryMap parameter type must be Map.");
             }
-          } else if (methodAnnotationType == Header.class) {
-            // Nothing to do.
-          } else if (methodAnnotationType == Field.class) {
+            QueryMap queryMap = (QueryMap) methodParameterAnnotation;
+            requestBuilderActions[i] = new RequestBuilderAction.QueryMap(queryMap.encoded());
+
+          } else if (methodParameterAnnotation instanceof Header) {
+            Header header = (Header) methodParameterAnnotation;
+            requestBuilderActions[i] = new RequestBuilderAction.Header(header.value());
+
+          } else if (methodParameterAnnotation instanceof Field) {
             if (bodyEncoding != BodyEncoding.FORM_URL_ENCODED) {
               throw parameterError(i, "@Field parameters can only be used with form encoding.");
             }
-
+            Field field = (Field) methodParameterAnnotation;
+            requestBuilderActions[i] =
+                new RequestBuilderAction.Field(field.value(), field.encoded());
             gotField = true;
-          } else if (methodAnnotationType == FieldMap.class) {
+
+          } else if (methodParameterAnnotation instanceof FieldMap) {
             if (bodyEncoding != BodyEncoding.FORM_URL_ENCODED) {
               throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
             }
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
               throw parameterError(i, "@FieldMap parameter type must be Map.");
             }
-
+            FieldMap fieldMap = (FieldMap) methodParameterAnnotation;
+            requestBuilderActions[i] = new RequestBuilderAction.FieldMap(fieldMap.encoded());
             gotField = true;
-          } else if (methodAnnotationType == Part.class) {
+
+          } else if (methodParameterAnnotation instanceof Part) {
             if (bodyEncoding != BodyEncoding.MULTIPART) {
               throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
             }
-            if (converterFactory == null && methodParameterType != BodyEncoding.class) {
-              throw parameterError(i, "@Part parameter is "
-                  + methodParameterType
-                  + " but no converter registered. "
-                  + "Either add a converter to the Retrofit instance or use RequestBody.");
+            Part part = (Part) methodParameterAnnotation;
+            com.squareup.okhttp.Headers headers = com.squareup.okhttp.Headers.of(
+                "Content-Disposition", "name=\"" + part.value() + "\"",
+                "Content-Transfer-Encoding", part.encoding());
+            Converter<?> converter;
+            if (methodParameterType == RequestBody.class) {
+              converter = new OkHttpRequestBodyConverter();
+            } else {
+              if (converterFactory == null) {
+                throw parameterError(i, "@Part parameter is "
+                    + methodParameterType
+                    + " but no converter registered. "
+                    + "Either add a converter to the Retrofit instance or use RequestBody.");
+              }
+              converter = converterFactory.get(methodParameterType);
             }
-
+            requestBuilderActions[i] = new RequestBuilderAction.Part<>(headers, converter);
             gotPart = true;
-          } else if (methodAnnotationType == PartMap.class) {
+
+          } else if (methodParameterAnnotation instanceof PartMap) {
             if (bodyEncoding != BodyEncoding.MULTIPART) {
               throw parameterError(i,
                   "@PartMap parameters can only be used with multipart encoding.");
@@ -314,9 +336,12 @@ final class MethodInfo {
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
               throw parameterError(i, "@PartMap parameter type must be Map.");
             }
-
+            PartMap partMap = (PartMap) methodParameterAnnotation;
+            requestBuilderActions[i] =
+                new RequestBuilderAction.PartMap(converterFactory, partMap.encoding());
             gotPart = true;
-          } else if (methodAnnotationType == Body.class) {
+
+          } else if (methodParameterAnnotation instanceof Body) {
             if (bodyEncoding != BodyEncoding.NONE) {
               throw parameterError(i,
                   "@Body parameters cannot be used with form or multi-part encoding.");
@@ -324,37 +349,33 @@ final class MethodInfo {
             if (gotBody) {
               throw methodError("Multiple @Body method annotations found.");
             }
-            if (converterFactory == null && methodParameterType != RequestBody.class) {
-              throw parameterError(i, "@Body parameter is "
-                  + methodParameterType
-                  + " but no converter registered. "
-                  + "Either add a converter to the Retrofit instance or use RequestBody.");
+
+            Converter<?> converter;
+            if (methodParameterType == RequestBody.class) {
+              converter = new OkHttpRequestBodyConverter();
+            } else {
+              if (converterFactory == null) {
+                throw parameterError(i, "@Body parameter is "
+                    + methodParameterType
+                    + " but no converter registered. "
+                    + "Either add a converter to the Retrofit instance or use RequestBody.");
+              }
+              converter = converterFactory.get(methodParameterType);
             }
 
-            requestType = methodParameterType;
+            requestBuilderActions[i] = new RequestBuilderAction.Body<>(converter);
             gotBody = true;
-          } else {
-            // This is a non-Retrofit annotation. Skip to the next one.
-            continue;
-          }
-
-          if (requestParamAnnotations[i] != null) {
-            throw parameterError(i,
-                "Multiple Retrofit annotations found, only one allowed: @%s, @%s.",
-                requestParamAnnotations[i].annotationType().getSimpleName(),
-                methodAnnotationType.getSimpleName());
           }
-          requestParamAnnotations[i] = methodParameterAnnotation;
         }
       }
 
-      if (requestParamAnnotations[i] == null) {
+      if (requestBuilderActions[i] == null) {
         throw parameterError(i, "No Retrofit annotation found.");
       }
     }
 
     if (bodyEncoding == BodyEncoding.NONE && !requestHasBody && gotBody) {
-      throw methodError("Non-body HTTP method cannot contain @Body or @TypedOutput.");
+      throw methodError("Non-body HTTP method cannot contain @Body.");
     }
     if (bodyEncoding == BodyEncoding.FORM_URL_ENCODED && !gotField) {
       throw methodError("Form-encoded method must contain at least one @Field.");
@@ -363,7 +384,7 @@ final class MethodInfo {
       throw methodError("Multipart method must contain at least one @Part.");
     }
 
-    this.requestParamAnnotations = requestParamAnnotations;
+    this.requestBuilderActions = requestBuilderActions;
   }
 
   private void validatePathName(int index, String name) {
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index ff9d0f82..0c33f230 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -111,7 +111,15 @@ final class OkHttpCall<T> implements Call<T> {
   private com.squareup.okhttp.Call createRawCall() {
     HttpUrl url = endpoint.url();
     RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo);
-    requestBuilder.setArguments(args);
+
+    Object[] args = this.args;
+    if (args != null) {
+      RequestBuilderAction[] actions = methodInfo.requestBuilderActions;
+      for (int i = 0, count = args.length; i < count; i++) {
+        actions[i].perform(requestBuilder, args[i]);
+      }
+    }
+
     Request request = requestBuilder.build();
 
     return client.newCall(request);
diff --git a/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
new file mode 100644
index 00000000..ad2434e4
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/OkHttpRequestBodyConverter.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+
+final class OkHttpRequestBodyConverter implements Converter<RequestBody> {
+  @Override public RequestBody fromBody(ResponseBody body) throws IOException {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override public RequestBody toBody(RequestBody value) {
+    return value;
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index f9991422..7e7d73ba 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -24,57 +24,35 @@ import com.squareup.okhttp.Request;
 import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Array;
-import java.lang.reflect.Type;
 import java.net.URLEncoder;
-import java.util.Map;
 import okio.BufferedSink;
-import retrofit.http.Body;
-import retrofit.http.Field;
-import retrofit.http.FieldMap;
-import retrofit.http.Header;
-import retrofit.http.Part;
-import retrofit.http.PartMap;
-import retrofit.http.Path;
-import retrofit.http.Query;
-import retrofit.http.QueryMap;
 
 final class RequestBuilder {
-  private static final Headers NO_HEADERS = Headers.of();
-  private static final byte[] NO_BODY = new byte[0];
-
-  private final Converter.Factory converterFactory;
-  private final Annotation[] paramAnnotations;
   private final String requestMethod;
   private final boolean requestHasBody;
-  private final Type requestType;
   private final HttpUrl.Builder urlBuilder;
+  private final Request.Builder requestBuilder;
 
   private MultipartBuilder multipartBuilder;
   private FormEncodingBuilder formEncodingBuilder;
   private RequestBody body;
 
   private String relativeUrl;
-  private Headers.Builder headers;
-  private String contentTypeHeader;
+  private MediaType mediaType;
 
   RequestBuilder(HttpUrl url, MethodInfo methodInfo) {
-    converterFactory = methodInfo.converterFactory;
-
-    paramAnnotations = methodInfo.requestParamAnnotations;
     requestMethod = methodInfo.requestMethod;
     requestHasBody = methodInfo.requestHasBody;
-    requestType = methodInfo.requestType;
-
-    if (methodInfo.headers != null) {
-      headers = methodInfo.headers.newBuilder();
-    }
-    contentTypeHeader = methodInfo.contentTypeHeader;
-
+    mediaType = methodInfo.mediaType;
     relativeUrl = methodInfo.requestUrl;
 
     urlBuilder = url.newBuilder();
+    requestBuilder = new Request.Builder();
+
+    Headers headers = methodInfo.headers;
+    if (headers != null) {
+      requestBuilder.headers(headers);
+    }
 
     String requestQuery = methodInfo.requestQuery;
     if (requestQuery != null) {
@@ -98,30 +76,15 @@ final class RequestBuilder {
     }
   }
 
-  public void addHeader(String name, String value) {
-    if (name == null) {
-      throw new IllegalArgumentException("Header name must not be null.");
-    }
+  void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
-      contentTypeHeader = value;
-      return;
-    }
-
-    Headers.Builder headers = this.headers;
-    if (headers == null) {
-      this.headers = headers = new Headers.Builder();
+      mediaType = MediaType.parse(value);
+    } else {
+      requestBuilder.addHeader(name, value);
     }
-    headers.add(name, value);
   }
 
-  private void addPathParam(String name, String value, boolean encoded) {
-    if (name == null) {
-      throw new IllegalArgumentException("Path replacement name must not be null.");
-    }
-    if (value == null) {
-      throw new IllegalArgumentException(
-          "Path replacement \"" + name + "\" value must not be null.");
-    }
+  void addPathParam(String name, String value, boolean encoded) {
     try {
       if (!encoded) {
         String encodedValue = URLEncoder.encode(String.valueOf(value), "UTF-8");
@@ -139,26 +102,7 @@ final class RequestBuilder {
     }
   }
 
-  private void addQueryParam(String name, Object value, boolean encoded) {
-    if (value instanceof Iterable) {
-      for (Object iterableValue : (Iterable<?>) value) {
-        if (iterableValue != null) { // Skip null values
-          addQueryParam(name, iterableValue.toString(), encoded);
-        }
-      }
-    } else if (value.getClass().isArray()) {
-      for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-        Object arrayValue = Array.get(value, x);
-        if (arrayValue != null) { // Skip null values
-          addQueryParam(name, arrayValue.toString(), encoded);
-        }
-      }
-    } else {
-      addQueryParam(name, value.toString(), encoded);
-    }
-  }
-
-  private void addQueryParam(String name, String value, boolean encoded) {
+  void addQueryParam(String name, String value, boolean encoded) {
     if (encoded) {
       urlBuilder.addEncodedQueryParameter(name, value);
     } else {
@@ -166,21 +110,7 @@ final class RequestBuilder {
     }
   }
 
-  private void addQueryParamMap(int parameterNumber, Map<?, ?> map, boolean encoded) {
-    for (Map.Entry<?, ?> entry : map.entrySet()) {
-      Object entryKey = entry.getKey();
-      if (entryKey == null) {
-        throw new IllegalArgumentException(
-            "Parameter #" + (parameterNumber + 1) + " query map contained null key.");
-      }
-      Object entryValue = entry.getValue();
-      if (entryValue != null) { // Skip null values.
-        addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
-      }
-    }
-  }
-
-  private void addFormField(String name, String value, boolean encoded) {
+  void addFormField(String name, String value, boolean encoded) {
     if (encoded) {
       formEncodingBuilder.addEncoded(name, value);
     } else {
@@ -188,156 +118,12 @@ final class RequestBuilder {
     }
   }
 
-  void setArguments(Object[] args) {
-    if (args == null) {
-      return;
-    }
-    for (int i = 0; i < args.length; i++) {
-      Object value = args[i];
+  void addPart(Headers headers, RequestBody body) {
+    multipartBuilder.addPart(headers, body);
+  }
 
-      Annotation annotation = paramAnnotations[i];
-      Class<? extends Annotation> annotationType = annotation.annotationType();
-      if (annotationType == Path.class) {
-        Path path = (Path) annotation;
-        String name = path.value();
-        if (value == null) {
-          throw new IllegalArgumentException(
-              "Path parameter \"" + name + "\" value must not be null.");
-        }
-        addPathParam(name, value.toString(), path.encoded());
-      } else if (annotationType == Query.class) {
-        if (value != null) { // Skip null values.
-          Query query = (Query) annotation;
-          addQueryParam(query.value(), value, query.encoded());
-        }
-      } else if (annotationType == QueryMap.class) {
-        if (value != null) { // Skip null values.
-          QueryMap queryMap = (QueryMap) annotation;
-          addQueryParamMap(i, (Map<?, ?>) value, queryMap.encoded());
-        }
-      } else if (annotationType == Header.class) {
-        if (value != null) { // Skip null values.
-          String name = ((Header) annotation).value();
-          if (value instanceof Iterable) {
-            for (Object iterableValue : (Iterable<?>) value) {
-              if (iterableValue != null) { // Skip null values.
-                addHeader(name, iterableValue.toString());
-              }
-            }
-          } else if (value.getClass().isArray()) {
-            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-              Object arrayValue = Array.get(value, x);
-              if (arrayValue != null) { // Skip null values.
-                addHeader(name, arrayValue.toString());
-              }
-            }
-          } else {
-            addHeader(name, value.toString());
-          }
-        }
-      } else if (annotationType == Field.class) {
-        if (value != null) { // Skip null values.
-          Field field = (Field) annotation;
-          String name = field.value();
-          boolean encoded = field.encoded();
-          if (value instanceof Iterable) {
-            for (Object iterableValue : (Iterable<?>) value) {
-              if (iterableValue != null) { // Skip null values.
-                addFormField(name, iterableValue.toString(), encoded);
-              }
-            }
-          } else if (value.getClass().isArray()) {
-            for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
-              Object arrayValue = Array.get(value, x);
-              if (arrayValue != null) { // Skip null values.
-                addFormField(name, arrayValue.toString(), encoded);
-              }
-            }
-          } else {
-            addFormField(name, value.toString(), encoded);
-          }
-        }
-      } else if (annotationType == FieldMap.class) {
-        if (value != null) { // Skip null values.
-          FieldMap fieldMap = (FieldMap) annotation;
-          boolean encoded = fieldMap.encoded();
-          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-            Object entryKey = entry.getKey();
-            if (entryKey == null) {
-              throw new IllegalArgumentException(
-                  "Parameter #" + (i + 1) + " field map contained null key.");
-            }
-            Object entryValue = entry.getValue();
-            if (entryValue != null) { // Skip null values.
-              addFormField(entryKey.toString(), entryValue.toString(), encoded);
-            }
-          }
-        }
-      } else if (annotationType == Part.class) {
-        if (value != null) { // Skip null values.
-          String name = ((Part) annotation).value();
-          String transferEncoding = ((Part) annotation).encoding();
-          Headers headers = Headers.of(
-              "Content-Disposition", "name=\"" + name + "\"",
-              "Content-Transfer-Encoding", transferEncoding);
-          if (value instanceof RequestBody) {
-            multipartBuilder.addPart(headers, (RequestBody) value);
-          } else if (value instanceof String) {
-            multipartBuilder.addPart(headers,
-                RequestBody.create(MediaType.parse("text/plain"), (String) value));
-          } else {
-            //noinspection unchecked
-            Converter<Object> converter =
-                (Converter<Object>) converterFactory.get(value.getClass());
-            multipartBuilder.addPart(headers, converter.toBody(value));
-          }
-        }
-      } else if (annotationType == PartMap.class) {
-        if (value != null) { // Skip null values.
-          String transferEncoding = ((PartMap) annotation).encoding();
-          for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
-            Object entryKey = entry.getKey();
-            if (entryKey == null) {
-              throw new IllegalArgumentException(
-                  "Parameter #" + (i + 1) + " part map contained null key.");
-            }
-            String entryName = entryKey.toString();
-            Object entryValue = entry.getValue();
-            Headers headers = Headers.of(
-                "Content-Disposition", "name=\"" + entryName + "\"",
-                "Content-Transfer-Encoding", transferEncoding);
-            if (entryValue != null) { // Skip null values.
-              if (entryValue instanceof RequestBody) {
-                multipartBuilder.addPart(headers, (RequestBody) entryValue);
-              } else if (entryValue instanceof String) {
-                multipartBuilder.addPart(headers,
-                    RequestBody.create(MediaType.parse("text/plain"), (String) entryValue));
-              } else {
-                //noinspection unchecked
-                Converter<Object> converter =
-                    (Converter<Object>) converterFactory.get(entryValue.getClass());
-                multipartBuilder.addPart(headers, converter.toBody(entryValue));
-              }
-            }
-          }
-        }
-      } else if (annotationType == Body.class) {
-        if (value == null) {
-          throw new IllegalArgumentException("Body parameter value must not be null.");
-        }
-        if (requestType == RequestBody.class
-            || (requestType == Object.class && value instanceof RequestBody)) {
-          body = (RequestBody) value;
-        } else {
-          //noinspection unchecked
-          Converter<Object> converter = (Converter<Object>) converterFactory.get(requestType);
-          body = converter.toBody(value);
-        }
-      } else {
-        throw new IllegalArgumentException(
-            "Unknown annotation: " + annotationType.getCanonicalName());
-      }
-    }
+  void setBody(RequestBody body) {
+    this.body = body;
   }
 
   Request build() {
@@ -352,27 +138,22 @@ final class RequestBuilder {
         body = multipartBuilder.build();
       } else if (requestHasBody) {
         // Body is absent, make an empty body.
-        body = RequestBody.create(null, NO_BODY);
+        body = RequestBody.create(null, new byte[0]);
       }
     }
 
-    Headers.Builder headerBuilder = this.headers;
-    if (contentTypeHeader != null) {
+    MediaType mediaType = this.mediaType;
+    if (mediaType != null) {
       if (body != null) {
-        body = new MediaTypeOverridingRequestBody(body, contentTypeHeader);
+        body = new MediaTypeOverridingRequestBody(body, mediaType);
       } else {
-        if (headerBuilder == null) {
-          headerBuilder = new Headers.Builder();
-        }
-        headerBuilder.add("Content-Type", contentTypeHeader);
+        requestBuilder.addHeader("Content-Type", mediaType.toString());
       }
     }
-    Headers headers = headerBuilder != null ? headerBuilder.build() : NO_HEADERS;
 
-    return new Request.Builder()
+    return requestBuilder
         .url(urlBuilder.build())
         .method(requestMethod, body)
-        .headers(headers)
         .build();
   }
 
@@ -380,9 +161,9 @@ final class RequestBuilder {
     private final RequestBody delegate;
     private final MediaType mediaType;
 
-    MediaTypeOverridingRequestBody(RequestBody delegate, String mediaType) {
+    MediaTypeOverridingRequestBody(RequestBody delegate, MediaType mediaType) {
       this.delegate = delegate;
-      this.mediaType = MediaType.parse(mediaType);
+      this.mediaType = mediaType;
     }
 
     @Override public MediaType contentType() {
diff --git a/retrofit/src/main/java/retrofit/RequestBuilderAction.java b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
new file mode 100644
index 00000000..f837b3a5
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/RequestBuilderAction.java
@@ -0,0 +1,250 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.Headers;
+import java.lang.reflect.Array;
+import java.util.Map;
+
+import static retrofit.Utils.checkNotNull;
+
+abstract class RequestBuilderAction {
+  abstract void perform(RequestBuilder builder, Object value);
+
+  static final class Header extends RequestBuilderAction {
+    private final String name;
+
+    Header(String name) {
+      this.name = checkNotNull(name, "name == null");
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      if (value instanceof Iterable) {
+        for (Object iterableValue : (Iterable<?>) value) {
+          if (iterableValue != null) { // Skip null values.
+            builder.addHeader(name, iterableValue.toString());
+          }
+        }
+      } else if (value.getClass().isArray()) {
+        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+          Object arrayValue = Array.get(value, x);
+          if (arrayValue != null) { // Skip null values.
+            builder.addHeader(name, arrayValue.toString());
+          }
+        }
+      } else {
+        builder.addHeader(name, value.toString());
+      }
+    }
+  }
+
+  static final class Path extends RequestBuilderAction {
+    private final String name;
+    private final boolean encoded;
+
+    Path(String name, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) {
+        throw new IllegalArgumentException(
+            "Path parameter \"" + name + "\" value must not be null.");
+      }
+      builder.addPathParam(name, value.toString(), encoded);
+    }
+  }
+
+  static final class Query extends RequestBuilderAction {
+    private final String name;
+    private final boolean encoded;
+
+    Query(String name, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      if (value instanceof Iterable) {
+        for (Object iterableValue : (Iterable<?>) value) {
+          if (iterableValue != null) { // Skip null values.
+            builder.addQueryParam(name, iterableValue.toString(), encoded);
+          }
+        }
+      } else if (value.getClass().isArray()) {
+        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+          Object arrayValue = Array.get(value, x);
+          if (arrayValue != null) { // Skip null values.
+            builder.addQueryParam(name, arrayValue.toString(), encoded);
+          }
+        }
+      } else {
+        builder.addQueryParam(name, value.toString(), encoded);
+      }
+    }
+  }
+
+  static final class QueryMap extends RequestBuilderAction {
+    private final boolean encoded;
+
+    QueryMap(boolean encoded) {
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      Map<?, ?> map = (Map<?, ?>) value;
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        Object entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Query map contained null key.");
+        }
+        Object entryValue = entry.getValue();
+        if (entryValue != null) { // Skip null values.
+          builder.addQueryParam(entryKey.toString(), entryValue.toString(), encoded);
+        }
+      }
+    }
+  }
+
+  static final class Field extends RequestBuilderAction {
+    private final String name;
+    private final boolean encoded;
+
+    Field(String name, boolean encoded) {
+      this.name = checkNotNull(name, "name == null");
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      if (value instanceof Iterable) {
+        for (Object iterableValue : (Iterable<?>) value) {
+          if (iterableValue != null) { // Skip null values.
+            builder.addFormField(name, iterableValue.toString(), encoded);
+          }
+        }
+      } else if (value.getClass().isArray()) {
+        for (int x = 0, arrayLength = Array.getLength(value); x < arrayLength; x++) {
+          Object arrayValue = Array.get(value, x);
+          if (arrayValue != null) { // Skip null values.
+            builder.addFormField(name, arrayValue.toString(), encoded);
+          }
+        }
+      } else {
+        builder.addFormField(name, value.toString(), encoded);
+      }
+    }
+  }
+
+  static final class FieldMap extends RequestBuilderAction {
+    private final boolean encoded;
+
+    FieldMap(boolean encoded) {
+      this.encoded = encoded;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      Map<?, ?> map = (Map<?, ?>) value;
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        Object entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Field map contained null key.");
+        }
+        Object entryValue = entry.getValue();
+        if (entryValue != null) { // Skip null values.
+          builder.addFormField(entryKey.toString(), entryValue.toString(), encoded);
+        }
+      }
+    }
+  }
+
+  static final class Part<T> extends RequestBuilderAction {
+    private final Headers headers;
+    private final Converter<T> converter;
+
+    Part(Headers headers, Converter<T> converter) {
+      this.headers = headers;
+      this.converter = converter;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      //noinspection unchecked
+      builder.addPart(headers, converter.toBody((T) value));
+    }
+  }
+
+  static final class PartMap extends RequestBuilderAction {
+    private final Converter.Factory converterFactory;
+    private final String transferEncoding;
+
+    PartMap(Converter.Factory converterFactory, String transferEncoding) {
+      this.converterFactory = converterFactory;
+      this.transferEncoding = transferEncoding;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) return; // Skip null values.
+
+      Map<?, ?> map = (Map<?, ?>) value;
+      for (Map.Entry<?, ?> entry : map.entrySet()) {
+        Object entryKey = entry.getKey();
+        if (entryKey == null) {
+          throw new IllegalArgumentException("Part map contained null key.");
+        }
+        Object entryValue = entry.getValue();
+        if (entryValue == null) {
+          continue; // Skip null values.
+        }
+
+        Headers headers = Headers.of(
+            "Content-Disposition", "name=\"" + entryKey + "\"",
+            "Content-Transfer-Encoding", transferEncoding);
+        //noinspection unchecked
+        Converter<Object> converter =
+            (Converter<Object>) converterFactory.get(entryValue.getClass());
+        builder.addPart(headers, converter.toBody(entryValue));
+      }
+    }
+  }
+
+  static final class Body<T> extends RequestBuilderAction {
+    private final Converter<T> converter;
+
+    Body(Converter<T> converter) {
+      this.converter = converter;
+    }
+
+    @Override void perform(RequestBuilder builder, Object value) {
+      if (value == null) {
+        throw new IllegalArgumentException("Body parameter value must not be null.");
+      }
+      //noinspection unchecked
+      builder.setBody(converter.toBody((T) value));
+    }
+  }
+}
