diff --git a/core-processor/src/main/java/io/micronaut/inject/configuration/JsonSchemaConfigurationMetadataWriter.java b/core-processor/src/main/java/io/micronaut/inject/configuration/JsonSchemaConfigurationMetadataWriter.java
deleted file mode 100644
index 5adf2e7bef..0000000000
--- a/core-processor/src/main/java/io/micronaut/inject/configuration/JsonSchemaConfigurationMetadataWriter.java
+++ /dev/null
@@ -1,874 +0,0 @@
-/*
- * Copyright 2017-2020 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.inject.configuration;
-
-import io.micronaut.core.annotation.AnnotationMetadata;
-import io.micronaut.core.annotation.AnnotationValue;
-import io.micronaut.core.bind.annotation.Bindable;
-import io.micronaut.core.naming.NameUtils;
-import io.micronaut.core.util.StringUtils;
-import io.micronaut.inject.ast.ClassElement;
-import io.micronaut.inject.ast.FieldElement;
-import io.micronaut.inject.ast.PropertyElement;
-import io.micronaut.inject.ast.ElementQuery;
-import io.micronaut.inject.visitor.VisitorContext;
-import io.micronaut.inject.writer.ClassWriterOutputVisitor;
-import io.micronaut.inject.writer.GeneratedFile;
-import org.jspecify.annotations.Nullable;
-
-import java.io.IOException;
-import java.io.Writer;
-import java.lang.annotation.Annotation;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.OptionalInt;
-import java.util.OptionalLong;
-import java.util.Set;
-import java.util.function.BiFunction;
-
-/**
- * A {@link ConfigurationMetadataWriter} that writes per-class JSON Schema (Draft 2020-12)
- * for each {@code @ConfigurationProperties} / {@code @EachProperty} annotated type.
- */
-public final class JsonSchemaConfigurationMetadataWriter implements ConfigurationMetadataWriter {
-
-    private static final String SCHEMAS_DIR = "micronaut-configuration-schemas";
-    private static final String ATTR_MIN = "minimum";
-    private static final String ATTR_MAX = "maximum";
-    private static final String ATTR_CONST = "const";
-    private static final String ATTR_FORMAT = "format";
-    private static final String ATTR_PATTERN = "pattern";
-    private static final String ATTR_TYPE = "type";
-    private static final String ATTR_ENUM = "enum";
-    private static final String ATTR_PROPERTIES = "properties";
-    private static final String JV_NOT_NULL = "jakarta.validation.constraints.NotNull";
-    private static final String JV_NOT_BLANK = "jakarta.validation.constraints.NotBlank";
-    private static final String JV_ASSERT_TRUE = "jakarta.validation.constraints.AssertTrue";
-    private static final String JV_ASSERT_FALSE = "jakarta.validation.constraints.AssertFalse";
-    private static final String JV_EMAIL = "jakarta.validation.constraints.Email";
-    private static final String JV_PATTERN = "jakarta.validation.constraints.Pattern";
-    private static final String JV_SIZE = "jakarta.validation.constraints.Size";
-    private static final String JV_NOT_EMPTY = "jakarta.validation.constraints.NotEmpty";
-    private static final String ATTR_MIN_PROPERTIES = "minProperties";
-    private static final String ATTR_MAX_PROPERTIES = "maxProperties";
-    private static final String JV_MIN = "jakarta.validation.constraints.Min";
-    private static final String JV_MAX = "jakarta.validation.constraints.Max";
-    private static final String JV_DIGITS = "jakarta.validation.constraints.Digits";
-    private static final String JV_NEGATIVE = "jakarta.validation.constraints.Negative";
-    private static final String JV_NEGATIVE_OR_ZERO = "jakarta.validation.constraints.NegativeOrZero";
-    private static final String ATTR_EXCLUSIVE_MINIMUM = "exclusiveMinimum";
-    private static final String ATTR_EXCLUSIVE_MAXIMUM = "exclusiveMaximum";
-    private static final String JV_POSITIVE = "jakarta.validation.constraints.Positive";
-    private static final String JV_POSITIVE_OR_ZERO = "jakarta.validation.constraints.PositiveOrZero";
-    private static final String OBJECT = "object";
-    private static final String DEFAULT = "default";
-    private static final String ARRAY = "array";
-    private static final String ATTR_MIN_ITEMS = "minItems";
-    private static final String URL_JSON_SCHEMA = "https://json-schema.org/draft/2020-12/schema";
-    private static final String STRING = "string";
-    private static final String DURATION = "duration";
-    private static final String ATTR_ADDITIONAL_PROPERTIES = "additionalProperties";
-    private static final String BOOLEAN = "boolean";
-
-    @Override
-    public void write(ConfigurationMetadataBuilder metadataBuilder, ClassWriterOutputVisitor outputVisitor) throws IOException {
-        final List<ConfigurationMetadata> configs = metadataBuilder.getConfigurations();
-        if (configs.isEmpty()) {
-            return;
-        }
-        // We need VisitorContext for richer type info where available.
-        final VisitorContext vc;
-        if (outputVisitor instanceof VisitorContext) {
-            vc = (VisitorContext) outputVisitor;
-        } else {
-            vc = null;
-        }
-
-        // Build quick index of properties by path for efficient filtering
-        final List<PropertyMetadata> props = metadataBuilder.getProperties();
-
-        Set<String> seen = new HashSet<>();
-        for (ConfigurationMetadata cm : configs) {
-            final String fqcn = cm.getType();
-            if (!seen.add(fqcn)) {
-                continue;
-            }
-            final String fileName = SCHEMAS_DIR + "/" + fqcn + ".json";
-            Optional<GeneratedFile> fileOpt = outputVisitor.visitMetaInfFile(fileName, metadataBuilder.getOriginatingElements());
-            if (fileOpt.isEmpty()) {
-                continue;
-            }
-
-            try (Writer out = fileOpt.get().openWriter()) {
-                writeSchemaFor(cm, props, vc, out);
-            }
-        }
-    }
-
-    private void writeSchemaFor(ConfigurationMetadata cm,
-                                List<PropertyMetadata> allProps,
-                                @Nullable VisitorContext vc,
-                                Writer out) throws IOException {
-        // Determine prefix and whether this is EachProperty
-        String fullPrefix = cm.getName(); // may contain .* or [*]
-        boolean isEachMap = fullPrefix.endsWith(".*");
-        boolean isEachList = fullPrefix.endsWith("[*]");
-        String basePrefix = fullPrefix;
-        if (isEachMap) {
-            basePrefix = fullPrefix.substring(0, fullPrefix.length() - 2);
-        }
-        if (isEachList) {
-            basePrefix = fullPrefix.substring(0, fullPrefix.length() - 3);
-        }
-
-        // JSON begin
-        out.write('{');
-        attr(out, "$schema");
-        str(out, URL_JSON_SCHEMA);
-        comma(out);
-        attr(out, "$id");
-        str(out, "urn:micronaut:config:" + cm.getType());
-        comma(out);
-        attr(out, "title");
-        str(out, cm.getType());
-        comma(out);
-        if (cm.getDescription() != null) {
-            attr(out, "description");
-            str(out, cm.getDescription());
-            comma(out);
-        }
-        // Vendor extension at root
-        attr(out, "x-micronaut");
-        out.write('{');
-        attr(out, "prefix");
-        str(out, basePrefix);
-        comma(out);
-        attr(out, ATTR_TYPE);
-        str(out, cm.getType());
-        comma(out);
-        boolean isEach = isEachMap || isEachList;
-        attr(out, "kind");
-        str(out, isEach ? "each-property" : "configuration-properties");
-        if (isEach) {
-            comma(out);
-            attr(out, "container");
-            str(out, isEachMap ? "map" : "list");
-        }
-        out.write('}');
-        comma(out);
-
-        // Root schema shape
-        if (isEachMap) {
-            // type: object; minProperties:1; additionalProperties: $ref $defs.Entry
-            attr(out, ATTR_TYPE);
-            str(out, OBJECT);
-            comma(out);
-            attr(out, ATTR_MIN_PROPERTIES);
-            out.write("1");
-            comma(out);
-            emitAdditionalPropertiesRef(out);
-            // defs entry schema
-            emitEntryDefs(cm, basePrefix, allProps, vc, out, true, vc != null ? vc.getClassElement(cm.getType()).orElse(null) : null);
-        } else if (isEachList) {
-            // type: array; minItems:1; items: $ref $defs.Entry
-            attr(out, ATTR_TYPE);
-            str(out, ARRAY);
-            comma(out);
-            attr(out, ATTR_MIN_ITEMS);
-            out.write("1");
-            comma(out);
-            attr(out, "items");
-            refEntry(out);
-            emitEntryDefs(cm, basePrefix, allProps, vc, out, false, vc != null ? vc.getClassElement(cm.getType()).orElse(null) : null);
-        } else {
-            // Plain configuration object
-            attr(out, ATTR_TYPE);
-            str(out, OBJECT);
-            comma(out);
-            // properties: object
-            attr(out, ATTR_PROPERTIES);
-            ClassElement classElement = vc != null ? vc.getClassElement(cm.getType()).orElse(null) : null;
-            Set<String> required = writePropertiesObject(out, cm, basePrefix, allProps, vc, /*containerMode*/ null, classElement);
-            emitRequired(out, required);
-            // keep additionalProperties default (omitted) or explicitly true
-        }
-        out.write('}');
-    }
-
-    private void emitRequired(Writer out, Set<String> required) throws IOException {
-        if (!required.isEmpty()) {
-            comma(out);
-            attr(out, "required");
-            out.write('[');
-            Iterator<String> r = required.iterator();
-            while (r.hasNext()) {
-                str(out, r.next());
-                if (r.hasNext()) {
-                    out.write(',');
-                }
-            }
-            out.write(']');
-        }
-    }
-
-    private void emitEntryDefs(ConfigurationMetadata cm,
-                               String basePrefix,
-                               List<PropertyMetadata> allProps,
-                               @Nullable VisitorContext vc,
-                               Writer out,
-                               boolean mapMode,
-                               @Nullable ClassElement classElement) throws IOException {
-        comma(out);
-        attr(out, "$defs");
-        out.write('{');
-        attr(out, "Entry");
-        out.write('{');
-        attr(out, ATTR_TYPE);
-        str(out, OBJECT);
-        comma(out);
-        attr(out, ATTR_PROPERTIES);
-        Set<String> required = writePropertiesObject(out, cm, basePrefix, allProps, vc, mapMode ? ContainerMode.MAP : ContainerMode.LIST, classElement);
-        emitRequired(out, required);
-        out.write('}');
-        out.write('}');
-    }
-
-    private enum ContainerMode {
-        MAP,
-        LIST
-    }
-
-    private Set<String> writePropertiesObject(Writer out,
-                                              ConfigurationMetadata cm,
-                                              String basePrefix,
-                                              List<PropertyMetadata> allProps,
-                                              @Nullable VisitorContext vc,
-                                              @Nullable ContainerMode containerMode,
-                                              @Nullable ClassElement classElement) throws IOException {
-        // Build nested property tree from matching properties
-        Map<String, Object> tree = new LinkedHashMap<>();
-        Set<String> required = new java.util.LinkedHashSet<>();
-        for (PropertyMetadata pm : allProps) {
-            String path = pm.getPath();
-            String matchPrefix = basePrefix + ".";
-            if (containerMode == ContainerMode.MAP) {
-                matchPrefix = basePrefix + ".*.";
-            }
-            if (containerMode == ContainerMode.LIST) {
-                matchPrefix = basePrefix + "[*].";
-            }
-            if (!path.startsWith(matchPrefix)) {
-                continue;
-            }
-            String rel = path.substring(matchPrefix.length());
-            if (rel.isEmpty()) {
-                continue;
-            }
-            // Split into segments
-            List<String> segs = splitOnDot(rel);
-            Map<String, Object> cursor = tree;
-            for (int i = 0; i < segs.size(); i++) {
-                String seg = segs.get(i);
-                boolean last = (i == segs.size() - 1);
-                if (last) {
-                    // Leaf: store PropertyMetadata
-                    cursor.put(seg, pm);
-                } else {
-                    Object n = cursor.get(seg);
-                    if (!(n instanceof Map)) {
-                        n = new LinkedHashMap<String, Object>();
-                        cursor.put(seg, n);
-                    }
-                    //noinspection unchecked
-                    cursor = (Map<String, Object>) n;
-                }
-            }
-        }
-        if (tree.isEmpty()) {
-            for (PropertyMetadata pm : allProps) {
-                if (pm.getDeclaringType().equals(cm.getType())) {
-                    tree.put(pm.getName(), pm);
-                }
-            }
-        }
-        // Serialize properties from the tree
-        emitProperties(out, vc, classElement, tree, required);
-        return required;
-    }
-
-    private void emitProperties(Writer out, @Nullable VisitorContext vc, @Nullable ClassElement classElement, Map<String, Object> tree, Set<String> required) throws IOException {
-        out.write('{');
-        Iterator<Map.Entry<String, Object>> it = tree.entrySet().iterator();
-        while (it.hasNext()) {
-            Map.Entry<String, Object> e = it.next();
-            String key = e.getKey();
-            attr(out, key);
-            writeSchemaNode(out, e.getValue(), vc, classElement, key, required);
-            if (it.hasNext()) {
-                out.write(',');
-            }
-        }
-        out.write('}');
-    }
-
-    @SuppressWarnings("unchecked")
-    private void writeSchemaNode(Writer out, Object node, @Nullable VisitorContext vc, @Nullable ClassElement classElement, @Nullable String currentKey, Set<String> requiredOut) throws IOException {
-        if (node instanceof PropertyMetadata pm) {
-            // Leaf property schema
-            out.write('{');
-            // type mapping (best effort)
-            writeTypeForProperty(out, pm, vc);
-            // description
-            if (pm.getDescription() != null) {
-                out.write(',');
-                attr(out, "description");
-                str(out, pm.getDescription());
-            }
-            // default
-            boolean wroteDefault;
-            if (pm.getDefaultValue() != null) {
-                Object coerced = coerceDefault(pm.getDefaultValue(), pm.getType());
-                if (coerced != null) {
-                    out.write(',');
-                    attr(out, DEFAULT);
-                    writeJsonValue(out, coerced);
-                    wroteDefault = true;
-                } else {
-                    wroteDefault = false;
-                }
-            } else {
-                wroteDefault = false;
-            }
-            // vendor ext per property
-            out.write(',');
-            attr(out, "x-micronaut-javaType");
-            str(out, pm.getType());
-            out.write(',');
-            attr(out, "x-micronaut-sourceType");
-            str(out, pm.getDeclaringType());
-            out.write(',');
-            attr(out, "x-micronaut-path");
-            str(out, pm.getPath());
-            if (vc != null) {
-                if (classElement != null) {
-                    PropertyElement pe = findProperty(classElement, currentKey, pm);
-                    if (pe != null) {
-                        applyValidationConstraints(out, pe, currentKey, requiredOut);
-                        if (!wroteDefault) {
-                            String defaultValue = pe.stringValue(Bindable.class, "defaultValue").orElse(null);
-                            if (defaultValue != null) {
-                                Object aDefault = coerceDefault(defaultValue, pm.getType());
-                                if (aDefault != null) {
-                                    out.write(',');
-                                    attr(out, DEFAULT);
-                                    writeJsonValue(out, aDefault);
-                                }
-                            } else {
-                                String constantName = "DEFAULT_" + NameUtils.environmentName(pm.getName());
-                                FieldElement constantField = classElement.getEnclosedElement(ElementQuery.ALL_FIELDS.named(constantName).onlyStatic()).orElse(null);
-                                if (constantField != null) {
-                                    Object constantValue = constantField.getConstantValue();
-                                    if (constantValue != null) {
-                                        out.write(',');
-                                        attr(out, DEFAULT);
-                                        writeJsonValue(out, constantValue);
-                                    }
-                                }
-                            }
-                        }
-                        if (pe.hasStereotype(Deprecated.class)) {
-                            try {
-                                out.write(',');
-                                attr(out, "deprecated");
-                                out.write("true");
-                            } catch (IOException ignored) {
-                                // ignored
-                            }
-                        }
-                    }
-                }
-            }
-            out.write('}');
-        } else if (node instanceof Map) {
-            Map<String, Object> m = (Map<String, Object>) node;
-            out.write('{');
-            attr(out, ATTR_TYPE);
-            str(out, OBJECT);
-            out.write(',');
-            attr(out, ATTR_PROPERTIES);
-            emitProperties(out, vc, classElement, m, requiredOut);
-            out.write('}');
-        } else {
-            // Should not happen; write permissive schema
-            out.write("{\"type\":\"object\"}");
-        }
-    }
-
-    @Nullable
-    private static PropertyElement findProperty(ClassElement classElement, @Nullable String currentKey, PropertyMetadata pm) {
-        return classElement.getBeanProperties()
-            .stream().filter(p -> p.getName().equals(currentKey) || p.getName().equals(pm.getName()))
-            .findFirst().orElse(null);
-    }
-
-    private void writeTypeForProperty(Writer out, PropertyMetadata pm, @Nullable VisitorContext vc) throws IOException {
-        String fqcn = pm.getType();
-        // Try to refine via VisitorContext (generics, enums)
-        ClassElement ce = (vc != null) ? vc.getClassElement(pm.getDeclaringType()).orElse(null) : null;
-        PropertyElement pe = null;
-        if (ce != null) {
-            pe = findProperty(ce, null, pm);
-        }
-        if (pe != null) {
-            // Optional
-            ClassElement t = pe.getGenericType();
-            if (t.isOptional()) {
-                t = t.getOptionalValueType().orElse(t);
-            }
-            // Collection/Array
-            if (t.isArray() || t.isIterable()) {
-                out.write('"');
-                out.write(ATTR_TYPE);
-                out.write('"');
-                out.write(':');
-                str(out, ARRAY);
-                out.write(',');
-                attr(out, "items");
-                if (t.isArray()) {
-                    String n = t.getName();
-                    while (n.endsWith("[]")) {
-                        n = n.substring(0, n.length() - 2);
-                    }
-                    writeChildTypeName(out, n);
-                } else {
-                    ClassElement item = t.getFirstTypeArgument().orElse(null);
-                    if (item != null) {
-                        writeChildTypeSchema(out, item);
-                    } else {
-                        writeChildTypeName(out, "java.lang.String");
-                    }
-                }
-                return;
-            }
-            // Map
-            if (t.isAssignable(Map.class)) {
-                out.write('"');
-                out.write(ATTR_TYPE);
-                out.write('"');
-                out.write(':');
-                str(out, OBJECT);
-                out.write(',');
-                attr(out, ATTR_ADDITIONAL_PROPERTIES);
-                ClassElement v = t.getTypeArguments().get("V");
-                if (v == null) {
-                    v = t;
-                }
-                writeChildTypeSchema(out, v);
-                return;
-            }
-            // Plain type
-            writeSimpleTypeSchema(out, t);
-            return;
-        }
-        // Fallback: map simple by name
-        writeSimpleTypeName(out, fqcn);
-    }
-
-    private void writeChildTypeSchema(Writer out, ClassElement t) throws IOException {
-        out.write('{');
-        writeSimpleTypeSchema(out, t);
-        out.write('}');
-    }
-
-    private void writeChildTypeName(Writer out, String fqcn) throws IOException {
-        out.write('{');
-        writeSimpleTypeName(out, fqcn);
-        out.write('}');
-    }
-
-    private void writeSimpleTypeSchema(Writer out, ClassElement t) throws IOException {
-        // Enum
-        if (t.isEnum()) {
-            attr(out, ATTR_TYPE);
-            str(out, STRING);
-            out.write(',');
-            attr(out, ATTR_ENUM);
-            out.write('[');
-            List<String> values;
-            if (t instanceof io.micronaut.inject.ast.EnumElement ee) {
-                values = ee.values();
-            } else {
-                values = Collections.emptyList();
-            }
-            for (int i = 0; i < values.size(); i++) {
-                str(out, values.get(i));
-                if (i + 1 < values.size()) {
-                    out.write(',');
-                }
-            }
-            out.write(']');
-            return;
-        }
-        // URI/URL
-        String n = t.getName();
-        if ("java.net.URI".equals(n) || "java.net.URL".equals(n)) {
-            attr(out, ATTR_TYPE);
-            str(out, STRING);
-            out.write(',');
-            attr(out, ATTR_FORMAT);
-            str(out, "uri");
-            return;
-        }
-        if ("java.time.Duration".equals(n)) {
-            attr(out, ATTR_TYPE);
-            str(out, STRING);
-            out.write(',');
-            attr(out, ATTR_FORMAT);
-            str(out, DURATION);
-            return;
-        }
-        // Basic primitives/wrappers/strings
-        writeSimpleTypeName(out, n);
-    }
-
-    private void writeSimpleTypeName(Writer out, String fqcn) throws IOException {
-        String type = switch (fqcn) {
-            case BOOLEAN, "java.lang.Boolean" -> BOOLEAN;
-            case "byte", "short", "int", "long", "java.lang.Byte", "java.lang.Short",
-                 "java.lang.Integer", "java.lang.Long", "java.math.BigInteger" -> "integer";
-            case "float", "double", "java.lang.Float", "java.lang.Double", "java.math.BigDecimal" ->
-                "number";
-            default -> STRING;
-        };
-        attr(out, ATTR_TYPE);
-        str(out, type);
-    }
-
-    private @Nullable Object coerceDefault(String value, String typeName) {
-        try {
-            return switch (typeName) {
-                case BOOLEAN, "java.lang.Boolean" -> Boolean.parseBoolean(value);
-                case "byte", "short", "int", "long", "java.lang.Byte", "java.lang.Short",
-                     "java.lang.Integer", "java.lang.Long", "java.math.BigInteger" ->
-                    Long.parseLong(value);
-                case "float", "double", "java.lang.Float", "java.lang.Double",
-                     "java.math.BigDecimal" -> Double.parseDouble(value);
-                default -> value; // string/enum/uri fall back to string
-            };
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
-    private void writeJsonValue(Writer out, Object v) throws IOException {
-        switch (v) {
-            case String s -> {
-                str(out, s);
-                return;
-            }
-            case Boolean b -> {
-                out.write(b ? StringUtils.TRUE : StringUtils.FALSE);
-                return;
-            }
-            case Number number -> {
-                out.write(number.toString());
-                return;
-            }
-            default -> {
-                // no-oip
-            }
-        }
-        // fallback to string
-        str(out, String.valueOf(v));
-    }
-
-    private void emitAdditionalPropertiesRef(Writer out) throws IOException {
-        attr(out, ATTR_ADDITIONAL_PROPERTIES);
-        refEntry(out);
-    }
-
-    private static List<String> splitOnDot(String rel) {
-        if (rel.indexOf('.') < 0) {
-            return List.of(rel);
-        }
-        List<String> parts = new ArrayList<>();
-        int start = 0;
-        for (int i = 0; i < rel.length(); i++) {
-            if (rel.charAt(i) == '.') {
-                parts.add(rel.substring(start, i));
-                start = i + 1;
-            }
-        }
-        if (start <= rel.length()) {
-            parts.add(rel.substring(start));
-        }
-        return parts;
-    }
-
-    private void refEntry(Writer out) throws IOException {
-        out.write('{');
-        attr(out, "$ref");
-        str(out, "#/$defs/Entry");
-        out.write('}');
-    }
-
-    private void applyValidationConstraints(Writer out,
-                                            PropertyElement pe,
-                                            @Nullable String currentKey,
-                                            Set<String> requiredOut) throws IOException {
-        BiFunction<String, String, @Nullable String> sval = (ann, member) ->
-            pe.stringValue(ann, member).orElseGet(() -> {
-                List<AnnotationValue<Annotation>> values = pe.getDeclaredAnnotationValuesByName(ann);
-                if (!values.isEmpty()) {
-                    return values.getFirst().stringValue(member).orElse(null);
-                }
-                return null;
-            }
-        );
-
-        // Collect NotNull -> required
-        if ((hasValidationAnnotation(pe, JV_NOT_NULL) || hasValidationAnnotation(pe, JV_NOT_BLANK)) && currentKey != null) {
-            requiredOut.add(currentKey);
-        }
-        // Null -> const null? skip (rare); users should use @Nullable to allow nulls
-        // AssertTrue/False -> const
-        if (hasValidationAnnotation(pe, JV_ASSERT_TRUE)) {
-            comma(out);
-            attr(out, ATTR_CONST);
-            out.write(StringUtils.TRUE);
-        }
-        if (hasValidationAnnotation(pe, JV_ASSERT_FALSE)) {
-            comma(out);
-            attr(out, ATTR_CONST);
-            out.write(StringUtils.FALSE);
-        }
-        // Email
-        if (hasValidationAnnotation(pe, JV_EMAIL)) {
-            comma(out);
-            attr(out, ATTR_FORMAT);
-            str(out, "email");
-        }
-        // Pattern
-        String pattern = sval.apply(JV_PATTERN, "regexp");
-        if (pattern != null && !pattern.isEmpty()) {
-            comma(out);
-            attr(out, ATTR_PATTERN);
-            str(out, pattern);
-        }
-        // Size
-        Integer sizeMinBox = intValue(pe, JV_SIZE, "min");
-        Integer sizeMaxBox = intValue(pe, JV_SIZE, "max");
-        int sizeMin = sizeMinBox == null ? -1 : sizeMinBox;
-        int sizeMax = sizeMaxBox == null ? -1 : sizeMaxBox;
-        ClassElement t = pe.getType();
-        boolean isString = String.class.getName().equals(t.getName());
-        boolean isArray = t.isArray() || t.isIterable();
-        boolean isMap = t.isAssignable(java.util.Map.class);
-        if (isString) {
-            if (hasValidationAnnotation(pe, JV_NOT_BLANK) || hasValidationAnnotation(pe, JV_NOT_EMPTY)) {
-                sizeMin = Math.max(sizeMin, 1);
-            }
-            if (sizeMin >= 0) {
-                comma(out);
-                attr(out, "minLength");
-                out.write(Integer.toString(sizeMin));
-            }
-            if (sizeMax >= 0) {
-                comma(out);
-                attr(out, "maxLength");
-                out.write(Integer.toString(sizeMax));
-            }
-        } else if (isArray) {
-            if (hasValidationAnnotation(pe, JV_NOT_EMPTY)) {
-                sizeMin = Math.max(sizeMin, 1);
-            }
-            if (sizeMin >= 0) {
-                comma(out);
-                attr(out, ATTR_MIN_ITEMS);
-                out.write(Integer.toString(sizeMin));
-            }
-            if (sizeMax >= 0) {
-                comma(out);
-                attr(out, "maxItems");
-                out.write(Integer.toString(sizeMax));
-            }
-        } else if (isMap) {
-            if (hasValidationAnnotation(pe, JV_NOT_EMPTY)) {
-                sizeMin = Math.max(sizeMin, 1);
-            }
-            if (sizeMin >= 0) {
-                comma(out);
-                attr(out, ATTR_MIN_PROPERTIES);
-                out.write(Integer.toString(sizeMin));
-            }
-            if (sizeMax >= 0) {
-                comma(out);
-                attr(out, ATTR_MAX_PROPERTIES);
-                out.write(Integer.toString(sizeMax));
-            }
-        }
-        // Min/Max
-        Long min = longValue(pe, JV_MIN, AnnotationMetadata.VALUE_MEMBER);
-        Long max = longValue(pe, JV_MAX, AnnotationMetadata.VALUE_MEMBER);
-        if (min != null) {
-            comma(out);
-            attr(out, ATTR_MIN);
-            out.write(Long.toString(min));
-        }
-        if (max != null) {
-            comma(out);
-            attr(out, ATTR_MAX);
-            out.write(Long.toString(max));
-        }
-        // DecimalMin/DecimalMax
-        String dmin = sval.apply("jakarta.validation.constraints.DecimalMin", AnnotationMetadata.VALUE_MEMBER);
-        Boolean dminInc = booleanValue(pe, "jakarta.validation.constraints.DecimalMin", "inclusive");
-        if (dmin != null) {
-            comma(out);
-            if (dminInc == null || dminInc) {
-                attr(out, ATTR_MIN);
-            } else {
-                attr(out, ATTR_EXCLUSIVE_MINIMUM);
-            }
-            out.write(dmin);
-        }
-        String dmax = sval.apply("jakarta.validation.constraints.DecimalMax", AnnotationMetadata.VALUE_MEMBER);
-        Boolean dmaxInc = booleanValue(pe, "jakarta.validation.constraints.DecimalMax", "inclusive");
-        if (dmax != null) {
-            comma(out);
-            if (dmaxInc == null || dmaxInc) {
-                attr(out, ATTR_MAX);
-            } else {
-                attr(out, ATTR_EXCLUSIVE_MAXIMUM);
-            }
-            out.write(dmax);
-        }
-        // Positive / Negative variants
-        if (hasValidationAnnotation(pe, JV_POSITIVE)) {
-            comma(out);
-            attr(out, ATTR_EXCLUSIVE_MINIMUM);
-            out.write("0");
-        }
-        if (hasValidationAnnotation(pe, JV_POSITIVE_OR_ZERO)) {
-            comma(out);
-            attr(out, ATTR_MIN);
-            out.write("0");
-        }
-        if (hasValidationAnnotation(pe, JV_NEGATIVE)) {
-            comma(out);
-            attr(out, ATTR_EXCLUSIVE_MAXIMUM);
-            out.write("0");
-        }
-        if (hasValidationAnnotation(pe, JV_NEGATIVE_OR_ZERO)) {
-            comma(out);
-            attr(out, ATTR_MAX);
-            out.write("0");
-        }
-        // Digits -> regex
-        Integer intDigits = intValue(pe, JV_DIGITS, "integer");
-        Integer fracDigits = intValue(pe, JV_DIGITS, "fraction");
-        if (intDigits != null || fracDigits != null) {
-            StringBuilder re = new StringBuilder("^");
-            int id = intDigits != null ? intDigits : 0;
-            int fd = fracDigits != null ? fracDigits : 0;
-            if (id > 0) {
-                re.append("\\d{1,").append(id).append("}");
-            } else {
-                re.append("\\d+");
-            }
-            if (fd > 0) {
-                re.append("(\\.\\d{1,").append(fd).append("})?");
-            }
-            re.append("$");
-            comma(out);
-            attr(out, ATTR_PATTERN);
-            str(out, re.toString());
-        }
-    }
-
-    @Nullable
-    private static Boolean booleanValue(PropertyElement pe, String ann, String member) {
-        return pe.booleanValue(ann, member).orElseGet(() -> {
-                List<AnnotationValue<Annotation>> values = pe.getDeclaredAnnotationValuesByName(ann);
-                if (!values.isEmpty()) {
-                    return values.getFirst().booleanValue(member).orElse(null);
-                }
-                return null;
-            }
-        );
-    }
-
-    @Nullable
-    private static Long longValue(PropertyElement pe, String ann, String member) {
-        OptionalLong opt = pe.longValue(ann, member);
-        if (opt.isPresent()) {
-            return opt.getAsLong();
-        } else {
-            List<AnnotationValue<Annotation>> values = pe.getDeclaredAnnotationValuesByName(ann);
-            if (!values.isEmpty()) {
-                OptionalLong optionalInt = values.getFirst().longValue(member);
-                if (optionalInt.isPresent()) {
-                    return optionalInt.getAsLong();
-                }
-            }
-            return null;
-        }
-    }
-
-    @Nullable
-    private static Integer intValue(PropertyElement pe, String ann, String member) {
-        OptionalInt opt = pe.intValue(ann, member);
-        if (opt.isPresent()) {
-            return opt.getAsInt();
-        } else {
-            List<AnnotationValue<Annotation>> values = pe.getDeclaredAnnotationValuesByName(ann);
-            if (!values.isEmpty()) {
-                OptionalInt optionalInt = values.getFirst().intValue(member);
-                if (optionalInt.isPresent()) {
-                    return optionalInt.getAsInt();
-                }
-            }
-            return null;
-        }
-    }
-
-    private static boolean hasValidationAnnotation(PropertyElement pe, String ann) {
-        List<AnnotationValue<Annotation>> values = pe.getDeclaredAnnotationValuesByName(ann);
-        return !values.isEmpty();
-    }
-
-    // JSON writing helpers
-    private void attr(Writer out, String name) throws IOException {
-        out.write('"');
-        out.write(name);
-        out.write('"');
-        out.write(':');
-    }
-
-    private void str(Writer out, String s) throws IOException {
-        out.write(ConfigurationMetadataBuilder.quote(s));
-    }
-
-    private void comma(Writer out) throws IOException {
-        out.write(',');
-    }
-}
diff --git a/core-processor/src/main/resources/META-INF/services/io.micronaut.inject.configuration.ConfigurationMetadataWriter b/core-processor/src/main/resources/META-INF/services/io.micronaut.inject.configuration.ConfigurationMetadataWriter
index d754936d19..34b6d42e07 100644
--- a/core-processor/src/main/resources/META-INF/services/io.micronaut.inject.configuration.ConfigurationMetadataWriter
+++ b/core-processor/src/main/resources/META-INF/services/io.micronaut.inject.configuration.ConfigurationMetadataWriter
@@ -1,2 +1 @@
-io.micronaut.inject.configuration.JsonConfigurationMetadataWriter
-io.micronaut.inject.configuration.JsonSchemaConfigurationMetadataWriter
\ No newline at end of file
+io.micronaut.inject.configuration.JsonConfigurationMetadataWriter
\ No newline at end of file
diff --git a/core/src/main/java/io/micronaut/core/bind/annotation/Bindable.java b/core/src/main/java/io/micronaut/core/bind/annotation/Bindable.java
index 3e29f7c492..0dc13a71e5 100644
--- a/core/src/main/java/io/micronaut/core/bind/annotation/Bindable.java
+++ b/core/src/main/java/io/micronaut/core/bind/annotation/Bindable.java
@@ -27,7 +27,7 @@ import java.lang.annotation.*;
  */
 @Documented
 @Retention(RUNTIME)
-@Target({ElementType.ANNOTATION_TYPE, ElementType.PARAMETER, ElementType.METHOD, ElementType.FIELD})
+@Target({ElementType.ANNOTATION_TYPE, ElementType.PARAMETER, ElementType.METHOD})
 @Inherited
 public @interface Bindable {
 
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/configuration/ConfigurationJsonSchemaDefaultsSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/configuration/ConfigurationJsonSchemaDefaultsSpec.groovy
deleted file mode 100644
index e2c233210b..0000000000
--- a/inject-java/src/test/groovy/io/micronaut/inject/configuration/ConfigurationJsonSchemaDefaultsSpec.groovy
+++ /dev/null
@@ -1,114 +0,0 @@
-package io.micronaut.inject.configuration
-
-import io.micronaut.annotation.processing.test.AbstractTypeElementSpec
-import io.micronaut.annotation.processing.test.JavaParser
-import org.intellij.lang.annotations.Language
-import groovy.json.JsonSlurper
-
-class ConfigurationJsonSchemaDefaultsSpec extends AbstractTypeElementSpec {
-
-    @Override
-    protected JavaParser newJavaParser() {
-        new JavaParser() {}
-    }
-
-    private static String readSchemaFile(AbstractTypeElementSpec self, String fqcn, @Language("java") String cls) {
-        String path = "META-INF/micronaut-configuration-schemas/${fqcn}.json"
-        return self.buildAndReadResourceAsString(path, cls)
-    }
-
-    private static Map parseJson(String json) { new JsonSlurper().parseText(json) as Map }
-
-    void "test field constants as defaults (int/string/boolean)"() {
-        when:
-        String schema = readSchemaFile(this, 'test.Consts', '''
-package test;
-import io.micronaut.context.annotation.*;
-
-@ConfigurationProperties("consts")
-class Consts {
-  public static final int DEFAULT_I = 42;
-  public static final String DEFAULT_STRING_VALUE = "hello";
-  public static final boolean DEFAULT_B = true;
-
-  private int i = DEFAULT_I;
-  private String stringValue = DEFAULT_STRING_VALUE;
-  private boolean b = DEFAULT_B;
-
-  public int getI() { return i; }
-  public void setI(int v) { this.i = v; }
-  public String getStringValue() { return stringValue; }
-  public void setStringValue(String v) { this.stringValue = v; }
-  public boolean isB() { return b; }
-  public void setB(boolean v) { this.b = v; }
-}
-''')
-        then:
-        def m = parseJson(schema)
-        Map props = (Map) m.get('properties')
-        ((Map) props.get('i')).get('default') == 42
-        ((Map) props.get('string-value')).get('default') == 'hello'
-        ((Map) props.get('b')).get('default') == true
-    }
-
-    void "test @Bindable default on setter parameter is used"() {
-        when:
-        String schema = readSchemaFile(this, 'test.BindableSetter', '''
-package test;
-import io.micronaut.context.annotation.*;
-import io.micronaut.core.bind.annotation.Bindable;
-
-@ConfigurationProperties("bindable.setter")
-class BindableSetter {
-  @Bindable(defaultValue = "64")
-  private int size;
-  public int getSize() { return size; }
-  public void setSize(int size) { this.size = size; }
-}
-''')
-        then:
-        def m = parseJson(schema)
-        Map props = (Map) m.get('properties')
-        ((Map) props.get('size')).get('default') == 64
-    }
-
-    void "test @Bindable default on property method (interface) is used"() {
-        when:
-        String schema = readSchemaFile(this, 'test.ItfProps', '''
-package test;
-import io.micronaut.context.annotation.*;
-import io.micronaut.core.bind.annotation.Bindable;
-
-@ConfigurationProperties("itf")
-interface ItfProps {
-  @Bindable(defaultValue = "http://default")
-  java.net.URI getEndpoint();
-}
-''')
-        then:
-        def m = parseJson(schema)
-        Map props = (Map) m.get('properties')
-        ((Map) props.get('endpoint')).get('default') == 'http://default'
-        ((Map) props.get('endpoint')).get('format') == 'uri'
-    }
-
-    void "test @Bindable default on property method record is used"() {
-        when:
-        String schema = readSchemaFile(this, 'test.ItfProps', '''
-package test;
-import io.micronaut.context.annotation.*;
-import io.micronaut.core.bind.annotation.Bindable;
-
-@ConfigurationProperties("itf")
-record ItfProps(
-  @Bindable(defaultValue = "http://default")
-  java.net.URI endpoint) {
-}
-''')
-        then:
-        def m = parseJson(schema)
-        Map props = (Map) m.get('properties')
-        ((Map) props.get('endpoint')).get('default') == 'http://default'
-        ((Map) props.get('endpoint')).get('format') == 'uri'
-    }
-}
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/configuration/ConfigurationJsonSchemaSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/configuration/ConfigurationJsonSchemaSpec.groovy
deleted file mode 100644
index 181ef0a49f..0000000000
--- a/inject-java/src/test/groovy/io/micronaut/inject/configuration/ConfigurationJsonSchemaSpec.groovy
+++ /dev/null
@@ -1,200 +0,0 @@
-package io.micronaut.inject.configuration
-
-import io.micronaut.annotation.processing.test.AbstractTypeElementSpec
-import io.micronaut.annotation.processing.test.JavaParser
-import org.intellij.lang.annotations.Language
-import groovy.json.JsonSlurper
-
-class ConfigurationJsonSchemaSpec extends AbstractTypeElementSpec {
-
-    @Override
-    protected JavaParser newJavaParser() {
-        new JavaParser() {}
-    }
-
-    private static Map readSchema(String fqcn, String json) {
-        new JsonSlurper().parseText(json) as Map
-    }
-
-    private static String readSchemaFile(AbstractTypeElementSpec self, String fqcn, @Language("java") String cls) {
-        String path = "META-INF/micronaut-configuration-schemas/${fqcn}.json"
-        return self.buildAndReadResourceAsString(path, cls)
-    }
-
-    void "test simple configuration properties schema"() {
-        when:
-        String schema = readSchemaFile(this, 'test.MyProps', '''
-package test;
-
-import io.micronaut.context.annotation.*;
-
-/** My props */
-@ConfigurationProperties("foo.bar")
-class MyProps {
-    private String host;
-    private int port;
-
-    public String getHost() { return host; }
-    public void setHost(String host) { this.host = host; }
-
-    public int getPort() { return port; }
-    public void setPort(int port) { this.port = port; }
-}
-''')
-
-        then:
-        def m = readSchema('test.MyProps', schema)
-        m.'$schema' == 'https://json-schema.org/draft/2020-12/schema'
-        m.'$id' == 'urn:micronaut:config:test.MyProps'
-        m.title == 'test.MyProps'
-        m.'x-micronaut'.prefix == 'foo.bar'
-        m.type == 'object'
-        Map props = (Map) m.get('properties')
-        ((Map) props.get('host')).get('type') == 'string'
-        ((Map) props.get('port')).get('type') == 'integer'
-    }
-
-    void "test each property map schema with requires"() {
-        when:
-        String schema = readSchemaFile(this, 'test.Ds', '''
-package test;
-import io.micronaut.context.annotation.*;
-
-@EachProperty("dataSources")
-class Ds {
-    private java.net.URI url;
-    public java.net.URI getUrl() { return url; }
-    public void setUrl(java.net.URI url) { this.url = url; }
-}
-''')
-
-        then:
-        def m = readSchema('test.Ds', schema)
-        m.'x-micronaut'.kind == 'each-property'
-        m.'x-micronaut'.container == 'map'
-        m.'x-micronaut'.prefix == 'data-sources'
-        m.type == 'object'
-        m.minProperties == 1
-        m.additionalProperties.'$ref' == '#/$defs/Entry'
-        m.'$defs'.Entry.type == 'object'
-        Map entryProps = (Map) ((Map) m.get('$defs')).get('Entry').get('properties')
-        ((Map) entryProps.get('url')).get('format') == 'uri'
-    }
-
-    void "test each property list schema with requires"() {
-        when:
-        String schema = readSchemaFile(this, 'test.Buckets', '''
-package test;
-import io.micronaut.context.annotation.*;
-
-@EachProperty(value = "buckets", list = true)
-class Buckets {
-    private String region;
-    public String getRegion() { return region; }
-    public void setRegion(String region) { this.region = region; }
-}
-''')
-
-        then:
-        def m = readSchema('test.Buckets', schema)
-        m.'x-micronaut'.kind == 'each-property'
-        m.'x-micronaut'.container == 'list'
-        m.type == 'array'
-        m.minItems == 1
-        m.items.'$ref' == '#/$defs/Entry'
-        Map entryProps2 = (Map) ((Map) m.get('$defs')).get('Entry').get('properties')
-        ((Map) entryProps2.get('region')).get('type') == 'string'
-    }
-
-    void "test nested configuration properties produce separate schema files"() {
-        when:
-        String schemaOuter = readSchemaFile(this, 'test.Outer', '''
-package test;
-import io.micronaut.context.annotation.*;
-
-@ConfigurationProperties("outer")
-class Outer {
-  Inner inner = new Inner();
-  @ConfigurationProperties("inner")
-  public static class Inner {
-    private boolean enabled;
-    public boolean isEnabled() { return enabled; }
-    public void setEnabled(boolean enabled) { this.enabled = enabled; }
-  }
-}
-''')
-        String schemaInner = readSchemaFile(this, 'test.Outer$Inner', '''
-package test;
-import io.micronaut.context.annotation.*;
-
-@ConfigurationProperties("outer")
-class Outer {
-  Inner inner = new Inner();
-  @ConfigurationProperties("inner")
-  public static class Inner {
-    private boolean enabled;
-    public boolean isEnabled() { return enabled; }
-    public void setEnabled(boolean enabled) { this.enabled = enabled; }
-  }
-}
-''')
-        then:
-        def outer = readSchema('test.Outer', schemaOuter)
-        outer.'x-micronaut'.prefix == 'outer'
-        outer.type == 'object'
-        def inner = readSchema('test.Outer$Inner', schemaInner)
-        inner.'x-micronaut'.prefix == 'outer.inner'
-        inner.type == 'object'
-        Map iprops = (Map) inner.get('properties')
-        ((Map) iprops.get('enabled')).get('type') == 'boolean'
-    }
-
-    void "test common java types mapping"() {
-        when:
-        String schema = readSchemaFile(this, 'test.Types', '''
-package test;
-import io.micronaut.context.annotation.*;
-import java.net.URI;
-import java.time.Duration;
-import java.util.*;
-
-@ConfigurationProperties("types")
-class Types {
-  private String s; private int i; private long l; private double d; private boolean b;
-  private URI uri; private Duration dur; private Optional<Integer> opt;
-  private java.util.List<String> names; private java.util.Map<String,String> labels;
-  private Color color;
-  public String getS(){return s;} public void setS(String s){this.s=s;}
-  public int getI(){return i;} public void setI(int v){this.i=v;}
-  public long getL(){return l;} public void setL(long v){this.l=v;}
-  public double getD(){return d;} public void setD(double v){this.d=v;}
-  public boolean isB(){return b;} public void setB(boolean v){this.b=v;}
-  public URI getUri(){return uri;} public void setUri(URI u){this.uri=u;}
-  public Duration getDur(){return dur;} public void setDur(Duration u){this.dur=u;}
-  public Optional<Integer> getOpt(){return opt;} public void setOpt(Optional<Integer> o){this.opt=o;}
-  public java.util.List<String> getNames(){return names;} public void setNames(java.util.List<String> n){this.names=n;}
-  public java.util.Map<String,String> getLabels(){return labels;} public void setLabels(java.util.Map<String,String> m){this.labels=m;}
-  public Color getColor(){return color;} public void setColor(Color c){this.color=c;}
-  public static enum Color { RED, GREEN, BLUE }
-}
-''')
-        then:
-        def m = readSchema('test.Types', schema)
-        m.'x-micronaut'.prefix == 'types'
-
-        def properties = m.get('properties')
-        properties['s']['type'] == 'string'
-        properties['i']['type'] == 'integer'
-        properties['l']['type'] == 'integer'
-        properties['d']['type'] == 'number'
-        properties['b']['type'] == 'boolean'
-        properties['uri']['format'] == 'uri'
-        properties['dur']['format'] == 'duration'
-        properties['names']['type'] == 'array'
-        properties['names']['items']['type'] == 'string'
-        properties['labels']['type'] == 'object'
-        properties['labels']['additionalProperties']['type'] == 'string'
-        properties['color']['type'] == 'string'
-        properties['color']['enum'] == ['RED', 'GREEN', 'BLUE']
-    }
-}
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/configuration/ConfigurationJsonSchemaValidationSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/configuration/ConfigurationJsonSchemaValidationSpec.groovy
deleted file mode 100644
index e43adb6d8c..0000000000
--- a/inject-java/src/test/groovy/io/micronaut/inject/configuration/ConfigurationJsonSchemaValidationSpec.groovy
+++ /dev/null
@@ -1,256 +0,0 @@
-package io.micronaut.inject.configuration
-
-import io.micronaut.annotation.processing.test.AbstractTypeElementSpec
-import io.micronaut.annotation.processing.test.JavaParser
-import org.intellij.lang.annotations.Language
-import groovy.json.JsonSlurper
-
-class ConfigurationJsonSchemaValidationSpec extends AbstractTypeElementSpec {
-
-    @Override
-    protected JavaParser newJavaParser() {
-        new JavaParser() {}
-    }
-
-    private static String readSchemaFile(AbstractTypeElementSpec self, String fqcn, @Language("java") String cls) {
-        String path = "META-INF/micronaut-configuration-schemas/${fqcn}.json"
-        return self.buildAndReadResourceAsString(path, cls)
-    }
-
-    private static Map parseJson(String json) { new JsonSlurper().parseText(json) as Map }
-
-    void "string constraints: NotBlank, Size, Pattern, Email"() {
-        when:
-        String schema = readSchemaFile(this, 'test.Props', '''
-package test;
-import io.micronaut.context.annotation.*;
-import jakarta.validation.constraints.*;
-
-@ConfigurationProperties("props")
-class Props {
-  @NotBlank
-  @Size(min=2, max=5)
-  @Pattern(regexp = "[a-z]+")
-  @Email
-  private String s;
-
-  public String getS() { return s; }
-  public void setS(String v) { this.s = v; }
-}
-''')
-        then:
-        def m = parseJson(schema)
-        def props = m.get("properties")
-        Map s = props['s']
-        assert m.required.contains('s')
-        s.minLength == 2
-        s.maxLength == 5
-        s.pattern == '[a-z]+'
-        s.format == 'email'
-    }
-
-    void "number constraints: Min/Max, DecimalMin/DecimalMax exclusive, Positive, NegativeOrZero"() {
-        when:
-        String schema = readSchemaFile(this, 'test.NumProps', '''
-package test;
-import io.micronaut.context.annotation.*;
-import jakarta.validation.constraints.*;
-
-@ConfigurationProperties("num")
-class NumProps {
-  @Min(10)
-  @Max(100)
-  private int a;
-
-  @DecimalMin(value="1.5", inclusive=false)
-  @DecimalMax(value="9.5", inclusive=false)
-  private double b;
-
-  @Positive
-  private long c;
-
-  @NegativeOrZero
-  private long d;
-
-  public int getA(){return a;} public void setA(int v){this.a=v;}
-  public double getB(){return b;} public void setB(double v){this.b=v;}
-  public long getC(){return c;} public void setC(long v){this.c=v;}
-  public long getD(){return d;} public void setD(long v){this.d=v;}
-}
-''')
-        then:
-        def m = parseJson(schema)
-        Map props = m.get("properties")
-        Map a = props['a']
-        Map b = props['b']
-        Map c = props['c']
-        Map d = props['d']
-        a.minimum == 10
-        a.maximum == 100
-        b.exclusiveMinimum == 1.5
-        b.exclusiveMaximum == 9.5
-        c.exclusiveMinimum == 0
-        d.maximum == 0
-    }
-
-    void "collection constraints: NotEmpty and Size on List and Map"() {
-        when:
-        String schema = readSchemaFile(this, 'test.CollProps', '''
-package test;
-import io.micronaut.context.annotation.*;
-import jakarta.validation.constraints.*;
-import java.util.*;
-
-@ConfigurationProperties("coll")
-class CollProps {
-  @NotEmpty
-  @Size(min=2, max=4)
-  private java.util.List<String> l;
-
-  @NotEmpty
-  @Size(min=1, max=3)
-  private java.util.Map<String,String> m;
-
-  public java.util.List<String> getL(){return l;} public void setL(java.util.List<String> v){this.l=v;}
-  public java.util.Map<String,String> getM(){return m;} public void setM(java.util.Map<String,String> v){this.m=v;}
-}
-''')
-        then:
-        def m = parseJson(schema)
-        Map props = m.get("properties")
-        Map l = props['l']
-        Map pmap = props['m']
-        l.minItems == 2
-        l.maxItems == 4
-        pmap.minProperties == 1
-        pmap.maxProperties == 3
-    }
-
-    void "required with NotNull and EachProperty entry constraints"() {
-        when:
-        String schema = readSchemaFile(this, 'test.Each', '''
-package test;
-import io.micronaut.context.annotation.*;
-import jakarta.validation.constraints.*;
-
-@EachProperty("things")
-class Each {
-  @NotNull
-  private String name;
-
-  public String getName(){return name;} public void setName(String v){this.name=v;}
-}
-''')
-        then:
-        def m = parseJson(schema)
-        m.type == 'object' || m.type == 'array'
-        def entry = m.'$defs'.Entry
-        assert entry.required != null && entry.required.contains('name')
-        (entry.get("properties")['name']).type == 'string'
-    }
-
-    void "assertTrue/assertFalse map to const"() {
-        when:
-        String schema = readSchemaFile(this, 'test.BoolProps', '''
-package test;
-import io.micronaut.context.annotation.*;
-import jakarta.validation.constraints.*;
-
-@ConfigurationProperties("bools")
-class BoolProps {
-  @AssertTrue
-  private boolean on;
-  @AssertFalse
-  private boolean off;
-  public boolean isOn(){return on;} public void setOn(boolean v){this.on=v;}
-  public boolean isOff(){return off;} public void setOff(boolean v){this.off=v;}
-}
-''')
-        then:
-        def m = parseJson(schema)
-        Map props = m.get("properties")
-        props.on.const == true
-        props.off.const == false
-    }
-
-    void "NotNull implies required for configuration properties"() {
-        when:
-        String schema = readSchemaFile(this, 'test.RequiredProps', '''
-package test;
-import io.micronaut.context.annotation.*;
-import jakarta.validation.constraints.*;
-
-@ConfigurationProperties("required")
-class RequiredProps {
-  @NotNull
-  private String must;
-  public String getMust(){return must;} public void setMust(String v){this.must=v;}
-}
-''')
-        then:
-        def m = parseJson(schema)
-        m.required.contains('must')
-    }
-
-    void "Digits maps to conservative pattern"() {
-        when:
-        String schema = readSchemaFile(this, 'test.DigitsProps', '''
-package test;
-import io.micronaut.context.annotation.*;
-import jakarta.validation.constraints.*;
-
-@ConfigurationProperties("digits")
-class DigitsProps {
-  @Digits(integer=3, fraction=2)
-  private java.math.BigDecimal amount;
-  public java.math.BigDecimal getAmount(){return amount;} public void setAmount(java.math.BigDecimal v){this.amount=v;}
-}
-''')
-        then:
-        def m = parseJson(schema)
-        Map props = m.get("properties")
-        String pat = props.amount.pattern
-        assert pat != null
-        assert pat.contains("\\d")
-    }
-
-    void "EachProperty entry NotEmpty list implies minItems"() {
-        when:
-        String schema = readSchemaFile(this, 'test.EachList', '''
-package test;
-import io.micronaut.context.annotation.*;
-import jakarta.validation.constraints.*;
-import java.util.*;
-
-@EachProperty("groups")
-class EachList {
-  @NotEmpty
-  private java.util.List<String> names;
-  public java.util.List<String> getNames(){return names;} public void setNames(java.util.List<String> v){this.names=v;}
-}
-''')
-        then:
-        def m = parseJson(schema)
-        def entry = m.'$defs'.Entry
-        (entry.get("properties").names).minItems == 1
-    }
-
-    void "Nullable properties are not required"() {
-        when:
-        String schema = readSchemaFile(this, 'test.NullableProps', '''
-package test;
-import io.micronaut.context.annotation.*;
-import org.jspecify.annotations.Nullable;
-
-@ConfigurationProperties("nullable")
-class NullableProps {
-  @Nullable
-  private String maybe;
-  public String getMaybe(){return maybe;} public void setMaybe(String v){this.maybe=v;}
-}
-''')
-        then:
-        def m = parseJson(schema)
-        assert m.required == null || !m.required.contains('maybe')
-    }
-}
