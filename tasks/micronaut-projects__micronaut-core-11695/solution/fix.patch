diff --git a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
index 9b669e9a21..2e22b182d2 100644
--- a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
@@ -946,9 +946,9 @@ final class BeanIntrospectionWriter extends AbstractClassFileWriter {
             desc);
 
         if (args.length == 0) {
-            invokeBeanConstructor(instantiateInternal, constructor, true, null);
+            invokeBeanConstructor(ClassElement.of(introspectionName), instantiateInternal, constructor, true, null);
         } else {
-            invokeBeanConstructor(instantiateInternal, constructor, true, (index, parameter) -> {
+            invokeBeanConstructor(ClassElement.of(introspectionName), instantiateInternal, constructor, true, (index, parameter) -> {
                 instantiateInternal.loadArg(0);
                 instantiateInternal.push(index);
                 instantiateInternal.arrayLoad(TYPE_OBJECT);
@@ -1153,7 +1153,7 @@ final class BeanIntrospectionWriter extends AbstractClassFileWriter {
 
                 // NOTE: It doesn't make sense to check defaults for the copy constructor
 
-                invokeBeanConstructor(writer, constructor, false, (paramIndex, parameter) -> {
+                invokeBeanConstructor(ClassElement.of(introspectionName), writer, constructor, false, (paramIndex, parameter) -> {
                     Object constructorArgument = constructorArguments[paramIndex];
                     TypedElement supplierType;
                     if (constructorArgument instanceof MethodElement readMethod) {
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java b/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java
index 865bcdbae7..53e736f43f 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java
@@ -53,7 +53,7 @@ import static org.objectweb.asm.commons.GeneratorAdapter.EQ;
  */
 @Internal
 public final class WriterUtils {
-    private static final String METHOD_NAME_INSTANTIATE = "instantiate";
+    private static final String METHOD_NAME_INSTANTIATE = "instantiateReflectively";
 
     /**
      * The number of Kotlin defaults masks.
@@ -75,12 +75,13 @@ public final class WriterUtils {
         return arguments.stream().anyMatch(p -> p instanceof KotlinParameterElement kp && kp.hasDefault());
     }
 
-    public static void invokeBeanConstructor(GeneratorAdapter writer,
+    public static void invokeBeanConstructor(ClassElement caller,
+                                             GeneratorAdapter writer,
                                              MethodElement constructor,
                                              boolean allowKotlinDefaults,
                                              @Nullable
                                              BiConsumer<Integer, ParameterElement> argumentsPusher) {
-        invokeBeanConstructor(writer, constructor, constructor.isReflectionRequired(), allowKotlinDefaults, argumentsPusher, null);
+        invokeBeanConstructor(writer, constructor, constructor.isReflectionRequired(caller), allowKotlinDefaults, argumentsPusher, null);
     }
 
     public static void invokeBeanConstructor(GeneratorAdapter writer,
diff --git a/core/src/main/java/io/micronaut/core/reflect/InstantiationUtils.java b/core/src/main/java/io/micronaut/core/reflect/InstantiationUtils.java
index 5d7162ceb3..7b98575521 100644
--- a/core/src/main/java/io/micronaut/core/reflect/InstantiationUtils.java
+++ b/core/src/main/java/io/micronaut/core/reflect/InstantiationUtils.java
@@ -15,6 +15,8 @@
  */
 package io.micronaut.core.reflect;
 
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.UsedByGeneratedCode;
 import io.micronaut.core.beans.BeanIntrospection;
 import io.micronaut.core.beans.BeanIntrospector;
 import io.micronaut.core.convert.ConversionContext;
@@ -28,9 +30,12 @@ import io.micronaut.core.util.CollectionUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import io.micronaut.core.annotation.NonNull;
 import java.lang.reflect.Constructor;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
 import java.util.function.Function;
 import java.util.function.Supplier;
 
@@ -232,19 +237,37 @@ public class InstantiationUtils {
      */
     public static <T> T instantiate(Class<T> type, Class<?>[] argTypes, Object... args) {
         try {
-            return BeanIntrospector.SHARED.findIntrospection(type).map(bi -> bi.instantiate(args)).orElseGet(() -> {
-                try {
-                    Logger log = ClassUtils.REFLECTION_LOGGER;
-                    if (log.isDebugEnabled()) {
-                        log.debug("Reflectively instantiating type: {}", type);
-                    }
-                    final Constructor<T> declaredConstructor = type.getDeclaredConstructor(argTypes);
-                    declaredConstructor.setAccessible(true);
-                    return declaredConstructor.newInstance(args);
-                } catch (Throwable e) {
-                    throw new InstantiationException("Could not instantiate type [" + type.getName() + "]: " + e.getMessage(), e);
-                }
-            });
+            return BeanIntrospector.SHARED.findIntrospection(type)
+                .map(bi -> bi.instantiate(args))
+                .orElseGet(() -> instantiateReflectively(type, argTypes, args));
+        } catch (Throwable e) {
+            throw new InstantiationException("Could not instantiate type [" + type.getName() + "]: " + e.getMessage(), e);
+        }
+    }
+
+    /**
+     * Instantiate the given class rethrowing any exceptions as {@link InstantiationException},
+     * only using reflection.
+     *
+     * @param type     The type
+     * @param argTypes The argument types
+     * @param args     The values of arguments
+     * @param <T>      The generic type
+     * @return The instantiated instance
+     * @throws InstantiationException When an error occurs
+     * @since 4.8.0
+     */
+    @NonNull
+    @UsedByGeneratedCode
+    public static <T> T instantiateReflectively(Class<T> type, Class<?>[] argTypes, Object[] args) {
+        try {
+            Logger log = ClassUtils.REFLECTION_LOGGER;
+            if (log.isDebugEnabled()) {
+                log.debug("Reflectively instantiating type: {}", type);
+            }
+            final Constructor<T> declaredConstructor = type.getDeclaredConstructor(argTypes);
+            declaredConstructor.setAccessible(true);
+            return declaredConstructor.newInstance(args);
         } catch (Throwable e) {
             throw new InstantiationException("Could not instantiate type [" + type.getName() + "]: " + e.getMessage(), e);
         }
