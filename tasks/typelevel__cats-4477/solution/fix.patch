diff --git a/.scalafmt.conf b/.scalafmt.conf
index 3942fcccd..355ba4798 100644
--- a/.scalafmt.conf
+++ b/.scalafmt.conf
@@ -1,4 +1,4 @@
-version=3.7.10
+version=3.7.7
 align.openParenCallSite = true
 align.openParenDefnSite = true
 maxColumn = 120
diff --git a/core/src/main/scala-2/src/main/scala/cats/compat/targetName.scala b/core/src/main/scala-2/src/main/scala/cats/compat/targetName.scala
new file mode 100644
index 000000000..44e0e795a
--- /dev/null
+++ b/core/src/main/scala-2/src/main/scala/cats/compat/targetName.scala
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2015 Typelevel
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package cats.compat
+
+import scala.annotation.Annotation
+
+// compat dummy so we can use targetName on scala 3 to get out of bincompat pickles
+private[cats] class targetName(dummy: String) extends Annotation
diff --git a/core/src/main/scala-3/src/main/scala/cats/compat/package.scala b/core/src/main/scala-3/src/main/scala/cats/compat/package.scala
new file mode 100644
index 000000000..1cc8b9ecc
--- /dev/null
+++ b/core/src/main/scala-3/src/main/scala/cats/compat/package.scala
@@ -0,0 +1,26 @@
+/*
+ * Copyright (c) 2015 Typelevel
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of
+ * this software and associated documentation files (the "Software"), to deal in
+ * the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+ * the Software, and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all
+ * copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+ * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+ * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+package cats
+
+package object compat {
+  private[cats] type targetName = scala.annotation.targetName
+}
diff --git a/core/src/main/scala/cats/Align.scala b/core/src/main/scala/cats/Align.scala
index 9bdc4a7a6..8b87faa7e 100644
--- a/core/src/main/scala/cats/Align.scala
+++ b/core/src/main/scala/cats/Align.scala
@@ -145,7 +145,6 @@ object Align extends ScalaVersionSpecificAlignInstances {
   implicit def catsAlignForSortedMap[K]: Align[SortedMap[K, *]] =
     cats.instances.sortedMap.catsStdInstancesForSortedMap[K]
   implicit def catsAlignForEither[A]: Align[Either[A, *]] = cats.instances.either.catsStdInstancesForEither[A]
-  implicit def catsAlignForId: Align[Id] = cats.catsAlignForId
 
   private[cats] def alignWithIterator[A, B, C](fa: Iterable[A], fb: Iterable[B])(f: Ior[A, B] => C): Iterator[C] =
     new Iterator[C] {
diff --git a/core/src/main/scala/cats/Eval.scala b/core/src/main/scala/cats/Eval.scala
index 7834248b3..855551e30 100644
--- a/core/src/main/scala/cats/Eval.scala
+++ b/core/src/main/scala/cats/Eval.scala
@@ -21,8 +21,6 @@
 
 package cats
 
-import org.typelevel.scalaccompat.annotation.uncheckedVariance2
-
 import scala.annotation.tailrec
 
 /**
@@ -104,20 +102,20 @@ sealed abstract class Eval[+A] extends Serializable { self =>
             new Eval.FlatMap[B] {
               type Start = A
               val start = () => c.run(s)
-              val run: (Start => Eval[B]) @uncheckedVariance2 = f
+              val run = f
             }
         }
       case c: Eval.Defer[A] =>
         new Eval.FlatMap[B] {
           type Start = A
           val start = c.thunk
-          val run: (Start => Eval[B]) @uncheckedVariance2 = f
+          val run = f
         }
       case _ =>
         new Eval.FlatMap[B] {
           type Start = A
           val start = () => self
-          val run: (Start => Eval[B]) @uncheckedVariance2 = f
+          val run = f
         }
     }
 
diff --git a/core/src/main/scala/cats/Invariant.scala b/core/src/main/scala/cats/Invariant.scala
index 2728fdd76..4854be5d7 100644
--- a/core/src/main/scala/cats/Invariant.scala
+++ b/core/src/main/scala/cats/Invariant.scala
@@ -25,7 +25,6 @@ import cats.arrow.Arrow
 import cats.kernel._
 
 import cats.kernel.compat.scalaVersionSpecific._
-import org.typelevel.scalaccompat.annotation.targetName3
 import scala.collection.immutable.{Queue, Seq, SortedMap}
 import scala.concurrent.{ExecutionContext, Future}
 import scala.util.Try
@@ -128,7 +127,7 @@ object Invariant extends ScalaVersionSpecificInvariantInstances with InvariantIn
     : Distributive[Id] with Bimonad[Id] with CommutativeMonad[Id] with NonEmptyTraverse[Id] =
     cats.catsInstancesForId
   @deprecated("Added for bincompat", "2.8.0")
-  @targetName3("catsInstancesForId")
+  @cats.compat.targetName("catsInstancesForId")
   private[cats] def catsInstancesForIdCompat2_6_1: Comonad[Id] =
     cats.catsInstancesForId
   implicit def catsMonadErrorForEither[A]: MonadError[Either[A, *], A] =
diff --git a/core/src/main/scala/cats/package.scala b/core/src/main/scala/cats/package.scala
index 2ef2e1aa6..b5e2b52cd 100644
--- a/core/src/main/scala/cats/package.scala
+++ b/core/src/main/scala/cats/package.scala
@@ -152,7 +152,7 @@ package object cats {
     override def index[A](f: Id[A]): Unit => A = (_: Unit) => f
   }
 
-  val catsAlignForId: Align[Id] = new Align[Id] {
+  implicit val catsAlignForId: Align[Id] = new Align[Id] {
     override val functor: Functor[Id] = Functor[Id]
 
     override def align[A, B](fa: Id[A], fb: Id[B]): Id[Ior[A, B]] = Ior.both(fa, fb)
diff --git a/core/src/main/scala/cats/syntax/apply.scala b/core/src/main/scala/cats/syntax/apply.scala
index 868647b5d..df9b7d336 100644
--- a/core/src/main/scala/cats/syntax/apply.scala
+++ b/core/src/main/scala/cats/syntax/apply.scala
@@ -23,7 +23,8 @@ package cats
 package syntax
 
 trait ApplySyntax extends TupleSemigroupalSyntax {
-  implicit final def catsSyntaxApply[F[_], A](fa: F[A])(implicit F: Apply[F]): Apply.Ops[F, A] =
+  @deprecated("Kept for binary compatibility", "2.10.0")
+  final def catsSyntaxApply[F[_], A](fa: F[A], F: Apply[F]): Apply.Ops[F, A] =
     new Apply.Ops[F, A] {
       type TypeClassType = Apply[F]
 
@@ -31,6 +32,12 @@ trait ApplySyntax extends TupleSemigroupalSyntax {
       val typeClassInstance = F
     }
 
+  implicit final def catsSyntaxApplyFABOps[F[_], A, B](fab: F[A => B]): ApplyFABOps[F, A, B] =
+    new ApplyFABOps[F, A, B](fab)
+
+  implicit final def catsSyntaxApplyFABCOps[F[_], A, B, C](ff: F[(A, B) => C]): ApplyFABCOps[F, A, B, C] =
+    new ApplyFABCOps[F, A, B, C](ff)
+
   implicit final def catsSyntaxApplyOps[F[_], A](fa: F[A]): ApplyOps[F, A] =
     new ApplyOps(fa)
 }
@@ -40,6 +47,73 @@ private[syntax] trait ApplySyntaxBinCompat0 {
     new IfApplyOps[F](fa)
 }
 
+final class ApplyFABOps[F[_], A, B](private val fab: F[A => B]) extends AnyVal {
+
+  /**
+   * @see [[Apply.ap]].
+   * 
+   * Example:
+   * {{{
+   * scala> import cats.syntax.all._
+   *
+   * scala> val someF: Option[Int => Long] = Some(_.toLong + 1L)
+   * scala> val noneF: Option[Int => Long] = None
+   * scala> val someInt: Option[Int] = Some(3)
+   * scala> val noneInt: Option[Int] = None
+   *
+   * scala> someF.ap(someInt)
+   * res0: Option[Long] = Some(4)
+   *
+   * scala> noneF.ap(someInt)
+   * res1: Option[Long] = None
+   *
+   * scala> someF.ap(noneInt)
+   * res2: Option[Long] = None
+   *
+   * scala> noneF.ap(noneInt)
+   * res3: Option[Long] = None
+   * }}}
+   */
+  def ap(fa: F[A])(implicit F: Apply[F]): F[B] = F.ap(fab)(fa)
+
+  /**
+   * Alias for [[ap]].
+   */
+  def <*>(fa: F[A])(implicit F: Apply[F]): F[B] = F.<*>[A, B](fab)(fa)
+}
+
+final class ApplyFABCOps[F[_], A, B, C](private val ff: F[(A, B) => C]) extends AnyVal {
+
+  /**
+   * @see [[Apply.ap2]].
+   * 
+   * Example:
+   * {{{
+   * scala> import cats.syntax.all._
+   *
+   * scala> val someF: Option[(Int, Int) => Long] = Some((a, b) => (a + b).toLong)
+   * scala> val noneF: Option[(Int, Int) => Long] = None
+   * scala> val someInt1: Option[Int] = Some(3)
+   * scala> val someInt2: Option[Int] = Some(2)
+   * scala> val noneInt: Option[Int] = None
+   *
+   * scala> someF.ap2(someInt1, someInt2)
+   * res0: Option[Long] = Some(5)
+   *
+   * scala> noneF.ap2(someInt1, someInt2)
+   * res1: Option[Long] = None
+   *
+   * scala> someF.ap2(noneInt, noneInt)
+   * res2: Option[Long] = None
+   *
+   * scala> noneF.ap2(noneInt, noneInt)
+   * res3: Option[Long] = None
+   * }}}
+   * 
+   */
+  def ap2(fa: F[A], fb: F[B])(implicit F: Apply[F]): F[C] = F.ap2(ff)(fa, fb)
+}
+
 final class IfApplyOps[F[_]](private val fcond: F[Boolean]) extends AnyVal {
 
   @deprecated("Dangerous method, use ifM (a flatMap) or ifF (a map) instead", "2.6.2")
@@ -61,4 +135,122 @@ final class ApplyOps[F[_], A](private val fa: F[A]) extends AnyVal {
   @deprecated("Use <* or productL instead.", "1.0.0-RC2")
   @inline private[syntax] def forEffect[B](fb: F[B])(implicit F: Apply[F]): F[A] =
     F.productL(fa)(fb)
+
+  /**
+   * @see [[Apply.productR]].
+   * 
+   * Example:
+   * {{{
+   * scala> import cats.syntax.all._
+   * scala> import cats.data.Validated
+   * scala> import Validated.{Valid, Invalid}
+   *
+   * scala> type ErrOr[A] = Validated[String, A]
+   *
+   * scala> val validInt: ErrOr[Int] = Valid(3)
+   * scala> val validBool: ErrOr[Boolean] = Valid(true)
+   * scala> val invalidInt: ErrOr[Int] = Invalid("Invalid int.")
+   * scala> val invalidBool: ErrOr[Boolean] = Invalid("Invalid boolean.")
+   *
+   * scala> validInt.productR(validBool)
+   * res0: ErrOr[Boolean] = Valid(true)
+   *
+   * scala> invalidInt.productR(validBool)
+   * res1: ErrOr[Boolean] = Invalid(Invalid int.)
+   *
+   * scala> validInt.productR(invalidBool)
+   * res2: ErrOr[Boolean] = Invalid(Invalid boolean.)
+   *
+   * scala> invalidInt.productR(invalidBool)
+   * res3: ErrOr[Boolean] = Invalid(Invalid int.Invalid boolean.)
+   * }}}    
+   */
+  def productR[B](fb: F[B])(implicit F: Apply[F]): F[B] = F.productR(fa)(fb)
+
+  /**
+   * @see [[Apply.productL]].
+   * 
+   * Example:
+   * {{{
+   * scala> import cats.syntax.all._
+   * scala> import cats.data.Validated
+   * scala> import Validated.{Valid, Invalid}
+   *
+   * scala> type ErrOr[A] = Validated[String, A]
+   *
+   * scala> val validInt: ErrOr[Int] = Valid(3)
+   * scala> val validBool: ErrOr[Boolean] = Valid(true)
+   * scala> val invalidInt: ErrOr[Int] = Invalid("Invalid int.")
+   * scala> val invalidBool: ErrOr[Boolean] = Invalid("Invalid boolean.")
+   *
+   * scala> validInt.productL(validBool)
+   * res0: ErrOr[Int] = Valid(3)
+   *
+   * scala> invalidInt.productL(validBool)
+   * res1: ErrOr[Int] = Invalid(Invalid int.)
+   *
+   * scala> validInt.productL(invalidBool)
+   * res2: ErrOr[Int] = Invalid(Invalid boolean.)
+   *
+   * scala> invalidInt.productL(invalidBool)
+   * res3: ErrOr[Int] = Invalid(Invalid int.Invalid boolean.)
+   * }}}    
+   */
+  def productL[B](fb: F[B])(implicit F: Apply[F]): F[A] = F.productL(fa)(fb)
+
+  /**
+   * Alias for [[productR]].
+   */
+  def *>[B](fb: F[B])(implicit F: Apply[F]): F[B] = F.*>(fa)(fb)
+
+  /**
+   * Alias for [[productL]].
+   */
+  def <*[B](fb: F[B])(implicit F: Apply[F]): F[A] = F.<*(fa)(fb)
+
+  /**
+   * @see [[Apply.map2]].
+   * 
+   * Example:
+   * {{{
+   * scala> import cats.syntax.all._
+   *
+   * scala> val someInt: Option[Int] = Some(3)
+   * scala> val noneInt: Option[Int] = None
+   * scala> val someLong: Option[Long] = Some(4L)
+   * scala> val noneLong: Option[Long] = None
+   *
+   * scala> someInt.map2(someLong)((i, l) => i.toString + l.toString)
+   * res0: Option[String] = Some(34)
+   *
+   * scala> someInt.map2(noneLong)((i, l) => i.toString + l.toString)
+   * res0: Option[String] = None
+   *
+   * scala> noneInt.map2(noneLong)((i, l) => i.toString + l.toString)
+   * res0: Option[String] = None
+   *
+   * scala> noneInt.map2(someLong)((i, l) => i.toString + l.toString)
+   * res0: Option[String] = None
+   * }}} 
+   */
+  def map2[B, C](fb: F[B])(f: (A, B) => C)(implicit F: Apply[F]): F[C] =
+    F.map2(fa, fb)(f)
+
+  /**
+   * @see [[Apply.map2Eval]].
+   * 
+   * Example:
+   * {{{
+   * scala> import cats.{Eval, Later}
+   * scala> import cats.syntax.all._
+   * 
+   * scala> val bomb: Eval[Option[Int]] = Later(sys.error("boom"))
+   * scala> val x: Option[Int] = None
+   * 
+   * scala> x.map2Eval(bomb)(_ + _).value
+   * res0: Option[Int] = None
+   * }}} 
+   */
+  def map2Eval[B, C](fb: Eval[F[B]])(f: (A, B) => C)(implicit F: Apply[F]): Eval[F[C]] =
+    F.map2Eval(fa, fb)(f)
 }
diff --git a/core/src/main/scala/cats/syntax/contravariantMonoidal.scala b/core/src/main/scala/cats/syntax/contravariantMonoidal.scala
index 0253d1c18..ab5b76c75 100644
--- a/core/src/main/scala/cats/syntax/contravariantMonoidal.scala
+++ b/core/src/main/scala/cats/syntax/contravariantMonoidal.scala
@@ -25,9 +25,11 @@ package syntax
 import cats.ContravariantMonoidal
 
 trait ContravariantMonoidalSyntax {
-  implicit final def catsSyntaxContravariantMonoidal[F[_], A](
-    fa: F[A]
-  )(implicit F: ContravariantMonoidal[F]): ContravariantMonoidalOps[F, A] =
+  @deprecated("Kept for binary compatibility", "2.10.0")
+  final def catsSyntaxContravariantMonoidal[F[_], A](
+    fa: F[A],
+    F: ContravariantMonoidal[F]
+  ): ContravariantMonoidalOps[F, A] =
     new ContravariantMonoidalOps[F, A] {
       type TypeClassType = ContravariantMonoidal[F]
 
diff --git a/core/src/main/scala/cats/syntax/contravariantSemigroupal.scala b/core/src/main/scala/cats/syntax/contravariantSemigroupal.scala
index 688a279ca..29d92a4d2 100644
--- a/core/src/main/scala/cats/syntax/contravariantSemigroupal.scala
+++ b/core/src/main/scala/cats/syntax/contravariantSemigroupal.scala
@@ -25,9 +25,11 @@ package syntax
 import cats.ContravariantSemigroupal
 
 trait ContravariantSemigroupalSyntax extends TupleSemigroupalSyntax {
-  implicit final def catsSyntaxContravariantSemigroupal[F[_], A](
-    fa: F[A]
-  )(implicit F: ContravariantSemigroupal[F]): ContravariantSemigroupal.Ops[F, A] =
+  @deprecated("Kept for binary compatibility", "2.10.0")
+  final def catsSyntaxContravariantSemigroupal[F[_], A](
+    fa: F[A],
+    F: ContravariantSemigroupal[F]
+  ): ContravariantSemigroupal.Ops[F, A] =
     new ContravariantSemigroupal.Ops[F, A] {
       type TypeClassType = ContravariantSemigroupal[F]
 
diff --git a/core/src/main/scala/cats/syntax/semigroupal.scala b/core/src/main/scala/cats/syntax/semigroupal.scala
index bd53dbd7e..e80bd78fd 100644
--- a/core/src/main/scala/cats/syntax/semigroupal.scala
+++ b/core/src/main/scala/cats/syntax/semigroupal.scala
@@ -23,13 +23,52 @@ package cats
 package syntax
 
 trait SemigroupalSyntax {
-  implicit final def catsSyntaxSemigroupal[F[_], A](fa: F[A])(implicit F: Semigroupal[F]): SemigroupalOps[F, A] =
+  @deprecated("Use `catsSyntaxSemigroupalOps2`", "2.10.0")
+  final def catsSyntaxSemigroupal[F[_], A](fa: F[A], F: Semigroupal[F]): SemigroupalOps[F, A] =
     new SemigroupalOps[F, A] {
       type TypeClassType = Semigroupal[F]
 
       val self = fa
       val typeClassInstance = F
     }
+
+  implicit def catsSyntaxSemigroupalOps2[F[_], A](fa: F[A]): SemigroupalOps2[F, A] =
+    new SemigroupalOps2[F, A](fa)
+
+}
+
+final class SemigroupalOps2[F[_], A](private val fa: F[A]) extends AnyVal {
+
+  /**
+   * @see [[Semigroupal.product]]
+   *
+   * Example:
+   * {{{
+   * scala> import cats.syntax.all._
+   *
+   * scala> val noneInt: Option[Int] = None
+   * scala> val some3: Option[Int] = Some(3)
+   * scala> val noneString: Option[String] = None
+   * scala> val someFoo: Option[String] = Some("foo")
+   *
+   * scala> noneInt.product(noneString)
+   * res0: Option[(Int, String)] = None
+   *
+   * scala> noneInt.product(someFoo)
+   * res1: Option[(Int, String)] = None
+   *
+   * scala> some3.product(noneString)
+   * res2: Option[(Int, String)] = None
+   *
+   * scala> some3.product(someFoo)
+   * res3: Option[(Int, String)] = Some((3,foo))
+   * }}}
+   */
+  def product[B](fb: F[B])(implicit F: Semigroupal[F]): F[(A, B)] = F.product(fa, fb)
+
+  @deprecated("Replaced by an apply syntax, e.g. instead of (a |@| b).map(...) use (a, b).mapN(...)", "1.0.0-MF")
+  def |@|[B](fb: F[B]): SemigroupalBuilder[F]#SemigroupalBuilder2[A, B] =
+    new SemigroupalBuilder[F] |@| fa |@| fb
 }
 
 abstract class SemigroupalOps[F[_], A] extends Semigroupal.Ops[F, A] {
diff --git a/docs/faq.md b/docs/faq.md
index 395b7473e..164a06aef 100644
--- a/docs/faq.md
+++ b/docs/faq.md
@@ -25,9 +25,9 @@ Please refer to the [jump start guide](jump_start_guide.md).
 
 ## What is the difference between Cats and Scalaz?
 
-Cats and [Scalaz](https://github.com/scalaz/scalaz) have the same goal: to facilitate pure functional programming in Scala applications. However the underlying core strategy is different; Scalaz took the approach of trying to provide a single batteries-included *standard library* for FP that powers the Scala applications. Cats, on the other hand, aims to help build an [ecosystem](typelevelEcosystem.md) of pure FP libraries by providing a solid and stable foundation; these libraries can have their own styles and personalities, competing with each other, while at the same time playing nice. It is through this ecosystem of FP libraries (cats included) that Scala applications can be powered with "FP awesome-ness" and beyond by picking whatever best fit their needs.
+Cats and [Scalaz](https://github.com/scalaz/scalaz) have the same goal: to facilitate pure functional programming in Scala applications. However the underlying core strategy is different; Scalaz took the approach of trying to provide a single batteries-included *standard library* for FP that powers the Scala applications. Cats, on the other hand, aims to help build an [ecosystem](/cats/#ecosystem) of pure FP libraries by providing a solid and stable foundation; these libraries can have their own styles and personalities, competing with each other, while at the same time playing nice. It is through this ecosystem of FP libraries (cats included) that Scala applications can be powered with "FP awesome-ness" and beyond by picking whatever best fit their needs.
 
-Based on this core strategy, Cats takes a [modular](motivations.md#modularity) approach and focuses on providing core, [binary compatible](index.md#binary-compatibility-and-versioning), [approachable](motivations.md#approachability) and [efficient](motivations.md#efficiency) abstractions. It provides a welcoming and supportive environment for the [user community](https://discord.gg/XF3CXcMzqD) governed by the [Scala Code of Conduct](https://www.scala-lang.org/conduct/). It also takes great effort in supplying a comprehensive and beginner-friendly [documentation](motivations.md#documentation).
+Based on this core strategy, Cats takes a [modular](/cats/motivations#modularity) approach and focuses on providing core, [binary compatible](/cats/#binary-compatibility-and-versioning), [approachable](/cats/motivations#approachability) and [efficient](/cats/motivations#efficiency) abstractions. It provides a welcoming and supportive environment for the [user community](https://discord.gg/XF3CXcMzqD) governed by the [Scala Code of Conduct](https://www.scala-lang.org/conduct/). It also takes great effort in supplying a comprehensive and beginner-friendly [documentation](/cats/#documentation).
 
 ## Where is right-biased Either?
 Up through Cats 0.7.x we had `cats.data.Xor`, which was effectively `scala.util.Either`, but right-biased by default and with
diff --git a/docs/typeclasses/alternative.md b/docs/typeclasses/alternative.md
index 10291d592..f5a052578 100644
--- a/docs/typeclasses/alternative.md
+++ b/docs/typeclasses/alternative.md
@@ -77,7 +77,7 @@ object Decoder {
 Then, we can implement an `Alternative` instance for this type like so:
 
 ```scala mdoc:silent
-implicit val decoderAlternative: Alternative[Decoder] = new Alternative[Decoder] {
+implicit val decoderAlternative = new Alternative[Decoder] {
   def pure[A](a: A) = Decoder.from(Function.const(Right(a)))
 
   def empty[A] = Decoder.from(Function.const(Left(new Error("No dice."))))
diff --git a/docs/typeclasses/bimonad.md b/docs/typeclasses/bimonad.md
index b8423b681..a84d4b29c 100644
--- a/docs/typeclasses/bimonad.md
+++ b/docs/typeclasses/bimonad.md
@@ -27,7 +27,7 @@ import cats._
 import cats.data._
 import cats.syntax.all._
 
-implicit val nelBimonad: Bimonad[NonEmptyList] =
+implicit val nelBimonad =
   new Bimonad[NonEmptyList] {
 
     // in order to have a lawful bimonad `pure` and `extract` need to respect: `nelBimonad.extract(nelBimonad.pure(a)) <-> a`
diff --git a/docs/typeclasses/monad.md b/docs/typeclasses/monad.md
index 080f0a398..0caf105ad 100644
--- a/docs/typeclasses/monad.md
+++ b/docs/typeclasses/monad.md
@@ -31,7 +31,7 @@ the identity function `x => x` (i.e. `flatMap(_)(x => x)`).
 ```scala mdoc:silent
 import cats._
 
-implicit def optionMonad(implicit app: Applicative[Option]): Monad[Option] =
+implicit def optionMonad(implicit app: Applicative[Option]) =
   new Monad[Option] {
     // Define flatMap using Option's flatten method
     override def flatMap[A, B](fa: Option[A])(f: A => Option[B]): Option[B] =
@@ -88,7 +88,7 @@ and therefore stack safe implementation of `tailRecM`.
 import cats.Monad
 import scala.annotation.tailrec
 
-implicit val optionMonad: Monad[Option] = new Monad[Option] {
+implicit val optionMonad = new Monad[Option] {
   def flatMap[A, B](fa: Option[A])(f: A => Option[B]): Option[B] = fa.flatMap(f)
   def pure[A](a: A): Option[A] = Some(a)
 
diff --git a/docs/typelevelEcosystem.md b/docs/typelevelEcosystem.md
index d5f6ab059..d7ad0f5a1 100644
--- a/docs/typelevelEcosystem.md
+++ b/docs/typelevelEcosystem.md
@@ -42,7 +42,7 @@ Here you can find a comprehensive list of libraries and projects related to Type
 | [epimetheus-http4s](https://github.com/davenverse/epimetheus-http4s)                                                       | Prometheus Http4s Metrics Middleware and Push Gateway Support.                                                                                                                                                                                                                                                                                                                                                                                              |
 | [epimetheus-log4cats](https://github.com/davenverse/epimetheus-log4cats)                                                   | Prometheus Logging Metrics.                                                                                                                                                                                                                                                                                                                                                                                                                                 |
 | [epimetheus-redis4cats](https://github.com/davenverse/epimetheus-redis4cats)                                               | Prometheus Redis4cats Metrics.                                                                                                                                                                                                                                                                                                                                                                                                                              |
-| [epimetheus](https://davenverse.github.io/epimetheus/)                                                                     | Prometheus Core Representations.                                                                                                                                                                                                                                                                                                                                                                                                                           |
+| [epimetheus](https://davenverse.github.io/epimetheus/)                                                                     | Prometheus Core Reperesentations.                                                                                                                                                                                                                                                                                                                                                                                                                           |
 | [extruder](https://janstenpickle.github.io/extruder/)                                                                      | Populate case classes from any data source.                                                                                                                                                                                                                                                                                                                                                                                                                |
 | [fastparse-cats](https://github.com/johnynek/fastparse-cats)                                                               | [Cats][Cats] Monad and Alternative instances for [fastparse](https://com-lihaoyi.github.io/fastparse/).                                                                                                                                                                                                                                                                                                                                                    |
 | [fd4s/fs2-kafka](https://fd4s.github.io/fs2-kafka/)                                                                        | Functional [Kafka][Kafka] Streams for Scala.                                                                                                                                                                                                                                                                                                                                                                                                               |
diff --git a/mima.sbt b/mima.sbt
index 7b37117e5..6581068fe 100644
--- a/mima.sbt
+++ b/mima.sbt
@@ -148,14 +148,15 @@ ThisBuild / mimaBinaryIssueFilters ++= {
     ) ++ // https://github.com/typelevel/cats/pull/4315
     Seq(
       exclude[MissingClassProblem]("cats.compat.compat$package"),
-      exclude[MissingClassProblem]("cats.compat.compat$package$"),
-      ProblemFilters.exclude[MissingClassProblem]("cats.compat.targetName")
-    ) ++ // scala 3 specific filters
+      exclude[MissingClassProblem]("cats.compat.compat$package$")
+    )
+}
+
+ThisBuild / mimaBinaryIssueFilters ++= {
+  if (tlIsScala3.value)
     Seq(
       exclude[DirectMissingMethodProblem]("cats.free.ContravariantCoyoneda.unsafeApply"),
       exclude[DirectMissingMethodProblem]("cats.free.Coyoneda.unsafeApply")
-    ) ++ Seq(
-      ProblemFilters.exclude[MissingClassProblem]("cats.compat.package"),
-      ProblemFilters.exclude[MissingClassProblem]("cats.compat.package$")
     )
+  else Nil
 }
diff --git a/project/build.properties b/project/build.properties
index 52413ab79..875b706a8 100644
--- a/project/build.properties
+++ b/project/build.properties
@@ -1 +1 @@
-sbt.version=1.9.3
+sbt.version=1.9.2
diff --git a/project/plugins.sbt b/project/plugins.sbt
index 1372fd661..c8c741485 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -1,8 +1,9 @@
-val sbtTypelevelVersion = "0.5.0-RC7"
+val sbtTypelevelVersion = "0.4.22"
 addSbtPlugin("org.typelevel" % "sbt-typelevel" % sbtTypelevelVersion)
 addSbtPlugin("org.typelevel" % "sbt-typelevel-site" % sbtTypelevelVersion)
 addSbtPlugin("pl.project13.scala" % "sbt-jmh" % "0.4.5")
 addSbtPlugin("com.github.tkawachi" % "sbt-doctest" % "0.10.0")
+addSbtPlugin("org.portable-scala" % "sbt-scala-native-crossproject" % "1.3.2")
 addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.13.2")
 addSbtPlugin("org.scala-native" % "sbt-scala-native" % "0.4.14")
 addSbtPlugin("com.eed3si9n" % "sbt-buildinfo" % "0.11.0")
diff --git a/scalafix/project/build.properties b/scalafix/project/build.properties
index 52413ab79..875b706a8 100644
--- a/scalafix/project/build.properties
+++ b/scalafix/project/build.properties
@@ -1 +1 @@
-sbt.version=1.9.3
+sbt.version=1.9.2
