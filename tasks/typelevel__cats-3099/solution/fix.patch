diff --git a/.travis.yml b/.travis.yml
index 92e6f8271..197533c80 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -11,7 +11,7 @@ jdk:
   - openjdk8
 
 
-scala_version_212: &scala_version_212 2.12.9
+scala_version_212: &scala_version_212 2.12.10
 scala_version_213: &scala_version_213 2.13.0
 
 before_install:
diff --git a/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala b/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
index 55ab7e7de..e43b11f7c 100644
--- a/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
+++ b/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
@@ -3,70 +3,30 @@ package instances
 
 import cats.data._
 import cats.kernel.Semigroup
-import cats.syntax.either._
-import cats.{~>, Applicative, Apply, FlatMap, Monad, NonEmptyParallel, Parallel}
+import cats.{NonEmptyParallel, Parallel}
 
 trait ParallelInstances extends ParallelInstances1 {
-  implicit def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
-    new Parallel[Either[E, *]] {
-      type F[x] = Validated[E, x]
 
-      def applicative: Applicative[Validated[E, *]] = Validated.catsDataApplicativeErrorForValidated
-      def monad: Monad[Either[E, *]] = cats.instances.either.catsStdInstancesForEither
-
-      def sequential: Validated[E, *] ~> Either[E, *] =
-        λ[Validated[E, *] ~> Either[E, *]](_.toEither)
-
-      def parallel: Either[E, *] ~> Validated[E, *] =
-        λ[Either[E, *] ~> Validated[E, *]](_.toValidated)
-    }
+  @deprecated("Use cats.instances.either.catsParallelForEitherAndValidated", "2.1.0")
+  def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
+    cats.instances.either.catsParallelForEitherAndValidated[E]
 
   @deprecated("Use OptionT.catsDataParallelForOptionT", "2.0.0")
   def catsParallelForOptionTNestedOption[M[_]](
     implicit P: Parallel[M]
   ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = OptionT.catsDataParallelForOptionT[M]
 
-  implicit def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
-    new NonEmptyParallel[List] {
-      type F[x] = ZipList[x]
-
-      def flatMap: FlatMap[List] = cats.instances.list.catsStdInstancesForList
-      def apply: Apply[ZipList] = ZipList.catsDataCommutativeApplyForZipList
-
-      def sequential: ZipList ~> List =
-        λ[ZipList ~> List](_.value)
-
-      def parallel: List ~> ZipList =
-        λ[List ~> ZipList](v => new ZipList(v))
-    }
-
-  implicit def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
-    new NonEmptyParallel[Vector] {
-      type F[x] = ZipVector[x]
-
-      def flatMap: FlatMap[Vector] = cats.instances.vector.catsStdInstancesForVector
-      def apply: Apply[ZipVector] = ZipVector.catsDataCommutativeApplyForZipVector
-
-      def sequential: ZipVector ~> Vector =
-        λ[ZipVector ~> Vector](_.value)
-
-      def parallel: Vector ~> ZipVector =
-        λ[Vector ~> ZipVector](v => new ZipVector(v))
-    }
-
-  implicit def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
-    new Parallel[Stream] {
-      type F[x] = ZipStream[x]
-
-      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
-      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
+  @deprecated("Use cats.instances.list.catsStdNonEmptyParallelForListZipList", "2.1.0")
+  def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
+    cats.instances.list.catsStdNonEmptyParallelForListZipList
 
-      def sequential: ZipStream ~> Stream =
-        λ[ZipStream ~> Stream](_.value)
+  @deprecated("Use cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector", "2.1.0")
+  def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
+    cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector
 
-      def parallel: Stream ~> ZipStream =
-        λ[Stream ~> ZipStream](v => new ZipStream(v))
-    }
+  @deprecated("Use cats.instances.stream.catsStdParallelForStreamZipStream", "2.1.0")
+  def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
+    cats.instances.stream.catsStdParallelForStreamZipStream
 
   @deprecated("Use EitherT.catsDataParallelForEitherTWithParallelEffect", "2.0.0")
   def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](
diff --git a/core/src/main/scala-2.12/cats/instances/stream.scala b/core/src/main/scala-2.12/cats/instances/stream.scala
index de0fcbbf8..67d4db6e1 100644
--- a/core/src/main/scala-2.12/cats/instances/stream.scala
+++ b/core/src/main/scala-2.12/cats/instances/stream.scala
@@ -1,6 +1,7 @@
 package cats
 package instances
 
+import cats.data.ZipStream
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -157,6 +158,19 @@ trait StreamInstances extends cats.kernel.instances.StreamInstances {
       def show(fa: Stream[A]): String = if (fa.isEmpty) "Stream()" else s"Stream(${fa.head.show}, ?)"
     }
 
+  implicit def catsStdParallelForStreamZipStream: Parallel.Aux[Stream, ZipStream] =
+    new Parallel[Stream] {
+      type F[x] = ZipStream[x]
+
+      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
+      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
+
+      def sequential: ZipStream ~> Stream =
+        λ[ZipStream ~> Stream](_.value)
+
+      def parallel: Stream ~> ZipStream =
+        λ[Stream ~> ZipStream](v => new ZipStream(v))
+    }
 }
 
 private[instances] trait StreamInstancesBinCompat0 {
diff --git a/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala b/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
index ae37f968f..f3c16fcaa 100644
--- a/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
+++ b/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
@@ -3,85 +3,35 @@ package instances
 
 import cats.data._
 import cats.kernel.Semigroup
-import cats.syntax.either._
-import cats.{~>, Applicative, Apply, FlatMap, Monad, NonEmptyParallel, Parallel}
+import cats.data.ZipLazyList
+import cats.{NonEmptyParallel, Parallel}
 
 trait ParallelInstances extends ParallelInstances1 {
-  implicit def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
-    new Parallel[Either[E, *]] {
-      type F[x] = Validated[E, x]
 
-      def applicative: Applicative[Validated[E, *]] = Validated.catsDataApplicativeErrorForValidated
-      def monad: Monad[Either[E, *]] = cats.instances.either.catsStdInstancesForEither
-
-      def sequential: Validated[E, *] ~> Either[E, *] =
-        λ[Validated[E, *] ~> Either[E, *]](_.toEither)
-
-      def parallel: Either[E, *] ~> Validated[E, *] =
-        λ[Either[E, *] ~> Validated[E, *]](_.toValidated)
-    }
+  @deprecated("Use cats.instances.either.catsParallelForEitherAndValidated", "2.1.0")
+  def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
+    cats.instances.either.catsParallelForEitherAndValidated[E]
 
   @deprecated("Use OptionT.catsDataParallelForOptionT", "2.0.0")
   def catsParallelForOptionTNestedOption[M[_]](
     implicit P: Parallel[M]
   ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = OptionT.catsDataParallelForOptionT[M]
 
-  implicit def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
-    new NonEmptyParallel[List] {
-      type F[x] = ZipList[x]
-
-      def flatMap: FlatMap[List] = cats.instances.list.catsStdInstancesForList
-      def apply: Apply[ZipList] = ZipList.catsDataCommutativeApplyForZipList
-
-      def sequential: ZipList ~> List =
-        λ[ZipList ~> List](_.value)
-
-      def parallel: List ~> ZipList =
-        λ[List ~> ZipList](v => new ZipList(v))
-    }
-
-  implicit def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
-    new NonEmptyParallel[Vector] {
-      type F[x] = ZipVector[x]
-
-      def flatMap: FlatMap[Vector] = cats.instances.vector.catsStdInstancesForVector
-      def apply: Apply[ZipVector] = ZipVector.catsDataCommutativeApplyForZipVector
+  @deprecated("Use cats.instances.list.catsStdNonEmptyParallelForListZipList", "2.1.0")
+  def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
+    cats.instances.list.catsStdNonEmptyParallelForListZipList
 
-      def sequential: ZipVector ~> Vector =
-        λ[ZipVector ~> Vector](_.value)
-
-      def parallel: Vector ~> ZipVector =
-        λ[Vector ~> ZipVector](v => new ZipVector(v))
-    }
+  @deprecated("Use cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector", "2.1.0")
+  def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
+    cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector
 
   @deprecated("Use catsStdParallelForZipLazyList", "2.0.0-RC2")
-  implicit def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
-    new Parallel[Stream] {
-      type F[x] = ZipStream[x]
-
-      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
-      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
-
-      def sequential: ZipStream ~> Stream =
-        λ[ZipStream ~> Stream](_.value)
-
-      def parallel: Stream ~> ZipStream =
-        λ[Stream ~> ZipStream](v => new ZipStream(v))
-    }
-
-  implicit def catsStdParallelForZipLazyList[A]: Parallel.Aux[LazyList, ZipLazyList] =
-    new Parallel[LazyList] {
-      type F[x] = ZipLazyList[x]
-
-      def monad: Monad[LazyList] = cats.instances.lazyList.catsStdInstancesForLazyList
-      def applicative: Applicative[ZipLazyList] = ZipLazyList.catsDataAlternativeForZipLazyList
-
-      def sequential: ZipLazyList ~> LazyList =
-        λ[ZipLazyList ~> LazyList](_.value)
+  def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
+    cats.instances.stream.catsStdParallelForStreamZipStream
 
-      def parallel: LazyList ~> ZipLazyList =
-        λ[LazyList ~> ZipLazyList](v => new ZipLazyList(v))
-    }
+  @deprecated("Use cats.instances.lazyList.catsStdParallelForLazyListZipLazyList", "2.1.0")
+  def catsStdParallelForZipLazyList[A]: Parallel.Aux[LazyList, ZipLazyList] =
+    cats.instances.lazyList.catsStdParallelForLazyListZipLazyList[A]
 
   @deprecated("Use EitherT.catsDataParallelForEitherTWithParallelEffect", "2.0.0")
   def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](
diff --git a/core/src/main/scala-2.13+/cats/instances/lazyList.scala b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
index 1d55cb8c2..6c4e08354 100644
--- a/core/src/main/scala-2.13+/cats/instances/lazyList.scala
+++ b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
@@ -1,13 +1,14 @@
 package cats
 package instances
+
 import cats.kernel
 import cats.syntax.show._
+import cats.data.ZipLazyList
 
 import scala.annotation.tailrec
 
 trait LazyListInstances extends cats.kernel.instances.LazyListInstances {
-  implicit val catsStdInstancesForLazyList
-    : Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] =
+  implicit val catsStdInstancesForLazyList: Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] =
     new Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] {
 
       def empty[A]: LazyList[A] = LazyList.empty
@@ -155,4 +156,18 @@ trait LazyListInstances extends cats.kernel.instances.LazyListInstances {
         .value
 
   }
+
+  implicit def catsStdParallelForLazyListZipLazyList[A]: Parallel.Aux[LazyList, ZipLazyList] =
+    new Parallel[LazyList] {
+      type F[x] = ZipLazyList[x]
+
+      def monad: Monad[LazyList] = cats.instances.lazyList.catsStdInstancesForLazyList
+      def applicative: Applicative[ZipLazyList] = ZipLazyList.catsDataAlternativeForZipLazyList
+
+      def sequential: ZipLazyList ~> LazyList =
+        λ[ZipLazyList ~> LazyList](_.value)
+
+      def parallel: LazyList ~> ZipLazyList =
+        λ[LazyList ~> ZipLazyList](v => new ZipLazyList(v))
+    }
 }
diff --git a/core/src/main/scala-2.13+/cats/instances/stream.scala b/core/src/main/scala-2.13+/cats/instances/stream.scala
index 68844aa79..df1c6feae 100644
--- a/core/src/main/scala-2.13+/cats/instances/stream.scala
+++ b/core/src/main/scala-2.13+/cats/instances/stream.scala
@@ -1,6 +1,7 @@
 package cats
 package instances
 
+import cats.data.ZipStream
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -8,8 +9,7 @@ import scala.annotation.tailrec
 trait StreamInstances extends cats.kernel.instances.StreamInstances {
 
   @deprecated("Use cats.instances.lazyList", "2.0.0-RC2")
-  implicit val catsStdInstancesForStream
-    : Traverse[Stream] with Alternative[Stream] with Monad[Stream] with CoflatMap[Stream] =
+  implicit val catsStdInstancesForStream: Traverse[Stream] with Alternative[Stream] with Monad[Stream] with CoflatMap[Stream] =
     new Traverse[Stream] with Alternative[Stream] with Monad[Stream] with CoflatMap[Stream] {
 
       def empty[A]: Stream[A] = Stream.Empty
@@ -159,6 +159,20 @@ trait StreamInstances extends cats.kernel.instances.StreamInstances {
       def show(fa: Stream[A]): String = if (fa.isEmpty) "Stream()" else s"Stream(${fa.head.show}, ?)"
     }
 
+  @deprecated("Use catsStdParallelForZipLazyList", "2.0.0-RC2")
+  implicit val catsStdParallelForStreamZipStream: Parallel.Aux[Stream, ZipStream] =
+    new Parallel[Stream] {
+      type F[x] = ZipStream[x]
+
+      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
+      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
+
+      def sequential: ZipStream ~> Stream =
+        λ[ZipStream ~> Stream](_.value)
+
+      def parallel: Stream ~> ZipStream =
+        λ[Stream ~> ZipStream](v => new ZipStream(v))
+    }
 }
 
 private[instances] trait StreamInstancesBinCompat0 {
diff --git a/core/src/main/scala/cats/instances/either.scala b/core/src/main/scala/cats/instances/either.scala
index 572b5df3c..ff2025a14 100644
--- a/core/src/main/scala/cats/instances/either.scala
+++ b/core/src/main/scala/cats/instances/either.scala
@@ -1,8 +1,11 @@
 package cats
 package instances
 
+import cats.data.Validated
+import cats.kernel.Semigroup
 import cats.syntax.EitherUtil
 import cats.syntax.either._
+
 import scala.annotation.tailrec
 
 trait EitherInstances extends cats.kernel.instances.EitherInstances {
@@ -158,4 +161,18 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
           case Right(b) => "Right(" + B.show(b) + ")"
         }
     }
+
+  implicit def catsParallelForEitherAndValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
+    new Parallel[Either[E, *]] {
+      type F[x] = Validated[E, x]
+
+      def applicative: Applicative[Validated[E, *]] = Validated.catsDataApplicativeErrorForValidated
+      def monad: Monad[Either[E, *]] = cats.instances.either.catsStdInstancesForEither
+
+      def sequential: Validated[E, *] ~> Either[E, *] =
+        λ[Validated[E, *] ~> Either[E, *]](_.toEither)
+
+      def parallel: Either[E, *] ~> Validated[E, *] =
+        λ[Either[E, *] ~> Validated[E, *]](_.toValidated)
+    }
 }
diff --git a/core/src/main/scala/cats/instances/list.scala b/core/src/main/scala/cats/instances/list.scala
index 975fa1451..d93cadfaf 100644
--- a/core/src/main/scala/cats/instances/list.scala
+++ b/core/src/main/scala/cats/instances/list.scala
@@ -1,6 +1,7 @@
 package cats
 package instances
 
+import cats.data.ZipList
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -150,6 +151,20 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
       def show(fa: List[A]): String =
         fa.iterator.map(_.show).mkString("List(", ", ", ")")
     }
+
+  implicit def catsStdNonEmptyParallelForListZipList: NonEmptyParallel.Aux[List, ZipList] =
+    new NonEmptyParallel[List] {
+      type F[x] = ZipList[x]
+
+      def flatMap: FlatMap[List] = cats.instances.list.catsStdInstancesForList
+      def apply: Apply[ZipList] = ZipList.catsDataCommutativeApplyForZipList
+
+      def sequential: ZipList ~> List =
+        λ[ZipList ~> List](_.value)
+
+      def parallel: List ~> ZipList =
+        λ[List ~> ZipList](v => new ZipList(v))
+    }
 }
 
 private[instances] trait ListInstancesBinCompat0 {
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index 5c27e6f4b..107efceca 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -1,6 +1,7 @@
 package cats
 package instances
 
+import cats.data.ZipVector
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -120,6 +121,20 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
       def show(fa: Vector[A]): String =
         fa.iterator.map(_.show).mkString("Vector(", ", ", ")")
     }
+
+  implicit def catsStdNonEmptyParallelForVectorZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
+    new NonEmptyParallel[Vector] {
+      type F[x] = ZipVector[x]
+
+      def flatMap: FlatMap[Vector] = cats.instances.vector.catsStdInstancesForVector
+      def apply: Apply[ZipVector] = ZipVector.catsDataCommutativeApplyForZipVector
+
+      def sequential: ZipVector ~> Vector =
+        λ[ZipVector ~> Vector](_.value)
+
+      def parallel: Vector ~> ZipVector =
+        λ[Vector ~> ZipVector](v => new ZipVector(v))
+    }
 }
 
 private[instances] trait VectorInstancesBinCompat0 {
