diff --git a/.travis.yml b/.travis.yml
index 197533c80..92e6f8271 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -11,7 +11,7 @@ jdk:
   - openjdk8
 
 
-scala_version_212: &scala_version_212 2.12.10
+scala_version_212: &scala_version_212 2.12.9
 scala_version_213: &scala_version_213 2.13.0
 
 before_install:
diff --git a/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala b/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
index e43b11f7c..55ab7e7de 100644
--- a/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
+++ b/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
@@ -3,30 +3,70 @@ package instances
 
 import cats.data._
 import cats.kernel.Semigroup
-import cats.{NonEmptyParallel, Parallel}
+import cats.syntax.either._
+import cats.{~>, Applicative, Apply, FlatMap, Monad, NonEmptyParallel, Parallel}
 
 trait ParallelInstances extends ParallelInstances1 {
+  implicit def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
+    new Parallel[Either[E, *]] {
+      type F[x] = Validated[E, x]
 
-  @deprecated("Use cats.instances.either.catsParallelForEitherAndValidated", "2.1.0")
-  def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
-    cats.instances.either.catsParallelForEitherAndValidated[E]
+      def applicative: Applicative[Validated[E, *]] = Validated.catsDataApplicativeErrorForValidated
+      def monad: Monad[Either[E, *]] = cats.instances.either.catsStdInstancesForEither
+
+      def sequential: Validated[E, *] ~> Either[E, *] =
+        λ[Validated[E, *] ~> Either[E, *]](_.toEither)
+
+      def parallel: Either[E, *] ~> Validated[E, *] =
+        λ[Either[E, *] ~> Validated[E, *]](_.toValidated)
+    }
 
   @deprecated("Use OptionT.catsDataParallelForOptionT", "2.0.0")
   def catsParallelForOptionTNestedOption[M[_]](
     implicit P: Parallel[M]
   ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = OptionT.catsDataParallelForOptionT[M]
 
-  @deprecated("Use cats.instances.list.catsStdNonEmptyParallelForListZipList", "2.1.0")
-  def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
-    cats.instances.list.catsStdNonEmptyParallelForListZipList
+  implicit def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
+    new NonEmptyParallel[List] {
+      type F[x] = ZipList[x]
+
+      def flatMap: FlatMap[List] = cats.instances.list.catsStdInstancesForList
+      def apply: Apply[ZipList] = ZipList.catsDataCommutativeApplyForZipList
+
+      def sequential: ZipList ~> List =
+        λ[ZipList ~> List](_.value)
+
+      def parallel: List ~> ZipList =
+        λ[List ~> ZipList](v => new ZipList(v))
+    }
+
+  implicit def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
+    new NonEmptyParallel[Vector] {
+      type F[x] = ZipVector[x]
+
+      def flatMap: FlatMap[Vector] = cats.instances.vector.catsStdInstancesForVector
+      def apply: Apply[ZipVector] = ZipVector.catsDataCommutativeApplyForZipVector
+
+      def sequential: ZipVector ~> Vector =
+        λ[ZipVector ~> Vector](_.value)
+
+      def parallel: Vector ~> ZipVector =
+        λ[Vector ~> ZipVector](v => new ZipVector(v))
+    }
+
+  implicit def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
+    new Parallel[Stream] {
+      type F[x] = ZipStream[x]
+
+      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
+      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
 
-  @deprecated("Use cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector", "2.1.0")
-  def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
-    cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector
+      def sequential: ZipStream ~> Stream =
+        λ[ZipStream ~> Stream](_.value)
 
-  @deprecated("Use cats.instances.stream.catsStdParallelForStreamZipStream", "2.1.0")
-  def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
-    cats.instances.stream.catsStdParallelForStreamZipStream
+      def parallel: Stream ~> ZipStream =
+        λ[Stream ~> ZipStream](v => new ZipStream(v))
+    }
 
   @deprecated("Use EitherT.catsDataParallelForEitherTWithParallelEffect", "2.0.0")
   def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](
diff --git a/core/src/main/scala-2.12/cats/instances/stream.scala b/core/src/main/scala-2.12/cats/instances/stream.scala
index 67d4db6e1..de0fcbbf8 100644
--- a/core/src/main/scala-2.12/cats/instances/stream.scala
+++ b/core/src/main/scala-2.12/cats/instances/stream.scala
@@ -1,7 +1,6 @@
 package cats
 package instances
 
-import cats.data.ZipStream
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -158,19 +157,6 @@ trait StreamInstances extends cats.kernel.instances.StreamInstances {
       def show(fa: Stream[A]): String = if (fa.isEmpty) "Stream()" else s"Stream(${fa.head.show}, ?)"
     }
 
-  implicit def catsStdParallelForStreamZipStream: Parallel.Aux[Stream, ZipStream] =
-    new Parallel[Stream] {
-      type F[x] = ZipStream[x]
-
-      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
-      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
-
-      def sequential: ZipStream ~> Stream =
-        λ[ZipStream ~> Stream](_.value)
-
-      def parallel: Stream ~> ZipStream =
-        λ[Stream ~> ZipStream](v => new ZipStream(v))
-    }
 }
 
 private[instances] trait StreamInstancesBinCompat0 {
diff --git a/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala b/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
index f3c16fcaa..ae37f968f 100644
--- a/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
+++ b/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
@@ -3,35 +3,85 @@ package instances
 
 import cats.data._
 import cats.kernel.Semigroup
-import cats.data.ZipLazyList
-import cats.{NonEmptyParallel, Parallel}
+import cats.syntax.either._
+import cats.{~>, Applicative, Apply, FlatMap, Monad, NonEmptyParallel, Parallel}
 
 trait ParallelInstances extends ParallelInstances1 {
+  implicit def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
+    new Parallel[Either[E, *]] {
+      type F[x] = Validated[E, x]
 
-  @deprecated("Use cats.instances.either.catsParallelForEitherAndValidated", "2.1.0")
-  def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
-    cats.instances.either.catsParallelForEitherAndValidated[E]
+      def applicative: Applicative[Validated[E, *]] = Validated.catsDataApplicativeErrorForValidated
+      def monad: Monad[Either[E, *]] = cats.instances.either.catsStdInstancesForEither
+
+      def sequential: Validated[E, *] ~> Either[E, *] =
+        λ[Validated[E, *] ~> Either[E, *]](_.toEither)
+
+      def parallel: Either[E, *] ~> Validated[E, *] =
+        λ[Either[E, *] ~> Validated[E, *]](_.toValidated)
+    }
 
   @deprecated("Use OptionT.catsDataParallelForOptionT", "2.0.0")
   def catsParallelForOptionTNestedOption[M[_]](
     implicit P: Parallel[M]
   ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = OptionT.catsDataParallelForOptionT[M]
 
-  @deprecated("Use cats.instances.list.catsStdNonEmptyParallelForListZipList", "2.1.0")
-  def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
-    cats.instances.list.catsStdNonEmptyParallelForListZipList
+  implicit def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
+    new NonEmptyParallel[List] {
+      type F[x] = ZipList[x]
+
+      def flatMap: FlatMap[List] = cats.instances.list.catsStdInstancesForList
+      def apply: Apply[ZipList] = ZipList.catsDataCommutativeApplyForZipList
+
+      def sequential: ZipList ~> List =
+        λ[ZipList ~> List](_.value)
+
+      def parallel: List ~> ZipList =
+        λ[List ~> ZipList](v => new ZipList(v))
+    }
+
+  implicit def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
+    new NonEmptyParallel[Vector] {
+      type F[x] = ZipVector[x]
+
+      def flatMap: FlatMap[Vector] = cats.instances.vector.catsStdInstancesForVector
+      def apply: Apply[ZipVector] = ZipVector.catsDataCommutativeApplyForZipVector
 
-  @deprecated("Use cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector", "2.1.0")
-  def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
-    cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector
+      def sequential: ZipVector ~> Vector =
+        λ[ZipVector ~> Vector](_.value)
+
+      def parallel: Vector ~> ZipVector =
+        λ[Vector ~> ZipVector](v => new ZipVector(v))
+    }
 
   @deprecated("Use catsStdParallelForZipLazyList", "2.0.0-RC2")
-  def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
-    cats.instances.stream.catsStdParallelForStreamZipStream
+  implicit def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
+    new Parallel[Stream] {
+      type F[x] = ZipStream[x]
+
+      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
+      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
+
+      def sequential: ZipStream ~> Stream =
+        λ[ZipStream ~> Stream](_.value)
+
+      def parallel: Stream ~> ZipStream =
+        λ[Stream ~> ZipStream](v => new ZipStream(v))
+    }
+
+  implicit def catsStdParallelForZipLazyList[A]: Parallel.Aux[LazyList, ZipLazyList] =
+    new Parallel[LazyList] {
+      type F[x] = ZipLazyList[x]
+
+      def monad: Monad[LazyList] = cats.instances.lazyList.catsStdInstancesForLazyList
+      def applicative: Applicative[ZipLazyList] = ZipLazyList.catsDataAlternativeForZipLazyList
+
+      def sequential: ZipLazyList ~> LazyList =
+        λ[ZipLazyList ~> LazyList](_.value)
 
-  @deprecated("Use cats.instances.lazyList.catsStdParallelForLazyListZipLazyList", "2.1.0")
-  def catsStdParallelForZipLazyList[A]: Parallel.Aux[LazyList, ZipLazyList] =
-    cats.instances.lazyList.catsStdParallelForLazyListZipLazyList[A]
+      def parallel: LazyList ~> ZipLazyList =
+        λ[LazyList ~> ZipLazyList](v => new ZipLazyList(v))
+    }
 
   @deprecated("Use EitherT.catsDataParallelForEitherTWithParallelEffect", "2.0.0")
   def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](
diff --git a/core/src/main/scala-2.13+/cats/instances/lazyList.scala b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
index 6c4e08354..1d55cb8c2 100644
--- a/core/src/main/scala-2.13+/cats/instances/lazyList.scala
+++ b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
@@ -1,14 +1,13 @@
 package cats
 package instances
-
 import cats.kernel
 import cats.syntax.show._
-import cats.data.ZipLazyList
 
 import scala.annotation.tailrec
 
 trait LazyListInstances extends cats.kernel.instances.LazyListInstances {
-  implicit val catsStdInstancesForLazyList: Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] =
+  implicit val catsStdInstancesForLazyList
+    : Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] =
     new Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] {
 
       def empty[A]: LazyList[A] = LazyList.empty
@@ -156,18 +155,4 @@ trait LazyListInstances extends cats.kernel.instances.LazyListInstances {
         .value
 
   }
-
-  implicit def catsStdParallelForLazyListZipLazyList[A]: Parallel.Aux[LazyList, ZipLazyList] =
-    new Parallel[LazyList] {
-      type F[x] = ZipLazyList[x]
-
-      def monad: Monad[LazyList] = cats.instances.lazyList.catsStdInstancesForLazyList
-      def applicative: Applicative[ZipLazyList] = ZipLazyList.catsDataAlternativeForZipLazyList
-
-      def sequential: ZipLazyList ~> LazyList =
-        λ[ZipLazyList ~> LazyList](_.value)
-
-      def parallel: LazyList ~> ZipLazyList =
-        λ[LazyList ~> ZipLazyList](v => new ZipLazyList(v))
-    }
 }
diff --git a/core/src/main/scala-2.13+/cats/instances/stream.scala b/core/src/main/scala-2.13+/cats/instances/stream.scala
index df1c6feae..68844aa79 100644
--- a/core/src/main/scala-2.13+/cats/instances/stream.scala
+++ b/core/src/main/scala-2.13+/cats/instances/stream.scala
@@ -1,7 +1,6 @@
 package cats
 package instances
 
-import cats.data.ZipStream
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -9,7 +8,8 @@ import scala.annotation.tailrec
 trait StreamInstances extends cats.kernel.instances.StreamInstances {
 
   @deprecated("Use cats.instances.lazyList", "2.0.0-RC2")
-  implicit val catsStdInstancesForStream: Traverse[Stream] with Alternative[Stream] with Monad[Stream] with CoflatMap[Stream] =
+  implicit val catsStdInstancesForStream
+    : Traverse[Stream] with Alternative[Stream] with Monad[Stream] with CoflatMap[Stream] =
     new Traverse[Stream] with Alternative[Stream] with Monad[Stream] with CoflatMap[Stream] {
 
       def empty[A]: Stream[A] = Stream.Empty
@@ -159,20 +159,6 @@ trait StreamInstances extends cats.kernel.instances.StreamInstances {
       def show(fa: Stream[A]): String = if (fa.isEmpty) "Stream()" else s"Stream(${fa.head.show}, ?)"
     }
 
-  @deprecated("Use catsStdParallelForZipLazyList", "2.0.0-RC2")
-  implicit val catsStdParallelForStreamZipStream: Parallel.Aux[Stream, ZipStream] =
-    new Parallel[Stream] {
-      type F[x] = ZipStream[x]
-
-      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
-      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
-
-      def sequential: ZipStream ~> Stream =
-        λ[ZipStream ~> Stream](_.value)
-
-      def parallel: Stream ~> ZipStream =
-        λ[Stream ~> ZipStream](v => new ZipStream(v))
-    }
 }
 
 private[instances] trait StreamInstancesBinCompat0 {
diff --git a/core/src/main/scala/cats/instances/either.scala b/core/src/main/scala/cats/instances/either.scala
index ff2025a14..572b5df3c 100644
--- a/core/src/main/scala/cats/instances/either.scala
+++ b/core/src/main/scala/cats/instances/either.scala
@@ -1,11 +1,8 @@
 package cats
 package instances
 
-import cats.data.Validated
-import cats.kernel.Semigroup
 import cats.syntax.EitherUtil
 import cats.syntax.either._
-
 import scala.annotation.tailrec
 
 trait EitherInstances extends cats.kernel.instances.EitherInstances {
@@ -161,18 +158,4 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
           case Right(b) => "Right(" + B.show(b) + ")"
         }
     }
-
-  implicit def catsParallelForEitherAndValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
-    new Parallel[Either[E, *]] {
-      type F[x] = Validated[E, x]
-
-      def applicative: Applicative[Validated[E, *]] = Validated.catsDataApplicativeErrorForValidated
-      def monad: Monad[Either[E, *]] = cats.instances.either.catsStdInstancesForEither
-
-      def sequential: Validated[E, *] ~> Either[E, *] =
-        λ[Validated[E, *] ~> Either[E, *]](_.toEither)
-
-      def parallel: Either[E, *] ~> Validated[E, *] =
-        λ[Either[E, *] ~> Validated[E, *]](_.toValidated)
-    }
 }
diff --git a/core/src/main/scala/cats/instances/list.scala b/core/src/main/scala/cats/instances/list.scala
index d93cadfaf..975fa1451 100644
--- a/core/src/main/scala/cats/instances/list.scala
+++ b/core/src/main/scala/cats/instances/list.scala
@@ -1,7 +1,6 @@
 package cats
 package instances
 
-import cats.data.ZipList
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -151,20 +150,6 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
       def show(fa: List[A]): String =
         fa.iterator.map(_.show).mkString("List(", ", ", ")")
     }
-
-  implicit def catsStdNonEmptyParallelForListZipList: NonEmptyParallel.Aux[List, ZipList] =
-    new NonEmptyParallel[List] {
-      type F[x] = ZipList[x]
-
-      def flatMap: FlatMap[List] = cats.instances.list.catsStdInstancesForList
-      def apply: Apply[ZipList] = ZipList.catsDataCommutativeApplyForZipList
-
-      def sequential: ZipList ~> List =
-        λ[ZipList ~> List](_.value)
-
-      def parallel: List ~> ZipList =
-        λ[List ~> ZipList](v => new ZipList(v))
-    }
 }
 
 private[instances] trait ListInstancesBinCompat0 {
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index 107efceca..5c27e6f4b 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -1,7 +1,6 @@
 package cats
 package instances
 
-import cats.data.ZipVector
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -121,20 +120,6 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
       def show(fa: Vector[A]): String =
         fa.iterator.map(_.show).mkString("Vector(", ", ", ")")
     }
-
-  implicit def catsStdNonEmptyParallelForVectorZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
-    new NonEmptyParallel[Vector] {
-      type F[x] = ZipVector[x]
-
-      def flatMap: FlatMap[Vector] = cats.instances.vector.catsStdInstancesForVector
-      def apply: Apply[ZipVector] = ZipVector.catsDataCommutativeApplyForZipVector
-
-      def sequential: ZipVector ~> Vector =
-        λ[ZipVector ~> Vector](_.value)
-
-      def parallel: Vector ~> ZipVector =
-        λ[Vector ~> ZipVector](v => new ZipVector(v))
-    }
 }
 
 private[instances] trait VectorInstancesBinCompat0 {
diff --git a/tests/src/test/scala-2.13+/cats/tests/LazyListSuite.scala b/tests/src/test/scala-2.13+/cats/tests/LazyListSuite.scala
index 171f89a34..5392187a2 100644
--- a/tests/src/test/scala-2.13+/cats/tests/LazyListSuite.scala
+++ b/tests/src/test/scala-2.13+/cats/tests/LazyListSuite.scala
@@ -1,10 +1,18 @@
 package cats
 package tests
 
-import cats.laws.discipline.{AlternativeTests, CoflatMapTests, CommutativeApplyTests, MonadTests, SemigroupalTests, SerializableTests, TraverseFilterTests, TraverseTests}
+import cats.laws.discipline.{
+  AlternativeTests,
+  CoflatMapTests,
+  CommutativeApplyTests,
+  MonadTests,
+  SemigroupalTests,
+  SerializableTests,
+  TraverseFilterTests,
+  TraverseTests
+}
 import cats.data.ZipLazyList
 import cats.laws.discipline.arbitrary._
-import org.scalatest.funsuite.AnyFunSuiteLike
 
 class LazyListSuite extends CatsSuite {
   checkAll("LazyList[Int]", SemigroupalTests[LazyList].semigroupal[Int, Int, Int])
@@ -51,13 +59,3 @@ class LazyListSuite extends CatsSuite {
   }
 
 }
-
-final class LazyListInstancesSuite extends AnyFunSuiteLike {
-
-  test("parallel instance in cats.instances.lazyList") {
-    import cats.instances.lazyList._
-    import cats.syntax.parallel._
-
-    (LazyList(1, 2, 3), LazyList("A", "B", "C")).parTupled
-  }
-}
diff --git a/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala b/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala
index 76af75af3..43c3230dd 100644
--- a/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala
+++ b/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala
@@ -123,9 +123,11 @@ trait ScalaVersionSpecificParallelSuite { self: ParallelSuite =>
   }
 
   // Can't test Parallel here, as Applicative[ZipLazyList].pure doesn't terminate
-  checkAll("Parallel[LazyList]", NonEmptyParallelTests[LazyList].nonEmptyParallel[Int, String])
+  checkAll("Parallel[LazyList]",
+           NonEmptyParallelTests[LazyList].nonEmptyParallel[Int, String])
 
-  checkAll("Parallel[NonEmptyLazyList]", ParallelTests[NonEmptyLazyList].parallel[Int, String])
+  checkAll("Parallel[NonEmptyLazyList]",
+           ParallelTests[NonEmptyLazyList].parallel[Int, String])
 }
 
 trait ScalaVersionSpecificRegressionSuite { self: RegressionSuite =>
diff --git a/tests/src/test/scala/cats/tests/EitherSuite.scala b/tests/src/test/scala/cats/tests/EitherSuite.scala
index 3544434b7..7dff18ad7 100644
--- a/tests/src/test/scala/cats/tests/EitherSuite.scala
+++ b/tests/src/test/scala/cats/tests/EitherSuite.scala
@@ -4,8 +4,6 @@ package tests
 import cats.data.{EitherT, NonEmptyChain, NonEmptyList, NonEmptySet, Validated}
 import cats.laws.discipline._
 import cats.kernel.laws.discipline.{EqTests, MonoidTests, OrderTests, PartialOrderTests, SemigroupTests}
-import org.scalatest.funsuite.AnyFunSuiteLike
-
 import scala.util.Try
 
 class EitherSuite extends CatsSuite {
@@ -363,18 +361,7 @@ class EitherSuite extends CatsSuite {
       either.leftFlatMap(f) should ===(either.swap.flatMap(a => f(a).swap).swap)
     }
   }
-}
-
-final class EitherInstancesSuite extends AnyFunSuiteLike {
 
-  test("parallel instance in cats.instances.either") {
-    import cats.instances.either._
-    import cats.instances.string._
-    import cats.syntax.parallel._
-
-    def either: Either[String, Int] = Left("Test")
-    (either, either).parTupled
-  }
 }
 
 @deprecated("To test deprecated methods", "2.1.0")
diff --git a/tests/src/test/scala/cats/tests/ListSuite.scala b/tests/src/test/scala/cats/tests/ListSuite.scala
index b5bb2061d..c5301365f 100644
--- a/tests/src/test/scala/cats/tests/ListSuite.scala
+++ b/tests/src/test/scala/cats/tests/ListSuite.scala
@@ -13,7 +13,6 @@ import cats.laws.discipline.{
   TraverseTests
 }
 import cats.laws.discipline.arbitrary._
-import org.scalatest.funsuite.AnyFunSuiteLike
 
 class ListSuite extends CatsSuite {
 
@@ -61,13 +60,3 @@ class ListSuite extends CatsSuite {
     }
   }
 }
-
-final class ListInstancesSuite extends AnyFunSuiteLike {
-
-  test("NonEmptyParallel instance in cats.instances.list") {
-    import cats.instances.list._
-    import cats.syntax.parallel._
-
-    (List(1, 2, 3), List("A", "B", "C")).parTupled
-  }
-}
diff --git a/tests/src/test/scala/cats/tests/ParallelSuite.scala b/tests/src/test/scala/cats/tests/ParallelSuite.scala
index 8d052df62..d1b4168aa 100644
--- a/tests/src/test/scala/cats/tests/ParallelSuite.scala
+++ b/tests/src/test/scala/cats/tests/ParallelSuite.scala
@@ -493,6 +493,7 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
 trait ApplicativeErrorForEitherTest extends AnyFunSuiteLike with Discipline {
 
   import cats.instances.either._
+  import cats.instances.parallel._
   import cats.instances.string._
   import cats.instances.int._
   import cats.instances.unit._
diff --git a/tests/src/test/scala/cats/tests/StreamSuite.scala b/tests/src/test/scala/cats/tests/StreamSuite.scala
index 3a22bc4b9..e97d92dbb 100644
--- a/tests/src/test/scala/cats/tests/StreamSuite.scala
+++ b/tests/src/test/scala/cats/tests/StreamSuite.scala
@@ -13,7 +13,6 @@ import cats.laws.discipline.{
 }
 import cats.data.ZipStream
 import cats.laws.discipline.arbitrary._
-import org.scalatest.funsuite.AnyFunSuiteLike
 
 class StreamSuite extends CatsSuite {
   checkAll("Stream[Int]", SemigroupalTests[Stream].semigroupal[Int, Int, Int])
@@ -60,13 +59,3 @@ class StreamSuite extends CatsSuite {
   }
 
 }
-
-final class StreamInstancesSuite extends AnyFunSuiteLike {
-
-  test("parallel instance in cats.instances.stream") {
-    import cats.instances.stream._
-    import cats.syntax.parallel._
-
-    (Stream(1, 2, 3), Stream("A", "B", "C")).parTupled
-  }
-}
diff --git a/tests/src/test/scala/cats/tests/VectorSuite.scala b/tests/src/test/scala/cats/tests/VectorSuite.scala
index 515b1cf52..0f8964653 100644
--- a/tests/src/test/scala/cats/tests/VectorSuite.scala
+++ b/tests/src/test/scala/cats/tests/VectorSuite.scala
@@ -13,7 +13,6 @@ import cats.laws.discipline.{
   TraverseTests
 }
 import cats.laws.discipline.arbitrary._
-import org.scalatest.funsuite.AnyFunSuiteLike
 
 class VectorSuite extends CatsSuite {
   checkAll("Vector[Int]", SemigroupalTests[Vector].semigroupal[Int, Int, Int])
@@ -56,13 +55,3 @@ class VectorSuite extends CatsSuite {
     assert(Vector.empty[Int].toNev == None)
   }
 }
-
-final class VectorInstancesSuite extends AnyFunSuiteLike {
-
-  test("NonEmptyParallel instance in cats.instances.vector") {
-    import cats.instances.vector._
-    import cats.syntax.parallel._
-
-    (Vector(1, 2, 3), Vector("A", "B", "C")).parTupled
-  }
-}
