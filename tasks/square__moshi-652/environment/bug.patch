diff --git a/adapters/src/main/java/com/squareup/moshi/adapters/EnumJsonAdapter.java b/adapters/src/main/java/com/squareup/moshi/adapters/EnumJsonAdapter.java
index 8bf1637d..359ddce7 100644
--- a/adapters/src/main/java/com/squareup/moshi/adapters/EnumJsonAdapter.java
+++ b/adapters/src/main/java/com/squareup/moshi/adapters/EnumJsonAdapter.java
@@ -1,18 +1,3 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package com.squareup.moshi.adapters;
 
 import com.squareup.moshi.Json;
@@ -22,6 +7,7 @@ import com.squareup.moshi.JsonReader;
 import com.squareup.moshi.JsonWriter;
 import java.io.IOException;
 import java.util.Arrays;
+import javax.annotation.Nonnull;
 import javax.annotation.Nullable;
 
 /**
@@ -69,7 +55,7 @@ public final class EnumJsonAdapter<T extends Enum<T>> extends JsonAdapter<T> {
     }
   }
 
-  @Override public @Nullable T fromJson(JsonReader reader) throws IOException {
+  @Override public @Nonnull T fromJson(JsonReader reader) throws IOException {
     int index = reader.selectString(options);
     if (index != -1) return constants[index];
 
diff --git a/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java b/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java
index 1e805c10..44b97d22 100644
--- a/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java
+++ b/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java
@@ -21,7 +21,6 @@ import com.squareup.moshi.JsonReader;
 import com.squareup.moshi.JsonWriter;
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.Types;
-import com.squareup.moshi.internal.Util;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -32,7 +31,7 @@ import javax.annotation.CheckReturnValue;
 
 /**
  * A JsonAdapter factory for polymorphic types. This is useful when the type is not known before
- * decoding the JSON. This factory's adapters expect JSON in the format of a JSON object with a
+ * deserializing the JSON. This factory's adapters expect JSON in the format of a JSON object with a
  * key whose value is a label that determines the type to which to map the JSON object.
  */
 public final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
@@ -43,7 +42,7 @@ public final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
   /**
    * @param baseType The base type for which this factory will create adapters.
    * @param labelKey The key in the JSON object whose value determines the type to which to map the
-   *     JSON object.
+   * JSON object.
    */
   @CheckReturnValue
   public static <T> RuntimeJsonAdapterFactory<T> of(Class<T> baseType, String labelKey) {
@@ -58,9 +57,9 @@ public final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
   }
 
   /**
-   * Register the subtype that can be created based on the label. When an unknown type is found
-   * during encoding an {@linkplain IllegalArgumentException} will be thrown. When an unknown label
-   * is found during decoding a {@linkplain JsonDataException} will be thrown.
+   * Register the subtype that can be created based on the label. When deserializing, if a label
+   * that was not registered is found, a JsonDataException will be thrown. When serializing, if a
+   * type that was not registered is used, an IllegalArgumentException will be thrown.
    */
   public RuntimeJsonAdapterFactory<T> registerSubtype(Class<? extends T> subtype, String label) {
     if (subtype == null) throw new NullPointerException("subtype == null");
@@ -78,32 +77,30 @@ public final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
       return null;
     }
     int size = labelToType.size();
+    Map<Type, JsonAdapter<Object>> typeToAdapter = new LinkedHashMap<>(size);
     Map<String, JsonAdapter<Object>> labelToAdapter = new LinkedHashMap<>(size);
-    Map<Type, String> typeToLabel = new LinkedHashMap<>(size);
     for (Map.Entry<String, Type> entry : labelToType.entrySet()) {
       String label = entry.getKey();
       Type typeValue = entry.getValue();
-      typeToLabel.put(typeValue, label);
-      labelToAdapter.put(label, moshi.adapter(typeValue));
+      JsonAdapter<Object> adapter = moshi.adapter(typeValue);
+      labelToAdapter.put(label, adapter);
+      typeToAdapter.put(typeValue, adapter);
     }
-    JsonAdapter<Object> objectJsonAdapter = moshi.nextAdapter(
-        this, Object.class, Util.NO_ANNOTATIONS);
-    return new RuntimeJsonAdapter(labelKey, labelToAdapter, typeToLabel, objectJsonAdapter)
-        .nullSafe();
+    return new RuntimeJsonAdapter(labelKey, labelToAdapter, typeToAdapter).nullSafe();
   }
 
   static final class RuntimeJsonAdapter extends JsonAdapter<Object> {
     final String labelKey;
     final Map<String, JsonAdapter<Object>> labelToAdapter;
-    final Map<Type, String> typeToLabel;
-    final JsonAdapter<Object> objectJsonAdapter;
+    final Map<Type, JsonAdapter<Object>> typeToAdapter;
 
-    RuntimeJsonAdapter(String labelKey, Map<String, JsonAdapter<Object>> labelToAdapter,
-        Map<Type, String> typeToLabel, JsonAdapter<Object> objectJsonAdapter) {
+    RuntimeJsonAdapter(
+        String labelKey,
+        Map<String, JsonAdapter<Object>> labelToAdapter,
+        Map<Type, JsonAdapter<Object>> typeToAdapter) {
       this.labelKey = labelKey;
       this.labelToAdapter = labelToAdapter;
-      this.typeToLabel = typeToLabel;
-      this.objectJsonAdapter = objectJsonAdapter;
+      this.typeToAdapter = typeToAdapter;
     }
 
     @Override public Object fromJson(JsonReader reader) throws IOException {
@@ -141,23 +138,17 @@ public final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
 
     @Override public void toJson(JsonWriter writer, Object value) throws IOException {
       Class<?> type = value.getClass();
-      String label = typeToLabel.get(type);
-      if (label == null) {
+      JsonAdapter<Object> adapter = typeToAdapter.get(type);
+      if (adapter == null) {
         throw new IllegalArgumentException("Expected one of "
-            + typeToLabel.keySet()
+            + typeToAdapter.keySet()
             + " but found "
             + value
             + ", a "
             + value.getClass()
             + ". Register this subtype.");
       }
-      JsonAdapter<Object> adapter = labelToAdapter.get(label);
-      Map<String, Object> jsonValue = (Map<String, Object>) adapter.toJsonValue(value);
-
-      Map<String, Object> valueWithLabel = new LinkedHashMap<>(1 + jsonValue.size());
-      valueWithLabel.put(labelKey, label);
-      valueWithLabel.putAll(jsonValue);
-      objectJsonAdapter.toJson(writer, valueWithLabel);
+      adapter.toJson(writer, value);
     }
 
     @Override public String toString() {
diff --git a/adapters/src/test/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactoryTest.java b/adapters/src/test/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactoryTest.java
index 6e04f53a..a105fd50 100644
--- a/adapters/src/test/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactoryTest.java
+++ b/adapters/src/test/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactoryTest.java
@@ -53,9 +53,9 @@ public final class RuntimeJsonAdapterFactoryTest {
     JsonAdapter<Message> adapter = moshi.adapter(Message.class);
 
     assertThat(adapter.toJson(new Success("Okay!")))
-        .isEqualTo("{\"type\":\"success\",\"value\":\"Okay!\"}");
+        .isEqualTo("{\"value\":\"Okay!\"}");
     assertThat(adapter.toJson(new Error(Collections.<String, Object>singletonMap("order", 66))))
-        .isEqualTo("{\"type\":\"error\",\"error_logs\":{\"order\":66}}");
+        .isEqualTo("{\"error_logs\":{\"order\":66}}");
   }
 
   @Test public void unregisteredLabelValue() throws IOException {
