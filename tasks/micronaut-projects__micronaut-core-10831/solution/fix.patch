diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/KotlinNativeElementsHelper.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/KotlinNativeElementsHelper.kt
index 40451e592c..e8bf16e42d 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/KotlinNativeElementsHelper.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/KotlinNativeElementsHelper.kt
@@ -98,7 +98,10 @@ internal class KotlinNativeElementsHelper(private val resolver: Resolver) : Nati
         return t == builtIns.anyType ||
                 t == builtIns.nothingType ||
                 t == builtIns.unitType ||
-                classNode.qualifiedName.toString() == Enum::class.java.name
+                (classNode.qualifiedName != null && (
+                        classNode.qualifiedName!!.asString() == Enum::class.java.name ||
+                                classNode.qualifiedName!!.asString() == Record::class.java.name
+                        ))
     }
 
     override fun isInterface(classNode: KSClassDeclaration): Boolean {
diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinElement.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinElement.kt
index 89071d6a89..67c59f5939 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinElement.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/AbstractKotlinElement.kt
@@ -30,6 +30,7 @@ import com.google.devtools.ksp.symbol.KSType
 import com.google.devtools.ksp.symbol.KSTypeArgument
 import com.google.devtools.ksp.symbol.KSTypeParameter
 import com.google.devtools.ksp.symbol.Modifier
+import com.google.devtools.ksp.symbol.Nullability
 import com.google.devtools.ksp.symbol.Variance
 import com.google.devtools.ksp.symbol.Visibility
 import io.micronaut.aop.Around
@@ -538,7 +539,7 @@ internal abstract class AbstractKotlinElement<T : KotlinNativeElement>(
             }
             val canBePrimitive =
                 type == null || type.annotations.toList().isEmpty() && !type.isMarkedNullable
-            if (allowPrimitive && canBePrimitive) {
+            if (allowPrimitive && canBePrimitive && type?.nullability != Nullability.PLATFORM) {
                 val element = primitives[qualifiedNameString]
                 if (element != null) {
                     return element
diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
index 53c75460e0..743a4d0eec 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
@@ -433,10 +433,13 @@ internal open class KotlinClassElement(
                     }
                 }
         }
-        val propertyNames = allProperties.map { it.name }.toSet()
-
+        val propertyNames = allProperties.map { it.name }.toMutableSet()
         val resolvedProperties: MutableList<PropertyElement> = mutableListOf()
         val methods = ArrayList(getEnclosedElements(ElementQuery.ALL_METHODS))
+        if (isJavaRecord(nativeType.declaration)) {
+            propertyElementQuery.readPrefixes("")
+            propertyElementQuery.writePrefixes(emptyArray())
+        }
         allProperties.forEach { prop ->
             methods.removeIf { m ->
                 prop.name == NameUtils.getPropertyNameForGetter(
@@ -456,7 +459,8 @@ internal open class KotlinClassElement(
             {
                 emptyList()
             },
-            false, propertyNames,
+            false,
+            propertyNames,
             customReaderPropertyNameResolver,
             customWriterPropertyNameResolver,
             { value: AstBeanPropertiesUtils.BeanPropertyData ->
@@ -792,16 +796,23 @@ internal open class KotlinClassElement(
                 }
 
                 MethodElement::class.java -> {
-                    classNode.getDeclaredFunctions()
+                    val functions = if (isJavaRecord(classNode)) {
+                        classNode.getAllFunctions().filter {
+                            !listOf(
+                                "hashCode",
+                                "toString",
+                                "equals"
+                            ).contains(it.simpleName.asString())
+                        }
+                    } else {
+                        classNode.getDeclaredFunctions()
+                    }
+
+                    functions
                         .filter { func: KSFunctionDeclaration ->
                             !func.isConstructor() &&
                                     func.origin != Origin.SYNTHETIC &&
-                                    // this is a hack but no other way it seems
-                                    !listOf(
-                                        "hashCode",
-                                        "toString",
-                                        "equals"
-                                    ).contains(func.simpleName.asString()) && (includeAbstract || !func.isAbstract || !classNode.isAbstract())
+                                    (includeAbstract || !func.isAbstract || !classNode.isAbstract())
                         }
                         .toList()
                 }
@@ -841,7 +852,10 @@ internal open class KotlinClassElement(
             return t == builtIns.anyType ||
                     t == builtIns.nothingType ||
                     t == builtIns.unitType ||
-                    classNode.qualifiedName.toString() == Enum::class.java.name
+                    (classNode.qualifiedName != null && (
+                            classNode.qualifiedName!!.asString() == Enum::class.java.name ||
+                                    classNode.qualifiedName!!.asString() == Record::class.java.name
+                            ))
         }
 
         override fun isAbstractClass(classNode: KSClassDeclaration) = classNode.isAbstract()
@@ -906,5 +920,8 @@ internal open class KotlinClassElement(
         }
     }
 
+    private fun isJavaRecord(classNode: KSClassDeclaration) =
+        classNode.origin == Origin.JAVA && classNode.superTypes.filter { Record::class.java.name == it.resolve().declaration.qualifiedName?.asString() }
+            .any()
 
 }
