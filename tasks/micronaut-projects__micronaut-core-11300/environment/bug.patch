diff --git a/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java b/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
index f1dc120523..d4fafd1bb2 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
@@ -924,9 +924,6 @@ public abstract class HttpClientConfiguration {
 
         private boolean enabled = DEFAULT_ENABLED;
 
-        @NonNull
-        private HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality connectionLocality = ConnectionLocality.PREFERRED;
-
         /**
          * Whether connection pooling is enabled.
          * [available in the Netty HTTP client]
@@ -1065,61 +1062,6 @@ public abstract class HttpClientConfiguration {
         public void setMaxConcurrentHttp2Connections(int maxConcurrentHttp2Connections) {
             this.maxConcurrentHttp2Connections = maxConcurrentHttp2Connections;
         }
-
-        /**
-         * Optimize locality of client connections depending on which event loop makes a request.
-         * [available in the Netty HTTP client]
-         *
-         * @return The locality configuration
-         * @since 4.8.0
-         */
-        public @NonNull HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality getConnectionLocality() {
-            return connectionLocality;
-        }
-
-        /**
-         * Optimize locality of client connections depending on which event loop makes a request.
-         * [available in the Netty HTTP client]
-         *
-         * @param connectionLocality The locality configuration
-         * @since 4.8.0
-         */
-        public void setConnectionLocality(@NonNull HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality connectionLocality) {
-            this.connectionLocality = connectionLocality;
-        }
-
-        /**
-         * Options for {@link #connectionLocality}.
-         *
-         * @since 4.8.0
-         */
-        public enum ConnectionLocality {
-            /**
-             * Do not consider locality when selecting a connection.
-             */
-            IGNORE,
-            /**
-             * If a request is made from an event loop, and a connection is already in the pool
-             * from that same event loop, prefer using that connection. When a new connection needs
-             * to be created, also prefer the current event loop.
-             */
-            PREFERRED,
-            /**
-             * If a request is made from an event loop, and a connection is already in the pool
-             * from that same event loop, use that connection. Otherwise, force creating a new
-             * connection on the same event loop. Please ensure that settings such as
-             * {@link #maxPendingConnections} are also high enough to create new connections.
-             */
-            ENFORCED_IF_SAME_GROUP,
-            /**
-             * Same as {@link #ENFORCED_IF_SAME_GROUP}, but if a request is made from outside the
-             * event loop group of the client, fail <i>a</i> request. Note that there is no
-             * guarantee that the offending request is the only request seeing a failure, so the
-             * exception should only be used as a warning that you are using the client in a way
-             * that you did not intend.
-             */
-            ENFORCED_ALWAYS,
-        }
     }
 
     /**
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
index 74ffcf4c21..1eccca969a 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
@@ -46,7 +46,6 @@ import io.netty.channel.ChannelOption;
 import io.netty.channel.ChannelOutboundHandlerAdapter;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPromise;
-import io.netty.channel.EventLoop;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.handler.codec.DecoderException;
@@ -110,7 +109,6 @@ import io.netty.util.concurrent.EventExecutor;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
 import io.netty.util.concurrent.ScheduledFuture;
-import io.netty.util.internal.ThreadExecutorMap;
 import org.slf4j.Logger;
 import reactor.core.publisher.Mono;
 import reactor.core.publisher.Sinks;
@@ -365,10 +363,12 @@ public class ConnectionManager {
 
     private void initBootstrap() {
         this.bootstrap = new Bootstrap()
+            .group(group)
             .channelFactory(socketChannelFactory)
             .option(ChannelOption.SO_KEEPALIVE, true);
         if (httpVersion.isHttp3()) {
             this.udpBootstrap = new Bootstrap()
+                .group(group)
                 .channelFactory(udpChannelFactory);
         }
 
@@ -450,12 +450,11 @@ public class ConnectionManager {
      * Use the bootstrap to connect to the given host. Also does some proxy setup. This method is
      * not final: The test suite overrides it to return embedded channels instead.
      *
-     * @param requestKey         The host to connect to
+     * @param requestKey The host to connect to
      * @param channelInitializer The initializer to use
-     * @param requestingThread   A hint which thread may use this connection (not 100% reliable)
      * @return Future that terminates when the TCP connection is established.
      */
-    ChannelFuture doConnect(DefaultHttpClient.RequestKey requestKey, CustomizerAwareInitializer channelInitializer, @NonNull Thread requestingThread) {
+    ChannelFuture doConnect(DefaultHttpClient.RequestKey requestKey, CustomizerAwareInitializer channelInitializer) {
         String host = requestKey.getHost();
         int port = requestKey.getPort();
         Bootstrap localBootstrap = bootstrap.clone();
@@ -466,30 +465,9 @@ public class ConnectionManager {
         localBootstrap.handler(channelInitializer)
             .remoteAddress(host, port);
         channelInitializer.bootstrappedCustomizer = clientCustomizer.specializeForBootstrap(localBootstrap);
-        assignGroup(localBootstrap, requestingThread);
         return localBootstrap.connect();
     }
 
-    private void assignGroup(Bootstrap bootstrap, Thread requestingThread) {
-        HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality locality = configuration.getConnectionPoolConfiguration().getConnectionLocality();
-        if (locality == HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality.IGNORE) {
-            bootstrap.group(group);
-            return;
-        }
-        EventLoop loop = (EventLoop) findEventLoop(requestingThread);
-        if (loop == null) {
-            if (locality == HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality.ENFORCED_ALWAYS) {
-                throw new IllegalStateException("Attempted to open a HTTP connection from thread " +
-                    requestingThread + " which is not part of event loop group " + group +
-                    ", but configured the pool in locality mode ENFORCED_ALWAYS, which disallows " +
-                    "requesting from outside this group");
-            }
-            bootstrap.group(group);
-        } else {
-            bootstrap.group(loop);
-        }
-    }
-
     /**
      * Builds an {@link SslContext} for the given URI if necessary.
      *
@@ -596,7 +574,7 @@ public class ConnectionManager {
                 // failed
                 ch.close();
             }
-        }, Thread.currentThread());
+        });
         withPropagation(connectFuture, future -> {
             if (!future.isSuccess()) {
                 initial.tryEmitError(future.cause());
@@ -866,27 +844,6 @@ public class ConnectionManager {
         return HttpClientExceptionUtils.populateServiceId(exc, informationalServiceId, configuration);
     }
 
-    @Nullable
-    private EventExecutor findEventLoop(Thread thread) {
-        if (thread == Thread.currentThread()) {
-            // shortcut to avoid the loop
-            EventExecutor executor = ThreadExecutorMap.currentExecutor();
-            if (executor != null) {
-                if (executor == group || executor.parent() == group) {
-                    return executor;
-                } else {
-                    return null;
-                }
-            }
-        }
-        for (EventExecutor executor : group) {
-            if (executor.inEventLoop(thread)) {
-                return executor;
-            }
-        }
-        return null;
-    }
-
     abstract static class CustomizerAwareInitializer extends ChannelInitializer<Channel> {
         NettyClientCustomizer bootstrappedCustomizer;
     }
@@ -1248,9 +1205,9 @@ public class ConnectionManager {
         }
 
         @Override
-        void openNewConnection(@Nullable BlockHint blockHint, @NonNull Thread requestingThread) throws Exception {
+        void openNewConnection(@Nullable BlockHint blockHint) throws Exception {
             // open a new connection
-            ChannelFuture channelFuture = openConnectionFuture(requestingThread);
+            ChannelFuture channelFuture = openConnectionFuture();
             if (blockHint != null && blockHint.blocks(channelFuture.channel().eventLoop())) {
                 channelFuture.channel().close();
                 onNewConnectionFailure(BlockHint.createException());
@@ -1263,12 +1220,7 @@ public class ConnectionManager {
             });
         }
 
-        @Override
-        boolean containsThread(@NonNull Thread thread) {
-            return findEventLoop(thread) != null;
-        }
-
-        private ChannelFuture openConnectionFuture(@NonNull Thread requestingThread) {
+        private ChannelFuture openConnectionFuture() {
             CustomizerAwareInitializer initializer;
             if (requestKey.isSecure()) {
                 if (httpVersion.isHttp3()) {
@@ -1276,7 +1228,6 @@ public class ConnectionManager {
                     Bootstrap localBootstrap = udpBootstrap.clone()
                         .handler(channelInitializer)
                         .localAddress(0);
-                    assignGroup(localBootstrap, requestingThread);
                     channelInitializer.bootstrappedCustomizer = clientCustomizer.specializeForBootstrap(localBootstrap);
                     return localBootstrap.bind();
                 }
@@ -1309,7 +1260,7 @@ public class ConnectionManager {
                     case H2C -> new Http2UpgradeInitializer(this);
                 };
             }
-            return doConnect(requestKey, initializer, requestingThread);
+            return doConnect(requestKey, initializer);
         }
 
         public void shutdown() {
@@ -1430,11 +1381,6 @@ public class ConnectionManager {
                 }
             }
 
-            @Override
-            boolean inEventLoop(Thread thread) {
-                return channel.eventLoop().inEventLoop(thread);
-            }
-
             @Override
             public final boolean dispatch(PendingRequest sink) {
                 if (!tryEarmarkForRequest()) {
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index 9f8a2286f3..f2a77ed029 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -196,10 +196,8 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalLong;
 import java.util.concurrent.ExecutorService;
-import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BiFunction;
 import java.util.function.Function;
 
@@ -888,15 +886,11 @@ public class DefaultHttpClient implements
     private <I, O, E> Mono<HttpResponse<O>> exchange(io.micronaut.http.HttpRequest<I> request, Argument<O> bodyType, Argument<E> errorType, @Nullable BlockHint blockHint) {
         setupConversionService(request);
         PropagatedContext propagatedContext = PropagatedContext.getOrEmpty();
-        // if a connection is available immediately, we can use its executor for the timeout
-        // instead of a random executor for the whole group
-        AtomicReference<ScheduledExecutorService> scheduler = new AtomicReference<>(connectionManager.getGroup());
         ExecutionFlow<HttpResponse<O>> mono = resolveRequestURI(request).flatMap(uri -> {
             MutableHttpRequest<?> mutableRequest = toMutableRequest(request).uri(uri);
             //noinspection unchecked
             return sendRequestWithRedirects(
                 propagatedContext,
-                scheduler,
                 blockHint,
                 mutableRequest,
                 (req, resp) -> InternalByteBody.bufferFlow(resp.byteBody())
@@ -914,7 +908,7 @@ public class DefaultHttpClient implements
         }
         if (requestTimeout != null) {
             if (!requestTimeout.isNegative()) {
-                mono = mono.timeout(requestTimeout, scheduler.get(), null)
+                mono = mono.timeout(requestTimeout, connectionManager.getGroup(), null)
                     .onErrorResume(throwable -> {
                         if (throwable instanceof TimeoutException) {
                             return ExecutionFlow.error(ReadTimeoutException.TIMEOUT_EXCEPTION);
@@ -1514,23 +1508,11 @@ public class DefaultHttpClient implements
         return toMono(mono, propagatedContext).doOnTerminate(requestBody::close);
     }
 
-    private ExecutionFlow<HttpResponse<?>> sendRequestWithRedirects(
-        PropagatedContext propagatedContext,
-        @Nullable BlockHint blockHint,
-        MutableHttpRequest<?> request,
-        BiFunction<MutableHttpRequest<?>, NettyClientByteBodyResponse, ? extends ExecutionFlow<? extends HttpResponse<?>>> readResponse
-    ) {
-        return sendRequestWithRedirects(propagatedContext, new AtomicReference<>(), blockHint, request, readResponse);
-    }
-
     /**
      * This is the high-level request method. It sits above {@link #sendRawRequest} and handles
      * things like filters, error handling, response parsing, request writing.
      *
      * @param propagatedContext The context propagated from the original client call
-     * @param preferredScheduler A reference holding the preferred scheduler for timeouts. This is
-     *                           replaced by the connection event loop ASAP so that callers can take
-     *                           advantage of locality
      * @param blockHint         The optional block hint
      * @param request           The request to send. Must have resolved absolute URI (see {@link #resolveURI})
      * @param readResponse      Function that reads the response from the raw
@@ -1541,7 +1523,6 @@ public class DefaultHttpClient implements
      */
     private ExecutionFlow<HttpResponse<?>> sendRequestWithRedirects(
         PropagatedContext propagatedContext,
-        AtomicReference<ScheduledExecutorService> preferredScheduler,
         @Nullable BlockHint blockHint,
         MutableHttpRequest<?> request,
         BiFunction<MutableHttpRequest<?>, NettyClientByteBodyResponse, ? extends ExecutionFlow<? extends HttpResponse<?>>> readResponse
@@ -1562,7 +1543,6 @@ public class DefaultHttpClient implements
                     try (PropagatedContext.Scope ignore = propagatedContext.propagate()) {
                         return sendRequestWithRedirectsNoFilter(
                             propagatedContext,
-                            preferredScheduler,
                             blockHint,
                             MutableHttpRequestWrapper.wrapIfNecessary(conversionService, request),
                             readResponse
@@ -1578,7 +1558,6 @@ public class DefaultHttpClient implements
 
     private ExecutionFlow<HttpResponse<?>> sendRequestWithRedirectsNoFilter(
         PropagatedContext propagatedContext,
-        AtomicReference<ScheduledExecutorService> preferredScheduler,
         @Nullable BlockHint blockHint,
         MutableHttpRequest<?> request,
         BiFunction<MutableHttpRequest<?>, NettyClientByteBodyResponse, ? extends ExecutionFlow<? extends HttpResponse<?>>> readResponse
@@ -1597,8 +1576,6 @@ public class DefaultHttpClient implements
         // first: connect
         return connectionManager.connect(requestKey, blockHint)
             .flatMap(poolHandle -> {
-                preferredScheduler.set(poolHandle.channel.eventLoop());
-
                 // build the raw request
                 request.setAttribute(NettyClientHttpRequest.CHANNEL, poolHandle.channel);
 
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/PoolResizer.java b/http-client/src/main/java/io/micronaut/http/client/netty/PoolResizer.java
index 2246c1318a..c832681fed 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/PoolResizer.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/PoolResizer.java
@@ -16,7 +16,6 @@
 package io.micronaut.http.client.netty;
 
 import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.execution.DelayedExecutionFlow;
 import io.micronaut.core.execution.ExecutionFlow;
@@ -24,17 +23,13 @@ import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.client.exceptions.HttpClientException;
 import org.slf4j.Logger;
 
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Deque;
-import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
-import java.util.concurrent.locks.Lock;
-import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Consumer;
 
 /**
@@ -58,8 +53,8 @@ abstract class PoolResizer {
     private final AtomicInteger pendingConnectionCount = new AtomicInteger(0);
 
     private final Deque<PendingRequest> pendingRequests = new ConcurrentLinkedDeque<>();
-    private final ConnectionList http1Connections = new ConnectionList();
-    private final ConnectionList http2Connections = new ConnectionList();
+    private final List<ResizerConnection> http1Connections = new CopyOnWriteArrayList<>();
+    private final List<ResizerConnection> http2Connections = new CopyOnWriteArrayList<>();
 
     PoolResizer(Logger log, HttpClientConfiguration.ConnectionPoolConfiguration connectionPoolConfiguration) {
         this.log = log;
@@ -103,49 +98,6 @@ abstract class PoolResizer {
         }
     }
 
-    private ResizerConnection[] sort(PendingRequest request, ConnectionList connections) {
-        ResizerConnection[] items = connections.unsafeItems;
-        if (items.length == 0) {
-            return items;
-        }
-        HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality locality = connectionPoolConfiguration.getConnectionLocality();
-        if (locality == HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality.PREFERRED) {
-            // this is a very simple selection sort. There's usually only one or two connections on
-            // the same thread
-            int copies = 0;
-            for (int i = 1; i < items.length; i++) {
-                ResizerConnection connection = items[i];
-                if (connection.inEventLoop(request.requestingThread)) {
-                    // place that connection at the front
-                    System.arraycopy(items, 0, items, 1, i);
-                    items[0] = connection;
-                    if (copies++ > 4) {
-                        // prevent nÂ² worst-case performance
-                        break;
-                    }
-                }
-            }
-        } else if (locality == HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality.ENFORCED_IF_SAME_GROUP ||
-            locality == HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality.ENFORCED_ALWAYS) {
-
-            List<ResizerConnection> options = new ArrayList<>();
-            for (ResizerConnection item : items) {
-                if (item.inEventLoop(request.requestingThread)) {
-                    options.add(item);
-                }
-            }
-            if (!options.isEmpty() ||
-                locality == HttpClientConfiguration.ConnectionPoolConfiguration.ConnectionLocality.ENFORCED_ALWAYS ||
-                containsThread(request.requestingThread)) {
-
-                return options.toArray(new ResizerConnection[0]);
-            }
-            // escape hatch: in ENFORCED_IF_SAME_GROUP, we can use any connection if the
-            // requesting thread is *not* in the same event loop group.
-        }
-        return items;
-    }
-
     private void doSomeWork() {
         BlockHint blockedPendingRequests = null;
         while (true) {
@@ -154,14 +106,14 @@ abstract class PoolResizer {
                 break;
             }
             boolean dispatched = false;
-            for (ResizerConnection c : sort(toDispatch, http2Connections)) {
+            for (ResizerConnection c : http2Connections) {
                 if (dispatchSafe(c, toDispatch)) {
                     dispatched = true;
                     break;
                 }
             }
             if (!dispatched) {
-                for (ResizerConnection c : sort(toDispatch, http1Connections)) {
+                for (ResizerConnection c : http1Connections) {
                     if (dispatchSafe(c, toDispatch)) {
                         dispatched = true;
                         break;
@@ -179,8 +131,8 @@ abstract class PoolResizer {
         // snapshot our fields
         int pendingRequestCount = this.pendingRequests.size();
         int pendingConnectionCount = this.pendingConnectionCount.get();
-        int http1ConnectionCount = this.http1Connections.unsafeItems.length;
-        int http2ConnectionCount = this.http2Connections.unsafeItems.length;
+        int http1ConnectionCount = this.http1Connections.size();
+        int http2ConnectionCount = this.http2Connections.size();
 
         if (pendingRequestCount == 0) {
             // if there are no pending requests, there is nothing to do.
@@ -199,17 +151,10 @@ abstract class PoolResizer {
         }
 
         if (connectionsToOpen > 0) {
-            Iterator<PendingRequest> pendingRequestIterator = this.pendingRequests.iterator();
-            if (!pendingRequestIterator.hasNext()) {
-                // no pending requests now
-                return;
-            }
-            // we need to pass a preferred thread to openNewConnection. This is the best we can do
-            Thread preferredThread = pendingRequestIterator.next().requestingThread;
             this.pendingConnectionCount.addAndGet(connectionsToOpen);
             for (int i = 0; i < connectionsToOpen; i++) {
                 try {
-                    openNewConnection(blockedPendingRequests, preferredThread);
+                    openNewConnection(blockedPendingRequests);
                 } catch (Exception e) {
                     try {
                         onNewConnectionFailure(e);
@@ -217,9 +162,6 @@ abstract class PoolResizer {
                         log.error("Internal error", f);
                     }
                 }
-                if (pendingRequestIterator.hasNext()) {
-                    preferredThread = pendingRequestIterator.next().requestingThread;
-                }
             }
             dirty();
         }
@@ -241,9 +183,7 @@ abstract class PoolResizer {
         }
     }
 
-    abstract void openNewConnection(@Nullable BlockHint blockedPendingRequests, @NonNull Thread requestingThread) throws Exception;
-
-    abstract boolean containsThread(@NonNull Thread thread);
+    abstract void openNewConnection(@Nullable BlockHint blockedPendingRequests) throws Exception;
 
     static boolean incrementWithLimit(AtomicInteger variable, int limit) {
         while (true) {
@@ -310,72 +250,11 @@ abstract class PoolResizer {
     }
 
     final void forEachConnection(Consumer<ResizerConnection> c) {
-        http1Connections.forEach(c);
-        http2Connections.forEach(c);
-    }
-
-    /**
-     * This is a concurrent list implementation that is similar to
-     * {@link java.util.concurrent.CopyOnWriteArrayList}, but with some extra optimization for
-     * {@link #doSomeWork()}.
-     */
-    private static final class ConnectionList {
-        private static final ResizerConnection[] EMPTY = new ResizerConnection[0];
-
-        private final Lock lock = new ReentrantLock();
-
-        /**
-         * Copy of {@link #safeItems} <i>only</i> for use in {@link #doSomeWork()}, without lock.
-         * {@link #doSomeWork()} may shuffle and reorder this array in-place as needed.
-         */
-        private volatile ResizerConnection[] unsafeItems = EMPTY;
-        /**
-         * Items for concurrent access, guarded by {@link #lock}.
-         */
-        private ResizerConnection[] safeItems = EMPTY;
-
-        void forEach(Consumer<ResizerConnection> c) {
-            ResizerConnection[] items;
-            lock.lock();
-            try {
-                items = safeItems;
-            } finally {
-                lock.unlock();
-            }
-            for (ResizerConnection item : items) {
-                c.accept(item);
-            }
+        for (ResizerConnection http1Connection : http1Connections) {
+            c.accept(http1Connection);
         }
-
-        void add(ResizerConnection connection) {
-            lock.lock();
-            try {
-                ResizerConnection[] prev = safeItems;
-                ResizerConnection[] next = Arrays.copyOf(prev, prev.length + 1);
-                next[prev.length] = connection;
-                this.safeItems = next;
-                this.unsafeItems = next.clone();
-            } finally {
-                lock.unlock();
-            }
-        }
-
-        void remove(ResizerConnection connection) {
-            lock.lock();
-            try {
-                ResizerConnection[] prev = safeItems;
-                int index = Arrays.asList(prev).indexOf(connection);
-                if (index == -1) {
-                    return;
-                }
-                ResizerConnection[] next = Arrays.copyOf(prev, prev.length - 1);
-                System.arraycopy(prev, index + 1, next, index, prev.length - index - 1);
-
-                this.safeItems = next;
-                this.unsafeItems = next.clone();
-            } finally {
-                lock.unlock();
-            }
+        for (ResizerConnection http2Connection : http2Connections) {
+            c.accept(http2Connection);
         }
     }
 
@@ -397,8 +276,6 @@ abstract class PoolResizer {
     }
 
     abstract static class ResizerConnection {
-        abstract boolean inEventLoop(Thread thread);
-
         /**
          * Attempt to dispatch a stream on this connection.
          *
@@ -410,7 +287,6 @@ abstract class PoolResizer {
     }
 
     static final class PendingRequest extends AtomicBoolean {
-        final Thread requestingThread = Thread.currentThread();
         final @Nullable BlockHint blockHint;
         private final DelayedExecutionFlow<ConnectionManager.PoolHandle> sink = DelayedExecutionFlow.create();
 
diff --git a/http-client/src/test/groovy/io/micronaut/http/client/netty/ConnectionManagerSpec.groovy b/http-client/src/test/groovy/io/micronaut/http/client/netty/ConnectionManagerSpec.groovy
index ccb35a9e1c..1c6364193c 100644
--- a/http-client/src/test/groovy/io/micronaut/http/client/netty/ConnectionManagerSpec.groovy
+++ b/http-client/src/test/groovy/io/micronaut/http/client/netty/ConnectionManagerSpec.groovy
@@ -95,7 +95,7 @@ class ConnectionManagerSpec extends Specification {
             int i = 0
 
             @Override
-            protected ChannelFuture doConnect(DefaultHttpClient.RequestKey requestKey, ConnectionManager.CustomizerAwareInitializer channelInitializer, Thread requestingThread) {
+            protected ChannelFuture doConnect(DefaultHttpClient.RequestKey requestKey, ConnectionManager.CustomizerAwareInitializer channelInitializer) {
                 try {
                     channelInitializer.bootstrappedCustomizer = clientCustomizer
                     def connection = connections[i++]
diff --git a/http-client/src/test/groovy/io/micronaut/http/client/netty/StickyEventLoopSpec.groovy b/http-client/src/test/groovy/io/micronaut/http/client/netty/StickyEventLoopSpec.groovy
deleted file mode 100644
index 0b70bfa7eb..0000000000
--- a/http-client/src/test/groovy/io/micronaut/http/client/netty/StickyEventLoopSpec.groovy
+++ /dev/null
@@ -1,143 +0,0 @@
-package io.micronaut.http.client.netty
-
-import io.micronaut.context.ApplicationContext
-import io.micronaut.context.annotation.Requires
-import io.micronaut.http.annotation.ClientFilter
-import io.micronaut.http.annotation.Controller
-import io.micronaut.http.annotation.Get
-import io.micronaut.http.annotation.ResponseFilter
-import io.micronaut.http.client.HttpClient
-import io.micronaut.http.client.exceptions.HttpClientException
-import io.micronaut.inject.qualifiers.Qualifiers
-import io.micronaut.runtime.server.EmbeddedServer
-import io.micronaut.scheduling.TaskExecutors
-import io.micronaut.scheduling.annotation.ExecuteOn
-import io.netty.channel.EventLoopGroup
-import io.netty.util.concurrent.EventExecutor
-import org.junit.jupiter.api.Assertions
-import reactor.core.publisher.Flux
-import reactor.core.publisher.Mono
-import reactor.core.scheduler.Schedulers
-import spock.lang.Specification
-
-import java.util.concurrent.CountDownLatch
-
-class StickyEventLoopSpec extends Specification {
-    def 'connection reuse is sticky by default'() {
-        given:
-        def numThreads = 10
-        def numClients = 15
-        def ctx = ApplicationContext.run([
-                'spec.name': 'StickyEventLoopSpec',
-                'micronaut.http.client.event-loop-group': 'test-loop',
-                'micronaut.netty.event-loops.test-loop.num-threads': numThreads
-        ])
-        def server = ctx.getBean(EmbeddedServer)
-        server.start()
-        def client = ctx.createBean(HttpClient, server.URI)
-
-        createConcurrentConnections(numClients, ctx, client)
-        checkAllThreads(ctx, client)
-
-        cleanup:
-        client.close()
-        server.stop()
-        ctx.close()
-    }
-
-    def 'in enforced mode, we dont need initial clients'(String mode) {
-        given:
-        def numThreads = 10
-        def ctx = ApplicationContext.run([
-                'spec.name': 'StickyEventLoopSpec',
-                'micronaut.http.client.event-loop-group': 'test-loop',
-                'micronaut.http.client.pool.connection-locality': mode,
-                'micronaut.netty.event-loops.test-loop.num-threads': numThreads
-        ])
-        def server = ctx.getBean(EmbeddedServer)
-        server.start()
-        def client = ctx.createBean(HttpClient, server.URI)
-
-        checkAllThreads(ctx, client)
-
-        cleanup:
-        client.close()
-        server.stop()
-        ctx.close()
-
-        where:
-        mode << ['enforced-if-same-group', 'enforced-always']
-    }
-
-    def 'in enforced-always mode, creating an outside request is forbidden'() {
-        given:
-        def numThreads = 10
-        def ctx = ApplicationContext.run([
-                'spec.name': 'StickyEventLoopSpec',
-                'micronaut.http.client.event-loop-group': 'test-loop',
-                'micronaut.http.client.pool.connection-locality': 'enforced-always',
-                'micronaut.netty.event-loops.test-loop.num-threads': numThreads
-        ])
-        def server = ctx.getBean(EmbeddedServer)
-        server.start()
-        def client = ctx.createBean(HttpClient, server.URI)
-
-        when:
-        client.toBlocking().retrieve("/sticky/simple")
-        then:
-        thrown HttpClientException
-
-        cleanup:
-        client.close()
-        server.stop()
-        ctx.close()
-    }
-
-    private static void checkAllThreads(ApplicationContext ctx, HttpClient client) {
-        def filter = ctx.getBean(LoopDetectingFilter)
-        def group = ctx.getBean(EventLoopGroup, Qualifiers.byName("test-loop"))
-        for (EventExecutor loop : group) {
-            Mono.defer { Mono.from(client.retrieve("/sticky/simple")) }
-                    .doOnNext {Assertions.assertTrue(loop.inEventLoop(filter.thread)) }
-                    .subscribeOn(Schedulers.fromExecutor(loop))
-                    .block()
-        }
-    }
-
-    private static void createConcurrentConnections(int numClients, ApplicationContext ctx, HttpClient client) {
-        ctx.getBean(MyController).latch = new CountDownLatch(numClients)
-        Flux.range(0, numClients)
-                .flatMap(i -> client.retrieve('/sticky/concurrent'), Integer.MAX_VALUE)
-                .blockLast()
-    }
-
-    @Controller("/sticky")
-    @Requires(property = "spec.name", value = "StickyEventLoopSpec")
-    static class MyController {
-        CountDownLatch latch
-
-        @Get("/simple")
-        def simple() {
-            return "foo"
-        }
-
-        @Get("/concurrent")
-        @ExecuteOn(TaskExecutors.BLOCKING)
-        def concurrent() {
-            latch.countDown()
-            latch.await()
-            return "foo"
-        }
-    }
-
-    @ClientFilter("/sticky/simple")
-    @Requires(property = "spec.name", value = "StickyEventLoopSpec")
-    static class LoopDetectingFilter {
-        Thread thread
-
-        @ResponseFilter
-        void observe() {
-            thread = Thread.currentThread()
-        }
-    }
-}
