diff --git a/ktor-client/ktor-client-plugins/ktor-client-logging/api/ktor-client-logging.api b/ktor-client/ktor-client-plugins/ktor-client-logging/api/ktor-client-logging.api
index 6f2df7f25..cbfee3010 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-logging/api/ktor-client-logging.api
+++ b/ktor-client/ktor-client-plugins/ktor-client-logging/api/ktor-client-logging.api
@@ -37,14 +37,24 @@ public final class io/ktor/client/plugins/logging/LoggerKt {
 public final class io/ktor/client/plugins/logging/LoggingConfig {
 	public fun <init> ()V
 	public final fun filter (Lkotlin/jvm/functions/Function1;)V
+	public final fun getFormat ()Lio/ktor/client/plugins/logging/LoggingFormat;
 	public final fun getLevel ()Lio/ktor/client/plugins/logging/LogLevel;
 	public final fun getLogger ()Lio/ktor/client/plugins/logging/Logger;
 	public final fun sanitizeHeader (Ljava/lang/String;Lkotlin/jvm/functions/Function1;)V
 	public static synthetic fun sanitizeHeader$default (Lio/ktor/client/plugins/logging/LoggingConfig;Ljava/lang/String;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
+	public final fun setFormat (Lio/ktor/client/plugins/logging/LoggingFormat;)V
 	public final fun setLevel (Lio/ktor/client/plugins/logging/LogLevel;)V
 	public final fun setLogger (Lio/ktor/client/plugins/logging/Logger;)V
 }
 
+public final class io/ktor/client/plugins/logging/LoggingFormat : java/lang/Enum {
+	public static final field Default Lio/ktor/client/plugins/logging/LoggingFormat;
+	public static final field OkHttp Lio/ktor/client/plugins/logging/LoggingFormat;
+	public static fun getEntries ()Lkotlin/enums/EnumEntries;
+	public static fun valueOf (Ljava/lang/String;)Lio/ktor/client/plugins/logging/LoggingFormat;
+	public static fun values ()[Lio/ktor/client/plugins/logging/LoggingFormat;
+}
+
 public final class io/ktor/client/plugins/logging/LoggingKt {
 	public static final fun Logging (Lio/ktor/client/HttpClientConfig;Lkotlin/jvm/functions/Function1;)V
 	public static synthetic fun Logging$default (Lio/ktor/client/HttpClientConfig;Lkotlin/jvm/functions/Function1;ILjava/lang/Object;)V
diff --git a/ktor-client/ktor-client-plugins/ktor-client-logging/api/ktor-client-logging.klib.api b/ktor-client/ktor-client-plugins/ktor-client-logging/api/ktor-client-logging.klib.api
index ebccae08f..db623464b 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-logging/api/ktor-client-logging.klib.api
+++ b/ktor-client/ktor-client-plugins/ktor-client-logging/api/ktor-client-logging.klib.api
@@ -26,6 +26,17 @@ final enum class io.ktor.client.plugins.logging/LogLevel : kotlin/Enum<io.ktor.c
     final fun values(): kotlin/Array<io.ktor.client.plugins.logging/LogLevel> // io.ktor.client.plugins.logging/LogLevel.values|values#static(){}[0]
 }
 
+final enum class io.ktor.client.plugins.logging/LoggingFormat : kotlin/Enum<io.ktor.client.plugins.logging/LoggingFormat> { // io.ktor.client.plugins.logging/LoggingFormat|null[0]
+    enum entry Default // io.ktor.client.plugins.logging/LoggingFormat.Default|null[0]
+    enum entry OkHttp // io.ktor.client.plugins.logging/LoggingFormat.OkHttp|null[0]
+
+    final val entries // io.ktor.client.plugins.logging/LoggingFormat.entries|#static{}entries[0]
+        final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.plugins.logging/LoggingFormat> // io.ktor.client.plugins.logging/LoggingFormat.entries.<get-entries>|<get-entries>#static(){}[0]
+
+    final fun valueOf(kotlin/String): io.ktor.client.plugins.logging/LoggingFormat // io.ktor.client.plugins.logging/LoggingFormat.valueOf|valueOf#static(kotlin.String){}[0]
+    final fun values(): kotlin/Array<io.ktor.client.plugins.logging/LoggingFormat> // io.ktor.client.plugins.logging/LoggingFormat.values|values#static(){}[0]
+}
+
 abstract interface io.ktor.client.plugins.logging/Logger { // io.ktor.client.plugins.logging/Logger|null[0]
     abstract fun log(kotlin/String) // io.ktor.client.plugins.logging/Logger.log|log(kotlin.String){}[0]
 
@@ -35,6 +46,9 @@ abstract interface io.ktor.client.plugins.logging/Logger { // io.ktor.client.plu
 final class io.ktor.client.plugins.logging/LoggingConfig { // io.ktor.client.plugins.logging/LoggingConfig|null[0]
     constructor <init>() // io.ktor.client.plugins.logging/LoggingConfig.<init>|<init>(){}[0]
 
+    final var format // io.ktor.client.plugins.logging/LoggingConfig.format|{}format[0]
+        final fun <get-format>(): io.ktor.client.plugins.logging/LoggingFormat // io.ktor.client.plugins.logging/LoggingConfig.format.<get-format>|<get-format>(){}[0]
+        final fun <set-format>(io.ktor.client.plugins.logging/LoggingFormat) // io.ktor.client.plugins.logging/LoggingConfig.format.<set-format>|<set-format>(io.ktor.client.plugins.logging.LoggingFormat){}[0]
     final var level // io.ktor.client.plugins.logging/LoggingConfig.level|{}level[0]
         final fun <get-level>(): io.ktor.client.plugins.logging/LogLevel // io.ktor.client.plugins.logging/LoggingConfig.level.<get-level>|<get-level>(){}[0]
         final fun <set-level>(io.ktor.client.plugins.logging/LogLevel) // io.ktor.client.plugins.logging/LoggingConfig.level.<set-level>|<set-level>(io.ktor.client.plugins.logging.LogLevel){}[0]
diff --git a/ktor-client/ktor-client-plugins/ktor-client-logging/build.gradle.kts b/ktor-client/ktor-client-plugins/ktor-client-logging/build.gradle.kts
index edb59c978..e0969111f 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-logging/build.gradle.kts
+++ b/ktor-client/ktor-client-plugins/ktor-client-logging/build.gradle.kts
@@ -22,6 +22,7 @@ kotlin.sourceSets {
     jvmTest {
         dependencies {
             api(project(":ktor-shared:ktor-serialization:ktor-serialization-jackson"))
+            api(project(":ktor-client:ktor-client-plugins:ktor-client-encoding"))
         }
     }
 }
diff --git a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt
index 2665b76d5..517a6f338 100644
--- a/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt
+++ b/ktor-client/ktor-client-plugins/ktor-client-logging/common/src/io/ktor/client/plugins/logging/Logging.kt
@@ -7,20 +7,39 @@ package io.ktor.client.plugins.logging
 import io.ktor.client.*
 import io.ktor.client.call.*
 import io.ktor.client.plugins.api.*
+import io.ktor.client.plugins.isSaved
 import io.ktor.client.plugins.observer.*
 import io.ktor.client.request.*
 import io.ktor.client.statement.*
+import io.ktor.client.utils.*
 import io.ktor.http.*
 import io.ktor.http.content.*
 import io.ktor.util.*
 import io.ktor.util.pipeline.*
 import io.ktor.utils.io.*
 import io.ktor.utils.io.charsets.*
-import kotlinx.coroutines.*
+import io.ktor.utils.io.core.readText
+import io.ktor.utils.io.core.writeFully
+import kotlinx.coroutines.DelicateCoroutinesApi
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.GlobalScope
+import kotlinx.coroutines.async
+import kotlinx.coroutines.launch
+import kotlinx.io.Buffer
 
 private val ClientCallLogger = AttributeKey<HttpClientCallLogger>("CallLogger")
 private val DisableLogging = AttributeKey<Unit>("DisableLogging")
 
+public enum class LoggingFormat {
+    Default,
+
+    /**
+     * [OkHttp logging format](https://github.com/square/okhttp/blob/parent-4.12.0/okhttp-logging-interceptor/src/main/kotlin/okhttp3/logging/HttpLoggingInterceptor.kt#L48-L105).
+     * Writes only application-level logs because the low-level HTTP communication is hidden within the engine implementations.
+     */
+    OkHttp
+}
+
 /**
  * A configuration for the [Logging] plugin.
  */
@@ -31,6 +50,9 @@ public class LoggingConfig {
 
     private var _logger: Logger? = null
 
+    /** A general format for logging requests and responses. See [LoggingFormat]. */
+    public var format: LoggingFormat = LoggingFormat.Default
+
     /**
      * Specifies a [Logger] instance.
      */
@@ -69,15 +91,342 @@ public class LoggingConfig {
  *
  * You can learn more from [Logging](https://ktor.io/docs/client-logging.html).
  */
-@OptIn(InternalAPI::class)
+@OptIn(InternalAPI::class, DelicateCoroutinesApi::class)
 public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging", ::LoggingConfig) {
     val logger: Logger = pluginConfig.logger
     val level: LogLevel = pluginConfig.level
     val filters: List<(HttpRequestBuilder) -> Boolean> = pluginConfig.filters
     val sanitizedHeaders: List<SanitizedHeader> = pluginConfig.sanitizedHeaders
+    val okHttpFormat = pluginConfig.format == LoggingFormat.OkHttp
 
     fun shouldBeLogged(request: HttpRequestBuilder): Boolean = filters.isEmpty() || filters.any { it(request) }
 
+    fun isNone(): Boolean = level == LogLevel.NONE
+    fun isInfo(): Boolean = level == LogLevel.INFO
+    fun isHeaders(): Boolean = level == LogLevel.HEADERS
+    fun isBody(): Boolean = level == LogLevel.BODY || level == LogLevel.ALL
+
+    /**
+     * Detects if the body is a binary data
+     * @return
+     * Boolean: true if the body is a binary data.
+     * Long?: body size if calculated.
+     * ByteReadChannel: body channel with the original data.
+     */
+    suspend fun detectIfBinary(
+        body: ByteReadChannel,
+        contentLength: Long?,
+        contentType: ContentType?,
+        headers: Headers
+    ): Triple<Boolean, Long?, ByteReadChannel> {
+        if (headers.contains(HttpHeaders.ContentEncoding)) {
+            return Triple(true, contentLength, body)
+        }
+
+        val charset = if (contentType != null) {
+            contentType.charset() ?: Charsets.UTF_8
+        } else {
+            Charsets.UTF_8
+        }
+
+        var isBinary = false
+        val firstChunk = ByteArray(1024)
+        val firstReadSize = body.readAvailable(firstChunk)
+
+        if (firstReadSize < 1) {
+            return Triple(false, 0L, body)
+        }
+
+        val buffer = Buffer().apply { writeFully(firstChunk, 0, firstReadSize) }
+        val firstChunkText = charset.newDecoder().decode(buffer, firstReadSize)
+
+        var lastCharIndex = -1
+        for (ch in firstChunkText) {
+            lastCharIndex += 1
+        }
+
+        for ((i, ch) in firstChunkText.withIndex()) {
+            if (ch == '\ufffd' && i != lastCharIndex) {
+                isBinary = true
+                break
+            }
+        }
+
+        if (!isBinary) {
+            val channel = ByteChannel()
+
+            val copied = client.async {
+                channel.writeFully(firstChunk, 0, firstReadSize)
+                val copied = body.copyTo(channel)
+                channel.flushAndClose()
+                copied
+            }.await()
+
+            return Triple(isBinary, copied + firstReadSize, channel)
+        }
+
+        return Triple(isBinary, contentLength, body)
+    }
+
+    suspend fun logRequestBody(
+        content: OutgoingContent,
+        contentLength: Long?,
+        headers: Headers,
+        method: HttpMethod,
+        body: ByteReadChannel
+    ) {
+        val (isBinary, size, newBody) = detectIfBinary(body, contentLength, content.contentType, headers)
+
+        if (!isBinary) {
+            val contentType = content.contentType
+            val charset = if (contentType != null) {
+                contentType.charset() ?: Charsets.UTF_8
+            } else {
+                Charsets.UTF_8
+            }
+
+            logger.log(newBody.readRemaining().readText(charset = charset))
+            logger.log("--> END ${method.value} ($size-byte body)")
+        } else {
+            var type = "binary"
+            if (headers.contains(HttpHeaders.ContentEncoding)) {
+                type = "encoded"
+            }
+
+            if (size != null) {
+                logger.log("--> END ${method.value} ($type $size-byte body omitted)")
+            } else {
+                logger.log("--> END ${method.value} ($type body omitted)")
+            }
+        }
+    }
+
+    suspend fun logOutgoingContent(
+        content: OutgoingContent,
+        method: HttpMethod,
+        headers: Headers,
+        process: (ByteReadChannel) -> ByteReadChannel = { it }
+    ): OutgoingContent? {
+        return when (content) {
+            is OutgoingContent.ByteArrayContent -> {
+                val bytes = content.bytes()
+                logRequestBody(content, bytes.size.toLong(), headers, method, ByteReadChannel(bytes))
+                null
+            }
+            is OutgoingContent.ContentWrapper -> {
+                logOutgoingContent(content.delegate(), method, headers, process)
+            }
+            is OutgoingContent.NoContent -> {
+                logger.log("--> END ${method.value}")
+                null
+            }
+            is OutgoingContent.ProtocolUpgrade -> {
+                logger.log("--> END ${method.value}")
+                null
+            }
+            is OutgoingContent.ReadChannelContent -> {
+                val (origChannel, newChannel) = content.readFrom().split(client)
+                logRequestBody(content, content.contentLength, headers, method, newChannel)
+                LoggedContent(content, origChannel)
+            }
+            is OutgoingContent.WriteChannelContent -> {
+                val channel = ByteChannel()
+
+                client.launch {
+                    content.writeTo(channel)
+                    channel.close()
+                }
+
+                val (origChannel, newChannel) = channel.split(client)
+                logRequestBody(content, content.contentLength, headers, method, newChannel)
+                LoggedContent(content, origChannel)
+            }
+        }
+    }
+
+    suspend fun logRequestOkHttpFormat(request: HttpRequestBuilder): OutgoingContent? {
+        if (isNone()) return null
+
+        val uri = URLBuilder().takeFrom(request.url).build().pathQuery()
+        val body = request.body
+        val headers = HeadersBuilder().apply {
+            if (body is OutgoingContent &&
+                request.method != HttpMethod.Get &&
+                request.method != HttpMethod.Head &&
+                body !is EmptyContent
+            ) {
+                body.contentType?.let {
+                    appendIfNameAbsent(HttpHeaders.ContentType, it.toString())
+                }
+                body.contentLength?.let {
+                    appendIfNameAbsent(HttpHeaders.ContentLength, it.toString())
+                }
+            }
+            appendAll(request.headers)
+        }.build()
+
+        val contentLength = headers[HttpHeaders.ContentLength]?.toLongOrNull()
+        val startLine = when {
+            (request.method == HttpMethod.Get) ||
+                (request.method == HttpMethod.Head) ||
+                ((isHeaders() || isBody()) && contentLength != null) ||
+                (isHeaders() && contentLength == null) ||
+                headers.contains(HttpHeaders.ContentEncoding) -> "--> ${request.method.value} $uri"
+
+            isInfo() && contentLength != null -> "--> ${request.method.value} $uri ($contentLength-byte body)"
+
+            body is OutgoingContent.WriteChannelContent ||
+                body is OutgoingContent.ReadChannelContent -> "--> ${request.method.value} $uri (unknown-byte body)"
+
+            else -> {
+                val size = computeRequestBodySize(request.body, headers)
+                "--> ${request.method.value} $uri ($size-byte body)"
+            }
+        }
+
+        logger.log(startLine)
+
+        if (!isHeaders() && !isBody()) {
+            return null
+        }
+
+        for ((name, values) in headers.entries()) {
+            if (sanitizedHeaders.find { sh -> sh.predicate(name) } == null) {
+                logger.log("$name: ${values.joinToString(separator = ", ")}")
+            } else {
+                logger.log("$name: ██")
+            }
+        }
+
+        if (!isBody() || request.method == HttpMethod.Get || request.method == HttpMethod.Head) {
+            logger.log("--> END ${request.method.value}")
+            return null
+        }
+
+        logger.log("")
+
+        if (body !is OutgoingContent) {
+            logger.log("--> END ${request.method.value}")
+            return null
+        }
+
+        val newContent = if (request.headers[HttpHeaders.ContentEncoding] == "gzip") {
+            logOutgoingContent(body, request.method, headers) { channel ->
+                GZipEncoder.decode(channel)
+            }
+        } else {
+            logOutgoingContent(body, request.method, headers)
+        }
+
+        return newContent
+    }
+
+    suspend fun logResponseBody(response: HttpResponse, body: ByteReadChannel) {
+        logger.log("")
+
+        val (isBinary, size, newBody) = detectIfBinary(
+            body,
+            response.contentLength(),
+            response.contentType(),
+            response.headers
+        )
+        val duration = response.responseTime.timestamp - response.requestTime.timestamp
+
+        if (size == 0L) {
+            logger.log("<-- END HTTP (${duration}ms, $size-byte body)")
+            return
+        }
+
+        if (!isBinary) {
+            val contentType = response.contentType()
+            val charset = if (contentType != null) {
+                contentType.charset() ?: Charsets.UTF_8
+            } else {
+                Charsets.UTF_8
+            }
+
+            logger.log(newBody.readRemaining().readText(charset = charset))
+            logger.log("<-- END HTTP (${duration}ms, $size-byte body)")
+        } else {
+            var type = "binary"
+            if (response.headers.contains(HttpHeaders.ContentEncoding)) {
+                type = "encoded"
+            }
+
+            if (size != null) {
+                logger.log("<-- END HTTP (${duration}ms, $type $size-byte body omitted)")
+            } else {
+                logger.log("<-- END HTTP (${duration}ms, $type body omitted)")
+            }
+        }
+    }
+
+    suspend fun logResponseOkHttpFormat(response: HttpResponse): HttpResponse {
+        if (isNone()) return response
+
+        val contentLength = response.headers[HttpHeaders.ContentLength]?.toLongOrNull()
+        val request = response.request
+        val duration = response.responseTime.timestamp - response.requestTime.timestamp
+
+        val startLine = when {
+            response.headers[HttpHeaders.TransferEncoding] == "chunked" &&
+                (isInfo() || isHeaders()) ->
+                "<-- ${response.status} ${request.url.pathQuery()} (${duration}ms, unknown-byte body)"
+
+            isInfo() && contentLength != null ->
+                "<-- ${response.status} ${request.url.pathQuery()} (${duration}ms, $contentLength-byte body)"
+
+            isBody() ||
+                (isInfo() && contentLength == null) ||
+                (isHeaders() && contentLength != null) ||
+                (response.headers[HttpHeaders.ContentEncoding] == "gzip") ->
+                "<-- ${response.status} ${request.url.pathQuery()} (${duration}ms)"
+
+            else -> "<-- ${response.status} ${request.url.pathQuery()} (${duration}ms, unknown-byte body)"
+        }
+
+        logger.log(startLine)
+
+        if (!isHeaders() && !isBody()) {
+            return response
+        }
+
+        for ((name, values) in response.headers.entries()) {
+            if (sanitizedHeaders.find { sh -> sh.predicate(name) } == null) {
+                logger.log("$name: ${values.joinToString(separator = ", ")}")
+            } else {
+                logger.log("$name: ██")
+            }
+        }
+
+        if (!isBody()) {
+            logger.log("<-- END HTTP")
+            return response
+        }
+
+        if (contentLength != null && contentLength == 0L) {
+            logger.log("<-- END HTTP (${duration}ms, $contentLength-byte body)")
+            return response
+        }
+
+        if (response.contentType() == ContentType.Text.EventStream) {
+            logger.log("<-- END HTTP (streaming)")
+            return response
+        }
+
+        if (response.isSaved) {
+            logResponseBody(response, response.rawContent)
+            return response
+        }
+
+        val (origChannel, newChannel) = response.rawContent.split(response)
+
+        logResponseBody(response, newChannel)
+
+        val call = response.call.wrapWithContent(origChannel)
+        return call.response
+    }
+
     @OptIn(DelicateCoroutinesApi::class)
     suspend fun logRequestBody(
         content: OutgoingContent,
@@ -165,6 +514,23 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
             return@on
         }
 
+        if (okHttpFormat) {
+            val content = logRequestOkHttpFormat(request)
+
+            try {
+                if (content != null) {
+                    proceedWith(content)
+                } else {
+                    proceed()
+                }
+            } catch (cause: Throwable) {
+                logger.log("<-- HTTP FAILED: $cause")
+                throw cause
+            }
+
+            return@on
+        }
+
         val loggedRequest = try {
             logRequest(request)
         } catch (_: Throwable) {
@@ -180,7 +546,18 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
         }
     }
 
+    on(ResponseAfterEncodingHook) { response ->
+        if (okHttpFormat) {
+            val newResponse = logResponseOkHttpFormat(response)
+            if (newResponse != response) {
+                proceedWith(newResponse)
+            }
+        }
+    }
+
     on(ResponseHook) { response ->
+        if (okHttpFormat) return@on
+
         if (level == LogLevel.NONE || response.call.attributes.contains(DisableLogging)) return@on
 
         val callLogger = response.call.attributes[ClientCallLogger]
@@ -201,6 +578,8 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
     }
 
     on(ReceiveHook) { call ->
+        if (okHttpFormat) return@on
+
         if (level == LogLevel.NONE || call.attributes.contains(DisableLogging)) {
             return@on
         }
@@ -217,6 +596,8 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
         }
     }
 
+    if (okHttpFormat) return@createClientPlugin
+
     if (!level.body) return@createClientPlugin
 
     @OptIn(InternalAPI::class)
@@ -239,6 +620,34 @@ public val Logging: ClientPlugin<LoggingConfig> = createClientPlugin("Logging",
     ResponseObserver.install(ResponseObserver.prepare { onResponse(observer) }, client)
 }
 
+private fun Url.pathQuery(): String {
+    return buildString {
+        if (encodedPath.isEmpty()) {
+            append("/")
+        } else {
+            append(encodedPath)
+        }
+
+        if (!encodedQuery.isEmpty()) {
+            append("?")
+            append(encodedQuery)
+        }
+    }
+}
+
+@OptIn(DelicateCoroutinesApi::class)
+private fun computeRequestBodySize(content: Any, headers: Headers): Long {
+    check(content is OutgoingContent)
+
+    return when (content) {
+        is OutgoingContent.ByteArrayContent -> content.bytes().size.toLong()
+        is OutgoingContent.ContentWrapper -> computeRequestBodySize(content.delegate(), content.headers)
+        is OutgoingContent.NoContent -> 0
+        is OutgoingContent.ProtocolUpgrade -> 0
+        else -> error("Unable to calculate the size for type ${content::class.simpleName}")
+    }
+}
+
 /**
  * Configures and installs [Logging] in [HttpClient].
  */
@@ -268,10 +677,30 @@ private object ResponseHook : ClientHook<suspend ResponseHook.Context.(response:
     }
 }
 
+private object ResponseAfterEncodingHook :
+    ClientHook<suspend ResponseAfterEncodingHook.Context.(response: HttpResponse) -> Unit> {
+
+    class Context(private val context: PipelineContext<HttpResponse, Unit>) {
+        suspend fun proceedWith(response: HttpResponse) = context.proceedWith(response)
+    }
+
+    override fun install(
+        client: HttpClient,
+        handler: suspend Context.(response: HttpResponse) -> Unit
+    ) {
+        val afterState = PipelinePhase("AfterState")
+        client.receivePipeline.insertPhaseAfter(HttpReceivePipeline.State, afterState)
+        client.receivePipeline.intercept(afterState) {
+            handler(Context(this), subject)
+        }
+    }
+}
+
 private object SendHook : ClientHook<suspend SendHook.Context.(response: HttpRequestBuilder) -> Unit> {
 
     class Context(private val context: PipelineContext<Any, HttpRequestBuilder>) {
         suspend fun proceedWith(content: Any) = context.proceedWith(content)
+        suspend fun proceed() = context.proceed()
     }
 
     override fun install(
