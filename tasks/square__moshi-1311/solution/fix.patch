diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/AdapterGenerator.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/AdapterGenerator.kt
index ce6cfede..8326f6db 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/AdapterGenerator.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/AdapterGenerator.kt
@@ -17,6 +17,7 @@ package com.squareup.moshi.kotlin.codegen.api
 
 import com.squareup.kotlinpoet.ARRAY
 import com.squareup.kotlinpoet.AnnotationSpec
+import com.squareup.kotlinpoet.AnnotationSpec.UseSiteTarget.FILE
 import com.squareup.kotlinpoet.CodeBlock
 import com.squareup.kotlinpoet.FileSpec
 import com.squareup.kotlinpoet.FunSpec
@@ -82,9 +83,12 @@ internal class AdapterGenerator(
       // like for stylistic reasons.
       "LocalVariableName",
       // KotlinPoet always generates explicit public modifiers for public members.
-      "RedundantVisibilityModifier"
+      "RedundantVisibilityModifier",
+      // For LambdaTypeNames we have to import kotlin.functions.* types
+      "PLATFORM_CLASS_MAPPED_TO_KOTLIN"
     ).let { suppressions ->
       AnnotationSpec.builder(Suppress::class)
+        .useSiteTarget(FILE)
         .addMember(
           suppressions.indices.joinToString { "%S" },
           *suppressions
@@ -175,6 +179,7 @@ internal class AdapterGenerator(
     val generatedAdapter = generateType().let(typeHook)
     val result = FileSpec.builder(className.packageName, adapterName)
     result.addComment("Code generated by moshi-kotlin-codegen. Do not edit.")
+    result.addAnnotation(COMMON_SUPPRESS)
     result.addType(generatedAdapter)
     return PreparedAdapter(result.build(), generatedAdapter.createProguardRule())
   }
@@ -224,7 +229,6 @@ internal class AdapterGenerator(
 
   private fun generateType(): TypeSpec {
     val result = TypeSpec.classBuilder(adapterName)
-      .addAnnotation(COMMON_SUPPRESS)
 
     result.superclass(jsonAdapterTypeName)
 
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/kotlintypes.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/kotlintypes.kt
index 5dcbb915..55413247 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/kotlintypes.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/kotlintypes.kt
@@ -27,6 +27,7 @@ import com.squareup.kotlinpoet.FLOAT
 import com.squareup.kotlinpoet.INT
 import com.squareup.kotlinpoet.KModifier
 import com.squareup.kotlinpoet.LONG
+import com.squareup.kotlinpoet.LambdaTypeName
 import com.squareup.kotlinpoet.NOTHING
 import com.squareup.kotlinpoet.ParameterizedTypeName
 import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
@@ -46,6 +47,18 @@ internal fun TypeName.findRawType(): ClassName? {
   return when (this) {
     is ClassName -> this
     is ParameterizedTypeName -> rawType
+    is LambdaTypeName -> {
+      var count = parameters.size
+      if (receiver != null) {
+        count++
+      }
+      val functionSimpleName = if (count >= 23) {
+        "FunctionN"
+      } else {
+        "Function$count"
+      }
+      ClassName("kotlin.jvm.functions", functionSimpleName)
+    }
     else -> null
   }
 }
@@ -80,6 +93,7 @@ internal fun TypeName.asTypeBlock(): CodeBlock {
       val bound = bounds.firstOrNull() ?: ANY
       return bound.asTypeBlock()
     }
+    is LambdaTypeName -> return rawType().asTypeBlock()
     is ClassName -> {
       // Check against the non-nullable version for equality, but we'll keep the nullability in
       // consideration when creating the CodeBlock if needed.
@@ -151,6 +165,14 @@ internal fun WildcardTypeName.deepCopy(transform: (TypeName) -> TypeName): TypeN
   }
 }
 
+internal fun LambdaTypeName.deepCopy(transform: (TypeName) -> TypeName): TypeName {
+  return LambdaTypeName.get(
+    receiver?.let(transform),
+    parameters.map { it.toBuilder(type = transform(it.type)).build() },
+    transform(returnType)
+  ).copy(nullable = isNullable, annotations = annotations, suspending = isSuspending)
+}
+
 internal interface TypeVariableResolver {
   val parametersMap: Map<String, TypeVariableName>
   operator fun get(index: String): TypeVariableName
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
index 3531e4db..e9ff9201 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
@@ -18,6 +18,7 @@ package com.squareup.moshi.kotlin.codegen
 import com.squareup.kotlinpoet.AnnotationSpec
 import com.squareup.kotlinpoet.ClassName
 import com.squareup.kotlinpoet.KModifier
+import com.squareup.kotlinpoet.LambdaTypeName
 import com.squareup.kotlinpoet.ParameterizedTypeName
 import com.squareup.kotlinpoet.TypeName
 import com.squareup.kotlinpoet.TypeSpec
@@ -530,6 +531,7 @@ internal fun TypeName.unwrapTypeAlias(): TypeName {
     is ParameterizedTypeName -> deepCopy(TypeName::unwrapTypeAlias)
     is TypeVariableName -> deepCopy(transform = TypeName::unwrapTypeAlias)
     is WildcardTypeName -> deepCopy(TypeName::unwrapTypeAlias)
+    is LambdaTypeName -> deepCopy(TypeName::unwrapTypeAlias)
     else -> throw UnsupportedOperationException("Type '${javaClass.simpleName}' is illegal. Only classes, parameterized types, wildcard types, or type variables are allowed.")
   }
 }
