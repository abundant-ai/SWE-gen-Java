diff --git a/documentation/modules/ROOT/partials/release-notes/release-notes-6.1.0-M2.adoc b/documentation/modules/ROOT/partials/release-notes/release-notes-6.1.0-M2.adoc
index ba9b0fb0f..1454510fa 100644
--- a/documentation/modules/ROOT/partials/release-notes/release-notes-6.1.0-M2.adoc
+++ b/documentation/modules/ROOT/partials/release-notes/release-notes-6.1.0-M2.adoc
@@ -52,6 +52,10 @@ repository on GitHub.
 * Introduce new `trimStacktrace(Class<?>)` and `retainStackTraceElements(int)`
   methods for `AssertionFailureBuilder`. These allow user defined assertions to
   trim their stacktrace.
+* Generic inline value classes (such as `kotlin.Result<T>`) can now be used as parameters
+  in `@ParameterizedTest` methods when `kotlin-reflect` is on the classpath.
+  Note: Primitive-wrapper inline value classes (e.g., `UInt`, custom value classes wrapping
+  primitives) are not yet supported.
 
 
 [[v6.1.0-M2-junit-vintage]]
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/support/MethodReflectionUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/support/MethodReflectionUtils.java
index 02c8ca228..8aa593899 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/support/MethodReflectionUtils.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/support/MethodReflectionUtils.java
@@ -13,15 +13,19 @@ package org.junit.jupiter.engine.support;
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.platform.commons.util.KotlinReflectionUtils.getKotlinSuspendingFunctionGenericReturnType;
 import static org.junit.platform.commons.util.KotlinReflectionUtils.getKotlinSuspendingFunctionReturnType;
+import static org.junit.platform.commons.util.KotlinReflectionUtils.invokeKotlinFunction;
 import static org.junit.platform.commons.util.KotlinReflectionUtils.invokeKotlinSuspendingFunction;
 import static org.junit.platform.commons.util.KotlinReflectionUtils.isKotlinSuspendingFunction;
+import static org.junit.platform.commons.util.KotlinReflectionUtils.isKotlinType;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
+import java.util.Arrays;
 
 import org.apiguardian.api.API;
 import org.jspecify.annotations.Nullable;
 import org.junit.platform.commons.support.ReflectionSupport;
+import org.junit.platform.commons.util.KotlinReflectionUtils;
 
 @API(status = INTERNAL, since = "6.0")
 public class MethodReflectionUtils {
@@ -42,9 +46,21 @@ public class MethodReflectionUtils {
 		if (isKotlinSuspendingFunction(method)) {
 			return invokeKotlinSuspendingFunction(method, target, arguments);
 		}
+		if (isKotlinType(method.getDeclaringClass()) && KotlinReflectionUtils.isKotlinReflectPresent()
+				&& hasInlineTypeArgument(arguments)) {
+			return invokeKotlinFunction(method, target, arguments);
+		}
 		return ReflectionSupport.invokeMethod(method, target, arguments);
 	}
 
+	private static boolean hasInlineTypeArgument(@Nullable Object[] arguments) {
+		if (!KotlinReflectionUtils.isKotlinReflectPresent()) {
+			return false;
+		}
+
+		return arguments.length > 0 && Arrays.stream(arguments).anyMatch(KotlinReflectionUtils::isInstanceOfInlineType);
+	}
+
 	private MethodReflectionUtils() {
 	}
 }
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/KotlinFunctionUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/KotlinFunctionUtils.java
new file mode 100644
index 000000000..9d75be425
--- /dev/null
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/KotlinFunctionUtils.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.commons.util;
+
+import static kotlin.jvm.JvmClassMappingKt.getJavaClass;
+import static kotlin.reflect.full.KCallables.callSuspendBy;
+import static kotlin.reflect.jvm.KCallablesJvm.isAccessible;
+import static kotlin.reflect.jvm.KCallablesJvm.setAccessible;
+import static kotlin.reflect.jvm.KTypesJvm.getJvmErasure;
+import static kotlin.reflect.jvm.ReflectJvmMapping.getJavaType;
+import static kotlinx.coroutines.BuildersKt.runBlocking;
+import static org.junit.platform.commons.util.ExceptionUtils.throwAsUncheckedException;
+import static org.junit.platform.commons.util.ReflectionUtils.EMPTY_CLASS_ARRAY;
+import static org.junit.platform.commons.util.ReflectionUtils.getUnderlyingCause;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Parameter;
+import java.lang.reflect.Type;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.jspecify.annotations.Nullable;
+import org.junit.platform.commons.JUnitException;
+
+import kotlin.Unit;
+import kotlin.coroutines.EmptyCoroutineContext;
+import kotlin.reflect.KFunction;
+import kotlin.reflect.KParameter;
+import kotlin.reflect.jvm.ReflectJvmMapping;
+
+class KotlinFunctionUtils {
+
+	static Class<?> getReturnType(Method method) {
+		var returnType = getJavaClass(getJvmErasure(getKotlinFunction(method).getReturnType()));
+		if (Unit.class.equals(returnType)) {
+			return void.class;
+		}
+		return returnType;
+	}
+
+	static Type getGenericReturnType(Method method) {
+		return getJavaType(getKotlinFunction(method).getReturnType());
+	}
+
+	static Parameter[] getParameters(Method method) {
+		var parameterCount = method.getParameterCount();
+		if (parameterCount == 1) {
+			return new Parameter[0];
+		}
+		return Arrays.copyOf(method.getParameters(), parameterCount - 1);
+	}
+
+	static Class<?>[] getParameterTypes(Method method) {
+		var parameterCount = method.getParameterCount();
+		if (parameterCount == 1) {
+			return EMPTY_CLASS_ARRAY;
+		}
+		return Arrays.stream(method.getParameterTypes()).limit(parameterCount - 1).toArray(Class<?>[]::new);
+	}
+
+	static @Nullable Object invokeKotlinFunction(Method method, @Nullable Object target, @Nullable Object[] args) {
+		try {
+			return invokeKotlinFunction(getKotlinFunction(method), target, args);
+		}
+		catch (InterruptedException e) {
+			throw throwAsUncheckedException(e);
+		}
+	}
+
+	private static <T extends @Nullable Object> T invokeKotlinFunction(KFunction<T> function, @Nullable Object target,
+			@Nullable Object[] args) throws InterruptedException {
+		if (!isAccessible(function)) {
+			setAccessible(function, true);
+		}
+		return function.callBy(toArgumentMap(target, args, function));
+	}
+
+	static @Nullable Object invokeKotlinSuspendingFunction(Method method, @Nullable Object target,
+			@Nullable Object[] args) {
+		try {
+			return invokeKotlinSuspendingFunction(getKotlinFunction(method), target, args);
+		}
+		catch (InterruptedException e) {
+			throw throwAsUncheckedException(e);
+		}
+	}
+
+	private static <T extends @Nullable Object> T invokeKotlinSuspendingFunction(KFunction<T> function,
+			@Nullable Object target, @Nullable Object[] args) throws InterruptedException {
+		if (!isAccessible(function)) {
+			setAccessible(function, true);
+		}
+		return runBlocking(EmptyCoroutineContext.INSTANCE, (__, continuation) -> {
+			try {
+				return callSuspendBy(function, toArgumentMap(target, args, function), continuation);
+			}
+			catch (Exception e) {
+				throw throwAsUncheckedException(getUnderlyingCause(e));
+			}
+		});
+	}
+
+	private static Map<KParameter, @Nullable Object> toArgumentMap(@Nullable Object target, @Nullable Object[] args,
+			KFunction<?> function) {
+		Map<KParameter, @Nullable Object> arguments = new HashMap<>(args.length + 1);
+		int index = 0;
+		for (KParameter parameter : function.getParameters()) {
+			switch (parameter.getKind()) {
+				case INSTANCE -> arguments.put(parameter, target);
+				case VALUE, EXTENSION_RECEIVER -> {
+					arguments.put(parameter, args[index]);
+					index++;
+				}
+				default -> throw new JUnitException("Unsupported parameter kind: " + parameter.getKind());
+			}
+		}
+		return arguments;
+	}
+
+	private static KFunction<?> getKotlinFunction(Method method) {
+		return Preconditions.notNull(ReflectJvmMapping.getKotlinFunction(method),
+			() -> "Failed to get Kotlin function for method: " + method);
+	}
+
+	private KotlinFunctionUtils() {
+	}
+}
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/KotlinReflectionUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/KotlinReflectionUtils.java
index f3a04fe2e..e804bf74c 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/KotlinReflectionUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/KotlinReflectionUtils.java
@@ -37,6 +37,7 @@ public class KotlinReflectionUtils {
 	private static final String DEFAULT_IMPLS_CLASS_NAME = "DefaultImpls";
 
 	private static final @Nullable Class<? extends Annotation> kotlinMetadata;
+	private static final @Nullable Class<? extends Annotation> jvmInline;
 	private static final @Nullable Class<?> kotlinCoroutineContinuation;
 	private static final boolean kotlinReflectPresent;
 	private static final boolean kotlinxCoroutinesPresent;
@@ -44,6 +45,7 @@ public class KotlinReflectionUtils {
 	static {
 		var metadata = tryToLoadKotlinMetadataClass();
 		kotlinMetadata = metadata.toOptional().orElse(null);
+		jvmInline = tryToLoadJvmInlineClass().toOptional().orElse(null);
 		kotlinCoroutineContinuation = metadata //
 				.andThen(__ -> tryToLoadClass("kotlin.coroutines.Continuation")) //
 				.toOptional() //
@@ -62,6 +64,12 @@ public class KotlinReflectionUtils {
 				.andThenTry(it -> (Class<? extends Annotation>) it);
 	}
 
+	@SuppressWarnings("unchecked")
+	private static Try<Class<? extends Annotation>> tryToLoadJvmInlineClass() {
+		return tryToLoadClass("kotlin.jvm.JvmInline") //
+				.andThenTry(it -> (Class<? extends Annotation>) it);
+	}
+
 	/**
 	 * @since 6.0
 	 */
@@ -117,36 +125,54 @@ public class KotlinReflectionUtils {
 		return result;
 	}
 
-	private static boolean isKotlinType(Class<?> clazz) {
+	@API(status = INTERNAL, since = "6.1")
+	public static boolean isKotlinType(Class<?> clazz) {
 		return kotlinMetadata != null //
 				&& clazz.getDeclaredAnnotation(kotlinMetadata) != null;
 	}
 
+	@API(status = INTERNAL, since = "6.1")
+	public static boolean isKotlinReflectPresent() {
+		return kotlinReflectPresent;
+	}
+
 	public static Class<?> getKotlinSuspendingFunctionReturnType(Method method) {
 		requireKotlinReflect(method);
-		return KotlinSuspendingFunctionUtils.getReturnType(method);
+		return KotlinFunctionUtils.getReturnType(method);
 	}
 
 	public static Type getKotlinSuspendingFunctionGenericReturnType(Method method) {
 		requireKotlinReflect(method);
-		return KotlinSuspendingFunctionUtils.getGenericReturnType(method);
+		return KotlinFunctionUtils.getGenericReturnType(method);
 	}
 
 	public static Parameter[] getKotlinSuspendingFunctionParameters(Method method) {
 		requireKotlinReflect(method);
-		return KotlinSuspendingFunctionUtils.getParameters(method);
+		return KotlinFunctionUtils.getParameters(method);
 	}
 
 	public static Class<?>[] getKotlinSuspendingFunctionParameterTypes(Method method) {
 		requireKotlinReflect(method);
-		return KotlinSuspendingFunctionUtils.getParameterTypes(method);
+		return KotlinFunctionUtils.getParameterTypes(method);
 	}
 
 	public static @Nullable Object invokeKotlinSuspendingFunction(Method method, @Nullable Object target,
 			@Nullable Object[] args) {
 		requireKotlinReflect(method);
 		requireKotlinxCoroutines(method);
-		return KotlinSuspendingFunctionUtils.invoke(method, target, args);
+		return KotlinFunctionUtils.invokeKotlinSuspendingFunction(method, target, args);
+	}
+
+	@API(status = INTERNAL, since = "6.1")
+	public static boolean isInstanceOfInlineType(@Nullable Object value) {
+		return jvmInline != null && value != null && value.getClass().getDeclaredAnnotation(jvmInline) != null;
+	}
+
+	@API(status = INTERNAL, since = "6.1")
+	public static @Nullable Object invokeKotlinFunction(Method method, @Nullable Object target,
+			@Nullable Object... args) {
+		requireKotlinReflect(method);
+		return KotlinFunctionUtils.invokeKotlinFunction(method, target, args);
 	}
 
 	private static void requireKotlinReflect(Method method) {
