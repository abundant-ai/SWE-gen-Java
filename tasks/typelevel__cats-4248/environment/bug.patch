diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 34be7107c..dea5cd368 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -28,7 +28,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-latest]
-        scala: [2.12.16, 2.13.8, 3.1.2]
+        scala: [2.12.16, 2.13.8, 3.1.3]
         java: [temurin@8, temurin@17, graalvm@11]
         project: [rootJS, rootJVM, rootNative]
         exclude:
@@ -36,9 +36,9 @@ jobs:
             java: temurin@17
           - scala: 2.13.8
             java: graalvm@11
-          - scala: 3.1.2
+          - scala: 3.1.3
             java: temurin@17
-          - scala: 3.1.2
+          - scala: 3.1.3
             java: graalvm@11
           - project: rootJS
             java: temurin@17
@@ -312,32 +312,32 @@ jobs:
           tar xf targets.tar
           rm targets.tar
 
-      - name: Download target directories (3.1.2, rootJS)
+      - name: Download target directories (3.1.3, rootJS)
         uses: actions/download-artifact@v2
         with:
-          name: target-${{ matrix.os }}-${{ matrix.java }}-3.1.2-rootJS
+          name: target-${{ matrix.os }}-${{ matrix.java }}-3.1.3-rootJS
 
-      - name: Inflate target directories (3.1.2, rootJS)
+      - name: Inflate target directories (3.1.3, rootJS)
         run: |
           tar xf targets.tar
           rm targets.tar
 
-      - name: Download target directories (3.1.2, rootJVM)
+      - name: Download target directories (3.1.3, rootJVM)
         uses: actions/download-artifact@v2
         with:
-          name: target-${{ matrix.os }}-${{ matrix.java }}-3.1.2-rootJVM
+          name: target-${{ matrix.os }}-${{ matrix.java }}-3.1.3-rootJVM
 
-      - name: Inflate target directories (3.1.2, rootJVM)
+      - name: Inflate target directories (3.1.3, rootJVM)
         run: |
           tar xf targets.tar
           rm targets.tar
 
-      - name: Download target directories (3.1.2, rootNative)
+      - name: Download target directories (3.1.3, rootNative)
         uses: actions/download-artifact@v2
         with:
-          name: target-${{ matrix.os }}-${{ matrix.java }}-3.1.2-rootNative
+          name: target-${{ matrix.os }}-${{ matrix.java }}-3.1.3-rootNative
 
-      - name: Inflate target directories (3.1.2, rootNative)
+      - name: Inflate target directories (3.1.3, rootNative)
         run: |
           tar xf targets.tar
           rm targets.tar
diff --git a/build.sbt b/build.sbt
index aa3bc7b59..5194816a3 100644
--- a/build.sbt
+++ b/build.sbt
@@ -18,7 +18,7 @@ ThisBuild / githubWorkflowJavaVersions := Seq(PrimaryJava, LTSJava, GraalVM11)
 
 val Scala212 = "2.12.16"
 val Scala213 = "2.13.8"
-val Scala3 = "3.1.2"
+val Scala3 = "3.1.3"
 
 ThisBuild / crossScalaVersions := Seq(Scala212, Scala213, Scala3)
 ThisBuild / scalaVersion := Scala212
diff --git a/core/src/main/scala/cats/Defer.scala b/core/src/main/scala/cats/Defer.scala
index 068778ab5..7b7884f42 100644
--- a/core/src/main/scala/cats/Defer.scala
+++ b/core/src/main/scala/cats/Defer.scala
@@ -69,7 +69,7 @@ trait Defer[F[_]] extends Serializable {
    * of the above F[A] run forever.
    */
   def fix[A](fn: F[A] => F[A]): F[A] = {
-    lazy val res: F[A] = defer(fn(res))
+    lazy val res: F[A] = fn(defer(res))
     res
   }
 }
diff --git a/core/src/main/scala/cats/Traverse.scala b/core/src/main/scala/cats/Traverse.scala
index 295395b0b..f57300248 100644
--- a/core/src/main/scala/cats/Traverse.scala
+++ b/core/src/main/scala/cats/Traverse.scala
@@ -168,46 +168,6 @@ trait Traverse[F[_]] extends Functor[F] with Foldable[F] with UnorderedTraverse[
   def zipWithIndex[A](fa: F[A]): F[(A, Int)] =
     mapWithIndex(fa)((a, i) => (a, i))
 
-  /**
-    * Same as [[traverseWithIndexM]] but the index type is [[Long]] instead of [[Int]].
-    */
-  def traverseWithLongIndexM[G[_], A, B](fa: F[A])(f: (A, Long) => G[B])(implicit G: Monad[G]): G[F[B]] =
-    traverse(fa)(a => StateT((s: Long) => G.map(f(a, s))(b => (s + 1, b)))).runA(0L)
-
-  /**
-    * Same as [[mapWithIndex]] but the index type is [[Long]] instead of [[Int]].
-    */
-  def mapWithLongIndex[A, B](fa: F[A])(f: (A, Long) => B): F[B] =
-    traverseWithLongIndexM[cats.Id, A, B](fa)((a, long) => f(a, long))
-
-  /**
-    * Same as [[zipWithIndex]] but the index type is [[Long]] instead of [[Int]].
-    */
-  def zipWithLongIndex[A](fa: F[A]): F[(A, Long)] =
-    mapWithLongIndex(fa)((a, long) => (a, long))
-
-  /**
-   * If `fa` contains the element at index `idx`, 
-   * return the copy of `fa` where the element at `idx` is replaced with `b`. 
-   * If there is no element with such an index, return `None`. 
-   *
-   * The behavior is consistent with the Scala collection library's
-   * `updated` for collections such as `List`.
-   */
-  def updated_[A, B >: A](fa: F[A], idx: Long, b: B): Option[F[B]] = {
-    if (idx < 0L)
-      None
-    else
-      mapAccumulate(0L, fa)((i, a) =>
-        if (i == idx)
-          (i + 1, b)
-        else
-          (i + 1, a)
-      ) match {
-        case (i, fb) if i > idx => Some(fb)
-        case _                  => None
-      }
-  }
   override def unorderedTraverse[G[_]: CommutativeApplicative, A, B](sa: F[A])(f: (A) => G[B]): G[F[B]] =
     traverse(sa)(f)
 
@@ -255,14 +215,6 @@ object Traverse {
       typeClassInstance.traverseWithIndexM[G, A, B](self)(f)(G)
     def zipWithIndex: F[(A, Int)] =
       typeClassInstance.zipWithIndex[A](self)
-    def zipWithLongIndex: F[(A, Long)] =
-      typeClassInstance.zipWithLongIndex[A](self)
-    def traverseWithLongIndexM[G[_], B](f: (A, Long) => G[B])(implicit G: Monad[G]): G[F[B]] =
-      typeClassInstance.traverseWithLongIndexM[G, A, B](self)(f)
-    def mapWithLongIndex[B](f: (A, Long) => B): F[B] =
-      typeClassInstance.mapWithLongIndex[A, B](self)(f)
-    def updated_[B >: A](idx: Long, b: B): Option[F[B]] =
-      typeClassInstance.updated_(self, idx, b)
   }
   trait AllOps[F[_], A]
       extends Ops[F, A]
diff --git a/core/src/main/scala/cats/data/Chain.scala b/core/src/main/scala/cats/data/Chain.scala
index 112c890d7..0cbf2839b 100644
--- a/core/src/main/scala/cats/data/Chain.scala
+++ b/core/src/main/scala/cats/data/Chain.scala
@@ -1256,9 +1256,6 @@ sealed abstract private[data] class ChainInstances extends ChainInstances1 {
       override def mapWithIndex[A, B](fa: Chain[A])(f: (A, Int) => B): Chain[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
-      override def mapWithLongIndex[A, B](fa: Chain[A])(f: (A, Long) => B): Chain[B] =
-        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
-
       override def zipWithIndex[A](fa: Chain[A]): Chain[(A, Int)] =
         fa.zipWithIndex
 
diff --git a/core/src/main/scala/cats/data/NonEmptyChain.scala b/core/src/main/scala/cats/data/NonEmptyChain.scala
index 7c8e70c90..d2f1968fe 100644
--- a/core/src/main/scala/cats/data/NonEmptyChain.scala
+++ b/core/src/main/scala/cats/data/NonEmptyChain.scala
@@ -639,9 +639,6 @@ sealed abstract private[data] class NonEmptyChainInstances extends NonEmptyChain
       override def mapWithIndex[A, B](fa: NonEmptyChain[A])(f: (A, Int) => B): NonEmptyChain[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
-      override def mapWithLongIndex[A, B](fa: NonEmptyChain[A])(f: (A, Long) => B): NonEmptyChain[B] =
-        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
-
       override def zipWithIndex[A](fa: NonEmptyChain[A]): NonEmptyChain[(A, Int)] =
         fa.zipWithIndex
 
diff --git a/core/src/main/scala/cats/data/NonEmptyList.scala b/core/src/main/scala/cats/data/NonEmptyList.scala
index aff19f3a8..d72827b63 100644
--- a/core/src/main/scala/cats/data/NonEmptyList.scala
+++ b/core/src/main/scala/cats/data/NonEmptyList.scala
@@ -794,9 +794,6 @@ sealed abstract private[data] class NonEmptyListInstances extends NonEmptyListIn
       override def mapWithIndex[A, B](fa: NonEmptyList[A])(f: (A, Int) => B): NonEmptyList[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
-      override def mapWithLongIndex[A, B](fa: NonEmptyList[A])(f: (A, Long) => B): NonEmptyList[B] =
-        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
-
       override def zipWithIndex[A](fa: NonEmptyList[A]): NonEmptyList[(A, Int)] =
         fa.zipWithIndex
 
diff --git a/core/src/main/scala/cats/data/NonEmptyVector.scala b/core/src/main/scala/cats/data/NonEmptyVector.scala
index ec8849e17..22117f86d 100644
--- a/core/src/main/scala/cats/data/NonEmptyVector.scala
+++ b/core/src/main/scala/cats/data/NonEmptyVector.scala
@@ -442,18 +442,12 @@ sealed abstract private[data] class NonEmptyVectorInstances {
       ): (S, NonEmptyVector[B]) =
         StaticMethods.mapAccumulateFromStrictFunctor(init, fa, f)(this)
 
-      override def mapWithLongIndex[A, B](fa: NonEmptyVector[A])(f: (A, Long) => B): NonEmptyVector[B] =
-        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
-
       override def mapWithIndex[A, B](fa: NonEmptyVector[A])(f: (A, Int) => B): NonEmptyVector[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
       override def zipWithIndex[A](fa: NonEmptyVector[A]): NonEmptyVector[(A, Int)] =
         fa.zipWithIndex
 
-      override def updated_[A, B >: A](fa: NonEmptyVector[A], idx: Long, b: B): Option[NonEmptyVector[B]] =
-        Traverse[Vector].updated_(fa.toVector, idx, b).map(NonEmptyVector.fromVectorUnsafe)
-
       override def foldLeft[A, B](fa: NonEmptyVector[A], b: B)(f: (B, A) => B): B =
         fa.foldLeft(b)(f)
 
diff --git a/core/src/main/scala/cats/instances/StaticMethods.scala b/core/src/main/scala/cats/instances/StaticMethods.scala
index 8df598bdd..24cbfad4b 100644
--- a/core/src/main/scala/cats/instances/StaticMethods.scala
+++ b/core/src/main/scala/cats/instances/StaticMethods.scala
@@ -60,14 +60,4 @@ private[cats] object StaticMethods {
     }
   }
 
-  def mapWithLongIndexFromStrictFunctor[F[_], A, B](fa: F[A], f: (A, Long) => B)(implicit ev: Functor[F]): F[B] = {
-    var idx: Long = 0L
-
-    ev.map(fa) { a =>
-      val b = f(a, idx)
-      idx += 1
-      b
-    }
-  }
-
 }
diff --git a/core/src/main/scala/cats/instances/list.scala b/core/src/main/scala/cats/instances/list.scala
index e65cb5b19..979438171 100644
--- a/core/src/main/scala/cats/instances/list.scala
+++ b/core/src/main/scala/cats/instances/list.scala
@@ -188,9 +188,6 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
       override def mapAccumulate[S, A, B](init: S, fa: List[A])(f: (S, A) => (S, B)): (S, List[B]) =
         StaticMethods.mapAccumulateFromStrictFunctor(init, fa, f)(this)
 
-      override def mapWithLongIndex[A, B](fa: List[A])(f: (A, Long) => B): List[B] =
-        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
-
       override def mapWithIndex[A, B](fa: List[A])(f: (A, Int) => B): List[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
diff --git a/core/src/main/scala/cats/instances/queue.scala b/core/src/main/scala/cats/instances/queue.scala
index a54c92099..ed1662449 100644
--- a/core/src/main/scala/cats/instances/queue.scala
+++ b/core/src/main/scala/cats/instances/queue.scala
@@ -132,9 +132,6 @@ trait QueueInstances extends cats.kernel.instances.QueueInstances {
       override def mapAccumulate[S, A, B](init: S, fa: Queue[A])(f: (S, A) => (S, B)): (S, Queue[B]) =
         StaticMethods.mapAccumulateFromStrictFunctor(init, fa, f)(this)
 
-      override def mapWithLongIndex[A, B](fa: Queue[A])(f: (A, Long) => B): Queue[B] =
-        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
-
       override def mapWithIndex[A, B](fa: Queue[A])(f: (A, Int) => B): Queue[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index ea89f1cbc..5632b6bad 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -130,13 +130,6 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
       final override def traverse[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: Applicative[G]): G[Vector[B]] =
         G.map(Chain.traverseViaChain(fa)(f))(_.toVector)
 
-      final override def updated_[A, B >: A](fa: Vector[A], idx: Long, b: B): Option[Vector[B]] =
-        if (idx >= 0L && idx < fa.size.toLong) {
-          Some(fa.updated(idx.toInt, b))
-        } else {
-          None
-        }
-
       /**
        * This avoids making a very deep stack by building a tree instead
        */
@@ -181,9 +174,6 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
       override def mapWithIndex[A, B](fa: Vector[A])(f: (A, Int) => B): Vector[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
-      override def mapWithLongIndex[A, B](fa: Vector[A])(f: (A, Long) => B): Vector[B] =
-        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
-
       override def zipWithIndex[A](fa: Vector[A]): Vector[(A, Int)] =
         fa.zipWithIndex
 
diff --git a/docs/datatypes/either.md b/docs/datatypes/either.md
index c7667cb16..dd03f90ca 100644
--- a/docs/datatypes/either.md
+++ b/docs/datatypes/either.md
@@ -30,6 +30,17 @@ How then do we communicate an error? By making it explicit in the data type we r
 
 ## Either
 
+### Lifting Values into an Either
+
+`asRight` and `asLeft` are provided by Cats to lift a value into an Either. The advantage of these operations over the `Right` and `Left` constructors provided in the standard library is that the lifted value can help guide type inference.
+
+```scala mdoc
+import cats.syntax.all._
+
+val e1 = 5.asRight[String]
+val e2 = "error".asLeft[Int]
+```
+
 ### `Either` vs `Validated`
 
 In general, `Validated` is used to accumulate errors, while `Either` is used to short-circuit a computation upon the first error. For more information, see the `Validated` vs `Either` section of the [`Validated` documentation](validated.md).
@@ -41,7 +52,7 @@ are missing from it. Instead, you call `.right` or `.left` to get a `RightProjec
 `LeftProjection` (respectively) which does have the combinators. The direction of the projection indicates the direction
 of bias. For instance, calling `map` on a `RightProjection` acts on the `Right` of an `Either`.
 
-```scala mdoc
+```scala mdoc:reset
 val e1: Either[String, Int] = Right(5)
 e1.right.map(_ + 1)
 
diff --git a/docs/datatypes/freemonad.md b/docs/datatypes/freemonad.md
index ad436ba68..32fa377eb 100644
--- a/docs/datatypes/freemonad.md
+++ b/docs/datatypes/freemonad.md
@@ -185,7 +185,7 @@ def impureCompiler: KVStoreA ~> Id  =
           ()
         case Get(key) =>
           println(s"get($key)")
-          kvs.get(key).map(_.asInstanceOf[A])
+          kvs.get(key).asInstanceOf[A]
         case Delete(key) =>
           println(s"delete($key)")
           kvs.remove(key)
@@ -273,7 +273,7 @@ val pureCompiler: KVStoreA ~> KVStoreState = new (KVStoreA ~> KVStoreState) {
     fa match {
       case Put(key, value) => State.modify(_.updated(key, value))
       case Get(key) =>
-        State.inspect(_.get(key).map(_.asInstanceOf[A]))
+        State.inspect(_.get(key).asInstanceOf[A])
       case Delete(key) => State.modify(_ - key)
     }
 }
diff --git a/laws/src/main/scala/cats/laws/TraverseLaws.scala b/laws/src/main/scala/cats/laws/TraverseLaws.scala
index d9ab4d84b..cfcb419ff 100644
--- a/laws/src/main/scala/cats/laws/TraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/TraverseLaws.scala
@@ -129,43 +129,6 @@ trait TraverseLaws[F[_]] extends FunctorLaws[F] with FoldableLaws[F] with Unorde
     val rhs = F.map(F.mapWithIndex(fa)((a, i) => (a, i)))(f)
     lhs <-> rhs
   }
-
-  def mapWithLongIndexRef[A, B](fa: F[A], f: (A, Long) => B): IsEq[F[B]] = {
-    val lhs = F.mapWithLongIndex(fa)(f)
-    val rhs = F.traverse(fa)(a => State((s: Long) => (s + 1, f(a, s)))).runA(0L).value
-    lhs <-> rhs
-  }
-
-  def traverseWithLongIndexMRef[G[_], A, B](fa: F[A], f: (A, Long) => G[B])(implicit G: Monad[G]): IsEq[G[F[B]]] = {
-    val lhs = F.traverseWithLongIndexM(fa)(f)
-    val rhs = F.traverse(fa)(a => StateT((s: Long) => G.map(f(a, s))(b => (s + 1, b)))).runA(0L)
-    lhs <-> rhs
-  }
-
-  def zipWithLongIndexRef[A, B](fa: F[A], f: ((A, Long)) => B): IsEq[F[B]] = {
-    val lhs = F.map(F.zipWithLongIndex(fa))(f)
-    val rhs = F.map(F.mapWithLongIndex(fa)((a, i) => (a, i)))(f)
-    lhs <-> rhs
-  }
-
-  def updatedRef[A, B >: A](fa: F[A], idx: Long, b: B): IsEq[Option[F[B]]] = {
-    val lhs = F.updated_(fa, idx, b)
-    val rhs =
-      if (idx < 0L)
-        None
-      else
-        F.mapAccumulate(0L, fa)((i, a) =>
-          if (i == idx)
-            (i + 1, b)
-          else
-            (i + 1, a)
-        ) match {
-          case (i, fb) if i > idx => Some(fb)
-          case _                  => None
-        }
-
-    lhs <-> rhs
-  }
 }
 
 object TraverseLaws {
diff --git a/project/plugins.sbt b/project/plugins.sbt
index 89ed4aec0..3aff02c83 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -5,7 +5,7 @@ addSbtPlugin("pl.project13.scala" % "sbt-jmh" % "0.4.3")
 addSbtPlugin("com.github.tkawachi" % "sbt-doctest" % "0.10.0")
 addSbtPlugin("org.portable-scala" % "sbt-scalajs-crossproject" % "1.2.0")
 addSbtPlugin("org.portable-scala" % "sbt-scala-native-crossproject" % "1.2.0")
-addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.10.0")
+addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.10.1")
 addSbtPlugin("org.scala-native" % "sbt-scala-native" % "0.4.4")
 addSbtPlugin("org.scalameta" % "sbt-scalafmt" % "2.4.6")
 addSbtPlugin("com.eed3si9n" % "sbt-buildinfo" % "0.11.0")
diff --git a/tests/shared/src/test/scala/cats/tests/TraverseSuite.scala b/tests/shared/src/test/scala/cats/tests/TraverseSuite.scala
index 94fffaea5..4b893758e 100644
--- a/tests/shared/src/test/scala/cats/tests/TraverseSuite.scala
+++ b/tests/shared/src/test/scala/cats/tests/TraverseSuite.scala
@@ -36,12 +36,6 @@ abstract class TraverseSuite[F[_]: Traverse](name: String)(implicit ArbFInt: Arb
     }
   }
 
-  test(s"Traverse[$name].zipWithLongIndex") {
-    forAll { (fa: F[Int]) =>
-      assert(fa.zipWithLongIndex.toList === (fa.toList.zipWithLongIndex))
-    }
-  }
-
   test(s"Traverse[$name].mapAccumulate") {
     forAll { (init: Int, fa: F[Int], fn: ((Int, Int)) => (Int, Int)) =>
       val lhs = fa.mapAccumulate(init)((s, a) => fn((s, a)))
@@ -61,12 +55,6 @@ abstract class TraverseSuite[F[_]: Traverse](name: String)(implicit ArbFInt: Arb
     }
   }
 
-  test(s"Traverse[$name].mapWithLongIndex") {
-    forAll { (fa: F[Int], fn: ((Int, Long)) => Int) =>
-      assert(fa.mapWithLongIndex((a, i) => fn((a, i))).toList === (fa.toList.zipWithLongIndex.map(fn)))
-    }
-  }
-
   test(s"Traverse[$name].traverseWithIndexM") {
     forAll { (fa: F[Int], fn: ((Int, Int)) => (Int, Int)) =>
       val left = fa.traverseWithIndexM((a, i) => fn((a, i))).fmap(_.toList)
@@ -75,28 +63,12 @@ abstract class TraverseSuite[F[_]: Traverse](name: String)(implicit ArbFInt: Arb
     }
   }
 
-  test(s"Traverse[$name].traverseWithLongIndexM") {
-    forAll { (fa: F[Int], fn: ((Int, Long)) => (Int, Long)) =>
-      val left = fa.traverseWithLongIndexM((a, i) => fn((a, i))).fmap(_.toList)
-      val (xs, values) = fa.toList.zipWithLongIndex.map(fn).unzip
-      assert(left === ((xs.combineAll, values)))
-    }
-  }
-
   test(s"Traverse[$name].traverse matches traverse_ with Option") {
     forAll { (fa: F[Int], fn: Int => Option[Int]) =>
       assert(Applicative[Option].void(fa.traverse(fn)) == fa.traverse_(fn))
     }
   }
 
-  test(s"Traverse[$name].updated_") {
-    forAll { (fa: F[Int], i: Int, b: Int) =>
-      val updatedThenToList: Option[List[Int]] = fa.updated_(i.toLong, b).fmap(_.toList)
-      val toListThenUpdated: Option[List[Int]] = scala.util.Try(fa.toList.updated(i, b)).toOption
-      assertEquals(updatedThenToList, toListThenUpdated)
-    }
-  }
-
 }
 
 object TraverseSuite {
