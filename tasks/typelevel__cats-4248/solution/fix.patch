diff --git a/core/src/main/scala/cats/Defer.scala b/core/src/main/scala/cats/Defer.scala
index 7b7884f42..068778ab5 100644
--- a/core/src/main/scala/cats/Defer.scala
+++ b/core/src/main/scala/cats/Defer.scala
@@ -69,7 +69,7 @@ trait Defer[F[_]] extends Serializable {
    * of the above F[A] run forever.
    */
   def fix[A](fn: F[A] => F[A]): F[A] = {
-    lazy val res: F[A] = fn(defer(res))
+    lazy val res: F[A] = defer(fn(res))
     res
   }
 }
diff --git a/core/src/main/scala/cats/Traverse.scala b/core/src/main/scala/cats/Traverse.scala
index f57300248..295395b0b 100644
--- a/core/src/main/scala/cats/Traverse.scala
+++ b/core/src/main/scala/cats/Traverse.scala
@@ -168,6 +168,46 @@ trait Traverse[F[_]] extends Functor[F] with Foldable[F] with UnorderedTraverse[
   def zipWithIndex[A](fa: F[A]): F[(A, Int)] =
     mapWithIndex(fa)((a, i) => (a, i))
 
+  /**
+    * Same as [[traverseWithIndexM]] but the index type is [[Long]] instead of [[Int]].
+    */
+  def traverseWithLongIndexM[G[_], A, B](fa: F[A])(f: (A, Long) => G[B])(implicit G: Monad[G]): G[F[B]] =
+    traverse(fa)(a => StateT((s: Long) => G.map(f(a, s))(b => (s + 1, b)))).runA(0L)
+
+  /**
+    * Same as [[mapWithIndex]] but the index type is [[Long]] instead of [[Int]].
+    */
+  def mapWithLongIndex[A, B](fa: F[A])(f: (A, Long) => B): F[B] =
+    traverseWithLongIndexM[cats.Id, A, B](fa)((a, long) => f(a, long))
+
+  /**
+    * Same as [[zipWithIndex]] but the index type is [[Long]] instead of [[Int]].
+    */
+  def zipWithLongIndex[A](fa: F[A]): F[(A, Long)] =
+    mapWithLongIndex(fa)((a, long) => (a, long))
+
+  /**
+   * If `fa` contains the element at index `idx`, 
+   * return the copy of `fa` where the element at `idx` is replaced with `b`. 
+   * If there is no element with such an index, return `None`. 
+   *
+   * The behavior is consistent with the Scala collection library's
+   * `updated` for collections such as `List`.
+   */
+  def updated_[A, B >: A](fa: F[A], idx: Long, b: B): Option[F[B]] = {
+    if (idx < 0L)
+      None
+    else
+      mapAccumulate(0L, fa)((i, a) =>
+        if (i == idx)
+          (i + 1, b)
+        else
+          (i + 1, a)
+      ) match {
+        case (i, fb) if i > idx => Some(fb)
+        case _                  => None
+      }
+  }
   override def unorderedTraverse[G[_]: CommutativeApplicative, A, B](sa: F[A])(f: (A) => G[B]): G[F[B]] =
     traverse(sa)(f)
 
@@ -215,6 +255,14 @@ object Traverse {
       typeClassInstance.traverseWithIndexM[G, A, B](self)(f)(G)
     def zipWithIndex: F[(A, Int)] =
       typeClassInstance.zipWithIndex[A](self)
+    def zipWithLongIndex: F[(A, Long)] =
+      typeClassInstance.zipWithLongIndex[A](self)
+    def traverseWithLongIndexM[G[_], B](f: (A, Long) => G[B])(implicit G: Monad[G]): G[F[B]] =
+      typeClassInstance.traverseWithLongIndexM[G, A, B](self)(f)
+    def mapWithLongIndex[B](f: (A, Long) => B): F[B] =
+      typeClassInstance.mapWithLongIndex[A, B](self)(f)
+    def updated_[B >: A](idx: Long, b: B): Option[F[B]] =
+      typeClassInstance.updated_(self, idx, b)
   }
   trait AllOps[F[_], A]
       extends Ops[F, A]
diff --git a/core/src/main/scala/cats/data/Chain.scala b/core/src/main/scala/cats/data/Chain.scala
index 0cbf2839b..112c890d7 100644
--- a/core/src/main/scala/cats/data/Chain.scala
+++ b/core/src/main/scala/cats/data/Chain.scala
@@ -1256,6 +1256,9 @@ sealed abstract private[data] class ChainInstances extends ChainInstances1 {
       override def mapWithIndex[A, B](fa: Chain[A])(f: (A, Int) => B): Chain[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
+      override def mapWithLongIndex[A, B](fa: Chain[A])(f: (A, Long) => B): Chain[B] =
+        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
+
       override def zipWithIndex[A](fa: Chain[A]): Chain[(A, Int)] =
         fa.zipWithIndex
 
diff --git a/core/src/main/scala/cats/data/NonEmptyChain.scala b/core/src/main/scala/cats/data/NonEmptyChain.scala
index d2f1968fe..7c8e70c90 100644
--- a/core/src/main/scala/cats/data/NonEmptyChain.scala
+++ b/core/src/main/scala/cats/data/NonEmptyChain.scala
@@ -639,6 +639,9 @@ sealed abstract private[data] class NonEmptyChainInstances extends NonEmptyChain
       override def mapWithIndex[A, B](fa: NonEmptyChain[A])(f: (A, Int) => B): NonEmptyChain[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
+      override def mapWithLongIndex[A, B](fa: NonEmptyChain[A])(f: (A, Long) => B): NonEmptyChain[B] =
+        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
+
       override def zipWithIndex[A](fa: NonEmptyChain[A]): NonEmptyChain[(A, Int)] =
         fa.zipWithIndex
 
diff --git a/core/src/main/scala/cats/data/NonEmptyList.scala b/core/src/main/scala/cats/data/NonEmptyList.scala
index d72827b63..aff19f3a8 100644
--- a/core/src/main/scala/cats/data/NonEmptyList.scala
+++ b/core/src/main/scala/cats/data/NonEmptyList.scala
@@ -794,6 +794,9 @@ sealed abstract private[data] class NonEmptyListInstances extends NonEmptyListIn
       override def mapWithIndex[A, B](fa: NonEmptyList[A])(f: (A, Int) => B): NonEmptyList[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
+      override def mapWithLongIndex[A, B](fa: NonEmptyList[A])(f: (A, Long) => B): NonEmptyList[B] =
+        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
+
       override def zipWithIndex[A](fa: NonEmptyList[A]): NonEmptyList[(A, Int)] =
         fa.zipWithIndex
 
diff --git a/core/src/main/scala/cats/data/NonEmptyVector.scala b/core/src/main/scala/cats/data/NonEmptyVector.scala
index 22117f86d..ec8849e17 100644
--- a/core/src/main/scala/cats/data/NonEmptyVector.scala
+++ b/core/src/main/scala/cats/data/NonEmptyVector.scala
@@ -442,12 +442,18 @@ sealed abstract private[data] class NonEmptyVectorInstances {
       ): (S, NonEmptyVector[B]) =
         StaticMethods.mapAccumulateFromStrictFunctor(init, fa, f)(this)
 
+      override def mapWithLongIndex[A, B](fa: NonEmptyVector[A])(f: (A, Long) => B): NonEmptyVector[B] =
+        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
+
       override def mapWithIndex[A, B](fa: NonEmptyVector[A])(f: (A, Int) => B): NonEmptyVector[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
       override def zipWithIndex[A](fa: NonEmptyVector[A]): NonEmptyVector[(A, Int)] =
         fa.zipWithIndex
 
+      override def updated_[A, B >: A](fa: NonEmptyVector[A], idx: Long, b: B): Option[NonEmptyVector[B]] =
+        Traverse[Vector].updated_(fa.toVector, idx, b).map(NonEmptyVector.fromVectorUnsafe)
+
       override def foldLeft[A, B](fa: NonEmptyVector[A], b: B)(f: (B, A) => B): B =
         fa.foldLeft(b)(f)
 
diff --git a/core/src/main/scala/cats/instances/StaticMethods.scala b/core/src/main/scala/cats/instances/StaticMethods.scala
index 24cbfad4b..8df598bdd 100644
--- a/core/src/main/scala/cats/instances/StaticMethods.scala
+++ b/core/src/main/scala/cats/instances/StaticMethods.scala
@@ -60,4 +60,14 @@ private[cats] object StaticMethods {
     }
   }
 
+  def mapWithLongIndexFromStrictFunctor[F[_], A, B](fa: F[A], f: (A, Long) => B)(implicit ev: Functor[F]): F[B] = {
+    var idx: Long = 0L
+
+    ev.map(fa) { a =>
+      val b = f(a, idx)
+      idx += 1
+      b
+    }
+  }
+
 }
diff --git a/core/src/main/scala/cats/instances/list.scala b/core/src/main/scala/cats/instances/list.scala
index 979438171..e65cb5b19 100644
--- a/core/src/main/scala/cats/instances/list.scala
+++ b/core/src/main/scala/cats/instances/list.scala
@@ -188,6 +188,9 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
       override def mapAccumulate[S, A, B](init: S, fa: List[A])(f: (S, A) => (S, B)): (S, List[B]) =
         StaticMethods.mapAccumulateFromStrictFunctor(init, fa, f)(this)
 
+      override def mapWithLongIndex[A, B](fa: List[A])(f: (A, Long) => B): List[B] =
+        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
+
       override def mapWithIndex[A, B](fa: List[A])(f: (A, Int) => B): List[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
diff --git a/core/src/main/scala/cats/instances/queue.scala b/core/src/main/scala/cats/instances/queue.scala
index ed1662449..a54c92099 100644
--- a/core/src/main/scala/cats/instances/queue.scala
+++ b/core/src/main/scala/cats/instances/queue.scala
@@ -132,6 +132,9 @@ trait QueueInstances extends cats.kernel.instances.QueueInstances {
       override def mapAccumulate[S, A, B](init: S, fa: Queue[A])(f: (S, A) => (S, B)): (S, Queue[B]) =
         StaticMethods.mapAccumulateFromStrictFunctor(init, fa, f)(this)
 
+      override def mapWithLongIndex[A, B](fa: Queue[A])(f: (A, Long) => B): Queue[B] =
+        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
+
       override def mapWithIndex[A, B](fa: Queue[A])(f: (A, Int) => B): Queue[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index 5632b6bad..ea89f1cbc 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -130,6 +130,13 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
       final override def traverse[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: Applicative[G]): G[Vector[B]] =
         G.map(Chain.traverseViaChain(fa)(f))(_.toVector)
 
+      final override def updated_[A, B >: A](fa: Vector[A], idx: Long, b: B): Option[Vector[B]] =
+        if (idx >= 0L && idx < fa.size.toLong) {
+          Some(fa.updated(idx.toInt, b))
+        } else {
+          None
+        }
+
       /**
        * This avoids making a very deep stack by building a tree instead
        */
@@ -174,6 +181,9 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
       override def mapWithIndex[A, B](fa: Vector[A])(f: (A, Int) => B): Vector[B] =
         StaticMethods.mapWithIndexFromStrictFunctor(fa, f)(this)
 
+      override def mapWithLongIndex[A, B](fa: Vector[A])(f: (A, Long) => B): Vector[B] =
+        StaticMethods.mapWithLongIndexFromStrictFunctor(fa, f)(this)
+
       override def zipWithIndex[A](fa: Vector[A]): Vector[(A, Int)] =
         fa.zipWithIndex
 
diff --git a/docs/datatypes/either.md b/docs/datatypes/either.md
index dd03f90ca..c7667cb16 100644
--- a/docs/datatypes/either.md
+++ b/docs/datatypes/either.md
@@ -30,17 +30,6 @@ How then do we communicate an error? By making it explicit in the data type we r
 
 ## Either
 
-### Lifting Values into an Either
-
-`asRight` and `asLeft` are provided by Cats to lift a value into an Either. The advantage of these operations over the `Right` and `Left` constructors provided in the standard library is that the lifted value can help guide type inference.
-
-```scala mdoc
-import cats.syntax.all._
-
-val e1 = 5.asRight[String]
-val e2 = "error".asLeft[Int]
-```
-
 ### `Either` vs `Validated`
 
 In general, `Validated` is used to accumulate errors, while `Either` is used to short-circuit a computation upon the first error. For more information, see the `Validated` vs `Either` section of the [`Validated` documentation](validated.md).
@@ -52,7 +41,7 @@ are missing from it. Instead, you call `.right` or `.left` to get a `RightProjec
 `LeftProjection` (respectively) which does have the combinators. The direction of the projection indicates the direction
 of bias. For instance, calling `map` on a `RightProjection` acts on the `Right` of an `Either`.
 
-```scala mdoc:reset
+```scala mdoc
 val e1: Either[String, Int] = Right(5)
 e1.right.map(_ + 1)
 
diff --git a/docs/datatypes/freemonad.md b/docs/datatypes/freemonad.md
index 32fa377eb..ad436ba68 100644
--- a/docs/datatypes/freemonad.md
+++ b/docs/datatypes/freemonad.md
@@ -185,7 +185,7 @@ def impureCompiler: KVStoreA ~> Id  =
           ()
         case Get(key) =>
           println(s"get($key)")
-          kvs.get(key).asInstanceOf[A]
+          kvs.get(key).map(_.asInstanceOf[A])
         case Delete(key) =>
           println(s"delete($key)")
           kvs.remove(key)
@@ -273,7 +273,7 @@ val pureCompiler: KVStoreA ~> KVStoreState = new (KVStoreA ~> KVStoreState) {
     fa match {
       case Put(key, value) => State.modify(_.updated(key, value))
       case Get(key) =>
-        State.inspect(_.get(key).asInstanceOf[A])
+        State.inspect(_.get(key).map(_.asInstanceOf[A]))
       case Delete(key) => State.modify(_ - key)
     }
 }
diff --git a/laws/src/main/scala/cats/laws/TraverseLaws.scala b/laws/src/main/scala/cats/laws/TraverseLaws.scala
index cfcb419ff..d9ab4d84b 100644
--- a/laws/src/main/scala/cats/laws/TraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/TraverseLaws.scala
@@ -129,6 +129,43 @@ trait TraverseLaws[F[_]] extends FunctorLaws[F] with FoldableLaws[F] with Unorde
     val rhs = F.map(F.mapWithIndex(fa)((a, i) => (a, i)))(f)
     lhs <-> rhs
   }
+
+  def mapWithLongIndexRef[A, B](fa: F[A], f: (A, Long) => B): IsEq[F[B]] = {
+    val lhs = F.mapWithLongIndex(fa)(f)
+    val rhs = F.traverse(fa)(a => State((s: Long) => (s + 1, f(a, s)))).runA(0L).value
+    lhs <-> rhs
+  }
+
+  def traverseWithLongIndexMRef[G[_], A, B](fa: F[A], f: (A, Long) => G[B])(implicit G: Monad[G]): IsEq[G[F[B]]] = {
+    val lhs = F.traverseWithLongIndexM(fa)(f)
+    val rhs = F.traverse(fa)(a => StateT((s: Long) => G.map(f(a, s))(b => (s + 1, b)))).runA(0L)
+    lhs <-> rhs
+  }
+
+  def zipWithLongIndexRef[A, B](fa: F[A], f: ((A, Long)) => B): IsEq[F[B]] = {
+    val lhs = F.map(F.zipWithLongIndex(fa))(f)
+    val rhs = F.map(F.mapWithLongIndex(fa)((a, i) => (a, i)))(f)
+    lhs <-> rhs
+  }
+
+  def updatedRef[A, B >: A](fa: F[A], idx: Long, b: B): IsEq[Option[F[B]]] = {
+    val lhs = F.updated_(fa, idx, b)
+    val rhs =
+      if (idx < 0L)
+        None
+      else
+        F.mapAccumulate(0L, fa)((i, a) =>
+          if (i == idx)
+            (i + 1, b)
+          else
+            (i + 1, a)
+        ) match {
+          case (i, fb) if i > idx => Some(fb)
+          case _                  => None
+        }
+
+    lhs <-> rhs
+  }
 }
 
 object TraverseLaws {
diff --git a/project/plugins.sbt b/project/plugins.sbt
index 3aff02c83..89ed4aec0 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -5,7 +5,7 @@ addSbtPlugin("pl.project13.scala" % "sbt-jmh" % "0.4.3")
 addSbtPlugin("com.github.tkawachi" % "sbt-doctest" % "0.10.0")
 addSbtPlugin("org.portable-scala" % "sbt-scalajs-crossproject" % "1.2.0")
 addSbtPlugin("org.portable-scala" % "sbt-scala-native-crossproject" % "1.2.0")
-addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.10.1")
+addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.10.0")
 addSbtPlugin("org.scala-native" % "sbt-scala-native" % "0.4.4")
 addSbtPlugin("org.scalameta" % "sbt-scalafmt" % "2.4.6")
 addSbtPlugin("com.eed3si9n" % "sbt-buildinfo" % "0.11.0")
