diff --git a/release-notes/VERSION b/release-notes/VERSION
index 0a8393a28..2c6ee2d57 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -62,10 +62,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
   serialization
  (requested by @arungitan)
  (implemented by Lee Jiwon)
-#3786: Deserialization of generic container (of Record type) using `EXTERNAL_PROPERTY`
-  fails for "natural" types (`boolean`/`long`/`String`/`double`) because
-  type information is missing
- (fix by @cowtowncoder, w/ Claude code)
 #3964: Deserialization issue: MismatchedInputException, Bean not
   yet resolved
  (reported by @detomarco)
diff --git a/src/main/java/tools/jackson/databind/deser/impl/ExternalTypeHandler.java b/src/main/java/tools/jackson/databind/deser/impl/ExternalTypeHandler.java
index f7ef26573..a8bb9de93 100644
--- a/src/main/java/tools/jackson/databind/deser/impl/ExternalTypeHandler.java
+++ b/src/main/java/tools/jackson/databind/deser/impl/ExternalTypeHandler.java
@@ -277,24 +277,7 @@ public class ExternalTypeHandler
                     ) {
                     continue;
                 }
-                // [databind#3786]: Need to mind natural types, for which no type id
-                // will be included.
-                JsonToken t = tb.firstToken();
-                if (t.isScalarValue()) {
-                    JsonParser buffered = tb.asParser(ctxt, p);
-                    buffered.nextToken();
-                    SettableBeanProperty prop = extProp.getProperty();
-                    Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, prop.getType());
-                    if (result != null) {
-                        values[i] = result;
-                        // Unlike bean-based complete(), creator-based needs
-                        // to assign parameter to buffer before continuing
-                        if (prop.isCreatorProperty()) {
-                            buffer.assignParameter(prop, result);
-                        }
-                        continue;
-                    }
-                }
+                // but not just one
                 // 26-Oct-2012, tatu: As per [databind#94], must allow use of 'defaultImpl'
                 if (!extProp.hasDefaultType()) {
                     ctxt.reportPropertyInputMismatch(_beanType, extProp.getProperty().getName(),
diff --git a/src/main/java/tools/jackson/databind/jsontype/TypeDeserializer.java b/src/main/java/tools/jackson/databind/jsontype/TypeDeserializer.java
index aaa158d01..3595a9509 100644
--- a/src/main/java/tools/jackson/databind/jsontype/TypeDeserializer.java
+++ b/src/main/java/tools/jackson/databind/jsontype/TypeDeserializer.java
@@ -159,12 +159,6 @@ public abstract class TypeDeserializer
             if (base.isAssignableFrom(Integer.class)) {
                 return p.getIntValue();
             }
-            // 07-Feb-2026, tatu: [databind#3786] We should probably FIRST check
-            //   `Long.class`, as default... but due to backwards-compatibility
-            //   requirements cannot simply change
-            if (base.isAssignableFrom(Long.class)) {
-                return p.getLongValue();
-            }
             break;
 
         case VALUE_NUMBER_FLOAT:
diff --git a/src/test/java/tools/jackson/databind/records/RecordExternalPropertyGeneric3786Test.java b/src/test/java/tools/jackson/databind/records/RecordExternalPropertyGeneric3786Test.java
deleted file mode 100644
index 1c1986086..000000000
--- a/src/test/java/tools/jackson/databind/records/RecordExternalPropertyGeneric3786Test.java
+++ /dev/null
@@ -1,89 +0,0 @@
-package tools.jackson.databind.records;
-
-import org.junit.jupiter.api.Test;
-
-import com.fasterxml.jackson.annotation.JsonTypeInfo;
-
-import tools.jackson.core.type.TypeReference;
-import tools.jackson.databind.ObjectMapper;
-import tools.jackson.databind.testutil.DatabindTestUtil;
-import tools.jackson.databind.testutil.NoCheckSubTypeValidator;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-
-// [databind#3786]: Deserialization of generic container (Record type) using
-// EXTERNAL_PROPERTY fails for boxed built-ins because type information is missing
-public class RecordExternalPropertyGeneric3786Test extends DatabindTestUtil
-{
-    record Container3786<T>(
-        int id,
-        @JsonTypeInfo(
-            use = JsonTypeInfo.Id.CLASS,
-            include = JsonTypeInfo.As.EXTERNAL_PROPERTY,
-            property = "type"
-        )
-        T value
-    ) { }
-
-    record MyObject3786(
-        String foo,
-        String bar
-    ) { }
-
-    // Need to allow Object as base type for CLASS-based type id
-    private final ObjectMapper MAPPER = jsonMapperBuilder()
-            .polymorphicTypeValidator(NoCheckSubTypeValidator.instance)
-            .build();
-
-    // This case works: custom object has type info written
-    @Test
-    public void testCustomObjectRoundTrip() {
-        Container3786<MyObject3786> myContainer = new Container3786<>(1, new MyObject3786("foo", "bar"));
-        String json = MAPPER.writeValueAsString(myContainer);
-
-        // Should include type property for custom object
-        Container3786<?> result = MAPPER.readValue(json, new TypeReference<Container3786<?>>() { });
-        assertNotNull(result);
-        assertEquals(1, result.id());
-        assertNotNull(result.value());
-    }
-
-    // This case fails: String value has no type info written,
-    // but deserialization requires it
-    @Test
-    public void testStringValueRoundTrip() {
-        Container3786<String> strContainer = new Container3786<>(1, "Hello");
-        String json = MAPPER.writeValueAsString(strContainer);
-
-        // JSON will be {"id":1,"value":"Hello"} -- no "type" property
-        Container3786<?> result = MAPPER.readValue(json, new TypeReference<Container3786<?>>() { });
-        assertNotNull(result);
-        assertEquals(1, result.id());
-        assertEquals("Hello", result.value());
-    }
-
-    // Also test with Integer value
-    @Test
-    public void testIntegerValueRoundTrip() {
-        Container3786<Integer> intContainer = new Container3786<>(1, 42);
-        String json = MAPPER.writeValueAsString(intContainer);
-
-        Container3786<?> result = MAPPER.readValue(json, new TypeReference<Container3786<?>>() { });
-        assertNotNull(result);
-        assertEquals(1, result.id());
-        assertEquals(42, result.value());
-    }
-
-    // Also test with Boolean value
-    @Test
-    public void testBooleanValueRoundTrip() {
-        Container3786<Boolean> boolContainer = new Container3786<>(1, true);
-        String json = MAPPER.writeValueAsString(boolContainer);
-
-        Container3786<?> result = MAPPER.readValue(json, new TypeReference<Container3786<?>>() { });
-        assertNotNull(result);
-        assertEquals(1, result.id());
-        assertEquals(true, result.value());
-    }
-}
