diff --git a/.travis.yml b/.travis.yml
index cd23e575a..f980fe6ab 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -57,11 +57,11 @@ jobs:
 
     - env: TEST="docs"
       install: gem install jekyll -v 2.5
-      script: sbt docs/makeMicrosite
+      script: sbt makeMicrosite
 
     - stage: styling
       env: TEST="linting"
-      script: sbt fmtCheck
+      script: sbt scalastyle fmtCheck
 
     - env: TEST="scalafix"
       script: cd scalafix && sbt tests/test
diff --git a/bench/src/main/scala/cats/bench/ChainBench.scala b/bench/src/main/scala/cats/bench/ChainBench.scala
new file mode 100644
index 000000000..a8e64b340
--- /dev/null
+++ b/bench/src/main/scala/cats/bench/ChainBench.scala
@@ -0,0 +1,79 @@
+package cats.bench
+
+import cats.data.Chain
+import fs2.Catenable
+import chain.{Chain => OldChain}
+import org.openjdk.jmh.annotations.{Benchmark, Scope, State}
+
+@State(Scope.Thread)
+class ChainBench {
+
+  private val smallChain = Chain(1, 2, 3, 4, 5)
+  private val smallCatenable = Catenable(1, 2, 3, 4, 5)
+  private val smallVector = Vector(1, 2, 3, 4, 5)
+  private val smallList = List(1, 2, 3, 4, 5)
+  private val smallOldChain = OldChain(smallList)
+
+  private val largeChain = (0 to 1000)
+    .foldLeft(Chain.empty[Int])((acc, _) => acc ++ Chain.fromSeq(0 to 1000))
+  private val largeCatenable = Catenable.fromSeq(0 to 1000000)
+  private val largeVector = (0 to 1000000).toVector
+  private val largeList = (0 to 1000000).toList
+  private val largeOldChain = (0 to 1000).foldLeft(OldChain.empty[Int])((acc, _) => acc ++ OldChain(0 to 1000))
+
+
+  @Benchmark def mapSmallChain: Chain[Int] = smallChain.map(_ + 1)
+  @Benchmark def mapSmallCatenable: Catenable[Int] = smallCatenable.map(_ + 1)
+  @Benchmark def mapSmallVector: Vector[Int] = smallVector.map(_ + 1)
+  @Benchmark def mapSmallList: List[Int] = smallList.map(_ + 1)
+  @Benchmark def mapSmallOldChain: OldChain[Int] = smallOldChain.map(_ + 1)
+
+
+  @Benchmark def mapLargeChain: Chain[Int] = largeChain.map(_ + 1)
+  @Benchmark def mapLargeCatenable: Catenable[Int] = largeCatenable.map(_ + 1)
+  @Benchmark def mapLargeVector: Vector[Int] = largeVector.map(_ + 1)
+  @Benchmark def mapLargeList: List[Int] = largeList.map(_ + 1)
+  @Benchmark def mapLargeOldChain: OldChain[Int] = largeOldChain.map(_ + 1)
+
+
+
+  @Benchmark def foldLeftSmallChain: Int = smallChain.foldLeft(0)(_ + _)
+  @Benchmark def foldLeftSmallCatenable: Int = smallCatenable.foldLeft(0)(_ + _)
+  @Benchmark def foldLeftSmallVector: Int = smallVector.foldLeft(0)(_ + _)
+  @Benchmark def foldLeftSmallList: Int = smallList.foldLeft(0)(_ + _)
+  @Benchmark def foldLeftSmallOldChain: Int = smallOldChain.foldLeft(0)(_ + _)
+
+
+  @Benchmark def foldLeftLargeChain: Int = largeChain.foldLeft(0)(_ + _)
+  @Benchmark def foldLeftLargeCatenable: Int = largeCatenable.foldLeft(0)(_ + _)
+  @Benchmark def foldLeftLargeVector: Int = largeVector.foldLeft(0)(_ + _)
+  @Benchmark def foldLeftLargeList: Int = largeList.foldLeft(0)(_ + _)
+  @Benchmark def foldLeftLargeOldChain: Int = largeOldChain.foldLeft(0)(_ + _)
+
+
+
+
+  @Benchmark def consSmallChain: Chain[Int] = 0 +: smallChain
+  @Benchmark def consSmallCatenable: Catenable[Int] = 0 +: smallCatenable
+  @Benchmark def consSmallVector: Vector[Int] = 0 +: smallVector
+  @Benchmark def consSmallList: List[Int] = 0 +: smallList
+  @Benchmark def consSmallOldChain: OldChain[Int] = 0 +: smallOldChain
+
+  @Benchmark def consLargeChain: Chain[Int] = 0 +: largeChain
+  @Benchmark def consLargeCatenable: Catenable[Int] = 0 +: largeCatenable
+  @Benchmark def consLargeVector: Vector[Int] = 0 +: largeVector
+  @Benchmark def consLargeList: List[Int] = 0 +: largeList
+  @Benchmark def consLargeOldChain: OldChain[Int] = 0 +: largeOldChain
+
+  @Benchmark def createTinyChain: Chain[Int] = Chain(1)
+  @Benchmark def createTinyCatenable: Catenable[Int] = Catenable(1)
+  @Benchmark def createTinyVector: Vector[Int] = Vector(1)
+  @Benchmark def createTinyList: List[Int] = List(1)
+  @Benchmark def createTinyOldChain: OldChain[Int] = OldChain.single(1)
+
+  @Benchmark def createSmallChain: Chain[Int] = Chain(1, 2, 3, 4, 5)
+  @Benchmark def createSmallCatenable: Catenable[Int] = Catenable(1, 2, 3, 4, 5)
+  @Benchmark def createSmallVector: Vector[Int] = Vector(1, 2, 3, 4, 5)
+  @Benchmark def createSmallList: List[Int] = List(1, 2, 3, 4, 5)
+  @Benchmark def createSmallOldChain: OldChain[Int] = OldChain(Seq(1, 2, 3, 4, 5))
+}
diff --git a/bench/src/main/scala/cats/bench/CollectionMonoidBench.scala b/bench/src/main/scala/cats/bench/CollectionMonoidBench.scala
new file mode 100644
index 000000000..81d4ec197
--- /dev/null
+++ b/bench/src/main/scala/cats/bench/CollectionMonoidBench.scala
@@ -0,0 +1,24 @@
+package cats.bench
+
+import cats.Monoid
+import cats.data.Chain
+import cats.implicits._
+import chain.{Chain => OldChain}
+import org.openjdk.jmh.annotations.{Benchmark, Scope, State}
+
+@State(Scope.Thread)
+class CollectionMonoidBench {
+
+  private val largeList = (0 to 1000000).toList
+
+  implicit def monoidOldChain[A]: Monoid[OldChain[A]] = new Monoid[OldChain[A]] {
+    def empty: OldChain[A] = OldChain.empty[A]
+
+    def combine(x: OldChain[A], y: OldChain[A]): OldChain[A] = x ++ y
+  }
+
+  @Benchmark def accumulateChain: Chain[Int] = largeList.foldMap(Chain.one)
+  @Benchmark def accumulateVector: Vector[Int] = largeList.foldMap(Vector(_))
+  @Benchmark def accumulateList: List[Int] = largeList.foldMap(List(_))
+  @Benchmark def accumulateOldChain: OldChain[Int] = largeList.foldMap(OldChain.single)
+}
diff --git a/bench/src/main/scala/cats/bench/MapMonoidBench.scala b/bench/src/main/scala/cats/bench/MapMonoidBench.scala
new file mode 100644
index 000000000..f13d9c4a4
--- /dev/null
+++ b/bench/src/main/scala/cats/bench/MapMonoidBench.scala
@@ -0,0 +1,59 @@
+package cats.bench
+
+import cats.instances.list._
+import cats.instances.int._
+import cats.instances.map._
+
+import scalaz.std.anyVal._
+import scalaz.std.list._
+import scalaz.std.map._
+
+import org.openjdk.jmh.annotations.{ Benchmark, Scope, State }
+
+@State(Scope.Benchmark)
+class MapMonoidBench {
+
+  val words: List[String] =
+    for {
+      c <- List("a", "b", "c", "d", "e")
+      t <- 1 to 100
+    } yield c * t
+
+  val maps: List[Map[String, Int]] = (words ++ words).map(s => Map(s -> 1))
+
+  @Benchmark def combineAllCats: Map[String, Int] =
+    cats.Monoid[Map[String, Int]].combineAll(maps)
+
+  @Benchmark def combineCats: Map[String, Int] =
+    maps.foldLeft(Map.empty[String, Int]) {
+      case (acc, m) => cats.Monoid[Map[String, Int]].combine(acc, m)
+    }
+
+  @Benchmark def combineScalaz: Map[String, Int] =
+    maps.foldLeft(Map.empty[String, Int]) {
+      case (acc, m) => scalaz.Monoid[Map[String, Int]].append(acc, m)
+    }
+
+  @Benchmark def combineDirect: Map[String, Int] =
+    maps.foldLeft(Map.empty[String, Int]) {
+      case (acc, m) => m.foldLeft(acc) {
+        case (m, (k, v)) => m.updated(k, v + m.getOrElse(k, 0))
+      }
+    }
+
+  @Benchmark def combineGeneric: Map[String, Int] =
+    combineMapsGeneric[String, Int](maps, 0, _ + _)
+
+  def combineMapsGeneric[K, V](maps: List[Map[K, V]], z: V, f: (V, V) => V): Map[K, V] =
+    maps.foldLeft(Map.empty[K, V]) {
+      case (acc, m) => m.foldLeft(acc) {
+        case (m, (k, v)) => m.updated(k, f(v, m.getOrElse(k, z)))
+      }
+    }
+
+  @Benchmark def foldMapCats: Map[String, Int] =
+    cats.Foldable[List].foldMap(maps)(identity)
+
+  @Benchmark def foldMapScalaz: Map[String, Int] =
+    scalaz.Foldable[List].foldMap(maps)(identity)
+}
diff --git a/core/src/main/scala-2.13+/cats/instances/lazyList.scala b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
index b60e348ac..a33fb71fb 100644
--- a/core/src/main/scala-2.13+/cats/instances/lazyList.scala
+++ b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
@@ -15,12 +15,12 @@ trait StreamInstances extends LazyListInstances {
 
 trait LazyListInstances extends cats.kernel.instances.StreamInstances {
   implicit val catsStdInstancesForLazyList
-    : Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] =
+  : Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] =
     new Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] {
 
       def empty[A]: LazyList[A] = LazyList.empty
 
-      def combineK[A](x: LazyList[A], y: LazyList[A]): LazyList[A] = x.lazyAppendedAll(y)
+      def combineK[A](x: LazyList[A], y: LazyList[A]): LazyList[A]  = x lazyAppendedAll y
 
       def pure[A](x: A): LazyList[A] = LazyList(x)
 
@@ -55,9 +55,9 @@ trait LazyListInstances extends cats.kernel.instances.StreamInstances {
         B.combineAll(fa.iterator.map(f))
 
       def traverse[G[_], A, B](fa: LazyList[A])(f: A => G[B])(implicit G: Applicative[G]): G[LazyList[B]] =
-        // We use foldRight to avoid possible stack overflows. Since
-        // we don't want to return a Eval[_] instance, we call .value
-        // at the end.
+      // We use foldRight to avoid possible stack overflows. Since
+      // we don't want to return a Eval[_] instance, we call .value
+      // at the end.
         foldRight(fa, Always(G.pure(LazyList.empty[B]))) { (a, lgsb) =>
           G.map2Eval(f(a), lgsb)(_ #:: _)
         }.value
@@ -85,7 +85,8 @@ trait LazyListInstances extends cats.kernel.instances.StreamInstances {
                     stack = nextFront :: stack
                     advance()
                 }
-              } else {
+              }
+              else {
                 stack = tail
                 advance()
               }
@@ -189,18 +190,16 @@ trait LazyListInstances extends cats.kernel.instances.StreamInstances {
 
     override def flattenOption[A](fa: LazyList[Option[A]]): LazyList[A] = fa.flatten
 
-    def traverseFilter[G[_], A, B](
-      fa: LazyList[A]
-    )(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[LazyList[B]] =
+    def traverseFilter[G[_], A, B](fa: LazyList[A])(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[LazyList[B]] =
       fa.foldRight(Eval.now(G.pure(LazyList.empty[B])))(
-          (x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o))
-        )
+        (x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o))
+      )
         .value
 
     override def filterA[G[_], A](fa: LazyList[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[LazyList[A]] =
       fa.foldRight(Eval.now(G.pure(LazyList.empty[A])))(
-          (x, xse) => G.map2Eval(f(x), xse)((b, as) => if (b) x +: as else as)
-        )
+        (x, xse) => G.map2Eval(f(x), xse)((b, as) => if (b) x +: as else as)
+      )
         .value
 
   }
diff --git a/core/src/main/scala/cats/Invariant.scala b/core/src/main/scala/cats/Invariant.scala
index 313d8dad3..1960f1f24 100644
--- a/core/src/main/scala/cats/Invariant.scala
+++ b/core/src/main/scala/cats/Invariant.scala
@@ -2,7 +2,6 @@ package cats
 
 import cats.kernel._
 import simulacrum.typeclass
-import cats.kernel.compat.scalaVersionSpecific._
 
 /**
  * Must obey the laws defined in cats.laws.InvariantLaws.
@@ -50,8 +49,8 @@ object Invariant {
     def imap[A, B](fa: Monoid[A])(f: A => B)(g: B => A): Monoid[B] = new Monoid[B] {
       val empty = f(fa.empty)
       def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
+      override def combineAllOption(bs: TraversableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.map(g)).map(f)
     }
 
   }
@@ -60,8 +59,8 @@ object Invariant {
 
     def imap[A, B](fa: Band[A])(f: A => B)(g: B => A): Band[B] = new Band[B] {
       def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
+      override def combineAllOption(bs: TraversableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.map(g)).map(f)
     }
   }
 
@@ -69,8 +68,8 @@ object Invariant {
 
     def imap[A, B](fa: Semilattice[A])(f: A => B)(g: B => A): Semilattice[B] = new Semilattice[B] {
       def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
+      override def combineAllOption(bs: TraversableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.map(g)).map(f)
     }
 
   }
@@ -80,8 +79,8 @@ object Invariant {
     def imap[A, B](fa: CommutativeMonoid[A])(f: A => B)(g: B => A): CommutativeMonoid[B] = new CommutativeMonoid[B] {
       val empty = f(fa.empty)
       def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
+      override def combineAllOption(bs: TraversableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.map(g)).map(f)
     }
 
   }
@@ -91,8 +90,8 @@ object Invariant {
     def imap[A, B](fa: BoundedSemilattice[A])(f: A => B)(g: B => A): BoundedSemilattice[B] = new BoundedSemilattice[B] {
       val empty = f(fa.empty)
       def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
+      override def combineAllOption(bs: TraversableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.map(g)).map(f)
     }
 
   }
@@ -103,8 +102,8 @@ object Invariant {
       val empty = f(fa.empty)
       def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
       def inverse(b: B): B = f(fa.inverse(g(b)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
+      override def combineAllOption(bs: TraversableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.map(g)).map(f)
     }
 
   }
@@ -115,8 +114,8 @@ object Invariant {
       val empty = f(fa.empty)
       def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
       def inverse(b: B): B = f(fa.inverse(g(b)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
+      override def combineAllOption(bs: TraversableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.map(g)).map(f)
     }
 
   }
diff --git a/core/src/main/scala/cats/data/OneAnd.scala b/core/src/main/scala/cats/data/OneAnd.scala
index 9ddeb13a1..8cf849743 100644
--- a/core/src/main/scala/cats/data/OneAnd.scala
+++ b/core/src/main/scala/cats/data/OneAnd.scala
@@ -4,7 +4,7 @@ package data
 import scala.annotation.tailrec
 import scala.collection.mutable.Builder
 import cats.instances.stream._
-import kernel.compat.scalaVersionSpecific._
+import kernel.compat.lazyList._
 
 /**
  * A data type which represents a single element (head) and some other
diff --git a/core/src/main/scala/cats/data/WriterT.scala b/core/src/main/scala/cats/data/WriterT.scala
index f25a6522d..01f301326 100644
--- a/core/src/main/scala/cats/data/WriterT.scala
+++ b/core/src/main/scala/cats/data/WriterT.scala
@@ -16,6 +16,11 @@ final case class WriterT[F[_], L, V](run: F[(L, V)]) {
   def value(implicit functorF: Functor[F]): F[V] =
     functorF.map(run)(_._2)
 
+  def listen(implicit F: Functor[F]): WriterT[F, L, (V, L)] =
+    WriterT(F.map(run) {
+      case (l, v) => (l, (v, l))
+    })
+
   def ap[Z](f: WriterT[F, L, V => Z])(implicit F: Apply[F], L: Semigroup[L]): WriterT[F, L, Z] =
     WriterT(F.map2(f.run, run) {
       case ((l1, fvz), (l2, v)) => (L.combine(l1, l2), fvz(v))
@@ -84,7 +89,7 @@ final case class WriterT[F[_], L, V](run: F[(L, V)]) {
     )(WriterT.apply)
 }
 
-object WriterT extends WriterTInstances with WriterTFunctions {
+object WriterT extends WriterTInstances with WriterTFunctions with WriterTFunctions0 {
 
   def liftF[F[_], L, V](fv: F[V])(implicit monoidL: Monoid[L], F: Applicative[F]): WriterT[F, L, V] =
     WriterT(F.map(fv)(v => (monoidL.empty, v)))
@@ -527,6 +532,12 @@ sealed private[data] trait WriterTComonad[F[_], L] extends Comonad[WriterT[F, L,
   def extract[A](fa: WriterT[F, L, A]): A = F0.extract(F0.map(fa.run)(_._2))
 }
 
+// new trait for binary compatibility
+private[data] trait WriterTFunctions0 {
+  def listen[F[_], L, V](writerTFLV: WriterT[F, L, V])(implicit functorF: Functor[F]): WriterT[F, L, (V, L)] =
+    writerTFLV.listen
+}
+
 private[data] trait WriterTFunctions {
   def putT[F[_], L, V](vf: F[V])(l: L)(implicit functorF: Functor[F]): WriterT[F, L, V] =
     WriterT(functorF.map(vf)(v => (l, v)))
diff --git a/core/src/main/scala/cats/data/ZipStream.scala b/core/src/main/scala/cats/data/ZipStream.scala
index 832af5ce2..550931847 100644
--- a/core/src/main/scala/cats/data/ZipStream.scala
+++ b/core/src/main/scala/cats/data/ZipStream.scala
@@ -2,7 +2,7 @@ package cats
 package data
 
 import instances.stream._
-import kernel.compat.scalaVersionSpecific._
+import kernel.compat.lazyList._
 
 class ZipStream[A](val value: LazyList[A]) extends AnyVal
 
diff --git a/core/src/main/scala/cats/data/package.scala b/core/src/main/scala/cats/data/package.scala
index 09473cbba..25f83a527 100644
--- a/core/src/main/scala/cats/data/package.scala
+++ b/core/src/main/scala/cats/data/package.scala
@@ -1,5 +1,5 @@
 package cats
-import kernel.compat.scalaVersionSpecific._
+import kernel.compat.lazyList._
 import compat.lazyList.toLazyList
 package object data {
 
@@ -43,6 +43,9 @@ package object data {
     def value[L: Monoid, V](v: V): Writer[L, V] = WriterT.value(v)
 
     def tell[L](l: L): Writer[L, Unit] = WriterT.tell(l)
+
+    def listen[L, V](writer: Writer[L, V]): Writer[L, (V, L)] =
+      WriterT.listen(writer)
   }
 
   type IndexedState[S1, S2, A] = IndexedStateT[Eval, S1, S2, A]
diff --git a/core/src/main/scala/cats/instances/parallel.scala b/core/src/main/scala/cats/instances/parallel.scala
index d1a5547ca..845bf43bd 100644
--- a/core/src/main/scala/cats/instances/parallel.scala
+++ b/core/src/main/scala/cats/instances/parallel.scala
@@ -5,7 +5,7 @@ import cats.data._
 import cats.kernel.Semigroup
 import cats.syntax.either._
 import cats.{~>, Applicative, Apply, FlatMap, Functor, Monad, NonEmptyParallel, Parallel}
-import kernel.compat.scalaVersionSpecific._
+import kernel.compat.lazyList._
 
 trait ParallelInstances extends ParallelInstances1 {
   implicit def catsParallelForEitherValidated[E: Semigroup]: Parallel[Either[E, ?], Validated[E, ?]] =
diff --git a/core/src/main/scala/cats/instances/set.scala b/core/src/main/scala/cats/instances/set.scala
index 0e9e8c223..6abb316fc 100644
--- a/core/src/main/scala/cats/instances/set.scala
+++ b/core/src/main/scala/cats/instances/set.scala
@@ -41,6 +41,6 @@ trait SetInstances extends cats.kernel.instances.SetInstances {
 
   implicit def catsStdShowForSet[A: Show]: Show[Set[A]] = new Show[Set[A]] {
     def show(fa: Set[A]): String =
-      fa.iterator.map(_.show).mkString("Set(", ", ", ")")
+      fa.toIterator.map(_.show).mkString("Set(", ", ", ")")
   }
 }
diff --git a/core/src/main/scala/cats/instances/sortedSet.scala b/core/src/main/scala/cats/instances/sortedSet.scala
index 3dfb00214..24823a6cc 100644
--- a/core/src/main/scala/cats/instances/sortedSet.scala
+++ b/core/src/main/scala/cats/instances/sortedSet.scala
@@ -33,7 +33,7 @@ trait SortedSetInstances extends SortedSetInstances1 {
               go(idx - 1, it)
             }
           } else None
-        if (idx < Int.MaxValue && idx >= 0L) go(idx.toInt, fa.iterator) else None
+        if (idx < Int.MaxValue && idx >= 0L) go(idx.toInt, fa.toIterator) else None
       }
 
       override def size[A](fa: SortedSet[A]): Long = fa.size.toLong
@@ -64,7 +64,7 @@ trait SortedSetInstances extends SortedSetInstances1 {
 
   implicit def catsStdShowForSortedSet[A: Show]: Show[SortedSet[A]] = new Show[SortedSet[A]] {
     def show(fa: SortedSet[A]): String =
-      fa.iterator.map(_.show).mkString("SortedSet(", ", ", ")")
+      fa.toIterator.map(_.show).mkString("SortedSet(", ", ", ")")
   }
 
   implicit def catsKernelStdOrderForSortedSet[A: Order]: Order[SortedSet[A]] =
diff --git a/kernel/src/main/scala-2.12-/cats/kernel/compat/TraversableOnce.scala b/kernel/src/main/scala-2.12-/cats/kernel/compat/TraversableOnce.scala
index 76c592439..0106979ca 100644
--- a/kernel/src/main/scala-2.12-/cats/kernel/compat/TraversableOnce.scala
+++ b/kernel/src/main/scala-2.12-/cats/kernel/compat/TraversableOnce.scala
@@ -1,7 +1,6 @@
 package cats.kernel
 package compat
 
-@deprecated("No longer needed. Kept for bin compat", "2.0.0-RC1")
 private[kernel] object TraversableOnce {
   def reduceOption[A, A1 >: A](as: TraversableOnce[A], op: (A1, A1) => A1): Option[A1] =
     as.reduceOption(op)
diff --git a/kernel/src/main/scala-2.12-/cats/kernel/compat/lazyList.scala b/kernel/src/main/scala-2.12-/cats/kernel/compat/lazyList.scala
new file mode 100644
index 000000000..59c263f43
--- /dev/null
+++ b/kernel/src/main/scala-2.12-/cats/kernel/compat/lazyList.scala
@@ -0,0 +1,6 @@
+package cats.kernel.compat
+
+object lazyList {
+  type LazyList[+A] = Stream[A]
+  val LazyList = Stream
+}
diff --git a/kernel/src/main/scala-2.12-/cats/kernel/compat/scalaVersionSpecific.scala b/kernel/src/main/scala-2.12-/cats/kernel/compat/scalaVersionSpecific.scala
deleted file mode 100644
index 912c3f21f..000000000
--- a/kernel/src/main/scala-2.12-/cats/kernel/compat/scalaVersionSpecific.scala
+++ /dev/null
@@ -1,11 +0,0 @@
-package cats.kernel.compat
-
-private[cats] object scalaVersionSpecific {
-  type LazyList[+A] = Stream[A]
-  val LazyList = Stream
-  type IterableOnce[+A] = TraversableOnce[A]
-
-  implicit class traversableOnceExtension[A](private val to: TraversableOnce[A]) extends AnyVal {
-    def iterator: Iterator[A] = to.toIterator
-  }
-}
diff --git a/kernel/src/main/scala-2.13+/cats/kernel/compat/TraversableOnce.scala b/kernel/src/main/scala-2.13+/cats/kernel/compat/TraversableOnce.scala
new file mode 100644
index 000000000..bcfc4635b
--- /dev/null
+++ b/kernel/src/main/scala-2.13+/cats/kernel/compat/TraversableOnce.scala
@@ -0,0 +1,7 @@
+package cats.kernel
+package compat
+
+private[kernel] object TraversableOnce {
+  def reduceOption[A, A1 >: A](as: TraversableOnce[A], op: (A1, A1) => A1): Option[A1] =
+    as.iterator.reduceOption(op)
+}
diff --git a/kernel/src/main/scala-2.13+/cats/kernel/compat/lazyList.scala b/kernel/src/main/scala-2.13+/cats/kernel/compat/lazyList.scala
new file mode 100644
index 000000000..5b8fcead5
--- /dev/null
+++ b/kernel/src/main/scala-2.13+/cats/kernel/compat/lazyList.scala
@@ -0,0 +1,9 @@
+package cats
+package kernel
+
+package compat
+
+object lazyList {
+  type LazyList[+A] = scala.LazyList[A] //this is needed only to avoid unused import warnings on Scala 2.13
+  val LazyList = scala.LazyList
+}
diff --git a/kernel/src/main/scala-2.13+/cats/kernel/compat/scalaVersionSpecific.scala b/kernel/src/main/scala-2.13+/cats/kernel/compat/scalaVersionSpecific.scala
deleted file mode 100644
index ef8a0ffd5..000000000
--- a/kernel/src/main/scala-2.13+/cats/kernel/compat/scalaVersionSpecific.scala
+++ /dev/null
@@ -1,13 +0,0 @@
-package cats
-package kernel
-
-package compat
-
-private[cats] object scalaVersionSpecific {
-  type LazyList[+A] = scala.LazyList[A] //this is needed only to avoid unused import warnings on Scala 2.13
-  type IterableOnce[+A] = scala.IterableOnce[A] //this is needed only to avoid unused import warnings on Scala 2.13
-
-  implicit class iterableOnceExtension[A](private val io: IterableOnce[A]) extends AnyVal {
-    def reduceOption(f: (A, A) => A): Option[A] = io.iterator.reduceOption(f)
-  }
-}
diff --git a/kernel/src/main/scala/cats/kernel/Eq.scala b/kernel/src/main/scala/cats/kernel/Eq.scala
index bbc8110ff..631e264b2 100644
--- a/kernel/src/main/scala/cats/kernel/Eq.scala
+++ b/kernel/src/main/scala/cats/kernel/Eq.scala
@@ -3,7 +3,6 @@ package cats.kernel
 import scala.{specialized => sp}
 
 import scala.math.Equiv
-import compat.scalaVersionSpecific._
 
 /**
  * A type class used to determine equality between 2 instances of the same
@@ -111,7 +110,7 @@ object Eq extends EqFunctions[Eq] with EqToEquivConversion {
   def allEqualBoundedSemilattice[A]: BoundedSemilattice[Eq[A]] = new BoundedSemilattice[Eq[A]] {
     def empty = allEqual[A]
     def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.and(e1, e2)
-    override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
+    override def combineAllOption(es: TraversableOnce[Eq[A]]): Option[Eq[A]] =
       if (es.isEmpty) None
       else {
         val materialized = es.toVector
@@ -127,7 +126,7 @@ object Eq extends EqFunctions[Eq] with EqToEquivConversion {
    */
   def anyEqualSemilattice[A]: Semilattice[Eq[A]] = new Semilattice[Eq[A]] {
     def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.or(e1, e2)
-    override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
+    override def combineAllOption(es: TraversableOnce[Eq[A]]): Option[Eq[A]] =
       if (es.isEmpty) None
       else {
         val materialized = es.toVector
diff --git a/kernel/src/main/scala/cats/kernel/Monoid.scala b/kernel/src/main/scala/cats/kernel/Monoid.scala
index 8fc0c4992..bf66a3364 100644
--- a/kernel/src/main/scala/cats/kernel/Monoid.scala
+++ b/kernel/src/main/scala/cats/kernel/Monoid.scala
@@ -1,7 +1,6 @@
 package cats.kernel
 
 import scala.{specialized => sp}
-import compat.scalaVersionSpecific._
 
 /**
  * A monoid is a semigroup with an identity. A monoid is a specialization of a
@@ -78,10 +77,10 @@ trait Monoid[@sp(Int, Long, Float, Double) A] extends Any with Semigroup[A] {
    * res1: String = ""
    * }}}
    */
-  def combineAll(as: IterableOnce[A]): A =
+  def combineAll(as: TraversableOnce[A]): A =
     as.foldLeft(empty)(combine)
 
-  override def combineAllOption(as: IterableOnce[A]): Option[A] =
+  override def combineAllOption(as: TraversableOnce[A]): Option[A] =
     if (as.isEmpty) None else Some(combineAll(as))
 }
 
@@ -92,7 +91,7 @@ abstract class MonoidFunctions[M[T] <: Monoid[T]] extends SemigroupFunctions[M]
   def isEmpty[@sp(Int, Long, Float, Double) A](a: A)(implicit m: M[A], ev: Eq[A]): Boolean =
     m.isEmpty(a)
 
-  def combineAll[@sp(Int, Long, Float, Double) A](as: IterableOnce[A])(implicit ev: M[A]): A =
+  def combineAll[@sp(Int, Long, Float, Double) A](as: TraversableOnce[A])(implicit ev: M[A]): A =
     ev.combineAll(as)
 }
 
diff --git a/kernel/src/main/scala/cats/kernel/Semigroup.scala b/kernel/src/main/scala/cats/kernel/Semigroup.scala
index 602609b15..e63544c5c 100644
--- a/kernel/src/main/scala/cats/kernel/Semigroup.scala
+++ b/kernel/src/main/scala/cats/kernel/Semigroup.scala
@@ -2,7 +2,6 @@ package cats.kernel
 
 import scala.{specialized => sp}
 import scala.annotation.tailrec
-import compat.scalaVersionSpecific._
 
 /**
  * A semigroup is any set `A` with an associative operation (`combine`).
@@ -75,8 +74,8 @@ trait Semigroup[@sp(Int, Long, Float, Double) A] extends Any with Serializable {
    * res1: Option[String] = None
    * }}}
    */
-  def combineAllOption(as: IterableOnce[A]): Option[A] =
-    as.reduceOption(combine)
+  def combineAllOption(as: TraversableOnce[A]): Option[A] =
+    cats.kernel.compat.TraversableOnce.reduceOption(as, combine)
 }
 
 abstract class SemigroupFunctions[S[T] <: Semigroup[T]] {
@@ -104,7 +103,7 @@ abstract class SemigroupFunctions[S[T] <: Semigroup[T]] {
   def combineN[@sp(Int, Long, Float, Double) A](a: A, n: Int)(implicit ev: S[A]): A =
     ev.combineN(a, n)
 
-  def combineAllOption[A](as: IterableOnce[A])(implicit ev: S[A]): Option[A] =
+  def combineAllOption[A](as: TraversableOnce[A])(implicit ev: S[A]): Option[A] =
     ev.combineAllOption(as)
 }
 
diff --git a/kernel/src/main/scala/cats/kernel/instances/ListInstances.scala b/kernel/src/main/scala/cats/kernel/instances/ListInstances.scala
index 7712539d0..ca290716a 100644
--- a/kernel/src/main/scala/cats/kernel/instances/ListInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/ListInstances.scala
@@ -2,7 +2,6 @@ package cats.kernel
 package instances
 
 import scala.annotation.tailrec
-import compat.scalaVersionSpecific._
 
 trait ListInstances extends ListInstances1 {
   implicit def catsKernelStdOrderForList[A: Order]: Order[List[A]] =
@@ -89,6 +88,6 @@ class ListMonoid[A] extends Monoid[List[A]] {
   override def combineN(x: List[A], n: Int): List[A] =
     StaticMethods.combineNIterable(List.newBuilder[A], x, n)
 
-  override def combineAll(xs: IterableOnce[List[A]]): List[A] =
+  override def combineAll(xs: TraversableOnce[List[A]]): List[A] =
     StaticMethods.combineAllIterable(List.newBuilder[A], xs)
 }
diff --git a/kernel/src/main/scala/cats/kernel/instances/MapInstances.scala b/kernel/src/main/scala/cats/kernel/instances/MapInstances.scala
index 436f446cd..d06f8e724 100644
--- a/kernel/src/main/scala/cats/kernel/instances/MapInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/MapInstances.scala
@@ -2,7 +2,6 @@ package cats.kernel
 package instances
 
 import scala.collection.mutable
-import compat.scalaVersionSpecific._
 
 trait MapInstances extends MapInstances1 {
   implicit def catsKernelStdHashForMap[K: Hash, V: Hash]: Hash[Map[K, V]] =
@@ -73,7 +72,7 @@ class MapMonoid[K, V](implicit V: Semigroup[V]) extends Monoid[Map[K, V]] {
       }
     }
 
-  override def combineAll(xss: IterableOnce[Map[K, V]]): Map[K, V] = {
+  override def combineAll(xss: TraversableOnce[Map[K, V]]): Map[K, V] = {
     val acc = mutable.Map.empty[K, V]
     xss.foreach { m =>
       val it = m.iterator
diff --git a/kernel/src/main/scala/cats/kernel/instances/QueueInstances.scala b/kernel/src/main/scala/cats/kernel/instances/QueueInstances.scala
index f36e87ec9..1ec6c71ff 100644
--- a/kernel/src/main/scala/cats/kernel/instances/QueueInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/QueueInstances.scala
@@ -2,7 +2,6 @@ package cats.kernel
 package instances
 
 import scala.collection.immutable.Queue
-import compat.scalaVersionSpecific._
 
 trait QueueInstances extends QueueInstances1 {
   implicit def catsKernelStdOrderForQueue[A: Order]: Order[Queue[A]] =
@@ -53,6 +52,6 @@ class QueueMonoid[A] extends Monoid[Queue[A]] {
   override def combineN(x: Queue[A], n: Int): Queue[A] =
     StaticMethods.combineNIterable(Queue.newBuilder[A], x, n)
 
-  override def combineAll(xs: IterableOnce[Queue[A]]): Queue[A] =
+  override def combineAll(xs: TraversableOnce[Queue[A]]): Queue[A] =
     StaticMethods.combineAllIterable(Queue.newBuilder[A], xs)
 }
diff --git a/kernel/src/main/scala/cats/kernel/instances/StaticMethods.scala b/kernel/src/main/scala/cats/kernel/instances/StaticMethods.scala
index b27c441c6..51e5f233d 100644
--- a/kernel/src/main/scala/cats/kernel/instances/StaticMethods.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/StaticMethods.scala
@@ -3,7 +3,6 @@ package kernel
 package instances
 
 import scala.collection.mutable
-import compat.scalaVersionSpecific._
 
 object StaticMethods extends cats.kernel.compat.HashCompat {
 
@@ -76,7 +75,7 @@ object StaticMethods extends cats.kernel.compat.HashCompat {
     b.result
   }
 
-  def combineAllIterable[A, R](b: mutable.Builder[A, R], xs: IterableOnce[Iterable[A]]): R = {
+  def combineAllIterable[A, R](b: mutable.Builder[A, R], xs: TraversableOnce[Iterable[A]]): R = {
     xs.foreach(b ++= _)
     b.result
   }
diff --git a/kernel/src/main/scala/cats/kernel/instances/StreamInstances.scala b/kernel/src/main/scala/cats/kernel/instances/StreamInstances.scala
index 2ea3a2a37..ff21b0ffb 100644
--- a/kernel/src/main/scala/cats/kernel/instances/StreamInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/StreamInstances.scala
@@ -1,6 +1,6 @@
 package cats.kernel
 package instances
-import compat.scalaVersionSpecific._
+import compat.lazyList._
 
 trait StreamInstances extends StreamInstances1 {
   implicit def catsKernelStdOrderForStream[A: Order]: Order[LazyList[A]] =
@@ -50,6 +50,6 @@ class StreamMonoid[A] extends Monoid[LazyList[A]] {
   override def combineN(x: LazyList[A], n: Int): LazyList[A] =
     StaticMethods.combineNIterable(LazyList.newBuilder[A], x, n)
 
-  override def combineAll(xs: IterableOnce[LazyList[A]]): LazyList[A] =
+  override def combineAll(xs: TraversableOnce[LazyList[A]]): LazyList[A] =
     StaticMethods.combineAllIterable(LazyList.newBuilder[A], xs)
 }
diff --git a/kernel/src/main/scala/cats/kernel/instances/StringInstances.scala b/kernel/src/main/scala/cats/kernel/instances/StringInstances.scala
index 2919b29e4..50d0ad64c 100644
--- a/kernel/src/main/scala/cats/kernel/instances/StringInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/StringInstances.scala
@@ -1,6 +1,5 @@
 package cats.kernel
 package instances
-import compat.scalaVersionSpecific._
 
 trait StringInstances {
   implicit val catsKernelStdOrderForString: Order[String] with Hash[String] = new StringOrder
@@ -21,7 +20,7 @@ class StringMonoid extends Monoid[String] {
   def empty: String = ""
   def combine(x: String, y: String): String = x + y
 
-  override def combineAll(xs: IterableOnce[String]): String = {
+  override def combineAll(xs: TraversableOnce[String]): String = {
     val sb = new StringBuilder
     xs.foreach(sb.append)
     sb.toString
diff --git a/kernel/src/main/scala/cats/kernel/instances/UnitInstances.scala b/kernel/src/main/scala/cats/kernel/instances/UnitInstances.scala
index f8f58a888..e795cdfa3 100644
--- a/kernel/src/main/scala/cats/kernel/instances/UnitInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/UnitInstances.scala
@@ -1,6 +1,5 @@
 package cats.kernel
 package instances
-import compat.scalaVersionSpecific._
 
 trait UnitInstances {
   implicit val catsKernelStdOrderForUnit: Order[Unit] with Hash[Unit] =
@@ -32,6 +31,6 @@ class UnitAlgebra extends BoundedSemilattice[Unit] with CommutativeGroup[Unit] {
   override def remove(x: Unit, y: Unit): Unit = ()
   def inverse(x: Unit): Unit = ()
   override protected[this] def repeatedCombineN(a: Unit, n: Int): Unit = ()
-  override def combineAllOption(as: IterableOnce[Unit]): Option[Unit] =
+  override def combineAllOption(as: TraversableOnce[Unit]): Option[Unit] =
     if (as.isEmpty) None else Some(())
 }
diff --git a/kernel/src/main/scala/cats/kernel/instances/VectorInstances.scala b/kernel/src/main/scala/cats/kernel/instances/VectorInstances.scala
index e07422824..0d3b41405 100644
--- a/kernel/src/main/scala/cats/kernel/instances/VectorInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/VectorInstances.scala
@@ -1,6 +1,5 @@
 package cats.kernel
 package instances
-import compat.scalaVersionSpecific._
 
 trait VectorInstances extends VectorInstances1 {
   implicit def catsKernelStdOrderForVector[A: Order]: Order[Vector[A]] =
@@ -51,6 +50,6 @@ class VectorMonoid[A] extends Monoid[Vector[A]] {
   override def combineN(x: Vector[A], n: Int): Vector[A] =
     StaticMethods.combineNIterable(Vector.newBuilder[A], x, n)
 
-  override def combineAll(xs: IterableOnce[Vector[A]]): Vector[A] =
+  override def combineAll(xs: TraversableOnce[Vector[A]]): Vector[A] =
     StaticMethods.combineAllIterable(Vector.newBuilder[A], xs)
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/Arbitrary.scala b/laws/src/main/scala/cats/laws/discipline/Arbitrary.scala
index 78d0ccf20..3a69ace37 100644
--- a/laws/src/main/scala/cats/laws/discipline/Arbitrary.scala
+++ b/laws/src/main/scala/cats/laws/discipline/Arbitrary.scala
@@ -1,7 +1,7 @@
 package cats
 package laws
 package discipline
-import kernel.compat.scalaVersionSpecific._
+import kernel.compat.lazyList._
 import cats.data.NonEmptyList.ZipNonEmptyList
 import cats.data.NonEmptyVector.ZipNonEmptyVector
 import scala.util.{Failure, Success, Try}
diff --git a/project/plugins.sbt b/project/plugins.sbt
index 5f666cfaa..b360e5e91 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -4,6 +4,7 @@ addSbtPlugin("com.github.gseitz" %% "sbt-release" % "1.0.11")
 addSbtPlugin("com.jsuereth" % "sbt-pgp" % "2.0.0-M2")
 addSbtPlugin("com.typesafe" % "sbt-mima-plugin" % "0.3.0")
 addSbtPlugin("pl.project13.scala" % "sbt-jmh" % "0.3.7")
+addSbtPlugin("org.scalastyle" % "scalastyle-sbt-plugin" % "1.0.0")
 addSbtPlugin("org.scoverage" % "sbt-scoverage" % "1.6.0")
 addSbtPlugin("com.typesafe.sbt" % "sbt-git" % "1.0.0")
 addSbtPlugin("com.github.tkawachi" % "sbt-doctest" % "0.9.5")
diff --git a/scalastyle-config.xml b/scalastyle-config.xml
new file mode 100644
index 000000000..9b6c1c39c
--- /dev/null
+++ b/scalastyle-config.xml
@@ -0,0 +1,83 @@
+<scalastyle>
+ <name>Scalastyle standard configuration</name>
+ <check level="error" class="org.scalastyle.file.FileTabChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.file.FileLengthChecker" enabled="true">
+  <parameters>
+   <parameter name="maxFileLength"><![CDATA[800]]></parameter>
+  </parameters>
+ </check>
+ <check level="error" class="org.scalastyle.file.WhitespaceEndOfLineChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.ClassNamesChecker" enabled="true">
+  <parameters>
+   <parameter name="regex"><![CDATA[[A-Z][A-Za-z]*]]></parameter>
+  </parameters>
+ </check>
+ <check level="error" class="org.scalastyle.scalariform.ObjectNamesChecker" enabled="true">
+  <parameters>
+   <parameter name="regex"><![CDATA[[A-Za-z][A-Za-z]*]]></parameter>
+  </parameters>
+ </check>
+ <check level="error" class="org.scalastyle.scalariform.PackageObjectNamesChecker" enabled="true">
+  <parameters>
+   <parameter name="regex"><![CDATA[^[a-z][a-z]*$]]></parameter>
+  </parameters>
+ </check>
+ <check level="error" class="org.scalastyle.scalariform.EqualsHashCodeChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.IllegalImportsChecker" enabled="true">
+  <parameters>
+   <parameter name="illegalImports"><![CDATA[sun._,java.awt._]]></parameter>
+  </parameters>
+ </check>
+ <check level="error" class="org.scalastyle.scalariform.NoWhitespaceBeforeLeftBracketChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.NoWhitespaceAfterLeftBracketChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.ReturnChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.NullChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.NoCloneChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.NoFinalizeChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.CovariantEqualsChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.file.RegexChecker" enabled="true">
+  <parameters>
+   <parameter name="regex"><![CDATA[println]]></parameter>
+  </parameters>
+ </check>
+ <check level="error" class="org.scalastyle.scalariform.CyclomaticComplexityChecker" enabled="true">
+  <parameters>
+   <parameter name="maximum"><![CDATA[10]]></parameter>
+  </parameters>
+ </check>
+ <check level="error" class="org.scalastyle.scalariform.UppercaseLChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.SimplifyBooleanExpressionChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.scalariform.MethodLengthChecker" enabled="true">
+  <parameters>
+   <parameter name="maxLength"><![CDATA[55]]></parameter>
+  </parameters>
+ </check>
+ <check level="error" class="org.scalastyle.file.NewLineAtEofChecker" enabled="true"></check>
+ <check level="error" class="org.scalastyle.file.NoNewLineAtEofChecker" enabled="false"></check>
+ <check level="error" class="org.scalastyle.scalariform.PublicMethodsHaveTypeChecker" enabled="true">
+  <parameters>
+   <parameter name="ignoreOverride">false</parameter>
+  </parameters>
+ </check>
+ <check level="error" class="org.scalastyle.file.RegexChecker" enabled="true" customId="kind.projector.lambda">
+  <parameters>
+   <parameter name="regex">Lambda\[</parameter>
+  </parameters>
+  <customMessage><![CDATA[Use Greek characters in a kind projection (λ[α => ...]).]]></customMessage>
+ </check>
+ <check enabled="true" class="org.scalastyle.scalariform.EnsureSingleSpaceBeforeTokenChecker" level="error">
+   <parameters>
+     <parameter name="tokens">OP, PIPE, FORSOME</parameter>
+   </parameters>
+ </check>
+ <check enabled="true" class="org.scalastyle.scalariform.ForBraceChecker" level="error"/>
+ <check enabled="true" class="org.scalastyle.scalariform.ProcedureDeclarationChecker" level="error"/>
+ <check enabled="true" class="org.scalastyle.scalariform.RedundantIfChecker" level="error"/>
+ <check enabled="true" class="org.scalastyle.scalariform.SpaceAfterCommentStartChecker" level="error"/>
+ <check level="error" class="org.scalastyle.file.RegexChecker" enabled="true" customId="type.class.spacing">
+  <parameters>
+   <parameter name="regex"><![CDATA[(?<!@|simulacrum\.)typeclass]]></parameter>
+  </parameters>
+  <customMessage><![CDATA[Use 'type class' instead of typeclass (See #441)]]></customMessage>
+ </check>
+</scalastyle>
