diff --git a/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/GrammarToTree.kt b/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/GrammarToTree.kt
index 593e597c3b8..38c1f1f9726 100644
--- a/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/GrammarToTree.kt
+++ b/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/GrammarToTree.kt
@@ -36,6 +36,7 @@ import org.gradle.internal.declarativedsl.language.UnsupportedLanguageFeature.In
 import org.gradle.internal.declarativedsl.parsing.FailureCollectorContext.CheckedResult
 import org.jetbrains.kotlin.ElementTypeUtils.getOperationSymbol
 import org.jetbrains.kotlin.ElementTypeUtils.isExpression
+import org.jetbrains.kotlin.KtNodeTypes
 import org.jetbrains.kotlin.KtNodeTypes.ANNOTATED_EXPRESSION
 import org.jetbrains.kotlin.KtNodeTypes.ANNOTATION_ENTRY
 import org.jetbrains.kotlin.KtNodeTypes.ARRAY_ACCESS_EXPRESSION
@@ -44,8 +45,6 @@ import org.jetbrains.kotlin.KtNodeTypes.BLOCK
 import org.jetbrains.kotlin.KtNodeTypes.BOOLEAN_CONSTANT
 import org.jetbrains.kotlin.KtNodeTypes.CALL_EXPRESSION
 import org.jetbrains.kotlin.KtNodeTypes.CLASS
-import org.jetbrains.kotlin.KtNodeTypes.CLASS_BODY
-import org.jetbrains.kotlin.KtNodeTypes.CLASS_INITIALIZER
 import org.jetbrains.kotlin.KtNodeTypes.DOT_QUALIFIED_EXPRESSION
 import org.jetbrains.kotlin.KtNodeTypes.ESCAPE_STRING_TEMPLATE_ENTRY
 import org.jetbrains.kotlin.KtNodeTypes.FUN
@@ -67,6 +66,7 @@ import org.jetbrains.kotlin.KtNodeTypes.PARENTHESIZED
 import org.jetbrains.kotlin.KtNodeTypes.PREFIX_EXPRESSION
 import org.jetbrains.kotlin.KtNodeTypes.PROPERTY
 import org.jetbrains.kotlin.KtNodeTypes.REFERENCE_EXPRESSION
+import org.jetbrains.kotlin.KtNodeTypes.SCRIPT_INITIALIZER
 import org.jetbrains.kotlin.KtNodeTypes.SHORT_STRING_TEMPLATE_ENTRY
 import org.jetbrains.kotlin.KtNodeTypes.STRING_TEMPLATE
 import org.jetbrains.kotlin.KtNodeTypes.THIS_EXPRESSION
@@ -90,13 +90,11 @@ import org.jetbrains.kotlin.lexer.KtTokens.DOT
 import org.jetbrains.kotlin.lexer.KtTokens.EQ
 import org.jetbrains.kotlin.lexer.KtTokens.IDENTIFIER
 import org.jetbrains.kotlin.lexer.KtTokens.INTEGER_LITERAL
-import org.jetbrains.kotlin.lexer.KtTokens.LBRACE
 import org.jetbrains.kotlin.lexer.KtTokens.LPAR
 import org.jetbrains.kotlin.lexer.KtTokens.MINUS
 import org.jetbrains.kotlin.lexer.KtTokens.MUL
 import org.jetbrains.kotlin.lexer.KtTokens.OPEN_QUOTE
 import org.jetbrains.kotlin.lexer.KtTokens.QUALIFIED_ACCESS
-import org.jetbrains.kotlin.lexer.KtTokens.RBRACE
 import org.jetbrains.kotlin.lexer.KtTokens.RPAR
 import org.jetbrains.kotlin.lexer.KtTokens.SAFE_ACCESS
 import org.jetbrains.kotlin.parsing.hasIllegalUnderscore
@@ -107,14 +105,13 @@ import org.jetbrains.kotlin.parsing.parseBoolean
 import org.jetbrains.kotlin.parsing.parseNumericLiteral
 import org.jetbrains.kotlin.psi.stubs.elements.KtConstantExpressionElementType
 import org.jetbrains.kotlin.psi.stubs.elements.KtNameReferenceExpressionElementType
+import org.jetbrains.kotlin.util.getChildren
 import org.jetbrains.kotlin.utils.doNothing
 
 
 class GrammarToTree(
     private val sourceIdentifier: SourceIdentifier,
-    private val sourceCode: String,
-    private val sourceOffset: Int,
-    private val suffixLength: Int
+    private val sourceCode: String
 ) {
 
     inner
@@ -122,14 +119,14 @@ class GrammarToTree(
         private
         val sourceData: MutableMap<LighterASTNode, LightTreeSourceData> = mutableMapOf()
 
-        fun sourceData(node: LighterASTNode, offset: Int = sourceOffset): LightTreeSourceData =
+        fun sourceData(node: LighterASTNode): LightTreeSourceData =
             sourceData.computeIfAbsent(node) {
-                it.sourceData(sourceIdentifier, sourceCode, offset)
+                it.sourceData(sourceIdentifier, sourceCode)
             }
 
         fun rootSourceData(): LightTreeSourceData =
             sourceData.computeIfAbsent(root) {
-                LightTreeSourceData(sourceIdentifier, sourceCode, sourceOffset, sourceOffset..sourceCode.lastIndex - suffixLength)
+                LightTreeSourceData(sourceIdentifier, sourceCode, sourceCode.indices)
             }
 
         fun parsingError(node: LighterASTNode, message: String): ParsingError {
@@ -159,12 +156,6 @@ class GrammarToTree(
             val innerSourceData = sourceData(inner)
             return UnsupportedConstruct(outerSourceData, innerSourceData, feature)
         }
-
-        fun unsupportedNoOffset(outer: LighterASTNode, inner: LighterASTNode, feature: UnsupportedLanguageFeature): UnsupportedConstruct {
-            val outerSourceData = sourceData(outer, 0)
-            val innerSourceData = sourceData(inner, 0)
-            return UnsupportedConstruct(outerSourceData, innerSourceData, feature)
-        } // TODO: hack, due to script wrapping
     }
 
     fun script(originalTree: LightTree): LanguageTreeResult {
@@ -190,7 +181,7 @@ class GrammarToTree(
     private
     fun packageHeader(tree: CachingLightTree, node: LighterASTNode): List<FailingResult> =
         when {
-            tree.children(node).isNotEmpty() -> listOf(tree.unsupportedNoOffset(node, node, UnsupportedLanguageFeature.PackageHeader))
+            tree.children(node).isNotEmpty() -> listOf(tree.unsupported(node, node, UnsupportedLanguageFeature.PackageHeader))
             else -> listOf()
         }
 
@@ -206,8 +197,8 @@ class GrammarToTree(
                             propertyAccessStatement(tree, it)
                                 .flatMap { e -> if (e is NamedReference) Element(e) else tree.unsupported(node, InvalidImportValue) }
                         )
-                        MUL -> collectingFailure(tree.unsupportedNoOffset(node, it, UnsupportedLanguageFeature.StarImport))
-                        IMPORT_ALIAS -> collectingFailure(tree.unsupportedNoOffset(node, it, UnsupportedLanguageFeature.RenamingImport))
+                        MUL -> collectingFailure(tree.unsupported(node, it, UnsupportedLanguageFeature.StarImport))
+                        IMPORT_ALIAS -> collectingFailure(tree.unsupported(node, it, UnsupportedLanguageFeature.RenamingImport))
                     }
                 }
 
@@ -223,7 +214,7 @@ class GrammarToTree(
                         }
 
                     val nameParts = checked(content!!).flatten()
-                    Element(Import(AccessChain(nameParts), tree.sourceData(node, offset = 0)))
+                    Element(Import(AccessChain(nameParts), tree.sourceData(node)))
                 }
             }
         }
@@ -744,19 +735,12 @@ class GrammarToTree(
         tree.children(toplevelNode(tree, IMPORT_LIST))
 
     private
-    fun scriptNodes(tree: LightTree): List<LighterASTNode> {
-        // the actual script we want to parse is wrapped into a class initializer block, we need to extract it
-
-        val childrenOfWrappingClass = tree.children(toplevelNode(tree, CLASS))
-        val wrappingClassBody = childrenOfWrappingClass.expectSingleOfKind(CLASS_BODY)
-        val childrenOfWrappingClassBody = tree.children(wrappingClassBody)
-        val wrappingClassInitializer = childrenOfWrappingClassBody.expectSingleOfKind(CLASS_INITIALIZER)
-        val childrenOfWrappingClassInitializer = tree.children(wrappingClassInitializer)
-        val wrappingClassInitializerBlock = childrenOfWrappingClassInitializer.expectSingleOfKind(BLOCK)
-        val childrenOfWrappingClassInitializerBlock = tree.children(wrappingClassInitializerBlock)
-
-        return extractBlockContent(childrenOfWrappingClassInitializerBlock)
-    }
+    fun scriptNodes(tree: LightTree): List<LighterASTNode> =
+        tree.children(toplevelNode(tree, KtNodeTypes.SCRIPT))
+            .expectSingleOrNoneOfKind(BLOCK)?.getChildren(tree)
+            ?.filter(LighterASTNode::isUseful)
+            ?.flatMap { if (it.tokenType == SCRIPT_INITIALIZER) it.getChildren(tree) else listOf(it) }
+            .orEmpty()
 
     private
     fun toplevelNode(tree: LightTree, parentNode: IElementType): LighterASTNode {
@@ -765,19 +749,6 @@ class GrammarToTree(
         return childrenOfRoot.expectSingleOfKind(parentNode)
     }
 
-    private
-    fun extractBlockContent(blockNodes: List<LighterASTNode>): List<LighterASTNode> {
-        check(blockNodes.size >= 2) // first and last nodes are the opening an¡¡d closing braces
-
-        val openBrace = blockNodes.first()
-        openBrace.expectKind(LBRACE)
-
-        val closingBrace = blockNodes.last()
-        closingBrace.expectKind(RBRACE)
-
-        return blockNodes.slice(1..blockNodes.size - 2)
-    }
-
     private
     fun FailureCollectorContext.childrenWithParsingErrorCollection(tree: CachingLightTree, node: LighterASTNode): List<LighterASTNode> {
         val children = tree.children(node)
diff --git a/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/LanguageTreeBuilder.kt b/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/LanguageTreeBuilder.kt
index 956113ccf49..22e75b2f8a7 100644
--- a/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/LanguageTreeBuilder.kt
+++ b/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/LanguageTreeBuilder.kt
@@ -14,6 +14,6 @@ class DefaultLanguageTreeBuilder : LanguageTreeBuilder {
         parsedLightTree: ParsedLightTree,
         sourceIdentifier: SourceIdentifier
     ): LanguageTreeResult =
-        GrammarToTree(sourceIdentifier, parsedLightTree.wrappedCode, parsedLightTree.originalCodeOffset, parsedLightTree.suffixLength)
+        GrammarToTree(sourceIdentifier, parsedLightTree.code)
             .script(parsedLightTree.lightTree)
 }
diff --git a/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/LightTreeUtil.kt b/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/LightTreeUtil.kt
index 7ea81f87d7c..65aa5397769 100644
--- a/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/LightTreeUtil.kt
+++ b/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/LightTreeUtil.kt
@@ -27,13 +27,11 @@ typealias LightTree = FlyweightCapableTreeStructure<LighterASTNode>
 
 fun FlyweightCapableTreeStructure<LighterASTNode>.sourceData(
     sourceIdentifier: SourceIdentifier,
-    sourceCode: String,
-    sourceOffset: Int
+    sourceCode: String
 ) =
     LightTreeSourceData(
         sourceIdentifier,
         sourceCode,
-        sourceOffset,
         root.range()
     )
 
@@ -41,22 +39,16 @@ fun FlyweightCapableTreeStructure<LighterASTNode>.sourceData(
 class LightTreeSourceData(
     override val sourceIdentifier: SourceIdentifier,
     private val sourceCode: String,
-    private val sourceOffset: Int,
     private val nodeRange: IntRange,
 ) : SourceData {
 
     override fun toString(): String = "LightTreeSourceData(${sourceIdentifier.fileIdentifier}:$nodeRange)"
 
-    override val indexRange: IntRange by lazy {
-        val originalRange = nodeRange
-        val first = originalRange.first - sourceOffset
-        val last = originalRange.last - sourceOffset
-        first..last
-    }
+    override val indexRange: IntRange = nodeRange
 
     private
     val lineColumnInfo: LineColumnInfo by lazy {
-        LineColumnInfo.fromIndexRange(sourceCode, sourceOffset, indexRange)
+        LineColumnInfo.fromIndexRange(sourceCode, indexRange)
     }
     override
     val lineRange: IntRange
@@ -68,12 +60,12 @@ class LightTreeSourceData(
     val endColumn: Int
         get() = lineColumnInfo.endColumn
     override
-    fun text(): String = sourceCode.substring((indexRange.first + sourceOffset)..(indexRange.last + sourceOffset))
+    fun text(): String = sourceCode.substring(indexRange)
 
     private
     class LineColumnInfo(val startLine: Int, val startColumn: Int, val endLine: Int, val endColumn: Int) {
         companion object Factory {
-            fun fromIndexRange(text: String, offset: Int, offsetRelativeIndexRange: IntRange): LineColumnInfo {
+            fun fromIndexRange(text: String, indexRange: IntRange): LineColumnInfo {
                 fun String.newLineLength(index: Int): Int =
                     when (this[index]) {
                         '\n' -> 1
@@ -85,33 +77,28 @@ class LightTreeSourceData(
 
                 fun String.isValidIndex(index: Int) = index in indices
 
-                check(text.isValidIndex(offset))
-
-                val realStartIndex = offset + offsetRelativeIndexRange.first
-                check(text.isValidIndex(realStartIndex))
-
-                val realEndIndex = offset + offsetRelativeIndexRange.last
-                check(text.isValidIndex(realEndIndex))
+                check(text.isValidIndex(indexRange.first) || indexRange.first == text.lastIndex + 1)
+                check(text.isValidIndex(indexRange.last))
 
-                check(realEndIndex - realStartIndex >= -1) // -1 is for empty intervals
+                check(indexRange.last - indexRange.first >= -1) // -1 is for empty intervals
 
                 var startLine = -1
                 var startColumn = -1
                 var endLine = -1
                 var endColumn = -1
 
-                var i = offset
+                var i = 0
                 var line = 1
                 var column = 1
                 while (i < text.length) {
-                    if (i == realStartIndex) {
+                    if (i == indexRange.first) {
                         startLine = line
                         startColumn = column
                     }
-                    if (i == realEndIndex) {
+                    if (i == indexRange.last) {
                         endLine = line
                         endColumn = column
-                        if (realStartIndex == realEndIndex + 1) { // might be an empty range, e.g. 20..19
+                        if (indexRange.first == indexRange.last + 1) { // might be an empty range, e.g. 20..19
                             startLine = line
                             startColumn = column + 1
                         }
@@ -239,16 +226,14 @@ val LighterASTNode.isUseful: Boolean
     get() = !(COMMENTS.contains(tokenType) || tokenType == WHITE_SPACE || tokenType == SEMICOLON)
 
 
-internal
-fun LighterASTNode.expectKind(expected: IElementType) {
-    check(isKind(expected))
-}
-
-
 internal
 fun List<LighterASTNode>.expectSingleOfKind(expected: IElementType): LighterASTNode =
     this.single { it.isKind(expected) }
 
+internal
+fun List<LighterASTNode>.expectSingleOrNoneOfKind(expected: IElementType): LighterASTNode? =
+    this.singleOrNull { it.isKind(expected) }
+
 
 internal
 fun LighterASTNode.isKind(expected: IElementType) =
@@ -256,8 +241,8 @@ fun LighterASTNode.isKind(expected: IElementType) =
 
 
 internal
-fun LighterASTNode.sourceData(sourceIdentifier: SourceIdentifier, sourceCode: String, sourceOffset: Int) =
-    LightTreeSourceData(sourceIdentifier, sourceCode, sourceOffset, this.range())
+fun LighterASTNode.sourceData(sourceIdentifier: SourceIdentifier, sourceCode: String) =
+    LightTreeSourceData(sourceIdentifier, sourceCode, this.range())
 
 
 private
diff --git a/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/Parser.kt b/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/Parser.kt
index 803af55650e..b83f97a59a2 100644
--- a/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/Parser.kt
+++ b/platforms/core-configuration/declarative-dsl-core/src/main/kotlin/org/gradle/internal/declarativedsl/parsing/Parser.kt
@@ -1,6 +1,5 @@
 package org.gradle.internal.declarativedsl.parsing
 
-import org.gradle.internal.declarativedsl.analysis.interpretationFailure
 import org.intellij.lang.annotations.Language
 import org.jetbrains.kotlin.com.intellij.lang.impl.PsiBuilderFactoryImpl
 import org.jetbrains.kotlin.lexer.KotlinLexer
@@ -22,77 +21,14 @@ val psiBuilderFactory by lazy {
 
 data class ParsedLightTree(
     val lightTree: LightTree,
-    val wrappedCode: String,
-    val originalCodeOffset: Int,
-    val suffixLength: Int,
+    val code: String,
 )
 
 
 fun parse(@Language("dcl") code: String): ParsedLightTree {
-    val (wrappedCode, codeOffset, suffixLength) = wrapScriptIntoClassInitializerBlock(code)
     val lexer = KotlinLexer()
     return ParsedLightTree(
-        KotlinLightParser.parse(psiBuilderFactory.createBuilder(parserDefinition, lexer, wrappedCode), isScript = false),
-        wrappedCode,
-        codeOffset,
-        suffixLength
+        KotlinLightParser.parse(psiBuilderFactory.createBuilder(parserDefinition, lexer, code), isScript = true),
+        code,
     )
 }
-
-
-fun main() {
-    parse(
-        """
-            #!/usr/bin/env kscript
-        a = 1""".trimIndent()
-    ).lightTree.print()
-}
-
-
-private
-fun wrapScriptIntoClassInitializerBlock(@Language("dcl") code: String): Triple<String, Int, Int> {
-    val packageStatements = mutableListOf<String>()
-    val importStatements = mutableListOf<String>()
-    val codeStatements = mutableListOf<String>()
-
-    var isAfterImportLine = false
-
-    code.lines().forEach { line ->
-        when {
-            line.startsWith("import") -> {
-                importStatements.add(line)
-                isAfterImportLine = true
-            }
-
-            line.startsWith("package") -> {
-                packageStatements.add(line)
-                isAfterImportLine = false
-            }
-
-            line.isBlank() -> {
-                if (!isAfterImportLine) codeStatements.add(line)
-            }
-
-            else -> {
-                codeStatements.add(line)
-                isAfterImportLine = false
-            }
-        } // TODO: ugly, brittle hack...
-    }
-
-    if (packageStatements.size > 2) interpretationFailure("Multiple package statements in $code")
-
-    fun addNewlineIfNotBlank(it: String) = when {
-        it.isNotBlank() -> it + "\n"
-        else -> it
-    }
-
-    val packageSection = packageStatements.joinToString("") { addNewlineIfNotBlank(it) }
-    val importSection = importStatements.joinToString("") { addNewlineIfNotBlank(it) }
-    val codeSection = codeStatements.joinToString("") { "$it\n" }
-
-    val prefix = "${packageSection}${importSection}class Script {init {"
-    val suffix = "}}"
-    val codeOffset = prefix.length
-    return Triple("$prefix$codeSection$suffix", codeOffset, suffix.length)
-}
diff --git a/platforms/core-configuration/declarative-dsl-core/src/testFixtures/kotlin/org/gradle/internal/declarativedsl/demo/resolve.kt b/platforms/core-configuration/declarative-dsl-core/src/testFixtures/kotlin/org/gradle/internal/declarativedsl/demo/resolve.kt
index b5a8df6f4f7..daed7e187af 100644
--- a/platforms/core-configuration/declarative-dsl-core/src/testFixtures/kotlin/org/gradle/internal/declarativedsl/demo/resolve.kt
+++ b/platforms/core-configuration/declarative-dsl-core/src/testFixtures/kotlin/org/gradle/internal/declarativedsl/demo/resolve.kt
@@ -47,7 +47,7 @@ fun AnalysisSchema.resolve(
                     "Parsing error: " + failure.message
                 )
                 is UnsupportedConstruct -> println(
-                    failure.languageFeature.toString() + " in " + parsedTree.wrappedCode.slice(parsedTree.originalCodeOffset..parsedTree.originalCodeOffset + failure.potentialElementSource.indexRange.count())
+                    failure.languageFeature.toString() + " in " + failure.potentialElementSource.text()
                 )
                 is MultipleFailuresResult -> failure.failures.forEach { printFailures(it) }
             }
diff --git a/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java b/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
index 5dd9e806ece..dd25aa63b24 100644
--- a/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
+++ b/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/eclipse/EclipsePlugin.java
@@ -147,7 +147,7 @@ public void execute(Task task) {
     private void configureEclipseProject(final ProjectInternal project, final EclipseModel model) {
         final EclipseProject projectModel = model.getProject();
 
-        projectModel.setName(uniqueProjectNameProvider.getUniqueName(project.getProjectIdentity()));
+        projectModel.setName(uniqueProjectNameProvider.getUniqueName(project));
 
         final ConventionMapping convention = ((IConventionAware) projectModel).getConventionMapping();
         convention.map("comment", new Callable<String>() {
diff --git a/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java b/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
index 0ebd3489637..8e17adb7cbf 100644
--- a/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
+++ b/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/idea/IdeaPlugin.java
@@ -283,7 +283,7 @@ public void execute(GenerateIdeaModule task) {
         task.configure(IdePluginHelper.withGracefulDegradation());
         ideaModel.setModule(module);
 
-        final String defaultModuleName = uniqueProjectNameProvider.getUniqueName(project.getProjectIdentity());
+        final String defaultModuleName = uniqueProjectNameProvider.getUniqueName(project);
         module.setName(defaultModuleName);
 
         ConventionMapping conventionMapping = ((IConventionAware) module).getConventionMapping();
diff --git a/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/internal/tooling/EclipseModelBuilder.java b/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/internal/tooling/EclipseModelBuilder.java
index 15a854453d1..83d22283ee0 100644
--- a/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/internal/tooling/EclipseModelBuilder.java
+++ b/platforms/ide/ide-plugins/src/main/java/org/gradle/plugins/ide/internal/tooling/EclipseModelBuilder.java
@@ -164,7 +164,7 @@ private void deduplicateProjectNames(ProjectInternal root) {
         for (Project project : root.getAllprojects()) {
             EclipseModel eclipseModel = project.getExtensions().findByType(EclipseModel.class);
             if (eclipseModel != null) {
-                eclipseModel.getProject().setName(uniqueProjectNameProvider.getUniqueName(((ProjectInternal) project).getProjectIdentity()));
+                eclipseModel.getProject().setName(uniqueProjectNameProvider.getUniqueName(project));
             }
         }
     }
diff --git a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/AbstractUniqueProjectNameProvider.java b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/AbstractUniqueProjectNameProvider.java
deleted file mode 100644
index 9a92e71f4f2..00000000000
--- a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/AbstractUniqueProjectNameProvider.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2025 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.gradle.plugins.ide.internal.configurer;
-
-import org.gradle.api.internal.project.ProjectIdentity;
-import org.gradle.api.internal.project.ProjectState;
-import org.gradle.api.internal.project.ProjectStateRegistry;
-import org.gradle.util.Path;
-import org.jspecify.annotations.Nullable;
-
-public abstract class AbstractUniqueProjectNameProvider implements UniqueProjectNameProvider {
-
-    protected final ProjectStateRegistry projectRegistry;
-
-    protected AbstractUniqueProjectNameProvider(ProjectStateRegistry projectRegistry) {
-        this.projectRegistry = projectRegistry;
-    }
-
-    /**
-     * Finds the "parent" project based on the build-tree path of the current project.
-     * <p>
-     * This is different from looking up the {@link ProjectState#getBuildParent() parent project} inside a given build,
-     * because a root project of a build does not have a parent. In the context of project hiearachy shown in the IDE, however,
-     * we are looking for the "parent" project based on the build-tree path.
-     * This means that the <b>"parent" project might belong to a different build.</b>
-     */
-    @Nullable
-    protected ProjectIdentity findParentInBuildTree(ProjectIdentity projectIdentity) {
-        Path parentInBuildTreePath = projectIdentity.getBuildTreePath().getParent();
-        if (parentInBuildTreePath == null) {
-            return null;
-        }
-        ProjectState parentInBuildTree = projectRegistry.findProjectState(parentInBuildTreePath);
-        if (parentInBuildTree == null) {
-            return null;
-        }
-        return parentInBuildTree.getIdentity();
-    }
-}
diff --git a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/DefaultUniqueProjectNameProvider.java b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/DefaultUniqueProjectNameProvider.java
index 0177e3c6690..84633911b0d 100644
--- a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/DefaultUniqueProjectNameProvider.java
+++ b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/DefaultUniqueProjectNameProvider.java
@@ -15,58 +15,53 @@
  */
 package org.gradle.plugins.ide.internal.configurer;
 
-import org.gradle.api.internal.project.ProjectIdentity;
+import org.gradle.api.Project;
 import org.gradle.api.internal.project.ProjectState;
 import org.gradle.api.internal.project.ProjectStateRegistry;
-import org.jspecify.annotations.Nullable;
 
-import java.util.List;
 import java.util.Map;
 
-import static java.util.stream.Collectors.toList;
-
-public class DefaultUniqueProjectNameProvider extends AbstractUniqueProjectNameProvider {
-
-    @Nullable
-    private Map<ProjectIdentity, String> deduplicated;
+public class DefaultUniqueProjectNameProvider implements UniqueProjectNameProvider {
+    private final ProjectStateRegistry projectRegistry;
+    private Map<ProjectState, String> deduplicated;
 
     public DefaultUniqueProjectNameProvider(ProjectStateRegistry projectRegistry) {
-        super(projectRegistry);
+        this.projectRegistry = projectRegistry;
     }
 
     @Override
-    public String getUniqueName(ProjectIdentity projectIdentity) {
-        String uniqueName = getDeduplicatedNames().get(projectIdentity);
-        return uniqueName != null ? uniqueName : projectIdentity.getProjectName();
+    public String getUniqueName(Project project) {
+        ProjectState projectState = projectRegistry.stateFor(project);
+        String uniqueName = getDeduplicatedNames().get(projectState);
+        if (uniqueName != null) {
+            return uniqueName;
+        }
+        return project.getName();
     }
 
-    private synchronized Map<ProjectIdentity, String> getDeduplicatedNames() {
+    private synchronized Map<ProjectState, String> getDeduplicatedNames() {
         if (deduplicated == null) {
-            HierarchicalElementDeduplicator<ProjectIdentity> deduplicator = new HierarchicalElementDeduplicator<>(new ProjectPathDeduplicationAdapter());
-            List<ProjectIdentity> allProjects = projectRegistry.getAllProjects().stream()
-                .map(ProjectState::getIdentity)
-                .collect(toList());
-            this.deduplicated = deduplicator.deduplicate(allProjects);
+            HierarchicalElementDeduplicator<ProjectState> deduplicator = new HierarchicalElementDeduplicator<ProjectState>(new ProjectPathDeduplicationAdapter());
+            this.deduplicated = deduplicator.deduplicate(projectRegistry.getAllProjects());
         }
         return deduplicated;
     }
 
-    private class ProjectPathDeduplicationAdapter implements HierarchicalElementAdapter<ProjectIdentity> {
+    private static class ProjectPathDeduplicationAdapter implements HierarchicalElementAdapter<ProjectState> {
         @Override
-        public String getName(ProjectIdentity element) {
-            return element.getProjectName();
+        public String getName(ProjectState element) {
+            return element.getName();
         }
 
         @Override
-        public String getIdentityName(ProjectIdentity element) {
-            String identityName = element.getBuildTreePath().getName();
-            return identityName != null ? identityName : element.getProjectName();
+        public String getIdentityName(ProjectState element) {
+            String identityName = element.getIdentityPath().getName();
+            return identityName != null ? identityName : element.getName();
         }
 
         @Override
-        @Nullable
-        public ProjectIdentity getParent(ProjectIdentity element) {
-            return findParentInBuildTree(element);
+        public ProjectState getParent(ProjectState element) {
+            return element.getParent();
         }
     }
 }
diff --git a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/EclipseModelAwareUniqueProjectNameProvider.java b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/EclipseModelAwareUniqueProjectNameProvider.java
index de9f076322e..b2f1e1e9172 100644
--- a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/EclipseModelAwareUniqueProjectNameProvider.java
+++ b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/EclipseModelAwareUniqueProjectNameProvider.java
@@ -15,11 +15,10 @@
  */
 package org.gradle.plugins.ide.internal.configurer;
 
-import org.gradle.api.internal.project.ProjectIdentity;
+import org.gradle.api.Project;
 import org.gradle.api.internal.project.ProjectState;
 import org.gradle.api.internal.project.ProjectStateRegistry;
 import org.gradle.plugins.ide.eclipse.model.EclipseModel;
-import org.jspecify.annotations.Nullable;
 
 import java.util.ArrayList;
 import java.util.Collections;
@@ -28,17 +27,14 @@
 import java.util.Map;
 import java.util.stream.Collectors;
 
-import static java.util.stream.Collectors.toMap;
-
-public class EclipseModelAwareUniqueProjectNameProvider extends AbstractUniqueProjectNameProvider {
-
-    @Nullable
-    private Map<ProjectIdentity, String> deduplicated;
+public class EclipseModelAwareUniqueProjectNameProvider implements UniqueProjectNameProvider {
+    private final ProjectStateRegistry projectRegistry;
+    private Map<ProjectState, String> deduplicated;
     private List<ProjectStateWrapper> reservedNames = Collections.emptyList();
-    private Map<ProjectIdentity, ProjectStateWrapper> projectToInformationMap = Collections.emptyMap();
+    private Map<ProjectState, ProjectStateWrapper> projectToInformationMap = Collections.emptyMap();
 
     public EclipseModelAwareUniqueProjectNameProvider(ProjectStateRegistry projectRegistry) {
-        super(projectRegistry);
+        this.projectRegistry = projectRegistry;
     }
 
     public synchronized void setReservedProjectNames(List<String> reservedNames) {
@@ -47,27 +43,35 @@ public synchronized void setReservedProjectNames(List<String> reservedNames) {
     }
 
     @Override
-    public String getUniqueName(ProjectIdentity projectIdentity) {
-        String uniqueName = getDeduplicatedNames().get(projectIdentity);
+    public String getUniqueName(Project project) {
+        ProjectState state = projectRegistry.stateFor(project);
+        String uniqueName = getDeduplicatedNames().get(state);
         if (uniqueName != null) {
             return uniqueName;
         }
 
         // ProjectStateWrapper might contain the configured eclipse project name
-        ProjectStateWrapper information = projectToInformationMap.get(projectIdentity);
+        ProjectStateWrapper information = projectToInformationMap.get(state);
         if (information != null) {
             return information.name;
         }
-        return projectIdentity.getProjectName();
+        return state.getName();
     }
 
-    private synchronized Map<ProjectIdentity, String> getDeduplicatedNames() {
+    private synchronized Map<ProjectState, String> getDeduplicatedNames() {
         if (deduplicated == null) {
 
             projectToInformationMap = new HashMap<>();
             for (ProjectState state : projectRegistry.getAllProjects()) {
-                String projectNameForEclipse = getName(state);
-                projectToInformationMap.put(state.getIdentity(), new ProjectStateWrapper(projectNameForEclipse, state));
+                // try to get the name from EclipseProject.name
+                state.getOwner().ensureProjectsConfigured();
+                EclipseModel model = state.getMutableModel().getExtensions().findByType(EclipseModel.class);
+                if (model != null && model.getProject().getName() != null) {
+                    projectToInformationMap.put(state, new ProjectStateWrapper(model.getProject().getName(), state, state.getParent()));
+                    continue;
+                }
+                // fallback: take the name from the ProjectState
+                projectToInformationMap.put(state, new ProjectStateWrapper(state.getName(), state, state.getParent()));
             }
 
             HierarchicalElementDeduplicator<ProjectStateWrapper> deduplicator = new HierarchicalElementDeduplicator<>(new ProjectPathDeduplicationAdapter(projectToInformationMap));
@@ -76,43 +80,31 @@ private synchronized Map<ProjectIdentity, String> getDeduplicatedNames() {
             allElements.addAll(projectToInformationMap.values());
 
             this.deduplicated = deduplicator.deduplicate(allElements).entrySet().stream()
-                .collect(toMap(e -> e.getKey().project.getIdentity(), Map.Entry::getValue));
+                .collect(Collectors.toMap(e -> e.getKey().project, Map.Entry::getValue));
         }
         return deduplicated;
     }
 
-    private static String getName(ProjectState state) {
-        // try to get the name from EclipseProject.name
-        state.getOwner().ensureProjectsConfigured();
-
-        EclipseModel model = state.getMutableModel().getExtensions().findByType(EclipseModel.class);
-        if (model != null && model.getProject().getName() != null) {
-            return model.getProject().getName();
-        }
-
-        // fallback: take the name from the ProjectState
-        return state.getName();
-    }
-
     private static class ProjectStateWrapper {
         private final String name;
-        @Nullable
         private final ProjectState project;
+        private final ProjectState parent;
 
-        public ProjectStateWrapper(String name, @Nullable ProjectState project) {
+        public ProjectStateWrapper(String name, ProjectState project, ProjectState parent) {
             this.name = name;
             this.project = project;
+            this.parent = parent;
         }
 
         public ProjectStateWrapper(String name) {
-            this(name, null);
+            this(name, null, null);
         }
     }
 
-    private class ProjectPathDeduplicationAdapter implements HierarchicalElementAdapter<ProjectStateWrapper> {
-        private final Map<ProjectIdentity, ProjectStateWrapper> projectToInformationMap;
+    private static class ProjectPathDeduplicationAdapter implements HierarchicalElementAdapter<ProjectStateWrapper> {
+        private final Map<ProjectState, ProjectStateWrapper> projectToInformationMap;
 
-        public ProjectPathDeduplicationAdapter(Map<ProjectIdentity, ProjectStateWrapper> projectToInformationMap) {
+        public ProjectPathDeduplicationAdapter(Map<ProjectState, ProjectStateWrapper> projectToInformationMap) {
             this.projectToInformationMap = projectToInformationMap;
         }
 
@@ -127,14 +119,8 @@ public String getIdentityName(ProjectStateWrapper element) {
         }
 
         @Override
-        @Nullable
         public ProjectStateWrapper getParent(ProjectStateWrapper element) {
-            if (element.project == null) {
-                return null;
-            }
-
-            ProjectIdentity parentInBuildTree = findParentInBuildTree(element.project.getIdentity());
-            return parentInBuildTree == null ? null : projectToInformationMap.get(parentInBuildTree);
+            return projectToInformationMap.get(element.parent);
         }
     }
 
diff --git a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/HierarchicalElementAdapter.java b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/HierarchicalElementAdapter.java
index a664c0441e4..3218022b030 100644
--- a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/HierarchicalElementAdapter.java
+++ b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/HierarchicalElementAdapter.java
@@ -16,8 +16,6 @@
 
 package org.gradle.plugins.ide.internal.configurer;
 
-import org.jspecify.annotations.Nullable;
-
 /**
  * Adapts any type of element to the generic {@link HierarchicalElementDeduplicator}.
  *
@@ -49,6 +47,5 @@
      * @param element the child element, cannot be null
      * @return the parent element, may be null
      */
-    @Nullable
     T getParent(T element);
 }
diff --git a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/UniqueProjectNameProvider.java b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/UniqueProjectNameProvider.java
index 46bdc197709..dbe492b99e2 100644
--- a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/UniqueProjectNameProvider.java
+++ b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/UniqueProjectNameProvider.java
@@ -15,11 +15,11 @@
  */
 package org.gradle.plugins.ide.internal.configurer;
 
-import org.gradle.api.internal.project.ProjectIdentity;
+import org.gradle.api.Project;
 import org.gradle.internal.service.scopes.Scope;
 import org.gradle.internal.service.scopes.ServiceScope;
 
 @ServiceScope(Scope.Build.class)
 public interface UniqueProjectNameProvider {
-    String getUniqueName(ProjectIdentity projectIdentity);
+    String getUniqueName(Project project);
 }
diff --git a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/package-info.java b/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/package-info.java
deleted file mode 100644
index 255b7846b40..00000000000
--- a/platforms/ide/ide/src/main/java/org/gradle/plugins/ide/internal/configurer/package-info.java
+++ /dev/null
@@ -1,18 +0,0 @@
-/*
- * Copyright 2025 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-@org.jspecify.annotations.NullMarked
-package org.gradle.plugins.ide.internal.configurer;
diff --git a/testing/architecture-test/src/changes/archunit-store/internal-api-nullability.txt b/testing/architecture-test/src/changes/archunit-store/internal-api-nullability.txt
index f929af46ac5..285dc8bdff5 100644
--- a/testing/architecture-test/src/changes/archunit-store/internal-api-nullability.txt
+++ b/testing/architecture-test/src/changes/archunit-store/internal-api-nullability.txt
@@ -3415,6 +3415,15 @@ Class <org.gradle.plugins.ide.internal.IdeArtifactStore> is not annotated (direc
 Class <org.gradle.plugins.ide.internal.IdePlugin> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (IdePlugin.java:0)
 Class <org.gradle.plugins.ide.internal.IdeProjectMetadata> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (IdeProjectMetadata.java:0)
 Class <org.gradle.plugins.ide.internal.IdeServices> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (IdeServices.java:0)
+Class <org.gradle.plugins.ide.internal.configurer.DefaultUniqueProjectNameProvider$ProjectPathDeduplicationAdapter> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (DefaultUniqueProjectNameProvider.java:0)
+Class <org.gradle.plugins.ide.internal.configurer.DefaultUniqueProjectNameProvider> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (DefaultUniqueProjectNameProvider.java:0)
+Class <org.gradle.plugins.ide.internal.configurer.EclipseModelAwareUniqueProjectNameProvider$ProjectPathDeduplicationAdapter> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (EclipseModelAwareUniqueProjectNameProvider.java:0)
+Class <org.gradle.plugins.ide.internal.configurer.EclipseModelAwareUniqueProjectNameProvider$ProjectStateWrapper> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (EclipseModelAwareUniqueProjectNameProvider.java:0)
+Class <org.gradle.plugins.ide.internal.configurer.EclipseModelAwareUniqueProjectNameProvider> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (EclipseModelAwareUniqueProjectNameProvider.java:0)
+Class <org.gradle.plugins.ide.internal.configurer.HierarchicalElementAdapter> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (HierarchicalElementAdapter.java:0)
+Class <org.gradle.plugins.ide.internal.configurer.HierarchicalElementDeduplicator$StatefulDeduplicator> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (HierarchicalElementDeduplicator.java:0)
+Class <org.gradle.plugins.ide.internal.configurer.HierarchicalElementDeduplicator> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (HierarchicalElementDeduplicator.java:0)
+Class <org.gradle.plugins.ide.internal.configurer.UniqueProjectNameProvider> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (UniqueProjectNameProvider.java:0)
 Class <org.gradle.plugins.ide.internal.generator.AbstractPersistableConfigurationObject> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (AbstractPersistableConfigurationObject.java:0)
 Class <org.gradle.plugins.ide.internal.generator.PropertiesPersistableConfigurationObject> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (PropertiesPersistableConfigurationObject.java:0)
 Class <org.gradle.plugins.ide.internal.generator.PropertyListPersistableConfigurationObject> is not annotated (directly or via its package) with @org.jspecify.annotations.NullMarked in (PropertyListPersistableConfigurationObject.java:0)
