diff --git a/core/src/main/scala/cats/arrow/Profunctor.scala b/core/src/main/scala/cats/arrow/Profunctor.scala
index 491421ae6..8ef9e0a56 100644
--- a/core/src/main/scala/cats/arrow/Profunctor.scala
+++ b/core/src/main/scala/cats/arrow/Profunctor.scala
@@ -41,36 +41,6 @@ import scala.annotation.implicitNotFound
    */
   def rmap[A, B, C](fab: F[A, B])(f: B => C): F[A, C] =
     dimap[A, B, A, C](fab)(identity)(f)
-
-  /**
-   * Narrows A into a subtype AA.
-   * Example:
-   * {{{
-   * scala> import cats.syntax.profunctor._
-   * scala> import cats.instances.function._
-   * scala>
-   * scala> sealed trait Foo
-   * scala> case object Bar extends Foo
-   * scala> val x1: Foo => Int = _ => 1
-   * scala> val x2: Bar.type => Int = x1.leftNarrow
-   * }}}
-   */
-  def leftNarrow[A, B, AA <: A](fab: F[A, B]): F[AA, B] = fab.asInstanceOf[F[AA, B]]
-
-  /**
-   * Widens B into a supertype BB.
-   * Example:
-   * {{{
-   * scala> import cats.syntax.profunctor._
-   * scala> import cats.instances.function._
-   * scala>
-   * scala> sealed trait Foo
-   * scala> case object Bar extends Foo
-   * scala> val x1: Int => Bar.type = _ => Bar
-   * scala> val x2: Int => Foo = x1.rightWiden
-   * }}}
-   */
-  def rightWiden[A, B, BB >: B](fab: F[A, B]): F[A, BB] = fab.asInstanceOf[F[A, BB]]
 }
 
 object Profunctor {
@@ -107,8 +77,6 @@ object Profunctor {
     def dimap[C, D](f: C => A)(g: B => D): F[C, D] = typeClassInstance.dimap[A, B, C, D](self)(f)(g)
     def lmap[C](f: C => A): F[C, B] = typeClassInstance.lmap[A, B, C](self)(f)
     def rmap[C](f: B => C): F[A, C] = typeClassInstance.rmap[A, B, C](self)(f)
-    def leftNarrow[C <: A]: F[C, B] = typeClassInstance.leftNarrow[A, B, C](self)
-    def rightWiden[C >: B]: F[A, C] = typeClassInstance.rightWiden[A, B, C](self)
   }
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B]
   trait ToProfunctorOps extends Serializable {
diff --git a/core/src/main/scala/cats/conversions/VarianceConversions.scala b/core/src/main/scala/cats/conversions/VarianceConversions.scala
index c463a3d07..7e8b7f769 100644
--- a/core/src/main/scala/cats/conversions/VarianceConversions.scala
+++ b/core/src/main/scala/cats/conversions/VarianceConversions.scala
@@ -1,14 +1,10 @@
 package cats
 package conversions
-import cats.arrow.Profunctor
 
 trait VarianceConversions extends VarianceConversionsLowPriority {
   implicit def autoWidenBifunctor[F[_, _]: Bifunctor, A, B >: A, C, D >: C](fac: F[A, C]): F[B, D] =
     Bifunctor[F].leftWiden(Bifunctor[F].rightFunctor.widen(fac))
 
-  implicit def autoConvertProfunctorVariance[F[_, _]: Profunctor, A, B <: A, C, D >: C](fac: F[A, C]): F[B, D] =
-    Profunctor[F].leftNarrow(Profunctor[F].rightWiden(fac))
-
   implicit def autoNarrowContravariant[F[_]: Contravariant, A, B <: A](fa: F[A]): F[B] = Contravariant[F].narrow(fa)
 
 }
diff --git a/tests/src/test/scala/cats/tests/VarianceSuite.scala b/tests/src/test/scala/cats/tests/VarianceSuite.scala
index 690dc1d6e..33d029b8f 100644
--- a/tests/src/test/scala/cats/tests/VarianceSuite.scala
+++ b/tests/src/test/scala/cats/tests/VarianceSuite.scala
@@ -1,14 +1,12 @@
 package cats.tests
 
-import cats.arrow.Profunctor
-import cats.conversions.all._
-import cats.implicits._
 import cats.{Bifunctor, Contravariant, Functor}
+import cats.implicits._
+import cats.conversions.all._
 
 class VarianceSuite extends CatsSuite {
 
-  sealed trait FooBar
-  sealed trait Foo extends FooBar
+  sealed trait Foo
   case class Bar(x: Int) extends Foo
   case object Baz extends Foo
 
@@ -45,25 +43,4 @@ class VarianceSuite extends CatsSuite {
     def inferred[F[_, _]: Bifunctor](fi: F[Int, Int]): F[Either[Foo, Foo], Int] = shouldInfer[F](fi)
   }
 
-  test("Auto-variance auto adjust a profunctor's variance") {
-    def shouldInfer[F[_, _]: Profunctor](fi: F[Int, Int]) =
-      fi.dimap((_: Either[FooBar, FooBar]) => 1)(i => if (true) Left(Bar(i)) else Right(Baz))
-
-    def inferred[F[_, _]: Profunctor](fi: F[Int, Int]): F[Either[Foo, Foo], Either[Foo, Foo]] = shouldInfer[F](fi)
-  }
-
-  test("Auto-variance should widen the second type parameter of a profunctor automatically") {
-    def shouldInfer[F[_, _]: Profunctor](fi: F[Int, Int]) =
-      fi.dimap(identity[Int])(i => if (true) Left(Bar(i)) else Right(Baz))
-
-    def inferred[F[_, _]: Profunctor](fi: F[Int, Int]): F[Int, Either[Foo, Foo]] = shouldInfer[F](fi)
-  }
-
-  test("Auto-variance should narrow the first type parameter of a profunctor automatically") {
-    def shouldInfer[F[_, _]: Profunctor](fi: F[Int, Int]) =
-      fi.dimap((_: Either[FooBar, FooBar]) => 1)(identity[Int])
-
-    def inferred[F[_, _]: Profunctor](fi: F[Int, Int]): F[Either[Foo, Foo], Int] = shouldInfer[F](fi)
-  }
-
 }
