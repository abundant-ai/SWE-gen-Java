diff --git a/http-server/src/main/java/io/micronaut/http/server/binding/RouteMatchArgumentBinder.java b/http-server/src/main/java/io/micronaut/http/server/binding/RouteMatchArgumentBinder.java
new file mode 100644
index 0000000000..f05306fb47
--- /dev/null
+++ b/http-server/src/main/java/io/micronaut/http/server/binding/RouteMatchArgumentBinder.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.binding;
+
+import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.convert.ArgumentConversionContext;
+import io.micronaut.core.propagation.MutablePropagatedContext;
+import io.micronaut.core.type.Argument;
+import io.micronaut.http.HttpAttributes;
+import io.micronaut.http.HttpRequest;
+import io.micronaut.http.HttpResponse;
+import io.micronaut.http.bind.binders.TypedRequestArgumentBinder;
+import io.micronaut.http.filter.FilterArgumentBinderPredicate;
+import io.micronaut.web.router.RouteMatch;
+import jakarta.inject.Singleton;
+
+import java.util.Optional;
+
+/**
+ * Argument binder for {@link RouteMatch} objects.
+ *
+ * @since 4.6.0
+ * @author Jonas Konrad
+ */
+@Singleton
+public final class RouteMatchArgumentBinder implements TypedRequestArgumentBinder<RouteMatch<?>>, FilterArgumentBinderPredicate {
+    RouteMatchArgumentBinder() {
+    }
+
+    @Override
+    public Argument<RouteMatch<?>> argumentType() {
+        return (Argument) Argument.of(RouteMatch.class);
+    }
+
+    @Override
+    public BindingResult<RouteMatch<?>> bind(ArgumentConversionContext<RouteMatch<?>> context, HttpRequest<?> source) {
+        Optional<RouteMatch<?>> match = source.getAttribute(HttpAttributes.ROUTE_MATCH).map(r -> (RouteMatch<?>) r);
+        return () -> match;
+    }
+
+    @Override
+    public boolean test(Argument<?> argument, MutablePropagatedContext mutablePropagatedContext, HttpRequest<?> request, @Nullable HttpResponse<?> response, @Nullable Throwable failure) {
+        return argument.isNullable() || request.getAttribute(HttpAttributes.ROUTE_MATCH).isPresent();
+    }
+}
diff --git a/http-validation/src/main/java/io/micronaut/validation/routes/FilterVisitor.java b/http-validation/src/main/java/io/micronaut/validation/routes/FilterVisitor.java
index 65ef1744c9..00202af4f9 100644
--- a/http-validation/src/main/java/io/micronaut/validation/routes/FilterVisitor.java
+++ b/http-validation/src/main/java/io/micronaut/validation/routes/FilterVisitor.java
@@ -38,6 +38,7 @@ import io.micronaut.inject.ast.MethodElement;
 import io.micronaut.inject.ast.ParameterElement;
 import io.micronaut.inject.visitor.TypeElementVisitor;
 import io.micronaut.inject.visitor.VisitorContext;
+import io.micronaut.web.router.RouteMatch;
 import org.reactivestreams.Publisher;
 
 import java.util.Optional;
@@ -57,7 +58,8 @@ public final class FilterVisitor implements TypeElementVisitor<Object, Object> {
         FilterContinuation.class,
         Optional.class,
         Throwable.class,
-        MutablePropagatedContext.class
+        MutablePropagatedContext.class,
+        RouteMatch.class
     );
     private static final Set<String> PERMITTED_BINDING_ANNOTATIONS = Set.of(
         Body.class.getName(),
diff --git a/http/src/main/java/io/micronaut/http/annotation/RequestFilter.java b/http/src/main/java/io/micronaut/http/annotation/RequestFilter.java
index cbbb40b53b..3284bd1775 100644
--- a/http/src/main/java/io/micronaut/http/annotation/RequestFilter.java
+++ b/http/src/main/java/io/micronaut/http/annotation/RequestFilter.java
@@ -55,6 +55,10 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *     <li>A {@code @}{@link Body} parameter of type {@code byte[]}, {@link String} or
  *     {@link ByteBuffer}. Only supported for some HTTP server implementations.</li>
  *     <li>A {@link io.micronaut.core.propagation.MutablePropagatedContext} to modify the propagated context</li>
+ *     <li>A RouteMatch of the route that will handle this request. Note: Unless the parameter is
+ *     marked as {@link io.micronaut.core.annotation.Nullable}, the filter method will <b>not</b>
+ *     match for requests that do not match a route (e.g. static resources). This parameter is only
+ *     supported on the server.</li>
  * </ul>
  *
  * The return value may be:
diff --git a/http/src/main/java/io/micronaut/http/annotation/ResponseFilter.java b/http/src/main/java/io/micronaut/http/annotation/ResponseFilter.java
index a7b656ebbd..e5b88c5f39 100644
--- a/http/src/main/java/io/micronaut/http/annotation/ResponseFilter.java
+++ b/http/src/main/java/io/micronaut/http/annotation/ResponseFilter.java
@@ -52,6 +52,10 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *     <li>A {@code @}{@link Header}, {@code @}{@link QueryValue} or {@code @}{@link CookieValue}
  *     parameter</li>
  *     <li>A {@link io.micronaut.core.propagation.MutablePropagatedContext} to modify the propagated context</li>
+ *     <li>A RouteMatch of the route that handled this request. Note: Unless the parameter is
+ *     marked as {@link io.micronaut.core.annotation.Nullable}, the filter method will <b>not</b>
+ *     match for requests that do not match a route (e.g. static resources). This parameter is only
+ *     supported on the server.</li>
  * </ul>
  *
  * The return value may be:
diff --git a/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java b/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java
index 3810f23708..ab580366d3 100644
--- a/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java
+++ b/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java
@@ -23,7 +23,6 @@ import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.annotation.Order;
 import io.micronaut.core.bind.ArgumentBinder;
-import io.micronaut.core.bind.annotation.Bindable;
 import io.micronaut.core.convert.ArgumentConversionContext;
 import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.core.io.buffer.ByteBuffer;
@@ -86,33 +85,29 @@ public abstract class BaseFilterProcessor<A extends Annotation> implements Execu
         this.argumentBinderRegistry = new RequestBinderRegistry() {
             @Override
             public <T> Optional<ArgumentBinder<T, HttpRequest<?>>> findArgumentBinder(Argument<T> argument) {
-                Class<? extends Annotation> annotation = argument.getAnnotationMetadata().getAnnotationTypeByStereotype(Bindable.class).orElse(null);
-                if (annotation != null && PERMITTED_BINDING_ANNOTATIONS.contains(annotation.getName())) {
-                    if (annotation == Body.class) {
-                        return Optional.of((AsyncBodyBinder<T>) (context, source) -> {
-                            if (source instanceof ServerHttpRequest<?> fullHttpRequest) {
-                                return InternalByteBody.bufferFlow(fullHttpRequest.byteBody().split(ByteBody.SplitBackpressureMode.FASTEST)).map(imm -> {
-                                    Argument<T> t = context.getArgument();
-                                    if (t.isAssignableFrom(ByteBuffer.class)) {
-                                        return () -> Optional.of((T) imm.toByteBuffer());
-                                    } else if (t.isAssignableFrom(byte[].class)) {
-                                        byte[] bytes = imm.toByteArray();
-                                        return () -> Optional.of((T) bytes);
-                                    } else if (t.isAssignableFrom(String.class)) {
-                                        String str = imm.toString(StandardCharsets.UTF_8);
-                                        return () -> Optional.of((T) str);
-                                    } else {
-                                        return ArgumentBinder.BindingResult.UNSATISFIED;
-                                    }
-                                });
-                            }
-                            return ExecutionFlow.just(ArgumentBinder.BindingResult.UNSATISFIED);
-                        });
-                    } else {
-                        return requestBinderRegistry.flatMap(registry -> registry.findArgumentBinder(argument));
-                    }
+                if (argument.getAnnotationMetadata().hasAnnotation(Body.class)) {
+                    return Optional.of((AsyncBodyBinder<T>) (context, source) -> {
+                        if (source instanceof ServerHttpRequest<?> fullHttpRequest) {
+                            return InternalByteBody.bufferFlow(fullHttpRequest.byteBody().split(ByteBody.SplitBackpressureMode.FASTEST)).map(imm -> {
+                                Argument<T> t = context.getArgument();
+                                if (t.isAssignableFrom(ByteBuffer.class)) {
+                                    return () -> Optional.of((T) imm.toByteBuffer());
+                                } else if (t.isAssignableFrom(byte[].class)) {
+                                    byte[] bytes = imm.toByteArray();
+                                    return () -> Optional.of((T) bytes);
+                                } else if (t.isAssignableFrom(String.class)) {
+                                    String str = imm.toString(StandardCharsets.UTF_8);
+                                    return () -> Optional.of((T) str);
+                                } else {
+                                    return ArgumentBinder.BindingResult.unsatisfied();
+                                }
+                            });
+                        }
+                        return ExecutionFlow.just(ArgumentBinder.BindingResult.unsatisfied());
+                    });
+                } else {
+                    return requestBinderRegistry.flatMap(registry -> registry.findArgumentBinder(argument));
                 }
-                return Optional.empty();
             }
         };
     }
diff --git a/http/src/main/java/io/micronaut/http/filter/FilterArgumentBinderPredicate.java b/http/src/main/java/io/micronaut/http/filter/FilterArgumentBinderPredicate.java
new file mode 100644
index 0000000000..6a9c9b1a78
--- /dev/null
+++ b/http/src/main/java/io/micronaut/http/filter/FilterArgumentBinderPredicate.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.filter;
+
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.propagation.MutablePropagatedContext;
+import io.micronaut.core.type.Argument;
+import io.micronaut.http.HttpRequest;
+import io.micronaut.http.HttpResponse;
+
+/**
+ * Additional interface that {@link io.micronaut.core.bind.ArgumentBinder}s can implement to
+ * restrict when a filter method with this argument will run.
+ *
+ * @author Jonas Konrad
+ * @since 4.6.0
+ */
+@Experimental
+public interface FilterArgumentBinderPredicate {
+    /**
+     * Check whether the filter method should run in the given context.
+     *
+     * @param argument                 The argument that this binder binds
+     * @param mutablePropagatedContext The propagated context
+     * @param request                  The request
+     * @param response                 For response filters, the response (if there is no failure)
+     * @param failure                  For response filters, the failure
+     * @return {@code true} if this filter method should run
+     */
+    boolean test(Argument<?> argument,
+                 MutablePropagatedContext mutablePropagatedContext,
+                 HttpRequest<?> request,
+                 @Nullable HttpResponse<?> response,
+                 @Nullable Throwable failure);
+}
diff --git a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
index b868274c66..105d79af0a 100644
--- a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
+++ b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
@@ -22,7 +22,6 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.async.propagation.ReactivePropagation;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.core.bind.ArgumentBinder;
-import io.micronaut.core.bind.annotation.Bindable;
 import io.micronaut.core.convert.ArgumentConversionContext;
 import io.micronaut.core.convert.ConversionContext;
 import io.micronaut.core.convert.ConversionError;
@@ -123,33 +122,7 @@ record MethodFilter<T>(FilterOrder order,
             Argument<?> argument = arguments[i];
             Class<?> argumentType = argument.getType();
             AnnotationMetadata annotationMetadata = argument.getAnnotationMetadata();
-            if (annotationMetadata.hasStereotype(Bindable.class)) {
-                ArgumentBinder<Object, HttpRequest<?>> argumentBinder = (ArgumentBinder<Object, HttpRequest<?>>) argumentBinderRegistry.findArgumentBinder(argument).orElse(null);
-                if (argumentBinder != null) {
-                    if (argumentBinder instanceof BaseFilterProcessor.AsyncBodyBinder<Object> async) {
-                        if (isResponseFilter) {
-                            throw new IllegalArgumentException("Cannot bind @Body in response filter method [" + method.getDescription(true) + "]");
-                        }
-                        if (asyncArgBinders == null) {
-                            asyncArgBinders = new AsyncFilterArgBinder[arguments.length];
-                        }
-                        asyncArgBinders[i] = ctx -> {
-                            HttpRequest<?> request = ctx.request;
-                            ArgumentConversionContext<Object> conversionContext = (ArgumentConversionContext<Object>) ConversionContext.of(argument);
-                            return async.bindAsync(conversionContext, request).map(result -> convertResult(method, argument, result));
-                        };
-                    } else {
-                        fulfilled[i] = ctx -> {
-                            HttpRequest<?> request = ctx.request;
-                            ArgumentConversionContext<Object> conversionContext = (ArgumentConversionContext<Object>) ConversionContext.of(argument);
-                            ArgumentBinder.BindingResult<Object> result = argumentBinder.bind(conversionContext, request);
-                            return convertResult(method, argument, result);
-                        };
-                    }
-                } else {
-                    throw new IllegalArgumentException("Unsupported binding annotation in filter method [" + method.getDescription(true) + "]: " + annotationMetadata.getAnnotationNameByStereotype(Bindable.class).orElse(null));
-                }
-            } else if (argumentType.isAssignableFrom(HttpRequest.class)) {
+            if (argumentType.isAssignableFrom(HttpRequest.class)) {
                 fulfilled[i] = ctx -> ctx.request;
             } else if (argumentType.isAssignableFrom(ServerHttpRequest.class)) {
                 // todo: only permit for server
@@ -208,7 +181,34 @@ record MethodFilter<T>(FilterOrder order,
             } else if (argumentType == MutablePropagatedContext.class) {
                 fulfilled[i] = ctx -> ctx.mutablePropagatedContext;
             } else {
-                throw new IllegalArgumentException("Unsupported filter argument type: " + argument);
+                ArgumentBinder<Object, HttpRequest<?>> argumentBinder = (ArgumentBinder<Object, HttpRequest<?>>) argumentBinderRegistry.findArgumentBinder(argument).orElse(null);
+                if (argumentBinder != null) {
+                    if (argumentBinder instanceof BaseFilterProcessor.AsyncBodyBinder<Object> async) {
+                        if (isResponseFilter) {
+                            throw new IllegalArgumentException("Cannot bind @Body in response filter method [" + method.getDescription(true) + "]");
+                        }
+                        if (asyncArgBinders == null) {
+                            asyncArgBinders = new AsyncFilterArgBinder[arguments.length];
+                        }
+                        asyncArgBinders[i] = ctx -> {
+                            HttpRequest<?> request = ctx.request;
+                            ArgumentConversionContext<Object> conversionContext = (ArgumentConversionContext<Object>) ConversionContext.of(argument);
+                            return async.bindAsync(conversionContext, request).map(result -> convertResult(method, argument, result));
+                        };
+                    } else {
+                        fulfilled[i] = ctx -> {
+                            HttpRequest<?> request = ctx.request;
+                            ArgumentConversionContext<Object> conversionContext = (ArgumentConversionContext<Object>) ConversionContext.of(argument);
+                            ArgumentBinder.BindingResult<Object> result = argumentBinder.bind(conversionContext, request);
+                            return convertResult(method, argument, result);
+                        };
+                        if (argumentBinder instanceof FilterArgumentBinderPredicate pred) {
+                            filterCondition = filterCondition.and(ctx -> pred.test(argument, ctx.mutablePropagatedContext, ctx.request, ctx.response, ctx.failure));
+                        }
+                    }
+                } else {
+                    throw new IllegalArgumentException("Unsupported filter argument type: " + argument);
+                }
             }
         }
         if (skipOnError) {
@@ -234,8 +234,8 @@ record MethodFilter<T>(FilterOrder order,
     }
 
     private static <T> Object convertResult(@Nullable ExecutableMethod<T, ?> method, Argument<?> argument, ArgumentBinder.BindingResult<Object> result) {
-        if (result.isPresentAndSatisfied()) {
-            return result.get();
+        if (result.isPresentAndSatisfied() || (argument.isNullable() && result.isSatisfied())) {
+            return result.getValue().orElse(null);
         } else {
             List<ConversionError> conversionErrors = result.getConversionErrors();
             if (!conversionErrors.isEmpty()) {
