diff --git a/http-client-tck/src/main/java/io/micronaut/http/client/tck/tests/ContentLengthHeaderTest.java b/http-client-tck/src/main/java/io/micronaut/http/client/tck/tests/ContentLengthHeaderTest.java
index 320295869c..677312f7fc 100644
--- a/http-client-tck/src/main/java/io/micronaut/http/client/tck/tests/ContentLengthHeaderTest.java
+++ b/http-client-tck/src/main/java/io/micronaut/http/client/tck/tests/ContentLengthHeaderTest.java
@@ -20,6 +20,7 @@ import com.sun.net.httpserver.HttpExchange;
 import com.sun.net.httpserver.HttpHandler;
 import com.sun.net.httpserver.HttpServer;
 import io.micronaut.context.ApplicationContext;
+import io.micronaut.core.io.socket.SocketUtils;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MutableHttpRequest;
 import io.micronaut.http.client.HttpClient;
@@ -47,7 +48,7 @@ class ContentLengthHeaderTest {
 
     @BeforeEach
     void setUp() throws IOException {
-        server = HttpServer.create(new InetSocketAddress(0), 0);
+        server = HttpServer.create(new InetSocketAddress(SocketUtils.findAvailableTcpPort()), 0);
         server.setExecutor(java.util.concurrent.Executors.newCachedThreadPool());
         server.createContext(PATH, new MyHandler());
         server.start();
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/filter/RequestFilterTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/filter/RequestFilterTest.java
index a29fe12dd4..77798e402e 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/filter/RequestFilterTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/filter/RequestFilterTest.java
@@ -36,7 +36,6 @@ import io.micronaut.http.tck.HttpResponseAssertion;
 import io.micronaut.http.tck.TestScenario;
 import io.micronaut.scheduling.TaskExecutors;
 import io.micronaut.scheduling.annotation.ExecuteOn;
-import io.micronaut.web.router.RouteMatch;
 import jakarta.inject.Singleton;
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
@@ -377,46 +376,6 @@ public class RequestFilterTest {
             .run();
     }
 
-    @Test
-    public void requestFilterRouteMatch() throws IOException {
-        TestScenario.builder()
-            .specName(SPEC_NAME)
-            .request(HttpRequest.GET("/request-filter/route-match"))
-            .assertion((server, request) -> {
-                AssertionUtils.assertDoesNotThrow(server, request, HttpResponseAssertion.builder()
-                    .status(HttpStatus.OK)
-                    .body("java.lang.String")
-                    .build());
-            })
-            .run();
-    }
-
-    @Test
-    public void requestFilterRouteMatchNullable() throws IOException {
-        TestScenario.builder()
-            .specName(SPEC_NAME)
-            .request(HttpRequest.GET("/request-filter/route-match-nullable"))
-            .assertion((server, request) -> {
-                AssertionUtils.assertDoesNotThrow(server, request, HttpResponseAssertion.builder()
-                    .status(HttpStatus.OK)
-                    .body("route-match-nullable")
-                    .build());
-            })
-            .run();
-    }
-
-    @Test
-    public void requestFilterRouteMatchNonNull() throws IOException {
-        TestScenario.builder()
-            .specName(SPEC_NAME)
-            .request(HttpRequest.GET("/request-filter/route-match-nonnull"))
-            .assertion((server, request) -> {
-                AssertionUtils.assertThrows(server, request, HttpResponseAssertion.builder()
-                    .status(HttpStatus.NOT_FOUND)
-                    .build());
-            })
-            .run();
-    }
 
     @ServerFilter
     @Singleton
@@ -543,21 +502,6 @@ public class RequestFilterTest {
         public CompletionStage<MutableHttpResponse<String>> requestFilterCompletionResponse() {
             return CompletableFuture.completedStage(HttpResponse.ok("requestFilterCompletionResponse"));
         }
-
-        @RequestFilter("/request-filter/route-match")
-        public void requestFilterRouteMatch(MutableHttpRequest<?> request, RouteMatch<?> routeMatch) {
-            request.setAttribute("route-match-response", routeMatch.getRouteInfo().getReturnType().getType().getName());
-        }
-
-        @RequestFilter("/request-filter/route-match-nullable")
-        public HttpResponse<?> requestFilterRouteMatchNullable(MutableHttpRequest<?> request, @Nullable RouteMatch<?> routeMatch) {
-            return HttpResponse.ok("route-match-nullable");
-        }
-
-        @RequestFilter("/request-filter/route-match-nonnull")
-        public HttpResponse<?> requestFilterRouteMatchNonNull(MutableHttpRequest<?> request, RouteMatch<?> routeMatch) {
-            return HttpResponse.ok("route-match-nonnull");
-        }
     }
 
     @Controller
@@ -642,10 +586,5 @@ public class RequestFilterTest {
         public String requestFilterBinding(@Header String contentType, @Body byte[] bytes) {
             return contentType + " " + new String(bytes, StandardCharsets.UTF_8);
         }
-
-        @Get("/request-filter/route-match")
-        public String requestFilterRouteMatch(HttpRequest<?> request) {
-            return request.getAttribute("route-match-response", String.class).orElse("none");
-        }
     }
 }
diff --git a/http-server/src/main/java/io/micronaut/http/server/binding/RouteMatchArgumentBinder.java b/http-server/src/main/java/io/micronaut/http/server/binding/RouteMatchArgumentBinder.java
deleted file mode 100644
index f05306fb47..0000000000
--- a/http-server/src/main/java/io/micronaut/http/server/binding/RouteMatchArgumentBinder.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.server.binding;
-
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.convert.ArgumentConversionContext;
-import io.micronaut.core.propagation.MutablePropagatedContext;
-import io.micronaut.core.type.Argument;
-import io.micronaut.http.HttpAttributes;
-import io.micronaut.http.HttpRequest;
-import io.micronaut.http.HttpResponse;
-import io.micronaut.http.bind.binders.TypedRequestArgumentBinder;
-import io.micronaut.http.filter.FilterArgumentBinderPredicate;
-import io.micronaut.web.router.RouteMatch;
-import jakarta.inject.Singleton;
-
-import java.util.Optional;
-
-/**
- * Argument binder for {@link RouteMatch} objects.
- *
- * @since 4.6.0
- * @author Jonas Konrad
- */
-@Singleton
-public final class RouteMatchArgumentBinder implements TypedRequestArgumentBinder<RouteMatch<?>>, FilterArgumentBinderPredicate {
-    RouteMatchArgumentBinder() {
-    }
-
-    @Override
-    public Argument<RouteMatch<?>> argumentType() {
-        return (Argument) Argument.of(RouteMatch.class);
-    }
-
-    @Override
-    public BindingResult<RouteMatch<?>> bind(ArgumentConversionContext<RouteMatch<?>> context, HttpRequest<?> source) {
-        Optional<RouteMatch<?>> match = source.getAttribute(HttpAttributes.ROUTE_MATCH).map(r -> (RouteMatch<?>) r);
-        return () -> match;
-    }
-
-    @Override
-    public boolean test(Argument<?> argument, MutablePropagatedContext mutablePropagatedContext, HttpRequest<?> request, @Nullable HttpResponse<?> response, @Nullable Throwable failure) {
-        return argument.isNullable() || request.getAttribute(HttpAttributes.ROUTE_MATCH).isPresent();
-    }
-}
diff --git a/http-validation/src/main/java/io/micronaut/validation/routes/FilterVisitor.java b/http-validation/src/main/java/io/micronaut/validation/routes/FilterVisitor.java
index 00202af4f9..65ef1744c9 100644
--- a/http-validation/src/main/java/io/micronaut/validation/routes/FilterVisitor.java
+++ b/http-validation/src/main/java/io/micronaut/validation/routes/FilterVisitor.java
@@ -38,7 +38,6 @@ import io.micronaut.inject.ast.MethodElement;
 import io.micronaut.inject.ast.ParameterElement;
 import io.micronaut.inject.visitor.TypeElementVisitor;
 import io.micronaut.inject.visitor.VisitorContext;
-import io.micronaut.web.router.RouteMatch;
 import org.reactivestreams.Publisher;
 
 import java.util.Optional;
@@ -58,8 +57,7 @@ public final class FilterVisitor implements TypeElementVisitor<Object, Object> {
         FilterContinuation.class,
         Optional.class,
         Throwable.class,
-        MutablePropagatedContext.class,
-        RouteMatch.class
+        MutablePropagatedContext.class
     );
     private static final Set<String> PERMITTED_BINDING_ANNOTATIONS = Set.of(
         Body.class.getName(),
diff --git a/http/src/main/java/io/micronaut/http/annotation/RequestFilter.java b/http/src/main/java/io/micronaut/http/annotation/RequestFilter.java
index 3284bd1775..cbbb40b53b 100644
--- a/http/src/main/java/io/micronaut/http/annotation/RequestFilter.java
+++ b/http/src/main/java/io/micronaut/http/annotation/RequestFilter.java
@@ -55,10 +55,6 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *     <li>A {@code @}{@link Body} parameter of type {@code byte[]}, {@link String} or
  *     {@link ByteBuffer}. Only supported for some HTTP server implementations.</li>
  *     <li>A {@link io.micronaut.core.propagation.MutablePropagatedContext} to modify the propagated context</li>
- *     <li>A RouteMatch of the route that will handle this request. Note: Unless the parameter is
- *     marked as {@link io.micronaut.core.annotation.Nullable}, the filter method will <b>not</b>
- *     match for requests that do not match a route (e.g. static resources). This parameter is only
- *     supported on the server.</li>
  * </ul>
  *
  * The return value may be:
diff --git a/http/src/main/java/io/micronaut/http/annotation/ResponseFilter.java b/http/src/main/java/io/micronaut/http/annotation/ResponseFilter.java
index e5b88c5f39..a7b656ebbd 100644
--- a/http/src/main/java/io/micronaut/http/annotation/ResponseFilter.java
+++ b/http/src/main/java/io/micronaut/http/annotation/ResponseFilter.java
@@ -52,10 +52,6 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  *     <li>A {@code @}{@link Header}, {@code @}{@link QueryValue} or {@code @}{@link CookieValue}
  *     parameter</li>
  *     <li>A {@link io.micronaut.core.propagation.MutablePropagatedContext} to modify the propagated context</li>
- *     <li>A RouteMatch of the route that handled this request. Note: Unless the parameter is
- *     marked as {@link io.micronaut.core.annotation.Nullable}, the filter method will <b>not</b>
- *     match for requests that do not match a route (e.g. static resources). This parameter is only
- *     supported on the server.</li>
  * </ul>
  *
  * The return value may be:
diff --git a/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java b/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java
index ab580366d3..3810f23708 100644
--- a/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java
+++ b/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java
@@ -23,6 +23,7 @@ import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.annotation.Order;
 import io.micronaut.core.bind.ArgumentBinder;
+import io.micronaut.core.bind.annotation.Bindable;
 import io.micronaut.core.convert.ArgumentConversionContext;
 import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.core.io.buffer.ByteBuffer;
@@ -85,29 +86,33 @@ public abstract class BaseFilterProcessor<A extends Annotation> implements Execu
         this.argumentBinderRegistry = new RequestBinderRegistry() {
             @Override
             public <T> Optional<ArgumentBinder<T, HttpRequest<?>>> findArgumentBinder(Argument<T> argument) {
-                if (argument.getAnnotationMetadata().hasAnnotation(Body.class)) {
-                    return Optional.of((AsyncBodyBinder<T>) (context, source) -> {
-                        if (source instanceof ServerHttpRequest<?> fullHttpRequest) {
-                            return InternalByteBody.bufferFlow(fullHttpRequest.byteBody().split(ByteBody.SplitBackpressureMode.FASTEST)).map(imm -> {
-                                Argument<T> t = context.getArgument();
-                                if (t.isAssignableFrom(ByteBuffer.class)) {
-                                    return () -> Optional.of((T) imm.toByteBuffer());
-                                } else if (t.isAssignableFrom(byte[].class)) {
-                                    byte[] bytes = imm.toByteArray();
-                                    return () -> Optional.of((T) bytes);
-                                } else if (t.isAssignableFrom(String.class)) {
-                                    String str = imm.toString(StandardCharsets.UTF_8);
-                                    return () -> Optional.of((T) str);
-                                } else {
-                                    return ArgumentBinder.BindingResult.unsatisfied();
-                                }
-                            });
-                        }
-                        return ExecutionFlow.just(ArgumentBinder.BindingResult.unsatisfied());
-                    });
-                } else {
-                    return requestBinderRegistry.flatMap(registry -> registry.findArgumentBinder(argument));
+                Class<? extends Annotation> annotation = argument.getAnnotationMetadata().getAnnotationTypeByStereotype(Bindable.class).orElse(null);
+                if (annotation != null && PERMITTED_BINDING_ANNOTATIONS.contains(annotation.getName())) {
+                    if (annotation == Body.class) {
+                        return Optional.of((AsyncBodyBinder<T>) (context, source) -> {
+                            if (source instanceof ServerHttpRequest<?> fullHttpRequest) {
+                                return InternalByteBody.bufferFlow(fullHttpRequest.byteBody().split(ByteBody.SplitBackpressureMode.FASTEST)).map(imm -> {
+                                    Argument<T> t = context.getArgument();
+                                    if (t.isAssignableFrom(ByteBuffer.class)) {
+                                        return () -> Optional.of((T) imm.toByteBuffer());
+                                    } else if (t.isAssignableFrom(byte[].class)) {
+                                        byte[] bytes = imm.toByteArray();
+                                        return () -> Optional.of((T) bytes);
+                                    } else if (t.isAssignableFrom(String.class)) {
+                                        String str = imm.toString(StandardCharsets.UTF_8);
+                                        return () -> Optional.of((T) str);
+                                    } else {
+                                        return ArgumentBinder.BindingResult.UNSATISFIED;
+                                    }
+                                });
+                            }
+                            return ExecutionFlow.just(ArgumentBinder.BindingResult.UNSATISFIED);
+                        });
+                    } else {
+                        return requestBinderRegistry.flatMap(registry -> registry.findArgumentBinder(argument));
+                    }
                 }
+                return Optional.empty();
             }
         };
     }
diff --git a/http/src/main/java/io/micronaut/http/filter/FilterArgumentBinderPredicate.java b/http/src/main/java/io/micronaut/http/filter/FilterArgumentBinderPredicate.java
deleted file mode 100644
index 6a9c9b1a78..0000000000
--- a/http/src/main/java/io/micronaut/http/filter/FilterArgumentBinderPredicate.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.filter;
-
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.propagation.MutablePropagatedContext;
-import io.micronaut.core.type.Argument;
-import io.micronaut.http.HttpRequest;
-import io.micronaut.http.HttpResponse;
-
-/**
- * Additional interface that {@link io.micronaut.core.bind.ArgumentBinder}s can implement to
- * restrict when a filter method with this argument will run.
- *
- * @author Jonas Konrad
- * @since 4.6.0
- */
-@Experimental
-public interface FilterArgumentBinderPredicate {
-    /**
-     * Check whether the filter method should run in the given context.
-     *
-     * @param argument                 The argument that this binder binds
-     * @param mutablePropagatedContext The propagated context
-     * @param request                  The request
-     * @param response                 For response filters, the response (if there is no failure)
-     * @param failure                  For response filters, the failure
-     * @return {@code true} if this filter method should run
-     */
-    boolean test(Argument<?> argument,
-                 MutablePropagatedContext mutablePropagatedContext,
-                 HttpRequest<?> request,
-                 @Nullable HttpResponse<?> response,
-                 @Nullable Throwable failure);
-}
diff --git a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
index 105d79af0a..b868274c66 100644
--- a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
+++ b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
@@ -22,6 +22,7 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.async.propagation.ReactivePropagation;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.core.bind.ArgumentBinder;
+import io.micronaut.core.bind.annotation.Bindable;
 import io.micronaut.core.convert.ArgumentConversionContext;
 import io.micronaut.core.convert.ConversionContext;
 import io.micronaut.core.convert.ConversionError;
@@ -122,7 +123,33 @@ record MethodFilter<T>(FilterOrder order,
             Argument<?> argument = arguments[i];
             Class<?> argumentType = argument.getType();
             AnnotationMetadata annotationMetadata = argument.getAnnotationMetadata();
-            if (argumentType.isAssignableFrom(HttpRequest.class)) {
+            if (annotationMetadata.hasStereotype(Bindable.class)) {
+                ArgumentBinder<Object, HttpRequest<?>> argumentBinder = (ArgumentBinder<Object, HttpRequest<?>>) argumentBinderRegistry.findArgumentBinder(argument).orElse(null);
+                if (argumentBinder != null) {
+                    if (argumentBinder instanceof BaseFilterProcessor.AsyncBodyBinder<Object> async) {
+                        if (isResponseFilter) {
+                            throw new IllegalArgumentException("Cannot bind @Body in response filter method [" + method.getDescription(true) + "]");
+                        }
+                        if (asyncArgBinders == null) {
+                            asyncArgBinders = new AsyncFilterArgBinder[arguments.length];
+                        }
+                        asyncArgBinders[i] = ctx -> {
+                            HttpRequest<?> request = ctx.request;
+                            ArgumentConversionContext<Object> conversionContext = (ArgumentConversionContext<Object>) ConversionContext.of(argument);
+                            return async.bindAsync(conversionContext, request).map(result -> convertResult(method, argument, result));
+                        };
+                    } else {
+                        fulfilled[i] = ctx -> {
+                            HttpRequest<?> request = ctx.request;
+                            ArgumentConversionContext<Object> conversionContext = (ArgumentConversionContext<Object>) ConversionContext.of(argument);
+                            ArgumentBinder.BindingResult<Object> result = argumentBinder.bind(conversionContext, request);
+                            return convertResult(method, argument, result);
+                        };
+                    }
+                } else {
+                    throw new IllegalArgumentException("Unsupported binding annotation in filter method [" + method.getDescription(true) + "]: " + annotationMetadata.getAnnotationNameByStereotype(Bindable.class).orElse(null));
+                }
+            } else if (argumentType.isAssignableFrom(HttpRequest.class)) {
                 fulfilled[i] = ctx -> ctx.request;
             } else if (argumentType.isAssignableFrom(ServerHttpRequest.class)) {
                 // todo: only permit for server
@@ -181,34 +208,7 @@ record MethodFilter<T>(FilterOrder order,
             } else if (argumentType == MutablePropagatedContext.class) {
                 fulfilled[i] = ctx -> ctx.mutablePropagatedContext;
             } else {
-                ArgumentBinder<Object, HttpRequest<?>> argumentBinder = (ArgumentBinder<Object, HttpRequest<?>>) argumentBinderRegistry.findArgumentBinder(argument).orElse(null);
-                if (argumentBinder != null) {
-                    if (argumentBinder instanceof BaseFilterProcessor.AsyncBodyBinder<Object> async) {
-                        if (isResponseFilter) {
-                            throw new IllegalArgumentException("Cannot bind @Body in response filter method [" + method.getDescription(true) + "]");
-                        }
-                        if (asyncArgBinders == null) {
-                            asyncArgBinders = new AsyncFilterArgBinder[arguments.length];
-                        }
-                        asyncArgBinders[i] = ctx -> {
-                            HttpRequest<?> request = ctx.request;
-                            ArgumentConversionContext<Object> conversionContext = (ArgumentConversionContext<Object>) ConversionContext.of(argument);
-                            return async.bindAsync(conversionContext, request).map(result -> convertResult(method, argument, result));
-                        };
-                    } else {
-                        fulfilled[i] = ctx -> {
-                            HttpRequest<?> request = ctx.request;
-                            ArgumentConversionContext<Object> conversionContext = (ArgumentConversionContext<Object>) ConversionContext.of(argument);
-                            ArgumentBinder.BindingResult<Object> result = argumentBinder.bind(conversionContext, request);
-                            return convertResult(method, argument, result);
-                        };
-                        if (argumentBinder instanceof FilterArgumentBinderPredicate pred) {
-                            filterCondition = filterCondition.and(ctx -> pred.test(argument, ctx.mutablePropagatedContext, ctx.request, ctx.response, ctx.failure));
-                        }
-                    }
-                } else {
-                    throw new IllegalArgumentException("Unsupported filter argument type: " + argument);
-                }
+                throw new IllegalArgumentException("Unsupported filter argument type: " + argument);
             }
         }
         if (skipOnError) {
@@ -234,8 +234,8 @@ record MethodFilter<T>(FilterOrder order,
     }
 
     private static <T> Object convertResult(@Nullable ExecutableMethod<T, ?> method, Argument<?> argument, ArgumentBinder.BindingResult<Object> result) {
-        if (result.isPresentAndSatisfied() || (argument.isNullable() && result.isSatisfied())) {
-            return result.getValue().orElse(null);
+        if (result.isPresentAndSatisfied()) {
+            return result.get();
         } else {
             List<ConversionError> conversionErrors = result.getConversionErrors();
             if (!conversionErrors.isEmpty()) {
