diff --git a/laws/src/main/scala/cats/laws/NonEmptyParallelLaws.scala b/laws/src/main/scala/cats/laws/NonEmptyParallelLaws.scala
index 96deeb8df..880b3ba1d 100644
--- a/laws/src/main/scala/cats/laws/NonEmptyParallelLaws.scala
+++ b/laws/src/main/scala/cats/laws/NonEmptyParallelLaws.scala
@@ -4,8 +4,9 @@ package laws
 /**
  * Laws that must be obeyed by any `cats.NonEmptyParallel`.
  */
-trait NonEmptyParallelLaws[M[_], F[_]] {
-  def P: NonEmptyParallel.Aux[M, F]
+trait NonEmptyParallelLaws[M[_]] {
+  val P: NonEmptyParallel[M]
+  type F[A] = P.F[A]
 
   def parallelRoundTrip[A](ma: M[A]): IsEq[M[A]] =
     P.sequential(P.parallel(ma)) <-> ma
@@ -18,6 +19,11 @@ trait NonEmptyParallelLaws[M[_], F[_]] {
 }
 
 object NonEmptyParallelLaws {
-  def apply[M[_], F[_]](implicit ev: NonEmptyParallel.Aux[M, F]): NonEmptyParallelLaws[M, F] =
-    new NonEmptyParallelLaws[M, F] { def P: NonEmptyParallel.Aux[M, F] = ev }
+  type Aux[M[_], F0[_]] = NonEmptyParallelLaws[M] { type F[A] = F0[A]; val P: NonEmptyParallel.Aux[M, F0] }
+
+  def apply[M[_]](implicit ev: NonEmptyParallel[M]): NonEmptyParallelLaws.Aux[M, ev.F] =
+    apply[M, ev.F](ev, implicitly)
+
+  def apply[M[_], F[_]](implicit ev: NonEmptyParallel.Aux[M, F], D: DummyImplicit): NonEmptyParallelLaws.Aux[M, F] =
+    new NonEmptyParallelLaws[M] { val P: ev.type = ev }
 }
diff --git a/laws/src/main/scala/cats/laws/ParallelLaws.scala b/laws/src/main/scala/cats/laws/ParallelLaws.scala
index 892ca79ea..4e7165e94 100644
--- a/laws/src/main/scala/cats/laws/ParallelLaws.scala
+++ b/laws/src/main/scala/cats/laws/ParallelLaws.scala
@@ -4,14 +4,19 @@ package laws
 /**
  * Laws that must be obeyed by any `cats.Parallel`.
  */
-trait ParallelLaws[M[_], F[_]] extends NonEmptyParallelLaws[M, F] {
-  def P: Parallel.Aux[M, F]
+trait ParallelLaws[M[_]] extends NonEmptyParallelLaws[M] {
+  val P: Parallel[M]
 
   def isomorphicPure[A](a: A): IsEq[F[A]] =
     P.applicative.pure(a) <-> P.parallel(P.monad.pure(a))
 }
 
 object ParallelLaws {
-  def apply[M[_], F[_]](implicit ev: Parallel.Aux[M, F]): ParallelLaws[M, F] =
-    new ParallelLaws[M, F] { def P: Parallel.Aux[M, F] = ev }
+  type Aux[M[_], F0[_]] = ParallelLaws[M] { type F[A] = F0[A]; val P: Parallel.Aux[M, F0] }
+
+  def apply[M[_]](implicit ev: Parallel[M]): ParallelLaws.Aux[M, ev.F] =
+    apply[M, ev.F](ev, implicitly)
+
+  def apply[M[_], F[_]](implicit ev: Parallel.Aux[M, F], D: DummyImplicit): ParallelLaws.Aux[M, F] =
+    new ParallelLaws[M] { val P: ev.type = ev }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala b/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
index 64b14b8c3..b503b3329 100644
--- a/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
@@ -6,8 +6,9 @@ import org.scalacheck.Arbitrary
 import org.scalacheck.Prop.forAll
 import org.typelevel.discipline.Laws
 
-trait NonEmptyParallelTests[M[_], F[_]] extends Laws {
-  def laws: NonEmptyParallelLaws[M, F]
+trait NonEmptyParallelTests[M[_]] extends Laws {
+  val laws: NonEmptyParallelLaws[M]
+  type F[A] = laws.F[A]
 
   def nonEmptyParallel[A, B](implicit ArbA: Arbitrary[A],
                              ArbM: Arbitrary[M[A]],
@@ -27,6 +28,11 @@ trait NonEmptyParallelTests[M[_], F[_]] extends Laws {
 }
 
 object NonEmptyParallelTests {
-  def apply[M[_], F[_]](implicit ev: NonEmptyParallel.Aux[M, F]): NonEmptyParallelTests[M, F] =
-    new NonEmptyParallelTests[M, F] { val laws: NonEmptyParallelLaws[M, F] = NonEmptyParallelLaws[M, F] }
+  type Aux[M[_], F0[_]] = NonEmptyParallelTests[M] { type F[A] = F0[A]; val laws: NonEmptyParallelLaws.Aux[M, F0] }
+
+  def apply[M[_]](implicit ev: NonEmptyParallel[M]): NonEmptyParallelTests.Aux[M, ev.F] =
+    apply[M, ev.F](ev, implicitly)
+
+  def apply[M[_], F[_]](implicit ev: NonEmptyParallel.Aux[M, F], D: DummyImplicit): NonEmptyParallelTests.Aux[M, F] =
+    new NonEmptyParallelTests[M] { val laws = NonEmptyParallelLaws[M] }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala b/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
index b5b394adc..5f4e28fa8 100644
--- a/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
@@ -5,8 +5,8 @@ package discipline
 import org.scalacheck.Arbitrary
 import org.scalacheck.Prop.forAll
 
-trait ParallelTests[M[_], F[_]] extends NonEmptyParallelTests[M, F] {
-  def laws: ParallelLaws[M, F]
+trait ParallelTests[M[_]] extends NonEmptyParallelTests[M] {
+  val laws: ParallelLaws[M]
 
   def parallel[A, B](implicit ArbA: Arbitrary[A],
                      ArbM: Arbitrary[M[A]],
@@ -24,6 +24,11 @@ trait ParallelTests[M[_], F[_]] extends NonEmptyParallelTests[M, F] {
 }
 
 object ParallelTests {
-  def apply[M[_], F[_]](implicit ev: Parallel.Aux[M, F]): ParallelTests[M, F] =
-    new ParallelTests[M, F] { val laws: ParallelLaws[M, F] = ParallelLaws[M, F] }
+  type Aux[M[_], F0[_]] = ParallelTests[M] { type F[A] = F0[A]; val laws: ParallelLaws.Aux[M, F0] }
+
+  def apply[M[_]](implicit ev: Parallel[M]): ParallelTests.Aux[M, ev.F] =
+    apply[M, ev.F](ev, implicitly)
+
+  def apply[M[_], F[_]](implicit ev: Parallel.Aux[M, F], D: DummyImplicit): ParallelTests.Aux[M, F] =
+    new ParallelTests[M] { val laws = ParallelLaws[M] }
 }
