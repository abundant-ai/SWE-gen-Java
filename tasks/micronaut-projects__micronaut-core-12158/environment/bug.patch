diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupRegistry.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupRegistry.java
index d906aa1746..ae85664158 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupRegistry.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupRegistry.java
@@ -30,10 +30,8 @@ import io.micronaut.core.util.ArgumentUtils;
 import io.micronaut.http.netty.channel.loom.LoomCarrierGroup;
 import io.micronaut.inject.qualifiers.Qualifiers;
 import io.netty.channel.EventLoopGroup;
-import io.netty.channel.IoEventLoop;
 import io.netty.channel.IoHandlerFactory;
 import io.netty.channel.MultiThreadIoEventLoopGroup;
-import io.netty.channel.SingleThreadIoEventLoop;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.util.NettyRuntime;
 import io.netty.util.concurrent.DefaultThreadFactory;
@@ -44,10 +42,8 @@ import jakarta.inject.Singleton;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.List;
 import java.util.Map;
 import java.util.Optional;
-import java.util.Queue;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
@@ -72,8 +68,6 @@ public class DefaultEventLoopGroupRegistry implements EventLoopGroupRegistry {
 
     private final BeanProvider<LoomCarrierGroup.Factory> loomCarrierGroupFactory;
 
-    private final List<TaskQueueInterceptor> taskQueueInterceptors;
-
     /**
      * Default constructor.
      *
@@ -81,11 +75,10 @@ public class DefaultEventLoopGroupRegistry implements EventLoopGroupRegistry {
      * @param beanLocator           The bean locator
      * @param loomCarrierGroupFactory Factory for the loom carrier group
      */
-    public DefaultEventLoopGroupRegistry(EventLoopGroupFactory eventLoopGroupFactory, BeanLocator beanLocator, BeanProvider<LoomCarrierGroup.Factory> loomCarrierGroupFactory, List<TaskQueueInterceptor> taskQueueInterceptors) {
+    public DefaultEventLoopGroupRegistry(EventLoopGroupFactory eventLoopGroupFactory, BeanLocator beanLocator, BeanProvider<LoomCarrierGroup.Factory> loomCarrierGroupFactory) {
         this.eventLoopGroupFactory = eventLoopGroupFactory;
         this.beanLocator = beanLocator;
         this.loomCarrierGroupFactory = loomCarrierGroupFactory;
-        this.taskQueueInterceptors = taskQueueInterceptors;
     }
 
     /**
@@ -107,30 +100,14 @@ public class DefaultEventLoopGroupRegistry implements EventLoopGroupRegistry {
         eventLoopGroups.clear();
     }
 
-    private EventLoopGroup createGroup(EventLoopGroupConfiguration configuration, String name, Executor executor) {
+    private EventLoopGroup createGroup(EventLoopGroupConfiguration configuration, Executor executor) {
         IoHandlerFactory ioHandlerFactory = eventLoopGroupFactory.createIoHandlerFactory(configuration);
         int nThreads = numThreads(configuration);
         EventLoopGroup eventLoopGroup;
         if (configuration.isLoomCarrier()) {
             eventLoopGroup = loomCarrierGroupFactory.get().create(nThreads, executor, ioHandlerFactory);
-        } else if (taskQueueInterceptors.isEmpty()) {
-            eventLoopGroup = new MultiThreadIoEventLoopGroup(nThreads, executor, ioHandlerFactory);
         } else {
-            eventLoopGroup = new MultiThreadIoEventLoopGroup(nThreads, executor, ioHandlerFactory) {
-                @Override
-                protected IoEventLoop newChild(Executor executor, IoHandlerFactory ioHandlerFactory, Object... args) {
-                    return new SingleThreadIoEventLoop(this, executor, ioHandlerFactory) {
-                        @Override
-                        protected Queue<Runnable> newTaskQueue(int maxPendingTasks) {
-                            Queue<Runnable> tq = super.newTaskQueue(maxPendingTasks);
-                            for (TaskQueueInterceptor taskQueueInterceptor : taskQueueInterceptors) {
-                                tq = taskQueueInterceptor.wrapTaskQueue(name, tq);
-                            }
-                            return tq;
-                        }
-                    };
-                }
-            };
+            eventLoopGroup = new MultiThreadIoEventLoopGroup(nThreads, executor, ioHandlerFactory);
         }
         eventLoopGroups.put(eventLoopGroup, configuration);
         return eventLoopGroup;
@@ -160,7 +137,7 @@ public class DefaultEventLoopGroupRegistry implements EventLoopGroupRegistry {
             executor = new ThreadPerTaskExecutor(threadFactory);
         }
 
-        return createGroup(configuration, configuration.getName(), executor);
+        return createGroup(configuration, executor);
     }
 
     /**
@@ -178,7 +155,7 @@ public class DefaultEventLoopGroupRegistry implements EventLoopGroupRegistry {
         if (threadFactory instanceof NettyThreadFactory.EventLoopCustomizableThreadFactory custom) {
             threadFactory = custom.customizeForEventLoop();
         }
-        return createGroup(new DefaultEventLoopGroupConfiguration(), EventLoopGroupConfiguration.DEFAULT, new ThreadPerTaskExecutor(threadFactory));
+        return createGroup(new DefaultEventLoopGroupConfiguration(), new ThreadPerTaskExecutor(threadFactory));
     }
 
     @NonNull
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/TaskQueueInterceptor.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/TaskQueueInterceptor.java
deleted file mode 100644
index 57453162fd..0000000000
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/TaskQueueInterceptor.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.netty.channel;
-
-import io.micronaut.context.annotation.BootstrapContextCompatible;
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.NonNull;
-
-import java.util.Queue;
-
-/**
- * An interceptor that wraps a task queue for a netty event loop.
- *
- * @author Jonas Konrad
- */
-@BootstrapContextCompatible
-@Experimental
-public interface TaskQueueInterceptor {
-    /**
-     * Wrap a task queue.
-     *
-     * @param groupName The event loop group name
-     * @param original  The original queue
-     * @return The wrapped queue
-     */
-    @NonNull
-    Queue<Runnable> wrapTaskQueue(@NonNull String groupName, @NonNull Queue<Runnable> original);
-}
diff --git a/http-netty/src/test/java/io/micronaut/http/netty/channel/TaskQueueInterceptorTest.java b/http-netty/src/test/java/io/micronaut/http/netty/channel/TaskQueueInterceptorTest.java
deleted file mode 100644
index a376b97400..0000000000
--- a/http-netty/src/test/java/io/micronaut/http/netty/channel/TaskQueueInterceptorTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package io.micronaut.http.netty.channel;
-
-import io.micronaut.context.ApplicationContext;
-import io.micronaut.context.annotation.Requires;
-import io.netty.channel.EventLoop;
-import io.netty.channel.EventLoopGroup;
-import io.netty.util.concurrent.Promise;
-import jakarta.inject.Singleton;
-import org.junit.jupiter.api.Test;
-
-import java.util.AbstractQueue;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.Queue;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import static org.junit.jupiter.api.Assertions.*;
-
-class TaskQueueInterceptorTest {
-    @Test
-    public void test() throws ExecutionException, InterruptedException {
-        try (ApplicationContext ctx = ApplicationContext.run(Map.of("spec.name", "TaskQueueInterceptorTest"))) {
-            AtomicInteger started = ctx.getBean(MyTaskQueueInterceptor.class).started;
-            EventLoopGroup group = ctx.getBean(EventLoopGroup.class);
-            EventLoop loop = group.next();
-            Promise<String> promise = loop.newPromise();
-            int before = started.get();
-            loop.execute(() -> promise.setSuccess("foo"));
-            assertEquals("foo", promise.get());
-            assertNotEquals(before, started.get());
-        }
-    }
-
-    @Singleton
-    @Requires(property = "spec.name", value = "TaskQueueInterceptorTest")
-    static final class MyTaskQueueInterceptor implements TaskQueueInterceptor {
-        final AtomicInteger started = new AtomicInteger(0);
-
-        @Override
-        public Queue<Runnable> wrapTaskQueue(String groupName, Queue<Runnable> original) {
-            return new AbstractQueue<>() {
-                @Override
-                public Iterator<Runnable> iterator() {
-                    return original.iterator();
-                }
-
-                @Override
-                public int size() {
-                    return original.size();
-                }
-
-                @Override
-                public boolean offer(Runnable runnable) {
-                    return original.offer(() -> {
-                        started.incrementAndGet();
-                        runnable.run();
-                    });
-                }
-
-                @Override
-                public Runnable poll() {
-                    return original.poll();
-                }
-
-                @Override
-                public Runnable peek() {
-                    return original.peek();
-                }
-            };
-        }
-    }
-}
