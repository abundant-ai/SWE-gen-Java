diff --git a/okhttp-logging-interceptor/api/logging-interceptor.api b/okhttp-logging-interceptor/api/logging-interceptor.api
index 65bfedffd..b6b4d7e94 100644
--- a/okhttp-logging-interceptor/api/logging-interceptor.api
+++ b/okhttp-logging-interceptor/api/logging-interceptor.api
@@ -5,30 +5,21 @@ public final class okhttp3/logging/HttpLoggingInterceptor : okhttp3/Interceptor
 	public fun <init> (Lokhttp3/logging/HttpLoggingInterceptor$Logger;)V
 	public synthetic fun <init> (Lokhttp3/logging/HttpLoggingInterceptor$Logger;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
 	public final fun getLevel ()Lokhttp3/logging/HttpLoggingInterceptor$Level;
-	public final fun getRequestLevel ()Lkotlin/jvm/functions/Function1;
 	public fun intercept (Lokhttp3/Interceptor$Chain;)Lokhttp3/Response;
 	public final fun level (Lokhttp3/logging/HttpLoggingInterceptor$Level;)V
 	public final fun redactHeader (Ljava/lang/String;)V
 	public final fun redactQueryParams ([Ljava/lang/String;)V
 	public final fun setLevel (Lokhttp3/logging/HttpLoggingInterceptor$Level;)Lokhttp3/logging/HttpLoggingInterceptor;
-	public final fun setRequestLevel (Lkotlin/jvm/functions/Function1;)V
 }
 
 public final class okhttp3/logging/HttpLoggingInterceptor$Companion {
 }
 
-public final class okhttp3/logging/HttpLoggingInterceptor$Identity : okhttp3/CompressionInterceptor$DecompressionAlgorithm {
-	public static final field INSTANCE Lokhttp3/logging/HttpLoggingInterceptor$Identity;
-	public fun decompress (Lokio/BufferedSource;)Lokio/Source;
-	public fun getEncoding ()Ljava/lang/String;
-}
-
 public final class okhttp3/logging/HttpLoggingInterceptor$Level : java/lang/Enum {
 	public static final field BASIC Lokhttp3/logging/HttpLoggingInterceptor$Level;
 	public static final field BODY Lokhttp3/logging/HttpLoggingInterceptor$Level;
 	public static final field HEADERS Lokhttp3/logging/HttpLoggingInterceptor$Level;
 	public static final field NONE Lokhttp3/logging/HttpLoggingInterceptor$Level;
-	public static final field STREAMING Lokhttp3/logging/HttpLoggingInterceptor$Level;
 	public static fun getEntries ()Lkotlin/enums/EnumEntries;
 	public static fun valueOf (Ljava/lang/String;)Lokhttp3/logging/HttpLoggingInterceptor$Level;
 	public static fun values ()[Lokhttp3/logging/HttpLoggingInterceptor$Level;
diff --git a/okhttp-logging-interceptor/src/main/kotlin/okhttp3/logging/HttpLoggingInterceptor.kt b/okhttp-logging-interceptor/src/main/kotlin/okhttp3/logging/HttpLoggingInterceptor.kt
index 29b937459..8fdb38a06 100644
--- a/okhttp-logging-interceptor/src/main/kotlin/okhttp3/logging/HttpLoggingInterceptor.kt
+++ b/okhttp-logging-interceptor/src/main/kotlin/okhttp3/logging/HttpLoggingInterceptor.kt
@@ -20,31 +20,17 @@ import java.io.IOException
 import java.nio.charset.Charset
 import java.util.TreeSet
 import java.util.concurrent.TimeUnit
-import okhttp3.CompressionInterceptor
-import okhttp3.CompressionInterceptor.DecompressionAlgorithm
-import okhttp3.Gzip
 import okhttp3.Headers
 import okhttp3.HttpUrl
 import okhttp3.Interceptor
-import okhttp3.MediaType
 import okhttp3.OkHttpClient
-import okhttp3.Request
-import okhttp3.RequestBody
 import okhttp3.Response
-import okhttp3.ResponseBody
 import okhttp3.internal.charsetOrUtf8
-import okhttp3.internal.connection.RealCall
 import okhttp3.internal.http.promisesBody
 import okhttp3.internal.platform.Platform
 import okhttp3.logging.internal.isProbablyUtf8
 import okio.Buffer
-import okio.BufferedSink
-import okio.BufferedSource
-import okio.ForwardingSink
-import okio.ForwardingSource
 import okio.GzipSource
-import okio.Source
-import okio.buffer
 
 /**
  * An OkHttp interceptor which logs request and response information. Can be applied as an
@@ -66,8 +52,6 @@ class HttpLoggingInterceptor
     @Volatile
     var level = Level.NONE
 
-    var requestLevel: (Request) -> Level = { level }
-
     enum class Level {
       /** No logs. */
       NONE,
@@ -125,27 +109,6 @@ class HttpLoggingInterceptor
        * ```
        */
       BODY,
-
-      /**
-       * Logs streaming request and response lines.
-       *
-       * Example:
-       * ```
-       * --> POST /greeting http/1.1
-       * <-- 200 OK (22ms, unknown-length body)
-       * > request A
-       *
-       * < response B
-       *
-       * > request C
-       *
-       * < response D
-       *
-       * --> END POST
-       * <-- END HTTP
-       * ```
-       */
-      STREAMING,
     }
 
     fun interface Logger {
@@ -200,90 +163,29 @@ class HttpLoggingInterceptor
 
     @Throws(IOException::class)
     override fun intercept(chain: Interceptor.Chain): Response {
-      var request = chain.request()
-
-      val level = this.requestLevel(request)
+      val level = this.level
 
+      val request = chain.request()
       if (level == Level.NONE) {
         return chain.proceed(request)
       }
 
-      val logHeaders = level == Level.BODY || level == Level.HEADERS
+      val logBody = level == Level.BODY
+      val logHeaders = logBody || level == Level.HEADERS
 
-      val decompressionAlgorithms = findCompressionAlgorithms(chain)
+      val requestBody = request.body
 
       val connection = chain.connection()
-
-      val requestBody = request.body
       var requestStartMessage =
         ("--> ${request.method} ${redactUrl(request.url)}${if (connection != null) " " + connection.protocol() else ""}")
-      if (!logHeaders && level != Level.STREAMING && requestBody != null) {
+      if (!logHeaders && requestBody != null) {
         requestStartMessage += " (${requestBody.contentLength()}-byte body)"
       }
       logger.log(requestStartMessage)
 
-      if (level != Level.BASIC) {
-        request = logRequest(request, level, decompressionAlgorithms)
-      }
-
-      val startNs = System.nanoTime()
-      val response: Response
-      try {
-        response = chain.proceed(request)
-      } catch (e: Exception) {
-        val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
-        logger.log(
-          buildString {
-            append("<-- HTTP FAILED: $e.")
-            append(" ${redactUrl(request.url)} (${tookMs}ms)")
-          },
-        )
-        throw e
-      }
-
-      val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
-
-      val responseBody = response.body
-      val contentLength = responseBody.contentLength()
-      val bodySize = if (contentLength != -1L) "$contentLength-byte" else "unknown-length"
-      logger.log(
-        buildString {
-          append("<-- ${response.code}")
-          if (response.message.isNotEmpty()) append(" ${response.message}")
-          append(" ${redactUrl(response.request.url)} (${tookMs}ms")
-          if (!logHeaders) append(", $bodySize body")
-          append(")")
-        },
-      )
-
-      return if (level != Level.BASIC) {
-        logResponse(
-          response,
-          decompressionAlgorithms,
-          startNs,
-          contentLength,
-        )
-      } else {
-        response
-      }
-    }
-
-    private fun findCompressionAlgorithms(chain: Interceptor.Chain): List<DecompressionAlgorithm> {
-      val compressionInterceptor =
-        (chain.call() as? RealCall)?.client?.interceptors?.find { it is CompressionInterceptor } as? CompressionInterceptor
-
-      return compressionInterceptor?.algorithms?.toList() ?: listOf(Gzip)
-    }
-
-    private fun logRequest(
-      request: Request,
-      level: Level,
-      decompressionAlgorithms: List<DecompressionAlgorithm>,
-    ): Request {
-      val requestBody = request.body
-
-      if (level == Level.HEADERS || level == Level.BODY) {
+      if (logHeaders) {
         val headers = request.headers
+
         if (requestBody != null) {
           // Request body headers are only present when installed as a network interceptor. When not
           // already present, force them to be included (if available) so their values are known.
@@ -302,34 +204,25 @@ class HttpLoggingInterceptor
         for (i in 0 until headers.size) {
           logHeader(headers, i)
         }
-      }
 
-      if (level == Level.HEADERS || requestBody == null) {
-        logger.log("--> END ${request.method}")
-      } else if (level == Level.STREAMING) {
-        return streamRequestBody(request)
-      } else if (level == Level.BODY) {
-        if (requestBody.isDuplex()) {
+        if (!logBody || requestBody == null) {
+          logger.log("--> END ${request.method}")
+        } else if (bodyHasUnknownEncoding(request.headers)) {
+          logger.log("--> END ${request.method} (encoded body omitted)")
+        } else if (requestBody.isDuplex()) {
           logger.log("--> END ${request.method} (duplex request body omitted)")
         } else if (requestBody.isOneShot()) {
           logger.log("--> END ${request.method} (one-shot body omitted)")
         } else {
-          val decompressor = findCompressionAlgorithm(request.headers, decompressionAlgorithms)
-
-          if (decompressor == null) {
-            logger.log("--> END ${request.method} (unknown encoded body omitted)")
-            return request
-          }
-
           var buffer = Buffer()
           requestBody.writeTo(buffer)
 
-          var compressedLength: Long? = null
-          if (decompressor != Identity) {
-            compressedLength = buffer.size
-            decompressor.decompress(buffer).use { uncompressedResponseBody ->
+          var gzippedLength: Long? = null
+          if ("gzip".equals(headers["Content-Encoding"], ignoreCase = true)) {
+            gzippedLength = buffer.size
+            GzipSource(buffer).use { gzippedResponseBody ->
               buffer = Buffer()
-              buffer.writeAll(uncompressedResponseBody)
+              buffer.writeAll(gzippedResponseBody)
             }
           }
 
@@ -340,8 +233,8 @@ class HttpLoggingInterceptor
             logger.log(
               "--> END ${request.method} (binary ${requestBody.contentLength()}-byte body omitted)",
             )
-          } else if (compressedLength != null) {
-            logger.log("--> END ${request.method} (${buffer.size}-byte, $compressedLength-${decompressor.encoding}-byte body)")
+          } else if (gzippedLength != null) {
+            logger.log("--> END ${request.method} (${buffer.size}-byte, $gzippedLength-gzipped-byte body)")
           } else {
             logger.log(buffer.readString(charset))
             logger.log("--> END ${request.method} (${requestBody.contentLength()}-byte body)")
@@ -349,42 +242,49 @@ class HttpLoggingInterceptor
         }
       }
 
-      return request
-    }
+      val startNs = System.nanoTime()
+      val response: Response
+      try {
+        response = chain.proceed(request)
+      } catch (e: Exception) {
+        val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
+        logger.log(
+          buildString {
+            append("<-- HTTP FAILED: $e.")
+            append(" ${redactUrl(request.url)} (${tookMs}ms)")
+          },
+        )
+        throw e
+      }
 
-    private fun logResponse(
-      response: Response,
-      decompressionAlgorithms: List<DecompressionAlgorithm>,
-      startNs: Long,
-      contentLength: Long,
-    ): Response {
-      val logBody = level == Level.BODY
-      val logStreamed = level == Level.STREAMING
-      val logHeaders = logBody || level == Level.HEADERS
-      val responseBody = response.body
+      val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
+
+      val responseBody = response.body!!
+      val contentLength = responseBody.contentLength()
+      val bodySize = if (contentLength != -1L) "$contentLength-byte" else "unknown-length"
+      logger.log(
+        buildString {
+          append("<-- ${response.code}")
+          if (response.message.isNotEmpty()) append(" ${response.message}")
+          append(" ${redactUrl(response.request.url)} (${tookMs}ms")
+          if (!logHeaders) append(", $bodySize body")
+          append(")")
+        },
+      )
 
       if (logHeaders) {
         val headers = response.headers
         for (i in 0 until headers.size) {
           logHeader(headers, i)
         }
-      }
 
-      if (level == Level.HEADERS || !response.promisesBody()) {
-        logger.log("<-- END HTTP")
-      } else if (logStreamed) {
-        return streamResponseBody(response, decompressionAlgorithms)
-      } else if (logBody) {
-        if (bodyIsEventStream(response)) {
-          logger.log("<-- END HTTP (event-stream)")
+        if (!logBody || !response.promisesBody()) {
+          logger.log("<-- END HTTP")
+        } else if (bodyHasUnknownEncoding(response.headers)) {
+          logger.log("<-- END HTTP (encoded body omitted)")
+        } else if (bodyIsStreaming(response)) {
+          logger.log("<-- END HTTP (streaming)")
         } else {
-          val decompressor = findCompressionAlgorithm(response.headers, decompressionAlgorithms)
-
-          if (decompressor == null) {
-            logger.log("<-- END HTTP (unknown encoded body omitted)")
-            return response
-          }
-
           val source = responseBody.source()
           source.request(Long.MAX_VALUE) // Buffer the entire body.
 
@@ -392,9 +292,9 @@ class HttpLoggingInterceptor
 
           var buffer = source.buffer
 
-          var compressedLength: Long? = null
-          if (decompressor != Identity) {
-            compressedLength = buffer.size
+          var gzippedLength: Long? = null
+          if ("gzip".equals(headers["Content-Encoding"], ignoreCase = true)) {
+            gzippedLength = buffer.size
             GzipSource(buffer.clone()).use { gzippedResponseBody ->
               buffer = Buffer()
               buffer.writeAll(gzippedResponseBody)
@@ -417,38 +317,14 @@ class HttpLoggingInterceptor
           logger.log(
             buildString {
               append("<-- END HTTP (${totalMs}ms, ${buffer.size}-byte")
-              if (compressedLength != null) append(", $compressedLength-${decompressor.encoding}-byte")
+              if (gzippedLength != null) append(", $gzippedLength-gzipped-byte")
               append(" body)")
             },
           )
         }
       }
-      return response
-    }
-
-    private fun streamRequestBody(request: Request): Request =
-      request
-        .newBuilder()
-        .method(request.method, StreamingRequestBody(request, logger))
-        .build()
-
-    private fun streamResponseBody(
-      response: Response,
-      decompressionAlgorithms: List<DecompressionAlgorithm>,
-    ): Response {
-      val decompressor = findCompressionAlgorithm(response.headers, decompressionAlgorithms)
-
-      if (decompressor == null) {
-        logger.log("--> END HTTP (encoded streaming body omitted)")
-        return response
-      }
 
       return response
-        .newBuilder()
-        .body(StreamingResponseBody(response, decompressor, logger))
-        .removeHeader("Content-Encoding")
-        .removeHeader("Content-Length")
-        .build()
     }
 
     internal fun redactUrl(url: HttpUrl): String {
@@ -476,107 +352,16 @@ class HttpLoggingInterceptor
       logger.log(headers.name(i) + ": " + value)
     }
 
-    private fun findCompressionAlgorithm(
-      headers: Headers,
-      decompressionAlgorithms: List<DecompressionAlgorithm>,
-    ): DecompressionAlgorithm? {
-      val contentEncoding = headers["Content-Encoding"] ?: return Identity
-
-      if (contentEncoding.equals("identity", ignoreCase = true)) return Identity
-
-      return decompressionAlgorithms.find { contentEncoding.equals(it.encoding, ignoreCase = true) }
+    private fun bodyHasUnknownEncoding(headers: Headers): Boolean {
+      val contentEncoding = headers["Content-Encoding"] ?: return false
+      return !contentEncoding.equals("identity", ignoreCase = true) &&
+        !contentEncoding.equals("gzip", ignoreCase = true)
     }
 
-    object Identity : DecompressionAlgorithm {
-      override val encoding: String
-        get() = "identity"
-
-      override fun decompress(compressedSource: BufferedSource): Source = compressedSource
-    }
-
-    private fun bodyIsEventStream(response: Response): Boolean {
+    private fun bodyIsStreaming(response: Response): Boolean {
       val contentType = response.body.contentType()
       return contentType != null && contentType.type == "text" && contentType.subtype == "event-stream"
     }
 
     companion object
   }
-
-private class StreamingRequestBody(
-  val request: Request,
-  val logger: HttpLoggingInterceptor.Logger,
-) : RequestBody() {
-  val body = request.body!!
-  val charset: Charset = body.contentType().charsetOrUtf8()
-
-  override fun contentType(): MediaType? = body.contentType()
-
-  override fun writeTo(sink: BufferedSink) {
-    val sink =
-      object : ForwardingSink(sink) {
-        override fun write(
-          source: Buffer,
-          byteCount: Long,
-        ) {
-          logger.log("> " + source.copy().readString(charset))
-          super.write(source, byteCount)
-        }
-
-        override fun close() {
-          super.close()
-          logger.log("--> END ${request.method} (streaming body)")
-        }
-      }.buffer()
-
-    body.writeTo(sink)
-  }
-
-  override fun contentLength(): Long = -1
-
-  override fun isDuplex(): Boolean = body.isDuplex()
-
-  override fun isOneShot(): Boolean = body.isOneShot()
-}
-
-private class StreamingResponseBody(
-  val response: Response,
-  val decompressor: DecompressionAlgorithm,
-  val logger: HttpLoggingInterceptor.Logger,
-) : ResponseBody() {
-  val buffer = Buffer()
-  val charset: Charset = response.body.contentType().charsetOrUtf8()
-
-  override fun contentType(): MediaType? = response.body.contentType()
-
-  override fun contentLength(): Long = -1
-
-  override fun source(): BufferedSource {
-    val decompressedSource = decompressor.decompress(response.body.source())
-
-    val source: Source =
-      object : ForwardingSource(decompressedSource) {
-        override fun read(
-          sink: Buffer,
-          byteCount: Long,
-        ): Long {
-          val count = super.read(buffer, byteCount)
-
-          if (count == -1L) {
-            logger.log("<-- END HTTP (streaming body)")
-          } else {
-            logger.log("< " + buffer.copy().readString(charset))
-            sink.write(buffer, count)
-          }
-
-          return count
-        }
-      }
-
-    return source.buffer()
-  }
-
-  override fun close() {
-    response.body.close()
-    buffer.clear()
-  }
-}
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.kt b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.kt
index ccf19dd1f..ffacefb13 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.kt
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.kt
@@ -19,7 +19,6 @@ import assertk.assertThat
 import assertk.assertions.isEqualTo
 import assertk.assertions.isLessThan
 import assertk.assertions.isLessThanOrEqualTo
-import assertk.assertions.isNull
 import assertk.assertions.isSameInstanceAs
 import assertk.assertions.matches
 import java.net.UnknownHostException
@@ -36,8 +35,6 @@ import okhttp3.RecordingHostnameVerifier
 import okhttp3.Request
 import okhttp3.RequestBody
 import okhttp3.RequestBody.Companion.toRequestBody
-import okhttp3.internal.duplex.AsyncRequestBody
-import okhttp3.internal.duplex.MockSocketHandler
 import okhttp3.logging.HttpLoggingInterceptor.Level
 import okhttp3.testing.PlatformRule
 import okio.Buffer
@@ -605,7 +602,7 @@ class HttpLoggingInterceptorTest {
       .assertLogEqual("Accept-Encoding: gzip")
       .assertLogMatch(Regex("""User-Agent: okhttp/.+"""))
       .assertLogEqual("")
-      .assertLogEqual("--> END POST (12-byte, 32-gzip-byte body)")
+      .assertLogEqual("--> END POST (12-byte, 32-gzipped-byte body)")
       .assertLogMatch(Regex("""<-- 200 OK $url \(\d+ms\)"""))
       .assertLogEqual("Content-Type: text/plain; charset=utf-8")
       .assertLogMatch(Regex("""Content-Length: \d+"""))
@@ -644,7 +641,7 @@ class HttpLoggingInterceptorTest {
       .assertLogMatch(Regex("""Content-Length: \d+"""))
       .assertLogEqual("")
       .assertLogEqual("Hello, Hello, Hello")
-      .assertLogMatch(Regex("""<-- END HTTP \(\d+ms, 19-byte, 29-gzip-byte body\)"""))
+      .assertLogMatch(Regex("""<-- END HTTP \(\d+ms, 19-byte, 29-gzipped-byte body\)"""))
       .assertNoMoreLogs()
     applicationLogs
       .assertLogEqual("--> GET $url")
@@ -681,7 +678,7 @@ class HttpLoggingInterceptorTest {
       .assertLogEqual("Content-Encoding: br")
       .assertLogEqual("Content-Type: text/plain; charset=utf-8")
       .assertLogMatch(Regex("""Content-Length: \d+"""))
-      .assertLogEqual("<-- END HTTP (unknown encoded body omitted)")
+      .assertLogEqual("<-- END HTTP (encoded body omitted)")
       .assertNoMoreLogs()
     applicationLogs
       .assertLogEqual("--> GET $url")
@@ -690,64 +687,12 @@ class HttpLoggingInterceptorTest {
       .assertLogEqual("Content-Encoding: br")
       .assertLogEqual("Content-Type: text/plain; charset=utf-8")
       .assertLogMatch(Regex("""Content-Length: \d+"""))
-      .assertLogEqual("<-- END HTTP (unknown encoded body omitted)")
+      .assertLogEqual("<-- END HTTP (encoded body omitted)")
       .assertNoMoreLogs()
   }
 
   @Test
   fun bodyResponseIsStreaming() {
-    setLevel(Level.STREAMING)
-    server.enqueue(
-      MockResponse
-        .Builder()
-        .setHeader("Content-Type", "text/event-stream")
-        .chunkedBody(
-          """
-          |event: add
-          |data: 73857293
-          |
-          |event: remove
-          |data: 2153
-          |
-          |event: add
-          |data: 113411
-          |
-          |
-          """.trimMargin(),
-          8,
-        ).build(),
-    )
-    val parts = mutableListOf<String>()
-    client.newCall(request().build()).execute().use {
-      val source = it.body.source()
-      while (!source.exhausted()) {
-        parts.add(source.readUtf8(source.buffer.size))
-      }
-    }
-    networkLogs
-      .assertLogEqual("--> GET $url http/1.1")
-      .assertLogEqual("--> END GET")
-      .assertLogMatch(Regex("""<-- 200 OK $url \(\d+ms, unknown-length body\)"""))
-      .apply {
-        parts.forEach {
-          assertLogEqual("< $it")
-        }
-      }.assertLogEqual("<-- END HTTP (streaming body)")
-      .assertNoMoreLogs()
-    applicationLogs
-      .assertLogEqual("--> GET $url")
-      .assertLogEqual("--> END GET")
-      .assertLogMatch(Regex("""<-- 200 OK $url \(\d+ms, unknown-length body\)"""))
-      .apply {
-        parts.forEach {
-          assertLogEqual("< $it")
-        }
-      }.assertLogEqual("<-- END HTTP (streaming body)")
-      .assertNoMoreLogs()
-  }
-
-  @Test
-  fun bodyResponseIsEventStream() {
     setLevel(Level.BODY)
     server.enqueue(
       MockResponse
@@ -781,7 +726,7 @@ class HttpLoggingInterceptorTest {
       .assertLogMatch(Regex("""<-- 200 OK $url \(\d+ms\)"""))
       .assertLogEqual("Content-Type: text/event-stream")
       .assertLogMatch(Regex("""Transfer-encoding: chunked"""))
-      .assertLogEqual("<-- END HTTP (event-stream)")
+      .assertLogEqual("<-- END HTTP (streaming)")
       .assertNoMoreLogs()
     applicationLogs
       .assertLogEqual("--> GET $url")
@@ -789,7 +734,7 @@ class HttpLoggingInterceptorTest {
       .assertLogMatch(Regex("""<-- 200 OK $url \(\d+ms\)"""))
       .assertLogEqual("Content-Type: text/event-stream")
       .assertLogMatch(Regex("""Transfer-encoding: chunked"""))
-      .assertLogEqual("<-- END HTTP (event-stream)")
+      .assertLogEqual("<-- END HTTP (streaming)")
       .assertNoMoreLogs()
   }
 
@@ -1115,72 +1060,6 @@ class HttpLoggingInterceptorTest {
       .assertNoMoreLogs()
   }
 
-  @Test
-  fun duplexRequestsAreStreamable() {
-    platform.assumeHttp2Support()
-    server.useHttps(handshakeCertificates.sslSocketFactory()) // HTTP/2
-    url = server.url("/")
-    setLevel(Level.STREAMING)
-
-    val body =
-      MockSocketHandler()
-        .receiveRequest("request A\n")
-        .sendResponse("response B\n")
-        .receiveRequest("request C\n")
-        .sendResponse("response D\n")
-        .receiveRequest("request E\n")
-        .sendResponse("response F\n")
-        .exhaustRequest()
-        .exhaustResponse()
-    server.enqueue(
-      MockResponse
-        .Builder()
-        .clearHeaders()
-        .socketHandler(body)
-        .build(),
-    )
-    val call =
-      client.newCall(
-        Request
-          .Builder()
-          .url(server.url("/"))
-          .post(AsyncRequestBody())
-          .build(),
-      )
-    call.execute().use { response ->
-      val requestBody = (call.request().body as AsyncRequestBody?)!!.takeSink()
-      requestBody.writeUtf8("request A\n")
-      requestBody.flush()
-      val responseBody = response.body.source()
-      assertThat(responseBody.readUtf8Line())
-        .isEqualTo("response B")
-      requestBody.writeUtf8("request C\n")
-      requestBody.flush()
-      assertThat(responseBody.readUtf8Line())
-        .isEqualTo("response D")
-      requestBody.writeUtf8("request E\n")
-      requestBody.flush()
-      assertThat(responseBody.readUtf8Line())
-        .isEqualTo("response F")
-      requestBody.close()
-      assertThat(responseBody.readUtf8Line()).isNull()
-    }
-    body.awaitSuccess()
-
-    applicationLogs
-      .assertLogEqual("--> POST $url")
-      .assertLogMatch(Regex("""<-- 200 $url \(\d+ms, unknown-length body\)"""))
-      .assertLogEqual("> request A\n")
-      .assertLogEqual("< response B\n")
-      .assertLogEqual("> request C\n")
-      .assertLogEqual("< response D\n")
-      .assertLogEqual("> request E\n")
-      .assertLogEqual("< response F\n")
-      .assertLogEqual("--> END POST (streaming body)")
-      .assertLogEqual("<-- END HTTP (streaming body)")
-      .assertNoMoreLogs()
-  }
-
   @Test
   fun oneShotRequestsAreNotLogged() {
     url = server.url("/")
@@ -1228,7 +1107,7 @@ class HttpLoggingInterceptorTest {
   internal class LogRecorder(
     val prefix: Regex = Regex(""),
   ) : HttpLoggingInterceptor.Logger {
-    val logs = mutableListOf<String>()
+    private val logs = mutableListOf<String>()
     private var index = 0
 
     fun assertLogEqual(expected: String) =
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt
index c046229dd..2fe2dd7b0 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt
@@ -44,8 +44,6 @@ import okhttp3.TestUtil.assumeNotWindows
 import okhttp3.internal.RecordingOkAuthenticator
 import okhttp3.internal.duplex.AsyncRequestBody
 import okhttp3.internal.duplex.MockSocketHandler
-import okhttp3.logging.HttpLoggingInterceptor
-import okhttp3.logging.HttpLoggingInterceptor.Level
 import okhttp3.testing.PlatformRule
 import okio.BufferedSink
 import org.junit.jupiter.api.AfterEach
@@ -53,10 +51,9 @@ import org.junit.jupiter.api.Assertions.assertTrue
 import org.junit.jupiter.api.BeforeEach
 import org.junit.jupiter.api.Disabled
 import org.junit.jupiter.api.Tag
+import org.junit.jupiter.api.Test
 import org.junit.jupiter.api.Timeout
 import org.junit.jupiter.api.extension.RegisterExtension
-import org.junit.jupiter.params.ParameterizedTest
-import org.junit.jupiter.params.provider.ValueSource
 
 @Timeout(30)
 @Tag("Slowish")
@@ -72,17 +69,10 @@ class DuplexTest {
 
   private var listener = RecordingEventListener()
   private val handshakeCertificates = platform.localhostHandshakeCertificates()
-  private val loggingInterceptor =
-    HttpLoggingInterceptor({
-      // Not testing output here, but making sure it doesn't fail
-    }).apply {
-      level = Level.NONE
-    }
   private var client =
     clientTestRule
       .newClientBuilder()
       .eventListenerFactory(clientTestRule.wrap(listener))
-      .addInterceptor(loggingInterceptor)
       .build()
   private val executorService = Executors.newScheduledThreadPool(1)
 
@@ -97,17 +87,9 @@ class DuplexTest {
     executorService.shutdown()
   }
 
-  fun setupLogging(logging: Boolean) {
-    if (logging) {
-      loggingInterceptor.level = Level.STREAMING
-    }
-  }
-
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
+  @Test
   @Throws(IOException::class)
-  fun http1DoesntSupportDuplex(logging: Boolean) {
-    setupLogging(logging)
+  fun http1DoesntSupportDuplex() {
     val call =
       client.newCall(
         Request
@@ -121,10 +103,8 @@ class DuplexTest {
     }
   }
 
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun trueDuplexClientWritesFirst(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun trueDuplexClientWritesFirst() {
     enableProtocol(Protocol.HTTP_2)
     val body =
       MockSocketHandler()
@@ -172,10 +152,8 @@ class DuplexTest {
     body.awaitSuccess()
   }
 
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun trueDuplexServerWritesFirst(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun trueDuplexServerWritesFirst() {
     enableProtocol(Protocol.HTTP_2)
     val body =
       MockSocketHandler()
@@ -223,10 +201,8 @@ class DuplexTest {
     body.awaitSuccess()
   }
 
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun clientReadsHeadersDataTrailers(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun clientReadsHeadersDataTrailers() {
     enableProtocol(Protocol.HTTP_2)
     val body =
       MockSocketHandler()
@@ -260,10 +236,8 @@ class DuplexTest {
     body.awaitSuccess()
   }
 
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun serverReadsHeadersData(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun serverReadsHeadersData() {
     assumeNotWindows()
     enableProtocol(Protocol.HTTP_2)
     val body =
@@ -297,10 +271,8 @@ class DuplexTest {
     body.awaitSuccess()
   }
 
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun requestBodyEndsAfterResponseBody(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun requestBodyEndsAfterResponseBody() {
     enableProtocol(Protocol.HTTP_2)
     val body =
       MockSocketHandler()
@@ -355,10 +327,8 @@ class DuplexTest {
     )
   }
 
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun duplexWith100Continue(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun duplexWith100Continue() {
     enableProtocol(Protocol.HTTP_2)
     val body =
       MockSocketHandler()
@@ -400,10 +370,8 @@ class DuplexTest {
    * already split off another thread to stream the request body. Because we permit at most one
    * exchange at a time we break the request stream out from under that writer.
    */
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun duplexWithRedirect(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun duplexWithRedirect() {
     enableProtocol(Protocol.HTTP_2)
     val duplexResponseSent = CountDownLatch(1)
     listener =
@@ -508,10 +476,8 @@ class DuplexTest {
    * Auth requires follow-ups. Unlike redirects, the auth follow-up also has a request body. This
    * test makes a single call with two duplex requests!
    */
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun duplexWithAuthChallenge(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun duplexWithAuthChallenge() {
     enableProtocol(Protocol.HTTP_2)
     val credential = basic("jesse", "secret")
     client =
@@ -580,10 +546,8 @@ class DuplexTest {
     (call.request().body as AsyncRequestBody?)!!.assertNoMoreSinks()
   }
 
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun fullCallTimeoutAppliesToSetup(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun fullCallTimeoutAppliesToSetup() {
     enableProtocol(Protocol.HTTP_2)
     server.enqueue(
       MockResponse
@@ -607,10 +571,8 @@ class DuplexTest {
     }
   }
 
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun fullCallTimeoutDoesNotApplyOnceConnected(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun fullCallTimeoutDoesNotApplyOnceConnected() {
     enableProtocol(Protocol.HTTP_2)
     val body =
       MockSocketHandler()
@@ -651,10 +613,8 @@ class DuplexTest {
     body.awaitSuccess()
   }
 
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun duplexWithRewriteInterceptors(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun duplexWithRewriteInterceptors() {
     enableProtocol(Protocol.HTTP_2)
     val body =
       MockSocketHandler()
@@ -705,10 +665,8 @@ class DuplexTest {
    * be readable after the request stream is canceled.
    */
   @Disabled
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun serverCancelsRequestBodyAndSendsResponseBody(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun serverCancelsRequestBodyAndSendsResponseBody() {
     client =
       client
         .newBuilder()
@@ -766,10 +724,8 @@ class DuplexTest {
    * We delay sending the last byte of the request body 1500 ms. The 1000 ms read timeout should
    * only elapse 1000 ms after the request body is sent.
    */
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun headersReadTimeoutDoesNotStartUntilLastRequestBodyByteFire(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun headersReadTimeoutDoesNotStartUntilLastRequestBodyByteFire() {
     enableProtocol(Protocol.HTTP_2)
     server.enqueue(
       MockResponse
@@ -797,10 +753,8 @@ class DuplexTest {
   }
 
   /** Same as the previous test, but the server stalls sending the response body.  */
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun bodyReadTimeoutDoesNotStartUntilLastRequestBodyByteFire(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun bodyReadTimeoutDoesNotStartUntilLastRequestBodyByteFire() {
     enableProtocol(Protocol.HTTP_2)
     server.enqueue(
       MockResponse
@@ -833,10 +787,8 @@ class DuplexTest {
    * We delay sending the last byte of the request body 1500 ms. The 1000 ms read timeout shouldn't
    * elapse because it shouldn't start until the request body is sent.
    */
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun headersReadTimeoutDoesNotStartUntilLastRequestBodyByteNoFire(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun headersReadTimeoutDoesNotStartUntilLastRequestBodyByteNoFire() {
     enableProtocol(Protocol.HTTP_2)
     server.enqueue(
       MockResponse
@@ -864,10 +816,8 @@ class DuplexTest {
    * We delay sending the last byte of the request body 1500 ms. The 1000 ms read timeout shouldn't
    * elapse because it shouldn't start until the request body is sent.
    */
-  @ParameterizedTest(name = "logging = {0}")
-  @ValueSource(booleans = [false, true])
-  fun bodyReadTimeoutDoesNotStartUntilLastRequestBodyByteNoFire(logging: Boolean) {
-    setupLogging(logging)
+  @Test
+  fun bodyReadTimeoutDoesNotStartUntilLastRequestBodyByteNoFire() {
     enableProtocol(Protocol.HTTP_2)
     server.enqueue(
       MockResponse
