diff --git a/CHANGELOG.md b/CHANGELOG.md
index 2fee887b3..1896aa987 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -8,6 +8,7 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 ## Unreleased - 2025-??-??
 ### Fixed
 - Fix for an error when a record method has the `@SuppressFBWarnings` annotation ([#3622](https://github.com/spotbugs/spotbugs/pull/3622))
+- Fix `SF_SWITCH_FALLTHROUGH` false positive when continuing a loop ([#3617](https://github.com/spotbugs/spotbugs/issues/3617))
 
 ## 4.9.4 - 2025-08-07
 ### Changed
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/SwitchHandler.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/SwitchHandler.java
index a8f2f6905..19be594ff 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/SwitchHandler.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/SwitchHandler.java
@@ -123,6 +123,27 @@ public class SwitchHandler {
         return -1;
     }
 
+    @CheckForNull
+    public SwitchDetails getNextSwitchDetails(DismantleBytecode dbc) {
+        int size = switchOffsetStack.size();
+        while (size > 0) {
+            SwitchDetails details = switchOffsetStack.get(size - 1);
+
+            int nextSwitchOffset = details.getNextSwitchOffset(dbc.getPC());
+            if (nextSwitchOffset >= 0) {
+                return details;
+            }
+
+            if (dbc.getPC() <= details.getDefaultOffset()) {
+                return null;
+            }
+            switchOffsetStack.remove(size - 1);
+            size--;
+        }
+
+        return null;
+    }
+
     public int getDefaultOffset() {
         int size = switchOffsetStack.size();
         if (size == 0) {
@@ -294,5 +315,12 @@ public class SwitchHandler {
         private int getLastOffset() {
             return swOffsets.length > 0 ? swOffsets[swOffsets.length - 1] : 0;
         }
+
+        /**
+         * @return The PC of the switch instruction
+         */
+        public int getSwitchPC() {
+            return switchPC;
+        }
     }
 }
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java
index 26813a70c..9da85dfd9 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java
@@ -40,6 +40,7 @@ import edu.umd.cs.findbugs.OpcodeStack;
 import edu.umd.cs.findbugs.SourceLineAnnotation;
 import edu.umd.cs.findbugs.StatelessDetector;
 import edu.umd.cs.findbugs.SwitchHandler;
+import edu.umd.cs.findbugs.SwitchHandler.SwitchDetails;
 import edu.umd.cs.findbugs.SystemProperties;
 import edu.umd.cs.findbugs.ba.AnalysisContext;
 import edu.umd.cs.findbugs.ba.ClassContext;
@@ -182,7 +183,7 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
 
         if (isSwitch(seen)
                 || isReturn(seen)
-                || (isBranch(seen) && isBranchTargetAfterNextCaseOffset())) {
+                || (isBranch(seen) && isBranchTargetOutsideOfNextCase())) {
             clearAllDeadStores();
         }
 
@@ -273,7 +274,7 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
 
         case Const.GOTO_W:
         case Const.GOTO:
-            if (isBranchTargetAfterNextCaseOffset() || switchHdlr.getDefaultOffset() == getBranchTarget()) {
+            if (isBranchTargetOutsideOfNextCase() || switchHdlr.getDefaultOffset() == getBranchTarget()) {
                 if (biggestJumpTarget < getBranchTarget()) {
                     biggestJumpTarget = getBranchTarget();
                     if (DEBUG) {
@@ -311,11 +312,24 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
     /**
      * A GOTO might correspond to a <code>break</code> or to a do/while/for loop.
      * For loops the branch target will be before the offset of the next case, for breaks we're exiting the switch so the target is actually even after the end of the last case.
+     * The branch target might be before the switch when we're inside another structure such as a loop.
      *
-     * @return <code>true</code> if the branch target is after the next switch offset as it is the case for a switch break.
+     * @return <code>true</code> if:
+     * <ul>
+     * <li> the branch target is after the next switch offset as it is the case for a switch break</li>
+     * <li> or the branch target is before the PC corresponding to the switch instruction</li>
+     * <li> or there's no next switch case (as it is the case for the default case)</li>
+     * </ul>
      */
-    public boolean isBranchTargetAfterNextCaseOffset() {
-        return getBranchTarget() > switchHdlr.getNextSwitchOffset(this);
+    public boolean isBranchTargetOutsideOfNextCase() {
+        int branchTarget = getBranchTarget();
+        SwitchDetails nextSwitchDetails = switchHdlr.getNextSwitchDetails(this);
+
+        if (nextSwitchDetails != null) {
+            return branchTarget > nextSwitchDetails.getNextSwitchOffset(getPC()) || branchTarget < nextSwitchDetails.getSwitchPC();
+        } else {
+            return true;
+        }
     }
 
     boolean justSawHashcode;
diff --git a/spotbugsTestCases/src/java/ghIssues/Issue3617.java b/spotbugsTestCases/src/java/ghIssues/Issue3617.java
new file mode 100644
index 000000000..0ade5f3ea
--- /dev/null
+++ b/spotbugsTestCases/src/java/ghIssues/Issue3617.java
@@ -0,0 +1,45 @@
+package ghIssues;
+
+public abstract class Issue3617 {
+
+	private static final int IDLE = 0;
+	private static final int REQUIRED = 1;
+	private static final int PROCESSING_TO_IDLE = 2;
+	private static final int PROCESSING_TO_REQUIRED = 3;
+
+	void scheduleAfterWrite() {
+		int drainStatus = drainStatusOpaque();
+		for (;;) {
+			switch (drainStatus) {
+			case IDLE:
+				casDrainStatus(IDLE, REQUIRED);
+				scheduleDrainBuffers();
+				return;
+			case REQUIRED:
+				scheduleDrainBuffers();
+				return;
+			case PROCESSING_TO_IDLE:
+				if (casDrainStatus(PROCESSING_TO_IDLE, PROCESSING_TO_REQUIRED)) {
+					return;
+				}
+				drainStatus = drainStatusOpaque();
+				continue;
+			case PROCESSING_TO_REQUIRED:
+				return;
+			default:
+				throw new IllegalStateException("Invalid drain status: " + drainStatus);
+			}
+		}
+	}
+
+	public void scheduleDrainBuffers() {
+	}
+
+	public boolean casDrainStatus(int idle2, int required2) {
+		return false;
+	}
+
+	public int drainStatusOpaque() {
+		return 0;
+	}
+}
