diff --git a/docs/src/main/asciidoc/scheduler-reference.adoc b/docs/src/main/asciidoc/scheduler-reference.adoc
index eda9ea20371..031380b177f 100644
--- a/docs/src/main/asciidoc/scheduler-reference.adoc
+++ b/docs/src/main/asciidoc/scheduler-reference.adoc
@@ -575,45 +575,6 @@ In this case, the method is invoked on a virtual thread.
 The method must return `void` and your Java runtime must provide support for virtual threads.
 Read xref:./virtual-threads.adoc[the virtual thread guide] for more details.
 
-== Assign a user and roles to a scheduled task
-
-You can use the `@RunAsUser` annotation on methods annotated with the `@Scheduled` annotation to configure the `SecurityIdentity` for the task execution.
-The `@RunAsUser` annotation works only for the scheduled tasks.
-
-.Example scheduled task with `@RunAsUser`
-[source,java]
-----
-import io.quarkus.scheduler.Scheduled;
-import io.quarkus.security.identity.RunAsUser;
-import jakarta.annotation.security.RolesAllowed;
-import jakarta.enterprise.context.ApplicationScoped;
-
-class MyJob {
-
-    @Inject
-    MyService myService;
-
-    @RunAsUser(user = "Alice", roles = "admin") <1>
-    @Scheduled(every = "1s")
-    void updateTask() {
-        myService.update();   <2>
-    }
-
-}
-
-@ApplicationScoped
-class MyService {
-
-    @RolesAllowed("admin")
-    void update() { }
-
-}
-----
-<1> Assign the user `Alice` to the scheduled `updateTask`.
-<2> The call to the `MyService#update` method succeeds, because the configured user has role `admin`.
-
-IMPORTANT: The `@RunAsUser` annotation creates an identity for scheduled tasks. It does not temporarily replace the current identity.
-
 == Configuration Reference
 
 include::{generated-dir}/config/quarkus-scheduler.adoc[leveloffset=+1, opts=optional]
diff --git a/extensions/quartz/deployment/src/test/java/io/quarkus/quartz/test/security/QuartzSchedulerRunAsUserTest.java b/extensions/quartz/deployment/src/test/java/io/quarkus/quartz/test/security/QuartzSchedulerRunAsUserTest.java
deleted file mode 100644
index 99f4053f0b3..00000000000
--- a/extensions/quartz/deployment/src/test/java/io/quarkus/quartz/test/security/QuartzSchedulerRunAsUserTest.java
+++ /dev/null
@@ -1,236 +0,0 @@
-package io.quarkus.quartz.test.security;
-
-import static io.quarkus.scheduler.Scheduled.QUARTZ;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.fail;
-import static org.junit.jupiter.api.Assertions.assertNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.CompletionStage;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import jakarta.annotation.security.RolesAllowed;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.maven.dependency.Dependency;
-import io.quarkus.scheduler.Scheduled;
-import io.quarkus.security.Authenticated;
-import io.quarkus.security.ForbiddenException;
-import io.quarkus.security.UnauthorizedException;
-import io.quarkus.security.identity.RunAsUser;
-import io.quarkus.test.QuarkusUnitTest;
-import io.smallrye.mutiny.Uni;
-
-class QuartzSchedulerRunAsUserTest {
-
-    private static final String UNAUTHENTICATED_SCHEDULER = "unauthenticated";
-    private static final String AUTHENTICATED_SCHEDULER = "authenticated";
-    private static final String FORBIDDEN_SCHEDULER = "forbidden";
-    private static final String AUTHORIZED_SCHEDULER = "authorized";
-
-    @RegisterExtension
-    static final QuarkusUnitTest test = new QuarkusUnitTest()
-            .withApplicationRoot((jar) -> jar.addClasses(Scheduler.class, SecuredBean.class, StaticScheduler.class))
-            .setForcedDependencies(List.of(Dependency.of("io.quarkus", "quarkus-security")));
-
-    @Inject
-    Scheduler scheduler;
-
-    @Test
-    void testRunAsUserAnnotationOnBeanMethods() throws InterruptedException {
-        for (var e : scheduler.getLatchMap().entrySet()) {
-            var latchKey = e.getKey();
-            var latch = e.getValue();
-            var result = latch.await(5, TimeUnit.SECONDS);
-            assertTrue(result, () -> "Latch " + latchKey + " did not count down in time");
-            var failure = scheduler.getLatchKeyToFailure().get(latchKey);
-            assertNull(failure, () -> "Test for latch '" + latchKey + "' failed over: " + failure);
-        }
-    }
-
-    @Test
-    void testRunAsUserAnnotationOnStaticMethod() throws InterruptedException {
-        var result = StaticScheduler.LATCH.await(5, TimeUnit.SECONDS);
-        assertTrue(result, "Latch on static scheduler did not count down in time");
-        if (StaticScheduler.authenticatedTestFailure != null) {
-            fail("Static scheduler should succeed when calling method that requires authentication",
-                    StaticScheduler.authenticatedTestFailure);
-        }
-        if (StaticScheduler.rolesAllowedTestFailure != null) {
-            fail("Static scheduler should succeed when calling to method that requires 'user' role",
-                    StaticScheduler.rolesAllowedTestFailure);
-        }
-        if (StaticScheduler.forbiddenTestFailure == null) {
-            fail("Static scheduler should fail when calling to method that requires 'admin' role");
-        }
-        assertThat(StaticScheduler.forbiddenTestFailure).isInstanceOf(ForbiddenException.class);
-    }
-
-    static class StaticScheduler {
-
-        private static final CountDownLatch LATCH = new CountDownLatch(1);
-        private static volatile boolean run = false;
-        private static Throwable forbiddenTestFailure = null;
-        private static Throwable authenticatedTestFailure = null;
-        private static Throwable rolesAllowedTestFailure = null;
-
-        @RunAsUser(user = "Elliott", roles = "user")
-        @Scheduled(every = "1s", executeWith = QUARTZ)
-        static void everySecond() {
-            if (!run) {
-                run = true;
-                try {
-                    authenticated();
-                } catch (Throwable throwable) {
-                    authenticatedTestFailure = throwable;
-                }
-                try {
-                    rolesAllowedUser();
-                } catch (Throwable throwable) {
-                    rolesAllowedTestFailure = throwable;
-                }
-                try {
-                    rolesAllowedAdmin();
-                } catch (Throwable throwable) {
-                    forbiddenTestFailure = throwable;
-                }
-                LATCH.countDown();
-            }
-        }
-
-        @Authenticated
-        static void authenticated() {
-
-        }
-
-        @RolesAllowed("user")
-        static void rolesAllowedUser() {
-
-        }
-
-        @RolesAllowed("admin")
-        static void rolesAllowedAdmin() {
-
-        }
-
-    }
-
-    @ApplicationScoped
-    static class Scheduler {
-
-        private final Map<String, CountDownLatch> latchMap;
-        private final Map<String, Throwable> latchKeyToFailure;
-        private final SecuredBean securedBean;
-
-        Scheduler(SecuredBean securedBean) {
-            this.latchKeyToFailure = new ConcurrentHashMap<>();
-            this.latchMap = Map.of(
-                    UNAUTHENTICATED_SCHEDULER, new CountDownLatch(2),
-                    FORBIDDEN_SCHEDULER, new CountDownLatch(2),
-                    AUTHORIZED_SCHEDULER, new CountDownLatch(2),
-                    AUTHENTICATED_SCHEDULER, new CountDownLatch(2));
-            this.securedBean = securedBean;
-        }
-
-        @Scheduled(every = "1s", executeWith = QUARTZ)
-        void noRunAsUserAnnotation() {
-            runTest(UNAUTHENTICATED_SCHEDULER, () -> {
-                try {
-                    securedBean.authenticated();
-                } catch (UnauthorizedException ignored) {
-                    return;
-                }
-                throw new AssertionError("Authorization should fail for scheduled method 'noRunAsUserAnnotation'");
-            });
-        }
-
-        @RunAsUser(user = "Quentin")
-        @Scheduled(every = "1s", executeWith = QUARTZ)
-        void runAsUserAnnotationWithVoidReturnType() {
-            runTest(AUTHENTICATED_SCHEDULER, () -> {
-                try {
-                    securedBean.authenticated();
-                } catch (UnauthorizedException exception) {
-                    throw new AssertionError(
-                            "Authorization should not fail for scheduled method 'runAsUserAnnotationWithVoidReturnType'",
-                            exception);
-                }
-            });
-        }
-
-        @RunAsUser(user = "Julia", roles = "user")
-        @Scheduled(every = "1s", executeWith = QUARTZ)
-        Uni<Void> runAsUserAnnotationWithUniReturnType() {
-            return Uni.createFrom().item(() -> {
-                runTest(FORBIDDEN_SCHEDULER, () -> {
-                    try {
-                        securedBean.rolesAllowedAdmin();
-                    } catch (ForbiddenException exception) {
-                        return;
-                    }
-                    throw new AssertionError(
-                            "Authorization should fail for scheduled method 'runAsUserAnnotationWithUniReturnType'");
-                });
-                return null;
-            });
-        }
-
-        @RunAsUser(user = "Alice", roles = "admin")
-        @Scheduled(every = "1s", executeWith = QUARTZ)
-        CompletionStage<Void> runAsUserAnnotationWithCompletionStageReturnType() {
-            return Uni.createFrom().<Void> item(() -> {
-                runTest(AUTHORIZED_SCHEDULER, () -> {
-                    try {
-                        securedBean.rolesAllowedAdmin();
-                    } catch (ForbiddenException exception) {
-                        throw new AssertionError(
-                                "Authorization should not fail for scheduled method 'runAsUserAnnotationWithCompletionStageReturnType'",
-                                exception);
-                    }
-                });
-                return null;
-            }).subscribeAsCompletionStage();
-        }
-
-        private void runTest(String latchKey, Runnable test) {
-            try {
-                test.run();
-            } catch (Throwable failure) {
-                latchKeyToFailure.put(latchKey, failure);
-            }
-            latchMap.get(latchKey).countDown();
-        }
-
-        Map<String, CountDownLatch> getLatchMap() {
-            return latchMap;
-        }
-
-        Map<String, Throwable> getLatchKeyToFailure() {
-            return latchKeyToFailure;
-        }
-    }
-
-    @ApplicationScoped
-    static class SecuredBean {
-
-        @Authenticated
-        void authenticated() {
-
-        }
-
-        @RolesAllowed("admin")
-        void rolesAllowedAdmin() {
-
-        }
-
-    }
-
-}
diff --git a/extensions/scheduler/deployment/pom.xml b/extensions/scheduler/deployment/pom.xml
index a56897d4bcf..f468fc301c5 100644
--- a/extensions/scheduler/deployment/pom.xml
+++ b/extensions/scheduler/deployment/pom.xml
@@ -38,10 +38,6 @@
           <groupId>io.quarkus</groupId>
           <artifactId>quarkus-assistant-deployment-spi</artifactId>
       </dependency>
-      <dependency>
-          <groupId>io.quarkus</groupId>
-          <artifactId>quarkus-security-spi</artifactId>
-      </dependency>
       <dependency>
           <groupId>io.quarkus</groupId>
           <artifactId>quarkus-vertx-http-deployment</artifactId>
diff --git a/extensions/scheduler/deployment/src/main/java/io/quarkus/scheduler/deployment/SchedulerProcessor.java b/extensions/scheduler/deployment/src/main/java/io/quarkus/scheduler/deployment/SchedulerProcessor.java
index 14404021a9a..61b6a69e820 100644
--- a/extensions/scheduler/deployment/src/main/java/io/quarkus/scheduler/deployment/SchedulerProcessor.java
+++ b/extensions/scheduler/deployment/src/main/java/io/quarkus/scheduler/deployment/SchedulerProcessor.java
@@ -95,7 +95,6 @@
 import io.quarkus.scheduler.runtime.SchedulerConfig;
 import io.quarkus.scheduler.runtime.SchedulerRecorder;
 import io.quarkus.scheduler.runtime.SimpleScheduler;
-import io.quarkus.security.spi.RunAsUserPredicateBuildItem;
 import io.smallrye.common.annotation.Identifier;
 
 public class SchedulerProcessor {
@@ -757,8 +756,4 @@ void produceCoroutineScope(BuildProducer<AdditionalBeanBuildItem> buildItemBuild
                 .setUnremovable().build());
     }
 
-    @BuildStep
-    RunAsUserPredicateBuildItem allowRunAsUserAnnotationForScheduledMethods() {
-        return RunAsUserPredicateBuildItem.ofAnnotation(Scheduled.class);
-    }
 }
diff --git a/extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/security/SimpleSchedulerRunAsUserTest.java b/extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/security/SimpleSchedulerRunAsUserTest.java
deleted file mode 100644
index 4d89c684ae9..00000000000
--- a/extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/security/SimpleSchedulerRunAsUserTest.java
+++ /dev/null
@@ -1,235 +0,0 @@
-package io.quarkus.scheduler.test.security;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.fail;
-import static org.junit.jupiter.api.Assertions.assertNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.CompletionStage;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-import jakarta.annotation.security.RolesAllowed;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.maven.dependency.Dependency;
-import io.quarkus.scheduler.Scheduled;
-import io.quarkus.security.Authenticated;
-import io.quarkus.security.ForbiddenException;
-import io.quarkus.security.UnauthorizedException;
-import io.quarkus.security.identity.RunAsUser;
-import io.quarkus.test.QuarkusUnitTest;
-import io.smallrye.mutiny.Uni;
-
-class SimpleSchedulerRunAsUserTest {
-
-    private static final String UNAUTHENTICATED_SCHEDULER = "unauthenticated";
-    private static final String AUTHENTICATED_SCHEDULER = "authenticated";
-    private static final String FORBIDDEN_SCHEDULER = "forbidden";
-    private static final String AUTHORIZED_SCHEDULER = "authorized";
-
-    @RegisterExtension
-    static final QuarkusUnitTest test = new QuarkusUnitTest()
-            .withApplicationRoot((jar) -> jar.addClasses(Scheduler.class, SecuredBean.class, StaticScheduler.class))
-            .setForcedDependencies(List.of(Dependency.of("io.quarkus", "quarkus-security")));
-
-    @Inject
-    Scheduler scheduler;
-
-    @Test
-    void testRunAsUserAnnotationOnBeanMethods() throws InterruptedException {
-        for (var e : scheduler.getLatchMap().entrySet()) {
-            var latchKey = e.getKey();
-            var latch = e.getValue();
-            var result = latch.await(5, TimeUnit.SECONDS);
-            assertTrue(result, () -> "Latch " + latchKey + " did not count down in time");
-            var failure = scheduler.getLatchKeyToFailure().get(latchKey);
-            assertNull(failure, () -> "Test for latch '" + latchKey + "' failed over: " + failure);
-        }
-    }
-
-    @Test
-    void testRunAsUserAnnotationOnStaticMethod() throws InterruptedException {
-        var result = StaticScheduler.LATCH.await(5, TimeUnit.SECONDS);
-        assertTrue(result, "Latch on static scheduler did not count down in time");
-        if (StaticScheduler.authenticatedTestFailure != null) {
-            fail("Static scheduler should succeed when calling method that requires authentication",
-                    StaticScheduler.authenticatedTestFailure);
-        }
-        if (StaticScheduler.rolesAllowedTestFailure != null) {
-            fail("Static scheduler should succeed when calling to method that requires 'user' role",
-                    StaticScheduler.rolesAllowedTestFailure);
-        }
-        if (StaticScheduler.forbiddenTestFailure == null) {
-            fail("Static scheduler should fail when calling to method that requires 'admin' role");
-        }
-        assertThat(StaticScheduler.forbiddenTestFailure).isInstanceOf(ForbiddenException.class);
-    }
-
-    static class StaticScheduler {
-
-        private static final CountDownLatch LATCH = new CountDownLatch(1);
-        private static volatile boolean run = false;
-        private static Throwable forbiddenTestFailure = null;
-        private static Throwable authenticatedTestFailure = null;
-        private static Throwable rolesAllowedTestFailure = null;
-
-        @RunAsUser(user = "Elliott", roles = "user")
-        @Scheduled(every = "1s")
-        static void everySecond() {
-            if (!run) {
-                run = true;
-                try {
-                    authenticated();
-                } catch (Throwable throwable) {
-                    authenticatedTestFailure = throwable;
-                }
-                try {
-                    rolesAllowedUser();
-                } catch (Throwable throwable) {
-                    rolesAllowedTestFailure = throwable;
-                }
-                try {
-                    rolesAllowedAdmin();
-                } catch (Throwable throwable) {
-                    forbiddenTestFailure = throwable;
-                }
-                LATCH.countDown();
-            }
-        }
-
-        @Authenticated
-        static void authenticated() {
-
-        }
-
-        @RolesAllowed("user")
-        static void rolesAllowedUser() {
-
-        }
-
-        @RolesAllowed("admin")
-        static void rolesAllowedAdmin() {
-
-        }
-
-    }
-
-    @ApplicationScoped
-    static class Scheduler {
-
-        private final Map<String, CountDownLatch> latchMap;
-        private final Map<String, Throwable> latchKeyToFailure;
-        private final SecuredBean securedBean;
-
-        Scheduler(SecuredBean securedBean) {
-            this.latchKeyToFailure = new ConcurrentHashMap<>();
-            this.latchMap = Map.of(
-                    UNAUTHENTICATED_SCHEDULER, new CountDownLatch(2),
-                    FORBIDDEN_SCHEDULER, new CountDownLatch(2),
-                    AUTHORIZED_SCHEDULER, new CountDownLatch(2),
-                    AUTHENTICATED_SCHEDULER, new CountDownLatch(2));
-            this.securedBean = securedBean;
-        }
-
-        @Scheduled(every = "1s")
-        void noRunAsUserAnnotation() {
-            runTest(UNAUTHENTICATED_SCHEDULER, () -> {
-                try {
-                    securedBean.authenticated();
-                } catch (UnauthorizedException ignored) {
-                    return;
-                }
-                throw new AssertionError("Authorization should fail for scheduled method 'noRunAsUserAnnotation'");
-            });
-        }
-
-        @RunAsUser(user = "Quentin")
-        @Scheduled(every = "1s")
-        void runAsUserAnnotationWithVoidReturnType() {
-            runTest(AUTHENTICATED_SCHEDULER, () -> {
-                try {
-                    securedBean.authenticated();
-                } catch (UnauthorizedException exception) {
-                    throw new AssertionError(
-                            "Authorization should not fail for scheduled method 'runAsUserAnnotationWithVoidReturnType'",
-                            exception);
-                }
-            });
-        }
-
-        @RunAsUser(user = "Julia", roles = "user")
-        @Scheduled(every = "1s")
-        Uni<Void> runAsUserAnnotationWithUniReturnType() {
-            return Uni.createFrom().item(() -> {
-                runTest(FORBIDDEN_SCHEDULER, () -> {
-                    try {
-                        securedBean.rolesAllowedAdmin();
-                    } catch (ForbiddenException exception) {
-                        return;
-                    }
-                    throw new AssertionError(
-                            "Authorization should fail for scheduled method 'runAsUserAnnotationWithUniReturnType'");
-                });
-                return null;
-            });
-        }
-
-        @RunAsUser(user = "Alice", roles = "admin")
-        @Scheduled(every = "1s")
-        CompletionStage<Void> runAsUserAnnotationWithCompletionStageReturnType() {
-            return Uni.createFrom().<Void> item(() -> {
-                runTest(AUTHORIZED_SCHEDULER, () -> {
-                    try {
-                        securedBean.rolesAllowedAdmin();
-                    } catch (ForbiddenException exception) {
-                        throw new AssertionError(
-                                "Authorization should not fail for scheduled method 'runAsUserAnnotationWithCompletionStageReturnType'",
-                                exception);
-                    }
-                });
-                return null;
-            }).subscribeAsCompletionStage();
-        }
-
-        private void runTest(String latchKey, Runnable test) {
-            try {
-                test.run();
-            } catch (Throwable failure) {
-                latchKeyToFailure.put(latchKey, failure);
-            }
-            latchMap.get(latchKey).countDown();
-        }
-
-        Map<String, CountDownLatch> getLatchMap() {
-            return latchMap;
-        }
-
-        Map<String, Throwable> getLatchKeyToFailure() {
-            return latchKeyToFailure;
-        }
-    }
-
-    @ApplicationScoped
-    static class SecuredBean {
-
-        @Authenticated
-        void authenticated() {
-
-        }
-
-        @RolesAllowed("admin")
-        void rolesAllowedAdmin() {
-
-        }
-
-    }
-
-}
diff --git a/extensions/security/deployment/src/main/java/io/quarkus/security/deployment/SecurityProcessor.java b/extensions/security/deployment/src/main/java/io/quarkus/security/deployment/SecurityProcessor.java
index 7ca52db99cc..ce7c6bb1b9f 100644
--- a/extensions/security/deployment/src/main/java/io/quarkus/security/deployment/SecurityProcessor.java
+++ b/extensions/security/deployment/src/main/java/io/quarkus/security/deployment/SecurityProcessor.java
@@ -71,7 +71,6 @@
 import io.quarkus.arc.processor.AnnotationStore;
 import io.quarkus.arc.processor.BuildExtension;
 import io.quarkus.arc.processor.BuiltinScope;
-import io.quarkus.arc.processor.InterceptorBindingRegistrar;
 import io.quarkus.arc.processor.ObserverInfo;
 import io.quarkus.builder.item.MultiBuildItem;
 import io.quarkus.builder.item.SimpleBuildItem;
@@ -115,7 +114,6 @@
 import io.quarkus.security.Authenticated;
 import io.quarkus.security.PermissionsAllowed;
 import io.quarkus.security.deployment.PermissionSecurityChecks.PermissionSecurityChecksBuilder;
-import io.quarkus.security.identity.RunAsUser;
 import io.quarkus.security.identity.SecurityIdentityAugmentor;
 import io.quarkus.security.runtime.IdentityProviderManagerCreator;
 import io.quarkus.security.runtime.PrincipalProducer;
@@ -132,7 +130,6 @@
 import io.quarkus.security.runtime.interceptor.PermissionsAllowedInterceptor;
 import io.quarkus.security.runtime.interceptor.PermitAllInterceptor;
 import io.quarkus.security.runtime.interceptor.RolesAllowedInterceptor;
-import io.quarkus.security.runtime.interceptor.RunAsUserInterceptor;
 import io.quarkus.security.runtime.interceptor.SecurityCheckStorageBuilder;
 import io.quarkus.security.runtime.interceptor.SecurityConstrainer;
 import io.quarkus.security.runtime.interceptor.SecurityHandler;
@@ -147,7 +144,6 @@
 import io.quarkus.security.spi.PermissionsAllowedMetaAnnotationBuildItem;
 import io.quarkus.security.spi.RegisterClassSecurityCheckBuildItem;
 import io.quarkus.security.spi.RolesAllowedConfigExpResolverBuildItem;
-import io.quarkus.security.spi.RunAsUserPredicateBuildItem;
 import io.quarkus.security.spi.SecuredInterfaceAnnotationBuildItem;
 import io.quarkus.security.spi.SecurityTransformer;
 import io.quarkus.security.spi.SecurityTransformer.AuthorizationType;
@@ -1315,52 +1311,6 @@ void gatherClassSecurityChecks(BuildProducer<RegisterClassSecurityCheckBuildItem
         }
     }
 
-    @BuildStep
-    InterceptorBindingRegistrarBuildItem registerRunAsUserInterceptorBinding() {
-        return new InterceptorBindingRegistrarBuildItem(new InterceptorBindingRegistrar() {
-            @Override
-            public List<InterceptorBinding> getAdditionalBindings() {
-                return List.of(InterceptorBindingRegistrar.InterceptorBinding.of(RunAsUser.class, m -> true));
-            }
-        });
-    }
-
-    @BuildStep
-    void registerRunAsUserInterceptorBean(BuildProducer<AnnotationsTransformerBuildItem> annotationsTransformerProducer,
-            BuildProducer<AdditionalBeanBuildItem> additionalBeanProducer) {
-        annotationsTransformerProducer.produce(new AnnotationsTransformerBuildItem(AnnotationTransformation
-                .forClasses().whenClass(RunAsUserInterceptor.class)
-                .transform(tc -> tc.add(AnnotationInstance.builder(RunAsUser.class).add("user", "").build()))));
-        additionalBeanProducer.produce(AdditionalBeanBuildItem.unremovableOf(RunAsUserInterceptor.class));
-    }
-
-    @BuildStep
-    void validateRunAsUserUsage(List<RunAsUserPredicateBuildItem> runAsUserPredicates,
-            BeanArchiveIndexBuildItem beanArchiveIndexBuildItem,
-            BuildProducer<ValidationErrorBuildItem> errors) {
-        var annotationInstances = beanArchiveIndexBuildItem.getIndex().getAnnotations(RunAsUser.class);
-        if (annotationInstances.isEmpty()) {
-            return;
-        }
-
-        var targetNotAllowedPredicate = Predicate.not(RunAsUserPredicateBuildItem.get(runAsUserPredicates));
-        var notAllowedTargets = annotationInstances.stream()
-                .map(AnnotationInstance::target)
-                .filter(targetNotAllowedPredicate)
-                .map(AnnotationTarget::asMethod)
-                .map(SecurityProcessor::toString)
-                .collect(Collectors.joining(", "));
-        if (!notAllowedTargets.isEmpty()) {
-            errors.produce(
-                    new ValidationErrorBuildItem(new RuntimeException("Annotation '%s' cannot be used on following methods: %s"
-                            .formatted(RunAsUser.class.getName(), notAllowedTargets))));
-        }
-    }
-
-    private static String toString(MethodInfo mi) {
-        return "%s#%s".formatted(mi.declaringClass().name().toString(), mi.name());
-    }
-
     private static boolean hasClassLevelStandardSecurityAnnotation(MethodInfo method, AnnotationStore annotationStore,
             SecurityTransformer securityTransformer) {
         return applyClassLevenInterceptor(method, annotationStore)
diff --git a/extensions/security/deployment/src/test/java/io/quarkus/security/test/runasuser/RunAsUserMissingAnnotationValidationFailureTest.java b/extensions/security/deployment/src/test/java/io/quarkus/security/test/runasuser/RunAsUserMissingAnnotationValidationFailureTest.java
deleted file mode 100644
index 73d7c076872..00000000000
--- a/extensions/security/deployment/src/test/java/io/quarkus/security/test/runasuser/RunAsUserMissingAnnotationValidationFailureTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package io.quarkus.security.test.runasuser;
-
-import static org.junit.jupiter.api.Assertions.assertInstanceOf;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.security.identity.RunAsUser;
-import io.quarkus.test.QuarkusUnitTest;
-
-class RunAsUserMissingAnnotationValidationFailureTest {
-
-    @RegisterExtension
-    static final QuarkusUnitTest config = new QuarkusUnitTest().withEmptyApplication()
-            .assertException(t -> {
-                assertInstanceOf(RuntimeException.class, t);
-                String exceptionMessage = t.getMessage();
-                assertNotNull(exceptionMessage);
-                String expectedFailure1 = "cannot be used on following methods";
-                assertTrue(exceptionMessage.contains(expectedFailure1),
-                        () -> "Expected failure message to contain '%s', but got: %s".formatted(expectedFailure1,
-                                exceptionMessage));
-                String expectedFailure2 = "RunAsUserMissingAnnotationValidationFailureTest#runTest";
-                assertTrue(exceptionMessage.contains(expectedFailure2),
-                        () -> "Expected failure message to contain '%s', but got: %s".formatted(expectedFailure2,
-                                exceptionMessage));
-            });
-
-    @RunAsUser(user = "ignored")
-    @Test
-    void runTest() {
-        fail("Expected validation failure.");
-    }
-
-}
diff --git a/extensions/security/deployment/src/test/java/io/quarkus/security/test/runasuser/RunAsUserSecurityAnnotationsTest.java b/extensions/security/deployment/src/test/java/io/quarkus/security/test/runasuser/RunAsUserSecurityAnnotationsTest.java
deleted file mode 100644
index f472b3b739b..00000000000
--- a/extensions/security/deployment/src/test/java/io/quarkus/security/test/runasuser/RunAsUserSecurityAnnotationsTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package io.quarkus.security.test.runasuser;
-
-import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-
-import jakarta.annotation.security.RolesAllowed;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.enterprise.context.control.ActivateRequestContext;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.security.Authenticated;
-import io.quarkus.security.ForbiddenException;
-import io.quarkus.security.identity.RunAsUser;
-import io.quarkus.security.spi.RunAsUserPredicateBuildItem;
-import io.quarkus.test.QuarkusUnitTest;
-
-@ActivateRequestContext
-class RunAsUserSecurityAnnotationsTest {
-
-    @RegisterExtension
-    static final QuarkusUnitTest config = new QuarkusUnitTest().withApplicationRoot((jar) -> jar.addClass(SecuredBean.class))
-            .addBuildChainCustomizer(b -> b
-                    .addBuildStep(context -> context.produce(RunAsUserPredicateBuildItem.ofAnnotation(Test.class)))
-                    .produces(RunAsUserPredicateBuildItem.class).build());
-
-    @Inject
-    SecuredBean securedBean;
-
-    @RunAsUser(user = "Martin")
-    @Test
-    void testAuthenticated() {
-        assertDoesNotThrow(securedBean::authenticated);
-        assertThrows(ForbiddenException.class, securedBean::rolesAllowedAdmin);
-    }
-
-    @RunAsUser(user = "Merlin", roles = { "admin", "user" })
-    @Test
-    void testRolesAllowed() {
-        assertDoesNotThrow(securedBean::rolesAllowedAdmin);
-        assertDoesNotThrow(securedBean::rolesAllowedUser);
-        assertThrows(ForbiddenException.class, securedBean::rolesAllowedOther);
-    }
-
-    @ApplicationScoped
-    static class SecuredBean {
-
-        @Authenticated
-        void authenticated() {
-
-        }
-
-        @RolesAllowed("admin")
-        void rolesAllowedAdmin() {
-
-        }
-
-        @RolesAllowed("user")
-        void rolesAllowedUser() {
-
-        }
-
-        @RolesAllowed("other")
-        void rolesAllowedOther() {
-
-        }
-
-    }
-}
diff --git a/extensions/security/deployment/src/test/java/io/quarkus/security/test/runasuser/RunAsUserSecurityBeansTest.java b/extensions/security/deployment/src/test/java/io/quarkus/security/test/runasuser/RunAsUserSecurityBeansTest.java
deleted file mode 100644
index 372e167f178..00000000000
--- a/extensions/security/deployment/src/test/java/io/quarkus/security/test/runasuser/RunAsUserSecurityBeansTest.java
+++ /dev/null
@@ -1,241 +0,0 @@
-package io.quarkus.security.test.runasuser;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-import java.security.Principal;
-import java.util.Set;
-import java.util.concurrent.CompletionStage;
-
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.enterprise.context.control.ActivateRequestContext;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.security.identity.CurrentIdentityAssociation;
-import io.quarkus.security.identity.RunAsUser;
-import io.quarkus.security.identity.SecurityIdentity;
-import io.quarkus.security.spi.RunAsUserPredicateBuildItem;
-import io.quarkus.test.QuarkusUnitTest;
-import io.smallrye.mutiny.Uni;
-
-@ActivateRequestContext
-class RunAsUserSecurityBeansTest {
-
-    @RegisterExtension
-    static final QuarkusUnitTest config = new QuarkusUnitTest()
-            .withApplicationRoot((jar) -> jar.addClasses(WhoAmIBean.class, FakeScheduled.class))
-            .addBuildChainCustomizer(b -> b
-                    .addBuildStep(context -> context.produce(RunAsUserPredicateBuildItem.ofAnnotation(FakeScheduled.class)))
-                    .produces(RunAsUserPredicateBuildItem.class).build());
-
-    @Inject
-    WhoAmIBean whoAmIBean;
-
-    @BeforeEach
-    void resetReturnValues() {
-        whoAmIBean.reset();
-    }
-
-    @Test
-    void testPrincipalName_Wrapper() {
-        // return type: Void
-        whoAmIBean.getFromPrincipal_Wrapper();
-        assertEquals("Mirek", whoAmIBean.getReturnedPrincipalName());
-    }
-
-    @Test
-    void testPrincipalName() {
-        // return type: void
-        whoAmIBean.getFromPrincipal();
-        assertEquals("Mirek", whoAmIBean.getReturnedPrincipalName());
-    }
-
-    @Test
-    void testSecurityIdentity() {
-        whoAmIBean.getFromIdentityWithoutRoles();
-        assertEquals("Marek", whoAmIBean.getReturnedPrincipalName());
-        assertEquals(0, whoAmIBean.getReturnedRoles().size());
-    }
-
-    @Test
-    void testSecurityIdentityRoles() {
-        whoAmIBean.getFromIdentityWithRoles();
-        assertEquals("Milan", whoAmIBean.getReturnedPrincipalName());
-        var roles = whoAmIBean.getReturnedRoles();
-        assertEquals(2, roles.size());
-        assertTrue(roles.contains("user"));
-        assertTrue(roles.contains("admin"));
-    }
-
-    @Test
-    void testCurrentIdentityAssociation() {
-        whoAmIBean.getFromCurrentIdentityAssociation();
-        assertEquals("Michal", whoAmIBean.getReturnedPrincipalName());
-    }
-
-    @Test
-    void testPrincipalName_Uni() {
-        whoAmIBean.getFromPrincipal_Uni().await().indefinitely();
-        assertEquals("Mirek", whoAmIBean.getReturnedPrincipalName());
-    }
-
-    @Test
-    void testSecurityIdentity_Uni() {
-        whoAmIBean.getFromIdentityWithoutRoles_Uni().await().indefinitely();
-        assertEquals("Marek", whoAmIBean.getReturnedPrincipalName());
-        assertEquals(0, whoAmIBean.getReturnedRoles().size());
-    }
-
-    @Test
-    void testSecurityIdentityRoles_Uni() {
-        whoAmIBean.getFromIdentityWithRoles_Uni().await().indefinitely();
-        assertEquals("Milan", whoAmIBean.getReturnedPrincipalName());
-        var roles = whoAmIBean.getReturnedRoles();
-        assertEquals(2, roles.size());
-        assertTrue(roles.contains("user"));
-        assertTrue(roles.contains("admin"));
-    }
-
-    @Test
-    void testCurrentIdentityAssociation_Uni() {
-        whoAmIBean.getFromCurrentIdentityAssociation_Uni().await().indefinitely();
-        assertEquals("Michal", whoAmIBean.getReturnedPrincipalName());
-        assertEquals(0, whoAmIBean.getReturnedRoles().size());
-    }
-
-    @Test
-    void testCurrentIdentityAssociation_CompletionStage() {
-        whoAmIBean.getFromCurrentIdentityAssociation_CompletionStage().toCompletableFuture().join();
-        assertEquals("Michal", whoAmIBean.getReturnedPrincipalName());
-        assertEquals(0, whoAmIBean.getReturnedRoles().size());
-    }
-
-    @ApplicationScoped
-    static class WhoAmIBean {
-
-        private volatile String returnedPrincipalName;
-        private volatile Set<String> returnedRoles;
-
-        @Inject
-        Principal principal;
-
-        @Inject
-        SecurityIdentity securityIdentity;
-
-        @Inject
-        CurrentIdentityAssociation currentIdentityAssociation;
-
-        @FakeScheduled
-        @RunAsUser(user = "Mirek")
-        Void getFromPrincipal_Wrapper() {
-            returnedPrincipalName = principal.getName();
-            returnedRoles = null;
-            return null;
-        }
-
-        @FakeScheduled
-        @RunAsUser(user = "Mirek")
-        void getFromPrincipal() {
-            returnedPrincipalName = principal.getName();
-            returnedRoles = null;
-        }
-
-        @FakeScheduled
-        @RunAsUser(user = "Mirek")
-        Uni<Void> getFromPrincipal_Uni() {
-            return Uni.createFrom().item(() -> {
-                returnedPrincipalName = principal.getName();
-                returnedRoles = Set.of();
-                return null;
-            });
-        }
-
-        @FakeScheduled
-        @RunAsUser(user = "Marek")
-        void getFromIdentityWithoutRoles() {
-            returnedPrincipalName = securityIdentity.getPrincipal().getName();
-            returnedRoles = securityIdentity.getRoles();
-        }
-
-        @FakeScheduled
-        @RunAsUser(user = "Marek")
-        Uni<Void> getFromIdentityWithoutRoles_Uni() {
-            return Uni.createFrom().item(() -> {
-                returnedPrincipalName = securityIdentity.getPrincipal().getName();
-                returnedRoles = securityIdentity.getRoles();
-                return null;
-            });
-        }
-
-        @FakeScheduled
-        @RunAsUser(user = "Milan", roles = { "user", "admin" })
-        void getFromIdentityWithRoles() {
-            returnedPrincipalName = securityIdentity.getPrincipal().getName();
-            returnedRoles = securityIdentity.getRoles();
-        }
-
-        @FakeScheduled
-        @RunAsUser(user = "Milan", roles = { "user", "admin" })
-        Uni<Void> getFromIdentityWithRoles_Uni() {
-            return Uni.createFrom().item(() -> {
-                returnedPrincipalName = securityIdentity.getPrincipal().getName();
-                returnedRoles = securityIdentity.getRoles();
-                return null;
-            });
-        }
-
-        @FakeScheduled
-        @RunAsUser(user = "Michal")
-        void getFromCurrentIdentityAssociation() {
-            var identity = currentIdentityAssociation.getIdentity();
-            returnedPrincipalName = identity.getPrincipal().getName();
-            returnedRoles = identity.getRoles();
-        }
-
-        @FakeScheduled
-        @RunAsUser(user = "Michal")
-        Uni<Void> getFromCurrentIdentityAssociation_Uni() {
-            return touchDeferredIdentity();
-        }
-
-        @FakeScheduled
-        @RunAsUser(user = "Michal")
-        CompletionStage<Void> getFromCurrentIdentityAssociation_CompletionStage() {
-            return touchDeferredIdentity().subscribeAsCompletionStage();
-        }
-
-        private Uni<Void> touchDeferredIdentity() {
-            return currentIdentityAssociation.getDeferredIdentity()
-                    .invoke(identity -> {
-                        returnedPrincipalName = identity.getPrincipal().getName();
-                        returnedRoles = identity.getRoles();
-                    }).replaceWithVoid();
-        }
-
-        String getReturnedPrincipalName() {
-            return returnedPrincipalName;
-        }
-
-        Set<String> getReturnedRoles() {
-            return returnedRoles;
-        }
-
-        void reset() {
-            returnedRoles = Set.of();
-            returnedPrincipalName = null;
-        }
-    }
-
-    @Target({ ElementType.METHOD })
-    @Retention(RetentionPolicy.RUNTIME)
-    @interface FakeScheduled {
-    }
-}
diff --git a/extensions/security/runtime/src/main/java/io/quarkus/security/runtime/interceptor/RunAsUserInterceptor.java b/extensions/security/runtime/src/main/java/io/quarkus/security/runtime/interceptor/RunAsUserInterceptor.java
deleted file mode 100644
index e1659e222d8..00000000000
--- a/extensions/security/runtime/src/main/java/io/quarkus/security/runtime/interceptor/RunAsUserInterceptor.java
+++ /dev/null
@@ -1,84 +0,0 @@
-package io.quarkus.security.runtime.interceptor;
-
-import static io.quarkus.security.spi.runtime.SecurityHandlerConstants.SECURITY_INTERCEPTOR_PRIORITY;
-
-import java.util.Set;
-import java.util.concurrent.CompletionStage;
-
-import jakarta.annotation.Priority;
-import jakarta.inject.Inject;
-import jakarta.interceptor.AroundInvoke;
-import jakarta.interceptor.Interceptor;
-import jakarta.interceptor.InvocationContext;
-
-import io.quarkus.security.identity.CurrentIdentityAssociation;
-import io.quarkus.security.identity.RunAsUser;
-import io.quarkus.security.identity.SecurityIdentity;
-import io.quarkus.security.runtime.QuarkusPrincipal;
-import io.quarkus.security.runtime.QuarkusSecurityIdentity;
-import io.smallrye.mutiny.Uni;
-
-/**
- * This is a CDI interceptor used for the {@link RunAsUser} interceptor binding type.
- * The interceptor binding type is registered during the build time via the annotation transformer.
- * Also, the {@link RunAsUser} interceptor binding is currently registered via a build item.
- */
-@Interceptor
-@Priority(SECURITY_INTERCEPTOR_PRIORITY)
-public final class RunAsUserInterceptor {
-
-    @Inject
-    CurrentIdentityAssociation identityAssociation;
-
-    @AroundInvoke
-    Object intercept(InvocationContext ic) throws Exception {
-        Class<?> returnType = ic.getMethod().getReturnType();
-        if (Uni.class.isAssignableFrom(returnType)) {
-            configureIdentityFromAnnotation(ic);
-            try {
-                return ((Uni<?>) ic.proceed()).onTermination().invoke(this::cleanIdentity);
-            } catch (Throwable throwable) {
-                cleanIdentity();
-                throw throwable;
-            }
-        } else if (CompletionStage.class.isAssignableFrom(returnType)) {
-            configureIdentityFromAnnotation(ic);
-            try {
-                return ((CompletionStage<?>) ic.proceed()).whenComplete((item, failure) -> cleanIdentity());
-            } catch (Throwable throwable) {
-                cleanIdentity();
-                throw throwable;
-            }
-        } else {
-            configureIdentityFromAnnotation(ic);
-            try {
-                return ic.proceed();
-            } finally {
-                cleanIdentity();
-            }
-        }
-    }
-
-    private void cleanIdentity() {
-        try {
-            identityAssociation.setIdentity((SecurityIdentity) null);
-        } catch (Throwable ignored) {
-            // theoretically, this could be for example inactive CDI request
-            // make this silent, we only try to "clear" the association to cover every eventuality
-            // currently supported scheduled methods should not need it anyway
-        }
-    }
-
-    private void configureIdentityFromAnnotation(InvocationContext ic) {
-        identityAssociation.setIdentity(createIdentity(ic));
-    }
-
-    private static SecurityIdentity createIdentity(InvocationContext ic) {
-        var runAsUser = ic.getInterceptorBinding(RunAsUser.class);
-        var identityBuilder = QuarkusSecurityIdentity.builder().setPrincipal(new QuarkusPrincipal(runAsUser.user()));
-        if (runAsUser.roles() != null && runAsUser.roles().length > 0) {
-            identityBuilder.addRoles(Set.of(runAsUser.roles()));
-        }
-        return identityBuilder.build();
-    }
-}
diff --git a/extensions/security/spi/src/main/java/io/quarkus/security/spi/RunAsUserPredicateBuildItem.java b/extensions/security/spi/src/main/java/io/quarkus/security/spi/RunAsUserPredicateBuildItem.java
deleted file mode 100644
index b6658643feb..00000000000
--- a/extensions/security/spi/src/main/java/io/quarkus/security/spi/RunAsUserPredicateBuildItem.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package io.quarkus.security.spi;
-
-import static org.jboss.jandex.AnnotationTarget.Kind.METHOD;
-
-import java.lang.annotation.Annotation;
-import java.util.List;
-import java.util.function.Predicate;
-
-import org.jboss.jandex.AnnotationTarget;
-
-import io.quarkus.builder.item.MultiBuildItem;
-
-/**
- * The {@link io.quarkus.security.identity.RunAsUser} annotation can only be used on the {@link AnnotationTarget}
- * matching a predicate registered with this build item. Using the annotation on any other {@link AnnotationTarget}
- * results in validation failure that prevents unsupported scenarios.
- */
-public final class RunAsUserPredicateBuildItem extends MultiBuildItem {
-
-    private final Predicate<AnnotationTarget> annotationTargetPredicate;
-
-    private RunAsUserPredicateBuildItem(Predicate<AnnotationTarget> annotationTargetPredicate) {
-        this.annotationTargetPredicate = annotationTargetPredicate;
-    }
-
-    public static Predicate<AnnotationTarget> get(List<RunAsUserPredicateBuildItem> items) {
-        return at -> items.stream().map(i -> i.annotationTargetPredicate).anyMatch(p -> p.test(at));
-    }
-
-    public static RunAsUserPredicateBuildItem ofAnnotation(Class<? extends Annotation> annotationClass) {
-        return new RunAsUserPredicateBuildItem(at -> at.kind() == METHOD && at.hasAnnotation(annotationClass));
-    }
-}
