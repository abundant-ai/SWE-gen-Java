diff --git a/adapters/build.gradle.kts b/adapters/build.gradle.kts
index d3e0d4dc..aeb4d631 100644
--- a/adapters/build.gradle.kts
+++ b/adapters/build.gradle.kts
@@ -14,18 +14,9 @@
  * limitations under the License.
  */
 
-import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
-
 plugins {
   kotlin("jvm")
   id("com.vanniktech.maven.publish")
-  id("ru.vyarus.animalsniffer")
-}
-
-tasks.withType<KotlinCompile>().configureEach {
-  kotlinOptions {
-    jvmTarget = "1.6"
-  }
 }
 
 dependencies {
diff --git a/examples/src/main/java/com/squareup/moshi/recipes/FallbackEnum.java b/examples/src/main/java/com/squareup/moshi/recipes/FallbackEnum.java
index 8b584f17..9edf0ac4 100644
--- a/examples/src/main/java/com/squareup/moshi/recipes/FallbackEnum.java
+++ b/examples/src/main/java/com/squareup/moshi/recipes/FallbackEnum.java
@@ -58,9 +58,9 @@ final class FallbackEnum {
             if (!(annotation instanceof Fallback)) {
               return null;
             }
-            Class<Enum> enumType = (Class<Enum>) rawType;
-            Enum<?> fallback = Enum.valueOf(enumType, ((Fallback) annotation).value());
-            return new FallbackEnumJsonAdapter<>(enumType, fallback);
+            //noinspection rawtypes
+            return new FallbackEnumJsonAdapter<>(
+                (Class<? extends Enum>) rawType, ((Fallback) annotation).value());
           }
         };
 
@@ -70,9 +70,9 @@ final class FallbackEnum {
     final JsonReader.Options options;
     final T defaultValue;
 
-    FallbackEnumJsonAdapter(Class<T> enumType, T defaultValue) {
+    FallbackEnumJsonAdapter(Class<T> enumType, String fallbackName) {
       this.enumType = enumType;
-      this.defaultValue = defaultValue;
+      this.defaultValue = Enum.valueOf(enumType, fallbackName);
       try {
         constants = enumType.getEnumConstants();
         nameStrings = new String[constants.length];
diff --git a/gradle.properties b/gradle.properties
index 1d7c1a61..b38e0dfe 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -15,9 +15,36 @@
 #
 
 # For Dokka https://github.com/Kotlin/dokka/issues/1405
-org.gradle.jvmargs=-XX:MaxMetaspaceSize=512m
+org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 \
+  --add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.jvm=ALL-UNNAMED  \
+  --add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED
 
-kapt.includeCompileClasspath=false
+# TODO move this to DSL in Kotlin 1.5.30 https://youtrack.jetbrains.com/issue/KT-44266
+kotlin.daemon.jvmargs=-Dfile.encoding=UTF-8 \
+  --add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.jvm=ALL-UNNAMED  \
+  --add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED \
+  --add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED
+
+kapt.include.compile.classpath=false
 
 GROUP=com.squareup.moshi
 VERSION_NAME=1.13.0-SNAPSHOT
diff --git a/kotlin/codegen/build.gradle.kts b/kotlin/codegen/build.gradle.kts
index f9e95ae1..1ae9b29f 100644
--- a/kotlin/codegen/build.gradle.kts
+++ b/kotlin/codegen/build.gradle.kts
@@ -27,7 +27,6 @@ plugins {
 
 tasks.withType<KotlinCompile>().configureEach {
   kotlinOptions {
-    jvmTarget = "1.8"
     @Suppress("SuspiciousCollectionReassignment")
     freeCompilerArgs += listOf(
       "-Xopt-in=com.squareup.kotlinpoet.metadata.KotlinPoetMetadataPreview"
@@ -35,10 +34,20 @@ tasks.withType<KotlinCompile>().configureEach {
   }
 }
 
-// To make Gradle happy
-java {
-  sourceCompatibility = JavaVersion.VERSION_1_8
-  targetCompatibility = JavaVersion.VERSION_1_8
+tasks.withType<Test>().configureEach {
+  // For kapt to work with kotlin-compile-testing
+  jvmArgs(
+    "--add-opens=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
+    "--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
+    "--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
+    "--add-opens=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
+    "--add-opens=jdk.compiler/com.sun.tools.javac.jvm=ALL-UNNAMED",
+    "--add-opens=jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
+    "--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED",
+    "--add-opens=jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
+    "--add-opens=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
+    "--add-opens=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
+  )
 }
 
 val shade: Configuration = configurations.maybeCreate("compileShaded")
diff --git a/moshi/build.gradle.kts b/moshi/build.gradle.kts
index 7a6a9252..c951ddfc 100644
--- a/moshi/build.gradle.kts
+++ b/moshi/build.gradle.kts
@@ -19,14 +19,49 @@ import org.jetbrains.kotlin.gradle.tasks.KotlinCompile
 plugins {
   kotlin("jvm")
   id("com.vanniktech.maven.publish")
-  id("ru.vyarus.animalsniffer")
+}
+
+val mainSourceSet by sourceSets.named("main")
+val java16 by sourceSets.creating {
+  java {
+    srcDir("src/main/java16")
+  }
+}
+
+tasks.named<JavaCompile>("compileJava16Java") {
+  javaCompiler.set(
+    javaToolchains.compilerFor {
+      languageVersion.set(JavaLanguageVersion.of(16))
+    }
+  )
+  options.release.set(16)
+}
+
+// Package our actual RecordJsonAdapter from java16 sources in and denote it as an MRJAR
+tasks.named<Jar>("jar") {
+  from(java16.output) {
+    into("META-INF/versions/16")
+  }
+  manifest {
+    attributes("Multi-Release" to "true")
+  }
+}
+
+configurations {
+  "java16Implementation" {
+    extendsFrom(api.get())
+    extendsFrom(implementation.get())
+  }
+}
+
+tasks.withType<Test>().configureEach {
+  // ExtendsPlatformClassWithProtectedField tests a case where we set a protected ByteArrayOutputStream.buf field
+  jvmArgs("--add-opens=java.base/java.io=ALL-UNNAMED")
 }
 
 tasks.withType<KotlinCompile>()
   .configureEach {
     kotlinOptions {
-      jvmTarget = "1.6"
-
       if (name.contains("test", true)) {
         @Suppress("SuspiciousCollectionReassignment") // It's not suspicious
         freeCompilerArgs += listOf("-Xopt-in=kotlin.ExperimentalStdlibApi")
@@ -35,6 +70,8 @@ tasks.withType<KotlinCompile>()
   }
 
 dependencies {
+  // So the j16 source set can "see" main Moshi sources
+  "java16Implementation"(mainSourceSet.output)
   compileOnly(Dependencies.jsr305)
   api(Dependencies.okio)
 
diff --git a/moshi/records-tests/build.gradle.kts b/moshi/records-tests/build.gradle.kts
new file mode 100644
index 00000000..7b6b541d
--- /dev/null
+++ b/moshi/records-tests/build.gradle.kts
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2021 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+plugins {
+  `java-library`
+}
+
+tasks.withType<JavaCompile>().configureEach {
+  options.release.set(16)
+}
+
+dependencies {
+  testImplementation(project(":moshi"))
+  testCompileOnly(Dependencies.jsr305)
+  testImplementation(Dependencies.Testing.junit)
+  testImplementation(Dependencies.Testing.truth)
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 6a480f21..51a82a69 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -51,6 +51,7 @@ public final class Moshi {
     BUILT_IN_FACTORIES.add(CollectionJsonAdapter.FACTORY);
     BUILT_IN_FACTORIES.add(MapJsonAdapter.FACTORY);
     BUILT_IN_FACTORIES.add(ArrayJsonAdapter.FACTORY);
+    BUILT_IN_FACTORIES.add(RecordJsonAdapter.FACTORY);
     BUILT_IN_FACTORIES.add(ClassJsonAdapter.FACTORY);
   }
 
diff --git a/moshi/src/main/java/com/squareup/moshi/RecordJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/RecordJsonAdapter.java
new file mode 100644
index 00000000..0f273c04
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/RecordJsonAdapter.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2021 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.Set;
+import javax.annotation.Nullable;
+
+/**
+ * This is just a simple shim for linking in {@link StandardJsonAdapters} and swapped with a real
+ * implementation in Java 16 via MR Jar.
+ */
+final class RecordJsonAdapter<T> extends JsonAdapter<T> {
+
+  static final JsonAdapter.Factory FACTORY =
+      new JsonAdapter.Factory() {
+
+        @Nullable
+        @Override
+        public JsonAdapter<?> create(
+            Type type, Set<? extends Annotation> annotations, Moshi moshi) {
+          return null;
+        }
+      };
+
+  @Nullable
+  @Override
+  public T fromJson(JsonReader reader) throws IOException {
+    throw new AssertionError();
+  }
+
+  @Override
+  public void toJson(JsonWriter writer, @Nullable T value) throws IOException {
+    throw new AssertionError();
+  }
+}
diff --git a/moshi/src/main/java16/com/squareup/moshi/RecordJsonAdapter.java b/moshi/src/main/java16/com/squareup/moshi/RecordJsonAdapter.java
new file mode 100644
index 00000000..af527838
--- /dev/null
+++ b/moshi/src/main/java16/com/squareup/moshi/RecordJsonAdapter.java
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2021 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import static java.lang.invoke.MethodType.methodType;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.RecordComponent;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ * A {@link JsonAdapter} that supports Java {@code record} classes via reflection.
+ *
+ * <p><em>NOTE:</em> Java records require JDK 16 or higher.
+ */
+final class RecordJsonAdapter<T> extends JsonAdapter<T> {
+
+  static final JsonAdapter.Factory FACTORY =
+      (type, annotations, moshi) -> {
+        if (!annotations.isEmpty()) {
+          return null;
+        }
+
+        if (!(type instanceof Class) && !(type instanceof ParameterizedType)) {
+          return null;
+        }
+
+        var rawType = Types.getRawType(type);
+        if (!rawType.isRecord()) {
+          return null;
+        }
+
+        Map<String, Type> mappedTypeArgs = null;
+        if (type instanceof ParameterizedType parameterizedType) {
+          Type[] typeArgs = parameterizedType.getActualTypeArguments();
+          var typeVars = rawType.getTypeParameters();
+          mappedTypeArgs = new LinkedHashMap<>(typeArgs.length);
+          for (int i = 0; i < typeArgs.length; ++i) {
+            var typeVarName = typeVars[i].getName();
+            var materialized = typeArgs[i];
+            mappedTypeArgs.put(typeVarName, materialized);
+          }
+        }
+        var components = rawType.getRecordComponents();
+        var bindings = new LinkedHashMap<String, ComponentBinding<?>>();
+        var constructorParams = new Class<?>[components.length];
+        var lookup = MethodHandles.lookup();
+        for (int i = 0, componentsLength = components.length; i < componentsLength; i++) {
+          RecordComponent component = components[i];
+          constructorParams[i] = component.getType();
+          var name = component.getName();
+          var componentType = component.getGenericType();
+          if (componentType instanceof TypeVariable<?> typeVariable) {
+            var typeVarName = typeVariable.getName();
+            if (mappedTypeArgs == null) {
+              throw new AssertionError(
+                  "No mapped type arguments found for type '" + typeVarName + "'");
+            }
+            var mappedType = mappedTypeArgs.get(typeVarName);
+            if (mappedType == null) {
+              throw new AssertionError(
+                  "No materialized type argument found for type '" + typeVarName + "'");
+            }
+            componentType = mappedType;
+          }
+          var jsonName = name;
+          Set<Annotation> qualifiers = null;
+          for (var annotation : component.getDeclaredAnnotations()) {
+            if (annotation instanceof Json jsonAnnotation) {
+              jsonName = jsonAnnotation.name();
+            } else {
+              if (annotation.annotationType().isAnnotationPresent(JsonQualifier.class)) {
+                if (qualifiers == null) {
+                  qualifiers = new LinkedHashSet<>();
+                }
+                qualifiers.add(annotation);
+              }
+            }
+          }
+          if (qualifiers == null) {
+            qualifiers = Collections.emptySet();
+          }
+          var adapter = moshi.adapter(componentType, qualifiers);
+          MethodHandle accessor;
+          try {
+            accessor = lookup.unreflect(component.getAccessor());
+          } catch (IllegalAccessException e) {
+            throw new AssertionError(e);
+          }
+          var componentBinding = new ComponentBinding<>(name, jsonName, adapter, accessor);
+          var replaced = bindings.put(jsonName, componentBinding);
+          if (replaced != null) {
+            throw new IllegalArgumentException(
+                "Conflicting components:\n"
+                    + "    "
+                    + replaced.name
+                    + "\n"
+                    + "    "
+                    + componentBinding.name);
+          }
+        }
+
+        MethodHandle constructor;
+        try {
+          constructor = lookup.findConstructor(rawType, methodType(void.class, constructorParams));
+        } catch (NoSuchMethodException | IllegalAccessException e) {
+          throw new AssertionError(e);
+        }
+        return new RecordJsonAdapter<>(constructor, rawType.getSimpleName(), bindings).nullSafe();
+      };
+
+  private static record ComponentBinding<T>(
+      String name, String jsonName, JsonAdapter<T> adapter, MethodHandle accessor) {}
+
+  private final String targetClass;
+  private final MethodHandle constructor;
+  private final ComponentBinding<Object>[] componentBindingsArray;
+  private final JsonReader.Options options;
+
+  @SuppressWarnings("ToArrayCallWithZeroLengthArrayArgument")
+  public RecordJsonAdapter(
+      MethodHandle constructor,
+      String targetClass,
+      Map<String, ComponentBinding<?>> componentBindings) {
+    this.constructor = constructor;
+    this.targetClass = targetClass;
+    //noinspection unchecked
+    this.componentBindingsArray =
+        componentBindings.values().toArray(new ComponentBinding[componentBindings.size()]);
+    this.options =
+        JsonReader.Options.of(
+            componentBindings.keySet().toArray(new String[componentBindings.size()]));
+  }
+
+  @Override
+  public T fromJson(JsonReader reader) throws IOException {
+    var resultsArray = new Object[componentBindingsArray.length];
+
+    reader.beginObject();
+    while (reader.hasNext()) {
+      int index = reader.selectName(options);
+      if (index == -1) {
+        reader.skipName();
+        reader.skipValue();
+        continue;
+      }
+      var result = componentBindingsArray[index].adapter.fromJson(reader);
+      resultsArray[index] = result;
+    }
+    reader.endObject();
+
+    try {
+      //noinspection unchecked
+      return (T) constructor.invokeWithArguments(resultsArray);
+    } catch (Throwable e) {
+      if (e instanceof InvocationTargetException ite) {
+        Throwable cause = ite.getCause();
+        if (cause instanceof RuntimeException) throw (RuntimeException) cause;
+        if (cause instanceof Error) throw (Error) cause;
+        throw new RuntimeException(cause);
+      } else {
+        throw new AssertionError(e);
+      }
+    }
+  }
+
+  @Override
+  public void toJson(JsonWriter writer, T value) throws IOException {
+    writer.beginObject();
+
+    for (var binding : componentBindingsArray) {
+      writer.name(binding.jsonName);
+      try {
+        binding.adapter.toJson(writer, binding.accessor.invoke(value));
+      } catch (Throwable e) {
+        if (e instanceof InvocationTargetException ite) {
+          Throwable cause = ite.getCause();
+          if (cause instanceof RuntimeException) throw (RuntimeException) cause;
+          if (cause instanceof Error) throw (Error) cause;
+          throw new RuntimeException(cause);
+        } else {
+          throw new AssertionError(e);
+        }
+      }
+    }
+
+    writer.endObject();
+  }
+
+  @Override
+  public String toString() {
+    return "JsonAdapter(" + targetClass + ")";
+  }
+}
diff --git a/settings.gradle.kts b/settings.gradle.kts
index c65b0178..d37a0f5f 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -24,6 +24,7 @@ pluginManagement {
 rootProject.name = "moshi-root"
 include(":moshi")
 include(":moshi:japicmp")
+include(":moshi:records-tests")
 include(":adapters")
 include(":adapters:japicmp")
 include(":examples")
