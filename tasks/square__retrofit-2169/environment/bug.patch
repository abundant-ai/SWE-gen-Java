diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
deleted file mode 100644
index aa5ca67a..00000000
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2016 Jake Wharton
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava2;
-
-import io.reactivex.Observable;
-import io.reactivex.Observer;
-import io.reactivex.disposables.Disposable;
-import io.reactivex.exceptions.CompositeException;
-import io.reactivex.exceptions.Exceptions;
-import io.reactivex.plugins.RxJavaPlugins;
-import retrofit2.Call;
-import retrofit2.Callback;
-import retrofit2.Response;
-
-final class CallEnqueueObservable<T> extends Observable<Response<T>> {
-  private final Call<T> originalCall;
-
-  CallEnqueueObservable(Call<T> originalCall) {
-    this.originalCall = originalCall;
-  }
-
-  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
-    // Since Call is a one-shot type, clone it for each new observer.
-    Call<T> call = originalCall.clone();
-    CallCallback<T> callback = new CallCallback<>(call, observer);
-    observer.onSubscribe(callback);
-    call.enqueue(callback);
-  }
-
-  private static final class CallCallback<T> implements Disposable, Callback<T> {
-    private final Call<?> call;
-    private final Observer<? super Response<T>> observer;
-    boolean terminated = false;
-
-    CallCallback(Call<?> call, Observer<? super Response<T>> observer) {
-      this.call = call;
-      this.observer = observer;
-    }
-
-    @Override public void onResponse(Call<T> call, Response<T> response) {
-      if (call.isCanceled()) return;
-
-      try {
-        observer.onNext(response);
-
-        if (!call.isCanceled()) {
-          terminated = true;
-          observer.onComplete();
-        }
-      } catch (Throwable t) {
-        if (terminated) {
-          RxJavaPlugins.onError(t);
-        } else if (!call.isCanceled()) {
-          try {
-            observer.onError(t);
-          } catch (Throwable inner) {
-            Exceptions.throwIfFatal(inner);
-            RxJavaPlugins.onError(new CompositeException(t, inner));
-          }
-        }
-      }
-    }
-
-    @Override public void onFailure(Call<T> call, Throwable t) {
-      if (call.isCanceled()) return;
-
-      try {
-        observer.onError(t);
-      } catch (Throwable inner) {
-        Exceptions.throwIfFatal(inner);
-        RxJavaPlugins.onError(new CompositeException(t, inner));
-      }
-    }
-
-    @Override public void dispose() {
-      call.cancel();
-    }
-
-    @Override public boolean isDisposed() {
-      return call.isCanceled();
-    }
-  }
-}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
similarity index 94%
rename from retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
rename to retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
index bf945336..d7a4f719 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallObservable.java
@@ -24,10 +24,10 @@ import io.reactivex.plugins.RxJavaPlugins;
 import retrofit2.Call;
 import retrofit2.Response;
 
-final class CallExecuteObservable<T> extends Observable<Response<T>> {
+final class CallObservable<T> extends Observable<Response<T>> {
   private final Call<T> originalCall;
 
-  CallExecuteObservable(Call<T> originalCall) {
+  CallObservable(Call<T> originalCall) {
     this.originalCall = originalCall;
   }
 
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
index a585e311..e6b7861c 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -26,7 +26,6 @@ import retrofit2.Response;
 final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
   private final Type responseType;
   private final Scheduler scheduler;
-  private final boolean isAsync;
   private final boolean isResult;
   private final boolean isBody;
   private final boolean isFlowable;
@@ -34,12 +33,10 @@ final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
   private final boolean isMaybe;
   private final boolean isCompletable;
 
-  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isAsync, boolean isResult,
-      boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
-      boolean isCompletable) {
+  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
+      boolean isFlowable, boolean isSingle, boolean isMaybe, boolean isCompletable) {
     this.responseType = responseType;
     this.scheduler = scheduler;
-    this.isAsync = isAsync;
     this.isResult = isResult;
     this.isBody = isBody;
     this.isFlowable = isFlowable;
@@ -53,9 +50,7 @@ final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
   }
 
   @Override public Object adapt(Call<R> call) {
-    Observable<Response<R>> responseObservable = isAsync
-        ? new CallEnqueueObservable<>(call)
-        : new CallExecuteObservable<>(call);
+    Observable<Response<R>> responseObservable = new CallObservable<>(call);
 
     Observable<?> observable;
     if (isResult) {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index ead95216..6e1fe7b5 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -59,15 +59,7 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
    * by default.
    */
   public static RxJava2CallAdapterFactory create() {
-    return new RxJava2CallAdapterFactory(null, false);
-  }
-
-  /**
-   * Returns an instance which creates asynchronous observables. Applying
-   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
-   */
-  public static RxJava2CallAdapterFactory createAsync() {
-    return new RxJava2CallAdapterFactory(null, true);
+    return new RxJava2CallAdapterFactory(null);
   }
 
   /**
@@ -76,15 +68,13 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
    */
   public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
     if (scheduler == null) throw new NullPointerException("scheduler == null");
-    return new RxJava2CallAdapterFactory(scheduler, false);
+    return new RxJava2CallAdapterFactory(scheduler);
   }
 
   private final Scheduler scheduler;
-  private final boolean isAsync;
 
-  private RxJava2CallAdapterFactory(Scheduler scheduler, boolean isAsync) {
+  private RxJava2CallAdapterFactory(Scheduler scheduler) {
     this.scheduler = scheduler;
-    this.isAsync = isAsync;
   }
 
   @Override
@@ -94,8 +84,7 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
     if (rawType == Completable.class) {
       // Completable is not parameterized (which is what the rest of this method deals with) so it
       // can only be created with a single configuration.
-      return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,
-          false, true);
+      return new RxJava2CallAdapter(Void.class, scheduler, false, true, false, false, false, true);
     }
 
     boolean isFlowable = rawType == Flowable.class;
@@ -109,7 +98,9 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
     boolean isBody = false;
     Type responseType;
     if (!(returnType instanceof ParameterizedType)) {
-      String name = isFlowable ? "Flowable" : isSingle ? "Single" : "Observable";
+      String name = isFlowable ? "Flowable"
+          : isSingle ? "Single"
+          : isMaybe ? "Maybe" : "Observable";
       throw new IllegalStateException(name + " return type must be parameterized"
           + " as " + name + "<Foo> or " + name + "<? extends Foo>");
     }
@@ -134,7 +125,7 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
       isBody = true;
     }
 
-    return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,
+    return new RxJava2CallAdapter(responseType, scheduler, isResult, isBody, isFlowable,
         isSingle, isMaybe, false);
   }
 }
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
deleted file mode 100644
index d008a5e7..00000000
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/AsyncTest.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.rxjava2;
-
-import io.reactivex.Completable;
-import io.reactivex.exceptions.CompositeException;
-import io.reactivex.exceptions.Exceptions;
-import io.reactivex.functions.Consumer;
-import io.reactivex.observers.TestObserver;
-import io.reactivex.plugins.RxJavaPlugins;
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.Retrofit;
-import retrofit2.adapter.rxjava2.CompletableThrowingTest.ForwardingCompletableObserver;
-import retrofit2.http.GET;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertFalse;
-
-public final class AsyncTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") Completable completable();
-  }
-
-  private Service service;
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addCallAdapterFactory(RxJava2CallAdapterFactory.createAsync())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void success() throws InterruptedException {
-    TestObserver<Void> observer = new TestObserver<>();
-    service.completable().subscribe(observer);
-    assertFalse(observer.await(1, SECONDS));
-
-    server.enqueue(new MockResponse());
-    observer.awaitTerminalEvent(1, SECONDS);
-    observer.assertComplete();
-  }
-
-
-  @Test public void failure() throws InterruptedException {
-    TestObserver<Void> observer = new TestObserver<>();
-    service.completable().subscribe(observer);
-    assertFalse(observer.await(1, SECONDS));
-
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-    observer.awaitTerminalEvent(1, SECONDS);
-    observer.assertError(IOException.class);
-  }
-
-  @Test public void throwingInOnCompleteDeliveredToPlugin() throws InterruptedException {
-    server.enqueue(new MockResponse());
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!errorRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
-        }
-        latch.countDown();
-      }
-    });
-
-    TestObserver<Void> observer = new TestObserver<>();
-    final RuntimeException e = new RuntimeException();
-    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
-      @Override public void onComplete() {
-        throw e;
-      }
-    });
-
-    latch.await(1, SECONDS);
-    assertThat(errorRef.get()).isSameAs(e);
-  }
-
-  @Test public void bodyThrowingInOnErrorDeliveredToPlugin() throws InterruptedException {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<Throwable> pluginRef = new AtomicReference<>();
-    RxJavaPlugins.setErrorHandler(new Consumer<Throwable>() {
-      @Override public void accept(Throwable throwable) throws Exception {
-        if (!pluginRef.compareAndSet(null, throwable)) {
-          throw Exceptions.propagate(throwable); // Don't swallow secondary errors!
-        }
-        latch.countDown();
-      }
-    });
-
-    TestObserver<Void> observer = new TestObserver<>();
-    final RuntimeException e = new RuntimeException();
-    final AtomicReference<Throwable> errorRef = new AtomicReference<>();
-    service.completable().subscribe(new ForwardingCompletableObserver(observer) {
-      @Override public void onError(Throwable throwable) {
-        errorRef.set(throwable);
-        throw e;
-      }
-    });
-
-    latch.await(1, SECONDS);
-    //noinspection ThrowableResultOfMethodCallIgnored
-    CompositeException composite = (CompositeException) pluginRef.get();
-    assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
-  }
-}
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
index 6c558b02..535fdeee 100644
--- a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/CompletableThrowingTest.java
@@ -104,7 +104,7 @@ public final class CompletableThrowingTest {
     assertThat(composite.getExceptions()).containsExactly(errorRef.get(), e);
   }
 
-  static abstract class ForwardingCompletableObserver implements CompletableObserver {
+  private static abstract class ForwardingCompletableObserver implements CompletableObserver {
     private final CompletableObserver delegate;
 
     ForwardingCompletableObserver(CompletableObserver delegate) {
diff --git a/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
new file mode 100644
index 00000000..58971612
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/test/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactoryTest.java
@@ -0,0 +1,274 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package retrofit2.adapter.rxjava2;
+
+import com.google.common.reflect.TypeToken;
+import io.reactivex.Completable;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Type;
+import java.util.List;
+import org.junit.Before;
+import org.junit.Test;
+import retrofit2.CallAdapter;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import io.reactivex.Observable;
+import io.reactivex.Single;
+import io.reactivex.Flowable;
+import io.reactivex.Maybe;
+import io.reactivex.Completable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
+public class RxJava2CallAdapterFactoryTest {
+  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
+
+  private final CallAdapter.Factory factory = RxJava2CallAdapterFactory.create();
+  private Retrofit retrofit;
+
+  @Before public void setUp() {
+    retrofit = new Retrofit.Builder()
+        .baseUrl("http://localhost:1")
+        .addConverterFactory(new StringConverterFactory())
+        .addCallAdapterFactory(factory)
+        .build();
+  }
+
+  @Test public void nullSchedulerThrows() {
+    try {
+      RxJava2CallAdapterFactory.createWithScheduler(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("scheduler == null");
+    }
+  }
+
+  @Test public void nonRxJavaTypeReturnsNull() {
+    CallAdapter<?, ?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
+    assertThat(adapter).isNull();
+  }
+
+  @Test public void responseTypes() {
+    Type oBodyClass = new TypeToken<Observable<String>>() {}.getType();
+    assertThat(factory.get(oBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyClass = new TypeToken<Single<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mBodyClass = new TypeToken<Maybe<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fBodyClass = new TypeToken<Flowable<String>>() {}.getType();
+    assertThat(factory.get(sBodyClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyWildcard = new TypeToken<Observable<? extends String>>() {}.getType();
+    assertThat(factory.get(oBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sBodyWildcard = new TypeToken<Single<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mBodyWildcard = new TypeToken<Maybe<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fBodyWildcard = new TypeToken<Flowable<? extends String>>() {}.getType();
+    assertThat(factory.get(sBodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oBodyGeneric = new TypeToken<Observable<List<String>>>() {}.getType();
+    assertThat(factory.get(oBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type sBodyGeneric = new TypeToken<Single<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type mBodyGeneric = new TypeToken<Maybe<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+    Type fBodyGeneric = new TypeToken<Flowable<List<String>>>() {}.getType();
+    assertThat(factory.get(sBodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(new TypeToken<List<String>>() {}.getType());
+
+    Type oResponseClass = new TypeToken<Observable<Response<String>>>() {}.getType();
+    assertThat(factory.get(oResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseClass = new TypeToken<Single<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResponseClass = new TypeToken<Maybe<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResponseClass = new TypeToken<Flowable<Response<String>>>() {}.getType();
+    assertThat(factory.get(sResponseClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResponseWildcard = new TypeToken<Observable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResponseWildcard = new TypeToken<Single<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResponseWildcard = new TypeToken<Maybe<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResponseWildcard = new TypeToken<Flowable<Response<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResponseWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultClass = new TypeToken<Observable<Result<String>>>() {}.getType();
+    assertThat(factory.get(oResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultClass = new TypeToken<Single<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResultClass = new TypeToken<Maybe<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResultClass = new TypeToken<Flowable<Result<String>>>() {}.getType();
+    assertThat(factory.get(sResultClass, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+
+    Type oResultWildcard = new TypeToken<Observable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(oResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type sResultWildcard = new TypeToken<Single<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type mResultWildcard = new TypeToken<Maybe<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+    Type fResultWildcard = new TypeToken<Flowable<Result<? extends String>>>() {}.getType();
+    assertThat(factory.get(sResultWildcard, NO_ANNOTATIONS, retrofit).responseType())
+        .isEqualTo(String.class);
+  }
+
+  @Test public void rawBodyTypeThrows() {
+    Type observableType = new TypeToken<Observable>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Maybe return type must be parameterized as Maybe<Foo> or Maybe<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Flowable return type must be parameterized as Flowable<Foo> or Flowable<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResponseTypeThrows() {
+    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Response>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe<Response>>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable<Response>>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
+    }
+  }
+
+  @Test public void rawResultTypeThrows() {
+    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
+    try {
+      factory.get(observableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    try {
+      factory.get(singleType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type maybeType = new TypeToken<Maybe<Result>>() {}.getType();
+    try {
+      factory.get(maybeType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+
+    Type flowableType = new TypeToken<Flowable<Result>>() {}.getType();
+    try {
+      factory.get(flowableType, NO_ANNOTATIONS, retrofit);
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage(
+          "Result must be parameterized as Result<Foo> or Result<? extends Foo>");
+    }
+  }
+}
diff --git a/samples/pom.xml b/samples/pom.xml
index 5931b34d..e266a2b3 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -24,6 +24,11 @@
       <artifactId>retrofit-mock</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>converter-moshi</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>converter-gson</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
new file mode 100644
index 00000000..0664d348
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.google.gson.GsonBuilder;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.annotation.Retention;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import okhttp3.RequestBody;
+import okhttp3.ResponseBody;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import org.simpleframework.xml.Attribute;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import retrofit2.Call;
+import retrofit2.Converter;
+import retrofit2.Retrofit;
+import retrofit2.converter.gson.GsonConverterFactory;
+import retrofit2.converter.moshi.MoshiConverterFactory;
+import retrofit2.converter.simplexml.SimpleXmlConverterFactory;
+import retrofit2.http.GET;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+final class AnnotatedConverters {
+  public static final class AnnotatedConverterFactory extends Converter.Factory {
+    private final Map<Class<? extends Annotation>, Converter.Factory> factories;
+
+    public static final class Builder {
+      private final Map<Class<? extends Annotation>, Converter.Factory> factories =
+          new LinkedHashMap<>();
+
+      public Builder add(Class<? extends Annotation> cls, Converter.Factory factory) {
+        if (cls == null) {
+          throw new NullPointerException("cls == null");
+        }
+        if (factory == null) {
+          throw new NullPointerException("factory == null");
+        }
+        factories.put(cls, factory);
+        return this;
+      }
+
+      public AnnotatedConverterFactory build() {
+        return new AnnotatedConverterFactory(factories);
+      }
+    }
+
+    AnnotatedConverterFactory(Map<Class<? extends Annotation>, Converter.Factory> factories) {
+      this.factories = new LinkedHashMap<>(factories);
+    }
+
+    @Override
+    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
+        Retrofit retrofit) {
+      for (Annotation annotation : annotations) {
+        Converter.Factory factory = factories.get(annotation.annotationType());
+        if (factory != null) {
+          return factory.responseBodyConverter(type, annotations, retrofit);
+        }
+      }
+      return null;
+    }
+
+    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
+        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
+      for (Annotation annotation : parameterAnnotations) {
+        Converter.Factory factory = factories.get(annotation.annotationType());
+        if (factory != null) {
+          return factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
+              retrofit);
+        }
+      }
+      return null;
+    }
+  }
+
+  @Retention(RUNTIME) public @interface Moshi {
+  }
+
+  @Retention(RUNTIME) public @interface Gson {
+  }
+
+  @Retention(RUNTIME) public @interface SimpleXml {
+  }
+
+  @Default(value = DefaultType.FIELD) static final class Library {
+    @Attribute String name;
+  }
+
+  interface Service {
+    @GET("/") @Moshi Call<Library> exampleMoshi();
+
+    @GET("/") @Gson Call<Library> exampleGson();
+
+    @GET("/") @SimpleXml Call<Library> exampleSimpleXml();
+
+    @GET("/") Call<Library> exampleDefault();
+  }
+
+  public static void main(String... args) throws IOException {
+    MockWebServer server = new MockWebServer();
+    server.start();
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Moshi\"}"));
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
+    server.enqueue(new MockResponse().setBody("<user name=\"SimpleXML\"/>"));
+    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
+
+    com.squareup.moshi.Moshi moshi = new com.squareup.moshi.Moshi.Builder().build();
+    com.google.gson.Gson gson = new GsonBuilder().create();
+    MoshiConverterFactory moshiConverterFactory = MoshiConverterFactory.create(moshi);
+    GsonConverterFactory gsonConverterFactory = GsonConverterFactory.create(gson);
+    SimpleXmlConverterFactory simpleXmlConverterFactory = SimpleXmlConverterFactory.create();
+    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url("/"))
+        .addConverterFactory(
+            new AnnotatedConverterFactory.Builder().add(Moshi.class, moshiConverterFactory)
+                .add(Gson.class, gsonConverterFactory)
+                .add(SimpleXml.class, simpleXmlConverterFactory)
+                .build())
+        .addConverterFactory(gsonConverterFactory)
+        .build();
+    Service service = retrofit.create(Service.class);
+
+    Library library1 = service.exampleMoshi().execute().body();
+    System.out.println("Library 1: " + library1.name);
+
+    Library library2 = service.exampleGson().execute().body();
+    System.out.println("Library 2: " + library2.name);
+
+    Library library3 = service.exampleSimpleXml().execute().body();
+    System.out.println("Library 3: " + library3.name);
+
+    Library library4 = service.exampleDefault().execute().body();
+    System.out.println("Library 4: " + library4.name);
+
+    server.shutdown();
+  }
+}
