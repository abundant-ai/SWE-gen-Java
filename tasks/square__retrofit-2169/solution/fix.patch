diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
new file mode 100644
index 00000000..aa5ca67a
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallEnqueueObservable.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+final class CallEnqueueObservable<T> extends Observable<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallEnqueueObservable(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
+    // Since Call is a one-shot type, clone it for each new observer.
+    Call<T> call = originalCall.clone();
+    CallCallback<T> callback = new CallCallback<>(call, observer);
+    observer.onSubscribe(callback);
+    call.enqueue(callback);
+  }
+
+  private static final class CallCallback<T> implements Disposable, Callback<T> {
+    private final Call<?> call;
+    private final Observer<? super Response<T>> observer;
+    boolean terminated = false;
+
+    CallCallback(Call<?> call, Observer<? super Response<T>> observer) {
+      this.call = call;
+      this.observer = observer;
+    }
+
+    @Override public void onResponse(Call<T> call, Response<T> response) {
+      if (call.isCanceled()) return;
+
+      try {
+        observer.onNext(response);
+
+        if (!call.isCanceled()) {
+          terminated = true;
+          observer.onComplete();
+        }
+      } catch (Throwable t) {
+        if (terminated) {
+          RxJavaPlugins.onError(t);
+        } else if (!call.isCanceled()) {
+          try {
+            observer.onError(t);
+          } catch (Throwable inner) {
+            Exceptions.throwIfFatal(inner);
+            RxJavaPlugins.onError(new CompositeException(t, inner));
+          }
+        }
+      }
+    }
+
+    @Override public void onFailure(Call<T> call, Throwable t) {
+      if (call.isCanceled()) return;
+
+      try {
+        observer.onError(t);
+      } catch (Throwable inner) {
+        Exceptions.throwIfFatal(inner);
+        RxJavaPlugins.onError(new CompositeException(t, inner));
+      }
+    }
+
+    @Override public void dispose() {
+      call.cancel();
+    }
+
+    @Override public boolean isDisposed() {
+      return call.isCanceled();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
new file mode 100644
index 00000000..bf945336
--- /dev/null
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/CallExecuteObservable.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 Jake Wharton
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.adapter.rxjava2;
+
+import io.reactivex.Observable;
+import io.reactivex.Observer;
+import io.reactivex.disposables.Disposable;
+import io.reactivex.exceptions.CompositeException;
+import io.reactivex.exceptions.Exceptions;
+import io.reactivex.plugins.RxJavaPlugins;
+import retrofit2.Call;
+import retrofit2.Response;
+
+final class CallExecuteObservable<T> extends Observable<Response<T>> {
+  private final Call<T> originalCall;
+
+  CallExecuteObservable(Call<T> originalCall) {
+    this.originalCall = originalCall;
+  }
+
+  @Override protected void subscribeActual(Observer<? super Response<T>> observer) {
+    // Since Call is a one-shot type, clone it for each new observer.
+    Call<T> call = originalCall.clone();
+    observer.onSubscribe(new CallDisposable(call));
+
+    boolean terminated = false;
+    try {
+      Response<T> response = call.execute();
+      if (!call.isCanceled()) {
+        observer.onNext(response);
+      }
+      if (!call.isCanceled()) {
+        terminated = true;
+        observer.onComplete();
+      }
+    } catch (Throwable t) {
+      Exceptions.throwIfFatal(t);
+      if (terminated) {
+        RxJavaPlugins.onError(t);
+      } else if (!call.isCanceled()) {
+        try {
+          observer.onError(t);
+        } catch (Throwable inner) {
+          Exceptions.throwIfFatal(inner);
+          RxJavaPlugins.onError(new CompositeException(t, inner));
+        }
+      }
+    }
+  }
+
+  private static final class CallDisposable implements Disposable {
+    private final Call<?> call;
+
+    CallDisposable(Call<?> call) {
+      this.call = call;
+    }
+
+    @Override public void dispose() {
+      call.cancel();
+    }
+
+    @Override public boolean isDisposed() {
+      return call.isCanceled();
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
index e6b7861c..a585e311 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapter.java
@@ -26,6 +26,7 @@ import retrofit2.Response;
 final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
   private final Type responseType;
   private final Scheduler scheduler;
+  private final boolean isAsync;
   private final boolean isResult;
   private final boolean isBody;
   private final boolean isFlowable;
@@ -33,10 +34,12 @@ final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
   private final boolean isMaybe;
   private final boolean isCompletable;
 
-  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isResult, boolean isBody,
-      boolean isFlowable, boolean isSingle, boolean isMaybe, boolean isCompletable) {
+  RxJava2CallAdapter(Type responseType, Scheduler scheduler, boolean isAsync, boolean isResult,
+      boolean isBody, boolean isFlowable, boolean isSingle, boolean isMaybe,
+      boolean isCompletable) {
     this.responseType = responseType;
     this.scheduler = scheduler;
+    this.isAsync = isAsync;
     this.isResult = isResult;
     this.isBody = isBody;
     this.isFlowable = isFlowable;
@@ -50,7 +53,9 @@ final class RxJava2CallAdapter<R> implements CallAdapter<R, Object> {
   }
 
   @Override public Object adapt(Call<R> call) {
-    Observable<Response<R>> responseObservable = new CallObservable<>(call);
+    Observable<Response<R>> responseObservable = isAsync
+        ? new CallEnqueueObservable<>(call)
+        : new CallExecuteObservable<>(call);
 
     Observable<?> observable;
     if (isResult) {
diff --git a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
index 6e1fe7b5..ead95216 100644
--- a/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
+++ b/retrofit-adapters/rxjava2/src/main/java/retrofit2/adapter/rxjava2/RxJava2CallAdapterFactory.java
@@ -59,7 +59,15 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
    * by default.
    */
   public static RxJava2CallAdapterFactory create() {
-    return new RxJava2CallAdapterFactory(null);
+    return new RxJava2CallAdapterFactory(null, false);
+  }
+
+  /**
+   * Returns an instance which creates asynchronous observables. Applying
+   * {@link Observable#subscribeOn} has no effect on stream types created by this factory.
+   */
+  public static RxJava2CallAdapterFactory createAsync() {
+    return new RxJava2CallAdapterFactory(null, true);
   }
 
   /**
@@ -68,13 +76,15 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
    */
   public static RxJava2CallAdapterFactory createWithScheduler(Scheduler scheduler) {
     if (scheduler == null) throw new NullPointerException("scheduler == null");
-    return new RxJava2CallAdapterFactory(scheduler);
+    return new RxJava2CallAdapterFactory(scheduler, false);
   }
 
   private final Scheduler scheduler;
+  private final boolean isAsync;
 
-  private RxJava2CallAdapterFactory(Scheduler scheduler) {
+  private RxJava2CallAdapterFactory(Scheduler scheduler, boolean isAsync) {
     this.scheduler = scheduler;
+    this.isAsync = isAsync;
   }
 
   @Override
@@ -84,7 +94,8 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
     if (rawType == Completable.class) {
       // Completable is not parameterized (which is what the rest of this method deals with) so it
       // can only be created with a single configuration.
-      return new RxJava2CallAdapter(Void.class, scheduler, false, true, false, false, false, true);
+      return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false,
+          false, true);
     }
 
     boolean isFlowable = rawType == Flowable.class;
@@ -98,9 +109,7 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
     boolean isBody = false;
     Type responseType;
     if (!(returnType instanceof ParameterizedType)) {
-      String name = isFlowable ? "Flowable"
-          : isSingle ? "Single"
-          : isMaybe ? "Maybe" : "Observable";
+      String name = isFlowable ? "Flowable" : isSingle ? "Single" : "Observable";
       throw new IllegalStateException(name + " return type must be parameterized"
           + " as " + name + "<Foo> or " + name + "<? extends Foo>");
     }
@@ -125,7 +134,7 @@ public final class RxJava2CallAdapterFactory extends CallAdapter.Factory {
       isBody = true;
     }
 
-    return new RxJava2CallAdapter(responseType, scheduler, isResult, isBody, isFlowable,
+    return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable,
         isSingle, isMaybe, false);
   }
 }
diff --git a/samples/pom.xml b/samples/pom.xml
index e266a2b3..5931b34d 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -24,11 +24,6 @@
       <artifactId>retrofit-mock</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>converter-moshi</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>converter-gson</artifactId>
diff --git a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java b/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
deleted file mode 100644
index 0664d348..00000000
--- a/samples/src/main/java/com/example/retrofit/AnnotatedConverters.java
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.example.retrofit;
-
-import com.google.gson.GsonBuilder;
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.annotation.Retention;
-import java.lang.reflect.Type;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.simpleframework.xml.Attribute;
-import org.simpleframework.xml.Default;
-import org.simpleframework.xml.DefaultType;
-import retrofit2.Call;
-import retrofit2.Converter;
-import retrofit2.Retrofit;
-import retrofit2.converter.gson.GsonConverterFactory;
-import retrofit2.converter.moshi.MoshiConverterFactory;
-import retrofit2.converter.simplexml.SimpleXmlConverterFactory;
-import retrofit2.http.GET;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-final class AnnotatedConverters {
-  public static final class AnnotatedConverterFactory extends Converter.Factory {
-    private final Map<Class<? extends Annotation>, Converter.Factory> factories;
-
-    public static final class Builder {
-      private final Map<Class<? extends Annotation>, Converter.Factory> factories =
-          new LinkedHashMap<>();
-
-      public Builder add(Class<? extends Annotation> cls, Converter.Factory factory) {
-        if (cls == null) {
-          throw new NullPointerException("cls == null");
-        }
-        if (factory == null) {
-          throw new NullPointerException("factory == null");
-        }
-        factories.put(cls, factory);
-        return this;
-      }
-
-      public AnnotatedConverterFactory build() {
-        return new AnnotatedConverterFactory(factories);
-      }
-    }
-
-    AnnotatedConverterFactory(Map<Class<? extends Annotation>, Converter.Factory> factories) {
-      this.factories = new LinkedHashMap<>(factories);
-    }
-
-    @Override
-    public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-        Retrofit retrofit) {
-      for (Annotation annotation : annotations) {
-        Converter.Factory factory = factories.get(annotation.annotationType());
-        if (factory != null) {
-          return factory.responseBodyConverter(type, annotations, retrofit);
-        }
-      }
-      return null;
-    }
-
-    @Override public Converter<?, RequestBody> requestBodyConverter(Type type,
-        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
-      for (Annotation annotation : parameterAnnotations) {
-        Converter.Factory factory = factories.get(annotation.annotationType());
-        if (factory != null) {
-          return factory.requestBodyConverter(type, parameterAnnotations, methodAnnotations,
-              retrofit);
-        }
-      }
-      return null;
-    }
-  }
-
-  @Retention(RUNTIME) public @interface Moshi {
-  }
-
-  @Retention(RUNTIME) public @interface Gson {
-  }
-
-  @Retention(RUNTIME) public @interface SimpleXml {
-  }
-
-  @Default(value = DefaultType.FIELD) static final class Library {
-    @Attribute String name;
-  }
-
-  interface Service {
-    @GET("/") @Moshi Call<Library> exampleMoshi();
-
-    @GET("/") @Gson Call<Library> exampleGson();
-
-    @GET("/") @SimpleXml Call<Library> exampleSimpleXml();
-
-    @GET("/") Call<Library> exampleDefault();
-  }
-
-  public static void main(String... args) throws IOException {
-    MockWebServer server = new MockWebServer();
-    server.start();
-    server.enqueue(new MockResponse().setBody("{\"name\": \"Moshi\"}"));
-    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
-    server.enqueue(new MockResponse().setBody("<user name=\"SimpleXML\"/>"));
-    server.enqueue(new MockResponse().setBody("{\"name\": \"Gson\"}"));
-
-    com.squareup.moshi.Moshi moshi = new com.squareup.moshi.Moshi.Builder().build();
-    com.google.gson.Gson gson = new GsonBuilder().create();
-    MoshiConverterFactory moshiConverterFactory = MoshiConverterFactory.create(moshi);
-    GsonConverterFactory gsonConverterFactory = GsonConverterFactory.create(gson);
-    SimpleXmlConverterFactory simpleXmlConverterFactory = SimpleXmlConverterFactory.create();
-    Retrofit retrofit = new Retrofit.Builder().baseUrl(server.url("/"))
-        .addConverterFactory(
-            new AnnotatedConverterFactory.Builder().add(Moshi.class, moshiConverterFactory)
-                .add(Gson.class, gsonConverterFactory)
-                .add(SimpleXml.class, simpleXmlConverterFactory)
-                .build())
-        .addConverterFactory(gsonConverterFactory)
-        .build();
-    Service service = retrofit.create(Service.class);
-
-    Library library1 = service.exampleMoshi().execute().body();
-    System.out.println("Library 1: " + library1.name);
-
-    Library library2 = service.exampleGson().execute().body();
-    System.out.println("Library 2: " + library2.name);
-
-    Library library3 = service.exampleSimpleXml().execute().body();
-    System.out.println("Library 3: " + library3.name);
-
-    Library library4 = service.exampleDefault().execute().body();
-    System.out.println("Library 4: " + library4.name);
-
-    server.shutdown();
-  }
-}
