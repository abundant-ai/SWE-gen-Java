diff --git a/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java b/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java
index 1260b81d..6fa32f3e 100644
--- a/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java
@@ -57,11 +57,35 @@ final class BufferedSinkJsonWriter extends JsonWriter {
   /** The output data, containing at most one top-level array or object. */
   private final BufferedSink sink;
 
-  /** The name/value separator; either ":" or ": ". */
+  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack permits
+  // up to 32 levels of nesting including the top-level document. Deeper nesting is prone to trigger
+  // StackOverflowErrors.
+  private final int[] stack = new int[32];
+  private int stackSize = 0;
+  {
+    push(EMPTY_DOCUMENT);
+  }
+
+  private final String[] pathNames = new String[32];
+  private final int[] pathIndices = new int[32];
+
+  /**
+   * A string containing a full set of spaces for a single level of
+   * indentation, or null for no pretty printing.
+   */
+  private String indent;
+
+  /**
+   * The name/value separator; either ":" or ": ".
+   */
   private String separator = ":";
 
+  private boolean lenient;
+
   private String deferredName;
 
+  private boolean serializeNulls;
+
   private boolean promoteNameToValue;
 
   BufferedSinkJsonWriter(BufferedSink sink) {
@@ -69,12 +93,36 @@ final class BufferedSinkJsonWriter extends JsonWriter {
       throw new NullPointerException("sink == null");
     }
     this.sink = sink;
-    pushScope(EMPTY_DOCUMENT);
   }
 
-  @Override public void setIndent(String indent) {
-    super.setIndent(indent);
-    this.separator = !indent.isEmpty() ? ": " : ":";
+  @Override public final void setIndent(String indent) {
+    if (indent.length() == 0) {
+      this.indent = null;
+      this.separator = ":";
+    } else {
+      this.indent = indent;
+      this.separator = ": ";
+    }
+  }
+
+  @Override public final String getIndent() {
+    return indent != null ? indent : "";
+  }
+
+  @Override public final void setLenient(boolean lenient) {
+    this.lenient = lenient;
+  }
+
+  @Override public boolean isLenient() {
+    return lenient;
+  }
+
+  @Override public final void setSerializeNulls(boolean serializeNulls) {
+    this.serializeNulls = serializeNulls;
+  }
+
+  @Override public final boolean getSerializeNulls() {
+    return serializeNulls;
   }
 
   @Override public JsonWriter beginArray() throws IOException {
@@ -102,7 +150,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
    */
   private JsonWriter open(int empty, String openBracket) throws IOException {
     beforeValue();
-    pushScope(empty);
+    push(empty);
     pathIndices[stackSize - 1] = 0;
     sink.writeUtf8(openBracket);
     return this;
@@ -112,8 +160,9 @@ final class BufferedSinkJsonWriter extends JsonWriter {
    * Closes the current scope by appending any necessary whitespace and the
    * given bracket.
    */
-  private JsonWriter close(int empty, int nonempty, String closeBracket) throws IOException {
-    int context = peekScope();
+  private JsonWriter close(int empty, int nonempty, String closeBracket)
+      throws IOException {
+    int context = peek();
     if (context != nonempty && context != empty) {
       throw new IllegalStateException("Nesting problem.");
     }
@@ -131,6 +180,30 @@ final class BufferedSinkJsonWriter extends JsonWriter {
     return this;
   }
 
+  private void push(int newTop) {
+    if (stackSize == stack.length) {
+      throw new JsonDataException("Nesting too deep at " + getPath() + ": circular reference?");
+    }
+    stack[stackSize++] = newTop;
+  }
+
+  /**
+   * Returns the scope on the top of the stack.
+   */
+  private int peek() {
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    return stack[stackSize - 1];
+  }
+
+  /**
+   * Replace the value on the top of the stack with the given value.
+   */
+  private void replaceTop(int topOfStack) {
+    stack[stackSize - 1] = topOfStack;
+  }
+
   @Override public JsonWriter name(String name) throws IOException {
     if (name == null) {
       throw new NullPointerException("name == null");
@@ -264,7 +337,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
     sink.close();
 
     int size = stackSize;
-    if (size > 1 || size == 1 && scopes[size - 1] != NONEMPTY_DOCUMENT) {
+    if (size > 1 || size == 1 && stack[size - 1] != NONEMPTY_DOCUMENT) {
       throw new IOException("Incomplete document");
     }
     stackSize = 0;
@@ -322,7 +395,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
    * adjusts the stack to expect the name's value.
    */
   private void beforeName() throws IOException {
-    int context = peekScope();
+    int context = peek();
     if (context == NONEMPTY_OBJECT) { // first in object
       sink.writeByte(',');
     } else if (context != EMPTY_OBJECT) { // not in an object!
@@ -339,7 +412,7 @@ final class BufferedSinkJsonWriter extends JsonWriter {
    */
   @SuppressWarnings("fallthrough")
   private void beforeValue() throws IOException {
-    switch (peekScope()) {
+    switch (peek()) {
       case NONEMPTY_DOCUMENT:
         if (!lenient) {
           throw new IllegalStateException(
@@ -371,10 +444,14 @@ final class BufferedSinkJsonWriter extends JsonWriter {
   }
 
   @Override void promoteNameToValue() throws IOException {
-    int context = peekScope();
+    int context = peek();
     if (context != NONEMPTY_OBJECT && context != EMPTY_OBJECT) {
       throw new IllegalStateException("Nesting problem.");
     }
     promoteNameToValue = true;
   }
+
+  @Override public String getPath() {
+    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java b/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
index de4bccbb..c3f5f3e2 100644
--- a/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
@@ -63,6 +63,12 @@ final class BufferedSourceJsonReader extends JsonReader {
   private static final int NUMBER_CHAR_EXP_SIGN = 6;
   private static final int NUMBER_CHAR_EXP_DIGIT = 7;
 
+  /** True to accept non-spec compliant JSON */
+  private boolean lenient = false;
+
+  /** True to throw a {@link JsonDataException} on any attempt to call {@link #skipValue()}. */
+  private boolean failOnUnknown = false;
+
   /** The input JSON. */
   private final BufferedSource source;
   private final Buffer buffer;
@@ -88,13 +94,41 @@ final class BufferedSourceJsonReader extends JsonReader {
    */
   private String peekedString;
 
+  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack permits
+  // up to 32 levels of nesting including the top-level document. Deeper nesting is prone to trigger
+  // StackOverflowErrors.
+  private final int[] stack = new int[32];
+  private int stackSize = 0;
+
+  {
+    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
+  }
+
+  private final String[] pathNames = new String[32];
+  private final int[] pathIndices = new int[32];
+
   BufferedSourceJsonReader(BufferedSource source) {
     if (source == null) {
       throw new NullPointerException("source == null");
     }
     this.source = source;
     this.buffer = source.buffer();
-    pushScope(JsonScope.EMPTY_DOCUMENT);
+  }
+
+  @Override public void setLenient(boolean lenient) {
+    this.lenient = lenient;
+  }
+
+  @Override public boolean isLenient() {
+    return lenient;
+  }
+
+  @Override public void setFailOnUnknown(boolean failOnUnknown) {
+    this.failOnUnknown = failOnUnknown;
+  }
+
+  @Override public boolean failOnUnknown() {
+    return failOnUnknown;
   }
 
   @Override public void beginArray() throws IOException {
@@ -103,7 +137,7 @@ final class BufferedSourceJsonReader extends JsonReader {
       p = doPeek();
     }
     if (p == PEEKED_BEGIN_ARRAY) {
-      pushScope(JsonScope.EMPTY_ARRAY);
+      push(JsonScope.EMPTY_ARRAY);
       pathIndices[stackSize - 1] = 0;
       peeked = PEEKED_NONE;
     } else {
@@ -133,7 +167,7 @@ final class BufferedSourceJsonReader extends JsonReader {
       p = doPeek();
     }
     if (p == PEEKED_BEGIN_OBJECT) {
-      pushScope(JsonScope.EMPTY_OBJECT);
+      push(JsonScope.EMPTY_OBJECT);
       peeked = PEEKED_NONE;
     } else {
       throw new JsonDataException("Expected BEGIN_OBJECT but was " + peek()
@@ -206,9 +240,9 @@ final class BufferedSourceJsonReader extends JsonReader {
   }
 
   private int doPeek() throws IOException {
-    int peekStack = scopes[stackSize - 1];
+    int peekStack = stack[stackSize - 1];
     if (peekStack == JsonScope.EMPTY_ARRAY) {
-      scopes[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
+      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
     } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
       // Look for a comma before the next element.
       int c = nextNonWhitespace(true);
@@ -224,7 +258,7 @@ final class BufferedSourceJsonReader extends JsonReader {
           throw syntaxError("Unterminated array");
       }
     } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
-      scopes[stackSize - 1] = JsonScope.DANGLING_NAME;
+      stack[stackSize - 1] = JsonScope.DANGLING_NAME;
       // Look for a comma before the next element.
       if (peekStack == JsonScope.NONEMPTY_OBJECT) {
         int c = nextNonWhitespace(true);
@@ -265,7 +299,7 @@ final class BufferedSourceJsonReader extends JsonReader {
           }
       }
     } else if (peekStack == JsonScope.DANGLING_NAME) {
-      scopes[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
+      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
       // Look for a colon before the value.
       int c = nextNonWhitespace(true);
       buffer.readByte(); // Consume ':'.
@@ -282,7 +316,7 @@ final class BufferedSourceJsonReader extends JsonReader {
           throw syntaxError("Expected ':'");
       }
     } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
-      scopes[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
+      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
     } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
       int c = nextNonWhitespace(false);
       if (c == -1) {
@@ -889,7 +923,7 @@ final class BufferedSourceJsonReader extends JsonReader {
 
   @Override public void close() throws IOException {
     peeked = PEEKED_NONE;
-    scopes[0] = JsonScope.CLOSED;
+    stack[0] = JsonScope.CLOSED;
     stackSize = 1;
     buffer.clear();
     source.close();
@@ -907,10 +941,10 @@ final class BufferedSourceJsonReader extends JsonReader {
       }
 
       if (p == PEEKED_BEGIN_ARRAY) {
-        pushScope(JsonScope.EMPTY_ARRAY);
+        push(JsonScope.EMPTY_ARRAY);
         count++;
       } else if (p == PEEKED_BEGIN_OBJECT) {
-        pushScope(JsonScope.EMPTY_OBJECT);
+        push(JsonScope.EMPTY_OBJECT);
         count++;
       } else if (p == PEEKED_END_ARRAY) {
         stackSize--;
@@ -934,6 +968,13 @@ final class BufferedSourceJsonReader extends JsonReader {
     pathNames[stackSize - 1] = "null";
   }
 
+  private void push(int newTop) {
+    if (stackSize == stack.length) {
+      throw new JsonDataException("Nesting too deep at " + getPath());
+    }
+    stack[stackSize++] = newTop;
+  }
+
   /**
    * Returns the next character in the stream that is neither whitespace nor a
    * part of a comment. When this returns, the returned character is always at
@@ -1042,6 +1083,10 @@ final class BufferedSourceJsonReader extends JsonReader {
     return "JsonReader(" + source + ")";
   }
 
+  @Override public String getPath() {
+    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
+  }
+
   /**
    * Unescapes the character identified by the character or characters that immediately follow a
    * backslash. The backslash '\' should have already been read. This supports both unicode escapes
@@ -1106,6 +1151,14 @@ final class BufferedSourceJsonReader extends JsonReader {
     }
   }
 
+  /**
+   * Throws a new IO exception with the given message and a context snippet
+   * with this reader's content.
+   */
+  private JsonEncodingException syntaxError(String message) throws JsonEncodingException {
+    throw new JsonEncodingException(message + " at path " + getPath());
+  }
+
   @Override void promoteNameToValue() throws IOException {
     if (hasNext()) {
       peekedString = nextName();
diff --git a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
index 6cf71df8..34409d93 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
@@ -111,11 +111,11 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
      */
     private boolean isPlatformType(Class<?> rawType) {
       String name = rawType.getName();
-      return name.startsWith("android.")
+      return (name.startsWith("android.")
           || name.startsWith("java.")
           || name.startsWith("javax.")
           || name.startsWith("kotlin.")
-          || name.startsWith("scala.");
+          || name.startsWith("scala.")) && !Types.isAllowedPlatformType(rawType);
     }
 
     /** Returns true if fields with {@code modifiers} are included in the emitted JSON. */
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index 0ff01a70..b3ee721b 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -171,21 +171,9 @@ import okio.ByteString;
  * of this class are not thread safe.
  */
 public abstract class JsonReader implements Closeable {
-  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack permits
-  // up to 32 levels of nesting including the top-level document. Deeper nesting is prone to trigger
-  // StackOverflowErrors.
-  int stackSize = 0;
-  final int[] scopes = new int[32];
-  final String[] pathNames = new String[32];
-  final int[] pathIndices = new int[32];
-
-  /** True to accept non-spec compliant JSON */
-  boolean lenient;
-
-  /** True to throw a {@link JsonDataException} on any attempt to call {@link #skipValue()}. */
-  boolean failOnUnknown;
-
-  /** Returns a new instance that reads a JSON-encoded stream from {@code source}. */
+  /**
+   * Returns a new instance that reads a JSON-encoded stream from {@code source}.
+   */
   public static JsonReader of(BufferedSource source) {
     return new BufferedSourceJsonReader(source);
   }
@@ -194,31 +182,6 @@ public abstract class JsonReader implements Closeable {
     // Package-private to control subclasses.
   }
 
-  final void pushScope(int newTop) {
-    if (stackSize == scopes.length) {
-      throw new JsonDataException("Nesting too deep at " + getPath());
-    }
-    scopes[stackSize++] = newTop;
-  }
-
-  /**
-   * Throws a new IO exception with the given message and a context snippet
-   * with this reader's content.
-   */
-  final JsonEncodingException syntaxError(String message) throws JsonEncodingException {
-    throw new JsonEncodingException(message + " at path " + getPath());
-  }
-
-  final JsonDataException typeMismatch(Object value, Object expected) {
-    if (value == null) {
-      return new JsonDataException(
-          "Expected " + expected + " but was null at path " + getPath());
-    } else {
-      return new JsonDataException("Expected " + expected + " but was " + value + ", a "
-          + value.getClass().getName() + ", at path " + getPath());
-    }
-  }
-
   /**
    * Configure this parser to be liberal in what it accepts. By default
    * this parser is strict and only accepts JSON as specified by <a
@@ -244,16 +207,12 @@ public abstract class JsonReader implements Closeable {
    *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.
    * </ul>
    */
-  public final void setLenient(boolean lenient) {
-    this.lenient = lenient;
-  }
+  public abstract void setLenient(boolean lenient);
 
   /**
    * Returns true if this parser is liberal in what it accepts.
    */
-  public final boolean isLenient() {
-    return lenient;
-  }
+  public abstract boolean isLenient();
 
   /**
    * Configure whether this parser throws a {@link JsonDataException} when {@link #skipValue} is
@@ -263,16 +222,12 @@ public abstract class JsonReader implements Closeable {
    * useful in development and debugging because it means a typo like "locatiom" will be detected
    * early. It's potentially harmful in production because it complicates revising a JSON schema.
    */
-  public final void setFailOnUnknown(boolean failOnUnknown) {
-    this.failOnUnknown = failOnUnknown;
-  }
+  public abstract void setFailOnUnknown(boolean failOnUnknown);
 
   /**
    * Returns true if this parser forbids skipping values.
    */
-  public final boolean failOnUnknown() {
-    return failOnUnknown;
-  }
+  public abstract boolean failOnUnknown();
 
   /**
    * Consumes the next token from the JSON stream and asserts that it is the beginning of a new
@@ -394,9 +349,7 @@ public abstract class JsonReader implements Closeable {
    * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
    * the current location in the JSON value.
    */
-  public final String getPath() {
-    return JsonScope.getPath(stackSize, scopes, pathNames, pathIndices);
-  }
+  public abstract String getPath();
 
   /**
    * Changes the reader to treat the next name as a string value. This is useful for map adapters so
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index e1787607..f8d1e4ee 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -116,23 +116,9 @@ import okio.BufferedSink;
  * malformed JSON string will fail with an {@link IllegalStateException}.
  */
 public abstract class JsonWriter implements Closeable, Flushable {
-  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack permits
-  // up to 32 levels of nesting including the top-level document. Deeper nesting is prone to trigger
-  // StackOverflowErrors.
-  int stackSize = 0;
-  final int[] scopes = new int[32];
-  final String[] pathNames = new String[32];
-  final int[] pathIndices = new int[32];
-
   /**
-   * A string containing a full set of spaces for a single level of indentation, or null for no
-   * pretty printing.
+   * Returns a new instance that writes a JSON-encoded stream to {@code sink}.
    */
-  String indent;
-  boolean lenient;
-  boolean serializeNulls;
-
-  /** Returns a new instance that writes a JSON-encoded stream to {@code sink}. */
   public static JsonWriter of(BufferedSink sink) {
     return new BufferedSinkJsonWriter(sink);
   }
@@ -141,26 +127,6 @@ public abstract class JsonWriter implements Closeable, Flushable {
     // Package-private to control subclasses.
   }
 
-  /** Returns the scope on the top of the stack. */
-  final int peekScope() {
-    if (stackSize == 0) {
-      throw new IllegalStateException("JsonWriter is closed.");
-    }
-    return scopes[stackSize - 1];
-  }
-
-  final void pushScope(int newTop) {
-    if (stackSize == scopes.length) {
-      throw new JsonDataException("Nesting too deep at " + getPath() + ": circular reference?");
-    }
-    scopes[stackSize++] = newTop;
-  }
-
-  /** Replace the value on the top of the stack with the given value. */
-  final void replaceTop(int topOfStack) {
-    scopes[stackSize - 1] = topOfStack;
-  }
-
   /**
    * Sets the indentation string to be repeated for each level of indentation
    * in the encoded document. If {@code indent.isEmpty()} the encoded document
@@ -169,17 +135,13 @@ public abstract class JsonWriter implements Closeable, Flushable {
    *
    * @param indent a string containing only whitespace.
    */
-  public void setIndent(String indent) {
-    this.indent = !indent.isEmpty() ? indent : null;
-  }
+  public abstract void setIndent(String indent);
 
   /**
    * Returns a string containing only whitespace, used for each level of
    * indentation. If empty, the encoded document will be compact.
    */
-  public final String getIndent() {
-    return indent != null ? indent : "";
-  }
+  public abstract String getIndent();
 
   /**
    * Configure this writer to relax its syntax rules. By default, this writer
@@ -193,32 +155,24 @@ public abstract class JsonWriter implements Closeable, Flushable {
    *       Double#isInfinite() infinities}.
    * </ul>
    */
-  public final void setLenient(boolean lenient) {
-    this.lenient = lenient;
-  }
+  public abstract void setLenient(boolean lenient);
 
   /**
    * Returns true if this writer has relaxed syntax rules.
    */
-  public final boolean isLenient() {
-    return lenient;
-  }
+  public abstract boolean isLenient();
 
   /**
    * Sets whether object members are serialized when their value is null.
    * This has no impact on array elements. The default is false.
    */
-  public final void setSerializeNulls(boolean serializeNulls) {
-    this.serializeNulls = serializeNulls;
-  }
+  public abstract void setSerializeNulls(boolean serializeNulls);
 
   /**
    * Returns true if object members are serialized when their value is null.
    * This has no impact on array elements. The default is false.
    */
-  public final boolean getSerializeNulls() {
-    return serializeNulls;
-  }
+  public abstract boolean getSerializeNulls();
 
   /**
    * Begins encoding a new array. Each call to this method must be paired with
@@ -322,7 +276,5 @@ public abstract class JsonWriter implements Closeable, Flushable {
    * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
    * the current location in the JSON value.
    */
-  public final String getPath() {
-    return JsonScope.getPath(stackSize, scopes, pathNames, pathIndices);
-  }
+  public abstract String getPath();
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java b/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java
index 8f16fec4..37d628de 100644
--- a/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java
@@ -48,13 +48,35 @@ final class ObjectJsonReader extends JsonReader {
   /** Sentinel object pushed on {@link #stack} when the reader is closed. */
   private static final Object JSON_READER_CLOSED = new Object();
 
+  private int stackSize = 0;
   private final Object[] stack = new Object[32];
+  private final int[] scopes = new int[32];
+  private final String[] pathNames = new String[32];
+  private final int[] pathIndices = new int[32];
+  private boolean lenient;
+  private boolean failOnUnknown;
 
   public ObjectJsonReader(Object root) {
     scopes[stackSize] = JsonScope.NONEMPTY_DOCUMENT;
     stack[stackSize++] = root;
   }
 
+  @Override public void setLenient(boolean lenient) {
+    this.lenient = lenient;
+  }
+
+  @Override public boolean isLenient() {
+    return lenient;
+  }
+
+  @Override public void setFailOnUnknown(boolean failOnUnknown) {
+    this.failOnUnknown = failOnUnknown;
+  }
+
+  @Override public boolean failOnUnknown() {
+    return failOnUnknown;
+  }
+
   @Override public void beginArray() throws IOException {
     List<?> peeked = require(List.class, Token.BEGIN_ARRAY);
 
@@ -272,6 +294,10 @@ final class ObjectJsonReader extends JsonReader {
     }
   }
 
+  @Override public String getPath() {
+    return JsonScope.getPath(stackSize, scopes, pathNames, pathIndices);
+  }
+
   @Override void promoteNameToValue() throws IOException {
     Map.Entry<?, ?> peeked = require(Map.Entry.class, Token.NAME);
 
@@ -318,6 +344,16 @@ final class ObjectJsonReader extends JsonReader {
     throw typeMismatch(name, Token.NAME);
   }
 
+  private JsonDataException typeMismatch(Object value, Object expected) {
+    if (value == null) {
+      return new JsonDataException(
+          "Expected " + expected + " but was null at path " + getPath());
+    } else {
+      return new JsonDataException("Expected " + expected + " but was " + value + ", a "
+          + value.getClass().getName() + ", at path " + getPath());
+    }
+  }
+
   /**
    * Removes a value and prepares for the next. If we're iterating a map or list this advances the
    * iterator.
diff --git a/moshi/src/main/java/com/squareup/moshi/ObjectJsonWriter.java b/moshi/src/main/java/com/squareup/moshi/ObjectJsonWriter.java
index a4b7c533..15a1174c 100644
--- a/moshi/src/main/java/com/squareup/moshi/ObjectJsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ObjectJsonWriter.java
@@ -27,11 +27,19 @@ import static com.squareup.moshi.JsonScope.NONEMPTY_DOCUMENT;
 
 /** Writes JSON by building a Java object comprising maps, lists, and JSON primitives. */
 final class ObjectJsonWriter extends JsonWriter {
+  private String indent;
+  private boolean lenient;
+  private boolean serializeNulls;
+
   private final Object[] stack = new Object[32];
+  private final int[] scopes = new int[32];
+  private final String[] pathNames = new String[32];
+  private final int[] pathIndices = new int[32];
+  private int stackSize = 0;
   private String deferredName;
 
   ObjectJsonWriter() {
-    pushScope(EMPTY_DOCUMENT);
+    scopes[stackSize++] = EMPTY_DOCUMENT;
   }
 
   public Object root() {
@@ -42,6 +50,30 @@ final class ObjectJsonWriter extends JsonWriter {
     return stack[0];
   }
 
+  @Override public void setIndent(String indent) {
+    this.indent = indent;
+  }
+
+  @Override public String getIndent() {
+    return indent;
+  }
+
+  @Override public void setLenient(boolean lenient) {
+    this.lenient = lenient;
+  }
+
+  @Override public boolean isLenient() {
+    return lenient;
+  }
+
+  @Override public void setSerializeNulls(boolean serializeNulls) {
+    this.serializeNulls = serializeNulls;
+  }
+
+  @Override public boolean getSerializeNulls() {
+    return serializeNulls;
+  }
+
   @Override public JsonWriter beginArray() throws IOException {
     if (stackSize == stack.length) {
       throw new JsonDataException("Nesting too deep at " + getPath() + ": circular reference?");
@@ -49,13 +81,14 @@ final class ObjectJsonWriter extends JsonWriter {
     List<Object> list = new ArrayList<>();
     add(list);
     stack[stackSize] = list;
+    scopes[stackSize] = EMPTY_ARRAY;
     pathIndices[stackSize] = 0;
-    pushScope(EMPTY_ARRAY);
+    stackSize++;
     return this;
   }
 
   @Override public JsonWriter endArray() throws IOException {
-    if (peekScope() != EMPTY_ARRAY) {
+    if (peek() != EMPTY_ARRAY) {
       throw new IllegalStateException("Nesting problem.");
     }
     stackSize--;
@@ -71,12 +104,13 @@ final class ObjectJsonWriter extends JsonWriter {
     Map<String, Object> map = new LinkedHashTreeMap<>();
     add(map);
     stack[stackSize] = map;
-    pushScope(EMPTY_OBJECT);
+    scopes[stackSize] = EMPTY_OBJECT;
+    stackSize++;
     return this;
   }
 
   @Override public JsonWriter endObject() throws IOException {
-    if (peekScope() != EMPTY_OBJECT || deferredName != null) {
+    if (peek() != EMPTY_OBJECT || deferredName != null) {
       throw new IllegalStateException("Nesting problem.");
     }
     stackSize--;
@@ -93,7 +127,7 @@ final class ObjectJsonWriter extends JsonWriter {
     if (stackSize == 0) {
       throw new IllegalStateException("JsonWriter is closed.");
     }
-    if (peekScope() != EMPTY_OBJECT || deferredName != null) {
+    if (peek() != EMPTY_OBJECT || deferredName != null) {
       throw new IllegalStateException("Nesting problem.");
     }
     pathNames[stackSize - 1] = name;
@@ -102,27 +136,19 @@ final class ObjectJsonWriter extends JsonWriter {
   }
 
   @Override public JsonWriter value(String value) throws IOException {
-    add(value);
-    pathIndices[stackSize - 1]++;
-    return this;
+    return add(value);
   }
 
   @Override public JsonWriter nullValue() throws IOException {
-    add(null);
-    pathIndices[stackSize - 1]++;
-    return this;
+    return add(null);
   }
 
   @Override public JsonWriter value(boolean value) throws IOException {
-    add(value);
-    pathIndices[stackSize - 1]++;
-    return this;
+    return add(value);
   }
 
   @Override public JsonWriter value(Boolean value) throws IOException {
-    add(value);
-    pathIndices[stackSize - 1]++;
-    return this;
+    return add(value);
   }
 
   @Override public JsonWriter value(double value) throws IOException {
@@ -130,9 +156,7 @@ final class ObjectJsonWriter extends JsonWriter {
   }
 
   @Override public JsonWriter value(long value) throws IOException {
-    add(value);
-    pathIndices[stackSize - 1]++;
-    return this;
+    return add(value);
   }
 
   @Override public JsonWriter value(Number value) throws IOException {
@@ -142,15 +166,17 @@ final class ObjectJsonWriter extends JsonWriter {
         throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
       }
     }
-    add(value);
-    pathIndices[stackSize - 1]++;
-    return this;
+    return add(value);
   }
 
   @Override void promoteNameToValue() throws IOException {
     throw new UnsupportedOperationException();
   }
 
+  @Override public String getPath() {
+    return JsonScope.getPath(stackSize, scopes, pathNames, pathIndices);
+  }
+
   @Override public void close() throws IOException {
     int size = stackSize;
     if (size > 1 || size == 1 && scopes[size - 1] != NONEMPTY_DOCUMENT) {
@@ -165,8 +191,18 @@ final class ObjectJsonWriter extends JsonWriter {
     }
   }
 
+  /**
+   * Returns the scope on the top of the stack.
+   */
+  private int peek() {
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    return scopes[stackSize - 1];
+  }
+
   private ObjectJsonWriter add(Object newTop) {
-    int scope = peekScope();
+    int scope = peek();
 
     if (stackSize == 1) {
       if (scope != EMPTY_DOCUMENT) {
diff --git a/moshi/src/main/java/com/squareup/moshi/Types.java b/moshi/src/main/java/com/squareup/moshi/Types.java
index 67cac084..f6c0ede5 100644
--- a/moshi/src/main/java/com/squareup/moshi/Types.java
+++ b/moshi/src/main/java/com/squareup/moshi/Types.java
@@ -386,6 +386,22 @@ public final class Types {
     return unknown;
   }
 
+  /**
+   * Returns true if this is a Type supported by {@link StandardJsonAdapters#FACTORY}.
+   */
+  static boolean isAllowedPlatformType(Type type) {
+    return type == Boolean.class
+        || type == Byte.class
+        || type == Character.class
+        || type == Double.class
+        || type == Float.class
+        || type == Integer.class
+        || type == Long.class
+        || type == Short.class
+        || type == String.class
+        || type == Object.class;
+  }
+
   private static int indexOf(Object[] array, Object toFind) {
     for (int i = 0; i < array.length; i++) {
       if (toFind.equals(array[i])) return i;
