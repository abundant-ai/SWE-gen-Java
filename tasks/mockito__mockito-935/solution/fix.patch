diff --git a/src/main/java/org/mockito/MockSettings.java b/src/main/java/org/mockito/MockSettings.java
index 137764c35..29745d407 100644
--- a/src/main/java/org/mockito/MockSettings.java
+++ b/src/main/java/org/mockito/MockSettings.java
@@ -240,19 +240,25 @@ public interface MockSettings extends Serializable {
      * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
      *   .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
      *
+     * //Mocking an abstract class with constructor arguments
+     * SomeAbstract spy = mock(SomeAbstract.class, withSettings()
+     *   .useConstructor("arg1", 123).defaultAnswer(CALLS_REAL_METHODS));
+     *
      * //Mocking a non-static inner abstract class:
      * InnerAbstract spy = mock(InnerAbstract.class, withSettings()
      *   .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
      * </code></pre>
      *
+     * @param args The arguments to pass to the constructor. Not passing any arguments means that a parameter-less
+     *             constructor will be called
      * @return settings instance so that you can fluently specify other settings
-     * @since 1.10.12
+     * @since 2.7.14 (useConstructor with no arguments was supported since 1.10.12)
      */
     @Incubating
-    MockSettings useConstructor();
+    MockSettings useConstructor(Object... args);
 
     /**
-     * Makes it possible to mock non-static inner classes in conjunction with {@link #useConstructor()}.
+     * Makes it possible to mock non-static inner classes in conjunction with {@link #useConstructor(Object...)}.
      * <p>
      * Example:
      * <pre class="code"><code class="java">
diff --git a/src/main/java/org/mockito/Mockito.java b/src/main/java/org/mockito/Mockito.java
index 8db730489..5e74aa779 100644
--- a/src/main/java/org/mockito/Mockito.java
+++ b/src/main/java/org/mockito/Mockito.java
@@ -65,7 +65,7 @@ import org.mockito.verification.*;
  *      <a href="#27">27. Delegate calls to real instance (Since 1.9.5)</a><br/>
  *      <a href="#28">28. <code>MockMaker</code> API (Since 1.9.5)</a><br/>
  *      <a href="#29">29. BDD style verification (Since 1.10.0)</a><br/>
- *      <a href="#30">30. Spying or mocking abstract classes (Since 1.10.12) and Java 8 default methods (Since release 2.x)</a><br/>
+ *      <a href="#30">30. Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)</a><br/>
  *      <a href="#31">31. Mockito mocks can be <em>serialized</em> / <em>deserialized</em> across classloaders (Since 1.10.0)</a></h3><br/>
  *      <a href="#32">32. Better generic support with deep stubs (Since 1.10.0)</a></h3><br/>
  *      <a href="#32">33. Mockito JUnit rule (Since 1.10.17)</a><br/>
@@ -1017,7 +1017,7 @@ import org.mockito.verification.*;
  *
  *
  *
- * <h3 id="30">30. <a class="meaningful_link" href="#spying_abstract_classes" name="spying_abstract_classes">Spying or mocking abstract classes (Since 1.10.12) and Java 8 default methods (Since release 2.x)</a></h3>
+ * <h3 id="30">30. <a class="meaningful_link" href="#spying_abstract_classes" name="spying_abstract_classes">Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)</a></h3>
  *
  * It is now possible to conveniently spy on abstract classes. Note that overusing spies hints at code design smells (see {@link #spy(Object)}).
  * <p>
@@ -1030,19 +1030,23 @@ import org.mockito.verification.*;
  * //convenience API, new overloaded spy() method:
  * SomeAbstract spy = spy(SomeAbstract.class);
  *
- * // Mocking abstract methods, spying default methods of an interface
+ * //Mocking abstract methods, spying default methods of an interface (only avilable since 2.7.13)
  * Function<Foo, Bar> function = spy(Function.class);
  *
  * //Robust API, via settings builder:
  * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
  *    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
  *
+ * //Mocking an abstract class with constructor arguments (only available since 2.7.14)
+ * SomeAbstract spy = mock(SomeAbstract.class, withSettings()
+ *   .useConstructor("arg1", 123).defaultAnswer(CALLS_REAL_METHODS));
+ *
  * //Mocking a non-static inner abstract class:
  * InnerAbstract spy = mock(InnerAbstract.class, withSettings()
  *    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
  * </code></pre>
  *
- * For more information please see {@link MockSettings#useConstructor()}.
+ * For more information please see {@link MockSettings#useConstructor(Object...)}.
  *
  *
  *
diff --git a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
index 0b761747c..ec0109afc 100644
--- a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
+++ b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
@@ -9,6 +9,7 @@ import org.mockito.MockSettings;
 import static org.mockito.internal.exceptions.Reporter.*;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.debugging.VerboseMockInvocationLogger;
+import org.mockito.internal.util.Checks;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockNameImpl;
 import org.mockito.listeners.InvocationListener;
@@ -18,6 +19,8 @@ import org.mockito.mock.SerializableMode;
 import org.mockito.stubbing.Answer;
 
 import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -30,6 +33,7 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
     private static final long serialVersionUID = 4475297236197939569L;
     private boolean useConstructor;
     private Object outerClassInstance;
+    private Object[] constructorArgs;
 
     public MockSettings serializable() {
         return serializable(SerializableMode.BASIC);
@@ -95,8 +99,12 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
         return this;
     }
 
-    public MockSettings useConstructor() {
+    public MockSettings useConstructor(Object... constructorArgs) {
+        Checks.checkNotNull(constructorArgs,
+            "constructorArgs",
+            "If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
         this.useConstructor = true;
+        this.constructorArgs = constructorArgs;
         return this;
     }
 
@@ -113,6 +121,16 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
         return outerClassInstance;
     }
 
+    public Object[] getConstructorArgs() {
+        if (outerClassInstance == null) {
+            return constructorArgs;
+        }
+        List<Object> resultArgs = new ArrayList<Object>(constructorArgs.length + 1);
+        resultArgs.add(outerClassInstance);
+        resultArgs.addAll(Arrays.asList(constructorArgs));
+        return resultArgs.toArray(new Object[constructorArgs.length + 1]);
+    }
+
     public boolean isStubOnly() {
         return this.stubOnly;
     }
diff --git a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
index 049d1b8e3..7161fa78e 100644
--- a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
+++ b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
@@ -5,59 +5,110 @@
 package org.mockito.internal.creation.instance;
 
 import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+
+import org.mockito.internal.util.Primitives;
 import org.mockito.internal.util.reflection.AccessibilityChanger;
 
 import static org.mockito.internal.util.StringUtil.join;
 
 public class ConstructorInstantiator implements Instantiator {
 
-    private final Object outerClassInstance;
+    /**
+     * Whether or not the constructors used for creating an object refer to an outer instance or not.
+     * This member is only used to for constructing error messages.
+     * If an outer inject exists, it would be the first ([0]) element of the {@link #constructorArgs} array.
+     */
+    private final boolean hasOuterClassInstance;
+    private final Object[] constructorArgs;
 
-    public ConstructorInstantiator(Object outerClassInstance) {
-        this.outerClassInstance = outerClassInstance;
+    public ConstructorInstantiator(boolean hasOuterClassInstance, Object... constructorArgs) {
+        this.hasOuterClassInstance = hasOuterClassInstance;
+        this.constructorArgs = constructorArgs;
     }
 
     public <T> T newInstance(Class<T> cls) {
-        if (outerClassInstance == null) {
-            return noArgConstructor(cls);
-        }
-        return withParams(cls, outerClassInstance);
+        return withParams(cls, constructorArgs);
     }
 
-    private static <T> T withParams(Class<T> cls, Object... params) {
+    private <T> T withParams(Class<T> cls, Object... params) {
+        List<Constructor<?>> matchingConstructors = new LinkedList<Constructor<?>>();
         try {
-            //this is kind of over-engineered because we don't need to support more params
-            //however, I know we will be needing it :)
             for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
                 Class<?>[] types = constructor.getParameterTypes();
                 if (paramsMatch(types, params)) {
-                    return invokeConstructor(constructor, params);
+                    matchingConstructors.add(constructor);
                 }
             }
+
+            if (matchingConstructors.size() == 1) {
+                return invokeConstructor(matchingConstructors.get(0), params);
+            }
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
-        throw noMatchingConstructor(cls);
+        if (matchingConstructors.size() == 0) {
+            throw noMatchingConstructor(cls);
+        } else {
+            throw multipleMatchingConstructors(cls, matchingConstructors);
+        }
     }
 
     @SuppressWarnings("unchecked")
-    private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, java.lang.reflect.InvocationTargetException {
+    private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, InvocationTargetException {
         AccessibilityChanger accessibility = new AccessibilityChanger();
         accessibility.enableAccess(constructor);
         return (T) constructor.newInstance(params);
     }
 
-    private static <T> InstantiationException paramsException(Class<T> cls, Exception cause) {
-        return new InstantiationException(
-                join("Unable to create instance of '" + cls.getSimpleName() + "'.",
-                     "Please ensure that the outer instance has correct type and that the target class has 0-arg constructor."),
-                cause);
+    private InstantiationException paramsException(Class<?> cls, Exception e) {
+        return new InstantiationException(join(
+                "Unable to create instance of '" + cls.getSimpleName() + "'.",
+                "Please ensure the target class has " + constructorArgsString() + " and executes cleanly.")
+                , e);
     }
 
-    private static <T> InstantiationException noMatchingConstructor(Class<T> cls) {
-        return new InstantiationException(
-                join("Unable to create instance of '" + cls.getSimpleName() + "'.",
-                     "Unable to find a matching 1-arg constructor for the outer instance.")
+    private String constructorArgTypes() {
+        int argPos = 0;
+        if (hasOuterClassInstance) {
+            ++argPos;
+        }
+        String[] constructorArgTypes = new String[constructorArgs.length - argPos];
+        for (int i = argPos; i < constructorArgs.length; ++i) {
+            constructorArgTypes[i - argPos] = constructorArgs[i] == null ? null : constructorArgs[i].getClass().getName();
+        }
+        return Arrays.toString(constructorArgTypes);
+    }
+
+    private InstantiationException noMatchingConstructor(Class<?> cls) {
+        String constructorString = constructorArgsString();
+        String outerClassString = "";
+        if (hasOuterClassInstance) {
+            outerClassString = " and that it's indeed an inner class of the passed instance of type " +
+                constructorArgs[0].getClass().getName();
+        }
+        return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
+                "Please ensure that the target class has " + constructorString + outerClassString + ".")
+                , null);
+    }
+
+    private String constructorArgsString() {
+        String constructorString;
+        if (constructorArgs.length == 0 || (hasOuterClassInstance && constructorArgs.length == 1)) {
+            constructorString = "a 0-arg constructor";
+        } else {
+            constructorString = "a constructor that matches these argument types: " + constructorArgTypes();
+        }
+        return constructorString;
+    }
+
+    private InstantiationException multipleMatchingConstructors(Class<?> cls, List<Constructor<?>> constructors) {
+        return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
+                "Multiple constructors could be matched to arguments of types " + constructorArgTypes() + ":",
+                join("", constructors))
                 , null);
     }
 
@@ -66,21 +117,15 @@ public class ConstructorInstantiator implements Instantiator {
             return false;
         }
         for (int i = 0; i < params.length; i++) {
-            if (!types[i].isInstance(params[i])) {
+            if (params[i] == null) {
+                if (types[i].isPrimitive()) {
+                    return false;
+                }
+            } else if ((!types[i].isPrimitive() && !types[i].isInstance(params[i])) ||
+                    (types[i].isPrimitive() && !types[i].equals(Primitives.primitiveTypeOf(params[i].getClass())))) {
                 return false;
             }
         }
         return true;
     }
-
-    private static <T> T noArgConstructor(Class<T> cls) {
-        try {
-            return invokeConstructor(cls.getDeclaredConstructor());
-        } catch (Throwable t) {
-            throw new InstantiationException(join(
-                    "Unable to create instance of '" + cls.getSimpleName() + "'.",
-                    "Please ensure it has 0-arg constructor which invokes cleanly."),
-                                             t);
-        }
-    }
 }
diff --git a/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java b/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
index fe44b6fd3..22d06d116 100644
--- a/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
+++ b/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
@@ -12,8 +12,8 @@ public class DefaultInstantiatorProvider implements InstantiatorProvider {
     private final static Instantiator INSTANCE = new ObjenesisInstantiator();
 
     public Instantiator getInstantiator(MockCreationSettings<?> settings) {
-        if (settings != null && settings.isUsingConstructor()) {
-            return new ConstructorInstantiator(settings.getOuterClassInstance());
+        if (settings != null && settings.getConstructorArgs() != null) {
+            return new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs());
         } else {
             return INSTANCE;
         }
diff --git a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
index f40450cfe..3fe179999 100644
--- a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
+++ b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
@@ -32,6 +32,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
     protected boolean stubOnly;
     private boolean useConstructor;
     private Object outerClassInstance;
+    private Object[] constructorArgs;
 
     public CreationSettings() {}
 
@@ -48,6 +49,7 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         this.stubOnly = copy.stubOnly;
         this.useConstructor = copy.isUsingConstructor();
         this.outerClassInstance = copy.getOuterClassInstance();
+        this.constructorArgs = copy.getConstructorArgs();
     }
 
     public Class<T> getTypeToMock() {
@@ -114,6 +116,11 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         return useConstructor;
     }
 
+    @Override
+    public Object[] getConstructorArgs() {
+        return constructorArgs;
+    }
+
     public Object getOuterClassInstance() {
         return outerClassInstance;
     }
diff --git a/src/main/java/org/mockito/internal/util/Checks.java b/src/main/java/org/mockito/internal/util/Checks.java
index 9731dbe3b..b672f6a0d 100644
--- a/src/main/java/org/mockito/internal/util/Checks.java
+++ b/src/main/java/org/mockito/internal/util/Checks.java
@@ -11,8 +11,16 @@ package org.mockito.internal.util;
 public class Checks {
 
     public static <T> T checkNotNull(T value, String checkedValue) {
+        return checkNotNull(value, checkedValue, null);
+    }
+
+    public static <T> T checkNotNull(T value, String checkedValue, String additionalMessage) {
         if(value == null) {
-            throw new IllegalArgumentException(checkedValue + " should not be null");
+            String message = checkedValue + " should not be null";
+            if (additionalMessage != null) {
+                message += ". " + additionalMessage;
+            }
+            throw new IllegalArgumentException(message);
         }
         return value;
     }
diff --git a/src/main/java/org/mockito/mock/MockCreationSettings.java b/src/main/java/org/mockito/mock/MockCreationSettings.java
index f27d48146..a0c088b87 100644
--- a/src/main/java/org/mockito/mock/MockCreationSettings.java
+++ b/src/main/java/org/mockito/mock/MockCreationSettings.java
@@ -72,6 +72,18 @@ public interface MockCreationSettings<T> {
     @Incubating
     boolean isUsingConstructor();
 
+    /**
+     * Used when arguments should be passed to the mocked object's constructor, regardless of whether these
+     * arguments are supplied directly, or whether they include the outer instance.
+     *
+     * @return An array of arguments that are passed to the mocked object's constructor. If
+     * {@link #getOuterClassInstance()} is available, it is prepended to the passed arguments.
+     *
+     * @since 2.7.14
+     */
+    @Incubating
+    public Object[] getConstructorArgs();
+
     /**
      * Used when mocking non-static inner classes in conjunction with {@link #isUsingConstructor()}
      *
