diff --git a/src/main/java/org/mockito/MockSettings.java b/src/main/java/org/mockito/MockSettings.java
index 29745d407..137764c35 100644
--- a/src/main/java/org/mockito/MockSettings.java
+++ b/src/main/java/org/mockito/MockSettings.java
@@ -240,25 +240,19 @@ public interface MockSettings extends Serializable {
      * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
      *   .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
      *
-     * //Mocking an abstract class with constructor arguments
-     * SomeAbstract spy = mock(SomeAbstract.class, withSettings()
-     *   .useConstructor("arg1", 123).defaultAnswer(CALLS_REAL_METHODS));
-     *
      * //Mocking a non-static inner abstract class:
      * InnerAbstract spy = mock(InnerAbstract.class, withSettings()
      *   .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
      * </code></pre>
      *
-     * @param args The arguments to pass to the constructor. Not passing any arguments means that a parameter-less
-     *             constructor will be called
      * @return settings instance so that you can fluently specify other settings
-     * @since 2.7.14 (useConstructor with no arguments was supported since 1.10.12)
+     * @since 1.10.12
      */
     @Incubating
-    MockSettings useConstructor(Object... args);
+    MockSettings useConstructor();
 
     /**
-     * Makes it possible to mock non-static inner classes in conjunction with {@link #useConstructor(Object...)}.
+     * Makes it possible to mock non-static inner classes in conjunction with {@link #useConstructor()}.
      * <p>
      * Example:
      * <pre class="code"><code class="java">
diff --git a/src/main/java/org/mockito/Mockito.java b/src/main/java/org/mockito/Mockito.java
index 5e74aa779..8db730489 100644
--- a/src/main/java/org/mockito/Mockito.java
+++ b/src/main/java/org/mockito/Mockito.java
@@ -65,7 +65,7 @@ import org.mockito.verification.*;
  *      <a href="#27">27. Delegate calls to real instance (Since 1.9.5)</a><br/>
  *      <a href="#28">28. <code>MockMaker</code> API (Since 1.9.5)</a><br/>
  *      <a href="#29">29. BDD style verification (Since 1.10.0)</a><br/>
- *      <a href="#30">30. Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)</a><br/>
+ *      <a href="#30">30. Spying or mocking abstract classes (Since 1.10.12) and Java 8 default methods (Since release 2.x)</a><br/>
  *      <a href="#31">31. Mockito mocks can be <em>serialized</em> / <em>deserialized</em> across classloaders (Since 1.10.0)</a></h3><br/>
  *      <a href="#32">32. Better generic support with deep stubs (Since 1.10.0)</a></h3><br/>
  *      <a href="#32">33. Mockito JUnit rule (Since 1.10.17)</a><br/>
@@ -1017,7 +1017,7 @@ import org.mockito.verification.*;
  *
  *
  *
- * <h3 id="30">30. <a class="meaningful_link" href="#spying_abstract_classes" name="spying_abstract_classes">Spying or mocking abstract classes (Since 1.10.12, further enhanced in 2.7.13 and 2.7.14)</a></h3>
+ * <h3 id="30">30. <a class="meaningful_link" href="#spying_abstract_classes" name="spying_abstract_classes">Spying or mocking abstract classes (Since 1.10.12) and Java 8 default methods (Since release 2.x)</a></h3>
  *
  * It is now possible to conveniently spy on abstract classes. Note that overusing spies hints at code design smells (see {@link #spy(Object)}).
  * <p>
@@ -1030,23 +1030,19 @@ import org.mockito.verification.*;
  * //convenience API, new overloaded spy() method:
  * SomeAbstract spy = spy(SomeAbstract.class);
  *
- * //Mocking abstract methods, spying default methods of an interface (only avilable since 2.7.13)
+ * // Mocking abstract methods, spying default methods of an interface
  * Function<Foo, Bar> function = spy(Function.class);
  *
  * //Robust API, via settings builder:
  * OtherAbstract spy = mock(OtherAbstract.class, withSettings()
  *    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));
  *
- * //Mocking an abstract class with constructor arguments (only available since 2.7.14)
- * SomeAbstract spy = mock(SomeAbstract.class, withSettings()
- *   .useConstructor("arg1", 123).defaultAnswer(CALLS_REAL_METHODS));
- *
  * //Mocking a non-static inner abstract class:
  * InnerAbstract spy = mock(InnerAbstract.class, withSettings()
  *    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
  * </code></pre>
  *
- * For more information please see {@link MockSettings#useConstructor(Object...)}.
+ * For more information please see {@link MockSettings#useConstructor()}.
  *
  *
  *
diff --git a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
index ec0109afc..0b761747c 100644
--- a/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
+++ b/src/main/java/org/mockito/internal/creation/MockSettingsImpl.java
@@ -9,7 +9,6 @@ import org.mockito.MockSettings;
 import static org.mockito.internal.exceptions.Reporter.*;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.debugging.VerboseMockInvocationLogger;
-import org.mockito.internal.util.Checks;
 import org.mockito.internal.util.MockCreationValidator;
 import org.mockito.internal.util.MockNameImpl;
 import org.mockito.listeners.InvocationListener;
@@ -19,8 +18,6 @@ import org.mockito.mock.SerializableMode;
 import org.mockito.stubbing.Answer;
 
 import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -33,7 +30,6 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
     private static final long serialVersionUID = 4475297236197939569L;
     private boolean useConstructor;
     private Object outerClassInstance;
-    private Object[] constructorArgs;
 
     public MockSettings serializable() {
         return serializable(SerializableMode.BASIC);
@@ -99,12 +95,8 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
         return this;
     }
 
-    public MockSettings useConstructor(Object... constructorArgs) {
-        Checks.checkNotNull(constructorArgs,
-            "constructorArgs",
-            "If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
+    public MockSettings useConstructor() {
         this.useConstructor = true;
-        this.constructorArgs = constructorArgs;
         return this;
     }
 
@@ -121,16 +113,6 @@ public class MockSettingsImpl<T> extends CreationSettings<T> implements MockSett
         return outerClassInstance;
     }
 
-    public Object[] getConstructorArgs() {
-        if (outerClassInstance == null) {
-            return constructorArgs;
-        }
-        List<Object> resultArgs = new ArrayList<Object>(constructorArgs.length + 1);
-        resultArgs.add(outerClassInstance);
-        resultArgs.addAll(Arrays.asList(constructorArgs));
-        return resultArgs.toArray(new Object[constructorArgs.length + 1]);
-    }
-
     public boolean isStubOnly() {
         return this.stubOnly;
     }
diff --git a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
index 7161fa78e..049d1b8e3 100644
--- a/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
+++ b/src/main/java/org/mockito/internal/creation/instance/ConstructorInstantiator.java
@@ -5,110 +5,59 @@
 package org.mockito.internal.creation.instance;
 
 import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.util.Arrays;
-import java.util.LinkedList;
-import java.util.List;
-
-import org.mockito.internal.util.Primitives;
 import org.mockito.internal.util.reflection.AccessibilityChanger;
 
 import static org.mockito.internal.util.StringUtil.join;
 
 public class ConstructorInstantiator implements Instantiator {
 
-    /**
-     * Whether or not the constructors used for creating an object refer to an outer instance or not.
-     * This member is only used to for constructing error messages.
-     * If an outer inject exists, it would be the first ([0]) element of the {@link #constructorArgs} array.
-     */
-    private final boolean hasOuterClassInstance;
-    private final Object[] constructorArgs;
+    private final Object outerClassInstance;
 
-    public ConstructorInstantiator(boolean hasOuterClassInstance, Object... constructorArgs) {
-        this.hasOuterClassInstance = hasOuterClassInstance;
-        this.constructorArgs = constructorArgs;
+    public ConstructorInstantiator(Object outerClassInstance) {
+        this.outerClassInstance = outerClassInstance;
     }
 
     public <T> T newInstance(Class<T> cls) {
-        return withParams(cls, constructorArgs);
+        if (outerClassInstance == null) {
+            return noArgConstructor(cls);
+        }
+        return withParams(cls, outerClassInstance);
     }
 
-    private <T> T withParams(Class<T> cls, Object... params) {
-        List<Constructor<?>> matchingConstructors = new LinkedList<Constructor<?>>();
+    private static <T> T withParams(Class<T> cls, Object... params) {
         try {
+            //this is kind of over-engineered because we don't need to support more params
+            //however, I know we will be needing it :)
             for (Constructor<?> constructor : cls.getDeclaredConstructors()) {
                 Class<?>[] types = constructor.getParameterTypes();
                 if (paramsMatch(types, params)) {
-                    matchingConstructors.add(constructor);
+                    return invokeConstructor(constructor, params);
                 }
             }
-
-            if (matchingConstructors.size() == 1) {
-                return invokeConstructor(matchingConstructors.get(0), params);
-            }
         } catch (Exception e) {
             throw paramsException(cls, e);
         }
-        if (matchingConstructors.size() == 0) {
-            throw noMatchingConstructor(cls);
-        } else {
-            throw multipleMatchingConstructors(cls, matchingConstructors);
-        }
+        throw noMatchingConstructor(cls);
     }
 
     @SuppressWarnings("unchecked")
-    private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, InvocationTargetException {
+    private static <T> T invokeConstructor(Constructor<?> constructor, Object... params) throws java.lang.InstantiationException, IllegalAccessException, java.lang.reflect.InvocationTargetException {
         AccessibilityChanger accessibility = new AccessibilityChanger();
         accessibility.enableAccess(constructor);
         return (T) constructor.newInstance(params);
     }
 
-    private InstantiationException paramsException(Class<?> cls, Exception e) {
-        return new InstantiationException(join(
-                "Unable to create instance of '" + cls.getSimpleName() + "'.",
-                "Please ensure the target class has " + constructorArgsString() + " and executes cleanly.")
-                , e);
+    private static <T> InstantiationException paramsException(Class<T> cls, Exception cause) {
+        return new InstantiationException(
+                join("Unable to create instance of '" + cls.getSimpleName() + "'.",
+                     "Please ensure that the outer instance has correct type and that the target class has 0-arg constructor."),
+                cause);
     }
 
-    private String constructorArgTypes() {
-        int argPos = 0;
-        if (hasOuterClassInstance) {
-            ++argPos;
-        }
-        String[] constructorArgTypes = new String[constructorArgs.length - argPos];
-        for (int i = argPos; i < constructorArgs.length; ++i) {
-            constructorArgTypes[i - argPos] = constructorArgs[i] == null ? null : constructorArgs[i].getClass().getName();
-        }
-        return Arrays.toString(constructorArgTypes);
-    }
-
-    private InstantiationException noMatchingConstructor(Class<?> cls) {
-        String constructorString = constructorArgsString();
-        String outerClassString = "";
-        if (hasOuterClassInstance) {
-            outerClassString = " and that it's indeed an inner class of the passed instance of type " +
-                constructorArgs[0].getClass().getName();
-        }
-        return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
-                "Please ensure that the target class has " + constructorString + outerClassString + ".")
-                , null);
-    }
-
-    private String constructorArgsString() {
-        String constructorString;
-        if (constructorArgs.length == 0 || (hasOuterClassInstance && constructorArgs.length == 1)) {
-            constructorString = "a 0-arg constructor";
-        } else {
-            constructorString = "a constructor that matches these argument types: " + constructorArgTypes();
-        }
-        return constructorString;
-    }
-
-    private InstantiationException multipleMatchingConstructors(Class<?> cls, List<Constructor<?>> constructors) {
-        return new InstantiationException(join("Unable to create instance of '" + cls.getSimpleName() + "'.",
-                "Multiple constructors could be matched to arguments of types " + constructorArgTypes() + ":",
-                join("", constructors))
+    private static <T> InstantiationException noMatchingConstructor(Class<T> cls) {
+        return new InstantiationException(
+                join("Unable to create instance of '" + cls.getSimpleName() + "'.",
+                     "Unable to find a matching 1-arg constructor for the outer instance.")
                 , null);
     }
 
@@ -117,15 +66,21 @@ public class ConstructorInstantiator implements Instantiator {
             return false;
         }
         for (int i = 0; i < params.length; i++) {
-            if (params[i] == null) {
-                if (types[i].isPrimitive()) {
-                    return false;
-                }
-            } else if ((!types[i].isPrimitive() && !types[i].isInstance(params[i])) ||
-                    (types[i].isPrimitive() && !types[i].equals(Primitives.primitiveTypeOf(params[i].getClass())))) {
+            if (!types[i].isInstance(params[i])) {
                 return false;
             }
         }
         return true;
     }
+
+    private static <T> T noArgConstructor(Class<T> cls) {
+        try {
+            return invokeConstructor(cls.getDeclaredConstructor());
+        } catch (Throwable t) {
+            throw new InstantiationException(join(
+                    "Unable to create instance of '" + cls.getSimpleName() + "'.",
+                    "Please ensure it has 0-arg constructor which invokes cleanly."),
+                                             t);
+        }
+    }
 }
diff --git a/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java b/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
index 22d06d116..fe44b6fd3 100644
--- a/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
+++ b/src/main/java/org/mockito/internal/creation/instance/DefaultInstantiatorProvider.java
@@ -12,8 +12,8 @@ public class DefaultInstantiatorProvider implements InstantiatorProvider {
     private final static Instantiator INSTANCE = new ObjenesisInstantiator();
 
     public Instantiator getInstantiator(MockCreationSettings<?> settings) {
-        if (settings != null && settings.getConstructorArgs() != null) {
-            return new ConstructorInstantiator(settings.getOuterClassInstance() != null, settings.getConstructorArgs());
+        if (settings != null && settings.isUsingConstructor()) {
+            return new ConstructorInstantiator(settings.getOuterClassInstance());
         } else {
             return INSTANCE;
         }
diff --git a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
index 3fe179999..f40450cfe 100644
--- a/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
+++ b/src/main/java/org/mockito/internal/creation/settings/CreationSettings.java
@@ -32,7 +32,6 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
     protected boolean stubOnly;
     private boolean useConstructor;
     private Object outerClassInstance;
-    private Object[] constructorArgs;
 
     public CreationSettings() {}
 
@@ -49,7 +48,6 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         this.stubOnly = copy.stubOnly;
         this.useConstructor = copy.isUsingConstructor();
         this.outerClassInstance = copy.getOuterClassInstance();
-        this.constructorArgs = copy.getConstructorArgs();
     }
 
     public Class<T> getTypeToMock() {
@@ -116,11 +114,6 @@ public class CreationSettings<T> implements MockCreationSettings<T>, Serializabl
         return useConstructor;
     }
 
-    @Override
-    public Object[] getConstructorArgs() {
-        return constructorArgs;
-    }
-
     public Object getOuterClassInstance() {
         return outerClassInstance;
     }
diff --git a/src/main/java/org/mockito/internal/util/Checks.java b/src/main/java/org/mockito/internal/util/Checks.java
index b672f6a0d..9731dbe3b 100644
--- a/src/main/java/org/mockito/internal/util/Checks.java
+++ b/src/main/java/org/mockito/internal/util/Checks.java
@@ -11,16 +11,8 @@ package org.mockito.internal.util;
 public class Checks {
 
     public static <T> T checkNotNull(T value, String checkedValue) {
-        return checkNotNull(value, checkedValue, null);
-    }
-
-    public static <T> T checkNotNull(T value, String checkedValue, String additionalMessage) {
         if(value == null) {
-            String message = checkedValue + " should not be null";
-            if (additionalMessage != null) {
-                message += ". " + additionalMessage;
-            }
-            throw new IllegalArgumentException(message);
+            throw new IllegalArgumentException(checkedValue + " should not be null");
         }
         return value;
     }
diff --git a/src/main/java/org/mockito/mock/MockCreationSettings.java b/src/main/java/org/mockito/mock/MockCreationSettings.java
index a0c088b87..f27d48146 100644
--- a/src/main/java/org/mockito/mock/MockCreationSettings.java
+++ b/src/main/java/org/mockito/mock/MockCreationSettings.java
@@ -72,18 +72,6 @@ public interface MockCreationSettings<T> {
     @Incubating
     boolean isUsingConstructor();
 
-    /**
-     * Used when arguments should be passed to the mocked object's constructor, regardless of whether these
-     * arguments are supplied directly, or whether they include the outer instance.
-     *
-     * @return An array of arguments that are passed to the mocked object's constructor. If
-     * {@link #getOuterClassInstance()} is available, it is prepended to the passed arguments.
-     *
-     * @since 2.7.14
-     */
-    @Incubating
-    public Object[] getConstructorArgs();
-
     /**
      * Used when mocking non-static inner classes in conjunction with {@link #isUsingConstructor()}
      *
diff --git a/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java b/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
index cf30bc1ce..b669fa0a2 100644
--- a/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
+++ b/src/test/java/org/mockito/internal/creation/instance/ConstructorInstantiatorTest.java
@@ -28,52 +28,25 @@ public class ConstructorInstantiatorTest extends TestBase {
         }
     }
 
-    static class SomeClass3 {
-
-        SomeClass3(int i) {
-
-        }
-    }
-
     @Test
     public void creates_instances() {
-        assertEquals(new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass.class).getClass(), SomeClass.class);
+        assertEquals(new ConstructorInstantiator(null).newInstance(SomeClass.class).getClass(), SomeClass.class);
     }
 
     @Test
     public void creates_instances_of_inner_classes() {
-        assertEquals(new ConstructorInstantiator(true, this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
-        assertEquals(new ConstructorInstantiator(true, new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
-    }
-
-    @Test
-    public void creates_instances_with_arguments() {
-        assertEquals(new ConstructorInstantiator(false, "someString").newInstance(SomeClass2.class).getClass(), SomeClass2.class);
-    }
-
-    @Test
-    public void creates_instances_with_null_arguments() {
-        assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass2.class).getClass(), SomeClass2.class);
-    }
-
-    @Test
-    public void creates_instances_with_primitive_arguments() {
-        assertEquals(new ConstructorInstantiator(false, 123).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
-    }
-
-    @Test(expected = InstantiationException.class)
-    public void fails_when_null_is_passed_for_a_primitive() {
-        assertEquals(new ConstructorInstantiator(false, new Object[]{null}).newInstance(SomeClass3.class).getClass(), SomeClass3.class);
+        assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
+        assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);
     }
 
     @Test
     public void explains_when_constructor_cannot_be_found() {
         try {
-            new ConstructorInstantiator(false, new Object[0]).newInstance(SomeClass2.class);
+            new ConstructorInstantiator(null).newInstance(SomeClass2.class);
             fail();
         } catch (InstantiationException e) {
             assertThat(e).hasMessageContaining("Unable to create instance of 'SomeClass2'.\n" +
-                    "Please ensure that the target class has a 0-arg constructor.");
+                    "Please ensure it has 0-arg constructor which invokes cleanly.");
         }
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/ChecksTest.java b/src/test/java/org/mockito/internal/util/ChecksTest.java
deleted file mode 100644
index d2c75b5cd..000000000
--- a/src/test/java/org/mockito/internal/util/ChecksTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (c) 2017 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-
-package org.mockito.internal.util;
-
-import static org.junit.Assert.assertEquals;
-
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.ExpectedException;
-
-public class ChecksTest {
-    @Rule
-    public ExpectedException expectedException = ExpectedException.none();
-
-    @Test
-    public void checkNotNull_not_null() throws Exception {
-        assertEquals("abc", Checks.checkNotNull("abc", "someValue"));
-    }
-
-    @Test
-    public void checkNotNull_not_null_additional_message() throws Exception {
-        assertEquals("abc", Checks.checkNotNull("abc", "someValue", "Oh no!"));
-    }
-
-    @Test
-    public void checkNotNull_null() throws Exception {
-        expectedException.expect(IllegalArgumentException.class);
-        expectedException.expectMessage("someValue should not be null");
-        Checks.checkNotNull(null, "someValue");
-    }
-
-    @Test
-    public void checkNotNull_null_additonal_message() throws Exception {
-        expectedException.expect(IllegalArgumentException.class);
-        expectedException.expectMessage("someValue should not be null. Oh no!");
-        Checks.checkNotNull(null, "someValue", "Oh no!");
-    }
-}
diff --git a/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java b/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
index e1843d570..2295593e3 100644
--- a/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
+++ b/src/test/java/org/mockitousage/constructor/CreatingMocksWithConstructorTest.java
@@ -24,12 +24,6 @@ public class CreatingMocksWithConstructorTest extends TestBase {
         AbstractMessage() {
             this.message = "hey!";
         }
-        AbstractMessage(String message) {
-            this.message = message;
-        }
-        AbstractMessage(int i) {
-            this.message = String.valueOf(i);
-        }
         String getMessage() {
             return message;
         }
@@ -57,64 +51,12 @@ public class CreatingMocksWithConstructorTest extends TestBase {
         assertEquals("hey!", mock.getMessage());
     }
 
-    @Test
-    public void can_spy_abstract_classes_with_constructor_args() {
-        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor("hello!").defaultAnswer(CALLS_REAL_METHODS));
-        assertEquals("hello!", mock.getMessage());
-    }
-
-    @Test
-    public void can_spy_abstract_classes_with_constructor_primitive_args() {
-        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(7).defaultAnswer(CALLS_REAL_METHODS));
-        assertEquals("7", mock.getMessage());
-    }
-
-    @Test
-    public void can_spy_abstract_classes_with_constructor_array_of_nulls() {
-        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor(new Object[]{null}).defaultAnswer(CALLS_REAL_METHODS));
-        assertNull(mock.getMessage());
-    }
-
-    @Test
-    public void can_spy_abstract_classes_with_casted_null() {
-        AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor((String) null).defaultAnswer(CALLS_REAL_METHODS));
-        assertNull(mock.getMessage());
-    }
-
-    @Test
-    public void can_spy_abstract_classes_with_null_varargs() {
-        try {
-            mock(AbstractMessage.class, withSettings().useConstructor(null).defaultAnswer(CALLS_REAL_METHODS));
-            fail();
-        } catch (IllegalArgumentException e) {
-            assertThat(e).hasMessageContaining("constructorArgs should not be null. " +
-                "If you need to pass null, please cast it to the right type, e.g.: useConstructor((String) null)");
-        }
-    }
-
     @Test
     public void can_mock_inner_classes() {
         InnerClass mock = mock(InnerClass.class, withSettings().useConstructor().outerInstance(this).defaultAnswer(CALLS_REAL_METHODS));
         assertEquals("hey!", mock.getMessage());
     }
 
-    public static class ThrowingConstructorClass{
-        public ThrowingConstructorClass() {
-            throw new RuntimeException();
-        }
-    }
-
-    @Test
-    public void explains_constructor_exceptions() {
-        try {
-            ThrowingConstructorClass mock = mock(ThrowingConstructorClass.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));
-            fail();
-        } catch (MockitoException e) {
-            assertThat(e).hasRootCauseInstanceOf(RuntimeException.class);
-            assertThat(e.getCause()).hasMessageContaining("Please ensure the target class has a 0-arg constructor and executes cleanly.");
-        }
-    }
-
     static class HasConstructor {
         HasConstructor(String x) {}
     }
@@ -128,49 +70,7 @@ public class CreatingMocksWithConstructorTest extends TestBase {
             fail();
         } catch (MockitoException e) {
             assertThat(e).hasMessage("Unable to create mock instance of type 'HasConstructor'");
-            assertThat(e.getCause()).hasMessageContaining("Please ensure that the target class has a 0-arg constructor.");
-        }
-    }
-
-    static class Base {}
-    static class ExtendsBase extends Base {}
-    static class ExtendsExtendsBase extends ExtendsBase {}
-
-    static class UsesBase {
-        public UsesBase(Base b) {}
-        public UsesBase(ExtendsBase b) {}
-    }
-
-    @Test
-    public void can_mock_unambigous_constructor_with_inheritence() {
-        UsesBase mock = mock(UsesBase.class, withSettings().useConstructor(new Base()).defaultAnswer(CALLS_REAL_METHODS));
-    }
-
-    @Test
-    public void exception_message_when_ambiguous_constructor_found_exact_exists() {
-        try {
-            //when
-            UsesBase mock = mock(UsesBase.class, withSettings().useConstructor(new ExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
-            //then
-            fail();
-        } catch (MockitoException e) {
-            assertThat(e).hasMessage("Unable to create mock instance of type 'UsesBase'");
-            assertThat(e.getCause()).hasMessageContaining
-                ("Multiple constructors could be matched to arguments of types [org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsBase]");
-        }
-    }
-
-    @Test
-    public void exception_message_when_ambiguous_constructor_found_exact_doesnt_exist() {
-        try {
-            //when
-            UsesBase mock = mock(UsesBase.class, withSettings().useConstructor(new ExtendsExtendsBase()).defaultAnswer(CALLS_REAL_METHODS));
-            //then
-            fail();
-        } catch (MockitoException e) {
-            assertThat(e).hasMessage("Unable to create mock instance of type 'UsesBase'");
-            assertThat(e.getCause()).hasMessageContaining
-                ("Multiple constructors could be matched to arguments of types [org.mockitousage.constructor.CreatingMocksWithConstructorTest$ExtendsExtendsBase]");
+            assertThat(e.getCause()).hasMessageContaining("0-arg constructor");
         }
     }
 
@@ -178,14 +78,12 @@ public class CreatingMocksWithConstructorTest extends TestBase {
     public void mocking_inner_classes_with_wrong_outer_instance() {
         try {
             //when
-            mock(InnerClass.class, withSettings().useConstructor().outerInstance(123).defaultAnswer(CALLS_REAL_METHODS));
+            mock(InnerClass.class, withSettings().useConstructor().outerInstance("foo").defaultAnswer(CALLS_REAL_METHODS));
             //then
             fail();
         } catch (MockitoException e) {
             assertThat(e).hasMessage("Unable to create mock instance of type 'InnerClass'");
-            assertThat(e.getCause()).hasMessageContaining(
-                "Please ensure that the target class has a 0-arg constructor"
-                    + " and that it's indeed an inner class of the passed instance of type java.lang.Integer");
+            assertThat(e.getCause()).hasMessageContaining("Unable to find a matching 1-arg constructor for the outer instance.");
         }
     }
 
