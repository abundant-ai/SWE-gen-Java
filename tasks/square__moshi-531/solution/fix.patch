diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
index 8da9f594..70137ad0 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
@@ -319,7 +319,6 @@ internal class AdapterGenerator(
         .returns(jsonAdapterTypeName)
         .addParameter(moshiParam)
 
-    // TODO make this configurable. Right now it just matches the source model
     if (visibility == Visibility.INTERNAL) {
       result.addModifiers(KModifier.INTERNAL)
     }
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/DelegateKey.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/DelegateKey.kt
index b9261bd2..3fc7f741 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/DelegateKey.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/DelegateKey.kt
@@ -53,12 +53,14 @@ internal data class DelegateKey(
       val annotationElement = MoreTypes.asTypeElement(annotationType)
       annotationElement.getAnnotation(java.lang.annotation.Retention::class.java)?.let {
         if (it.value != RetentionPolicy.RUNTIME) {
-          messager.printMessage(ERROR, "JsonQualifier @${MoreTypes.asTypeElement(annotationType).simpleName} must have RUNTIME retention")
+          messager.printMessage(ERROR, "JsonQualifier " +
+              "@${MoreTypes.asTypeElement(annotationType).simpleName} must have RUNTIME retention")
         }
       }
       annotationElement.getAnnotation(java.lang.annotation.Target::class.java)?.let {
         if (ElementType.FIELD !in it.value) {
-          messager.printMessage(ERROR, "JsonQualifier @${MoreTypes.asTypeElement(annotationType).simpleName} must support FIELD target")
+          messager.printMessage(ERROR, "JsonQualifier " +
+              "@${MoreTypes.asTypeElement(annotationType).simpleName} must support FIELD target")
         }
       }
       return this
@@ -84,9 +86,8 @@ internal data class DelegateKey(
     val (initializerString, args) = when {
       qualifiers.isEmpty() -> "" to emptyArray()
       else -> {
-        ", %${standardArgsSize}T.getFieldJsonQualifierAnnotations(javaClass, %${standardArgsSize + 1}S)" to arrayOf(
-            Types::class.asTypeName(),
-            adapterName)
+        ", %${standardArgsSize}T.getFieldJsonQualifierAnnotations(javaClass, " +
+            "%${standardArgsSize + 1}S)" to arrayOf(Types::class.asTypeName(), adapterName)
       }
     }
     val finalArgs = arrayOf(*standardArgs, *args)
@@ -94,7 +95,9 @@ internal data class DelegateKey(
     val nullModifier = if (nullable) ".nullSafe()" else ".nonNull()"
 
     return PropertySpec.builder(adapterName, adapterTypeName, KModifier.PRIVATE)
-        .addAnnotations(qualifiers.map { AnnotationSpec.get(it).toBuilder().useSiteTarget(FIELD).build() })
+        .addAnnotations(qualifiers.map {
+          AnnotationSpec.get(it).toBuilder().useSiteTarget(FIELD).build()
+        })
         .initializer("%1N.adapter%2L(%3L$initializerString)$nullModifier", *finalArgs)
         .build()
   }
@@ -104,9 +107,7 @@ internal data class DelegateKey(
  * Returns a suggested variable name derived from a list of type names. This just concatenates,
  * yielding types like MapOfStringLong.
  */
-private fun List<TypeName>.toVariableNames(): String {
-  return joinToString("") { it.toVariableName() }
-}
+private fun List<TypeName>.toVariableNames() = joinToString("") { it.toVariableName() }
 
 /** Returns a suggested variable name derived from a type name, like nullableListOfString. */
 private fun TypeName.toVariableName(): String {
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
index 09810965..4660a43f 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
@@ -73,8 +73,8 @@ class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils
     super.init(processingEnv)
     generatedType = processingEnv.options[OPTION_GENERATED]?.let {
       if (it !in POSSIBLE_GENERATED_NAMES) {
-        throw IllegalArgumentException(
-            "Invalid option value for $OPTION_GENERATED. Found $it, allowable values are $POSSIBLE_GENERATED_NAMES.")
+        throw IllegalArgumentException("Invalid option value for $OPTION_GENERATED. Found $it, " +
+            "allowable values are $POSSIBLE_GENERATED_NAMES.")
       }
       processingEnv.elementUtils.getTypeElement(it)
     }
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/TargetType.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/TargetType.kt
index 343355c6..bea4e6e5 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/TargetType.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/TargetType.kt
@@ -31,7 +31,9 @@ import me.eugeniomarletti.kotlin.metadata.modality
 import me.eugeniomarletti.kotlin.metadata.shadow.metadata.ProtoBuf.Class
 import me.eugeniomarletti.kotlin.metadata.shadow.metadata.ProtoBuf.Modality.ABSTRACT
 import me.eugeniomarletti.kotlin.metadata.shadow.metadata.ProtoBuf.TypeParameter
+import me.eugeniomarletti.kotlin.metadata.shadow.metadata.ProtoBuf.Visibility.INTERNAL
 import me.eugeniomarletti.kotlin.metadata.shadow.metadata.ProtoBuf.Visibility.LOCAL
+import me.eugeniomarletti.kotlin.metadata.shadow.metadata.ProtoBuf.Visibility.PUBLIC
 import me.eugeniomarletti.kotlin.metadata.shadow.metadata.deserialization.NameResolver
 import me.eugeniomarletti.kotlin.metadata.shadow.util.capitalizeDecapitalize.decapitalizeAsciiOnly
 import me.eugeniomarletti.kotlin.metadata.visibility
@@ -70,6 +72,11 @@ internal data class TargetType(
 
       val proto = typeMetadata.data.classProto
       when {
+        proto.classKind == Class.Kind.ENUM_CLASS -> {
+          messager.printMessage(
+              ERROR, "@JsonClass can't be applied to $element: must not be an enum class", element)
+          return null
+        }
         proto.classKind != Class.Kind.CLASS -> {
           messager.printMessage(
               ERROR, "@JsonClass can't be applied to $element: must be a Kotlin class", element)
@@ -96,6 +103,12 @@ internal data class TargetType(
       val appliedType = AppliedType.get(element)
 
       val constructor = TargetConstructor.primary(typeMetadata, elements)
+      if (constructor.proto.visibility != INTERNAL && constructor.proto.visibility != PUBLIC) {
+        messager.printMessage(ERROR, "@JsonClass can't be applied to $element: " +
+            "primary constructor is not internal or public", element)
+        return null
+      }
+
       val properties = mutableMapOf<String, TargetProperty>()
       for (supertype in appliedType.supertypes(types)) {
         if (supertype.element.asClassName() == OBJECT_CLASS) {
