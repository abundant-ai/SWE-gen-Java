diff --git a/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java b/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
index 91141191..c51ea745 100644
--- a/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
@@ -552,7 +552,7 @@ final class BufferedSourceJsonReader extends JsonReader {
     return result;
   }
 
-  @Override int selectName(Options options) throws IOException {
+  @Override int selectName(Selection selection) throws IOException {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -561,10 +561,10 @@ final class BufferedSourceJsonReader extends JsonReader {
       return -1;
     }
 
-    int result = source.select(options.doubleQuoteSuffix);
+    int result = source.select(selection.doubleQuoteSuffix);
     if (result != -1) {
       peeked = PEEKED_NONE;
-      pathNames[stackSize - 1] = options.strings[result];
+      pathNames[stackSize - 1] = selection.strings[result];
     }
     return result;
   }
@@ -596,7 +596,7 @@ final class BufferedSourceJsonReader extends JsonReader {
     return result;
   }
 
-  @Override int selectString(Options options) throws IOException {
+  @Override int selectString(Selection selection) throws IOException {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
@@ -605,7 +605,7 @@ final class BufferedSourceJsonReader extends JsonReader {
       return -1;
     }
 
-    int result = source.select(options.doubleQuoteSuffix);
+    int result = source.select(selection.doubleQuoteSuffix);
     if (result != -1) {
       peeked = PEEKED_NONE;
       pathIndices[stackSize - 1]++;
diff --git a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
index 472731df..2ce4f523 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
@@ -116,13 +116,13 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
   private final ClassFactory<T> classFactory;
   private final Map<String, FieldBinding<?>> fieldsMap;
   private final FieldBinding<?>[] fieldsArray;
-  private final JsonReader.Options options;
+  private final JsonReader.Selection selection;
 
   ClassJsonAdapter(ClassFactory<T> classFactory, Map<String, FieldBinding<?>> fieldsMap) {
     this.classFactory = classFactory;
     this.fieldsMap = new LinkedHashMap<>(fieldsMap);
     this.fieldsArray = fieldsMap.values().toArray(new FieldBinding[fieldsMap.size()]);
-    this.options = JsonReader.Options.of(
+    this.selection = JsonReader.Selection.of(
         fieldsMap.keySet().toArray(new String[fieldsMap.size()]));
   }
 
@@ -144,7 +144,7 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
     try {
       reader.beginObject();
       while (reader.hasNext()) {
-        int index = reader.selectName(options);
+        int index = reader.selectName(selection);
         FieldBinding<?> fieldBinding;
         if (index != -1) {
           fieldBinding = fieldsArray[index];
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index 6a660421..a1522426 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -17,6 +17,8 @@ package com.squareup.moshi;
 
 import java.io.Closeable;
 import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.ByteString;
@@ -275,10 +277,10 @@ public abstract class JsonReader implements Closeable {
   public abstract String nextName() throws IOException;
 
   /**
-   * If the next token is a {@linkplain Token#NAME property name} that's in {@code options}, this
+   * If the next token is a {@linkplain Token#NAME property name} that's in {@code selection}, this
    * consumes it and returns its index. Otherwise this returns -1 and no name is consumed.
    */
-  abstract int selectName(Options options) throws IOException;
+  abstract int selectName(Selection selection) throws IOException;
 
   /**
    * Returns the {@linkplain Token#STRING string} value of the next token, consuming it. If the next
@@ -289,10 +291,10 @@ public abstract class JsonReader implements Closeable {
   public abstract String nextString() throws IOException;
 
   /**
-   * If the next token is a {@linkplain Token#STRING string} that's in {@code options}, this
+   * If the next token is a {@linkplain Token#STRING string} that's in {@code selection}, this
    * consumes it and returns its index. Otherwise this returns -1 and no string is consumed.
    */
-  abstract int selectString(Options options) throws IOException;
+  abstract int selectString(Selection selection) throws IOException;
 
   /**
    * Returns the {@linkplain Token#BOOLEAN boolean} value of the next token, consuming it.
@@ -369,16 +371,16 @@ public abstract class JsonReader implements Closeable {
    * unquoted or uses single quotes in the source JSON, it will not be selected. Client code that
    * uses this class should fall back to another mechanism to accommodate this possibility.
    */
-  static final class Options {
+  static final class Selection {
     final String[] strings;
-    final okio.Options doubleQuoteSuffix;
+    final List<ByteString> doubleQuoteSuffix;
 
-    private Options(String[] strings, okio.Options doubleQuoteSuffix) {
+    public Selection(String[] strings, List<ByteString> doubleQuoteSuffix) {
       this.strings = strings;
       this.doubleQuoteSuffix = doubleQuoteSuffix;
     }
 
-    public static Options of(String... strings) {
+    public static Selection of(String... strings) {
       try {
         ByteString[] result = new ByteString[strings.length];
         Buffer buffer = new Buffer();
@@ -387,7 +389,7 @@ public abstract class JsonReader implements Closeable {
           buffer.readByte(); // Skip the leading double quote (but leave the trailing one).
           result[i] = buffer.readByteString();
         }
-        return new Options(strings.clone(), okio.Options.of(result));
+        return new Selection(strings.clone(), Arrays.asList(result));
       } catch (IOException e) {
         throw new AssertionError(e);
       }
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index f4bf1613..db08b586 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -217,7 +217,7 @@ final class StandardJsonAdapters {
     private final Map<String, T> nameConstantMap;
     private final String[] nameStrings;
     private final T[] constants;
-    private final JsonReader.Options options;
+    private final JsonReader.Selection selection;
 
     public EnumJsonAdapter(Class<T> enumType) {
       this.enumType = enumType;
@@ -232,14 +232,14 @@ final class StandardJsonAdapters {
           nameConstantMap.put(name, constant);
           nameStrings[i] = name;
         }
-        options = JsonReader.Options.of(nameStrings);
+        selection = JsonReader.Selection.of(nameStrings);
       } catch (NoSuchFieldException e) {
         throw new AssertionError("Missing field in " + enumType.getName(), e);
       }
     }
 
     @Override public T fromJson(JsonReader reader) throws IOException {
-      int index = reader.selectString(options);
+      int index = reader.selectString(selection);
       if (index != -1) return constants[index];
 
       String name = reader.nextString();
diff --git a/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java b/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java
index aac8ba22..742694fa 100644
--- a/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java
@@ -1772,7 +1772,7 @@ public final class BufferedSourceJsonReaderTest {
   }
 
   @Test public void selectName() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
+    JsonReader.Selection abc = JsonReader.Selection.of("a", "b", "c");
 
     JsonReader reader = newReader("{\"a\": 5, \"b\": 5, \"c\": 5, \"d\": 5}");
     reader.beginObject();
@@ -1807,7 +1807,7 @@ public final class BufferedSourceJsonReaderTest {
   }
 
   @Test public void selectString() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
+    JsonReader.Selection abc = JsonReader.Selection.of("a", "b", "c");
 
     JsonReader reader = newReader("[\"a\", \"b\", \"c\", \"d\"]");
     reader.beginArray();
@@ -1835,7 +1835,7 @@ public final class BufferedSourceJsonReaderTest {
 
   /** Select doesn't match unquoted strings. */
   @Test public void selectStringUnquoted() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
+    JsonReader.Selection abc = JsonReader.Selection.of("a", "b", "c");
 
     JsonReader reader = newReader("[a]");
     reader.setLenient(true);
@@ -1847,7 +1847,7 @@ public final class BufferedSourceJsonReaderTest {
 
   /** Select doesn't match single quoted strings. */
   @Test public void selectStringSingleQuoted() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
+    JsonReader.Selection abc = JsonReader.Selection.of("a", "b", "c");
 
     JsonReader reader = newReader("['a']");
     reader.setLenient(true);
@@ -1859,7 +1859,7 @@ public final class BufferedSourceJsonReaderTest {
 
   /** Select doesn't match unnecessarily-escaped strings. */
   @Test public void selectUnnecessaryEscaping() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
+    JsonReader.Selection abc = JsonReader.Selection.of("a", "b", "c");
 
     JsonReader reader = newReader("[\"\\u0061\"]");
     reader.beginArray();
@@ -1870,17 +1870,17 @@ public final class BufferedSourceJsonReaderTest {
 
   /** Select does match necessarily escaping. The decoded value is used in the path. */
   @Test public void selectNecessaryEscaping() throws IOException {
-    JsonReader.Options options = JsonReader.Options.of("\n", "\u0000", "\"");
+    JsonReader.Selection selection = JsonReader.Selection.of("\n", "\u0000", "\"");
 
     JsonReader reader = newReader("{\"\\n\": 5,\"\\u0000\": 5, \"\\\"\": 5}");
     reader.beginObject();
-    assertEquals(0, reader.selectName(options));
+    assertEquals(0, reader.selectName(selection));
     assertEquals(5, reader.nextInt());
     assertEquals("$.\n", reader.getPath());
-    assertEquals(1, reader.selectName(options));
+    assertEquals(1, reader.selectName(selection));
     assertEquals(5, reader.nextInt());
     assertEquals("$.\u0000", reader.getPath());
-    assertEquals(2, reader.selectName(options));
+    assertEquals(2, reader.selectName(selection));
     assertEquals(5, reader.nextInt());
     assertEquals("$.\"", reader.getPath());
     reader.endObject();
