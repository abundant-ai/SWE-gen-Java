diff --git a/ktor-server/ktor-server-netty/api/ktor-server-netty.api b/ktor-server/ktor-server-netty/api/ktor-server-netty.api
index 79f8ee36d..844d69220 100644
--- a/ktor-server/ktor-server-netty/api/ktor-server-netty.api
+++ b/ktor-server/ktor-server-netty/api/ktor-server-netty.api
@@ -83,6 +83,7 @@ public final class io/ktor/server/netty/NettyApplicationEngine$Configuration : i
 	public fun <init> ()V
 	public final fun getChannelPipelineConfig ()Lkotlin/jvm/functions/Function1;
 	public final fun getConfigureBootstrap ()Lkotlin/jvm/functions/Function1;
+	public final fun getEnableH2c ()Z
 	public final fun getEnableHttp2 ()Z
 	public final fun getHttpServerCodec ()Lkotlin/jvm/functions/Function0;
 	public final fun getMaxChunkSize ()I
@@ -95,6 +96,7 @@ public final class io/ktor/server/netty/NettyApplicationEngine$Configuration : i
 	public final fun getTcpKeepAlive ()Z
 	public final fun setChannelPipelineConfig (Lkotlin/jvm/functions/Function1;)V
 	public final fun setConfigureBootstrap (Lkotlin/jvm/functions/Function1;)V
+	public final fun setEnableH2c (Z)V
 	public final fun setEnableHttp2 (Z)V
 	public final fun setHttpServerCodec (Lkotlin/jvm/functions/Function0;)V
 	public final fun setMaxChunkSize (I)V
@@ -159,6 +161,7 @@ public final class io/ktor/server/netty/NettyApplicationResponse$Companion {
 public final class io/ktor/server/netty/NettyChannelInitializer : io/netty/channel/ChannelInitializer {
 	public static final field Companion Lio/ktor/server/netty/NettyChannelInitializer$Companion;
 	public fun <init> (Lkotlin/jvm/functions/Function0;Lio/ktor/server/engine/EnginePipeline;Lio/ktor/server/application/ApplicationEnvironment;Lio/netty/util/concurrent/EventExecutorGroup;Lkotlin/coroutines/CoroutineContext;Lkotlin/coroutines/CoroutineContext;Lio/ktor/server/engine/EngineConnectorConfig;IIILkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Z)V
+	public fun <init> (Lkotlin/jvm/functions/Function0;Lio/ktor/server/engine/EnginePipeline;Lio/ktor/server/application/ApplicationEnvironment;Lio/netty/util/concurrent/EventExecutorGroup;Lkotlin/coroutines/CoroutineContext;Lkotlin/coroutines/CoroutineContext;Lio/ktor/server/engine/EngineConnectorConfig;IIILkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;ZZ)V
 	public synthetic fun initChannel (Lio/netty/channel/Channel;)V
 }
 
diff --git a/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt b/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt
index 717f489b1..90c956243 100644
--- a/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt
+++ b/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt
@@ -124,6 +124,13 @@ public class NettyApplicationEngine(
          */
         public var enableHttp2: Boolean = true
 
+        /**
+         * If set to `true` and [enableHttp2] is set to `true`, enables HTTP/2 protocol without TLS for Netty engine
+         *
+         * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.server.netty.NettyApplicationEngine.Configuration.enableH2c)
+         */
+        public var enableH2c: Boolean = false
+
         /**
          * User-provided function to configure Netty's [HttpServerCodec]
          *
@@ -223,7 +230,8 @@ public class NettyApplicationEngine(
                     configuration.requestReadTimeoutSeconds,
                     configuration.httpServerCodec,
                     configuration.channelPipelineConfig,
-                    configuration.enableHttp2
+                    configuration.enableHttp2,
+                    configuration.enableH2c
                 )
             )
             if (configuration.tcpKeepAlive) {
diff --git a/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyChannelInitializer.kt b/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyChannelInitializer.kt
index a3e59c34c..f0b4884e6 100644
--- a/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyChannelInitializer.kt
+++ b/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyChannelInitializer.kt
@@ -8,20 +8,40 @@ import io.ktor.server.application.*
 import io.ktor.server.engine.*
 import io.ktor.server.netty.http1.*
 import io.ktor.server.netty.http2.*
-import io.netty.channel.*
+import io.netty.channel.ChannelHandlerContext
+import io.netty.channel.ChannelInitializer
+import io.netty.channel.ChannelPipeline
+import io.netty.channel.SimpleChannelInboundHandler
 import io.netty.channel.socket.SocketChannel
-import io.netty.handler.codec.http.*
-import io.netty.handler.codec.http2.*
-import io.netty.handler.ssl.*
-import io.netty.handler.timeout.*
-import io.netty.util.concurrent.*
-import kotlinx.coroutines.*
-import java.io.*
-import java.nio.channels.*
-import java.security.*
-import java.security.cert.*
-import javax.net.ssl.*
-import kotlin.coroutines.*
+import io.netty.handler.codec.http.HttpMessage
+import io.netty.handler.codec.http.HttpServerCodec
+import io.netty.handler.codec.http.HttpServerExpectContinueHandler
+import io.netty.handler.codec.http.HttpServerUpgradeHandler
+import io.netty.handler.codec.http2.CleartextHttp2ServerUpgradeHandler
+import io.netty.handler.codec.http2.Http2CodecUtil
+import io.netty.handler.codec.http2.Http2MultiplexCodecBuilder
+import io.netty.handler.codec.http2.Http2SecurityUtil
+import io.netty.handler.codec.http2.Http2ServerUpgradeCodec
+import io.netty.handler.ssl.ApplicationProtocolConfig
+import io.netty.handler.ssl.ApplicationProtocolNames
+import io.netty.handler.ssl.ApplicationProtocolNegotiationHandler
+import io.netty.handler.ssl.SslContext
+import io.netty.handler.ssl.SslContextBuilder
+import io.netty.handler.ssl.SslHandler
+import io.netty.handler.ssl.SslProvider
+import io.netty.handler.ssl.SupportedCipherSuiteFilter
+import io.netty.handler.timeout.ReadTimeoutException
+import io.netty.handler.timeout.ReadTimeoutHandler
+import io.netty.handler.timeout.WriteTimeoutHandler
+import io.netty.util.concurrent.EventExecutorGroup
+import kotlinx.coroutines.cancel
+import java.io.FileInputStream
+import java.nio.channels.ClosedChannelException
+import java.security.KeyStore
+import java.security.PrivateKey
+import java.security.cert.X509Certificate
+import javax.net.ssl.TrustManagerFactory
+import kotlin.coroutines.CoroutineContext
 
 /**
  * A [ChannelInitializer] implementation that sets up the default ktor channel pipeline
@@ -41,10 +61,51 @@ public class NettyChannelInitializer(
     private val requestReadTimeout: Int,
     private val httpServerCodec: () -> HttpServerCodec,
     private val channelPipelineConfig: ChannelPipeline.() -> Unit,
-    private val enableHttp2: Boolean
+    private val enableHttp2: Boolean,
+    private val enableH2c: Boolean
 ) : ChannelInitializer<SocketChannel>() {
     private var sslContext: SslContext? = null
 
+    @Deprecated(
+        message = "Use main constructor",
+        replaceWith = ReplaceWith(
+            "NettyChannelInitializer(" +
+                "getRequestBodySizeEstimator, enginePipeline, environment, callEventGroup, " +
+                "userContext, engineContext, connector, maxInitialLineLength, maxHeaderSize, " +
+                "maxChunkSize, httpServerCodec, channelPipelineConfig, enableHttp2, enableH2c)"
+        )
+    )
+    public constructor(
+        applicationProvider: () -> Application,
+        enginePipeline: EnginePipeline,
+        environment: ApplicationEnvironment,
+        callEventGroup: EventExecutorGroup,
+        engineContext: CoroutineContext,
+        userContext: CoroutineContext,
+        connector: EngineConnectorConfig,
+        runningLimit: Int,
+        responseWriteTimeout: Int,
+        requestReadTimeout: Int,
+        httpServerCodec: () -> HttpServerCodec,
+        channelPipelineConfig: ChannelPipeline.() -> Unit,
+        enableHttp2: Boolean,
+    ) : this(
+        applicationProvider = applicationProvider,
+        enginePipeline = enginePipeline,
+        environment = environment,
+        callEventGroup = callEventGroup,
+        engineContext = engineContext,
+        userContext = userContext,
+        connector = connector,
+        runningLimit = runningLimit,
+        responseWriteTimeout = responseWriteTimeout,
+        requestReadTimeout = requestReadTimeout,
+        httpServerCodec = httpServerCodec,
+        channelPipelineConfig = channelPipelineConfig,
+        enableHttp2 = enableHttp2,
+        enableH2c = false
+    )
+
     init {
         if (connector is EngineSSLConnectorConfig) {
 
@@ -83,25 +144,37 @@ public class NettyChannelInitializer(
 
     override fun initChannel(ch: SocketChannel) {
         with(ch.pipeline()) {
-            if (connector is EngineSSLConnectorConfig) {
-                val sslEngine = sslContext!!.newEngine(ch.alloc()).apply {
-                    if (connector.hasTrustStore()) {
-                        useClientMode = false
-                        needClientAuth = true
+            when {
+                enableHttp2 && enableH2c && connector is EngineSSLConnectorConfig -> {
+                    error("Invalid configuration: H2C (HTTP/2 cleartext) cannot be used with SSL")
+                }
+
+                enableHttp2 && enableH2c -> {
+                    configurePipeline(this, Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME.toString())
+                }
+
+                connector is EngineSSLConnectorConfig -> {
+                    val sslEngine = sslContext!!.newEngine(ch.alloc()).apply {
+                        if (connector.hasTrustStore()) {
+                            useClientMode = false
+                            needClientAuth = true
+                        }
+                        connector.enabledProtocols?.let {
+                            enabledProtocols = it.toTypedArray()
+                        }
                     }
-                    connector.enabledProtocols?.let {
-                        enabledProtocols = it.toTypedArray()
+                    addLast("ssl", SslHandler(sslEngine))
+
+                    if (enableHttp2 && alpnProvider != null) {
+                        addLast(NegotiatedPipelineInitializer())
+                    } else {
+                        configurePipeline(this, ApplicationProtocolNames.HTTP_1_1)
                     }
                 }
-                addLast("ssl", SslHandler(sslEngine))
 
-                if (enableHttp2 && alpnProvider != null) {
-                    addLast(NegotiatedPipelineInitializer())
-                } else {
+                else -> {
                     configurePipeline(this, ApplicationProtocolNames.HTTP_1_1)
                 }
-            } else {
-                configurePipeline(this, ApplicationProtocolNames.HTTP_1_1)
             }
         }
     }
@@ -124,6 +197,69 @@ public class NettyChannelInitializer(
                 channelPipelineConfig(pipeline)
             }
 
+            Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME.toString() -> {
+                val handler = NettyHttp2Handler(
+                    enginePipeline,
+                    applicationProvider(),
+                    callEventGroup,
+                    userContext,
+                    runningLimit
+                )
+
+                val multiplexHandler = Http2MultiplexCodecBuilder.forServer(handler).build()
+
+                val codec = httpServerCodec()
+
+                val upgradeHandler = HttpServerUpgradeHandler(codec) {
+                    Http2ServerUpgradeCodec(multiplexHandler)
+                }
+
+                val cleartextHttp2ServerUpgradeHandler = CleartextHttp2ServerUpgradeHandler(
+                    codec,
+                    upgradeHandler,
+                    multiplexHandler
+                )
+
+                pipeline.addLast("cleartextUpgradeHandler", cleartextHttp2ServerUpgradeHandler)
+
+                pipeline.addLast(object : SimpleChannelInboundHandler<HttpMessage>() {
+                    @Throws(Exception::class)
+                    override fun channelRead0(ctx: ChannelHandlerContext, msg: HttpMessage) {
+                        val pipe = ctx.pipeline()
+
+                        val http1handler = NettyHttp1Handler(
+                            applicationProvider,
+                            enginePipeline,
+                            environment,
+                            callEventGroup,
+                            engineContext,
+                            userContext,
+                            runningLimit
+                        )
+
+                        if (requestReadTimeout > 0) {
+                            pipe.addAfter(ctx.name(), "readTimeout", KtorReadTimeoutHandler(requestReadTimeout))
+                            pipe.addAfter("readTimeout", "continue", HttpServerExpectContinueHandler())
+                        } else {
+                            pipe.addAfter(ctx.name(), "continue", HttpServerExpectContinueHandler())
+                        }
+                        pipe.addAfter("continue", "timeout", WriteTimeoutHandler(responseWriteTimeout))
+                        pipe.addAfter("timeout", "http1", http1handler)
+
+                        pipe.remove(upgradeHandler)
+                        pipe.remove(ctx.name())
+
+                        ctx.fireChannelActive()
+                        ctx.fireChannelRead(msg)
+                    }
+                })
+
+                pipeline.channel().closeFuture().addListener {
+                    handler.cancel()
+                }
+                channelPipelineConfig(pipeline)
+            }
+
             ApplicationProtocolNames.HTTP_1_1 -> {
                 val handler = NettyHttp1Handler(
                     applicationProvider,
