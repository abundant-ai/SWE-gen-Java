diff --git a/ktor-server/ktor-server-netty/api/ktor-server-netty.api b/ktor-server/ktor-server-netty/api/ktor-server-netty.api
index 844d69220..79f8ee36d 100644
--- a/ktor-server/ktor-server-netty/api/ktor-server-netty.api
+++ b/ktor-server/ktor-server-netty/api/ktor-server-netty.api
@@ -83,7 +83,6 @@ public final class io/ktor/server/netty/NettyApplicationEngine$Configuration : i
 	public fun <init> ()V
 	public final fun getChannelPipelineConfig ()Lkotlin/jvm/functions/Function1;
 	public final fun getConfigureBootstrap ()Lkotlin/jvm/functions/Function1;
-	public final fun getEnableH2c ()Z
 	public final fun getEnableHttp2 ()Z
 	public final fun getHttpServerCodec ()Lkotlin/jvm/functions/Function0;
 	public final fun getMaxChunkSize ()I
@@ -96,7 +95,6 @@ public final class io/ktor/server/netty/NettyApplicationEngine$Configuration : i
 	public final fun getTcpKeepAlive ()Z
 	public final fun setChannelPipelineConfig (Lkotlin/jvm/functions/Function1;)V
 	public final fun setConfigureBootstrap (Lkotlin/jvm/functions/Function1;)V
-	public final fun setEnableH2c (Z)V
 	public final fun setEnableHttp2 (Z)V
 	public final fun setHttpServerCodec (Lkotlin/jvm/functions/Function0;)V
 	public final fun setMaxChunkSize (I)V
@@ -161,7 +159,6 @@ public final class io/ktor/server/netty/NettyApplicationResponse$Companion {
 public final class io/ktor/server/netty/NettyChannelInitializer : io/netty/channel/ChannelInitializer {
 	public static final field Companion Lio/ktor/server/netty/NettyChannelInitializer$Companion;
 	public fun <init> (Lkotlin/jvm/functions/Function0;Lio/ktor/server/engine/EnginePipeline;Lio/ktor/server/application/ApplicationEnvironment;Lio/netty/util/concurrent/EventExecutorGroup;Lkotlin/coroutines/CoroutineContext;Lkotlin/coroutines/CoroutineContext;Lio/ktor/server/engine/EngineConnectorConfig;IIILkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;Z)V
-	public fun <init> (Lkotlin/jvm/functions/Function0;Lio/ktor/server/engine/EnginePipeline;Lio/ktor/server/application/ApplicationEnvironment;Lio/netty/util/concurrent/EventExecutorGroup;Lkotlin/coroutines/CoroutineContext;Lkotlin/coroutines/CoroutineContext;Lio/ktor/server/engine/EngineConnectorConfig;IIILkotlin/jvm/functions/Function0;Lkotlin/jvm/functions/Function1;ZZ)V
 	public synthetic fun initChannel (Lio/netty/channel/Channel;)V
 }
 
diff --git a/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt b/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt
index 90c956243..717f489b1 100644
--- a/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt
+++ b/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyApplicationEngine.kt
@@ -124,13 +124,6 @@ public class NettyApplicationEngine(
          */
         public var enableHttp2: Boolean = true
 
-        /**
-         * If set to `true` and [enableHttp2] is set to `true`, enables HTTP/2 protocol without TLS for Netty engine
-         *
-         * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.server.netty.NettyApplicationEngine.Configuration.enableH2c)
-         */
-        public var enableH2c: Boolean = false
-
         /**
          * User-provided function to configure Netty's [HttpServerCodec]
          *
@@ -230,8 +223,7 @@ public class NettyApplicationEngine(
                     configuration.requestReadTimeoutSeconds,
                     configuration.httpServerCodec,
                     configuration.channelPipelineConfig,
-                    configuration.enableHttp2,
-                    configuration.enableH2c
+                    configuration.enableHttp2
                 )
             )
             if (configuration.tcpKeepAlive) {
diff --git a/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyChannelInitializer.kt b/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyChannelInitializer.kt
index f0b4884e6..a3e59c34c 100644
--- a/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyChannelInitializer.kt
+++ b/ktor-server/ktor-server-netty/jvm/src/io/ktor/server/netty/NettyChannelInitializer.kt
@@ -8,40 +8,20 @@ import io.ktor.server.application.*
 import io.ktor.server.engine.*
 import io.ktor.server.netty.http1.*
 import io.ktor.server.netty.http2.*
-import io.netty.channel.ChannelHandlerContext
-import io.netty.channel.ChannelInitializer
-import io.netty.channel.ChannelPipeline
-import io.netty.channel.SimpleChannelInboundHandler
+import io.netty.channel.*
 import io.netty.channel.socket.SocketChannel
-import io.netty.handler.codec.http.HttpMessage
-import io.netty.handler.codec.http.HttpServerCodec
-import io.netty.handler.codec.http.HttpServerExpectContinueHandler
-import io.netty.handler.codec.http.HttpServerUpgradeHandler
-import io.netty.handler.codec.http2.CleartextHttp2ServerUpgradeHandler
-import io.netty.handler.codec.http2.Http2CodecUtil
-import io.netty.handler.codec.http2.Http2MultiplexCodecBuilder
-import io.netty.handler.codec.http2.Http2SecurityUtil
-import io.netty.handler.codec.http2.Http2ServerUpgradeCodec
-import io.netty.handler.ssl.ApplicationProtocolConfig
-import io.netty.handler.ssl.ApplicationProtocolNames
-import io.netty.handler.ssl.ApplicationProtocolNegotiationHandler
-import io.netty.handler.ssl.SslContext
-import io.netty.handler.ssl.SslContextBuilder
-import io.netty.handler.ssl.SslHandler
-import io.netty.handler.ssl.SslProvider
-import io.netty.handler.ssl.SupportedCipherSuiteFilter
-import io.netty.handler.timeout.ReadTimeoutException
-import io.netty.handler.timeout.ReadTimeoutHandler
-import io.netty.handler.timeout.WriteTimeoutHandler
-import io.netty.util.concurrent.EventExecutorGroup
-import kotlinx.coroutines.cancel
-import java.io.FileInputStream
-import java.nio.channels.ClosedChannelException
-import java.security.KeyStore
-import java.security.PrivateKey
-import java.security.cert.X509Certificate
-import javax.net.ssl.TrustManagerFactory
-import kotlin.coroutines.CoroutineContext
+import io.netty.handler.codec.http.*
+import io.netty.handler.codec.http2.*
+import io.netty.handler.ssl.*
+import io.netty.handler.timeout.*
+import io.netty.util.concurrent.*
+import kotlinx.coroutines.*
+import java.io.*
+import java.nio.channels.*
+import java.security.*
+import java.security.cert.*
+import javax.net.ssl.*
+import kotlin.coroutines.*
 
 /**
  * A [ChannelInitializer] implementation that sets up the default ktor channel pipeline
@@ -61,51 +41,10 @@ public class NettyChannelInitializer(
     private val requestReadTimeout: Int,
     private val httpServerCodec: () -> HttpServerCodec,
     private val channelPipelineConfig: ChannelPipeline.() -> Unit,
-    private val enableHttp2: Boolean,
-    private val enableH2c: Boolean
+    private val enableHttp2: Boolean
 ) : ChannelInitializer<SocketChannel>() {
     private var sslContext: SslContext? = null
 
-    @Deprecated(
-        message = "Use main constructor",
-        replaceWith = ReplaceWith(
-            "NettyChannelInitializer(" +
-                "getRequestBodySizeEstimator, enginePipeline, environment, callEventGroup, " +
-                "userContext, engineContext, connector, maxInitialLineLength, maxHeaderSize, " +
-                "maxChunkSize, httpServerCodec, channelPipelineConfig, enableHttp2, enableH2c)"
-        )
-    )
-    public constructor(
-        applicationProvider: () -> Application,
-        enginePipeline: EnginePipeline,
-        environment: ApplicationEnvironment,
-        callEventGroup: EventExecutorGroup,
-        engineContext: CoroutineContext,
-        userContext: CoroutineContext,
-        connector: EngineConnectorConfig,
-        runningLimit: Int,
-        responseWriteTimeout: Int,
-        requestReadTimeout: Int,
-        httpServerCodec: () -> HttpServerCodec,
-        channelPipelineConfig: ChannelPipeline.() -> Unit,
-        enableHttp2: Boolean,
-    ) : this(
-        applicationProvider = applicationProvider,
-        enginePipeline = enginePipeline,
-        environment = environment,
-        callEventGroup = callEventGroup,
-        engineContext = engineContext,
-        userContext = userContext,
-        connector = connector,
-        runningLimit = runningLimit,
-        responseWriteTimeout = responseWriteTimeout,
-        requestReadTimeout = requestReadTimeout,
-        httpServerCodec = httpServerCodec,
-        channelPipelineConfig = channelPipelineConfig,
-        enableHttp2 = enableHttp2,
-        enableH2c = false
-    )
-
     init {
         if (connector is EngineSSLConnectorConfig) {
 
@@ -144,37 +83,25 @@ public class NettyChannelInitializer(
 
     override fun initChannel(ch: SocketChannel) {
         with(ch.pipeline()) {
-            when {
-                enableHttp2 && enableH2c && connector is EngineSSLConnectorConfig -> {
-                    error("Invalid configuration: H2C (HTTP/2 cleartext) cannot be used with SSL")
-                }
-
-                enableHttp2 && enableH2c -> {
-                    configurePipeline(this, Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME.toString())
-                }
-
-                connector is EngineSSLConnectorConfig -> {
-                    val sslEngine = sslContext!!.newEngine(ch.alloc()).apply {
-                        if (connector.hasTrustStore()) {
-                            useClientMode = false
-                            needClientAuth = true
-                        }
-                        connector.enabledProtocols?.let {
-                            enabledProtocols = it.toTypedArray()
-                        }
+            if (connector is EngineSSLConnectorConfig) {
+                val sslEngine = sslContext!!.newEngine(ch.alloc()).apply {
+                    if (connector.hasTrustStore()) {
+                        useClientMode = false
+                        needClientAuth = true
                     }
-                    addLast("ssl", SslHandler(sslEngine))
-
-                    if (enableHttp2 && alpnProvider != null) {
-                        addLast(NegotiatedPipelineInitializer())
-                    } else {
-                        configurePipeline(this, ApplicationProtocolNames.HTTP_1_1)
+                    connector.enabledProtocols?.let {
+                        enabledProtocols = it.toTypedArray()
                     }
                 }
+                addLast("ssl", SslHandler(sslEngine))
 
-                else -> {
+                if (enableHttp2 && alpnProvider != null) {
+                    addLast(NegotiatedPipelineInitializer())
+                } else {
                     configurePipeline(this, ApplicationProtocolNames.HTTP_1_1)
                 }
+            } else {
+                configurePipeline(this, ApplicationProtocolNames.HTTP_1_1)
             }
         }
     }
@@ -197,69 +124,6 @@ public class NettyChannelInitializer(
                 channelPipelineConfig(pipeline)
             }
 
-            Http2CodecUtil.HTTP_UPGRADE_PROTOCOL_NAME.toString() -> {
-                val handler = NettyHttp2Handler(
-                    enginePipeline,
-                    applicationProvider(),
-                    callEventGroup,
-                    userContext,
-                    runningLimit
-                )
-
-                val multiplexHandler = Http2MultiplexCodecBuilder.forServer(handler).build()
-
-                val codec = httpServerCodec()
-
-                val upgradeHandler = HttpServerUpgradeHandler(codec) {
-                    Http2ServerUpgradeCodec(multiplexHandler)
-                }
-
-                val cleartextHttp2ServerUpgradeHandler = CleartextHttp2ServerUpgradeHandler(
-                    codec,
-                    upgradeHandler,
-                    multiplexHandler
-                )
-
-                pipeline.addLast("cleartextUpgradeHandler", cleartextHttp2ServerUpgradeHandler)
-
-                pipeline.addLast(object : SimpleChannelInboundHandler<HttpMessage>() {
-                    @Throws(Exception::class)
-                    override fun channelRead0(ctx: ChannelHandlerContext, msg: HttpMessage) {
-                        val pipe = ctx.pipeline()
-
-                        val http1handler = NettyHttp1Handler(
-                            applicationProvider,
-                            enginePipeline,
-                            environment,
-                            callEventGroup,
-                            engineContext,
-                            userContext,
-                            runningLimit
-                        )
-
-                        if (requestReadTimeout > 0) {
-                            pipe.addAfter(ctx.name(), "readTimeout", KtorReadTimeoutHandler(requestReadTimeout))
-                            pipe.addAfter("readTimeout", "continue", HttpServerExpectContinueHandler())
-                        } else {
-                            pipe.addAfter(ctx.name(), "continue", HttpServerExpectContinueHandler())
-                        }
-                        pipe.addAfter("continue", "timeout", WriteTimeoutHandler(responseWriteTimeout))
-                        pipe.addAfter("timeout", "http1", http1handler)
-
-                        pipe.remove(upgradeHandler)
-                        pipe.remove(ctx.name())
-
-                        ctx.fireChannelActive()
-                        ctx.fireChannelRead(msg)
-                    }
-                })
-
-                pipeline.channel().closeFuture().addListener {
-                    handler.cancel()
-                }
-                channelPipelineConfig(pipeline)
-            }
-
             ApplicationProtocolNames.HTTP_1_1 -> {
                 val handler = NettyHttp1Handler(
                     applicationProvider,
diff --git a/ktor-server/ktor-server-netty/jvm/test/io/ktor/tests/server/netty/NettyEngineTest.kt b/ktor-server/ktor-server-netty/jvm/test/io/ktor/tests/server/netty/NettyEngineTest.kt
index 67fbee0f3..61029c2b7 100644
--- a/ktor-server/ktor-server-netty/jvm/test/io/ktor/tests/server/netty/NettyEngineTest.kt
+++ b/ktor-server/ktor-server-netty/jvm/test/io/ktor/tests/server/netty/NettyEngineTest.kt
@@ -9,8 +9,6 @@ import io.ktor.client.engine.cio.*
 import io.ktor.client.plugins.websocket.cio.*
 import io.ktor.client.statement.*
 import io.ktor.http.*
-import io.ktor.network.selector.*
-import io.ktor.network.sockets.*
 import io.ktor.server.application.*
 import io.ktor.server.netty.*
 import io.ktor.server.response.*
@@ -18,21 +16,9 @@ import io.ktor.server.routing.*
 import io.ktor.server.test.base.*
 import io.ktor.server.testing.suites.*
 import io.ktor.server.websocket.*
-import io.ktor.utils.io.*
 import io.ktor.websocket.*
-import io.netty.buffer.ByteBuf
-import io.netty.buffer.Unpooled
-import io.netty.handler.codec.http.HttpResponseStatus
-import io.netty.handler.codec.http2.DefaultHttp2Headers
-import io.netty.handler.codec.http2.DefaultHttp2HeadersDecoder
-import io.netty.handler.codec.http2.DefaultHttp2HeadersEncoder
-import io.netty.handler.codec.http2.Http2CodecUtil.readUnsignedInt
-import io.netty.handler.codec.http2.Http2Flags
-import io.netty.handler.codec.http2.Http2FrameTypes
-import kotlinx.coroutines.flow.consumeAsFlow
-import kotlin.test.Test
-import kotlin.test.assertEquals
-import kotlin.test.assertTrue
+import kotlinx.coroutines.flow.*
+import kotlin.test.*
 
 class NettyCompressionTest : CompressionTestSuite<NettyApplicationEngine, NettyApplicationEngine.Configuration>(Netty) {
     init {
@@ -165,224 +151,3 @@ class NettyServerPluginsTest : ServerPluginsTestSuite<NettyApplicationEngine, Ne
 }
 
 class NettyHooksTest : HooksTestSuite<NettyApplicationEngine, NettyApplicationEngine.Configuration>(Netty)
-
-class NettyH2cServerJvmTest :
-    HttpServerJvmTestSuite<NettyApplicationEngine, NettyApplicationEngine.Configuration>(Netty) {
-
-    init {
-        enableSsl = false
-        enableHttp2 = true
-    }
-
-    override fun configure(configuration: NettyApplicationEngine.Configuration) {
-        configuration.enableH2c = true
-    }
-}
-
-class NettyH2cEnabledTest :
-    EngineTestBase<NettyApplicationEngine, NettyApplicationEngine.Configuration>(Netty) {
-
-    init {
-        enableSsl = false
-        enableHttp2 = true
-    }
-
-    override fun configure(configuration: NettyApplicationEngine.Configuration) {
-        configuration.enableH2c = true
-    }
-
-    class Http2Frame(
-        val frameType: Byte,
-        val flags: Http2Flags,
-        val streamId: Int,
-        val payload: ByteArray,
-    )
-
-    companion object {
-        private const val TEST_SERVER_HOST = "127.0.0.1"
-        private const val PATH = "/"
-        private const val BODY = "Hello world"
-        private const val STREAM_ID = 3
-    }
-
-    @Test
-    fun testConnectionUpgradeH2cRequest() = runTest {
-        h2cTest { writer, reader ->
-            writer.writeStringUtf8("GET $PATH HTTP/1.1\r\n")
-            writer.writeStringUtf8("Host: ${TEST_SERVER_HOST}\r\n")
-            writer.writeStringUtf8("Connection: Upgrade, HTTP2-Settings\r\n")
-            writer.writeStringUtf8("Upgrade: h2c\r\n")
-            writer.writeStringUtf8("HTTP2-Settings: AAMAAABkAAQCAAAAAAIAAAAA\r\n")
-            writer.writeStringUtf8("\r\n")
-            writer.flush()
-
-            val response = reader.readHttp1Headers()
-            val responseLower = response.lowercase()
-
-            assertTrue(response.startsWith("HTTP/1.1 101"))
-            assertTrue(responseLower.contains("connection: upgrade"))
-            assertTrue(responseLower.contains("upgrade: h2c"))
-        }
-    }
-
-    @Test
-    fun testSendH2cRequestWithConnectionPreface() = runTest {
-        h2cTest { writer, reader ->
-            // send connection preset
-            writer.writeHttp2ConnectionPreface()
-
-            // send settings frame
-            writer.writeFully(http2SettingsFrame(ack = false))
-            writer.flush()
-
-            // read server settings
-            val http2ServerSettingsFrame = reader.readHttp2Frame()
-            assertEquals(Http2FrameTypes.SETTINGS, http2ServerSettingsFrame.frameType)
-
-            // read server ack
-            val http2ServerAckFrame = reader.readHttp2Frame()
-            assertEquals(Http2FrameTypes.SETTINGS, http2ServerAckFrame.frameType)
-            assertTrue(http2ServerAckFrame.flags.ack())
-
-            // send settings ack frame
-            writer.writeFully(http2SettingsFrame(ack = true))
-            writer.flush()
-
-            // send headers frame
-            writer.writeFully(http2HeadersFrame())
-            writer.flush()
-
-            reader.readHeaderFrame()
-
-            reader.readDataFrame()
-        }
-    }
-
-    private suspend fun ByteWriteChannel.writeHttp2ConnectionPreface() {
-        writeStringUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n")
-        flush()
-    }
-
-    private suspend fun ByteReadChannel.readHttp2Frame(): Http2Frame {
-        val dataHeaderBuf = Unpooled.wrappedBuffer(readByteArray(9))
-
-        val payloadLength = dataHeaderBuf.readUnsignedMedium()
-        val frameType = dataHeaderBuf.readByte()
-        val flags = Http2Flags(dataHeaderBuf.readUnsignedByte())
-        val streamId = readUnsignedInt(dataHeaderBuf)
-        val payload = readByteArray(payloadLength)
-
-        return Http2Frame(
-            frameType = frameType,
-            flags = flags,
-            streamId = streamId,
-            payload = payload
-        )
-    }
-
-    private suspend fun ByteReadChannel.readHeaderFrame() {
-        val http2Frame = readHttp2Frame()
-
-        val payloadBuff = Unpooled.wrappedBuffer(http2Frame.payload)
-        val decoder = DefaultHttp2HeadersDecoder(true)
-        val decodedHeaders = decoder.decodeHeaders(STREAM_ID, payloadBuff)
-
-        assertEquals(Http2FrameTypes.HEADERS, http2Frame.frameType)
-        assertEquals(STREAM_ID, http2Frame.streamId)
-        assertTrue(http2Frame.flags.endOfHeaders())
-        assertEquals(decodedHeaders.status(), HttpResponseStatus.OK.codeAsText())
-    }
-
-    private suspend fun ByteReadChannel.readDataFrame() {
-        val http2Frame = readHttp2Frame()
-
-        val data = String(http2Frame.payload, Charsets.UTF_8)
-
-        assertEquals(Http2FrameTypes.DATA, http2Frame.frameType)
-        assertEquals(STREAM_ID, http2Frame.streamId)
-        assertTrue(http2Frame.flags.endOfStream())
-        assertEquals(BODY, data)
-    }
-
-    private fun http2HeadersFrame(): ByteArray {
-        val headers = DefaultHttp2Headers().also {
-            it.method("GET")
-            it.path("/")
-            it.scheme("http")
-        }
-
-        val encodedHeaders = Unpooled.buffer()
-        val encoder = DefaultHttp2HeadersEncoder()
-        encoder.encodeHeaders(STREAM_ID, headers, encodedHeaders)
-
-        return http2Frame(
-            payload = encodedHeaders,
-            type = Http2FrameTypes.HEADERS,
-            flags = Http2Flags()
-                .endOfHeaders(true)
-                .endOfStream(true),
-            streamId = STREAM_ID
-        )
-    }
-
-    private fun http2SettingsFrame(ack: Boolean) = http2Frame(
-        payload = null,
-        type = Http2FrameTypes.SETTINGS,
-        flags = Http2Flags().ack(ack),
-        streamId = 0
-    )
-
-    private fun http2Frame(payload: ByteBuf?, type: Byte, flags: Http2Flags, streamId: Int): ByteArray {
-        val buf = Unpooled.buffer()
-
-        val payloadLength = payload?.readableBytes() ?: 0
-
-        buf.writeMedium(payloadLength)
-        buf.writeByte(type.toInt())
-        buf.writeByte(flags.value().toInt())
-        buf.writeInt(streamId)
-        payload?.let {
-            buf.writeBytes(it)
-        }
-
-        val frame = ByteArray(buf.readableBytes())
-        buf.readBytes(frame)
-
-        return frame
-    }
-
-    private fun h2cTest(block: suspend (ByteWriteChannel, ByteReadChannel) -> Unit) = runTest {
-        val server = createServer {
-            routing {
-                get(PATH) {
-                    call.respondText(BODY)
-                }
-            }
-        }
-        server.start(wait = false)
-
-        SelectorManager().use {
-            aSocket(it).tcp().connect(TEST_SERVER_HOST, port).use { socket ->
-                val writeChannel = socket.openWriteChannel()
-                val readChannel = socket.openReadChannel()
-                block(writeChannel, readChannel)
-            }
-        }
-
-        server.stop()
-    }
-
-    private suspend fun ByteReadChannel.readHttp1Headers(maxBytes: Int = 8192): String {
-        val buf = ByteArray(maxBytes)
-        var total = 0
-        while (true) {
-            val n = readAvailable(buf, total, buf.size - total)
-            if (n == -1) error("Connection closed before headers complete")
-            total += n
-            val s = buf.decodeToString(0, total)
-            val end = s.indexOf("\r\n\r\n")
-            if (end >= 0) return s.substring(0, end + 4)
-            require(total < maxBytes) { "HTTP/1.1 headers exceed $maxBytes bytes" }
-        }
-    }
-}
