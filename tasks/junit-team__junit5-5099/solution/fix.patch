diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-6.1.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-6.1.0-M1.adoc
index a42b54393..bd1bce04e 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-6.1.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-6.1.0-M1.adoc
@@ -31,6 +31,9 @@ repository on GitHub.
 * `OpenTestReportGeneratingListener` now supports redirecting XML events to a socket via
   the new `junit.platform.reporting.open.xml.socket` configuration parameter. When set to a
   port number, events are sent to `127.0.0.1:<port>` instead of being written to a file.
+* Allow implementations of `HierarchicalTestEngine` to specify which nodes require the
+  global read lock by overriding the `Node.isGlobalReadLockRequired()` method to return
+  `false`.
 
 
 [[release-notes-6.1.0-M1-junit-jupiter]]
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java
index 1fa014c92..fa7405ab5 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java
@@ -11,6 +11,7 @@
 package org.junit.platform.engine.support.hierarchical;
 
 import static java.util.Collections.emptySet;
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.MAINTAINED;
 import static org.apiguardian.api.API.Status.STABLE;
 
@@ -182,6 +183,23 @@ public interface Node<C extends EngineExecutionContext> {
 		return emptySet();
 	}
 
+	/**
+	 * {@return whether this node requires the global read-write lock}
+	 *
+	 * <p>Engines should return {@code true} for all nodes that have behavior,
+	 * including tests but also containers with before/after lifecycle hooks.
+	 *
+	 * <p>The default implementation returns {@code true}. The value returned by
+	 * engine-level nodes is ignored. Otherwise, if a container node returns
+	 * {@code true}, the value returned by its descendants is ignored.
+	 *
+	 * @since 6.1
+	 */
+	@API(status = EXPERIMENTAL, since = "6.1")
+	default boolean isGlobalReadLockRequired() {
+		return true;
+	}
+
 	/**
 	 * Get the preferred of {@linkplain ExecutionMode execution mode} for
 	 * parallel execution of this node.
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java
index 1f95c6233..38dd1e0ea 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java
@@ -13,11 +13,13 @@ package org.junit.platform.engine.support.hierarchical;
 import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_READ;
 import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_READ_WRITE;
 import static org.junit.platform.engine.support.hierarchical.Node.ExecutionMode.SAME_THREAD;
+import static org.junit.platform.engine.support.hierarchical.NodeUtils.asNode;
 
 import java.util.HashSet;
 import java.util.Set;
 import java.util.function.Consumer;
 
+import org.jspecify.annotations.Nullable;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.engine.TestDescriptor;
 
@@ -44,26 +46,34 @@ class NodeTreeWalker {
 		Preconditions.condition(getExclusiveResources(rootDescriptor).isEmpty(),
 			"Engine descriptor must not declare exclusive resources");
 		NodeExecutionAdvisor advisor = new NodeExecutionAdvisor();
-		rootDescriptor.getChildren().forEach(child -> walk(child, child, advisor));
+		rootDescriptor.getChildren().forEach(child -> walk(nullUnlessRequiresGlobalReadLock(child), child, advisor));
 		return advisor;
 	}
 
-	private void walk(TestDescriptor globalLockDescriptor, TestDescriptor testDescriptor,
+	private void walk(@Nullable TestDescriptor globalLockDescriptor, TestDescriptor testDescriptor,
 			NodeExecutionAdvisor advisor) {
 
-		if (advisor.getResourceLock(globalLockDescriptor) == globalReadWriteLock) {
+		if (globalLockDescriptor != null && advisor.getResourceLock(globalLockDescriptor) == globalReadWriteLock) {
 			// Global read-write lock is already being enforced, so no additional locks are needed
 			return;
 		}
 
 		Set<ExclusiveResource> exclusiveResources = getExclusiveResources(testDescriptor);
 		if (exclusiveResources.isEmpty()) {
-			if (globalLockDescriptor.equals(testDescriptor)) {
+			if (globalLockDescriptor != null && globalLockDescriptor.equals(testDescriptor)) {
 				advisor.useResourceLock(globalLockDescriptor, globalReadLock);
 			}
-			testDescriptor.getChildren().forEach(child -> walk(globalLockDescriptor, child, advisor));
+			testDescriptor.getChildren().forEach(child -> {
+				var newGlobalLockDescriptor = globalLockDescriptor == null //
+						? nullUnlessRequiresGlobalReadLock(child) //
+						: globalLockDescriptor;
+				walk(newGlobalLockDescriptor, child, advisor);
+			});
 		}
 		else {
+			Preconditions.notNull(globalLockDescriptor,
+				() -> "Node requiring exclusive resources must also require global read lock: " + testDescriptor);
+
 			Set<ExclusiveResource> allResources = new HashSet<>(exclusiveResources);
 			if (isReadOnly(allResources)) {
 				doForChildrenRecursively(testDescriptor, child -> allResources.addAll(getExclusiveResources(child)));
@@ -109,7 +119,11 @@ class NodeTreeWalker {
 	}
 
 	private Set<ExclusiveResource> getExclusiveResources(TestDescriptor testDescriptor) {
-		return NodeUtils.asNode(testDescriptor).getExclusiveResources();
+		return asNode(testDescriptor).getExclusiveResources();
+	}
+
+	private static @Nullable TestDescriptor nullUnlessRequiresGlobalReadLock(TestDescriptor testDescriptor) {
+		return asNode(testDescriptor).isGlobalReadLockRequired() ? testDescriptor : null;
 	}
 
 	private void doForChildrenRecursively(TestDescriptor parent, Consumer<TestDescriptor> consumer) {
