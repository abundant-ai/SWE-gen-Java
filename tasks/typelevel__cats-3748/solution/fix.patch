diff --git a/core/src/main/scala/cats/data/ContT.scala b/core/src/main/scala/cats/data/ContT.scala
index 07f9b9807..efbc41c54 100644
--- a/core/src/main/scala/cats/data/ContT.scala
+++ b/core/src/main/scala/cats/data/ContT.scala
@@ -47,6 +47,8 @@ sealed abstract class ContT[M[_], A, +B] extends Serializable {
       M.defer(run(fn3))
     }
   }
+
+  final def eval(implicit M: Applicative[M], D: Defer[M], ev: B <:< A): M[A] = D.defer(run(b => M.pure(ev(b))))
 }
 
 object ContT {
@@ -125,7 +127,7 @@ object ContT {
    *
    * }}}
    */
-  def callCC[M[_], R, A, B](f: (A => ContT[M, R, B]) => ContT[M, R, A])(implicit M: Defer[M]): ContT[M, R, A] =
+  def callCC[M[_], A, B, C](f: (B => ContT[M, A, C]) => ContT[M, A, B])(implicit M: Defer[M]): ContT[M, A, B] =
     apply { cb =>
       val cont = f { a =>
         apply(_ => cb(a))
@@ -188,6 +190,58 @@ object ContT {
   def later[M[_], A, B](fn: => (B => M[A]) => M[A]): ContT[M, A, B] =
     DeferCont(() => FromFn(AndThen(fn)))
 
+  /*
+   * Limits the continuation of any inner [[shiftT]]
+   */
+  def resetT[M[_]: Monad: Defer, A, B](contT: ContT[M, B, B]): ContT[M, A, B] =
+    ContT.liftF(contT.eval)
+
+  /*
+   * Captures the continuation up to the nearest enclosing [[resetT]] and passes
+   * it to f.
+   *
+   * For example, in the following the continuation captured as k is
+   * {{{ _.map(_ + 1) }}}
+   * so the evaluation (modulo Eval) is 2 * (5 + 1)
+   *
+   * {{{
+   *   val cont: Cont[Int, Int] = Cont.reset(
+   *     Cont.shift((k: Int => Eval[Int]) =>
+   *       Cont.liftF[Int, Int](k(5))
+   *     ).map(_ + 1)
+   *   ).map(_ * 2)
+   *
+   *   cont.eval.value === 12
+   * }}}
+   *
+   *
+   * For an example with IO, consider the evaluation order of this:
+   * {{{
+   *   for {
+   *     _ <- ContT.resetT(
+   *            for {
+   *              _ <- ContT.liftF(IO.println("1"))
+   *              _ <- ContT.shiftT { (k: Unit => IO[Unit]) =>
+   *                     for {
+   *                       _ <- ContT.liftF(IO.println("2"))
+   *                       _ <- ContT.liftF(k(()))
+   *                       _ <- ContT.liftF(IO.println("4"))
+   *                     }
+   *                   }
+   *              _ <- ContT.liftF(IO.println("3"))
+   *            } yield ()
+   *         )
+   *     _ <- ContT.liftF(IO.println("5"))
+   *   } yield ()
+   * }}}
+   *
+   * The continuation captured by k is {{{ >> ContT.liftF(IO.println("3")) }}}
+   * which is why that is evaluated when {{{ k() }}} is invoked and
+   * hence why it is printed before 4.
+   */
+  def shiftT[M[_]: Applicative: Defer, A, B](f: (B => M[A]) => ContT[M, A, A]): ContT[M, A, B] =
+    apply(cb => f(cb).eval)
+
   def tailRecM[M[_], A, B, C](a: A)(fn: A => ContT[M, C, Either[A, B]])(implicit M: Defer[M]): ContT[M, C, B] =
     ContT[M, C, B] { (cb: (B => M[C])) =>
       def go(a: A): M[C] =
diff --git a/core/src/main/scala/cats/data/package.scala b/core/src/main/scala/cats/data/package.scala
index 4561800bd..96fbff90c 100644
--- a/core/src/main/scala/cats/data/package.scala
+++ b/core/src/main/scala/cats/data/package.scala
@@ -100,5 +100,16 @@ package object data extends ScalaVersionSpecificPackage {
 
     def tailRecM[A, B, C](a: A)(f: A => Cont[C, Either[A, B]]): Cont[C, B] =
       ContT.tailRecM(a)(f)
+
+    def liftF[A, B](b: Eval[B]): Cont[A, B] = ContT.liftF(b)
+
+    def callCC[A, B, C](f: (B => Cont[A, C]) => Cont[A, B]): Cont[A, B] =
+      ContT.callCC(f)
+
+    def reset[A, B](cont: Cont[A, A]): Cont[B, A] =
+      ContT.resetT(cont)
+
+    def shift[A, B](f: (B => Eval[A]) => Cont[A, A]): Cont[A, B] =
+      ContT.shiftT(f)
   }
 }
