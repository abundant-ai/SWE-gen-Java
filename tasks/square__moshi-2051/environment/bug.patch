diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4389e1e5..70e9b24c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -5,8 +5,6 @@ Change Log
 
 * Refuse `j$.*` types from Android library desugaring as platform types.
 * In-development snapshots are now published to the Central Portal Snapshots repository at https://central.sonatype.com/repository/maven-snapshots/.
-* Fully supports encoding/decoding of value classes in both moshi-kotlin and code gen.
-  * Note that Moshi does not propagate inlining to JSON. For example: `@JvmInline value class Color(val raw: Int)` is serialized to `{"raw": 12345}`.
 
 ## Upgrading to Moshi 2.x
 
@@ -70,6 +68,7 @@ This release switches `KotlinJsonAdapterFactory` to use `kotlin-metadata` instea
 
 * This is not a source or ABI breaking change but if you were relying on the transitive `kotlin-reflect` dependency you will need to add it explicitly.
 * No longer encodes properties/fields from supertypes that are platform types.
+* Fully supports encoding/decoding of value classes. Note that Moshi does not propagate inlining to JSON. For example: `@JvmInline value class Color(val raw: Int)` is serialized to `{"raw": 12345}`.
 
 ## Version 1.15.2
 
diff --git a/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/AdapterGenerator.kt b/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/AdapterGenerator.kt
index d112fd7b..a3729d93 100644
--- a/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/AdapterGenerator.kt
+++ b/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/AdapterGenerator.kt
@@ -524,109 +524,77 @@ public class AdapterGenerator(
     var closeNextControlFlowInAssignment = false
 
     if (useDefaultsConstructor) {
-      if (target.isValueClass) {
-        // Special case for value classes with defaults
-        // For value classes, we want to call the constructor directly, omitting arguments when
-        // they weren't present in the JSON (according to the mask) so defaults can be used.
-        val paramProperty = components.filterIsInstance<ParameterProperty>().single()
-        val maskName = maskNames.single() // Value classes only have one parameter
-        val maskSetValue = maskAllSetValues.single()
-        // return if (mask == allSetValue) Constructor(value) else Constructor()
-        result.addCode(
-          "return·if·(%L·== 0x%L.toInt())·{\n",
-          maskName,
-          Integer.toHexString(maskSetValue),
-        )
-        result.addCode("⇥")
-        result.addComment("Property was present, invoke constructor with the value")
-        result.addCode("%T(\n", originalTypeName)
-        result.addCode("⇥%N = %N", paramProperty.property.name, paramProperty.property.localName)
-        if (paramProperty.property.isRequired) {
-          result.addMissingPropertyCheck(paramProperty.property, readerParam)
-        } else if (!paramProperty.type.isNullable) {
-          result.addCode("·as·%T", paramProperty.type)
-        }
-        result.addCode("\n⇤)\n")
-        result.addCode("⇤}·else·{\n")
-        result.addCode("⇥")
-        result.addComment("Property was absent, invoke constructor without argument to use default")
-        result.addCode("%T()\n", originalTypeName)
-        result.addCode("⇤}\n")
-        // Early return for value classes, skip the rest of the constructor logic
-        return result.build()
-      } else {
-        // Happy path - all parameters with defaults are set
-        val allMasksAreSetBlock = maskNames.withIndex()
-          .map { (index, maskName) ->
-            CodeBlock.of("$maskName·== 0x${Integer.toHexString(maskAllSetValues[index])}.toInt()")
-          }
-          .joinToCode("·&& ")
-        result.beginControlFlow("if (%L)", allMasksAreSetBlock)
-        result.addComment("All parameters with defaults are set, invoke the constructor directly")
-        result.addCode("«%L·%T(", returnOrResultAssignment, originalTypeName)
-        var localSeparator = "\n"
-        val paramsToSet = components.filterIsInstance<ParameterProperty>()
-          .filterNot { it.property.isTransient }
-
-        // Set all non-transient property parameters
-        for (input in paramsToSet) {
-          result.addCode(localSeparator)
-          val property = input.property
-          result.addCode("%N = %N", property.name, property.localName)
-          if (property.isRequired) {
-            result.addMissingPropertyCheck(property, readerParam)
-          } else if (!input.type.isNullable) {
-            // Unfortunately incurs an intrinsic null-check even though we know it's set, but
-            // maybe in the future we can use contracts to omit them.
-            result.addCode("·as·%T", input.type)
-          }
-          localSeparator = ",\n"
+      // Happy path - all parameters with defaults are set
+      val allMasksAreSetBlock = maskNames.withIndex()
+        .map { (index, maskName) ->
+          CodeBlock.of("$maskName·== 0x${Integer.toHexString(maskAllSetValues[index])}.toInt()")
         }
-        result.addCode("\n»)\n")
-        result.nextControlFlow("else")
-        closeNextControlFlowInAssignment = true
-
-        classBuilder.addProperty(constructorProperty)
-        result.addComment("Reflectively invoke the synthetic defaults constructor")
-        // Dynamic default constructor call
-        val nonNullConstructorType = constructorProperty.type.copy(nullable = false)
-        val args = constructorPropertyTypes
-          .plus(0.until(maskCount).map { INT_TYPE_BLOCK }) // Masks, one every 32 params
-          .plus(DEFAULT_CONSTRUCTOR_MARKER_TYPE_BLOCK) // Default constructor marker is always last
-          .joinToCode(", ")
-        val coreLookupBlock = CodeBlock.of(
-          "%T::class.java.getDeclaredConstructor(%L)",
-          originalRawTypeName,
-          args,
-        )
-        val lookupBlock = if (originalTypeName is ParameterizedTypeName) {
-          CodeBlock.of("(%L·as·%T)", coreLookupBlock, nonNullConstructorType)
-        } else {
-          coreLookupBlock
+        .joinToCode("·&& ")
+      result.beginControlFlow("if (%L)", allMasksAreSetBlock)
+      result.addComment("All parameters with defaults are set, invoke the constructor directly")
+      result.addCode("«%L·%T(", returnOrResultAssignment, originalTypeName)
+      var localSeparator = "\n"
+      val paramsToSet = components.filterIsInstance<ParameterProperty>()
+        .filterNot { it.property.isTransient }
+
+      // Set all non-transient property parameters
+      for (input in paramsToSet) {
+        result.addCode(localSeparator)
+        val property = input.property
+        result.addCode("%N = %N", property.name, property.localName)
+        if (property.isRequired) {
+          result.addMissingPropertyCheck(property, readerParam)
+        } else if (!input.type.isNullable) {
+          // Unfortunately incurs an intrinsic null-check even though we know it's set, but
+          // maybe in the future we can use contracts to omit them.
+          result.addCode("·as·%T", input.type)
         }
-        val initializerBlock = CodeBlock.of(
-          "this.%1N·?: %2L.also·{ this.%1N·= it }",
-          constructorProperty,
-          lookupBlock,
-        )
-        val localConstructorProperty = PropertySpec.builder(
-          nameAllocator.newName("localConstructor"),
-          nonNullConstructorType,
-        )
-          .addAnnotation(
-            AnnotationSpec.builder(Suppress::class)
-              .addMember("%S", "UNCHECKED_CAST")
-              .build(),
-          )
-          .initializer(initializerBlock)
-          .build()
-        result.addCode("%L", localConstructorProperty)
-        result.addCode(
-          "«%L%N.newInstance(",
-          returnOrResultAssignment,
-          localConstructorProperty,
-        )
+        localSeparator = ",\n"
+      }
+      result.addCode("\n»)\n")
+      result.nextControlFlow("else")
+      closeNextControlFlowInAssignment = true
+
+      classBuilder.addProperty(constructorProperty)
+      result.addComment("Reflectively invoke the synthetic defaults constructor")
+      // Dynamic default constructor call
+      val nonNullConstructorType = constructorProperty.type.copy(nullable = false)
+      val args = constructorPropertyTypes
+        .plus(0.until(maskCount).map { INT_TYPE_BLOCK }) // Masks, one every 32 params
+        .plus(DEFAULT_CONSTRUCTOR_MARKER_TYPE_BLOCK) // Default constructor marker is always last
+        .joinToCode(", ")
+      val coreLookupBlock = CodeBlock.of(
+        "%T::class.java.getDeclaredConstructor(%L)",
+        originalRawTypeName,
+        args,
+      )
+      val lookupBlock = if (originalTypeName is ParameterizedTypeName) {
+        CodeBlock.of("(%L·as·%T)", coreLookupBlock, nonNullConstructorType)
+      } else {
+        coreLookupBlock
       }
+      val initializerBlock = CodeBlock.of(
+        "this.%1N·?: %2L.also·{ this.%1N·= it }",
+        constructorProperty,
+        lookupBlock,
+      )
+      val localConstructorProperty = PropertySpec.builder(
+        nameAllocator.newName("localConstructor"),
+        nonNullConstructorType,
+      )
+        .addAnnotation(
+          AnnotationSpec.builder(Suppress::class)
+            .addMember("%S", "UNCHECKED_CAST")
+            .build(),
+        )
+        .initializer(initializerBlock)
+        .build()
+      result.addCode("%L", localConstructorProperty)
+      result.addCode(
+        "«%L%N.newInstance(",
+        returnOrResultAssignment,
+        localConstructorProperty,
+      )
     } else {
       // Standard constructor call. Don't omit generics for parameterized types even if they can be
       // inferred, as calculating the right condition for inference exceeds the value gained from
diff --git a/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetType.kt b/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetType.kt
index 760c3ae4..a6972982 100644
--- a/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetType.kt
+++ b/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/api/TargetType.kt
@@ -28,7 +28,6 @@ public data class TargetType(
   val typeVariables: List<TypeVariableName>,
   val isDataClass: Boolean,
   val visibility: KModifier,
-  val isValueClass: Boolean,
 ) {
 
   init {
diff --git a/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/ksp/TargetTypes.kt b/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/ksp/TargetTypes.kt
index f5579089..699abc2a 100644
--- a/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/ksp/TargetTypes.kt
+++ b/moshi-kotlin-codegen/src/main/java/com/squareup/moshi/kotlin/codegen/ksp/TargetTypes.kt
@@ -156,7 +156,6 @@ internal fun targetType(type: KSDeclaration, resolver: Resolver, logger: KSPLogg
     typeVariables = typeVariables,
     isDataClass = Modifier.DATA in type.modifiers,
     visibility = resolvedVisibility,
-    isValueClass = Modifier.VALUE in type.modifiers,
   )
 }
 
diff --git a/moshi-kotlin-tests/src/test/kotlin/com/squareup/moshi/kotlin/DualKotlinTest.kt b/moshi-kotlin-tests/src/test/kotlin/com/squareup/moshi/kotlin/DualKotlinTest.kt
index 65d3c1e6..fa1d4f77 100644
--- a/moshi-kotlin-tests/src/test/kotlin/com/squareup/moshi/kotlin/DualKotlinTest.kt
+++ b/moshi-kotlin-tests/src/test/kotlin/com/squareup/moshi/kotlin/DualKotlinTest.kt
@@ -807,7 +807,7 @@ data class GenericClass<T>(val value: T)
 
 // Has to be outside since value classes are only allowed on top level
 @JvmInline
-@JsonClass(generateAdapter = true)
+@JsonClass(generateAdapter = false) // TODO revisit code gen support separately
 value class ValueClass(val i: Int = 0)
 
 typealias A = Int
