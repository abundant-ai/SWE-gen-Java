diff --git a/CHANGELOG.md b/CHANGELOG.md
index 7994e6a0..34d33bac 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -10,7 +10,6 @@ Change Log
 * New `@JsonClass.inline` property to allow inlining single-property JSON classes during encoding/decoding.
   * This is particularly useful for value classes.
   * For example, a class `@JvmInline value class UserId(val id: Int)` with `inline = true` will serialize as just `123` rather than `{"id": 123}`.
-* `PolymorphicJsonAdapterFactory` now invokes the fallback adapter when the label key is missing entirely from the JSON, not just when the label value is unrecognized.
 
 ## Upgrading to Moshi 2.x
 
diff --git a/moshi-adapters/src/main/java/com/squareup/moshi/adapters/PolymorphicJsonAdapterFactory.kt b/moshi-adapters/src/main/java/com/squareup/moshi/adapters/PolymorphicJsonAdapterFactory.kt
index 2e2aeec3..bf769873 100644
--- a/moshi-adapters/src/main/java/com/squareup/moshi/adapters/PolymorphicJsonAdapterFactory.kt
+++ b/moshi-adapters/src/main/java/com/squareup/moshi/adapters/PolymorphicJsonAdapterFactory.kt
@@ -87,7 +87,7 @@ import javax.annotation.CheckReturnValue
  * For best performance type information should be the first field in the object. Otherwise Moshi
  * must reprocess the JSON stream once it knows the object's type.
  *
- * If an unknown subtype label is encountered when decoding, or if the label key is missing entirely:
+ * If an unknown subtype is encountered when decoding:
  *  * If [withDefaultValue] is used, then `defaultValue` will be returned.
  *  * If [withFallbackJsonAdapter] is used, then the `fallbackJsonAdapter.fromJson(reader)` result will be returned.
  *  * Otherwise a [JsonDataException] will be thrown.
@@ -127,7 +127,7 @@ public class PolymorphicJsonAdapterFactory<T> internal constructor(
 
   /**
    * Returns a new factory that with default to `fallbackJsonAdapter.fromJson(reader)` upon
-   * decoding of unrecognized labels or when the label key is missing entirely.
+   * decoding of unrecognized labels.
    *
    * The [JsonReader] instance will not be automatically consumed, so make sure to consume
    * it within your implementation of [JsonAdapter.fromJson]
@@ -146,7 +146,7 @@ public class PolymorphicJsonAdapterFactory<T> internal constructor(
 
   /**
    * Returns a new factory that will default to `defaultValue` upon decoding of unrecognized
-   * labels or when the label key is missing entirely. The default value should be immutable.
+   * labels. The default value should be immutable.
    */
   public fun withDefaultValue(defaultValue: T?): PolymorphicJsonAdapterFactory<T> {
     return withFallbackJsonAdapter(buildFallbackJsonAdapter(defaultValue))
@@ -216,9 +216,6 @@ public class PolymorphicJsonAdapterFactory<T> internal constructor(
         }
         return labelIndex
       }
-      if (fallbackJsonAdapter != null) {
-        return -1
-      }
       throw JsonDataException("Missing label for $labelKey")
     }
 
diff --git a/moshi-adapters/src/test/java/com/squareup/moshi/adapters/PolymorphicJsonAdapterFactoryTest.java b/moshi-adapters/src/test/java/com/squareup/moshi/adapters/PolymorphicJsonAdapterFactoryTest.java
index 8f7c52f6..68011b82 100644
--- a/moshi-adapters/src/test/java/com/squareup/moshi/adapters/PolymorphicJsonAdapterFactoryTest.java
+++ b/moshi-adapters/src/test/java/com/squareup/moshi/adapters/PolymorphicJsonAdapterFactoryTest.java
@@ -377,78 +377,6 @@ public final class PolymorphicJsonAdapterFactoryTest {
     assertThat(decoded.value).isEqualTo("Okay!");
   }
 
-  @Test
-  public void missingLabelKey() throws IOException {
-    Moshi moshi =
-        new Moshi.Builder()
-            .add(
-                PolymorphicJsonAdapterFactory.of(Message.class, "type")
-                    .withSubtype(Success.class, "success")
-                    .withSubtype(Error.class, "error"))
-            .build();
-    JsonAdapter<Message> adapter = moshi.adapter(Message.class);
-
-    JsonReader reader = JsonReader.of(new Buffer().writeUtf8("{\"value\":\"Okay!\"}"));
-    try {
-      adapter.fromJson(reader);
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected).hasMessageThat().isEqualTo("Missing label for type");
-    }
-    assertThat(reader.peek()).isEqualTo(JsonReader.Token.BEGIN_OBJECT);
-  }
-
-  @Test
-  public void missingLabelKeyWithSpecifiedFallbackJsonAdapter() throws IOException {
-    Moshi moshi =
-        new Moshi.Builder()
-            .add(
-                PolymorphicJsonAdapterFactory.of(Message.class, "type")
-                    .withSubtype(Success.class, "success")
-                    .withSubtype(Error.class, "error")
-                    .withFallbackJsonAdapter(
-                        new JsonAdapter<Object>() {
-                          @Override
-                          public Object fromJson(JsonReader reader) throws IOException {
-                            reader.beginObject();
-                            assertThat(reader.nextName()).isEqualTo("value");
-                            assertThat(reader.nextString()).isEqualTo("Okay!");
-                            reader.endObject();
-                            return new EmptyMessage();
-                          }
-
-                          @Override
-                          public void toJson(JsonWriter writer, @Nullable Object value) {
-                            throw new AssertionError();
-                          }
-                        }))
-            .build();
-    JsonAdapter<Message> adapter = moshi.adapter(Message.class);
-
-    JsonReader reader = JsonReader.of(new Buffer().writeUtf8("{\"value\":\"Okay!\"}"));
-
-    Message message = adapter.fromJson(reader);
-    assertThat(message).isInstanceOf(EmptyMessage.class);
-    assertThat(reader.peek()).isEqualTo(JsonReader.Token.END_DOCUMENT);
-  }
-
-  @Test
-  public void missingLabelKeyWithSpecifiedDefaultValue() throws IOException {
-    Error fallbackError = new Error(Collections.<String, Object>emptyMap());
-    Moshi moshi =
-        new Moshi.Builder()
-            .add(
-                PolymorphicJsonAdapterFactory.of(Message.class, "type")
-                    .withSubtype(Success.class, "success")
-                    .withSubtype(Error.class, "error")
-                    .withDefaultValue(fallbackError))
-            .build();
-    JsonAdapter<Message> adapter = moshi.adapter(Message.class);
-
-    Message message = adapter.fromJson("{\"value\":\"Okay!\"}");
-    assertThat(message).isSameInstanceAs(fallbackError);
-  }
-
   interface Message {}
 
   static final class Success implements Message {
