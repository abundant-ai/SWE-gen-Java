diff --git a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
index dd7ba149..52d0e819 100644
--- a/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
+++ b/retrofit/src/main/java/retrofit/ExceptionCatchingRequestBody.java
@@ -53,11 +53,9 @@ final class ExceptionCatchingRequestBody extends ResponseBody {
     delegate.close();
   }
 
-  IOException getThrownException() {
-    return thrownException;
-  }
-
-  boolean threwException() {
-    return thrownException != null;
+  void throwIfCaught() throws IOException {
+    if (thrownException != null) {
+      throw thrownException;
+    }
   }
 }
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index b1687ea4..7e9dad8f 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -22,6 +22,8 @@ import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.lang.reflect.Type;
 
+import static retrofit.Utils.closeQueitly;
+
 final class OkHttpCall<T> implements Call<T> {
   private final Endpoint endpoint;
   private final Converter converter;
@@ -118,43 +120,55 @@ final class OkHttpCall<T> implements Call<T> {
 
   private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
     ResponseBody rawBody = rawResponse.body();
-    // Remove the body (the only stateful object) from the raw response so we can pass it along.
+    // Remove the body (the only stateful object) so we can pass the response along.
     rawResponse = rawResponse.newBuilder().body(null).build();
 
-    T converted = null;
-    ResponseBody body = null;
+    int code = rawResponse.code();
+    if (code < 200 || code >= 300) {
+      try {
+        // Buffer the entire body to avoid future I/O.
+        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
+        return Response.error(bufferedBody, rawResponse);
+      } finally {
+        closeQueitly(rawBody);
+      }
+    }
 
-    try {
-      int code = rawResponse.code();
-      if (code < 200 || code >= 300) {
-        // Buffer the entire body in the event of a non-2xx status to avoid future I/O.
-        body = Utils.readBodyToBytesIfNecessary(rawBody);
-      } else if (code != 204 && code != 205) {
-        Type responseType = methodInfo.adapter.responseType();
-        if (responseType == ResponseBody.class) {
-          //noinspection unchecked
-          converted = (T) Utils.readBodyToBytesIfNecessary(rawBody);
-        } else {
-          ExceptionCatchingRequestBody wrapped = new ExceptionCatchingRequestBody(rawBody);
-          try {
-            //noinspection unchecked
-            converted = (T) converter.fromBody(wrapped, responseType);
-          } catch (RuntimeException e) {
-            // If the underlying input stream threw an exception, propagate that rather than
-            // indicating that it was a conversion exception.
-            if (wrapped.threwException()) {
-              throw wrapped.getThrownException();
-            }
-
-            throw e;
-          }
-        }
+    if (code == 204 || code == 205) {
+      return Response.success(null, rawResponse);
+    }
+
+    Type responseType = methodInfo.adapter.responseType();
+    if (responseType == ResponseBody.class) {
+      if (methodInfo.isStreaming) {
+        // Use the raw body from the request. The caller is responsible for closing.
+        //noinspection unchecked
+        return Response.success((T) rawBody, rawResponse);
+      }
+
+      try {
+        // Buffer the entire body to avoid future I/O.
+        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
+        //noinspection unchecked
+        return Response.success((T) bufferedBody, rawResponse);
+      } finally {
+        closeQueitly(rawBody);
       }
-    } finally {
-      rawBody.close();
     }
 
-    return new Response<>(rawResponse, converted, body);
+    ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
+    try {
+      //noinspection unchecked
+      T body = (T) converter.fromBody(catchingBody, responseType);
+      return Response.success(body, rawResponse);
+    } catch (RuntimeException e) {
+      // If the underlying source threw an exception, propagate that rather than indicating it was
+      // a runtime exception.
+      catchingBody.throwIfCaught();
+      throw e;
+    } finally {
+      closeQueitly(rawBody);
+    }
   }
 
   public void cancel() {
diff --git a/retrofit/src/main/java/retrofit/Response.java b/retrofit/src/main/java/retrofit/Response.java
index 8aaa9bca..8e2ee2fc 100644
--- a/retrofit/src/main/java/retrofit/Response.java
+++ b/retrofit/src/main/java/retrofit/Response.java
@@ -29,8 +29,8 @@ public final class Response<T> {
   /**
    * TODO
    */
-  public static <T, B extends T> Response<T> fromBody(B body) {
-    return fromBody(body, new com.squareup.okhttp.Response.Builder() //
+  public static <T, B extends T> Response<T> fakeSuccess(B body) {
+    return success(body, new com.squareup.okhttp.Response.Builder() //
         .code(200)
         .protocol(Protocol.HTTP_1_1)
         .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
@@ -41,7 +41,7 @@ public final class Response<T> {
   /**
    * TODO
    */
-  public static <T, B extends T> Response<T> fromBody(B body,
+  public static <T, B extends T> Response<T> success(B body,
       com.squareup.okhttp.Response rawResponse) {
     return new Response<T>(rawResponse, body, null);
   }
@@ -49,11 +49,10 @@ public final class Response<T> {
   /**
    * TODO
    */
-  public static Response<Object> fromError(int code, ResponseBody body) {
-    return fromError(new com.squareup.okhttp.Response.Builder() //
+  public static <T> Response<T> fakeError(int code, ResponseBody body) {
+    return error(body, new com.squareup.okhttp.Response.Builder() //
         .code(code)
         .protocol(Protocol.HTTP_1_1)
-        .body(body)
         .request(new com.squareup.okhttp.Request.Builder().url(HttpUrl.parse("http://localhost"))
             .build())
         .build());
@@ -62,18 +61,18 @@ public final class Response<T> {
   /**
    * TODO
    */
-  public static Response<Object> fromError(com.squareup.okhttp.Response rawResponse) {
-    ResponseBody errorBody = rawResponse.body();
-    if (errorBody == null) throw new IllegalArgumentException("Raw response must have body.");
-    rawResponse = rawResponse.newBuilder().body(null).build();
-    return new Response<>(rawResponse, null, errorBody);
+  public static <T> Response<T> error(ResponseBody body, com.squareup.okhttp.Response rawResponse) {
+    if (rawResponse.body() != null) {
+      throw new IllegalArgumentException("Raw response must not have body.");
+    }
+    return new Response<>(rawResponse, null, body);
   }
 
   private final com.squareup.okhttp.Response rawResponse;
   private final T body;
   private final ResponseBody errorBody;
 
-  Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
+  private Response(com.squareup.okhttp.Response rawResponse, T body, ResponseBody errorBody) {
     this.rawResponse = checkNotNull(rawResponse, "rawResponse == null");
     this.body = body;
     this.errorBody = errorBody;
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index c9a6d53a..decdad80 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -18,6 +18,7 @@ package retrofit;
 
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.ResponseBody;
+import java.io.Closeable;
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
@@ -39,6 +40,14 @@ final class Utils {
     return object;
   }
 
+  static void closeQueitly(Closeable closeable) {
+    if (closeable == null) return;
+    try {
+      closeable.close();
+    } catch (IOException ignored) {
+    }
+  }
+
   /**
    * Replace a {@link Response} with an identical copy whose body is backed by a
    * {@link Buffer} rather than a {@link Source}.
