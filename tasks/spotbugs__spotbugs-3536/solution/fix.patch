diff --git a/CHANGELOG.md b/CHANGELOG.md
index d88574ab0..01cca8d2c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -29,6 +29,7 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 - Make the osgi manifest of the annotations jar Java 8 compatible  ([#3498](https://github.com/spotbugs/spotbugs/pull/3498)) ([#3500](https://github.com/spotbugs/spotbugs/pull/3500))
 - `TextUICommandLine` supports all options encoded in Eclipse preferences file ([#3520](https://github.com/spotbugs/spotbugs/issues/3520))
 - Unnecessary suppressions fix for records headers ([#3471](https://github.com/spotbugs/spotbugs/issues/3471))
+- Dead store fix when switch case contains loops  ([#3530](https://github.com/spotbugs/spotbugs/issues/3530))  ([#3449](https://github.com/spotbugs/spotbugs/issues/3449))
 
 ### Added
 - Added the unnecessary annotation to the `US_USELESS_SUPPRESSION_ON_*` messages ([#3395](https://github.com/spotbugs/spotbugs/issues/3395))
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java
index dccbf9bd4..3e420d81b 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java
@@ -77,8 +77,6 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
 
     private int priority;
 
-    private int fallthroughDistance;
-
     public SwitchFallthrough(BugReporter bugReporter) {
         this.bugAccumulator = new BugAccumulator(bugReporter);
     }
@@ -103,7 +101,6 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
         clearAllDeadStores();
         deadStore = null;
         priority = NORMAL_PRIORITY;
-        fallthroughDistance = 1000;
         enumType = null;
         super.visit(obj);
         enumType = null;
@@ -163,7 +160,7 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
             if (DEBUG) {
                 System.out.println("Fallthrough at : " + getPC() + ": " + Const.getOpcodeName(seen));
             }
-            fallthroughDistance = 0;
+
             potentiallyDeadStoresFromBeforeFallthrough = (BitSet) potentiallyDeadStores.clone();
             potentiallyDeadFieldsFromBeforeFallthrough = new HashSet<>(potentiallyDeadFields);
             if (!hasFallThruComment(lastPC + 1, getPC() - 1)) {
@@ -183,8 +180,9 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
 
         }
 
-        if (isBranch(seen) || isSwitch(seen) || seen == Const.GOTO || seen == Const.ARETURN || seen == Const.IRETURN || seen == Const.RETURN
-                || seen == Const.LRETURN || seen == Const.DRETURN || seen == Const.FRETURN) {
+        if (isSwitch(seen)
+                || isReturn(seen)
+                || (isBranch(seen) && isBranchTargetAfterNextCaseOffset())) {
             clearAllDeadStores();
         }
 
@@ -275,14 +273,17 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
 
         case Const.GOTO_W:
         case Const.GOTO:
-            if (biggestJumpTarget < getBranchTarget()) {
-                biggestJumpTarget = getBranchTarget();
-                if (DEBUG) {
-                    System.out.printf("  Setting BJT to %d%n", biggestJumpTarget);
+            if (isBranchTargetAfterNextCaseOffset()) {
+                if (biggestJumpTarget < getBranchTarget()) {
+                    biggestJumpTarget = getBranchTarget();
+                    if (DEBUG) {
+                        System.out.printf("  Setting BJT to %d%n", biggestJumpTarget);
+                    }
                 }
+
+                reachable = false;
             }
 
-            reachable = false;
             break;
 
         case Const.ATHROW:
@@ -305,7 +306,16 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
 
         justSawHashcode = seen == Const.INVOKEVIRTUAL && "hashCode".equals(getNameConstantOperand()) && "()I".equals(getSigConstantOperand());
         lastPC = getPC();
-        fallthroughDistance++;
+    }
+
+    /**
+     * A GOTO might correspond to a <code>break</code> or to a do/while/for loop.
+     * For loops the branch target will be before the offset of the next case, for breaks we're exiting the switch so the target is actually even after the end of the last case.
+     *
+     * @return <code>true</code> if the branch target is after the next switch offset as it is the case for a switch break.
+     */
+    public boolean isBranchTargetAfterNextCaseOffset() {
+        return getBranchTarget() > switchHdlr.getNextSwitchOffset(this);
     }
 
     boolean justSawHashcode;
diff --git a/spotbugsTestCases/src/java/ghIssues/Issue3530.java b/spotbugsTestCases/src/java/ghIssues/Issue3530.java
new file mode 100644
index 000000000..538e900a9
--- /dev/null
+++ b/spotbugsTestCases/src/java/ghIssues/Issue3530.java
@@ -0,0 +1,41 @@
+package ghIssues;
+
+public class Issue3530 {
+
+	// Issue 3530
+    public String switchForLoop(int value) {
+        String valueType = null;
+        switch (value % 2) {
+            case 0:
+                valueType = "even";        // this falls through and is over-written by valueType = "odd";
+                for (int i = 0; i < 5; i++) {
+                    System.out.println("Nice even value: " + i);
+                }
+            case 1:
+                valueType = "odd";
+                break;
+            default:
+                valueType = "invalid number";
+        }
+        return valueType;
+    }
+    
+    // Issue 3449
+    public int switchWhileLoop(int input) {
+        int i = 0;
+        int result = 0;
+        switch (input) {
+            case 1:
+                result = 10;
+                while (i < input) {
+                    System.out.println(i);
+                    i++;
+                }
+            case 2:
+                throw new IllegalArgumentException("Invalid input");
+            default:
+                result = input * 2;
+        }
+        return result;
+    }
+}
\ No newline at end of file
