diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
index 3515a5cfa..3294a1757 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
@@ -15,7 +15,6 @@ import static java.util.function.Predicate.isEqual;
 import static java.util.stream.Collectors.toCollection;
 import static java.util.stream.Collectors.toSet;
 import static org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor.getEnclosingTestClasses;
-import static org.junit.jupiter.engine.discovery.predicates.TestClassPredicates.NestedClassInvalidityReason.NOT_INNER;
 import static org.junit.platform.commons.support.HierarchyTraversalMode.TOP_DOWN;
 import static org.junit.platform.commons.support.ReflectionSupport.findMethods;
 import static org.junit.platform.commons.util.FunctionUtils.where;
@@ -87,22 +86,13 @@ class ClassSelectorResolver implements SelectorResolver {
 
 		if (this.predicates.isAnnotatedWithNested.test(testClass)) {
 			// Class name filter is not applied to nested test classes
-			var invalidityReason = this.predicates.validateNestedTestClass(testClass);
-			if (invalidityReason == null) {
+			if (this.predicates.isValidNestedTestClass(testClass)) {
 				return toResolution(
 					context.addToParent(() -> DiscoverySelectors.selectClass(testClass.getEnclosingClass()),
 						parent -> Optional.of(newMemberClassTestDescriptor(parent, testClass))));
 			}
-			if (invalidityReason == NOT_INNER) {
-				return resolveStandaloneTestClass(context, testClass);
-			}
-			return unresolved();
 		}
-		return resolveStandaloneTestClass(context, testClass);
-	}
-
-	private Resolution resolveStandaloneTestClass(Context context, Class<?> testClass) {
-		if (isAcceptedStandaloneTestClass(testClass)) {
+		else if (isAcceptedStandaloneTestClass(testClass)) {
 			return toResolution(
 				context.addToParent(parent -> Optional.of(newStandaloneClassTestDescriptor(parent, testClass))));
 		}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java
index f44347380..4867348f0 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java
@@ -27,7 +27,6 @@ import java.util.Set;
 import java.util.function.Predicate;
 
 import org.apiguardian.api.API;
-import org.jspecify.annotations.Nullable;
 import org.junit.jupiter.api.ClassTemplate;
 import org.junit.jupiter.api.Nested;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -56,16 +55,15 @@ public class TestClassPredicates {
 		candidate) || looksLikeIntendedTestClass(candidate);
 	public final Predicate<Method> isTestOrTestFactoryOrTestTemplateMethod;
 
-	private final Condition<Class<?>> isNotPrivateUnlessAbstractNestedClass;
-	private final Condition<Class<?>> isInnerNestedClass;
+	private final Condition<Class<?>> isValidNestedTestClass;
 	private final Condition<Class<?>> isValidStandaloneTestClass;
 
 	public TestClassPredicates(DiscoveryIssueReporter issueReporter) {
 		this.isTestOrTestFactoryOrTestTemplateMethod = new IsTestMethod(issueReporter) //
 				.or(new IsTestFactoryMethod(issueReporter)) //
 				.or(new IsTestTemplateMethod(issueReporter));
-		this.isNotPrivateUnlessAbstractNestedClass = isNotPrivateUnlessAbstract("@Nested", issueReporter);
-		this.isInnerNestedClass = isInner(issueReporter);
+		this.isValidNestedTestClass = isNotPrivateUnlessAbstract("@Nested", issueReporter) //
+				.and(isInner(issueReporter));
 		this.isValidStandaloneTestClass = isNotPrivateUnlessAbstract("Test", issueReporter) //
 				.and(isNotLocal(issueReporter)) //
 				.and(isNotInnerUnlessAbstract(issueReporter)) //
@@ -86,16 +84,8 @@ public class TestClassPredicates {
 	}
 
 	public boolean isValidNestedTestClass(Class<?> candidate) {
-		return validateNestedTestClass(candidate) == null;
-	}
-
-	public @Nullable NestedClassInvalidityReason validateNestedTestClass(Class<?> candidate) {
-		boolean isInner = this.isInnerNestedClass.check(candidate);
-		boolean isNotPrivateUnlessAbstract = this.isNotPrivateUnlessAbstractNestedClass.check(candidate);
-		if (isNotPrivateUnlessAbstract && isNotAbstract(candidate)) {
-			return isInner ? null : NestedClassInvalidityReason.NOT_INNER;
-		}
-		return NestedClassInvalidityReason.OTHER;
+		return this.isValidNestedTestClass.check(candidate) //
+				&& isNotAbstract(candidate);
 	}
 
 	public boolean isValidStandaloneTestClass(Class<?> candidate) {
@@ -134,13 +124,9 @@ public class TestClassPredicates {
 	private static Condition<Class<?>> isInner(DiscoveryIssueReporter issueReporter) {
 		return issueReporter.createReportingCondition(ReflectionUtils::isInnerClass, testClass -> {
 			if (testClass.getEnclosingClass() == null) {
-				return createIssue("Top-level", testClass, "must not be annotated with @Nested",
-					"It will be executed anyway for backward compatibility. "
-							+ "You should remove the @Nested annotation to resolve this warning.");
+				return createIssue("@Nested", testClass, "must not be a top-level class");
 			}
-			return createIssue("@Nested", testClass, "must not be static",
-				"It will only be executed if discovered as a standalone test class. "
-						+ "You should remove the annotation or make it non-static to resolve this warning.");
+			return createIssue("@Nested", testClass, "must not be static");
 		});
 	}
 
@@ -155,11 +141,8 @@ public class TestClassPredicates {
 	}
 
 	private static DiscoveryIssue createIssue(String prefix, Class<?> testClass, String detailMessage) {
-		return createIssue(prefix, testClass, detailMessage, "It will not be executed.");
-	}
-
-	private static DiscoveryIssue createIssue(String prefix, Class<?> testClass, String detailMessage, String effect) {
-		String message = "%s class '%s' %s. %s".formatted(prefix, testClass.getName(), detailMessage, effect);
+		String message = "%s class '%s' %s. It will not be executed.".formatted(prefix, testClass.getName(),
+			detailMessage);
 		return DiscoveryIssue.builder(DiscoveryIssue.Severity.WARNING, message) //
 				.source(ClassSource.from(testClass)) //
 				.build();
@@ -168,9 +151,4 @@ public class TestClassPredicates {
 	private static boolean isAnnotatedButNotComposed(Class<?> candidate, Class<? extends Annotation> annotationType) {
 		return !candidate.isAnnotation() && isAnnotated(candidate, annotationType);
 	}
-
-	@API(status = INTERNAL, since = "5.13.3")
-	public enum NestedClassInvalidityReason {
-		NOT_INNER, OTHER
-	}
 }
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java
index 70a844cd2..68bd39c89 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java
@@ -274,40 +274,6 @@ class NestedTestClassesTests extends AbstractJupiterTestEngineTests {
 				.haveExactly(1, finishedWithFailure(message(it -> it.contains(expectedMessage))));
 	}
 
-	@Test
-	void discoversButWarnsAboutTopLevelNestedTestClasses() {
-		var results = discoverTestsForClass(TopLevelNestedTestCase.class);
-
-		var engineDescriptor = results.getEngineDescriptor();
-		assertEquals(2, engineDescriptor.getDescendants().size(), "# resolved test descriptors");
-
-		var discoveryIssues = results.getDiscoveryIssues();
-		assertThat(discoveryIssues).hasSize(1);
-		assertThat(discoveryIssues.getFirst().message()) //
-				.isEqualTo(
-					"Top-level class '%s' must not be annotated with @Nested. "
-							+ "It will be executed anyway for backward compatibility. "
-							+ "You should remove the @Nested annotation to resolve this warning.",
-					TopLevelNestedTestCase.class.getName());
-	}
-
-	@Test
-	void discoversButWarnsAboutStaticNestedTestClasses() {
-		var results = discoverTestsForClass(StaticNestedTestCase.TestCase.class);
-
-		var engineDescriptor = results.getEngineDescriptor();
-		assertEquals(2, engineDescriptor.getDescendants().size(), "# resolved test descriptors");
-
-		var discoveryIssues = results.getDiscoveryIssues();
-		assertThat(discoveryIssues).hasSize(1);
-		assertThat(discoveryIssues.getFirst().message()) //
-				.isEqualTo(
-					"@Nested class '%s' must not be static. "
-							+ "It will only be executed if discovered as a standalone test class. "
-							+ "You should remove the annotation or make it non-static to resolve this warning.",
-					StaticNestedTestCase.TestCase.class.getName());
-	}
-
 	// -------------------------------------------------------------------
 
 	@SuppressWarnings("JUnitMalformedDeclaration")
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/StaticNestedTestCase.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/StaticNestedTestCase.java
deleted file mode 100644
index a68851a90..000000000
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/StaticNestedTestCase.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright 2015-2025 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine;
-
-import org.junit.jupiter.api.Nested;
-import org.junit.jupiter.api.Test;
-
-class StaticNestedTestCase {
-
-	@SuppressWarnings("JUnitMalformedDeclaration")
-	@Nested
-	static class TestCase {
-		@Test
-		void test() {
-		}
-	}
-
-}
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/TopLevelNestedTestCase.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/TopLevelNestedTestCase.java
deleted file mode 100644
index da2b30026..000000000
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/TopLevelNestedTestCase.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright 2015-2025 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.engine;
-
-import org.junit.jupiter.api.Nested;
-import org.junit.jupiter.api.Test;
-
-@Nested
-public class TopLevelNestedTestCase {
-
-	@Test
-	void test() {
-	}
-}
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java
index 02fa1eb5b..045e4be72 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java
@@ -305,8 +305,8 @@ class DiscoveryTests extends AbstractJupiterTestEngineTests {
 				.isEqualTo("@Nested class '%s' must not be private. It will not be executed.",
 					InvalidTestCases.InvalidTestClassTestCase.Inner.class.getName());
 		assertThat(discoveryIssues.getLast().message()) //
-				.startsWith("@Nested class '%s' must not be static.".formatted(
-					InvalidTestCases.InvalidTestClassTestCase.Inner.class.getName()));
+				.isEqualTo("@Nested class '%s' must not be static. It will not be executed.",
+					InvalidTestCases.InvalidTestClassTestCase.Inner.class.getName());
 	}
 
 	static List<Named<LauncherDiscoveryRequest>> requestsForTestClassWithInvalidNestedTestClass() {
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java
index 34d5f9ae5..bacd663d3 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java
@@ -254,9 +254,7 @@ public class TestClassPredicatesTests {
 			assertThat(predicates.isAnnotatedWithNestedAndValid).rejects(candidate);
 
 			var issue = DiscoveryIssue.builder(Severity.WARNING,
-				"@Nested class '%s' must not be static. ".formatted(candidate.getName())
-						+ "It will only be executed if discovered as a standalone test class. "
-						+ "You should remove the annotation or make it non-static to resolve this warning.") //
+				"@Nested class '%s' must not be static. It will not be executed.".formatted(candidate.getName())) //
 					.source(ClassSource.from(candidate)) //
 					.build();
 			assertThat(discoveryIssues.stream().distinct()).containsExactly(issue);
@@ -270,9 +268,8 @@ public class TestClassPredicatesTests {
 			assertThat(predicates.isAnnotatedWithNestedAndValid).rejects(candidate);
 
 			var issue = DiscoveryIssue.builder(Severity.WARNING,
-				("Top-level class '%s' must not be annotated with @Nested. ".formatted(candidate.getName())
-						+ "It will be executed anyway for backward compatibility. "
-						+ "You should remove the @Nested annotation to resolve this warning.")) //
+				"@Nested class '%s' must not be a top-level class. It will not be executed.".formatted(
+					candidate.getName())) //
 					.source(ClassSource.from(candidate)) //
 					.build();
 			assertThat(discoveryIssues.stream().distinct()).containsExactly(issue);
@@ -315,9 +312,7 @@ public class TestClassPredicatesTests {
 			assertThat(predicates.isAnnotatedWithNestedAndValid).rejects(candidate);
 
 			var issue = DiscoveryIssue.builder(Severity.WARNING,
-				"@Nested class '%s' must not be static. ".formatted(candidate.getName())
-						+ "It will only be executed if discovered as a standalone test class. "
-						+ "You should remove the annotation or make it non-static to resolve this warning.") //
+				"@Nested class '%s' must not be static. It will not be executed.".formatted(candidate.getName())) //
 					.source(ClassSource.from(candidate)) //
 					.build();
 			assertThat(discoveryIssues.stream().distinct()).containsExactly(issue);
