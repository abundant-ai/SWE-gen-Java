diff --git a/README.md b/README.md
index 13c52bab2..3075968da 100644
--- a/README.md
+++ b/README.md
@@ -119,6 +119,19 @@ The latest release is available on [Maven Central](https://search.maven.org/arti
 testImplementation("com.squareup.okhttp3:mockwebserver:4.9.0")
 ```
 
+GraalVM Native Image
+--------------------
+
+Building your own native images with Graal https://www.graalvm.org/ should work automatically.
+Please report any bugs or workarounds you find.
+
+See okcurl module for an example build.
+
+```
+$ ./gradlew okcurl:nativeImage
+$ ./okcurl/build/graal/okcurl https://httpbin.org/get
+```
+
 License
 -------
 
diff --git a/build.gradle b/build.gradle
index bceb74832..174010669 100644
--- a/build.gradle
+++ b/build.gradle
@@ -2,7 +2,7 @@ import net.ltgt.gradle.errorprone.CheckSeverity
 
 buildscript {
   ext.versions = [
-      'animalSniffer': '1.18',
+      'animalSniffer': '1.19',
       'assertj': '3.15.0',
       'bouncycastle': '1.65',
       'brotli': '0.1.2',
@@ -19,7 +19,7 @@ buildscript {
       'moshi': '1.9.2',
       'okio': '2.8.0',
       'ktlint': '0.38.0',
-      'picocli': '4.2.0',
+      'picocli': '4.5.1',
       'openjsse': '1.1.0'
   ]
 
@@ -60,7 +60,7 @@ buildscript {
 }
 
 plugins {
-  id "ru.vyarus.animalsniffer" version "1.5.0"
+  id "ru.vyarus.animalsniffer" version "1.5.1"
   id "com.github.johnrengelman.shadow" version "5.2.0"
   id "me.champeau.gradle.japicmp" version "0.2.9"
   id "com.diffplug.spotless" version "5.1.2"
@@ -144,8 +144,6 @@ subprojects { project ->
 
   // Animal Sniffer confirms we generally don't use APIs not on Java 8.
   animalsniffer {
-    // https://github.com/mojohaus/animal-sniffer/issues/70
-    excludeJars "android-all-*"
     annotation "okhttp3.internal.SuppressSignatureCheck"
     sourceSets = [sourceSets.main]
   }
diff --git a/docs/security_providers.md b/docs/security_providers.md
index f2d3d4e7d..5ee4669cc 100644
--- a/docs/security_providers.md
+++ b/docs/security_providers.md
@@ -8,6 +8,7 @@ Security Providers
 | :--------------- | :------ | :----------- | :-------------- | :----------------------------------------------------------- |
 | JVM default      | Java 9+ | Java 11+     | [OpenJDK]       |                                                              |
 | Android default  | ✅      | Android 10+  | [BoringSSL]     |                                                              |
+| [GraalVM]        | ✅      |              | [OpenJDK]       | Only actively tested with JDK 11, not with 8 target          |
 | [Bouncy Castle]  | ✅      |              | [Bouncy Castle] | [Tracking bug.][bug5698]                                     |
 | [Conscrypt]      | ✅      | ✅           | [BoringSSL]     | Activated if Conscrypt is first registered provider.         |
 | [OpenJSSE]       |         | ✅           | [OpenJDK]       | OpenJDK backport.                                            |
@@ -20,6 +21,7 @@ All providers support HTTP/1.1 and TLSv1.2.
 [Bouncy Castle]: https://www.bouncycastle.org/java.html
 [Conscrypt]: https://www.conscrypt.org/
 [Corretto]: https://github.com/corretto/amazon-corretto-crypto-provider
+[GraalVM]: https://www.graalvm.org/
 [OpenJDK]: https://openjdk.java.net/groups/security/
 [OpenJSSE]: https://github.com/openjsse/openjsse
 [OpenSSL]: https://www.openssl.org/
diff --git a/mkdocs.yml b/mkdocs.yml
index 2da82aea1..c65529aee 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -5,6 +5,7 @@ repo_url: https://github.com/square/okhttp
 site_description: "An HTTP & HTTP/2 client for Android and Java applications"
 site_author: Square, Inc.
 remote_branch: gh-pages
+edit_uri: ""
 
 copyright: 'Copyright &copy; 2019 Square, Inc.'
 
diff --git a/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/MockResponse.kt b/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/MockResponse.kt
index e61479bcb..1c2b4f58a 100644
--- a/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/MockResponse.kt
+++ b/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/MockResponse.kt
@@ -60,8 +60,7 @@ class MockResponse : Cloneable {
   /**
    * Sets the [HTTP/2 error code](https://tools.ietf.org/html/rfc7540#section-7) to be
    * returned when resetting the stream.
-   * This is only valid with [SocketPolicy.RESET_STREAM_AT_START] and
-   * [SocketPolicy.DO_NOT_READ_REQUEST_BODY].
+   * This is only valid with [SocketPolicy.RESET_STREAM_AT_START].
    */
   @set:JvmName("http2ErrorCode")
   var http2ErrorCode = -1
diff --git a/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/MockWebServer.kt b/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/MockWebServer.kt
index 65622104c..f72a849ef 100644
--- a/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/MockWebServer.kt
+++ b/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/MockWebServer.kt
@@ -72,7 +72,6 @@ import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END
 import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START
 import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_REQUEST_BODY
 import okhttp3.mockwebserver.SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY
-import okhttp3.mockwebserver.SocketPolicy.DO_NOT_READ_REQUEST_BODY
 import okhttp3.mockwebserver.SocketPolicy.EXPECT_CONTINUE
 import okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE
 import okhttp3.mockwebserver.SocketPolicy.NO_RESPONSE
@@ -628,7 +627,7 @@ class MockWebServer : ExternalResource(), Closeable {
 
       // See warnings associated with these socket policies in SocketPolicy.
       when (response.socketPolicy) {
-        DISCONNECT_AT_END, DO_NOT_READ_REQUEST_BODY -> {
+        DISCONNECT_AT_END -> {
           socket.close()
           return false
         }
@@ -720,9 +719,7 @@ class MockWebServer : ExternalResource(), Closeable {
 
       var hasBody = false
       val policy = dispatcher.peek()
-      if (policy.socketPolicy == DO_NOT_READ_REQUEST_BODY) {
-        // Ignore the body completely.
-      } else if (contentLength != -1L) {
+      if (contentLength != -1L) {
         hasBody = contentLength > 0L
         throttledTransfer(policy, socket, source, requestBody.buffer(), contentLength, true)
       } else if (chunked) {
@@ -969,8 +966,7 @@ class MockWebServer : ExternalResource(), Closeable {
 
       val response: MockResponse = dispatcher.dispatch(request)
 
-      val socketPolicy = response.socketPolicy
-      if (socketPolicy === DISCONNECT_AFTER_REQUEST) {
+      if (response.socketPolicy === DISCONNECT_AFTER_REQUEST) {
         socket.close()
         return
       }
@@ -981,15 +977,9 @@ class MockWebServer : ExternalResource(), Closeable {
                 "and responded: $response protocol is $protocol")
       }
 
-      when (socketPolicy) {
-        DISCONNECT_AT_END -> {
-          stream.connection.shutdown(ErrorCode.NO_ERROR)
-        }
-        DO_NOT_READ_REQUEST_BODY -> {
-          stream.close(ErrorCode.fromHttp2(response.http2ErrorCode)!!, null)
-        }
-        else -> {
-        }
+      if (response.socketPolicy === DISCONNECT_AT_END) {
+        val connection = stream.connection
+        connection.shutdown(ErrorCode.NO_ERROR)
       }
     }
 
@@ -1029,7 +1019,7 @@ class MockWebServer : ExternalResource(), Closeable {
       val body = Buffer()
       val requestLine = "$method $path HTTP/1.1"
       var exception: IOException? = null
-      if (readBody && !peek.isDuplex && peek.socketPolicy !== DO_NOT_READ_REQUEST_BODY) {
+      if (readBody && !peek.isDuplex) {
         try {
           val contentLengthString = headers["content-length"]
           val byteCount = contentLengthString?.toLong() ?: Long.MAX_VALUE
diff --git a/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/SocketPolicy.kt b/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/SocketPolicy.kt
index 1a60b6e4d..60f26e5fd 100644
--- a/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/SocketPolicy.kt
+++ b/mockwebserver/src/main/kotlin/okhttp3/mockwebserver/SocketPolicy.kt
@@ -75,13 +75,6 @@ enum class SocketPolicy {
   /** Close connection after writing half of the response body (if present). */
   DISCONNECT_DURING_RESPONSE_BODY,
 
-  /**
-   * Process the response without even attempting to reading the request body. For HTTP/2 this will
-   * send [MockResponse.getHttp2ErrorCode] after the response body or trailers. For HTTP/1 this will
-   * close the socket after the response body or trailers.
-   */
-  DO_NOT_READ_REQUEST_BODY,
-
   /** Don't trust the client during the SSL handshake. */
   FAIL_HANDSHAKE,
 
diff --git a/okcurl/build.gradle b/okcurl/build.gradle
index 92f8f2bea..bdea9530b 100644
--- a/okcurl/build.gradle
+++ b/okcurl/build.gradle
@@ -1,3 +1,9 @@
+plugins {
+  id "com.palantir.graal" version "0.7.1"
+}
+
+import org.apache.tools.ant.taskdefs.condition.Os
+
 apply plugin: 'com.github.johnrengelman.shadow'
 
 jar {
@@ -27,6 +33,9 @@ dependencies {
   implementation deps.picocli
   implementation deps.guava
 
+  implementation 'info.picocli:picocli-codegen:4.5.1'
+  annotationProcessor 'info.picocli:picocli-codegen:4.5.1'
+
   testImplementation project(':okhttp-testing-support')
   testImplementation deps.junit
   testImplementation deps.assertj
@@ -35,3 +44,21 @@ dependencies {
 shadowJar {
   mergeServiceFiles()
 }
+
+graal {
+  mainClass "okhttp3.curl.Main"
+  outputName "okcurl"
+  graalVersion "20.2.0"
+  javaVersion "11"
+
+  option "--enable-https"
+  option "--no-fallback"
+  option "--allow-incomplete-classpath"
+
+  if (Os.isFamily(Os.FAMILY_WINDOWS)) {
+    // May be possible without, but autodetection is problematic on Windows 10
+    // see https://github.com/palantir/gradle-graal
+    // see https://www.graalvm.org/docs/reference-manual/native-image/#prerequisites
+    windowsVsVarsPath("C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\VC\\Auxiliary\\Build\\vcvars64.bat")
+  }
+}
diff --git a/okcurl/src/main/kotlin/okhttp3/curl/Main.kt b/okcurl/src/main/kotlin/okhttp3/curl/Main.kt
index 1c6d9d9df..7b10d429d 100644
--- a/okcurl/src/main/kotlin/okhttp3/curl/Main.kt
+++ b/okcurl/src/main/kotlin/okhttp3/curl/Main.kt
@@ -48,6 +48,7 @@ import picocli.CommandLine.Command
 import picocli.CommandLine.IVersionProvider
 import picocli.CommandLine.Option
 import picocli.CommandLine.Parameters
+import java.lang.IllegalArgumentException
 
 @Command(name = NAME, description = ["A curl for the next-generation web."],
     mixinStandardHelpOptions = true, versionProvider = Main.VersionProvider::class)
@@ -179,7 +180,9 @@ class Main : Runnable {
 
     val requestMethod = method ?: if (data != null) "POST" else "GET"
 
-    request.url(url!!)
+    val url = url ?: throw IllegalArgumentException("No url provided")
+
+    request.url(url)
 
     data?.let {
       request.method(requestMethod, it.toRequestBody(mediaType()))
diff --git a/okcurl/src/main/resources/META-INF/native-image/okhttp3/okcurl/reflect-config.json b/okcurl/src/main/resources/META-INF/native-image/okhttp3/okcurl/reflect-config.json
new file mode 100644
index 000000000..4907f8d44
--- /dev/null
+++ b/okcurl/src/main/resources/META-INF/native-image/okhttp3/okcurl/reflect-config.json
@@ -0,0 +1,45 @@
+[
+  {
+    "name" : "okhttp3.curl.Main",
+    "allDeclaredConstructors" : true,
+    "allPublicConstructors" : true,
+    "allDeclaredMethods" : true,
+    "allPublicMethods" : true,
+    "fields" : [
+      { "name" : "allowInsecure" },
+      { "name" : "callTimeout" },
+      { "name" : "completionScript" },
+      { "name" : "connectTimeout" },
+      { "name" : "data" },
+      { "name" : "followRedirects" },
+      { "name" : "headers" },
+      { "name" : "method" },
+      { "name" : "readTimeout" },
+      { "name" : "referer" },
+      { "name" : "showHeaders" },
+      { "name" : "showHttp2Frames" },
+      { "name" : "sslDebug" },
+      { "name" : "url" },
+      { "name" : "userAgent" },
+      { "name" : "verbose" }
+    ]
+  },
+  {
+    "name" : "okhttp3.curl.Main$VersionProvider",
+    "allDeclaredConstructors" : true,
+    "allPublicConstructors" : true,
+    "allDeclaredMethods" : true,
+    "allPublicMethods" : true
+  },
+  {
+    "name" : "picocli.CommandLine$AutoHelpMixin",
+    "allDeclaredConstructors" : true,
+    "allPublicConstructors" : true,
+    "allDeclaredMethods" : true,
+    "allPublicMethods" : true,
+    "fields" : [
+      { "name" : "helpRequested" },
+      { "name" : "versionRequested" }
+    ]
+  }
+]
diff --git a/okcurl/src/main/resources/META-INF/native-image/okhttp3/okcurl/resource-config.json b/okcurl/src/main/resources/META-INF/native-image/okhttp3/okcurl/resource-config.json
new file mode 100644
index 000000000..ab5d3a743
--- /dev/null
+++ b/okcurl/src/main/resources/META-INF/native-image/okhttp3/okcurl/resource-config.json
@@ -0,0 +1,5 @@
+{
+  "resources": [
+    {"pattern": "okcurl-version.properties"}
+  ]
+}
diff --git a/okcurl/src/test/java/okhttp3/curl/GenerateReflectionConfig.kt b/okcurl/src/test/java/okhttp3/curl/GenerateReflectionConfig.kt
new file mode 100644
index 000000000..c383d2922
--- /dev/null
+++ b/okcurl/src/test/java/okhttp3/curl/GenerateReflectionConfig.kt
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2020 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.curl
+
+import picocli.CommandLine.Model.CommandSpec.forAnnotatedObject
+import picocli.codegen.aot.graalvm.ReflectionConfigGenerator
+import java.io.File
+
+/**
+ * Manual process to update reflect-config.json
+ */
+fun main() {
+  val configFile = File("okcurl/src/main/resources/META-INF/native-image/okhttp3/okcurl/reflect-config.json")
+  configFile.writeText(ReflectionConfigGenerator.generateReflectionConfig(forAnnotatedObject(Main())))
+}
\ No newline at end of file
diff --git a/okcurl/src/test/java/okhttp3/curl/RunMain.kt b/okcurl/src/test/java/okhttp3/curl/RunMain.kt
new file mode 100644
index 000000000..26a5b1468
--- /dev/null
+++ b/okcurl/src/test/java/okhttp3/curl/RunMain.kt
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2020 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.curl
+
+fun main() {
+  Main.main(arrayOf("https://www.google.com/robots.txt"))
+}
\ No newline at end of file
diff --git a/okhttp-sse/src/main/kotlin/okhttp3/sse/EventSources.kt b/okhttp-sse/src/main/kotlin/okhttp3/sse/EventSources.kt
index fcb6a5550..cb6a3c1e7 100644
--- a/okhttp-sse/src/main/kotlin/okhttp3/sse/EventSources.kt
+++ b/okhttp-sse/src/main/kotlin/okhttp3/sse/EventSources.kt
@@ -17,7 +17,7 @@ package okhttp3.sse
 
 import okhttp3.OkHttpClient
 import okhttp3.Response
-import okhttp3.internal.sse.RealEventSource
+import okhttp3.sse.internal.RealEventSource
 
 object EventSources {
   @JvmStatic
diff --git a/okhttp-sse/src/main/kotlin/okhttp3/internal/sse/RealEventSource.kt b/okhttp-sse/src/main/kotlin/okhttp3/sse/internal/RealEventSource.kt
similarity index 99%
rename from okhttp-sse/src/main/kotlin/okhttp3/internal/sse/RealEventSource.kt
rename to okhttp-sse/src/main/kotlin/okhttp3/sse/internal/RealEventSource.kt
index 2e95a2881..ea67ec497 100644
--- a/okhttp-sse/src/main/kotlin/okhttp3/internal/sse/RealEventSource.kt
+++ b/okhttp-sse/src/main/kotlin/okhttp3/sse/internal/RealEventSource.kt
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.sse
+package okhttp3.sse.internal
 
 import java.io.IOException
 import okhttp3.Call
diff --git a/okhttp-sse/src/main/kotlin/okhttp3/internal/sse/ServerSentEventReader.kt b/okhttp-sse/src/main/kotlin/okhttp3/sse/internal/ServerSentEventReader.kt
similarity index 99%
rename from okhttp-sse/src/main/kotlin/okhttp3/internal/sse/ServerSentEventReader.kt
rename to okhttp-sse/src/main/kotlin/okhttp3/sse/internal/ServerSentEventReader.kt
index 9f6f343bf..3e10d0866 100644
--- a/okhttp-sse/src/main/kotlin/okhttp3/internal/sse/ServerSentEventReader.kt
+++ b/okhttp-sse/src/main/kotlin/okhttp3/sse/internal/ServerSentEventReader.kt
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.sse
+package okhttp3.sse.internal
 
 import java.io.IOException
 import okhttp3.internal.toLongOrDefault
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java b/okhttp-sse/src/test/java/okhttp3/sse/internal/Event.java
similarity index 98%
rename from okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
rename to okhttp-sse/src/test/java/okhttp3/sse/internal/Event.java
index fade2b978..ac202dc95 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
+++ b/okhttp-sse/src/test/java/okhttp3/sse/internal/Event.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.sse;
+package okhttp3.sse.internal;
 
 import java.util.Objects;
 import javax.annotation.Nullable;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/sse/internal/EventSourceHttpTest.java
similarity index 99%
rename from okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
rename to okhttp-sse/src/test/java/okhttp3/sse/internal/EventSourceHttpTest.java
index a9583fc42..ab61cf6fb 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
+++ b/okhttp-sse/src/test/java/okhttp3/sse/internal/EventSourceHttpTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.sse;
+package okhttp3.sse.internal;
 
 import java.util.concurrent.TimeUnit;
 import javax.annotation.Nullable;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/sse/internal/EventSourceRecorder.java
similarity index 99%
rename from okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
rename to okhttp-sse/src/test/java/okhttp3/sse/internal/EventSourceRecorder.java
index c96672d27..ae9639199 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
+++ b/okhttp-sse/src/test/java/okhttp3/sse/internal/EventSourceRecorder.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.sse;
+package okhttp3.sse.internal;
 
 import java.io.IOException;
 import java.util.concurrent.BlockingQueue;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java b/okhttp-sse/src/test/java/okhttp3/sse/internal/ServerSentEventIteratorTest.java
similarity index 99%
rename from okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
rename to okhttp-sse/src/test/java/okhttp3/sse/internal/ServerSentEventIteratorTest.java
index e837e0e42..6406de242 100644
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
+++ b/okhttp-sse/src/test/java/okhttp3/sse/internal/ServerSentEventIteratorTest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package okhttp3.internal.sse;
+package okhttp3.sse.internal;
 
 import java.io.IOException;
 import java.util.ArrayDeque;
diff --git a/okhttp-testing-support/src/main/kotlin/okhttp3/internal/io/InMemoryFileSystem.kt b/okhttp-testing-support/src/main/kotlin/okhttp3/internal/io/InMemoryFileSystem.kt
index f6832d2a6..ac120bc47 100644
--- a/okhttp-testing-support/src/main/kotlin/okhttp3/internal/io/InMemoryFileSystem.kt
+++ b/okhttp-testing-support/src/main/kotlin/okhttp3/internal/io/InMemoryFileSystem.kt
@@ -31,7 +31,7 @@ import org.junit.runners.model.Statement
 
 /** A simple file system where all files are held in memory. Not safe for concurrent use.  */
 class InMemoryFileSystem : FileSystem, TestRule {
-  private val files = mutableMapOf<File, Buffer>()
+  val files = mutableMapOf<File, Buffer>()
   private val openSources = IdentityHashMap<Source, File>()
   private val openSinks = IdentityHashMap<Sink, File>()
 
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
index df42f4281..b4416288b 100644
--- a/okhttp/build.gradle
+++ b/okhttp/build.gradle
@@ -32,6 +32,16 @@ dependencies {
   compileOnly deps.jsr305
   compileOnly deps.animalSniffer
 
+  // graal build support
+  compileOnly("org.graalvm.nativeimage:svm:20.2.0") {
+    // Avoid kapt tripping up on a non jar dependency.
+    // Only annotations are needed here.
+    // https://youtrack.jetbrains.com/issue/KT-29513
+    exclude group: 'org.graalvm.nativeimage'
+    exclude group: 'org.graalvm.truffle'
+    exclude group: 'org.graalvm.compiler'
+  }
+
   testImplementation project(':okhttp-testing-support')
   testImplementation project(':okhttp-tls')
   testImplementation project(':okhttp-urlconnection')
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/Exchange.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/Exchange.kt
index 8d3696270..ca93f27c4 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/Exchange.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/Exchange.kt
@@ -43,14 +43,10 @@ class Exchange(
   internal val finder: ExchangeFinder,
   private val codec: ExchangeCodec
 ) {
-  /** True if the request body need not complete before the response body starts. */
+  /** Returns true if the request body need not complete before the response body starts. */
   internal var isDuplex: Boolean = false
     private set
 
-  /** True if there was an exception on the connection to the peer. */
-  internal var hasFailure: Boolean = false
-    private set
-
   internal val connection: RealConnection = codec.connection
 
   internal val isCoalescedConnection: Boolean
@@ -167,7 +163,6 @@ class Exchange(
   }
 
   private fun trackFailure(e: IOException) {
-    hasFailure = true
     finder.trackFailure(e)
     codec.connection.trackFailure(call, e)
   }
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/graal/svm.kt b/okhttp/src/main/kotlin/okhttp3/internal/graal/svm.kt
new file mode 100644
index 000000000..b609f7daf
--- /dev/null
+++ b/okhttp/src/main/kotlin/okhttp3/internal/graal/svm.kt
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2020 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.graal
+
+import com.oracle.svm.core.annotate.Delete
+import com.oracle.svm.core.annotate.Substitute
+import com.oracle.svm.core.annotate.TargetClass
+import okhttp3.internal.platform.Android10Platform
+import okhttp3.internal.platform.AndroidPlatform
+import okhttp3.internal.platform.BouncyCastlePlatform
+import okhttp3.internal.platform.ConscryptPlatform
+import okhttp3.internal.platform.Jdk8WithJettyBootPlatform
+import okhttp3.internal.platform.Jdk9Platform
+import okhttp3.internal.platform.OpenJSSEPlatform
+import okhttp3.internal.platform.Platform
+
+@TargetClass(AndroidPlatform::class)
+@Delete
+class TargetAndroidPlatform {
+}
+
+@TargetClass(Android10Platform::class)
+@Delete
+class TargetAndroid10Platform {
+}
+
+@TargetClass(BouncyCastlePlatform::class)
+@Delete
+class TargetBouncyCastlePlatform {
+}
+
+@TargetClass(ConscryptPlatform::class)
+@Delete
+class TargetConscryptPlatform {
+}
+
+@TargetClass(Jdk8WithJettyBootPlatform::class)
+@Delete
+class TargetJdk8WithJettyBootPlatform {
+}
+
+@TargetClass(OpenJSSEPlatform::class)
+@Delete
+class TargetOpenJSSEPlatform {
+}
+
+@TargetClass(Platform.Companion::class)
+class TargetPlatform {
+  @Substitute
+  fun findPlatform(): Platform {
+    return Jdk9Platform.buildIfSupported()!!
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/http/CallServerInterceptor.kt b/okhttp/src/main/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
index 6801154b3..7fdf9feee 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
@@ -20,7 +20,6 @@ import java.net.ProtocolException
 import okhttp3.Interceptor
 import okhttp3.Response
 import okhttp3.internal.EMPTY_RESPONSE
-import okhttp3.internal.http2.ConnectionShutdownException
 import okio.buffer
 
 /** This is the last interceptor in the chain. It makes a network call to the server. */
@@ -34,118 +33,98 @@ class CallServerInterceptor(private val forWebSocket: Boolean) : Interceptor {
     val requestBody = request.body
     val sentRequestMillis = System.currentTimeMillis()
 
+    exchange.writeRequestHeaders(request)
+
     var invokeStartEvent = true
     var responseBuilder: Response.Builder? = null
-    var sendRequestException: IOException? = null
-    try {
-      exchange.writeRequestHeaders(request)
-
-      if (HttpMethod.permitsRequestBody(request.method) && requestBody != null) {
-        // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-        // Continue" response before transmitting the request body. If we don't get that, return
-        // what we did get (such as a 4xx response) without ever transmitting the request body.
-        if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) {
+    if (HttpMethod.permitsRequestBody(request.method) && requestBody != null) {
+      // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+      // Continue" response before transmitting the request body. If we don't get that, return
+      // what we did get (such as a 4xx response) without ever transmitting the request body.
+      if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) {
+        exchange.flushRequest()
+        responseBuilder = exchange.readResponseHeaders(expectContinue = true)
+        exchange.responseHeadersStart()
+        invokeStartEvent = false
+      }
+      if (responseBuilder == null) {
+        if (requestBody.isDuplex()) {
+          // Prepare a duplex body so that the application can send a request body later.
           exchange.flushRequest()
-          responseBuilder = exchange.readResponseHeaders(expectContinue = true)
-          exchange.responseHeadersStart()
-          invokeStartEvent = false
-        }
-        if (responseBuilder == null) {
-          if (requestBody.isDuplex()) {
-            // Prepare a duplex body so that the application can send a request body later.
-            exchange.flushRequest()
-            val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
-            requestBody.writeTo(bufferedRequestBody)
-          } else {
-            // Write the request body if the "Expect: 100-continue" expectation was met.
-            val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
-            requestBody.writeTo(bufferedRequestBody)
-            bufferedRequestBody.close()
-          }
+          val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
+          requestBody.writeTo(bufferedRequestBody)
         } else {
-          exchange.noRequestBody()
-          if (!exchange.connection.isMultiplexed) {
-            // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-            // from being reused. Otherwise we're still obligated to transmit the request body to
-            // leave the connection in a consistent state.
-            exchange.noNewExchangesOnConnection()
-          }
+          // Write the request body if the "Expect: 100-continue" expectation was met.
+          val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
+          requestBody.writeTo(bufferedRequestBody)
+          bufferedRequestBody.close()
         }
       } else {
         exchange.noRequestBody()
+        if (!exchange.connection.isMultiplexed) {
+          // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+          // from being reused. Otherwise we're still obligated to transmit the request body to
+          // leave the connection in a consistent state.
+          exchange.noNewExchangesOnConnection()
+        }
       }
+    } else {
+      exchange.noRequestBody()
+    }
 
-      if (requestBody == null || !requestBody.isDuplex()) {
-        exchange.finishRequest()
-      }
-    } catch (e: IOException) {
-      if (e is ConnectionShutdownException) {
-        throw e // No request was sent so there's no response to read.
-      }
-      if (!exchange.hasFailure) {
-        throw e // Don't attempt to read the response; we failed to send the request.
+    if (requestBody == null || !requestBody.isDuplex()) {
+      exchange.finishRequest()
+    }
+    if (responseBuilder == null) {
+      responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!
+      if (invokeStartEvent) {
+        exchange.responseHeadersStart()
+        invokeStartEvent = false
       }
-      sendRequestException = e
     }
-
-    try {
-      if (responseBuilder == null) {
-        responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!
-        if (invokeStartEvent) {
-          exchange.responseHeadersStart()
-          invokeStartEvent = false
-        }
+    var response = responseBuilder
+        .request(request)
+        .handshake(exchange.connection.handshake())
+        .sentRequestAtMillis(sentRequestMillis)
+        .receivedResponseAtMillis(System.currentTimeMillis())
+        .build()
+    var code = response.code
+    if (code == 100) {
+      // Server sent a 100-continue even though we did not request one. Try again to read the actual
+      // response status.
+      responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!
+      if (invokeStartEvent) {
+        exchange.responseHeadersStart()
       }
-      var response = responseBuilder
+      response = responseBuilder
           .request(request)
           .handshake(exchange.connection.handshake())
           .sentRequestAtMillis(sentRequestMillis)
           .receivedResponseAtMillis(System.currentTimeMillis())
           .build()
-      var code = response.code
-      if (code == 100) {
-        // Server sent a 100-continue even though we did not request one. Try again to read the
-        // actual response status.
-        responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!
-        if (invokeStartEvent) {
-          exchange.responseHeadersStart()
-        }
-        response = responseBuilder
-            .request(request)
-            .handshake(exchange.connection.handshake())
-            .sentRequestAtMillis(sentRequestMillis)
-            .receivedResponseAtMillis(System.currentTimeMillis())
-            .build()
-        code = response.code
-      }
+      code = response.code
+    }
 
-      exchange.responseHeadersEnd(response)
+    exchange.responseHeadersEnd(response)
 
-      response = if (forWebSocket && code == 101) {
-        // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
-        response.newBuilder()
-            .body(EMPTY_RESPONSE)
-            .build()
-      } else {
-        response.newBuilder()
-            .body(exchange.openResponseBody(response))
-            .build()
-      }
-      if ("close".equals(response.request.header("Connection"), ignoreCase = true) ||
-          "close".equals(response.header("Connection"), ignoreCase = true)) {
-        exchange.noNewExchangesOnConnection()
-      }
-      if ((code == 204 || code == 205) && response.body?.contentLength() ?: -1L > 0L) {
-        throw ProtocolException(
-            "HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}")
-      }
-      return response
-    } catch (e: IOException) {
-      if (sendRequestException != null) {
-        sendRequestException.addSuppressed(e)
-        throw sendRequestException
-      }
-      throw e
+    response = if (forWebSocket && code == 101) {
+      // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
+      response.newBuilder()
+          .body(EMPTY_RESPONSE)
+          .build()
+    } else {
+      response.newBuilder()
+          .body(exchange.openResponseBody(response))
+          .build()
+    }
+    if ("close".equals(response.request.header("Connection"), ignoreCase = true) ||
+        "close".equals(response.header("Connection"), ignoreCase = true)) {
+      exchange.noNewExchangesOnConnection()
+    }
+    if ((code == 204 || code == 205) && response.body?.contentLength() ?: -1L > 0L) {
+      throw ProtocolException(
+          "HTTP $code had non-zero Content-Length: ${response.body?.contentLength()}")
     }
+    return response
   }
 }
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/http1/Http1ExchangeCodec.kt b/okhttp/src/main/kotlin/okhttp3/internal/http1/Http1ExchangeCodec.kt
index 87f516a69..156085e14 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/http1/Http1ExchangeCodec.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/http1/Http1ExchangeCodec.kt
@@ -170,9 +170,7 @@ class Http1ExchangeCodec(
   }
 
   override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? {
-    check(state == STATE_OPEN_REQUEST_BODY ||
-        state == STATE_WRITING_REQUEST_BODY ||
-        state == STATE_READ_RESPONSE_HEADERS) {
+    check(state == STATE_OPEN_REQUEST_BODY || state == STATE_READ_RESPONSE_HEADERS) {
       "state: $state"
     }
 
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/http2/Http2ExchangeCodec.kt b/okhttp/src/main/kotlin/okhttp3/internal/http2/Http2ExchangeCodec.kt
index eddc78a61..d0b6b20de 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/http2/Http2ExchangeCodec.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/http2/Http2ExchangeCodec.kt
@@ -93,8 +93,7 @@ class Http2ExchangeCodec(
   }
 
   override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? {
-    val stream = stream ?: throw IOException("stream wasn't created")
-    val headers = stream.takeHeaders()
+    val headers = stream!!.takeHeaders()
     val responseBuilder = readHttp2HeadersList(headers, protocol)
     return if (expectContinue && responseBuilder.code == HTTP_CONTINUE) {
       null
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/http2/Http2Stream.kt b/okhttp/src/main/kotlin/okhttp3/internal/http2/Http2Stream.kt
index e8a6d7499..73c261bfd 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/http2/Http2Stream.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/http2/Http2Stream.kt
@@ -350,7 +350,7 @@ class Http2Stream internal constructor(
         synchronized(this@Http2Stream) {
           readTimeout.enter()
           try {
-            if (errorCode != null && !finished) {
+            if (errorCode != null) {
               // Prepare to deliver an error.
               errorExceptionToDeliver = errorException ?: StreamResetException(errorCode!!)
             }
diff --git a/okhttp/src/test/java/okhttp3/CacheCorruptionTest.kt b/okhttp/src/test/java/okhttp3/CacheCorruptionTest.kt
new file mode 100644
index 000000000..b148c0ae7
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/CacheCorruptionTest.kt
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2020 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3
+
+import okhttp3.internal.io.InMemoryFileSystem
+import okhttp3.mockwebserver.MockResponse
+import okhttp3.mockwebserver.MockWebServer
+import okhttp3.testing.PlatformRule
+import okhttp3.tls.internal.TlsUtil.localhost
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.After
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import java.io.File
+import java.net.CookieManager
+import java.net.ResponseCache
+import java.text.DateFormat
+import java.text.SimpleDateFormat
+import java.util.Date
+import java.util.Locale
+import java.util.TimeZone
+import java.util.concurrent.TimeUnit
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSession
+
+class CacheCorruptionTest {
+  @get:Rule
+  var server = MockWebServer()
+
+  @get:Rule
+  var fileSystem = InMemoryFileSystem()
+
+  @get:Rule
+  val clientTestRule = OkHttpClientTestRule()
+
+  @get:Rule
+  val platform = PlatformRule()
+
+  private val handshakeCertificates = localhost()
+  private lateinit var client: OkHttpClient
+  private lateinit var cache: Cache
+  private val NULL_HOSTNAME_VERIFIER =
+    HostnameVerifier { name: String?, session: SSLSession? -> true }
+  private val cookieManager = CookieManager()
+
+  @Before fun setUp() {
+    platform.assumeNotOpenJSSE()
+    platform.assumeNotBouncyCastle()
+    server.protocolNegotiationEnabled = false
+    cache = Cache(File("/cache/"), Int.MAX_VALUE.toLong(), fileSystem)
+    client = clientTestRule.newClientBuilder()
+      .cache(cache)
+      .cookieJar(JavaNetCookieJar(cookieManager))
+      .build()
+  }
+
+  @After fun tearDown() {
+    ResponseCache.setDefault(null)
+    if (this::cache.isInitialized) {
+      cache.delete()
+    }
+  }
+
+  @Test fun corruptedCipher() {
+    val response = testCorruptingCache {
+      corruptMetadata {
+        // mess with cipher suite
+        it.replace("TLS_", "SLT_")
+      }
+    }
+
+    assertThat(response.body!!.string()).isEqualTo("ABC.1") // cached
+    assertThat(cache.requestCount()).isEqualTo(2)
+    assertThat(cache.networkCount()).isEqualTo(1)
+    assertThat(cache.hitCount()).isEqualTo(1)
+
+    assertThat(response.handshake?.cipherSuite?.javaName).startsWith("SLT_")
+  }
+
+  @Test fun truncatedMetadataEntry() {
+    val response = testCorruptingCache {
+      corruptMetadata {
+        // truncate metadata to 1/4 of length
+        it.substring(0, it.length / 4)
+      }
+    }
+
+    assertThat(response.body!!.string()).isEqualTo("ABC.2") // not cached
+    assertThat(cache.requestCount()).isEqualTo(2)
+    assertThat(cache.networkCount()).isEqualTo(2)
+    assertThat(cache.hitCount()).isEqualTo(0)
+  }
+
+  private fun corruptMetadata(corruptor: (String) -> String) {
+    val metadataFile = fileSystem.files.keys.find { it.name.endsWith(".0") }
+    val metadataBuffer = fileSystem.files[metadataFile]
+
+    val contents = metadataBuffer!!.peek().readUtf8()
+
+    metadataBuffer.clear()
+    metadataBuffer.writeUtf8(corruptor(contents))
+  }
+
+  private fun testCorruptingCache(corruptor: () -> Unit): Response {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
+    server.enqueue(MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC.1"))
+    server.enqueue(MockResponse()
+      .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+      .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+      .setBody("ABC.2"))
+    client = client.newBuilder()
+        .sslSocketFactory(
+          handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager)
+        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
+        .build()
+    val request: Request = Request.Builder().url(server.url("/")).build()
+    val response1: Response = client.newCall(request).execute()
+    val bodySource = response1.body!!.source()
+    assertThat(bodySource.readUtf8()).isEqualTo("ABC.1")
+
+    corruptor()
+
+    return client.newCall(request).execute()
+  }
+
+  /**
+   * @param delta the offset from the current date to use. Negative values yield dates in the past;
+   * positive values yield dates in the future.
+   */
+  private fun formatDate(delta: Long, timeUnit: TimeUnit): String? {
+    return formatDate(Date(System.currentTimeMillis() + timeUnit.toMillis(delta)))
+  }
+
+  private fun formatDate(date: Date): String? {
+    val rfc1123: DateFormat = SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US)
+    rfc1123.timeZone = TimeZone.getTimeZone("GMT")
+    return rfc1123.format(date)
+  }
+}
\ No newline at end of file
diff --git a/okhttp/src/test/java/okhttp3/EventListenerTest.java b/okhttp/src/test/java/okhttp3/EventListenerTest.java
index 72472012b..afa1e9bdb 100644
--- a/okhttp/src/test/java/okhttp3/EventListenerTest.java
+++ b/okhttp/src/test/java/okhttp3/EventListenerTest.java
@@ -1118,7 +1118,7 @@ public final class EventListenerTest {
     assertThat(listener.recordedEventTypes()).containsExactly(
         "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
         "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
-        "RequestBodyStart", "RequestFailed", "ResponseFailed", "ConnectionReleased", "CallFailed");
+        "RequestBodyStart", "RequestFailed", "ConnectionReleased", "CallFailed");
   }
 
   @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
diff --git a/okhttp/src/test/java/okhttp3/ServerTruncatesRequestTest.kt b/okhttp/src/test/java/okhttp3/ServerTruncatesRequestTest.kt
deleted file mode 100644
index 170ea9714..000000000
--- a/okhttp/src/test/java/okhttp3/ServerTruncatesRequestTest.kt
+++ /dev/null
@@ -1,270 +0,0 @@
-/*
- * Copyright (C) 2020 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.Headers.Companion.headersOf
-import okhttp3.internal.duplex.AsyncRequestBody
-import okhttp3.internal.http2.ErrorCode
-import okhttp3.mockwebserver.MockResponse
-import okhttp3.mockwebserver.MockWebServer
-import okhttp3.mockwebserver.SocketPolicy
-import okhttp3.testing.PlatformRule
-import okhttp3.tls.internal.TlsUtil.localhost
-import okio.BufferedSink
-import okio.IOException
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Assert.fail
-import org.junit.Before
-import org.junit.Rule
-import org.junit.Test
-import org.junit.rules.TestRule
-import org.junit.rules.Timeout
-import java.util.concurrent.TimeUnit
-
-class ServerTruncatesRequestTest {
-  @Rule @JvmField
-  val platform = PlatformRule()
-
-  @Rule @JvmField
-  val timeout: TestRule = Timeout(30_000, TimeUnit.MILLISECONDS)
-
-  @Rule @JvmField
-  val server = MockWebServer()
-
-  @Rule @JvmField
-  var clientTestRule = OkHttpClientTestRule()
-
-  private val listener = RecordingEventListener()
-  private val handshakeCertificates = localhost()
-
-  private var client = clientTestRule.newClientBuilder()
-      .eventListenerFactory(clientTestRule.wrap(listener))
-      .build()
-
-  @Before fun setUp() {
-    platform.assumeNotOpenJSSE()
-    platform.assumeHttp2Support()
-    platform.assumeNotBouncyCastle()
-  }
-
-  @Test fun serverTruncatesRequestOnLongPostHttp1() {
-    serverTruncatesRequestOnLongPost(https = false)
-  }
-
-  @Test fun serverTruncatesRequestOnLongPostHttp2() {
-    enableProtocol(Protocol.HTTP_2)
-    serverTruncatesRequestOnLongPost(https = true)
-  }
-
-  private fun serverTruncatesRequestOnLongPost(https: Boolean) {
-    server.enqueue(MockResponse()
-        .setSocketPolicy(SocketPolicy.DO_NOT_READ_REQUEST_BODY)
-        .setBody("abc")
-        .apply { this.http2ErrorCode = ErrorCode.NO_ERROR.httpCode })
-
-    val call = client.newCall(Request.Builder()
-        .url(server.url("/"))
-        .post(SlowRequestBody)
-        .build())
-
-    call.execute().use { response ->
-      assertThat(response.body!!.string()).isEqualTo("abc")
-    }
-
-    val expectedEvents = mutableListOf<String>()
-    // Start out with standard events...
-    expectedEvents += "CallStart"
-    expectedEvents += "ProxySelectStart"
-    expectedEvents += "ProxySelectEnd"
-    expectedEvents += "DnsStart"
-    expectedEvents += "DnsEnd"
-    expectedEvents += "ConnectStart"
-    if (https) {
-      expectedEvents += "SecureConnectStart"
-      expectedEvents += "SecureConnectEnd"
-    }
-    expectedEvents += "ConnectEnd"
-    expectedEvents += "ConnectionAcquired"
-    expectedEvents += "RequestHeadersStart"
-    expectedEvents += "RequestHeadersEnd"
-    expectedEvents += "RequestBodyStart"
-    // ... but we can read the response even after writing the request fails.
-    expectedEvents += "RequestFailed"
-    expectedEvents += "ResponseHeadersStart"
-    expectedEvents += "ResponseHeadersEnd"
-    expectedEvents += "ResponseBodyStart"
-    expectedEvents += "ResponseBodyEnd"
-    expectedEvents += "ConnectionReleased"
-    expectedEvents += "CallEnd"
-    assertThat(listener.recordedEventTypes()).isEqualTo(expectedEvents)
-
-    // Confirm that the connection pool was not corrupted by making another call.
-    makeSimpleCall()
-  }
-
-  /**
-   * If the server returns a full response, it doesn't really matter if the HTTP/2 stream is reset.
-   * Attempts to write the request body fails fast.
-   */
-  @Test fun serverTruncatesRequestHttp2OnDuplexRequest() {
-    enableProtocol(Protocol.HTTP_2)
-
-    server.enqueue(MockResponse()
-        .setSocketPolicy(SocketPolicy.DO_NOT_READ_REQUEST_BODY)
-        .setBody("abc")
-        .apply { this.http2ErrorCode = ErrorCode.NO_ERROR.httpCode })
-
-    val requestBody = AsyncRequestBody()
-
-    val call = client.newCall(Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build())
-
-    call.execute().use { response ->
-      assertThat(response.body!!.string()).isEqualTo("abc")
-      val requestBodyOut = requestBody.takeSink()
-      try {
-        SlowRequestBody.writeTo(requestBodyOut)
-        fail()
-      } catch (expected: IOException) {
-      }
-      try {
-        requestBodyOut.close()
-        fail()
-      } catch (expected: IOException) {
-      }
-    }
-
-    // Confirm that the connection pool was not corrupted by making another call.
-    makeSimpleCall()
-  }
-
-  @Test fun serverTruncatesRequestButTrailersCanStillBeReadHttp1() {
-    serverTruncatesRequestButTrailersCanStillBeRead(http2 = false)
-  }
-
-  @Test fun serverTruncatesRequestButTrailersCanStillBeReadHttp2() {
-    enableProtocol(Protocol.HTTP_2)
-    serverTruncatesRequestButTrailersCanStillBeRead(http2 = true)
-  }
-
-  private fun serverTruncatesRequestButTrailersCanStillBeRead(http2: Boolean) {
-    val mockResponse = MockResponse()
-        .setSocketPolicy(SocketPolicy.DO_NOT_READ_REQUEST_BODY)
-        .apply {
-          this.trailers = headersOf("caboose", "xyz")
-          this.http2ErrorCode = ErrorCode.NO_ERROR.httpCode
-        }
-
-    // Trailers always work for HTTP/2, but only for chunked bodies in HTTP/1.
-    if (http2) {
-      mockResponse.setBody("abc")
-    } else {
-      mockResponse.setChunkedBody("abc", 1)
-    }
-
-    server.enqueue(mockResponse)
-
-    val call = client.newCall(Request.Builder()
-        .url(server.url("/"))
-        .post(SlowRequestBody)
-        .build())
-
-    call.execute().use { response ->
-      assertThat(response.body!!.string()).isEqualTo("abc")
-      assertThat(response.trailers()).isEqualTo(headersOf("caboose", "xyz"))
-    }
-  }
-
-  @Test fun noAttemptToReadResponseIfLoadingRequestBodyIsSourceOfFailure() {
-    server.enqueue(MockResponse().setBody("abc"))
-
-    val requestBody = object : RequestBody() {
-      override fun contentType(): MediaType? = null
-
-      override fun writeTo(sink: BufferedSink) {
-        throw IOException("boom") // Despite this exception, 'sink' is healthy.
-      }
-    }
-
-    val callA = client.newCall(Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build())
-
-    try {
-      callA.execute()
-      fail()
-    } catch (expected: IOException) {
-      assertThat(expected).hasMessage("boom")
-    }
-
-    assertThat(server.requestCount).isEqualTo(0)
-
-    // Confirm that the connection pool was not corrupted by making another call. This doesn't use
-    // makeSimpleCall() because it uses the MockResponse enqueued above.
-    val callB = client.newCall(Request.Builder()
-        .url(server.url("/"))
-        .build())
-    callB.execute().use { response ->
-      assertThat(response.body!!.string()).isEqualTo("abc")
-    }
-  }
-
-  private fun makeSimpleCall() {
-    server.enqueue(MockResponse().setBody("healthy"))
-    val callB = client.newCall(Request.Builder()
-        .url(server.url("/"))
-        .build())
-    callB.execute().use { response ->
-      assertThat(response.body!!.string()).isEqualTo("healthy")
-    }
-  }
-
-  private fun enableProtocol(protocol: Protocol) {
-    enableTls()
-    client = client.newBuilder()
-        .protocols(listOf(protocol, Protocol.HTTP_1_1))
-        .build()
-    server.protocols = client.protocols
-  }
-
-  private fun enableTls() {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(),
-            handshakeCertificates.trustManager
-        )
-        .hostnameVerifier(RecordingHostnameVerifier())
-        .build()
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
-  }
-
-  /** A request body that slowly trickles bytes, expecting to not complete. */
-  private object SlowRequestBody : RequestBody() {
-    override fun contentType(): MediaType? = null
-
-    override fun writeTo(sink: BufferedSink) {
-      for (i in 0 until 50) {
-        sink.writeUtf8("abc")
-        sink.flush()
-        Thread.sleep(100)
-      }
-      fail()
-    }
-  }
-}
