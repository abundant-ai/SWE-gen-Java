diff --git a/core/src/main/scala/cats/instances/all.scala b/core/src/main/scala/cats/instances/all.scala
index e1f2e949d..456ea2082 100644
--- a/core/src/main/scala/cats/instances/all.scala
+++ b/core/src/main/scala/cats/instances/all.scala
@@ -69,6 +69,5 @@ trait AllInstancesBinCompat7
     with VectorInstancesBinCompat1
     with EitherInstancesBinCompat0
     with StreamInstancesBinCompat1
-    with QueueInstancesBinCompat0
     with TailRecInstances
     with SortedSetInstancesBinCompat2
diff --git a/core/src/main/scala/cats/instances/queue.scala b/core/src/main/scala/cats/instances/queue.scala
index 9a898afa3..aebedd10d 100644
--- a/core/src/main/scala/cats/instances/queue.scala
+++ b/core/src/main/scala/cats/instances/queue.scala
@@ -2,7 +2,6 @@ package cats
 package instances
 
 import cats.syntax.show._
-
 import scala.annotation.tailrec
 import scala.collection.immutable.Queue
 import scala.util.Try
@@ -154,31 +153,3 @@ trait QueueInstances extends cats.kernel.instances.QueueInstances {
         fa.iterator.map(_.show).mkString("Queue(", ", ", ")")
     }
 }
-
-private[instances] trait QueueInstancesBinCompat0 {
-  implicit val catsStdTraverseFilterForQueue: TraverseFilter[Queue] = new TraverseFilter[Queue] {
-    val traverse: Traverse[Queue] = cats.instances.queue.catsStdInstancesForQueue
-
-    override def mapFilter[A, B](fa: Queue[A])(f: (A) => Option[B]): Queue[B] =
-      fa.collect(Function.unlift(f))
-
-    override def filter[A](fa: Queue[A])(f: (A) => Boolean): Queue[A] = fa.filter(f)
-
-    override def collect[A, B](fa: Queue[A])(f: PartialFunction[A, B]): Queue[B] = fa.collect(f)
-
-    override def flattenOption[A](fa: Queue[Option[A]]): Queue[A] = fa.flatten
-
-    def traverseFilter[G[_], A, B](fa: Queue[A])(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Queue[B]] =
-      fa.foldRight(Eval.now(G.pure(Queue.empty[B])))(
-          (x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o))
-        )
-        .value
-
-    override def filterA[G[_], A](fa: Queue[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Queue[A]] =
-      fa.foldRight(Eval.now(G.pure(Queue.empty[A])))(
-          (x, xse) => G.map2Eval(f(x), xse)((b, vec) => if (b) x +: vec else vec)
-        )
-        .value
-  }
-
-}
diff --git a/tests/src/test/scala/cats/tests/QueueSuite.scala b/tests/src/test/scala/cats/tests/QueueSuite.scala
index 255adc0f6..a63202246 100644
--- a/tests/src/test/scala/cats/tests/QueueSuite.scala
+++ b/tests/src/test/scala/cats/tests/QueueSuite.scala
@@ -2,13 +2,13 @@ package cats
 package tests
 
 import scala.collection.immutable.Queue
+
 import cats.laws.discipline.{
   AlternativeTests,
   CoflatMapTests,
   MonadTests,
   SemigroupalTests,
   SerializableTests,
-  TraverseFilterTests,
   TraverseTests
 }
 
@@ -28,9 +28,6 @@ class QueueSuite extends CatsSuite {
   checkAll("Queue[Int] with Option", TraverseTests[Queue].traverse[Int, Int, Int, Set[Int], Option, Option])
   checkAll("Traverse[Queue]", SerializableTests.serializable(Traverse[Queue]))
 
-  checkAll("Queue[Int]", TraverseFilterTests[Queue].traverseFilter[Int, Int, Int])
-  checkAll("TraverseFilter[Queue]", SerializableTests.serializable(TraverseFilter[Queue]))
-
   test("show") {
     Queue(1, 2, 3).show should ===("Queue(1, 2, 3)")
     Queue.empty[Int].show should ===("Queue()")
