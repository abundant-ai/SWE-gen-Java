diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
index 0bbfe92ab..0ae983de3 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
@@ -192,8 +192,15 @@ public abstract interface class io/ktor/server/plugins/di/DependencyProvider {
 	public abstract fun set (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function1;)V
 }
 
+public final class io/ktor/server/plugins/di/DependencyProviderContext : io/ktor/server/plugins/di/DependencyProvider {
+	public fun <init> (Lio/ktor/server/plugins/di/DependencyProvider;)V
+	public fun getDeclarations ()Ljava/util/Map;
+	public fun set (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function1;)V
+}
+
 public final class io/ktor/server/plugins/di/DependencyProviderKt {
 	public static final fun ifImplicit (Lio/ktor/server/plugins/di/DependencyCreateFunction;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
+	public static final fun invoke (Lio/ktor/server/plugins/di/DependencyProvider;Lkotlin/jvm/functions/Function1;)V
 }
 
 public abstract interface class io/ktor/server/plugins/di/DependencyReflection {
@@ -208,21 +215,24 @@ public class io/ktor/server/plugins/di/DependencyReflectionJvm : io/ktor/server/
 	public fun toDependencyKey (Lkotlin/reflect/KParameter;)Lio/ktor/server/plugins/di/DependencyKey;
 }
 
-public final class io/ktor/server/plugins/di/DependencyRegistry : io/ktor/server/plugins/di/DependencyProvider, io/ktor/server/plugins/di/DependencyResolver {
+public abstract interface class io/ktor/server/plugins/di/DependencyRegistry : io/ktor/server/plugins/di/DependencyProvider, io/ktor/server/plugins/di/DependencyResolver {
+	public abstract fun require (Lio/ktor/server/plugins/di/DependencyKey;)V
+	public abstract fun validate ()V
+}
+
+public final class io/ktor/server/plugins/di/DependencyRegistryImpl : io/ktor/server/plugins/di/DependencyProvider, io/ktor/server/plugins/di/DependencyRegistry {
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyProvider;Lio/ktor/server/plugins/di/DependencyMap;Lio/ktor/server/plugins/di/DependencyResolution;Lio/ktor/server/plugins/di/DependencyReflection;)V
 	public fun contains (Lio/ktor/server/plugins/di/DependencyKey;)Z
 	public fun get (Lio/ktor/server/plugins/di/DependencyKey;)Ljava/lang/Object;
 	public fun getDeclarations ()Ljava/util/Map;
 	public fun getOrPut (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
 	public fun getReflection ()Lio/ktor/server/plugins/di/DependencyReflection;
-	public fun named (Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
-	public final fun require (Lio/ktor/server/plugins/di/DependencyKey;)V
+	public fun require (Lio/ktor/server/plugins/di/DependencyKey;)V
 	public fun set (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function1;)V
-	public final fun validate ()V
+	public fun validate ()V
 }
 
 public final class io/ktor/server/plugins/di/DependencyRegistryKt {
-	public static final fun dependencies (Lio/ktor/server/application/Application;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
 	public static final fun getDefaultDependencyResolution ()Lio/ktor/server/plugins/di/DependencyResolution;
 	public static final fun getDependencies (Lio/ktor/server/application/Application;)Lio/ktor/server/plugins/di/DependencyRegistry;
 	public static final fun setDependencies (Lio/ktor/server/application/Application;Lio/ktor/server/plugins/di/DependencyRegistry;)V
@@ -233,16 +243,13 @@ public abstract interface class io/ktor/server/plugins/di/DependencyResolution {
 }
 
 public final class io/ktor/server/plugins/di/DependencyResolutionKt {
+	public static final fun getOrNull (Lio/ktor/server/plugins/di/DependencyMap;Lio/ktor/server/plugins/di/DependencyKey;)Ljava/lang/Object;
+	public static final fun named (Lio/ktor/server/plugins/di/DependencyResolver;Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 	public static final fun plus (Lio/ktor/server/plugins/di/DependencyMap;Lio/ktor/server/plugins/di/DependencyMap;)Lio/ktor/server/plugins/di/DependencyMap;
 }
 
 public abstract interface class io/ktor/server/plugins/di/DependencyResolver : io/ktor/server/plugins/di/MutableDependencyMap {
 	public abstract fun getReflection ()Lio/ktor/server/plugins/di/DependencyReflection;
-	public abstract fun named (Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
-}
-
-public final class io/ktor/server/plugins/di/DependencyResolver$DefaultImpls {
-	public static fun named (Lio/ktor/server/plugins/di/DependencyResolver;Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 }
 
 public final class io/ktor/server/plugins/di/DependencyResolverContext {
@@ -252,7 +259,7 @@ public final class io/ktor/server/plugins/di/DependencyResolverContext {
 	public final fun copy (Lio/ktor/server/plugins/di/DependencyResolver;Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 	public static synthetic fun copy$default (Lio/ktor/server/plugins/di/DependencyResolverContext;Lio/ktor/server/plugins/di/DependencyResolver;Ljava/lang/String;ILjava/lang/Object;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 	public fun equals (Ljava/lang/Object;)Z
-	public final fun getName ()Ljava/lang/String;
+	public final fun getKey ()Ljava/lang/String;
 	public final fun getResolver ()Lio/ktor/server/plugins/di/DependencyResolver;
 	public fun hashCode ()I
 	public fun toString ()Ljava/lang/String;
@@ -322,7 +329,6 @@ public final class io/ktor/server/plugins/di/ProcessingDependencyResolver : io/k
 	public fun get (Lio/ktor/server/plugins/di/DependencyKey;)Ljava/lang/Object;
 	public fun getOrPut (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
 	public fun getReflection ()Lio/ktor/server/plugins/di/DependencyReflection;
-	public fun named (Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 	public final fun resolveAll ()Ljava/util/Map;
 }
 
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
index 0868ba65c..f294d3355 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
@@ -53,11 +53,14 @@ abstract interface io.ktor.server.plugins.di/DependencyReflection { // io.ktor.s
     abstract fun <#A1: kotlin/Any> create(kotlin.reflect/KClass<#A1>, kotlin/Function1<io.ktor.server.plugins.di/DependencyKey, kotlin/Any>): #A1 // io.ktor.server.plugins.di/DependencyReflection.create|create(kotlin.reflect.KClass<0:0>;kotlin.Function1<io.ktor.server.plugins.di.DependencyKey,kotlin.Any>){0§<kotlin.Any>}[0]
 }
 
+abstract interface io.ktor.server.plugins.di/DependencyRegistry : io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyResolver { // io.ktor.server.plugins.di/DependencyRegistry|null[0]
+    abstract fun require(io.ktor.server.plugins.di/DependencyKey) // io.ktor.server.plugins.di/DependencyRegistry.require|require(io.ktor.server.plugins.di.DependencyKey){}[0]
+    abstract fun validate() // io.ktor.server.plugins.di/DependencyRegistry.validate|validate(){}[0]
+}
+
 abstract interface io.ktor.server.plugins.di/DependencyResolver : io.ktor.server.plugins.di/MutableDependencyMap { // io.ktor.server.plugins.di/DependencyResolver|null[0]
     abstract val reflection // io.ktor.server.plugins.di/DependencyResolver.reflection|{}reflection[0]
         abstract fun <get-reflection>(): io.ktor.server.plugins.di/DependencyReflection // io.ktor.server.plugins.di/DependencyResolver.reflection.<get-reflection>|<get-reflection>(){}[0]
-
-    open fun named(kotlin/String): io.ktor.server.plugins.di/DependencyResolverContext // io.ktor.server.plugins.di/DependencyResolver.named|named(kotlin.String){}[0]
 }
 
 abstract interface io.ktor.server.plugins.di/MutableDependencyMap : io.ktor.server.plugins.di/DependencyMap { // io.ktor.server.plugins.di/MutableDependencyMap|null[0]
@@ -220,31 +223,36 @@ final class io.ktor.server.plugins.di/DependencyMapImpl : io.ktor.server.plugins
     final fun contains(io.ktor.server.plugins.di/DependencyKey): kotlin/Boolean // io.ktor.server.plugins.di/DependencyMapImpl.contains|contains(io.ktor.server.plugins.di.DependencyKey){}[0]
 }
 
-final class io.ktor.server.plugins.di/DependencyRegistry : io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyResolver { // io.ktor.server.plugins.di/DependencyRegistry|null[0]
-    constructor <init>(io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyMap, io.ktor.server.plugins.di/DependencyResolution, io.ktor.server.plugins.di/DependencyReflection) // io.ktor.server.plugins.di/DependencyRegistry.<init>|<init>(io.ktor.server.plugins.di.DependencyProvider;io.ktor.server.plugins.di.DependencyMap;io.ktor.server.plugins.di.DependencyResolution;io.ktor.server.plugins.di.DependencyReflection){}[0]
+final class io.ktor.server.plugins.di/DependencyProviderContext : io.ktor.server.plugins.di/DependencyProvider { // io.ktor.server.plugins.di/DependencyProviderContext|null[0]
+    constructor <init>(io.ktor.server.plugins.di/DependencyProvider) // io.ktor.server.plugins.di/DependencyProviderContext.<init>|<init>(io.ktor.server.plugins.di.DependencyProvider){}[0]
+
+    final val declarations // io.ktor.server.plugins.di/DependencyProviderContext.declarations|{}declarations[0]
+        final fun <get-declarations>(): kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/DependencyProviderContext.declarations.<get-declarations>|<get-declarations>(){}[0]
+
+    final fun <#A1: kotlin/Any?> set(io.ktor.server.plugins.di/DependencyKey, kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1>) // io.ktor.server.plugins.di/DependencyProviderContext.set|set(io.ktor.server.plugins.di.DependencyKey;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
+}
+
+final class io.ktor.server.plugins.di/DependencyRegistryImpl : io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyRegistry { // io.ktor.server.plugins.di/DependencyRegistryImpl|null[0]
+    constructor <init>(io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyMap, io.ktor.server.plugins.di/DependencyResolution, io.ktor.server.plugins.di/DependencyReflection) // io.ktor.server.plugins.di/DependencyRegistryImpl.<init>|<init>(io.ktor.server.plugins.di.DependencyProvider;io.ktor.server.plugins.di.DependencyMap;io.ktor.server.plugins.di.DependencyResolution;io.ktor.server.plugins.di.DependencyReflection){}[0]
 
-    final val declarations // io.ktor.server.plugins.di/DependencyRegistry.declarations|{}declarations[0]
-        final fun <get-declarations>(): kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/DependencyRegistry.declarations.<get-declarations>|<get-declarations>(){}[0]
-    final val reflection // io.ktor.server.plugins.di/DependencyRegistry.reflection|{}reflection[0]
-        final fun <get-reflection>(): io.ktor.server.plugins.di/DependencyReflection // io.ktor.server.plugins.di/DependencyRegistry.reflection.<get-reflection>|<get-reflection>(){}[0]
+    final val declarations // io.ktor.server.plugins.di/DependencyRegistryImpl.declarations|{}declarations[0]
+        final fun <get-declarations>(): kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/DependencyRegistryImpl.declarations.<get-declarations>|<get-declarations>(){}[0]
+    final val reflection // io.ktor.server.plugins.di/DependencyRegistryImpl.reflection|{}reflection[0]
+        final fun <get-reflection>(): io.ktor.server.plugins.di/DependencyReflection // io.ktor.server.plugins.di/DependencyRegistryImpl.reflection.<get-reflection>|<get-reflection>(){}[0]
 
-    final fun <#A1: kotlin/Any?> get(io.ktor.server.plugins.di/DependencyKey): #A1 // io.ktor.server.plugins.di/DependencyRegistry.get|get(io.ktor.server.plugins.di.DependencyKey){0§<kotlin.Any?>}[0]
-    final fun <#A1: kotlin/Any?> getOrPut(io.ktor.server.plugins.di/DependencyKey, kotlin/Function0<#A1>): #A1 // io.ktor.server.plugins.di/DependencyRegistry.getOrPut|getOrPut(io.ktor.server.plugins.di.DependencyKey;kotlin.Function0<0:0>){0§<kotlin.Any?>}[0]
-    final fun <#A1: kotlin/Any?> set(io.ktor.server.plugins.di/DependencyKey, kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1>) // io.ktor.server.plugins.di/DependencyRegistry.set|set(io.ktor.server.plugins.di.DependencyKey;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
-    final fun contains(io.ktor.server.plugins.di/DependencyKey): kotlin/Boolean // io.ktor.server.plugins.di/DependencyRegistry.contains|contains(io.ktor.server.plugins.di.DependencyKey){}[0]
-    final fun require(io.ktor.server.plugins.di/DependencyKey) // io.ktor.server.plugins.di/DependencyRegistry.require|require(io.ktor.server.plugins.di.DependencyKey){}[0]
-    final fun validate() // io.ktor.server.plugins.di/DependencyRegistry.validate|validate(){}[0]
-    final inline fun <#A1: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyProvider).provide(kotlin.reflect/KClass<out #A1>) // io.ktor.server.plugins.di/DependencyRegistry.provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
-    final inline fun <#A1: reified kotlin/Any?> provide(kotlin/String? = ..., noinline kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1>) // io.ktor.server.plugins.di/DependencyRegistry.provide|provide(kotlin.String?;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
-    final inline fun <#A1: reified kotlin/Any?> provideDelegate(kotlin/Any?, kotlin.reflect/KProperty<*>): kotlin.properties/ReadOnlyProperty<kotlin/Any?, #A1> // io.ktor.server.plugins.di/DependencyRegistry.provideDelegate|provideDelegate(kotlin.Any?;kotlin.reflect.KProperty<*>){0§<kotlin.Any?>}[0]
-    final inline fun <#A1: reified kotlin/Any?> resolve(kotlin/String? = ...): #A1 // io.ktor.server.plugins.di/DependencyRegistry.resolve|resolve(kotlin.String?){0§<kotlin.Any?>}[0]
+    final fun <#A1: kotlin/Any?> get(io.ktor.server.plugins.di/DependencyKey): #A1 // io.ktor.server.plugins.di/DependencyRegistryImpl.get|get(io.ktor.server.plugins.di.DependencyKey){0§<kotlin.Any?>}[0]
+    final fun <#A1: kotlin/Any?> getOrPut(io.ktor.server.plugins.di/DependencyKey, kotlin/Function0<#A1>): #A1 // io.ktor.server.plugins.di/DependencyRegistryImpl.getOrPut|getOrPut(io.ktor.server.plugins.di.DependencyKey;kotlin.Function0<0:0>){0§<kotlin.Any?>}[0]
+    final fun <#A1: kotlin/Any?> set(io.ktor.server.plugins.di/DependencyKey, kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1>) // io.ktor.server.plugins.di/DependencyRegistryImpl.set|set(io.ktor.server.plugins.di.DependencyKey;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
+    final fun contains(io.ktor.server.plugins.di/DependencyKey): kotlin/Boolean // io.ktor.server.plugins.di/DependencyRegistryImpl.contains|contains(io.ktor.server.plugins.di.DependencyKey){}[0]
+    final fun require(io.ktor.server.plugins.di/DependencyKey) // io.ktor.server.plugins.di/DependencyRegistryImpl.require|require(io.ktor.server.plugins.di.DependencyKey){}[0]
+    final fun validate() // io.ktor.server.plugins.di/DependencyRegistryImpl.validate|validate(){}[0]
 }
 
 final class io.ktor.server.plugins.di/DependencyResolverContext { // io.ktor.server.plugins.di/DependencyResolverContext|null[0]
     constructor <init>(io.ktor.server.plugins.di/DependencyResolver, kotlin/String) // io.ktor.server.plugins.di/DependencyResolverContext.<init>|<init>(io.ktor.server.plugins.di.DependencyResolver;kotlin.String){}[0]
 
-    final val name // io.ktor.server.plugins.di/DependencyResolverContext.name|{}name[0]
-        final fun <get-name>(): kotlin/String // io.ktor.server.plugins.di/DependencyResolverContext.name.<get-name>|<get-name>(){}[0]
+    final val key // io.ktor.server.plugins.di/DependencyResolverContext.key|{}key[0]
+        final fun <get-key>(): kotlin/String // io.ktor.server.plugins.di/DependencyResolverContext.key.<get-key>|<get-key>(){}[0]
     final val resolver // io.ktor.server.plugins.di/DependencyResolverContext.resolver|{}resolver[0]
         final fun <get-resolver>(): io.ktor.server.plugins.di/DependencyResolver // io.ktor.server.plugins.di/DependencyResolverContext.resolver.<get-resolver>|<get-resolver>(){}[0]
 
@@ -254,8 +262,6 @@ final class io.ktor.server.plugins.di/DependencyResolverContext { // io.ktor.ser
     final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.server.plugins.di/DependencyResolverContext.equals|equals(kotlin.Any?){}[0]
     final fun hashCode(): kotlin/Int // io.ktor.server.plugins.di/DependencyResolverContext.hashCode|hashCode(){}[0]
     final fun toString(): kotlin/String // io.ktor.server.plugins.di/DependencyResolverContext.toString|toString(){}[0]
-    final inline fun <#A1: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).resolve(kotlin/String? = ...): #A1 // io.ktor.server.plugins.di/DependencyResolverContext.resolve|resolve@io.ktor.server.plugins.di.DependencyMap(kotlin.String?){0§<kotlin.Any?>}[0]
-    final inline fun <#A1: reified kotlin/Any?> getValue(kotlin/Any?, kotlin.reflect/KProperty<*>): #A1 // io.ktor.server.plugins.di/DependencyResolverContext.getValue|getValue(kotlin.Any?;kotlin.reflect.KProperty<*>){0§<kotlin.Any?>}[0]
 }
 
 final class io.ktor.server.plugins.di/DuplicateDependencyException : io.ktor.server.plugins.di/DependencyInjectionException { // io.ktor.server.plugins.di/DuplicateDependencyException|null[0]
@@ -369,12 +375,17 @@ final fun (io.ktor.server.plugins.di/DependencyKey).io.ktor.server.plugins.di/is
 final fun (io.ktor.server.plugins.di/DependencyKeyCovariance).io.ktor.server.plugins.di/plus(io.ktor.server.plugins.di/DependencyKeyCovariance): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/plus|plus@io.ktor.server.plugins.di.DependencyKeyCovariance(io.ktor.server.plugins.di.DependencyKeyCovariance){}[0]
 final fun (io.ktor.server.plugins.di/DependencyKeyCovariance).io.ktor.server.plugins.di/times(io.ktor.server.plugins.di/DependencyKeyCovariance): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/times|times@io.ktor.server.plugins.di.DependencyKeyCovariance(io.ktor.server.plugins.di.DependencyKeyCovariance){}[0]
 final fun (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/plus(io.ktor.server.plugins.di/DependencyMap): io.ktor.server.plugins.di/DependencyMap // io.ktor.server.plugins.di/plus|plus@io.ktor.server.plugins.di.DependencyMap(io.ktor.server.plugins.di.DependencyMap){}[0]
+final fun (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/invoke(kotlin/Function1<io.ktor.server.plugins.di/DependencyProviderContext, kotlin/Unit>) // io.ktor.server.plugins.di/invoke|invoke@io.ktor.server.plugins.di.DependencyProvider(kotlin.Function1<io.ktor.server.plugins.di.DependencyProviderContext,kotlin.Unit>){}[0]
+final fun (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/named(kotlin/String): io.ktor.server.plugins.di/DependencyResolverContext // io.ktor.server.plugins.di/named|named@io.ktor.server.plugins.di.DependencyResolver(kotlin.String){}[0]
 final fun (io.ktor.util.reflect/TypeInfo).io.ktor.server.plugins.di.utils/hierarchy(): kotlin.sequences/Sequence<io.ktor.util.reflect/TypeInfo> // io.ktor.server.plugins.di.utils/hierarchy|hierarchy@io.ktor.util.reflect.TypeInfo(){}[0]
 final fun (io.ktor.util.reflect/TypeInfo).io.ktor.server.plugins.di.utils/toNullable(): io.ktor.util.reflect/TypeInfo? // io.ktor.server.plugins.di.utils/toNullable|toNullable@io.ktor.util.reflect.TypeInfo(){}[0]
 final fun (io.ktor.util.reflect/TypeInfo).io.ktor.server.plugins.di.utils/typeParametersHierarchy(): kotlin.sequences/Sequence<io.ktor.util.reflect/TypeInfo> // io.ktor.server.plugins.di.utils/typeParametersHierarchy|typeParametersHierarchy@io.ktor.util.reflect.TypeInfo(){}[0]
-final fun <#A: kotlin/Any?> (io.ktor.server.application/Application).io.ktor.server.plugins.di/dependencies(kotlin/Function1<io.ktor.server.plugins.di/DependencyRegistry, #A>): #A // io.ktor.server.plugins.di/dependencies|dependencies@io.ktor.server.application.Application(kotlin.Function1<io.ktor.server.plugins.di.DependencyRegistry,0:0>){0§<kotlin.Any?>}[0]
 final fun <#A: kotlin/Any?> (io.ktor.server.plugins.di/DependencyCreateFunction).io.ktor.server.plugins.di/ifImplicit(kotlin/Function1<io.ktor.server.plugins.di/ImplicitCreateFunction, #A>): #A? // io.ktor.server.plugins.di/ifImplicit|ifImplicit@io.ktor.server.plugins.di.DependencyCreateFunction(kotlin.Function1<io.ktor.server.plugins.di.ImplicitCreateFunction,0:0>){0§<kotlin.Any?>}[0]
+final fun <#A: kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/getOrNull(io.ktor.server.plugins.di/DependencyKey): #A? // io.ktor.server.plugins.di/getOrNull|getOrNull@io.ktor.server.plugins.di.DependencyMap(io.ktor.server.plugins.di.DependencyKey){0§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/provide(kotlin.reflect/KClass<out #A>) // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
 final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/create(): #A // io.ktor.server.plugins.di/create|create@io.ktor.server.plugins.di.DependencyResolver(){0§<kotlin.Any>}[0]
 final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/create(kotlin.reflect/KClass<out #A>): #A // io.ktor.server.plugins.di/create|create@io.ktor.server.plugins.di.DependencyResolver(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/resolve(kotlin/String? = ...): #A // io.ktor.server.plugins.di/resolve|resolve@io.ktor.server.plugins.di.DependencyMap(kotlin.String?){0§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/provide(kotlin/String? = ..., noinline kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A>) // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.String?;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideDelegate(kotlin/Any?, kotlin.reflect/KProperty<*>): kotlin.properties/ReadOnlyProperty<kotlin/Any?, #A> // io.ktor.server.plugins.di/provideDelegate|provideDelegate@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Any?;kotlin.reflect.KProperty<*>){0§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyResolverContext).io.ktor.server.plugins.di/getValue(kotlin/Any?, kotlin.reflect/KProperty<*>): #A // io.ktor.server.plugins.di/getValue|getValue@io.ktor.server.plugins.di.DependencyResolverContext(kotlin.Any?;kotlin.reflect.KProperty<*>){0§<kotlin.Any?>}[0]
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
index 6dc474fac..2464fce9d 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
@@ -68,7 +68,7 @@ public val DI: ApplicationPlugin<DependencyInjectionConfig> =
         val configMap = ConfigurationDependencyMap(application.environment.config)
         val dependenciesMap = pluginConfig.dependenciesMap?.let { it + configMap } ?: configMap
 
-        var registry = DependencyRegistry(
+        var registry = DependencyRegistryImpl(
             provider,
             dependenciesMap,
             pluginConfig.resolution,
@@ -198,6 +198,7 @@ public data class DependencyKey(
     public val name: String? = null,
     public val qualifier: Any? = null,
 ) {
+
     override fun toString(): String = buildString {
         append(type.kotlinType ?: type.type)
         if (name != null) {
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
index c5be8bd07..93756a2ba 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
@@ -44,16 +44,6 @@ public interface DependencyProvider {
     public val declarations: Map<DependencyKey, DependencyCreateFunction>
 }
 
-/**
- * Basic call for providing a dependency, like `provide<Service> { ServiceImpl() }`.
- */
-public inline fun <reified T> DependencyProvider.provide(
-    name: String? = null,
-    noinline provide: DependencyResolver.() -> T
-) {
-    set(DependencyKey(typeInfo<T>(), name), provide)
-}
-
 /**
  * Wraps the logic for creating a new instance of a dependency.
  *
@@ -244,3 +234,28 @@ public open class MapDependencyProvider(
         }
     }
 }
+
+/**
+ * DSL helper for declaring dependencies with `dependencies {}` block.
+ */
+@KtorDsl
+public operator fun DependencyProvider.invoke(action: DependencyProviderContext.() -> Unit) {
+    DependencyProviderContext(this).action()
+}
+
+/**
+ * Builder context for providing dependencies.
+ */
+@KtorDsl
+public class DependencyProviderContext(
+    private val delegate: DependencyProvider
+) : DependencyProvider by delegate
+
+/**
+ * Basic call for providing a dependency, like `provide<Service> { ServiceImpl() }`.
+ */
+public inline fun <reified T> DependencyProvider.provide(
+    name: String? = null,
+    noinline provide: DependencyResolver.() -> T
+) =
+    set(DependencyKey(typeInfo<T>(), name), provide)
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt
index b2ced8b33..be210bd38 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt
@@ -23,9 +23,21 @@ public interface DependencyReflection {
     public fun <T : Any> create(kClass: KClass<T>, init: (DependencyKey) -> Any): T
 }
 
+/**
+ * Provides an instance of the dependency associated with the specified [kClass].
+ *
+ * Uses the `create` method from the `DependencyResolver` to resolve and instantiate a dependency
+ * of type [T] specified by the given [kClass].
+ *
+ * @param T The type of the dependency to be provided.
+ * @param kClass The `KClass` representing the type of the dependency to be created or resolved.
+ */
+public inline fun <reified T : Any> DependencyProvider.provide(kClass: KClass<out T>) =
+    provide { create(kClass) }
+
 /**
  * Creates an instance of the specified type [T] using the dependency resolver.
- * This function uses the `DependencyReflection` mechanism to dynamically
+ * This function utilizes the `DependencyReflection` mechanism to dynamically
  * construct an instance of the requested type, resolving dependencies as needed.
  *
  * @return An instance of the type [T].
@@ -41,5 +53,5 @@ public inline fun <reified T : Any> DependencyResolver.create(): T =
  * @param kClass The class reference representing the type of object to create or retrieve.
  * @return An instance of the specified type [T].
  */
-public inline fun <reified T : Any> DependencyResolver.create(kClass: KClass<out T>): T =
+public inline fun <reified T : Any> DependencyResolver.create(kClass: KClass<out T>) =
     getOrPut(DependencyKey(typeInfo<T>())) { reflection.create(kClass, ::get) }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
index f10f82a98..0d05593ac 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
@@ -9,29 +9,53 @@ import io.ktor.server.plugins.di.MutableDependencyMap.Companion.asResolver
 import io.ktor.util.reflect.typeInfo
 import io.ktor.utils.io.*
 import kotlin.properties.ReadOnlyProperty
-import kotlin.reflect.KClass
 import kotlin.reflect.KProperty
 
 /**
- * A central registry for managing and resolving dependencies within a dependency injection context.
+ * Combined abstraction for dependency provider and resolver.
  *
- * The `DependencyRegistry` class acts as both a `DependencyProvider` and a `DependencyResolver`.
- * It facilitates the registration of dependencies through a `DependencyProvider` as well as the resolution
- * and validation of dependencies using the provided resolver mechanism. This registry also supports
- * reflective creation of instances and type-safe access to registered dependencies.
- *
- * @param provider The internal provider responsible for managing dependency initializers.
- * @param external A map of externally provided dependencies that can be used during resolution.
- * @param resolution The resolution mechanism used to create new instances of the `DependencyResolver`.
- * @param reflection A reflection implementation that supports dynamic instantiation of classes.
+ * This is a stateful type that can verify that all required dependencies can be resolved.
  */
 @KtorDsl
-public class DependencyRegistry(
+public interface DependencyRegistry : DependencyProvider, DependencyResolver {
+
+    /**
+     * Indicates that the given dependency is required.
+     *
+     * This is ensured after `validate()` is called.
+     */
+    public fun require(key: DependencyKey)
+
+    /**
+     * Performs resolutions, ensuring there are no missing dependencies.
+     *
+     * @throws DependencyInjectionException if there are invalid references in the configuration
+     */
+    public fun validate()
+}
+
+public var Application.dependencies: DependencyRegistry
+    get() {
+        if (!attributes.contains(DependencyRegistryKey)) {
+            install(DI)
+        }
+        return attributes[DependencyRegistryKey]
+    }
+    set(value) {
+        attributes.put(DependencyRegistryKey, value)
+    }
+
+/**
+ * Basic implementation of [DependencyRegistry], which is a façade of [DependencyProvider] and a late-initialized
+ * [DependencyResolver].  The resolver is available after the first call to a get function is made, which triggers the
+ * [DependencyResolution] process to populate the instances.
+ */
+public class DependencyRegistryImpl(
     private val provider: DependencyProvider,
     private val external: DependencyMap,
     private val resolution: DependencyResolution,
     public override val reflection: DependencyReflection,
-) : DependencyProvider by provider, DependencyResolver {
+) : DependencyRegistry, DependencyProvider by provider {
 
     private val requiredKeys = mutableSetOf<DependencyKey>()
     private val resolver: Lazy<DependencyResolver> = lazy {
@@ -52,98 +76,44 @@ public class DependencyRegistry(
     override fun <T> getOrPut(key: DependencyKey, defaultValue: () -> T): T =
         resolver.value.getOrPut(key, defaultValue)
 
-    /**
-     * Indicates that the given dependency is required.
-     *
-     * This is ensured after `validate()` is called.
-     */
-    public fun require(key: DependencyKey) {
+    override fun require(key: DependencyKey) {
         requiredKeys += key
     }
 
-    /**
-     * Performs resolutions, ensuring there are no missing dependencies.
-     *
-     * @throws DependencyInjectionException if there are invalid references in the configuration
-     */
-    public fun validate() {
+    override fun validate() {
         for (key in requiredKeys) {
             resolver.value.get<Any>(key)
         }
     }
-
-    /**
-     * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
-     */
-    public inline fun <reified T> resolve(key: String? = null): T =
-        get(DependencyKey(typeInfo<T>(), key))
-
-    /**
-     * Provides a delegated property for accessing a dependency from a [DependencyRegistry].
-     * This operator function allows property delegation, ensuring the required dependency is
-     * registered and retrievable through the registry.
-     *
-     * Example usage:
-     * ```
-     * val repository: Repository<Message> by dependencies
-     * ```
-     *
-     * @param thisRef The receiver to which the property is being delegated. This parameter
-     * is not used in the actual implementation.
-     * @param prop The property for which the delegate is being requested.
-     * @return A [ReadOnlyProperty] that provides access to the resolved dependency of type [T].
-     * @throws DependencyInjectionException If the dependency required by [prop] is not resolvable
-     * during access.
-     */
-    public inline operator fun <reified T> provideDelegate(
-        thisRef: Any?,
-        prop: KProperty<*>
-    ): ReadOnlyProperty<Any?, T> {
-        val key = DependencyKey(typeInfo<T>())
-            .also(::require)
-        return ReadOnlyProperty { _, _ ->
-            get(key)
-        }
-    }
-
-    /**
-     * Provides an instance of the dependency associated with the specified [kClass].
-     *
-     * Uses the `create` method from the `DependencyResolver` to resolve and instantiate a dependency
-     * of type [T] specified by the given [kClass].
-     *
-     * @param T The type of the dependency to be provided.
-     * @param kClass The `KClass` representing the type of the dependency to be created or resolved.
-     */
-    public inline fun <reified T : Any> DependencyProvider.provide(kClass: KClass<out T>) {
-        provide<T> { create(kClass) }
-    }
-
-    /**
-     * Basic call for providing a dependency, like `provide<Service> { ServiceImpl() }`.
-     */
-    public inline fun <reified T> provide(name: String? = null, noinline provide: DependencyResolver.() -> T) {
-        set(DependencyKey(typeInfo<T>(), name), provide)
-    }
 }
 
 /**
- * DSL helper for declaring dependencies with `dependencies {}` block.
+ * Provides a delegated property for accessing a dependency from a [DependencyRegistry].
+ * This operator function allows property delegation, ensuring the required dependency is
+ * registered and retrievable through the registry.
+ *
+ * Example usage:
+ * ```
+ * val repository: Repository<Message> by dependencies
+ * ```
+ *
+ * @param thisRef The receiver to which the property is being delegated. This parameter
+ * is not used in the actual implementation.
+ * @param prop The property for which the delegate is being requested.
+ * @return A [ReadOnlyProperty] that provides access to the resolved dependency of type [T].
+ * @throws DependencyInjectionException If the dependency required by [prop] is not resolvable
+ * during access.
  */
-@KtorDsl
-public fun <T> Application.dependencies(action: DependencyRegistry.() -> T): T =
-    dependencies.action()
-
-public var Application.dependencies: DependencyRegistry
-    get() {
-        if (!attributes.contains(DependencyRegistryKey)) {
-            install(DI)
-        }
-        return attributes[DependencyRegistryKey]
-    }
-    set(value) {
-        attributes.put(DependencyRegistryKey, value)
+public inline operator fun <reified T> DependencyRegistry.provideDelegate(
+    thisRef: Any?,
+    prop: KProperty<*>
+): ReadOnlyProperty<Any?, T> {
+    val key = DependencyKey(typeInfo<T>())
+        .also(::require)
+    return ReadOnlyProperty { _, _ ->
+        this@provideDelegate.get(key)
     }
+}
 
 /**
  * Standard [DependencyResolution] implementation, which populates a map of instances using
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
index 4f283fe69..0a1943968 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
@@ -107,14 +107,6 @@ public interface MutableDependencyMap : DependencyMap {
  */
 public interface DependencyResolver : MutableDependencyMap {
     public val reflection: DependencyReflection
-
-    /**
-     * Decorates the dependency resolver with a qualified name for the expected type.
-     *
-     * Useful with delegation when used like: `val connection by dependencies.named("postgres")`
-     */
-    public fun named(key: String): DependencyResolverContext =
-        DependencyResolverContext(this, key)
 }
 
 /**
@@ -158,6 +150,20 @@ public class DependencyMapImpl(
         }
 }
 
+/**
+ * Retrieves the dependency associated with the given key from the dependency map, or returns `null` if no dependency
+ * is associated with the key.
+ *
+ * @param key the unique key that identifies the dependency to retrieve
+ * @return the dependency instance associated with the given key, or `null` if the key is not present
+ */
+public fun <T> DependencyMap.getOrNull(key: DependencyKey): T? =
+    if (contains(key)) {
+        get(key)
+    } else {
+        null
+    }
+
 /**
  * Combines two `DependencyMap`s into one.
  *
@@ -169,12 +175,6 @@ public class DependencyMapImpl(
 public operator fun DependencyMap.plus(right: DependencyMap): DependencyMap =
     MergedDependencyMap(this, right)
 
-/**
- * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
- */
-public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
-    get(DependencyKey(typeInfo<T>(), key))
-
 internal class MergedDependencyMap(
     private val left: DependencyMap,
     private val right: DependencyMap,
@@ -214,22 +214,30 @@ public class ConfigurationDependencyMap(
         }
 }
 
+/**
+ * Decorates the dependency resolver with a qualified name for the expected type.
+ *
+ * Useful with delegation when used like: `val connection by dependencies.named("postgres")`
+ */
+public fun DependencyResolver.named(key: String) =
+    DependencyResolverContext(this, key)
+
+/**
+ * Property delegation for [DependencyResolverContext] for use with the `named` shorthand for string qualifiers.
+ */
+public inline operator fun <reified T> DependencyResolverContext.getValue(thisRef: Any?, property: KProperty<*>): T =
+    resolver.resolve(key)
+
 /**
  * Context for property delegation with chaining (i.e., `dependencies.named("foo")`)
  */
 public data class DependencyResolverContext(
     val resolver: DependencyResolver,
-    val name: String,
-) {
-    /**
-     * Property delegation for [DependencyResolverContext] for use with the `named` shorthand for string qualifiers.
-     */
-    public inline operator fun <reified T> getValue(thisRef: Any?, property: KProperty<*>): T =
-        resolver.resolve(name)
+    val key: String,
+)
 
-    /**
-     * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
-     */
-    public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
-        get(DependencyKey(typeInfo<T>(), key))
-}
+/**
+ * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
+ */
+public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
+    get(DependencyKey(typeInfo<T>(), key))
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt
index 7f14b4372..0cd37a918 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt
@@ -7,7 +7,6 @@ package io.ktor.server.plugins.di
 import io.ktor.client.request.get
 import io.ktor.client.statement.bodyAsText
 import io.ktor.server.application.*
-import io.ktor.server.plugins.di.dependencies
 import io.ktor.server.response.respondText
 import io.ktor.server.routing.*
 import io.ktor.server.testing.*
@@ -262,7 +261,7 @@ class DependencyInjectionTest {
     fun `custom provider`() = testApplication {
         val assignmentKeys = mutableListOf<DependencyKey>()
         install(DI) {
-            val delegate = MapDependencyProvider()
+            var delegate = MapDependencyProvider()
             provider = object : DependencyProvider by delegate {
                 override fun <T> set(
                     key: DependencyKey,
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
index dbaa02735..7d4ad34da 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
@@ -5,7 +5,6 @@
 package io.ktor.server.plugins.di.utils
 
 import io.ktor.server.application.*
-import io.ktor.server.config.ApplicationConfig
 import io.ktor.server.plugins.di.*
 import io.ktor.util.reflect.*
 import kotlin.reflect.full.starProjectedType
@@ -48,14 +47,10 @@ internal actual fun Application.installReference(
                         reflection.mapParameters(function.parameters) { param ->
                             when (param.type) {
                                 // special types, from application
-                                DependencyRegistry::class.starProjectedType -> registry
-                                DependencyMap::class.starProjectedType,
                                 DependencyResolver::class.starProjectedType -> this@set
-                                Application::class.starProjectedType -> this@installReference
                                 ApplicationEnvironment::class.starProjectedType -> environment
-                                ApplicationConfig::class.starProjectedType -> environment.config
                                 // regular types, from resolver
-                                else -> this.get(reflection.toDependencyKey(param))
+                                else -> this.get<Any>(reflection.toDependencyKey(param))
                             }
                         }
                     )
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt
index 907fd2ad7..2d412b477 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt
@@ -62,9 +62,9 @@ class DependencyInjectionJvmTest {
     @Test
     fun `circular references from create`() = runTestDI {
         dependencies {
-            provide<WorkExperience> { WorkExperience(resolve()) }
-            provide<PaidWork> { PaidWork(resolve()) }
-            provide<List<PaidWork>> { listOf(resolve()) }
+            provide<WorkExperience> { WorkExperience(this.resolve()) }
+            provide<PaidWork> { PaidWork(this.resolve()) }
+            provide<List<PaidWork>> { listOf(this.resolve()) }
         }
 
         assertFailsWith<CircularDependencyException> {
@@ -226,7 +226,7 @@ class DependencyInjectionJvmTest {
         testConfigFile(
             ::createGreetingService.qualifiedName,
             ::createBankService.qualifiedName,
-            DependencyRegistry::createBankTellerNoArgs.qualifiedName,
+            DependencyResolver::createBankTellerNoArgs.qualifiedName,
         ) {
             val teller: BankTeller by dependencies
             assertEquals(HELLO, teller.hello())
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionTestModules.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionTestModules.kt
index 47bab3947..798c84356 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionTestModules.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionTestModules.kt
@@ -15,7 +15,7 @@ internal fun createGreetingService(): GreetingService =
 internal fun createBankService(): BankService =
     BankServiceImpl()
 
-internal fun DependencyRegistry.createBankTellerNoArgs(): BankTeller =
+internal fun DependencyResolver.createBankTellerNoArgs(): BankTeller =
     BankTeller(resolve(), resolve())
 
 internal fun createBankTellerWithArgs(
@@ -25,10 +25,10 @@ internal fun createBankTellerWithArgs(
 
 internal fun createBankTellerWithLogging(
     environment: ApplicationEnvironment,
-    registry: DependencyRegistry,
+    resolver: DependencyResolver,
 ): BankTeller {
     environment.log.info("Creating BankTeller with environment argument")
-    return BankTeller(BankGreetingService(), registry.resolve())
+    return BankTeller(BankGreetingService(), resolver.resolve())
 }
 
 internal fun createBankTellerWithNullables(
