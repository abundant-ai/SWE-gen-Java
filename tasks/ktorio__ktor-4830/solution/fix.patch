diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
index 0ae983de3..0bbfe92ab 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
@@ -192,15 +192,8 @@ public abstract interface class io/ktor/server/plugins/di/DependencyProvider {
 	public abstract fun set (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function1;)V
 }
 
-public final class io/ktor/server/plugins/di/DependencyProviderContext : io/ktor/server/plugins/di/DependencyProvider {
-	public fun <init> (Lio/ktor/server/plugins/di/DependencyProvider;)V
-	public fun getDeclarations ()Ljava/util/Map;
-	public fun set (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function1;)V
-}
-
 public final class io/ktor/server/plugins/di/DependencyProviderKt {
 	public static final fun ifImplicit (Lio/ktor/server/plugins/di/DependencyCreateFunction;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
-	public static final fun invoke (Lio/ktor/server/plugins/di/DependencyProvider;Lkotlin/jvm/functions/Function1;)V
 }
 
 public abstract interface class io/ktor/server/plugins/di/DependencyReflection {
@@ -215,24 +208,21 @@ public class io/ktor/server/plugins/di/DependencyReflectionJvm : io/ktor/server/
 	public fun toDependencyKey (Lkotlin/reflect/KParameter;)Lio/ktor/server/plugins/di/DependencyKey;
 }
 
-public abstract interface class io/ktor/server/plugins/di/DependencyRegistry : io/ktor/server/plugins/di/DependencyProvider, io/ktor/server/plugins/di/DependencyResolver {
-	public abstract fun require (Lio/ktor/server/plugins/di/DependencyKey;)V
-	public abstract fun validate ()V
-}
-
-public final class io/ktor/server/plugins/di/DependencyRegistryImpl : io/ktor/server/plugins/di/DependencyProvider, io/ktor/server/plugins/di/DependencyRegistry {
+public final class io/ktor/server/plugins/di/DependencyRegistry : io/ktor/server/plugins/di/DependencyProvider, io/ktor/server/plugins/di/DependencyResolver {
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyProvider;Lio/ktor/server/plugins/di/DependencyMap;Lio/ktor/server/plugins/di/DependencyResolution;Lio/ktor/server/plugins/di/DependencyReflection;)V
 	public fun contains (Lio/ktor/server/plugins/di/DependencyKey;)Z
 	public fun get (Lio/ktor/server/plugins/di/DependencyKey;)Ljava/lang/Object;
 	public fun getDeclarations ()Ljava/util/Map;
 	public fun getOrPut (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
 	public fun getReflection ()Lio/ktor/server/plugins/di/DependencyReflection;
-	public fun require (Lio/ktor/server/plugins/di/DependencyKey;)V
+	public fun named (Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
+	public final fun require (Lio/ktor/server/plugins/di/DependencyKey;)V
 	public fun set (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function1;)V
-	public fun validate ()V
+	public final fun validate ()V
 }
 
 public final class io/ktor/server/plugins/di/DependencyRegistryKt {
+	public static final fun dependencies (Lio/ktor/server/application/Application;Lkotlin/jvm/functions/Function1;)Ljava/lang/Object;
 	public static final fun getDefaultDependencyResolution ()Lio/ktor/server/plugins/di/DependencyResolution;
 	public static final fun getDependencies (Lio/ktor/server/application/Application;)Lio/ktor/server/plugins/di/DependencyRegistry;
 	public static final fun setDependencies (Lio/ktor/server/application/Application;Lio/ktor/server/plugins/di/DependencyRegistry;)V
@@ -243,13 +233,16 @@ public abstract interface class io/ktor/server/plugins/di/DependencyResolution {
 }
 
 public final class io/ktor/server/plugins/di/DependencyResolutionKt {
-	public static final fun getOrNull (Lio/ktor/server/plugins/di/DependencyMap;Lio/ktor/server/plugins/di/DependencyKey;)Ljava/lang/Object;
-	public static final fun named (Lio/ktor/server/plugins/di/DependencyResolver;Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 	public static final fun plus (Lio/ktor/server/plugins/di/DependencyMap;Lio/ktor/server/plugins/di/DependencyMap;)Lio/ktor/server/plugins/di/DependencyMap;
 }
 
 public abstract interface class io/ktor/server/plugins/di/DependencyResolver : io/ktor/server/plugins/di/MutableDependencyMap {
 	public abstract fun getReflection ()Lio/ktor/server/plugins/di/DependencyReflection;
+	public abstract fun named (Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
+}
+
+public final class io/ktor/server/plugins/di/DependencyResolver$DefaultImpls {
+	public static fun named (Lio/ktor/server/plugins/di/DependencyResolver;Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 }
 
 public final class io/ktor/server/plugins/di/DependencyResolverContext {
@@ -259,7 +252,7 @@ public final class io/ktor/server/plugins/di/DependencyResolverContext {
 	public final fun copy (Lio/ktor/server/plugins/di/DependencyResolver;Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 	public static synthetic fun copy$default (Lio/ktor/server/plugins/di/DependencyResolverContext;Lio/ktor/server/plugins/di/DependencyResolver;Ljava/lang/String;ILjava/lang/Object;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 	public fun equals (Ljava/lang/Object;)Z
-	public final fun getKey ()Ljava/lang/String;
+	public final fun getName ()Ljava/lang/String;
 	public final fun getResolver ()Lio/ktor/server/plugins/di/DependencyResolver;
 	public fun hashCode ()I
 	public fun toString ()Ljava/lang/String;
@@ -329,6 +322,7 @@ public final class io/ktor/server/plugins/di/ProcessingDependencyResolver : io/k
 	public fun get (Lio/ktor/server/plugins/di/DependencyKey;)Ljava/lang/Object;
 	public fun getOrPut (Lio/ktor/server/plugins/di/DependencyKey;Lkotlin/jvm/functions/Function0;)Ljava/lang/Object;
 	public fun getReflection ()Lio/ktor/server/plugins/di/DependencyReflection;
+	public fun named (Ljava/lang/String;)Lio/ktor/server/plugins/di/DependencyResolverContext;
 	public final fun resolveAll ()Ljava/util/Map;
 }
 
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
index f294d3355..0868ba65c 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
@@ -53,14 +53,11 @@ abstract interface io.ktor.server.plugins.di/DependencyReflection { // io.ktor.s
     abstract fun <#A1: kotlin/Any> create(kotlin.reflect/KClass<#A1>, kotlin/Function1<io.ktor.server.plugins.di/DependencyKey, kotlin/Any>): #A1 // io.ktor.server.plugins.di/DependencyReflection.create|create(kotlin.reflect.KClass<0:0>;kotlin.Function1<io.ktor.server.plugins.di.DependencyKey,kotlin.Any>){0§<kotlin.Any>}[0]
 }
 
-abstract interface io.ktor.server.plugins.di/DependencyRegistry : io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyResolver { // io.ktor.server.plugins.di/DependencyRegistry|null[0]
-    abstract fun require(io.ktor.server.plugins.di/DependencyKey) // io.ktor.server.plugins.di/DependencyRegistry.require|require(io.ktor.server.plugins.di.DependencyKey){}[0]
-    abstract fun validate() // io.ktor.server.plugins.di/DependencyRegistry.validate|validate(){}[0]
-}
-
 abstract interface io.ktor.server.plugins.di/DependencyResolver : io.ktor.server.plugins.di/MutableDependencyMap { // io.ktor.server.plugins.di/DependencyResolver|null[0]
     abstract val reflection // io.ktor.server.plugins.di/DependencyResolver.reflection|{}reflection[0]
         abstract fun <get-reflection>(): io.ktor.server.plugins.di/DependencyReflection // io.ktor.server.plugins.di/DependencyResolver.reflection.<get-reflection>|<get-reflection>(){}[0]
+
+    open fun named(kotlin/String): io.ktor.server.plugins.di/DependencyResolverContext // io.ktor.server.plugins.di/DependencyResolver.named|named(kotlin.String){}[0]
 }
 
 abstract interface io.ktor.server.plugins.di/MutableDependencyMap : io.ktor.server.plugins.di/DependencyMap { // io.ktor.server.plugins.di/MutableDependencyMap|null[0]
@@ -223,36 +220,31 @@ final class io.ktor.server.plugins.di/DependencyMapImpl : io.ktor.server.plugins
     final fun contains(io.ktor.server.plugins.di/DependencyKey): kotlin/Boolean // io.ktor.server.plugins.di/DependencyMapImpl.contains|contains(io.ktor.server.plugins.di.DependencyKey){}[0]
 }
 
-final class io.ktor.server.plugins.di/DependencyProviderContext : io.ktor.server.plugins.di/DependencyProvider { // io.ktor.server.plugins.di/DependencyProviderContext|null[0]
-    constructor <init>(io.ktor.server.plugins.di/DependencyProvider) // io.ktor.server.plugins.di/DependencyProviderContext.<init>|<init>(io.ktor.server.plugins.di.DependencyProvider){}[0]
-
-    final val declarations // io.ktor.server.plugins.di/DependencyProviderContext.declarations|{}declarations[0]
-        final fun <get-declarations>(): kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/DependencyProviderContext.declarations.<get-declarations>|<get-declarations>(){}[0]
-
-    final fun <#A1: kotlin/Any?> set(io.ktor.server.plugins.di/DependencyKey, kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1>) // io.ktor.server.plugins.di/DependencyProviderContext.set|set(io.ktor.server.plugins.di.DependencyKey;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
-}
-
-final class io.ktor.server.plugins.di/DependencyRegistryImpl : io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyRegistry { // io.ktor.server.plugins.di/DependencyRegistryImpl|null[0]
-    constructor <init>(io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyMap, io.ktor.server.plugins.di/DependencyResolution, io.ktor.server.plugins.di/DependencyReflection) // io.ktor.server.plugins.di/DependencyRegistryImpl.<init>|<init>(io.ktor.server.plugins.di.DependencyProvider;io.ktor.server.plugins.di.DependencyMap;io.ktor.server.plugins.di.DependencyResolution;io.ktor.server.plugins.di.DependencyReflection){}[0]
+final class io.ktor.server.plugins.di/DependencyRegistry : io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyResolver { // io.ktor.server.plugins.di/DependencyRegistry|null[0]
+    constructor <init>(io.ktor.server.plugins.di/DependencyProvider, io.ktor.server.plugins.di/DependencyMap, io.ktor.server.plugins.di/DependencyResolution, io.ktor.server.plugins.di/DependencyReflection) // io.ktor.server.plugins.di/DependencyRegistry.<init>|<init>(io.ktor.server.plugins.di.DependencyProvider;io.ktor.server.plugins.di.DependencyMap;io.ktor.server.plugins.di.DependencyResolution;io.ktor.server.plugins.di.DependencyReflection){}[0]
 
-    final val declarations // io.ktor.server.plugins.di/DependencyRegistryImpl.declarations|{}declarations[0]
-        final fun <get-declarations>(): kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/DependencyRegistryImpl.declarations.<get-declarations>|<get-declarations>(){}[0]
-    final val reflection // io.ktor.server.plugins.di/DependencyRegistryImpl.reflection|{}reflection[0]
-        final fun <get-reflection>(): io.ktor.server.plugins.di/DependencyReflection // io.ktor.server.plugins.di/DependencyRegistryImpl.reflection.<get-reflection>|<get-reflection>(){}[0]
+    final val declarations // io.ktor.server.plugins.di/DependencyRegistry.declarations|{}declarations[0]
+        final fun <get-declarations>(): kotlin.collections/Map<io.ktor.server.plugins.di/DependencyKey, io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/DependencyRegistry.declarations.<get-declarations>|<get-declarations>(){}[0]
+    final val reflection // io.ktor.server.plugins.di/DependencyRegistry.reflection|{}reflection[0]
+        final fun <get-reflection>(): io.ktor.server.plugins.di/DependencyReflection // io.ktor.server.plugins.di/DependencyRegistry.reflection.<get-reflection>|<get-reflection>(){}[0]
 
-    final fun <#A1: kotlin/Any?> get(io.ktor.server.plugins.di/DependencyKey): #A1 // io.ktor.server.plugins.di/DependencyRegistryImpl.get|get(io.ktor.server.plugins.di.DependencyKey){0§<kotlin.Any?>}[0]
-    final fun <#A1: kotlin/Any?> getOrPut(io.ktor.server.plugins.di/DependencyKey, kotlin/Function0<#A1>): #A1 // io.ktor.server.plugins.di/DependencyRegistryImpl.getOrPut|getOrPut(io.ktor.server.plugins.di.DependencyKey;kotlin.Function0<0:0>){0§<kotlin.Any?>}[0]
-    final fun <#A1: kotlin/Any?> set(io.ktor.server.plugins.di/DependencyKey, kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1>) // io.ktor.server.plugins.di/DependencyRegistryImpl.set|set(io.ktor.server.plugins.di.DependencyKey;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
-    final fun contains(io.ktor.server.plugins.di/DependencyKey): kotlin/Boolean // io.ktor.server.plugins.di/DependencyRegistryImpl.contains|contains(io.ktor.server.plugins.di.DependencyKey){}[0]
-    final fun require(io.ktor.server.plugins.di/DependencyKey) // io.ktor.server.plugins.di/DependencyRegistryImpl.require|require(io.ktor.server.plugins.di.DependencyKey){}[0]
-    final fun validate() // io.ktor.server.plugins.di/DependencyRegistryImpl.validate|validate(){}[0]
+    final fun <#A1: kotlin/Any?> get(io.ktor.server.plugins.di/DependencyKey): #A1 // io.ktor.server.plugins.di/DependencyRegistry.get|get(io.ktor.server.plugins.di.DependencyKey){0§<kotlin.Any?>}[0]
+    final fun <#A1: kotlin/Any?> getOrPut(io.ktor.server.plugins.di/DependencyKey, kotlin/Function0<#A1>): #A1 // io.ktor.server.plugins.di/DependencyRegistry.getOrPut|getOrPut(io.ktor.server.plugins.di.DependencyKey;kotlin.Function0<0:0>){0§<kotlin.Any?>}[0]
+    final fun <#A1: kotlin/Any?> set(io.ktor.server.plugins.di/DependencyKey, kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1>) // io.ktor.server.plugins.di/DependencyRegistry.set|set(io.ktor.server.plugins.di.DependencyKey;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
+    final fun contains(io.ktor.server.plugins.di/DependencyKey): kotlin/Boolean // io.ktor.server.plugins.di/DependencyRegistry.contains|contains(io.ktor.server.plugins.di.DependencyKey){}[0]
+    final fun require(io.ktor.server.plugins.di/DependencyKey) // io.ktor.server.plugins.di/DependencyRegistry.require|require(io.ktor.server.plugins.di.DependencyKey){}[0]
+    final fun validate() // io.ktor.server.plugins.di/DependencyRegistry.validate|validate(){}[0]
+    final inline fun <#A1: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyProvider).provide(kotlin.reflect/KClass<out #A1>) // io.ktor.server.plugins.di/DependencyRegistry.provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
+    final inline fun <#A1: reified kotlin/Any?> provide(kotlin/String? = ..., noinline kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A1>) // io.ktor.server.plugins.di/DependencyRegistry.provide|provide(kotlin.String?;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
+    final inline fun <#A1: reified kotlin/Any?> provideDelegate(kotlin/Any?, kotlin.reflect/KProperty<*>): kotlin.properties/ReadOnlyProperty<kotlin/Any?, #A1> // io.ktor.server.plugins.di/DependencyRegistry.provideDelegate|provideDelegate(kotlin.Any?;kotlin.reflect.KProperty<*>){0§<kotlin.Any?>}[0]
+    final inline fun <#A1: reified kotlin/Any?> resolve(kotlin/String? = ...): #A1 // io.ktor.server.plugins.di/DependencyRegistry.resolve|resolve(kotlin.String?){0§<kotlin.Any?>}[0]
 }
 
 final class io.ktor.server.plugins.di/DependencyResolverContext { // io.ktor.server.plugins.di/DependencyResolverContext|null[0]
     constructor <init>(io.ktor.server.plugins.di/DependencyResolver, kotlin/String) // io.ktor.server.plugins.di/DependencyResolverContext.<init>|<init>(io.ktor.server.plugins.di.DependencyResolver;kotlin.String){}[0]
 
-    final val key // io.ktor.server.plugins.di/DependencyResolverContext.key|{}key[0]
-        final fun <get-key>(): kotlin/String // io.ktor.server.plugins.di/DependencyResolverContext.key.<get-key>|<get-key>(){}[0]
+    final val name // io.ktor.server.plugins.di/DependencyResolverContext.name|{}name[0]
+        final fun <get-name>(): kotlin/String // io.ktor.server.plugins.di/DependencyResolverContext.name.<get-name>|<get-name>(){}[0]
     final val resolver // io.ktor.server.plugins.di/DependencyResolverContext.resolver|{}resolver[0]
         final fun <get-resolver>(): io.ktor.server.plugins.di/DependencyResolver // io.ktor.server.plugins.di/DependencyResolverContext.resolver.<get-resolver>|<get-resolver>(){}[0]
 
@@ -262,6 +254,8 @@ final class io.ktor.server.plugins.di/DependencyResolverContext { // io.ktor.ser
     final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.server.plugins.di/DependencyResolverContext.equals|equals(kotlin.Any?){}[0]
     final fun hashCode(): kotlin/Int // io.ktor.server.plugins.di/DependencyResolverContext.hashCode|hashCode(){}[0]
     final fun toString(): kotlin/String // io.ktor.server.plugins.di/DependencyResolverContext.toString|toString(){}[0]
+    final inline fun <#A1: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).resolve(kotlin/String? = ...): #A1 // io.ktor.server.plugins.di/DependencyResolverContext.resolve|resolve@io.ktor.server.plugins.di.DependencyMap(kotlin.String?){0§<kotlin.Any?>}[0]
+    final inline fun <#A1: reified kotlin/Any?> getValue(kotlin/Any?, kotlin.reflect/KProperty<*>): #A1 // io.ktor.server.plugins.di/DependencyResolverContext.getValue|getValue(kotlin.Any?;kotlin.reflect.KProperty<*>){0§<kotlin.Any?>}[0]
 }
 
 final class io.ktor.server.plugins.di/DuplicateDependencyException : io.ktor.server.plugins.di/DependencyInjectionException { // io.ktor.server.plugins.di/DuplicateDependencyException|null[0]
@@ -375,17 +369,12 @@ final fun (io.ktor.server.plugins.di/DependencyKey).io.ktor.server.plugins.di/is
 final fun (io.ktor.server.plugins.di/DependencyKeyCovariance).io.ktor.server.plugins.di/plus(io.ktor.server.plugins.di/DependencyKeyCovariance): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/plus|plus@io.ktor.server.plugins.di.DependencyKeyCovariance(io.ktor.server.plugins.di.DependencyKeyCovariance){}[0]
 final fun (io.ktor.server.plugins.di/DependencyKeyCovariance).io.ktor.server.plugins.di/times(io.ktor.server.plugins.di/DependencyKeyCovariance): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/times|times@io.ktor.server.plugins.di.DependencyKeyCovariance(io.ktor.server.plugins.di.DependencyKeyCovariance){}[0]
 final fun (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/plus(io.ktor.server.plugins.di/DependencyMap): io.ktor.server.plugins.di/DependencyMap // io.ktor.server.plugins.di/plus|plus@io.ktor.server.plugins.di.DependencyMap(io.ktor.server.plugins.di.DependencyMap){}[0]
-final fun (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/invoke(kotlin/Function1<io.ktor.server.plugins.di/DependencyProviderContext, kotlin/Unit>) // io.ktor.server.plugins.di/invoke|invoke@io.ktor.server.plugins.di.DependencyProvider(kotlin.Function1<io.ktor.server.plugins.di.DependencyProviderContext,kotlin.Unit>){}[0]
-final fun (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/named(kotlin/String): io.ktor.server.plugins.di/DependencyResolverContext // io.ktor.server.plugins.di/named|named@io.ktor.server.plugins.di.DependencyResolver(kotlin.String){}[0]
 final fun (io.ktor.util.reflect/TypeInfo).io.ktor.server.plugins.di.utils/hierarchy(): kotlin.sequences/Sequence<io.ktor.util.reflect/TypeInfo> // io.ktor.server.plugins.di.utils/hierarchy|hierarchy@io.ktor.util.reflect.TypeInfo(){}[0]
 final fun (io.ktor.util.reflect/TypeInfo).io.ktor.server.plugins.di.utils/toNullable(): io.ktor.util.reflect/TypeInfo? // io.ktor.server.plugins.di.utils/toNullable|toNullable@io.ktor.util.reflect.TypeInfo(){}[0]
 final fun (io.ktor.util.reflect/TypeInfo).io.ktor.server.plugins.di.utils/typeParametersHierarchy(): kotlin.sequences/Sequence<io.ktor.util.reflect/TypeInfo> // io.ktor.server.plugins.di.utils/typeParametersHierarchy|typeParametersHierarchy@io.ktor.util.reflect.TypeInfo(){}[0]
+final fun <#A: kotlin/Any?> (io.ktor.server.application/Application).io.ktor.server.plugins.di/dependencies(kotlin/Function1<io.ktor.server.plugins.di/DependencyRegistry, #A>): #A // io.ktor.server.plugins.di/dependencies|dependencies@io.ktor.server.application.Application(kotlin.Function1<io.ktor.server.plugins.di.DependencyRegistry,0:0>){0§<kotlin.Any?>}[0]
 final fun <#A: kotlin/Any?> (io.ktor.server.plugins.di/DependencyCreateFunction).io.ktor.server.plugins.di/ifImplicit(kotlin/Function1<io.ktor.server.plugins.di/ImplicitCreateFunction, #A>): #A? // io.ktor.server.plugins.di/ifImplicit|ifImplicit@io.ktor.server.plugins.di.DependencyCreateFunction(kotlin.Function1<io.ktor.server.plugins.di.ImplicitCreateFunction,0:0>){0§<kotlin.Any?>}[0]
-final fun <#A: kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/getOrNull(io.ktor.server.plugins.di/DependencyKey): #A? // io.ktor.server.plugins.di/getOrNull|getOrNull@io.ktor.server.plugins.di.DependencyMap(io.ktor.server.plugins.di.DependencyKey){0§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/provide(kotlin.reflect/KClass<out #A>) // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
 final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/create(): #A // io.ktor.server.plugins.di/create|create@io.ktor.server.plugins.di.DependencyResolver(){0§<kotlin.Any>}[0]
 final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/create(kotlin.reflect/KClass<out #A>): #A // io.ktor.server.plugins.di/create|create@io.ktor.server.plugins.di.DependencyResolver(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/resolve(kotlin/String? = ...): #A // io.ktor.server.plugins.di/resolve|resolve@io.ktor.server.plugins.di.DependencyMap(kotlin.String?){0§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/provide(kotlin/String? = ..., noinline kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A>) // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.String?;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0>){0§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideDelegate(kotlin/Any?, kotlin.reflect/KProperty<*>): kotlin.properties/ReadOnlyProperty<kotlin/Any?, #A> // io.ktor.server.plugins.di/provideDelegate|provideDelegate@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Any?;kotlin.reflect.KProperty<*>){0§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyResolverContext).io.ktor.server.plugins.di/getValue(kotlin/Any?, kotlin.reflect/KProperty<*>): #A // io.ktor.server.plugins.di/getValue|getValue@io.ktor.server.plugins.di.DependencyResolverContext(kotlin.Any?;kotlin.reflect.KProperty<*>){0§<kotlin.Any?>}[0]
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
index 2464fce9d..6dc474fac 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
@@ -68,7 +68,7 @@ public val DI: ApplicationPlugin<DependencyInjectionConfig> =
         val configMap = ConfigurationDependencyMap(application.environment.config)
         val dependenciesMap = pluginConfig.dependenciesMap?.let { it + configMap } ?: configMap
 
-        var registry = DependencyRegistryImpl(
+        var registry = DependencyRegistry(
             provider,
             dependenciesMap,
             pluginConfig.resolution,
@@ -198,7 +198,6 @@ public data class DependencyKey(
     public val name: String? = null,
     public val qualifier: Any? = null,
 ) {
-
     override fun toString(): String = buildString {
         append(type.kotlinType ?: type.type)
         if (name != null) {
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
index 93756a2ba..c5be8bd07 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
@@ -44,6 +44,16 @@ public interface DependencyProvider {
     public val declarations: Map<DependencyKey, DependencyCreateFunction>
 }
 
+/**
+ * Basic call for providing a dependency, like `provide<Service> { ServiceImpl() }`.
+ */
+public inline fun <reified T> DependencyProvider.provide(
+    name: String? = null,
+    noinline provide: DependencyResolver.() -> T
+) {
+    set(DependencyKey(typeInfo<T>(), name), provide)
+}
+
 /**
  * Wraps the logic for creating a new instance of a dependency.
  *
@@ -234,28 +244,3 @@ public open class MapDependencyProvider(
         }
     }
 }
-
-/**
- * DSL helper for declaring dependencies with `dependencies {}` block.
- */
-@KtorDsl
-public operator fun DependencyProvider.invoke(action: DependencyProviderContext.() -> Unit) {
-    DependencyProviderContext(this).action()
-}
-
-/**
- * Builder context for providing dependencies.
- */
-@KtorDsl
-public class DependencyProviderContext(
-    private val delegate: DependencyProvider
-) : DependencyProvider by delegate
-
-/**
- * Basic call for providing a dependency, like `provide<Service> { ServiceImpl() }`.
- */
-public inline fun <reified T> DependencyProvider.provide(
-    name: String? = null,
-    noinline provide: DependencyResolver.() -> T
-) =
-    set(DependencyKey(typeInfo<T>(), name), provide)
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt
index be210bd38..b2ced8b33 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyReflection.kt
@@ -23,21 +23,9 @@ public interface DependencyReflection {
     public fun <T : Any> create(kClass: KClass<T>, init: (DependencyKey) -> Any): T
 }
 
-/**
- * Provides an instance of the dependency associated with the specified [kClass].
- *
- * Uses the `create` method from the `DependencyResolver` to resolve and instantiate a dependency
- * of type [T] specified by the given [kClass].
- *
- * @param T The type of the dependency to be provided.
- * @param kClass The `KClass` representing the type of the dependency to be created or resolved.
- */
-public inline fun <reified T : Any> DependencyProvider.provide(kClass: KClass<out T>) =
-    provide { create(kClass) }
-
 /**
  * Creates an instance of the specified type [T] using the dependency resolver.
- * This function utilizes the `DependencyReflection` mechanism to dynamically
+ * This function uses the `DependencyReflection` mechanism to dynamically
  * construct an instance of the requested type, resolving dependencies as needed.
  *
  * @return An instance of the type [T].
@@ -53,5 +41,5 @@ public inline fun <reified T : Any> DependencyResolver.create(): T =
  * @param kClass The class reference representing the type of object to create or retrieve.
  * @return An instance of the specified type [T].
  */
-public inline fun <reified T : Any> DependencyResolver.create(kClass: KClass<out T>) =
+public inline fun <reified T : Any> DependencyResolver.create(kClass: KClass<out T>): T =
     getOrPut(DependencyKey(typeInfo<T>())) { reflection.create(kClass, ::get) }
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
index 0d05593ac..f10f82a98 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
@@ -9,53 +9,29 @@ import io.ktor.server.plugins.di.MutableDependencyMap.Companion.asResolver
 import io.ktor.util.reflect.typeInfo
 import io.ktor.utils.io.*
 import kotlin.properties.ReadOnlyProperty
+import kotlin.reflect.KClass
 import kotlin.reflect.KProperty
 
 /**
- * Combined abstraction for dependency provider and resolver.
+ * A central registry for managing and resolving dependencies within a dependency injection context.
  *
- * This is a stateful type that can verify that all required dependencies can be resolved.
+ * The `DependencyRegistry` class acts as both a `DependencyProvider` and a `DependencyResolver`.
+ * It facilitates the registration of dependencies through a `DependencyProvider` as well as the resolution
+ * and validation of dependencies using the provided resolver mechanism. This registry also supports
+ * reflective creation of instances and type-safe access to registered dependencies.
+ *
+ * @param provider The internal provider responsible for managing dependency initializers.
+ * @param external A map of externally provided dependencies that can be used during resolution.
+ * @param resolution The resolution mechanism used to create new instances of the `DependencyResolver`.
+ * @param reflection A reflection implementation that supports dynamic instantiation of classes.
  */
 @KtorDsl
-public interface DependencyRegistry : DependencyProvider, DependencyResolver {
-
-    /**
-     * Indicates that the given dependency is required.
-     *
-     * This is ensured after `validate()` is called.
-     */
-    public fun require(key: DependencyKey)
-
-    /**
-     * Performs resolutions, ensuring there are no missing dependencies.
-     *
-     * @throws DependencyInjectionException if there are invalid references in the configuration
-     */
-    public fun validate()
-}
-
-public var Application.dependencies: DependencyRegistry
-    get() {
-        if (!attributes.contains(DependencyRegistryKey)) {
-            install(DI)
-        }
-        return attributes[DependencyRegistryKey]
-    }
-    set(value) {
-        attributes.put(DependencyRegistryKey, value)
-    }
-
-/**
- * Basic implementation of [DependencyRegistry], which is a façade of [DependencyProvider] and a late-initialized
- * [DependencyResolver].  The resolver is available after the first call to a get function is made, which triggers the
- * [DependencyResolution] process to populate the instances.
- */
-public class DependencyRegistryImpl(
+public class DependencyRegistry(
     private val provider: DependencyProvider,
     private val external: DependencyMap,
     private val resolution: DependencyResolution,
     public override val reflection: DependencyReflection,
-) : DependencyRegistry, DependencyProvider by provider {
+) : DependencyProvider by provider, DependencyResolver {
 
     private val requiredKeys = mutableSetOf<DependencyKey>()
     private val resolver: Lazy<DependencyResolver> = lazy {
@@ -76,44 +52,98 @@ public class DependencyRegistryImpl(
     override fun <T> getOrPut(key: DependencyKey, defaultValue: () -> T): T =
         resolver.value.getOrPut(key, defaultValue)
 
-    override fun require(key: DependencyKey) {
+    /**
+     * Indicates that the given dependency is required.
+     *
+     * This is ensured after `validate()` is called.
+     */
+    public fun require(key: DependencyKey) {
         requiredKeys += key
     }
 
-    override fun validate() {
+    /**
+     * Performs resolutions, ensuring there are no missing dependencies.
+     *
+     * @throws DependencyInjectionException if there are invalid references in the configuration
+     */
+    public fun validate() {
         for (key in requiredKeys) {
             resolver.value.get<Any>(key)
         }
     }
+
+    /**
+     * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
+     */
+    public inline fun <reified T> resolve(key: String? = null): T =
+        get(DependencyKey(typeInfo<T>(), key))
+
+    /**
+     * Provides a delegated property for accessing a dependency from a [DependencyRegistry].
+     * This operator function allows property delegation, ensuring the required dependency is
+     * registered and retrievable through the registry.
+     *
+     * Example usage:
+     * ```
+     * val repository: Repository<Message> by dependencies
+     * ```
+     *
+     * @param thisRef The receiver to which the property is being delegated. This parameter
+     * is not used in the actual implementation.
+     * @param prop The property for which the delegate is being requested.
+     * @return A [ReadOnlyProperty] that provides access to the resolved dependency of type [T].
+     * @throws DependencyInjectionException If the dependency required by [prop] is not resolvable
+     * during access.
+     */
+    public inline operator fun <reified T> provideDelegate(
+        thisRef: Any?,
+        prop: KProperty<*>
+    ): ReadOnlyProperty<Any?, T> {
+        val key = DependencyKey(typeInfo<T>())
+            .also(::require)
+        return ReadOnlyProperty { _, _ ->
+            get(key)
+        }
+    }
+
+    /**
+     * Provides an instance of the dependency associated with the specified [kClass].
+     *
+     * Uses the `create` method from the `DependencyResolver` to resolve and instantiate a dependency
+     * of type [T] specified by the given [kClass].
+     *
+     * @param T The type of the dependency to be provided.
+     * @param kClass The `KClass` representing the type of the dependency to be created or resolved.
+     */
+    public inline fun <reified T : Any> DependencyProvider.provide(kClass: KClass<out T>) {
+        provide<T> { create(kClass) }
+    }
+
+    /**
+     * Basic call for providing a dependency, like `provide<Service> { ServiceImpl() }`.
+     */
+    public inline fun <reified T> provide(name: String? = null, noinline provide: DependencyResolver.() -> T) {
+        set(DependencyKey(typeInfo<T>(), name), provide)
+    }
 }
 
 /**
- * Provides a delegated property for accessing a dependency from a [DependencyRegistry].
- * This operator function allows property delegation, ensuring the required dependency is
- * registered and retrievable through the registry.
- *
- * Example usage:
- * ```
- * val repository: Repository<Message> by dependencies
- * ```
- *
- * @param thisRef The receiver to which the property is being delegated. This parameter
- * is not used in the actual implementation.
- * @param prop The property for which the delegate is being requested.
- * @return A [ReadOnlyProperty] that provides access to the resolved dependency of type [T].
- * @throws DependencyInjectionException If the dependency required by [prop] is not resolvable
- * during access.
+ * DSL helper for declaring dependencies with `dependencies {}` block.
  */
-public inline operator fun <reified T> DependencyRegistry.provideDelegate(
-    thisRef: Any?,
-    prop: KProperty<*>
-): ReadOnlyProperty<Any?, T> {
-    val key = DependencyKey(typeInfo<T>())
-        .also(::require)
-    return ReadOnlyProperty { _, _ ->
-        this@provideDelegate.get(key)
+@KtorDsl
+public fun <T> Application.dependencies(action: DependencyRegistry.() -> T): T =
+    dependencies.action()
+
+public var Application.dependencies: DependencyRegistry
+    get() {
+        if (!attributes.contains(DependencyRegistryKey)) {
+            install(DI)
+        }
+        return attributes[DependencyRegistryKey]
+    }
+    set(value) {
+        attributes.put(DependencyRegistryKey, value)
     }
-}
 
 /**
  * Standard [DependencyResolution] implementation, which populates a map of instances using
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
index 0a1943968..4f283fe69 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
@@ -107,6 +107,14 @@ public interface MutableDependencyMap : DependencyMap {
  */
 public interface DependencyResolver : MutableDependencyMap {
     public val reflection: DependencyReflection
+
+    /**
+     * Decorates the dependency resolver with a qualified name for the expected type.
+     *
+     * Useful with delegation when used like: `val connection by dependencies.named("postgres")`
+     */
+    public fun named(key: String): DependencyResolverContext =
+        DependencyResolverContext(this, key)
 }
 
 /**
@@ -150,20 +158,6 @@ public class DependencyMapImpl(
         }
 }
 
-/**
- * Retrieves the dependency associated with the given key from the dependency map, or returns `null` if no dependency
- * is associated with the key.
- *
- * @param key the unique key that identifies the dependency to retrieve
- * @return the dependency instance associated with the given key, or `null` if the key is not present
- */
-public fun <T> DependencyMap.getOrNull(key: DependencyKey): T? =
-    if (contains(key)) {
-        get(key)
-    } else {
-        null
-    }
-
 /**
  * Combines two `DependencyMap`s into one.
  *
@@ -175,6 +169,12 @@ public fun <T> DependencyMap.getOrNull(key: DependencyKey): T? =
 public operator fun DependencyMap.plus(right: DependencyMap): DependencyMap =
     MergedDependencyMap(this, right)
 
+/**
+ * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
+ */
+public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
+    get(DependencyKey(typeInfo<T>(), key))
+
 internal class MergedDependencyMap(
     private val left: DependencyMap,
     private val right: DependencyMap,
@@ -214,30 +214,22 @@ public class ConfigurationDependencyMap(
         }
 }
 
-/**
- * Decorates the dependency resolver with a qualified name for the expected type.
- *
- * Useful with delegation when used like: `val connection by dependencies.named("postgres")`
- */
-public fun DependencyResolver.named(key: String) =
-    DependencyResolverContext(this, key)
-
-/**
- * Property delegation for [DependencyResolverContext] for use with the `named` shorthand for string qualifiers.
- */
-public inline operator fun <reified T> DependencyResolverContext.getValue(thisRef: Any?, property: KProperty<*>): T =
-    resolver.resolve(key)
-
 /**
  * Context for property delegation with chaining (i.e., `dependencies.named("foo")`)
  */
 public data class DependencyResolverContext(
     val resolver: DependencyResolver,
-    val key: String,
-)
+    val name: String,
+) {
+    /**
+     * Property delegation for [DependencyResolverContext] for use with the `named` shorthand for string qualifiers.
+     */
+    public inline operator fun <reified T> getValue(thisRef: Any?, property: KProperty<*>): T =
+        resolver.resolve(name)
 
-/**
- * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
- */
-public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
-    get(DependencyKey(typeInfo<T>(), key))
+    /**
+     * Get the dependency from the map for the key represented by the type (and optionally, with the given name).
+     */
+    public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
+        get(DependencyKey(typeInfo<T>(), key))
+}
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
index 7d4ad34da..dbaa02735 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/src/io/ktor/server/plugins/di/utils/ClasspathReference.jvm.kt
@@ -5,6 +5,7 @@
 package io.ktor.server.plugins.di.utils
 
 import io.ktor.server.application.*
+import io.ktor.server.config.ApplicationConfig
 import io.ktor.server.plugins.di.*
 import io.ktor.util.reflect.*
 import kotlin.reflect.full.starProjectedType
@@ -47,10 +48,14 @@ internal actual fun Application.installReference(
                         reflection.mapParameters(function.parameters) { param ->
                             when (param.type) {
                                 // special types, from application
+                                DependencyRegistry::class.starProjectedType -> registry
+                                DependencyMap::class.starProjectedType,
                                 DependencyResolver::class.starProjectedType -> this@set
+                                Application::class.starProjectedType -> this@installReference
                                 ApplicationEnvironment::class.starProjectedType -> environment
+                                ApplicationConfig::class.starProjectedType -> environment.config
                                 // regular types, from resolver
-                                else -> this.get<Any>(reflection.toDependencyKey(param))
+                                else -> this.get(reflection.toDependencyKey(param))
                             }
                         }
                     )
