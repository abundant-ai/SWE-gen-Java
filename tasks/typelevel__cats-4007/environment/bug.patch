diff --git a/core/src/main/scala/cats/Parallel.scala b/core/src/main/scala/cats/Parallel.scala
index bc285641a..5cc12b385 100644
--- a/core/src/main/scala/cats/Parallel.scala
+++ b/core/src/main/scala/cats/Parallel.scala
@@ -426,13 +426,6 @@ object Parallel extends ParallelArityFunctions2 {
       P.apply.ap2(P.parallel(ff))(P.parallel(ma), P.parallel(mb))
     )
 
-  /**
-   * Like `Applicative[F].replicateA`, but uses the apply instance
-   * corresponding to the Parallel instance instead.
-   */
-  def parReplicateA[M[_], A](n: Int, ma: M[A])(implicit P: Parallel[M]): M[List[A]] =
-    P.sequential(P.applicative.replicateA(n, P.parallel(ma)))
-
   /**
    * Provides an `ApplicativeError[F, E]` instance for any F, that has a `Parallel.Aux[M, F]`
    * and a `MonadError[M, E]` instance.
diff --git a/core/src/main/scala/cats/syntax/parallel.scala b/core/src/main/scala/cats/syntax/parallel.scala
index 28a850d20..078909b1b 100644
--- a/core/src/main/scala/cats/syntax/parallel.scala
+++ b/core/src/main/scala/cats/syntax/parallel.scala
@@ -245,9 +245,6 @@ final class ParallelApOps[M[_], A](private val ma: M[A]) extends AnyVal {
 
   def parProduct[B](mb: M[B])(implicit P: Parallel[M]): M[(A, B)] =
     Parallel.parProduct(ma, mb)
-
-  def parReplicateA(n: Int)(implicit P: Parallel[M]): M[List[A]] =
-    Parallel.parReplicateA(n, ma)
 }
 
 final class ParallelApplyOps[M[_], A, B](private val mab: M[A => B]) extends AnyVal {
diff --git a/tests/src/test/scala/cats/tests/ParallelSuite.scala b/tests/src/test/scala/cats/tests/ParallelSuite.scala
index e30fee286..e8d1af5ae 100644
--- a/tests/src/test/scala/cats/tests/ParallelSuite.scala
+++ b/tests/src/test/scala/cats/tests/ParallelSuite.scala
@@ -8,8 +8,6 @@ import cats.laws.discipline.{ApplicativeErrorTests, MiniInt, NonEmptyParallelTes
 import cats.laws.discipline.eq._
 import cats.laws.discipline.arbitrary._
 import cats.implicits._
-import org.scalacheck.{Arbitrary, Gen}
-
 import scala.collection.immutable.SortedSet
 import org.scalacheck.Prop._
 
@@ -268,19 +266,6 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
     assert(Parallel.parAp2(rightPlus)("Hello".asLeft, "World".asLeft) === (Left("HelloWorld")))
   }
 
-  test("ParReplicateA should be equivalent to fill parSequence") {
-    forAll(Gen.choose(1, 20), Arbitrary.arbitrary[Either[String, String]]) {
-      (repetitions: Int, e: Either[String, String]) =>
-        assert(Parallel.parReplicateA(repetitions, e) === Parallel.parSequence(List.fill(repetitions)(e)))
-    }
-  }
-
-  test("ParReplicateA 2 should be equivalent to parMap2 List") {
-    forAll { (e: Either[String, String]) =>
-      assert(Parallel.parReplicateA(2, e) === Parallel.parMap2(e, e)((s1, s2) => List(s1, s2)))
-    }
-  }
-
   test("Kleisli with Either should accumulate errors") {
     val k1: Kleisli[Either[String, *], String, Int] = Kleisli(s => Right(s.length))
     val k2: Kleisli[Either[String, *], String, Int] = Kleisli(s => Left("Boo"))
diff --git a/tests/src/test/scala/cats/tests/SyntaxSuite.scala b/tests/src/test/scala/cats/tests/SyntaxSuite.scala
index 1c637f042..29c0ccfda 100644
--- a/tests/src/test/scala/cats/tests/SyntaxSuite.scala
+++ b/tests/src/test/scala/cats/tests/SyntaxSuite.scala
@@ -184,7 +184,6 @@ object SyntaxSuite {
     val mb4: M[B] = ma.parProductR(mb)
     val mab2: M[(A, B)] = ma.parProduct(mb)
     val mb5: M[B] = mab.parAp(ma)
-    val mla: M[List[A]] = ma.parReplicateA(mock[Int])
   }
 
   def testParallelUnorderedTraverse[M[_]: Monad, F[_]: CommutativeApplicative, T[_]: UnorderedTraverse: FlatMap, A, B](
