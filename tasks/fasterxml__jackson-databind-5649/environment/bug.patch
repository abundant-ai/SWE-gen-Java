diff --git a/release-notes/VERSION b/release-notes/VERSION
index 2c6ee2d57..c8b1a3c4f 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -181,9 +181,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
  (implemented by @pjfanning)
 #5646: `ObjectArrayDeserializer` may throw `ArrayStoreException` for some special cases
  (fixed by @cowtowncoder, w/ Claude code)
-#5649: Wrap `LocalDate.ofEpochDay()` and `Instant.ofEpochSecond()` to throw
-  `DateTimeParseException` on invalid values
- (implemented by @pjfanning)
 
 3.0.4 (not yet released)
 
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java
index 337612a46..ee2061106 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java
@@ -405,20 +405,13 @@ public class InstantDeserializer<T extends Temporal>
 
     protected T _fromLong(DeserializationContext context, long timestamp)
     {
-        try {
-            if(shouldReadTimestampsAsNanoseconds(context)){
-                return fromNanoseconds.apply(new FromDecimalArguments(
-                        timestamp, 0, this.getZone(context)
-                ));
-            }
-            return fromMilliseconds.apply(new FromIntegerArguments(
-                    timestamp, this.getZone(context)));
-        } catch (DateTimeException e) {
-            throw DateTimeParseException.from(context.getParser(),
-                    String.format("Failed to deserialize %s from timestamp value %d: %s",
-                            handledType().getName(), timestamp, e.getMessage()),
-                    String.valueOf(timestamp), handledType(), e);
+        if(shouldReadTimestampsAsNanoseconds(context)){
+            return fromNanoseconds.apply(new FromDecimalArguments(
+                    timestamp, 0, this.getZone(context)
+            ));
         }
+        return fromMilliseconds.apply(new FromIntegerArguments(
+                timestamp, this.getZone(context)));
     }
 
     protected T _fromDecimal(DeserializationContext context, BigDecimal value)
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserializer.java
index e6ca7f84e..a371fc50a 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserializer.java
@@ -141,16 +141,7 @@ public class LocalDateDeserializer extends JSR310DateTimeDeserializerBase<LocalD
 
             // issue 58 - also check for NUMBER_INT, which needs to be specified when serializing.
             if (_shape == JsonFormat.Shape.NUMBER_INT || isLenient()) {
-                long epochDay = p.getLongValue();
-                try {
-                    return LocalDate.ofEpochDay(epochDay);
-                } catch (DateTimeException e) {
-                    throw DateTimeParseException.from(p,
-                            String.format("Failed to deserialize %s from epoch day value %d: %s",
-                                    handledType().getName(), epochDay, e.getMessage()),
-                            String.valueOf(epochDay),
-                            handledType(), e);
-                }
+                return LocalDate.ofEpochDay(p.getLongValue());
             }
             return _failForNotLenient(p, ctxt, JsonToken.VALUE_STRING);
         }
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/InstantDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/InstantDeserTest.java
index f7f231a7e..a0e58b50b 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/InstantDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/InstantDeserTest.java
@@ -325,25 +325,6 @@ public class InstantDeserTest extends DateTimeTestBase
         assertEquals(expected.value, actual.value);
     }
 
-    @Test
-    public void testInvalidEpochSecondValue() throws Exception
-    {
-        // Test with an invalid epoch second value that causes DateTimeException
-        // Use a value beyond Instant.MAX
-        long invalidValue = Long.MAX_VALUE;
-        
-        try {
-            READER.readValue(String.valueOf(invalidValue));
-            fail("Should not pass");
-        } catch (DateTimeParseException e) {
-            // Verify it's a DateTimeParseException, not DateTimeException
-            verifyException(e, "Failed to deserialize");
-            verifyException(e, "java.time.Instant");
-            verifyException(e, String.valueOf(invalidValue));
-            verifyException(e, "Instant exceeds minimum or maximum instant");
-        }
-    }
-
     /*
     /**********************************************************************
     /* Basic deserialization from String (ISO-8601 timestamps)
diff --git a/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserTest.java b/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserTest.java
index cd575088c..dd7f90237 100644
--- a/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserTest.java
+++ b/src/test/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserTest.java
@@ -22,7 +22,6 @@ import tools.jackson.core.type.TypeReference;
 
 import tools.jackson.databind.*;
 import tools.jackson.databind.exc.MismatchedInputException;
-import tools.jackson.databind.ext.javatime.DateTimeParseException;
 import tools.jackson.databind.ext.javatime.DateTimeTestBase;
 import tools.jackson.databind.ext.javatime.MockObjectConfiguration;
 import tools.jackson.databind.json.JsonMapper;
@@ -221,23 +220,6 @@ public class LocalDateDeserTest extends DateTimeTestBase
         assertEquals(LocalDate.of(1970, Month.FEBRUARY, 10), READER.readValue("40"));
     }
 
-    @Test
-    public void testInvalidEpochDayValueInLenientMode()
-    {
-        // Test with an invalid epoch day value that causes DateTimeException
-        // even in lenient mode (default)
-        try {
-            READER.readValue("-922337203685");
-            fail("Should not pass");
-        } catch (DateTimeParseException e) {
-            // Verify it's a DateTimeParseException, not DateTimeException
-            verifyException(e, "Failed to deserialize");
-            verifyException(e, "java.time.LocalDate");
-            verifyException(e, "-922337203685");
-            verifyException(e, "Invalid value for EpochDay");
-        }
-    }
-
     // But with alternate setting, not so
     @Test
     public void testStricDeserializeFromInt()
@@ -572,27 +554,6 @@ public class LocalDateDeserTest extends DateTimeTestBase
         }
     }
 
-    @Test
-    public void testInvalidEpochDayValue()
-    {
-        // Test with an invalid epoch day value that causes DateTimeException
-        ObjectMapper mapper = newMapperBuilder()
-                .withConfigOverride(LocalDate.class,
-                        o -> o.setFormat(JsonFormat.Value.forShape(JsonFormat.Shape.NUMBER_INT)))
-                .build();
-        
-        try {
-            mapper.readValue("-922337203685", LocalDate.class);
-            fail("Should not pass");
-        } catch (DateTimeParseException e) {
-            // Verify it's a DateTimeParseException, not DateTimeException
-            verifyException(e, "Failed to deserialize");
-            verifyException(e, "java.time.LocalDate");
-            verifyException(e, "-922337203685");
-            verifyException(e, "Invalid value for EpochDay");
-        }
-    }
-
     /**********************************************************************
      *
      * coercion config test
