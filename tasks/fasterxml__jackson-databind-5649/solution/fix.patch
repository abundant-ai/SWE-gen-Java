diff --git a/release-notes/VERSION b/release-notes/VERSION
index c8b1a3c4f..2c6ee2d57 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -181,6 +181,9 @@ Versions: 3.x (for earlier see VERSION-2.x)
  (implemented by @pjfanning)
 #5646: `ObjectArrayDeserializer` may throw `ArrayStoreException` for some special cases
  (fixed by @cowtowncoder, w/ Claude code)
+#5649: Wrap `LocalDate.ofEpochDay()` and `Instant.ofEpochSecond()` to throw
+  `DateTimeParseException` on invalid values
+ (implemented by @pjfanning)
 
 3.0.4 (not yet released)
 
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java
index ee2061106..337612a46 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/InstantDeserializer.java
@@ -405,13 +405,20 @@ public class InstantDeserializer<T extends Temporal>
 
     protected T _fromLong(DeserializationContext context, long timestamp)
     {
-        if(shouldReadTimestampsAsNanoseconds(context)){
-            return fromNanoseconds.apply(new FromDecimalArguments(
-                    timestamp, 0, this.getZone(context)
-            ));
+        try {
+            if(shouldReadTimestampsAsNanoseconds(context)){
+                return fromNanoseconds.apply(new FromDecimalArguments(
+                        timestamp, 0, this.getZone(context)
+                ));
+            }
+            return fromMilliseconds.apply(new FromIntegerArguments(
+                    timestamp, this.getZone(context)));
+        } catch (DateTimeException e) {
+            throw DateTimeParseException.from(context.getParser(),
+                    String.format("Failed to deserialize %s from timestamp value %d: %s",
+                            handledType().getName(), timestamp, e.getMessage()),
+                    String.valueOf(timestamp), handledType(), e);
         }
-        return fromMilliseconds.apply(new FromIntegerArguments(
-                timestamp, this.getZone(context)));
     }
 
     protected T _fromDecimal(DeserializationContext context, BigDecimal value)
diff --git a/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserializer.java b/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserializer.java
index a371fc50a..e6ca7f84e 100644
--- a/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserializer.java
+++ b/src/main/java/tools/jackson/databind/ext/javatime/deser/LocalDateDeserializer.java
@@ -141,7 +141,16 @@ public class LocalDateDeserializer extends JSR310DateTimeDeserializerBase<LocalD
 
             // issue 58 - also check for NUMBER_INT, which needs to be specified when serializing.
             if (_shape == JsonFormat.Shape.NUMBER_INT || isLenient()) {
-                return LocalDate.ofEpochDay(p.getLongValue());
+                long epochDay = p.getLongValue();
+                try {
+                    return LocalDate.ofEpochDay(epochDay);
+                } catch (DateTimeException e) {
+                    throw DateTimeParseException.from(p,
+                            String.format("Failed to deserialize %s from epoch day value %d: %s",
+                                    handledType().getName(), epochDay, e.getMessage()),
+                            String.valueOf(epochDay),
+                            handledType(), e);
+                }
             }
             return _failForNotLenient(p, ctxt, JsonToken.VALUE_STRING);
         }
