diff --git a/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java b/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java
index 8dfbfe9b81..1553a3d479 100644
--- a/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java
+++ b/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java
@@ -368,11 +368,11 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         @Override
         public Path pushConstructorResolve(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments) {
             if (CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
-                ConstructorSegment constructorSegment = new ConstructorArgumentSegment(declaringType, methodName, argument, arguments);
+                ConstructorSegment constructorSegment = new ConstructorArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments);
                 detectCircularDependency(declaringType, argument, constructorSegment);
             } else {
                 Segment<?, ?> previous = peek();
-                MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
+                MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
                 if (contains(methodSegment)) {
                     throw new CircularDependencyException(AbstractBeanResolutionContext.this, argument, CIRCULAR_ERROR_MSG);
                 } else {
@@ -390,7 +390,7 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         @Override
         public Path pushMethodArgumentResolve(BeanDefinition declaringType, MethodInjectionPoint methodInjectionPoint, Argument argument) {
             Segment<?, ?> previous = peek();
-            MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, methodInjectionPoint.getName(), argument,
+            MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodInjectionPoint.getName(), argument,
                     methodInjectionPoint.getArguments(), previous instanceof MethodSegment ms ? ms : null);
             if (contains(methodSegment)) {
                 throw new CircularDependencyException(AbstractBeanResolutionContext.this, methodInjectionPoint, argument, CIRCULAR_ERROR_MSG);
@@ -404,7 +404,7 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         @Override
         public Path pushMethodArgumentResolve(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments) {
             Segment<?, ?> previous = peek();
-            MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
+            MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
             if (contains(methodSegment)) {
                 throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, methodName, argument, CIRCULAR_ERROR_MSG);
             } else {
@@ -416,7 +416,7 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public Path pushFieldResolve(BeanDefinition declaringType, FieldInjectionPoint fieldInjectionPoint) {
-            FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, fieldInjectionPoint.asArgument());
+            FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldInjectionPoint.asArgument());
             if (contains(fieldSegment)) {
                 throw new CircularDependencyException(AbstractBeanResolutionContext.this, fieldInjectionPoint, CIRCULAR_ERROR_MSG);
             } else {
@@ -427,7 +427,7 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public Path pushFieldResolve(BeanDefinition declaringType, Argument fieldAsArgument) {
-            FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, fieldAsArgument);
+            FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldAsArgument);
             if (contains(fieldSegment)) {
                 throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, fieldAsArgument.getName(), CIRCULAR_ERROR_MSG);
             } else {
@@ -438,7 +438,7 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public Path pushAnnotationResolve(BeanDefinition beanDefinition, Argument annotationMemberBeanAsArgument) {
-            AnnotationSegment annotationSegment = new AnnotationSegment(beanDefinition, annotationMemberBeanAsArgument);
+            AnnotationSegment annotationSegment = new AnnotationSegment(beanDefinition, getCurrentQualifier(), annotationMemberBeanAsArgument);
             if (contains(annotationSegment)) {
                 throw new CircularDependencyException(AbstractBeanResolutionContext.this, beanDefinition, annotationMemberBeanAsArgument.getName(), CIRCULAR_ERROR_MSG);
             } else {
@@ -494,39 +494,45 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
     /**
      * A segment that represents a method argument.
      */
-    public static class ConstructorArgumentSegment extends ConstructorSegment implements ArgumentInjectionPoint {
-        public ConstructorArgumentSegment(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments) {
-            super(declaringType, methodName, argument, arguments);
+    public static final class ConstructorArgumentSegment extends ConstructorSegment implements ArgumentInjectionPoint<Object, Object> {
+        public ConstructorArgumentSegment(BeanDefinition<Object> declaringType, Qualifier<Object> qualifier, String methodName, Argument<Object> argument, Argument<Object>[] arguments) {
+            super(declaringType, qualifier, methodName, argument, arguments);
         }
 
         @Override
-        public CallableInjectionPoint getOuterInjectionPoint() {
+        public CallableInjectionPoint<Object> getOuterInjectionPoint() {
             throw new UnsupportedOperationException("Outer injection point inaccessible from here");
         }
 
         @Override
-        public BeanDefinition getDeclaringBean() {
+        public BeanDefinition<Object> getDeclaringBean() {
             return getDeclaringType();
         }
 
+        @Override
+        public Qualifier<Object> getDeclaringBeanQualifier() {
+            return getDeclaringTypeQualifier();
+        }
+
     }
 
     /**
      * A segment that represents a constructor.
      */
-    public static class ConstructorSegment extends AbstractSegment {
+    public static class ConstructorSegment extends AbstractSegment<Object, Object> implements ArgumentInjectionPoint<Object, Object> {
 
         private final String methodName;
-        private final Argument[] arguments;
+        private final Argument<Object>[] arguments;
 
         /**
-         * @param declaringClass The declaring class
+         * @param declaringBeanDefinition The declaring class
+         * @param qualifier      The qualifier
          * @param methodName     The methodName
          * @param argument       The argument
          * @param arguments      The arguments
          */
-        ConstructorSegment(BeanDefinition declaringClass, String methodName, Argument argument, Argument[] arguments) {
-            super(declaringClass, declaringClass.getBeanType().getName(), argument);
+        ConstructorSegment(BeanDefinition<Object> declaringBeanDefinition, Qualifier<Object> qualifier, String methodName, Argument<Object> argument, Argument<Object>[] arguments) {
+            super(declaringBeanDefinition, qualifier, declaringBeanDefinition.getBeanType().getName(), argument);
             this.methodName = methodName;
             this.arguments = arguments;
         }
@@ -546,31 +552,29 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         }
 
         @Override
-        public InjectionPoint getInjectionPoint() {
-            ConstructorInjectionPoint constructorInjectionPoint = getDeclaringType().getConstructor();
-            return new ArgumentInjectionPoint() {
-                @NonNull
-                @Override
-                public CallableInjectionPoint getOuterInjectionPoint() {
-                    return constructorInjectionPoint;
-                }
+        public InjectionPoint<Object> getInjectionPoint() {
+            return this;
+        }
 
-                @NonNull
-                @Override
-                public Argument getArgument() {
-                    return ConstructorSegment.this.getArgument();
-                }
+        @NonNull
+        @Override
+        public CallableInjectionPoint<Object> getOuterInjectionPoint() {
+            return getDeclaringType().getConstructor();
+        }
 
-                @Override
-                public BeanDefinition getDeclaringBean() {
-                    return constructorInjectionPoint.getDeclaringBean();
-                }
+        @Override
+        public BeanDefinition<Object> getDeclaringBean() {
+            return ConstructorSegment.this.getDeclaringType();
+        }
 
-                @Override
-                public AnnotationMetadata getAnnotationMetadata() {
-                    return getArgument().getAnnotationMetadata();
-                }
-            };
+        @Override
+        public Qualifier<Object> getDeclaringBeanQualifier() {
+            return ConstructorSegment.this.getDeclaringTypeQualifier();
+        }
+
+        @Override
+        public AnnotationMetadata getAnnotationMetadata() {
+            return getArgument().getAnnotationMetadata();
         }
 
     }
@@ -578,16 +582,21 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
     /**
      * A segment that represents a method argument.
      */
-    public static class MethodArgumentSegment extends MethodSegment implements ArgumentInjectionPoint {
-        private final MethodSegment outer;
-
-        public MethodArgumentSegment(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments, MethodSegment outer) {
-            super(declaringType, methodName, argument, arguments);
+    public static final class MethodArgumentSegment extends MethodSegment<Object, Object> implements ArgumentInjectionPoint<Object, Object> {
+        private final MethodSegment<Object, Object> outer;
+
+        public MethodArgumentSegment(BeanDefinition<Object> declaringType,
+                                     Qualifier<Object> qualifier,
+                                     String methodName,
+                                     Argument<Object>  argument,
+                                     Argument<Object> [] arguments,
+                                     MethodSegment<Object, Object> outer) {
+            super(declaringType, qualifier, methodName, argument, arguments);
             this.outer = outer;
         }
 
         @Override
-        public CallableInjectionPoint getOuterInjectionPoint() {
+        public CallableInjectionPoint<Object> getOuterInjectionPoint() {
             if (outer == null) {
                 throw new IllegalStateException("Outer argument inaccessible");
             }
@@ -614,16 +623,17 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
      */
     public static class MethodSegment<B, T> extends AbstractSegment<B, T> implements CallableInjectionPoint<B> {
 
-        private final Argument[] arguments;
+        private final Argument<Object>[] arguments;
 
         /**
          * @param declaringType      The declaring type
+         * @param qualifier          The qualifier
          * @param methodName         The method name
          * @param argument           The argument
          * @param arguments          The arguments
          */
-        MethodSegment(BeanDefinition<B> declaringType, String methodName, Argument<T> argument, Argument[] arguments) {
-            super(declaringType, methodName, argument);
+        MethodSegment(BeanDefinition<B> declaringType, Qualifier<B> qualifier, String methodName, Argument<T> argument, Argument<Object>[] arguments) {
+            super(declaringType, qualifier, methodName, argument);
             this.arguments = arguments;
         }
 
@@ -654,19 +664,25 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         public AnnotationMetadata getAnnotationMetadata() {
             return getArgument().getAnnotationMetadata();
         }
+
+        @Override
+        public Qualifier<B> getDeclaringBeanQualifier() {
+            return getDeclaringTypeQualifier();
+        }
     }
 
     /**
      * A segment that represents a field.
      */
-    public static class FieldSegment<B, T> extends AbstractSegment<B, T> implements InjectionPoint<B>, ArgumentCoercible<T>, ArgumentInjectionPoint<B, T> {
+    public static final class FieldSegment<B, T> extends AbstractSegment<B, T> implements InjectionPoint<B>, ArgumentCoercible<T>, ArgumentInjectionPoint<B, T> {
 
         /**
          * @param declaringClass     The declaring class
+         * @param qualifier          The qualifier
          * @param argument           The argument
          */
-        FieldSegment(BeanDefinition<B> declaringClass, Argument<T> argument) {
-            super(declaringClass, argument.getName(), argument);
+        FieldSegment(BeanDefinition<B> declaringClass, Qualifier<B> qualifier, Argument<T> argument) {
+            super(declaringClass, qualifier, argument.getName(), argument);
         }
 
         @Override
@@ -698,6 +714,11 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         public AnnotationMetadata getAnnotationMetadata() {
             return getArgument().getAnnotationMetadata();
         }
+
+        @Override
+        public Qualifier<B> getDeclaringBeanQualifier() {
+            return getDeclaringTypeQualifier();
+        }
     }
 
     /**
@@ -706,12 +727,14 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
      * @since 3.3.0
      */
     public static final class AnnotationSegment<B> extends AbstractSegment<B, B> implements InjectionPoint<B> {
+
         /**
          * @param beanDefinition The bean definition
+         * @param qualifier      The qualifier
          * @param argument       The argument
          */
-        AnnotationSegment(BeanDefinition<B> beanDefinition, Argument<B> argument) {
-            super(beanDefinition, argument.getName(), argument);
+        AnnotationSegment(BeanDefinition<B> beanDefinition, Qualifier<B> qualifier, Argument<B> argument) {
+            super(beanDefinition, qualifier, argument.getName(), argument);
         }
 
         @Override
@@ -733,23 +756,32 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         public AnnotationMetadata getAnnotationMetadata() {
             return getArgument().getAnnotationMetadata();
         }
+
+        @Override
+        public Qualifier<B> getDeclaringBeanQualifier() {
+            return getDeclaringTypeQualifier();
+        }
     }
 
     /**
      * Abstract class for a Segment.
      */
-    abstract static class AbstractSegment<B, T> implements Segment<B, T>, Named {
+    protected abstract static class AbstractSegment<B, T> implements Segment<B, T>, Named {
         private final BeanDefinition<B> declaringComponent;
+        @Nullable
+        private final Qualifier<B> qualifier;
         private final String name;
         private final Argument<T> argument;
 
         /**
          * @param declaringClass The declaring class
+         * @param qualifier      The qualifier
          * @param name           The name
          * @param argument       The argument
          */
-        AbstractSegment(BeanDefinition<B> declaringClass, String name, Argument<T> argument) {
+        AbstractSegment(BeanDefinition<B> declaringClass, Qualifier<B> qualifier, String name, Argument<T> argument) {
             this.declaringComponent = declaringClass;
+            this.qualifier = qualifier;
             this.name = name;
             this.argument = argument;
         }
@@ -764,6 +796,11 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
             return declaringComponent;
         }
 
+        @Override
+        public Qualifier<B> getDeclaringTypeQualifier() {
+            return qualifier == null ? declaringComponent.getDeclaredQualifier() : qualifier;
+        }
+
         @Override
         public Argument<T> getArgument() {
             return argument;
diff --git a/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java b/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java
index 2667a89541..2c48f33608 100644
--- a/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java
+++ b/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java
@@ -405,6 +405,12 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
          */
         BeanDefinition<B> getDeclaringType();
 
+        /**
+         * @return The declaring type qualifier
+         * @since 4.5.0
+         */
+        Qualifier<B> getDeclaringTypeQualifier();
+
         /**
          * @return The inject point
          */
diff --git a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
index ab9a344d02..a06b73164b 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
@@ -2887,21 +2887,22 @@ public class DefaultBeanContext implements InitializableBeanContext {
                                                           boolean throwNoSuchBean) {
         final BeanResolutionContext.Path path = resolutionContext != null ? resolutionContext.getPath() : null;
         BeanResolutionContext.Segment<?, ?> injectionPointSegment = null;
-        if (CollectionUtils.isNotEmpty(path)) {
-            @SuppressWarnings("java:S2259") // false positive
+        if (path != null) {
             final Iterator<BeanResolutionContext.Segment<?, ?>> i = path.iterator();
-            injectionPointSegment = i.next();
-            BeanResolutionContext.Segment<?, ?> segment = null;
             if (i.hasNext()) {
-                segment = i.next();
-                if (segment.getDeclaringType().hasStereotype(INTRODUCTION_TYPE)) {
-                    segment = i.hasNext() ? i.next() : null;
+                injectionPointSegment = i.next();
+                BeanResolutionContext.Segment<?, ?> segment = null;
+                if (i.hasNext()) {
+                    segment = i.next();
+                    if (segment.getDeclaringType().hasStereotype(INTRODUCTION_TYPE)) {
+                        segment = i.hasNext() ? i.next() : null;
+                    }
                 }
-            }
-            if (segment != null) {
-                T ip = (T) segment.getInjectionPoint();
-                if (ip != null && beanType.isInstance(ip)) {
-                    return new BeanRegistration<>(BeanIdentifier.of(InjectionPoint.class.getName()), null, ip);
+                if (segment != null) {
+                    T ip = (T) segment.getInjectionPoint();
+                    if (ip != null && beanType.isInstance(ip)) {
+                        return new BeanRegistration<>(BeanIdentifier.of(InjectionPoint.class.getName()), null, ip);
+                    }
                 }
             }
         }
diff --git a/inject/src/main/java/io/micronaut/inject/InjectionPoint.java b/inject/src/main/java/io/micronaut/inject/InjectionPoint.java
index 9f45e4a7eb..ec6680c432 100644
--- a/inject/src/main/java/io/micronaut/inject/InjectionPoint.java
+++ b/inject/src/main/java/io/micronaut/inject/InjectionPoint.java
@@ -15,9 +15,11 @@
  */
 package io.micronaut.inject;
 
+import io.micronaut.context.Qualifier;
 import io.micronaut.core.annotation.AnnotationMetadataProvider;
 
 import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
 
 /**
  * An injection point as a point in a class definition where dependency injection is required.
@@ -33,4 +35,13 @@ public interface InjectionPoint<T> extends AnnotationMetadataProvider {
      */
     @NonNull BeanDefinition<T> getDeclaringBean();
 
+    /**
+     * @return The qualifier of the bean that declares this injection point
+     * @since 4.5.0
+     */
+    @Nullable
+    default Qualifier<T> getDeclaringBeanQualifier() {
+        return getDeclaringBean().getDeclaredQualifier();
+    }
+
 }
