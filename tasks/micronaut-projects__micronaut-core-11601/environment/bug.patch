diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index e17fea2279..8f0c55810b 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -64,7 +64,6 @@ vertx = "4.5.14"
 wiremock = "2.33.2"
 mimepull = "1.10.0"
 micronaut-sourcegen = "1.6.2"
-icu4j = "76.1"
 
 #
 # Versions which start with managed- are managed by Micronaut in the sense
@@ -202,8 +201,6 @@ hibernate = { module = "org.hibernate:hibernate-core", version.ref = "hibernate"
 htmlunit = { module = "net.sourceforge.htmlunit:htmlunit", version.ref = "htmlunit" }
 htmlsanitycheck = { module = "org.aim42:htmlSanityCheck", version.ref = "htmlsanitycheck"}
 
-icu4j = { module = "com.ibm.icu:icu4j", version.ref = "icu4j" }
-
 jakarta-inject-api = { module = "jakarta.inject:jakarta.inject-api", version.ref = "jakarta-inject-api" }
 jakarta-inject-tck = { module = "jakarta.inject:jakarta.inject-tck", version.ref = "jakarta-inject-tck" }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/AbstractNettyHttpRequest.java b/http-netty/src/main/java/io/micronaut/http/netty/AbstractNettyHttpRequest.java
similarity index 89%
rename from http-server-netty/src/main/java/io/micronaut/http/server/netty/AbstractNettyHttpRequest.java
rename to http-netty/src/main/java/io/micronaut/http/netty/AbstractNettyHttpRequest.java
index 03a06d0893..922080cbb6 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/AbstractNettyHttpRequest.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/AbstractNettyHttpRequest.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.micronaut.http.server.netty;
+package io.micronaut.http.netty;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
@@ -22,12 +22,8 @@ import io.micronaut.core.convert.ConversionService;
 import io.micronaut.http.HttpMethod;
 import io.micronaut.http.HttpParameters;
 import io.micronaut.http.HttpRequest;
-import io.micronaut.http.netty.NettyHttpParameters;
-import io.micronaut.http.netty.NettyHttpRequestBuilder;
 import io.micronaut.http.netty.stream.DefaultStreamedHttpRequest;
 import io.micronaut.http.netty.stream.StreamedHttpRequest;
-import io.micronaut.http.server.HttpServerConfiguration;
-import io.micronaut.web.router.uri.UriUtil;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultLastHttpContent;
 import io.netty.handler.codec.http.HttpConstants;
@@ -55,27 +51,19 @@ public abstract class AbstractNettyHttpRequest<B> extends DefaultAttributeMap im
     protected final String unvalidatedUrl;
     protected final String httpMethodName;
 
-    private volatile URI uri;
-    private volatile NettyHttpParameters httpParameters;
-    private volatile Charset charset;
-    private volatile String path;
+    private URI uri;
+    private NettyHttpParameters httpParameters;
+    private Charset charset;
+    private String path;
 
     /**
      * @param nettyRequest      The Http netty request
      * @param conversionService The conversion service
-     * @param escapeHtmlUrl     {@link HttpServerConfiguration#isEscapeHtmlUrl()}
      */
-    public AbstractNettyHttpRequest(io.netty.handler.codec.http.HttpRequest nettyRequest, ConversionService conversionService, boolean escapeHtmlUrl) {
+    public AbstractNettyHttpRequest(io.netty.handler.codec.http.HttpRequest nettyRequest, ConversionService conversionService) {
         this.nettyRequest = nettyRequest;
         this.conversionService = conversionService;
-        String uri = nettyRequest.uri();
-        if (!UriUtil.isValidPath(uri)) {
-            if (escapeHtmlUrl && UriUtil.isRelative(uri)) {
-                uri = UriUtil.toValidPath(uri);
-            }
-            this.uri = createURI(uri);
-        }
-        this.unvalidatedUrl = uri;
+        this.unvalidatedUrl = nettyRequest.uri();
         this.httpMethodName = nettyRequest.method().name();
         this.httpMethod = HttpMethod.parse(httpMethodName);
     }
@@ -172,8 +160,13 @@ public abstract class AbstractNettyHttpRequest<B> extends DefaultAttributeMap im
     public URI getUri() {
         URI u = this.uri;
         if (u == null) {
-            u = createURI(unvalidatedUrl);
-            this.uri = u;
+            synchronized (this) { // double check
+                u = this.uri;
+                if (u == null) {
+                    u = createURI(unvalidatedUrl);
+                    this.uri = u;
+                }
+            }
         }
         return u;
     }
@@ -182,8 +175,13 @@ public abstract class AbstractNettyHttpRequest<B> extends DefaultAttributeMap im
     public String getPath() {
         String p = this.path;
         if (p == null) {
-            p = parsePath(unvalidatedUrl);
-            this.path = p;
+            synchronized (this) { // double check
+                p = this.path;
+                if (p == null) {
+                    p = parsePath(unvalidatedUrl);
+                    this.path = p;
+                }
+            }
         }
         return p;
     }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
index 97e9c2b6f0..70ddd10e41 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
@@ -47,6 +47,7 @@ import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.body.InternalByteBody;
 import io.micronaut.http.cookie.Cookie;
 import io.micronaut.http.cookie.Cookies;
+import io.micronaut.http.netty.AbstractNettyHttpRequest;
 import io.micronaut.http.netty.NettyHttpHeaders;
 import io.micronaut.http.netty.NettyHttpParameters;
 import io.micronaut.http.netty.NettyHttpRequestBuilder;
@@ -196,7 +197,7 @@ public final class NettyHttpRequest<T> extends AbstractNettyHttpRequest<T> imple
                             ChannelHandlerContext ctx,
                             ConversionService environment,
                             HttpServerConfiguration serverConfiguration) throws IllegalArgumentException {
-        super(nettyRequest, environment, serverConfiguration.isEscapeHtmlUrl());
+        super(nettyRequest, environment);
         Objects.requireNonNull(nettyRequest, "Netty request cannot be null");
         Objects.requireNonNull(ctx, "ChannelHandlerContext cannot be null");
         Objects.requireNonNull(environment, "Environment cannot be null");
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
index 01657a96b4..acf6175b7d 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
@@ -29,7 +29,6 @@ import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.context.ServerHttpRequestContext;
 import io.micronaut.http.context.event.HttpRequestReceivedEvent;
-import io.micronaut.http.context.event.HttpRequestReceivedEvent;
 import io.micronaut.http.context.event.HttpRequestTerminatedEvent;
 import io.micronaut.http.netty.NettyMutableHttpResponse;
 import io.micronaut.http.netty.body.AvailableNettyByteBody;
@@ -169,32 +168,31 @@ public final class RoutingInBoundHandler implements RequestHandler {
 
     @Override
     public void accept(ChannelHandlerContext ctx, io.netty.handler.codec.http.HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
-        NettyHttpRequest<Object> mnRequest;
-        try {
-            mnRequest = new NettyHttpRequest<>(request, body, ctx, conversionService, serverConfiguration);
-        } catch (IllegalArgumentException e) {
-            body.close();
-
-            // invalid URI
-            NettyHttpRequest<Object> errorRequest = new NettyHttpRequest<>(
-                new DefaultHttpRequest(request.protocolVersion(), request.method(), "/"),
-                AvailableNettyByteBody.empty(),
-                ctx,
-                conversionService,
-                serverConfiguration
-            );
-            outboundAccess.attachment(errorRequest);
-            if (receivedPublisher != ApplicationEventPublisher.NO_OP) {
-                receivedPublisher.publishEvent(new HttpRequestReceivedEvent(errorRequest));
-            }
-            try (PropagatedContext.Scope ignore = PropagatedContext.getOrEmpty().plus(new ServerHttpRequestContext(errorRequest)).propagate()) {
-                new NettyRequestLifecycle(this, outboundAccess).handleException(errorRequest, e.getCause() == null ? e : e.getCause());
-            }
-            return;
-        }
+        NettyHttpRequest<Object> mnRequest = new NettyHttpRequest<>(request, body, ctx, conversionService, serverConfiguration);
         if (receivedPublisher != ApplicationEventPublisher.NO_OP) {
             receivedPublisher.publishEvent(new HttpRequestReceivedEvent(mnRequest));
         }
+        if (serverConfiguration.isValidateUrl()) {
+            try {
+                mnRequest.getUri();
+            } catch (IllegalArgumentException e) {
+                body.close();
+
+                // invalid URI
+                NettyHttpRequest<Object> errorRequest = new NettyHttpRequest<>(
+                    new DefaultHttpRequest(request.protocolVersion(), request.method(), "/"),
+                    AvailableNettyByteBody.empty(),
+                    ctx,
+                    conversionService,
+                    serverConfiguration
+                );
+                outboundAccess.attachment(errorRequest);
+                try (PropagatedContext.Scope ignore = PropagatedContext.getOrEmpty().plus(new ServerHttpRequestContext(errorRequest)).propagate()) {
+                    new NettyRequestLifecycle(this, outboundAccess).handleException(errorRequest, e.getCause() == null ? e : e.getCause());
+                }
+                return;
+            }
+        }
         if (supportLoggingHandler && ctx.pipeline().get(ChannelPipelineCustomizer.HANDLER_ACCESS_LOGGER) != null) {
             // Micronaut Session needs this to extract values from the Micronaut Http Request for logging
             AttributeKey<NettyHttpRequest> key = AttributeKey.valueOf(NettyHttpRequest.class.getSimpleName());
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/MalformedUriDisabledValidationSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/MalformedUriDisabledValidationSpec.groovy
index 3635d5c844..fa65d8307c 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/MalformedUriDisabledValidationSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/MalformedUriDisabledValidationSpec.groovy
@@ -28,7 +28,7 @@ class MalformedUriDisabledValidationSpec extends Specification {
 
     @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, [
             'spec.name': 'MalformedUriDisabledValidationSpec',
-            'micronaut.server.escape-html-url': 'true'
+            'micronaut.server.validate-url': 'false'
     ])
     @Shared @AutoCleanup HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL())
 
@@ -59,8 +59,7 @@ class MalformedUriDisabledValidationSpec extends Specification {
     @Controller('/malformed')
     static class SomeController {
         @Get(uri="/{some}", produces = MediaType.TEXT_PLAIN)
-        String some(HttpRequest<?> request, String some) throws Exception {
-            assert request.uri.path.contains(some)
+        String some(String some) throws Exception{
             return some
         }
 
diff --git a/http-server/src/main/java/io/micronaut/http/server/HttpServerConfiguration.java b/http-server/src/main/java/io/micronaut/http/server/HttpServerConfiguration.java
index e451331b1b..eeb3b15ac9 100644
--- a/http-server/src/main/java/io/micronaut/http/server/HttpServerConfiguration.java
+++ b/http-server/src/main/java/io/micronaut/http/server/HttpServerConfiguration.java
@@ -166,7 +166,6 @@ public class HttpServerConfiguration implements ServerContextPathProvider {
     private Charset defaultCharset;
     private ThreadSelection threadSelection = ThreadSelection.MANUAL;
     private boolean validateUrl = true;
-    private boolean escapeHtmlUrl = false;
     private boolean notFoundOnMissingBody = true;
     private boolean semicolonIsNormalChar = DEFAULT_SEMICOLON_IS_NORMAL_CHAR;
     private int maxParams = DEFAULT_MAX_PARAMS;
@@ -584,9 +583,7 @@ public class HttpServerConfiguration implements ServerContextPathProvider {
      *
      * @param validateUrl The validate URL value
      * @since 4.3.0
-     * @deprecated URLs are always validated again as of 4.9. This setting does nothing
      */
-    @Deprecated(forRemoval = true, since = "4.9.0")
     public void setValidateUrl(boolean validateUrl) {
         this.validateUrl = validateUrl;
     }
@@ -594,39 +591,11 @@ public class HttpServerConfiguration implements ServerContextPathProvider {
     /**
      * @return True if the url should be validated
      * @since 4.3.0
-     * @deprecated URLs are always validated again as of 4.9. This setting does nothing
      */
-    @Deprecated(forRemoval = true, since = "4.9.0")
     public boolean isValidateUrl() {
         return validateUrl;
     }
 
-    /**
-     * Browsers can send characters (such as {@code |}) which are not permitted under RFC 3986 as
-     * part of the request path. These characters are normally rejected by the server. If this
-     * setting is enabled, the server will escape these characters before parsing them using
-     * {@link java.net.URI} so that they are not rejected. Default off.
-     *
-     * @return Whether to escape forbidden URL characters prior to parsing
-     * @since 4.9.0
-     */
-    public boolean isEscapeHtmlUrl() {
-        return escapeHtmlUrl;
-    }
-
-    /**
-     * Browsers can send characters (such as {@code |}) which are not permitted under RFC 3986 as
-     * part of the request path. These characters are normally rejected by the server. If this
-     * setting is enabled, the server will escape these characters before parsing them using
-     * {@link java.net.URI} so that they are not rejected. Default off.
-     *
-     * @param escapeHtmlUrl Whether to escape forbidden URL characters prior to parsing
-     * @since 4.9.0
-     */
-    public void setEscapeHtmlUrl(boolean escapeHtmlUrl) {
-        this.escapeHtmlUrl = escapeHtmlUrl;
-    }
-
     /**
      * @return True if not-found should be returned on missing body. False to return an empty body.
      * @since 4.6
diff --git a/router/build.gradle.kts b/router/build.gradle.kts
index 0417535767..bae112833a 100644
--- a/router/build.gradle.kts
+++ b/router/build.gradle.kts
@@ -14,9 +14,6 @@ dependencies {
     testImplementation(projects.micronautInjectJava)
     testAnnotationProcessor(projects.micronautInjectJava)
     testImplementation(projects.micronautInjectGroovyTest)
-    testImplementation(libs.jazzer.junit)
-    testImplementation(libs.jazzer.api)
-    testImplementation(libs.icu4j)
 }
 
 
diff --git a/router/src/main/java/io/micronaut/web/router/uri/PercentEncoder.java b/router/src/main/java/io/micronaut/web/router/uri/PercentEncoder.java
deleted file mode 100644
index f770ce3466..0000000000
--- a/router/src/main/java/io/micronaut/web/router/uri/PercentEncoder.java
+++ /dev/null
@@ -1,143 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.web.router.uri;
-
-import io.micronaut.core.annotation.Internal;
-
-import java.util.BitSet;
-import java.util.Locale;
-
-/**
- * Utility class for different URL percent encoding sets.
- *
- * @since 4.9.0
- * @author Jonas Konrad
- */
-@Internal
-final class PercentEncoder {
-    static final PercentEncoder C0 = new PercentEncoder(new BitSet());
-
-    static {
-        for (char c = 0x20; c <= 0x7e; c++) {
-            C0.keepSet.set(c);
-        }
-    }
-
-    // whatwg sets
-    static final PercentEncoder FRAGMENT = C0.addEncode(' ', '"', '<', '>', '`');
-    static final PercentEncoder QUERY = C0.addEncode(' ', '"', '<', '>', '#');
-    static final PercentEncoder SPECIAL_QUERY = QUERY.addEncode('\'');
-    static final PercentEncoder PATH = QUERY.addEncode('?', '`', '{', '}');
-    static final PercentEncoder USERINFO = PATH.addEncode('/', ':', ';', '=', '@', '|').addEncodeRange('[', '^');
-    static final PercentEncoder COMPONENT = USERINFO.addEncode('+', ',').addEncodeRange('$', '&');
-    static final PercentEncoder FORM = COMPONENT.addEncode('!', '~').addEncodeRange('\'', ')');
-
-    // RFC 3986 (URI) sets
-    static final PercentEncoder RFC3986_UNRESERVED = new PercentEncoder(new BitSet())
-        .removeEncodeRange('a', 'z')
-        .removeEncodeRange('A', 'Z')
-        .removeEncodeRange('0', '9')
-        .removeEncode('-', '.', '_', '~');
-    static final PercentEncoder RFC3986_PCHAR = RFC3986_UNRESERVED.removeEncode('%', '!', '$', '&', '\'', '(', ')', '*', '+', ',', ';', '=', '@'); // ':' is allowed but makes java.net.URI hiccup
-    static final PercentEncoder RFC3986_QUERY_CHAR = RFC3986_PCHAR.removeEncode('/', '?');
-
-    private final BitSet keepSet;
-
-    private PercentEncoder(BitSet keepSet) {
-        this.keepSet = keepSet;
-    }
-
-    public void encodeByte(StringBuilder target, byte b) {
-        if (keep(b)) {
-            target.append((char) (b & 0xff));
-        } else {
-            target.ensureCapacity(target.length() + 3);
-            appendEncodedByte(target, b);
-        }
-    }
-
-    public boolean keep(byte b) {
-        return keepSet.get(b & 0xff);
-    }
-
-    public void encodeUtf8(StringBuilder target, int codePoint) {
-        if (codePoint < 0x80) {
-            if (keepSet.get(codePoint)) {
-                target.append((char) codePoint);
-            } else {
-                target.ensureCapacity(target.length() + 3);
-                appendEncodedByte(target, (byte) codePoint);
-            }
-        } else if (codePoint < 0x800) {
-            target.ensureCapacity(target.length() + 6);
-            appendEncodedByte(target, (byte) (0b11000000 | (codePoint >> 6)));
-            appendEncodedByte(target, (byte) (0b10000000 | (codePoint & 0b111111)));
-        } else if (codePoint < 0x10000) {
-            target.ensureCapacity(target.length() + 9);
-            appendEncodedByte(target, (byte) (0b11100000 | (codePoint >> 12)));
-            appendEncodedByte(target, (byte) (0b10000000 | ((codePoint >> 6) & 0b111111)));
-            appendEncodedByte(target, (byte) (0b10000000 | (codePoint & 0b111111)));
-        } else if (codePoint < 0x110000) {
-            target.ensureCapacity(target.length() + 12);
-            appendEncodedByte(target, (byte) (0b11110000 | (codePoint >> 18)));
-            appendEncodedByte(target, (byte) (0b10000000 | ((codePoint >> 12) & 0b111111)));
-            appendEncodedByte(target, (byte) (0b10000000 | ((codePoint >> 6) & 0b111111)));
-            appendEncodedByte(target, (byte) (0b10000000 | (codePoint & 0b111111)));
-        } else {
-            throw new IllegalArgumentException("Code point out of range: " + codePoint);
-        }
-    }
-
-    static void appendEncodedByte(StringBuilder target, byte b) {
-        target.append('%');
-        if ((b & 0xff) < 0x10) {
-            target.append('0');
-        }
-        target.append(Integer.toHexString(b & 0xFF).toUpperCase(Locale.ROOT));
-    }
-
-    private PercentEncoder addEncode(char... removed) {
-        BitSet result = (BitSet) keepSet.clone();
-        for (char c : removed) {
-            result.clear(c);
-        }
-        return new PercentEncoder(result);
-    }
-
-    private PercentEncoder addEncodeRange(char fromInclusive, char toExclusive) {
-        BitSet result = (BitSet) keepSet.clone();
-        for (char c = fromInclusive; c <= toExclusive; c++) {
-            result.clear(c);
-        }
-        return new PercentEncoder(result);
-    }
-
-    private PercentEncoder removeEncode(char... removed) {
-        BitSet result = (BitSet) keepSet.clone();
-        for (char c : removed) {
-            result.set(c);
-        }
-        return new PercentEncoder(result);
-    }
-
-    private PercentEncoder removeEncodeRange(char fromInclusive, char toExclusive) {
-        BitSet result = (BitSet) keepSet.clone();
-        for (char c = fromInclusive; c <= toExclusive; c++) {
-            result.set(c);
-        }
-        return new PercentEncoder(result);
-    }
-}
diff --git a/router/src/main/java/io/micronaut/web/router/uri/UriUtil.java b/router/src/main/java/io/micronaut/web/router/uri/UriUtil.java
deleted file mode 100644
index 60818f9d51..0000000000
--- a/router/src/main/java/io/micronaut/web/router/uri/UriUtil.java
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.web.router.uri;
-
-import io.micronaut.core.annotation.NonNull;
-
-import java.net.URI;
-
-/**
- * Utilities for converting URI formats.
- *
- * @author Jonas Konrad
- * @since 4.9.0
- */
-public final class UriUtil {
-    private UriUtil() {
-    }
-
-    /**
-     * Transform a path+query as specified by the whatwg url spec into a path+query that is allowed
-     * by RFC 3986. Whatwg permits certain characters (e.g. '|') and invalid percent escape
-     * sequences that RFC 3986 (or {@link URI}) does not allow. This method will percent-encode
-     * those cases, so that any URI sent by a browser can be transformed to {@link URI}.
-     *
-     * @param path The whatwg path+query
-     * @return A valid RFC 3986 {@code relative-ref}
-     */
-    public static String toValidPath(String path) {
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < path.length();) {
-            int cp = path.codePointAt(i);
-            if (cp == '%') {
-                boolean validEscape;
-                if (i + 2 >= path.length()) {
-                    validEscape = false;
-                } else {
-                    char c1 = path.charAt(i + 1);
-                    char c2 = path.charAt(i + 2);
-                    validEscape = isAsciiHexDigit(c1) && isAsciiHexDigit(c2);
-                }
-                if (validEscape) {
-                    sb.appendCodePoint(cp);
-                } else {
-                    PercentEncoder.appendEncodedByte(sb, (byte) '%');
-                }
-            } else {
-                if (cp == '/' && sb.length() == 1 && sb.charAt(0) == '/') {
-                    // prevent '//' at start of url
-                } else {
-                    PercentEncoder.RFC3986_QUERY_CHAR.encodeUtf8(sb, cp);
-                }
-            }
-            i += Character.charCount(cp);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Check whether the given HTTP request target is a valid RFC 3986 relative URI (path + query)
-     * that will be parsed without complaint by {@link URI}. If this is true, we can skip the
-     * expensive parsing until necessary.
-     *
-     * @param requestTarget The HTTP request line
-     * @return {@code true} iff this is a valid relative URI
-     */
-    public static boolean isValidPath(@NonNull String requestTarget) {
-        if (requestTarget.isEmpty() || requestTarget.charAt(0) != '/') {
-            return false;
-        }
-        for (int i = 0; i < requestTarget.length(); i++) {
-            char c = requestTarget.charAt(i);
-            if (c == '%' || c > 0x7f || !PercentEncoder.RFC3986_QUERY_CHAR.keep((byte) c)) {
-                return false;
-            }
-            if (c == '/' && i < requestTarget.length() - 1) {
-                char next = requestTarget.charAt(i + 1);
-                if (next == '/') {
-                    return false;
-                }
-                if (next == '.') {
-                    if (i >= requestTarget.length() - 2) {
-                        return false;
-                    }
-                    char nextNext = requestTarget.charAt(i + 2);
-                    if (nextNext == '.' || nextNext == '/' || nextNext == '?' || nextNext == '#') {
-                        return false;
-                    }
-                }
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Determine whether the given HTTP request target is a relative URI (path+query) appropriate
-     * for {@link #toValidPath(String)}. The invariants are:
-     *
-     * <ul>
-     *     <li>This method returns {@code true} exactly when, according to the whatwg URL spec, this
-     *     URL has no scheme</li>
-     *     <li>If the input is a valid URI, this method is equal to the inverse of
-     *     {@link URI#isAbsolute()}</li>
-     *     <li>If this method returns {@code true}, and the input is a valid URI after going
-     *     through {@link #toValidPath(String)}, {@link URI#isAbsolute()} is {@code false}</li>
-     * </ul>
-     *
-     * @param requestTarget The HTTP request target
-     * @return {@code true} if this URL is relative
-     */
-    public static boolean isRelative(@NonNull String requestTarget) {
-        // yes this code is weird. There's a fuzz test that checks it against the whatwg spec
-        boolean start = true;
-        for (int i = 0; i < requestTarget.length(); i++) {
-            char c = requestTarget.charAt(i);
-            if (c == '\t' || c == '\n' || c == '\r') {
-                // newline and tab is ignored anywhere.
-                continue;
-            }
-            if (isAsciiLowerAlpha(c) || isAsciiUpperAlpha(c)) {
-                start = false;
-                continue;
-            }
-            if (!start) {
-                if (c == ':') {
-                    return false;
-                }
-                if (isAsciiDigit(c) || c == '+' || c == '-' || c == '.') {
-                    continue;
-                }
-                if (isC0OrSpace(c)) {
-                    // c0 and space are trimmed at start and end, so we are either invalid or at
-                    // the end
-                    break;
-                }
-            } else {
-                if (isC0OrSpace(c)) {
-                    // c0 and space are trimmed at start and end.
-                    continue;
-                }
-            }
-            break;
-        }
-        return true;
-    }
-
-    private static boolean isC0(int c) {
-        return c <= 0x1f;
-    }
-
-    private static boolean isC0OrSpace(char c) {
-        return isC0(c) || c == ' ';
-    }
-
-    private static boolean isAsciiDigit(int c) {
-        return c >= '0' && c <= '9';
-    }
-
-    private static boolean isAsciiUpperHexDigit(int c) {
-        return isAsciiDigit(c) || (c >= 'A' && c <= 'F');
-    }
-
-    private static boolean isAsciiLowerHexDigit(int c) {
-        return isAsciiDigit(c) || (c >= 'a' && c <= 'f');
-    }
-
-    private static boolean isAsciiHexDigit(int c) {
-        return isAsciiLowerHexDigit(c) || isAsciiUpperHexDigit(c);
-    }
-
-    private static boolean isAsciiUpperAlpha(int c) {
-        return c >= 'A' && c <= 'Z';
-    }
-
-    private static boolean isAsciiLowerAlpha(int c) {
-        return c >= 'a' && c <= 'z';
-    }
-}
diff --git a/router/src/test/java/io/micronaut/web/router/uri/PercentDecoder.java b/router/src/test/java/io/micronaut/web/router/uri/PercentDecoder.java
deleted file mode 100644
index 8feb833316..0000000000
--- a/router/src/test/java/io/micronaut/web/router/uri/PercentDecoder.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package io.micronaut.web.router.uri;
-
-import io.micronaut.core.annotation.Nullable;
-
-final class PercentDecoder {
-    private static final short EOF = -1;
-    private static final short INVALID = -2;
-
-    static void decode(StringBuilder dest, StringBuilder in, @Nullable Runnable onError) {
-        outer:
-        for (int i = 0; i < in.length(); i++) {
-            short s = takeByte(in, i);
-            if (s < 0) {
-                dest.append(in.charAt(i));
-                continue;
-            }
-            if (s < 0x80) {
-                dest.append((char) s);
-                i += 2;
-            } else {
-                int n;
-                int cp;
-                int min; // for overlong encoding detection
-                if ((s & 0b11100000) == 0b11000000) {
-                    n = 2;
-                    cp = s & 0b11111;
-                    min = 0b1_0000000;
-                } else if ((s & 0b11110000) == 0b11100000) {
-                    n = 3;
-                    cp = s & 0b1111;
-                    min = 0b1_00000_000000;
-                } else if ((s & 0b11111000) == 0b11110000) {
-                    n = 4;
-                    cp = s & 0b111;
-                    min = 0b1_0000_000000_000000;
-                } else {
-                    if (onError != null) {
-                        onError.run();
-                    }
-                    dest.appendCodePoint(0xfffd);
-                    continue;
-                }
-                for (int j = 1; j < n; j++) {
-                    short then = takeByte(in, i + j * 3);
-                    if (then < 0 || (then & 0b11000000) != 0b10000000) {
-                        if (onError != null) {
-                            onError.run();
-                        }
-                        dest.appendCodePoint(0xfffd);
-                        continue outer;
-                    }
-                    cp = cp * 0b1000000 + (then & 0b111111);
-                }
-                if (cp > Character.MAX_CODE_POINT || cp < min) {
-                    if (onError != null) {
-                        onError.run();
-                    }
-                    dest.appendCodePoint(0xfffd);
-                    continue;
-                }
-                dest.appendCodePoint(cp);
-                i += n * 3 - 1;
-            }
-        }
-    }
-
-    private static short takeByte(CharSequence sequence, int index) {
-        if (index + 2 >= sequence.length()) {
-            return EOF;
-        } else if (sequence.charAt(index) != '%') {
-            return INVALID;
-        }
-        char hi = sequence.charAt(index + 1);
-        char lo = sequence.charAt(index + 2);
-        if (!WhatwgParser.isAsciiHexDigit(hi) || !WhatwgParser.isAsciiHexDigit(lo)) {
-            return INVALID;
-        }
-        return Short.parseShort(sequence.subSequence(index + 1, index + 3).toString(), 16);
-    }
-
-    enum FailureMode {
-        REPLACEMENT,
-        FATAL,
-    }
-}
diff --git a/router/src/test/java/io/micronaut/web/router/uri/UriUtilTest.java b/router/src/test/java/io/micronaut/web/router/uri/UriUtilTest.java
deleted file mode 100644
index 646ce80846..0000000000
--- a/router/src/test/java/io/micronaut/web/router/uri/UriUtilTest.java
+++ /dev/null
@@ -1,99 +0,0 @@
-package io.micronaut.web.router.uri;
-
-import com.code_intelligence.jazzer.api.FuzzedDataProvider;
-import com.code_intelligence.jazzer.junit.FuzzTest;
-import org.junit.jupiter.api.Assertions;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-
-class UriUtilTest {
-    @FuzzTest(maxDuration = "30m")
-    void whatwgUrlCanBeFixedUp(FuzzedDataProvider data) throws URISyntaxException {
-        String input = data.consumeRemainingAsString();
-        WhatwgParser parser = new WhatwgParser(input);
-        parser.setBaseUrl(new WhatwgUrl("http", "", "", "example.com", null, "/", false, null, null));
-        try {
-            parser.parse();
-        } catch (IllegalArgumentException e) {
-            return;
-        }
-        WhatwgUrl url = parser.toUrl();
-        StringBuilder builder = new StringBuilder();
-        builder.append(url.path);
-        if (url.query != null) {
-            builder.append("?").append(url.query);
-        }
-        String valid = UriUtil.toValidPath(builder.toString());
-        URI uri = new URI(valid); // should not throw
-        Assertions.assertEquals(url.query == null, uri.getRawQuery() == null);
-    }
-
-    @FuzzTest(maxDuration = "30m")
-    void validPaths(FuzzedDataProvider data) throws URISyntaxException {
-        String input = data.consumeRemainingAsString();
-        if (!UriUtil.isValidPath(input)) {
-            return;
-        }
-        URI uri = new URI(input); // should not throw
-
-        Assertions.assertFalse(uri.isAbsolute());
-
-        WhatwgParser parser = new WhatwgParser(input);
-        parser.setBaseUrl(new WhatwgUrl("http", "", "", "example.com", null, "/", false, null, null));
-        try {
-            parser.parse();
-        } catch (IllegalArgumentException e) {
-            return;
-        }
-        WhatwgUrl url = parser.toUrl();
-
-        Assertions.assertEquals("example.com", url.host); // check that this really is a relative URI
-        Assertions.assertEquals(url.query == null, uri.getRawQuery() == null);
-    }
-
-    @FuzzTest(maxDuration = "30m")
-    void isRelative(FuzzedDataProvider data) {
-        String input = data.consumeRemainingAsString();
-
-        WhatwgParser parser = new WhatwgParser(input);
-        parser.setBaseUrl(new WhatwgUrl("http", "", "", "example.com", null, "/", false, null, null));
-
-        boolean relative = UriUtil.isRelative(input);
-        if (relative) {
-            try {
-                parser.parse();
-            } catch (IllegalArgumentException e) {
-                return;
-            }
-
-            Assertions.assertEquals("http", parser.toUrl().scheme); // all other fields can still change in a relative uri
-        } else {
-            parser.setStateOverride(WhatwgParser.State.SCHEME_START);
-            try {
-                parser.parse();
-            } catch (IllegalArgumentException e) {
-                if (e.getMessage().equals("Invalid scheme while state override is given") || e.getMessage().equals("Invalid character in scheme")) {
-                    throw e;
-                }
-                return;
-            }
-        }
-
-        if (relative) {
-            try {
-                URI uri = new URI(UriUtil.toValidPath(input));
-                Assertions.assertFalse(uri.isAbsolute());
-            } catch (URISyntaxException ignored) {
-            }
-        }
-
-        URI uri;
-        try {
-            uri = new URI(input);
-        } catch (URISyntaxException e) {
-            return;
-        }
-        Assertions.assertEquals(uri.isAbsolute(), !relative);
-    }
-}
diff --git a/router/src/test/java/io/micronaut/web/router/uri/WhatwgParser.java b/router/src/test/java/io/micronaut/web/router/uri/WhatwgParser.java
deleted file mode 100644
index 453eae2dfe..0000000000
--- a/router/src/test/java/io/micronaut/web/router/uri/WhatwgParser.java
+++ /dev/null
@@ -1,1253 +0,0 @@
-package io.micronaut.web.router.uri;
-
-import com.ibm.icu.text.IDNA;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
-
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.Charset;
-import java.nio.charset.CharsetEncoder;
-import java.nio.charset.CoderResult;
-import java.nio.charset.StandardCharsets;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Set;
-
-final class WhatwgParser {
-    static final Set<String> SPECIAL_SCHEMES = Set.of("http", "https", "ftp", "file", "ws", "wss");
-
-    private State stateOverride = null;
-    private String input;
-    private WhatwgUrl baseUrl = null;
-    private Charset encoding = StandardCharsets.UTF_8;
-    private int pointer = 0;
-    private State state = State.SCHEME_START;
-    private boolean atSignSeen = false;
-    private boolean insideBrackets = false;
-    private boolean passwordTokenSeen = false;
-    private boolean abort = false;
-
-    private boolean schemeMixedCase = false;
-    private final StringBuilder buffer = new StringBuilder();
-
-    private @NonNull String scheme = "";
-    private @NonNull String username = "";
-    private @NonNull String password = "";
-    private @Nullable String host = null;
-    private @Nullable Integer port = null;
-    private final @NonNull StringBuilder path = new StringBuilder();
-    private boolean opaquePath = false;
-    private @Nullable StringBuilder query = null;
-    private @Nullable StringBuilder fragment = null;
-
-    WhatwgParser(String input) {
-        this.input = input;
-    }
-
-    public void setBaseUrl(WhatwgUrl baseUrl) {
-        this.baseUrl = baseUrl;
-    }
-
-    void setInputUrl(WhatwgUrl inputUrl) {
-        this.scheme = inputUrl.scheme;
-        this.username = inputUrl.username;
-        this.password = inputUrl.password;
-        this.host = inputUrl.host;
-        this.port = inputUrl.port;
-        setPath(inputUrl.path, inputUrl.opaquePath);
-        setQuery(inputUrl.query);
-        setFragment(inputUrl.fragment);
-    }
-
-    void setStateOverride(State stateOverride) {
-        this.stateOverride = stateOverride;
-        this.state = stateOverride;
-    }
-
-    private void setPath(String path, boolean opaque) {
-        this.path.setLength(0);
-        this.path.append(path);
-        this.opaquePath = opaque;
-    }
-
-    private void setQuery(@Nullable String query) {
-        if (query == null) {
-            this.query = null;
-        } else if (this.query != null) {
-            this.query.setLength(0);
-            this.query.append(query);
-        } else {
-            this.query = new StringBuilder(query);
-        }
-    }
-
-    private void setFragment(@Nullable String fragment) {
-        if (fragment == null) {
-            this.fragment = null;
-        } else if (this.fragment != null) {
-            this.fragment.setLength(0);
-            this.fragment.append(fragment);
-        } else {
-            this.fragment = new StringBuilder(fragment);
-        }
-    }
-
-    WhatwgUrl toUrl() {
-        return new WhatwgUrl(
-            scheme,
-            username,
-            password,
-            host,
-            port,
-            path.toString(),
-            opaquePath,
-            query == null ? null : query.toString(),
-            fragment == null ? null : fragment.toString()
-        );
-    }
-
-    void parse() {
-        trimWhitespace();
-
-        while (pointer <= input.length() && !abort) {
-            boolean eof = pointer == input.length();
-            int c;
-            int cLen;
-            if (eof) {
-                c = -1;
-                cLen = 1;
-            } else {
-                c = input.charAt(pointer);
-                if (Character.isSurrogate((char) c)) {
-                    if (Character.isHighSurrogate((char) c) && pointer + 1 < input.length()) {
-                        c = Character.toCodePoint((char) c, input.charAt(pointer + 1));
-                        cLen = 2;
-                    } else {
-                        throw failure("Unpaired surrogate");
-                    }
-                } else {
-                    cLen = 1;
-                }
-            }
-            switch (state) {
-                case SCHEME_START -> {
-                    if (isAsciiLowerAlpha(c)) {
-                        state = State.SCHEME;
-                    } else if (isAsciiUpperAlpha(c)) {
-                        schemeMixedCase = true;
-                        state = State.SCHEME;
-                    } else if (stateOverride == null) {
-                        state = State.NO_SCHEME;
-                        pointer -= cLen;
-                    } else {
-                        throw failure("Invalid scheme while state override is given");
-                    }
-                }
-                case SCHEME -> {
-                    if (isAsciiLowerAlpha(c) || isAsciiDigit(c) || c == '+' || c == '-' || c == '.') {
-                        break;
-                    } else if (isAsciiUpperAlpha(c)) {
-                        schemeMixedCase = true;
-                    } else if (c == ':') {
-                        String newScheme = input.substring(0, pointer);
-                        if (schemeMixedCase) {
-                            newScheme = newScheme.toLowerCase(Locale.ROOT);
-                        }
-                        if (stateOverride != null) {
-                            if (SPECIAL_SCHEMES.contains(this.scheme) != SPECIAL_SCHEMES.contains(newScheme)) {
-                                abort = true;
-                                break;
-                            }
-                            if (newScheme.equals("file") && (port != null || !username.isEmpty() || !password.isEmpty())) {
-                                abort = true;
-                                break;
-                            }
-                            if ("file".equals(this.scheme) && "".equals(host)) {
-                                abort = true;
-                                break;
-                            }
-                        }
-                        scheme = newScheme;
-                        if (stateOverride != null) {
-                            if (Objects.equals(port, getDefaultPort(scheme))) {
-                                port = null;
-                            }
-                            abort = true;
-                            break;
-                        }
-                        if (scheme.equals("file")) {
-                            if (input.length() <= pointer + 2 || input.charAt(pointer + 1) != '/' || input.charAt(pointer + 2) != '/') {
-                                validationError(ValidationError.SPECIAL_SCHEME_MISSING_FOLLOWING_SOLIDUS);
-                            }
-                            state = State.FILE;
-                        } else if (SPECIAL_SCHEMES.contains(scheme) && baseUrl != null && scheme.equals(baseUrl.scheme)) {
-                            state = State.SPECIAL_RELATIVE_OR_AUTHORITY;
-                        } else if (SPECIAL_SCHEMES.contains(scheme)) {
-                            state = State.SPECIAL_AUTHORITY_SLASHES;
-                        } else if (input.length() > pointer + 1 && input.charAt(pointer + 1) == '/') {
-                            pointer++;
-                            state = State.PATH_OR_AUTHORITY;
-                        } else {
-                            path.setLength(0);
-                            opaquePath = true;
-                            state = State.OPAQUE_PATH;
-                        }
-                    } else if (stateOverride == null) {
-                        state = State.NO_SCHEME;
-                        pointer = -1;
-                    } else {
-                        throw failure("Invalid character in scheme");
-                    }
-                }
-                case NO_SCHEME -> {
-                    if (baseUrl == null || (c != '#' && baseUrl.opaquePath)) {
-                        throw fatalValidationError(ValidationError.MISSING_SCHEME_NON_RELATIVE_URL);
-                    }
-                    if (baseUrl.opaquePath && c == '#') {
-                        this.scheme = baseUrl.scheme;
-                        setPath(baseUrl.path, baseUrl.opaquePath);
-                        setQuery(baseUrl.query);
-                        setFragment("");
-                        state = State.FRAGMENT;
-                    } else if (!"file".equals(baseUrl.scheme)) {
-                        state = State.RELATIVE;
-                        pointer -= cLen;
-                    } else {
-                        state = State.FILE;
-                        pointer -= cLen;
-                    }
-                }
-                case SPECIAL_RELATIVE_OR_AUTHORITY -> {
-                    if (c == '/' && pointer + 1 < input.length() && input.charAt(pointer + 1) == '/') {
-                        state = State.SPECIAL_AUTHORITY_IGNORE_SLASHES;
-                        pointer++;
-                    } else {
-                        validationError(ValidationError.SPECIAL_SCHEME_MISSING_FOLLOWING_SOLIDUS);
-                        state = State.RELATIVE;
-                        pointer -= cLen;
-                    }
-                }
-                case PATH_OR_AUTHORITY -> {
-                    if (c == '/') {
-                        state = State.AUTHORITY;
-                    } else {
-                        state = State.PATH;
-                        pointer -= cLen;
-                    }
-                }
-                case RELATIVE -> {
-                    assert baseUrl != null;
-                    assert !"file".equals(baseUrl.scheme);
-                    this.scheme = baseUrl.scheme;
-                    if (c == '/') {
-                        state = State.RELATIVE_SLASH;
-                    } else if (SPECIAL_SCHEMES.contains(baseUrl.scheme) && c == '\\') {
-                        validationError(ValidationError.INVALID_REVERSE_SOLIDUS);
-                        state = State.RELATIVE_SLASH;
-                    } else {
-                        this.username = baseUrl.username;
-                        this.password = baseUrl.password;
-                        this.host = baseUrl.host;
-                        this.port = baseUrl.port;
-                        setPath(baseUrl.path, baseUrl.opaquePath);
-                        setQuery(baseUrl.query);
-
-                        if (c == '?') {
-                            setQuery("");
-                            state = State.QUERY;
-                        } else if (c == '#') {
-                            setFragment("");
-                            state = State.FRAGMENT;
-                        } else if (!eof) {
-                            setQuery(null);
-                            shortenPath();
-                            state = State.PATH;
-                            pointer -= cLen;
-                        }
-                    }
-                }
-                case RELATIVE_SLASH -> {
-                    if (SPECIAL_SCHEMES.contains(scheme) && (c == '\\' || c == '/')) {
-                        if (c == '\\') {
-                            validationError(ValidationError.INVALID_REVERSE_SOLIDUS);
-                        }
-                        state = State.SPECIAL_AUTHORITY_IGNORE_SLASHES;
-                    } else if (c == '/') {
-                        state = State.AUTHORITY;
-                    } else {
-                        this.username = baseUrl.username;
-                        this.password = baseUrl.password;
-                        this.host = baseUrl.host;
-                        this.port = baseUrl.port;
-                        state = State.PATH;
-                        pointer -= cLen;
-                    }
-                }
-                case SPECIAL_AUTHORITY_SLASHES -> {
-                    if (c == '/' && pointer + 1 < input.length() && input.charAt(pointer + 1) == '/') {
-                        state = State.SPECIAL_AUTHORITY_IGNORE_SLASHES;
-                        pointer++;
-                    } else {
-                        validationError(ValidationError.SPECIAL_SCHEME_MISSING_FOLLOWING_SOLIDUS);
-                        state = State.SPECIAL_AUTHORITY_IGNORE_SLASHES;
-                        pointer -= cLen;
-                    }
-                }
-                case SPECIAL_AUTHORITY_IGNORE_SLASHES -> {
-                    if (c != '/' && c != '\\') {
-                        state = State.AUTHORITY;
-                        pointer -= cLen;
-                    } else {
-                        validationError(ValidationError.SPECIAL_SCHEME_MISSING_FOLLOWING_SOLIDUS);
-                    }
-                }
-                case AUTHORITY -> {
-                    if (c == '@') {
-                        validationError(ValidationError.INVALID_CREDENTIALS);
-                        if (atSignSeen) {
-                            buffer.insert(0, "%40");
-                        }
-                        atSignSeen = true;
-                        StringBuilder dst = passwordTokenSeen ? new StringBuilder(password) : new StringBuilder(username);
-                        for (int i = 0; i < buffer.length(); i++) {
-                            int cp = buffer.charAt(i);
-                            if (Character.isHighSurrogate((char) cp)) {
-                                cp = buffer.codePointAt(i);
-                                i++;
-                            }
-                            if (cp == ':' && !passwordTokenSeen) {
-                                passwordTokenSeen = true;
-                                username = dst.toString();
-                                dst = new StringBuilder(password);
-                                continue;
-                            }
-                            PercentEncoder.USERINFO.encodeUtf8(dst, cp);
-                        }
-                        if (passwordTokenSeen) {
-                            password = dst.toString();
-                        } else {
-                            username = dst.toString();
-                        }
-                        buffer.setLength(0);
-                    } else if (eof || c == '/' || c == '?' || c == '#' || (SPECIAL_SCHEMES.contains(scheme) && c == '\\')) {
-                        if (atSignSeen && buffer.isEmpty()) {
-                            throw fatalValidationError(ValidationError.HOST_MISSING);
-                        } else {
-                            pointer -= buffer.length() + 1;
-                            buffer.setLength(0);
-                            state = State.HOST;
-                        }
-                    } else {
-                        buffer.appendCodePoint(c);
-                    }
-                }
-                case HOST, HOSTNAME -> {
-                    if (stateOverride != null && scheme.equals("file")) {
-                        pointer -= cLen;
-                        state = State.FILE_HOST;
-                    } else if (c == ':' && !insideBrackets) {
-                        if (buffer.isEmpty()) {
-                            throw fatalValidationError(ValidationError.HOST_MISSING);
-                        }
-                        if (stateOverride == State.HOSTNAME) {
-                            abort = true;
-                            break;
-                        }
-                        host = hostParse(buffer, !SPECIAL_SCHEMES.contains(scheme));
-                        buffer.setLength(0);
-                        state = State.PORT;
-                    } else if (eof || c == '/' || c == '?' || c == '#' || (SPECIAL_SCHEMES.contains(scheme) && c == '\\')) {
-                        pointer -= cLen;
-                        if (SPECIAL_SCHEMES.contains(scheme) && buffer.isEmpty()) {
-                            throw fatalValidationError(ValidationError.HOST_MISSING);
-                        } else if (stateOverride != null && buffer.isEmpty() && (!username.isEmpty() || !password.isEmpty() || port != null)) {
-                            abort = true;
-                            break;
-                        }
-                        host = hostParse(buffer, !SPECIAL_SCHEMES.contains(scheme));
-                        buffer.setLength(0);
-                        state = State.PATH_START;
-                        if (stateOverride != null) {
-                            abort = true;
-                        }
-                    } else {
-                        if (c == '[') {
-                            insideBrackets = true;
-                        } else if (c == ']') {
-                            insideBrackets = false;
-                        }
-                        buffer.appendCodePoint(c);
-                    }
-                }
-                case PORT -> {
-                    if (isAsciiDigit(c)) {
-                        buffer.appendCodePoint(c);
-                    } else if (eof || c == '/' || c == '?' || c == '#' || (SPECIAL_SCHEMES.contains(scheme) && c == '\\') || stateOverride != null) {
-                        if (!buffer.isEmpty()) {
-                            int p;
-                            try {
-                                p = Integer.parseInt(buffer.toString());
-                            } catch (NumberFormatException e) {
-                                // only happens on out-of-range
-                                throw fatalValidationError(ValidationError.PORT_OUT_OF_RANGE);
-                            }
-                            if (p > 0xffff) {
-                                throw fatalValidationError(ValidationError.PORT_OUT_OF_RANGE);
-                            }
-                            if (Objects.equals(getDefaultPort(scheme), p)) {
-                                this.port = null;
-                            } else {
-                                this.port = p;
-                            }
-                            buffer.setLength(0);
-                        }
-                        if (stateOverride != null) {
-                            abort = true;
-                        }
-                        state = State.PATH_START;
-                        pointer -= cLen;
-                    } else {
-                        throw fatalValidationError(ValidationError.PORT_INVALID);
-                    }
-                }
-                case FILE -> {
-                    scheme = "file";
-                    host = "";
-                    if (c == '/' || c == '\\') {
-                        if (c == '\\') {
-                            validationError(ValidationError.INVALID_REVERSE_SOLIDUS);
-                        }
-                        state = State.FILE_SLASH;
-                    } else if (baseUrl != null && "file".equals(baseUrl.scheme)) {
-                        this.host = baseUrl.host;
-                        setPath(baseUrl.path, baseUrl.opaquePath);
-                        setQuery(baseUrl.query);
-
-                        if (c == '?') {
-                            setQuery("");
-                            state = State.QUERY;
-                        } else if (c == '#') {
-                            setFragment("");
-                            state = State.FRAGMENT;
-                        } else if (!eof) {
-                            setQuery(null);
-                            if (!startsWithWindowsDriveLetter(input, pointer)) {
-                                shortenPath();
-                            } else {
-                                validationError(ValidationError.FILE_INVALID_WINDOWS_DRIVE_LETTER);
-                                setPath("", false);
-                            }
-                            state = State.PATH;
-                            pointer -= cLen;
-                        }
-                    } else {
-                        state = State.PATH;
-                        pointer -= cLen;
-                    }
-                }
-                case FILE_SLASH -> {
-                    if (c == '/' || c == '\\') {
-                        if (c == '\\') {
-                            validationError(ValidationError.INVALID_REVERSE_SOLIDUS);
-                        }
-                        state = State.FILE_HOST;
-                    } else {
-                        if (baseUrl != null && "file".equals(baseUrl.scheme)) {
-                            this.host = baseUrl.host;
-                            if (!startsWithWindowsDriveLetter(input, pointer)) {
-                                String basePath = baseUrl.path;
-                                int i = basePath.indexOf('/', 1);
-                                int end = i == -1 ? basePath.length() : i;
-                                if (isNormalizedWindowsDriveLetter(basePath, 1, end)) {
-                                    appendToPath(basePath, 1, end);
-                                }
-                            }
-                        }
-                        state = State.PATH;
-                        pointer -= cLen;
-                    }
-                }
-                case FILE_HOST -> {
-                    if (eof || c == '/' || c == '\\' || c == '?' || c == '#') {
-                        pointer -= cLen;
-                        if (stateOverride == null && isWindowsDriveLetter(buffer)) {
-                            validationError(ValidationError.FILE_INVALID_WINDOWS_DRIVE_LETTER_HOST);
-                            state = State.PATH;
-                        } else if (buffer.isEmpty()) {
-                            host = "";
-                            if (stateOverride != null) {
-                                abort = true;
-                            }
-                            state = State.PATH_START;
-                        } else {
-                            host = hostParse(buffer, !SPECIAL_SCHEMES.contains(scheme));
-                            if (host.equals("localhost")) {
-                                host = "";
-                            }
-                            if (stateOverride != null) {
-                                abort = true;
-                            }
-                            buffer.setLength(0);
-                            state = State.PATH_START;
-                        }
-                    } else {
-                        buffer.appendCodePoint(c);
-                    }
-                }
-                case PATH_START -> {
-                    if (SPECIAL_SCHEMES.contains(scheme)) {
-                        if (c == '\\') {
-                            validationError(ValidationError.INVALID_REVERSE_SOLIDUS);
-                        }
-                        state = State.PATH;
-                        if (c != '/' && c != '\\') {
-                            pointer -= cLen;
-                        }
-                    } else if (stateOverride == null && c == '?') {
-                        setQuery("");
-                        state = State.QUERY;
-                    } else if (stateOverride == null && c == '#') {
-                        setFragment("");
-                        state = State.FRAGMENT;
-                    } else if (!eof) {
-                        state = State.PATH;
-                        if (c != '/') {
-                            pointer -= cLen;
-                        }
-                    } else if (stateOverride != null && host != null) {
-                        appendToPath("");
-                    }
-                }
-                case PATH -> {
-                    if (eof || c == '/' || (SPECIAL_SCHEMES.contains(scheme) && c == '\\') || (stateOverride == null && (c == '?' || c == '#'))) {
-                        if (SPECIAL_SCHEMES.contains(scheme) && c == '\\') {
-                            validationError(ValidationError.INVALID_REVERSE_SOLIDUS);
-                        }
-                        if (isDoubleDotUrlPathSegment(buffer)) {
-                            shortenPath();
-                            if (c != '/' && (c != '\\' || !SPECIAL_SCHEMES.contains(scheme))) {
-                                appendToPath("");
-                            }
-                        } else if (isSingleDotUrlPathSegment(buffer) && c != '/' && (c != '\\' || !SPECIAL_SCHEMES.contains(scheme))) {
-                            appendToPath("");
-                        } else if (!isSingleDotUrlPathSegment(buffer)) {
-                            if (scheme.equals("file") && path.isEmpty() && isWindowsDriveLetter(buffer)) {
-                                buffer.setCharAt(1, ':');
-                            }
-                            appendToPath(buffer);
-                        }
-                        buffer.setLength(0);
-                        if (c == '?') {
-                            setQuery("");
-                            state = State.QUERY;
-                        } else if (c == '#') {
-                            setFragment("");
-                            state = State.FRAGMENT;
-                        }
-                    } else {
-                        validateCodePoint(c);
-                        PercentEncoder.PATH.encodeUtf8(buffer, c);
-                    }
-                }
-                case OPAQUE_PATH -> {
-                    if (c == '?') {
-                        setQuery("");
-                        state = State.QUERY;
-                    } else if (c == '#') {
-                        setFragment("");
-                        state = State.FRAGMENT;
-                    } else if (!eof) {
-                        validateCodePoint(c);
-                        PercentEncoder.C0.encodeUtf8(path, c);
-                    }
-                }
-                case QUERY -> {
-                    if (!encoding.equals(StandardCharsets.UTF_8) && (!SPECIAL_SCHEMES.contains(scheme) || scheme.equals("ws") || scheme.equals("wss"))) {
-                        encoding = StandardCharsets.UTF_8;
-                    }
-                    if (eof || (stateOverride == null && c == '#')) {
-                        PercentEncoder queryPercentEncodeSet = SPECIAL_SCHEMES.contains(scheme) ? PercentEncoder.SPECIAL_QUERY : PercentEncoder.QUERY;
-                        percentEncodeAfterEncoding(query, encoding, buffer, queryPercentEncodeSet, false);
-                        buffer.setLength(0);
-                        if (c == '#') {
-                            setFragment("");
-                            state = State.FRAGMENT;
-                        }
-                    } else {
-                        validateCodePoint(c);
-                        buffer.appendCodePoint(c);
-                    }
-                }
-                case FRAGMENT -> {
-                    if (!eof) {
-                        validateCodePoint(c);
-                        PercentEncoder.FRAGMENT.encodeUtf8(fragment, c);
-                    }
-                }
-                default -> throw new AssertionError("Unexpected value: " + state);
-            }
-            pointer += cLen;
-        }
-    }
-
-    private void validateCodePoint(int c) {
-        if (!isUrlCodePoint(c) && c != '%') {
-            validationError(ValidationError.INVALID_URL_UNIT);
-        }
-        if (c == '%' && (pointer + 2 >= input.length() || !isAsciiHexDigit(input.charAt(pointer + 1)) || !isAsciiHexDigit(input.charAt(pointer + 2)))) {
-            validationError(ValidationError.INVALID_URL_UNIT);
-        }
-    }
-
-    private void appendToPath(CharSequence s) {
-        appendToPath(s, 0, s.length());
-    }
-
-    private void appendToPath(CharSequence s, int start, int end) {
-        if (!opaquePath) {
-            path.append('/');
-        }
-        path.append(s, start, end);
-    }
-
-    private void trimWhitespace() {
-        StringBuilder trimmed = null;
-        if (!input.isEmpty() && (isC0OrSpace(input.charAt(0)) || isC0OrSpace(input.charAt(input.length() - 1)))) {
-            validationError(ValidationError.INVALID_URL_UNIT);
-
-            trimmed = new StringBuilder(input);
-            // remove trailing, O(n)
-            while (!trimmed.isEmpty() && isC0OrSpace(trimmed.charAt(trimmed.length() - 1))) {
-                trimmed.setLength(trimmed.length() - 1);
-            }
-            // remove leading, O(n)
-            int n = 0;
-            while (n < trimmed.length() && isC0OrSpace(trimmed.charAt(n))) {
-                n++;
-            }
-            trimmed.delete(0, n);
-        }
-        if (trimmed == null ? hasTabOrNewline(input) : hasTabOrNewline(trimmed)) {
-            validationError(ValidationError.INVALID_URL_UNIT);
-
-            CharSequence source = trimmed == null ? input : trimmed;
-            // can't do this in the existing `trimmed` StringBuilder because it would be O(n)
-            StringBuilder trimmed2 = new StringBuilder(source.length());
-            for (int i = 0; i < source.length(); i++) {
-                char c = source.charAt(i);
-                if (!isTabOrNewline(c)) {
-                    trimmed2.append(c);
-                }
-            }
-            input = trimmed2.toString();
-        } else if (trimmed != null) {
-            input = trimmed.toString();
-        }
-    }
-
-    private void validationError(ValidationError error) {
-
-    }
-
-    private String hostParse(StringBuilder buffer, boolean isOpaque) {
-        if (!buffer.isEmpty() && buffer.charAt(0) == '[') {
-            if (buffer.charAt(buffer.length() - 1) != ']') {
-                throw fatalValidationError(ValidationError.IPV6_UNCLOSED);
-            }
-            buffer.setLength(buffer.length() - 1);
-            StringBuilder out = new StringBuilder("[");
-            ipv6Serialize(out, ipv6Parse(buffer, 1));
-            out.append(']');
-            return out.toString();
-        }
-        if (isOpaque) {
-            StringBuilder out = new StringBuilder(buffer.length());
-            for (int i = 0; i < buffer.length(); ) {
-                int c = buffer.codePointAt(i);
-                if (isForbiddenHostCodePoint(c)) {
-                    throw fatalValidationError(ValidationError.HOST_INVALID_CODE_POINT);
-                }
-                validateCodePoint(c);
-                PercentEncoder.C0.encodeUtf8(out, c);
-                i += Character.charCount(c);
-            }
-            return out.toString();
-        }
-        assert !buffer.isEmpty();
-        StringBuilder decoded = new StringBuilder(buffer.length());
-        PercentDecoder.decode(decoded, buffer, null);
-        String asciiDomain = domainToAscii(decoded.toString(), false);
-        if (endsInANumber(asciiDomain)) {
-            StringBuilder out = new StringBuilder();
-            ipv4Serialize(out, ipv4Parse(asciiDomain));
-            return out.toString();
-        } else {
-            return asciiDomain;
-        }
-    }
-
-    private static boolean isForbiddenHostCodePoint(int c) {
-        return c == 0 || c == '\t' || c == '\r' || c == '\n' || c == ' ' || c == '#' ||
-            c == '/' || c == ':' || c == '<' || c == '>' || c == '?' || c == '@' ||
-            c == '[' || c == '\\' || c == ']' || c == '^' || c == '|';
-    }
-
-    private static boolean isForbiddenDomainCodePoint(int c) {
-        return isForbiddenHostCodePoint(c) || isC0(c) || c == '%' || c == 0x7f;
-    }
-
-    private String domainToAscii(String s, boolean beStrict) {
-        StringBuilder dest = new StringBuilder();
-        idnaToAscii(dest, s, beStrict);
-        // todo: these two checks should be unnecessary for beStrict
-        if (dest.isEmpty()) {
-            throw fatalValidationError(ValidationError.DOMAIN_TO_ASCII);
-        }
-        for (int i = 0; i < dest.length(); i++) {
-            // only some ascii chars are forbidden, so we don't have to use codePointAt here
-            if (isForbiddenDomainCodePoint(dest.charAt(i))) {
-                throw fatalValidationError(ValidationError.DOMAIN_INVALID_CODE_POINT);
-            }
-        }
-        return dest.toString();
-    }
-
-    void idnaToAscii(StringBuilder dest, String input, boolean beStrict) {
-        int flags = IDNA.CHECK_BIDI | IDNA.CHECK_CONTEXTJ | IDNA.NONTRANSITIONAL_TO_ASCII;
-        if (beStrict) {
-            flags |= IDNA.USE_STD3_RULES;
-        }
-        IDNA idna = IDNA.getUTS46Instance(flags);
-        IDNA.Info info = new IDNA.Info();
-        idna.nameToASCII(input, dest, info);
-        if (info.hasErrors()) {
-            for (IDNA.Error error : info.getErrors()) {
-                switch (error) {
-                    case LEADING_HYPHEN, TRAILING_HYPHEN, HYPHEN_3_4, LABEL_TOO_LONG,
-                         DOMAIN_NAME_TOO_LONG -> {
-                        if (beStrict) {
-                            throw fatalValidationError(ValidationError.DOMAIN_TO_ASCII);
-                        }
-                    }
-                    case BIDI, CONTEXTJ, PUNYCODE, LABEL_HAS_DOT, LEADING_COMBINING_MARK,
-                         DISALLOWED, INVALID_ACE_LABEL ->
-                        throw fatalValidationError(ValidationError.DOMAIN_TO_ASCII);
-                    case CONTEXTO_PUNCTUATION, CONTEXTO_DIGITS ->
-                        throw new AssertionError("ContextO checking should not be enabled");
-                    case EMPTY_LABEL -> {
-                    }
-                }
-            }
-        }
-    }
-
-    private static boolean endsInANumber(String s) {
-        if (s.isEmpty()) {
-            return false;
-        }
-        int from = s.lastIndexOf('.');
-        int to = s.length();
-        if (from == s.length() - 1) {
-            from = s.lastIndexOf('.', from - 1);
-            to--;
-        }
-        from++;
-        if (from == to) {
-            return false;
-        }
-        return isValidIpv4Number(s, from, to);
-    }
-
-    private static boolean isValidIpv4Number(String s, int from, int to) {
-        boolean decimal = true;
-        for (int i = from; i < to; i++) {
-            decimal &= isAsciiDigit(s.charAt(i));
-        }
-        if (decimal) {
-            return true;
-        }
-        // try hex parsing
-        if (to - from < 2 || s.charAt(from) != '0' || (s.charAt(from + 1) != 'x' && s.charAt(from + 1) != 'X')) {
-            return false;
-        }
-        for (int i = from + 2; i < to; i++) {
-            if (!isAsciiHexDigit(s.charAt(i))) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    private int ipv4Parse(String s) {
-        int[] dotIndices = new int[4];
-        int pieceCount;
-        dotIndices[0] = s.indexOf('.');
-        dotIndices[1] = s.indexOf('.', dotIndices[0] + 1);
-        dotIndices[2] = s.indexOf('.', dotIndices[1] + 1);
-        dotIndices[3] = s.indexOf('.', dotIndices[2] + 1);
-        if (dotIndices[1] == -1 || dotIndices[2] == -1 || dotIndices[3] == -1) {
-            if (dotIndices[0] == -1) {
-                pieceCount = 1;
-            } else if (dotIndices[1] == -1) {
-                pieceCount = 2;
-            } else if (dotIndices[2] == -1) {
-                pieceCount = 3;
-            } else {
-                pieceCount = 4;
-            }
-            dotIndices[pieceCount - 1] = s.length();
-        } else {
-            pieceCount = 5;
-        }
-        if (pieceCount > 1 && dotIndices[pieceCount - 2] == s.length() - 1) {
-            validationError(ValidationError.IPV4_EMPTY_PART);
-            pieceCount--;
-        } else if (pieceCount > 4) {
-            throw fatalValidationError(ValidationError.IPV4_TOO_MANY_PARTS);
-        }
-        int ipv4 = ipv4NumberParse(s, pieceCount == 1 ? 0 : dotIndices[pieceCount - 2] + 1, dotIndices[pieceCount - 1]);
-        if (pieceCount > 1 && (ipv4 >>> (8 * (5 - pieceCount))) != 0) {
-            throw fatalValidationError(ValidationError.IPV4_OUT_OF_RANGE_PART);
-        }
-        for (int i = 0; i < pieceCount - 1; i++) {
-            int part = ipv4NumberParse(s, i == 0 ? 0 : dotIndices[i - 1] + 1, dotIndices[i]);
-            if (part < 0 || part >= 256) {
-                throw fatalValidationError(ValidationError.IPV4_OUT_OF_RANGE_PART);
-            }
-            ipv4 |= part << (8 * (3 - i));
-        }
-        return ipv4;
-    }
-
-    private int ipv4NumberParse(String s, int from, int to) {
-        if (!isValidIpv4Number(s, from, to) || from == to) {
-            throw failure("Invalid IPv4 number");
-        }
-        // the strict syntax checks are in isValidIpv4Number
-        int radix;
-        if (to - from >= 2 && (s.charAt(from + 1) == 'x' || s.charAt(from + 1) == 'X')) {
-            from += 2;
-            radix = 16;
-        } else if (to - from >= 2 && s.charAt(from) == '0') {
-            from++;
-            radix = 8;
-        } else {
-            radix = 10;
-        }
-        if (to <= from) {
-            validationError(ValidationError.IPV4_NON_DECIMAL_PART);
-            return 0;
-        }
-        try {
-            return Integer.parseUnsignedInt(s.substring(from, to), radix);
-        } catch (NumberFormatException e) {
-            throw failure("Failed to parse IPv4: " + e.getMessage());
-        }
-    }
-
-    private short[] ipv6Parse(CharSequence cs, int ptr) {
-        short[] pieces = new short[8];
-        int pieceIndex = 0;
-        int compress = -1;
-        if (cs.length() > ptr && cs.charAt(ptr) == ':') {
-            if (cs.length() == ptr + 1 || cs.charAt(ptr + 1) != ':') {
-                throw fatalValidationError(ValidationError.IPV6_INVALID_COMPRESSION);
-            }
-            ptr += 2;
-            pieceIndex = 1;
-            compress = pieceIndex;
-        }
-        while (ptr < cs.length()) {
-            if (pieceIndex >= 8) {
-                throw fatalValidationError(ValidationError.IPV6_TOO_MANY_PIECES);
-            }
-            char c = cs.charAt(ptr);
-            if (c == ':') {
-                if (compress != -1) {
-                    throw fatalValidationError(ValidationError.IPV6_MULTIPLE_COMPRESSION);
-                }
-                ptr++;
-                pieceIndex++;
-                compress = pieceIndex;
-                continue;
-            }
-            int value = 0;
-            int length = 0;
-            while (length < 4 && isAsciiHexDigit(c)) {
-                value = value * 0x10 + Integer.parseInt(Character.toString(c), 16);
-                ptr++;
-                length++;
-                c = ptr >= cs.length() ? 0 : cs.charAt(ptr);
-            }
-            if (c == '.') {
-                if (length == 0) {
-                    throw fatalValidationError(ValidationError.IPV4_IN_IPV6_INVALID_CODE_POINT);
-                }
-                ptr -= length;
-                c = cs.charAt(ptr);
-                if (pieceIndex > 6) {
-                    throw fatalValidationError(ValidationError.IPV4_IN_IPV6_TOO_MANY_PIECES);
-                }
-                int numbersSeen = 0;
-                while (ptr < cs.length()) {
-                    int ipv4Piece = -1;
-                    if (numbersSeen > 0) {
-                        if (c == '.' && numbersSeen < 4) {
-                            ptr++;
-                            c = ptr >= cs.length() ? 0 : cs.charAt(ptr);
-                        } else {
-                            throw fatalValidationError(ValidationError.IPV4_IN_IPV6_INVALID_CODE_POINT);
-                        }
-                    }
-                    if (!isAsciiDigit(c)) {
-                        throw fatalValidationError(ValidationError.IPV4_IN_IPV6_INVALID_CODE_POINT);
-                    }
-                    do {
-                        int number = c - '0';
-                        if (ipv4Piece == -1) {
-                            ipv4Piece = number;
-                        } else if (ipv4Piece == 0) {
-                            throw fatalValidationError(ValidationError.IPV4_IN_IPV6_INVALID_CODE_POINT);
-                        } else {
-                            ipv4Piece = ipv4Piece * 10 + number;
-                        }
-                        if (ipv4Piece > 255) {
-                            throw fatalValidationError(ValidationError.IPV4_IN_IPV6_OUT_OF_RANGE_PART);
-                        }
-                        ptr++;
-                        c = ptr >= cs.length() ? 0 : cs.charAt(ptr);
-                    } while (isAsciiDigit(c));
-                    pieces[pieceIndex] = (short) (pieces[pieceIndex] * 0x100 + ipv4Piece);
-                    numbersSeen++;
-                    if (numbersSeen == 2 || numbersSeen == 4) {
-                        pieceIndex++;
-                    }
-                }
-                if (numbersSeen != 4) {
-                    throw fatalValidationError(ValidationError.IPV4_IN_IPV6_TOO_FEW_PARTS);
-                }
-                break;
-            } else if (c == ':') {
-                ptr++;
-                if (ptr >= cs.length()) {
-                    throw fatalValidationError(ValidationError.IPV6_INVALID_CODE_POINT);
-                }
-                c = cs.charAt(ptr);
-            } else if (ptr < cs.length()) {
-                throw fatalValidationError(ValidationError.IPV6_INVALID_CODE_POINT);
-            }
-            pieces[pieceIndex++] = (short) value;
-        }
-        if (compress != -1) {
-            int swaps = pieceIndex - compress;
-            pieceIndex = 7;
-            while (pieceIndex != 0 && swaps > 0) {
-                short a = pieces[pieceIndex];
-                pieces[pieceIndex] = pieces[compress + swaps - 1];
-                pieces[compress + swaps - 1] = a;
-                pieceIndex--;
-                swaps--;
-            }
-        } else {
-            if (pieceIndex != 8) {
-                throw fatalValidationError(ValidationError.IPV6_TOO_FEW_PIECES);
-            }
-        }
-        return pieces;
-    }
-
-    private static void ipv4Serialize(StringBuilder dest, int ipv4) {
-        for (int i = 0; i < 4; i++) {
-            if (i != 0) {
-                dest.append('.');
-            }
-            dest.append((ipv4 >>> 8 * (3 - i)) & 0xff);
-        }
-    }
-
-    private static void ipv6Serialize(StringBuilder dest, short[] ipv6) {
-        int compress = findCompressedPieceIndex(ipv6);
-        boolean ignore0 = false;
-        for (int i = 0; i < ipv6.length; i++) {
-            if (ignore0 && ipv6[i] == 0) {
-                continue;
-            }
-            ignore0 = false;
-            if (compress == i) {
-                dest.append(i == 0 ? "::" : ":");
-                ignore0 = true;
-                continue;
-            }
-            dest.append(Integer.toHexString(ipv6[i] & 0xffff));
-            if (i != 7) {
-                dest.append(":");
-            }
-        }
-    }
-
-    private static int findCompressedPieceIndex(short[] ipv6) {
-        int longestIndex = -1;
-        int longestSize = 1;
-        int foundIndex = -1;
-        int foundSize = 0;
-        for (int i = 0; i < ipv6.length; i++) {
-            if (ipv6[i] != 0) {
-                if (foundSize > longestSize) {
-                    longestIndex = foundIndex;
-                    longestSize = foundSize;
-                }
-                foundIndex = -1;
-                foundSize = 0;
-            } else {
-                if (foundIndex == -1) {
-                    foundIndex = i;
-                }
-                foundSize++;
-            }
-        }
-        return foundSize > longestSize ? foundIndex : longestIndex;
-    }
-
-    private void shortenPath() {
-        assert !opaquePath;
-        if (!scheme.equals("file") || !isNormalizedWindowsDriveLetter(path, 1, path.length())) {
-            int i = path.lastIndexOf("/");
-            if (i != -1) {
-                path.setLength(i);
-            }
-        }
-    }
-
-    private IllegalArgumentException fatalValidationError(ValidationError error) {
-        validationError(error);
-        return new IllegalArgumentException(error.toString());
-    }
-
-    private IllegalArgumentException failure(String message) {
-        return new IllegalArgumentException(message);
-    }
-
-    private static boolean isC0(int c) {
-        return c <= 0x1f;
-    }
-
-    private static boolean isC0OrSpace(char c) {
-        return isC0(c) || c == ' ';
-    }
-
-    private static boolean isControl(char c) {
-        return isC0(c) || (c >= 0x7f && c <= 0x9f);
-    }
-
-    private static boolean isAsciiDigit(int c) {
-        return c >= '0' && c <= '9';
-    }
-
-    private static boolean isAsciiUpperHexDigit(int c) {
-        return isAsciiDigit(c) || (c >= 'A' && c <= 'F');
-    }
-
-    private static boolean isAsciiLowerHexDigit(int c) {
-        return isAsciiDigit(c) || (c >= 'a' && c <= 'f');
-    }
-
-    static boolean isAsciiHexDigit(int c) {
-        return isAsciiLowerHexDigit(c) || isAsciiUpperHexDigit(c);
-    }
-
-    private static boolean isAsciiUpperAlpha(int c) {
-        return c >= 'A' && c <= 'Z';
-    }
-
-    private static boolean isAsciiLowerAlpha(int c) {
-        return c >= 'a' && c <= 'z';
-    }
-
-    private static boolean isAsciiAlpha(char c) {
-        return isAsciiUpperAlpha(c) || isAsciiLowerAlpha(c);
-    }
-
-    private static boolean isAsciiAlphanumeric(char c) {
-        return isAsciiAlpha(c) || isAsciiDigit(c);
-    }
-
-    private static boolean isTabOrNewline(char c) {
-        return c == '\t' || c == '\r' || c == '\n';
-    }
-
-    private static boolean hasTabOrNewline(CharSequence input) {
-        for (int i = 0; i < input.length(); i++) {
-            if (isTabOrNewline(input.charAt(i))) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    @Nullable
-    private static Integer getDefaultPort(String scheme) {
-        return switch (scheme) {
-            case "ftp" -> 21;
-            case "http", "ws" -> 80;
-            case "https", "wss" -> 443;
-            default -> null;
-        };
-    }
-
-    private static boolean isWindowsDriveLetter(CharSequence input) {
-        return input.length() == 2 && isAsciiAlpha(input.charAt(0)) && (input.charAt(1) == ':' || input.charAt(1) == '|');
-    }
-
-    private static boolean isNormalizedWindowsDriveLetter(CharSequence input, int start, int end) {
-        return end == 2 + start && isAsciiAlpha(input.charAt(start)) && input.charAt(start + 1) == ':';
-    }
-
-    private static boolean startsWithWindowsDriveLetter(CharSequence input, int start) {
-        if (input.length() - start < 2) {
-            return false;
-        }
-        if (input.length() - start >= 3) {
-            char third = input.charAt(start + 2);
-            if (third != '/' && third != '\\' && third != '?' && third != '#') {
-                return false;
-            }
-        }
-        char c = input.charAt(start + 1);
-        return isAsciiAlpha(input.charAt(start)) && (c == ':' || c == '|');
-    }
-
-    private static boolean isDoubleDotUrlPathSegment(CharSequence input) {
-        if (input.length() == 2) {
-            return "..".contentEquals(input);
-        } else if (input.length() == 4) {
-            return ".%2e".contentEquals(input) || ".%2E".contentEquals(input) ||
-                "%2e.".contentEquals(input) || "%2E.".contentEquals(input);
-        } else if (input.length() == 6) {
-            return "%2e%2e".contentEquals(input) || "%2e%2E".contentEquals(input) ||
-                "%2E%2e".contentEquals(input) || "%2E%2E".contentEquals(input);
-        } else {
-            return false;
-        }
-    }
-
-    private static boolean isSingleDotUrlPathSegment(CharSequence input) {
-        return ".".contentEquals(input) || "%2e".contentEquals(input) || "%2E".contentEquals(input);
-    }
-
-    private static boolean isUrlCodePoint(int codePoint) {
-        if (codePoint < 0xa0) {
-            char c = (char) codePoint;
-            if (isAsciiAlphanumeric(c)) {
-                return true;
-            }
-            return "!$&'()*+,-./:;=?@_~".indexOf(c) != -1;
-        } else {
-            if (codePoint > 0x10fff) {
-                return false;
-            }
-            if (codePoint <= Character.MAX_VALUE) {
-                char c = (char) codePoint;
-                if (Character.isSurrogate(c)) {
-                    return false;
-                }
-            }
-            if ((codePoint >= 0xfdd0 && codePoint <= 0xfdef) ||
-                (codePoint >= 0xfffe && ((codePoint & 0xfff) == 0xffe || (codePoint & 0xfff) == 0xfff))) {
-                return false;
-            }
-            return true;
-        }
-    }
-
-    private static void percentEncodeAfterEncoding(StringBuilder dest, Charset charset, CharSequence input, PercentEncoder percentEncoder, boolean spaceAsPlus) {
-        CharsetEncoder encoder = charset.newEncoder();
-        CharBuffer inputBuffer = CharBuffer.wrap(input);
-        ByteBuffer outputBuffer = ByteBuffer.allocate(1024);
-        while (true) {
-            CoderResult result = encoder.encode(inputBuffer, outputBuffer, true);
-            outputBuffer.flip();
-            while (outputBuffer.hasRemaining()) {
-                byte b = outputBuffer.get();
-                if (b == ' ' && spaceAsPlus) {
-                    dest.append('+');
-                } else {
-                    percentEncoder.encodeByte(dest, b);
-                }
-            }
-            outputBuffer.flip();
-            if (result == CoderResult.OVERFLOW) {
-                continue;
-            }
-            if (result.isError()) {
-                dest.append("%26%23");
-                char high = inputBuffer.get();
-                if (Character.isHighSurrogate(high)) {
-                    dest.append(Character.toCodePoint(high, inputBuffer.get()));
-                } else {
-                    dest.append((int) high);
-                }
-                dest.append("%3B");
-            }
-            break;
-        }
-    }
-
-    private enum ValidationError {
-        DOMAIN_TO_ASCII,
-        DOMAIN_INVALID_CODE_POINT,
-        DOMAIN_TO_UNICODE,
-
-        HOST_INVALID_CODE_POINT,
-        IPV4_EMPTY_PART,
-        IPV4_TOO_MANY_PARTS,
-        IPV4_NON_NUMERIC_PART,
-        IPV4_NON_DECIMAL_PART,
-        IPV4_OUT_OF_RANGE_PART,
-        IPV6_UNCLOSED,
-        IPV6_INVALID_COMPRESSION,
-        IPV6_TOO_MANY_PIECES,
-        IPV6_MULTIPLE_COMPRESSION,
-        IPV6_INVALID_CODE_POINT,
-        IPV6_TOO_FEW_PIECES,
-        IPV4_IN_IPV6_TOO_MANY_PIECES,
-        IPV4_IN_IPV6_INVALID_CODE_POINT,
-        IPV4_IN_IPV6_OUT_OF_RANGE_PART,
-        IPV4_IN_IPV6_TOO_FEW_PARTS,
-
-        INVALID_URL_UNIT,
-        SPECIAL_SCHEME_MISSING_FOLLOWING_SOLIDUS,
-        MISSING_SCHEME_NON_RELATIVE_URL,
-        INVALID_REVERSE_SOLIDUS,
-        INVALID_CREDENTIALS,
-        HOST_MISSING,
-        PORT_OUT_OF_RANGE,
-        PORT_INVALID,
-        FILE_INVALID_WINDOWS_DRIVE_LETTER,
-        FILE_INVALID_WINDOWS_DRIVE_LETTER_HOST,
-    }
-
-    enum State {
-        SCHEME_START,
-        SCHEME,
-        NO_SCHEME,
-        SPECIAL_RELATIVE_OR_AUTHORITY,
-        PATH_OR_AUTHORITY,
-        RELATIVE,
-        RELATIVE_SLASH,
-        SPECIAL_AUTHORITY_SLASHES,
-        SPECIAL_AUTHORITY_IGNORE_SLASHES,
-        AUTHORITY,
-        HOST,
-        HOSTNAME,
-        PORT,
-        FILE,
-        FILE_SLASH,
-        FILE_HOST,
-        PATH_START,
-        PATH,
-        OPAQUE_PATH,
-        QUERY,
-        FRAGMENT,
-    }
-}
diff --git a/router/src/test/java/io/micronaut/web/router/uri/WhatwgUrl.java b/router/src/test/java/io/micronaut/web/router/uri/WhatwgUrl.java
deleted file mode 100644
index a9f4f375fd..0000000000
--- a/router/src/test/java/io/micronaut/web/router/uri/WhatwgUrl.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package io.micronaut.web.router.uri;
-
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
-
-final class WhatwgUrl {
-    final @NonNull String scheme;
-    final @NonNull String username;
-    final @NonNull String password;
-    final @Nullable String host;
-    final @Nullable Integer port;
-    final @NonNull String path;
-    final boolean opaquePath;
-    final @Nullable String query;
-    final @Nullable String fragment;
-
-    public WhatwgUrl(@NonNull String scheme, @NonNull String username, @NonNull String password, @Nullable String host, @Nullable Integer port, @NonNull String path, boolean opaquePath, @Nullable String query, @Nullable String fragment) {
-        this.scheme = scheme;
-        this.username = username;
-        this.password = password;
-        this.host = host;
-        this.port = port;
-        this.path = path;
-        this.opaquePath = opaquePath;
-        this.query = query;
-        this.fragment = fragment;
-    }
-
-    void serialize(StringBuilder builder, boolean excludeFragment) {
-        builder.append(scheme).append(':');
-        if (host != null) {
-            builder.append("//");
-            if (!username.isEmpty() || !password.isEmpty()) {
-                builder.append(username);
-                if (!password.isEmpty()) {
-                    builder.append(":").append(password);
-                }
-                builder.append('@');
-            }
-            builder.append(host);
-            if (port != null) {
-                builder.append(":").append(port);
-            }
-        }
-        builder.append(path);
-        if (query != null) {
-            builder.append("?").append(query);
-        }
-        if (fragment != null && !excludeFragment) {
-            builder.append("#").append(fragment);
-        }
-    }
-}
