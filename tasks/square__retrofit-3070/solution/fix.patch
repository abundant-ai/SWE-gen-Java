diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index 15a81cec..1d416c47 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -20,7 +20,6 @@ import java.lang.reflect.Array;
 import java.lang.reflect.Method;
 import java.util.Map;
 import javax.annotation.Nullable;
-import okhttp3.Headers;
 import okhttp3.MultipartBody;
 import okhttp3.RequestBody;
 
@@ -230,6 +229,23 @@ abstract class ParameterHandler<T> {
     }
   }
 
+  static final class Headers extends ParameterHandler<okhttp3.Headers> {
+    private final Method method;
+    private final int p;
+
+    Headers(Method method, int p) {
+      this.method = method;
+      this.p = p;
+    }
+
+    @Override void apply(RequestBuilder builder, @Nullable okhttp3.Headers headers) {
+      if (headers == null) {
+        throw Utils.parameterError(method, p, "Headers parameter must not be null.");
+      }
+      builder.addHeaders(headers);
+    }
+  }
+
   static final class Field<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
@@ -300,10 +316,10 @@ abstract class ParameterHandler<T> {
   static final class Part<T> extends ParameterHandler<T> {
     private final Method method;
     private final int p;
-    private final Headers headers;
+    private final okhttp3.Headers headers;
     private final Converter<T, RequestBody> converter;
 
-    Part(Method method, int p, Headers headers, Converter<T, RequestBody> converter) {
+    Part(Method method, int p, okhttp3.Headers headers, Converter<T, RequestBody> converter) {
       this.method = method;
       this.p = p;
       this.headers = headers;
@@ -367,7 +383,7 @@ abstract class ParameterHandler<T> {
                   "Part map contained null value for key '" + entryKey + "'.");
         }
 
-        Headers headers = Headers.of(
+        okhttp3.Headers headers = okhttp3.Headers.of(
             "Content-Disposition", "form-data; name=\"" + entryKey + "\"",
             "Content-Transfer-Encoding", transferEncoding);
 
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 95c3a433..6aab20df 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -55,6 +55,7 @@ final class RequestBuilder {
   private @Nullable HttpUrl.Builder urlBuilder;
 
   private final Request.Builder requestBuilder;
+  private final Headers.Builder headersBuilder;
   private @Nullable MediaType contentType;
 
   private final boolean hasBody;
@@ -73,7 +74,9 @@ final class RequestBuilder {
     this.hasBody = hasBody;
 
     if (headers != null) {
-      requestBuilder.headers(headers);
+      headersBuilder = headers.newBuilder();
+    } else {
+      headersBuilder = new Headers.Builder();
     }
 
     if (isFormEncoded) {
@@ -98,10 +101,14 @@ final class RequestBuilder {
         throw new IllegalArgumentException("Malformed content type: " + value, e);
       }
     } else {
-      requestBuilder.addHeader(name, value);
+      headersBuilder.add(name, value);
     }
   }
 
+  void addHeaders(Headers headers) {
+    headersBuilder.addAll(headers);
+  }
+
   void addPathParam(String name, String value, boolean encoded) {
     if (relativeUrl == null) {
       // The relative URL is cleared when the first query parameter is set.
@@ -245,12 +252,13 @@ final class RequestBuilder {
       if (body != null) {
         body = new ContentTypeOverridingRequestBody(body, contentType);
       } else {
-        requestBuilder.addHeader("Content-Type", contentType.toString());
+        headersBuilder.add("Content-Type", contentType.toString());
       }
     }
 
     return requestBuilder
         .url(url)
+        .headers(headersBuilder.build())
         .method(method, body);
   }
 
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index d0e026e2..cc43226e 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -512,6 +512,10 @@ final class RequestFactory {
         }
 
       } else if (annotation instanceof HeaderMap) {
+        if (type == Headers.class) {
+          return new ParameterHandler.Headers(method, p);
+        }
+
         validateResolvableType(p, type);
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
index 248abc15..f758f3e1 100644
--- a/retrofit/src/main/java/retrofit2/http/HeaderMap.java
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -15,9 +15,6 @@
  */
 package retrofit2.http;
 
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
@@ -26,11 +23,15 @@ import java.lang.reflect.Type;
 import java.util.Map;
 import retrofit2.Retrofit;
 
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
 /**
- * Adds headers specified in the {@link Map}.
+ * Adds headers specified in the {@link Map} or {@link okhttp3.Headers}.
  * <p>
- * Values are converted to strings using {@link Retrofit#stringConverter(Type, Annotation[])}
- * (or {@link Object#toString()}, if no matching string converter is installed).
+ * Values in the map are converted to strings using
+ * {@link Retrofit#stringConverter(Type, Annotation[])} (or {@link Object#toString()}, if no
+ * matching string converter is installed).
  * <p>
  * Simple Example:
  * <pre>
