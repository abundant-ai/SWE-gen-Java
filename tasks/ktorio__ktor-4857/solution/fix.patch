diff --git a/ktor-network/api/ktor-network.api b/ktor-network/api/ktor-network.api
index a71e09a90..ef8b29119 100644
--- a/ktor-network/api/ktor-network.api
+++ b/ktor-network/api/ktor-network.api
@@ -201,6 +201,7 @@ public final class io/ktor/network/sockets/InetSocketAddress : io/ktor/network/s
 	public final fun getHostname ()Ljava/lang/String;
 	public final fun getPort ()I
 	public fun hashCode ()I
+	public final fun resolveAddress ()[B
 	public fun toString ()Ljava/lang/String;
 }
 
diff --git a/ktor-network/api/ktor-network.klib.api b/ktor-network/api/ktor-network.klib.api
index aca8a628c..161c70708 100644
--- a/ktor-network/api/ktor-network.klib.api
+++ b/ktor-network/api/ktor-network.klib.api
@@ -135,6 +135,7 @@ final class io.ktor.network.sockets/InetSocketAddress : io.ktor.network.sockets/
     final fun copy(kotlin/String = ..., kotlin/Int = ...): io.ktor.network.sockets/InetSocketAddress // io.ktor.network.sockets/InetSocketAddress.copy|copy(kotlin.String;kotlin.Int){}[0]
     final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.network.sockets/InetSocketAddress.equals|equals(kotlin.Any?){}[0]
     final fun hashCode(): kotlin/Int // io.ktor.network.sockets/InetSocketAddress.hashCode|hashCode(){}[0]
+    final fun resolveAddress(): kotlin/ByteArray? // io.ktor.network.sockets/InetSocketAddress.resolveAddress|resolveAddress(){}[0]
     final fun toString(): kotlin/String // io.ktor.network.sockets/InetSocketAddress.toString|toString(){}[0]
 }
 
diff --git a/ktor-network/common/src/io/ktor/network/sockets/SocketAddress.kt b/ktor-network/common/src/io/ktor/network/sockets/SocketAddress.kt
index ff17c16df..10a8d0ecd 100644
--- a/ktor-network/common/src/io/ktor/network/sockets/SocketAddress.kt
+++ b/ktor-network/common/src/io/ktor/network/sockets/SocketAddress.kt
@@ -48,6 +48,18 @@ public expect class InetSocketAddress(
      */
     public val port: Int
 
+    /**
+     * Returns the raw IP address bytes of this socket address.
+     *
+     * The returned array is 4 bytes for IPv4 addresses and 16 bytes for IPv6 addresses.
+     * Returns null if the address cannot be resolved or is not a valid IP address.
+     *
+     * Always returns null for wasm/js targets.
+     *
+     * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.network.sockets.InetSocketAddress.address)
+     */
+    public fun resolveAddress(): ByteArray?
+
     /**
      * The hostname of the socket address.
      *
diff --git a/ktor-network/jsAndWasmShared/src/io/ktor/network/sockets/SocketAddress.nonJvm.jsAndWasmShared.kt b/ktor-network/jsAndWasmShared/src/io/ktor/network/sockets/SocketAddress.nonJvm.jsAndWasmShared.kt
index c1b9da38c..29c2ffa8c 100644
--- a/ktor-network/jsAndWasmShared/src/io/ktor/network/sockets/SocketAddress.nonJvm.jsAndWasmShared.kt
+++ b/ktor-network/jsAndWasmShared/src/io/ktor/network/sockets/SocketAddress.nonJvm.jsAndWasmShared.kt
@@ -5,3 +5,7 @@
 package io.ktor.network.sockets
 
 internal actual fun isUnixSocketSupported(): Boolean = false
+
+internal actual fun InetSocketAddress.platformResolveAddress(): ByteArray? {
+    return null
+}
diff --git a/ktor-network/jvm/src/io/ktor/network/sockets/SocketAddressJvm.kt b/ktor-network/jvm/src/io/ktor/network/sockets/SocketAddressJvm.kt
index 868ef0e47..12af904fd 100644
--- a/ktor-network/jvm/src/io/ktor/network/sockets/SocketAddressJvm.kt
+++ b/ktor-network/jvm/src/io/ktor/network/sockets/SocketAddressJvm.kt
@@ -19,6 +19,8 @@ public actual class InetSocketAddress internal constructor(
 
     public actual val port: Int get() = address.port
 
+    public actual fun resolveAddress(): ByteArray? = address.address?.address
+
     public actual constructor(hostname: String, port: Int) :
         this(java.net.InetSocketAddress(hostname, port))
 
diff --git a/ktor-network/nonJvm/src/io/ktor/network/sockets/SocketAddress.nonJvm.kt b/ktor-network/nonJvm/src/io/ktor/network/sockets/SocketAddress.nonJvm.kt
index 2eaa7aa8c..3767c86ec 100644
--- a/ktor-network/nonJvm/src/io/ktor/network/sockets/SocketAddress.nonJvm.kt
+++ b/ktor-network/nonJvm/src/io/ktor/network/sockets/SocketAddress.nonJvm.kt
@@ -10,6 +10,10 @@ public actual class InetSocketAddress actual constructor(
     public actual val hostname: String,
     public actual val port: Int
 ) : SocketAddress() {
+    public actual fun resolveAddress(): ByteArray? {
+        return platformResolveAddress()
+    }
+
     /**
      * Create a copy of [InetSocketAddress].
      *
@@ -100,3 +104,5 @@ public actual class UnixSocketAddress actual constructor(
 }
 
 internal expect fun isUnixSocketSupported(): Boolean
+
+internal expect fun InetSocketAddress.platformResolveAddress(): ByteArray?
diff --git a/ktor-network/posix/src/io/ktor/network/sockets/SocketAddress.nonJvm.posix.kt b/ktor-network/posix/src/io/ktor/network/sockets/SocketAddress.nonJvm.posix.kt
new file mode 100644
index 000000000..168496f10
--- /dev/null
+++ b/ktor-network/posix/src/io/ktor/network/sockets/SocketAddress.nonJvm.posix.kt
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
+ */
+
+package io.ktor.network.sockets
+
+import io.ktor.network.util.NativeIPv4SocketAddress
+import io.ktor.network.util.NativeIPv6SocketAddress
+import io.ktor.network.util.parseIPv4String
+import io.ktor.network.util.parseIPv6String
+import io.ktor.network.util.resolve
+
+internal actual fun InetSocketAddress.platformResolveAddress(): ByteArray? {
+    return this.resolve().firstOrNull()?.let {
+        when (it) {
+            is NativeIPv4SocketAddress -> parseIPv4String(it.ipString)
+            is NativeIPv6SocketAddress -> parseIPv6String(it.ipString)
+            else -> null
+        }
+    }
+}
diff --git a/ktor-network/posix/src/io/ktor/network/util/SocketAddressUtils.kt b/ktor-network/posix/src/io/ktor/network/util/SocketAddressUtils.kt
index f6691205e..2a7d837a1 100644
--- a/ktor-network/posix/src/io/ktor/network/util/SocketAddressUtils.kt
+++ b/ktor-network/posix/src/io/ktor/network/util/SocketAddressUtils.kt
@@ -19,3 +19,48 @@ internal fun SocketAddress.resolve(): List<NativeSocketAddress> = when (this) {
     is InetSocketAddress -> getAddressInfo(hostname, port)
     is UnixSocketAddress -> listOf(NativeUnixSocketAddress(AF_UNIX.convert(), path))
 }
+
+internal fun parseIPv4String(ipString: String): ByteArray? {
+    return try {
+        val octets = ipString.split('.').also {
+            require(it.size == 4) { "Invalid IPv4 string: $ipString" }
+        }
+
+        octets.map { it.toUByte().toByte() }.toByteArray()
+    } catch (_: Throwable) {
+        null
+    }
+}
+
+internal fun parseIPv6String(ipString: String): ByteArray? {
+    return try {
+        val groups = if ("::" in ipString) {
+            val parts = ipString.split("::", limit = 2)
+
+            val groups = Pair(
+                if (parts[0].isNotEmpty()) parts[0].split(':') else emptyList(),
+                if (parts.size > 1 && parts[1].isNotEmpty()) parts[1].split(':') else emptyList()
+            )
+
+            val totalGroups = groups.first.size + groups.second.size
+            val emptyGroups = 8 - totalGroups
+
+            groups.first + List(emptyGroups) { "0" } + groups.second
+        } else {
+            ipString.split(':').also {
+                require(it.size == 8) { "Invalid IPv6 string: $ipString" }
+            }
+        }
+
+        groups.flatMap {
+            val int = if (it.matches(Regex("^[0-9a-fA-f]+$"))) {
+                it.toUShort(16)
+            } else {
+                return null
+            }.toInt()
+            listOf((int shr 8).toByte(), int.toByte())
+        }.toByteArray()
+    } catch (_: Throwable) {
+        null
+    }
+}
