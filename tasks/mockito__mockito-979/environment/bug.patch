diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InterceptedInvocation.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InterceptedInvocation.java
index a0c74870a..9ad0247d9 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InterceptedInvocation.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InterceptedInvocation.java
@@ -42,15 +42,14 @@ class InterceptedInvocation implements Invocation, VerificationAwareInvocation {
                                  MockitoMethod mockitoMethod,
                                  Object[] arguments,
                                  SuperMethod superMethod,
-                                 Location location,
                                  int sequenceNumber) {
         this.mock = mock;
         this.mockitoMethod = mockitoMethod;
         this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), arguments);
         this.rawArguments = arguments;
         this.superMethod = superMethod;
-        this.location = location;
         this.sequenceNumber = sequenceNumber;
+        location = new LocationImpl();
     }
 
     @Override
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
index 707d57a2e..cef75c883 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
@@ -9,7 +9,6 @@ import net.bytebuddy.implementation.bind.annotation.Argument;
 import net.bytebuddy.implementation.bind.annotation.This;
 import net.bytebuddy.implementation.bytecode.assign.Assigner;
 import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.debugging.LocationImpl;
 import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
 import org.mockito.internal.invocation.SerializableMethod;
 import org.mockito.internal.util.concurrent.WeakConcurrentMap;
@@ -22,8 +21,6 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.concurrent.Callable;
 
 public class MockMethodAdvice extends MockMethodDispatcher {
@@ -94,13 +91,10 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         } else {
             superMethod = new SuperMethodCall(selfCallInfo, origin, instance, arguments);
         }
-        Throwable t = new Throwable();
-        t.setStackTrace(skipInlineMethodElement(t.getStackTrace()));
         return new ReturnValueWrapper(interceptor.doIntercept(instance,
                 origin,
                 arguments,
-                superMethod,
-                new LocationImpl(t)));
+                superMethod));
     }
 
     @Override
@@ -206,21 +200,6 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         }
     }
 
-    // With inline mocking, mocks for concrete classes are not subclassed, so elements of the stubbing methods are not filtered out.
-    // Therefore, if the method is inlined, skip the element.
-    private static StackTraceElement[] skipInlineMethodElement(StackTraceElement[] elements) {
-        List<StackTraceElement> list = new ArrayList<StackTraceElement>(elements.length);
-        for (int i = 0; i < elements.length; i++) {
-            StackTraceElement element = elements[i];
-            list.add(element);
-            if (element.getClassName().equals(MockMethodAdvice.class.getName()) && element.getMethodName().equals("handle")) {
-                // If the current element is MockMethodAdvice#handle(), the next is assumed to be an inlined method.
-                i++;
-            }
-        }
-        return list.toArray(new StackTraceElement[list.size()]);
-    }
-
     private static class ReturnValueWrapper implements Callable<Object> {
 
         private final Object returned;
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
index 5c9e588eb..804d70097 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodInterceptor.java
@@ -7,11 +7,9 @@ package org.mockito.internal.creation.bytebuddy;
 import net.bytebuddy.implementation.bind.annotation.*;
 import org.mockito.internal.InternalMockHandler;
 import org.mockito.internal.creation.DelegatingMethod;
-import org.mockito.internal.debugging.LocationImpl;
 import org.mockito.internal.invocation.MockitoMethod;
 import org.mockito.internal.invocation.SerializableMethod;
 import org.mockito.internal.progress.SequenceNumber;
-import org.mockito.invocation.Location;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 
@@ -40,27 +38,12 @@ public class MockMethodInterceptor implements Serializable {
                        Method invokedMethod,
                        Object[] arguments,
                        InterceptedInvocation.SuperMethod superMethod) throws Throwable {
-        return doIntercept(
+        return handler.handle(new InterceptedInvocation(
                 mock,
-                invokedMethod,
+                createMockitoMethod(invokedMethod),
                 arguments,
                 superMethod,
-                new LocationImpl()
-        );
-    }
-
-    Object doIntercept(Object mock,
-                       Method invokedMethod,
-                       Object[] arguments,
-                       InterceptedInvocation.SuperMethod superMethod,
-                       Location location) throws Throwable {
-        return handler.handle(new InterceptedInvocation(
-            mock,
-            createMockitoMethod(invokedMethod),
-            arguments,
-            superMethod,
-            location,
-            SequenceNumber.next()
+                SequenceNumber.next()
         ));
     }
 
diff --git a/src/main/java/org/mockito/internal/debugging/LocationImpl.java b/src/main/java/org/mockito/internal/debugging/LocationImpl.java
index ce3de04a0..c661ced7d 100644
--- a/src/main/java/org/mockito/internal/debugging/LocationImpl.java
+++ b/src/main/java/org/mockito/internal/debugging/LocationImpl.java
@@ -19,16 +19,8 @@ public class LocationImpl implements Location, Serializable {
     }
 
     public LocationImpl(StackTraceFilter stackTraceFilter) {
-        this(stackTraceFilter, new Throwable());
-    }
-
-    public LocationImpl(Throwable stackTraceHolder) {
-        this(new StackTraceFilter(), stackTraceHolder);
-    }
-
-    private LocationImpl(StackTraceFilter stackTraceFilter, Throwable stackTraceHolder) {
         this.stackTraceFilter = stackTraceFilter;
-        this.stackTraceHolder = stackTraceHolder;
+        stackTraceHolder = new Throwable();
     }
 
     @Override
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/StubbingLocationTest.java b/subprojects/inline/src/test/java/org/mockitoinline/StubbingLocationTest.java
deleted file mode 100644
index 050298dfc..000000000
--- a/subprojects/inline/src/test/java/org/mockitoinline/StubbingLocationTest.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.mockitoinline;
-
-import java.util.Collections;
-import java.util.Set;
-import org.junit.Test;
-import org.mockito.internal.invocation.finder.AllInvocationsFinder;
-import org.mockito.stubbing.Stubbing;
-
-import static org.junit.Assert.assertEquals;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-public class StubbingLocationTest {
-
-    @Test
-    public void stubbing_location_should_be_the_correct_point() {
-        ConcreteClass mock = mock(ConcreteClass.class);
-        String frame;
-        // Initializing 'frame' at the method parameter point is to gain the exact line number of the stubbing point.
-        when(mock.concreteMethod(frame = Thread.currentThread().getStackTrace()[1].toString())).thenReturn("");
-        mock.concreteMethod(frame);
-        Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(Collections.singleton(mock));
-        assertEquals(1, stubbings.size());
-        String location = stubbings.iterator().next().getInvocation().getLocation().toString();
-        assertEquals("-> at " + frame, location);
-    }
-
-    static final class ConcreteClass {
-        String concreteMethod(String s) {
-            throw new RuntimeException(s);
-        }
-    }
-
-}
