diff --git a/ktor-http/api/ktor-http.api b/ktor-http/api/ktor-http.api
index 8dfcbb680..b30c5f131 100644
--- a/ktor-http/api/ktor-http.api
+++ b/ktor-http/api/ktor-http.api
@@ -465,6 +465,8 @@ public final class io/ktor/http/HeadersImpl : io/ktor/util/StringValuesImpl, io/
 }
 
 public final class io/ktor/http/HeadersKt {
+	public static final fun getSplitValues (Lio/ktor/http/Headers;Ljava/lang/String;CZ)Ljava/util/List;
+	public static synthetic fun getSplitValues$default (Lio/ktor/http/Headers;Ljava/lang/String;CZILjava/lang/Object;)Ljava/util/List;
 	public static final fun headers (Lkotlin/jvm/functions/Function1;)Lio/ktor/http/Headers;
 	public static final fun headersOf ()Lio/ktor/http/Headers;
 	public static final fun headersOf (Ljava/lang/String;Ljava/lang/String;)Lio/ktor/http/Headers;
diff --git a/ktor-http/api/ktor-http.klib.api b/ktor-http/api/ktor-http.klib.api
index f287b974c..e3b25cb5b 100644
--- a/ktor-http/api/ktor-http.klib.api
+++ b/ktor-http/api/ktor-http.klib.api
@@ -1713,6 +1713,7 @@ final fun (io.ktor.http/ContentType.Companion).io.ktor.http/defaultForFilePath(k
 final fun (io.ktor.http/ContentType.Companion).io.ktor.http/fromFileExtension(kotlin/String): kotlin.collections/List<io.ktor.http/ContentType> // io.ktor.http/fromFileExtension|fromFileExtension@io.ktor.http.ContentType.Companion(kotlin.String){}[0]
 final fun (io.ktor.http/ContentType.Companion).io.ktor.http/fromFilePath(kotlin/String): kotlin.collections/List<io.ktor.http/ContentType> // io.ktor.http/fromFilePath|fromFilePath@io.ktor.http.ContentType.Companion(kotlin.String){}[0]
 final fun (io.ktor.http/HeaderValueWithParameters).io.ktor.http/charset(): io.ktor.utils.io.charsets/Charset? // io.ktor.http/charset|charset@io.ktor.http.HeaderValueWithParameters(){}[0]
+final fun (io.ktor.http/Headers).io.ktor.http/getSplitValues(kotlin/String, kotlin/Char = ..., kotlin/Boolean = ...): kotlin.collections/List<kotlin/String>? // io.ktor.http/getSplitValues|getSplitValues@io.ktor.http.Headers(kotlin.String;kotlin.Char;kotlin.Boolean){}[0]
 final fun (io.ktor.http/HeadersBuilder).io.ktor.http/etag(kotlin/String) // io.ktor.http/etag|etag@io.ktor.http.HeadersBuilder(kotlin.String){}[0]
 final fun (io.ktor.http/HttpMessage).io.ktor.http/cacheControl(): kotlin.collections/List<io.ktor.http/HeaderValue> // io.ktor.http/cacheControl|cacheControl@io.ktor.http.HttpMessage(){}[0]
 final fun (io.ktor.http/HttpMessage).io.ktor.http/charset(): io.ktor.utils.io.charsets/Charset? // io.ktor.http/charset|charset@io.ktor.http.HttpMessage(){}[0]
diff --git a/ktor-http/common/src/io/ktor/http/Headers.kt b/ktor-http/common/src/io/ktor/http/Headers.kt
index 114b3f291..9810ec2ad 100644
--- a/ktor-http/common/src/io/ktor/http/Headers.kt
+++ b/ktor-http/common/src/io/ktor/http/Headers.kt
@@ -4,6 +4,7 @@
 
 package io.ktor.http
 
+import io.ktor.http.header.*
 import io.ktor.util.*
 
 /**
@@ -105,3 +106,22 @@ public class HeadersSingleImpl(
 ) : Headers, StringValuesSingleImpl(true, name, values) {
     override fun toString(): String = "Headers ${entries()}"
 }
+
+/**
+ * Gets all values associated with the specified header [name] and splits them using the provided [separator].
+ *
+ * If [splitInsideQuotes] is true, the function ignores quotes entirely and splits everywhere the [separator] appears.
+ * Otherwise, [separator] that occurs inside a double-quoted string isn't treated as a split point.
+ *
+ *  @param name The header name.
+ *  @param separator The character on which to split (e.g., ',' or ';').
+ *  @param splitInsideQuotes If `true`, quotes are ignored and splitting occurs at every [separator].
+ *                           If `false`, separators inside quoted strings are not considered split points.
+ */
+public fun Headers.getSplitValues(
+    name: String,
+    separator: Char = ',',
+    splitInsideQuotes: Boolean = false
+): List<String>? {
+    return splitHeaderValues(getAll(name) ?: return null, separator, splitInsideQuotes)
+}
diff --git a/ktor-http/common/src/io/ktor/http/header/utils.kt b/ktor-http/common/src/io/ktor/http/header/utils.kt
new file mode 100644
index 000000000..de19de8ab
--- /dev/null
+++ b/ktor-http/common/src/io/ktor/http/header/utils.kt
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
+ */
+
+package io.ktor.http.header
+
+internal fun splitHeaderValues(values: List<String>, separator: Char, splitInsideQuotes: Boolean): List<String> {
+    return values.flatMap { splitHeaderValue(it, separator, splitInsideQuotes) }
+}
+
+/**
+ * Splits a header [value] by the given [separator] with support for [splitInsideQuotes].
+ *
+ * If [splitInsideQuotes] is true, the function ignores quotes entirely and splits everywhere the [separator] appears.
+ * Otherwise, [separator] that occurs inside a double-quoted string isn't treated as a split point.
+ *
+ * Rules:
+ * - Supports backslash escaping inside quotes (e.g., `\"`).
+ * - Trims optional whitespace around items.
+ * - Skips empty items produced by consecutive separators.
+ * - Preserves original quoting/escaping.
+ *
+ *  @param value The raw header value string.
+ *  @param separator The character on which to split (e.g., ',' or ';').
+ *  @param splitInsideQuotes If `true`, quotes are ignored and splitting occurs at every [separator].
+ *                           If `false`, separators inside quoted strings are not considered split points.
+ */
+private fun splitHeaderValue(value: String, separator: Char, splitInsideQuotes: Boolean): List<String> {
+    if (splitInsideQuotes) {
+        return value.split(separator).map { it.trim() }.filter { it.isNotEmpty() }
+    }
+
+    val result = mutableListOf<String>()
+    var start = 0
+    var i = 0
+    var inQuotes = false
+    var escape = false
+
+    fun emit(start: Int, end: Int) {
+        val token = value.substring(start, end).trim()
+        if (token.isNotEmpty()) result.add(token)
+    }
+
+    while (i < value.length) {
+        val ch = value[i]
+        if (inQuotes) {
+            when {
+                escape -> escape = false
+                ch == '\\' -> escape = true
+                ch == '"' -> inQuotes = false
+            }
+            i++
+            continue
+        }
+
+        when (ch) {
+            '"' -> {
+                inQuotes = true
+                i++
+            }
+
+            separator -> {
+                emit(start, i)
+                i++
+                start = i
+            }
+
+            else -> i++
+        }
+    }
+
+    emit(start, value.length)
+    return result
+}
