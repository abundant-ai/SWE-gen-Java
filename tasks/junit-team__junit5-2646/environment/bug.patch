diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
index 103543a22..1a4cd8723 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
@@ -46,9 +46,7 @@ on GitHub.
 
 ==== Bug Fixes
 
-* The `IndicativeSentences` `DisplayNameGenerator` no longer includes the display name of
-  the enclosing class when generating an _indicative sentence_ if the enclosing class is
-  not configured to use the `IndicativeSentences` display name generator as well.
+* ‚ùì
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java
index 4aa6206f2..0e6284891 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java
@@ -12,15 +12,12 @@ package org.junit.jupiter.api;
 
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
-import static org.junit.platform.commons.support.ModifierSupport.isStatic;
+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;
 
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.Optional;
-import java.util.function.Predicate;
 
 import org.apiguardian.api.API;
-import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.util.ClassUtils;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -34,14 +31,6 @@ import org.junit.platform.commons.util.ReflectionUtils;
  *
  * <p>Concrete implementations must have a <em>default constructor</em>.
  *
- * <h4>Built-in Implementations</h4>
- * <ul>
- * <li>{@link Standard}</li>
- * <li>{@link Simple}</li>
- * <li>{@link ReplaceUnderscores}</li>
- * <li>{@link IndicativeSentences}</li>
- * </ul>
- *
  * @since 5.4
  * @see DisplayName @DisplayName
  * @see DisplayNameGeneration @DisplayNameGeneration
@@ -192,12 +181,11 @@ public interface DisplayNameGenerator {
 	/**
 	 * {@code DisplayNameGenerator} that generates complete sentences.
 	 *
-	 * <p>This generator generates display names that build up complete sentences
-	 * by concatenating the names of the test and the enclosing classes. The
-	 * sentence fragments are concatenated using a separator. The separator and
-	 * the display name generator for individual sentence fragments can be configured
-	 * via the {@link IndicativeSentencesGeneration @IndicativeSentencesGeneration}
-	 * annotation.
+	 * <p>This implements the functionality of {@link DisplayNameGenerator}
+	 * by generating complete sentences display names, these
+	 * sentences are divided with a separator, and the generator and separator
+	 * can be customisable by using the {@link IndicativeSentencesGeneration}
+	 * interface as annotation.
 	 *
 	 * @since 5.7
 	 */
@@ -211,7 +199,7 @@ public interface DisplayNameGenerator {
 
 		@Override
 		public String generateDisplayNameForClass(Class<?> testClass) {
-			return getGeneratorFor(testClass).generateDisplayNameForClass(testClass);
+			return getGeneratorForIndicativeSentence(testClass).generateDisplayNameForClass(testClass);
 		}
 
 		@Override
@@ -221,133 +209,94 @@ public interface DisplayNameGenerator {
 
 		@Override
 		public String generateDisplayNameForMethod(Class<?> testClass, Method testMethod) {
-			return getSentenceBeginning(testClass) + getFragmentSeparator(testClass)
-					+ getGeneratorFor(testClass).generateDisplayNameForMethod(testClass, testMethod);
+			return getSentenceBeginning(testClass) + getSentenceSeparator(testClass)
+					+ getGeneratorForIndicativeSentence(testClass).generateDisplayNameForMethod(testClass, testMethod);
 		}
 
 		private String getSentenceBeginning(Class<?> testClass) {
-			Class<?> enclosingClass = testClass.getEnclosingClass();
-			boolean topLevelTestClass = (enclosingClass == null || isStatic(testClass));
-			Optional<String> displayName = AnnotationSupport.findAnnotation(testClass, DisplayName.class)//
-					.map(DisplayName::value).map(String::trim);
-
-			if (topLevelTestClass) {
-				if (displayName.isPresent()) {
-					return displayName.get();
-				}
-				Class<? extends DisplayNameGenerator> generatorClass = findDisplayNameGeneration(testClass)//
-						.map(DisplayNameGeneration::value)//
-						.filter(not(IndicativeSentences.class))//
-						.orElse(null);
-				if (generatorClass != null) {
-					return getDisplayNameGenerator(generatorClass).generateDisplayNameForClass(testClass);
-				}
-				return generateDisplayNameForClass(testClass);
-			}
+			Class<?> enclosingParent = testClass.getEnclosingClass();
+			Optional<DisplayName> displayName = findAnnotation(testClass, DisplayName.class);
+			Optional<DisplayNameGeneration> displayNameGeneration = findAnnotation(testClass,
+				DisplayNameGeneration.class);
 
-			// Only build prefix based on the enclosing class if the enclosing
-			// class is also configured to use the IndicativeSentences generator.
-			boolean buildPrefix = findDisplayNameGeneration(enclosingClass)//
-					.map(DisplayNameGeneration::value)//
-					.filter(IndicativeSentences.class::equals)//
-					.isPresent();
-
-			String prefix = (buildPrefix ? getSentenceBeginning(enclosingClass) + getFragmentSeparator(testClass) : "");
-
-			return prefix + displayName.orElseGet(
-				() -> getGeneratorFor(testClass).generateDisplayNameForNestedClass(testClass));
+			if (enclosingParent == null || displayNameGeneration.isPresent()) {
+				return displayName.map(DisplayName::value).orElseGet(() -> generateDisplayNameForClass(testClass));
+			}
+			String separator = getSentenceSeparator(testClass);
+			String sentenceBeginning = getSentenceBeginning(enclosingParent);
+			return displayName.map(name -> sentenceBeginning + separator + name.value()) //
+					.orElseGet(() -> sentenceBeginning + separator
+							+ getGeneratorForIndicativeSentence(testClass).generateDisplayNameForNestedClass(
+								testClass));
 		}
 
 		/**
-		 * Get the sentence fragment separator.
-		 *
-		 * <p>If {@link IndicativeSentencesGeneration @IndicativeSentencesGeneration}
-		 * is present (searching enclosing classes if not found locally), the
-		 * configured {@link IndicativeSentencesGeneration#separator() separator}
-		 * will be used. Otherwise, {@link IndicativeSentencesGeneration#DEFAULT_SEPARATOR}
-		 * will be used.
+		 * Gets the separator for {@link IndicativeSentencesGeneration} when extracting the
+		 * annotation from {@code IndicativeSentencesGeneration}, if it doesn't find it,
+		 * then search for the parent classes, if no separator is found use @code{", "} by default.
 		 *
-		 * @param testClass the test class to search on for {@code @IndicativeSentencesGeneration}
-		 * @return the sentence fragment separator
+		 * @param testClass Class to get Indicative sentence annotation separator either custom or default
+		 * @return the indicative sentence separator
 		 */
-		private static String getFragmentSeparator(Class<?> testClass) {
-			return findIndicativeSentencesGeneration(testClass)//
-					.map(IndicativeSentencesGeneration::separator)//
-					.orElse(IndicativeSentencesGeneration.DEFAULT_SEPARATOR);
-		}
+		private String getSentenceSeparator(Class<?> testClass) {
+			Optional<IndicativeSentencesGeneration> indicativeSentencesGeneration = getIndicativeSentencesGeneration(
+				testClass);
+			if (indicativeSentencesGeneration.isPresent()) {
+				if (indicativeSentencesGeneration.get().separator().equals("")) {
+					return IndicativeSentencesGeneration.DEFAULT_SEPARATOR;
+				}
+				return indicativeSentencesGeneration.get().separator();
+			}
 
-		/**
-		 * Get the display name generator to use for the supplied test class.
-		 *
-		 * <p>If {@link IndicativeSentencesGeneration @IndicativeSentencesGeneration}
-		 * is present (searching enclosing classes if not found locally), the
-		 * configured {@link IndicativeSentencesGeneration#generator() generator}
-		 * will be used. Otherwise, {@link IndicativeSentencesGeneration#DEFAULT_GENERATOR}
-		 * will be used.
-		 *
-		 * @param testClass the test class to search on for {@code @IndicativeSentencesGeneration}
-		 * @return the {@code DisplayNameGenerator} instance to use
-		 */
-		private static DisplayNameGenerator getGeneratorFor(Class<?> testClass) {
-			return findIndicativeSentencesGeneration(testClass)//
-					.map(IndicativeSentencesGeneration::generator)//
-					.filter(not(IndicativeSentences.class))//
-					.map(DisplayNameGenerator::getDisplayNameGenerator)//
-					.orElseGet(() -> getDisplayNameGenerator(IndicativeSentencesGeneration.DEFAULT_GENERATOR));
+			return IndicativeSentencesGeneration.DEFAULT_SEPARATOR;
 		}
 
 		/**
-		 * Find the first {@code DisplayNameGeneration} annotation that is either
-		 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly present</em>
-		 * on the supplied {@code testClass} or on an enclosing class.
+		 * Gets the generator for {@link IndicativeSentencesGeneration} when extracting the
+		 * annotation from {@code IndicativeSentencesGeneration}, if it doesn't find it,
+		 * then search for the parent classes, if no generator value is found use
+		 * {@link Standard} by default.
 		 *
-		 * @param testClass the test class on which to find the annotation; never {@code null}
-		 * @return an {@code Optional} containing the annotation, potentially empty if not found
+		 * @param testClass Class to get Indicative sentence generator either custom or default
+		 * @return the {@code DisplayNameGenerator} instance to use in indicative sentences generator
 		 */
-		private static Optional<DisplayNameGeneration> findDisplayNameGeneration(Class<?> testClass) {
-			return findAnnotation(testClass, DisplayNameGeneration.class);
-		}
+		private DisplayNameGenerator getGeneratorForIndicativeSentence(Class<?> testClass) {
+			Optional<IndicativeSentencesGeneration> indicativeSentencesGeneration = getIndicativeSentencesGeneration(
+				testClass);
+			if (indicativeSentencesGeneration.isPresent()) {
+				DisplayNameGenerator displayNameGenerator = getDisplayNameGenerator(
+					indicativeSentencesGeneration.get().generator());
+				if (displayNameGenerator.getClass() == IndicativeSentences.class) {
+					return getDisplayNameGenerator(IndicativeSentencesGeneration.DEFAULT_GENERATOR);
+				}
+				return displayNameGenerator;
+			}
 
-		/**
-		 * Find the first {@code IndicativeSentencesGeneration} annotation that is either
-		 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly present</em>
-		 * on the supplied {@code testClass} or on an enclosing class.
-		 *
-		 * @param testClass the test class on which to find the annotation; never {@code null}
-		 * @return an {@code Optional} containing the annotation, potentially empty if not found
-		 */
-		private static Optional<IndicativeSentencesGeneration> findIndicativeSentencesGeneration(Class<?> testClass) {
-			return findAnnotation(testClass, IndicativeSentencesGeneration.class);
+			return getDisplayNameGenerator(IndicativeSentencesGeneration.DEFAULT_GENERATOR);
 		}
 
 		/**
-		 * Find the first annotation of the specified type that is either
-		 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly
-		 * present</em> on the supplied {@code testClass} or on an enclosing class.
+		 * Finds the {@code IndicativeSentencesGeneration} annotation that is present,
+		 * meta-present or if it doesn't find it, then search for the enclosing
+		 * parent classes, if no annotation is found returns empty.
 		 *
-		 * @param <A> the annotation type
-		 * @param testClass the test class on which to search for the annotation;
-		 * never {@code null}
-		 * @param annotationType the annotation type to search for; never {@code null}
-		 * @return an {@code Optional} containing the annotation; never {@code null} but
-		 * potentially empty
+		 * @param testClass the test class to find the {@code IndicativeSentencesGeneration}
+		 * annotation
+		 * @return the optional annotation retrieved from the test class.
 		 */
-		private static <A extends Annotation> Optional<A> findAnnotation(Class<?> testClass, Class<A> annotationType) {
-			Class<?> candidate = testClass;
-			do {
-				Optional<A> annotation = AnnotationSupport.findAnnotation(candidate, annotationType);
-				if (annotation.isPresent()) {
-					return annotation;
-				}
-				candidate = candidate.getEnclosingClass();
-			} while (candidate != null);
-			return Optional.empty();
-		}
+		private Optional<IndicativeSentencesGeneration> getIndicativeSentencesGeneration(Class<?> testClass) {
+			Optional<IndicativeSentencesGeneration> indicativeSentencesGeneration = findAnnotation(testClass,
+				IndicativeSentencesGeneration.class);
 
-		private static Predicate<Class<?>> not(Class<?> clazz) {
-			return ((Predicate<Class<?>>) clazz::equals).negate();
-		}
+			if (indicativeSentencesGeneration.isPresent()) {
+				return indicativeSentencesGeneration;
+			}
+			if (testClass.getEnclosingClass() != null) {
+				return getIndicativeSentencesGeneration(testClass.getEnclosingClass());
+			}
 
+			return Optional.empty();
+		}
 	}
 
 	/**
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java
index 183fb8c6d..82acc5cfb 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java
@@ -20,24 +20,18 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.apiguardian.api.API;
-import org.junit.jupiter.api.DisplayNameGenerator.IndicativeSentences;
 
 /**
- * {@code @IndicativeSentencesGeneration} is used to register the
- * {@link IndicativeSentences} display name generator and configure it.
- *
- * <p>The {@link #separator} for sentence fragments and the display name
- * {@link #generator} for sentence fragments are configurable. If this annotation
- * is declared without any attributes &mdash; for example,
- * {@code @IndicativeSentencesGeneration} or {@code @IndicativeSentencesGeneration()}
- * &mdash; the default configuration will be used.
+ * {@code @IndicativeSentencesGeneration} is used to declare a custom parameters
+ * by {@code IndicativeSentences}, if this notation has some not declared
+ * parameters, it will use the default values instead.
  *
  * @since 5.7
  * @see DisplayName
  * @see DisplayNameGenerator
  * @see DisplayNameGenerator.IndicativeSentences
  */
-@DisplayNameGeneration(IndicativeSentences.class)
+@DisplayNameGeneration(DisplayNameGenerator.IndicativeSentences.class)
 @Target({ ElementType.ANNOTATION_TYPE, ElementType.TYPE })
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
@@ -46,21 +40,15 @@ import org.junit.jupiter.api.DisplayNameGenerator.IndicativeSentences;
 public @interface IndicativeSentencesGeneration {
 
 	String DEFAULT_SEPARATOR = ", ";
-
 	Class<? extends DisplayNameGenerator> DEFAULT_GENERATOR = DisplayNameGenerator.Standard.class;
 
 	/**
-	 * Custom separator for sentence fragments.
-	 *
-	 * <p>Defaults to {@value #DEFAULT_SEPARATOR}.
+	 * Custom separator for indicative sentences generator.
 	 */
-	String separator() default DEFAULT_SEPARATOR;
+	String separator() default "";
 
 	/**
-	 * Custom display name generator to use for sentence fragments.
-	 *
-	 * <p>Defaults to {@link DisplayNameGenerator.Standard}.
+	 * Custom display name generator.
 	 */
 	Class<? extends DisplayNameGenerator> generator() default DisplayNameGenerator.Standard.class;
-
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java
index 549fd19b5..23e9a9442 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.engine.descriptor;
 
+import static org.junit.jupiter.api.DisplayNameGenerator.IndicativeSentences;
 import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
 
 import java.lang.reflect.AnnotatedElement;
@@ -20,7 +21,6 @@ import java.util.function.Supplier;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.DisplayNameGeneration;
 import org.junit.jupiter.api.DisplayNameGenerator;
-import org.junit.jupiter.api.DisplayNameGenerator.IndicativeSentences;
 import org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores;
 import org.junit.jupiter.api.DisplayNameGenerator.Simple;
 import org.junit.jupiter.api.DisplayNameGenerator.Standard;
@@ -128,7 +128,7 @@ final class DisplayNameUtils {
 
 	/**
 	 * Find the first {@code DisplayNameGeneration} annotation that is either
-	 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly present</em>
+	 * <em>directly present</em>, <em>meta-present</em>, <em>indirectly present</em>
 	 * on the supplied {@code testClass} or on an enclosing class.
 	 */
 	private static Optional<DisplayNameGeneration> getDisplayNameGeneration(Class<?> testClass) {
@@ -142,5 +142,4 @@ final class DisplayNameUtils {
 		} while (candidate != null);
 		return Optional.empty();
 	}
-
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java
index ba748df29..f466c402f 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java
@@ -82,7 +82,7 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 	}
 
 	@Test
-	void indicativeSentencesGeneratorOnStaticNestedClass() {
+	void indicativeSentencesGenerator() {
 		var expectedDisplayNames = List.of( //
 			"CONTAINER: DisplayNameGenerationTests$IndicativeStyleTestCase", //
 			"TEST: @DisplayName prevails", //
@@ -96,26 +96,6 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 		check(IndicativeStyleTestCase.class, expectedDisplayNames);
 	}
 
-	@Test
-	void indicativeSentencesGeneratorOnTopLevelClass() {
-		var expectedDisplayNames = List.of( //
-			"CONTAINER: IndicativeSentencesTopLevelTestCase", //
-			"CONTAINER: IndicativeSentencesTopLevelTestCase -> A year is a leap year", //
-			"TEST: IndicativeSentencesTopLevelTestCase -> A year is a leap year -> if it is divisible by 4 but not by 100" //
-		);
-		check(IndicativeSentencesTopLevelTestCase.class, expectedDisplayNames);
-	}
-
-	@Test
-	void indicativeSentencesGeneratorOnNestedClass() {
-		var expectedDisplayNames = List.of( //
-			"CONTAINER: A year is a leap year", //
-			"CONTAINER: IndicativeSentencesNestedTestCase", //
-			"TEST: A year is a leap year -> if it is divisible by 4 but not by 100" //
-		);
-		check(IndicativeSentencesNestedTestCase.class, expectedDisplayNames);
-	}
-
 	@Test
 	void noNameGenerator() {
 		check(NoNameStyleTestCase.class, List.of( //
@@ -150,11 +130,11 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 	void checkDisplayNameGeneratedForIndicativeGeneratorTestCase() {
 		check(IndicativeGeneratorTestCase.class, List.of( //
 			"CONTAINER: A stack", //
-			"CONTAINER: A stack, when new", //
-			"CONTAINER: A stack, when new, after pushing an element to an empty stack", //
+			"CONTAINER: A stack, when is new", //
+			"CONTAINER: A stack, when is new, after pushing an element to an empty stack", //
 			"TEST: A stack, is instantiated with new constructor", //
-			"TEST: A stack, when new, after pushing an element to an empty stack, is no longer empty", //
-			"TEST: A stack, when new, throws EmptyStackException when peeked" //
+			"TEST: A stack, when is new, after pushing an element to an empty stack, is no longer empty", //
+			"TEST: A stack, when is new, throws EmptyStackException when peeked" //
 		));
 	}
 
@@ -162,11 +142,11 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 	void checkDisplayNameGeneratedForIndicativeGeneratorWithCustomSeparatorTestCase() {
 		check(IndicativeGeneratorWithCustomSeparatorTestCase.class, List.of( //
 			"CONTAINER: A stack", //
-			"CONTAINER: A stack >> when new", //
-			"CONTAINER: A stack >> when new >> after pushing an element to an empty stack", //
+			"CONTAINER: A stack >> when is new", //
+			"CONTAINER: A stack >> when is new >> after pushing an element to an empty stack", //
 			"TEST: A stack >> is instantiated with new constructor", //
-			"TEST: A stack >> when new >> after pushing an element to an empty stack >> is no longer empty", //
-			"TEST: A stack >> when new >> throws EmptyStackException when peeked"//
+			"TEST: A stack >> when is new >> after pushing an element to an empty stack >> is no longer empty", //
+			"TEST: A stack >> when is new >> throws EmptyStackException when peeked"//
 		));
 	}
 
@@ -339,7 +319,7 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 		}
 
 		@Nested
-		class when_new {
+		class when_is_new {
 
 			@BeforeEach
 			void create_with_new_stack() {
@@ -383,7 +363,7 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 		}
 
 		@Nested
-		class when_new {
+		class when_is_new {
 
 			@BeforeEach
 			void create_with_new_stack() {
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesNestedTestCase.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesNestedTestCase.java
deleted file mode 100644
index 018cd5255..000000000
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesNestedTestCase.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright 2015-2021 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.api;
-
-import org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores;
-
-/**
- * This test case declares {@link IndicativeSentencesGeneration} on a test class
- * that is nested directly within a top-level test class.
- *
- * @see IndicativeSentencesTopLevelTestCase
- */
-class IndicativeSentencesNestedTestCase {
-
-	@Nested
-	@IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
-	class A_year_is_a_leap_year {
-
-		@Test
-		void if_it_is_divisible_by_4_but_not_by_100() {
-		}
-	}
-
-}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesTopLevelTestCase.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesTopLevelTestCase.java
deleted file mode 100644
index 03fd754bb..000000000
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesTopLevelTestCase.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright 2015-2021 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.api;
-
-import org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores;
-
-/**
- * This test case declares {@link IndicativeSentencesGeneration} on a top-level
- * test class that contains a nested test class.
- *
- * @see IndicativeSentencesNestedTestCase
- */
-@IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
-class IndicativeSentencesTopLevelTestCase {
-
-	@Nested
-	class A_year_is_a_leap_year {
-
-		@Test
-		void if_it_is_divisible_by_4_but_not_by_100() {
-		}
-	}
-
-}
