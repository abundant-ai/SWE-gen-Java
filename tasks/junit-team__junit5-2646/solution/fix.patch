diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
index 1a4cd8723..103543a22 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
@@ -46,7 +46,9 @@ on GitHub.
 
 ==== Bug Fixes
 
-* ‚ùì
+* The `IndicativeSentences` `DisplayNameGenerator` no longer includes the display name of
+  the enclosing class when generating an _indicative sentence_ if the enclosing class is
+  not configured to use the `IndicativeSentences` display name generator as well.
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java
index 0e6284891..4aa6206f2 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java
@@ -12,12 +12,15 @@ package org.junit.jupiter.api;
 
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
-import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;
+import static org.junit.platform.commons.support.ModifierSupport.isStatic;
 
+import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.Optional;
+import java.util.function.Predicate;
 
 import org.apiguardian.api.API;
+import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.util.ClassUtils;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -31,6 +34,14 @@ import org.junit.platform.commons.util.ReflectionUtils;
  *
  * <p>Concrete implementations must have a <em>default constructor</em>.
  *
+ * <h4>Built-in Implementations</h4>
+ * <ul>
+ * <li>{@link Standard}</li>
+ * <li>{@link Simple}</li>
+ * <li>{@link ReplaceUnderscores}</li>
+ * <li>{@link IndicativeSentences}</li>
+ * </ul>
+ *
  * @since 5.4
  * @see DisplayName @DisplayName
  * @see DisplayNameGeneration @DisplayNameGeneration
@@ -181,11 +192,12 @@ public interface DisplayNameGenerator {
 	/**
 	 * {@code DisplayNameGenerator} that generates complete sentences.
 	 *
-	 * <p>This implements the functionality of {@link DisplayNameGenerator}
-	 * by generating complete sentences display names, these
-	 * sentences are divided with a separator, and the generator and separator
-	 * can be customisable by using the {@link IndicativeSentencesGeneration}
-	 * interface as annotation.
+	 * <p>This generator generates display names that build up complete sentences
+	 * by concatenating the names of the test and the enclosing classes. The
+	 * sentence fragments are concatenated using a separator. The separator and
+	 * the display name generator for individual sentence fragments can be configured
+	 * via the {@link IndicativeSentencesGeneration @IndicativeSentencesGeneration}
+	 * annotation.
 	 *
 	 * @since 5.7
 	 */
@@ -199,7 +211,7 @@ public interface DisplayNameGenerator {
 
 		@Override
 		public String generateDisplayNameForClass(Class<?> testClass) {
-			return getGeneratorForIndicativeSentence(testClass).generateDisplayNameForClass(testClass);
+			return getGeneratorFor(testClass).generateDisplayNameForClass(testClass);
 		}
 
 		@Override
@@ -209,94 +221,133 @@ public interface DisplayNameGenerator {
 
 		@Override
 		public String generateDisplayNameForMethod(Class<?> testClass, Method testMethod) {
-			return getSentenceBeginning(testClass) + getSentenceSeparator(testClass)
-					+ getGeneratorForIndicativeSentence(testClass).generateDisplayNameForMethod(testClass, testMethod);
+			return getSentenceBeginning(testClass) + getFragmentSeparator(testClass)
+					+ getGeneratorFor(testClass).generateDisplayNameForMethod(testClass, testMethod);
 		}
 
 		private String getSentenceBeginning(Class<?> testClass) {
-			Class<?> enclosingParent = testClass.getEnclosingClass();
-			Optional<DisplayName> displayName = findAnnotation(testClass, DisplayName.class);
-			Optional<DisplayNameGeneration> displayNameGeneration = findAnnotation(testClass,
-				DisplayNameGeneration.class);
-
-			if (enclosingParent == null || displayNameGeneration.isPresent()) {
-				return displayName.map(DisplayName::value).orElseGet(() -> generateDisplayNameForClass(testClass));
+			Class<?> enclosingClass = testClass.getEnclosingClass();
+			boolean topLevelTestClass = (enclosingClass == null || isStatic(testClass));
+			Optional<String> displayName = AnnotationSupport.findAnnotation(testClass, DisplayName.class)//
+					.map(DisplayName::value).map(String::trim);
+
+			if (topLevelTestClass) {
+				if (displayName.isPresent()) {
+					return displayName.get();
+				}
+				Class<? extends DisplayNameGenerator> generatorClass = findDisplayNameGeneration(testClass)//
+						.map(DisplayNameGeneration::value)//
+						.filter(not(IndicativeSentences.class))//
+						.orElse(null);
+				if (generatorClass != null) {
+					return getDisplayNameGenerator(generatorClass).generateDisplayNameForClass(testClass);
+				}
+				return generateDisplayNameForClass(testClass);
 			}
-			String separator = getSentenceSeparator(testClass);
-			String sentenceBeginning = getSentenceBeginning(enclosingParent);
-			return displayName.map(name -> sentenceBeginning + separator + name.value()) //
-					.orElseGet(() -> sentenceBeginning + separator
-							+ getGeneratorForIndicativeSentence(testClass).generateDisplayNameForNestedClass(
-								testClass));
+
+			// Only build prefix based on the enclosing class if the enclosing
+			// class is also configured to use the IndicativeSentences generator.
+			boolean buildPrefix = findDisplayNameGeneration(enclosingClass)//
+					.map(DisplayNameGeneration::value)//
+					.filter(IndicativeSentences.class::equals)//
+					.isPresent();
+
+			String prefix = (buildPrefix ? getSentenceBeginning(enclosingClass) + getFragmentSeparator(testClass) : "");
+
+			return prefix + displayName.orElseGet(
+				() -> getGeneratorFor(testClass).generateDisplayNameForNestedClass(testClass));
 		}
 
 		/**
-		 * Gets the separator for {@link IndicativeSentencesGeneration} when extracting the
-		 * annotation from {@code IndicativeSentencesGeneration}, if it doesn't find it,
-		 * then search for the parent classes, if no separator is found use @code{", "} by default.
+		 * Get the sentence fragment separator.
+		 *
+		 * <p>If {@link IndicativeSentencesGeneration @IndicativeSentencesGeneration}
+		 * is present (searching enclosing classes if not found locally), the
+		 * configured {@link IndicativeSentencesGeneration#separator() separator}
+		 * will be used. Otherwise, {@link IndicativeSentencesGeneration#DEFAULT_SEPARATOR}
+		 * will be used.
 		 *
-		 * @param testClass Class to get Indicative sentence annotation separator either custom or default
-		 * @return the indicative sentence separator
+		 * @param testClass the test class to search on for {@code @IndicativeSentencesGeneration}
+		 * @return the sentence fragment separator
 		 */
-		private String getSentenceSeparator(Class<?> testClass) {
-			Optional<IndicativeSentencesGeneration> indicativeSentencesGeneration = getIndicativeSentencesGeneration(
-				testClass);
-			if (indicativeSentencesGeneration.isPresent()) {
-				if (indicativeSentencesGeneration.get().separator().equals("")) {
-					return IndicativeSentencesGeneration.DEFAULT_SEPARATOR;
-				}
-				return indicativeSentencesGeneration.get().separator();
-			}
-
-			return IndicativeSentencesGeneration.DEFAULT_SEPARATOR;
+		private static String getFragmentSeparator(Class<?> testClass) {
+			return findIndicativeSentencesGeneration(testClass)//
+					.map(IndicativeSentencesGeneration::separator)//
+					.orElse(IndicativeSentencesGeneration.DEFAULT_SEPARATOR);
 		}
 
 		/**
-		 * Gets the generator for {@link IndicativeSentencesGeneration} when extracting the
-		 * annotation from {@code IndicativeSentencesGeneration}, if it doesn't find it,
-		 * then search for the parent classes, if no generator value is found use
-		 * {@link Standard} by default.
+		 * Get the display name generator to use for the supplied test class.
+		 *
+		 * <p>If {@link IndicativeSentencesGeneration @IndicativeSentencesGeneration}
+		 * is present (searching enclosing classes if not found locally), the
+		 * configured {@link IndicativeSentencesGeneration#generator() generator}
+		 * will be used. Otherwise, {@link IndicativeSentencesGeneration#DEFAULT_GENERATOR}
+		 * will be used.
 		 *
-		 * @param testClass Class to get Indicative sentence generator either custom or default
-		 * @return the {@code DisplayNameGenerator} instance to use in indicative sentences generator
+		 * @param testClass the test class to search on for {@code @IndicativeSentencesGeneration}
+		 * @return the {@code DisplayNameGenerator} instance to use
 		 */
-		private DisplayNameGenerator getGeneratorForIndicativeSentence(Class<?> testClass) {
-			Optional<IndicativeSentencesGeneration> indicativeSentencesGeneration = getIndicativeSentencesGeneration(
-				testClass);
-			if (indicativeSentencesGeneration.isPresent()) {
-				DisplayNameGenerator displayNameGenerator = getDisplayNameGenerator(
-					indicativeSentencesGeneration.get().generator());
-				if (displayNameGenerator.getClass() == IndicativeSentences.class) {
-					return getDisplayNameGenerator(IndicativeSentencesGeneration.DEFAULT_GENERATOR);
-				}
-				return displayNameGenerator;
-			}
-
-			return getDisplayNameGenerator(IndicativeSentencesGeneration.DEFAULT_GENERATOR);
+		private static DisplayNameGenerator getGeneratorFor(Class<?> testClass) {
+			return findIndicativeSentencesGeneration(testClass)//
+					.map(IndicativeSentencesGeneration::generator)//
+					.filter(not(IndicativeSentences.class))//
+					.map(DisplayNameGenerator::getDisplayNameGenerator)//
+					.orElseGet(() -> getDisplayNameGenerator(IndicativeSentencesGeneration.DEFAULT_GENERATOR));
 		}
 
 		/**
-		 * Finds the {@code IndicativeSentencesGeneration} annotation that is present,
-		 * meta-present or if it doesn't find it, then search for the enclosing
-		 * parent classes, if no annotation is found returns empty.
+		 * Find the first {@code DisplayNameGeneration} annotation that is either
+		 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly present</em>
+		 * on the supplied {@code testClass} or on an enclosing class.
 		 *
-		 * @param testClass the test class to find the {@code IndicativeSentencesGeneration}
-		 * annotation
-		 * @return the optional annotation retrieved from the test class.
+		 * @param testClass the test class on which to find the annotation; never {@code null}
+		 * @return an {@code Optional} containing the annotation, potentially empty if not found
 		 */
-		private Optional<IndicativeSentencesGeneration> getIndicativeSentencesGeneration(Class<?> testClass) {
-			Optional<IndicativeSentencesGeneration> indicativeSentencesGeneration = findAnnotation(testClass,
-				IndicativeSentencesGeneration.class);
+		private static Optional<DisplayNameGeneration> findDisplayNameGeneration(Class<?> testClass) {
+			return findAnnotation(testClass, DisplayNameGeneration.class);
+		}
 
-			if (indicativeSentencesGeneration.isPresent()) {
-				return indicativeSentencesGeneration;
-			}
-			if (testClass.getEnclosingClass() != null) {
-				return getIndicativeSentencesGeneration(testClass.getEnclosingClass());
-			}
+		/**
+		 * Find the first {@code IndicativeSentencesGeneration} annotation that is either
+		 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly present</em>
+		 * on the supplied {@code testClass} or on an enclosing class.
+		 *
+		 * @param testClass the test class on which to find the annotation; never {@code null}
+		 * @return an {@code Optional} containing the annotation, potentially empty if not found
+		 */
+		private static Optional<IndicativeSentencesGeneration> findIndicativeSentencesGeneration(Class<?> testClass) {
+			return findAnnotation(testClass, IndicativeSentencesGeneration.class);
+		}
 
+		/**
+		 * Find the first annotation of the specified type that is either
+		 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly
+		 * present</em> on the supplied {@code testClass} or on an enclosing class.
+		 *
+		 * @param <A> the annotation type
+		 * @param testClass the test class on which to search for the annotation;
+		 * never {@code null}
+		 * @param annotationType the annotation type to search for; never {@code null}
+		 * @return an {@code Optional} containing the annotation; never {@code null} but
+		 * potentially empty
+		 */
+		private static <A extends Annotation> Optional<A> findAnnotation(Class<?> testClass, Class<A> annotationType) {
+			Class<?> candidate = testClass;
+			do {
+				Optional<A> annotation = AnnotationSupport.findAnnotation(candidate, annotationType);
+				if (annotation.isPresent()) {
+					return annotation;
+				}
+				candidate = candidate.getEnclosingClass();
+			} while (candidate != null);
 			return Optional.empty();
 		}
+
+		private static Predicate<Class<?>> not(Class<?> clazz) {
+			return ((Predicate<Class<?>>) clazz::equals).negate();
+		}
+
 	}
 
 	/**
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java
index 82acc5cfb..183fb8c6d 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java
@@ -20,18 +20,24 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.DisplayNameGenerator.IndicativeSentences;
 
 /**
- * {@code @IndicativeSentencesGeneration} is used to declare a custom parameters
- * by {@code IndicativeSentences}, if this notation has some not declared
- * parameters, it will use the default values instead.
+ * {@code @IndicativeSentencesGeneration} is used to register the
+ * {@link IndicativeSentences} display name generator and configure it.
+ *
+ * <p>The {@link #separator} for sentence fragments and the display name
+ * {@link #generator} for sentence fragments are configurable. If this annotation
+ * is declared without any attributes &mdash; for example,
+ * {@code @IndicativeSentencesGeneration} or {@code @IndicativeSentencesGeneration()}
+ * &mdash; the default configuration will be used.
  *
  * @since 5.7
  * @see DisplayName
  * @see DisplayNameGenerator
  * @see DisplayNameGenerator.IndicativeSentences
  */
-@DisplayNameGeneration(DisplayNameGenerator.IndicativeSentences.class)
+@DisplayNameGeneration(IndicativeSentences.class)
 @Target({ ElementType.ANNOTATION_TYPE, ElementType.TYPE })
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
@@ -40,15 +46,21 @@ import org.apiguardian.api.API;
 public @interface IndicativeSentencesGeneration {
 
 	String DEFAULT_SEPARATOR = ", ";
+
 	Class<? extends DisplayNameGenerator> DEFAULT_GENERATOR = DisplayNameGenerator.Standard.class;
 
 	/**
-	 * Custom separator for indicative sentences generator.
+	 * Custom separator for sentence fragments.
+	 *
+	 * <p>Defaults to {@value #DEFAULT_SEPARATOR}.
 	 */
-	String separator() default "";
+	String separator() default DEFAULT_SEPARATOR;
 
 	/**
-	 * Custom display name generator.
+	 * Custom display name generator to use for sentence fragments.
+	 *
+	 * <p>Defaults to {@link DisplayNameGenerator.Standard}.
 	 */
 	Class<? extends DisplayNameGenerator> generator() default DisplayNameGenerator.Standard.class;
+
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java
index 23e9a9442..549fd19b5 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java
@@ -10,7 +10,6 @@
 
 package org.junit.jupiter.engine.descriptor;
 
-import static org.junit.jupiter.api.DisplayNameGenerator.IndicativeSentences;
 import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
 
 import java.lang.reflect.AnnotatedElement;
@@ -21,6 +20,7 @@ import java.util.function.Supplier;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.DisplayNameGeneration;
 import org.junit.jupiter.api.DisplayNameGenerator;
+import org.junit.jupiter.api.DisplayNameGenerator.IndicativeSentences;
 import org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores;
 import org.junit.jupiter.api.DisplayNameGenerator.Simple;
 import org.junit.jupiter.api.DisplayNameGenerator.Standard;
@@ -128,7 +128,7 @@ final class DisplayNameUtils {
 
 	/**
 	 * Find the first {@code DisplayNameGeneration} annotation that is either
-	 * <em>directly present</em>, <em>meta-present</em>, <em>indirectly present</em>
+	 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly present</em>
 	 * on the supplied {@code testClass} or on an enclosing class.
 	 */
 	private static Optional<DisplayNameGeneration> getDisplayNameGeneration(Class<?> testClass) {
@@ -142,4 +142,5 @@ final class DisplayNameUtils {
 		} while (candidate != null);
 		return Optional.empty();
 	}
+
 }
