diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractOrderingVisitor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractOrderingVisitor.java
index 8f104923b..0645aa0ab 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractOrderingVisitor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractOrderingVisitor.java
@@ -18,16 +18,14 @@ import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.Optional;
 import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Stream;
 
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.commons.util.UnrecoverableExceptions;
-import org.junit.platform.engine.DiscoveryIssue;
-import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
 
 /**
  * Abstract base class for {@linkplain TestDescriptor.Visitor visitors} that
@@ -37,11 +35,7 @@ import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
  */
 abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 
-	private final DiscoveryIssueReporter issueReporter;
-
-	AbstractOrderingVisitor(DiscoveryIssueReporter issueReporter) {
-		this.issueReporter = issueReporter;
-	}
+	private static final Logger logger = LoggerFactory.getLogger(AbstractOrderingVisitor.class);
 
 	/**
 	 * @param <PARENT> the parent container type to search in for matching children
@@ -57,10 +51,7 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 			}
 			catch (Throwable t) {
 				UnrecoverableExceptions.rethrowIfUnrecoverable(t);
-				String message = errorMessageBuilder.apply(parentTestDescriptor);
-				this.issueReporter.reportIssue(DiscoveryIssue.builder(Severity.ERROR, message) //
-						.source(parentTestDescriptor.getSource()) //
-						.cause(t));
+				logger.error(t, () -> errorMessageBuilder.apply(parentTestDescriptor));
 			}
 		}
 	}
@@ -70,24 +61,17 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 	 */
 	protected <CHILD extends TestDescriptor, WRAPPER extends AbstractAnnotatedDescriptorWrapper<?>> void orderChildrenTestDescriptors(
 			TestDescriptor parentTestDescriptor, Class<CHILD> matchingChildrenType,
-			Optional<Consumer<CHILD>> validationAction, Function<CHILD, WRAPPER> descriptorWrapperFactory,
-			DescriptorWrapperOrderer<?, WRAPPER> descriptorWrapperOrderer) {
-
-		Stream<CHILD> matchingChildren = parentTestDescriptor.getChildren()//
-				.stream()//
-				.filter(matchingChildrenType::isInstance)//
-				.map(matchingChildrenType::cast);
+			Function<CHILD, WRAPPER> descriptorWrapperFactory,
+			DescriptorWrapperOrderer<WRAPPER> descriptorWrapperOrderer) {
 
 		if (!descriptorWrapperOrderer.canOrderWrappers()) {
-			validationAction.ifPresent(matchingChildren::forEach);
 			return;
 		}
 
-		if (validationAction.isPresent()) {
-			matchingChildren = matchingChildren.peek(validationAction.get());
-		}
-
-		List<WRAPPER> matchingDescriptorWrappers = matchingChildren//
+		List<WRAPPER> matchingDescriptorWrappers = parentTestDescriptor.getChildren()//
+				.stream()//
+				.filter(matchingChildrenType::isInstance)//
+				.map(matchingChildrenType::cast)//
 				.map(descriptorWrapperFactory)//
 				.collect(toCollection(ArrayList::new));
 
@@ -100,8 +84,7 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 			Stream<TestDescriptor> nonMatchingTestDescriptors = children.stream()//
 					.filter(childTestDescriptor -> !matchingChildrenType.isInstance(childTestDescriptor));
 
-			descriptorWrapperOrderer.orderWrappers(matchingDescriptorWrappers,
-				message -> reportWarning(parentTestDescriptor, message));
+			descriptorWrapperOrderer.orderWrappers(matchingDescriptorWrappers);
 
 			Stream<TestDescriptor> orderedTestDescriptors = matchingDescriptorWrappers.stream()//
 					.map(AbstractAnnotatedDescriptorWrapper::getTestDescriptor);
@@ -117,50 +100,39 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 		});
 	}
 
-	private void reportWarning(TestDescriptor parentTestDescriptor, String message) {
-		issueReporter.reportIssue(DiscoveryIssue.builder(Severity.WARNING, message) //
-				.source(parentTestDescriptor.getSource()));
-	}
-
 	protected abstract boolean shouldNonMatchingDescriptorsComeBeforeOrderedOnes();
 
 	/**
 	 * @param <WRAPPER> the wrapper type for the children to order
 	 */
-	protected static class DescriptorWrapperOrderer<ORDERER, WRAPPER> {
+	protected static class DescriptorWrapperOrderer<WRAPPER> {
 
-		private static final DescriptorWrapperOrderer<?, ?> NOOP = new DescriptorWrapperOrderer<>(null, null, __ -> "",
+		private static final DescriptorWrapperOrderer<?> NOOP = new DescriptorWrapperOrderer<>(null, __ -> "",
 			___ -> "");
 
 		@SuppressWarnings("unchecked")
-		protected static <ORDERER, WRAPPER> DescriptorWrapperOrderer<ORDERER, WRAPPER> noop() {
-			return (DescriptorWrapperOrderer<ORDERER, WRAPPER>) NOOP;
+		protected static <WRAPPER> DescriptorWrapperOrderer<WRAPPER> noop() {
+			return (DescriptorWrapperOrderer<WRAPPER>) NOOP;
 		}
 
-		private final ORDERER orderer;
 		private final Consumer<List<WRAPPER>> orderingAction;
 		private final MessageGenerator descriptorsAddedMessageGenerator;
 		private final MessageGenerator descriptorsRemovedMessageGenerator;
 
-		DescriptorWrapperOrderer(ORDERER orderer, Consumer<List<WRAPPER>> orderingAction,
+		DescriptorWrapperOrderer(Consumer<List<WRAPPER>> orderingAction,
 				MessageGenerator descriptorsAddedMessageGenerator,
 				MessageGenerator descriptorsRemovedMessageGenerator) {
 
-			this.orderer = orderer;
 			this.orderingAction = orderingAction;
 			this.descriptorsAddedMessageGenerator = descriptorsAddedMessageGenerator;
 			this.descriptorsRemovedMessageGenerator = descriptorsRemovedMessageGenerator;
 		}
 
-		ORDERER getOrderer() {
-			return orderer;
-		}
-
 		private boolean canOrderWrappers() {
 			return this.orderingAction != null;
 		}
 
-		private void orderWrappers(List<WRAPPER> wrappers, Consumer<String> errorHandler) {
+		private void orderWrappers(List<WRAPPER> wrappers) {
 			List<WRAPPER> orderedWrappers = new ArrayList<>(wrappers);
 			this.orderingAction.accept(orderedWrappers);
 			Map<Object, Integer> distinctWrappersToIndex = distinctWrappersToIndex(orderedWrappers);
@@ -168,10 +140,10 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 			int difference = orderedWrappers.size() - wrappers.size();
 			int distinctDifference = distinctWrappersToIndex.size() - wrappers.size();
 			if (difference > 0) { // difference >= distinctDifference
-				reportDescriptorsAddedWarning(difference, errorHandler);
+				logDescriptorsAddedWarning(difference);
 			}
 			if (distinctDifference < 0) { // distinctDifference <= difference
-				reportDescriptorsRemovedWarning(distinctDifference, errorHandler);
+				logDescriptorsRemovedWarning(distinctDifference);
 			}
 
 			wrappers.sort(comparing(wrapper -> distinctWrappersToIndex.getOrDefault(wrapper, -1)));
@@ -189,12 +161,12 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 			return toIndex;
 		}
 
-		private void reportDescriptorsAddedWarning(int number, Consumer<String> errorHandler) {
-			errorHandler.accept(this.descriptorsAddedMessageGenerator.generateMessage(number));
+		private void logDescriptorsAddedWarning(int number) {
+			logger.warn(() -> this.descriptorsAddedMessageGenerator.generateMessage(number));
 		}
 
-		private void reportDescriptorsRemovedWarning(int number, Consumer<String> errorHandler) {
-			errorHandler.accept(this.descriptorsRemovedMessageGenerator.generateMessage(Math.abs(number)));
+		private void logDescriptorsRemovedWarning(int number) {
+			logger.warn(() -> this.descriptorsRemovedMessageGenerator.generateMessage(Math.abs(number)));
 		}
 
 	}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassOrderingVisitor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassOrderingVisitor.java
index e64063088..fb8861083 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassOrderingVisitor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassOrderingVisitor.java
@@ -10,14 +10,10 @@
 
 package org.junit.jupiter.engine.discovery;
 
-import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
-
 import java.util.List;
-import java.util.Optional;
 import java.util.function.Consumer;
 
 import org.junit.jupiter.api.ClassOrderer;
-import org.junit.jupiter.api.Order;
 import org.junit.jupiter.api.TestClassOrder;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;
@@ -25,37 +21,21 @@ import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
 import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.support.ReflectionSupport;
 import org.junit.platform.commons.util.LruCache;
-import org.junit.platform.engine.DiscoveryIssue;
-import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.support.descriptor.ClassSource;
-import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
-import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter.Condition;
 
 /**
  * @since 5.8
  */
 class ClassOrderingVisitor extends AbstractOrderingVisitor {
 
-	private final LruCache<ClassBasedTestDescriptor, DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor>> ordererCache = new LruCache<>(
+	private final LruCache<ClassBasedTestDescriptor, DescriptorWrapperOrderer<DefaultClassDescriptor>> ordererCache = new LruCache<>(
 		10);
 	private final JupiterConfiguration configuration;
-	private final DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> globalOrderer;
-	private final Condition<ClassBasedTestDescriptor> noOrderAnnotation;
+	private final DescriptorWrapperOrderer<DefaultClassDescriptor> globalOrderer;
 
-	ClassOrderingVisitor(JupiterConfiguration configuration, DiscoveryIssueReporter issueReporter) {
-		super(issueReporter);
+	ClassOrderingVisitor(JupiterConfiguration configuration) {
 		this.configuration = configuration;
 		this.globalOrderer = createGlobalOrderer(configuration);
-		this.noOrderAnnotation = issueReporter.createReportingCondition(
-			testDescriptor -> !isAnnotated(testDescriptor.getTestClass(), Order.class), testDescriptor -> {
-				String message = String.format(
-					"Ineffective @Order annotation on class '%s'. It will not be applied because ClassOrderer.OrderAnnotation is not in use.",
-					testDescriptor.getTestClass().getName());
-				return DiscoveryIssue.builder(Severity.INFO, message) //
-						.source(ClassSource.from(testDescriptor.getTestClass())) //
-						.build();
-			});
 	}
 
 	@Override
@@ -79,37 +59,31 @@ class ClassOrderingVisitor extends AbstractOrderingVisitor {
 		orderChildrenTestDescriptors(//
 			engineDescriptor, //
 			ClassBasedTestDescriptor.class, //
-			toValidationAction(globalOrderer), //
 			DefaultClassDescriptor::new, //
 			globalOrderer);
 	}
 
 	private void orderNestedClasses(ClassBasedTestDescriptor descriptor) {
-		DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> wrapperOrderer = createAndCacheClassLevelOrderer(
-			descriptor);
 		orderChildrenTestDescriptors(//
 			descriptor, //
 			ClassBasedTestDescriptor.class, //
-			toValidationAction(wrapperOrderer), //
 			DefaultClassDescriptor::new, //
-			wrapperOrderer);
+			createAndCacheClassLevelOrderer(descriptor));
 	}
 
-	private DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> createGlobalOrderer(
-			JupiterConfiguration configuration) {
+	private DescriptorWrapperOrderer<DefaultClassDescriptor> createGlobalOrderer(JupiterConfiguration configuration) {
 		ClassOrderer classOrderer = configuration.getDefaultTestClassOrderer().orElse(null);
 		return classOrderer == null ? DescriptorWrapperOrderer.noop() : createDescriptorWrapperOrderer(classOrderer);
 	}
 
-	private DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> createAndCacheClassLevelOrderer(
+	private DescriptorWrapperOrderer<DefaultClassDescriptor> createAndCacheClassLevelOrderer(
 			ClassBasedTestDescriptor classBasedTestDescriptor) {
-		DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> orderer = createClassLevelOrderer(
-			classBasedTestDescriptor);
+		DescriptorWrapperOrderer<DefaultClassDescriptor> orderer = createClassLevelOrderer(classBasedTestDescriptor);
 		ordererCache.put(classBasedTestDescriptor, orderer);
 		return orderer;
 	}
 
-	private DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> createClassLevelOrderer(
+	private DescriptorWrapperOrderer<DefaultClassDescriptor> createClassLevelOrderer(
 			ClassBasedTestDescriptor classBasedTestDescriptor) {
 		return AnnotationSupport.findAnnotation(classBasedTestDescriptor.getTestClass(), TestClassOrder.class)//
 				.map(TestClassOrder::value)//
@@ -119,7 +93,7 @@ class ClassOrderingVisitor extends AbstractOrderingVisitor {
 					Object parent = classBasedTestDescriptor.getParent().orElse(null);
 					if (parent instanceof ClassBasedTestDescriptor) {
 						ClassBasedTestDescriptor parentClassTestDescriptor = (ClassBasedTestDescriptor) parent;
-						DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> cacheEntry = ordererCache.get(
+						DescriptorWrapperOrderer<DefaultClassDescriptor> cacheEntry = ordererCache.get(
 							parentClassTestDescriptor);
 						return cacheEntry != null ? cacheEntry : createClassLevelOrderer(parentClassTestDescriptor);
 					}
@@ -127,8 +101,7 @@ class ClassOrderingVisitor extends AbstractOrderingVisitor {
 				});
 	}
 
-	private DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> createDescriptorWrapperOrderer(
-			ClassOrderer classOrderer) {
+	private DescriptorWrapperOrderer<DefaultClassDescriptor> createDescriptorWrapperOrderer(ClassOrderer classOrderer) {
 		Consumer<List<DefaultClassDescriptor>> orderingAction = classDescriptors -> classOrderer.orderClasses(
 			new DefaultClassOrdererContext(classDescriptors, this.configuration));
 
@@ -139,17 +112,8 @@ class ClassOrderingVisitor extends AbstractOrderingVisitor {
 			"ClassOrderer [%s] removed %s ClassDescriptor(s) which will be retained with arbitrary ordering.",
 			classOrderer.getClass().getName(), number);
 
-		return new DescriptorWrapperOrderer<>(classOrderer, orderingAction, descriptorsAddedMessageGenerator,
+		return new DescriptorWrapperOrderer<>(orderingAction, descriptorsAddedMessageGenerator,
 			descriptorsRemovedMessageGenerator);
 	}
 
-	private Optional<Consumer<ClassBasedTestDescriptor>> toValidationAction(
-			DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> wrapperOrderer) {
-
-		if (wrapperOrderer.getOrderer() instanceof ClassOrderer.OrderAnnotation) {
-			return Optional.empty();
-		}
-		return Optional.of(noOrderAnnotation::check);
-	}
-
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java
index 6fabb7546..4b25b3d43 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java
@@ -44,8 +44,8 @@ public class DiscoverySelectorResolver {
 				ctx.getIssueReporter())) //
 			.addSelectorResolver(ctx -> new MethodSelectorResolver(getConfiguration(ctx), ctx.getIssueReporter())) //
 			.addTestDescriptorVisitor(ctx -> TestDescriptor.Visitor.composite( //
-				new ClassOrderingVisitor(getConfiguration(ctx), ctx.getIssueReporter()), //
-				new MethodOrderingVisitor(getConfiguration(ctx), ctx.getIssueReporter()), //
+				new ClassOrderingVisitor(getConfiguration(ctx)), //
+				new MethodOrderingVisitor(getConfiguration(ctx)), //
 				descriptor -> {
 					if (descriptor instanceof Validatable) {
 						((Validatable) descriptor).validate(ctx.getIssueReporter());
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
index 471b9ecf8..bad48c639 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
@@ -11,26 +11,19 @@
 package org.junit.jupiter.engine.discovery;
 
 import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;
-import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
 
 import java.util.List;
 import java.util.Optional;
 import java.util.function.Consumer;
 
 import org.junit.jupiter.api.MethodOrderer;
-import org.junit.jupiter.api.Order;
 import org.junit.jupiter.api.TestMethodOrder;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;
 import org.junit.jupiter.engine.descriptor.JupiterTestDescriptor;
 import org.junit.jupiter.engine.descriptor.MethodBasedTestDescriptor;
 import org.junit.platform.commons.support.ReflectionSupport;
-import org.junit.platform.engine.DiscoveryIssue;
-import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.support.descriptor.MethodSource;
-import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
-import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter.Condition;
 
 /**
  * @since 5.5
@@ -38,20 +31,9 @@ import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter.Condit
 class MethodOrderingVisitor extends AbstractOrderingVisitor {
 
 	private final JupiterConfiguration configuration;
-	private final Condition<MethodBasedTestDescriptor> noOrderAnnotation;
 
-	MethodOrderingVisitor(JupiterConfiguration configuration, DiscoveryIssueReporter issueReporter) {
-		super(issueReporter);
+	MethodOrderingVisitor(JupiterConfiguration configuration) {
 		this.configuration = configuration;
-		this.noOrderAnnotation = issueReporter.createReportingCondition(
-			testDescriptor -> !isAnnotated(testDescriptor.getTestMethod(), Order.class), testDescriptor -> {
-				String message = String.format(
-					"Ineffective @Order annotation on method '%s'. It will not be applied because MethodOrderer.OrderAnnotation is not in use.",
-					testDescriptor.getTestMethod().toGenericString());
-				return DiscoveryIssue.builder(Severity.INFO, message) //
-						.source(MethodSource.from(testDescriptor.getTestMethod())) //
-						.build();
-			});
 	}
 
 	@Override
@@ -72,62 +54,37 @@ class MethodOrderingVisitor extends AbstractOrderingVisitor {
 	 * @since 5.4
 	 */
 	private void orderContainedMethods(ClassBasedTestDescriptor classBasedTestDescriptor, Class<?> testClass) {
-		Optional<MethodOrderer> methodOrderer = findAnnotation(testClass, TestMethodOrder.class)//
+		findAnnotation(testClass, TestMethodOrder.class)//
 				.map(TestMethodOrder::value)//
 				.<MethodOrderer> map(ReflectionSupport::newInstance)//
 				.map(Optional::of)//
-				.orElseGet(configuration::getDefaultTestMethodOrderer);
-		orderContainedMethods(classBasedTestDescriptor, testClass, methodOrderer);
-	}
-
-	private void orderContainedMethods(ClassBasedTestDescriptor classBasedTestDescriptor, Class<?> testClass,
-			Optional<MethodOrderer> methodOrderer) {
-		DescriptorWrapperOrderer<?, DefaultMethodDescriptor> descriptorWrapperOrderer = createDescriptorWrapperOrderer(
-			testClass, methodOrderer);
-
-		orderChildrenTestDescriptors(classBasedTestDescriptor, //
-			MethodBasedTestDescriptor.class, //
-			toValidationAction(methodOrderer), //
-			DefaultMethodDescriptor::new, //
-			descriptorWrapperOrderer);
-
-		// Note: MethodOrderer#getDefaultExecutionMode() is guaranteed
-		// to be invoked after MethodOrderer#orderMethods().
-		methodOrderer //
-				.flatMap(it -> it.getDefaultExecutionMode().map(JupiterTestDescriptor::toExecutionMode)) //
-				.ifPresent(classBasedTestDescriptor::setDefaultChildExecutionMode);
-	}
-
-	private DescriptorWrapperOrderer<?, DefaultMethodDescriptor> createDescriptorWrapperOrderer(Class<?> testClass,
-			Optional<MethodOrderer> methodOrderer) {
-
-		return methodOrderer //
-				.map(it -> createDescriptorWrapperOrderer(testClass, it)) //
-				.orElseGet(DescriptorWrapperOrderer::noop);
-
-	}
-
-	private DescriptorWrapperOrderer<?, DefaultMethodDescriptor> createDescriptorWrapperOrderer(Class<?> testClass,
-			MethodOrderer methodOrderer) {
-		Consumer<List<DefaultMethodDescriptor>> orderingAction = methodDescriptors -> methodOrderer.orderMethods(
-			new DefaultMethodOrdererContext(testClass, methodDescriptors, this.configuration));
-
-		MessageGenerator descriptorsAddedMessageGenerator = number -> String.format(
-			"MethodOrderer [%s] added %s MethodDescriptor(s) for test class [%s] which will be ignored.",
-			methodOrderer.getClass().getName(), number, testClass.getName());
-		MessageGenerator descriptorsRemovedMessageGenerator = number -> String.format(
-			"MethodOrderer [%s] removed %s MethodDescriptor(s) for test class [%s] which will be retained with arbitrary ordering.",
-			methodOrderer.getClass().getName(), number, testClass.getName());
-
-		return new DescriptorWrapperOrderer<>(methodOrderer, orderingAction, descriptorsAddedMessageGenerator,
-			descriptorsRemovedMessageGenerator);
-	}
-
-	private Optional<Consumer<MethodBasedTestDescriptor>> toValidationAction(Optional<MethodOrderer> methodOrderer) {
-		if (methodOrderer.orElse(null) instanceof MethodOrderer.OrderAnnotation) {
-			return Optional.empty();
-		}
-		return Optional.of(noOrderAnnotation::check);
+				.orElseGet(configuration::getDefaultTestMethodOrderer)//
+				.ifPresent(methodOrderer -> {
+
+					Consumer<List<DefaultMethodDescriptor>> orderingAction = methodDescriptors -> methodOrderer.orderMethods(
+						new DefaultMethodOrdererContext(testClass, methodDescriptors, this.configuration));
+
+					MessageGenerator descriptorsAddedMessageGenerator = number -> String.format(
+						"MethodOrderer [%s] added %s MethodDescriptor(s) for test class [%s] which will be ignored.",
+						methodOrderer.getClass().getName(), number, testClass.getName());
+					MessageGenerator descriptorsRemovedMessageGenerator = number -> String.format(
+						"MethodOrderer [%s] removed %s MethodDescriptor(s) for test class [%s] which will be retained with arbitrary ordering.",
+						methodOrderer.getClass().getName(), number, testClass.getName());
+
+					DescriptorWrapperOrderer<DefaultMethodDescriptor> descriptorWrapperOrderer = new DescriptorWrapperOrderer<>(
+						orderingAction, descriptorsAddedMessageGenerator, descriptorsRemovedMessageGenerator);
+
+					orderChildrenTestDescriptors(classBasedTestDescriptor, //
+						MethodBasedTestDescriptor.class, //
+						DefaultMethodDescriptor::new, //
+						descriptorWrapperOrderer);
+
+					// Note: MethodOrderer#getDefaultExecutionMode() is guaranteed
+					// to be invoked after MethodOrderer#orderMethods().
+					methodOrderer.getDefaultExecutionMode()//
+							.map(JupiterTestDescriptor::toExecutionMode)//
+							.ifPresent(classBasedTestDescriptor::setDefaultChildExecutionMode);
+				});
 	}
 
 }
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java
index b1e163d7c..f0e232eb7 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java
@@ -18,7 +18,6 @@ import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.Optional;
 import java.util.logging.Level;
 import java.util.logging.LogRecord;
 import java.util.stream.Stream;
@@ -39,11 +38,7 @@ import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.fixtures.TrackLogRecords;
 import org.junit.platform.commons.logging.LogRecordListener;
-import org.junit.platform.engine.DiscoveryIssue;
-import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.DiscoverySelector;
-import org.junit.platform.engine.support.descriptor.ClassSource;
-import org.junit.platform.testkit.engine.EngineDiscoveryResults;
 import org.junit.platform.testkit.engine.EngineTestKit;
 import org.junit.platform.testkit.engine.Events;
 
@@ -62,23 +57,8 @@ class OrderedClassTests {
 		callSequence.clear();
 	}
 
-	@Test
-	void noOrderer() {
-		var discoveryIssues = discoverTests(null).getDiscoveryIssues();
-		assertIneffectiveOrderAnnotationIssues(discoveryIssues);
-
-		executeTests(null)//
-				.assertStatistics(stats -> stats.succeeded(callSequence.size()));
-
-		assertThat(callSequence)//
-				.containsExactlyInAnyOrder("A_TestCase", "B_TestCase", "C_TestCase");
-	}
-
 	@Test
 	void className() {
-		var discoveryIssues = discoverTests(ClassOrderer.ClassName.class).getDiscoveryIssues();
-		assertIneffectiveOrderAnnotationIssues(discoveryIssues);
-
 		executeTests(ClassOrderer.ClassName.class)//
 				.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -106,9 +86,6 @@ class OrderedClassTests {
 
 	@Test
 	void displayName() {
-		var discoveryIssues = discoverTests(ClassOrderer.DisplayName.class).getDiscoveryIssues();
-		assertIneffectiveOrderAnnotationIssues(discoveryIssues);
-
 		executeTests(ClassOrderer.DisplayName.class)//
 				.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -118,9 +95,6 @@ class OrderedClassTests {
 
 	@Test
 	void orderAnnotation() {
-		var discoveryIssues = discoverTests(ClassOrderer.OrderAnnotation.class).getDiscoveryIssues();
-		assertThat(discoveryIssues).isEmpty();
-
 		executeTests(ClassOrderer.OrderAnnotation.class)//
 				.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -156,9 +130,6 @@ class OrderedClassTests {
 
 	@Test
 	void random() {
-		var discoveryIssues = discoverTests(ClassOrderer.Random.class).getDiscoveryIssues();
-		assertIneffectiveOrderAnnotationIssues(discoveryIssues);
-
 		executeTests(ClassOrderer.Random.class)//
 				.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 	}
@@ -199,16 +170,6 @@ class OrderedClassTests {
 				.containsSubsequence(classTemplate.getSimpleName(), otherClass.getSimpleName());
 	}
 
-	private static void assertIneffectiveOrderAnnotationIssues(List<DiscoveryIssue> discoveryIssues) {
-		assertThat(discoveryIssues).hasSize(2);
-		assertThat(discoveryIssues).extracting(DiscoveryIssue::severity).containsOnly(Severity.INFO);
-		assertThat(discoveryIssues).extracting(DiscoveryIssue::message) //
-				.allMatch(it -> it.startsWith("Ineffective @Order annotation on class")
-						&& it.endsWith("It will not be applied because ClassOrderer.OrderAnnotation is not in use."));
-		assertThat(discoveryIssues).extracting(DiscoveryIssue::source).extracting(Optional::orElseThrow) //
-				.containsExactlyInAnyOrder(ClassSource.from(A_TestCase.class), ClassSource.from(C_TestCase.class));
-	}
-
 	private Events executeTests(Class<? extends ClassOrderer> classOrderer) {
 		return executeTests(classOrderer, selectClass(A_TestCase.class), selectClass(B_TestCase.class),
 			selectClass(C_TestCase.class));
@@ -216,32 +177,14 @@ class OrderedClassTests {
 
 	private Events executeTests(Class<? extends ClassOrderer> classOrderer, DiscoverySelector... selectors) {
 		// @formatter:off
-		return testKit(classOrderer, selectors)
-				.execute()
-				.testEvents();
+		return EngineTestKit.engine("junit-jupiter")
+			.configurationParameter(DEFAULT_TEST_CLASS_ORDER_PROPERTY_NAME, classOrderer.getName())
+			.selectors(selectors)
+			.execute()
+			.testEvents();
 		// @formatter:on
 	}
 
-	private EngineDiscoveryResults discoverTests(Class<? extends ClassOrderer> classOrderer) {
-		return discoverTests(classOrderer, selectClass(A_TestCase.class), selectClass(B_TestCase.class),
-			selectClass(C_TestCase.class));
-	}
-
-	private EngineDiscoveryResults discoverTests(Class<? extends ClassOrderer> classOrderer,
-			DiscoverySelector... selectors) {
-		return testKit(classOrderer, selectors).discover();
-	}
-
-	private static EngineTestKit.Builder testKit(Class<? extends ClassOrderer> classOrderer,
-			DiscoverySelector[] selectors) {
-
-		var testKit = EngineTestKit.engine("junit-jupiter");
-		if (classOrderer != null) {
-			testKit.configurationParameter(DEFAULT_TEST_CLASS_ORDER_PROPERTY_NAME, classOrderer.getName());
-		}
-		return testKit.selectors(selectors);
-	}
-
 	static abstract class BaseTestCase {
 
 		@BeforeEach
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
index 0517a6dd0..90f34e291 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
@@ -19,7 +19,6 @@ import static org.junit.jupiter.engine.Constants.DEFAULT_PARALLEL_EXECUTION_MODE
 import static org.junit.jupiter.engine.Constants.DEFAULT_TEST_METHOD_ORDER_PROPERTY_NAME;
 import static org.junit.jupiter.engine.Constants.PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
-import static org.junit.platform.launcher.LauncherConstants.CRITICAL_DISCOVERY_ISSUE_SEVERITY_PROPERTY_NAME;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
@@ -57,11 +56,6 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
 import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.platform.commons.util.ClassUtils;
-import org.junit.platform.engine.DiscoveryIssue;
-import org.junit.platform.engine.DiscoveryIssue.Severity;
-import org.junit.platform.engine.support.descriptor.ClassSource;
-import org.junit.platform.engine.support.descriptor.MethodSource;
-import org.junit.platform.testkit.engine.EngineDiscoveryResults;
 import org.junit.platform.testkit.engine.EngineTestKit;
 import org.junit.platform.testkit.engine.Events;
 import org.mockito.Mockito;
@@ -96,7 +90,7 @@ class OrderedMethodTests {
 		// on the class names.
 		assertThat(testClass.getSuperclass().getName()).isGreaterThan(testClass.getName());
 
-		var tests = executeTestsInParallel(testClass, Random.class);
+		var tests = executeTestsInParallel(testClass);
 
 		tests.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -118,7 +112,7 @@ class OrderedMethodTests {
 		// on the class names.
 		assertThat(testClass.getSuperclass().getName()).isLessThan(testClass.getName());
 
-		var tests = executeTestsInParallel(testClass, Random.class);
+		var tests = executeTestsInParallel(testClass);
 
 		tests.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -129,7 +123,7 @@ class OrderedMethodTests {
 
 	@Test
 	void displayName() {
-		var tests = executeTestsInParallel(DisplayNameTestCase.class, Random.class);
+		var tests = executeTestsInParallel(DisplayNameTestCase.class);
 
 		tests.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -152,7 +146,7 @@ class OrderedMethodTests {
 
 	@Test
 	void orderAnnotationWithNestedTestClass() {
-		var tests = executeTestsInParallel(OrderAnnotationWithNestedClassTestCase.class, Random.class);
+		var tests = executeTestsInParallel(OrderAnnotationWithNestedClassTestCase.class);
 
 		tests.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -163,7 +157,7 @@ class OrderedMethodTests {
 	}
 
 	private void assertOrderAnnotationSupport(Class<?> testClass) {
-		var tests = executeTestsInParallel(testClass, Random.class);
+		var tests = executeTestsInParallel(testClass);
 
 		tests.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -174,7 +168,7 @@ class OrderedMethodTests {
 
 	@Test
 	void random() {
-		var tests = executeTestsInParallel(RandomTestCase.class, Random.class);
+		var tests = executeTestsInParallel(RandomTestCase.class);
 
 		tests.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -279,62 +273,35 @@ class OrderedMethodTests {
 	}
 
 	@Test
-	void reportsDiscoveryIssuesForIneffectiveOrderAnnotations() throws Exception {
-		var results = discoverTests(WithoutTestMethodOrderTestCase.class, OrderAnnotation.class);
-		assertThat(results.getDiscoveryIssues()).isEmpty();
-
-		results = discoverTests(WithoutTestMethodOrderTestCase.class, null);
-		assertIneffectiveOrderAnnotationIssues(results.getDiscoveryIssues());
-
-		results = discoverTests(WithoutTestMethodOrderTestCase.class, Random.class);
-		assertIneffectiveOrderAnnotationIssues(results.getDiscoveryIssues());
-	}
-
-	@Test
-	void misbehavingMethodOrdererThatAddsElements() {
+	void misbehavingMethodOrdererThatAddsElements(@TrackLogRecords LogRecordListener listener) {
 		Class<?> testClass = MisbehavingByAddingTestCase.class;
 
-		var discoveryIssues = discoverTests(testClass, null).getDiscoveryIssues();
-		assertThat(discoveryIssues).hasSize(1);
+		executeTestsInParallel(testClass).assertStatistics(stats -> stats.succeeded(2));
 
-		var issue = discoveryIssues.getFirst();
-		assertThat(issue.severity()).isEqualTo(Severity.WARNING);
-		assertThat(issue.message()).isEqualTo(
-			"MethodOrderer [%s] added 2 MethodDescriptor(s) for test class [%s] which will be ignored.",
-			MisbehavingByAdding.class.getName(), testClass.getName());
-		assertThat(issue.source()).contains(ClassSource.from(testClass));
+		assertThat(callSequence).containsExactly("test1()", "test2()");
 
-		executeTestsInParallel(testClass, null, Severity.ERROR) //
-				.assertStatistics(stats -> stats.succeeded(2));
+		var expectedMessage = "MethodOrderer [" + MisbehavingByAdding.class.getName()
+				+ "] added 2 MethodDescriptor(s) for test class [" + testClass.getName() + "] which will be ignored.";
 
-		assertThat(callSequence).containsExactly("test1()", "test2()");
+		assertExpectedLogMessage(listener, expectedMessage);
 	}
 
 	@Test
-	void misbehavingMethodOrdererThatImpersonatesElements() {
+	void misbehavingMethodOrdererThatImpersonatesElements(@TrackLogRecords LogRecordListener listener) {
 		Class<?> testClass = MisbehavingByImpersonatingTestCase.class;
 
-		executeTestsInParallel(testClass, Random.class).assertStatistics(stats -> stats.succeeded(2));
+		executeTestsInParallel(testClass).assertStatistics(stats -> stats.succeeded(2));
 
 		assertThat(callSequence).containsExactlyInAnyOrder("test1()", "test2()");
+
+		assertThat(listener.stream(Level.WARNING)).isEmpty();
 	}
 
 	@Test
-	void misbehavingMethodOrdererThatRemovesElements() {
+	void misbehavingMethodOrdererThatRemovesElements(@TrackLogRecords LogRecordListener listener) {
 		Class<?> testClass = MisbehavingByRemovingTestCase.class;
 
-		var discoveryIssues = discoverTests(testClass, null).getDiscoveryIssues();
-		assertThat(discoveryIssues).hasSize(1);
-
-		var issue = discoveryIssues.getFirst();
-		assertThat(issue.severity()).isEqualTo(Severity.WARNING);
-		assertThat(issue.message()).isEqualTo(
-			"MethodOrderer [%s] removed 2 MethodDescriptor(s) for test class [%s] which will be retained with arbitrary ordering.",
-			MisbehavingByRemoving.class.getName(), testClass.getName());
-		assertThat(issue.source()).contains(ClassSource.from(testClass));
-
-		executeTestsInParallel(testClass, null, Severity.ERROR) //
-				.assertStatistics(stats -> stats.succeeded(4));
+		executeTestsInParallel(testClass).assertStatistics(stats -> stats.succeeded(4));
 
 		assertThat(callSequence) //
 				.containsExactlyInAnyOrder("test1()", "test2()", "test3()", "test4()") //
@@ -343,33 +310,37 @@ class OrderedMethodTests {
 				.containsSubsequence("test1()", "test4()") // removed item is re-added before ordered item
 				.containsSubsequence("test2()", "test3()") // removed item is re-added before ordered item
 				.containsSubsequence("test2()", "test4()");// removed item is re-added before ordered item
-	}
 
-	private EngineDiscoveryResults discoverTests(Class<?> testClass, Class<? extends MethodOrderer> defaultOrderer) {
-		return testKit(testClass, defaultOrderer, Severity.INFO).discover();
+		var expectedMessage = "MethodOrderer [" + MisbehavingByRemoving.class.getName()
+				+ "] removed 2 MethodDescriptor(s) for test class [" + testClass.getName()
+				+ "] which will be retained with arbitrary ordering.";
+
+		assertExpectedLogMessage(listener, expectedMessage);
 	}
 
-	private Events executeTestsInParallel(Class<?> testClass, Class<? extends MethodOrderer> defaultOrderer) {
-		return executeTestsInParallel(testClass, defaultOrderer, Severity.INFO);
+	private void assertExpectedLogMessage(LogRecordListener listener, String expectedMessage) {
+		// @formatter:off
+		assertThat(listener.stream(Level.WARNING)
+				.map(LogRecord::getMessage))
+				.contains(expectedMessage);
+		// @formatter:on
 	}
 
-	private Events executeTestsInParallel(Class<?> testClass, Class<? extends MethodOrderer> defaultOrderer,
-			Severity criticalSeverity) {
-		return testKit(testClass, defaultOrderer, criticalSeverity) //
-				.execute() //
-				.testEvents();
+	private Events executeTestsInParallel(Class<?> testClass) {
+		return executeTestsInParallel(testClass, Random.class);
 	}
 
-	private static EngineTestKit.Builder testKit(Class<?> testClass, Class<? extends MethodOrderer> defaultOrderer,
-			Severity criticalSeverity) {
-		var testKit = EngineTestKit.engine("junit-jupiter") //
-				.configurationParameter(PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME, "true") //
-				.configurationParameter(DEFAULT_PARALLEL_EXECUTION_MODE, "concurrent") //
-				.configurationParameter(CRITICAL_DISCOVERY_ISSUE_SEVERITY_PROPERTY_NAME, criticalSeverity.name());
-		if (defaultOrderer != null) {
-			testKit.configurationParameter(DEFAULT_TEST_METHOD_ORDER_PROPERTY_NAME, defaultOrderer.getName());
-		}
-		return testKit.selectors(selectClass(testClass));
+	private Events executeTestsInParallel(Class<?> testClass, Class<? extends MethodOrderer> defaultOrderer) {
+		// @formatter:off
+		return EngineTestKit
+				.engine("junit-jupiter")
+				.configurationParameter(PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME, "true")
+				.configurationParameter(DEFAULT_PARALLEL_EXECUTION_MODE, "concurrent")
+				.configurationParameter(DEFAULT_TEST_METHOD_ORDER_PROPERTY_NAME, defaultOrderer.getName())
+				.selectors(selectClass(testClass))
+				.execute()
+				.testEvents();
+		// @formatter:on
 	}
 
 	private Events executeRandomTestCaseInParallelWithRandomSeed(String seed) {
@@ -389,19 +360,6 @@ class OrderedMethodTests {
 		// @formatter:on
 	}
 
-	private static void assertIneffectiveOrderAnnotationIssues(List<DiscoveryIssue> discoveryIssues) throws Exception {
-		assertThat(discoveryIssues).hasSize(3);
-		assertThat(discoveryIssues).extracting(DiscoveryIssue::severity).containsOnly(Severity.INFO);
-		assertThat(discoveryIssues).extracting(DiscoveryIssue::message) //
-				.allMatch(it -> it.startsWith("Ineffective @Order annotation on method")
-						&& it.endsWith("It will not be applied because MethodOrderer.OrderAnnotation is not in use."));
-		var testClass = WithoutTestMethodOrderTestCase.class;
-		assertThat(discoveryIssues).extracting(DiscoveryIssue::source).extracting(Optional::orElseThrow) //
-				.containsExactlyInAnyOrder(MethodSource.from(testClass.getDeclaredMethod("test1")),
-					MethodSource.from(testClass.getDeclaredMethod("test2")),
-					MethodSource.from(testClass.getDeclaredMethod("test3")));
-	}
-
 	// -------------------------------------------------------------------------
 
 	@SuppressWarnings("JUnitMalformedDeclaration")
