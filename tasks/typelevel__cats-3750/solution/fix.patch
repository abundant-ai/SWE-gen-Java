diff --git a/README.md b/README.md
index e3995c3eb..1323e3539 100644
--- a/README.md
+++ b/README.md
@@ -87,7 +87,7 @@ Support this project with your organization. Your logo will show up here with a
 
 ### Getting Started
 
-Cats is currently available for Scala 2.10 (up to 1.2.x), 2.11, 2.12, 2.13, and [Scala.js](http://www.scala-js.org/).
+Cats is currently available for Scala 2.10 (up to 1.2.x), 2.11, 2.12, 2.13, [Scala.js](http://www.scala-js.org/), and [Scala Native](https://www.scala-native.org/).
 
 Cats relies on improved type inference via the fix for [SI-2712](https://github.com/scala/bug/issues/2712), which is not enabled by default. For **Scala 2.11.9+ or 2.12** you should add the following to your `build.sbt`:
 
diff --git a/core/src/main/scala/cats/data/ContT.scala b/core/src/main/scala/cats/data/ContT.scala
index 07f9b9807..2006507a4 100644
--- a/core/src/main/scala/cats/data/ContT.scala
+++ b/core/src/main/scala/cats/data/ContT.scala
@@ -40,9 +40,7 @@ sealed abstract class ContT[M[_], A, +B] extends Serializable {
     // allocate/pattern match once
     val fnAndThen = AndThen(fn)
     ContT[M, A, C] { fn2 =>
-      val contRun: ContT[M, A, C] => M[A] = { c =>
-        M.defer(c.run(fn2))
-      }
+      val contRun: ContT[M, A, C] => M[A] = _.run(fn2)
       val fn3: B => M[A] = fnAndThen.andThen(contRun)
       M.defer(run(fn3))
     }
@@ -107,32 +105,6 @@ object ContT {
       def apply[A](ma: M[A]): ContT[M, B, A] = ContT.liftF(ma)
     }
 
-  /*
-   * Call with current continuation
-   *
-   * Passes the current continuation to f, meaning we can model short-circuit
-   * evaluation eg exception handling
-   *
-   * {{{
-   *   for {
-   *     _ <- ContT.callCC( (k: Unit => ContT[IO, Unit, Unit]) =>
-   *       ContT.liftF(IO.println("this will print first")) >>
-   *         k(()) >>
-   *         ContT.liftF(IO.println("this will NOT print as we short-circuit to the contination"))
-   *     )
-   *     _ <- ContT.liftF(IO.println("this will print second")])
-   *   } yield ()
-   *
-   * }}}
-   */
-  def callCC[M[_], R, A, B](f: (A => ContT[M, R, B]) => ContT[M, R, A])(implicit M: Defer[M]): ContT[M, R, A] =
-    apply { cb =>
-      val cont = f { a =>
-        apply(_ => cb(a))
-      }
-      M.defer(cont.run(cb))
-    }
-
   /**
    * Similar to [[pure]] but evaluation of the argument is deferred.
    *
diff --git a/free/src/main/scala/cats/free/Free.scala b/free/src/main/scala/cats/free/Free.scala
index 2c674431f..123429b15 100644
--- a/free/src/main/scala/cats/free/Free.scala
+++ b/free/src/main/scala/cats/free/Free.scala
@@ -276,7 +276,7 @@ object Free extends FreeInstances {
    * This method exists to allow the `F` and `G` parameters to be
    * bound independently of the `A` parameter below.
    */
-  @deprecated("use liftInject", "2.3.1")
+  // TODO: to be deprecated / removed in cats 2.0
   def inject[F[_], G[_]]: FreeInjectKPartiallyApplied[F, G] =
     new FreeInjectKPartiallyApplied
 
diff --git a/kernel-laws/js/src/main/scala/cats/platform/Platform.scala b/kernel-laws/js/src/main/scala/cats/platform/Platform.scala
index 13a9bb3b5..7a6c16c9e 100644
--- a/kernel-laws/js/src/main/scala/cats/platform/Platform.scala
+++ b/kernel-laws/js/src/main/scala/cats/platform/Platform.scala
@@ -5,5 +5,6 @@ private[cats] object Platform {
   // $COVERAGE-OFF$
   final val isJvm = false
   final val isJs = true
+  final val isNative = false
   // $COVERAGE-ON$
 }
diff --git a/kernel-laws/jvm/src/main/scala/cats/platform/Platform.scala b/kernel-laws/jvm/src/main/scala/cats/platform/Platform.scala
index fa14235e6..7a208487e 100644
--- a/kernel-laws/jvm/src/main/scala/cats/platform/Platform.scala
+++ b/kernel-laws/jvm/src/main/scala/cats/platform/Platform.scala
@@ -5,5 +5,6 @@ private[cats] object Platform {
   // $COVERAGE-OFF$
   final val isJvm = true
   final val isJs = false
+  final val isNative = false
   // $COVERAGE-ON$
 }
diff --git a/kernel-laws/native/src/main/scala/cats/platform/Platform.scala b/kernel-laws/native/src/main/scala/cats/platform/Platform.scala
new file mode 100644
index 000000000..699cdd6da
--- /dev/null
+++ b/kernel-laws/native/src/main/scala/cats/platform/Platform.scala
@@ -0,0 +1,10 @@
+package cats.platform
+
+private[cats] object Platform {
+  // using `final val` makes compiler constant-fold any use of these values, dropping dead code automatically
+  // $COVERAGE-OFF$
+  final val isJvm = false
+  final val isJs = false
+  final val isNative = true
+  // $COVERAGE-ON$
+}
diff --git a/kernel-laws/shared/src/main/scala/cats/kernel/laws/SerializableLaws.scala b/kernel-laws/shared/src/main/scala/cats/kernel/laws/SerializableLaws.scala
index ae2ee0d83..ac2190de1 100644
--- a/kernel-laws/shared/src/main/scala/cats/kernel/laws/SerializableLaws.scala
+++ b/kernel-laws/shared/src/main/scala/cats/kernel/laws/SerializableLaws.scala
@@ -18,14 +18,13 @@ object SerializableLaws {
   // This part is a bit tricky. Basically, we only want to test
   // serializability on the JVM.
   //
-  // `Platform.isJs` is a constant expression, so we can rely on
+  // `Platform.isJvm` is a constant expression, so we can rely on
   // scalac to prune away the "other" branch. Thus, when Scala.js
   // looks at this method it won't "see" the branch which was removed,
   // and will avoid an error trying to support java.io.*.
 
   def serializable[A](a: A): Prop =
-    if (Platform.isJs) Prop(_ => Result(status = Proof))
-    else
+    if (Platform.isJvm) {
       Prop { _ =>
         import java.io.{ByteArrayInputStream, ByteArrayOutputStream, ObjectInputStream, ObjectOutputStream}
 
@@ -48,4 +47,5 @@ object SerializableLaws {
           if (ois != null) ois.close() // scalastyle:ignore null
         }
       }
+    } else Prop(_ => Result(status = Proof))
 }
diff --git a/kernel/src/main/scala/cats/kernel/Comparison.scala b/kernel/src/main/scala/cats/kernel/Comparison.scala
index bd1a74665..0d08af974 100644
--- a/kernel/src/main/scala/cats/kernel/Comparison.scala
+++ b/kernel/src/main/scala/cats/kernel/Comparison.scala
@@ -26,14 +26,5 @@ object Comparison {
     else if (double == 0.0) SomeEq
     else SomeLt
 
-  implicit val catsKernelEqForComparison: Eq[Comparison] with Monoid[Comparison] =
-    new Eq[Comparison] with Monoid[Comparison] {
-      def eqv(x: Comparison, y: Comparison): Boolean = x == y
-      def empty: Comparison = EqualTo
-
-      def combine(x: Comparison, y: Comparison): Comparison = x match {
-        case EqualTo => y
-        case comp    => comp
-      }
-    }
+  implicit val catsKernelEqForComparison: Eq[Comparison] = Eq.fromUniversalEquals
 }
diff --git a/kernel/src/main/scala/cats/kernel/Enumerable.scala b/kernel/src/main/scala/cats/kernel/Enumerable.scala
index 96753108e..76f94d54b 100644
--- a/kernel/src/main/scala/cats/kernel/Enumerable.scala
+++ b/kernel/src/main/scala/cats/kernel/Enumerable.scala
@@ -67,8 +67,6 @@ object BoundedEnumerable {
     cats.kernel.instances.unit.catsKernelStdOrderForUnit
   implicit def catsKernelBoundedEnumerableForBoolean: BoundedEnumerable[Boolean] =
     cats.kernel.instances.boolean.catsKernelStdOrderForBoolean
-  implicit def catsKernelBoundedEnumerableForByte: BoundedEnumerable[Byte] =
-    cats.kernel.instances.byte.catsKernelStdOrderForByte
   implicit def catsKernelBoundedEnumerableForInt: BoundedEnumerable[Int] =
     cats.kernel.instances.int.catsKernelStdOrderForInt
   implicit def catsKernelBoundedEnumerableForShort: BoundedEnumerable[Short] =
diff --git a/kernel/src/main/scala/cats/kernel/instances/ByteInstances.scala b/kernel/src/main/scala/cats/kernel/instances/ByteInstances.scala
index 7ba66a1e7..f81b7813c 100644
--- a/kernel/src/main/scala/cats/kernel/instances/ByteInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/ByteInstances.scala
@@ -2,7 +2,7 @@ package cats.kernel
 package instances
 
 trait ByteInstances {
-  implicit val catsKernelStdOrderForByte: Order[Byte] with Hash[Byte] with BoundedEnumerable[Byte] =
+  implicit val catsKernelStdOrderForByte: Order[Byte] with Hash[Byte] with LowerBounded[Byte] with UpperBounded[Byte] =
     new ByteOrder
   implicit val catsKernelStdGroupForByte: CommutativeGroup[Byte] = new ByteGroup
 }
@@ -14,19 +14,12 @@ class ByteGroup extends CommutativeGroup[Byte] {
   override def remove(x: Byte, y: Byte): Byte = (x - y).toByte
 }
 
-trait ByteEnumerable extends BoundedEnumerable[Byte] {
-  override def partialNext(a: Byte): Option[Byte] =
-    if (order.eqv(a, maxBound)) None else Some((a + 1).toByte)
-  override def partialPrevious(a: Byte): Option[Byte] =
-    if (order.eqv(a, minBound)) None else Some((a - 1).toByte)
-}
-
 trait ByteBounded extends LowerBounded[Byte] with UpperBounded[Byte] {
   override def minBound: Byte = Byte.MinValue
   override def maxBound: Byte = Byte.MaxValue
 }
 
-class ByteOrder extends Order[Byte] with Hash[Byte] with ByteBounded with ByteEnumerable { self =>
+class ByteOrder extends Order[Byte] with Hash[Byte] with ByteBounded { self =>
 
   def hash(x: Byte): Int = x.hashCode()
 
@@ -45,5 +38,5 @@ class ByteOrder extends Order[Byte] with Hash[Byte] with ByteBounded with ByteEn
   override def max(x: Byte, y: Byte): Byte =
     java.lang.Math.max(x.toInt, y.toInt).toByte
 
-  override val order: Order[Byte] = self
+  override val partialOrder: PartialOrder[Byte] = self
 }
diff --git a/project/plugins.sbt b/project/plugins.sbt
index c4ff5a0af..3035dd84d 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -11,7 +11,9 @@ addSbtPlugin("org.xerial.sbt" % "sbt-sonatype" % "3.9.5")
 addSbtPlugin("com.47deg" % "sbt-microsites" % "1.3.1")
 addSbtPlugin("org.scalameta" % "sbt-mdoc" % "2.2.16")
 addSbtPlugin("org.portable-scala" % "sbt-scalajs-crossproject" % "1.0.0")
+addSbtPlugin("org.portable-scala" % "sbt-scala-native-crossproject" % "1.0.0")
 addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.4.0")
+addSbtPlugin("org.scala-native" % "sbt-scala-native" % "0.4.0")
 addSbtPlugin("org.scalameta" % "sbt-scalafmt" % "2.4.2")
 addSbtPlugin("com.eed3si9n" % "sbt-buildinfo" % "0.10.0")
 addSbtPlugin("com.codecommit" % "sbt-github-actions" % "0.10.1")
