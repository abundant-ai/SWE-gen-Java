diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 3e74f8d04..474824167 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -20,33 +20,22 @@ jobs:
   build:
     name: Build and Test
     strategy:
-      fail-fast: false
       matrix:
         os: [ubuntu-latest]
-        scala: [2.12.13, 2.13.4, 3.0.0-M2, 3.0.0-M3]
+        scala: [2.12.12, 2.13.4, 3.0.0-M2, 3.0.0-M3]
         java:
           - adopt@1.8
           - adopt@1.11
           - adopt@1.15
           - graalvm-ce-java8@20.2.0
-        platform: [jvm, js, native]
+        platform: [jvm, js]
         exclude:
           - platform: js
             java: adopt@1.11
-          - platform: native
-            java: adopt@1.11
           - platform: js
             java: adopt@1.15
-          - platform: native
-            java: adopt@1.15
           - platform: js
             java: graalvm-ce-java8@20.2.0
-          - platform: native
-            java: graalvm-ce-java8@20.2.0
-          - platform: native
-            scala: 3.0.0-M2
-          - platform: native
-            scala: 3.0.0-M3
     runs-on: ${{ matrix.os }}
     steps:
       - name: Checkout current branch (full)
@@ -78,10 +67,6 @@ jobs:
         if: matrix.platform == 'js'
         run: sbt ++${{ matrix.scala }} validateAllJS
 
-      - name: Validate Scala Native
-        if: matrix.platform == 'native'
-        run: sbt ++${{ matrix.scala }} validateAllNative
-
       - name: Validate JVM (scala 2)
         if: matrix.platform == 'jvm' && (matrix.scala != '3.0.0-M2' && matrix.scala != '3.0.0-M3')
         run: sbt ++${{ matrix.scala }} buildJVM bench/test
@@ -99,7 +84,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-latest]
-        scala: [2.12.13, 2.13.4, 3.0.0-M2, 3.0.0-M3]
+        scala: [2.12.12, 2.13.4, 3.0.0-M2, 3.0.0-M3]
         java: [adopt@1.8]
     runs-on: ${{ matrix.os }}
     steps:
@@ -135,7 +120,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-latest]
-        scala: [2.12.13, 2.13.4, 3.0.0-M2, 3.0.0-M3]
+        scala: [2.12.12, 2.13.4, 3.0.0-M2, 3.0.0-M3]
         java: [adopt@1.8]
     runs-on: ${{ matrix.os }}
     steps:
@@ -170,7 +155,7 @@ jobs:
     strategy:
       matrix:
         os: [ubuntu-latest]
-        scala: [2.12.13]
+        scala: [2.12.12]
         java: [adopt@1.8]
     runs-on: ${{ matrix.os }}
     steps:
diff --git a/README.md b/README.md
index 1323e3539..e3995c3eb 100644
--- a/README.md
+++ b/README.md
@@ -87,7 +87,7 @@ Support this project with your organization. Your logo will show up here with a
 
 ### Getting Started
 
-Cats is currently available for Scala 2.10 (up to 1.2.x), 2.11, 2.12, 2.13, [Scala.js](http://www.scala-js.org/), and [Scala Native](https://www.scala-native.org/).
+Cats is currently available for Scala 2.10 (up to 1.2.x), 2.11, 2.12, 2.13, and [Scala.js](http://www.scala-js.org/).
 
 Cats relies on improved type inference via the fix for [SI-2712](https://github.com/scala/bug/issues/2712), which is not enabled by default. For **Scala 2.11.9+ or 2.12** you should add the following to your `build.sbt`:
 
diff --git a/alleycats-tests/native/src/test/scala/alleycats/tests/TestSettings.scala b/alleycats-tests/native/src/test/scala/alleycats/tests/TestSettings.scala
deleted file mode 100644
index 423ff0176..000000000
--- a/alleycats-tests/native/src/test/scala/alleycats/tests/TestSettings.scala
+++ /dev/null
@@ -1,14 +0,0 @@
-package alleycats.tests
-
-import org.scalacheck.Test.Parameters
-
-trait TestSettings {
-
-  lazy val checkConfiguration: Parameters =
-    Parameters.default
-      .withMinSuccessfulTests(50)
-      .withMaxDiscardRatio(5.0f)
-      .withMaxSize(10)
-      .withMinSize(0)
-      .withWorkers(1)
-}
diff --git a/build.sbt b/build.sbt
index e3f462307..4c0cfe211 100644
--- a/build.sbt
+++ b/build.sbt
@@ -35,7 +35,7 @@ val GraalVM8 = "graalvm-ce-java8@20.2.0"
 
 ThisBuild / githubWorkflowJavaVersions := Seq(PrimaryJava, LTSJava, LatestJava, GraalVM8)
 
-val Scala212 = "2.12.13"
+val Scala212 = "2.12.12"
 val Scala213 = "2.13.4"
 val DottyOld = "3.0.0-M2"
 val DottyNew = "3.0.0-M3"
@@ -46,34 +46,24 @@ ThisBuild / scalaVersion := Scala213
 ThisBuild / githubWorkflowPublishTargetBranches := Seq() // disable publication for now
 
 ThisBuild / githubWorkflowBuildMatrixAdditions +=
-  "platform" -> List("jvm", "js", "native")
+  "platform" -> List("jvm", "js")
 
 ThisBuild / githubWorkflowBuildMatrixExclusions ++=
-  githubWorkflowJavaVersions.value.filterNot(Set(PrimaryJava)).flatMap { java =>
-    Seq(MatrixExclude(Map("platform" -> "js", "java" -> java)),
-        MatrixExclude(Map("platform" -> "native", "java" -> java))
-    )
+  githubWorkflowJavaVersions.value.filterNot(Set(PrimaryJava)).map { java =>
+    MatrixExclude(Map("platform" -> "js", "java" -> java))
   }
 
-ThisBuild / githubWorkflowBuildMatrixExclusions ++= Seq(DottyOld, DottyNew).map { dottyVersion =>
-  MatrixExclude(Map("platform" -> "native", "scala" -> dottyVersion))
-} // Dotty is not yet supported by Scala Native
-
 // we don't need this since we aren't publishing
 ThisBuild / githubWorkflowArtifactUpload := false
 
-ThisBuild / githubWorkflowBuildMatrixFailFast := Some(false)
-
 val JvmCond = s"matrix.platform == 'jvm'"
 val JsCond = s"matrix.platform == 'js'"
-val NativeCond = s"matrix.platform == 'native'"
 
 val Scala2Cond = s"(matrix.scala != '$DottyOld' && matrix.scala != '$DottyNew')"
 val Scala3Cond = s"(matrix.scala == '$DottyOld' || matrix.scala == '$DottyNew')"
 
 ThisBuild / githubWorkflowBuild := Seq(
   WorkflowStep.Sbt(List("validateAllJS"), name = Some("Validate JavaScript"), cond = Some(JsCond)),
-  WorkflowStep.Sbt(List("validateAllNative"), name = Some("Validate Scala Native"), cond = Some(NativeCond)),
   WorkflowStep.Sbt(List("buildJVM", "bench/test"),
                    name = Some("Validate JVM (scala 2)"),
                    cond = Some(JvmCond + " && " + Scala2Cond)
@@ -206,14 +196,6 @@ lazy val commonJsSettings = Seq(
   doctestGenTests := Seq.empty
 )
 
-lazy val commonNativeSettings = Seq(
-  // currently sbt-doctest doesn't work in Native/JS builds
-  // https://github.com/tkawachi/sbt-doctest/issues/52
-  doctestGenTests := Seq.empty,
-  // Currently scala-native does not support Dotty
-  crossScalaVersions := { crossScalaVersions.value.filterNot(Seq(DottyOld, DottyNew).contains) }
-)
-
 lazy val commonJvmSettings = Seq(
   testOptions in Test += {
     val flag = if (githubIsWorkflowBuild.value) "-oCI" else "-oDF"
@@ -512,8 +494,8 @@ lazy val cats = project
   .settings(moduleName := "root")
   .settings(publishSettings) // these settings are needed to release all aggregated modules under this root module
   .settings(noPublishSettings) // this is to exclude the root module itself from being published.
-  .aggregate(catsJVM, catsJS, catsNative)
-  .dependsOn(catsJVM, catsJS, catsNative, tests.jvm % "test-internal -> test")
+  .aggregate(catsJVM, catsJS)
+  .dependsOn(catsJVM, catsJS, tests.jvm % "test-internal -> test")
 
 lazy val catsJVM = project
   .in(file(".catsJVM"))
@@ -580,41 +562,7 @@ lazy val catsJS = project
   )
   .enablePlugins(ScalaJSPlugin)
 
-lazy val catsNative = project
-  .in(file(".catsNative"))
-  .settings(moduleName := "cats")
-  .settings(noPublishSettings)
-  .settings(catsSettings)
-  .settings(commonNativeSettings)
-  .aggregate(
-    kernel.native,
-    kernelLaws.native,
-    core.native,
-    laws.native,
-    free.native,
-    testkit.native,
-    tests.native,
-    alleycatsCore.native,
-    alleycatsLaws.native,
-    alleycatsTests.native,
-    native
-  )
-  .dependsOn(
-    kernel.native,
-    kernelLaws.native,
-    core.native,
-    laws.native,
-    free.native,
-    testkit.native,
-    tests.native % "test-internal -> test",
-    alleycatsCore.native,
-    alleycatsLaws.native,
-    alleycatsTests.native % "test-internal -> test",
-    native
-  )
-  .enablePlugins(ScalaNativePlugin)
-
-lazy val kernel = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val kernel = crossProject(JSPlatform, JVMPlatform)
   .crossType(CrossType.Pure)
   .in(file("kernel"))
   .settings(moduleName := "cats-kernel", name := "Cats kernel")
@@ -624,13 +572,11 @@ lazy val kernel = crossProject(JSPlatform, JVMPlatform, NativePlatform)
   .settings(includeGeneratedSrc)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("cats-kernel"))
-  .nativeSettings(commonNativeSettings)
-  .settings(testingDependencies)
   .settings(
     libraryDependencies += "org.scalacheck" %%% "scalacheck" % scalaCheckVersion % Test
   )
 
-lazy val kernelLaws = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val kernelLaws = crossProject(JSPlatform, JVMPlatform)
   .in(file("kernel-laws"))
   .settings(moduleName := "cats-kernel-laws", name := "Cats kernel laws")
   .settings(commonSettings)
@@ -641,9 +587,8 @@ lazy val kernelLaws = crossProject(JSPlatform, JVMPlatform, NativePlatform)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("cats-kernel-laws", includeCats1 = false))
   .dependsOn(kernel)
-  .nativeSettings(commonNativeSettings)
 
-lazy val core = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val core = crossProject(JSPlatform, JVMPlatform)
   .crossType(CrossType.Pure)
   .dependsOn(kernel)
   .settings(moduleName := "cats-core", name := "Cats core")
@@ -663,10 +608,8 @@ lazy val core = crossProject(JSPlatform, JVMPlatform, NativePlatform)
   )
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("cats-core"))
-  .settings(testingDependencies)
-  .nativeSettings(commonNativeSettings)
 
-lazy val laws = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val laws = crossProject(JSPlatform, JVMPlatform)
   .crossType(CrossType.Pure)
   .dependsOn(kernel, core, kernelLaws)
   .settings(moduleName := "cats-laws", name := "Cats laws")
@@ -675,18 +618,16 @@ lazy val laws = crossProject(JSPlatform, JVMPlatform, NativePlatform)
   .settings(testingDependencies)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("cats-laws", includeCats1 = false))
-  .nativeSettings(commonNativeSettings)
 
-lazy val free = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val free = crossProject(JSPlatform, JVMPlatform)
   .crossType(CrossType.Pure)
   .dependsOn(core, tests % "test-internal -> test")
   .settings(moduleName := "cats-free", name := "Cats Free")
   .settings(catsSettings)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("cats-free"))
-  .nativeSettings(commonNativeSettings)
 
-lazy val tests = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val tests = crossProject(JSPlatform, JVMPlatform)
   .crossType(CrossType.Pure)
   .dependsOn(testkit % Test)
   .settings(moduleName := "cats-tests")
@@ -696,9 +637,8 @@ lazy val tests = crossProject(JSPlatform, JVMPlatform, NativePlatform)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings)
   .settings(scalacOptions in Test := (scalacOptions in Test).value.filter(_ != "-Xfatal-warnings"))
-  .nativeSettings(commonNativeSettings)
 
-lazy val testkit = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val testkit = crossProject(JSPlatform, JVMPlatform)
   .crossType(CrossType.Pure)
   .dependsOn(core, laws)
   .enablePlugins(BuildInfoPlugin)
@@ -709,9 +649,8 @@ lazy val testkit = crossProject(JSPlatform, JVMPlatform, NativePlatform)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("cats-testkit", includeCats1 = false))
   .settings(scalacOptions := scalacOptions.value.filter(_ != "-Xfatal-warnings"))
-  .nativeSettings(commonNativeSettings)
 
-lazy val alleycatsCore = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val alleycatsCore = crossProject(JSPlatform, JVMPlatform)
   .crossType(CrossType.Pure)
   .in(file("alleycats-core"))
   .dependsOn(core)
@@ -721,9 +660,8 @@ lazy val alleycatsCore = crossProject(JSPlatform, JVMPlatform, NativePlatform)
   .settings(includeGeneratedSrc)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("alleycats-core", includeCats1 = false))
-  .nativeSettings(commonNativeSettings)
 
-lazy val alleycatsLaws = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val alleycatsLaws = crossProject(JSPlatform, JVMPlatform)
   .crossType(CrossType.Pure)
   .in(file("alleycats-laws"))
   .dependsOn(alleycatsCore, laws)
@@ -734,9 +672,8 @@ lazy val alleycatsLaws = crossProject(JSPlatform, JVMPlatform, NativePlatform)
   .settings(testingDependencies)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings ++ mimaSettings("alleycats-laws", includeCats1 = false))
-  .nativeSettings(commonNativeSettings)
 
-lazy val alleycatsTests = crossProject(JSPlatform, JVMPlatform, NativePlatform)
+lazy val alleycatsTests = crossProject(JSPlatform, JVMPlatform)
   .in(file("alleycats-tests"))
   .dependsOn(alleycatsLaws, tests % "test-internal -> test")
   .settings(moduleName := "alleycats-tests")
@@ -745,7 +682,6 @@ lazy val alleycatsTests = crossProject(JSPlatform, JVMPlatform, NativePlatform)
   .jsSettings(commonJsSettings)
   .jvmSettings(commonJvmSettings)
   .settings(scalacOptions in Test := (scalacOptions in Test).value.filter(_ != "-Xfatal-warnings"))
-  .nativeSettings(commonNativeSettings)
 
 // bench is currently JVM-only
 
@@ -790,14 +726,6 @@ lazy val js = project
   .settings(commonJsSettings)
   .enablePlugins(ScalaJSPlugin)
 
-// cats-native is Native-only
-lazy val native = project
-  .dependsOn(core.native, tests.native % "test-internal -> test")
-  .settings(moduleName := "cats-native")
-  .settings(catsSettings)
-  .settings(commonNativeSettings)
-  .enablePlugins(ScalaNativePlugin)
-
 // cats-jvm is JVM-only
 lazy val jvm = project
   .dependsOn(core.jvm, tests.jvm % "test-internal -> test")
@@ -902,24 +830,14 @@ addCommandAlias("buildTestsJVM", ";lawsJVM/test;testkitJVM/test;testsJVM/test;jv
 addCommandAlias("buildFreeJVM", ";freeJVM/test")
 addCommandAlias("buildAlleycatsJVM", ";alleycatsCoreJVM/test;alleycatsLawsJVM/test;alleycatsTestsJVM/test")
 addCommandAlias("buildJVM", ";buildKernelJVM;buildCoreJVM;buildTestsJVM;buildFreeJVM;buildAlleycatsJVM")
-addCommandAlias("validateBC", ";binCompatTest/test;catsJVM/mimaReportBinaryIssues")
+addCommandAlias("validateBC", ";binCompatTest/test;mimaReportBinaryIssues")
 addCommandAlias("validateJVM", ";fmtCheck;buildJVM;bench/test;validateBC;makeMicrosite")
 addCommandAlias("validateJS", ";testsJS/test;js/test")
 addCommandAlias("validateKernelJS", "kernelLawsJS/test")
 addCommandAlias("validateFreeJS", "freeJS/test")
 addCommandAlias("validateAlleycatsJS", "alleycatsTestsJS/test")
 addCommandAlias("validateAllJS", "all testsJS/test js/test kernelLawsJS/test freeJS/test alleycatsTestsJS/test")
-addCommandAlias("validateNative", ";testsNative/test;native/test")
-addCommandAlias("validateKernelNative", "kernelLawsNative/test")
-addCommandAlias("validateFreeNative", "freeNative/test")
-addCommandAlias("validateAlleycatsNative", "alleycatsTestsNative/test")
-addCommandAlias("validateAllNative",
-                "all testsNative/test native/test kernelLawsNative/test freeNative/test alleycatsTestsNative/test"
-)
-addCommandAlias(
-  "validate",
-  ";clean;validateJS;validateKernelJS;validateFreeJS;validateNative;validateKernelNative;validateFreeNative;validateJVM"
-)
+addCommandAlias("validate", ";clean;validateJS;validateKernelJS;validateFreeJS;validateJVM")
 
 addCommandAlias("prePR", "fmt")
 
diff --git a/core/src/main/scala/cats/data/ContT.scala b/core/src/main/scala/cats/data/ContT.scala
index 2006507a4..07f9b9807 100644
--- a/core/src/main/scala/cats/data/ContT.scala
+++ b/core/src/main/scala/cats/data/ContT.scala
@@ -40,7 +40,9 @@ sealed abstract class ContT[M[_], A, +B] extends Serializable {
     // allocate/pattern match once
     val fnAndThen = AndThen(fn)
     ContT[M, A, C] { fn2 =>
-      val contRun: ContT[M, A, C] => M[A] = _.run(fn2)
+      val contRun: ContT[M, A, C] => M[A] = { c =>
+        M.defer(c.run(fn2))
+      }
       val fn3: B => M[A] = fnAndThen.andThen(contRun)
       M.defer(run(fn3))
     }
@@ -105,6 +107,32 @@ object ContT {
       def apply[A](ma: M[A]): ContT[M, B, A] = ContT.liftF(ma)
     }
 
+  /*
+   * Call with current continuation
+   *
+   * Passes the current continuation to f, meaning we can model short-circuit
+   * evaluation eg exception handling
+   *
+   * {{{
+   *   for {
+   *     _ <- ContT.callCC( (k: Unit => ContT[IO, Unit, Unit]) =>
+   *       ContT.liftF(IO.println("this will print first")) >>
+   *         k(()) >>
+   *         ContT.liftF(IO.println("this will NOT print as we short-circuit to the contination"))
+   *     )
+   *     _ <- ContT.liftF(IO.println("this will print second")])
+   *   } yield ()
+   *
+   * }}}
+   */
+  def callCC[M[_], R, A, B](f: (A => ContT[M, R, B]) => ContT[M, R, A])(implicit M: Defer[M]): ContT[M, R, A] =
+    apply { cb =>
+      val cont = f { a =>
+        apply(_ => cb(a))
+      }
+      M.defer(cont.run(cb))
+    }
+
   /**
    * Similar to [[pure]] but evaluation of the argument is deferred.
    *
diff --git a/free/src/main/scala/cats/free/Free.scala b/free/src/main/scala/cats/free/Free.scala
index 123429b15..2c674431f 100644
--- a/free/src/main/scala/cats/free/Free.scala
+++ b/free/src/main/scala/cats/free/Free.scala
@@ -276,7 +276,7 @@ object Free extends FreeInstances {
    * This method exists to allow the `F` and `G` parameters to be
    * bound independently of the `A` parameter below.
    */
-  // TODO: to be deprecated / removed in cats 2.0
+  @deprecated("use liftInject", "2.3.1")
   def inject[F[_], G[_]]: FreeInjectKPartiallyApplied[F, G] =
     new FreeInjectKPartiallyApplied
 
diff --git a/free/src/test/scala/cats/free/FreeSuite.scala b/free/src/test/scala/cats/free/FreeSuite.scala
index b8a81f274..ed180dc7d 100644
--- a/free/src/test/scala/cats/free/FreeSuite.scala
+++ b/free/src/test/scala/cats/free/FreeSuite.scala
@@ -196,17 +196,6 @@ class FreeSuite extends CatsSuite {
 
   val eitherKInterpreter: FunctionK[T, Id] = Test1Interpreter.or(Test2Interpreter)
 
-  test(".inject") {
-    forAll { (x: Int, y: Int) =>
-      def res[F[_]](implicit I0: Test1Algebra :<: F, I1: Test2Algebra :<: F): Free[F, Int] =
-        for {
-          a <- Free.inject[Test1Algebra, F](test1(x, identity))
-          b <- Free.inject[Test2Algebra, F](test2(y, identity))
-        } yield a + b
-      assert(res[T].foldMap(eitherKInterpreter) == (x + y))
-    }
-  }
-
   test(".liftInject") {
     forAll { (x: Int, y: Int) =>
       def res[F[_]](implicit I0: Test1Algebra :<: F, I1: Test2Algebra :<: F): Free[F, Int] =
@@ -218,8 +207,6 @@ class FreeSuite extends CatsSuite {
     }
   }
 
-  val x: Free[T, Int] = Free.inject[Test1Algebra, T](Test1(1, identity))
-
   test(".injectRoll") {
     def distr[F[_], A](
       f: Free[F, A]
diff --git a/kernel-laws/js/src/main/scala/cats/platform/Platform.scala b/kernel-laws/js/src/main/scala/cats/platform/Platform.scala
index 7a6c16c9e..13a9bb3b5 100644
--- a/kernel-laws/js/src/main/scala/cats/platform/Platform.scala
+++ b/kernel-laws/js/src/main/scala/cats/platform/Platform.scala
@@ -5,6 +5,5 @@ private[cats] object Platform {
   // $COVERAGE-OFF$
   final val isJvm = false
   final val isJs = true
-  final val isNative = false
   // $COVERAGE-ON$
 }
diff --git a/kernel-laws/jvm/src/main/scala/cats/platform/Platform.scala b/kernel-laws/jvm/src/main/scala/cats/platform/Platform.scala
index 7a208487e..fa14235e6 100644
--- a/kernel-laws/jvm/src/main/scala/cats/platform/Platform.scala
+++ b/kernel-laws/jvm/src/main/scala/cats/platform/Platform.scala
@@ -5,6 +5,5 @@ private[cats] object Platform {
   // $COVERAGE-OFF$
   final val isJvm = true
   final val isJs = false
-  final val isNative = false
   // $COVERAGE-ON$
 }
diff --git a/kernel-laws/native/src/main/scala/cats/platform/Platform.scala b/kernel-laws/native/src/main/scala/cats/platform/Platform.scala
deleted file mode 100644
index 699cdd6da..000000000
--- a/kernel-laws/native/src/main/scala/cats/platform/Platform.scala
+++ /dev/null
@@ -1,10 +0,0 @@
-package cats.platform
-
-private[cats] object Platform {
-  // using `final val` makes compiler constant-fold any use of these values, dropping dead code automatically
-  // $COVERAGE-OFF$
-  final val isJvm = false
-  final val isJs = false
-  final val isNative = true
-  // $COVERAGE-ON$
-}
diff --git a/kernel-laws/shared/src/main/scala/cats/kernel/laws/SerializableLaws.scala b/kernel-laws/shared/src/main/scala/cats/kernel/laws/SerializableLaws.scala
index ac2190de1..ae2ee0d83 100644
--- a/kernel-laws/shared/src/main/scala/cats/kernel/laws/SerializableLaws.scala
+++ b/kernel-laws/shared/src/main/scala/cats/kernel/laws/SerializableLaws.scala
@@ -18,13 +18,14 @@ object SerializableLaws {
   // This part is a bit tricky. Basically, we only want to test
   // serializability on the JVM.
   //
-  // `Platform.isJvm` is a constant expression, so we can rely on
+  // `Platform.isJs` is a constant expression, so we can rely on
   // scalac to prune away the "other" branch. Thus, when Scala.js
   // looks at this method it won't "see" the branch which was removed,
   // and will avoid an error trying to support java.io.*.
 
   def serializable[A](a: A): Prop =
-    if (Platform.isJvm) {
+    if (Platform.isJs) Prop(_ => Result(status = Proof))
+    else
       Prop { _ =>
         import java.io.{ByteArrayInputStream, ByteArrayOutputStream, ObjectInputStream, ObjectOutputStream}
 
@@ -47,5 +48,4 @@ object SerializableLaws {
           if (ois != null) ois.close() // scalastyle:ignore null
         }
       }
-    } else Prop(_ => Result(status = Proof))
 }
diff --git a/kernel-laws/shared/src/test/scala/cats/kernel/laws/LawTests.scala b/kernel-laws/shared/src/test/scala/cats/kernel/laws/LawTests.scala
index 308765f45..58deb20de 100644
--- a/kernel-laws/shared/src/test/scala/cats/kernel/laws/LawTests.scala
+++ b/kernel-laws/shared/src/test/scala/cats/kernel/laws/LawTests.scala
@@ -212,20 +212,19 @@ class Tests extends TestsConfig with DisciplineSuite {
   checkAll("Order.reverse(Order.reverse(Order[Int]))", OrderTests(Order.reverse(Order.reverse(Order[Int]))).order)
   checkAll("Order.fromLessThan[Int](_ < _)", OrderTests(Order.fromLessThan[Int](_ < _)).order)
 
-  checkAll("LowerBounded[Byte]", LowerBoundedTests[Byte].lowerBounded)
   checkAll("LowerBounded[Duration]", LowerBoundedTests[Duration].lowerBounded)
   checkAll("LowerBounded[FiniteDuration]", LowerBoundedTests[FiniteDuration].lowerBounded)
   checkAll("LowerBounded[UUID]", LowerBoundedTests[UUID].lowerBounded)
   checkAll("LowerBounded[String]", LowerBoundedTests[String].lowerBounded)
   checkAll("LowerBounded[Symbol]", LowerBoundedTests[Symbol].lowerBounded)
 
-  checkAll("UpperBounded[Byte]", UpperBoundedTests[Byte].upperBounded)
   checkAll("UpperBounded[Duration]", UpperBoundedTests[Duration].upperBounded)
   checkAll("UpperBounded[FiniteDuration]", UpperBoundedTests[FiniteDuration].upperBounded)
   checkAll("UpperBounded[UUID]", UpperBoundedTests[UUID].upperBounded)
 
   checkAll("BoundedEnumerable[Unit]", BoundedEnumerableTests[Unit].boundedEnumerable)
   checkAll("BoundedEnumerable[Boolean]", BoundedEnumerableTests[Boolean].boundedEnumerable)
+  checkAll("BoundedEnumerable[Byte]", BoundedEnumerableTests[Byte].boundedEnumerable)
   checkAll("BoundedEnumerable[Short]", BoundedEnumerableTests[Short].boundedEnumerable)
   checkAll("BoundedEnumerable[Int]", BoundedEnumerableTests[Int].boundedEnumerable)
   checkAll("BoundedEnumerable[Char]", BoundedEnumerableTests[Char].boundedEnumerable)
@@ -390,6 +389,8 @@ class Tests extends TestsConfig with DisciplineSuite {
 
   checkAll("Eq[Comparison]", EqTests[Comparison].eqv)
 
+  checkAll("Monoid[Comparison]", MonoidTests[Comparison].monoid)
+
   test("comparison") {
     val order = Order[Int]
     val eqv = Eq[Comparison]
diff --git a/kernel/src/main/scala/cats/kernel/Comparison.scala b/kernel/src/main/scala/cats/kernel/Comparison.scala
index 0d08af974..bd1a74665 100644
--- a/kernel/src/main/scala/cats/kernel/Comparison.scala
+++ b/kernel/src/main/scala/cats/kernel/Comparison.scala
@@ -26,5 +26,14 @@ object Comparison {
     else if (double == 0.0) SomeEq
     else SomeLt
 
-  implicit val catsKernelEqForComparison: Eq[Comparison] = Eq.fromUniversalEquals
+  implicit val catsKernelEqForComparison: Eq[Comparison] with Monoid[Comparison] =
+    new Eq[Comparison] with Monoid[Comparison] {
+      def eqv(x: Comparison, y: Comparison): Boolean = x == y
+      def empty: Comparison = EqualTo
+
+      def combine(x: Comparison, y: Comparison): Comparison = x match {
+        case EqualTo => y
+        case comp    => comp
+      }
+    }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Enumerable.scala b/kernel/src/main/scala/cats/kernel/Enumerable.scala
index 76f94d54b..96753108e 100644
--- a/kernel/src/main/scala/cats/kernel/Enumerable.scala
+++ b/kernel/src/main/scala/cats/kernel/Enumerable.scala
@@ -67,6 +67,8 @@ object BoundedEnumerable {
     cats.kernel.instances.unit.catsKernelStdOrderForUnit
   implicit def catsKernelBoundedEnumerableForBoolean: BoundedEnumerable[Boolean] =
     cats.kernel.instances.boolean.catsKernelStdOrderForBoolean
+  implicit def catsKernelBoundedEnumerableForByte: BoundedEnumerable[Byte] =
+    cats.kernel.instances.byte.catsKernelStdOrderForByte
   implicit def catsKernelBoundedEnumerableForInt: BoundedEnumerable[Int] =
     cats.kernel.instances.int.catsKernelStdOrderForInt
   implicit def catsKernelBoundedEnumerableForShort: BoundedEnumerable[Short] =
diff --git a/kernel/src/main/scala/cats/kernel/instances/ByteInstances.scala b/kernel/src/main/scala/cats/kernel/instances/ByteInstances.scala
index f81b7813c..7ba66a1e7 100644
--- a/kernel/src/main/scala/cats/kernel/instances/ByteInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/ByteInstances.scala
@@ -2,7 +2,7 @@ package cats.kernel
 package instances
 
 trait ByteInstances {
-  implicit val catsKernelStdOrderForByte: Order[Byte] with Hash[Byte] with LowerBounded[Byte] with UpperBounded[Byte] =
+  implicit val catsKernelStdOrderForByte: Order[Byte] with Hash[Byte] with BoundedEnumerable[Byte] =
     new ByteOrder
   implicit val catsKernelStdGroupForByte: CommutativeGroup[Byte] = new ByteGroup
 }
@@ -14,12 +14,19 @@ class ByteGroup extends CommutativeGroup[Byte] {
   override def remove(x: Byte, y: Byte): Byte = (x - y).toByte
 }
 
+trait ByteEnumerable extends BoundedEnumerable[Byte] {
+  override def partialNext(a: Byte): Option[Byte] =
+    if (order.eqv(a, maxBound)) None else Some((a + 1).toByte)
+  override def partialPrevious(a: Byte): Option[Byte] =
+    if (order.eqv(a, minBound)) None else Some((a - 1).toByte)
+}
+
 trait ByteBounded extends LowerBounded[Byte] with UpperBounded[Byte] {
   override def minBound: Byte = Byte.MinValue
   override def maxBound: Byte = Byte.MaxValue
 }
 
-class ByteOrder extends Order[Byte] with Hash[Byte] with ByteBounded { self =>
+class ByteOrder extends Order[Byte] with Hash[Byte] with ByteBounded with ByteEnumerable { self =>
 
   def hash(x: Byte): Int = x.hashCode()
 
@@ -38,5 +45,5 @@ class ByteOrder extends Order[Byte] with Hash[Byte] with ByteBounded { self =>
   override def max(x: Byte, y: Byte): Byte =
     java.lang.Math.max(x.toInt, y.toInt).toByte
 
-  override val partialOrder: PartialOrder[Byte] = self
+  override val order: Order[Byte] = self
 }
diff --git a/native/src/test/scala/cats/native/tests/FutureSuite.scala b/native/src/test/scala/cats/native/tests/FutureSuite.scala
deleted file mode 100644
index 3536b7a7a..000000000
--- a/native/src/test/scala/cats/native/tests/FutureSuite.scala
+++ /dev/null
@@ -1,65 +0,0 @@
-package cats.native.tests
-
-import cats.kernel.laws.discipline.{MonoidTests => MonoidLawTests, SemigroupTests => SemigroupLawTests}
-import cats.kernel.{Eq, Semigroup}
-import cats.laws.discipline._
-import cats.laws.discipline.arbitrary._
-import cats.syntax.either._
-import cats.tests.{CatsSuite, ListWrapper}
-import org.scalacheck.Arbitrary.arbitrary
-import org.scalacheck.rng.Seed
-import org.scalacheck.{Arbitrary, Cogen}
-
-import scala.concurrent.{Await, ExecutionContextExecutor, Future}
-import scala.concurrent.duration._
-
-class FutureSuite extends CatsSuite {
-  val timeout = 3.seconds
-
-  // TODO: We shouldn't do this! See: https://github.com/scala-js/scala-js/issues/2102
-  implicit private object SynchronousExecutor extends ExecutionContextExecutor {
-    def execute(runnable: Runnable): Unit =
-      try {
-        runnable.run()
-      } catch {
-        case t: Throwable => reportFailure(t)
-      }
-
-    def reportFailure(t: Throwable): Unit =
-      t.printStackTrace()
-  }
-
-  def futureEither[A](f: Future[A]): Future[Either[Throwable, A]] =
-    f.map(Either.right[Throwable, A]).recover { case t => Either.left(t) }
-
-  implicit def eqfa[A: Eq]: Eq[Future[A]] =
-    new Eq[Future[A]] {
-      def eqv(fx: Future[A], fy: Future[A]): Boolean = {
-        val fz = futureEither(fx).zip(futureEither(fy))
-        Await.result(fz.map { case (tx, ty) => tx === ty }, timeout)
-      }
-    }
-
-  implicit def cogen[A: Cogen]: Cogen[Future[A]] =
-    Cogen[Future[A]] { (seed: Seed, t: Future[A]) =>
-      Cogen[A].perturb(seed, Await.result(t, timeout))
-    }
-
-  implicit val throwableEq: Eq[Throwable] =
-    Eq.by[Throwable, String](_.toString)
-
-  // Need non-fatal Throwables for Future recoverWith/handleError
-  implicit val nonFatalArbitrary: Arbitrary[Throwable] =
-    Arbitrary(arbitrary[Exception].map(identity))
-
-  checkAll("Future with Throwable", MonadErrorTests[Future, Throwable].monadError[Int, Int, Int])
-  checkAll("Future", MonadTests[Future].monad[Int, Int, Int])
-  checkAll("Future", CoflatMapTests[Future].coflatMap[Int, Int, Int])
-
-  {
-    implicit val F: Semigroup[ListWrapper[Int]] = ListWrapper.semigroup[Int]
-    checkAll("Future[ListWrapper[Int]]", SemigroupLawTests[Future[ListWrapper[Int]]].semigroup)
-  }
-
-  checkAll("Future[Int]", MonoidLawTests[Future[Int]].monoid)
-}
diff --git a/project/plugins.sbt b/project/plugins.sbt
index 3035dd84d..c4ff5a0af 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -11,9 +11,7 @@ addSbtPlugin("org.xerial.sbt" % "sbt-sonatype" % "3.9.5")
 addSbtPlugin("com.47deg" % "sbt-microsites" % "1.3.1")
 addSbtPlugin("org.scalameta" % "sbt-mdoc" % "2.2.16")
 addSbtPlugin("org.portable-scala" % "sbt-scalajs-crossproject" % "1.0.0")
-addSbtPlugin("org.portable-scala" % "sbt-scala-native-crossproject" % "1.0.0")
 addSbtPlugin("org.scala-js" % "sbt-scalajs" % "1.4.0")
-addSbtPlugin("org.scala-native" % "sbt-scala-native" % "0.4.0")
 addSbtPlugin("org.scalameta" % "sbt-scalafmt" % "2.4.2")
 addSbtPlugin("com.eed3si9n" % "sbt-buildinfo" % "0.10.0")
 addSbtPlugin("com.codecommit" % "sbt-github-actions" % "0.10.1")
diff --git a/tests/src/test/scala/cats/tests/ContTSuite.scala b/tests/src/test/scala/cats/tests/ContTSuite.scala
index 873648ddf..e86c85cc4 100644
--- a/tests/src/test/scala/cats/tests/ContTSuite.scala
+++ b/tests/src/test/scala/cats/tests/ContTSuite.scala
@@ -1,12 +1,14 @@
 package cats.tests
 
+import java.util.concurrent.atomic.AtomicInteger
+
 import cats.Eval
 import cats.data.ContT
 import cats.kernel.Eq
 import cats.laws.discipline._
 import cats.laws.discipline.arbitrary._
 import org.scalacheck.{Arbitrary, Gen}
-import cats.syntax.eq._
+import cats.syntax.all._
 import org.scalacheck.Prop._
 
 class ContTSuite extends CatsSuite {
@@ -86,4 +88,72 @@ class ContTSuite extends CatsSuite {
     }
   }
 
+  test("ContT.flatMap stack safety") {
+    val maxIters = 20000
+    var counter = 0
+
+    def contT: ContT[Eval, Int, Int] =
+      ContT
+        .defer[Eval, Int, Int] {
+          counter = counter + 1
+          counter
+        }
+        .flatMap { n =>
+          if (n === maxIters) ContT.pure[Eval, Int, Int](n) else contT
+        }
+
+    assert(contT.run(Eval.now(_)).value === maxIters)
+  }
+
+  test("ContT.callCC short-circuits and invokes the continuation") {
+    forAll { (cb: Unit => Eval[Int]) =>
+      var shouldNotChange = false
+      var shouldChange = false
+      var shouldAlsoChange = false
+
+      val contT: ContT[Eval, Int, Unit] = for {
+        _ <- ContT.callCC((k: Unit => ContT[Eval, Int, Unit]) =>
+          ContT.defer[Eval, Int, Unit] {
+            shouldChange = true
+          } >>
+            k(()) >>
+            ContT.defer[Eval, Int, Unit] {
+              shouldNotChange = true
+            }
+        )
+        _ <- ContT.defer[Eval, Int, Unit] {
+          shouldAlsoChange = true
+        }
+      } yield ()
+
+      contT.run(cb).value
+
+      assert(shouldNotChange === false)
+      assert(shouldChange === true)
+      assert(shouldAlsoChange === true)
+    }
+  }
+
+  test("ContT.callCC stack-safety") {
+
+    val counter = new AtomicInteger(0)
+    val maxIters = 10000
+
+    def contT: ContT[Eval, Unit, Int] = ContT
+      .callCC { (k: Int => ContT[Eval, Unit, Int]) =>
+        ContT
+          .defer[Eval, Unit, Int] {
+            counter.incrementAndGet()
+          }
+          .flatMap { n =>
+            if (n === maxIters) ContT.pure[Eval, Unit, Int](n) else contT
+          }
+      }
+      .flatMap { n =>
+        ContT.pure[Eval, Unit, Int](n)
+      }
+
+    contT.run(_ => Eval.now(())).value
+  }
+
 }
