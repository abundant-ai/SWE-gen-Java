diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index ecd95cbc..76e05315 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -429,6 +429,7 @@ public abstract class JsonReader implements Closeable {
    *
    * @throws JsonDataException if the next token is not a literal value, if a JSON object has a
    * duplicate key.
+   * @see JsonWriter#jsonValue(Object)
    */
   public final @Nullable Object readJsonValue() throws IOException {
     switch (peek()) {
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index f5d49786..af390204 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -19,6 +19,8 @@ import java.io.Closeable;
 import java.io.Flushable;
 import java.io.IOException;
 import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
 import javax.annotation.CheckReturnValue;
 import javax.annotation.Nullable;
 import okio.BufferedSink;
@@ -386,6 +388,58 @@ public abstract class JsonWriter implements Closeable, Flushable {
   @CheckReturnValue
   public abstract BufferedSink valueSink() throws IOException;
 
+  /**
+   * Encodes the value which may be a string, number, boolean, null, map, or list.
+   *
+   * @return this writer.
+   * @see JsonReader#readJsonValue()
+   */
+  public final JsonWriter jsonValue(@Nullable Object value) throws IOException {
+    if (value instanceof Map<?, ?>) {
+      beginObject();
+      for (Map.Entry<?, ?> entry : ((Map<?, ?>) value).entrySet()) {
+        Object key = entry.getKey();
+        if (!(key instanceof String)) {
+          throw new IllegalArgumentException(key == null
+              ? "Map keys must be non-null"
+              : "Map keys must be of type String: " + key.getClass().getName());
+        }
+        name(((String) key));
+        jsonValue(entry.getValue());
+      }
+      endObject();
+
+    } else if (value instanceof List<?>) {
+      beginArray();
+      for (Object element : ((List<?>) value)) {
+        jsonValue(element);
+      }
+      endArray();
+
+    } else if (value instanceof String) {
+      value(((String) value));
+
+    } else if (value instanceof Boolean) {
+      value(((Boolean) value).booleanValue());
+
+    } else if (value instanceof Double) {
+      value(((Double) value).doubleValue());
+
+    } else if (value instanceof Long) {
+      value(((Long) value).longValue());
+
+    } else if (value instanceof Number) {
+      value(((Number) value));
+
+    } else if (value == null) {
+      nullValue();
+
+    } else {
+      throw new IllegalArgumentException("Unsupported type: " + value.getClass().getName());
+    }
+    return this;
+  }
+
   /**
    * Changes the writer to treat the next value as a string name. This is useful for map adapters so
    * that arbitrary type adapters can use {@link #value} to write a name value.
