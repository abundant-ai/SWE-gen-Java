diff --git a/CHANGELOG.md b/CHANGELOG.md
index 23c38c3d3..e2029af44 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -29,6 +29,7 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 - Fix incorrect bug counts and sizes when unioning reports ([#3721](https://github.com/spotbugs/spotbugs/issues/3721))
 - Enhanced SARIF output with full description sections - adding markdown is still an open issue ([#2339](https://github.com/spotbugs/spotbugs/issues/2339))
 - Added missing null check to `MultipleInstantiationsOfSingletons` detector ([#3823](https://github.com/spotbugs/spotbugs/issues/3823))
+- Fix `CT_CONSTRUCTOR_THROW` FP with public and private constructors ([#3822](https://github.com/spotbugs/spotbugs/issues/3822))
 - Fix tool name in usage info, ([#3847](https://github.com/spotbugs/spotbugs/pull/3847))
 - Fix the building of relative chains of ./././ in filenames in fbp files ([#3852](https://github.com/spotbugs/spotbugs/pull/3852))
 - Do not report `DM_DEFAULT_ENCODING` for classes compiled with target >= 18 ([#3866](https://github.com/spotbugs/spotbugs/pull/3866))
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ConstructorThrow.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ConstructorThrow.java
index 5ca88a672..c721bc63d 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ConstructorThrow.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ConstructorThrow.java
@@ -23,6 +23,7 @@ import java.util.stream.Collectors;
 import edu.umd.cs.findbugs.OpcodeStack;
 import edu.umd.cs.findbugs.annotations.NonNull;
 import edu.umd.cs.findbugs.ba.AnalysisContext;
+import edu.umd.cs.findbugs.ba.Hierarchy;
 import edu.umd.cs.findbugs.ba.XMethod;
 import edu.umd.cs.findbugs.internalAnnotations.DottedClassName;
 import edu.umd.cs.findbugs.util.ClassName;
@@ -161,7 +162,13 @@ public class ConstructorThrow extends OpcodeStackDetector {
             }
         } else if (isMethodCall()) {
             if (Const.CONSTRUCTOR_NAME.equals(getNameConstantOperand())) {
-                hadObjectConstructor = true;
+                try {
+                    if (Hierarchy.isSubtype(getDottedClassName(), ClassName.toDottedClassName(getClassConstantOperand()))) {
+                        hadObjectConstructor = true;
+                    }
+                } catch (ClassNotFoundException e) {
+                    AnalysisContext.reportMissingClass(e);
+                }
             }
 
             String calledMethodFQN = getCalledMethodFQN();
diff --git a/spotbugsTestCases/src/java/constructorthrow/ConstructorThrowNegativeTest21.java b/spotbugsTestCases/src/java/constructorthrow/ConstructorThrowNegativeTest21.java
new file mode 100644
index 000000000..72e846a21
--- /dev/null
+++ b/spotbugsTestCases/src/java/constructorthrow/ConstructorThrowNegativeTest21.java
@@ -0,0 +1,22 @@
+package constructorthrow;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+/**
+ * The Exception is thrown before the java.lang.Object constructor exits, so this is compliant, since in this case
+ * the JVM will not execute an object's finalizer.
+ * @see <a href="https://github.com/spotbugs/spotbugs/issues/3822">GitHub issue</a>
+ */
+public class ConstructorThrowNegativeTest21 {
+    public ConstructorThrowNegativeTest21(Collection<?> foo) {
+        this(new ArrayList<>(foo), bar());
+    }
+
+    private ConstructorThrowNegativeTest21(Collection<?> foo, Object bar) {
+    }
+
+    private static Object bar() throws RuntimeException {
+        return null;
+    }
+}
diff --git a/spotbugsTestCases/src/java/constructorthrow/ConstructorThrowNegativeTest22.java b/spotbugsTestCases/src/java/constructorthrow/ConstructorThrowNegativeTest22.java
new file mode 100644
index 000000000..76315229b
--- /dev/null
+++ b/spotbugsTestCases/src/java/constructorthrow/ConstructorThrowNegativeTest22.java
@@ -0,0 +1,36 @@
+package constructorthrow;
+
+import java.io.IOException;
+
+/**
+ * The Exception is thrown before the java.lang.Object constructor exits, so this is compliant, since in this case
+ * the JVM will not execute an object's finalizer.
+ */
+public class ConstructorThrowNegativeTest22 extends SuperConstructorThrowNegativeTest22 {
+    protected static boolean verify() throws IOException {
+        // Returns true if data entered is valid, else throws an Exception
+        // Assume that the attacker just enters invalid data, so this method always throws the exception
+        throw new IOException("Still invalid data!");
+    }
+
+    public ConstructorThrowNegativeTest22() throws IOException {
+        super();
+    }
+}
+
+class SuperConstructorThrowNegativeTest22 {
+    protected static boolean verify() throws IOException {
+        // Returns true if data entered is valid, else throws an Exception
+        // Assume that the attacker just enters invalid data, so this method always throws the exception
+        throw new IOException("Invalid data!");
+    }
+
+    public SuperConstructorThrowNegativeTest22() throws IOException {
+        this(verify());
+    }
+
+    private SuperConstructorThrowNegativeTest22(boolean secure) {
+        // secure is always true
+        // Constructor without any checks
+    }
+}
