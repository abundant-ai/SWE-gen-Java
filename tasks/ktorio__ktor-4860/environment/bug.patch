diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
index 4d3c825ac..692fc6b60 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
@@ -1,7 +1,6 @@
 public final class io/ktor/server/plugins/di/AmbiguousCreateFunction : io/ktor/server/plugins/di/DependencyCreateFunction {
 	public static final field Companion Lio/ktor/server/plugins/di/AmbiguousCreateFunction$Companion;
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;)V
-	public final fun clarify (Lkotlin/jvm/functions/Function1;)Lio/ktor/server/plugins/di/DependencyCreateFunction;
 	public final fun component1 ()Lio/ktor/server/plugins/di/DependencyKey;
 	public final fun component2 ()Ljava/util/Set;
 	public final fun copy (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;)Lio/ktor/server/plugins/di/AmbiguousCreateFunction;
@@ -9,10 +8,8 @@ public final class io/ktor/server/plugins/di/AmbiguousCreateFunction : io/ktor/s
 	public fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
 	public fun equals (Ljava/lang/Object;)Z
 	public final fun getFunctions ()Ljava/util/Set;
-	public final fun getImplementations ()Ljava/util/List;
 	public fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
 	public fun hashCode ()I
-	public final fun keyString ()Ljava/lang/String;
 	public fun toString ()Ljava/lang/String;
 }
 
@@ -21,8 +18,7 @@ public final class io/ktor/server/plugins/di/AmbiguousCreateFunction$Companion {
 }
 
 public final class io/ktor/server/plugins/di/AmbiguousDependencyException : io/ktor/server/plugins/di/DependencyInjectionException {
-	public fun <init> (Lio/ktor/server/plugins/di/AmbiguousCreateFunction;)V
-	public final fun getFunction ()Lio/ktor/server/plugins/di/AmbiguousCreateFunction;
+	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Collection;)V
 }
 
 public final class io/ktor/server/plugins/di/CircularDependencyException : io/ktor/server/plugins/di/DependencyInjectionException {
@@ -45,7 +41,7 @@ public abstract interface class io/ktor/server/plugins/di/DependencyConflictPoli
 
 public final class io/ktor/server/plugins/di/DependencyConflictPolicyKt {
 	public static final fun getDefaultConflictPolicy ()Lio/ktor/server/plugins/di/DependencyConflictPolicy;
-	public static final fun getIgnoreConflicts ()Lio/ktor/server/plugins/di/DependencyConflictPolicy;
+	public static final fun getLastEntryWinsPolicy ()Lio/ktor/server/plugins/di/DependencyConflictPolicy;
 }
 
 public abstract interface class io/ktor/server/plugins/di/DependencyConflictResult {
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
index 22b13803f..202154fdb 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
@@ -119,19 +119,15 @@ final class io.ktor.server.plugins.di/AmbiguousCreateFunction : io.ktor.server.p
 
     final val functions // io.ktor.server.plugins.di/AmbiguousCreateFunction.functions|{}functions[0]
         final fun <get-functions>(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/AmbiguousCreateFunction.functions.<get-functions>|<get-functions>(){}[0]
-    final val implementations // io.ktor.server.plugins.di/AmbiguousCreateFunction.implementations|{}implementations[0]
-        final fun <get-implementations>(): kotlin.collections/List<io.ktor.server.plugins.di/DependencyKey> // io.ktor.server.plugins.di/AmbiguousCreateFunction.implementations.<get-implementations>|<get-implementations>(){}[0]
     final val key // io.ktor.server.plugins.di/AmbiguousCreateFunction.key|{}key[0]
         final fun <get-key>(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/AmbiguousCreateFunction.key.<get-key>|<get-key>(){}[0]
 
-    final fun clarify(kotlin/Function1<io.ktor.server.plugins.di/DependencyKey, kotlin/Boolean>): io.ktor.server.plugins.di/DependencyCreateFunction? // io.ktor.server.plugins.di/AmbiguousCreateFunction.clarify|clarify(kotlin.Function1<io.ktor.server.plugins.di.DependencyKey,kotlin.Boolean>){}[0]
     final fun component1(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/AmbiguousCreateFunction.component1|component1(){}[0]
     final fun component2(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/AmbiguousCreateFunction.component2|component2(){}[0]
     final fun copy(io.ktor.server.plugins.di/DependencyKey = ..., kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> = ...): io.ktor.server.plugins.di/AmbiguousCreateFunction // io.ktor.server.plugins.di/AmbiguousCreateFunction.copy|copy(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyCreateFunction>){}[0]
     final fun create(io.ktor.server.plugins.di/DependencyResolver): kotlin/Any // io.ktor.server.plugins.di/AmbiguousCreateFunction.create|create(io.ktor.server.plugins.di.DependencyResolver){}[0]
     final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.server.plugins.di/AmbiguousCreateFunction.equals|equals(kotlin.Any?){}[0]
     final fun hashCode(): kotlin/Int // io.ktor.server.plugins.di/AmbiguousCreateFunction.hashCode|hashCode(){}[0]
-    final fun keyString(): kotlin/String // io.ktor.server.plugins.di/AmbiguousCreateFunction.keyString|keyString(){}[0]
     final fun toString(): kotlin/String // io.ktor.server.plugins.di/AmbiguousCreateFunction.toString|toString(){}[0]
 
     final object Companion { // io.ktor.server.plugins.di/AmbiguousCreateFunction.Companion|null[0]
@@ -140,10 +136,7 @@ final class io.ktor.server.plugins.di/AmbiguousCreateFunction : io.ktor.server.p
 }
 
 final class io.ktor.server.plugins.di/AmbiguousDependencyException : io.ktor.server.plugins.di/DependencyInjectionException { // io.ktor.server.plugins.di/AmbiguousDependencyException|null[0]
-    constructor <init>(io.ktor.server.plugins.di/AmbiguousCreateFunction) // io.ktor.server.plugins.di/AmbiguousDependencyException.<init>|<init>(io.ktor.server.plugins.di.AmbiguousCreateFunction){}[0]
-
-    final val function // io.ktor.server.plugins.di/AmbiguousDependencyException.function|{}function[0]
-        final fun <get-function>(): io.ktor.server.plugins.di/AmbiguousCreateFunction // io.ktor.server.plugins.di/AmbiguousDependencyException.function.<get-function>|<get-function>(){}[0]
+    constructor <init>(io.ktor.server.plugins.di/DependencyKey, kotlin.collections/Collection<io.ktor.server.plugins.di/DependencyKey>) // io.ktor.server.plugins.di/AmbiguousDependencyException.<init>|<init>(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Collection<io.ktor.server.plugins.di.DependencyKey>){}[0]
 }
 
 final class io.ktor.server.plugins.di/CircularDependencyException : io.ktor.server.plugins.di/DependencyInjectionException { // io.ktor.server.plugins.di/CircularDependencyException|null[0]
@@ -377,8 +370,8 @@ final val io.ktor.server.plugins.di/DefaultReflection // io.ktor.server.plugins.
     final fun <get-DefaultReflection>(): io.ktor.server.plugins.di/DependencyReflection // io.ktor.server.plugins.di/DefaultReflection.<get-DefaultReflection>|<get-DefaultReflection>(){}[0]
 final val io.ktor.server.plugins.di/DependencyRegistryKey // io.ktor.server.plugins.di/DependencyRegistryKey|{}DependencyRegistryKey[0]
     final fun <get-DependencyRegistryKey>(): io.ktor.util/AttributeKey<io.ktor.server.plugins.di/DependencyRegistry> // io.ktor.server.plugins.di/DependencyRegistryKey.<get-DependencyRegistryKey>|<get-DependencyRegistryKey>(){}[0]
-final val io.ktor.server.plugins.di/IgnoreConflicts // io.ktor.server.plugins.di/IgnoreConflicts|{}IgnoreConflicts[0]
-    final fun <get-IgnoreConflicts>(): io.ktor.server.plugins.di/DependencyConflictPolicy // io.ktor.server.plugins.di/IgnoreConflicts.<get-IgnoreConflicts>|<get-IgnoreConflicts>(){}[0]
+final val io.ktor.server.plugins.di/LastEntryWinsPolicy // io.ktor.server.plugins.di/LastEntryWinsPolicy|{}LastEntryWinsPolicy[0]
+    final fun <get-LastEntryWinsPolicy>(): io.ktor.server.plugins.di/DependencyConflictPolicy // io.ktor.server.plugins.di/LastEntryWinsPolicy.<get-LastEntryWinsPolicy>|<get-LastEntryWinsPolicy>(){}[0]
 final val io.ktor.server.plugins.di/Nullables // io.ktor.server.plugins.di/Nullables|{}Nullables[0]
     final fun <get-Nullables>(): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/Nullables.<get-Nullables>|<get-Nullables>(){}[0]
 final val io.ktor.server.plugins.di/OutTypeArgumentsSupertypes // io.ktor.server.plugins.di/OutTypeArgumentsSupertypes|{}OutTypeArgumentsSupertypes[0]
@@ -403,21 +396,7 @@ final fun <#A: kotlin/Any?> (io.ktor.server.application/Application).io.ktor.ser
 final fun <#A: kotlin/Any?> (io.ktor.server.plugins.di/DependencyCreateFunction).io.ktor.server.plugins.di/ifImplicit(kotlin/Function1<io.ktor.server.plugins.di/ImplicitCreateFunction, #A>): #A? // io.ktor.server.plugins.di/ifImplicit|ifImplicit@io.ktor.server.plugins.di.DependencyCreateFunction(kotlin.Function1<io.ktor.server.plugins.di.ImplicitCreateFunction,0:0>){0§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/create(): #A // io.ktor.server.plugins.di/create|create@io.ktor.server.plugins.di.DependencyResolver(){0§<kotlin.Any>}[0]
 final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/create(kotlin.reflect/KClass<out #A>): #A // io.ktor.server.plugins.di/create|create@io.ktor.server.plugins.di.DependencyResolver(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?, #F: reified kotlin/Any?, #G: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function6<#B, #C, #D, #E, #F, #G, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function6<0:1,0:2,0:3,0:4,0:5,0:6,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>;6§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?, #F: reified kotlin/Any?, #G: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction6<#B, #C, #D, #E, #F, #G, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction6<0:1,0:2,0:3,0:4,0:5,0:6,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>;6§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?, #F: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function5<#B, #C, #D, #E, #F, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function5<0:1,0:2,0:3,0:4,0:5,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?, #F: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction5<#B, #C, #D, #E, #F, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction5<0:1,0:2,0:3,0:4,0:5,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function4<#B, #C, #D, #E, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function4<0:1,0:2,0:3,0:4,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction4<#B, #C, #D, #E, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction4<0:1,0:2,0:3,0:4,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function3<#B, #C, #D, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function3<0:1,0:2,0:3,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction3<#B, #C, #D, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction3<0:1,0:2,0:3,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function2<#B, #C, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function2<0:1,0:2,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction2<#B, #C, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction2<0:1,0:2,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function1<#B, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function1<0:1,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction1<#B, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction1<0:1,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/resolve(kotlin/String? = ...): #A // io.ktor.server.plugins.di/resolve|resolve@io.ktor.server.plugins.di.DependencyMap(kotlin.String?){0§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/provide(kotlin/String? = ..., noinline kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A?>) // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.String?;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0?>){0§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function0<#A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function0<0:0>){0§<kotlin.Any?>}[0]
-final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction0<#A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction0<0:0>){0§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any?> io.ktor.server.plugins.di/DependencyKey(kotlin/String? = ..., kotlin/Any? = ...): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/DependencyKey|DependencyKey(kotlin.String?;kotlin.Any?){0§<kotlin.Any?>}[0]
 final suspend inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/resolveAwait(kotlin/String? = ...): #A // io.ktor.server.plugins.di/resolveAwait|resolveAwait@io.ktor.server.plugins.di.DependencyMap(kotlin.String?){0§<kotlin.Any?>}[0]
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyConflictPolicy.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyConflictPolicy.kt
index af5039cfd..1c0bbfbeb 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyConflictPolicy.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyConflictPolicy.kt
@@ -72,13 +72,15 @@ public val DefaultConflictPolicy: DependencyConflictPolicy = DependencyConflictP
 }
 
 /**
- * During testing, we ignore conflicts.
+ * During testing, we simply override previously declared values.
  * This allows for replacing base implementations with mock values.
  */
-public val IgnoreConflicts: DependencyConflictPolicy = DependencyConflictPolicy { prev, current ->
-    when (val result = DefaultConflictPolicy.resolve(prev, current)) {
-        is Conflict -> KeepPrevious
-        else -> result
+public val LastEntryWinsPolicy: DependencyConflictPolicy = DependencyConflictPolicy { prev, current ->
+    require(current !is AmbiguousCreateFunction) { "Unexpected ambiguous function supplied" }
+    when (prev) {
+        is AmbiguousCreateFunction,
+        is ImplicitCreateFunction -> KeepNew
+        is ExplicitCreateFunction -> current.ifImplicit { KeepPrevious } ?: KeepNew
     }
 }
 
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
index a8081531e..c96b16b6f 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
@@ -62,7 +62,7 @@ public val DI: ApplicationPlugin<DependencyInjectionConfig> =
                 .orEmpty()
 
         val provider = if (isTestEngine() && !pluginConfig.providerChanged) {
-            MapDependencyProvider(conflictPolicy = IgnoreConflicts)
+            MapDependencyProvider(conflictPolicy = LastEntryWinsPolicy)
         } else {
             pluginConfig.provider
         }
@@ -117,7 +117,7 @@ public val DI: ApplicationPlugin<DependencyInjectionConfig> =
                         registry.shutdownHooks[key]?.invoke(instance)
                         onShutdown(key, instance)
                     } catch (e: Throwable) {
-                        environment.log.warn("Exception during cleanup for $key; continuing", e)
+                        environment.log.error("Exception during cleanup for $key; continuing", e)
                     }
                 }
                 registry.cancel()
@@ -132,7 +132,7 @@ private fun formatError(e: Throwable): String =
         is MissingDependencyException -> "Missing declaration"
         is CircularDependencyException -> "Circular dependency: ${e.keys.joinToString(" -> ")}"
         is DuplicateDependencyException -> "Conflicting declaration"
-        is AmbiguousDependencyException -> "Ambiguous dependency for ${e.function.keyString()}"
+        is AmbiguousDependencyException -> "Ambiguous dependency: ${e.keys.joinToString(", ")}"
         else -> e.message ?: ("Unknown error" + e.stackTraceToString().let { "\n$it" })
     }
 
@@ -302,11 +302,8 @@ public class DuplicateDependencyException(key: DependencyKey) :
 /**
  * Thrown when there are two or more implicit dependencies that match the given key.
  */
-public class AmbiguousDependencyException(
-    public val function: AmbiguousCreateFunction
-) : DependencyInjectionException(
-    "Cannot decide which value for ${function.key}: ${function.implementations}"
-)
+public class AmbiguousDependencyException(key: DependencyKey, internal val keys: Collection<DependencyKey>) :
+    DependencyInjectionException("Cannot decide which value for $key. Possible implementations: $keys")
 
 /**
  * Thrown when resolving a given dependency loops back on itself.
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
index 67641a959..c9a781e77 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
@@ -153,21 +153,12 @@ public data class AmbiguousCreateFunction(
             return functions.singleOrNull() ?: AmbiguousCreateFunction(key, functions)
         }
     }
-
     init {
         require(functions.size > 1) { "More than one function must be provided" }
     }
 
-    public fun clarify(predicate: (DependencyKey) -> Boolean): DependencyCreateFunction? =
-        functions.singleOrNull { predicate(it.key) }
-
-    public val implementations: List<DependencyKey> get() = functions.map { it.key }
-
     override fun create(resolver: DependencyResolver): Any =
-        throw AmbiguousDependencyException(this)
-
-    public fun keyString(): String =
-        "$key: ${implementations.joinToString()}"
+        throw AmbiguousDependencyException(key, functions.map { it.key })
 }
 
 /**
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProviderLambdaOverloads.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProviderLambdaOverloads.kt
deleted file mode 100644
index 4b418f7f6..000000000
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProviderLambdaOverloads.kt
+++ /dev/null
@@ -1,220 +0,0 @@
-/*
- * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
- */
-
-@file:Suppress("ktlint:standard:max-line-length")
-
-package io.ktor.server.plugins.di
-
-import io.ktor.utils.io.KtorDsl
-import kotlinx.coroutines.Deferred
-
-/**
- * Registers a dependency provider that takes no parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param function A function that creates and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E> DependencyRegistry.provide(
-    crossinline function: () -> E
-): DependencyRegistry.KeyContext<E> = provide {
-    function()
-}
-
-/**
- * Registers a dependency provider that takes one input parameter and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param function A function that takes one parameter of type [I1] and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1> DependencyRegistry.provide(
-    crossinline function: (I1) -> E
-): DependencyRegistry.KeyContext<E> = provide { function(resolve()) }
-
-/**
- * Registers a dependency provider that takes two input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param function A function that takes two parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2> DependencyRegistry.provide(
-    crossinline function: (I1, I2) -> E
-): DependencyRegistry.KeyContext<E> = provide { function(resolve(), resolve()) }
-
-/**
- * Registers a dependency provider that takes three input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param I3 The type of the third input parameter
- * @param function A function that takes three parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3> DependencyRegistry.provide(
-    crossinline function: (I1, I2, I3) -> E
-): DependencyRegistry.KeyContext<E> = provide { function(resolve(), resolve(), resolve()) }
-
-/**
- * Registers a dependency provider that takes four input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param I3 The type of the third input parameter
- * @param I4 The type of the fourth input parameter
- * @param function A function that takes four parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4> DependencyRegistry.provide(
-    crossinline function: (I1, I2, I3, I4) -> E
-): DependencyRegistry.KeyContext<E> = provide { function(resolve(), resolve(), resolve(), resolve()) }
-
-/**
- * Registers a dependency provider that takes five input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param I3 The type of the third input parameter
- * @param I4 The type of the fourth input parameter
- * @param I5 The type of the fifth input parameter
- * @param function A function that takes five parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4, reified I5> DependencyRegistry.provide(
-    crossinline function: (I1, I2, I3, I4, I5) -> E
-): DependencyRegistry.KeyContext<E> = provide { function(resolve(), resolve(), resolve(), resolve(), resolve()) }
-
-/**
- * Registers a dependency provider that takes six input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param I3 The type of the third input parameter
- * @param I4 The type of the fourth input parameter
- * @param I5 The type of the fifth input parameter
- * @param I6 The type of the sixth input parameter
- * @param function A function that takes six parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4, reified I5, reified I6> DependencyRegistry.provide(
-    crossinline function: (I1, I2, I3, I4, I5, I6) -> E
-): DependencyRegistry.KeyContext<E> = provide {
-    function(resolve(), resolve(), resolve(), resolve(), resolve(), resolve())
-}
-
-/**
- * Registers a deferred dependency provider that takes no parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param function A function that creates and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E> DependencyRegistry.provideAsync(
-    crossinline function: suspend () -> E
-): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
-    function()
-}
-
-/**
- * Registers a deferred dependency provider that takes one input parameter and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param function A function that takes one parameter of type [I1] and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1> DependencyRegistry.provideAsync(
-    crossinline function: suspend (I1) -> E
-): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync { function(resolveAwait()) }
-
-/**
- * Registers a deferred dependency provider that takes two input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param function A function that takes two parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2> DependencyRegistry.provideAsync(
-    crossinline function: suspend (I1, I2) -> E
-): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync { function(resolveAwait(), resolveAwait()) }
-
-/**
- * Registers a deferred dependency provider that takes three input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param I3 The type of the third input parameter
- * @param function A function that takes three parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3> DependencyRegistry.provideAsync(
-    crossinline function: suspend (I1, I2, I3) -> E
-): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
-    function(resolveAwait(), resolveAwait(), resolveAwait())
-}
-
-/**
- * Registers a deferred dependency provider that takes four input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param I3 The type of the third input parameter
- * @param I4 The type of the fourth input parameter
- * @param function A function that takes four parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4> DependencyRegistry.provideAsync(
-    crossinline function: suspend (I1, I2, I3, I4) -> E
-): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
-    function(resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait())
-}
-
-/**
- * Registers a deferred dependency provider that takes five input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param I3 The type of the third input parameter
- * @param I4 The type of the fourth input parameter
- * @param I5 The type of the fifth input parameter
- * @param function A function that takes five parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4, reified I5> DependencyRegistry.provideAsync(
-    crossinline function: suspend (I1, I2, I3, I4, I5) -> E
-): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
-    function(resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait())
-}
-
-/**
- * Registers a deferred dependency provider that takes six input parameters and returns a value of type [E].
- *
- * @param E The type of dependency to be provided
- * @param I1 The type of the first input parameter
- * @param I2 The type of the second input parameter
- * @param I3 The type of the third input parameter
- * @param I4 The type of the fourth input parameter
- * @param I5 The type of the fifth input parameter
- * @param I6 The type of the sixth input parameter
- * @param function A function that takes six parameters and returns an instance of [E]
- * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
- */
-@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4, reified I5, reified I6> DependencyRegistry.provideAsync(
-    crossinline function: suspend (I1, I2, I3, I4, I5, I6) -> E
-): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
-    function(resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait())
-}
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
index 44e1476cf..bc51892a5 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
@@ -235,14 +235,7 @@ public class ProcessingDependencyResolver(
         resolved.contains(key) || provider.declarations.contains(key) || external.contains(key)
 
     override fun <T> get(key: DependencyKey): T =
-        try {
-            resolveKey(key).getOrThrow() as T
-        } catch (e: AmbiguousDependencyException) {
-            // During resolution, we can recover from ambiguous dependencies.
-            // This often occurs with delegates.
-            val fallback = e.function.clarify { it in resolved } ?: throw e
-            fallback.create(this) as T
-        }
+        resolveKey(key).getOrThrow() as T
 
     override fun <T> getOrPut(key: DependencyKey, defaultValue: () -> T): T =
         resolved.getOrPut(key) {
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
index e5e063416..c79c9c63b 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
@@ -178,14 +178,8 @@ public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
 /**
  * Resolve a `Deferred<T>` dependency and await its result.
  */
-public suspend inline fun <reified T> DependencyMap.resolveAwait(key: String? = null): T {
-    val syncKey = DependencyKey<T>()
-    return if (contains(syncKey)) {
-        resolve(key)
-    } else {
-        resolve<Deferred<T>>(key).await()
-    }
-}
+public suspend inline fun <reified T> DependencyMap.resolveAwait(key: String? = null): T =
+    resolve<Deferred<T>>(key).await()
 
 internal class MergedDependencyMap(
     private val left: DependencyMap,
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt
index 73d596a53..1f71d16af 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/test/io/ktor/server/plugins/di/DependencyInjectionTest.kt
@@ -184,10 +184,10 @@ class DependencyInjectionTest {
     }
 
     @Test
-    fun `first entry wins on conflicts when testing`() = testApplication {
+    fun `last entry wins for tests`() = testApplication {
         application {
-            dependencies { provide<GreetingService> { BankGreetingService() } }
             dependencies { provide<GreetingService> { GreetingServiceImpl() } }
+            dependencies { provide<GreetingService> { BankGreetingService() } }
 
             val service: GreetingService by dependencies
             assertEquals(HELLO_CUSTOMER, service.hello())
@@ -258,18 +258,6 @@ class DependencyInjectionTest {
         assertEquals(HELLO, service().hello())
     }
 
-    @Test
-    fun `function references`() = runTestDI {
-        dependencies {
-            provide<GreetingService>(::GreetingServiceImpl)
-            provide<BankService>(::BankServiceImpl)
-            provide(::BankTeller)
-        }
-
-        val service: BankTeller by dependencies
-        assertEquals(HELLO, service.hello())
-    }
-
     @Test
     fun parameterized() = runTestDI {
         dependencies {
@@ -399,57 +387,6 @@ class DependencyInjectionTest {
         assertEquals(listOf("bank", "greeting", "teller"), resolutions)
     }
 
-    @Test
-    fun `async lambda arguments`() = testApplication(Dispatchers.Unconfined) {
-        val greeter = GreetingServiceImpl()
-        val bank = BankServiceImpl()
-
-        val fetchGreetingService: suspend () -> GreetingService = {
-            delay(100)
-            greeter
-        }
-        val fetchBankService: suspend () -> BankService = {
-            delay(50)
-            bank
-        }
-
-        application {
-            dependencies {
-                provideAsync<GreetingService>(fetchGreetingService)
-                provideAsync<BankService>(fetchBankService)
-                provideAsync(::BankTeller)
-            }
-            val bankService: Deferred<BankService> by dependencies
-            routing {
-                get("/hello") {
-                    val service: GreetingService = dependencies.resolveAwait()
-                    call.respondText(service.hello())
-                }
-                get("/balance") {
-                    val service: BankService = bankService.await()
-                    call.respondText(service.balance().toString())
-                }
-                get("/bank-teller") {
-                    val service: BankTeller = dependencies.resolveAwait()
-                    call.respondText("${service.hello()}, your balance is ${service.balance()}")
-                }
-            }
-        }
-        val responses = Array<HttpResponse?>(3) { null }
-        coroutineScope {
-            listOf("/hello", "/balance", "/bank-teller").mapIndexed { index, url ->
-                launch {
-                    responses[index] = client.get(url)
-                }
-            }.joinAll()
-        }
-        val (helloResponse, balanceResponse, bankTellerResponse) = responses.map { it!!.bodyAsText() }
-
-        assertEquals(greeter.hello(), helloResponse)
-        assertEquals(bank.balance().toString(), balanceResponse)
-        assertEquals("${greeter.hello()}, your balance is ${bank.balance()}", bankTellerResponse)
-    }
-
     @Test
     fun `async shutdown`() = runTest {
         val registryDeferred = CompletableDeferred<DependencyRegistry>()
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt
index b5c0d9b04..7f61a298c 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/jvm/test/io/ktor/server/plugins/di/DependencyInjectionJvmTest.kt
@@ -144,16 +144,13 @@ class DependencyInjectionJvmTest {
     @Test
     fun `parameterized covariant argument supertypes`() = runTestDI {
         val mySet = HashSet<String>()
-        val myMap = mutableMapOf("hello" to GreetingServiceImpl())
 
         dependencies {
             provide { mySet }
-            provide { myMap }
             provide<() -> String> { { mySet.iterator().next() } }
         }
         // `out` bounds should match supertypes
         assertEquals(mySet, dependencies.resolve<Collection<CharSequence>>())
-        assertEquals(myMap, dependencies.resolve<Map<String, GreetingService>>())
         // return types in lambdas accept supertypes
         assertNotNull(dependencies.resolve<() -> CharSequence>())
         // strict bounds should not match
@@ -196,6 +193,12 @@ class DependencyInjectionJvmTest {
         assertNotNull(dependencies.resolve<(String) -> Boolean>())
     }
 
+    /**
+     * [KTOR-8322 Handle delegate pattern](https://youtrack.jetbrains.com/issue/KTOR-8322/Dependency-injection-handle-delegate-pattern)
+     *     When declaring two classes that share an interface via delegation,
+     *     we should resolve the ambiguity automatically.
+     */
+    @Ignore
     @Test
     fun `install class ref with args from config`() {
         testConfigFile(
