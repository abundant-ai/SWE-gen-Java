diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
index 692fc6b60..4d3c825ac 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.api
@@ -1,6 +1,7 @@
 public final class io/ktor/server/plugins/di/AmbiguousCreateFunction : io/ktor/server/plugins/di/DependencyCreateFunction {
 	public static final field Companion Lio/ktor/server/plugins/di/AmbiguousCreateFunction$Companion;
 	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;)V
+	public final fun clarify (Lkotlin/jvm/functions/Function1;)Lio/ktor/server/plugins/di/DependencyCreateFunction;
 	public final fun component1 ()Lio/ktor/server/plugins/di/DependencyKey;
 	public final fun component2 ()Ljava/util/Set;
 	public final fun copy (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Set;)Lio/ktor/server/plugins/di/AmbiguousCreateFunction;
@@ -8,8 +9,10 @@ public final class io/ktor/server/plugins/di/AmbiguousCreateFunction : io/ktor/s
 	public fun create (Lio/ktor/server/plugins/di/DependencyResolver;)Ljava/lang/Object;
 	public fun equals (Ljava/lang/Object;)Z
 	public final fun getFunctions ()Ljava/util/Set;
+	public final fun getImplementations ()Ljava/util/List;
 	public fun getKey ()Lio/ktor/server/plugins/di/DependencyKey;
 	public fun hashCode ()I
+	public final fun keyString ()Ljava/lang/String;
 	public fun toString ()Ljava/lang/String;
 }
 
@@ -18,7 +21,8 @@ public final class io/ktor/server/plugins/di/AmbiguousCreateFunction$Companion {
 }
 
 public final class io/ktor/server/plugins/di/AmbiguousDependencyException : io/ktor/server/plugins/di/DependencyInjectionException {
-	public fun <init> (Lio/ktor/server/plugins/di/DependencyKey;Ljava/util/Collection;)V
+	public fun <init> (Lio/ktor/server/plugins/di/AmbiguousCreateFunction;)V
+	public final fun getFunction ()Lio/ktor/server/plugins/di/AmbiguousCreateFunction;
 }
 
 public final class io/ktor/server/plugins/di/CircularDependencyException : io/ktor/server/plugins/di/DependencyInjectionException {
@@ -41,7 +45,7 @@ public abstract interface class io/ktor/server/plugins/di/DependencyConflictPoli
 
 public final class io/ktor/server/plugins/di/DependencyConflictPolicyKt {
 	public static final fun getDefaultConflictPolicy ()Lio/ktor/server/plugins/di/DependencyConflictPolicy;
-	public static final fun getLastEntryWinsPolicy ()Lio/ktor/server/plugins/di/DependencyConflictPolicy;
+	public static final fun getIgnoreConflicts ()Lio/ktor/server/plugins/di/DependencyConflictPolicy;
 }
 
 public abstract interface class io/ktor/server/plugins/di/DependencyConflictResult {
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
index 202154fdb..22b13803f 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/api/ktor-server-di.klib.api
@@ -119,15 +119,19 @@ final class io.ktor.server.plugins.di/AmbiguousCreateFunction : io.ktor.server.p
 
     final val functions // io.ktor.server.plugins.di/AmbiguousCreateFunction.functions|{}functions[0]
         final fun <get-functions>(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/AmbiguousCreateFunction.functions.<get-functions>|<get-functions>(){}[0]
+    final val implementations // io.ktor.server.plugins.di/AmbiguousCreateFunction.implementations|{}implementations[0]
+        final fun <get-implementations>(): kotlin.collections/List<io.ktor.server.plugins.di/DependencyKey> // io.ktor.server.plugins.di/AmbiguousCreateFunction.implementations.<get-implementations>|<get-implementations>(){}[0]
     final val key // io.ktor.server.plugins.di/AmbiguousCreateFunction.key|{}key[0]
         final fun <get-key>(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/AmbiguousCreateFunction.key.<get-key>|<get-key>(){}[0]
 
+    final fun clarify(kotlin/Function1<io.ktor.server.plugins.di/DependencyKey, kotlin/Boolean>): io.ktor.server.plugins.di/DependencyCreateFunction? // io.ktor.server.plugins.di/AmbiguousCreateFunction.clarify|clarify(kotlin.Function1<io.ktor.server.plugins.di.DependencyKey,kotlin.Boolean>){}[0]
     final fun component1(): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/AmbiguousCreateFunction.component1|component1(){}[0]
     final fun component2(): kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> // io.ktor.server.plugins.di/AmbiguousCreateFunction.component2|component2(){}[0]
     final fun copy(io.ktor.server.plugins.di/DependencyKey = ..., kotlin.collections/Set<io.ktor.server.plugins.di/DependencyCreateFunction> = ...): io.ktor.server.plugins.di/AmbiguousCreateFunction // io.ktor.server.plugins.di/AmbiguousCreateFunction.copy|copy(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Set<io.ktor.server.plugins.di.DependencyCreateFunction>){}[0]
     final fun create(io.ktor.server.plugins.di/DependencyResolver): kotlin/Any // io.ktor.server.plugins.di/AmbiguousCreateFunction.create|create(io.ktor.server.plugins.di.DependencyResolver){}[0]
     final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.server.plugins.di/AmbiguousCreateFunction.equals|equals(kotlin.Any?){}[0]
     final fun hashCode(): kotlin/Int // io.ktor.server.plugins.di/AmbiguousCreateFunction.hashCode|hashCode(){}[0]
+    final fun keyString(): kotlin/String // io.ktor.server.plugins.di/AmbiguousCreateFunction.keyString|keyString(){}[0]
     final fun toString(): kotlin/String // io.ktor.server.plugins.di/AmbiguousCreateFunction.toString|toString(){}[0]
 
     final object Companion { // io.ktor.server.plugins.di/AmbiguousCreateFunction.Companion|null[0]
@@ -136,7 +140,10 @@ final class io.ktor.server.plugins.di/AmbiguousCreateFunction : io.ktor.server.p
 }
 
 final class io.ktor.server.plugins.di/AmbiguousDependencyException : io.ktor.server.plugins.di/DependencyInjectionException { // io.ktor.server.plugins.di/AmbiguousDependencyException|null[0]
-    constructor <init>(io.ktor.server.plugins.di/DependencyKey, kotlin.collections/Collection<io.ktor.server.plugins.di/DependencyKey>) // io.ktor.server.plugins.di/AmbiguousDependencyException.<init>|<init>(io.ktor.server.plugins.di.DependencyKey;kotlin.collections.Collection<io.ktor.server.plugins.di.DependencyKey>){}[0]
+    constructor <init>(io.ktor.server.plugins.di/AmbiguousCreateFunction) // io.ktor.server.plugins.di/AmbiguousDependencyException.<init>|<init>(io.ktor.server.plugins.di.AmbiguousCreateFunction){}[0]
+
+    final val function // io.ktor.server.plugins.di/AmbiguousDependencyException.function|{}function[0]
+        final fun <get-function>(): io.ktor.server.plugins.di/AmbiguousCreateFunction // io.ktor.server.plugins.di/AmbiguousDependencyException.function.<get-function>|<get-function>(){}[0]
 }
 
 final class io.ktor.server.plugins.di/CircularDependencyException : io.ktor.server.plugins.di/DependencyInjectionException { // io.ktor.server.plugins.di/CircularDependencyException|null[0]
@@ -370,8 +377,8 @@ final val io.ktor.server.plugins.di/DefaultReflection // io.ktor.server.plugins.
     final fun <get-DefaultReflection>(): io.ktor.server.plugins.di/DependencyReflection // io.ktor.server.plugins.di/DefaultReflection.<get-DefaultReflection>|<get-DefaultReflection>(){}[0]
 final val io.ktor.server.plugins.di/DependencyRegistryKey // io.ktor.server.plugins.di/DependencyRegistryKey|{}DependencyRegistryKey[0]
     final fun <get-DependencyRegistryKey>(): io.ktor.util/AttributeKey<io.ktor.server.plugins.di/DependencyRegistry> // io.ktor.server.plugins.di/DependencyRegistryKey.<get-DependencyRegistryKey>|<get-DependencyRegistryKey>(){}[0]
-final val io.ktor.server.plugins.di/LastEntryWinsPolicy // io.ktor.server.plugins.di/LastEntryWinsPolicy|{}LastEntryWinsPolicy[0]
-    final fun <get-LastEntryWinsPolicy>(): io.ktor.server.plugins.di/DependencyConflictPolicy // io.ktor.server.plugins.di/LastEntryWinsPolicy.<get-LastEntryWinsPolicy>|<get-LastEntryWinsPolicy>(){}[0]
+final val io.ktor.server.plugins.di/IgnoreConflicts // io.ktor.server.plugins.di/IgnoreConflicts|{}IgnoreConflicts[0]
+    final fun <get-IgnoreConflicts>(): io.ktor.server.plugins.di/DependencyConflictPolicy // io.ktor.server.plugins.di/IgnoreConflicts.<get-IgnoreConflicts>|<get-IgnoreConflicts>(){}[0]
 final val io.ktor.server.plugins.di/Nullables // io.ktor.server.plugins.di/Nullables|{}Nullables[0]
     final fun <get-Nullables>(): io.ktor.server.plugins.di/DependencyKeyCovariance // io.ktor.server.plugins.di/Nullables.<get-Nullables>|<get-Nullables>(){}[0]
 final val io.ktor.server.plugins.di/OutTypeArgumentsSupertypes // io.ktor.server.plugins.di/OutTypeArgumentsSupertypes|{}OutTypeArgumentsSupertypes[0]
@@ -396,7 +403,21 @@ final fun <#A: kotlin/Any?> (io.ktor.server.application/Application).io.ktor.ser
 final fun <#A: kotlin/Any?> (io.ktor.server.plugins.di/DependencyCreateFunction).io.ktor.server.plugins.di/ifImplicit(kotlin/Function1<io.ktor.server.plugins.di/ImplicitCreateFunction, #A>): #A? // io.ktor.server.plugins.di/ifImplicit|ifImplicit@io.ktor.server.plugins.di.DependencyCreateFunction(kotlin.Function1<io.ktor.server.plugins.di.ImplicitCreateFunction,0:0>){0§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/create(): #A // io.ktor.server.plugins.di/create|create@io.ktor.server.plugins.di.DependencyResolver(){0§<kotlin.Any>}[0]
 final inline fun <#A: reified kotlin/Any> (io.ktor.server.plugins.di/DependencyResolver).io.ktor.server.plugins.di/create(kotlin.reflect/KClass<out #A>): #A // io.ktor.server.plugins.di/create|create@io.ktor.server.plugins.di.DependencyResolver(kotlin.reflect.KClass<out|0:0>){0§<kotlin.Any>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?, #F: reified kotlin/Any?, #G: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function6<#B, #C, #D, #E, #F, #G, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function6<0:1,0:2,0:3,0:4,0:5,0:6,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>;6§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?, #F: reified kotlin/Any?, #G: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction6<#B, #C, #D, #E, #F, #G, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction6<0:1,0:2,0:3,0:4,0:5,0:6,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>;6§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?, #F: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function5<#B, #C, #D, #E, #F, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function5<0:1,0:2,0:3,0:4,0:5,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?, #F: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction5<#B, #C, #D, #E, #F, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction5<0:1,0:2,0:3,0:4,0:5,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>;5§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function4<#B, #C, #D, #E, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function4<0:1,0:2,0:3,0:4,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?, #E: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction4<#B, #C, #D, #E, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction4<0:1,0:2,0:3,0:4,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>;4§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function3<#B, #C, #D, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function3<0:1,0:2,0:3,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?, #D: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction3<#B, #C, #D, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction3<0:1,0:2,0:3,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>;3§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function2<#B, #C, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function2<0:1,0:2,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?, #C: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction2<#B, #C, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction2<0:1,0:2,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>;2§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function1<#B, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function1<0:1,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?, #B: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction1<#B, #A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction1<0:1,0:0>){0§<kotlin.Any?>;1§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/resolve(kotlin/String? = ...): #A // io.ktor.server.plugins.di/resolve|resolve@io.ktor.server.plugins.di.DependencyMap(kotlin.String?){0§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyProvider).io.ktor.server.plugins.di/provide(kotlin/String? = ..., noinline kotlin/Function1<io.ktor.server.plugins.di/DependencyResolver, #A?>) // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyProvider(kotlin.String?;kotlin.Function1<io.ktor.server.plugins.di.DependencyResolver,0:0?>){0§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provide(crossinline kotlin/Function0<#A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<#A> // io.ktor.server.plugins.di/provide|provide@io.ktor.server.plugins.di.DependencyRegistry(kotlin.Function0<0:0>){0§<kotlin.Any?>}[0]
+final inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyRegistry).io.ktor.server.plugins.di/provideAsync(crossinline kotlin.coroutines/SuspendFunction0<#A>): io.ktor.server.plugins.di/DependencyRegistry.KeyContext<kotlinx.coroutines/Deferred<#A>> // io.ktor.server.plugins.di/provideAsync|provideAsync@io.ktor.server.plugins.di.DependencyRegistry(kotlin.coroutines.SuspendFunction0<0:0>){0§<kotlin.Any?>}[0]
 final inline fun <#A: reified kotlin/Any?> io.ktor.server.plugins.di/DependencyKey(kotlin/String? = ..., kotlin/Any? = ...): io.ktor.server.plugins.di/DependencyKey // io.ktor.server.plugins.di/DependencyKey|DependencyKey(kotlin.String?;kotlin.Any?){0§<kotlin.Any?>}[0]
 final suspend inline fun <#A: reified kotlin/Any?> (io.ktor.server.plugins.di/DependencyMap).io.ktor.server.plugins.di/resolveAwait(kotlin/String? = ...): #A // io.ktor.server.plugins.di/resolveAwait|resolveAwait@io.ktor.server.plugins.di.DependencyMap(kotlin.String?){0§<kotlin.Any?>}[0]
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyConflictPolicy.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyConflictPolicy.kt
index 1c0bbfbeb..af5039cfd 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyConflictPolicy.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyConflictPolicy.kt
@@ -72,15 +72,13 @@ public val DefaultConflictPolicy: DependencyConflictPolicy = DependencyConflictP
 }
 
 /**
- * During testing, we simply override previously declared values.
+ * During testing, we ignore conflicts.
  * This allows for replacing base implementations with mock values.
  */
-public val LastEntryWinsPolicy: DependencyConflictPolicy = DependencyConflictPolicy { prev, current ->
-    require(current !is AmbiguousCreateFunction) { "Unexpected ambiguous function supplied" }
-    when (prev) {
-        is AmbiguousCreateFunction,
-        is ImplicitCreateFunction -> KeepNew
-        is ExplicitCreateFunction -> current.ifImplicit { KeepPrevious } ?: KeepNew
+public val IgnoreConflicts: DependencyConflictPolicy = DependencyConflictPolicy { prev, current ->
+    when (val result = DefaultConflictPolicy.resolve(prev, current)) {
+        is Conflict -> KeepPrevious
+        else -> result
     }
 }
 
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
index c96b16b6f..a8081531e 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyInjection.kt
@@ -62,7 +62,7 @@ public val DI: ApplicationPlugin<DependencyInjectionConfig> =
                 .orEmpty()
 
         val provider = if (isTestEngine() && !pluginConfig.providerChanged) {
-            MapDependencyProvider(conflictPolicy = LastEntryWinsPolicy)
+            MapDependencyProvider(conflictPolicy = IgnoreConflicts)
         } else {
             pluginConfig.provider
         }
@@ -117,7 +117,7 @@ public val DI: ApplicationPlugin<DependencyInjectionConfig> =
                         registry.shutdownHooks[key]?.invoke(instance)
                         onShutdown(key, instance)
                     } catch (e: Throwable) {
-                        environment.log.error("Exception during cleanup for $key; continuing", e)
+                        environment.log.warn("Exception during cleanup for $key; continuing", e)
                     }
                 }
                 registry.cancel()
@@ -132,7 +132,7 @@ private fun formatError(e: Throwable): String =
         is MissingDependencyException -> "Missing declaration"
         is CircularDependencyException -> "Circular dependency: ${e.keys.joinToString(" -> ")}"
         is DuplicateDependencyException -> "Conflicting declaration"
-        is AmbiguousDependencyException -> "Ambiguous dependency: ${e.keys.joinToString(", ")}"
+        is AmbiguousDependencyException -> "Ambiguous dependency for ${e.function.keyString()}"
         else -> e.message ?: ("Unknown error" + e.stackTraceToString().let { "\n$it" })
     }
 
@@ -302,8 +302,11 @@ public class DuplicateDependencyException(key: DependencyKey) :
 /**
  * Thrown when there are two or more implicit dependencies that match the given key.
  */
-public class AmbiguousDependencyException(key: DependencyKey, internal val keys: Collection<DependencyKey>) :
-    DependencyInjectionException("Cannot decide which value for $key. Possible implementations: $keys")
+public class AmbiguousDependencyException(
+    public val function: AmbiguousCreateFunction
+) : DependencyInjectionException(
+    "Cannot decide which value for ${function.key}: ${function.implementations}"
+)
 
 /**
  * Thrown when resolving a given dependency loops back on itself.
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
index c9a781e77..67641a959 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProvider.kt
@@ -153,12 +153,21 @@ public data class AmbiguousCreateFunction(
             return functions.singleOrNull() ?: AmbiguousCreateFunction(key, functions)
         }
     }
+
     init {
         require(functions.size > 1) { "More than one function must be provided" }
     }
 
+    public fun clarify(predicate: (DependencyKey) -> Boolean): DependencyCreateFunction? =
+        functions.singleOrNull { predicate(it.key) }
+
+    public val implementations: List<DependencyKey> get() = functions.map { it.key }
+
     override fun create(resolver: DependencyResolver): Any =
-        throw AmbiguousDependencyException(key, functions.map { it.key })
+        throw AmbiguousDependencyException(this)
+
+    public fun keyString(): String =
+        "$key: ${implementations.joinToString()}"
 }
 
 /**
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProviderLambdaOverloads.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProviderLambdaOverloads.kt
new file mode 100644
index 000000000..4b418f7f6
--- /dev/null
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyProviderLambdaOverloads.kt
@@ -0,0 +1,220 @@
+/*
+ * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
+ */
+
+@file:Suppress("ktlint:standard:max-line-length")
+
+package io.ktor.server.plugins.di
+
+import io.ktor.utils.io.KtorDsl
+import kotlinx.coroutines.Deferred
+
+/**
+ * Registers a dependency provider that takes no parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param function A function that creates and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E> DependencyRegistry.provide(
+    crossinline function: () -> E
+): DependencyRegistry.KeyContext<E> = provide {
+    function()
+}
+
+/**
+ * Registers a dependency provider that takes one input parameter and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param function A function that takes one parameter of type [I1] and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1> DependencyRegistry.provide(
+    crossinline function: (I1) -> E
+): DependencyRegistry.KeyContext<E> = provide { function(resolve()) }
+
+/**
+ * Registers a dependency provider that takes two input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param function A function that takes two parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2> DependencyRegistry.provide(
+    crossinline function: (I1, I2) -> E
+): DependencyRegistry.KeyContext<E> = provide { function(resolve(), resolve()) }
+
+/**
+ * Registers a dependency provider that takes three input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param I3 The type of the third input parameter
+ * @param function A function that takes three parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3> DependencyRegistry.provide(
+    crossinline function: (I1, I2, I3) -> E
+): DependencyRegistry.KeyContext<E> = provide { function(resolve(), resolve(), resolve()) }
+
+/**
+ * Registers a dependency provider that takes four input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param I3 The type of the third input parameter
+ * @param I4 The type of the fourth input parameter
+ * @param function A function that takes four parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4> DependencyRegistry.provide(
+    crossinline function: (I1, I2, I3, I4) -> E
+): DependencyRegistry.KeyContext<E> = provide { function(resolve(), resolve(), resolve(), resolve()) }
+
+/**
+ * Registers a dependency provider that takes five input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param I3 The type of the third input parameter
+ * @param I4 The type of the fourth input parameter
+ * @param I5 The type of the fifth input parameter
+ * @param function A function that takes five parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4, reified I5> DependencyRegistry.provide(
+    crossinline function: (I1, I2, I3, I4, I5) -> E
+): DependencyRegistry.KeyContext<E> = provide { function(resolve(), resolve(), resolve(), resolve(), resolve()) }
+
+/**
+ * Registers a dependency provider that takes six input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param I3 The type of the third input parameter
+ * @param I4 The type of the fourth input parameter
+ * @param I5 The type of the fifth input parameter
+ * @param I6 The type of the sixth input parameter
+ * @param function A function that takes six parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4, reified I5, reified I6> DependencyRegistry.provide(
+    crossinline function: (I1, I2, I3, I4, I5, I6) -> E
+): DependencyRegistry.KeyContext<E> = provide {
+    function(resolve(), resolve(), resolve(), resolve(), resolve(), resolve())
+}
+
+/**
+ * Registers a deferred dependency provider that takes no parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param function A function that creates and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E> DependencyRegistry.provideAsync(
+    crossinline function: suspend () -> E
+): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
+    function()
+}
+
+/**
+ * Registers a deferred dependency provider that takes one input parameter and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param function A function that takes one parameter of type [I1] and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1> DependencyRegistry.provideAsync(
+    crossinline function: suspend (I1) -> E
+): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync { function(resolveAwait()) }
+
+/**
+ * Registers a deferred dependency provider that takes two input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param function A function that takes two parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2> DependencyRegistry.provideAsync(
+    crossinline function: suspend (I1, I2) -> E
+): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync { function(resolveAwait(), resolveAwait()) }
+
+/**
+ * Registers a deferred dependency provider that takes three input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param I3 The type of the third input parameter
+ * @param function A function that takes three parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3> DependencyRegistry.provideAsync(
+    crossinline function: suspend (I1, I2, I3) -> E
+): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
+    function(resolveAwait(), resolveAwait(), resolveAwait())
+}
+
+/**
+ * Registers a deferred dependency provider that takes four input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param I3 The type of the third input parameter
+ * @param I4 The type of the fourth input parameter
+ * @param function A function that takes four parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4> DependencyRegistry.provideAsync(
+    crossinline function: suspend (I1, I2, I3, I4) -> E
+): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
+    function(resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait())
+}
+
+/**
+ * Registers a deferred dependency provider that takes five input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param I3 The type of the third input parameter
+ * @param I4 The type of the fourth input parameter
+ * @param I5 The type of the fifth input parameter
+ * @param function A function that takes five parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4, reified I5> DependencyRegistry.provideAsync(
+    crossinline function: suspend (I1, I2, I3, I4, I5) -> E
+): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
+    function(resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait())
+}
+
+/**
+ * Registers a deferred dependency provider that takes six input parameters and returns a value of type [E].
+ *
+ * @param E The type of dependency to be provided
+ * @param I1 The type of the first input parameter
+ * @param I2 The type of the second input parameter
+ * @param I3 The type of the third input parameter
+ * @param I4 The type of the fourth input parameter
+ * @param I5 The type of the fifth input parameter
+ * @param I6 The type of the sixth input parameter
+ * @param function A function that takes six parameters and returns an instance of [E]
+ * @return A [DependencyRegistry.KeyContext] for further configuration of the dependency
+ */
+@KtorDsl public inline fun <reified E, reified I1, reified I2, reified I3, reified I4, reified I5, reified I6> DependencyRegistry.provideAsync(
+    crossinline function: suspend (I1, I2, I3, I4, I5, I6) -> E
+): DependencyRegistry.KeyContext<Deferred<E>> = provideAsync {
+    function(resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait(), resolveAwait())
+}
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
index bc51892a5..44e1476cf 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyRegistry.kt
@@ -235,7 +235,14 @@ public class ProcessingDependencyResolver(
         resolved.contains(key) || provider.declarations.contains(key) || external.contains(key)
 
     override fun <T> get(key: DependencyKey): T =
-        resolveKey(key).getOrThrow() as T
+        try {
+            resolveKey(key).getOrThrow() as T
+        } catch (e: AmbiguousDependencyException) {
+            // During resolution, we can recover from ambiguous dependencies.
+            // This often occurs with delegates.
+            val fallback = e.function.clarify { it in resolved } ?: throw e
+            fallback.create(this) as T
+        }
 
     override fun <T> getOrPut(key: DependencyKey, defaultValue: () -> T): T =
         resolved.getOrPut(key) {
diff --git a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
index c79c9c63b..e5e063416 100644
--- a/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
+++ b/ktor-server/ktor-server-plugins/ktor-server-di/common/src/io/ktor/server/plugins/di/DependencyResolution.kt
@@ -178,8 +178,14 @@ public inline fun <reified T> DependencyMap.resolve(key: String? = null): T =
 /**
  * Resolve a `Deferred<T>` dependency and await its result.
  */
-public suspend inline fun <reified T> DependencyMap.resolveAwait(key: String? = null): T =
-    resolve<Deferred<T>>(key).await()
+public suspend inline fun <reified T> DependencyMap.resolveAwait(key: String? = null): T {
+    val syncKey = DependencyKey<T>()
+    return if (contains(syncKey)) {
+        resolve(key)
+    } else {
+        resolve<Deferred<T>>(key).await()
+    }
+}
 
 internal class MergedDependencyMap(
     private val left: DependencyMap,
