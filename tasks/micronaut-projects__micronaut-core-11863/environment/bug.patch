diff --git a/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ContextPropagatingExecutorService.java b/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ContextPropagatingExecutorService.java
deleted file mode 100644
index 7ae7ff12e6..0000000000
--- a/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ContextPropagatingExecutorService.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.context.propagation.instrument.execution;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.propagation.PropagatedContext;
-import io.micronaut.scheduling.instrument.InstrumentedExecutorService;
-
-import java.util.Optional;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-
-/**
- * Wraps {@link ExecutorService} to instrument it for propagating the {@link PropagatedContext}
- * across threads.
- *
- * @author Hauke Lange
- * @since 4.9.0
- */
-@Internal
-public class ContextPropagatingExecutorService implements InstrumentedExecutorService {
-    private final ExecutorService target;
-
-    private final PropagatedContext propagatedContext;
-
-    public ContextPropagatingExecutorService(ExecutorService target) {
-        this(target, null);
-    }
-
-    public ContextPropagatingExecutorService(
-        ExecutorService target,
-        @Nullable PropagatedContext propagatedContext
-    ) {
-        this.target = target;
-        this.propagatedContext = propagatedContext;
-    }
-
-    @Override
-    public ExecutorService getTarget() {
-        return target;
-    }
-
-    @Override
-    public <T> Callable<T> instrument(Callable<T> task) {
-        if (propagatedContext != null) {
-            return propagatedContext.wrap(task);
-        } else {
-            return PropagatedContext.wrapCurrent(task);
-        }
-    }
-
-    @Override
-    public Runnable instrument(Runnable task) {
-        if (propagatedContext != null) {
-            return propagatedContext.wrap(task);
-        } else {
-            return PropagatedContext.wrapCurrent(task);
-        }
-    }
-
-    /**
-     * Unwraps the target {@link ExecutorService} from the given {@link InstrumentedExecutorService}
-     * if it is instrumented with {@link ContextPropagatingExecutorService}.
-     *
-     * @param executorService The instrumented executor service
-     * @return The target executor service of the {@link ContextPropagatingScheduledExecutorService}
-     *  or empty if not found
-     */
-    public static Optional<ExecutorService> unwrap(ExecutorService executorService) {
-        if (!(executorService instanceof InstrumentedExecutorService)) {
-            return Optional.empty();
-        }
-        ExecutorService target = executorService;
-        while (target instanceof InstrumentedExecutorService ies) {
-            if (target instanceof ContextPropagatingExecutorService contextPropagatingExecutorService) {
-                return Optional.of(contextPropagatingExecutorService.getTarget());
-            }
-            target = ies.getTarget();
-        }
-        return Optional.empty();
-    }
-
-    /**
-     * Checks if the given {@link ExecutorService} is instrumented with
-     * {@link ContextPropagatingExecutorService}.
-     *
-     * @param executorService The executor service to check
-     * @return true if it is instrumented, false otherwise
-     */
-    public static boolean isInstrumented(ExecutorService executorService) {
-        return executorService instanceof InstrumentedExecutorService ies && unwrap(ies).isPresent();
-    }
-}
diff --git a/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ContextPropagatingScheduledExecutorService.java b/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ContextPropagatingScheduledExecutorService.java
deleted file mode 100644
index 6bafd967e8..0000000000
--- a/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ContextPropagatingScheduledExecutorService.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.context.propagation.instrument.execution;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.propagation.PropagatedContext;
-import io.micronaut.scheduling.instrument.InstrumentedScheduledExecutorService;
-
-import java.util.concurrent.ScheduledExecutorService;
-
-/**
- * Wraps {@link ScheduledExecutorService} to instrument it for propagating the {@link PropagatedContext}
- * across threads.
- *
- * @author Hauke Lange
- * @since 4.9.0
- */
-@Internal
-public class ContextPropagatingScheduledExecutorService extends ContextPropagatingExecutorService implements InstrumentedScheduledExecutorService {
-    private final ScheduledExecutorService target;
-
-    public ContextPropagatingScheduledExecutorService(ScheduledExecutorService target) {
-        super(target, null);
-        this.target = target;
-    }
-
-    public ContextPropagatingScheduledExecutorService(
-        ScheduledExecutorService target,
-        @Nullable PropagatedContext propagatedContext
-    ) {
-        super(target, propagatedContext);
-        this.target = target;
-    }
-
-    @Override
-    public ScheduledExecutorService getTarget() {
-        return this.target;
-    }
-}
diff --git a/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ExecutorServiceInstrumenter.java b/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ExecutorServiceInstrumenter.java
index d57a2c9172..020e08d8a0 100644
--- a/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ExecutorServiceInstrumenter.java
+++ b/context-propagation/src/main/java/io/micronaut/context/propagation/instrument/execution/ExecutorServiceInstrumenter.java
@@ -21,6 +21,7 @@ import io.micronaut.context.event.BeanCreatedEventListener;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.propagation.PropagatedContext;
 import io.micronaut.scheduling.instrument.InstrumentedExecutorService;
+import io.micronaut.scheduling.instrument.InstrumentedScheduledExecutorService;
 
 import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
@@ -49,12 +50,43 @@ final class ExecutorServiceInstrumenter implements BeanCreatedEventListener<Exec
             return event.getBean();
         }
         ExecutorService executorService = event.getBean();
-        if (ContextPropagatingExecutorService.isInstrumented(executorService)) {
+        if (executorService instanceof InstrumentedExecutorService) {
             return executorService;
         }
         if (executorService instanceof ScheduledExecutorService service) {
-            return new ContextPropagatingScheduledExecutorService(service);
+            return new InstrumentedScheduledExecutorService() {
+                @Override
+                public ScheduledExecutorService getTarget() {
+                    return service;
+                }
+
+                @Override
+                public <T> Callable<T> instrument(Callable<T> task) {
+                    return PropagatedContext.wrapCurrent(task);
+                }
+
+                @Override
+                public Runnable instrument(Runnable command) {
+                    return PropagatedContext.wrapCurrent(command);
+                }
+            };
         }
-        return new ContextPropagatingExecutorService(executorService);
+        return new InstrumentedExecutorService() {
+            @Override
+            public ExecutorService getTarget() {
+                return executorService;
+            }
+
+            @Override
+            public <T> Callable<T> instrument(Callable<T> task) {
+                return PropagatedContext.wrapCurrent(task);
+            }
+
+            @Override
+            public Runnable instrument(Runnable command) {
+                return PropagatedContext.wrapCurrent(command);
+            }
+        };
     }
+
 }
diff --git a/context-propagation/src/test/groovy/io/micronaut/context/propagation/instrument/execution/ExecutorServiceInstrumenterSpec.groovy b/context-propagation/src/test/groovy/io/micronaut/context/propagation/instrument/execution/ExecutorServiceInstrumenterSpec.groovy
deleted file mode 100644
index 2aa927af0b..0000000000
--- a/context-propagation/src/test/groovy/io/micronaut/context/propagation/instrument/execution/ExecutorServiceInstrumenterSpec.groovy
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.context.propagation.instrument.execution
-
-import io.micronaut.context.ApplicationContext
-import io.micronaut.context.annotation.Prototype
-import io.micronaut.context.annotation.Requires
-import io.micronaut.context.event.BeanCreatedEvent
-import io.micronaut.context.event.BeanCreatedEventListener
-import io.micronaut.core.order.Ordered
-import io.micronaut.inject.qualifiers.Qualifiers
-import io.micronaut.scheduling.instrument.InstrumentedExecutorService
-import io.micronaut.scheduling.instrument.InstrumentedScheduledExecutorService
-import spock.lang.Issue
-import spock.lang.Specification
-
-import java.util.concurrent.ExecutorService
-import java.util.concurrent.ScheduledExecutorService
-
-class ExecutorServiceInstrumenterSpec extends Specification {
-    @Issue("https://github.com/micronaut-projects/micronaut-core/issues/11653")
-    void "test ExecutorServiceInstrumenter instruments executor service if other instrumentations are present"() {
-        given:
-        ApplicationContext applicationContext = ApplicationContext.run([
-                'spec.name': 'ExecutorServiceInstrumenterSpec'
-        ])
-
-        when:
-        ExecutorService io = applicationContext.getBean(ExecutorService, Qualifiers.byName("io"))
-
-        then:"The last instrumentation is applied"
-        io instanceof InstrumentedExecutorService
-
-        and:"The context propagation instrumentation is applied"
-        (io as InstrumentedExecutorService).getTarget() instanceof ContextPropagatingExecutorService
-
-        and:"The first instrumentation is applied"
-        ((io as InstrumentedExecutorService).getTarget() as InstrumentedExecutorService).getTarget() instanceof InstrumentedExecutorService
-
-        cleanup:
-        applicationContext.close()
-    }
-
-    @Issue("https://github.com/micronaut-projects/micronaut-core/issues/11653")
-    void "test ExecutorServiceInstrumenter instruments scheduled executor service if other instrumentations are present"() {
-        given:
-        ApplicationContext applicationContext = ApplicationContext.run([
-                'spec.name': 'ExecutorServiceInstrumenterSpec'
-        ])
-
-        when:
-        ExecutorService scheduled = applicationContext.getBean(ExecutorService, Qualifiers.byName("scheduled"))
-
-        then:"The last instrumentation is applied"
-        scheduled instanceof InstrumentedScheduledExecutorService
-
-        and:"The context propagation instrumentation is applied"
-        (scheduled as InstrumentedExecutorService).getTarget() instanceof ContextPropagatingScheduledExecutorService
-
-        and:"The first instrumentation is applied"
-        ((scheduled as InstrumentedExecutorService).getTarget() as InstrumentedExecutorService).getTarget() instanceof InstrumentedScheduledExecutorService
-
-        cleanup:
-        applicationContext.close()
-    }
-
-    abstract static class ExecutorServiceInstrumentation implements BeanCreatedEventListener<ExecutorService>, Ordered {
-        @Override
-        ExecutorService onCreated(BeanCreatedEvent<ExecutorService> event) {
-            ExecutorService executorService = event.bean
-            if (executorService instanceof ScheduledExecutorService) {
-                return new InstrumentedScheduledExecutorService() {
-                    @Override
-                    ScheduledExecutorService getTarget() {
-                        return executorService as ScheduledExecutorService
-                    }
-
-                    @Override
-                    void execute(Runnable command) {
-                        getTarget().execute(instrument(command))
-                    }
-                }
-            } else {
-                return new InstrumentedExecutorService() {
-                    @Override
-                    ExecutorService getTarget() {
-                        return executorService
-                    }
-
-                    @Override
-                    void execute(Runnable command) {
-                        getTarget().execute(instrument(command))
-                    }
-                }
-            }
-        }
-    }
-
-    @Requires(property = 'spec.name', value = 'ExecutorServiceInstrumenterSpec')
-    @Prototype
-    static class FirstExecutorServiceInstrumentation extends ExecutorServiceInstrumentation {
-        @Override
-        int getOrder() {
-            // Ensure this instrumentation is applied before the ExecutorServiceInstrumenter
-            return HIGHEST_PRECEDENCE
-        }
-    }
-
-    @Requires(property = 'spec.name', value = 'ExecutorServiceInstrumenterSpec')
-    @Prototype
-    static class LastExecutorServiceInstrumentation extends ExecutorServiceInstrumentation {
-        @Override
-        int getOrder() {
-            // Ensure this instrumentation is applied after the ExecutorServiceInstrumenter
-            return LOWEST_PRECEDENCE
-        }
-    }
-}
diff --git a/core-bom/build.gradle.kts b/core-bom/build.gradle.kts
index 94edaac1ed..8ce78a4cf2 100644
--- a/core-bom/build.gradle.kts
+++ b/core-bom/build.gradle.kts
@@ -15,6 +15,15 @@ micronautBom {
         acceptedVersionRegressions.add("netty-iouring")
         acceptedVersionRegressions.add("netty-http3")
         acceptedLibraryRegressions.add("netty-incubator-codec-http3")
+        // remove managed Kotlin 2 Ksp 2
+        acceptedLibraryRegressions.add("ksp2")
+        acceptedLibraryRegressions.add("kotlin2-stdlib")
+        acceptedLibraryRegressions.add("kotlin2-test")
+        acceptedLibraryRegressions.add("kotlin2-reflect")
+        acceptedLibraryRegressions.add("ksp2-api")
+        acceptedLibraryRegressions.add("kotlin2-annotation-processing-embeddable")
+        acceptedLibraryRegressions.add("kotlin2-compiler-embeddable")
+        acceptedLibraryRegressions.add("kotlin2-stdlib-jdk8")
     }
     propertyName = "core"
 }
diff --git a/gradle.properties b/gradle.properties
index fdbe659895..a16604c551 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,4 +1,4 @@
-projectVersion=4.9.1-SNAPSHOT
+projectVersion=4.9.2-SNAPSHOT
 projectGroupId=io.micronaut
 projectDesc=Core components supporting the Micronaut Framework
 title=Micronaut Core
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index cc65b675e7..c8bf881d40 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -139,13 +139,6 @@ managed-kotlin-stdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib", version
 managed-kotlin-stdlib-jdk8 = { module = "org.jetbrains.kotlin:kotlin-stdlib-jdk8", version.ref = "managed-kotlin" }
 managed-kotlin-test = { module = "org.jetbrains.kotlin:kotlin-test", version.ref = "managed-kotlin" }
 
-managed-kotlin2-annotation-processing-embeddable = { module = "org.jetbrains.kotlin:kotlin-annotation-processing-embeddable", version.ref = "managed-kotlin2" }
-managed-kotlin2-compiler-embeddable = { module = "org.jetbrains.kotlin:kotlin-compiler-embeddable", version.ref = "managed-kotlin2" }
-managed-kotlin2-reflect = { module = "org.jetbrains.kotlin:kotlin-reflect", version.ref = "managed-kotlin2" }
-managed-kotlin2-stdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib", version.ref = "managed-kotlin2" }
-managed-kotlin2-stdlib-jdk8 = { module = "org.jetbrains.kotlin:kotlin-stdlib-jdk8", version.ref = "managed-kotlin2" }
-managed-kotlin2-test = { module = "org.jetbrains.kotlin:kotlin-test", version.ref = "managed-kotlin2" }
-
 managed-kotlinx-coroutines-core = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core", version.ref = "managed-kotlin-coroutines" }
 managed-kotlinx-coroutines-jdk8 = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-jdk8", version.ref = "managed-kotlin-coroutines" }
 managed-kotlinx-coroutines-reactive = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-reactive", version.ref = "managed-kotlin-coroutines" }
@@ -156,9 +149,6 @@ managed-kotlinx-coroutines-reactor = { module = "org.jetbrains.kotlinx:kotlinx-c
 managed-ksp-api = { module = "com.google.devtools.ksp:symbol-processing-api", version.ref = "managed-ksp" }
 managed-ksp = { module = "com.google.devtools.ksp:symbol-processing", version.ref = "managed-ksp" }
 
-managed-ksp2-api = { module = "com.google.devtools.ksp:symbol-processing-api", version.ref = "managed-ksp2" }
-managed-ksp2 = { module = "com.google.devtools.ksp:symbol-processing", version.ref = "managed-ksp2" }
-
 managed-java-parser-core = { module = "com.github.javaparser:javaparser-symbol-solver-core", version.ref = "managed-java-parser-core" }
 managed-methvin-directoryWatcher = { module = "io.methvin:directory-watcher", version.ref = "managed-methvin-directory-watcher" }
 
@@ -323,6 +313,18 @@ ksp2-aaEmbeddable = { module = "com.google.devtools.ksp:symbol-processing-aa-emb
 
 jfrunit-core = { module = "org.moditect.jfrunit:jfrunit-core", version.ref = "jfrunit" }
 
+# Kotlin 2 KSP 2 for testing
+
+kotlin2-annotation-processing-embeddable = { module = "org.jetbrains.kotlin:kotlin-annotation-processing-embeddable", version.ref = "managed-kotlin2" }
+kotlin2-compiler-embeddable = { module = "org.jetbrains.kotlin:kotlin-compiler-embeddable", version.ref = "managed-kotlin2" }
+kotlin2-reflect = { module = "org.jetbrains.kotlin:kotlin-reflect", version.ref = "managed-kotlin2" }
+kotlin2-stdlib = { module = "org.jetbrains.kotlin:kotlin-stdlib", version.ref = "managed-kotlin2" }
+kotlin2-stdlib-jdk8 = { module = "org.jetbrains.kotlin:kotlin-stdlib-jdk8", version.ref = "managed-kotlin2" }
+kotlin2-test = { module = "org.jetbrains.kotlin:kotlin-test", version.ref = "managed-kotlin2" }
+
+ksp2-api = { module = "com.google.devtools.ksp:symbol-processing-api", version.ref = "managed-ksp2" }
+ksp2 = { module = "com.google.devtools.ksp:symbol-processing", version.ref = "managed-ksp2" }
+
 [plugins]
 managed-kotlin-allopen = { id = "org.jetbrains.kotlin.plugin.allopen", version.ref = "managed-kotlin" }
 managed-kotlin-noarg = { id = "org.jetbrains.kotlin.plugin.noarg", version.ref = "managed-kotlin" }
@@ -330,5 +332,5 @@ managed-kotlin-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "managed-k
 managed-kotlin-kapt = { id = "org.jetbrains.kotlin.kapt", version.ref = "managed-kotlin" }
 managed-ksp = { id = "com.google.devtools.ksp", version.ref = "managed-ksp" }
 
-managed-kotlin2-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "managed-kotlin2" }
-managed-ksp2 = { id = "com.google.devtools.ksp", version.ref = "managed-ksp2" }
+kotlin2-jvm = { id = "org.jetbrains.kotlin.jvm", version.ref = "managed-kotlin2" }
+ksp2 = { id = "com.google.devtools.ksp", version.ref = "managed-ksp2" }
diff --git a/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java b/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java
index ccd68c7d22..50c248889b 100644
--- a/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java
+++ b/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java
@@ -17,8 +17,6 @@ package io.micronaut.http.server;
 
 import io.micronaut.context.BeanContext;
 import io.micronaut.context.exceptions.BeanCreationException;
-import io.micronaut.context.propagation.instrument.execution.ContextPropagatingExecutorService;
-import io.micronaut.context.propagation.instrument.execution.ContextPropagatingScheduledExecutorService;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
@@ -54,6 +52,8 @@ import io.micronaut.http.server.exceptions.response.ErrorResponseProcessor;
 import io.micronaut.inject.BeanType;
 import io.micronaut.inject.MethodReference;
 import io.micronaut.scheduling.executor.ExecutorSelector;
+import io.micronaut.scheduling.instrument.InstrumentedExecutorService;
+import io.micronaut.scheduling.instrument.InstrumentedScheduledExecutorService;
 import io.micronaut.web.router.DefaultRouteInfo;
 import io.micronaut.web.router.MethodBasedRouteInfo;
 import io.micronaut.web.router.RouteAttributes;
@@ -78,6 +78,7 @@ import java.time.LocalDateTime;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Optional;
+import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ExecutorService;
@@ -375,18 +376,45 @@ public final class RouteExecutor {
         if (executor == null) {
             return Flux.from(publisher).subscribeOn(Schedulers.fromExecutor(command -> propagatedContext.wrap(command).run()));
         }
-        Optional<ExecutorService> wrappedTarget = ContextPropagatingExecutorService.unwrap(executor);
-        if (wrappedTarget.isPresent()) {
-            executor = wrappedTarget.get();
+        if (executor instanceof InstrumentedExecutorService instrumentedExecutorService) {
+            executor = instrumentedExecutorService.getTarget();
         }
         if (executor instanceof ScheduledExecutorService scheduledExecutorService) {
-            executor = new ContextPropagatingScheduledExecutorService(
-                scheduledExecutorService,
-                propagatedContext
-            );
+            executor = new InstrumentedScheduledExecutorService() {
+                @Override
+                public ScheduledExecutorService getTarget() {
+                    return scheduledExecutorService;
+                }
+
+                @Override
+                public <X> Callable<X> instrument(Callable<X> task) {
+                    return propagatedContext.wrap(task);
+                }
+
+                @Override
+                public Runnable instrument(Runnable command) {
+                    return propagatedContext.wrap(command);
+                }
+            };
         } else {
             ExecutorService finalExecutor = executor;
-            executor = new ContextPropagatingExecutorService(finalExecutor, propagatedContext);
+            executor = new InstrumentedExecutorService() {
+
+                @Override
+                public ExecutorService getTarget() {
+                    return finalExecutor;
+                }
+
+                @Override
+                public <X> Callable<X> instrument(Callable<X> task) {
+                    return propagatedContext.wrap(task);
+                }
+
+                @Override
+                public Runnable instrument(Runnable command) {
+                    return propagatedContext.wrap(command);
+                }
+            };
         }
         final Scheduler scheduler = Schedulers.fromExecutorService(executor);
         return Flux.from(publisher)
diff --git a/test-inject-kotlin2-ksp2/build.gradle.kts b/test-inject-kotlin2-ksp2/build.gradle.kts
index 97ae3d723b..969135eb4c 100644
--- a/test-inject-kotlin2-ksp2/build.gradle.kts
+++ b/test-inject-kotlin2-ksp2/build.gradle.kts
@@ -1,7 +1,7 @@
 plugins {
     id("io.micronaut.build.internal.convention-test-library")
-    alias(libs.plugins.managed.kotlin2.jvm)
-    alias(libs.plugins.managed.ksp2)
+    alias(libs.plugins.kotlin2.jvm)
+    alias(libs.plugins.ksp2)
 }
 
 micronautBuild {
@@ -17,7 +17,7 @@ dependencies {
     // We use ASM API for some type conversions
     implementation(mnSourcegen.asm)
 
-    implementation(libs.managed.ksp2.api)
+    implementation(libs.ksp2.api)
 
     implementation(projects.micronautInjectKotlin) {
         exclude(group = "org.jetbrains.kotlin")
@@ -36,7 +36,7 @@ dependencies {
     testImplementation(projects.testInjectKotlin2Test)
     testImplementation(projects.micronautContext)
     testImplementation(projects.micronautJacksonDatabind)
-    testImplementation(libs.managed.kotlin2.stdlib)
+    testImplementation(libs.kotlin2.stdlib)
     testImplementation(projects.micronautHttpClient)
     testImplementation(libs.managed.jackson.annotations)
     testImplementation(libs.managed.reactor)
diff --git a/test-inject-kotlin2-test/build.gradle.kts b/test-inject-kotlin2-test/build.gradle.kts
index 441732eddb..0a5ca12465 100644
--- a/test-inject-kotlin2-test/build.gradle.kts
+++ b/test-inject-kotlin2-test/build.gradle.kts
@@ -1,6 +1,6 @@
 plugins {
     id("io.micronaut.build.internal.convention-test-library")
-    alias(libs.plugins.managed.kotlin2.jvm)
+    alias(libs.plugins.kotlin2.jvm)
 }
 
 dependencies {
@@ -9,9 +9,9 @@ dependencies {
     api(libs.spock) {
         exclude(module = "groovy-all")
     }
-    api(libs.managed.ksp2.api)
-    api(libs.managed.ksp2)
-    implementation(libs.managed.kotlin2.compiler.embeddable)
+    api(libs.ksp2.api)
+    api(libs.ksp2)
+    implementation(libs.kotlin2.compiler.embeddable)
     implementation(libs.ksp2.commonDeps)
     implementation(libs.ksp2.aaEmbeddable)
     implementation(libs.okio)
@@ -19,7 +19,7 @@ dependencies {
     testImplementation(libs.javax.persistence)
     testImplementation(projects.micronautRuntime)
     api(libs.blaze.persistence.core)
-    implementation(libs.managed.kotlin2.stdlib)
+    implementation(libs.kotlin2.stdlib)
 }
 
 tasks {
diff --git a/test-suite-kotlin2-ksp2/build.gradle.kts b/test-suite-kotlin2-ksp2/build.gradle.kts
index 5091a71002..88bb7192b7 100644
--- a/test-suite-kotlin2-ksp2/build.gradle.kts
+++ b/test-suite-kotlin2-ksp2/build.gradle.kts
@@ -1,7 +1,7 @@
 plugins {
     id("io.micronaut.build.internal.convention-test-library")
-    alias(libs.plugins.managed.kotlin2.jvm)
-    alias(libs.plugins.managed.ksp2)
+    alias(libs.plugins.kotlin2.jvm)
+    alias(libs.plugins.ksp2)
 }
 
 micronautBuild {
@@ -13,8 +13,8 @@ micronautBuild {
 }
 
 dependencies {
-    api(libs.managed.kotlin2.stdlib)
-    api(libs.managed.kotlin2.reflect)
+    api(libs.kotlin2.stdlib)
+    api(libs.kotlin2.reflect)
     api(libs.managed.kotlinx.coroutines.core)
     api(libs.managed.kotlinx.coroutines.jdk8)
     api(libs.managed.kotlinx.coroutines.rx2)
@@ -23,7 +23,7 @@ dependencies {
     api(projects.micronautRuntime)
 
     testImplementation(projects.micronautContext)
-    testImplementation(libs.managed.kotlin2.test)
+    testImplementation(libs.kotlin2.test)
     testImplementation(libs.managed.kotlinx.coroutines.core)
     testImplementation(libs.managed.kotlinx.coroutines.rx2)
     testImplementation(libs.managed.kotlinx.coroutines.slf4j)
