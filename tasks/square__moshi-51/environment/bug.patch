diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
index e33e1f38..aadc8666 100644
--- a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
@@ -59,7 +59,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
             throw new AssertionError();
           } catch (InvocationTargetException e) {
             if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause() + " at " + writer.getPath());
+            throw new JsonDataException(e.getCause()); // TODO: more context?
           }
         }
       }
@@ -77,7 +77,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
             throw new AssertionError();
           } catch (InvocationTargetException e) {
             if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause() + " at " + reader.getPath());
+            throw new JsonDataException(e.getCause()); // TODO: more context?
           }
         }
       }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonDataException.java b/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
index e3fe4ebd..a8463055 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
@@ -15,7 +15,14 @@
  */
 package com.squareup.moshi;
 
-/** Thrown when a JSON document doesn't match the expected format. */
+/**
+ * Thrown when the data in a JSON document doesn't match the data expected by the caller. For
+ * example, suppose the application expects a boolean but the JSON document contains a string. When
+ * the call to {@link JsonReader#nextBoolean} is made, a {@code JsonDataException} is thrown.
+ *
+ * <p>Exceptions of this type should be fixed by either changing the application code to accept
+ * the unexpected JSON, or by changing the JSON to conform to the application's expectations.
+ */
 public final class JsonDataException extends RuntimeException {
   public JsonDataException() {
   }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index 76b1a337..272c8e39 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -248,6 +248,14 @@ public final class JsonReader implements Closeable {
     stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
   }
 
+  /*
+   * The path members. It corresponds directly to stack: At indices where the
+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
+   * pathNames contains the name at this scope. Where it contains an array
+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
+   * that array. Otherwise the value is undefined, and we take advantage of that
+   * by incrementing pathIndices when doing so isn't useful.
+   */
   private String[] pathNames = new String[32];
   private int[] pathIndices = new int[32];
 
@@ -303,8 +311,8 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Consumes the next token from the JSON stream and asserts that it is the
-   * beginning of a new array.
+   * Consumes the next token from the JSON stream and asserts that it is the beginning of a new
+   * array.
    */
   public void beginArray() throws IOException {
     int p = peeked;
@@ -316,7 +324,7 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1] = 0;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek()
+      throw new JsonDataException("Expected BEGIN_ARRAY but was " + peek()
           + " at path " + getPath());
     }
   }
@@ -335,14 +343,14 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected END_ARRAY but was " + peek()
+      throw new JsonDataException("Expected END_ARRAY but was " + peek()
           + " at path " + getPath());
     }
   }
 
   /**
-   * Consumes the next token from the JSON stream and asserts that it is the
-   * beginning of a new object.
+   * Consumes the next token from the JSON stream and asserts that it is the beginning of a new
+   * object.
    */
   public void beginObject() throws IOException {
     int p = peeked;
@@ -353,14 +361,14 @@ public final class JsonReader implements Closeable {
       push(JsonScope.EMPTY_OBJECT);
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek()
+      throw new JsonDataException("Expected BEGIN_OBJECT but was " + peek()
           + " at path " + getPath());
     }
   }
 
   /**
-   * Consumes the next token from the JSON stream and asserts that it is the
-   * end of the current object.
+   * Consumes the next token from the JSON stream and asserts that it is the end of the current
+   * object.
    */
   public void endObject() throws IOException {
     int p = peeked;
@@ -373,7 +381,7 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new IllegalStateException("Expected END_OBJECT but was " + peek()
+      throw new JsonDataException("Expected END_OBJECT but was " + peek()
           + " at path " + getPath());
     }
   }
@@ -736,11 +744,9 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the next token, a {@link Token#NAME property name}, and
-   * consumes it.
+   * Returns the next token, a {@link Token#NAME property name}, and consumes it.
    *
-   * @throws java.io.IOException if the next token in the stream is not a property
-   *     name.
+   * @throws JsonDataException if the next token in the stream is not a property name.
    */
   public String nextName() throws IOException {
     int p = peeked;
@@ -755,8 +761,7 @@ public final class JsonReader implements Closeable {
     } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
       result = nextQuotedValue(SINGLE_QUOTE_OR_SLASH);
     } else {
-      throw new IllegalStateException("Expected a name but was " + peek()
-          + " at path " + getPath());
+      throw new JsonDataException("Expected a name but was " + peek() + " at path " + getPath());
     }
     peeked = PEEKED_NONE;
     pathNames[stackSize - 1] = result;
@@ -764,12 +769,10 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the {@link Token#STRING string} value of the next token,
-   * consuming it. If the next token is a number, this method will return its
-   * string form.
+   * Returns the {@link Token#STRING string} value of the next token, consuming it. If the next
+   * token is a number, this method will return its string form.
    *
-   * @throws IllegalStateException if the next token is not a string or if
-   *     this reader is closed.
+   * @throws JsonDataException if the next token is not a string or if this reader is closed.
    */
   public String nextString() throws IOException {
     int p = peeked;
@@ -791,8 +794,7 @@ public final class JsonReader implements Closeable {
     } else if (p == PEEKED_NUMBER) {
       result = buffer.readUtf8(peekedNumberLength);
     } else {
-      throw new IllegalStateException("Expected a string but was " + peek()
-          + " at path " + getPath());
+      throw new JsonDataException("Expected a string but was " + peek() + " at path " + getPath());
     }
     peeked = PEEKED_NONE;
     pathIndices[stackSize - 1]++;
@@ -800,11 +802,9 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the {@link Token#BOOLEAN boolean} value of the next token,
-   * consuming it.
+   * Returns the {@link Token#BOOLEAN boolean} value of the next token, consuming it.
    *
-   * @throws IllegalStateException if the next token is not a boolean or if
-   *     this reader is closed.
+   * @throws JsonDataException if the next token is not a boolean or if this reader is closed.
    */
   public boolean nextBoolean() throws IOException {
     int p = peeked;
@@ -820,16 +820,14 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1]++;
       return false;
     }
-    throw new IllegalStateException("Expected a boolean but was " + peek()
-        + " at path " + getPath());
+    throw new JsonDataException("Expected a boolean but was " + peek() + " at path " + getPath());
   }
 
   /**
-   * Consumes the next token from the JSON stream and asserts that it is a
-   * literal null. Returns null.
+   * Consumes the next token from the JSON stream and asserts that it is a literal null. Returns
+   * null.
    *
-   * @throws IllegalStateException if the next token is not null or if this
-   *     reader is closed.
+   * @throws JsonDataException if the next token is not null or if this reader is closed.
    */
   public <T> T nextNull() throws IOException {
     int p = peeked;
@@ -841,19 +839,17 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1]++;
       return null;
     } else {
-      throw new IllegalStateException("Expected null but was " + peek()
-          + " at path " + getPath());
+      throw new JsonDataException("Expected null but was " + peek() + " at path " + getPath());
     }
   }
 
   /**
-   * Returns the {@link Token#NUMBER double} value of the next token,
-   * consuming it. If the next token is a string, this method will attempt to
-   * parse it as a double using {@link Double#parseDouble(String)}.
+   * Returns the {@link Token#NUMBER double} value of the next token, consuming it. If the next
+   * token is a string, this method will attempt to parse it as a double using {@link
+   * Double#parseDouble(String)}.
    *
-   * @throws IllegalStateException if the next token is not a literal value.
-   * @throws NumberFormatException if the next literal value cannot be parsed
-   *     as a double, or is non-finite.
+   * @throws JsonDataException if the next token is not a literal value, or if the next literal
+   *     value cannot be parsed as a double, or is non-finite.
    */
   public double nextDouble() throws IOException {
     int p = peeked;
@@ -876,14 +872,19 @@ public final class JsonReader implements Closeable {
     } else if (p == PEEKED_UNQUOTED) {
       peekedString = nextUnquotedValue();
     } else if (p != PEEKED_BUFFERED) {
-      throw new IllegalStateException("Expected a double but was " + peek()
-          + " at path " + getPath());
+      throw new JsonDataException("Expected a double but was " + peek() + " at path " + getPath());
     }
 
     peeked = PEEKED_BUFFERED;
-    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+    double result;
+    try {
+      result = Double.parseDouble(peekedString);
+    } catch (NumberFormatException e) {
+      throw new JsonDataException("Expected a double but was " + peekedString
+          + " at path " + getPath());
+    }
     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
-      throw new NumberFormatException("JSON forbids NaN and infinities: " + result
+      throw new IOException("JSON forbids NaN and infinities: " + result
           + " at path " + getPath());
     }
     peekedString = null;
@@ -893,14 +894,12 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the {@link Token#NUMBER long} value of the next token,
-   * consuming it. If the next token is a string, this method will attempt to
-   * parse it as a long. If the next token's numeric value cannot be exactly
-   * represented by a Java {@code long}, this method throws.
+   * Returns the {@link Token#NUMBER long} value of the next token, consuming it. If the next token
+   * is a string, this method will attempt to parse it as a long. If the next token's numeric value
+   * cannot be exactly represented by a Java {@code long}, this method throws.
    *
-   * @throws IllegalStateException if the next token is not a literal value.
-   * @throws NumberFormatException if the next literal value cannot be parsed
-   *     as a number, or exactly represented as a long.
+   * @throws JsonDataException if the next token is not a literal value, if the next literal value
+   *     cannot be parsed as a number, or exactly represented as a long.
    */
   public long nextLong() throws IOException {
     int p = peeked;
@@ -929,15 +928,21 @@ public final class JsonReader implements Closeable {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new IllegalStateException("Expected a long but was " + peek()
+      throw new JsonDataException("Expected a long but was " + peek()
           + " at path " + getPath());
     }
 
     peeked = PEEKED_BUFFERED;
-    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+    double asDouble;
+    try {
+      asDouble = Double.parseDouble(peekedString);
+    } catch (NumberFormatException e) {
+      throw new JsonDataException("Expected a long but was " + peekedString
+          + " at path " + getPath());
+    }
     long result = (long) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
-      throw new NumberFormatException("Expected a long but was " + peekedString
+      throw new JsonDataException("Expected a long but was " + peekedString
           + " at path " + getPath());
     }
     peekedString = null;
@@ -947,13 +952,11 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the string up to but not including {@code quote}, unescaping any
-   * character escape sequences encountered along the way. The opening quote
-   * should have already been read. This consumes the closing quote, but does
-   * not include it in the returned string.
+   * Returns the string up to but not including {@code quote}, unescaping any character escape
+   * sequences encountered along the way. The opening quote should have already been read. This
+   * consumes the closing quote, but does not include it in the returned string.
    *
-   * @throws NumberFormatException if any unicode escape sequences are
-   *     malformed.
+   * @throws IOException if any unicode escape sequences are malformed.
    */
   private String nextQuotedValue(ByteString runTerminator) throws IOException {
     StringBuilder builder = null;
@@ -1010,14 +1013,12 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the {@link Token#NUMBER int} value of the next token,
-   * consuming it. If the next token is a string, this method will attempt to
-   * parse it as an int. If the next token's numeric value cannot be exactly
-   * represented by a Java {@code int}, this method throws.
+   * Returns the {@link Token#NUMBER int} value of the next token, consuming it. If the next token
+   * is a string, this method will attempt to parse it as an int. If the next token's numeric value
+   * cannot be exactly represented by a Java {@code int}, this method throws.
    *
-   * @throws IllegalStateException if the next token is not a literal value.
-   * @throws NumberFormatException if the next literal value cannot be parsed
-   *     as a number, or exactly represented as an int.
+   * @throws JsonDataException if the next token is not a literal value, if the next literal value
+   *     cannot be parsed as a number, or exactly represented as an int.
    */
   public int nextInt() throws IOException {
     int p = peeked;
@@ -1029,7 +1030,7 @@ public final class JsonReader implements Closeable {
     if (p == PEEKED_LONG) {
       result = (int) peekedLong;
       if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
-        throw new NumberFormatException("Expected an int but was " + peekedLong
+        throw new JsonDataException("Expected an int but was " + peekedLong
             + " at path " + getPath());
       }
       peeked = PEEKED_NONE;
@@ -1052,15 +1053,20 @@ public final class JsonReader implements Closeable {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new IllegalStateException("Expected an int but was " + peek()
-          + " at path " + getPath());
+      throw new JsonDataException("Expected an int but was " + peek() + " at path " + getPath());
     }
 
     peeked = PEEKED_BUFFERED;
-    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
+    double asDouble;
+    try {
+      asDouble = Double.parseDouble(peekedString);
+    } catch (NumberFormatException e) {
+      throw new JsonDataException("Expected an int but was " + peekedString
+          + " at path " + getPath());
+    }
     result = (int) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
-      throw new NumberFormatException("Expected an int but was " + peekedString
+      throw new JsonDataException("Expected an int but was " + peekedString
           + " at path " + getPath());
     }
     peekedString = null;
@@ -1081,9 +1087,9 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Skips the next value recursively. If it is an object or array, all nested
-   * elements are skipped. This method is intended for use when the JSON token
-   * stream contains unrecognized or unhandled values.
+   * Skips the next value recursively. If it is an object or array, all nested elements are skipped.
+   * This method is intended for use when the JSON token stream contains unrecognized or unhandled
+   * values.
    */
   public void skipValue() throws IOException {
     int count = 0;
@@ -1261,17 +1267,38 @@ public final class JsonReader implements Closeable {
    * the current location in the JSON value.
    */
   public String getPath() {
-    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
+    StringBuilder result = new StringBuilder().append('$');
+    for (int i = 0, size = stackSize; i < size; i++) {
+      switch (stack[i]) {
+        case JsonScope.EMPTY_ARRAY:
+        case JsonScope.NONEMPTY_ARRAY:
+          result.append('[').append(pathIndices[i]).append(']');
+          break;
+
+        case JsonScope.EMPTY_OBJECT:
+        case JsonScope.DANGLING_NAME:
+        case JsonScope.NONEMPTY_OBJECT:
+          result.append('.');
+          if (pathNames[i] != null) {
+            result.append(pathNames[i]);
+          }
+          break;
+
+        case JsonScope.NONEMPTY_DOCUMENT:
+        case JsonScope.EMPTY_DOCUMENT:
+        case JsonScope.CLOSED:
+          break;
+      }
+    }
+    return result.toString();
   }
 
   /**
-   * Unescapes the character identified by the character or characters that
-   * immediately follow a backslash. The backslash '\' should have already
-   * been read. This supports both unicode escapes "u000A" and two-character
-   * escapes "\n".
+   * Unescapes the character identified by the character or characters that immediately follow a
+   * backslash. The backslash '\' should have already been read. This supports both unicode escapes
+   * "u000A" and two-character escapes "\n".
    *
-   * @throws NumberFormatException if any unicode escape sequences are
-   *     malformed.
+   * @throws IOException if any unicode escape sequences are malformed.
    */
   private char readEscapeCharacter() throws IOException {
     if (!fillBuffer(1)) {
@@ -1282,7 +1309,7 @@ public final class JsonReader implements Closeable {
     switch (escaped) {
       case 'u':
         if (!fillBuffer(4)) {
-          throw syntaxError("Unterminated escape sequence");
+          throw new EOFException("Unterminated escape sequence at path " + getPath());
         }
         // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
         char result = 0;
@@ -1296,7 +1323,7 @@ public final class JsonReader implements Closeable {
           } else if (c >= 'A' && c <= 'F') {
             result += (c - 'A' + 10);
           } else {
-            throw new NumberFormatException("\\u" + buffer.readUtf8(4));
+            throw syntaxError("\\u" + buffer.readUtf8(4));
           }
         }
         buffer.skip(4);
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonScope.java b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
index 180839ad..776d7251 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonScope.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
@@ -15,65 +15,53 @@
  */
 package com.squareup.moshi;
 
-/** Lexical scoping elements within a JSON reader or writer. */
+/**
+ * Lexical scoping elements within a JSON reader or writer.
+ */
 final class JsonScope {
 
-  /** An array with no elements requires no separators or newlines before it is closed. */
+  /**
+   * An array with no elements requires no separators or newlines before
+   * it is closed.
+   */
   static final int EMPTY_ARRAY = 1;
 
-  /** A array with at least one value requires a comma and newline before the next element. */
+  /**
+   * A array with at least one value requires a comma and newline before
+   * the next element.
+   */
   static final int NONEMPTY_ARRAY = 2;
 
-  /** An object with no name/value pairs requires no separators or newlines before it is closed. */
+  /**
+   * An object with no name/value pairs requires no separators or newlines
+   * before it is closed.
+   */
   static final int EMPTY_OBJECT = 3;
 
-  /** An object whose most recent element is a key. The next element must be a value. */
+  /**
+   * An object whose most recent element is a key. The next element must
+   * be a value.
+   */
   static final int DANGLING_NAME = 4;
 
-  /** An object with at least one name/value pair requires a separator before the next element. */
+  /**
+   * An object with at least one name/value pair requires a comma and
+   * newline before the next element.
+   */
   static final int NONEMPTY_OBJECT = 5;
 
-  /** No object or array has been started. */
+  /**
+   * No object or array has been started.
+   */
   static final int EMPTY_DOCUMENT = 6;
 
-  /** A document with at an array or object. */
+  /**
+   * A document with at an array or object.
+   */
   static final int NONEMPTY_DOCUMENT = 7;
 
-  /** A document that's been closed and cannot be accessed. */
-  static final int CLOSED = 8;
-
   /**
-   * Renders the path in a JSON document to a string. The {@code pathNames} and {@code pathIndices}
-   * parameters corresponds directly to stack: At indices where the stack contains an object
-   * (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT), pathNames contains the name at this scope.
-   * Where it contains an array (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index
-   * in that array. Otherwise the value is undefined, and we take advantage of that by incrementing
-   * pathIndices when doing so isn't useful.
+   * A document that's been closed and cannot be accessed.
    */
-  static String getPath(int stackSize, int[] stack, String[] pathNames, int[] pathIndices) {
-    StringBuilder result = new StringBuilder().append('$');
-    for (int i = 0, size = stackSize; i < size; i++) {
-      switch (stack[i]) {
-        case EMPTY_ARRAY:
-        case NONEMPTY_ARRAY:
-          result.append('[').append(pathIndices[i]).append(']');
-          break;
-
-        case EMPTY_OBJECT:
-        case DANGLING_NAME:
-        case NONEMPTY_OBJECT:
-          result.append('.');
-          if (pathNames[i] != null) {
-            result.append(pathNames[i]);
-          }
-          break;
-
-        case NONEMPTY_DOCUMENT:
-        case EMPTY_DOCUMENT:
-        case CLOSED:
-          break;
-      }
-    }
-    return result.toString();
-  }
+  static final int CLOSED = 8;
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index e22bc55b..da3de7bc 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -160,9 +160,6 @@ public final class JsonWriter implements Closeable, Flushable {
     push(EMPTY_DOCUMENT);
   }
 
-  private String[] pathNames = new String[32];
-  private int[] pathIndices = new int[32];
-
   /**
    * A string containing a full set of spaces for a single level of
    * indentation, or null for no pretty printing.
@@ -293,7 +290,6 @@ public final class JsonWriter implements Closeable, Flushable {
    */
   private JsonWriter open(int empty, String openBracket) throws IOException {
     beforeValue(true);
-    pathIndices[stackSize] = 0;
     push(empty);
     sink.writeUtf8(openBracket);
     return this;
@@ -314,8 +310,6 @@ public final class JsonWriter implements Closeable, Flushable {
     }
 
     stackSize--;
-    pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
-    pathIndices[stackSize - 1]++;
     if (context == nonempty) {
       newline();
     }
@@ -359,14 +353,13 @@ public final class JsonWriter implements Closeable, Flushable {
     if (name == null) {
       throw new NullPointerException("name == null");
     }
-    if (deferredName != null) {
-      throw new IllegalStateException();
-    }
     if (stackSize == 0) {
       throw new IllegalStateException("JsonWriter is closed.");
     }
+    if (deferredName != null) {
+      throw new IllegalStateException();
+    }
     deferredName = name;
-    pathNames[stackSize - 1] = name;
     return this;
   }
 
@@ -391,7 +384,6 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     string(value);
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -411,7 +403,6 @@ public final class JsonWriter implements Closeable, Flushable {
     }
     beforeValue(false);
     sink.writeUtf8("null");
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -424,7 +415,6 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(value ? "true" : "false");
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -442,7 +432,6 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Double.toString(value));
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -455,7 +444,6 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Long.toString(value));
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -479,7 +467,6 @@ public final class JsonWriter implements Closeable, Flushable {
     }
     beforeValue(false);
     sink.writeUtf8(string);
-    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -497,7 +484,7 @@ public final class JsonWriter implements Closeable, Flushable {
   /**
    * Flushes and closes this writer and the underlying {@link Sink}.
    *
-   * @throws IOException if the JSON document is incomplete.
+   * @throws JsonDataException if the JSON document is incomplete.
    */
   public void close() throws IOException {
     sink.close();
@@ -611,12 +598,4 @@ public final class JsonWriter implements Closeable, Flushable {
         throw new IllegalStateException("Nesting problem.");
     }
   }
-
-  /**
-   * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
-   * the current location in the JSON value.
-   */
-  public String getPath() {
-    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
-  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
index 6667fc3b..289d034f 100644
--- a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
@@ -63,7 +63,7 @@ final class MapJsonAdapter<K, V> extends JsonAdapter<Map<K, V>> {
       V value = valueAdapter.fromJson(reader);
       V replaced = result.put(name, value);
       if (replaced != null) {
-        throw new IllegalArgumentException("object property '" + name + "' has multiple values");
+        throw new JsonDataException("object property '" + name + "' has multiple values");
       }
     }
     reader.endObject();
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index 53eed502..baaa4ce2 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -59,7 +59,7 @@ final class StandardJsonAdapters {
       throws IOException {
     int value = reader.nextInt();
     if (value < min || value > max) {
-      throw new NumberFormatException(
+      throw new JsonDataException(
           String.format(ERROR_FORMAT, typeMessage, value, reader.getPath()));
     }
     return value;
@@ -89,7 +89,7 @@ final class StandardJsonAdapters {
     @Override public Character fromJson(JsonReader reader) throws IOException {
       String value = reader.nextString();
       if (value.length() > 1) {
-        throw new IllegalStateException(
+        throw new JsonDataException(
             String.format(ERROR_FORMAT, "a char", '"' + value + '"', reader.getPath()));
       }
       return value.charAt(0);
@@ -115,7 +115,7 @@ final class StandardJsonAdapters {
       float value = (float) reader.nextDouble();
       // Double check for infinity after float conversion; many doubles > Float.MAX
       if (!reader.isLenient() && Float.isInfinite(value)) {
-        throw new NumberFormatException("JSON forbids NaN and infinities: " + value
+        throw new JsonDataException("JSON forbids NaN and infinities: " + value
             + " at path " + reader.getPath());
       }
       return value;
@@ -178,7 +178,7 @@ final class StandardJsonAdapters {
         try {
           return Enum.valueOf(enumType, name);
         } catch (IllegalArgumentException e) {
-          throw new IllegalStateException("Expected one of "
+          throw new JsonDataException("Expected one of "
               + Arrays.toString(enumType.getEnumConstants()) + " but was " + name + " at path "
               + reader.getPath());
         }
diff --git a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java b/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
index 2de853b6..f864f57d 100644
--- a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
@@ -233,37 +233,6 @@ public final class AdapterMethodsTest {
   @interface Nullable {
   }
 
-  @Test public void adapterThrows() throws Exception {
-    Moshi moshi = new Moshi.Builder()
-        .add(new ExceptionThrowingPointJsonAdapter())
-        .build();
-    JsonAdapter<Point[]> arrayOfPointAdapter = moshi.adapter(Point[].class).lenient();
-    try {
-      arrayOfPointAdapter.toJson(new Point[] { null, null, new Point(0, 0) });
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected.getMessage())
-          .isEqualTo("java.lang.Exception: pointToJson fail! at $[2]");
-    }
-    try {
-      arrayOfPointAdapter.fromJson("[null,null,[0,0]]");
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected.getMessage())
-          .isEqualTo("java.lang.Exception: pointFromJson fail! at $[2]");
-    }
-  }
-
-  static class ExceptionThrowingPointJsonAdapter {
-    @ToJson void pointToJson(JsonWriter writer, Point point) throws Exception {
-      throw new Exception("pointToJson fail!");
-    }
-
-    @FromJson Point pointFromJson(JsonReader reader) throws Exception {
-      throw new Exception("pointFromJson fail!");
-    }
-  }
-
   static class Point {
     final int x;
     final int y;
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java b/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java
index bff9a4c8..aec035a4 100644
--- a/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java
@@ -216,16 +216,16 @@ public final class JsonReaderTest {
     }
   }
 
-  @Test public void emptyString() {
+  @Test public void emptyString() throws Exception {
     try {
       newReader("").beginArray();
       fail();
-    } catch (IOException expected) {
+    } catch (EOFException expected) {
     }
     try {
       newReader("").beginObject();
       fail();
-    } catch (IOException expected) {
+    } catch (EOFException expected) {
     }
   }
 
@@ -290,7 +290,7 @@ public final class JsonReaderTest {
     try {
       reader.nextString();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (IOException expected) {
     }
   }
 
@@ -301,7 +301,7 @@ public final class JsonReaderTest {
     try {
       reader.nextString();
       fail();
-    } catch (IOException expected) {
+    } catch (EOFException expected) {
     }
   }
 
@@ -367,7 +367,7 @@ public final class JsonReaderTest {
     try {
       reader.nextDouble();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (IOException expected) {
       assertThat(expected).hasMessageContaining("NaN");
     }
   }
@@ -425,13 +425,13 @@ public final class JsonReaderTest {
     try {
       reader.nextInt();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
     }
     assertThat(reader.nextLong()).isEqualTo(Long.MIN_VALUE);
     try {
       reader.nextInt();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
     }
     assertThat(reader.nextLong()).isEqualTo(Long.MAX_VALUE);
     reader.endArray();
@@ -484,7 +484,7 @@ public final class JsonReaderTest {
     try {
       reader.nextBoolean();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     assertThat(reader.nextString()).isEqualTo("truey");
     reader.endArray();
@@ -544,7 +544,7 @@ public final class JsonReaderTest {
     try {
       reader.nextInt();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     assertThat(reader.nextString()).isEqualTo("12.34e5x");
   }
@@ -573,7 +573,7 @@ public final class JsonReaderTest {
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
     }
   }
 
@@ -585,7 +585,7 @@ public final class JsonReaderTest {
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
     }
   }
 
@@ -601,7 +601,7 @@ public final class JsonReaderTest {
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
     }
   }
 
@@ -617,7 +617,7 @@ public final class JsonReaderTest {
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
     }
     assertThat(reader.nextDouble()).isEqualTo(-9223372036854775809d);
   }
@@ -642,7 +642,7 @@ public final class JsonReaderTest {
     try {
       reader.nextLong();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
     }
     assertThat(reader.nextDouble()).isEqualTo(-92233720368547758080d);
   }
@@ -687,7 +687,7 @@ public final class JsonReaderTest {
     try {
       reader.nextName();
       fail();
-    } catch (IOException expected) {
+    } catch (EOFException expected) {
     }
   }
 
@@ -727,54 +727,54 @@ public final class JsonReaderTest {
     try {
       reader.nextString();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     assertThat(reader.nextName()).isEqualTo("a");
     try {
       reader.nextName();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     try {
       reader.beginArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     try {
       reader.endArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     try {
       reader.beginObject();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     try {
       reader.endObject();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     assertThat(reader.nextBoolean()).isTrue();
     try {
       reader.nextString();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     try {
       reader.nextName();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     try {
       reader.beginArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     try {
       reader.endArray();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
     reader.endObject();
     assertThat(reader.peek()).isEqualTo(JsonReader.Token.END_DOCUMENT);
@@ -787,7 +787,7 @@ public final class JsonReaderTest {
     try {
       reader.nextInt();
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
     }
     assertThat(reader.nextDouble()).isEqualTo(1.5d);
     reader.endArray();
@@ -799,7 +799,7 @@ public final class JsonReaderTest {
     try {
       reader.nextNull();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
   }
 
@@ -809,7 +809,7 @@ public final class JsonReaderTest {
     try {
       reader.nextString();
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
     }
   }
 
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonWriterPathTest.java b/moshi/src/test/java/com/squareup/moshi/JsonWriterPathTest.java
deleted file mode 100644
index 43badd39..00000000
--- a/moshi/src/test/java/com/squareup/moshi/JsonWriterPathTest.java
+++ /dev/null
@@ -1,219 +0,0 @@
-/*
- * Copyright (C) 2014 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.io.IOException;
-import java.math.BigInteger;
-import okio.Buffer;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class JsonWriterPathTest {
-  @Test public void path() throws IOException {
-    JsonWriter writer = new JsonWriter(new Buffer());
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$.");
-    writer.name("a");
-    assertThat(writer.getPath()).isEqualTo("$.a");
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$.a[0]");
-    writer.value(2);
-    assertThat(writer.getPath()).isEqualTo("$.a[1]");
-    writer.value(true);
-    assertThat(writer.getPath()).isEqualTo("$.a[2]");
-    writer.value(false);
-    assertThat(writer.getPath()).isEqualTo("$.a[3]");
-    writer.nullValue();
-    assertThat(writer.getPath()).isEqualTo("$.a[4]");
-    writer.value("b");
-    assertThat(writer.getPath()).isEqualTo("$.a[5]");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$.a[5].");
-    writer.name("c");
-    assertThat(writer.getPath()).isEqualTo("$.a[5].c");
-    writer.value("d");
-    assertThat(writer.getPath()).isEqualTo("$.a[5].c");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$.a[6]");
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$.a[6][0]");
-    writer.value(3);
-    assertThat(writer.getPath()).isEqualTo("$.a[6][1]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$.a[7]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$.a");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$");
-  }
-
-  @Test public void arrayOfObjects() throws IOException {
-    JsonWriter writer = new JsonWriter(new Buffer());
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$[0]");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$[0].");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$[1]");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$[1].");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$[2]");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$[2].");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$[3]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$");
-  }
-
-  @Test public void arrayOfArrays() throws IOException {
-    JsonWriter writer = new JsonWriter(new Buffer());
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$[0]");
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$[0][0]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$[1]");
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$[1][0]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$[2]");
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$[2][0]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$[3]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$");
-  }
-
-  @Test public void objectPath() throws IOException {
-    JsonWriter writer = new JsonWriter(new Buffer());
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$.");
-    writer.name("a");
-    assertThat(writer.getPath()).isEqualTo("$.a");
-    writer.value(1);
-    assertThat(writer.getPath()).isEqualTo("$.a");
-    writer.name("b");
-    assertThat(writer.getPath()).isEqualTo("$.b");
-    writer.value(2);
-    assertThat(writer.getPath()).isEqualTo("$.b");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.close();
-    assertThat(writer.getPath()).isEqualTo("$");
-  }
-
-  @Test public void nestedObjects() throws IOException {
-    JsonWriter writer = new JsonWriter(new Buffer());
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$.");
-    writer.name("a");
-    assertThat(writer.getPath()).isEqualTo("$.a");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$.a.");
-    writer.name("b");
-    assertThat(writer.getPath()).isEqualTo("$.a.b");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$.a.b.");
-    writer.name("c");
-    assertThat(writer.getPath()).isEqualTo("$.a.b.c");
-    writer.nullValue();
-    assertThat(writer.getPath()).isEqualTo("$.a.b.c");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$.a.b");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$.a");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$");
-  }
-
-  @Test public void arrayPath() throws IOException {
-    JsonWriter writer = new JsonWriter(new Buffer());
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$[0]");
-    writer.value(1);
-    assertThat(writer.getPath()).isEqualTo("$[1]");
-    writer.value(true);
-    assertThat(writer.getPath()).isEqualTo("$[2]");
-    writer.value("a");
-    assertThat(writer.getPath()).isEqualTo("$[3]");
-    writer.value(5.5d);
-    assertThat(writer.getPath()).isEqualTo("$[4]");
-    writer.value(BigInteger.ONE);
-    assertThat(writer.getPath()).isEqualTo("$[5]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.close();
-    assertThat(writer.getPath()).isEqualTo("$");
-  }
-
-  @Test public void nestedArrays() throws IOException {
-    JsonWriter writer = new JsonWriter(new Buffer());
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$[0]");
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$[0][0]");
-    writer.beginArray();
-    assertThat(writer.getPath()).isEqualTo("$[0][0][0]");
-    writer.nullValue();
-    assertThat(writer.getPath()).isEqualTo("$[0][0][1]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$[0][1]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$[1]");
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.close();
-    assertThat(writer.getPath()).isEqualTo("$");
-  }
-
-  @Test public void multipleTopLevelValuesInOneDocument() throws IOException {
-    JsonWriter writer = new JsonWriter(new Buffer());
-    writer.setLenient(true);
-    writer.beginArray();
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.beginArray();
-    writer.endArray();
-    assertThat(writer.getPath()).isEqualTo("$");
-  }
-
-  @Test public void skipNulls() throws IOException {
-    JsonWriter writer = new JsonWriter(new Buffer());
-    writer.setSerializeNulls(false);
-    assertThat(writer.getPath()).isEqualTo("$");
-    writer.beginObject();
-    assertThat(writer.getPath()).isEqualTo("$.");
-    writer.name("a");
-    assertThat(writer.getPath()).isEqualTo("$.a");
-    writer.nullValue();
-    assertThat(writer.getPath()).isEqualTo("$.a");
-    writer.name("b");
-    assertThat(writer.getPath()).isEqualTo("$.b");
-    writer.nullValue();
-    assertThat(writer.getPath()).isEqualTo("$.b");
-    writer.endObject();
-    assertThat(writer.getPath()).isEqualTo("$");
-  }
-}
diff --git a/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java b/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java
index eb3b77f6..f5860ee2 100644
--- a/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java
@@ -103,7 +103,7 @@ public final class MapJsonAdapterTest {
     try {
       fromJson(String.class, Integer.class, "{\"c\":1,\"c\":2}");
       fail();
-    } catch (IllegalArgumentException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("object property 'c' has multiple values");
     }
   }
diff --git a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
index 8d20eeda..23c0d5bb 100644
--- a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
@@ -50,7 +50,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson("null");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a boolean but was NULL at path $");
     }
 
@@ -93,14 +93,14 @@ public final class MoshiTest {
     try {
       adapter.fromJson("256");
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a byte but was 256 at path $");
     }
 
     try {
       adapter.fromJson("-129");
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a byte but was -129 at path $");
     }
 
@@ -108,7 +108,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson("null");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected an int but was NULL at path $");
     }
 
@@ -189,7 +189,7 @@ public final class MoshiTest {
       // Only a single character is allowed.
       adapter.fromJson("'ab'");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a char but was \"ab\" at path $");
     }
 
@@ -197,7 +197,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson("null");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a string but was NULL at path $");
     }
 
@@ -219,7 +219,7 @@ public final class MoshiTest {
       // Only a single character is allowed.
       adapter.fromJson("'ab'");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a char but was \"ab\" at path $");
     }
 
@@ -253,7 +253,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson("null");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a double but was NULL at path $");
     }
 
@@ -270,7 +270,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson(reader);
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (IOException expected) {
       assertThat(expected).hasMessage("JSON forbids NaN and infinities: Infinity at path $[0]");
     }
 
@@ -279,7 +279,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson(reader);
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (IOException expected) {
       assertThat(expected).hasMessage("JSON forbids NaN and infinities: -Infinity at path $[0]");
     }
   }
@@ -321,7 +321,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson("null");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a double but was NULL at path $");
     }
 
@@ -338,7 +338,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson(reader);
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("JSON forbids NaN and infinities: Infinity at path $[1]");
     }
 
@@ -347,7 +347,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson(reader);
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("JSON forbids NaN and infinities: -Infinity at path $[1]");
     }
   }
@@ -379,14 +379,14 @@ public final class MoshiTest {
     try {
       adapter.fromJson("2147483648");
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected an int but was 2147483648 at path $");
     }
 
     try {
       adapter.fromJson("-2147483649");
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected an int but was -2147483649 at path $");
     }
 
@@ -394,7 +394,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson("null");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected an int but was NULL at path $");
     }
 
@@ -447,7 +447,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson("null");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a long but was NULL at path $");
     }
 
@@ -483,14 +483,14 @@ public final class MoshiTest {
     try {
       adapter.fromJson("32768");
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a short but was 32768 at path $");
     }
 
     try {
       adapter.fromJson("-32769");
       fail();
-    } catch (NumberFormatException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected a short but was -32769 at path $");
     }
 
@@ -498,7 +498,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson("null");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage("Expected an int but was NULL at path $");
     }
 
@@ -676,7 +676,7 @@ public final class MoshiTest {
     try {
       adapter.fromJson("\"SPOCK\"");
       fail();
-    } catch (IllegalStateException expected) {
+    } catch (JsonDataException expected) {
       assertThat(expected).hasMessage(
           "Expected one of [ROCK, PAPER, SCISSORS] but was SPOCK at path $");
     }
