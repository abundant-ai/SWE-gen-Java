diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
index aadc8666..e33e1f38 100644
--- a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
@@ -59,7 +59,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
             throw new AssertionError();
           } catch (InvocationTargetException e) {
             if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause()); // TODO: more context?
+            throw new JsonDataException(e.getCause() + " at " + writer.getPath());
           }
         }
       }
@@ -77,7 +77,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
             throw new AssertionError();
           } catch (InvocationTargetException e) {
             if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause()); // TODO: more context?
+            throw new JsonDataException(e.getCause() + " at " + reader.getPath());
           }
         }
       }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonDataException.java b/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
index a8463055..e3fe4ebd 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
@@ -15,14 +15,7 @@
  */
 package com.squareup.moshi;
 
-/**
- * Thrown when the data in a JSON document doesn't match the data expected by the caller. For
- * example, suppose the application expects a boolean but the JSON document contains a string. When
- * the call to {@link JsonReader#nextBoolean} is made, a {@code JsonDataException} is thrown.
- *
- * <p>Exceptions of this type should be fixed by either changing the application code to accept
- * the unexpected JSON, or by changing the JSON to conform to the application's expectations.
- */
+/** Thrown when a JSON document doesn't match the expected format. */
 public final class JsonDataException extends RuntimeException {
   public JsonDataException() {
   }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index 272c8e39..76b1a337 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -248,14 +248,6 @@ public final class JsonReader implements Closeable {
     stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
   }
 
-  /*
-   * The path members. It corresponds directly to stack: At indices where the
-   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),
-   * pathNames contains the name at this scope. Where it contains an array
-   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in
-   * that array. Otherwise the value is undefined, and we take advantage of that
-   * by incrementing pathIndices when doing so isn't useful.
-   */
   private String[] pathNames = new String[32];
   private int[] pathIndices = new int[32];
 
@@ -311,8 +303,8 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Consumes the next token from the JSON stream and asserts that it is the beginning of a new
-   * array.
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * beginning of a new array.
    */
   public void beginArray() throws IOException {
     int p = peeked;
@@ -324,7 +316,7 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1] = 0;
       peeked = PEEKED_NONE;
     } else {
-      throw new JsonDataException("Expected BEGIN_ARRAY but was " + peek()
+      throw new IllegalStateException("Expected BEGIN_ARRAY but was " + peek()
           + " at path " + getPath());
     }
   }
@@ -343,14 +335,14 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new JsonDataException("Expected END_ARRAY but was " + peek()
+      throw new IllegalStateException("Expected END_ARRAY but was " + peek()
           + " at path " + getPath());
     }
   }
 
   /**
-   * Consumes the next token from the JSON stream and asserts that it is the beginning of a new
-   * object.
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * beginning of a new object.
    */
   public void beginObject() throws IOException {
     int p = peeked;
@@ -361,14 +353,14 @@ public final class JsonReader implements Closeable {
       push(JsonScope.EMPTY_OBJECT);
       peeked = PEEKED_NONE;
     } else {
-      throw new JsonDataException("Expected BEGIN_OBJECT but was " + peek()
+      throw new IllegalStateException("Expected BEGIN_OBJECT but was " + peek()
           + " at path " + getPath());
     }
   }
 
   /**
-   * Consumes the next token from the JSON stream and asserts that it is the end of the current
-   * object.
+   * Consumes the next token from the JSON stream and asserts that it is the
+   * end of the current object.
    */
   public void endObject() throws IOException {
     int p = peeked;
@@ -381,7 +373,7 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1]++;
       peeked = PEEKED_NONE;
     } else {
-      throw new JsonDataException("Expected END_OBJECT but was " + peek()
+      throw new IllegalStateException("Expected END_OBJECT but was " + peek()
           + " at path " + getPath());
     }
   }
@@ -744,9 +736,11 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the next token, a {@link Token#NAME property name}, and consumes it.
+   * Returns the next token, a {@link Token#NAME property name}, and
+   * consumes it.
    *
-   * @throws JsonDataException if the next token in the stream is not a property name.
+   * @throws java.io.IOException if the next token in the stream is not a property
+   *     name.
    */
   public String nextName() throws IOException {
     int p = peeked;
@@ -761,7 +755,8 @@ public final class JsonReader implements Closeable {
     } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
       result = nextQuotedValue(SINGLE_QUOTE_OR_SLASH);
     } else {
-      throw new JsonDataException("Expected a name but was " + peek() + " at path " + getPath());
+      throw new IllegalStateException("Expected a name but was " + peek()
+          + " at path " + getPath());
     }
     peeked = PEEKED_NONE;
     pathNames[stackSize - 1] = result;
@@ -769,10 +764,12 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the {@link Token#STRING string} value of the next token, consuming it. If the next
-   * token is a number, this method will return its string form.
+   * Returns the {@link Token#STRING string} value of the next token,
+   * consuming it. If the next token is a number, this method will return its
+   * string form.
    *
-   * @throws JsonDataException if the next token is not a string or if this reader is closed.
+   * @throws IllegalStateException if the next token is not a string or if
+   *     this reader is closed.
    */
   public String nextString() throws IOException {
     int p = peeked;
@@ -794,7 +791,8 @@ public final class JsonReader implements Closeable {
     } else if (p == PEEKED_NUMBER) {
       result = buffer.readUtf8(peekedNumberLength);
     } else {
-      throw new JsonDataException("Expected a string but was " + peek() + " at path " + getPath());
+      throw new IllegalStateException("Expected a string but was " + peek()
+          + " at path " + getPath());
     }
     peeked = PEEKED_NONE;
     pathIndices[stackSize - 1]++;
@@ -802,9 +800,11 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the {@link Token#BOOLEAN boolean} value of the next token, consuming it.
+   * Returns the {@link Token#BOOLEAN boolean} value of the next token,
+   * consuming it.
    *
-   * @throws JsonDataException if the next token is not a boolean or if this reader is closed.
+   * @throws IllegalStateException if the next token is not a boolean or if
+   *     this reader is closed.
    */
   public boolean nextBoolean() throws IOException {
     int p = peeked;
@@ -820,14 +820,16 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1]++;
       return false;
     }
-    throw new JsonDataException("Expected a boolean but was " + peek() + " at path " + getPath());
+    throw new IllegalStateException("Expected a boolean but was " + peek()
+        + " at path " + getPath());
   }
 
   /**
-   * Consumes the next token from the JSON stream and asserts that it is a literal null. Returns
-   * null.
+   * Consumes the next token from the JSON stream and asserts that it is a
+   * literal null. Returns null.
    *
-   * @throws JsonDataException if the next token is not null or if this reader is closed.
+   * @throws IllegalStateException if the next token is not null or if this
+   *     reader is closed.
    */
   public <T> T nextNull() throws IOException {
     int p = peeked;
@@ -839,17 +841,19 @@ public final class JsonReader implements Closeable {
       pathIndices[stackSize - 1]++;
       return null;
     } else {
-      throw new JsonDataException("Expected null but was " + peek() + " at path " + getPath());
+      throw new IllegalStateException("Expected null but was " + peek()
+          + " at path " + getPath());
     }
   }
 
   /**
-   * Returns the {@link Token#NUMBER double} value of the next token, consuming it. If the next
-   * token is a string, this method will attempt to parse it as a double using {@link
-   * Double#parseDouble(String)}.
+   * Returns the {@link Token#NUMBER double} value of the next token,
+   * consuming it. If the next token is a string, this method will attempt to
+   * parse it as a double using {@link Double#parseDouble(String)}.
    *
-   * @throws JsonDataException if the next token is not a literal value, or if the next literal
-   *     value cannot be parsed as a double, or is non-finite.
+   * @throws IllegalStateException if the next token is not a literal value.
+   * @throws NumberFormatException if the next literal value cannot be parsed
+   *     as a double, or is non-finite.
    */
   public double nextDouble() throws IOException {
     int p = peeked;
@@ -872,19 +876,14 @@ public final class JsonReader implements Closeable {
     } else if (p == PEEKED_UNQUOTED) {
       peekedString = nextUnquotedValue();
     } else if (p != PEEKED_BUFFERED) {
-      throw new JsonDataException("Expected a double but was " + peek() + " at path " + getPath());
+      throw new IllegalStateException("Expected a double but was " + peek()
+          + " at path " + getPath());
     }
 
     peeked = PEEKED_BUFFERED;
-    double result;
-    try {
-      result = Double.parseDouble(peekedString);
-    } catch (NumberFormatException e) {
-      throw new JsonDataException("Expected a double but was " + peekedString
-          + " at path " + getPath());
-    }
+    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
-      throw new IOException("JSON forbids NaN and infinities: " + result
+      throw new NumberFormatException("JSON forbids NaN and infinities: " + result
           + " at path " + getPath());
     }
     peekedString = null;
@@ -894,12 +893,14 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the {@link Token#NUMBER long} value of the next token, consuming it. If the next token
-   * is a string, this method will attempt to parse it as a long. If the next token's numeric value
-   * cannot be exactly represented by a Java {@code long}, this method throws.
+   * Returns the {@link Token#NUMBER long} value of the next token,
+   * consuming it. If the next token is a string, this method will attempt to
+   * parse it as a long. If the next token's numeric value cannot be exactly
+   * represented by a Java {@code long}, this method throws.
    *
-   * @throws JsonDataException if the next token is not a literal value, if the next literal value
-   *     cannot be parsed as a number, or exactly represented as a long.
+   * @throws IllegalStateException if the next token is not a literal value.
+   * @throws NumberFormatException if the next literal value cannot be parsed
+   *     as a number, or exactly represented as a long.
    */
   public long nextLong() throws IOException {
     int p = peeked;
@@ -928,21 +929,15 @@ public final class JsonReader implements Closeable {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new JsonDataException("Expected a long but was " + peek()
+      throw new IllegalStateException("Expected a long but was " + peek()
           + " at path " + getPath());
     }
 
     peeked = PEEKED_BUFFERED;
-    double asDouble;
-    try {
-      asDouble = Double.parseDouble(peekedString);
-    } catch (NumberFormatException e) {
-      throw new JsonDataException("Expected a long but was " + peekedString
-          + " at path " + getPath());
-    }
+    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     long result = (long) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.
-      throw new JsonDataException("Expected a long but was " + peekedString
+      throw new NumberFormatException("Expected a long but was " + peekedString
           + " at path " + getPath());
     }
     peekedString = null;
@@ -952,11 +947,13 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the string up to but not including {@code quote}, unescaping any character escape
-   * sequences encountered along the way. The opening quote should have already been read. This
-   * consumes the closing quote, but does not include it in the returned string.
+   * Returns the string up to but not including {@code quote}, unescaping any
+   * character escape sequences encountered along the way. The opening quote
+   * should have already been read. This consumes the closing quote, but does
+   * not include it in the returned string.
    *
-   * @throws IOException if any unicode escape sequences are malformed.
+   * @throws NumberFormatException if any unicode escape sequences are
+   *     malformed.
    */
   private String nextQuotedValue(ByteString runTerminator) throws IOException {
     StringBuilder builder = null;
@@ -1013,12 +1010,14 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Returns the {@link Token#NUMBER int} value of the next token, consuming it. If the next token
-   * is a string, this method will attempt to parse it as an int. If the next token's numeric value
-   * cannot be exactly represented by a Java {@code int}, this method throws.
+   * Returns the {@link Token#NUMBER int} value of the next token,
+   * consuming it. If the next token is a string, this method will attempt to
+   * parse it as an int. If the next token's numeric value cannot be exactly
+   * represented by a Java {@code int}, this method throws.
    *
-   * @throws JsonDataException if the next token is not a literal value, if the next literal value
-   *     cannot be parsed as a number, or exactly represented as an int.
+   * @throws IllegalStateException if the next token is not a literal value.
+   * @throws NumberFormatException if the next literal value cannot be parsed
+   *     as a number, or exactly represented as an int.
    */
   public int nextInt() throws IOException {
     int p = peeked;
@@ -1030,7 +1029,7 @@ public final class JsonReader implements Closeable {
     if (p == PEEKED_LONG) {
       result = (int) peekedLong;
       if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
-        throw new JsonDataException("Expected an int but was " + peekedLong
+        throw new NumberFormatException("Expected an int but was " + peekedLong
             + " at path " + getPath());
       }
       peeked = PEEKED_NONE;
@@ -1053,20 +1052,15 @@ public final class JsonReader implements Closeable {
         // Fall back to parse as a double below.
       }
     } else {
-      throw new JsonDataException("Expected an int but was " + peek() + " at path " + getPath());
+      throw new IllegalStateException("Expected an int but was " + peek()
+          + " at path " + getPath());
     }
 
     peeked = PEEKED_BUFFERED;
-    double asDouble;
-    try {
-      asDouble = Double.parseDouble(peekedString);
-    } catch (NumberFormatException e) {
-      throw new JsonDataException("Expected an int but was " + peekedString
-          + " at path " + getPath());
-    }
+    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.
     result = (int) asDouble;
     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
-      throw new JsonDataException("Expected an int but was " + peekedString
+      throw new NumberFormatException("Expected an int but was " + peekedString
           + " at path " + getPath());
     }
     peekedString = null;
@@ -1087,9 +1081,9 @@ public final class JsonReader implements Closeable {
   }
 
   /**
-   * Skips the next value recursively. If it is an object or array, all nested elements are skipped.
-   * This method is intended for use when the JSON token stream contains unrecognized or unhandled
-   * values.
+   * Skips the next value recursively. If it is an object or array, all nested
+   * elements are skipped. This method is intended for use when the JSON token
+   * stream contains unrecognized or unhandled values.
    */
   public void skipValue() throws IOException {
     int count = 0;
@@ -1267,38 +1261,17 @@ public final class JsonReader implements Closeable {
    * the current location in the JSON value.
    */
   public String getPath() {
-    StringBuilder result = new StringBuilder().append('$');
-    for (int i = 0, size = stackSize; i < size; i++) {
-      switch (stack[i]) {
-        case JsonScope.EMPTY_ARRAY:
-        case JsonScope.NONEMPTY_ARRAY:
-          result.append('[').append(pathIndices[i]).append(']');
-          break;
-
-        case JsonScope.EMPTY_OBJECT:
-        case JsonScope.DANGLING_NAME:
-        case JsonScope.NONEMPTY_OBJECT:
-          result.append('.');
-          if (pathNames[i] != null) {
-            result.append(pathNames[i]);
-          }
-          break;
-
-        case JsonScope.NONEMPTY_DOCUMENT:
-        case JsonScope.EMPTY_DOCUMENT:
-        case JsonScope.CLOSED:
-          break;
-      }
-    }
-    return result.toString();
+    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
   }
 
   /**
-   * Unescapes the character identified by the character or characters that immediately follow a
-   * backslash. The backslash '\' should have already been read. This supports both unicode escapes
-   * "u000A" and two-character escapes "\n".
+   * Unescapes the character identified by the character or characters that
+   * immediately follow a backslash. The backslash '\' should have already
+   * been read. This supports both unicode escapes "u000A" and two-character
+   * escapes "\n".
    *
-   * @throws IOException if any unicode escape sequences are malformed.
+   * @throws NumberFormatException if any unicode escape sequences are
+   *     malformed.
    */
   private char readEscapeCharacter() throws IOException {
     if (!fillBuffer(1)) {
@@ -1309,7 +1282,7 @@ public final class JsonReader implements Closeable {
     switch (escaped) {
       case 'u':
         if (!fillBuffer(4)) {
-          throw new EOFException("Unterminated escape sequence at path " + getPath());
+          throw syntaxError("Unterminated escape sequence");
         }
         // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
         char result = 0;
@@ -1323,7 +1296,7 @@ public final class JsonReader implements Closeable {
           } else if (c >= 'A' && c <= 'F') {
             result += (c - 'A' + 10);
           } else {
-            throw syntaxError("\\u" + buffer.readUtf8(4));
+            throw new NumberFormatException("\\u" + buffer.readUtf8(4));
           }
         }
         buffer.skip(4);
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonScope.java b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
index 776d7251..180839ad 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonScope.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonScope.java
@@ -15,53 +15,65 @@
  */
 package com.squareup.moshi;
 
-/**
- * Lexical scoping elements within a JSON reader or writer.
- */
+/** Lexical scoping elements within a JSON reader or writer. */
 final class JsonScope {
 
-  /**
-   * An array with no elements requires no separators or newlines before
-   * it is closed.
-   */
+  /** An array with no elements requires no separators or newlines before it is closed. */
   static final int EMPTY_ARRAY = 1;
 
-  /**
-   * A array with at least one value requires a comma and newline before
-   * the next element.
-   */
+  /** A array with at least one value requires a comma and newline before the next element. */
   static final int NONEMPTY_ARRAY = 2;
 
-  /**
-   * An object with no name/value pairs requires no separators or newlines
-   * before it is closed.
-   */
+  /** An object with no name/value pairs requires no separators or newlines before it is closed. */
   static final int EMPTY_OBJECT = 3;
 
-  /**
-   * An object whose most recent element is a key. The next element must
-   * be a value.
-   */
+  /** An object whose most recent element is a key. The next element must be a value. */
   static final int DANGLING_NAME = 4;
 
-  /**
-   * An object with at least one name/value pair requires a comma and
-   * newline before the next element.
-   */
+  /** An object with at least one name/value pair requires a separator before the next element. */
   static final int NONEMPTY_OBJECT = 5;
 
-  /**
-   * No object or array has been started.
-   */
+  /** No object or array has been started. */
   static final int EMPTY_DOCUMENT = 6;
 
-  /**
-   * A document with at an array or object.
-   */
+  /** A document with at an array or object. */
   static final int NONEMPTY_DOCUMENT = 7;
 
+  /** A document that's been closed and cannot be accessed. */
+  static final int CLOSED = 8;
+
   /**
-   * A document that's been closed and cannot be accessed.
+   * Renders the path in a JSON document to a string. The {@code pathNames} and {@code pathIndices}
+   * parameters corresponds directly to stack: At indices where the stack contains an object
+   * (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT), pathNames contains the name at this scope.
+   * Where it contains an array (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index
+   * in that array. Otherwise the value is undefined, and we take advantage of that by incrementing
+   * pathIndices when doing so isn't useful.
    */
-  static final int CLOSED = 8;
+  static String getPath(int stackSize, int[] stack, String[] pathNames, int[] pathIndices) {
+    StringBuilder result = new StringBuilder().append('$');
+    for (int i = 0, size = stackSize; i < size; i++) {
+      switch (stack[i]) {
+        case EMPTY_ARRAY:
+        case NONEMPTY_ARRAY:
+          result.append('[').append(pathIndices[i]).append(']');
+          break;
+
+        case EMPTY_OBJECT:
+        case DANGLING_NAME:
+        case NONEMPTY_OBJECT:
+          result.append('.');
+          if (pathNames[i] != null) {
+            result.append(pathNames[i]);
+          }
+          break;
+
+        case NONEMPTY_DOCUMENT:
+        case EMPTY_DOCUMENT:
+        case CLOSED:
+          break;
+      }
+    }
+    return result.toString();
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index da3de7bc..e22bc55b 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -160,6 +160,9 @@ public final class JsonWriter implements Closeable, Flushable {
     push(EMPTY_DOCUMENT);
   }
 
+  private String[] pathNames = new String[32];
+  private int[] pathIndices = new int[32];
+
   /**
    * A string containing a full set of spaces for a single level of
    * indentation, or null for no pretty printing.
@@ -290,6 +293,7 @@ public final class JsonWriter implements Closeable, Flushable {
    */
   private JsonWriter open(int empty, String openBracket) throws IOException {
     beforeValue(true);
+    pathIndices[stackSize] = 0;
     push(empty);
     sink.writeUtf8(openBracket);
     return this;
@@ -310,6 +314,8 @@ public final class JsonWriter implements Closeable, Flushable {
     }
 
     stackSize--;
+    pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
+    pathIndices[stackSize - 1]++;
     if (context == nonempty) {
       newline();
     }
@@ -353,13 +359,14 @@ public final class JsonWriter implements Closeable, Flushable {
     if (name == null) {
       throw new NullPointerException("name == null");
     }
-    if (stackSize == 0) {
-      throw new IllegalStateException("JsonWriter is closed.");
-    }
     if (deferredName != null) {
       throw new IllegalStateException();
     }
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
     deferredName = name;
+    pathNames[stackSize - 1] = name;
     return this;
   }
 
@@ -384,6 +391,7 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     string(value);
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -403,6 +411,7 @@ public final class JsonWriter implements Closeable, Flushable {
     }
     beforeValue(false);
     sink.writeUtf8("null");
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -415,6 +424,7 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(value ? "true" : "false");
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -432,6 +442,7 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Double.toString(value));
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -444,6 +455,7 @@ public final class JsonWriter implements Closeable, Flushable {
     writeDeferredName();
     beforeValue(false);
     sink.writeUtf8(Long.toString(value));
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -467,6 +479,7 @@ public final class JsonWriter implements Closeable, Flushable {
     }
     beforeValue(false);
     sink.writeUtf8(string);
+    pathIndices[stackSize - 1]++;
     return this;
   }
 
@@ -484,7 +497,7 @@ public final class JsonWriter implements Closeable, Flushable {
   /**
    * Flushes and closes this writer and the underlying {@link Sink}.
    *
-   * @throws JsonDataException if the JSON document is incomplete.
+   * @throws IOException if the JSON document is incomplete.
    */
   public void close() throws IOException {
     sink.close();
@@ -598,4 +611,12 @@ public final class JsonWriter implements Closeable, Flushable {
         throw new IllegalStateException("Nesting problem.");
     }
   }
+
+  /**
+   * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
+   * the current location in the JSON value.
+   */
+  public String getPath() {
+    return JsonScope.getPath(stackSize, stack, pathNames, pathIndices);
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
index 289d034f..6667fc3b 100644
--- a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
@@ -63,7 +63,7 @@ final class MapJsonAdapter<K, V> extends JsonAdapter<Map<K, V>> {
       V value = valueAdapter.fromJson(reader);
       V replaced = result.put(name, value);
       if (replaced != null) {
-        throw new JsonDataException("object property '" + name + "' has multiple values");
+        throw new IllegalArgumentException("object property '" + name + "' has multiple values");
       }
     }
     reader.endObject();
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index baaa4ce2..53eed502 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -59,7 +59,7 @@ final class StandardJsonAdapters {
       throws IOException {
     int value = reader.nextInt();
     if (value < min || value > max) {
-      throw new JsonDataException(
+      throw new NumberFormatException(
           String.format(ERROR_FORMAT, typeMessage, value, reader.getPath()));
     }
     return value;
@@ -89,7 +89,7 @@ final class StandardJsonAdapters {
     @Override public Character fromJson(JsonReader reader) throws IOException {
       String value = reader.nextString();
       if (value.length() > 1) {
-        throw new JsonDataException(
+        throw new IllegalStateException(
             String.format(ERROR_FORMAT, "a char", '"' + value + '"', reader.getPath()));
       }
       return value.charAt(0);
@@ -115,7 +115,7 @@ final class StandardJsonAdapters {
       float value = (float) reader.nextDouble();
       // Double check for infinity after float conversion; many doubles > Float.MAX
       if (!reader.isLenient() && Float.isInfinite(value)) {
-        throw new JsonDataException("JSON forbids NaN and infinities: " + value
+        throw new NumberFormatException("JSON forbids NaN and infinities: " + value
             + " at path " + reader.getPath());
       }
       return value;
@@ -178,7 +178,7 @@ final class StandardJsonAdapters {
         try {
           return Enum.valueOf(enumType, name);
         } catch (IllegalArgumentException e) {
-          throw new JsonDataException("Expected one of "
+          throw new IllegalStateException("Expected one of "
               + Arrays.toString(enumType.getEnumConstants()) + " but was " + name + " at path "
               + reader.getPath());
         }
