diff --git a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
index 913d2ca9d..931516c80 100644
--- a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
+++ b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
@@ -509,7 +509,7 @@ sealed abstract private[data] class NonEmptyLazyListInstances extends NonEmptyLa
 
   implicit val catsDataInstancesForNonEmptyLazyList: Bimonad[NonEmptyLazyList]
     with NonEmptyTraverse[NonEmptyLazyList]
-    with SemigroupK[NonEmptyLazyList]
+    with NonEmptyAlternative[NonEmptyLazyList]
     with Align[NonEmptyLazyList] =
     new AbstractNonEmptyInstances[LazyList, NonEmptyLazyList] with Align[NonEmptyLazyList] {
 
diff --git a/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala b/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala
index 7c22a21bf..dba28aa71 100644
--- a/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala
+++ b/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala
@@ -26,17 +26,23 @@ abstract private[data] class AbstractNonEmptyInstances[F[_], NonEmptyF[_]](impli
   MF: Monad[F],
   CF: CoflatMap[F],
   TF: Traverse[F],
-  SF: SemigroupK[F]
+  SF: Alternative[F]
 ) extends Bimonad[NonEmptyF]
     with NonEmptyTraverse[NonEmptyF]
-    with SemigroupK[NonEmptyF] {
+    with NonEmptyAlternative[NonEmptyF] {
   val monadInstance = MF.asInstanceOf[Monad[NonEmptyF]]
   val coflatMapInstance = CF.asInstanceOf[CoflatMap[NonEmptyF]]
   val traverseInstance = Traverse[F].asInstanceOf[Traverse[NonEmptyF]]
-  val semiGroupKInstance = SemigroupK[F].asInstanceOf[SemigroupK[NonEmptyF]]
+  val alternativeInstance = Alternative[F].asInstanceOf[Alternative[NonEmptyF]]
 
   def combineK[A](a: NonEmptyF[A], b: NonEmptyF[A]): NonEmptyF[A] =
-    semiGroupKInstance.combineK(a, b)
+    alternativeInstance.combineK(a, b)
+
+  override def prependK[A](a: A, fa: NonEmptyF[A]): NonEmptyF[A] =
+    alternativeInstance.prependK(a, fa)
+
+  override def appendK[A](fa: NonEmptyF[A], a: A): NonEmptyF[A] =
+    alternativeInstance.appendK(fa, a)
 
   def pure[A](x: A): NonEmptyF[A] = monadInstance.pure(x)
 
diff --git a/core/src/main/scala/cats/data/NonEmptyChain.scala b/core/src/main/scala/cats/data/NonEmptyChain.scala
index 74a434832..19260167e 100644
--- a/core/src/main/scala/cats/data/NonEmptyChain.scala
+++ b/core/src/main/scala/cats/data/NonEmptyChain.scala
@@ -617,10 +617,20 @@ class NonEmptyChainOps[A](private val value: NonEmptyChain[A])
 
 sealed abstract private[data] class NonEmptyChainInstances extends NonEmptyChainInstances1 {
 
-  implicit val catsDataInstancesForNonEmptyChain: SemigroupK[NonEmptyChain]
+  @deprecated(
+    "maintained for the sake of binary compatibility only, use catsDataInstancesForNonEmptyChainBinCompat1 instead",
+    "2.9.0"
+  )
+  def catsDataInstancesForNonEmptyChain: SemigroupK[NonEmptyChain]
     with NonEmptyTraverse[NonEmptyChain]
     with Bimonad[NonEmptyChain]
     with Align[NonEmptyChain] =
+    catsDataInstancesForNonEmptyChainBinCompat1
+
+  implicit val catsDataInstancesForNonEmptyChainBinCompat1: Align[NonEmptyChain]
+    with Bimonad[NonEmptyChain]
+    with NonEmptyAlternative[NonEmptyChain]
+    with NonEmptyTraverse[NonEmptyChain] =
     new AbstractNonEmptyInstances[Chain, NonEmptyChain] with Align[NonEmptyChain] {
       def extract[A](fa: NonEmptyChain[A]): A = fa.head
 
diff --git a/core/src/main/scala/cats/data/NonEmptyList.scala b/core/src/main/scala/cats/data/NonEmptyList.scala
index a19389567..8a4b41a3a 100644
--- a/core/src/main/scala/cats/data/NonEmptyList.scala
+++ b/core/src/main/scala/cats/data/NonEmptyList.scala
@@ -788,16 +788,26 @@ object NonEmptyList extends NonEmptyListInstances {
 
 sealed abstract private[data] class NonEmptyListInstances extends NonEmptyListInstances0 {
 
+  @deprecated(
+    "maintained for the sake of binary compatibility only - use catsDataInstancesForNonEmptyListBinCompat1 instead",
+    "2.9.0"
+  )
+  def catsDataInstancesForNonEmptyList
+    : SemigroupK[NonEmptyList] with Bimonad[NonEmptyList] with NonEmptyTraverse[NonEmptyList] with Align[NonEmptyList] =
+    catsDataInstancesForNonEmptyListBinCompat1
+
   /**
    * This is not a bug. The declared type of `catsDataInstancesForNonEmptyList` intentionally ignores
    * `NonEmptyReducible` trait for it not being a typeclass.
    *
    * Also see the discussion: PR #3541 and issue #3069.
    */
-  implicit val catsDataInstancesForNonEmptyList
-    : SemigroupK[NonEmptyList] with Bimonad[NonEmptyList] with NonEmptyTraverse[NonEmptyList] with Align[NonEmptyList] =
+  implicit val catsDataInstancesForNonEmptyListBinCompat1: NonEmptyAlternative[NonEmptyList]
+    with Bimonad[NonEmptyList]
+    with NonEmptyTraverse[NonEmptyList]
+    with Align[NonEmptyList] =
     new NonEmptyReducible[NonEmptyList, List]
-      with SemigroupK[NonEmptyList]
+      with NonEmptyAlternative[NonEmptyList]
       with Bimonad[NonEmptyList]
       with NonEmptyTraverse[NonEmptyList]
       with Align[NonEmptyList] {
@@ -805,6 +815,12 @@ sealed abstract private[data] class NonEmptyListInstances extends NonEmptyListIn
       def combineK[A](a: NonEmptyList[A], b: NonEmptyList[A]): NonEmptyList[A] =
         a.concatNel(b)
 
+      override def prependK[A](a: A, fa: NonEmptyList[A]): NonEmptyList[A] =
+        fa.prepend(a)
+
+      override def appendK[A](fa: NonEmptyList[A], a: A): NonEmptyList[A] =
+        fa.append(a)
+
       override def split[A](fa: NonEmptyList[A]): (A, List[A]) = (fa.head, fa.tail)
 
       override def reduceLeft[A](fa: NonEmptyList[A])(f: (A, A) => A): A =
@@ -955,7 +971,7 @@ sealed abstract private[data] class NonEmptyListInstances extends NonEmptyListIn
     new NonEmptyParallel[NonEmptyList] {
       type F[x] = ZipNonEmptyList[x]
 
-      def flatMap: FlatMap[NonEmptyList] = NonEmptyList.catsDataInstancesForNonEmptyList
+      def flatMap: FlatMap[NonEmptyList] = NonEmptyList.catsDataInstancesForNonEmptyListBinCompat1
 
       def apply: Apply[ZipNonEmptyList] = ZipNonEmptyList.catsDataCommutativeApplyForZipNonEmptyList
 
diff --git a/core/src/main/scala/cats/data/NonEmptySeq.scala b/core/src/main/scala/cats/data/NonEmptySeq.scala
index 6d18a21d4..ccc405bc1 100644
--- a/core/src/main/scala/cats/data/NonEmptySeq.scala
+++ b/core/src/main/scala/cats/data/NonEmptySeq.scala
@@ -381,16 +381,26 @@ final class NonEmptySeq[+A] private (val toSeq: Seq[A]) extends AnyVal with NonE
 @suppressUnusedImportWarningForScalaVersionSpecific
 sealed abstract private[data] class NonEmptySeqInstances {
 
+  @deprecated(
+    "maintained for the sake of binary compatibility only - use catsDataInstancesForNonEmptySeqBinCompat1 instead",
+    "2.9.0"
+  )
+  def catsDataInstancesForNonEmptySeq
+    : SemigroupK[NonEmptySeq] with Bimonad[NonEmptySeq] with NonEmptyTraverse[NonEmptySeq] with Align[NonEmptySeq] =
+    catsDataInstancesForNonEmptySeqBinCompat1
+
   /**
    * This is not a bug. The declared type of `catsDataInstancesForNonEmptySeq` intentionally ignores
    * `NonEmptyReducible` trait for it not being a typeclass.
    *
    * Also see the discussion: PR #3541 and issue #3069.
    */
-  implicit val catsDataInstancesForNonEmptySeq
-    : SemigroupK[NonEmptySeq] with Bimonad[NonEmptySeq] with NonEmptyTraverse[NonEmptySeq] with Align[NonEmptySeq] =
+  implicit val catsDataInstancesForNonEmptySeqBinCompat1: NonEmptyAlternative[NonEmptySeq]
+    with Bimonad[NonEmptySeq]
+    with NonEmptyTraverse[NonEmptySeq]
+    with Align[NonEmptySeq] =
     new NonEmptyReducible[NonEmptySeq, Seq]
-      with SemigroupK[NonEmptySeq]
+      with NonEmptyAlternative[NonEmptySeq]
       with Bimonad[NonEmptySeq]
       with NonEmptyTraverse[NonEmptySeq]
       with Align[NonEmptySeq] {
@@ -398,6 +408,12 @@ sealed abstract private[data] class NonEmptySeqInstances {
       def combineK[A](a: NonEmptySeq[A], b: NonEmptySeq[A]): NonEmptySeq[A] =
         a.concatNeSeq(b)
 
+      override def prependK[A](a: A, fa: NonEmptySeq[A]): NonEmptySeq[A] =
+        fa.prepend(a)
+
+      override def appendK[A](fa: NonEmptySeq[A], a: A): NonEmptySeq[A] =
+        fa.append(a)
+
       override def split[A](fa: NonEmptySeq[A]): (A, Seq[A]) = (fa.head, fa.tail)
 
       override def size[A](fa: NonEmptySeq[A]): Long = fa.length.toLong
@@ -532,14 +548,14 @@ sealed abstract private[data] class NonEmptySeqInstances {
   implicit def catsDataShowForNonEmptySeq[A: Show]: Show[NonEmptySeq[A]] = _.show
 
   implicit def catsDataSemigroupForNonEmptySeq[A]: Semigroup[NonEmptySeq[A]] =
-    catsDataInstancesForNonEmptySeq.algebra
+    catsDataInstancesForNonEmptySeqBinCompat1.algebra
 
   implicit def catsDataParallelForNonEmptySeq: NonEmptyParallel.Aux[NonEmptySeq, ZipNonEmptySeq] =
     new NonEmptyParallel[NonEmptySeq] {
       type F[x] = ZipNonEmptySeq[x]
 
       def apply: Apply[ZipNonEmptySeq] = ZipNonEmptySeq.catsDataCommutativeApplyForZipNonEmptySeq
-      def flatMap: FlatMap[NonEmptySeq] = NonEmptySeq.catsDataInstancesForNonEmptySeq
+      def flatMap: FlatMap[NonEmptySeq] = NonEmptySeq.catsDataInstancesForNonEmptySeqBinCompat1
 
       def sequential: ZipNonEmptySeq ~> NonEmptySeq =
         new (ZipNonEmptySeq ~> NonEmptySeq) { def apply[A](a: ZipNonEmptySeq[A]): NonEmptySeq[A] = a.value }
diff --git a/core/src/main/scala/cats/data/NonEmptyVector.scala b/core/src/main/scala/cats/data/NonEmptyVector.scala
index 67e085212..a3c10d651 100644
--- a/core/src/main/scala/cats/data/NonEmptyVector.scala
+++ b/core/src/main/scala/cats/data/NonEmptyVector.scala
@@ -386,18 +386,28 @@ final class NonEmptyVector[+A] private (val toVector: Vector[A])
 @suppressUnusedImportWarningForScalaVersionSpecific
 sealed abstract private[data] class NonEmptyVectorInstances {
 
+  @deprecated(
+    "maintained for the sake of binary compatibility only - use catsDataInstancesForNonEmptyChainBinCompat1 instead",
+    "2.9.0"
+  )
+  def catsDataInstancesForNonEmptyVector: SemigroupK[NonEmptyVector]
+    with Bimonad[NonEmptyVector]
+    with NonEmptyTraverse[NonEmptyVector]
+    with Align[NonEmptyVector] =
+    catsDataInstancesForNonEmptyVectorBinCompat1
+
   /**
    * This is not a bug. The declared type of `catsDataInstancesForNonEmptyVector` intentionally ignores
    * `NonEmptyReducible` trait for it not being a typeclass.
    *
    * Also see the discussion: PR #3541 and issue #3069.
    */
-  implicit val catsDataInstancesForNonEmptyVector: SemigroupK[NonEmptyVector]
+  implicit val catsDataInstancesForNonEmptyVectorBinCompat1: NonEmptyAlternative[NonEmptyVector]
     with Bimonad[NonEmptyVector]
     with NonEmptyTraverse[NonEmptyVector]
     with Align[NonEmptyVector] =
     new NonEmptyReducible[NonEmptyVector, Vector]
-      with SemigroupK[NonEmptyVector]
+      with NonEmptyAlternative[NonEmptyVector]
       with Bimonad[NonEmptyVector]
       with NonEmptyTraverse[NonEmptyVector]
       with Align[NonEmptyVector] {
@@ -405,6 +415,12 @@ sealed abstract private[data] class NonEmptyVectorInstances {
       def combineK[A](a: NonEmptyVector[A], b: NonEmptyVector[A]): NonEmptyVector[A] =
         a.concatNev(b)
 
+      override def prependK[A](a: A, fa: NonEmptyVector[A]): NonEmptyVector[A] =
+        fa.prepend(a)
+
+      override def appendK[A](fa: NonEmptyVector[A], a: A): NonEmptyVector[A] =
+        fa.append(a)
+
       override def split[A](fa: NonEmptyVector[A]): (A, Vector[A]) = (fa.head, fa.tail)
 
       override def size[A](fa: NonEmptyVector[A]): Long = fa.length.toLong
@@ -550,14 +566,14 @@ sealed abstract private[data] class NonEmptyVectorInstances {
   implicit def catsDataShowForNonEmptyVector[A: Show]: Show[NonEmptyVector[A]] = _.show
 
   implicit def catsDataSemigroupForNonEmptyVector[A]: Semigroup[NonEmptyVector[A]] =
-    catsDataInstancesForNonEmptyVector.algebra
+    catsDataInstancesForNonEmptyVectorBinCompat1.algebra
 
   implicit def catsDataParallelForNonEmptyVector: NonEmptyParallel.Aux[NonEmptyVector, ZipNonEmptyVector] =
     new NonEmptyParallel[NonEmptyVector] {
       type F[x] = ZipNonEmptyVector[x]
 
       def apply: Apply[ZipNonEmptyVector] = ZipNonEmptyVector.catsDataCommutativeApplyForZipNonEmptyVector
-      def flatMap: FlatMap[NonEmptyVector] = NonEmptyVector.catsDataInstancesForNonEmptyVector
+      def flatMap: FlatMap[NonEmptyVector] = NonEmptyVector.catsDataInstancesForNonEmptyVectorBinCompat1
 
       def sequential: ZipNonEmptyVector ~> NonEmptyVector =
         new (ZipNonEmptyVector ~> NonEmptyVector) { def apply[A](a: ZipNonEmptyVector[A]): NonEmptyVector[A] = a.value }
diff --git a/core/src/main/scala/cats/data/OneAnd.scala b/core/src/main/scala/cats/data/OneAnd.scala
index 2652f9ca7..efc5f4409 100644
--- a/core/src/main/scala/cats/data/OneAnd.scala
+++ b/core/src/main/scala/cats/data/OneAnd.scala
@@ -40,7 +40,7 @@ final case class OneAnd[F[_], A](head: A, tail: F[A]) {
    * Combine the head and tail into a single `F[A]` value.
    */
   def unwrap(implicit F: Alternative[F]): F[A] =
-    F.combineK(F.pure(head), tail)
+    F.prependK(head, tail)
 
   /**
    * remove elements not matching the predicate
@@ -54,7 +54,7 @@ final case class OneAnd[F[_], A](head: A, tail: F[A]) {
    * Append another OneAnd to this
    */
   def combine(other: OneAnd[F, A])(implicit F: Alternative[F]): OneAnd[F, A] =
-    OneAnd(head, F.combineK(tail, F.combineK(F.pure(other.head), other.tail)))
+    OneAnd(head, F.combineK(tail, other.unwrap))
 
   /**
    * find the first element matching the predicate, if one exists
@@ -239,7 +239,7 @@ sealed abstract private[data] class OneAndLowPriority2 extends OneAndLowPriority
       override def ap[A, B](ff: OneAnd[F, A => B])(fa: OneAnd[F, A]): OneAnd[F, B] = {
         val (f, tf) = (ff.head, ff.tail)
         val (a, ta) = (fa.head, fa.tail)
-        val fb = F.ap(tf)(F.combineK(F.pure(a), ta))
+        val fb = F.ap(tf)(F.prependK(a, ta))
         OneAnd(f(a), F.combineK(F.map(ta)(f), fb))
       }
     }
