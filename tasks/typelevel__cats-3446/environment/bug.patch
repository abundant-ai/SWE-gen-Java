diff --git a/.scalafmt.conf b/.scalafmt.conf
index caf916edd..3abbf3a70 100644
--- a/.scalafmt.conf
+++ b/.scalafmt.conf
@@ -1,4 +1,4 @@
-version=2.5.2
+version=2.5.3
 align.openParenCallSite = true
 align.openParenDefnSite = true
 maxColumn = 120
diff --git a/core/src/main/scala/cats/SemigroupK.scala b/core/src/main/scala/cats/SemigroupK.scala
index c7a09db51..3c9ed4251 100644
--- a/core/src/main/scala/cats/SemigroupK.scala
+++ b/core/src/main/scala/cats/SemigroupK.scala
@@ -39,31 +39,6 @@ import scala.annotation.implicitNotFound
   @simulacrum.op("<+>", alias = true)
   def combineK[A](x: F[A], y: F[A]): F[A]
 
-  /**
-   * Similar to [[combineK]] but uses [[Eval]] to allow for laziness in the second
-   * argument. This can allow for "short-circuiting" of computations.
-   *
-   * NOTE: the default implementation of `combineKEval` does not short-circuit
-   * computations. For data structures that can benefit from laziness, [[SemigroupK]]
-   * instances should override this method.
-   *
-   * In the following example, `x.combineK(bomb)` would result in an error,
-   * but `combineKEval` "short-circuits" the computation. `x` is `Some` and thus the
-   * result of `bomb` doesn't even need to be evaluated in order to determine
-   * that the result of `combineKEval` should be `x`.
-   *
-   * {{{
-   * scala> import cats.{Eval, Later}
-   * scala> import cats.implicits._
-   * scala> val bomb: Eval[Option[Int]] = Later(sys.error("boom"))
-   * scala> val x: Option[Int] = Some(42)
-   * scala> x.combineKEval(bomb).value
-   * res0: Option[Int] = Some(42)
-   * }}}
-   */
-  def combineKEval[A](x: F[A], y: Eval[F[A]]): Eval[F[A]] =
-    y.map(yy => combineK(x, yy))
-
   /**
    * Given a type A, create a concrete Semigroup[F[A]].
    *
@@ -135,7 +110,6 @@ object SemigroupK extends ScalaVersionSpecificMonoidKInstances {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[SemigroupK]] for `F`.
    */
@@ -147,7 +121,6 @@ object SemigroupK extends ScalaVersionSpecificMonoidKInstances {
     val typeClassInstance: TypeClassType
     def combineK(y: F[A]): F[A] = typeClassInstance.combineK[A](self, y)
     def <+>(y: F[A]): F[A] = typeClassInstance.combineK[A](self, y)
-    def combineKEval(y: Eval[F[A]]): Eval[F[A]] = typeClassInstance.combineKEval[A](self, y)
     def sum[B](fb: F[B])(implicit F: Functor[F]): F[Either[A, B]] = typeClassInstance.sum[A, B](self, fb)(F)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
diff --git a/core/src/main/scala/cats/instances/either.scala b/core/src/main/scala/cats/instances/either.scala
index a558fd503..994bf1fc0 100644
--- a/core/src/main/scala/cats/instances/either.scala
+++ b/core/src/main/scala/cats/instances/either.scala
@@ -186,12 +186,6 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
           case Left(_)  => y
           case Right(_) => x
         }
-
-      override def combineKEval[A](x: Either[L, A], y: Eval[Either[L, A]]): Eval[Either[L, A]] =
-        x match {
-          case Left(_)  => y
-          case Right(_) => Now(x)
-        }
     }
 
   implicit def catsStdShowForEither[A, B](implicit A: Show[A], B: Show[B]): Show[Either[A, B]] =
diff --git a/core/src/main/scala/cats/instances/list.scala b/core/src/main/scala/cats/instances/list.scala
index a0b271920..31dbe5d5d 100644
--- a/core/src/main/scala/cats/instances/list.scala
+++ b/core/src/main/scala/cats/instances/list.scala
@@ -74,15 +74,6 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
       override def foldMap[A, B](fa: List[A])(f: A => B)(implicit B: Monoid[B]): B =
         B.combineAll(fa.iterator.map(f))
 
-      override def foldMapK[G[_], A, B](fa: List[A])(f: A => G[B])(implicit G: MonoidK[G]): G[B] = {
-        def loop(fa: List[A]): Eval[G[B]] =
-          fa match {
-            case head :: tl => G.combineKEval(f(head), Eval.defer(loop(tl)))
-            case Nil        => Eval.now(G.empty)
-          }
-        loop(fa).value
-      }
-
       def traverse[G[_], A, B](fa: List[A])(f: A => G[B])(implicit G: Applicative[G]): G[List[B]] = {
         def loop(fa: List[A]): Eval[G[List[B]]] =
           fa match {
diff --git a/core/src/main/scala/cats/instances/option.scala b/core/src/main/scala/cats/instances/option.scala
index 64a130093..bf5194d36 100644
--- a/core/src/main/scala/cats/instances/option.scala
+++ b/core/src/main/scala/cats/instances/option.scala
@@ -23,12 +23,6 @@ trait OptionInstances extends cats.kernel.instances.OptionInstances {
 
       def combineK[A](x: Option[A], y: Option[A]): Option[A] = x.orElse(y)
 
-      override def combineKEval[A](x: Option[A], y: Eval[Option[A]]): Eval[Option[A]] =
-        x match {
-          case None    => y
-          case Some(_) => Now(x)
-        }
-
       def pure[A](x: A): Option[A] = Some(x)
 
       override def map[A, B](fa: Option[A])(f: A => B): Option[B] =
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index e5828c9f7..138433a60 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -84,12 +84,6 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
       override def get[A](fa: Vector[A])(idx: Long): Option[A] =
         if (idx < Int.MaxValue && fa.size > idx && idx >= 0) Some(fa(idx.toInt)) else None
 
-      override def foldMapK[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: MonoidK[G]): G[B] = {
-        def loop(i: Int): Eval[G[B]] =
-          if (i < fa.length) G.combineKEval(f(fa(i)), Eval.defer(loop(i + 1))) else Eval.now(G.empty)
-        loop(0).value
-      }
-
       final override def traverse[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: Applicative[G]): G[Vector[B]] = {
         def loop(i: Int): Eval[G[List[B]]] =
           if (i < fa.length) G.map2Eval(f(fa(i)), Eval.defer(loop(i + 1)))(_ :: _) else Eval.now(G.pure(Nil))
diff --git a/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala b/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
index 6d4300cc5..0811d6917 100644
--- a/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
+++ b/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
@@ -6,28 +6,10 @@ import cats.instances.option._
 import cats.syntax.foldable._
 import cats.syntax.traverse._
 import cats.syntax.traverseFilter._
-import cats.{Applicative, Foldable, MonoidK, Traverse, TraverseFilter}
+import cats.{Applicative, Traverse, TraverseFilter}
 
 trait ShortCircuitingLaws[F[_]] {
 
-  def foldMapKShortCircuits[A](fa: F[A], empty: A)(implicit F: Foldable[F]): IsEq[Long] = {
-    val size = fa.size
-    val maxInvocationsAllowed = size / 2
-    val f = new RestrictedFunction[A, Option[A]]((a: A) => None, maxInvocationsAllowed, Some(empty))
-
-    fa.foldMapK(f)
-    f.invocations.get <-> (maxInvocationsAllowed + 1).min(size)
-  }
-
-  def foldMapKWontShortCircuit[A](fa: F[A], empty: A)(implicit F: Foldable[F]): IsEq[Long] = {
-    val size = fa.size
-    val maxInvocationsAllowed = size / 2
-    val f = new RestrictedFunction[A, Option[A]]((a: A) => None, maxInvocationsAllowed, Some(empty))
-
-    fa.foldMapK(f)(F, nonShortCircuitingMonoidK)
-    f.invocations.get <-> size
-  }
-
   def traverseShortCircuits[A](fa: F[A])(implicit F: Traverse[F]): IsEq[Long] = {
     val size = fa.size
     val maxInvocationsAllowed = size / 2
@@ -104,11 +86,6 @@ trait ShortCircuitingLaws[F[_]] {
     override def pure[A](a: A): Option[A] = Some(a)
     override def ap[A, B](ff: Option[A => B])(fa: Option[A]): Option[B] = ff.flatMap(f => fa.map(f))
   }
-
-  private[this] val nonShortCircuitingMonoidK: MonoidK[Option] = new MonoidK[Option] {
-    def empty[A]: Option[A] = None
-    def combineK[A](x: Option[A], y: Option[A]): Option[A] = x.orElse(y)
-  }
 }
 
 object ShortCircuitingLaws {
diff --git a/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala b/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
index 1f40605a1..649c3af0a 100644
--- a/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
@@ -1,7 +1,7 @@
 package cats.laws.discipline
 
 import cats.laws.ShortCircuitingLaws
-import cats.{Eq, Foldable, Traverse, TraverseFilter}
+import cats.{Eq, Traverse, TraverseFilter}
 import org.scalacheck.Arbitrary
 import org.scalacheck.Prop.forAll
 import org.typelevel.discipline.Laws
@@ -9,14 +9,6 @@ import org.typelevel.discipline.Laws
 trait ShortCircuitingTests[F[_]] extends Laws {
   def laws: ShortCircuitingLaws[F]
 
-  def foldable[A: Arbitrary](implicit F: Foldable[F], ArbFA: Arbitrary[F[A]], lEq: Eq[Long]): RuleSet =
-    new DefaultRuleSet(
-      name = "foldMapKShortCircuiting",
-      parent = None,
-      "foldMapK short-circuits if MonoidK[G].combineKEval shorts" -> forAll(laws.foldMapKShortCircuits[A] _),
-      "foldMapK won't short-circuit if MonoidK[G].combineKEval won't" -> forAll(laws.foldMapKWontShortCircuit[A] _)
-    )
-
   def traverse[A: Arbitrary](implicit F: Traverse[F], ArbFA: Arbitrary[F[A]], lEq: Eq[Long]): RuleSet =
     new DefaultRuleSet(
       name = "traverseShortCircuiting",
diff --git a/project/build.properties b/project/build.properties
index 742d2e044..654fe70c4 100644
--- a/project/build.properties
+++ b/project/build.properties
@@ -1 +1 @@
-sbt.version=1.3.11
+sbt.version=1.3.12
diff --git a/scalafix/project/build.properties b/scalafix/project/build.properties
index 742d2e044..654fe70c4 100644
--- a/scalafix/project/build.properties
+++ b/scalafix/project/build.properties
@@ -1 +1 @@
-sbt.version=1.3.11
+sbt.version=1.3.12
diff --git a/tests/src/test/scala/cats/tests/ListSuite.scala b/tests/src/test/scala/cats/tests/ListSuite.scala
index b7672012c..5124f6880 100644
--- a/tests/src/test/scala/cats/tests/ListSuite.scala
+++ b/tests/src/test/scala/cats/tests/ListSuite.scala
@@ -43,7 +43,6 @@ class ListSuite extends CatsSuite {
   checkAll("Align[List]", SerializableTests.serializable(Align[List]))
 
   checkAll("List[Int]", ShortCircuitingTests[List].traverseFilter[Int])
-  checkAll("List[Int]", ShortCircuitingTests[List].foldable[Int])
 
   checkAll("ZipList[Int]", CommutativeApplyTests[ZipList].commutativeApply[Int, Int, Int])
 
diff --git a/tests/src/test/scala/cats/tests/SortedSetSuite.scala b/tests/src/test/scala/cats/tests/SortedSetSuite.scala
index be13e8434..6006db11f 100644
--- a/tests/src/test/scala/cats/tests/SortedSetSuite.scala
+++ b/tests/src/test/scala/cats/tests/SortedSetSuite.scala
@@ -7,7 +7,7 @@ import cats.kernel.{BoundedSemilattice, Semilattice}
 import cats.laws._
 import cats.laws.discipline.SemigroupalTests.Isomorphisms
 import cats.laws.discipline.arbitrary._
-import cats.laws.discipline.{FoldableTests, SemigroupKTests, SemigroupalTests, SerializableTests, ShortCircuitingTests}
+import cats.laws.discipline.{FoldableTests, SemigroupKTests, SemigroupalTests, SerializableTests}
 import cats.syntax.show._
 import scala.collection.immutable.SortedSet
 
diff --git a/tests/src/test/scala/cats/tests/VectorSuite.scala b/tests/src/test/scala/cats/tests/VectorSuite.scala
index 4fdd04815..9155653df 100644
--- a/tests/src/test/scala/cats/tests/VectorSuite.scala
+++ b/tests/src/test/scala/cats/tests/VectorSuite.scala
@@ -42,7 +42,6 @@ class VectorSuite extends CatsSuite {
   checkAll("Align[Vector]", SerializableTests.serializable(Align[Vector]))
 
   checkAll("Vector[Int]", ShortCircuitingTests[Vector].traverseFilter[Int])
-  checkAll("Vector[Int]", ShortCircuitingTests[Vector].foldable[Int])
 
   checkAll("ZipVector[Int]", CommutativeApplyTests[ZipVector].commutativeApply[Int, Int, Int])
 
