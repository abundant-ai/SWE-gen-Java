diff --git a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
index 07774683c7..b0d60fc5fb 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
@@ -45,6 +45,7 @@ import io.micronaut.core.util.StringUtils;
 import io.micronaut.inject.BeanConfiguration;
 import io.micronaut.inject.BeanDefinition;
 import io.micronaut.inject.BeanDefinitionReference;
+import io.micronaut.inject.qualifiers.EachBeanQualifier;
 import io.micronaut.inject.qualifiers.PrimaryQualifier;
 
 import java.util.ArrayList;
@@ -559,10 +560,15 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
                     createAndAddDelegate(resolutionContext, candidate, transformedCandidates, dependentPath);
                 } else {
                     Qualifier<?> qualifier = dependentCandidate.getDeclaredQualifier();
-                    if (qualifier == null && dependentCandidate.isPrimary()) {
-                        // Backwards compatibility, `getDeclaredQualifier` strips @Primary
-                        // This should be removed if @Primary is no longer qualifier
-                        qualifier = PrimaryQualifier.INSTANCE;
+                    if (qualifier == null) {
+                        if (dependentCandidate.isPrimary()) {
+                            // Backwards compatibility, `getDeclaredQualifier` strips @Primary
+                            // This should be removed if @Primary is no longer qualifier
+                            qualifier = PrimaryQualifier.INSTANCE;
+                        } else {
+                            // @EachBean needs to have something of qualifier to find its origin
+                            qualifier = new EachBeanQualifier<>(dependentCandidate);
+                        }
                     }
                     BeanDefinitionDelegate<?> delegate = BeanDefinitionDelegate.create(candidate, (Qualifier<T>) qualifier);
                     if (delegate.isEnabled(this, resolutionContext)) {
diff --git a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
index b8a83dfc41..e7b791a2a3 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
@@ -927,28 +927,25 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         BeanDefinition<Map<String, V>> existingBean = findBeanDefinitionInternal(mapType, mapQualifier).orElse(null);
         if (existingBean != null) {
             return getBean(existingBean);
-        } else {
-            Collection<BeanRegistration<V>> beanRegistrations = getBeanRegistrations(resolutionContext, beanType, qualifier);
-            if (beanRegistrations.isEmpty()) {
-                return Collections.emptyMap();
-            } else {
-                try {
-                    return beanRegistrations.stream().collect(Collectors.toUnmodifiableMap(
-                        DefaultBeanContext::resolveKey,
-                        reg -> reg.bean
-                    ));
-                } catch (IllegalStateException e) { // occurs for duplicate keys
-                    List<BeanDefinition<V>> beanDefinitions = beanRegistrations.stream().map(reg -> reg.beanDefinition).toList();
-                    throw new DependencyInjectionException(
-                        resolutionContext,
-                        "Injecting a map of beans requires each bean to define a qualifier. Multiple beans were found missing a qualifier resulting in duplicate keys: " + e.getMessage(),
-                        new NonUniqueBeanException(
-                            beanType.getType(),
-                            beanDefinitions.iterator()
-                        )
-                    );
-                }
-            }
+        }
+        Collection<BeanRegistration<V>> beanRegistrations = getBeanRegistrations(resolutionContext, beanType, qualifier);
+        if (beanRegistrations.isEmpty()) {
+            return Collections.emptyMap();
+        }
+        try {
+            return beanRegistrations.stream().collect(Collectors.toUnmodifiableMap(
+                DefaultBeanContext::resolveKey,
+                reg -> reg.bean
+            ));
+        } catch (IllegalStateException e) { // occurs for duplicate keys
+            throw new DependencyInjectionException(
+                resolutionContext,
+                "Injecting a map of beans requires `@Named` qualifier. Multiple beans were found missing a qualifier resulting in duplicate keys: " + e.getMessage(),
+                new NonUniqueBeanException(
+                    beanType.getType(),
+                    beanRegistrations.stream().map(reg -> reg.beanDefinition).iterator()
+                )
+            );
         }
     }
 
@@ -957,17 +954,18 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         BeanDefinition<?> definition = reg.beanDefinition;
         BeanIdentifier identifier = reg.identifier;
         if (definition instanceof NameResolver resolver) {
-            return resolver.resolveName().orElse(identifier.getName());
-        } else {
-            String name = identifier.getName();
-            if (name.equals(Primary.SIMPLE_NAME)) {
-                Class<?> candidateType = reg.beanDefinition.getBeanType();
-                String candidateSimpleName = candidateType.getSimpleName();
-                return NameUtils.decapitalize(candidateSimpleName);
-            } else {
+            String name = resolver.resolveName().orElse(null);
+            if (name != null) {
                 return name;
             }
         }
+        String name = identifier.getName();
+        if (name.equals(Primary.SIMPLE_NAME)) {
+            Class<?> candidateType = reg.beanDefinition.getBeanType();
+            String candidateSimpleName = candidateType.getSimpleName();
+            return NameUtils.decapitalize(candidateSimpleName);
+        }
+        return name;
     }
 
     /**
diff --git a/inject/src/main/java/io/micronaut/inject/qualifiers/EachBeanQualifier.java b/inject/src/main/java/io/micronaut/inject/qualifiers/EachBeanQualifier.java
new file mode 100644
index 0000000000..c1675748f5
--- /dev/null
+++ b/inject/src/main/java/io/micronaut/inject/qualifiers/EachBeanQualifier.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.inject.qualifiers;
+
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.inject.BeanDefinition;
+import io.micronaut.inject.BeanType;
+
+/**
+ * Qualifies the origin bean definition that was used to create an each bean.
+ *
+ * @param <T> The type
+ * @author Denis Stepanov
+ * @since 4.6
+ */
+@Internal
+public final class EachBeanQualifier<T> extends FilteringQualifier<T> {
+
+    private final BeanDefinition<?> beanDefinition;
+
+    public EachBeanQualifier(BeanDefinition<?> beanDefinition) {
+        this.beanDefinition = beanDefinition;
+    }
+
+    @Override
+    public boolean doesQualify(Class<T> beanType, BeanType<T> candidate) {
+        return candidate.equals(beanDefinition);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (o == null || !EachBeanQualifier.class.isAssignableFrom(o.getClass())) {
+            return false;
+        }
+
+        EachBeanQualifier<?> that = (EachBeanQualifier<?>) o;
+
+        return beanDefinition.equals(that.beanDefinition);
+    }
+
+    @Override
+    public String toString() {
+        return "EachBeanQualifier('" + beanDefinition + "')";
+    }
+
+    @Override
+    public int hashCode() {
+        return beanDefinition.hashCode();
+    }
+
+}
