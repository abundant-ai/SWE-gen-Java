diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Cache.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Cache.kt
index 34b00bd72..6768e4bf9 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Cache.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Cache.kt
@@ -26,7 +26,6 @@ import java.security.cert.CertificateFactory
 import java.util.TreeSet
 import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
 import okhttp3.MediaType.Companion.toMediaTypeOrNull
-import okhttp3.internal.UnreadableRequestBody
 import okhttp3.internal.cache.CacheRequest
 import okhttp3.internal.cache.CacheStrategy
 import okhttp3.internal.cache.DiskLruCache
@@ -46,12 +45,10 @@ import okio.ByteString.Companion.toByteString
 import okio.FileSystem
 import okio.ForwardingSink
 import okio.ForwardingSource
-import okio.HashingSink
 import okio.Path
 import okio.Path.Companion.toOkioPath
 import okio.Sink
 import okio.Source
-import okio.blackholeSink
 import okio.buffer
 
 /**
@@ -194,12 +191,7 @@ class Cache internal constructor(
     get() = cache.isClosed()
 
   internal fun get(request: Request): Response? {
-    if (request.body != null && request.body.isOneShot()) {
-      // Don't cache one-shot QUERY requests, since we need to cache by using the body,
-      // and we can't consume the body twice
-      return null
-    }
-    val key = key(request)
+    val key = key(request.url)
     val snapshot: DiskLruCache.Snapshot =
       try {
         cache[key] ?: return null
@@ -236,19 +228,13 @@ class Cache internal constructor(
       return null
     }
 
-    if (!HttpMethod.isCacheable(requestMethod)) {
+    if (requestMethod != "GET" && requestMethod != "QUERY") {
       // Don't cache non-GET and non-QUERY responses. We're technically allowed to cache HEAD
       // requests and some POST requests, but the complexity of doing so is high and the benefit
       // is low.
       return null
     }
 
-    if (response.request.body != null && response.request.body.isOneShot()) {
-      // Don't cache one-shot QUERY requests, since we need to cache by using the body,
-      // and we can't consume the body twice
-      return null
-    }
-
     if (response.hasVaryAll()) {
       return null
     }
@@ -256,7 +242,7 @@ class Cache internal constructor(
     val entry = Entry(response)
     var editor: DiskLruCache.Editor? = null
     try {
-      editor = cache.edit(key(response.request)) ?: return null
+      editor = cache.edit(key(response.request.url)) ?: return null
       entry.writeTo(editor)
       return RealCacheRequest(editor)
     } catch (_: IOException) {
@@ -267,7 +253,7 @@ class Cache internal constructor(
 
   @Throws(IOException::class)
   internal fun remove(request: Request) {
-    cache.remove(key(request))
+    cache.remove(key(request.url))
   }
 
   internal fun update(
@@ -702,13 +688,7 @@ class Cache internal constructor(
     fun response(snapshot: DiskLruCache.Snapshot): Response {
       val contentType = responseHeaders["Content-Type"]
       val contentLength = responseHeaders["Content-Length"]
-      val cacheRequest =
-        Request(
-          url = url,
-          headers = varyHeaders,
-          method = requestMethod,
-          body = if (HttpMethod.requiresRequestBody(requestMethod)) UnreadableRequestBody() else null,
-        )
+      val cacheRequest = Request(url, varyHeaders, requestMethod)
       return Response
         .Builder()
         .request(cacheRequest)
@@ -772,35 +752,6 @@ class Cache internal constructor(
         .md5()
         .hex()
 
-    /** Returns the cache key for a request */
-    internal fun key(request: Request): String {
-      if (
-        // Request such as PUT, DELETE that invalidates a GET
-        !HttpMethod.invalidatesCache(request.method) &&
-
-        // QUERY request that considers the request body in the cache key
-        HttpMethod.isCacheable(request.method) &&
-        HttpMethod.permitsRequestBody(request.method) &&
-        request.body != null
-      ) {
-        val hashingSink = HashingSink.md5(blackholeSink())
-        hashingSink.buffer().use {
-          it.writeUtf8(request.method)
-          it.writeByte(0)
-          it.writeUtf8(request.url.toString())
-          it.writeByte(0)
-          request.body.writeTo(it)
-        }
-        return hashingSink.hash.hex()
-      }
-
-      return request.url
-        .toString()
-        .encodeUtf8()
-        .md5()
-        .hex()
-    }
-
     @Throws(IOException::class)
     internal fun readInt(source: BufferedSource): Int {
       try {
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt
index b37b212a9..071490bec 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt
@@ -317,9 +317,6 @@ class Request internal constructor(
 
     open fun patch(body: RequestBody): Builder = method("PATCH", body)
 
-    /**
-     * A QUERY request with a body. If `body.isOneShot()` is true, then caching will be disabled.
-     */
     open fun query(body: RequestBody): Builder = method("QUERY", body)
 
     open fun method(
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/UnreadableRequestBody.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/UnreadableRequestBody.kt
deleted file mode 100644
index c0531b9a1..000000000
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/UnreadableRequestBody.kt
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2025 Block, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal
-
-import okhttp3.RequestBody
-import okio.Buffer
-import okio.BufferedSink
-import okio.Source
-import okio.Timeout
-
-internal class UnreadableRequestBody :
-  RequestBody(),
-  Source {
-  override fun contentType() = failUnsupported()
-
-  override fun contentLength() = failUnsupported()
-
-  override fun writeTo(sink: BufferedSink) = failUnsupported()
-
-  override fun read(
-    sink: Buffer,
-    byteCount: Long,
-  ): Long = failUnsupported()
-
-  private fun failUnsupported(): Nothing =
-    throw IllegalStateException(
-      """
-        |Unreadable RequestBody! These Request objects have bodies that are stripped:
-        | * Response.cacheResponse.request
-      """.trimMargin(),
-    )
-
-  override fun timeout() = Timeout.NONE
-
-  override fun close() {
-  }
-}
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/cache/CacheInterceptor.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/cache/CacheInterceptor.kt
index 1a66c2d4c..8e6581bdc 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/cache/CacheInterceptor.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/cache/CacheInterceptor.kt
@@ -299,8 +299,7 @@ class CacheInterceptor(
 private fun Request.requestForCache(): Request {
   val cacheUrlOverride = cacheUrlOverride
 
-  // Allow POST caching only when there is a cacheUrlOverride
-  return if (cacheUrlOverride != null && (HttpMethod.isCacheable(method) || method == "POST")) {
+  return if (cacheUrlOverride != null && (method == "GET" || method == "POST")) {
     newBuilder()
       .get()
       .url(cacheUrlOverride)
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/HttpMethod.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/HttpMethod.kt
index 77d2d9da5..0d3df7510 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/HttpMethod.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/HttpMethod.kt
@@ -35,7 +35,6 @@ object HttpMethod {
         method == "PUT" ||
         method == "PATCH" ||
         method == "PROPPATCH" ||
-        method == "QUERY" ||
         // WebDAV
         method == "REPORT"
     )
@@ -46,6 +45,4 @@ object HttpMethod {
   fun redirectsWithBody(method: String): Boolean = method == "PROPFIND"
 
   fun redirectsToGet(method: String): Boolean = method != "PROPFIND"
-
-  fun isCacheable(requestMethod: String): Boolean = requestMethod == "GET" || requestMethod == "QUERY"
 }
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/CacheTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/CacheTest.kt
index d9b084391..6a40e72db 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/CacheTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/CacheTest.kt
@@ -35,7 +35,6 @@ import java.util.Locale
 import java.util.TimeZone
 import java.util.concurrent.TimeUnit
 import java.util.concurrent.atomic.AtomicReference
-import java.util.stream.Stream
 import javax.net.ssl.HostnameVerifier
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
@@ -46,7 +45,6 @@ import mockwebserver3.junit5.StartStop
 import okhttp3.Cache.Companion.key
 import okhttp3.Headers.Companion.headersOf
 import okhttp3.MediaType.Companion.toMediaType
-import okhttp3.MediaType.Companion.toMediaTypeOrNull
 import okhttp3.RequestBody.Companion.toRequestBody
 import okhttp3.internal.addHeaderLenient
 import okhttp3.internal.cacheGet
@@ -54,7 +52,6 @@ import okhttp3.internal.platform.Platform.Companion.get
 import okhttp3.java.net.cookiejar.JavaNetCookieJar
 import okhttp3.testing.PlatformRule
 import okio.Buffer
-import okio.BufferedSink
 import okio.FileSystem
 import okio.ForwardingFileSystem
 import okio.GzipSink
@@ -514,147 +511,72 @@ class CacheTest {
         .body("ABC")
         .build(),
     )
-    // QUERY responses
     server.enqueue(
       MockResponse
         .Builder()
-        .addHeader("Cache-Control: max-age=60")
-        .body("DEF")
+        .code(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo")
         .build(),
     )
-
-    val requestGet1 =
-      Request
-        .Builder()
-        .url(server.url("/foo"))
-        .get()
-        .build()
-    val response1 = client.newCall(requestGet1).execute()
-    assertThat(response1.body.string()).isEqualTo("ABC")
-    val recordedRequest1 = server.takeRequest()
-    assertThat(recordedRequest1.requestLine).isEqualTo("GET /foo HTTP/1.1")
-
-    val requestQuery1 =
-      Request
-        .Builder()
-        .url(server.url("/foo"))
-        .query(RequestBody.EMPTY)
-        .build()
-    val response2 = client.newCall(requestQuery1).execute()
-    assertThat(response2.body.string()).isEqualTo("DEF")
-    val recordedRequest2 = server.takeRequest()
-    assertThat(recordedRequest2.requestLine).isEqualTo("QUERY /foo HTTP/1.1")
-  }
-
-  @Test
-  fun queryRequestsCacheTheBody() {
+    // QUERY responses
     server.enqueue(
       MockResponse
         .Builder()
         .addHeader("Cache-Control: max-age=60")
-        .body("ABC")
+        .body("DEF")
         .build(),
     )
     server.enqueue(
       MockResponse
         .Builder()
-        .addHeader("Cache-Control: max-age=60")
-        .body("DEF")
+        .code(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /baz")
         .build(),
     )
 
-    val url = server.url("/same")
-
-    // First QUERY request with body "foo"
     val request1 =
       Request
         .Builder()
-        .url(url)
-        .query("foo".toRequestBody())
+        .url(server.url("/foo"))
+        .get()
         .build()
     val response1 = client.newCall(request1).execute()
     assertThat(response1.body.string()).isEqualTo("ABC")
-
-    // Second QUERY request with body "bar"
+    val recordedRequest1 = server.takeRequest()
+    assertThat(recordedRequest1.requestLine).isEqualTo("GET /foo HTTP/1.1")
     val request2 =
       Request
         .Builder()
-        .url(url)
-        .query("bar".toRequestBody())
+        .url(server.url("/bar"))
+        .get()
         .build()
     val response2 = client.newCall(request2).execute()
-    assertThat(response2.body.string()).isEqualTo("DEF")
-
-    // Third QUERY request with body "foo" again, should be cached and return "ABC"
-    val response3 = client.newCall(request1).execute()
-    assertThat(response3.body.string()).isEqualTo("ABC")
-
-    // Fourth QUERY request with body "bar" again, should be cached and return "DEF"
-    val response4 = client.newCall(request2).execute()
-    assertThat(response4.body.string()).isEqualTo("DEF")
-  }
-
-  @Test
-  fun oneshotBodyIsNotCachedForQueryRequest() {
-    server.enqueue(
-      MockResponse
-        .Builder()
-        .addHeader("Cache-Control: max-age=60")
-        .body("ABC1")
-        .build(),
-    )
-    server.enqueue(
-      MockResponse
-        .Builder()
-        .addHeader("Cache-Control: max-age=60")
-        .body("ABC2")
-        .build(),
-    )
-
-    val url = server.url("/same")
-
-    // QUERY request with body "foo"
-    val body = "foo"
+    assertThat(response2.body.string()).isEqualTo("ABC")
+    val recordedRequest2 = server.takeRequest()
+    assertThat(recordedRequest2.requestLine).isEqualTo("GET /bar HTTP/1.1")
 
-    val request1 =
+    val request3 =
       Request
         .Builder()
-        .url(url)
-        .query(body.toOneShotRequestBody())
+        .url(server.url("/baz"))
+        .query(RequestBody.EMPTY)
         .build()
-    val response1 = client.newCall(request1).execute()
-    assertThat(response1.body.string()).isEqualTo("ABC1")
-
-    // QUERY request with body "foo" again, should not be cached
-    val request2 =
+    val response3 = client.newCall(request3).execute()
+    assertThat(response3.body.string()).isEqualTo("DEF")
+    val recordedRequest3 = server.takeRequest()
+    assertThat(recordedRequest3.requestLine).isEqualTo("QUERY /baz HTTP/1.1")
+    val request4 =
       Request
         .Builder()
-        .url(url)
-        .query(body.toOneShotRequestBody())
+        .url(server.url("/bar"))
+        .query(RequestBody.EMPTY)
         .build()
-    val response2 = client.newCall(request2).execute()
-    assertThat(response2.body.string()).isEqualTo("ABC2")
-
-    // Check that the cache did not store the response
-    assertThat(cache.requestCount()).isEqualTo(2)
-    assertThat(cache.hitCount()).isEqualTo(0)
+    val response4 = client.newCall(request4).execute()
+    assertThat(response4.body.string()).isEqualTo("DEF")
+    val recordedRequest4 = server.takeRequest()
+    assertThat(recordedRequest4.requestLine).isEqualTo("QUERY /bar HTTP/1.1")
   }
 
-  private fun String.toOneShotRequestBody(): RequestBody =
-    object : RequestBody() {
-      val internalBody = Stream.of(this)
-
-      override fun isOneShot(): Boolean = true
-
-      override fun contentType(): MediaType? = "application/text-plain".toMediaTypeOrNull()
-
-      override fun writeTo(sink: BufferedSink) {
-        internalBody.forEach { item ->
-          sink.writeUtf8(this@toOneShotRequestBody)
-        }
-      }
-    }
-
   @Test
   fun secureResponseCachingAndRedirects() {
     server.useHttps(handshakeCertificates.sslSocketFactory())
@@ -1211,16 +1133,6 @@ class CacheTest {
     testRequestMethod("GET", true)
   }
 
-  @Test
-  fun requestMethodQueryIsCached() {
-    testRequestMethod("QUERY", true)
-  }
-
-  @Test
-  fun requestMethodQueryIsCachedWithOverride() {
-    testRequestMethod("QUERY", true, withOverride = true)
-  }
-
   @Test
   fun requestMethodHeadIsNotCached() {
     // We could support this but choose not to for implementation simplicity
@@ -1293,35 +1205,17 @@ class CacheTest {
     val response1 = client.newCall(request).execute()
     response1.body.close()
     assertThat(response1.header("X-Response-ID")).isEqualTo("1")
-    val response2 = client.newCall(request).execute()
+    val response2 = get(url)
     response2.body.close()
     if (expectCached) {
       assertThat(response2.header("X-Response-ID")).isEqualTo("1")
     } else {
       assertThat(response2.header("X-Response-ID")).isEqualTo("2")
     }
-    if (!expectCached) {
-      server.enqueue(
-        MockResponse
-          .Builder()
-          .addHeader("X-Response-ID: 3")
-          .build(),
-      )
-      val response3 = get(url)
-      response3.body.close()
-      assertThat(response3.header("X-Response-ID")).isEqualTo("3")
-    }
   }
 
   private fun requestBodyOrNull(requestMethod: String): RequestBody? =
-    if (requestMethod == "POST" ||
-      requestMethod == "PUT" ||
-      requestMethod == "QUERY"
-    ) {
-      "foo".toRequestBody("text/plain".toMediaType())
-    } else {
-      null
-    }
+    if (requestMethod == "POST" || requestMethod == "PUT") "foo".toRequestBody("text/plain".toMediaType()) else null
 
   @Test
   fun postInvalidatesCache() {
