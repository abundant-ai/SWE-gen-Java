diff --git a/core/src/main/scala/cats/implicits.scala b/core/src/main/scala/cats/implicits.scala
index 03b246f07..6b419dae8 100644
--- a/core/src/main/scala/cats/implicits.scala
+++ b/core/src/main/scala/cats/implicits.scala
@@ -18,3 +18,4 @@ object implicits
     with instances.AllInstancesBinCompat4
     with instances.AllInstancesBinCompat5
     with instances.AllInstancesBinCompat6
+    with instances.AllInstancesBinCompat7
diff --git a/core/src/main/scala/cats/instances/ScalaVersionSpecificParallelInstances.scala b/core/src/main/scala/cats/instances/ScalaVersionSpecificParallelInstances.scala
index 55ab7e7de..04faf7d19 100644
--- a/core/src/main/scala/cats/instances/ScalaVersionSpecificParallelInstances.scala
+++ b/core/src/main/scala/cats/instances/ScalaVersionSpecificParallelInstances.scala
@@ -3,70 +3,29 @@ package instances
 
 import cats.data._
 import cats.kernel.Semigroup
-import cats.syntax.either._
-import cats.{~>, Applicative, Apply, FlatMap, Monad, NonEmptyParallel, Parallel}
 
 trait ParallelInstances extends ParallelInstances1 {
-  implicit def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
-    new Parallel[Either[E, *]] {
-      type F[x] = Validated[E, x]
 
-      def applicative: Applicative[Validated[E, *]] = Validated.catsDataApplicativeErrorForValidated
-      def monad: Monad[Either[E, *]] = cats.instances.either.catsStdInstancesForEither
-
-      def sequential: Validated[E, *] ~> Either[E, *] =
-        λ[Validated[E, *] ~> Either[E, *]](_.toEither)
-
-      def parallel: Either[E, *] ~> Validated[E, *] =
-        λ[Either[E, *] ~> Validated[E, *]](_.toValidated)
-    }
+  @deprecated("Use cats.instances.either.catsParallelForEitherAndValidated", "2.1.0")
+  def catsParallelForEitherValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
+    cats.instances.either.catsParallelForEitherAndValidated[E]
 
   @deprecated("Use OptionT.catsDataParallelForOptionT", "2.0.0")
   def catsParallelForOptionTNestedOption[M[_]](
     implicit P: Parallel[M]
   ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = OptionT.catsDataParallelForOptionT[M]
 
-  implicit def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
-    new NonEmptyParallel[List] {
-      type F[x] = ZipList[x]
-
-      def flatMap: FlatMap[List] = cats.instances.list.catsStdInstancesForList
-      def apply: Apply[ZipList] = ZipList.catsDataCommutativeApplyForZipList
-
-      def sequential: ZipList ~> List =
-        λ[ZipList ~> List](_.value)
-
-      def parallel: List ~> ZipList =
-        λ[List ~> ZipList](v => new ZipList(v))
-    }
-
-  implicit def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
-    new NonEmptyParallel[Vector] {
-      type F[x] = ZipVector[x]
-
-      def flatMap: FlatMap[Vector] = cats.instances.vector.catsStdInstancesForVector
-      def apply: Apply[ZipVector] = ZipVector.catsDataCommutativeApplyForZipVector
-
-      def sequential: ZipVector ~> Vector =
-        λ[ZipVector ~> Vector](_.value)
-
-      def parallel: Vector ~> ZipVector =
-        λ[Vector ~> ZipVector](v => new ZipVector(v))
-    }
-
-  implicit def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
-    new Parallel[Stream] {
-      type F[x] = ZipStream[x]
-
-      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
-      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
+  @deprecated("Use cats.instances.list.catsStdNonEmptyParallelForListZipList", "2.1.0")
+  def catsStdNonEmptyParallelForZipList: NonEmptyParallel.Aux[List, ZipList] =
+    cats.instances.list.catsStdNonEmptyParallelForListZipList
 
-      def sequential: ZipStream ~> Stream =
-        λ[ZipStream ~> Stream](_.value)
+  @deprecated("Use cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector", "2.1.0")
+  def catsStdNonEmptyParallelForZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
+    cats.instances.vector.catsStdNonEmptyParallelForVectorZipVector
 
-      def parallel: Stream ~> ZipStream =
-        λ[Stream ~> ZipStream](v => new ZipStream(v))
-    }
+  @deprecated("Use cats.instances.stream.catsStdParallelForStreamZipStream", "2.1.0")
+  def catsStdParallelForZipStream: Parallel.Aux[Stream, ZipStream] =
+    cats.instances.stream.catsStdParallelForStreamZipStream
 
   @deprecated("Use EitherT.catsDataParallelForEitherTWithParallelEffect", "2.0.0")
   def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](
diff --git a/core/src/main/scala/cats/instances/all.scala b/core/src/main/scala/cats/instances/all.scala
index 001e20ccf..5dcc1a3e0 100644
--- a/core/src/main/scala/cats/instances/all.scala
+++ b/core/src/main/scala/cats/instances/all.scala
@@ -10,6 +10,7 @@ abstract class AllInstancesBinCompat
     with AllInstancesBinCompat4
     with AllInstancesBinCompat5
     with AllInstancesBinCompat6
+    with AllInstancesBinCompat7
 
 trait AllInstances
     extends AnyValInstances
@@ -62,3 +63,9 @@ trait AllInstancesBinCompat4 extends SortedMapInstancesBinCompat1 with MapInstan
 trait AllInstancesBinCompat5 extends SortedSetInstancesBinCompat0
 
 trait AllInstancesBinCompat6 extends SortedSetInstancesBinCompat1 with SortedMapInstancesBinCompat2
+
+trait AllInstancesBinCompat7
+    extends ListInstancesBinCompat1
+    with VectorInstancesBinCompat1
+    with EitherInstancesBinCompat0
+    with StreamInstancesBinCompat1
diff --git a/core/src/main/scala/cats/instances/either.scala b/core/src/main/scala/cats/instances/either.scala
index 572b5df3c..e0363dd72 100644
--- a/core/src/main/scala/cats/instances/either.scala
+++ b/core/src/main/scala/cats/instances/either.scala
@@ -1,6 +1,7 @@
 package cats
 package instances
 
+import cats.data.Validated
 import cats.syntax.EitherUtil
 import cats.syntax.either._
 import scala.annotation.tailrec
@@ -159,3 +160,19 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
         }
     }
 }
+
+private[instances] trait EitherInstancesBinCompat0 {
+  implicit def catsParallelForEitherAndValidated[E: Semigroup]: Parallel.Aux[Either[E, *], Validated[E, *]] =
+    new Parallel[Either[E, *]] {
+      type F[x] = Validated[E, x]
+
+      def applicative: Applicative[Validated[E, *]] = Validated.catsDataApplicativeErrorForValidated
+      def monad: Monad[Either[E, *]] = cats.instances.either.catsStdInstancesForEither
+
+      def sequential: Validated[E, *] ~> Either[E, *] =
+        λ[Validated[E, *] ~> Either[E, *]](_.toEither)
+
+      def parallel: Either[E, *] ~> Validated[E, *] =
+        λ[Either[E, *] ~> Validated[E, *]](_.toValidated)
+    }
+}
diff --git a/core/src/main/scala/cats/instances/list.scala b/core/src/main/scala/cats/instances/list.scala
index 975fa1451..5dc7803de 100644
--- a/core/src/main/scala/cats/instances/list.scala
+++ b/core/src/main/scala/cats/instances/list.scala
@@ -1,6 +1,7 @@
 package cats
 package instances
 
+import cats.data.ZipList
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -177,3 +178,19 @@ private[instances] trait ListInstancesBinCompat0 {
         .value
   }
 }
+
+private[instances] trait ListInstancesBinCompat1 {
+  implicit def catsStdNonEmptyParallelForListZipList: NonEmptyParallel.Aux[List, ZipList] =
+    new NonEmptyParallel[List] {
+      type F[x] = ZipList[x]
+
+      def flatMap: FlatMap[List] = cats.instances.list.catsStdInstancesForList
+      def apply: Apply[ZipList] = ZipList.catsDataCommutativeApplyForZipList
+
+      def sequential: ZipList ~> List =
+        λ[ZipList ~> List](_.value)
+
+      def parallel: List ~> ZipList =
+        λ[List ~> ZipList](v => new ZipList(v))
+    }
+}
diff --git a/core/src/main/scala/cats/instances/package.scala b/core/src/main/scala/cats/instances/package.scala
index d905f919e..097bc4434 100644
--- a/core/src/main/scala/cats/instances/package.scala
+++ b/core/src/main/scala/cats/instances/package.scala
@@ -10,7 +10,7 @@ package object instances {
   object char extends CharInstances
   object double extends DoubleInstances
   object duration extends CoreDurationInstances with DurationInstances
-  object either extends EitherInstances
+  object either extends EitherInstances with EitherInstancesBinCompat0
   object eq extends EqInstances
   object equiv extends EquivInstances
   object float extends FloatInstances
@@ -19,7 +19,7 @@ package object instances {
   object future extends FutureInstances
   object int extends IntInstances
   object invariant extends InvariantMonoidalInstances
-  object list extends ListInstances with ListInstancesBinCompat0
+  object list extends ListInstances with ListInstancesBinCompat0 with ListInstancesBinCompat1
   object long extends LongInstances
   object option extends OptionInstances with OptionInstancesBinCompat0
   object map extends MapInstances with MapInstancesBinCompat0 with MapInstancesBinCompat1
@@ -37,11 +37,11 @@ package object instances {
       with SortedMapInstancesBinCompat1
       with SortedMapInstancesBinCompat2
   object sortedSet extends SortedSetInstances with SortedSetInstancesBinCompat0 with SortedSetInstancesBinCompat1
-  object stream extends StreamInstances with StreamInstancesBinCompat0
+  object stream extends StreamInstances with StreamInstancesBinCompat0 with StreamInstancesBinCompat1
   object string extends StringInstances
   object try_ extends TryInstances
   object tuple extends TupleInstances with Tuple2InstancesBinCompat0
   object unit extends UnitInstances
   object uuid extends UUIDInstances
-  object vector extends VectorInstances with VectorInstancesBinCompat0
+  object vector extends VectorInstances with VectorInstancesBinCompat0 with VectorInstancesBinCompat1
 }
diff --git a/core/src/main/scala/cats/instances/stream.scala b/core/src/main/scala/cats/instances/stream.scala
index de0fcbbf8..3bd39fa94 100644
--- a/core/src/main/scala/cats/instances/stream.scala
+++ b/core/src/main/scala/cats/instances/stream.scala
@@ -1,6 +1,7 @@
 package cats
 package instances
 
+import cats.data.ZipStream
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -186,3 +187,19 @@ private[instances] trait StreamInstancesBinCompat0 {
 
   }
 }
+
+private[instances] trait StreamInstancesBinCompat1 {
+  implicit def catsStdParallelForStreamZipStream: Parallel.Aux[Stream, ZipStream] =
+    new Parallel[Stream] {
+      type F[x] = ZipStream[x]
+
+      def monad: Monad[Stream] = cats.instances.stream.catsStdInstancesForStream
+      def applicative: Applicative[ZipStream] = ZipStream.catsDataAlternativeForZipStream
+
+      def sequential: ZipStream ~> Stream =
+        λ[ZipStream ~> Stream](_.value)
+
+      def parallel: Stream ~> ZipStream =
+        λ[Stream ~> ZipStream](v => new ZipStream(v))
+    }
+}
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index 5c27e6f4b..11b54466a 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -1,6 +1,7 @@
 package cats
 package instances
 
+import cats.data.ZipVector
 import cats.syntax.show._
 
 import scala.annotation.tailrec
@@ -148,3 +149,19 @@ private[instances] trait VectorInstancesBinCompat0 {
         .value
   }
 }
+
+private[instances] trait VectorInstancesBinCompat1 {
+  implicit def catsStdNonEmptyParallelForVectorZipVector: NonEmptyParallel.Aux[Vector, ZipVector] =
+    new NonEmptyParallel[Vector] {
+      type F[x] = ZipVector[x]
+
+      def flatMap: FlatMap[Vector] = cats.instances.vector.catsStdInstancesForVector
+      def apply: Apply[ZipVector] = ZipVector.catsDataCommutativeApplyForZipVector
+
+      def sequential: ZipVector ~> Vector =
+        λ[ZipVector ~> Vector](_.value)
+
+      def parallel: Vector ~> ZipVector =
+        λ[Vector ~> ZipVector](v => new ZipVector(v))
+    }
+}
