diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index b3d48ca51..de946c0f1 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -3,7 +3,7 @@
 biz-aQute-bnd = "7.1.0"
 checkStyle = "10.25.0"
 com-squareup-moshi = "1.15.2"
-com-squareup-okio = "3.13.0"
+com-squareup-okio = "3.12.0"
 de-mannodermaus-junit5 = "1.8.0"
 graalvm = "24.2.1"
 junit-platform = "1.13.1"
diff --git a/mockwebserver/api/mockwebserver3.api b/mockwebserver/api/mockwebserver3.api
index ede7b45e5..8c9a90cc3 100644
--- a/mockwebserver/api/mockwebserver3.api
+++ b/mockwebserver/api/mockwebserver3.api
@@ -19,9 +19,9 @@ public final class mockwebserver3/MockResponse {
 	public final fun getMessage ()Ljava/lang/String;
 	public final fun getPushPromises ()Ljava/util/List;
 	public final fun getSettings ()Lokhttp3/internal/http2/Settings;
-	public final fun getSocketHandler ()Lmockwebserver3/SocketHandler;
 	public final fun getSocketPolicy ()Lmockwebserver3/SocketPolicy;
 	public final fun getStatus ()Ljava/lang/String;
+	public final fun getStreamHandler ()Lmockwebserver3/StreamHandler;
 	public final fun getThrottleBytesPerPeriod ()J
 	public final fun getThrottlePeriodNanos ()J
 	public final fun getTrailers ()Lokhttp3/Headers;
@@ -61,9 +61,9 @@ public final class mockwebserver3/MockResponse$Builder : java/lang/Cloneable {
 	public final fun getInformationalResponses ()Ljava/util/List;
 	public final fun getPushPromises ()Ljava/util/List;
 	public final fun getSettings ()Lokhttp3/internal/http2/Settings;
-	public final fun getSocketHandler ()Lmockwebserver3/SocketHandler;
 	public final fun getSocketPolicy ()Lmockwebserver3/SocketPolicy;
 	public final fun getStatus ()Ljava/lang/String;
+	public final fun getStreamHandler ()Lmockwebserver3/StreamHandler;
 	public final fun getThrottleBytesPerPeriod ()J
 	public final fun getThrottlePeriodNanos ()J
 	public final fun getTrailers ()Lokhttp3/Headers;
@@ -75,9 +75,9 @@ public final class mockwebserver3/MockResponse$Builder : java/lang/Cloneable {
 	public final fun removeHeader (Ljava/lang/String;)Lmockwebserver3/MockResponse$Builder;
 	public final fun setHeader (Ljava/lang/String;Ljava/lang/Object;)Lmockwebserver3/MockResponse$Builder;
 	public final fun settings (Lokhttp3/internal/http2/Settings;)Lmockwebserver3/MockResponse$Builder;
-	public final fun socketHandler (Lmockwebserver3/SocketHandler;)Lmockwebserver3/MockResponse$Builder;
 	public final fun socketPolicy (Lmockwebserver3/SocketPolicy;)Lmockwebserver3/MockResponse$Builder;
 	public final fun status (Ljava/lang/String;)Lmockwebserver3/MockResponse$Builder;
+	public final fun streamHandler (Lmockwebserver3/StreamHandler;)Lmockwebserver3/MockResponse$Builder;
 	public final fun throttleBody (JJLjava/util/concurrent/TimeUnit;)Lmockwebserver3/MockResponse$Builder;
 	public final fun trailers (Lokhttp3/Headers;)Lmockwebserver3/MockResponse$Builder;
 	public final fun trailersDelay (JLjava/util/concurrent/TimeUnit;)Lmockwebserver3/MockResponse$Builder;
@@ -171,10 +171,6 @@ public final class mockwebserver3/RecordedRequest {
 	public fun toString ()Ljava/lang/String;
 }
 
-public abstract interface class mockwebserver3/SocketHandler {
-	public abstract fun handle (Lokio/Socket;)V
-}
-
 public abstract interface class mockwebserver3/SocketPolicy {
 }
 
@@ -244,3 +240,13 @@ public final class mockwebserver3/SocketPolicy$StallSocketAtStart : mockwebserve
 	public static final field INSTANCE Lmockwebserver3/SocketPolicy$StallSocketAtStart;
 }
 
+public abstract interface class mockwebserver3/Stream {
+	public abstract fun cancel ()V
+	public abstract fun getRequestBody ()Lokio/BufferedSource;
+	public abstract fun getResponseBody ()Lokio/BufferedSink;
+}
+
+public abstract interface class mockwebserver3/StreamHandler {
+	public abstract fun handle (Lmockwebserver3/Stream;)V
+}
+
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/MockResponse.kt b/mockwebserver/src/main/kotlin/mockwebserver3/MockResponse.kt
index d1aa78a57..5b52f47a7 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/MockResponse.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/MockResponse.kt
@@ -57,7 +57,7 @@ class MockResponse {
   // At most one of (body,webSocketListener,streamHandler) is non-null.
   val body: MockResponseBody?
   val webSocketListener: WebSocketListener?
-  val socketHandler: SocketHandler?
+  val streamHandler: StreamHandler?
 
   val inTunnel: Boolean
   val informationalResponses: List<MockResponse>
@@ -94,7 +94,7 @@ class MockResponse {
     this.headers = builder.headers
     this.trailers = builder.trailers
     this.body = builder.body
-    this.socketHandler = builder.socketHandler
+    this.streamHandler = builder.streamHandler
     this.webSocketListener = builder.webSocketListener
     this.inTunnel = builder.inTunnel
     this.informationalResponses = builder.informationalResponses
@@ -150,22 +150,22 @@ class MockResponse {
     val trailers: Headers
       get() = trailers_.build()
 
-    // At most one of (body,webSocketListener,socketHandler) is non-null.
+    // At most one of (body,webSocketListener,streamHandler) is non-null.
     private var bodyVar: MockResponseBody? = null
-    private var socketHandlerVar: SocketHandler? = null
+    private var streamHandlerVar: StreamHandler? = null
     private var webSocketListenerVar: WebSocketListener? = null
 
     var body: MockResponseBody?
       get() = bodyVar
       private set(value) {
         bodyVar = value
-        socketHandlerVar = null
+        streamHandlerVar = null
         webSocketListenerVar = null
       }
-    var socketHandler: SocketHandler?
-      get() = socketHandlerVar
+    var streamHandler: StreamHandler?
+      get() = streamHandlerVar
       private set(value) {
-        socketHandlerVar = value
+        streamHandlerVar = value
         bodyVar = null
         webSocketListenerVar = null
       }
@@ -174,7 +174,7 @@ class MockResponse {
       private set(value) {
         webSocketListenerVar = value
         bodyVar = null
-        socketHandlerVar = null
+        streamHandlerVar = null
       }
 
     var throttleBytesPerPeriod: Long
@@ -205,7 +205,7 @@ class MockResponse {
       this.informationalResponses_ = mutableListOf()
       this.status = "HTTP/1.1 200 OK"
       this.bodyVar = null
-      this.socketHandlerVar = null
+      this.streamHandlerVar = null
       this.webSocketListenerVar = null
       this.headers_ =
         Headers
@@ -229,7 +229,7 @@ class MockResponse {
       this.headers_ = mockResponse.headers.newBuilder()
       this.trailers_ = mockResponse.trailers.newBuilder()
       this.bodyVar = mockResponse.body
-      this.socketHandlerVar = mockResponse.socketHandler
+      this.streamHandlerVar = mockResponse.streamHandler
       this.webSocketListenerVar = mockResponse.webSocketListener
       this.throttleBytesPerPeriod = mockResponse.throttleBytesPerPeriod
       this.throttlePeriodNanos = mockResponse.throttlePeriodNanos
@@ -322,9 +322,9 @@ class MockResponse {
     /** Sets the response body to the UTF-8 encoded bytes of [body]. */
     fun body(body: String): Builder = body(Buffer().writeUtf8(body))
 
-    fun socketHandler(socketHandler: SocketHandler) =
+    fun streamHandler(streamHandler: StreamHandler) =
       apply {
-        this.socketHandler = socketHandler
+        this.streamHandler = streamHandler
       }
 
     /**
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
index a4ce2a0fd..734d05e59 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
@@ -65,6 +65,7 @@ import mockwebserver3.SocketPolicy.ShutdownServerAfterResponse
 import mockwebserver3.SocketPolicy.StallSocketAtStart
 import mockwebserver3.internal.ThrottledSink
 import mockwebserver3.internal.TriggerSink
+import mockwebserver3.internal.duplex.RealStream
 import mockwebserver3.internal.sleepNanos
 import okhttp3.ExperimentalOkHttpApi
 import okhttp3.Headers
@@ -1052,7 +1053,7 @@ class MockWebServer : Closeable {
       val body = Buffer()
       val requestLine = "$method $path HTTP/1.1"
       var exception: IOException? = null
-      if (readBody && peek.socketHandler == null && peek.socketPolicy !is DoNotReadRequestBody) {
+      if (readBody && peek.streamHandler == null && peek.socketPolicy !is DoNotReadRequestBody) {
         try {
           val contentLengthString = headers["content-length"]
           val requestBodySink =
@@ -1064,7 +1065,7 @@ class MockWebServer : Closeable {
                 socket = socket,
               ).buffer()
           requestBodySink.use {
-            it.writeAll(stream.source)
+            it.writeAll(stream.getSource())
           }
         } catch (e: IOException) {
           exception = e
@@ -1108,11 +1109,11 @@ class MockWebServer : Closeable {
       val bodyDelayNanos = response.bodyDelayNanos
       val trailers = response.trailers
       val body = response.body
-      val socketHandler = response.socketHandler
+      val streamHandler = response.streamHandler
       val outFinished = (
         body == null &&
           response.pushPromises.isEmpty() &&
-          socketHandler == null
+          streamHandler == null
       )
       val flushHeaders = body == null || bodyDelayNanos != 0L
       require(!outFinished || trailers.size == 0) {
@@ -1130,7 +1131,7 @@ class MockWebServer : Closeable {
         sleepNanos(bodyDelayNanos)
         val responseBodySink =
           stream
-            .sink
+            .getSink()
             .withThrottlingAndSocketPolicy(
               policy = response,
               disconnectHalfway = response.socketPolicy == DisconnectDuringResponseBody,
@@ -1146,8 +1147,8 @@ class MockWebServer : Closeable {
             sleepNanos(response.trailersDelayNanos)
           }
         }
-      } else if (socketHandler != null) {
-        socketHandler.handle(stream)
+      } else if (streamHandler != null) {
+        streamHandler.handle(RealStream(stream))
       } else if (!outFinished) {
         sleepNanos(response.trailersDelayNanos)
         stream.close(ErrorCode.NO_ERROR, null)
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/Stream.kt b/mockwebserver/src/main/kotlin/mockwebserver3/Stream.kt
new file mode 100644
index 000000000..90c68534e
--- /dev/null
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/Stream.kt
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2022 Block, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package mockwebserver3
+
+import okhttp3.ExperimentalOkHttpApi
+import okio.BufferedSink
+import okio.BufferedSource
+
+/**
+ * A bidirectional sequence of data frames exchanged between client and server.
+ */
+@ExperimentalOkHttpApi
+interface Stream {
+  val requestBody: BufferedSource
+  val responseBody: BufferedSink
+
+  /**
+   * Terminate the stream so that no further data is transmitted or received. Note that
+   * [requestBody] may return data after this call; that is the buffered data received before this
+   * stream was canceled.
+   *
+   * This does nothing if [requestBody] and [responseBody] are already closed.
+   *
+   * For HTTP/2 this sends the [CANCEL](https://datatracker.ietf.org/doc/html/rfc7540#section-7)
+   * error code.
+   */
+  fun cancel()
+}
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/SocketHandler.kt b/mockwebserver/src/main/kotlin/mockwebserver3/StreamHandler.kt
similarity index 74%
rename from mockwebserver/src/main/kotlin/mockwebserver3/SocketHandler.kt
rename to mockwebserver/src/main/kotlin/mockwebserver3/StreamHandler.kt
index 1d2980454..f247b273c 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/SocketHandler.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/StreamHandler.kt
@@ -16,15 +16,14 @@
 package mockwebserver3
 
 import okhttp3.ExperimentalOkHttpApi
-import okio.Socket
 
 /**
- * Handles a call's request and response streams directly. Use this instead of [MockResponseBody] to
- * begin sending response data before all request data has been received.
+ * Handles a call's stream directly. Use this instead of [MockResponseBody] to begin sending
+ * response data before all request data has been received.
  *
  * See [okhttp3.RequestBody.isDuplex].
  */
 @ExperimentalOkHttpApi
-interface SocketHandler {
-  fun handle(socket: Socket)
+interface StreamHandler {
+  fun handle(stream: Stream)
 }
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/internal/duplex/MockSocketHandler.kt b/mockwebserver/src/main/kotlin/mockwebserver3/internal/duplex/MockStreamHandler.kt
similarity index 72%
rename from mockwebserver/src/main/kotlin/mockwebserver3/internal/duplex/MockSocketHandler.kt
rename to mockwebserver/src/main/kotlin/mockwebserver3/internal/duplex/MockStreamHandler.kt
index e040f6ed9..db4e0449d 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/internal/duplex/MockSocketHandler.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/internal/duplex/MockStreamHandler.kt
@@ -20,38 +20,24 @@ import java.util.concurrent.CountDownLatch
 import java.util.concurrent.FutureTask
 import java.util.concurrent.LinkedBlockingQueue
 import java.util.concurrent.TimeUnit
-import mockwebserver3.SocketHandler
-import okio.BufferedSink
-import okio.BufferedSource
-import okio.Socket
-import okio.buffer
+import mockwebserver3.Stream
+import mockwebserver3.StreamHandler
 import okio.utf8Size
 
-private typealias Action = (BufferedSocket) -> Unit
-
-private class BufferedSocket(
-  val socket: Socket,
-) {
-  val source: BufferedSource = socket.source.buffer()
-  val sink: BufferedSink = socket.sink.buffer()
-
-  fun cancel() {
-    socket.cancel()
-  }
-}
+private typealias Action = (Stream) -> Unit
 
 /**
  * A scriptable request/response conversation. Create the script by calling methods like
  * [receiveRequest] in the sequence they are run.
  */
-class MockSocketHandler : SocketHandler {
+class MockStreamHandler : StreamHandler {
   private val actions = LinkedBlockingQueue<Action>()
   private val results = LinkedBlockingQueue<FutureTask<Void>>()
 
   fun receiveRequest(expected: String) =
     apply {
       actions += { stream ->
-        val actual = stream.source.readUtf8(expected.utf8Size())
+        val actual = stream.requestBody.readUtf8(expected.utf8Size())
         if (actual != expected) throw AssertionError("$actual != $expected")
       }
     }
@@ -59,7 +45,7 @@ class MockSocketHandler : SocketHandler {
   fun exhaustRequest() =
     apply {
       actions += { stream ->
-        if (!stream.source.exhausted()) throw AssertionError("expected exhausted")
+        if (!stream.requestBody.exhausted()) throw AssertionError("expected exhausted")
       }
     }
 
@@ -72,7 +58,7 @@ class MockSocketHandler : SocketHandler {
     apply {
       actions += { stream ->
         try {
-          stream.source.exhausted()
+          stream.requestBody.exhausted()
           throw AssertionError("expected IOException")
         } catch (expected: IOException) {
         }
@@ -85,15 +71,15 @@ class MockSocketHandler : SocketHandler {
     responseSent: CountDownLatch = CountDownLatch(0),
   ) = apply {
     actions += { stream ->
-      stream.sink.writeUtf8(s)
-      stream.sink.flush()
+      stream.responseBody.writeUtf8(s)
+      stream.responseBody.flush()
       responseSent.countDown()
     }
   }
 
   fun exhaustResponse() =
     apply {
-      actions += { stream -> stream.sink.close() }
+      actions += { stream -> stream.responseBody.close() }
     }
 
   fun sleep(
@@ -103,20 +89,20 @@ class MockSocketHandler : SocketHandler {
     actions += { Thread.sleep(unit.toMillis(duration)) }
   }
 
-  override fun handle(socket: Socket) {
-    val task = serviceSocketTask(BufferedSocket(socket))
+  override fun handle(stream: Stream) {
+    val task = serviceStreamTask(stream)
     results.add(task)
     task.run()
   }
 
-  /** Returns a task that processes both request and response from [socket]. */
-  private fun serviceSocketTask(socket: BufferedSocket): FutureTask<Void> {
+  /** Returns a task that processes both request and response from [stream]. */
+  private fun serviceStreamTask(stream: Stream): FutureTask<Void> {
     return FutureTask<Void> {
-      socket.source.use {
-        socket.sink.use {
+      stream.requestBody.use {
+        stream.responseBody.use {
           while (true) {
             val action = actions.poll() ?: break
-            action(socket)
+            action(stream)
           }
         }
       }
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/internal/duplex/RealStream.kt b/mockwebserver/src/main/kotlin/mockwebserver3/internal/duplex/RealStream.kt
new file mode 100644
index 000000000..b1867d7b3
--- /dev/null
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/internal/duplex/RealStream.kt
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2022 Block, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package mockwebserver3.internal.duplex
+
+import mockwebserver3.Stream
+import okhttp3.internal.http2.ErrorCode
+import okhttp3.internal.http2.Http2Stream
+import okio.buffer
+
+/** Adapt OkHttp's internal [Http2Stream] type to the public [Stream] type. */
+internal class RealStream(
+  private val http2Stream: Http2Stream,
+) : Stream {
+  override val requestBody = http2Stream.getSource().buffer()
+  override val responseBody = http2Stream.getSink().buffer()
+
+  override fun cancel() {
+    http2Stream.closeLater(ErrorCode.CANCEL)
+  }
+}
diff --git a/mockwebserver/src/test/java/mockwebserver3/internal/http2/Http2Server.kt b/mockwebserver/src/test/java/mockwebserver3/internal/http2/Http2Server.kt
index bb818a090..ade3a3d5c 100644
--- a/mockwebserver/src/test/java/mockwebserver3/internal/http2/Http2Server.kt
+++ b/mockwebserver/src/test/java/mockwebserver3/internal/http2/Http2Server.kt
@@ -130,7 +130,7 @@ class Http2Server(
       outFinished = false,
       flushHeaders = false,
     )
-    val out = stream.sink.buffer()
+    val out = stream.getSink().buffer()
     out.writeUtf8("Not found: $path")
     out.close()
   }
@@ -150,7 +150,7 @@ class Http2Server(
       outFinished = false,
       flushHeaders = false,
     )
-    val out = stream.sink.buffer()
+    val out = stream.getSink().buffer()
     for (file in files) {
       val target = if (file.isDirectory) file.name + "/" else file.name
       out.writeUtf8("<a href='$target'>$target</a><br>")
@@ -174,7 +174,7 @@ class Http2Server(
       flushHeaders = false,
     )
     file.source().use { source ->
-      stream.sink.buffer().use { sink ->
+      stream.getSink().buffer().use { sink ->
         sink.writeAll(source)
       }
     }
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http2/Http2ExchangeCodec.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http2/Http2ExchangeCodec.kt
index ee4d569ff..3b02e28a7 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http2/Http2ExchangeCodec.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http2/Http2ExchangeCodec.kt
@@ -70,7 +70,7 @@ class Http2ExchangeCodec(
   override fun createRequestBody(
     request: Request,
     contentLength: Long,
-  ): Sink = stream!!.sink
+  ): Sink = stream!!.getSink()
 
   override fun writeRequestHeaders(request: Request) {
     if (stream != null) return
@@ -93,7 +93,7 @@ class Http2ExchangeCodec(
   }
 
   override fun finishRequest() {
-    stream!!.sink.close()
+    stream!!.getSink().close()
   }
 
   override fun readResponseHeaders(expectContinue: Boolean): Response.Builder? {
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http2/Http2Stream.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http2/Http2Stream.kt
index fa7337a16..c03f7c636 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http2/Http2Stream.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http2/Http2Stream.kt
@@ -32,7 +32,6 @@ import okio.AsyncTimeout
 import okio.Buffer
 import okio.BufferedSource
 import okio.Sink
-import okio.Socket
 import okio.Source
 import okio.Timeout
 
@@ -44,8 +43,7 @@ class Http2Stream internal constructor(
   outFinished: Boolean,
   inFinished: Boolean,
   headers: Headers?,
-) : Lockable,
-  Socket {
+) : Lockable {
   // Internal state is guarded by `this`. No long-running or potentially blocking operations are
   // performed while the lock is held.
 
@@ -66,12 +64,12 @@ class Http2Stream internal constructor(
   /** True if response headers have been sent or received. */
   private var hasResponseHeaders: Boolean = false
 
-  override val source =
+  internal val source =
     FramingSource(
       maxByteCount = connection.okHttpSettings.initialWindowSize.toLong(),
       finished = inFinished,
     )
-  override val sink =
+  internal val sink =
     FramingSink(
       finished = outFinished,
     )
@@ -236,6 +234,24 @@ class Http2Stream internal constructor(
 
   fun writeTimeout(): Timeout = writeTimeout
 
+  /** Returns a source that reads data from the peer. */
+  fun getSource(): Source = source
+
+  /**
+   * Returns a sink that can be used to write data to the peer.
+   *
+   * @throws IllegalStateException if this stream was initiated by the peer and a [writeHeaders] has
+   *     not yet been sent.
+   */
+  fun getSink(): Sink {
+    withLock {
+      check(hasResponseHeaders || isLocallyInitiated) {
+        "reply before requesting the sink"
+      }
+    }
+    return sink
+  }
+
   /**
    * Abnormally terminate this stream. This blocks until the `RST_STREAM` frame has been
    * transmitted.
@@ -251,10 +267,6 @@ class Http2Stream internal constructor(
     connection.writeSynReset(id, rstStatusCode)
   }
 
-  override fun cancel() {
-    closeLater(ErrorCode.CANCEL)
-  }
-
   /**
    * Abnormally terminate this stream. This enqueues a `RST_STREAM` frame and returns immediately.
    */
@@ -560,7 +572,7 @@ class Http2Stream internal constructor(
   }
 
   /** A sink that writes outgoing data frames of a stream. This class is not thread safe. */
-  inner class FramingSink(
+  internal inner class FramingSink(
     /** True if either side has cleanly shut down this stream. We shall send no more bytes. */
     var finished: Boolean = false,
   ) : Sink {
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt
index 0e0fa6e46..b342886e2 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt
@@ -35,7 +35,7 @@ import java.util.concurrent.TimeUnit
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.internal.duplex.MockSocketHandler
+import mockwebserver3.internal.duplex.MockStreamHandler
 import okhttp3.CallEvent.FollowUpDecision
 import okhttp3.Credentials.basic
 import okhttp3.Headers.Companion.headersOf
@@ -104,7 +104,7 @@ class DuplexTest {
   fun trueDuplexClientWritesFirst() {
     enableProtocol(Protocol.HTTP_2)
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .receiveRequest("request A\n")
         .sendResponse("response B\n")
         .receiveRequest("request C\n")
@@ -117,7 +117,7 @@ class DuplexTest {
       MockResponse
         .Builder()
         .clearHeaders()
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     val call =
@@ -153,7 +153,7 @@ class DuplexTest {
   fun trueDuplexServerWritesFirst() {
     enableProtocol(Protocol.HTTP_2)
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .sendResponse("response A\n")
         .receiveRequest("request B\n")
         .sendResponse("response C\n")
@@ -166,7 +166,7 @@ class DuplexTest {
       MockResponse
         .Builder()
         .clearHeaders()
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     val call =
@@ -202,7 +202,7 @@ class DuplexTest {
   fun clientReadsHeadersDataTrailers() {
     enableProtocol(Protocol.HTTP_2)
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .sendResponse("ok")
         .exhaustResponse()
     server.enqueue(
@@ -212,7 +212,7 @@ class DuplexTest {
         .addHeader("h1", "v1")
         .addHeader("h2", "v2")
         .trailers(headersOf("trailers", "boom"))
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     val call =
@@ -238,7 +238,7 @@ class DuplexTest {
     assumeNotWindows()
     enableProtocol(Protocol.HTTP_2)
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .exhaustResponse()
         .receiveRequest("hey\n")
         .receiveRequest("whats going on\n")
@@ -249,7 +249,7 @@ class DuplexTest {
         .clearHeaders()
         .addHeader("h1", "v1")
         .addHeader("h2", "v2")
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     val request =
@@ -272,7 +272,7 @@ class DuplexTest {
   fun requestBodyEndsAfterResponseBody() {
     enableProtocol(Protocol.HTTP_2)
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .exhaustResponse()
         .receiveRequest("request A\n")
         .exhaustRequest()
@@ -280,7 +280,7 @@ class DuplexTest {
       MockResponse
         .Builder()
         .clearHeaders()
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     val call =
@@ -328,7 +328,7 @@ class DuplexTest {
   fun duplexWith100Continue() {
     enableProtocol(Protocol.HTTP_2)
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .receiveRequest("request body\n")
         .sendResponse("response body\n")
         .exhaustRequest()
@@ -337,7 +337,7 @@ class DuplexTest {
         .Builder()
         .clearHeaders()
         .add100Continue()
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     val call =
@@ -393,7 +393,7 @@ class DuplexTest {
         .eventListener(listener)
         .build()
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .sendResponse("/a has moved!\n", duplexResponseSent)
         .requestIOException()
         .exhaustResponse()
@@ -403,7 +403,7 @@ class DuplexTest {
         .clearHeaders()
         .code(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: /b")
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     server.enqueue(
@@ -483,7 +483,7 @@ class DuplexTest {
         .authenticator(RecordingOkAuthenticator(credential, null))
         .build()
     val body1 =
-      MockSocketHandler()
+      MockStreamHandler()
         .sendResponse("please authenticate!\n")
         .requestIOException()
         .exhaustResponse()
@@ -492,11 +492,11 @@ class DuplexTest {
         .Builder()
         .clearHeaders()
         .code(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .socketHandler(body1)
+        .streamHandler(body1)
         .build(),
     )
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .sendResponse("response body\n")
         .exhaustResponse()
         .receiveRequest("request body\n")
@@ -505,7 +505,7 @@ class DuplexTest {
       MockResponse
         .Builder()
         .clearHeaders()
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     val call =
@@ -572,7 +572,7 @@ class DuplexTest {
   fun fullCallTimeoutDoesNotApplyOnceConnected() {
     enableProtocol(Protocol.HTTP_2)
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .sendResponse("response A\n")
         .sleep(750, TimeUnit.MILLISECONDS)
         .sendResponse("response B\n")
@@ -583,7 +583,7 @@ class DuplexTest {
       MockResponse
         .Builder()
         .clearHeaders()
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     val request =
@@ -614,7 +614,7 @@ class DuplexTest {
   fun duplexWithRewriteInterceptors() {
     enableProtocol(Protocol.HTTP_2)
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .receiveRequest("REQUEST A\n")
         .sendResponse("response B\n")
         .exhaustRequest()
@@ -623,7 +623,7 @@ class DuplexTest {
       MockResponse
         .Builder()
         .clearHeaders()
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     client =
@@ -672,7 +672,7 @@ class DuplexTest {
     val log: BlockingQueue<String?> = LinkedBlockingQueue()
     enableProtocol(Protocol.HTTP_2)
     val body =
-      MockSocketHandler()
+      MockStreamHandler()
         .sendResponse("success!")
         .exhaustResponse()
         .cancelStream()
@@ -680,7 +680,7 @@ class DuplexTest {
       MockResponse
         .Builder()
         .clearHeaders()
-        .socketHandler(body)
+        .streamHandler(body)
         .build(),
     )
     val call =
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/internal/http2/Http2ConnectionTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/internal/http2/Http2ConnectionTest.kt
index 8ffd58297..d66af76ba 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/internal/http2/Http2ConnectionTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/internal/http2/Http2ConnectionTest.kt
@@ -170,7 +170,7 @@ class Http2ConnectionTest {
     val connection = connect(peer)
     connection.writePingAndAwaitPong() // Ensure the SETTINGS have been received.
     val stream = connection.newStream(headerEntries("a", "android"), true)
-    val sink = stream.sink.buffer()
+    val sink = stream.getSink().buffer()
     sink.writeUtf8("abcdefghi")
     sink.flush()
 
@@ -205,7 +205,7 @@ class Http2ConnectionTest {
     peer.play()
     val connection = connect(peer)
     val stream1 = connection.newStream(headerEntries("b", "bark"), false)
-    val source = stream1.source
+    val source = stream1.getSource()
     val buffer = Buffer()
     while (buffer.size != 1024L) source.read(buffer, 1024)
     stream1.close(ErrorCode.CANCEL, null)
@@ -236,8 +236,8 @@ class Http2ConnectionTest {
     val stream1 = connection.newStream(headerEntries("a", "android"), true)
     val stream2 = connection.newStream(headerEntries("b", "banana"), true)
     connection.writePingAndAwaitPong() // Ensure the GO_AWAY that resets stream2 has been received.
-    val sink1 = stream1.sink.buffer()
-    val sink2 = stream2.sink.buffer()
+    val sink1 = stream1.getSink().buffer()
+    val sink2 = stream2.getSink().buffer()
     sink1.writeUtf8("abc")
     assertFailsWith<IOException> {
       sink2.writeUtf8("abc")
@@ -294,7 +294,7 @@ class Http2ConnectionTest {
     assertThat(stream.readBytes.acknowledged).isEqualTo(0L)
     assertThat(stream.readBytes.total).isEqualTo(0L)
     assertThat(stream.takeHeaders()).isEqualTo(headersOf("a", "android"))
-    val source = stream.source
+    val source = stream.getSource()
     val buffer = Buffer()
     buffer.writeAll(source)
     assertThat(source.read(buffer, 1)).isEqualTo(-1)
@@ -328,7 +328,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val client = connection.newStream(headerEntries("b", "banana"), false)
-    assertThat(client.source.read(Buffer(), 1)).isEqualTo(-1)
+    assertThat(client.getSource().read(Buffer(), 1)).isEqualTo(-1)
 
     // Verify the peer received what was expected.
     val synStream = peer.takeFrame()
@@ -348,7 +348,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val client = connection.newStream(headerEntries("b", "banana"), true)
-    val out = client.sink.buffer()
+    val out = client.getSink().buffer()
     out.write(EMPTY_BYTE_ARRAY)
     out.flush()
     out.close()
@@ -375,7 +375,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("b", "banana"), true)
-    val out = stream.sink.buffer()
+    val out = stream.getSink().buffer()
     out.write(buff)
     out.flush()
     out.close()
@@ -413,7 +413,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer, observer, Http2Connection.Listener.REFUSE_INCOMING_STREAMS)
     val client = connection.newStream(headerEntries("b", "banana"), false)
-    assertThat(client.source.read(Buffer(), 1)).isEqualTo(-1)
+    assertThat(client.getSource().read(Buffer(), 1)).isEqualTo(-1)
 
     // Verify the peer received what was expected.
     assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS)
@@ -524,11 +524,11 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("b", "banana"), true)
-    val out = stream.sink.buffer()
+    val out = stream.getSink().buffer()
     out.writeUtf8("c3po")
     out.close()
     assertThat(stream.takeHeaders()).isEqualTo(headersOf("a", "android"))
-    assertStreamData("robot", stream.source)
+    assertStreamData("robot", stream.getSource())
     connection.writePingAndAwaitPong()
     assertThat(connection.openStreamCount()).isEqualTo(0)
 
@@ -616,9 +616,9 @@ class Http2ConnectionTest {
     val stream = connection.newStream(headerEntries(), false)
     connection.writePingAndAwaitPong()
     assertThat(stream.takeHeaders()).isEqualTo(headersOf("a", "android"))
-    val source = stream.source.buffer()
+    val source = stream.getSource().buffer()
     assertThat(source.readUtf8(5)).isEqualTo("robot")
-    stream.sink.close()
+    stream.getSink().close()
     assertThat(connection.openStreamCount()).isEqualTo(0)
 
     // Verify the peer received what was expected.
@@ -646,7 +646,7 @@ class Http2ConnectionTest {
     val stream = connection.newStream(headerEntries(), true)
     connection.writePingAndAwaitPong()
     assertThat(stream.takeHeaders()).isEqualTo(headersOf("a", "android"))
-    stream.sink.close()
+    stream.getSink().close()
     assertThat(stream.trailers()).isEqualTo(headersOf("z", "zebra"))
     assertThat(connection.openStreamCount()).isEqualTo(0)
 
@@ -677,7 +677,7 @@ class Http2ConnectionTest {
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries(), true)
     connection.writePingAndAwaitPong()
-    val sink = stream.sink.buffer()
+    val sink = stream.getSink().buffer()
     sink.writeUtf8("abc")
     assertFailsWith<StreamResetException> {
       sink.close()
@@ -685,7 +685,7 @@ class Http2ConnectionTest {
       assertThat(expected.errorCode).isEqualTo(ErrorCode.NO_ERROR)
     }
     assertThat(stream.takeHeaders()).isEqualTo(headersOf("a", "android"))
-    val source = stream.source.buffer()
+    val source = stream.getSource().buffer()
     assertThat(source.readUtf8(5)).isEqualTo("robot")
     assertThat(connection.openStreamCount()).isEqualTo(0)
 
@@ -716,7 +716,7 @@ class Http2ConnectionTest {
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("a", "android"), true)
     stream.enqueueTrailers(headersOf("foo", "bar"))
-    val sink = stream.sink.buffer()
+    val sink = stream.getSink().buffer()
     sink.writeUtf8("abcdefghi")
     sink.close()
 
@@ -805,7 +805,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("a", "artichaut"), false)
-    val source = stream.source.buffer()
+    val source = stream.getSource().buffer()
     connection.writePingAndAwaitPong()
     assertThat(stream.takeHeaders()).isEqualTo(headersOf("headers", "bam"))
     assertThat(source.readUtf8(5)).isEqualTo("robot")
@@ -836,7 +836,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("b", "banana"), true)
-    val out = stream.sink.buffer()
+    val out = stream.getSink().buffer()
     out.writeUtf8("c3po")
     out.close()
     stream.writeHeaders(headerEntries("e", "elephant"), false, false)
@@ -1088,7 +1088,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("a", "android"), true)
-    val out = stream.sink.buffer()
+    val out = stream.getSink().buffer()
     connection.writePingAndAwaitPong() // Ensure that the RST_CANCEL has been received.
     assertFailsWith<IOException> {
       out.writeUtf8("square")
@@ -1125,8 +1125,8 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("a", "android"), false)
-    val source = stream.source
-    val out = stream.sink.buffer()
+    val source = stream.getSource()
+    val out = stream.getSink().buffer()
     source.close()
     assertFailsWith<IOException> {
       source.read(Buffer(), 1)
@@ -1167,8 +1167,8 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("a", "android"), true)
-    val source = stream.source
-    val out = stream.sink.buffer()
+    val source = stream.getSource()
+    val out = stream.getSink().buffer()
     source.close()
     assertFailsWith<IOException> {
       source.read(Buffer(), 1)
@@ -1211,7 +1211,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("a", "android"), false)
-    val source = stream.source
+    val source = stream.getSource()
     assertStreamData("square", source)
     connection.writePingAndAwaitPong() // Ensure that inFinished has been received.
     assertThat(connection.openStreamCount()).isEqualTo(0)
@@ -1264,7 +1264,7 @@ class Http2ConnectionTest {
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("b", "banana"), false)
     assertThat(stream.takeHeaders()).isEqualTo(headersOf("a", "android"))
-    assertStreamData("robot", stream.source)
+    assertStreamData("robot", stream.getSource())
 
     // Verify the peer received what was expected.
     val synStream = peer.takeFrame()
@@ -1351,8 +1351,8 @@ class Http2ConnectionTest {
     val stream1 = connection.newStream(headerEntries("a", "android"), true)
     val stream2 = connection.newStream(headerEntries("b", "banana"), true)
     connection.writePingAndAwaitPong() // Ensure the GO_AWAY that resets stream2 has been received.
-    val sink1 = stream1.sink.buffer()
-    val sink2 = stream2.sink.buffer()
+    val sink1 = stream1.getSink().buffer()
+    val sink2 = stream2.getSink().buffer()
     sink1.writeUtf8("abc")
     assertFailsWith<IOException> {
       sink2.writeUtf8("abc")
@@ -1435,7 +1435,7 @@ class Http2ConnectionTest {
     assertFailsWith<ConnectionShutdownException> {
       connection.newStream(headerEntries("b", "banana"), false)
     }
-    val sink = stream.sink.buffer()
+    val sink = stream.getSink().buffer()
     assertFailsWith<IOException> {
       sink.writeByte(0)
       sink.flush()
@@ -1443,7 +1443,7 @@ class Http2ConnectionTest {
       assertThat(expected.message).isEqualTo("stream finished")
     }
     assertFailsWith<IOException> {
-      stream.source.read(Buffer(), 1)
+      stream.getSource().read(Buffer(), 1)
     }.also { expected ->
       assertThat(expected.message).isEqualTo("stream was reset: CANCEL")
     }
@@ -1509,7 +1509,7 @@ class Http2ConnectionTest {
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("b", "banana"), false)
     stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS)
-    val source = stream.source.buffer()
+    val source = stream.getSource().buffer()
     source.require(3)
     val startNanos = System.nanoTime()
     assertFailsWith<InterruptedIOException> {
@@ -1559,7 +1559,7 @@ class Http2ConnectionTest {
     val connection = connect(peer)
     connection.writePingAndAwaitPong() // Make sure settings have been received.
     val stream = connection.newStream(headerEntries("b", "banana"), true)
-    val sink = stream.sink
+    val sink = stream.getSink()
     sink.write(Buffer().writeUtf8("abcde"), 5)
     stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS)
     val startNanos = System.nanoTime()
@@ -1604,7 +1604,7 @@ class Http2ConnectionTest {
     connection.writePingAndAwaitPong() // Make sure settings have been acked.
     val stream = connection.newStream(headerEntries("b", "banana"), true)
     connection.writePingAndAwaitPong() // Make sure the window update has been received.
-    val sink = stream.sink
+    val sink = stream.getSink()
     stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS)
     sink.write(Buffer().writeUtf8("abcdef"), 6)
     val startNanos = System.nanoTime()
@@ -1640,7 +1640,7 @@ class Http2ConnectionTest {
     val stream = connection.newStream(headerEntries("b", "banana"), true)
 
     // two outgoing writes
-    val sink = stream.sink
+    val sink = stream.getSink()
     sink.write(Buffer().writeUtf8("abcde"), 5)
     sink.write(Buffer().writeUtf8("fghij"), 5)
     sink.close()
@@ -1735,7 +1735,7 @@ class Http2ConnectionTest {
     assertThat(stream.readBytes.acknowledged).isEqualTo(0L)
     assertThat(stream.readBytes.total).isEqualTo(0L)
     assertThat(stream.takeHeaders()).isEqualTo(headersOf("a", "android"))
-    val source = stream.source
+    val source = stream.getSource()
     val buffer = Buffer()
     buffer.writeAll(source)
     assertThat(source.read(buffer, 1)).isEqualTo(-1)
@@ -1770,7 +1770,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val client = connection.newStream(headerEntries("b", "banana"), false)
-    assertThat(client.source.read(Buffer(), 1)).isEqualTo(-1)
+    assertThat(client.getSource().read(Buffer(), 1)).isEqualTo(-1)
 
     // Verify the peer received what was expected.
     val synStream = peer.takeFrame()
@@ -1790,7 +1790,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val client = connection.newStream(headerEntries("b", "banana"), true)
-    val out = client.sink.buffer()
+    val out = client.getSink().buffer()
     out.write(EMPTY_BYTE_ARRAY)
     out.flush()
     out.close()
@@ -1815,7 +1815,7 @@ class Http2ConnectionTest {
     val connection = connect(peer)
     val stream = connection.newStream(headerEntries("b", "banana"), false)
     assertThat(stream.takeHeaders()).isEqualTo(headersOf("a", "android"))
-    val source = stream.source
+    val source = stream.getSource()
     assertFailsWith<EOFException> {
       source.buffer().readByteString(101)
     }
@@ -1839,7 +1839,7 @@ class Http2ConnectionTest {
     // Play it back.
     val connection = connect(peer)
     val stream1 = connection.newStream(headerEntries("a", "apple"), true)
-    val out1 = stream1.sink.buffer()
+    val out1 = stream1.getSink().buffer()
     out1.write(ByteArray(Settings.DEFAULT_INITIAL_WINDOW_SIZE))
     out1.flush()
 
@@ -1866,7 +1866,7 @@ class Http2ConnectionTest {
 
     // Another stream should be able to send data even though 1 is blocked.
     val stream2 = connection.newStream(headerEntries("b", "banana"), true)
-    val out2 = stream2.sink.buffer()
+    val out2 = stream2.getSink().buffer()
     out2.writeUtf8("foo")
     out2.flush()
     assertThat(connection.writeBytesTotal)
