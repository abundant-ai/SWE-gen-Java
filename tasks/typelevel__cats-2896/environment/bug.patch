diff --git a/build.sbt b/build.sbt
index 12c1d4bbb..1ec1938c3 100644
--- a/build.sbt
+++ b/build.sbt
@@ -38,23 +38,21 @@ crossScalaVersionsFromTravis in Global := {
   }
 }
 
-def scalaVersionSpecificFolders(srcName: String, srcBaseDir: java.io.File, scalaVersion: String) = {
-  def extraDirs(suffix: String) =
-    CrossType.Pure.sharedSrcDir(srcBaseDir, "main").toList.map(f => file(f.getPath + suffix))
-  CrossVersion.partialVersion(scalaVersion) match {
-    case Some((2, y)) if y <= 12 =>
-      extraDirs("-2.12-")
-    case Some((2, y)) if y >= 13 =>
-      extraDirs("-2.13+")
-    case _ => Nil
-  }
-}
-
 lazy val commonSettings = Seq(
   crossScalaVersions := (crossScalaVersionsFromTravis in Global).value,
   scalacOptions ++= commonScalacOptions(scalaVersion.value),
-  Compile / unmanagedSourceDirectories ++= scalaVersionSpecificFolders("main", baseDirectory.value, scalaVersion.value),
-  Test / unmanagedSourceDirectories ++= scalaVersionSpecificFolders("test", baseDirectory.value, scalaVersion.value),
+  Compile / unmanagedSourceDirectories ++= {
+    val bd = baseDirectory.value
+    def extraDirs(suffix: String) =
+      CrossType.Pure.sharedSrcDir(bd, "main").toList.map(f => file(f.getPath + suffix))
+    CrossVersion.partialVersion(scalaVersion.value) match {
+      case Some((2, y)) if y <= 12 =>
+        extraDirs("-2.12-")
+      case Some((2, y)) if y >= 13 =>
+        extraDirs("-2.13+")
+      case _ => Nil
+    }
+  },
   resolvers ++= Seq(Resolver.sonatypeRepo("releases"), Resolver.sonatypeRepo("snapshots")),
   parallelExecution in Test := false,
   scalacOptions in (Compile, doc) := (scalacOptions in (Compile, doc)).value.filter(_ != "-Xfatal-warnings"),
@@ -803,13 +801,13 @@ def commonScalacOptions(scalaVersion: String) =
     "-unchecked",
     "-Ywarn-dead-code",
     "-Ywarn-numeric-widen",
-    "-Ywarn-value-discard"
+    "-Ywarn-value-discard",
+    "-Xfuture"
   ) ++ (if (priorTo2_13(scalaVersion))
           Seq(
             "-Yno-adapted-args",
             "-Xfatal-warnings", // TODO: add the following two back to 2.13
-            "-deprecation",
-            "-Xfuture"
+            "-deprecation"
           )
         else
           Seq(
diff --git a/core/src/main/scala/cats/instances/SymbolInstances.scala b/core/src/main/scala/cats/instances/symbol.scala
similarity index 66%
rename from core/src/main/scala/cats/instances/SymbolInstances.scala
rename to core/src/main/scala/cats/instances/symbol.scala
index 4ec75cc11..d55d0942d 100644
--- a/core/src/main/scala/cats/instances/SymbolInstances.scala
+++ b/core/src/main/scala/cats/instances/symbol.scala
@@ -1,6 +1,7 @@
-package cats.instances
+package cats
+package instances
 
-import cats.Show
+package object symbol extends SymbolInstances
 
 trait SymbolInstances extends cats.kernel.instances.SymbolInstances {
   implicit val catsStdShowForSymbol: Show[Symbol] =
diff --git a/core/src/main/scala/cats/instances/symbol/package.scala b/core/src/main/scala/cats/instances/symbol/package.scala
deleted file mode 100644
index 769d9fb97..000000000
--- a/core/src/main/scala/cats/instances/symbol/package.scala
+++ /dev/null
@@ -1,4 +0,0 @@
-package cats
-package instances
-
-package object symbol extends SymbolInstances
diff --git a/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala b/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
index 3c3d398d3..1931a58a1 100644
--- a/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
@@ -8,18 +8,18 @@ package discipline
  * domain of values as opposed to generating a random sampling of values.
  */
 trait ExhaustiveCheck[A] extends Serializable { self =>
-  def allValues: List[A]
+  def allValues: Stream[A]
 }
 
 object ExhaustiveCheck {
   def apply[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[A] = A
 
-  def instance[A](values: List[A]): ExhaustiveCheck[A] = new ExhaustiveCheck[A] {
-    val allValues: List[A] = values
+  def instance[A](values: Stream[A]): ExhaustiveCheck[A] = new ExhaustiveCheck[A] {
+    val allValues: Stream[A] = values
   }
 
   implicit val catsLawsExhaustiveCheckForBoolean: ExhaustiveCheck[Boolean] =
-    instance(List(false, true))
+    instance(Stream(false, true))
 
   implicit val catsLawsExhaustiveCheckForSetBoolean: ExhaustiveCheck[Set[Boolean]] =
     forSet[Boolean]
@@ -50,7 +50,7 @@ object ExhaustiveCheck {
     instance(A.allValues.map(Left(_)) ++ B.allValues.map(Right(_)))
 
   implicit def catsLawsExhaustiveCheckForOption[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[Option[A]] =
-    instance(None :: A.allValues.map(Some(_)))
+    instance(Stream.cons(None, A.allValues.map(Some(_))))
 
   /**
    * Creates an `ExhaustiveCheck[Set[A]]` given an `ExhaustiveCheck[A]` by computing the powerset of
@@ -58,5 +58,5 @@ object ExhaustiveCheck {
    * in the domain of `Set[A]`, so use this only on small domains.
    */
   def forSet[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[Set[A]] =
-    instance(A.allValues.toSet.subsets.toList)
+    instance(A.allValues.toSet.subsets.toStream)
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/MiniInt.scala b/laws/src/main/scala/cats/laws/discipline/MiniInt.scala
index 0adf97838..bc193ab6c 100644
--- a/laws/src/main/scala/cats/laws/discipline/MiniInt.scala
+++ b/laws/src/main/scala/cats/laws/discipline/MiniInt.scala
@@ -49,7 +49,7 @@ object MiniInt {
       new MiniInt(i << intShift >>> intShift)
     } else throw new IllegalArgumentException(s"Expected value between $minIntValue and $maxIntValue but got $i")
 
-  val allValues: List[MiniInt] = (minIntValue to maxIntValue).map(unsafeFromInt).toList
+  val allValues: Stream[MiniInt] = (minIntValue to maxIntValue).map(unsafeFromInt).toStream
 
   implicit val catsLawsEqInstancesForMiniInt: Order[MiniInt] with Hash[MiniInt] = new Order[MiniInt]
   with Hash[MiniInt] {
@@ -58,7 +58,7 @@ object MiniInt {
     def compare(x: MiniInt, y: MiniInt): Int = Order[Int].compare(x.toInt, y.toInt)
   }
 
-  implicit val catsLawsExhaustiveCheckForMiniInt: ExhaustiveCheck[MiniInt] =
+  implicit val catsLawsExhuastiveCheckForMiniInt: ExhaustiveCheck[MiniInt] =
     ExhaustiveCheck.instance(allValues)
 
   val miniIntAddition: CommutativeGroup[MiniInt] = new CommutativeGroup[MiniInt] {
diff --git a/tests/src/test/scala/cats/tests/BinCodecInvariantMonoidalSuite.scala b/tests/src/test/scala/cats/tests/BinCodecInvariantMonoidalSuite.scala
index 768668d21..2e6390c48 100644
--- a/tests/src/test/scala/cats/tests/BinCodecInvariantMonoidalSuite.scala
+++ b/tests/src/test/scala/cats/tests/BinCodecInvariantMonoidalSuite.scala
@@ -51,8 +51,8 @@ object BinCodecInvariantMonoidalSuite {
     implicit val exhaustiveCheckForMiniListBoolean: ExhaustiveCheck[MiniList[Boolean]] =
       ExhaustiveCheck.instance(
         for {
-          length <- (0 to maxLength).toList
-          boolList <- List(false, true).replicateA(length)
+          length <- (0 to maxLength).toStream
+          boolList <- List(false, true).replicateA(length).toStream
         } yield MiniList.unsafe(boolList)
       )
   }
diff --git a/tests/src/test/scala/cats/tests/NonEmptySetSuite.scala b/tests/src/test/scala/cats/tests/NonEmptySetSuite.scala
index 95cf903c4..884606286 100644
--- a/tests/src/test/scala/cats/tests/NonEmptySetSuite.scala
+++ b/tests/src/test/scala/cats/tests/NonEmptySetSuite.scala
@@ -21,7 +21,7 @@ import cats.laws.discipline._
 import cats.laws.discipline.arbitrary._
 import cats.data.NonEmptySet
 import cats.kernel.Semilattice
-import cats.kernel.laws.discipline.{EqTests, OrderTests, SemilatticeTests}
+import cats.kernel.laws.discipline.{EqTests, OrderTests, PartialOrderTests, SemilatticeTests}
 
 import scala.collection.immutable.SortedSet
 
