diff --git a/core/src/main/scala/cats/instances/SymbolInstances.scala b/core/src/main/scala/cats/instances/SymbolInstances.scala
new file mode 100644
index 000000000..4ec75cc11
--- /dev/null
+++ b/core/src/main/scala/cats/instances/SymbolInstances.scala
@@ -0,0 +1,8 @@
+package cats.instances
+
+import cats.Show
+
+trait SymbolInstances extends cats.kernel.instances.SymbolInstances {
+  implicit val catsStdShowForSymbol: Show[Symbol] =
+    Show.fromToString[Symbol]
+}
diff --git a/core/src/main/scala/cats/instances/symbol.scala b/core/src/main/scala/cats/instances/symbol.scala
deleted file mode 100644
index d55d0942d..000000000
--- a/core/src/main/scala/cats/instances/symbol.scala
+++ /dev/null
@@ -1,9 +0,0 @@
-package cats
-package instances
-
-package object symbol extends SymbolInstances
-
-trait SymbolInstances extends cats.kernel.instances.SymbolInstances {
-  implicit val catsStdShowForSymbol: Show[Symbol] =
-    Show.fromToString[Symbol]
-}
diff --git a/core/src/main/scala/cats/instances/symbol/package.scala b/core/src/main/scala/cats/instances/symbol/package.scala
new file mode 100644
index 000000000..769d9fb97
--- /dev/null
+++ b/core/src/main/scala/cats/instances/symbol/package.scala
@@ -0,0 +1,4 @@
+package cats
+package instances
+
+package object symbol extends SymbolInstances
diff --git a/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala b/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
index 1931a58a1..3c3d398d3 100644
--- a/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
@@ -8,18 +8,18 @@ package discipline
  * domain of values as opposed to generating a random sampling of values.
  */
 trait ExhaustiveCheck[A] extends Serializable { self =>
-  def allValues: Stream[A]
+  def allValues: List[A]
 }

 object ExhaustiveCheck {
   def apply[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[A] = A

-  def instance[A](values: Stream[A]): ExhaustiveCheck[A] = new ExhaustiveCheck[A] {
-    val allValues: Stream[A] = values
+  def instance[A](values: List[A]): ExhaustiveCheck[A] = new ExhaustiveCheck[A] {
+    val allValues: List[A] = values
   }

   implicit val catsLawsExhaustiveCheckForBoolean: ExhaustiveCheck[Boolean] =
-    instance(Stream(false, true))
+    instance(List(false, true))

   implicit val catsLawsExhaustiveCheckForSetBoolean: ExhaustiveCheck[Set[Boolean]] =
     forSet[Boolean]
@@ -50,7 +50,7 @@ object ExhaustiveCheck {
     instance(A.allValues.map(Left(_)) ++ B.allValues.map(Right(_)))

   implicit def catsLawsExhaustiveCheckForOption[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[Option[A]] =
-    instance(Stream.cons(None, A.allValues.map(Some(_))))
+    instance(None :: A.allValues.map(Some(_)))

   /**
    * Creates an `ExhaustiveCheck[Set[A]]` given an `ExhaustiveCheck[A]` by computing the powerset of
@@ -58,5 +58,5 @@ object ExhaustiveCheck {
    * in the domain of `Set[A]`, so use this only on small domains.
    */
   def forSet[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[Set[A]] =
-    instance(A.allValues.toSet.subsets.toStream)
+    instance(A.allValues.toSet.subsets.toList)
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/MiniInt.scala b/laws/src/main/scala/cats/laws/discipline/MiniInt.scala
index bc193ab6c..0adf97838 100644
--- a/laws/src/main/scala/cats/laws/discipline/MiniInt.scala
+++ b/laws/src/main/scala/cats/laws/discipline/MiniInt.scala
@@ -49,7 +49,7 @@ object MiniInt {
       new MiniInt(i << intShift >>> intShift)
     } else throw new IllegalArgumentException(s"Expected value between $minIntValue and $maxIntValue but got $i")

-  val allValues: Stream[MiniInt] = (minIntValue to maxIntValue).map(unsafeFromInt).toStream
+  val allValues: List[MiniInt] = (minIntValue to maxIntValue).map(unsafeFromInt).toList

   implicit val catsLawsEqInstancesForMiniInt: Order[MiniInt] with Hash[MiniInt] = new Order[MiniInt]
   with Hash[MiniInt] {
@@ -58,7 +58,7 @@ object MiniInt {
     def compare(x: MiniInt, y: MiniInt): Int = Order[Int].compare(x.toInt, y.toInt)
   }

-  implicit val catsLawsExhuastiveCheckForMiniInt: ExhaustiveCheck[MiniInt] =
+  implicit val catsLawsExhaustiveCheckForMiniInt: ExhaustiveCheck[MiniInt] =
     ExhaustiveCheck.instance(allValues)

   val miniIntAddition: CommutativeGroup[MiniInt] = new CommutativeGroup[MiniInt] {
