diff --git a/pom.xml b/pom.xml
index 439fd2ff..51f82032 100644
--- a/pom.xml
+++ b/pom.xml
@@ -53,7 +53,7 @@
     <okhttp.version>2.5.0-SNAPSHOT</okhttp.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.13</rxjava.version>
+    <rxjava.version>1.0.10</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.3.1</gson.version>
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java
similarity index 74%
rename from retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
rename to retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java
index 8a338fae..3fd67a6c 100644
--- a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/ObservableBehaviorAdapter.java
@@ -16,24 +16,27 @@
 package retrofit.mock;
 
 import rx.Observable;
-import rx.Single;
 import rx.functions.Func1;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
-final class SingleHelper {
-  @SuppressWarnings("unchecked") // Caller must instanceof / getClass() verify 'value' is Single.
-  public static Object applySingleBehavior(final Behavior behavior, Object value) {
-    final Single<Object> single = (Single<Object>) value;
+public final class ObservableBehaviorAdapter implements BehaviorAdapter<Observable<?>> {
+  public static ObservableBehaviorAdapter create() {
+    return new ObservableBehaviorAdapter();
+  }
+
+  private ObservableBehaviorAdapter() {
+  }
+
+  @Override public Observable<?> applyBehavior(final Behavior behavior, final Observable<?> value) {
     return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
         .flatMap(new Func1<Long, Observable<?>>() {
           @Override public Observable<?> call(Long ignored) {
             if (behavior.calculateIsFailure()) {
               return Observable.error(behavior.failureException());
             }
-            return single.toObservable();
+            return value;
           }
-        })
-        .toSingle();
+        });
   }
 }
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
deleted file mode 100644
index 7e96b5e2..00000000
--- a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit.mock;
-
-import rx.Observable;
-import rx.functions.Func1;
-
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-
-public final class RxJavaBehaviorAdapter implements BehaviorAdapter<Object> {
-  public static RxJavaBehaviorAdapter create() {
-    return new RxJavaBehaviorAdapter();
-  }
-
-  private RxJavaBehaviorAdapter() {
-  }
-
-  @Override public Object applyBehavior(Behavior behavior, Object value) {
-    if (value instanceof Observable) {
-      return applyObservableBehavior(behavior, (Observable<?>) value);
-    }
-    String name = value.getClass().getCanonicalName();
-    if ("rx.Single".equals(name)) {
-      // Apply behavior to the Single from a separate class. This defers classloading such that
-      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
-      return SingleHelper.applySingleBehavior(behavior, value);
-    }
-    throw new IllegalStateException("Unsupported type " + name);
-  }
-
-  public Observable<?> applyObservableBehavior(final Behavior behavior, final Observable<?> value) {
-    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
-        .flatMap(new Func1<Long, Observable<?>>() {
-          @Override public Observable<?> call(Long ignored) {
-            if (behavior.calculateIsFailure()) {
-              return Observable.error(behavior.failureException());
-            }
-            return value;
-          }
-        });
-  }
-}
diff --git a/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java
similarity index 55%
rename from retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
rename to retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java
index 18ac4546..6b2528f6 100644
--- a/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/RxJavaBehaviorAdapterTest.java
+++ b/retrofit-adapters/rxjava-mock/src/test/java/retrofit/mock/ObservableBehaviorAdapterTest.java
@@ -23,7 +23,6 @@ import java.util.concurrent.atomic.AtomicReference;
 import org.junit.Before;
 import org.junit.Test;
 import rx.Observable;
-import rx.Single;
 import rx.Subscriber;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
@@ -31,10 +30,9 @@ import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertTrue;
 
-public final class RxJavaBehaviorAdapterTest {
+public final class ObservableBehaviorAdapterTest {
   interface DoWorkService {
-    Observable<String> observableResponse();
-    Single<String> singleResponse();
+    Observable<String> response();
   }
 
   private final Behavior behavior = Behavior.create(new Random(2847));
@@ -42,88 +40,22 @@ public final class RxJavaBehaviorAdapterTest {
 
   @Before public void setUp() {
     DoWorkService mockService = new DoWorkService() {
-      @Override public Observable<String> observableResponse() {
+      @Override public Observable<String> response() {
         return Observable.just("Hi!");
       }
-
-      @Override public Single<String> singleResponse() {
-        return Single.just("Hi!");
-      }
     };
 
-    BehaviorAdapter<?> adapter = RxJavaBehaviorAdapter.create();
+    BehaviorAdapter<?> adapter = ObservableBehaviorAdapter.create();
     MockRetrofit mockRetrofit = new MockRetrofit(adapter, behavior);
     service = mockRetrofit.create(DoWorkService.class, mockService);
   }
 
-  @Test public void observableFailureAfterDelay() throws InterruptedException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(100);
-
-    Observable<String> observable = service.observableResponse();
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    observable.subscribe(new Subscriber<String>() {
-      @Override public void onNext(String s) {
-        throw new AssertionError();
-      }
-
-      @Override public void onError(Throwable throwable) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        failureRef.set(throwable);
-        latch.countDown();
-      }
-
-      @Override public void onCompleted() {
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(failureRef.get()).isSameAs(behavior.failureException());
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void observableSuccessAfterDelay() throws InterruptedException {
-    behavior.setDelay(100, MILLISECONDS);
-    behavior.setVariancePercent(0);
-    behavior.setFailurePercent(0);
-
-    Observable<String> observable = service.observableResponse();
-
-    final long startNanos = System.nanoTime();
-    final AtomicLong tookMs = new AtomicLong();
-    final AtomicReference<String> actual = new AtomicReference<>();
-    final CountDownLatch latch = new CountDownLatch(1);
-    observable.subscribe(new Subscriber<String>() {
-      @Override public void onNext(String value) {
-        tookMs.set(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));
-        actual.set(value);
-        latch.countDown();
-      }
-
-      @Override public void onError(Throwable throwable) {
-        throw new AssertionError();
-      }
-
-      @Override public void onCompleted() {
-      }
-    });
-    assertTrue(latch.await(1, SECONDS));
-
-    assertThat(actual.get()).isEqualTo("Hi!");
-    assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
-  }
-
-  @Test public void singleFailureAfterDelay() throws InterruptedException {
+  @Test public void failureAfterDelay() throws InterruptedException {
     behavior.setDelay(100, MILLISECONDS);
     behavior.setVariancePercent(0);
     behavior.setFailurePercent(100);
 
-    Single<String> observable = service.singleResponse();
+    Observable<String> observable = service.response();
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
@@ -149,12 +81,12 @@ public final class RxJavaBehaviorAdapterTest {
     assertThat(tookMs.get()).isGreaterThanOrEqualTo(100);
   }
 
-  @Test public void singleSuccessAfterDelay() throws InterruptedException {
+  @Test public void successAfterDelay() throws InterruptedException {
     behavior.setDelay(100, MILLISECONDS);
     behavior.setVariancePercent(0);
     behavior.setFailurePercent(0);
 
-    Single<String> observable = service.singleResponse();
+    Observable<String> observable = service.response();
 
     final long startNanos = System.nanoTime();
     final AtomicLong tookMs = new AtomicLong();
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
similarity index 82%
rename from retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
rename to retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
index b715e1dc..9691968b 100644
--- a/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/ObservableCallAdapterFactory.java
@@ -26,41 +26,29 @@ import rx.subscriptions.Subscriptions;
 /**
  * TODO docs
  */
-public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
+public final class ObservableCallAdapterFactory implements CallAdapter.Factory {
   /**
    * TODO
    */
-  public static RxJavaCallAdapterFactory create() {
-    return new RxJavaCallAdapterFactory();
+  public static ObservableCallAdapterFactory create() {
+    return new ObservableCallAdapterFactory();
   }
 
-  private RxJavaCallAdapterFactory() {
+  private ObservableCallAdapterFactory() {
   }
 
   @Override public CallAdapter<?> get(Type returnType) {
-    Class<?> rawType = Utils.getRawType(returnType);
-    boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
-    if (rawType != Observable.class && !isSingle) {
+    if (Utils.getRawType(returnType) != Observable.class) {
       return null;
     }
     if (!(returnType instanceof ParameterizedType)) {
-      String name = isSingle ? "Single" : "Observable";
-      throw new IllegalStateException(name + " return type must be parameterized"
-          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+      throw new IllegalStateException("Observable return type must be parameterized"
+          + " as Observable<Foo> or Observable<? extends Foo>");
     }
 
-    CallAdapter<Object> callAdapter = getCallAdapter(returnType);
-    if (isSingle) {
-      // Add Single-converter wrapper from a separate class. This defers classloading such that
-      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
-      callAdapter = SingleHelper.makeSingle(callAdapter);
-    }
-    return callAdapter;
-  }
-
-  private CallAdapter<Object> getCallAdapter(Type returnType) {
     Type observableType = Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
     Class<?> rawObservableType = Utils.getRawType(observableType);
+
     if (rawObservableType == Response.class) {
       if (!(observableType instanceof ParameterizedType)) {
         throw new IllegalStateException("Response must be parameterized"
@@ -79,7 +67,7 @@ public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
       return new ResultCallAdapter<>(responseType);
     }
 
-    return new SimpleCallAdapter<>(observableType);
+    return new SimpleCallAdapter(observableType);
   }
 
   static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
deleted file mode 100644
index 01f91d7f..00000000
--- a/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import java.lang.reflect.Type;
-import rx.Observable;
-import rx.Single;
-
-final class SingleHelper {
-  static CallAdapter<Object> makeSingle(final CallAdapter<Object> callAdapter) {
-    return new CallAdapter<Object>() {
-      @Override public Type responseType() {
-        return callAdapter.responseType();
-      }
-
-      @Override public Single<?> adapt(Call<Object> call) {
-        Observable<?> observable = (Observable<?>) callAdapter.adapt(call);
-        return observable.toSingle();
-      }
-    };
-  }
-}
diff --git a/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
similarity index 67%
rename from retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
rename to retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
index 726de5a3..3be1a8a9 100644
--- a/retrofit-adapters/rxjava/src/test/java/retrofit/RxJavaCallAdapterFactoryTest.java
+++ b/retrofit-adapters/rxjava/src/test/java/retrofit/ObservableCallAdapterFactoryTest.java
@@ -29,24 +29,19 @@ import org.junit.Rule;
 import org.junit.Test;
 import retrofit.http.GET;
 import rx.Observable;
-import rx.Single;
 import rx.observables.BlockingObservable;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
-public final class RxJavaCallAdapterFactoryTest {
+public final class ObservableCallAdapterFactoryTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
   interface Service {
-    @GET("/") Observable<String> observableBody();
-    @GET("/") Observable<Response<String>> observableResponse();
-    @GET("/") Observable<Result<String>> observableResult();
-    @GET("/") Single<String> singleBody();
-    @GET("/") Single<Response<String>> singleResponse();
-    @GET("/") Single<Result<String>> singleResult();
+    @GET("/") Observable<String> body();
+    @GET("/") Observable<Response<String>> response();
+    @GET("/") Observable<Result<String>> result();
   }
 
   private Service service;
@@ -55,7 +50,7 @@ public final class RxJavaCallAdapterFactoryTest {
     Retrofit retrofit = new Retrofit.Builder()
         .baseUrl(server.url("/"))
         .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
+        .addCallAdapterFactory(ObservableCallAdapterFactory.create())
         .build();
     service = retrofit.create(Service.class);
   }
@@ -63,14 +58,14 @@ public final class RxJavaCallAdapterFactoryTest {
   @Test public void bodySuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<String> o = service.observableBody().toBlocking();
+    BlockingObservable<String> o = service.body().toBlocking();
     assertThat(o.first()).isEqualTo("Hi");
   }
 
   @Test public void bodySuccess404() {
     server.enqueue(new MockResponse().setResponseCode(404));
 
-    BlockingObservable<String> o = service.observableBody().toBlocking();
+    BlockingObservable<String> o = service.body().toBlocking();
     try {
       o.first();
       fail();
@@ -83,7 +78,7 @@ public final class RxJavaCallAdapterFactoryTest {
   @Test public void bodyFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<String> o = service.observableBody().toBlocking();
+    BlockingObservable<String> o = service.body().toBlocking();
     try {
       o.first();
       fail();
@@ -95,7 +90,7 @@ public final class RxJavaCallAdapterFactoryTest {
   @Test public void responseSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
     Response<String> response = o.first();
     assertThat(response.isSuccess()).isTrue();
     assertThat(response.body()).isEqualTo("Hi");
@@ -104,7 +99,7 @@ public final class RxJavaCallAdapterFactoryTest {
   @Test public void responseSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
     Response<String> response = o.first();
     assertThat(response.isSuccess()).isFalse();
     assertThat(response.errorBody().string()).isEqualTo("Hi");
@@ -113,7 +108,7 @@ public final class RxJavaCallAdapterFactoryTest {
   @Test public void responseFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Response<String>> o = service.observableResponse().toBlocking();
+    BlockingObservable<Response<String>> o = service.response().toBlocking();
     try {
       o.first();
       fail();
@@ -125,7 +120,7 @@ public final class RxJavaCallAdapterFactoryTest {
   @Test public void resultSuccess200() {
     server.enqueue(new MockResponse().setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
@@ -136,7 +131,7 @@ public final class RxJavaCallAdapterFactoryTest {
   @Test public void resultSuccess404() throws IOException {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
 
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isFalse();
     Response<String> response = result.response();
@@ -147,14 +142,14 @@ public final class RxJavaCallAdapterFactoryTest {
   @Test public void resultFailure() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
 
-    BlockingObservable<Result<String>> o = service.observableResult().toBlocking();
+    BlockingObservable<Result<String>> o = service.result().toBlocking();
     Result<String> result = o.first();
     assertThat(result.isError()).isTrue();
     assertThat(result.error()).isInstanceOf(IOException.class);
   }
 
   @Test public void responseType() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     Type classType = new TypeToken<Observable<String>>() {}.getType();
     assertThat(factory.get(classType).responseType()).isEqualTo(String.class);
     Type wilcardType = new TypeToken<Observable<? extends String>>() {}.getType();
@@ -169,41 +164,27 @@ public final class RxJavaCallAdapterFactoryTest {
   }
 
   @Test public void nonObservableTypeReturnsNull() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     CallAdapter<?> adapter = factory.get(String.class);
     assertThat(adapter).isNull();
   }
 
   @Test public void rawTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable>() {}.getType();
+    Type type = new TypeToken<Observable>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     try {
-      factory.get(observableType);
+      factory.get(type);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Observable return type must be parameterized as Observable<Foo> or Observable<? extends Foo>");
     }
-    Type singleType = new TypeToken<Single>() {}.getType();
-    try {
-      factory.get(singleType);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Single return type must be parameterized as Single<Foo> or Single<? extends Foo>");
-    }
   }
 
-  @Test public void rawObservableResponseTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable<Response>>() {}.getType();
-    try {
-      factory.get(observableType);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single<Response>>() {}.getType();
+  @Test public void rawResponseTypeThrows() {
+    Type type = new TypeToken<Observable<Response>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     try {
-      factory.get(singleType);
+      factory.get(type);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Response must be parameterized as Response<Foo> or Response<? extends Foo>");
@@ -211,30 +192,16 @@ public final class RxJavaCallAdapterFactoryTest {
   }
 
   @Test public void rawResultTypeThrows() {
-    CallAdapter.Factory factory = RxJavaCallAdapterFactory.create();
-    Type observableType = new TypeToken<Observable<Result>>() {}.getType();
-    try {
-      factory.get(observableType);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
-    }
-    Type singleType = new TypeToken<Single<Result>>() {}.getType();
+    Type type = new TypeToken<Observable<Result>>() {}.getType();
+    CallAdapter.Factory factory = ObservableCallAdapterFactory.create();
     try {
-      factory.get(singleType);
+      factory.get(type);
       fail();
     } catch (IllegalStateException e) {
       assertThat(e).hasMessage("Result must be parameterized as Result<Foo> or Result<? extends Foo>");
     }
   }
 
-  @Test public void single() {
-    // TODO Better tests here. Why is there no toBlocking() on Single?
-    assertNotNull(service.singleBody());
-    assertNotNull(service.singleResponse());
-    assertNotNull(service.singleResult());
-  }
-
   static class StringConverterFactory implements Converter.Factory {
     @Override public Converter<?> get(Type type) {
       return new Converter<String>() {
