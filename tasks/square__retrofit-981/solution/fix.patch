diff --git a/pom.xml b/pom.xml
index 51f82032..439fd2ff 100644
--- a/pom.xml
+++ b/pom.xml
@@ -53,7 +53,7 @@
     <okhttp.version>2.5.0-SNAPSHOT</okhttp.version>
 
     <!-- Adapter Dependencies -->
-    <rxjava.version>1.0.10</rxjava.version>
+    <rxjava.version>1.0.13</rxjava.version>
 
     <!-- Converter Dependencies -->
     <gson.version>2.3.1</gson.version>
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
new file mode 100644
index 00000000..7e96b5e2
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/RxJavaBehaviorAdapter.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import rx.Observable;
+import rx.functions.Func1;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+public final class RxJavaBehaviorAdapter implements BehaviorAdapter<Object> {
+  public static RxJavaBehaviorAdapter create() {
+    return new RxJavaBehaviorAdapter();
+  }
+
+  private RxJavaBehaviorAdapter() {
+  }
+
+  @Override public Object applyBehavior(Behavior behavior, Object value) {
+    if (value instanceof Observable) {
+      return applyObservableBehavior(behavior, (Observable<?>) value);
+    }
+    String name = value.getClass().getCanonicalName();
+    if ("rx.Single".equals(name)) {
+      // Apply behavior to the Single from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      return SingleHelper.applySingleBehavior(behavior, value);
+    }
+    throw new IllegalStateException("Unsupported type " + name);
+  }
+
+  public Observable<?> applyObservableBehavior(final Behavior behavior, final Observable<?> value) {
+    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
+        .flatMap(new Func1<Long, Observable<?>>() {
+          @Override public Observable<?> call(Long ignored) {
+            if (behavior.calculateIsFailure()) {
+              return Observable.error(behavior.failureException());
+            }
+            return value;
+          }
+        });
+  }
+}
diff --git a/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
new file mode 100644
index 00000000..8a338fae
--- /dev/null
+++ b/retrofit-adapters/rxjava-mock/src/main/java/retrofit/mock/SingleHelper.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit.mock;
+
+import rx.Observable;
+import rx.Single;
+import rx.functions.Func1;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+final class SingleHelper {
+  @SuppressWarnings("unchecked") // Caller must instanceof / getClass() verify 'value' is Single.
+  public static Object applySingleBehavior(final Behavior behavior, Object value) {
+    final Single<Object> single = (Single<Object>) value;
+    return Observable.timer(behavior.calculateDelay(MILLISECONDS), MILLISECONDS)
+        .flatMap(new Func1<Long, Observable<?>>() {
+          @Override public Observable<?> call(Long ignored) {
+            if (behavior.calculateIsFailure()) {
+              return Observable.error(behavior.failureException());
+            }
+            return single.toObservable();
+          }
+        })
+        .toSingle();
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
new file mode 100644
index 00000000..b715e1dc
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/RxJavaCallAdapterFactory.java
@@ -0,0 +1,192 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import rx.Observable;
+import rx.Subscriber;
+import rx.functions.Action0;
+import rx.functions.Func1;
+import rx.subscriptions.Subscriptions;
+
+/**
+ * TODO docs
+ */
+public final class RxJavaCallAdapterFactory implements CallAdapter.Factory {
+  /**
+   * TODO
+   */
+  public static RxJavaCallAdapterFactory create() {
+    return new RxJavaCallAdapterFactory();
+  }
+
+  private RxJavaCallAdapterFactory() {
+  }
+
+  @Override public CallAdapter<?> get(Type returnType) {
+    Class<?> rawType = Utils.getRawType(returnType);
+    boolean isSingle = "rx.Single".equals(rawType.getCanonicalName());
+    if (rawType != Observable.class && !isSingle) {
+      return null;
+    }
+    if (!(returnType instanceof ParameterizedType)) {
+      String name = isSingle ? "Single" : "Observable";
+      throw new IllegalStateException(name + " return type must be parameterized"
+          + " as " + name + "<Foo> or " + name + "<? extends Foo>");
+    }
+
+    CallAdapter<Object> callAdapter = getCallAdapter(returnType);
+    if (isSingle) {
+      // Add Single-converter wrapper from a separate class. This defers classloading such that
+      // regular Observable operation can be leveraged without relying on this unstable RxJava API.
+      callAdapter = SingleHelper.makeSingle(callAdapter);
+    }
+    return callAdapter;
+  }
+
+  private CallAdapter<Object> getCallAdapter(Type returnType) {
+    Type observableType = Utils.getSingleParameterUpperBound((ParameterizedType) returnType);
+    Class<?> rawObservableType = Utils.getRawType(observableType);
+    if (rawObservableType == Response.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Response must be parameterized"
+            + " as Response<Foo> or Response<? extends Foo>");
+      }
+      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
+      return new ResponseCallAdapter<>(responseType);
+    }
+
+    if (rawObservableType == Result.class) {
+      if (!(observableType instanceof ParameterizedType)) {
+        throw new IllegalStateException("Result must be parameterized"
+            + " as Result<Foo> or Result<? extends Foo>");
+      }
+      Type responseType = Utils.getSingleParameterUpperBound((ParameterizedType) observableType);
+      return new ResultCallAdapter<>(responseType);
+    }
+
+    return new SimpleCallAdapter<>(observableType);
+  }
+
+  static final class CallOnSubscribe<T> implements Observable.OnSubscribe<Response<T>> {
+    private final Call<T> originalCall;
+
+    private CallOnSubscribe(Call<T> originalCall) {
+      this.originalCall = originalCall;
+    }
+
+    @Override public void call(final Subscriber<? super Response<T>> subscriber) {
+      // Since Call is a one-shot type, clone it for each new subscriber.
+      final Call<T> call = originalCall.clone();
+
+      // Attempt to cancel the call if it is still in-flight on unsubscription.
+      subscriber.add(Subscriptions.create(new Action0() {
+        @Override public void call() {
+          call.cancel();
+        }
+      }));
+
+      call.enqueue(new Callback<T>() {
+        @Override public void onResponse(Response<T> response) {
+          if (subscriber.isUnsubscribed()) {
+            return;
+          }
+          try {
+            subscriber.onNext(response);
+          } catch (Throwable t) {
+            subscriber.onError(t);
+            return;
+          }
+          subscriber.onCompleted();
+        }
+
+        @Override public void onFailure(Throwable t) {
+          if (subscriber.isUnsubscribed()) {
+            return;
+          }
+          subscriber.onError(t);
+        }
+      });
+    }
+  }
+
+  static final class ResponseCallAdapter<T> implements CallAdapter<T> {
+    private final Type responseType;
+
+    ResponseCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public Observable<Response<T>> adapt(Call<T> call) {
+      return Observable.create(new CallOnSubscribe<>(call));
+    }
+  }
+
+  static final class SimpleCallAdapter<T> implements CallAdapter<T> {
+    private final Type responseType;
+
+    SimpleCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public Observable<T> adapt(Call<T> call) {
+      return Observable.create(new CallOnSubscribe<>(call)) //
+          .flatMap(new Func1<Response<T>, Observable<T>>() {
+            @Override public Observable<T> call(Response<T> response) {
+              if (response.isSuccess()) {
+                return Observable.just(response.body());
+              }
+              return Observable.error(new HttpException(response));
+            }
+          });
+    }
+  }
+
+  static final class ResultCallAdapter<T> implements CallAdapter<T> {
+    private final Type responseType;
+
+    ResultCallAdapter(Type responseType) {
+      this.responseType = responseType;
+    }
+
+    @Override public Type responseType() {
+      return responseType;
+    }
+
+    @Override public Observable<Result<T>> adapt(Call<T> call) {
+      return Observable.create(new CallOnSubscribe<>(call)) //
+          .map(new Func1<Response<T>, Result<T>>() {
+            @Override public Result<T> call(Response<T> response) {
+              return Result.response(response);
+            }
+          })
+          .onErrorReturn(new Func1<Throwable, Result<T>>() {
+            @Override public Result<T> call(Throwable throwable) {
+              return Result.error(throwable);
+            }
+          });
+    }
+  }
+}
diff --git a/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
new file mode 100644
index 00000000..01f91d7f
--- /dev/null
+++ b/retrofit-adapters/rxjava/src/main/java/retrofit/SingleHelper.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import java.lang.reflect.Type;
+import rx.Observable;
+import rx.Single;
+
+final class SingleHelper {
+  static CallAdapter<Object> makeSingle(final CallAdapter<Object> callAdapter) {
+    return new CallAdapter<Object>() {
+      @Override public Type responseType() {
+        return callAdapter.responseType();
+      }
+
+      @Override public Single<?> adapt(Call<Object> call) {
+        Observable<?> observable = (Observable<?>) callAdapter.adapt(call);
+        return observable.toSingle();
+      }
+    };
+  }
+}
