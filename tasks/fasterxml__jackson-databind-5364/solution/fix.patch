diff --git a/README.md b/README.md
index 0d81ec6ca..7db070a57 100644
--- a/README.md
+++ b/README.md
@@ -581,7 +581,60 @@ This will deserialize JSON fields with `known_as`, as well as `identifer` and `f
 Note: to use the `@JsonAlias` annotation, a `@JsonProperty` annotation must also be used.
 
 Overall, Jackson library is very powerful in deserializing objects using builder pattern.
- 
+
+## Tutorial: Collecting multiple errors (3.1+)
+
+One recently introduced feature is the ability to collect multiple deserialization errors instead of failing fast on the first one. This can be really handy for validation use cases.
+
+By default, if Jackson encounters a problem during deserialization -- say, string `"xyz"` for an `int` property -- it will immediately throw an exception and stop. But sometimes you want to see ALL the problems in one go.
+
+Consider a case where you have a couple of fields with bad data:
+
+```java
+class Order {
+  public int orderId;
+  public Date orderDate;
+  public double amount;
+}
+
+String json = "{\"orderId\":\"not-a-number\",\"orderDate\":\"bad-date\",\"amount\":\"xyz\"}";
+```
+
+Normally you'd get an error about `orderId`, fix it, resubmit, then get error about `orderDate`, and so on. Not fun. So let's collect them all:
+
+```java
+ObjectMapper mapper = new JsonMapper();
+ObjectReader reader = mapper.readerFor(Order.class).problemCollectingReader();
+
+try {
+    Order result = reader.readValueCollectingProblems(json);
+    // worked fine
+} catch (DeferredBindingException ex) {
+    System.out.println("Found " + ex.getProblems().size() + " problems:");
+    for (CollectedProblem problem : ex.getProblems()) {
+        System.out.println(problem.getPath() + ": " + problem.getMessage());
+        // Can also access problem.getRawValue() to see what the bad input was
+    }
+}
+```
+
+This will report all 3 problems at once. Much better.
+
+By default, Jackson will collect up to 100 problems before giving up (to prevent DoS-style attacks with huge bad payloads). You can configure this:
+
+```java
+ObjectReader reader = mapper.readerFor(Order.class).problemCollectingReader(10); // limit to 10
+```
+
+Few things to keep in mind:
+
+1. This is best-effort: not all problems can be collected. Malformed JSON (like missing closing brace) or other structural problems will still fail immediately. But type conversion errors, unknown properties (if you enable that check), and such will be collected.
+2. Error paths use JSON Pointer notation (RFC 6901): so `"/items/0/price"` means first item in `items` array, `price` field. Special characters get escaped (`~` becomes `~0`, `/` becomes `~1`).
+3. Each call to `readValueCollectingProblems()` gets its own problem bucket, so it's thread-safe to reuse the same `ObjectReader`.
+4. Fields that fail to deserialize get default values (0 for primitives, null for objects) during the attempt, but if any problems are collected, only the problems are reported in the `DeferredBindingException` - the partial result is not returned.
+
+This is particularly useful for things like REST API validation (return all validation errors to client), or batch processing (log errors but keep going), or development tooling.
+
 # Contribute!
 
 We would love to get your contribution, whether it's in form of bug reports, Requests for Enhancement (RFE), documentation, or code patches.
diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 490d96d66..4cf5820c4 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -113,6 +113,16 @@ Fouad Almalki (@Eng-Fouad)
    with Jackson 3
   [3.0.3]
 
+Oliver Drotbohm (@odrotbohm)
+ * Requested #1196: Add opt-in error collection for deserialization
+  [3.1.0]
+
+@sri-adarsh-kumar
+ * Contributed #1196: Add opt-in error collection for deserialization
+  [3.1.0]
+
 HÃ©lios Gilles (@RoiSoleil)
  * Contributed #5413: Add/support forward reference resolution for array values
   [3.1.0]
+
+   
\ No newline at end of file
diff --git a/release-notes/VERSION b/release-notes/VERSION
index 9a8b33f70..d78d391c9 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -7,6 +7,9 @@ Versions: 3.x (for earlier see VERSION-2.x)
 
 3.1.0 (not yet released)
 
+#1196: Add opt-in error collection for deserialization
+ (requested by @odrotbohm)
+ (contributed by @sri-adarsh-kumar)
 #5350: Add `DeserializationFeature.USE_NULL_FOR_MISSING_REFERENCE_VALUES` for
   selecting `null` vs "empty/absent" value when deserializing missing `Optional` value
 #5361: Fix Maven SBOM publishing (worked in 3.0.0-rc4 but not in rc5 or later)
diff --git a/src/main/java/tools/jackson/databind/ObjectReader.java b/src/main/java/tools/jackson/databind/ObjectReader.java
index 1346bdf0d..16b470f98 100644
--- a/src/main/java/tools/jackson/databind/ObjectReader.java
+++ b/src/main/java/tools/jackson/databind/ObjectReader.java
@@ -17,8 +17,11 @@ import tools.jackson.core.type.TypeReference;
 import tools.jackson.databind.cfg.ContextAttributes;
 import tools.jackson.databind.cfg.DatatypeFeature;
 import tools.jackson.databind.cfg.DeserializationContexts;
+import tools.jackson.databind.deser.CollectingProblemHandler;
 import tools.jackson.databind.deser.DeserializationContextExt;
 import tools.jackson.databind.deser.DeserializationProblemHandler;
+import tools.jackson.databind.exc.CollectedProblem;
+import tools.jackson.databind.exc.DeferredBindingException;
 import tools.jackson.databind.node.ArrayNode;
 import tools.jackson.databind.node.JsonNodeFactory;
 import tools.jackson.databind.node.ObjectNode;
@@ -26,6 +29,7 @@ import tools.jackson.databind.node.TreeTraversingParser;
 import tools.jackson.databind.type.SimpleType;
 import tools.jackson.databind.type.TypeFactory;
 import tools.jackson.databind.util.ClassUtil;
+import tools.jackson.databind.util.LinkedNode;
 import tools.jackson.databind.util.TokenBuffer;
 
 /**
@@ -692,6 +696,73 @@ public class ObjectReader
         return _with(_config.withHandler(h));
     }
 
+    /**
+     * Returns a new {@link ObjectReader} configured to collect deserialization problems
+     * instead of failing on the first error. Uses default problem limit (100 problems).
+     *
+     * <p><b>IMPORTANT</b>: This method registers a {@link CollectingProblemHandler},
+     * inserting it before possible other handlers.
+     * If you need custom problem handling in addition to collection, you need to create
+     * your own handler that delegates to {@code CollectingProblemHandler} (or sub-classes it)
+     * and use {@link #problemCollectingReader(CollectingProblemHandler)} overload
+     * instead of this method.
+     *
+     * <p>Future versions may support handler chaining; for now, only one handler is active.
+     *
+     * <p><b>Thread-safety</b>: The returned reader is immutable and thread-safe. Each call to
+     * {@link #readValueCollectingProblems} allocates a fresh problem bucket, so concurrent
+     * calls do not interfere.
+     *
+     * <p>Usage:
+     * <pre>
+     * ObjectReader reader = mapper.reader()
+     *     .forType(MyBean.class)
+     *     .problemCollectingReader();
+     *
+     * MyBean bean = reader.readValueCollectingProblems(json);
+     * </pre>
+     *
+     * @return A new ObjectReader configured for problem collection
+     * @since 3.1
+     */
+    public ObjectReader problemCollectingReader() {
+        return problemCollectingReader(CollectingProblemHandler.DEFAULT_MAX_PROBLEMS);
+    }
+
+    /**
+     * Variant of {@link #problemCollectingReader()} that allows overriding maximum
+     * number of problems to collect.
+     *
+     * @param maxProblems Maximum number of problems to collect (must be {@code >} 0)
+     * @return A new ObjectReader configured for problem collection
+     * @throws IllegalArgumentException if maxProblems is {@code <= 0}
+     *
+     * @since 3.1
+     */
+    public ObjectReader problemCollectingReader(int maxProblems) {
+        if (maxProblems <= 0) {
+            throw new IllegalArgumentException("maxProblems must be positive");
+        }
+        return problemCollectingReader(new CollectingProblemHandler(maxProblems));
+    }
+
+    /**
+     * Variant of {@link #problemCollectingReader()} that allows passing custom
+     * {@link CollectingProblemHandler} (usually sub-class).
+     *
+     * @param problemHandler Custom handler instance to use
+     *
+     * @return A new ObjectReader configured for problem collection
+     *
+     * @since 3.1
+     */
+    public ObjectReader problemCollectingReader(CollectingProblemHandler problemHandler)
+    {
+        DeserializationConfig newConfig = _config.withHandler(problemHandler);
+        return _new(this, newConfig, _valueType, _rootDeserializer, _valueToUpdate,
+                _schema, _injectableValues);
+    }
+
     public ObjectReader with(Base64Variant defaultBase64) {
         return _with(_config.with(defaultBase64));
     }
@@ -1320,6 +1391,133 @@ public class ObjectReader
                 _considerFilter(src.asParser(ctxt) , false));
     }
 
+    /*
+    /**********************************************************************
+    /* Deserialization methods with error collection
+    /**********************************************************************
+     */
+
+    /**
+     * Deserializes JSON content into a Java object, collecting multiple
+     * problems if encountered. If any problems were collected, throws
+     * {@link DeferredBindingException} with all problems.
+     *
+     * <p><b>Usage</b>: This method should be called on an ObjectReader created via
+     * {@link #problemCollectingReader()} or {@link #problemCollectingReader(int)}. If called on a regular
+     * reader (without problem collection enabled), it behaves the same as
+     * {@link #readValue(JsonParser)} since no handler is registered.
+     *
+     * <p><b>Error handling</b>:
+     * <ul>
+     * <li>Recoverable errors are accumulated and thrown as
+     *     {@link DeferredBindingException} after parsing</li>
+     * <li>Hard (non-recoverable) failures throw immediately, with collected problems
+     *     attached as suppressed exceptions</li>
+     * <li>When the configured limit is reached, collection stops</li>
+     * </ul>
+     *
+     * <p><b>Exception Handling Strategy</b>:
+     *
+     * <p>This method catches only {@link DatabindException} subtypes (not all
+     * {@link JacksonException}s) because:
+     *
+     * <ul>
+     * <li>Core streaming errors ({@link tools.jackson.core.exc.StreamReadException},
+     *     {@link tools.jackson.core.exc.StreamWriteException}) represent structural
+     *     JSON problems that cannot be recovered from (malformed JSON, I/O errors)</li>
+     *
+     * <li>Only databind-level errors (type conversion, unknown properties, instantiation
+     *     failures) are potentially recoverable and suitable for collection</li>
+     *
+     * <li>Catching all JacksonExceptions would hide critical parsing errors that should
+     *     fail fast</li>
+     * </ul>
+     *
+     * <p>If a hard failure occurs after some problems have been collected, those problems
+     * are attached as suppressed exceptions to the thrown exception for debugging purposes.
+     *
+     * <p><b>Thread-safety</b>: Each call allocates a fresh problem bucket,
+     * so multiple concurrent calls on the same reader instance are safe.
+     *
+     * <p><b>Parser filtering</b>: Unlike convenience overloads ({@link #readValueCollectingProblems(String)},
+     * {@link #readValueCollectingProblems(byte[])}, etc.), this method does <i>not</i> apply
+     * parser filtering. Callers are responsible for filter wrapping if needed.
+     *
+     * @param <T> Type to deserialize
+     * @param p JsonParser to read from (will not be closed by this method)
+     * @return Deserialized object
+     * @throws DeferredBindingException if recoverable problems were collected
+     * @throws DatabindException if a non-recoverable error occurred
+     * @since 3.1
+     */
+    public <T> T readValueCollectingProblems(JsonParser p) throws JacksonException {
+        _assertNotNull("p", p);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return _collectingBind(ctxt, p);
+    }
+
+    /**
+     * Convenience overload for {@link #readValueCollectingProblems(JsonParser)}.
+     */
+    public <T> T readValueCollectingProblems(String content) throws JacksonException {
+        _assertNotNull("content", content);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return _collectingBindAndClose(ctxt,
+                _considerFilter(_parserFactory.createParser(ctxt, content), false));
+    }
+
+    /**
+     * Convenience overload for {@link #readValueCollectingProblems(JsonParser)}.
+     */
+    public <T> T readValueCollectingProblems(byte[] content) throws JacksonException {
+        _assertNotNull("content", content);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return _collectingBindAndClose(ctxt,
+                _considerFilter(_parserFactory.createParser(ctxt, content), false));
+    }
+
+    /**
+     * Convenience overload for {@link #readValueCollectingProblems(JsonParser)}.
+     */
+    public <T> T readValueCollectingProblems(File src) throws JacksonException {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return _collectingBindAndClose(ctxt,
+                _considerFilter(_parserFactory.createParser(ctxt, src), false));
+    }
+
+    /**
+     * Convenience overload for {@link #readValueCollectingProblems(JsonParser)}.
+     */
+    @SuppressWarnings("unchecked")
+    public <T> T readValueCollectingProblems(Path path) throws JacksonException
+    {
+        _assertNotNull("path", path);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return (T) _collectingBindAndClose(ctxt,
+                _considerFilter(_parserFactory.createParser(ctxt, path), false));
+    }
+
+    /**
+     * Convenience overload for {@link #readValueCollectingProblems(JsonParser)}.
+     */
+    public <T> T readValueCollectingProblems(InputStream src) throws JacksonException {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return _collectingBindAndClose(ctxt,
+                _considerFilter(_parserFactory.createParser(ctxt, src), false));
+    }
+
+    /**
+     * Convenience overload for {@link #readValueCollectingProblems(JsonParser)}.
+     */
+    public <T> T readValueCollectingProblems(Reader src) throws JacksonException {
+        _assertNotNull("src", src);
+        DeserializationContextExt ctxt = _deserializationContext();
+        return _collectingBindAndClose(ctxt,
+                _considerFilter(_parserFactory.createParser(ctxt, src), false));
+    }
+
     /*
     /**********************************************************************
     /* Deserialization methods; JsonNode ("tree")
@@ -1653,6 +1851,78 @@ public class ObjectReader
         }
     }
 
+    /**
+     * Internal helper for problem-collecting deserialization that does NOT close the parser.
+     * Caller is responsible for parser lifecycle management.
+     *
+     * @since 3.1
+     */
+    protected <T> T _collectingBind(DeserializationContextExt ctxt, JsonParser p)
+            throws JacksonException {
+        // CRITICAL: Allocate a FRESH bucket for THIS call (thread-safety)
+        List<CollectedProblem> bucket = new ArrayList<>();
+
+        // Set bucket in context attributes (mutable per-call state)
+        ctxt.setAttribute(CollectingProblemHandler.class, bucket);
+
+        // Find the CollectingProblemHandler to get maxProblems limit
+        int maxProblems = CollectingProblemHandler.DEFAULT_MAX_PROBLEMS;
+        LinkedNode<DeserializationProblemHandler> handlers = _config.getProblemHandlers();
+        while (handlers != null) {
+            if (handlers.value() instanceof CollectingProblemHandler cph) {
+                maxProblems = cph.getMaxProblems();
+                break;
+            }
+            handlers = handlers.next();
+        }
+
+        try {
+            // Directly invoke _bind with the prepared context
+            @SuppressWarnings("unchecked")
+            T result = (T) _bind(ctxt, p, _valueToUpdate);
+
+            // Check if any problems were collected
+            if (!bucket.isEmpty()) {
+                boolean limitReached = (bucket.size() >= maxProblems);
+                throw new DeferredBindingException(p, bucket, limitReached);
+            }
+
+            return result;
+
+        } catch (DeferredBindingException e) {
+            throw e; // Already properly formatted
+
+        } catch (DatabindException e) {
+            // Hard failure occurred; attach collected problems as suppressed
+            if (!bucket.isEmpty()) {
+                boolean limitReached = (bucket.size() >= maxProblems);
+                if (limitReached) {
+                    // Limit was hit - throw DeferredBindingException as primary exception
+                    DeferredBindingException dbe = new DeferredBindingException(p, bucket, true);
+                    dbe.addSuppressed(e); // Original error as suppressed for debugging
+                    throw dbe;
+                } else {
+                    // Hard failure unrelated to limit - keep original as primary
+                    e.addSuppressed(new DeferredBindingException(p, bucket, false));
+                }
+            }
+            throw e;
+        }
+    }
+
+    /**
+     * Internal helper for problem-collecting deserialization that DOES close the parser.
+     * Mirrors {@link #_bindAndClose} but with problem collection enabled.
+     *
+     * @since 3.1
+     */
+    protected <T> T _collectingBindAndClose(DeserializationContextExt ctxt, JsonParser p0)
+            throws JacksonException {
+        try (JsonParser p = p0) {
+            return _collectingBind(ctxt, p);
+        }
+    }
+
     protected final JsonNode _bindAndCloseAsTree(DeserializationContextExt ctxt,
             JsonParser p0) throws JacksonException {
         try (JsonParser p = ctxt.assignAndReturnParser(p0)) {
@@ -1743,7 +2013,7 @@ public class ObjectReader
      */
     protected JsonParser _considerFilter(final JsonParser p, boolean multiValue) {
         // 26-Mar-2016, tatu: Need to allow multiple-matches at least if we have
-        //    have a multiple-value read (that is, "readValues()").
+        //    a multiple-value read (that is, "readValues()").
         return ((_filter == null) || FilteringParserDelegate.class.isInstance(p))
                 ? p : new FilteringParserDelegate(p, _filter, Inclusion.ONLY_INCLUDE_ALL, multiValue);
     }
diff --git a/src/main/java/tools/jackson/databind/deser/CollectingProblemHandler.java b/src/main/java/tools/jackson/databind/deser/CollectingProblemHandler.java
new file mode 100644
index 000000000..5dac787ae
--- /dev/null
+++ b/src/main/java/tools/jackson/databind/deser/CollectingProblemHandler.java
@@ -0,0 +1,316 @@
+package tools.jackson.databind.deser;
+
+import java.util.List;
+
+import tools.jackson.core.JacksonException;
+import tools.jackson.core.JsonParser;
+import tools.jackson.core.JsonPointer;
+import tools.jackson.core.JsonToken;
+import tools.jackson.core.TokenStreamContext;
+import tools.jackson.core.TokenStreamLocation;
+import tools.jackson.databind.DeserializationContext;
+import tools.jackson.databind.JavaType;
+import tools.jackson.databind.ValueDeserializer;
+import tools.jackson.databind.exc.CollectedProblem;
+import tools.jackson.databind.util.ClassUtil;
+
+/**
+ * Stateless {@link DeserializationProblemHandler} that collects recoverable
+ * problems into a per-call bucket stored in {@link DeserializationContext}
+ * attributes.
+ *
+ * <p><b>Design</b>: This handler is completely stateless. The problem collection
+ * bucket is allocated per-call by {@code ObjectReader.readValueCollectingProblems(...)}
+ * and stored in per-call context attributes, ensuring thread-safety and call isolation.
+ *
+ * <p><b>Usage</b>: This class is internal infrastructure, registered automatically by
+ * {@code ObjectReader.problemCollectingReader()}. Users should not instantiate or
+ * register this handler manually.
+ *
+ * <p><b>Design rationale - Context Attributes vs Handler State</b>:
+ *
+ * <p>Problem collection state is stored in {@link DeserializationContext} attributes
+ * rather than within this handler for several reasons:
+ *
+ * <ol>
+ * <li><b>Thread-safety</b>: The handler instance is shared across all calls to the
+ *     same ObjectReader. Storing mutable state in the handler would require
+ *     synchronization and complicate the implementation.</li>
+ *
+ * <li><b>Call isolation</b>: Each call to {@code readValueCollectingProblems()} needs
+ *     its own problem bucket. Context attributes are perfect for this - they're created
+ *     per-call and automatically cleaned up after deserialization.</li>
+ *
+ * <li><b>Immutability</b>: Jackson's config objects (including handlers) are designed
+ *     to be immutable and reusable. Storing per-call state violates this principle.</li>
+ *
+ * <li><b>Configuration vs State</b>: The handler stores configuration (max problems
+ *     limit) while attributes store runtime state (the actual problem list). This
+ *     separation follows Jackson's design patterns.</li>
+ * </ol>
+ *
+ * <p>The handler itself is stateless - it's just a strategy for handling problems.
+ * The actual collection happens in a bucket passed through context attributes.
+ *
+ * <p><b>Recoverable errors handled</b>:
+ * <ul>
+ * <li>Unknown properties ({@link #handleUnknownProperty handleUnknownProperty}) - skips children</li>
+ * <li>Type coercion failures ({@link #handleWeirdStringValue handleWeirdStringValue},
+ *     {@link #handleWeirdNumberValue handleWeirdNumberValue}) - returns defaults</li>
+ * <li>Map key coercion ({@link #handleWeirdKey handleWeirdKey}) - returns {@code NOT_HANDLED}</li>
+ * <li>Instantiation failures ({@link #handleInstantiationProblem handleInstantiationProblem}) -
+ *     returns null when safe</li>
+ * </ul>
+ *
+ * <p><b>Default values</b>: Primitives receive zero/false defaults; reference types
+ * (including boxed primitives) receive {@code null} to avoid masking nullability issues.
+ *
+ * <p><b>DoS protection</b>: Collection stops when the configured limit (default 100)
+ * is reached, preventing memory/CPU exhaustion attacks.
+ *
+ * <p><b>JSON Pointer</b>: Paths are built from parser context following RFC 6901,
+ * with proper escaping of {@code ~} and {@code /} characters via jackson-core's
+ * {@link JsonPointer} class.
+ *
+ * @since 3.1
+ */
+public class CollectingProblemHandler extends DeserializationProblemHandler
+{
+    /**
+     * Default maximum number of problems to collect before stopping.
+     * Prevents memory exhaustion attacks.
+     */
+    public static final int DEFAULT_MAX_PROBLEMS = 100;
+
+    /**
+     * Attribute key for the problem collection bucket.
+     * Using class object as key (not a string) for type safety.
+     */
+    private static final Object ATTR_KEY = CollectingProblemHandler.class;
+
+    /**
+     * Maximum number of problems to collect before stopping.
+     */
+    private final int _maxProblems;
+
+    /**
+     * Constructs a handler with the default maximum problem limit.
+     */
+    public CollectingProblemHandler() {
+        this(DEFAULT_MAX_PROBLEMS);
+    }
+
+    /**
+     * Constructs a handler with a specific maximum problem limit.
+     *
+     * @param maxProblems Maximum number of problems to collect (must be positive)
+     */
+    public CollectingProblemHandler(int maxProblems) {
+        if (maxProblems <= 0) {
+            throw new IllegalArgumentException("maxProblems must be positive, was: " + maxProblems);
+        }
+        _maxProblems = maxProblems;
+    }
+
+    /**
+     * Gets the maximum number of problems this handler will collect.
+     */
+    public int getMaxProblems() {
+        return _maxProblems;
+    }
+
+    /**
+     * Retrieves the problem collection bucket from context attributes.
+     *
+     * @return Problem bucket, or null if not in collecting mode
+     */
+    @SuppressWarnings("unchecked")
+    public static List<CollectedProblem> getBucket(DeserializationContext ctxt) {
+        Object attr = ctxt.getAttribute(ATTR_KEY);
+        return (attr instanceof List) ? (List<CollectedProblem>) attr : null;
+    }
+
+    /**
+     * Records a problem in the collection bucket.
+     *
+     * @return true if problem was recorded, false if limit reached
+     */
+    private boolean recordProblem(DeserializationContext ctxt,
+            String message, JavaType targetType, Object rawValue)
+    {
+        List<CollectedProblem> bucket = getBucket(ctxt);
+        if (bucket == null) {
+            return false; // Not in collecting mode
+        }
+
+        if (bucket.size() >= _maxProblems) {
+            return false; // Limit reached
+        }
+
+        JsonParser p = ctxt.getParser();
+        JsonPointer path = buildJsonPointer(p);
+        TokenStreamLocation location = safeGetLocation(p);
+        JsonToken token = safeGetToken(p);
+
+        bucket.add(new CollectedProblem(
+            path, message, targetType, location, rawValue, token
+        ));
+
+        return true;
+    }
+
+    /**
+     * Safely retrieves the current token location, handling null parser.
+     */
+    private TokenStreamLocation safeGetLocation(JsonParser p) {
+        return (p != null) ? p.currentTokenLocation() : null;
+    }
+
+    /**
+     * Safely retrieves the current token, handling null parser.
+     */
+    private JsonToken safeGetToken(JsonParser p) {
+        return (p != null) ? p.currentToken() : null;
+    }
+
+    /**
+     * Builds a JsonPointer from the parser's current context.
+     * Uses the built-in {@link TokenStreamContext#pathAsPointer()} method
+     * which handles RFC 6901 escaping ('~' becomes '~0', '/' becomes '~1').
+     */
+    private JsonPointer buildJsonPointer(JsonParser p) {
+        if (p == null) {
+            return JsonPointer.empty();
+        }
+        return p.streamReadContext().pathAsPointer();
+    }
+
+    @Override
+    public boolean handleUnknownProperty(DeserializationContext ctxt,
+            JsonParser p, ValueDeserializer<?> deserializer,
+            Object beanOrClass, String propertyName)
+        throws JacksonException
+    {
+        String message = String.format(
+            "Unknown property '%s' for type %s",
+            propertyName,
+            ClassUtil.getClassDescription(beanOrClass)
+        );
+
+        // Store null as rawValue for unknown properties
+        // (property name is in the path, no need to duplicate)
+        if (recordProblem(ctxt, message, null, null)) {
+            p.skipChildren(); // Skip the unknown property value
+            return true; // Problem handled
+        }
+
+        return false; // Limit reached or not collecting, let default handling throw
+    }
+
+    @Override
+    public Object handleWeirdKey(DeserializationContext ctxt,
+            Class<?> rawKeyType, String keyValue, String failureMsg)
+        throws JacksonException
+    {
+        String message = String.format(
+            "Cannot deserialize Map key '%s' to %s: %s",
+            keyValue,
+            ClassUtil.getClassDescription(rawKeyType),
+            failureMsg
+        );
+
+        if (recordProblem(ctxt, message,
+                ctxt.constructType(rawKeyType), keyValue)) {
+            // Return NOT_HANDLED instead of null
+            // Rationale: Some Map implementations (Hashtable, ConcurrentHashMap)
+            // reject null keys. Safer to let Jackson handle it than risk NPE.
+            // If null keys are needed, users can provide custom handler.
+            return NOT_HANDLED;
+        }
+
+        return NOT_HANDLED; // Limit reached or not collecting
+    }
+
+    @Override
+    public Object handleWeirdStringValue(DeserializationContext ctxt,
+            Class<?> targetType, String valueToConvert, String failureMsg)
+        throws JacksonException
+    {
+        String message = String.format(
+            "Cannot deserialize value '%s' to %s: %s",
+            valueToConvert,
+            ClassUtil.getClassDescription(targetType),
+            failureMsg
+        );
+
+        if (recordProblem(ctxt, message,
+                ctxt.constructType(targetType), valueToConvert)) {
+            // Return sensible default based on target type
+            return getDefaultValue(targetType);
+        }
+
+        return NOT_HANDLED; // Limit reached or not collecting
+    }
+
+    @Override
+    public Object handleWeirdNumberValue(DeserializationContext ctxt,
+            Class<?> targetType, Number valueToConvert, String failureMsg)
+        throws JacksonException
+    {
+        String message = String.format(
+            "Cannot deserialize number %s to %s: %s",
+            valueToConvert,
+            ClassUtil.getClassDescription(targetType),
+            failureMsg
+        );
+
+        if (recordProblem(ctxt, message,
+                ctxt.constructType(targetType), valueToConvert)) {
+            return getDefaultValue(targetType);
+        }
+
+        return NOT_HANDLED; // Limit reached or not collecting
+    }
+
+    @Override
+    public Object handleInstantiationProblem(DeserializationContext ctxt,
+            Class<?> instClass, Object argument, Throwable t)
+        throws JacksonException
+    {
+        String message = String.format(
+            "Cannot instantiate %s: %s",
+            ClassUtil.getClassDescription(instClass),
+            t.getMessage()
+        );
+
+        if (recordProblem(ctxt, message,
+                ctxt.constructType(instClass), argument)) {
+            // Cannot return null for primitives; safe for all reference types
+            if (!instClass.isPrimitive()) {
+                return null;
+            }
+            // fall through
+        }
+
+        return NOT_HANDLED; // Cannot recover
+    }
+
+    /**
+     * Returns a sensible default value for the given type to allow
+     * deserialization to continue.
+     *
+     * <p>IMPORTANT: Only primitives get non-null defaults. Reference types
+     * (including boxed primitives) get null to avoid masking nullability issues.
+     */
+    private Object getDefaultValue(Class<?> type) {
+        // Primitives MUST have non-null defaults (cannot be null)
+        // Use ClassUtil for consistent primitive default handling
+        if (type.isPrimitive()) {
+            return ClassUtil.defaultValue(type);
+        }
+
+        // Reference types (including Integer, Long, etc.) get null
+        // This avoids masking nullability issues in the domain model
+        return null;
+    }
+}
diff --git a/src/main/java/tools/jackson/databind/exc/CollectedProblem.java b/src/main/java/tools/jackson/databind/exc/CollectedProblem.java
new file mode 100644
index 000000000..7e66051ea
--- /dev/null
+++ b/src/main/java/tools/jackson/databind/exc/CollectedProblem.java
@@ -0,0 +1,108 @@
+package tools.jackson.databind.exc;
+
+import java.util.Objects;
+
+import tools.jackson.core.JsonPointer;
+import tools.jackson.core.JsonToken;
+import tools.jackson.core.TokenStreamLocation;
+import tools.jackson.databind.JavaType;
+
+/**
+ * Immutable value object capturing details about a single deserialization
+ * problem encountered during error-collecting mode.
+ *
+ * <p><b>Contents</b>: Each problem records:
+ * <ul>
+ * <li>{@link #getPath() path} - RFC 6901 JSON Pointer to the problematic field
+ *     (e.g., {@code "/items/2/price"})</li>
+ * <li>{@link #getMessage() message} - Human-readable error description</li>
+ * <li>{@link #getTargetType() targetType} - Expected Java type (may be null)</li>
+ * <li>{@link #getLocation() location} - Source location in JSON (line/column)</li>
+ * <li>{@link #getRawValue() rawValue} - Original value from JSON that caused the error
+ *     (truncated if > 200 chars)</li>
+ * <li>{@link #getToken() token} - JSON token type at error location</li>
+ * </ul>
+ *
+ * <p><b>Truncation</b>: String values longer than {@value #MAX_RAW_VALUE_LENGTH}
+ * characters are truncated with "..." suffix to prevent memory issues.
+ *
+ * <p><b>Unknown properties</b>: For unknown property errors, {@code rawValue}
+ * is {@code null} since the property name is already in the path.
+ *
+ * <p><b>Immutability</b>: All instances are immutable and thread-safe.
+ *
+ * @since 3.1
+ * @see DeferredBindingException#getProblems()
+ */
+public final class CollectedProblem {
+    /**
+     * Maximum length for raw value strings before truncation.
+     */
+    private static final int MAX_RAW_VALUE_LENGTH = 200;
+
+    private final JsonPointer path;
+    private final String message;
+    private final JavaType targetType;
+    private final TokenStreamLocation location;
+    private final Object rawValue;      // @Nullable
+    private final JsonToken token;      // @Nullable
+
+    public CollectedProblem(JsonPointer path, String message,
+            JavaType targetType, TokenStreamLocation location,
+            Object rawValue, JsonToken token) {
+        this.path = Objects.requireNonNull(path, "path");
+        this.message = Objects.requireNonNull(message, "message");
+        this.targetType = targetType;
+        this.location = location;
+        this.rawValue = truncateIfNeeded(rawValue);
+        this.token = token;
+    }
+
+    /**
+     * @return JSON Pointer path to the problematic field (e.g., "/items/1/date").
+     *         Empty string ("") for root-level problems.
+     */
+    public JsonPointer getPath() { return path; }
+
+    /**
+     * @return Human-readable error message
+     */
+    public String getMessage() { return message; }
+
+    /**
+     * @return Expected Java type for the field (may be null)
+     */
+    public JavaType getTargetType() { return targetType; }
+
+    /**
+     * @return Location in source JSON where problem occurred (may be null)
+     */
+    public TokenStreamLocation getLocation() { return location; }
+
+    /**
+     * @return Raw value from JSON that caused the problem (may be null or truncated).
+     *         For unknown properties, this is null; use the path to identify the property name.
+     */
+    public Object getRawValue() { return rawValue; }
+
+    /**
+     * @return JSON token type at the error location (may be null)
+     */
+    public JsonToken getToken() { return token; }
+
+    private static Object truncateIfNeeded(Object value) {
+        if (value instanceof String) {
+            String s = (String) value;
+            if (s.length() > MAX_RAW_VALUE_LENGTH) {
+                return s.substring(0, MAX_RAW_VALUE_LENGTH - 3) + "...";
+            }
+        }
+        return value;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("CollectedProblem[path=%s, message=%s, targetType=%s]",
+            path, message, targetType);
+    }
+}
diff --git a/src/main/java/tools/jackson/databind/exc/DeferredBindingException.java b/src/main/java/tools/jackson/databind/exc/DeferredBindingException.java
new file mode 100644
index 000000000..7847506ac
--- /dev/null
+++ b/src/main/java/tools/jackson/databind/exc/DeferredBindingException.java
@@ -0,0 +1,110 @@
+package tools.jackson.databind.exc;
+
+import java.util.Collections;
+import java.util.List;
+
+import tools.jackson.core.JsonParser;
+import tools.jackson.databind.DatabindException;
+
+/**
+ * Exception that aggregates multiple recoverable deserialization problems
+ * encountered during problem-collecting mode.
+ *
+ * <p><b>Usage</b>: This exception is thrown by
+ * {@link tools.jackson.databind.ObjectReader#readValueCollectingProblems ObjectReader.readValueCollectingProblems(...)}
+ * when one or more recoverable problems were collected during deserialization.
+ * Enable problem collection via {@link tools.jackson.databind.ObjectReader#problemCollectingReader()}.
+ *
+ * <p><b>Problem access</b>: Each problem is captured as a {@link CollectedProblem}
+ * containing the JSON Pointer path, error message, location, target type, raw value, and token.
+ * Access problems via {@link #getProblems()}.
+ *
+ * <p><b>Limit handling</b>: When the configured problem limit is reached, collection
+ * stops and {@link #isLimitReached()} returns {@code true}. This indicates additional
+ * problems may exist beyond those collected.
+ *
+ * <p><b>Message formatting</b>: The exception message shows:
+ * <ul>
+ * <li>For 1 problem: the single error message</li>
+ * <li>For multiple: count + first 5 problems + "...and N more" suffix</li>
+ * <li>A "limit reached" note if applicable</li>
+ * </ul>
+ *
+ * <p><b>Example</b>:
+ * <pre>{@code
+ * try {
+ *     MyBean bean = reader.problemCollectingReader()
+ *                         .readValueCollectingProblems(json);
+ * } catch (DeferredBindingException e) {
+ *     for (CollectedProblem p : e.getProblems()) {
+ *         System.err.println("Error at " + p.getPath() + ": " + p.getMessage());
+ *     }
+ * }
+ * }</pre>
+ *
+ * @since 3.1
+ */
+public class DeferredBindingException extends DatabindException {
+    private static final long serialVersionUID = 1L;
+
+    private final List<CollectedProblem> problems;
+    private final boolean limitReached;
+
+    public DeferredBindingException(JsonParser p,
+            List<CollectedProblem> problems,
+            boolean limitReached) {
+        super(p, formatMessage(problems, limitReached));
+        this.problems = Collections.unmodifiableList(problems);
+        this.limitReached = limitReached;
+    }
+
+    /**
+     * @return Unmodifiable list of all collected problems
+     */
+    public List<CollectedProblem> getProblems() {
+        return problems;
+    }
+
+    /**
+     * @return Number of problems collected
+     */
+    public int getProblemCount() {
+        return problems.size();
+    }
+
+    /**
+     * @return true if error collection stopped due to reaching the configured limit
+     */
+    public boolean isLimitReached() {
+        return limitReached;
+    }
+
+    private static String formatMessage(List<CollectedProblem> problems, boolean limitReached) {
+        int count = problems.size();
+        if (count == 1) {
+            return "1 deserialization problem: " + problems.get(0).getMessage();
+        }
+
+        String limitNote = limitReached ? " (limit reached; more errors may exist)" : "";
+        return String.format(
+            "%d deserialization problems%s (showing first 5):%n%s",
+            count,
+            limitNote,
+            formatProblems(problems)
+        );
+    }
+
+    private static String formatProblems(List<CollectedProblem> problems) {
+        StringBuilder sb = new StringBuilder();
+        int limit = Math.min(5, problems.size());
+        for (int i = 0; i < limit; i++) {
+            CollectedProblem p = problems.get(i);
+            sb.append(String.format("  [%d] at %s: %s%n",
+                i + 1, p.getPath(), p.getMessage()));
+        }
+        if (problems.size() > 5) {
+            sb.append(String.format("  ... and %d more", problems.size() - 5));
+        }
+        return sb.toString();
+    }
+}
