diff --git a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
index 6dedd1354a..73190e38fa 100644
--- a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
@@ -722,8 +722,7 @@ final class BeanIntrospectionWriter extends AbstractClassFileWriter {
         dispatchWriter.buildGetTargetMethodByIndex(classWriter);
         buildFindIndexedProperty(classWriter);
         buildGetIndexedProperties(classWriter);
-        boolean hasBuilder = annotationMetadata != null &&
-            (annotationMetadata.isPresent(Introspected.class, "builder") || annotationMetadata.hasDeclaredAnnotation("lombok.Builder"));
+        boolean hasBuilder = annotationMetadata != null && annotationMetadata.isPresent(Introspected.class, "builder");
         if (defaultConstructor != null) {
             writeInstantiateMethod(classWriter, defaultConstructor, "instantiate");
             // in case invoked directly or via instantiateUnsafe
diff --git a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java
index a7a0ff06c9..44407f9be0 100644
--- a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java
+++ b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java
@@ -67,7 +67,6 @@ public class IntrospectedTypeElementVisitor implements TypeElementVisitor<Object
      * The position of the visitor.
      */
     public static final int POSITION = -100;
-    private static final String ANN_LOMBOK_BUILDER = "lombok.Builder";
 
     private final Map<String, BeanIntrospectionWriter> writers = new LinkedHashMap<>(10);
 
@@ -181,101 +180,62 @@ public class IntrospectedTypeElementVisitor implements TypeElementVisitor<Object
             AnnotationClassValue<?> builderClass = builder.annotationClassValue("builderClass").orElse(null);
             String[] writePrefixes = builder.getAnnotation("accessorStyle", AccessorsStyle.class)
                 .map(a -> a.stringValues("writePrefixes")).orElse(new String[]{""});
-            processBuilderDefinition(
-                element,
-                context,
-                introspected,
-                index,
-                targetPackage,
-                builderMethod,
-                creatorMethod,
-                writePrefixes,
-                builderClass
-            );
-        } else if (element.hasDeclaredAnnotation(ANN_LOMBOK_BUILDER)) {
-            AnnotationValue<Annotation> lombokBuilder = element.getAnnotation(ANN_LOMBOK_BUILDER);
-            String builderMethod = lombokBuilder.stringValue("builderMethodName").orElse("builder");
-            MethodElement methodElement = element
-                .getEnclosedElement(ElementQuery.ALL_METHODS.onlyStatic()
-                    .filter(m -> m.getName().equals(builderMethod) && !m.getGenericReturnType().isVoid())
-                    .onlyAccessible(element))
-                .orElse(null);
-            if (methodElement == null) {
-                // Lombok processing not done yet, try again in the next round.
-                throw new ElementPostponedToNextRoundException(element);
-            }
-            String creatorMethod = lombokBuilder.stringValue("buildMethodName").orElse("build");
-            String[] writePrefixes = lombokBuilder.stringValue("setterPrefix").map(sp -> new String[] { sp }).orElse(new String[]{""});
-            processBuilderDefinition(
-                element,
-                context,
-                introspected,
-                index,
-                targetPackage,
-                builderMethod,
-                creatorMethod,
-                writePrefixes,
-                null
-            );
-        }
-    }
-
-    private void processBuilderDefinition(ClassElement element, VisitorContext context, AnnotationValue<Introspected> introspected, int index, String targetPackage, String builderMethod, String creatorMethod, String[] writePrefixes, AnnotationClassValue<?> builderClass) {
-        if (builderMethod != null) {
-            MethodElement methodElement = element
-                .getEnclosedElement(ElementQuery.ALL_METHODS.onlyStatic()
-                    .filter(m -> m.getName().equals(builderMethod) && !m.getGenericReturnType().isVoid())
-                    .onlyAccessible(element))
-                .orElse(null);
-            if (methodElement != null) {
-                ClassElement returnType = methodElement.getGenericReturnType();
-                if (returnType.isPublic() || returnType.getPackageName().equals(element.getPackageName())) {
+            if (builderMethod != null) {
+                MethodElement methodElement = element
+                    .getEnclosedElement(ElementQuery.ALL_METHODS.onlyStatic()
+                        .filter(m -> m.getName().equals(builderMethod) && !m.getGenericReturnType().isVoid())
+                        .onlyAccessible(element))
+                    .orElse(null);
+                if (methodElement != null) {
+                    ClassElement returnType = methodElement.getGenericReturnType();
+                    if (returnType.isPublic() || returnType.getPackageName().equals(element.getPackageName())) {
+                        AnnotationValueBuilder<Introspected> replaceIntrospected = AnnotationValue.builder(introspected, RetentionPolicy.RUNTIME);
+                        replaceIntrospected.member("builderClass", new AnnotationClassValue<>(returnType.getName()));
+                        element.annotate(replaceIntrospected.build());
+                        AnnotationMetadata methodMetadata = methodElement.getMethodAnnotationMetadata().getTargetAnnotationMetadata();
+
+                        handleBuilder(
+                            element,
+                            context,
+                            creatorMethod,
+                            writePrefixes,
+                            methodElement,
+                            null,
+                            returnType,
+                            methodMetadata,
+                            index,
+                            targetPackage
+                        );
+                    } else {
+                        context.fail("Builder return type is not public. The method must be static and accessible.", methodElement);
+                    }
+                } else {
+                    context.fail("Method specified by builderMethod not found. The method must be static and accessible.", element);
+                }
+            } else if (builderClass != null) {
+                ClassElement builderClassElement = context.getClassElement(builderClass.getName()).orElse(null);
+                if (builderClassElement != null) {
                     AnnotationValueBuilder<Introspected> replaceIntrospected = AnnotationValue.builder(introspected, RetentionPolicy.RUNTIME);
-                    replaceIntrospected.member("builderClass", new AnnotationClassValue<>(returnType.getName()));
+                    replaceIntrospected.member("builderClass", new AnnotationClassValue<>(builderClassElement.getName()));
                     element.annotate(replaceIntrospected.build());
-                    AnnotationMetadata methodMetadata = methodElement.getMethodAnnotationMetadata().getTargetAnnotationMetadata();
 
                     handleBuilder(
                         element,
                         context,
                         creatorMethod,
                         writePrefixes,
-                        methodElement,
-                        null,
-                        returnType,
-                        methodMetadata,
+                        builderClassElement.getPrimaryConstructor().orElse(null),
+                        builderClassElement.getDefaultConstructor().orElse(null),
+                        builderClassElement,
+                        builderClassElement.getTargetAnnotationMetadata(),
                         index,
-                        targetPackage
-                    );
+                        targetPackage);
                 } else {
-                    context.fail("Builder return type is not public. The method must be static and accessible.", methodElement);
+                    context.fail("Builder class not found on compilation classpath: " + builderClass.getName(), element);
                 }
             } else {
-                context.fail("Method " + builderMethod + "() specified by builderMethod not found. The method must be static and accessible.", element);
+                context.fail("When specifying the 'builder' member of @Introspected you must supply either a builderClass or builderMethod", element);
             }
-        } else if (builderClass != null) {
-            ClassElement builderClassElement = context.getClassElement(builderClass.getName()).orElse(null);
-            if (builderClassElement != null) {
-                AnnotationValueBuilder<Introspected> replaceIntrospected = AnnotationValue.builder(introspected, RetentionPolicy.RUNTIME);
-                replaceIntrospected.member("builderClass", new AnnotationClassValue<>(builderClassElement.getName()));
-                element.annotate(replaceIntrospected.build());
-
-                handleBuilder(
-                    element,
-                    context,
-                    creatorMethod,
-                    writePrefixes,
-                    builderClassElement.getPrimaryConstructor().orElse(null),
-                    builderClassElement.getDefaultConstructor().orElse(null),
-                    builderClassElement,
-                    builderClassElement.getTargetAnnotationMetadata(),
-                    index,
-                    targetPackage);
-            } else {
-                context.fail("Builder class not found on compilation classpath: " + builderClass.getName(), element);
-            }
-        } else {
-            context.fail("When specifying the 'builder' member of @Introspected you must supply either a builderClass or builderMethod", element);
         }
     }
 
@@ -420,18 +380,13 @@ public class IntrospectedTypeElementVisitor implements TypeElementVisitor<Object
         List<PropertyElement> beanProperties = ce.getBeanProperties(propertyElementQuery).stream()
             .filter(p -> !p.isExcluded())
             .toList();
-        // unfortunately sometimes we don't see the Lombok transformations
-        // so assume if the class is annotated with Lombok builder we cannot
-        // access the constructor.
-        if (!ce.hasDeclaredAnnotation(ANN_LOMBOK_BUILDER)) {
-            Optional<MethodElement> constructorElement = ce.getPrimaryConstructor();
-            constructorElement.ifPresent(constructorEl -> {
-                if (ArrayUtils.isNotEmpty(constructorEl.getParameters())) {
-                    writer.visitConstructor(constructorEl);
-                }
-            });
-            ce.getDefaultConstructor().ifPresent(writer::visitDefaultConstructor);
-        }
+        Optional<MethodElement> constructorElement = ce.getPrimaryConstructor();
+        constructorElement.ifPresent(constructorEl -> {
+            if (ArrayUtils.isNotEmpty(constructorEl.getParameters())) {
+                writer.visitConstructor(constructorEl);
+            }
+        });
+        ce.getDefaultConstructor().ifPresent(writer::visitDefaultConstructor);
 
         for (PropertyElement beanProperty : beanProperties) {
             if (beanProperty.isExcluded()) {
diff --git a/core/src/main/java/io/micronaut/core/beans/BeanIntrospection.java b/core/src/main/java/io/micronaut/core/beans/BeanIntrospection.java
index f14fc35467..55622d4a37 100644
--- a/core/src/main/java/io/micronaut/core/beans/BeanIntrospection.java
+++ b/core/src/main/java/io/micronaut/core/beans/BeanIntrospection.java
@@ -327,7 +327,7 @@ public interface BeanIntrospection<T> extends AnnotationMetadataDelegate, BeanIn
         final BeanReadProperty<T, ?> prop = getReadProperty(name).orElse(null);
         if (prop != null && type.isAssignableFrom(prop.getType())) {
             //noinspection unchecked
-            return Optional.of((BeanReadProperty<T, P>) prop);
+            return Optional.of((BeanProperty<T, P>) prop);
         }
         return Optional.empty();
     }
diff --git a/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java b/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java
index 86d2bc6766..6a7f71a9c5 100644
--- a/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java
+++ b/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java
@@ -89,12 +89,6 @@ class ServiceLoaderFeature implements Feature {
                             }
                             Class<?> beanType = beanInfo.getBeanType();
                             List<AnnotationValue<Annotation>> values = beanInfo.getAnnotationMetadata().getAnnotationValuesByName("io.micronaut.context.annotation.Requires");
-                            if (values.isEmpty()) {
-                                AnnotationValue<Annotation> requirements = beanInfo.getAnnotationMetadata().getAnnotation("io.micronaut.context.annotation.Requirements");
-                                if (requirements != null) {
-                                    values = requirements.getAnnotations("value");
-                                }
-                            }
                             if (!values.isEmpty()) {
                                 for (AnnotationValue<Annotation> value : values) {
                                     String[] classNames = EMPTY_STRING_ARRAY;
diff --git a/gradle.properties b/gradle.properties
index 4218359204..9c987613c8 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,4 +1,4 @@
-projectVersion=4.7.9-SNAPSHOT
+projectVersion=4.7.6-SNAPSHOT
 projectGroupId=io.micronaut
 projectDesc=Core components supporting the Micronaut Framework
 title=Micronaut Core
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index e2847c8200..df97d72b8b 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.11.1-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.10.2-bin.zip
 networkTimeout=10000
 validateDistributionUrl=true
 zipStoreBase=GRADLE_USER_HOME
diff --git a/http-client/build.gradle b/http-client/build.gradle
index c4e14be8d8..6a9c225a72 100644
--- a/http-client/build.gradle
+++ b/http-client/build.gradle
@@ -20,6 +20,7 @@ dependencies {
     api libs.managed.netty.handler.proxy
 
     compileOnly libs.managed.netty.incubator.codec.http3
+    testImplementation libs.managed.netty.incubator.codec.http3
 
     testAnnotationProcessor platform(libs.test.boms.micronaut.validation)
     testAnnotationProcessor (libs.micronaut.validation.processor) {
@@ -46,6 +47,8 @@ dependencies {
     testImplementation libs.wiremock
     testImplementation libs.logback.classic
     testImplementation libs.bcpkix
+    testImplementation libs.junit.jupiter.params
+    testImplementation libs.awaitility
 
     testRuntimeOnly(libs.managed.netty.tcnative.boringssl.static) {
         artifact {
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
index a77770d304..4a15ca7b73 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
@@ -1369,7 +1369,7 @@ public class ConnectionManager {
             }
 
             @Override
-            public boolean dispatch(PoolSink<PoolHandle> sink) {
+            public final boolean dispatch(PoolSink<PoolHandle> sink) {
                 if (!tryEarmarkForRequest()) {
                     return false;
                 }
@@ -1602,7 +1602,7 @@ public class ConnectionManager {
             }
 
             @Override
-            void dispatch0(PoolSink<PoolHandle> sink) {
+            final void dispatch0(PoolSink<PoolHandle> sink) {
                 if (!channel.isActive() || windDownConnection) {
                     // make sure the request isn't dispatched to this connection again
                     windDownConnection();
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index 9093107247..6595b5ea5b 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -2187,7 +2187,7 @@ public class DefaultHttpClient implements
     /**
      * Used as a holder for the current SSE event.
      */
-    private static class CurrentEvent {
+    private static final class CurrentEvent {
         byte[] data;
         String id;
         String name;
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/FullNettyClientHttpResponse.java b/http-client/src/main/java/io/micronaut/http/client/netty/FullNettyClientHttpResponse.java
index 78121bcd09..d5756b8427 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/FullNettyClientHttpResponse.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/FullNettyClientHttpResponse.java
@@ -45,7 +45,6 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
-import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * Wraps a Netty {@link FullHttpResponse} for consumption by the {@link io.micronaut.http.client.HttpClient}.
@@ -64,7 +63,7 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
     private final MutableConvertibleValues<Object> attributes;
     private final io.netty.handler.codec.http.HttpResponse nettyHttpResponse;
     private final ByteBuf unpooledContent;
-    private final Map<Argument, Optional> convertedBodies = new ConcurrentHashMap<>();
+    private final Map<Argument, Optional> convertedBodies = new HashMap<>();
     private final MessageBodyHandlerRegistry handlerRegistry;
     private final B body;
     private final ConversionService conversionService;
@@ -77,12 +76,11 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
      * @param conversionService      The conversion service
      */
     FullNettyClientHttpResponse(
-        FullHttpResponse fullHttpResponse,
-        MessageBodyHandlerRegistry handlerRegistry,
-        Argument<B> bodyType,
-        boolean convertBody,
-        ConversionService conversionService
-    ) {
+            FullHttpResponse fullHttpResponse,
+            MessageBodyHandlerRegistry handlerRegistry,
+            Argument<B> bodyType,
+            boolean convertBody,
+            ConversionService conversionService) {
         this.conversionService = conversionService;
         this.headers = new NettyHttpHeaders(fullHttpResponse.headers(), conversionService);
         this.attributes = new MutableConvertibleValuesMap<>();
@@ -97,7 +95,7 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
             if (HttpResponse.class.isAssignableFrom(bodyType.getType())) {
                 Optional<Argument<?>> responseBodyType = bodyType.getFirstTypeVariable();
                 if (responseBodyType.isPresent()) {
-                    var finalResponseBodyType = (Argument<B>) responseBodyType.get();
+                    Argument<B> finalResponseBodyType = (Argument<B>) responseBodyType.get();
                     this.body = convertBody || isParseableBodyType(finalResponseBodyType.getType()) ? getBody(finalResponseBodyType).orElse(null) : null;
                 } else {
                     this.body = null;
@@ -120,7 +118,6 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
         return this.nettyHttpResponse.status().code();
     }
 
-    @NonNull
     @Override
     public HttpHeaders getHeaders() {
         return headers;
@@ -136,21 +133,18 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
         return nettyCookies.findCookie(name);
     }
 
-    @NonNull
     @Override
     public MutableConvertibleValues<Object> getAttributes() {
         return attributes;
     }
 
-    @NonNull
     @Override
     public Optional<B> getBody() {
         return Optional.ofNullable(body);
     }
 
-    @NonNull
     @Override
-    public <T> Optional<T> getBody(@NonNull Class<T> type) {
+    public <T> Optional<T> getBody(Class<T> type) {
         if (type == null) {
             return Optional.empty();
         }
@@ -158,9 +152,8 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
     }
 
     @SuppressWarnings("unchecked")
-    @NonNull
     @Override
-    public <T> Optional<T> getBody(@NonNull Argument<T> type) {
+    public <T> Optional<T> getBody(Argument<T> type) {
         if (type == null) {
             return Optional.empty();
         }
@@ -178,19 +171,21 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
             } catch (RuntimeException e) {
                 if (code() < 400) {
                     throw e;
+                } else {
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Error decoding HTTP error response body: {}", e.getMessage(), e);
+                    }
+                    converted = Optional.empty();
                 }
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug("Error decoding HTTP error response body: {}", e.getMessage(), e);
-                }
-                converted = Optional.empty();
             }
             if (isOptional) {
                 return Optional.of(converted);
             } else {
                 return converted;
             }
-        });
+        }
 
+        );
         if (LOG.isTraceEnabled() && result.isEmpty()) {
             LOG.trace("Unable to convert response body to target type {}", type.getType());
         }
@@ -237,7 +232,7 @@ public class FullNettyClientHttpResponse<B> implements HttpResponse<B>, NettyHtt
     @NonNull
     @Override
     public FullHttpResponse toFullHttpResponse() {
-        var copy = new DefaultFullHttpResponse(
+        DefaultFullHttpResponse copy = new DefaultFullHttpResponse(
             nettyHttpResponse.protocolVersion(),
             nettyHttpResponse.status(),
             unpooledContent,
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/Http1ResponseHandler.java b/http-client/src/main/java/io/micronaut/http/client/netty/Http1ResponseHandler.java
index 7af3435a7d..3c7cdede95 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/Http1ResponseHandler.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/Http1ResponseHandler.java
@@ -95,6 +95,7 @@ final class Http1ResponseHandler extends SimpleChannelInboundHandlerInstrumented
         if (state != fromState) {
             throw new IllegalStateException("Wrong source state");
         }
+        fromState.leave(ctx);
         state = nextState;
     }
 
@@ -110,6 +111,9 @@ final class Http1ResponseHandler extends SimpleChannelInboundHandlerInstrumented
         void channelInactive(ChannelHandlerContext ctx) {
             exceptionCaught(ctx, new ResponseClosedException("Connection closed before response was received"));
         }
+
+        void leave(ChannelHandlerContext ctx) {
+        }
     }
 
     /**
@@ -226,6 +230,7 @@ final class Http1ResponseHandler extends SimpleChannelInboundHandlerInstrumented
         private final ResponseListener listener;
         private final ChannelHandlerContext streamingContext;
         private final StreamingNettyByteBody.SharedBuffer streaming;
+        private final boolean wasAutoRead;
         private long demand;
 
         UnbufferedContent(ResponseListener listener, ChannelHandlerContext ctx, HttpResponse response) {
@@ -235,6 +240,13 @@ final class Http1ResponseHandler extends SimpleChannelInboundHandlerInstrumented
                 streaming.setExpectedLengthFrom(response.headers());
             }
             streamingContext = ctx;
+            wasAutoRead = ctx.channel().config().isAutoRead();
+            ctx.channel().config().setAutoRead(false);
+        }
+
+        @Override
+        void leave(ChannelHandlerContext ctx) {
+            ctx.channel().config().setAutoRead(wasAutoRead);
         }
 
         void add(ByteBuf buf) {
@@ -278,14 +290,7 @@ final class Http1ResponseHandler extends SimpleChannelInboundHandlerInstrumented
         }
 
         private void start0() {
-            if (state != this) {
-                return;
-            }
-
-            demand++;
-            if (demand == 1) {
-                streamingContext.read();
-            }
+            onBytesConsumed0(1);
         }
 
         @Override
@@ -306,7 +311,7 @@ final class Http1ResponseHandler extends SimpleChannelInboundHandlerInstrumented
             long newDemand = oldDemand + bytesConsumed;
             if (newDemand < oldDemand) {
                 // overflow
-                newDemand = oldDemand;
+                newDemand = Long.MAX_VALUE;
             }
             this.demand = newDemand;
             if (oldDemand <= 0 && newDemand > 0) {
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ReactiveClientReader.java b/http-client/src/main/java/io/micronaut/http/client/netty/ReactiveClientReader.java
deleted file mode 100644
index d59cc65cf6..0000000000
--- a/http-client/src/main/java/io/micronaut/http/client/netty/ReactiveClientReader.java
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
- * Copyright 2017-2023 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.client.netty;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.http.client.exceptions.ResponseClosedException;
-import io.micronaut.http.netty.reactive.HotObservable;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerAdapter;
-import io.netty.channel.EventLoop;
-import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.LastHttpContent;
-import org.reactivestreams.Publisher;
-import org.reactivestreams.Subscriber;
-import org.reactivestreams.Subscription;
-
-/**
- * Provides incoming {@link HttpContent} as a {@link Publisher}. Note: This handler <b>requires</b>
- * a {@link io.netty.handler.flow.FlowControlHandler}.
- *
- * @since 4.1.0
- * @author Jonas Konrad
- */
-@Internal
-abstract class ReactiveClientReader extends ChannelInboundHandlerAdapter implements HotObservable<HttpContent>, Subscription {
-    private EventLoop eventLoop;
-    private ChannelHandlerContext ctx;
-    @Nullable
-    private Subscriber<? super HttpContent> subscriber;
-    private Throwable heldBackException;
-    private long demand;
-    private boolean cancelled = false;
-
-    @Override
-    public final void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-        this.ctx = ctx;
-        eventLoop = ctx.channel().eventLoop();
-    }
-
-    private void forwardException(Throwable t) {
-        if (subscriber == null) {
-            // no subscriber yet
-            heldBackException = t;
-        } else {
-            subscriber.onError(t);
-        }
-    }
-
-    @Override
-    public final void channelInactive(ChannelHandlerContext ctx) throws Exception {
-        super.channelInactive(ctx);
-        if (!cancelled) {
-            cancelled = true;
-            forwardException(new ResponseClosedException("Connection closed before full response body was transferred"));
-        }
-    }
-
-    @Override
-    public final void subscribe(Subscriber<? super HttpContent> s) {
-        if (subscriber != null) {
-            throw new IllegalStateException("Already subscribed");
-        }
-        if (!eventLoop.inEventLoop()) {
-            eventLoop.execute(() -> subscribe(s));
-            return;
-        }
-
-        subscriber = s;
-        s.onSubscribe(this);
-        if (heldBackException != null) {
-            // already got an error
-            s.onError(heldBackException);
-            heldBackException = null;
-        }
-    }
-
-    @Override
-    public final void request(long n) {
-        if (!eventLoop.inEventLoop()) {
-            eventLoop.execute(() -> request(n));
-            return;
-        }
-
-        long oldDemand = demand;
-        long newDemand = oldDemand + n;
-        if (newDemand < 0) {
-            newDemand = Long.MAX_VALUE;
-        }
-        demand = newDemand;
-        // this read call can lead to a channelRead and thus an onNext. If we are already in an
-        // onNext, we need to make sure this doesn't happen (onNext must not be nested). For this
-        // reason, in channelRead, the demand is decremented *after* the onNext call, so that
-        // if we are already in onNext, oldDemand is never 0 here.
-        if (oldDemand == 0) {
-            ctx.read();
-        }
-    }
-
-    @Override
-    public final void cancel() {
-        if (!eventLoop.inEventLoop()) {
-            eventLoop.execute(this::cancel);
-            return;
-        }
-        cancelled = true;
-        if (demand == 0) {
-            // eat remaining content
-            ctx.read();
-        }
-    }
-
-    @Override
-    public final void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        boolean last = msg instanceof LastHttpContent;
-        if (cancelled) {
-            ((HttpContent) msg).release();
-            if (last) {
-                remove(ctx);
-            } else {
-                ctx.read();
-            }
-        } else {
-            assert demand > 0 : "should be ensured by FlowControlHandler";
-            // demand > 0 => subscriber != null, so this is safe
-            subscriber.onNext((HttpContent) msg);
-            if (last) {
-                cancelled = true;
-                remove(ctx);
-                subscriber.onComplete();
-            } else if (--demand > 0) {
-                ctx.read();
-            }
-        }
-    }
-
-    @Override
-    public final void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
-        if (cancelled) {
-            ctx.fireExceptionCaught(cause);
-        } else {
-            cancelled = true;
-            remove(ctx);
-            forwardException(cause);
-        }
-    }
-
-    @Override
-    public final void closeIfNoSubscriber() {
-        cancel();
-    }
-
-    /**
-     * Remove this handler.
-     *
-     * @param ctx The context of this handler
-     */
-    protected abstract void remove(ChannelHandlerContext ctx);
-}
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ReactiveClientWriter.java b/http-client/src/main/java/io/micronaut/http/client/netty/ReactiveClientWriter.java
deleted file mode 100644
index 24551f9d7d..0000000000
--- a/http-client/src/main/java/io/micronaut/http/client/netty/ReactiveClientWriter.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright 2017-2023 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.client.netty;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.http.netty.EventLoopFlow;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerAdapter;
-import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.LastHttpContent;
-import org.reactivestreams.Publisher;
-import org.reactivestreams.Subscriber;
-import org.reactivestreams.Subscription;
-
-/**
- * Writes data from a publisher to a channel.
- *
- * @since 4.1.0
- * @author Jonas Konrad
- */
-@Internal
-final class ReactiveClientWriter extends ChannelInboundHandlerAdapter implements Subscriber<HttpContent> {
-    private final Publisher<HttpContent> source;
-    private EventLoopFlow flow;
-    private ChannelHandlerContext ctx;
-    private Subscription subscription;
-    private boolean writtenLast;
-
-    ReactiveClientWriter(Publisher<HttpContent> source) {
-        this.source = source;
-    }
-
-    @Override
-    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-        this.flow = new EventLoopFlow(ctx.channel().eventLoop());
-        this.ctx = ctx;
-        source.subscribe(this);
-    }
-
-    @Override
-    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
-        this.ctx = null;
-        if (subscription != null) {
-            subscription.cancel();
-        }
-    }
-
-    @Override
-    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {
-        super.channelWritabilityChanged(ctx);
-        if (ctx.channel().isWritable()) {
-            subscription.request(1);
-        }
-    }
-
-    @Override
-    public void onSubscribe(Subscription s) {
-        if (flow.executeNow(() -> onSubscribe0(s))) {
-            onSubscribe0(s);
-        }
-    }
-
-    private void onSubscribe0(Subscription s) {
-        if (ctx == null) {
-            s.cancel();
-        } else {
-            subscription = s;
-            if (ctx.channel().isWritable()) {
-                subscription.request(1);
-            }
-        }
-    }
-
-    @Override
-    public void onNext(HttpContent httpContent) {
-        if (flow.executeNow(() -> onNext0(httpContent))) {
-            onNext0(httpContent);
-        }
-    }
-
-    private void onNext0(HttpContent httpContent) {
-        if (writtenLast) {
-            throw new IllegalStateException("Already written a LastHttpContent");
-        }
-
-        if (ctx == null) {
-            httpContent.release();
-            return;
-        }
-
-        if (httpContent instanceof LastHttpContent) {
-            writtenLast = true;
-        }
-        ctx.writeAndFlush(httpContent, ctx.voidPromise());
-        if (ctx.channel().isWritable()) {
-            subscription.request(1);
-        }
-    }
-
-    @Override
-    public void onError(Throwable t) {
-        if (flow.executeNow(() -> onError0(t))) {
-            onError0(t);
-        }
-    }
-
-    private void onError0(Throwable t) {
-        ctx.fireExceptionCaught(t);
-        ctx.pipeline().remove(ctx.name());
-    }
-
-    @Override
-    public void onComplete() {
-        if (flow.executeNow(this::onComplete0)) {
-            onComplete0();
-        }
-    }
-
-    private void onComplete0() {
-        if (!writtenLast) {
-            ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT, ctx.voidPromise());
-        }
-        ctx.pipeline().remove(ctx.name());
-    }
-}
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/StreamWriter.java b/http-client/src/main/java/io/micronaut/http/client/netty/StreamWriter.java
index c0f6559f5f..1ea457aa49 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/StreamWriter.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/StreamWriter.java
@@ -37,11 +37,10 @@ import java.util.function.Consumer;
  */
 @Internal
 final class StreamWriter extends ChannelInboundHandlerAdapter implements BufferConsumer {
-    private final StreamingNettyByteBody body;
     private final Consumer<Throwable> errorHandler;
     private ChannelHandlerContext ctx;
     private EventLoopFlow flow;
-    private Upstream upstream;
+    private final Upstream upstream;
     private long unwritten = 0;
     private boolean completed = false;
 
@@ -50,8 +49,8 @@ final class StreamWriter extends ChannelInboundHandlerAdapter implements BufferC
      * @param errorHandler Handler to call when the streaming body emits an error
      */
     StreamWriter(StreamingNettyByteBody body, Consumer<Throwable> errorHandler) {
-        this.body = body;
         this.errorHandler = errorHandler;
+        this.upstream = body.primary(this);
     }
 
     /**
@@ -61,7 +60,6 @@ final class StreamWriter extends ChannelInboundHandlerAdapter implements BufferC
         if (ctx == null) {
             throw new IllegalStateException("Not added to a channel yet");
         }
-        upstream = body.primary(this);
         try {
             upstream.start();
         } catch (Exception e) {
@@ -73,11 +71,8 @@ final class StreamWriter extends ChannelInboundHandlerAdapter implements BufferC
      * Cancel writing the body (e.g. because a {@code CONTINUE} response was never received).
      */
     void cancel() {
-        if (upstream != null) {
-            upstream.allowDiscard();
-            upstream.disregardBackpressure();
-        }
-        body.close();
+        upstream.allowDiscard();
+        upstream.disregardBackpressure();
     }
 
     boolean isCompleted() {
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/DefaultHttpCompressionStrategy.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/DefaultHttpCompressionStrategy.java
index 20ecbbecac..a06975d582 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/DefaultHttpCompressionStrategy.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/DefaultHttpCompressionStrategy.java
@@ -36,7 +36,6 @@ final class DefaultHttpCompressionStrategy implements HttpCompressionStrategy {
 
     private final int compressionThreshold;
     private final int compressionLevel;
-    private final int maxZstdEncodeSize;
 
     /**
      * @param serverConfiguration The netty server configuration
@@ -45,17 +44,15 @@ final class DefaultHttpCompressionStrategy implements HttpCompressionStrategy {
     DefaultHttpCompressionStrategy(NettyHttpServerConfiguration serverConfiguration) {
         this.compressionThreshold = serverConfiguration.getCompressionThreshold();
         this.compressionLevel = serverConfiguration.getCompressionLevel();
-        this.maxZstdEncodeSize = serverConfiguration.getMaxZstdEncodeSize();
     }
 
     /**
      * @param compressionThreshold The compression threshold
      * @param compressionLevel The compression level (0-9)
      */
-    DefaultHttpCompressionStrategy(int compressionThreshold, int compressionLevel, int maxZstdEncodeSize) {
+    DefaultHttpCompressionStrategy(int compressionThreshold, int compressionLevel) {
         this.compressionThreshold = compressionThreshold;
         this.compressionLevel = compressionLevel;
-        this.maxZstdEncodeSize = maxZstdEncodeSize;
     }
 
     @Override
@@ -82,9 +79,4 @@ final class DefaultHttpCompressionStrategy implements HttpCompressionStrategy {
     public int getCompressionLevel() {
         return compressionLevel;
     }
-
-    @Override
-    public int getMaxZstdEncodeSize() {
-        return maxZstdEncodeSize;
-    }
 }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpCompressionStrategy.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpCompressionStrategy.java
index 2746fc5b67..29edddefd9 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpCompressionStrategy.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpCompressionStrategy.java
@@ -39,9 +39,4 @@ public interface HttpCompressionStrategy extends Toggleable {
     default int getCompressionLevel() {
         return StandardCompressionOptions.gzip().compressionLevel();
     }
-
-    /**
-     * @return The maximum size of data that can be encoded using the zstd algorithm.
-     */
-    int getMaxZstdEncodeSize();
 }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java
index ad5544ca4d..07813f8c03 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java
@@ -20,8 +20,8 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.naming.Named;
 import io.micronaut.core.util.SupplierUtil;
 import io.micronaut.http.HttpVersion;
-import io.micronaut.http.netty.channel.ChannelPipelineCustomizer;
 import io.micronaut.http.netty.body.BodySizeLimits;
+import io.micronaut.http.netty.channel.ChannelPipelineCustomizer;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.netty.handler.Http2ServerHandler;
 import io.micronaut.http.server.netty.handler.PipeliningServerHandler;
@@ -155,7 +155,7 @@ final class HttpPipelineBuilder implements Closeable {
     }
 
     boolean supportsSsl() {
-        return sslContext != null;
+        return sslContext != null || quicSslContext != null;
     }
 
     @Override
@@ -340,6 +340,7 @@ final class HttpPipelineBuilder implements Closeable {
                         ch.pipeline().addLast(new Http3ServerConnectionHandler(new ChannelInitializer<QuicStreamChannel>() {
                             @Override
                             protected void initChannel(@NonNull QuicStreamChannel ch) throws Exception {
+                                ch.config().setAutoRead(false);
                                 StreamPipeline streamPipeline = new StreamPipeline(ch, sslHandler, connectionCustomizer.specializeForChannel(ch, NettyServerCustomizer.ChannelRole.REQUEST_STREAM));
                                 streamPipeline.insertHttp3FrameHandlers();
                                 streamPipeline.streamCustomizer.onStreamPipelineBuilt();
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java
index 0d5c9b7f60..d26b2ff1f6 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java
@@ -109,12 +109,6 @@ public class NettyHttpServerConfiguration extends HttpServerConfiguration {
     @SuppressWarnings("WeakerAccess")
     public static final int DEFAULT_COMPRESSIONLEVEL = 6;
 
-    /**
-     * The default size of the largest data that can be encoded using the zstd algorithm.
-     */
-    @SuppressWarnings("WeakerAccess")
-    public static final int DEFAULT_MAX_ZSTD_ENCODE_SIZE = 1024 * 1024 * 32;
-
     /**
      * The default configuration for boolean flag indicating whether to add connection header `keep-alive` to responses with HttpStatus > 499.
      */
@@ -206,7 +200,6 @@ public class NettyHttpServerConfiguration extends HttpServerConfiguration {
     private LogLevel logLevel;
     private int compressionThreshold = DEFAULT_COMPRESSIONTHRESHOLD;
     private int compressionLevel = DEFAULT_COMPRESSIONLEVEL;
-    private int maxZstdEncodeSize = DEFAULT_MAX_ZSTD_ENCODE_SIZE;
     private boolean useNativeTransport = DEFAULT_USE_NATIVE_TRANSPORT;
     private String fallbackProtocol = ApplicationProtocolNames.HTTP_1_1;
     private AccessLogger accessLogger;
@@ -479,16 +472,6 @@ public class NettyHttpServerConfiguration extends HttpServerConfiguration {
         return compressionLevel;
     }
 
-    /**
-     * The default maximum size of data that can be encoded using the zstd algorithm.
-     * Default value ({@value #DEFAULT_MAX_ZSTD_ENCODE_SIZE}).
-     *
-     * @return The maximum size of data that can be encoded using the zstd algorithm.
-     */
-    public int getMaxZstdEncodeSize() {
-        return maxZstdEncodeSize;
-    }
-
     /**
      * @return The Netty child channel options.
      * @see io.netty.bootstrap.ServerBootstrap#childOption(io.netty.channel.ChannelOption, Object)
@@ -674,15 +657,6 @@ public class NettyHttpServerConfiguration extends HttpServerConfiguration {
         this.compressionLevel = compressionLevel;
     }
 
-    /**
-     * Sets the maximum size of data that can be encoded using the zstd algorithm. Default value ({@value #DEFAULT_MAX_ZSTD_ENCODE_SIZE}).
-     *
-     * @param maxZstdEncodeSize The maximum size of block.
-     */
-    public void setMaxZstdEncodeSize(int maxZstdEncodeSize) {
-        this.maxZstdEncodeSize = maxZstdEncodeSize;
-    }
-
     /**
      * Whether to send connection keep alive on internal server errors. Default value ({@value DEFAULT_KEEP_ALIVE_ON_SERVER_ERROR}).
      * @param keepAliveOnServerError The keep alive on server error flag
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java
index 9c28d2294e..dd5a88ca2a 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java
@@ -65,11 +65,7 @@ final class Compressor {
         this.gzipOptions = StandardCompressionOptions.gzip(strategy.getCompressionLevel(), stdGzip.windowBits(), stdGzip.memLevel());
         DeflateOptions stdDeflate = StandardCompressionOptions.deflate();
         this.deflateOptions = StandardCompressionOptions.deflate(strategy.getCompressionLevel(), stdDeflate.windowBits(), stdDeflate.memLevel());
-        this.zstdOptions = Zstd.isAvailable()
-            ? StandardCompressionOptions.zstd(strategy.getCompressionLevel(),
-            StandardCompressionOptions.zstd().blockSize(),
-            strategy.getMaxZstdEncodeSize())
-            : null;
+        this.zstdOptions = Zstd.isAvailable() ? StandardCompressionOptions.zstd() : null;
         this.snappyOptions = StandardCompressionOptions.snappy();
     }
 
@@ -100,7 +96,7 @@ final class Compressor {
         response.headers().add(HttpHeaderNames.CONTENT_ENCODING, encoding.contentEncoding);
         ChannelHandler handler = switch (encoding) {
             case BR -> makeBrotliEncoder();
-            case ZSTD -> new ZstdEncoder(zstdOptions.compressionLevel(), zstdOptions.blockSize(), strategy.getMaxZstdEncodeSize());
+            case ZSTD -> new ZstdEncoder(zstdOptions.compressionLevel(), zstdOptions.blockSize(), zstdOptions.maxEncodeSize());
             case SNAPPY -> new SnappyFrameEncoder();
             case GZIP -> ZlibCodecFactory.newZlibEncoder(ZlibWrapper.GZIP, gzipOptions.compressionLevel(), gzipOptions.windowBits(), gzipOptions.memLevel());
             case DEFLATE -> ZlibCodecFactory.newZlibEncoder(ZlibWrapper.ZLIB, deflateOptions.compressionLevel(), deflateOptions.windowBits(), deflateOptions.memLevel());
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
index 813ac99365..a1592cbc91 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
@@ -1141,6 +1141,7 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
 
                 if (!writtenLast) {
                     writeCompressing(LastHttpContent.EMPTY_LAST_CONTENT, true, outboundAccess.closeAfterWrite);
+                    writtenLast = true;
                 }
                 requestHandler.responseWritten(outboundAccess.attachment);
                 PipeliningServerHandler.this.writeSome();
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java b/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
index e68fac8b28..2d26416e05 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
@@ -35,7 +35,6 @@ import io.micronaut.inject.ast.FieldElement;
 import io.micronaut.inject.ast.MemberElement;
 import io.micronaut.inject.ast.MethodElement;
 import io.micronaut.inject.processing.ProcessingException;
-import io.micronaut.inject.visitor.ElementPostponedToNextRoundException;
 import io.micronaut.inject.visitor.TypeElementVisitor;
 import io.micronaut.inject.visitor.VisitorContext;
 import io.micronaut.inject.writer.AbstractBeanDefinitionBuilder;
@@ -43,7 +42,6 @@ import io.micronaut.inject.writer.AbstractBeanDefinitionBuilder;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.annotation.processing.RoundEnvironment;
 import javax.annotation.processing.SupportedOptions;
-import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import java.io.IOException;
@@ -278,15 +276,6 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
                             error(originatingElement.element(), e.getMessage());
                         } catch (PostponeToNextRoundException e) {
                             postponedTypes.put(javaClassElement.getCanonicalName(), e.getErrorElement());
-                        } catch (ElementPostponedToNextRoundException e) {
-                            Object nativeType = e.getOriginatingElement().getNativeType();
-                            if (nativeType instanceof JavaNativeElement jne) {
-                                Element element = jne.element();
-                                postponedTypes.put(javaClassElement.getCanonicalName(), element);
-                            } else {
-                                // should never happen.
-                                throw e;
-                            }
                         }
                     }
                 }
diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/annotation/KotlinAnnotationMetadataBuilder.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/annotation/KotlinAnnotationMetadataBuilder.kt
index 742fe92c87..6bd7ce1ccf 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/annotation/KotlinAnnotationMetadataBuilder.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/annotation/KotlinAnnotationMetadataBuilder.kt
@@ -79,7 +79,6 @@ internal class KotlinAnnotationMetadataBuilder(
         val annotationMirror = getAnnotationMirror(value.annotationName).orElse(null)
         if (annotationMirror == null) {
             return ClassUtils.forName(value.annotationName, null)
-                .or { ClassUtils.forName(value.annotationName, visitorContext::class.java.classLoader) }
                 .map { it -> it.annotations.any { it.annotationClass.java == Repeatable::class.java } }
                 .orElse(false)
         }
diff --git a/inject/src/main/java/io/micronaut/inject/beans/AbstractInitializableBeanIntrospection.java b/inject/src/main/java/io/micronaut/inject/beans/AbstractInitializableBeanIntrospection.java
index cab98699d4..05fad119a7 100644
--- a/inject/src/main/java/io/micronaut/inject/beans/AbstractInitializableBeanIntrospection.java
+++ b/inject/src/main/java/io/micronaut/inject/beans/AbstractInitializableBeanIntrospection.java
@@ -472,11 +472,9 @@ public abstract class AbstractInitializableBeanIntrospection<B> implements Unsaf
 
             AnnotationValue<Introspected.IntrospectionBuilder> builderAnn = getAnnotationMetadata().findAnnotation(Introspected.class)
                 .flatMap(a -> a.getAnnotation("builder", Introspected.IntrospectionBuilder.class)).orElse(null);
-            Class<?> builderClass = getAnnotationMetadata().classValue(Introspected.class, "builderClass").orElse(null);
-            if (builderAnn != null || builderClass != null) {
-                if (builderClass == null) {
-                    throw new IntrospectionException("Introspection defines invalid builder member for type: " + getBeanType());
-                } else {
+            if (builderAnn != null) {
+                Class<?> builderClass = getAnnotationMetadata().classValue(Introspected.class, "builderClass").orElse(null);
+                if (builderClass != null) {
                     BeanIntrospection<Object> builderIntrospection = (BeanIntrospection<Object>) BeanIntrospection.getIntrospection(builderClass);
                     Collection<BeanMethod<Object, Object>> beanMethods = builderIntrospection.getBeanMethods();
 
@@ -522,6 +520,8 @@ public abstract class AbstractInitializableBeanIntrospection<B> implements Unsaf
                             arguments.toArray(Argument.ZERO_ARGUMENTS)
                         );
                     }
+                } else {
+                    throw new IntrospectionException("Introspection defines invalid builder member for type: " + getBeanType());
                 }
             } else {
                 int constructorLength = constructorArguments.length;
diff --git a/settings.gradle b/settings.gradle
index f3acdf625a..2b6bb9d198 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -6,7 +6,7 @@ pluginManagement {
 }
 
 plugins {
-    id 'io.micronaut.build.shared.settings' version '7.3.0'
+    id 'io.micronaut.build.shared.settings' version '7.2.3'
 }
 enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")
 
diff --git a/src/main/docs/guide/config.adoc b/src/main/docs/guide/config.adoc
index 5d3b92313f..cb7c3ebf90 100644
--- a/src/main/docs/guide/config.adoc
+++ b/src/main/docs/guide/config.adoc
@@ -1,6 +1,6 @@
 Micronaut features a flexible configuration mechanism that allows reading configuration from a variety of sources into a unified model that can be bound to Java types annotated with <<configurationProperties, @ConfigurationProperties>>.
 
-Configuration can by default be provided in Java properties files or https://www.json.org/json-en.html[JSON] with the ability to add support for more formats (such as YAML or Groovy configuration) by adding additional third-party libraries to your classpath. The convention is to search for a file named `application.properties` or `application.json` with support for other formats requiring additional dependencies as described by the following table:
+Configuration can by default be provided in Java properties files or https://www.json.org/json-en.html[JSON] with the ability to add support for more formats (such as YAML or Groovy configuration) by adding addition third-party libraries to your classpath. The convention is to search for a file named `application.properties` or `application.json` with support for other formats requiring additional dependencies as described by the following table:
 
 .Supported Configuration Formats
 |===
diff --git a/src/main/docs/guide/httpServer/serverConfiguration/https.adoc b/src/main/docs/guide/httpServer/serverConfiguration/https.adoc
index 04fd50bff3..4d1ce10669 100644
--- a/src/main/docs/guide/httpServer/serverConfiguration/https.adoc
+++ b/src/main/docs/guide/httpServer/serverConfiguration/https.adoc
@@ -20,7 +20,7 @@ If you use a pre-generated certificate (as you should, for security), these step
 - Netty can use the JDK-internal `sun.security.x509` package. On newer JDK versions, this package is restricted and may not work. You may need to add `--add-exports=java.base/sun.security.x509=ALL-UNNAMED` as a VM parameter.
 - Alternatively, netty will use the Bouncy Castle BCPKIX API. This needs an additional dependency:
 
-dependency:org.bouncycastle:bcpkix-jdk18on[scope="implementation"]
+dependency:org.bouncycastle:bcpkix-jdk15on[scope="implementation"]
 
 WARNING: This configuration will generate a warning in the browser.
 
diff --git a/test-suite/build.gradle b/test-suite/build.gradle
index 690bf5429b..29c6095ecb 100644
--- a/test-suite/build.gradle
+++ b/test-suite/build.gradle
@@ -118,4 +118,3 @@ test {
     // Prevent scanning classes with missing classes
     exclude '**/classnotfound/**'
 }
-
