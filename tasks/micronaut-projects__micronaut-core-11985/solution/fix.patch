diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
index 32afc4daac..75fb5813ff 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
@@ -41,6 +41,7 @@ import io.micronaut.http.MutableHttpRequest;
 import io.micronaut.http.PushCapableHttpRequest;
 import io.micronaut.http.ServerHttpRequest;
 import io.micronaut.http.body.ByteBody;
+import io.micronaut.http.body.ByteBodyFactory;
 import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.body.InternalByteBody;
 import io.micronaut.http.body.stream.AvailableByteArrayBody;
@@ -50,6 +51,7 @@ import io.micronaut.http.netty.NettyHttpHeaders;
 import io.micronaut.http.netty.NettyHttpParameters;
 import io.micronaut.http.netty.NettyHttpRequestBuilder;
 import io.micronaut.http.netty.body.NettyByteBodyFactory;
+import io.micronaut.http.netty.body.NettyByteBodyFactory;
 import io.micronaut.http.netty.channel.ChannelPipelineCustomizer;
 import io.micronaut.http.netty.cookies.NettyCookie;
 import io.micronaut.http.netty.cookies.NettyCookies;
@@ -208,6 +210,11 @@ public final class NettyHttpRequest<T> extends AbstractNettyHttpRequest<T> imple
         return body;
     }
 
+    @Override
+    public @NonNull ByteBodyFactory byteBodyFactory() {
+        return new NettyByteBodyFactory(channelHandlerContext.channel());
+    }
+
     public void setLegacyBody(Object legacyBody) {
         this.legacyBody = legacyBody;
     }
diff --git a/http-server/src/main/java/io/micronaut/http/server/ResponseLifecycle.java b/http-server/src/main/java/io/micronaut/http/server/ResponseLifecycle.java
index a9a3fac572..a586e8ec12 100644
--- a/http-server/src/main/java/io/micronaut/http/server/ResponseLifecycle.java
+++ b/http-server/src/main/java/io/micronaut/http/server/ResponseLifecycle.java
@@ -107,16 +107,14 @@ public abstract class ResponseLifecycle {
         try {
             return encodeHttpResponse(
                 httpRequest,
-                response,
-                response.body()
+                response
             );
         } catch (Throwable e) {
             try {
                 response = routeExecutor.createDefaultErrorResponse(httpRequest, e);
                 return encodeHttpResponse(
                     httpRequest,
-                    response,
-                    response.body()
+                    response
                 );
             } catch (Throwable f) {
                 f.addSuppressed(e);
@@ -128,8 +126,8 @@ public abstract class ResponseLifecycle {
     @SuppressWarnings("unchecked")
     private ExecutionFlow<? extends ByteBodyHttpResponse<?>> encodeHttpResponse(
         HttpRequest<?> nettyRequest,
-        HttpResponse<?> httpResponse,
-        Object body) {
+        HttpResponse<?> httpResponse) {
+        Object body = httpResponse.body();
         MutableHttpResponse<?> response = httpResponse.toMutableResponse();
         if (nettyRequest.getMethod() != HttpMethod.HEAD && body != null) {
             Object routeInfoO = RouteAttributes.getRouteInfo(response).orElse(null);
@@ -291,8 +289,7 @@ public abstract class ResponseLifecycle {
         }
         return encodeHttpResponse(
             request,
-            errorResponse,
-            errorResponse.body()
+            errorResponse
         );
     }
 
diff --git a/http/src/main/java/io/micronaut/http/ServerHttpRequest.java b/http/src/main/java/io/micronaut/http/ServerHttpRequest.java
index febb35c336..9ec3ff26f5 100644
--- a/http/src/main/java/io/micronaut/http/ServerHttpRequest.java
+++ b/http/src/main/java/io/micronaut/http/ServerHttpRequest.java
@@ -17,7 +17,9 @@ package io.micronaut.http;
 
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.io.buffer.ByteArrayBufferFactory;
 import io.micronaut.http.body.ByteBody;
+import io.micronaut.http.body.ByteBodyFactory;
 
 /**
  * This interface extends {@link HttpRequest} with methods that are specific to a request received
@@ -37,4 +39,15 @@ public interface ServerHttpRequest<B> extends HttpRequest<B> {
      */
     @NonNull
     ByteBody byteBody();
+
+    /**
+     * Get a {@link ByteBodyFactory} that can be used to construct an efficient response to this
+     * request.
+     *
+     * @return The body factory
+     */
+    @NonNull
+    default ByteBodyFactory byteBodyFactory() {
+        return ByteBodyFactory.createDefault(ByteArrayBufferFactory.INSTANCE);
+    }
 }
diff --git a/http/src/main/java/io/micronaut/http/bind/DefaultRequestBinderRegistry.java b/http/src/main/java/io/micronaut/http/bind/DefaultRequestBinderRegistry.java
index 239bd3894c..59ce3ba4b1 100644
--- a/http/src/main/java/io/micronaut/http/bind/DefaultRequestBinderRegistry.java
+++ b/http/src/main/java/io/micronaut/http/bind/DefaultRequestBinderRegistry.java
@@ -30,11 +30,12 @@ import io.micronaut.http.HttpParameters;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpRequestWrapper;
 import io.micronaut.http.PushCapableHttpRequest;
+import io.micronaut.http.ServerHttpRequest;
 import io.micronaut.http.annotation.Body;
 import io.micronaut.http.bind.binders.AnnotatedRequestArgumentBinder;
 import io.micronaut.http.bind.binders.ContinuationArgumentBinder;
-import io.micronaut.http.bind.binders.CookieObjectArgumentBinder;
 import io.micronaut.http.bind.binders.CookieAnnotationBinder;
+import io.micronaut.http.bind.binders.CookieObjectArgumentBinder;
 import io.micronaut.http.bind.binders.DefaultBodyAnnotationBinder;
 import io.micronaut.http.bind.binders.DefaultUnmatchedRequestArgumentBinder;
 import io.micronaut.http.bind.binders.HeaderAnnotationBinder;
@@ -46,6 +47,8 @@ import io.micronaut.http.bind.binders.RequestArgumentBinder;
 import io.micronaut.http.bind.binders.RequestAttributeAnnotationBinder;
 import io.micronaut.http.bind.binders.RequestBeanAnnotationBinder;
 import io.micronaut.http.bind.binders.TypedRequestArgumentBinder;
+import io.micronaut.http.body.ByteBody;
+import io.micronaut.http.body.ByteBodyFactory;
 import io.micronaut.http.cookie.Cookie;
 import io.micronaut.http.cookie.Cookies;
 import jakarta.inject.Inject;
@@ -115,10 +118,17 @@ public class DefaultRequestBinderRegistry implements RequestBinderRegistry {
         registerDefaultAnnotationBinders(byAnnotation);
 
         byType.put(Argument.of(HttpHeaders.class).typeHashCode(), (RequestArgumentBinder<HttpHeaders>) (argument, source) -> () -> Optional.of(source.getHeaders()));
-        byType.put(Argument.of(HttpRequest.class).typeHashCode(), (RequestArgumentBinder<HttpRequest<?>>) (argument, source) -> convertBodyIfNecessary(bodyAnnotationBinder, argument, source, false));
+        byType.put(Argument.of(HttpRequest.class).typeHashCode(), (RequestArgumentBinder<HttpRequest<?>>) (argument, source) -> convertBodyIfNecessary(bodyAnnotationBinder, argument, source, RequestType.STANDARD));
+        byType.put(Argument.of(ServerHttpRequest.class).typeHashCode(), (RequestArgumentBinder<ServerHttpRequest<?>>) (argument, source) -> {
+            if (source instanceof ServerHttpRequest<?>) {
+                return convertBodyIfNecessary(bodyAnnotationBinder, argument, source, RequestType.SERVER);
+            } else {
+                return ArgumentBinder.BindingResult.unsatisfied();
+            }
+        });
         byType.put(Argument.of(PushCapableHttpRequest.class).typeHashCode(), (RequestArgumentBinder<PushCapableHttpRequest<?>>) (argument, source) -> {
             if (source instanceof PushCapableHttpRequest<?>) {
-                return convertBodyIfNecessary(bodyAnnotationBinder, argument, source, true);
+                return convertBodyIfNecessary(bodyAnnotationBinder, argument, source, RequestType.PUSH_CAPABLE);
             } else {
                 return ArgumentBinder.BindingResult.unsatisfied();
             }
@@ -260,7 +270,7 @@ public class DefaultRequestBinderRegistry implements RequestBinderRegistry {
         DefaultBodyAnnotationBinder<Object> bodyAnnotationBinder,
         ArgumentConversionContext<? extends HttpRequest<?>> context,
         HttpRequest<?> source,
-        boolean pushCapable
+        RequestType type
     ) {
         if (source.getMethod().permitsRequestBody()) {
             Optional<Argument<?>> typeVariable = context.getFirstTypeVariable()
@@ -285,21 +295,26 @@ public class DefaultRequestBinderRegistry implements RequestBinderRegistry {
                     @Override
                     public Optional<HttpRequest<?>> getValue() {
                         Optional<Object> body = bodyBound.getValue();
-                        if (pushCapable) {
-                            return Optional.of(new PushCapableRequestWrapper<Object>((HttpRequest<Object>) source, (PushCapableHttpRequest<?>) source) {
+                        return Optional.of(switch (type) {
+                            case STANDARD -> new HttpRequestWrapper<>((HttpRequest<Object>) source) {
                                 @Override
                                 public Optional<Object> getBody() {
                                     return body;
                                 }
-                            });
-                        } else {
-                            return Optional.of(new HttpRequestWrapper<Object>((HttpRequest<Object>) source) {
+                            };
+                            case PUSH_CAPABLE -> new PushCapableRequestWrapper<>((HttpRequest<Object>) source, (PushCapableHttpRequest<?>) source) {
                                 @Override
                                 public Optional<Object> getBody() {
                                     return body;
                                 }
-                            });
-                        }
+                            };
+                            case SERVER -> new ServerRequestWrapper<>((HttpRequest<Object>) source, (ServerRequestWrapper<?>) source) {
+                                @Override
+                                public Optional<Object> getBody() {
+                                    return body;
+                                }
+                            };
+                        });
                     }
                 };
             }
@@ -367,4 +382,29 @@ public class DefaultRequestBinderRegistry implements RequestBinderRegistry {
             return this;
         }
     }
+
+    private static class ServerRequestWrapper<B> extends HttpRequestWrapper<B> implements ServerHttpRequest<B> {
+        private final ServerHttpRequest<?> server;
+
+        public ServerRequestWrapper(HttpRequest<B> primary, ServerHttpRequest<?> server) {
+            super(primary);
+            this.server = server;
+        }
+
+        @Override
+        public @NonNull ByteBody byteBody() {
+            return server.byteBody();
+        }
+
+        @Override
+        public @NonNull ByteBodyFactory byteBodyFactory() {
+            return server.byteBodyFactory();
+        }
+    }
+
+    private enum RequestType {
+        STANDARD,
+        PUSH_CAPABLE,
+        SERVER;
+    }
 }
diff --git a/http/src/main/java/io/micronaut/http/body/ByteBodyWriter.java b/http/src/main/java/io/micronaut/http/body/ByteBodyWriter.java
new file mode 100644
index 0000000000..725fcefdd3
--- /dev/null
+++ b/http/src/main/java/io/micronaut/http/body/ByteBodyWriter.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2017-2025 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.body;
+
+import io.micronaut.context.annotation.BootstrapContextCompatible;
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.type.Argument;
+import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.HttpRequest;
+import io.micronaut.http.HttpResponse;
+import io.micronaut.http.MediaType;
+import io.micronaut.http.codec.CodecException;
+import jakarta.inject.Singleton;
+
+import java.io.OutputStream;
+
+/**
+ * The body writer for ByteBody.
+ *
+ * @author Jonas Konrad
+ * @since 4.10.0
+ */
+@Singleton
+@BootstrapContextCompatible
+@Internal
+final class ByteBodyWriter implements TypedMessageBodyWriter<ByteBody>, ResponseBodyWriter<ByteBody> {
+    @Override
+    public @NonNull CloseableByteBody writePiece(@NonNull ByteBodyFactory bodyFactory, @NonNull HttpRequest<?> request, @NonNull HttpResponse<?> response, @NonNull Argument<ByteBody> type, @NonNull MediaType mediaType, ByteBody object) throws CodecException {
+        return object.move();
+    }
+
+    @Override
+    public @NonNull Argument<ByteBody> getType() {
+        return Argument.of(ByteBody.class);
+    }
+
+    @Override
+    public void writeTo(@NonNull Argument<ByteBody> type, @NonNull MediaType mediaType, ByteBody object, @NonNull MutableHeaders outgoingHeaders, @NonNull OutputStream outputStream) throws CodecException {
+        throw new UnsupportedOperationException("Cannot write ByteBody to OutputStream");
+    }
+}
diff --git a/http/src/main/java/io/micronaut/http/body/ContextlessMessageBodyHandlerRegistry.java b/http/src/main/java/io/micronaut/http/body/ContextlessMessageBodyHandlerRegistry.java
index 219828a2f0..e3d279b48c 100644
--- a/http/src/main/java/io/micronaut/http/body/ContextlessMessageBodyHandlerRegistry.java
+++ b/http/src/main/java/io/micronaut/http/body/ContextlessMessageBodyHandlerRegistry.java
@@ -56,6 +56,7 @@ public final class ContextlessMessageBodyHandlerRegistry extends AbstractMessage
         this.typedMessageBodyWriters = new ArrayList<>(3 + otherRawHandlers.length);
         this.typedMessageBodyWriters.add(new CharSequenceBodyWriter(applicationConfiguration));
         this.typedMessageBodyWriters.add(new ByteArrayBodyHandler());
+        this.typedMessageBodyWriters.add(new ByteBodyWriter());
         this.typedMessageBodyWriters.add(new ByteBufferBodyHandler(byteBufferFactory));
         for (TypedMessageBodyHandler<?> otherRawHandler : otherRawHandlers) {
             this.typedMessageBodyReaders.add(otherRawHandler);
diff --git a/http/src/main/java/io/micronaut/http/body/stream/BaseSharedBuffer.java b/http/src/main/java/io/micronaut/http/body/stream/BaseSharedBuffer.java
index 268899495c..127e5fae2a 100644
--- a/http/src/main/java/io/micronaut/http/body/stream/BaseSharedBuffer.java
+++ b/http/src/main/java/io/micronaut/http/body/stream/BaseSharedBuffer.java
@@ -367,7 +367,7 @@ public abstract class BaseSharedBuffer implements BufferConsumer {
                 }
             }
             if (reserved > 0 || fullSubscribers != null) {
-                if (newLength > limits.maxBufferSize()|| bufferLimitsExceeded != null) {
+                if (newLength > limits.maxBufferSize() || bufferLimitsExceeded != null) {
                     // new subscribers will recognize that the limit has been exceeded. Streaming
                     // subscribers can proceed normally. Need to notify buffering subscribers
                     discardBuffer();
