diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index 7321ef693e..36eb066722 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -787,7 +787,7 @@ public class DefaultHttpClient implements
     }
 
     private static <T> Mono<T> toMono(ExecutionFlow<T> flow, PropagatedContext context) {
-        return Mono.from(ReactivePropagation.propagate(context, ReactiveExecutionFlow.toPublisher(() -> flow)));
+        return Mono.from(ReactivePropagation.propagate(context, ReactiveExecutionFlow.toPublisher(flow)));
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyPublisherBodyBinder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyPublisherBodyBinder.java
index 0e7c3a2d17..f973eb1844 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyPublisherBodyBinder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyPublisherBodyBinder.java
@@ -97,7 +97,7 @@ final class NettyPublisherBodyBinder implements NonBlockingBodyArgumentBinder<Pu
                     }
                     return value.orElseThrow(() -> NettyPublisherBodyBinder.extractError(null, context));
                 });
-            Publisher<Object> future = ReactiveExecutionFlow.toPublisher(() -> flow);
+            Publisher<Object> future = ReactiveExecutionFlow.toPublisher(flow);
             return () -> Optional.of(future);
         }
         return BindingResult.empty();
diff --git a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
index 4b05645242..64232d2068 100644
--- a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
+++ b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
@@ -457,14 +457,14 @@ record MethodFilter<T>(FilterOrder order,
                 if (returnValue == null && !nullable) {
                     return next.handle(context, null, continuation);
                 }
-                Publisher<?> publisher = ReactivePropagation.propagate(
-                    context.propagatedContext(),
-                    Publishers.convertToPublisher(conversionService, returnValue)
-                );
+                Publisher<Object> converted = Publishers.convertToPublisher(conversionService, returnValue);
                 if (continuation instanceof ResultAwareContinuation resultAwareContinuation) {
-                    return resultAwareContinuation.processResult(publisher);
+                    return resultAwareContinuation.processResult(ReactivePropagation.propagate(
+                        context.propagatedContext(),
+                        converted
+                    ));
                 }
-                return ReactiveExecutionFlow.fromPublisher(publisher).flatMap(v -> {
+                return ReactiveExecutionFlow.fromPublisherEager(converted, context.propagatedContext()).flatMap(v -> {
                     try {
                         return next.handle(context, v, continuation);
                     } catch (Throwable e) {
diff --git a/http/src/main/java/io/micronaut/http/reactive/execution/FlowAsMono.java b/http/src/main/java/io/micronaut/http/reactive/execution/FlowAsMono.java
new file mode 100644
index 0000000000..2c8c1f38ba
--- /dev/null
+++ b/http/src/main/java/io/micronaut/http/reactive/execution/FlowAsMono.java
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.reactive.execution;
+
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.execution.ExecutionFlow;
+import io.micronaut.core.execution.ImperativeExecutionFlow;
+import org.reactivestreams.Subscription;
+import reactor.core.CoreSubscriber;
+import reactor.core.Fuseable;
+import reactor.core.publisher.Mono;
+import reactor.core.publisher.Operators;
+
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+/**
+ * {@link Mono} implementation that is  based on an {@link ExecutionFlow}.
+ *
+ * @param <T> The value type
+ * @author Jonas Konrad
+ * @since 4.8.0
+ */
+@Internal
+final class FlowAsMono<T> extends Mono<T> implements Fuseable {
+    final ExecutionFlow<? extends T> flow;
+
+    FlowAsMono(ExecutionFlow<? extends T> flow) {
+        this.flow = flow;
+    }
+
+    @Override
+    public void subscribe(CoreSubscriber<? super T> actual) {
+        ImperativeExecutionFlow<? extends T> complete = flow.tryComplete();
+        if (complete != null) {
+            // these subscriptions support SYNC fusion
+            if (complete.getError() != null) {
+                Operators.error(actual, complete.getError());
+            } else if (complete.getValue() != null) {
+                actual.onSubscribe(Operators.scalarSubscription(actual, complete.getValue()));
+            } else {
+                actual.onSubscribe(Operators.emptySubscription());
+            }
+        } else {
+            // fallback to a normal subscription
+            new SubscriptionImpl(actual).callOnSubscribe();
+        }
+    }
+
+    private final class SubscriptionImpl implements QueueSubscription<T> {
+        @SuppressWarnings("rawtypes")
+        private static final AtomicIntegerFieldUpdater<FlowAsMono.SubscriptionImpl> STATE = AtomicIntegerFieldUpdater.newUpdater(FlowAsMono.SubscriptionImpl.class, "state");
+        private static final int STATE_WAITING = 0;
+        private static final int STATE_SUBSCRIBING = 1;
+        private static final int STATE_DONE = 2;
+
+        private final CoreSubscriber<? super T> actual;
+
+        /**
+         * State flag to avoid reentrancy. We only do two distinct operations on the subscriber:
+         * {@link CoreSubscriber#onSubscribe} and the completion operations (
+         * {@link CoreSubscriber#onNext} and then {@link CoreSubscriber#onComplete()}). By the
+         * reactive spec these must not happen in a reentrant fashion, i.e. we can't complete
+         * inside the {@link CoreSubscriber#onSubscribe} call. This field acts like a simple lock
+         * to avoid that.
+         * <p>Just before {@link CoreSubscriber#onSubscribe}, the state is set to
+         * {@link #STATE_SUBSCRIBING}. If the subscriber then calls {@link Subscription#request} in
+         * that method and the request can immediately be fulfilled, the completion handler will
+         * notice that the state is {@link #STATE_SUBSCRIBING}, switch it to {@link #STATE_DONE}
+         * and hold back the result for now. Once {@link CoreSubscriber#onSubscribe} finishes,
+         * {@link #callOnSubscribe()} will notice that the field is {@link #STATE_DONE} and forward
+         * the actual result.
+         * <p>If the request is <i>not</i> immediately fulfilled, {@link #callOnSubscribe()} will
+         * set the state to {@link #STATE_WAITING}. Once the flow completes, the completion handler
+         * will see this state and forward the result immediately instead of holding it back.
+         */
+        private volatile int state;
+
+        private boolean requested;
+
+        private T result;
+        private Throwable error;
+
+        SubscriptionImpl(CoreSubscriber<? super T> actual) {
+            this.actual = actual;
+        }
+
+        void callOnSubscribe() {
+            state = STATE_SUBSCRIBING;
+            actual.onSubscribe(this);
+            if (STATE.getAndSet(this, STATE_WAITING) == STATE_DONE) {
+                // onComplete was already called but result held back to avoid reentrancy, need to
+                // forward its result
+                forward(result, error);
+            }
+        }
+
+        @Override
+        public void request(long n) {
+            if (!requested) {
+                requested = true;
+                flow.onComplete((v, e) -> {
+                    result = v;
+                    error = e;
+                    if (STATE.getAndSet(this, STATE_DONE) == STATE_WAITING) {
+                        // onSubscribe is already done so we can forward immediately
+                        forward(v, e);
+                    }
+                });
+            }
+        }
+
+        private void forward(T v, Throwable e) {
+            if (v != null) {
+                actual.onNext(v);
+            }
+            if (error == null) {
+                actual.onComplete();
+            } else {
+                actual.onError(e);
+            }
+        }
+
+        @Override
+        public void cancel() {
+            requested = true;
+            flow.cancel();
+        }
+
+        @Override
+        public int requestFusion(int requestedMode) {
+            // while we implement QueueSubscription, we don't actually support it. only the
+            // short-circuit flows for ImperativeExecutionFlow above do. there's little value in
+            // supporting it here
+            return 0;
+        }
+
+        @Override
+        public T poll() {
+            throw noFusion();
+        }
+
+        @Override
+        public int size() {
+            throw noFusion();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            throw noFusion();
+        }
+
+        @Override
+        public void clear() {
+            throw noFusion();
+        }
+
+        private static UnsupportedOperationException noFusion() {
+            return new UnsupportedOperationException("fusion not supported");
+        }
+    }
+}
diff --git a/http/src/main/java/io/micronaut/http/reactive/execution/ReactiveExecutionFlow.java b/http/src/main/java/io/micronaut/http/reactive/execution/ReactiveExecutionFlow.java
index 9201140694..e3bdadaea0 100644
--- a/http/src/main/java/io/micronaut/http/reactive/execution/ReactiveExecutionFlow.java
+++ b/http/src/main/java/io/micronaut/http/reactive/execution/ReactiveExecutionFlow.java
@@ -17,7 +17,9 @@ package io.micronaut.http.reactive.execution;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.async.annotation.SingleResult;
 import io.micronaut.core.execution.ExecutionFlow;
+import io.micronaut.core.propagation.PropagatedContext;
 import org.reactivestreams.Publisher;
 import reactor.core.publisher.Mono;
 import reactor.core.scheduler.Scheduler;
@@ -49,6 +51,22 @@ public sealed interface ReactiveExecutionFlow<T> extends ExecutionFlow<T> permit
         return (ReactiveExecutionFlow<K>) new ReactorExecutionFlowImpl(publisher);
     }
 
+    /**
+     * Creates a new reactive flow from a publisher. This method eagerly subscribes to the
+     * publisher, and may return an immediate {@link ExecutionFlow} if possible.
+     *
+     * @param publisher         The publisher
+     * @param propagatedContext A context to propagate in the reactor context and as a thread-local
+     *                          in the subscribe operation.
+     * @param <K>       The flow value type
+     * @return a new flow
+     * @since 4.8.0
+     */
+    @NonNull
+    static <K> ExecutionFlow<K> fromPublisherEager(@NonNull Publisher<K> publisher, @NonNull PropagatedContext propagatedContext) {
+        return ReactorExecutionFlowImpl.defuse(publisher, propagatedContext);
+    }
+
     /**
      * Create a new reactive flow by invoking a supplier asynchronously.
      *
@@ -88,7 +106,30 @@ public sealed interface ReactiveExecutionFlow<T> extends ExecutionFlow<T> permit
     @NonNull
     Publisher<T> toPublisher();
 
-    static <K> Publisher<K> toPublisher(Supplier<ExecutionFlow<K>> flowSupplier) {
+    /**
+     * Convert the given flow to a reactive publisher. The supplier is called for every
+     * subscription to the publisher.
+     *
+     * @param flowSupplier The flow supplier
+     * @param <K>          The element type
+     * @return The publisher
+     */
+    @NonNull
+    @SingleResult
+    static <K> Publisher<K> toPublisher(@NonNull Supplier<@NonNull ExecutionFlow<K>> flowSupplier) {
         return (Publisher<K>) ReactorExecutionFlowImpl.toMono(flowSupplier);
     }
+
+    /**
+     * Convert the given flow to a reactive publisher.
+     *
+     * @param flow The flow
+     * @param <K>  The element type
+     * @return The publisher
+     */
+    @NonNull
+    @SingleResult
+    static <K> Publisher<K> toPublisher(@NonNull ExecutionFlow<K> flow) {
+        return (Publisher<K>) ReactorExecutionFlowImpl.toMono(flow);
+    }
 }
diff --git a/http/src/main/java/io/micronaut/http/reactive/execution/ReactorExecutionFlowImpl.java b/http/src/main/java/io/micronaut/http/reactive/execution/ReactorExecutionFlowImpl.java
index a63c7b7d12..750a538c0f 100644
--- a/http/src/main/java/io/micronaut/http/reactive/execution/ReactorExecutionFlowImpl.java
+++ b/http/src/main/java/io/micronaut/http/reactive/execution/ReactorExecutionFlowImpl.java
@@ -18,22 +18,25 @@ package io.micronaut.http.reactive.execution;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.async.propagation.ReactorPropagation;
+import io.micronaut.core.execution.DelayedExecutionFlow;
 import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.core.execution.ImperativeExecutionFlow;
+import io.micronaut.core.propagation.PropagatedContext;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
-import reactor.core.publisher.Sinks;
+import reactor.core.publisher.Operators;
 import reactor.util.context.Context;
-import reactor.util.context.ContextView;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.function.Supplier;
@@ -58,6 +61,108 @@ final class ReactorExecutionFlowImpl implements ReactiveExecutionFlow<Object> {
         this.value = (Mono<Object>) value;
     }
 
+    public static <T> ExecutionFlow<T> defuse(Publisher<T> publisher, PropagatedContext propagatedContext) {
+        if (publisher instanceof Fuseable.ScalarCallable<?> sc) {
+            // Mono.just, Mono.error. No need for context propagation
+            try {
+                //noinspection unchecked
+                return ExecutionFlow.just((T) sc.call());
+            } catch (Throwable t) {
+                return ExecutionFlow.error(t);
+            }
+        } else if (publisher instanceof FlowAsMono<T> flowAsMono) {
+            // unwrap directly
+            //noinspection unchecked
+            return (ExecutionFlow<T>) flowAsMono.flow;
+        }
+
+        // special subscriber that (a) contains the propagated context and (b) can return an
+        // imperative flow if the result is provided immediately in subscribe()
+        var s = new CoreSubscriber<T>() {
+            final AtomicReference<ExecutionFlow<T>> flow = new AtomicReference<>();
+
+            boolean complete = false;
+
+            @Override
+            public Context currentContext() {
+                return ReactorPropagation.addPropagatedContext(Context.empty(), propagatedContext);
+            }
+
+            @Override
+            public void onSubscribe(Subscription s) {
+                if (s instanceof Fuseable.QueueSubscription<?> qs && qs.requestFusion(Fuseable.SYNC) == Fuseable.SYNC) {
+                    // we can avoid the subscribe / WIP dance. This is for example Mono.just(…).map(…)
+                    T result;
+                    try {
+                        //noinspection unchecked
+                        result = (T) qs.poll();
+                    } catch (Throwable t) {
+                        completeError(t);
+                        return;
+                    }
+                    complete(result);
+                    return;
+                }
+                // fallback, normal reactive subscription
+                s.request(Long.MAX_VALUE);
+            }
+
+            private void complete(T result) {
+                if (!flow.compareAndSet(null, ExecutionFlow.just(result))) {
+                    ((DelayedExecutionFlow<T>) flow.get()).complete(result);
+                }
+                complete = true;
+            }
+
+            private void completeError(Throwable t) {
+                if (!flow.compareAndSet(null, ExecutionFlow.error(t))) {
+                    ((DelayedExecutionFlow<?>) flow.get()).completeExceptionally(t);
+                }
+                complete = true;
+            }
+
+            @Override
+            public void onNext(T t) {
+                if (complete) {
+                    Operators.onNextDropped(t, Context.empty());
+                    return;
+                }
+                complete(t);
+            }
+
+            @Override
+            public void onError(Throwable t) {
+                if (complete) {
+                    Operators.onErrorDropped(t, Context.empty());
+                    return;
+                }
+                completeError(t);
+            }
+
+            @Override
+            public void onComplete() {
+                if (!complete) {
+                    complete(null);
+                }
+            }
+        };
+        try (PropagatedContext.Scope ignored = propagatedContext.propagate()) {
+            publisher.subscribe(s);
+        }
+        ExecutionFlow<T> immediate = s.flow.getPlain();
+        if (immediate != null) {
+            return immediate;
+        } else {
+            DelayedExecutionFlow<T> flow = DelayedExecutionFlow.create();
+            if (s.flow.compareAndSet(null, flow)) {
+                return flow;
+            } else {
+                // data race
+                return s.flow.getPlain();
+            }
+        }
+    }
+
     @Override
     public <R> ExecutionFlow<R> flatMap(Function<? super Object, ? extends ExecutionFlow<? extends R>> transformer) {
         value = value.flatMap(value -> toMono(transformer.apply(value)));
@@ -130,14 +235,6 @@ final class ReactorExecutionFlowImpl implements ReactiveExecutionFlow<Object> {
             Subscription subscription;
             Object value;
 
-            @Override
-            public Context currentContext() {
-                if (fn instanceof ReactiveConsumer reactiveConsumer) {
-                    return Context.of(reactiveConsumer.contextView);
-                }
-                return CoreSubscriber.super.currentContext();
-            }
-
             @Override
             public void onSubscribe(Subscription s) {
                 this.subscription = s;
@@ -251,22 +348,7 @@ final class ReactorExecutionFlowImpl implements ReactiveExecutionFlow<Object> {
             }
             return m;
         } else {
-            return Mono.deferContextual(contextView -> {
-                Sinks.One<Object> sink = Sinks.one();
-                ReactiveConsumer reactiveConsumer = new ReactiveConsumer(contextView) {
-
-                    @Override
-                    public void accept(Object o, Throwable throwable) {
-                        if (throwable != null) {
-                            sink.tryEmitError(throwable);
-                        } else {
-                            sink.tryEmitValue(o);
-                        }
-                    }
-                };
-                next.onComplete(reactiveConsumer);
-                return sink.asMono().doOnCancel(next::cancel);
-            });
+            return new FlowAsMono<>(next);
         }
     }
 
@@ -283,13 +365,4 @@ final class ReactorExecutionFlowImpl implements ReactiveExecutionFlow<Object> {
     public CompletableFuture<Object> toCompletableFuture() {
         return value.toFuture();
     }
-
-    private abstract static class ReactiveConsumer implements BiConsumer<Object, Throwable> {
-
-        private final ContextView contextView;
-
-        private ReactiveConsumer(ContextView contextView) {
-            this.contextView = contextView;
-        }
-    }
 }
