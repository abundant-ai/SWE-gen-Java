diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index 36eb066722..7321ef693e 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -787,7 +787,7 @@ public class DefaultHttpClient implements
     }
 
     private static <T> Mono<T> toMono(ExecutionFlow<T> flow, PropagatedContext context) {
-        return Mono.from(ReactivePropagation.propagate(context, ReactiveExecutionFlow.toPublisher(flow)));
+        return Mono.from(ReactivePropagation.propagate(context, ReactiveExecutionFlow.toPublisher(() -> flow)));
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyPublisherBodyBinder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyPublisherBodyBinder.java
index f973eb1844..0e7c3a2d17 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyPublisherBodyBinder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyPublisherBodyBinder.java
@@ -97,7 +97,7 @@ final class NettyPublisherBodyBinder implements NonBlockingBodyArgumentBinder<Pu
                     }
                     return value.orElseThrow(() -> NettyPublisherBodyBinder.extractError(null, context));
                 });
-            Publisher<Object> future = ReactiveExecutionFlow.toPublisher(flow);
+            Publisher<Object> future = ReactiveExecutionFlow.toPublisher(() -> flow);
             return () -> Optional.of(future);
         }
         return BindingResult.empty();
diff --git a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
index 64232d2068..4b05645242 100644
--- a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
+++ b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
@@ -457,14 +457,14 @@ record MethodFilter<T>(FilterOrder order,
                 if (returnValue == null && !nullable) {
                     return next.handle(context, null, continuation);
                 }
-                Publisher<Object> converted = Publishers.convertToPublisher(conversionService, returnValue);
+                Publisher<?> publisher = ReactivePropagation.propagate(
+                    context.propagatedContext(),
+                    Publishers.convertToPublisher(conversionService, returnValue)
+                );
                 if (continuation instanceof ResultAwareContinuation resultAwareContinuation) {
-                    return resultAwareContinuation.processResult(ReactivePropagation.propagate(
-                        context.propagatedContext(),
-                        converted
-                    ));
+                    return resultAwareContinuation.processResult(publisher);
                 }
-                return ReactiveExecutionFlow.fromPublisherEager(converted, context.propagatedContext()).flatMap(v -> {
+                return ReactiveExecutionFlow.fromPublisher(publisher).flatMap(v -> {
                     try {
                         return next.handle(context, v, continuation);
                     } catch (Throwable e) {
diff --git a/http/src/main/java/io/micronaut/http/reactive/execution/FlowAsMono.java b/http/src/main/java/io/micronaut/http/reactive/execution/FlowAsMono.java
deleted file mode 100644
index 2c8c1f38ba..0000000000
--- a/http/src/main/java/io/micronaut/http/reactive/execution/FlowAsMono.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.reactive.execution;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.execution.ExecutionFlow;
-import io.micronaut.core.execution.ImperativeExecutionFlow;
-import org.reactivestreams.Subscription;
-import reactor.core.CoreSubscriber;
-import reactor.core.Fuseable;
-import reactor.core.publisher.Mono;
-import reactor.core.publisher.Operators;
-
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-
-/**
- * {@link Mono} implementation that is  based on an {@link ExecutionFlow}.
- *
- * @param <T> The value type
- * @author Jonas Konrad
- * @since 4.8.0
- */
-@Internal
-final class FlowAsMono<T> extends Mono<T> implements Fuseable {
-    final ExecutionFlow<? extends T> flow;
-
-    FlowAsMono(ExecutionFlow<? extends T> flow) {
-        this.flow = flow;
-    }
-
-    @Override
-    public void subscribe(CoreSubscriber<? super T> actual) {
-        ImperativeExecutionFlow<? extends T> complete = flow.tryComplete();
-        if (complete != null) {
-            // these subscriptions support SYNC fusion
-            if (complete.getError() != null) {
-                Operators.error(actual, complete.getError());
-            } else if (complete.getValue() != null) {
-                actual.onSubscribe(Operators.scalarSubscription(actual, complete.getValue()));
-            } else {
-                actual.onSubscribe(Operators.emptySubscription());
-            }
-        } else {
-            // fallback to a normal subscription
-            new SubscriptionImpl(actual).callOnSubscribe();
-        }
-    }
-
-    private final class SubscriptionImpl implements QueueSubscription<T> {
-        @SuppressWarnings("rawtypes")
-        private static final AtomicIntegerFieldUpdater<FlowAsMono.SubscriptionImpl> STATE = AtomicIntegerFieldUpdater.newUpdater(FlowAsMono.SubscriptionImpl.class, "state");
-        private static final int STATE_WAITING = 0;
-        private static final int STATE_SUBSCRIBING = 1;
-        private static final int STATE_DONE = 2;
-
-        private final CoreSubscriber<? super T> actual;
-
-        /**
-         * State flag to avoid reentrancy. We only do two distinct operations on the subscriber:
-         * {@link CoreSubscriber#onSubscribe} and the completion operations (
-         * {@link CoreSubscriber#onNext} and then {@link CoreSubscriber#onComplete()}). By the
-         * reactive spec these must not happen in a reentrant fashion, i.e. we can't complete
-         * inside the {@link CoreSubscriber#onSubscribe} call. This field acts like a simple lock
-         * to avoid that.
-         * <p>Just before {@link CoreSubscriber#onSubscribe}, the state is set to
-         * {@link #STATE_SUBSCRIBING}. If the subscriber then calls {@link Subscription#request} in
-         * that method and the request can immediately be fulfilled, the completion handler will
-         * notice that the state is {@link #STATE_SUBSCRIBING}, switch it to {@link #STATE_DONE}
-         * and hold back the result for now. Once {@link CoreSubscriber#onSubscribe} finishes,
-         * {@link #callOnSubscribe()} will notice that the field is {@link #STATE_DONE} and forward
-         * the actual result.
-         * <p>If the request is <i>not</i> immediately fulfilled, {@link #callOnSubscribe()} will
-         * set the state to {@link #STATE_WAITING}. Once the flow completes, the completion handler
-         * will see this state and forward the result immediately instead of holding it back.
-         */
-        private volatile int state;
-
-        private boolean requested;
-
-        private T result;
-        private Throwable error;
-
-        SubscriptionImpl(CoreSubscriber<? super T> actual) {
-            this.actual = actual;
-        }
-
-        void callOnSubscribe() {
-            state = STATE_SUBSCRIBING;
-            actual.onSubscribe(this);
-            if (STATE.getAndSet(this, STATE_WAITING) == STATE_DONE) {
-                // onComplete was already called but result held back to avoid reentrancy, need to
-                // forward its result
-                forward(result, error);
-            }
-        }
-
-        @Override
-        public void request(long n) {
-            if (!requested) {
-                requested = true;
-                flow.onComplete((v, e) -> {
-                    result = v;
-                    error = e;
-                    if (STATE.getAndSet(this, STATE_DONE) == STATE_WAITING) {
-                        // onSubscribe is already done so we can forward immediately
-                        forward(v, e);
-                    }
-                });
-            }
-        }
-
-        private void forward(T v, Throwable e) {
-            if (v != null) {
-                actual.onNext(v);
-            }
-            if (error == null) {
-                actual.onComplete();
-            } else {
-                actual.onError(e);
-            }
-        }
-
-        @Override
-        public void cancel() {
-            requested = true;
-            flow.cancel();
-        }
-
-        @Override
-        public int requestFusion(int requestedMode) {
-            // while we implement QueueSubscription, we don't actually support it. only the
-            // short-circuit flows for ImperativeExecutionFlow above do. there's little value in
-            // supporting it here
-            return 0;
-        }
-
-        @Override
-        public T poll() {
-            throw noFusion();
-        }
-
-        @Override
-        public int size() {
-            throw noFusion();
-        }
-
-        @Override
-        public boolean isEmpty() {
-            throw noFusion();
-        }
-
-        @Override
-        public void clear() {
-            throw noFusion();
-        }
-
-        private static UnsupportedOperationException noFusion() {
-            return new UnsupportedOperationException("fusion not supported");
-        }
-    }
-}
diff --git a/http/src/main/java/io/micronaut/http/reactive/execution/ReactiveExecutionFlow.java b/http/src/main/java/io/micronaut/http/reactive/execution/ReactiveExecutionFlow.java
index e3bdadaea0..9201140694 100644
--- a/http/src/main/java/io/micronaut/http/reactive/execution/ReactiveExecutionFlow.java
+++ b/http/src/main/java/io/micronaut/http/reactive/execution/ReactiveExecutionFlow.java
@@ -17,9 +17,7 @@ package io.micronaut.http.reactive.execution;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.async.annotation.SingleResult;
 import io.micronaut.core.execution.ExecutionFlow;
-import io.micronaut.core.propagation.PropagatedContext;
 import org.reactivestreams.Publisher;
 import reactor.core.publisher.Mono;
 import reactor.core.scheduler.Scheduler;
@@ -51,22 +49,6 @@ public sealed interface ReactiveExecutionFlow<T> extends ExecutionFlow<T> permit
         return (ReactiveExecutionFlow<K>) new ReactorExecutionFlowImpl(publisher);
     }
 
-    /**
-     * Creates a new reactive flow from a publisher. This method eagerly subscribes to the
-     * publisher, and may return an immediate {@link ExecutionFlow} if possible.
-     *
-     * @param publisher         The publisher
-     * @param propagatedContext A context to propagate in the reactor context and as a thread-local
-     *                          in the subscribe operation.
-     * @param <K>       The flow value type
-     * @return a new flow
-     * @since 4.8.0
-     */
-    @NonNull
-    static <K> ExecutionFlow<K> fromPublisherEager(@NonNull Publisher<K> publisher, @NonNull PropagatedContext propagatedContext) {
-        return ReactorExecutionFlowImpl.defuse(publisher, propagatedContext);
-    }
-
     /**
      * Create a new reactive flow by invoking a supplier asynchronously.
      *
@@ -106,30 +88,7 @@ public sealed interface ReactiveExecutionFlow<T> extends ExecutionFlow<T> permit
     @NonNull
     Publisher<T> toPublisher();
 
-    /**
-     * Convert the given flow to a reactive publisher. The supplier is called for every
-     * subscription to the publisher.
-     *
-     * @param flowSupplier The flow supplier
-     * @param <K>          The element type
-     * @return The publisher
-     */
-    @NonNull
-    @SingleResult
-    static <K> Publisher<K> toPublisher(@NonNull Supplier<@NonNull ExecutionFlow<K>> flowSupplier) {
+    static <K> Publisher<K> toPublisher(Supplier<ExecutionFlow<K>> flowSupplier) {
         return (Publisher<K>) ReactorExecutionFlowImpl.toMono(flowSupplier);
     }
-
-    /**
-     * Convert the given flow to a reactive publisher.
-     *
-     * @param flow The flow
-     * @param <K>  The element type
-     * @return The publisher
-     */
-    @NonNull
-    @SingleResult
-    static <K> Publisher<K> toPublisher(@NonNull ExecutionFlow<K> flow) {
-        return (Publisher<K>) ReactorExecutionFlowImpl.toMono(flow);
-    }
 }
diff --git a/http/src/main/java/io/micronaut/http/reactive/execution/ReactorExecutionFlowImpl.java b/http/src/main/java/io/micronaut/http/reactive/execution/ReactorExecutionFlowImpl.java
index 750a538c0f..a63c7b7d12 100644
--- a/http/src/main/java/io/micronaut/http/reactive/execution/ReactorExecutionFlowImpl.java
+++ b/http/src/main/java/io/micronaut/http/reactive/execution/ReactorExecutionFlowImpl.java
@@ -18,25 +18,22 @@ package io.micronaut.http.reactive.execution;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.async.propagation.ReactorPropagation;
-import io.micronaut.core.execution.DelayedExecutionFlow;
 import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.core.execution.ImperativeExecutionFlow;
-import io.micronaut.core.propagation.PropagatedContext;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscription;
 import reactor.core.CoreSubscriber;
 import reactor.core.Fuseable;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
-import reactor.core.publisher.Operators;
+import reactor.core.publisher.Sinks;
 import reactor.util.context.Context;
+import reactor.util.context.ContextView;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
 import java.util.function.Supplier;
@@ -61,108 +58,6 @@ final class ReactorExecutionFlowImpl implements ReactiveExecutionFlow<Object> {
         this.value = (Mono<Object>) value;
     }
 
-    public static <T> ExecutionFlow<T> defuse(Publisher<T> publisher, PropagatedContext propagatedContext) {
-        if (publisher instanceof Fuseable.ScalarCallable<?> sc) {
-            // Mono.just, Mono.error. No need for context propagation
-            try {
-                //noinspection unchecked
-                return ExecutionFlow.just((T) sc.call());
-            } catch (Throwable t) {
-                return ExecutionFlow.error(t);
-            }
-        } else if (publisher instanceof FlowAsMono<T> flowAsMono) {
-            // unwrap directly
-            //noinspection unchecked
-            return (ExecutionFlow<T>) flowAsMono.flow;
-        }
-
-        // special subscriber that (a) contains the propagated context and (b) can return an
-        // imperative flow if the result is provided immediately in subscribe()
-        var s = new CoreSubscriber<T>() {
-            final AtomicReference<ExecutionFlow<T>> flow = new AtomicReference<>();
-
-            boolean complete = false;
-
-            @Override
-            public Context currentContext() {
-                return ReactorPropagation.addPropagatedContext(Context.empty(), propagatedContext);
-            }
-
-            @Override
-            public void onSubscribe(Subscription s) {
-                if (s instanceof Fuseable.QueueSubscription<?> qs && qs.requestFusion(Fuseable.SYNC) == Fuseable.SYNC) {
-                    // we can avoid the subscribe / WIP dance. This is for example Mono.just(…).map(…)
-                    T result;
-                    try {
-                        //noinspection unchecked
-                        result = (T) qs.poll();
-                    } catch (Throwable t) {
-                        completeError(t);
-                        return;
-                    }
-                    complete(result);
-                    return;
-                }
-                // fallback, normal reactive subscription
-                s.request(Long.MAX_VALUE);
-            }
-
-            private void complete(T result) {
-                if (!flow.compareAndSet(null, ExecutionFlow.just(result))) {
-                    ((DelayedExecutionFlow<T>) flow.get()).complete(result);
-                }
-                complete = true;
-            }
-
-            private void completeError(Throwable t) {
-                if (!flow.compareAndSet(null, ExecutionFlow.error(t))) {
-                    ((DelayedExecutionFlow<?>) flow.get()).completeExceptionally(t);
-                }
-                complete = true;
-            }
-
-            @Override
-            public void onNext(T t) {
-                if (complete) {
-                    Operators.onNextDropped(t, Context.empty());
-                    return;
-                }
-                complete(t);
-            }
-
-            @Override
-            public void onError(Throwable t) {
-                if (complete) {
-                    Operators.onErrorDropped(t, Context.empty());
-                    return;
-                }
-                completeError(t);
-            }
-
-            @Override
-            public void onComplete() {
-                if (!complete) {
-                    complete(null);
-                }
-            }
-        };
-        try (PropagatedContext.Scope ignored = propagatedContext.propagate()) {
-            publisher.subscribe(s);
-        }
-        ExecutionFlow<T> immediate = s.flow.getPlain();
-        if (immediate != null) {
-            return immediate;
-        } else {
-            DelayedExecutionFlow<T> flow = DelayedExecutionFlow.create();
-            if (s.flow.compareAndSet(null, flow)) {
-                return flow;
-            } else {
-                // data race
-                return s.flow.getPlain();
-            }
-        }
-    }
-
     @Override
     public <R> ExecutionFlow<R> flatMap(Function<? super Object, ? extends ExecutionFlow<? extends R>> transformer) {
         value = value.flatMap(value -> toMono(transformer.apply(value)));
@@ -235,6 +130,14 @@ final class ReactorExecutionFlowImpl implements ReactiveExecutionFlow<Object> {
             Subscription subscription;
             Object value;
 
+            @Override
+            public Context currentContext() {
+                if (fn instanceof ReactiveConsumer reactiveConsumer) {
+                    return Context.of(reactiveConsumer.contextView);
+                }
+                return CoreSubscriber.super.currentContext();
+            }
+
             @Override
             public void onSubscribe(Subscription s) {
                 this.subscription = s;
@@ -348,7 +251,22 @@ final class ReactorExecutionFlowImpl implements ReactiveExecutionFlow<Object> {
             }
             return m;
         } else {
-            return new FlowAsMono<>(next);
+            return Mono.deferContextual(contextView -> {
+                Sinks.One<Object> sink = Sinks.one();
+                ReactiveConsumer reactiveConsumer = new ReactiveConsumer(contextView) {
+
+                    @Override
+                    public void accept(Object o, Throwable throwable) {
+                        if (throwable != null) {
+                            sink.tryEmitError(throwable);
+                        } else {
+                            sink.tryEmitValue(o);
+                        }
+                    }
+                };
+                next.onComplete(reactiveConsumer);
+                return sink.asMono().doOnCancel(next::cancel);
+            });
         }
     }
 
@@ -365,4 +283,13 @@ final class ReactorExecutionFlowImpl implements ReactiveExecutionFlow<Object> {
     public CompletableFuture<Object> toCompletableFuture() {
         return value.toFuture();
     }
+
+    private abstract static class ReactiveConsumer implements BiConsumer<Object, Throwable> {
+
+        private final ContextView contextView;
+
+        private ReactiveConsumer(ContextView contextView) {
+            this.contextView = contextView;
+        }
+    }
 }
diff --git a/http/src/test/groovy/io/micronaut/http/reactive/execution/ReactorExecutionFlowImplSpec.groovy b/http/src/test/groovy/io/micronaut/http/reactive/execution/ReactorExecutionFlowImplSpec.groovy
index cc559031dc..c81b94a5e9 100644
--- a/http/src/test/groovy/io/micronaut/http/reactive/execution/ReactorExecutionFlowImplSpec.groovy
+++ b/http/src/test/groovy/io/micronaut/http/reactive/execution/ReactorExecutionFlowImplSpec.groovy
@@ -1,11 +1,6 @@
 package io.micronaut.http.reactive.execution
 
-import io.micronaut.core.execution.DelayedExecutionFlow
-import io.micronaut.core.execution.ExecutionFlow
-import io.micronaut.core.execution.ImperativeExecutionFlow
-import io.micronaut.core.propagation.PropagatedContext
 import org.reactivestreams.Publisher
-import reactor.core.publisher.Hooks
 import reactor.core.publisher.Mono
 import reactor.core.scheduler.Schedulers
 import spock.lang.Specification
@@ -102,51 +97,4 @@ class ReactorExecutionFlowImplSpec extends Specification {
                 Mono.just("foo").subscribeOn(Schedulers.immediate()),
         ]
     }
-
-    def 'defuse immediate'() {
-        when:
-        Hooks.resetOnOperatorDebug()
-        def flow = ReactorExecutionFlowImpl.defuse(ReactorExecutionFlowImpl.toMono(ExecutionFlow.just("foo")), PropagatedContext.empty())
-        then:
-        flow instanceof ImperativeExecutionFlow
-        flow.tryCompleteValue() == "foo"
-    }
-
-    def 'defuse immediate with map'() {
-        when:
-        Hooks.resetOnOperatorDebug()
-        def flow = ReactorExecutionFlowImpl.defuse(ReactorExecutionFlowImpl.toMono(ExecutionFlow.just("foo")).map { it + "bar" }, PropagatedContext.empty())
-        then:
-        flow instanceof ImperativeExecutionFlow
-        flow.tryCompleteValue() == "foobar"
-    }
-
-    def 'defuse delayed with map'() {
-        when:
-        Hooks.resetOnOperatorDebug()
-        DelayedExecutionFlow del = DelayedExecutionFlow.create()
-        def flow = ReactorExecutionFlowImpl.defuse(ReactorExecutionFlowImpl.toMono(del).map { it + "bar" }, PropagatedContext.empty())
-        def result
-        flow.onComplete((o, e) -> {
-            result = o
-        })
-        then:
-        result == null
-        when:
-        del.complete("foo")
-        then:
-        result == "foobar"
-    }
-
-    def 'defuse delayed with map, but delayed completes before defuse'() {
-        when:
-        Hooks.resetOnOperatorDebug()
-        DelayedExecutionFlow del = DelayedExecutionFlow.create()
-        def mono = ReactorExecutionFlowImpl.toMono(del).map { it + "bar" }
-        del.complete("foo")
-        def flow = ReactorExecutionFlowImpl.defuse(mono, PropagatedContext.empty())
-        then:
-        flow instanceof ImperativeExecutionFlow
-        flow.tryCompleteValue() == "foobar"
-    }
 }
