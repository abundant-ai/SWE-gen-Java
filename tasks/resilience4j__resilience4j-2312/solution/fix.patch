diff --git a/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java b/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
index 9faaed6f..8b408117 100644
--- a/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
+++ b/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
@@ -5,10 +5,7 @@ import io.github.resilience4j.bulkhead.BulkheadFullException;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;
 import io.github.resilience4j.cache.Cache;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
-import io.github.resilience4j.core.CallableUtils;
-import io.github.resilience4j.core.CheckedFunctionUtils;
-import io.github.resilience4j.core.CompletionStageUtils;
-import io.github.resilience4j.core.SupplierUtils;
+import io.github.resilience4j.core.*;
 import io.github.resilience4j.core.functions.*;
 import io.github.resilience4j.micrometer.Timer;
 import io.github.resilience4j.ratelimiter.RateLimiter;
@@ -216,6 +213,31 @@ public interface Decorators {
             return this;
         }
 
+        public DecorateFunction<T, R> withFallback(BiFunction<R, Throwable, R> handler) {
+            function = FunctionUtils.andThen(function, handler);
+            return this;
+        }
+
+        public DecorateFunction<T, R> withFallback(Predicate<R> resultPredicate, UnaryOperator<R> resultHandler) {
+            function = FunctionUtils.recover(function, resultPredicate, resultHandler);
+            return this;
+        }
+
+        public DecorateFunction<T, R> withFallback(List<Class<? extends Throwable>> exceptionTypes, Function<Throwable, R> exceptionHandler) {
+            function = FunctionUtils.recover(function, exceptionTypes, exceptionHandler);
+            return this;
+        }
+
+        public DecorateFunction<T, R> withFallback(Function<Throwable, R> exceptionHandler) {
+            function = FunctionUtils.recover(function, exceptionHandler);
+            return this;
+        }
+
+        public <X extends Throwable> DecorateFunction<T, R> withFallback(Class<X> exceptionType, Function<Throwable, R> exceptionHandler) {
+            function = FunctionUtils.recover(function, exceptionType, exceptionHandler);
+            return this;
+        }
+
         public Function<T, R> decorate() {
             return function;
         }
@@ -505,6 +527,31 @@ public interface Decorators {
             return this;
         }
 
+        public DecorateCheckedFunction<T, R> withFallback(BiFunction<R, Throwable, R> handler) {
+            function = CheckedFunctionUtils.andThen(function, handler);
+            return this;
+        }
+
+        public DecorateCheckedFunction<T, R> withFallback(Predicate<R> resultPredicate, UnaryOperator<R> resultHandler) {
+            function = CheckedFunctionUtils.recover(function, resultPredicate, resultHandler);
+            return this;
+        }
+
+        public DecorateCheckedFunction<T, R> withFallback(List<Class<? extends Throwable>> exceptionTypes, CheckedFunction<Throwable, R> exceptionHandler) {
+            function = CheckedFunctionUtils.recover(function, exceptionTypes, exceptionHandler);
+            return this;
+        }
+
+        public DecorateCheckedFunction<T, R> withFallback(CheckedFunction<Throwable, R> exceptionHandler) {
+            function = CheckedFunctionUtils.recover(function, exceptionHandler);
+            return this;
+        }
+
+        public <X extends Throwable> DecorateCheckedFunction<T, R> withFallback(Class<X> exceptionType, CheckedFunction<Throwable, R> exceptionHandler) {
+            function = CheckedFunctionUtils.recover(function, exceptionType, exceptionHandler);
+            return this;
+        }
+
         public CheckedFunction<T, R> decorate() {
             return function;
         }
diff --git a/resilience4j-core/src/main/java/io/github/resilience4j/core/CheckedFunctionUtils.java b/resilience4j-core/src/main/java/io/github/resilience4j/core/CheckedFunctionUtils.java
index 4791f857..04a91075 100644
--- a/resilience4j-core/src/main/java/io/github/resilience4j/core/CheckedFunctionUtils.java
+++ b/resilience4j-core/src/main/java/io/github/resilience4j/core/CheckedFunctionUtils.java
@@ -24,7 +24,9 @@ import io.github.resilience4j.core.functions.CheckedSupplier;
 
 import java.util.List;
 import java.util.function.BiFunction;
+import java.util.function.Function;
 import java.util.function.Predicate;
+import java.util.function.UnaryOperator;
 
 public class CheckedFunctionUtils {
 
@@ -144,4 +146,161 @@ public class CheckedFunctionUtils {
             }
         };
     }
+
+    /**
+     * Returns a composed function that first applies the CheckedFunction and then applies the
+     * resultHandler.
+     *
+     * @param <T>           function parameter type
+     * @param <U>           return type of function
+     * @param <R>           return type of handler
+     * @param function the function
+     * @param resultHandler the function applied after function
+     * @return a function composed of supplier and resultHandler
+     */
+    public static <T, U, R> CheckedFunction<T, R> andThen(CheckedFunction<T, U> function, CheckedFunction<U, R> resultHandler) {
+        return t -> resultHandler.apply(function.apply(t));
+    }
+
+    /**
+     * Returns a composed function that first applies the CheckedFunction and then applies {@linkplain
+     * BiFunction} {@code after} to the result.
+     *
+     * @param <T>           function parameter type
+     * @param <U>           return type of function
+     * @param <R>           return type of handler
+     * @param function the function
+     * @param handler the function applied after function
+     * @return a function composed of supplier and handler
+     */
+    public static <T, U, R> CheckedFunction<T, R> andThen(CheckedFunction<T, U> function,
+                                                   BiFunction<U, Throwable, R> handler) {
+        return t -> {
+            try {
+                U result = function.apply(t);
+                return handler.apply(result, null);
+            } catch (Exception exception) {
+                return handler.apply(null, exception);
+            }
+        };
+    }
+
+    /**
+     * Returns a composed function that first applies the CheckedFunction and then applies either the
+     * resultHandler or exceptionHandler.
+     *
+     * @param <T>           function parameter type
+     * @param <U>           return type of function
+     * @param <R>           return type of handler
+     * @param function the function
+     * @param resultHandler    the function applied after function was successful
+     * @param exceptionHandler the function applied after function has failed
+     * @return a function composed of supplier and handler
+     */
+    public static <T, U, R> CheckedFunction<T, R> andThen(CheckedFunction<T, U> function, CheckedFunction<U, R> resultHandler,
+                                                          CheckedFunction<Throwable, R> exceptionHandler) {
+        return t -> {
+            try {
+                U result = function.apply(t);
+                return resultHandler.apply(result);
+            } catch (Exception exception) {
+                return exceptionHandler.apply(exception);
+            }
+        };
+    }
+
+    /**
+     * Returns a composed function that first executes the CheckedFunction and optionally recovers from an
+     * exception.
+     *
+     * @param <T>           function parameter type
+     * @param <R>           return type of function
+     * @param function the function which should be recovered from a certain exception
+     * @param exceptionHandler the exception handler
+     * @return a function composed of function and exceptionHandler
+     */
+    public static <T, R> CheckedFunction<T, R> recover(CheckedFunction<T, R> function,
+                                                CheckedFunction<Throwable, R> exceptionHandler) {
+        return t -> {
+            try {
+                return function.apply(t);
+            } catch (Exception exception) {
+                return exceptionHandler.apply(exception);
+            }
+        };
+    }
+
+    /**
+     * Returns a composed CheckedFunction that first executes the CheckedFunction and optionally recovers from a specific result.
+     *
+     * @param <T>           function parameter type
+     * @param <R>           return type of function
+     * @param function the function which should be recovered from a certain exception
+     * @param resultPredicate the result predicate
+     * @param resultHandler the result handler
+     * @return a function composed of supplier and exceptionHandler
+     */
+    public static <T, R> CheckedFunction<T, R> recover(CheckedFunction<T, R> function,
+                                                Predicate<R> resultPredicate, UnaryOperator<R> resultHandler) {
+        return t -> {
+            R result = function.apply(t);
+            if(resultPredicate.test(result)){
+                return resultHandler.apply(result);
+            }
+            return result;
+        };
+    }
+
+    /**
+     * Returns a composed function that first executes the CheckedFunction and optionally recovers from an
+     * exception.
+     *
+     * @param <T>           function parameter type
+     * @param <R>           return type of function
+     * @param function the function which should be recovered from a certain exception
+     * @param exceptionTypes the specific exception types that should be recovered
+     * @param exceptionHandler the exception handler
+     * @return a function composed of supplier and exceptionHandler
+     */
+    public static <T, R> CheckedFunction<T, R> recover(CheckedFunction<T, R> function,
+                                                List<Class<? extends Throwable>> exceptionTypes,
+                                                       CheckedFunction<Throwable, R> exceptionHandler) {
+        return t -> {
+            try {
+                return function.apply(t);
+            } catch (Exception exception) {
+                if(exceptionTypes.stream().anyMatch(exceptionType -> exceptionType.isAssignableFrom(exception.getClass()))){
+                    return exceptionHandler.apply(exception);
+                }else{
+                    throw exception;
+                }
+            }
+        };
+    }
+
+    /**
+     * Returns a composed function that first executes the CheckedFunction and optionally recovers from an
+     * exception.
+     *
+     * @param <T>           function parameter type
+     * @param <R>           return type of function
+     * @param exceptionType the specific exception type that should be recovered
+     * @param exceptionHandler the exception handler
+     * @return a function composed of function and exceptionHandler
+     */
+    public static <X extends Throwable, T, R> CheckedFunction<T, R> recover(CheckedFunction<T, R> function,
+                                                                     Class<X> exceptionType,
+                                                                     CheckedFunction<Throwable, R> exceptionHandler) {
+        return t -> {
+            try {
+                return function.apply(t);
+            } catch (Exception exception) {
+                if(exceptionType.isAssignableFrom(exception.getClass())) {
+                    return exceptionHandler.apply(exception);
+                }else{
+                    throw exception;
+                }
+            }
+        };
+    }
 }
diff --git a/resilience4j-core/src/main/java/io/github/resilience4j/core/FunctionUtils.java b/resilience4j-core/src/main/java/io/github/resilience4j/core/FunctionUtils.java
new file mode 100644
index 00000000..b09ef7fd
--- /dev/null
+++ b/resilience4j-core/src/main/java/io/github/resilience4j/core/FunctionUtils.java
@@ -0,0 +1,171 @@
+package io.github.resilience4j.core;
+
+
+import java.util.List;
+import java.util.function.BiFunction;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.function.UnaryOperator;
+
+public class FunctionUtils {
+
+    private FunctionUtils() {
+    }
+
+    /**
+     * Returns a composed function that first applies the Function and then applies the
+     * resultHandler.
+     *
+     * @param <T>           function parameter type
+     * @param <U>           return type of function
+     * @param <R>           return type of handler
+     * @param function the function
+     * @param resultHandler the function applied after function
+     * @return a function composed of supplier and resultHandler
+     */
+    public static <T, U, R> Function<T, R> andThen(Function<T, U> function, Function<U, R> resultHandler) {
+        return t -> resultHandler.apply(function.apply(t));
+    }
+
+    /**
+     * Returns a composed function that first applies the Function and then applies {@linkplain
+     * BiFunction} {@code after} to the result.
+     *
+     * @param <T>           function parameter type
+     * @param <U>           return type of function
+     * @param <R>           return type of handler
+     * @param function the function
+     * @param handler the function applied after function
+     * @return a function composed of supplier and handler
+     */
+    public static <T, U, R> Function<T, R> andThen(Function<T, U> function,
+        BiFunction<U, Throwable, R> handler) {
+        return t -> {
+            try {
+                U result = function.apply(t);
+                return handler.apply(result, null);
+            } catch (Exception exception) {
+                return handler.apply(null, exception);
+            }
+        };
+    }
+
+    /**
+     * Returns a composed function that first applies the Function and then applies either the
+     * resultHandler or exceptionHandler.
+     *
+     * @param <T>           function parameter type
+     * @param <U>           return type of function
+     * @param <R>           return type of handler
+     * @param function the function
+     * @param resultHandler    the function applied after function was successful
+     * @param exceptionHandler the function applied after function has failed
+     * @return a function composed of supplier and handler
+     */
+    public static <T, U, R> Function<T, R> andThen(Function<T, U> function, Function<U, R> resultHandler,
+        Function<Throwable, R> exceptionHandler) {
+        return t -> {
+            try {
+                U result = function.apply(t);
+                return resultHandler.apply(result);
+            } catch (Exception exception) {
+                return exceptionHandler.apply(exception);
+            }
+        };
+    }
+
+    /**
+     * Returns a composed function that first executes the Function and optionally recovers from an
+     * exception.
+     *
+     * @param <T>           function parameter type
+     * @param <R>           return type of function
+     * @param function the function which should be recovered from a certain exception
+     * @param exceptionHandler the exception handler
+     * @return a function composed of function and exceptionHandler
+     */
+    public static <T, R> Function<T, R> recover(Function<T, R> function,
+        Function<Throwable, R> exceptionHandler) {
+        return t -> {
+            try {
+                return function.apply(t);
+            } catch (Exception exception) {
+                return exceptionHandler.apply(exception);
+            }
+        };
+    }
+
+    /**
+     * Returns a composed Function that first executes the Function and optionally recovers from a specific result.
+     *
+     * @param <T>           function parameter type
+     * @param <R>           return type of function
+     * @param function the function which should be recovered from a certain exception
+     * @param resultPredicate the result predicate
+     * @param resultHandler the result handler
+     * @return a function composed of supplier and exceptionHandler
+     */
+    public static <T, R> Function<T, R> recover(Function<T, R> function,
+        Predicate<R> resultPredicate, UnaryOperator<R> resultHandler) {
+        return t -> {
+            R result = function.apply(t);
+            if(resultPredicate.test(result)){
+                return resultHandler.apply(result);
+            }
+            return result;
+        };
+    }
+
+    /**
+     * Returns a composed function that first executes the Function and optionally recovers from an
+     * exception.
+     *
+     * @param <T>           function parameter type
+     * @param <R>           return type of function
+     * @param function the function which should be recovered from a certain exception
+     * @param exceptionTypes the specific exception types that should be recovered
+     * @param exceptionHandler the exception handler
+     * @return a function composed of supplier and exceptionHandler
+     */
+    public static <T, R> Function<T, R> recover(Function<T, R> function,
+        List<Class<? extends Throwable>> exceptionTypes,
+        Function<Throwable, R> exceptionHandler) {
+        return t -> {
+            try {
+                return function.apply(t);
+            } catch (Exception exception) {
+                if(exceptionTypes.stream().anyMatch(exceptionType -> exceptionType.isAssignableFrom(exception.getClass()))){
+                    return exceptionHandler.apply(exception);
+                }else{
+                    throw exception;
+                }
+            }
+        };
+    }
+
+    /**
+     * Returns a composed function that first executes the Function and optionally recovers from an
+     * exception.
+     *
+     * @param <T>           function parameter type
+     * @param <R>           return type of function
+     * @param exceptionType the specific exception type that should be recovered
+     * @param exceptionHandler the exception handler
+     * @return a function composed of function and exceptionHandler
+     */
+    public static <X extends Throwable, T, R> Function<T, R> recover(Function<T, R> function,
+        Class<X> exceptionType,
+        Function<Throwable, R> exceptionHandler) {
+        return t -> {
+            try {
+                return function.apply(t);
+            } catch (Exception exception) {
+                if(exceptionType.isAssignableFrom(exception.getClass())) {
+                    return exceptionHandler.apply(exception);
+                }else{
+                    throw exception;
+                }
+            }
+        };
+    }
+}
