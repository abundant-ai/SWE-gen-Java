diff --git a/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java b/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
index 8b408117..9faaed6f 100644
--- a/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
+++ b/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
@@ -5,7 +5,10 @@ import io.github.resilience4j.bulkhead.BulkheadFullException;
 import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;
 import io.github.resilience4j.cache.Cache;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
-import io.github.resilience4j.core.*;
+import io.github.resilience4j.core.CallableUtils;
+import io.github.resilience4j.core.CheckedFunctionUtils;
+import io.github.resilience4j.core.CompletionStageUtils;
+import io.github.resilience4j.core.SupplierUtils;
 import io.github.resilience4j.core.functions.*;
 import io.github.resilience4j.micrometer.Timer;
 import io.github.resilience4j.ratelimiter.RateLimiter;
@@ -213,31 +216,6 @@ public interface Decorators {
             return this;
         }
 
-        public DecorateFunction<T, R> withFallback(BiFunction<R, Throwable, R> handler) {
-            function = FunctionUtils.andThen(function, handler);
-            return this;
-        }
-
-        public DecorateFunction<T, R> withFallback(Predicate<R> resultPredicate, UnaryOperator<R> resultHandler) {
-            function = FunctionUtils.recover(function, resultPredicate, resultHandler);
-            return this;
-        }
-
-        public DecorateFunction<T, R> withFallback(List<Class<? extends Throwable>> exceptionTypes, Function<Throwable, R> exceptionHandler) {
-            function = FunctionUtils.recover(function, exceptionTypes, exceptionHandler);
-            return this;
-        }
-
-        public DecorateFunction<T, R> withFallback(Function<Throwable, R> exceptionHandler) {
-            function = FunctionUtils.recover(function, exceptionHandler);
-            return this;
-        }
-
-        public <X extends Throwable> DecorateFunction<T, R> withFallback(Class<X> exceptionType, Function<Throwable, R> exceptionHandler) {
-            function = FunctionUtils.recover(function, exceptionType, exceptionHandler);
-            return this;
-        }
-
         public Function<T, R> decorate() {
             return function;
         }
@@ -527,31 +505,6 @@ public interface Decorators {
             return this;
         }
 
-        public DecorateCheckedFunction<T, R> withFallback(BiFunction<R, Throwable, R> handler) {
-            function = CheckedFunctionUtils.andThen(function, handler);
-            return this;
-        }
-
-        public DecorateCheckedFunction<T, R> withFallback(Predicate<R> resultPredicate, UnaryOperator<R> resultHandler) {
-            function = CheckedFunctionUtils.recover(function, resultPredicate, resultHandler);
-            return this;
-        }
-
-        public DecorateCheckedFunction<T, R> withFallback(List<Class<? extends Throwable>> exceptionTypes, CheckedFunction<Throwable, R> exceptionHandler) {
-            function = CheckedFunctionUtils.recover(function, exceptionTypes, exceptionHandler);
-            return this;
-        }
-
-        public DecorateCheckedFunction<T, R> withFallback(CheckedFunction<Throwable, R> exceptionHandler) {
-            function = CheckedFunctionUtils.recover(function, exceptionHandler);
-            return this;
-        }
-
-        public <X extends Throwable> DecorateCheckedFunction<T, R> withFallback(Class<X> exceptionType, CheckedFunction<Throwable, R> exceptionHandler) {
-            function = CheckedFunctionUtils.recover(function, exceptionType, exceptionHandler);
-            return this;
-        }
-
         public CheckedFunction<T, R> decorate() {
             return function;
         }
diff --git a/resilience4j-all/src/test/java/io/github/resilience4j/decorators/DecoratorsTest.java b/resilience4j-all/src/test/java/io/github/resilience4j/decorators/DecoratorsTest.java
index b2a04f60..7899cd43 100644
--- a/resilience4j-all/src/test/java/io/github/resilience4j/decorators/DecoratorsTest.java
+++ b/resilience4j-all/src/test/java/io/github/resilience4j/decorators/DecoratorsTest.java
@@ -52,7 +52,6 @@ import java.time.Duration;
 import java.util.Map;
 import java.util.concurrent.*;
 import java.util.function.Function;
-import java.util.function.Predicate;
 import java.util.function.Supplier;
 
 import static com.jayway.awaitility.Awaitility.matches;
@@ -243,32 +242,6 @@ public class DecoratorsTest {
         then(helloWorldService).should(times(1)).returnHelloWorldWithException();
     }
 
-    @Test
-    public void testDecorateFunctionWithFallbackFromResult() throws Exception {
-        given(helloWorldService.returnHelloWorldWithName("Name")).willReturn("Hello world Name");
-        Function<String, String> decoratedFunction = Decorators
-                .ofFunction((Function<String, String>) str -> helloWorldService.returnHelloWorldWithName(str))
-                .withFallback(result -> result.equals("Hello world Name"), (result) -> "Fallback")
-                .decorate();
-
-        String result = decoratedFunction.apply("Name");
-
-        assertThat(result).isEqualTo("Fallback");
-    }
-
-    @Test
-    public void testDecorateCheckedFunctionWithFallbackFromResult() throws Throwable {
-        given(helloWorldService.returnHelloWorldWithName("Name")).willReturn("Hello world Name");
-        CheckedFunction<String, String> decoratedFunction = Decorators
-                .ofCheckedFunction((CheckedFunction<String, String>) str -> helloWorldService.returnHelloWorldWithName(str))
-                .withFallback(result -> result.equals("Hello world Name"), (result) -> "Fallback")
-                .decorate();
-
-        String result = decoratedFunction.apply("Name");
-
-        assertThat(result).isEqualTo("Fallback");
-    }
-
     @Test
     public void testDecorateCheckedSupplierWithFallbackFromResult() throws Throwable {
         given(helloWorldService.returnHelloWorldWithException()).willReturn("Hello world");
@@ -847,19 +820,6 @@ public class DecoratorsTest {
         assertThat(metrics.getNumberOfSuccessfulCalls()).isEqualTo(1);
     }
 
-    @Test
-    public void testDecorateFunctionWithFallback() {
-        given(helloWorldService.returnHelloWorldWithName("Name")).willThrow(new RuntimeException("BAM!"));
-        Function<String, String> decoratedFunction = Decorators
-                .ofFunction(helloWorldService::returnHelloWorldWithName)
-                .withFallback(throwable -> "Fallback")
-                .decorate();
-
-        String result = decoratedFunction.apply("Name");
-
-        assertThat(result).isEqualTo("Fallback");
-    }
-
     @Test
     public void testDecorateCheckedFunction() throws IOException {
         given(helloWorldService.returnHelloWorldWithNameWithException("Name"))
@@ -881,19 +841,6 @@ public class DecoratorsTest {
         assertThat(metrics.getNumberOfSuccessfulCalls()).isEqualTo(1);
     }
 
-    @Test
-    public void testDecorateCheckedFunctionWithFallback() throws Throwable {
-        given(helloWorldService.returnHelloWorldWithName("Name")).willThrow(new RuntimeException("BAM!"));
-        CheckedFunction<String, String> decoratedFunction = Decorators
-                .ofCheckedFunction(helloWorldService::returnHelloWorldWithName)
-                .withFallback(throwable -> "Fallback")
-                .decorate();
-
-        String result = decoratedFunction.apply("Name");
-
-        assertThat(result).isEqualTo("Fallback");
-    }
-
     @Test
     public void testDecorateCheckedConsumer() {
         given(helloWorldService.returnHelloWorldWithName("Name"))
diff --git a/resilience4j-core/src/main/java/io/github/resilience4j/core/CheckedFunctionUtils.java b/resilience4j-core/src/main/java/io/github/resilience4j/core/CheckedFunctionUtils.java
index 04a91075..4791f857 100644
--- a/resilience4j-core/src/main/java/io/github/resilience4j/core/CheckedFunctionUtils.java
+++ b/resilience4j-core/src/main/java/io/github/resilience4j/core/CheckedFunctionUtils.java
@@ -24,9 +24,7 @@ import io.github.resilience4j.core.functions.CheckedSupplier;
 
 import java.util.List;
 import java.util.function.BiFunction;
-import java.util.function.Function;
 import java.util.function.Predicate;
-import java.util.function.UnaryOperator;
 
 public class CheckedFunctionUtils {
 
@@ -146,161 +144,4 @@ public class CheckedFunctionUtils {
             }
         };
     }
-
-    /**
-     * Returns a composed function that first applies the CheckedFunction and then applies the
-     * resultHandler.
-     *
-     * @param <T>           function parameter type
-     * @param <U>           return type of function
-     * @param <R>           return type of handler
-     * @param function the function
-     * @param resultHandler the function applied after function
-     * @return a function composed of supplier and resultHandler
-     */
-    public static <T, U, R> CheckedFunction<T, R> andThen(CheckedFunction<T, U> function, CheckedFunction<U, R> resultHandler) {
-        return t -> resultHandler.apply(function.apply(t));
-    }
-
-    /**
-     * Returns a composed function that first applies the CheckedFunction and then applies {@linkplain
-     * BiFunction} {@code after} to the result.
-     *
-     * @param <T>           function parameter type
-     * @param <U>           return type of function
-     * @param <R>           return type of handler
-     * @param function the function
-     * @param handler the function applied after function
-     * @return a function composed of supplier and handler
-     */
-    public static <T, U, R> CheckedFunction<T, R> andThen(CheckedFunction<T, U> function,
-                                                   BiFunction<U, Throwable, R> handler) {
-        return t -> {
-            try {
-                U result = function.apply(t);
-                return handler.apply(result, null);
-            } catch (Exception exception) {
-                return handler.apply(null, exception);
-            }
-        };
-    }
-
-    /**
-     * Returns a composed function that first applies the CheckedFunction and then applies either the
-     * resultHandler or exceptionHandler.
-     *
-     * @param <T>           function parameter type
-     * @param <U>           return type of function
-     * @param <R>           return type of handler
-     * @param function the function
-     * @param resultHandler    the function applied after function was successful
-     * @param exceptionHandler the function applied after function has failed
-     * @return a function composed of supplier and handler
-     */
-    public static <T, U, R> CheckedFunction<T, R> andThen(CheckedFunction<T, U> function, CheckedFunction<U, R> resultHandler,
-                                                          CheckedFunction<Throwable, R> exceptionHandler) {
-        return t -> {
-            try {
-                U result = function.apply(t);
-                return resultHandler.apply(result);
-            } catch (Exception exception) {
-                return exceptionHandler.apply(exception);
-            }
-        };
-    }
-
-    /**
-     * Returns a composed function that first executes the CheckedFunction and optionally recovers from an
-     * exception.
-     *
-     * @param <T>           function parameter type
-     * @param <R>           return type of function
-     * @param function the function which should be recovered from a certain exception
-     * @param exceptionHandler the exception handler
-     * @return a function composed of function and exceptionHandler
-     */
-    public static <T, R> CheckedFunction<T, R> recover(CheckedFunction<T, R> function,
-                                                CheckedFunction<Throwable, R> exceptionHandler) {
-        return t -> {
-            try {
-                return function.apply(t);
-            } catch (Exception exception) {
-                return exceptionHandler.apply(exception);
-            }
-        };
-    }
-
-    /**
-     * Returns a composed CheckedFunction that first executes the CheckedFunction and optionally recovers from a specific result.
-     *
-     * @param <T>           function parameter type
-     * @param <R>           return type of function
-     * @param function the function which should be recovered from a certain exception
-     * @param resultPredicate the result predicate
-     * @param resultHandler the result handler
-     * @return a function composed of supplier and exceptionHandler
-     */
-    public static <T, R> CheckedFunction<T, R> recover(CheckedFunction<T, R> function,
-                                                Predicate<R> resultPredicate, UnaryOperator<R> resultHandler) {
-        return t -> {
-            R result = function.apply(t);
-            if(resultPredicate.test(result)){
-                return resultHandler.apply(result);
-            }
-            return result;
-        };
-    }
-
-    /**
-     * Returns a composed function that first executes the CheckedFunction and optionally recovers from an
-     * exception.
-     *
-     * @param <T>           function parameter type
-     * @param <R>           return type of function
-     * @param function the function which should be recovered from a certain exception
-     * @param exceptionTypes the specific exception types that should be recovered
-     * @param exceptionHandler the exception handler
-     * @return a function composed of supplier and exceptionHandler
-     */
-    public static <T, R> CheckedFunction<T, R> recover(CheckedFunction<T, R> function,
-                                                List<Class<? extends Throwable>> exceptionTypes,
-                                                       CheckedFunction<Throwable, R> exceptionHandler) {
-        return t -> {
-            try {
-                return function.apply(t);
-            } catch (Exception exception) {
-                if(exceptionTypes.stream().anyMatch(exceptionType -> exceptionType.isAssignableFrom(exception.getClass()))){
-                    return exceptionHandler.apply(exception);
-                }else{
-                    throw exception;
-                }
-            }
-        };
-    }
-
-    /**
-     * Returns a composed function that first executes the CheckedFunction and optionally recovers from an
-     * exception.
-     *
-     * @param <T>           function parameter type
-     * @param <R>           return type of function
-     * @param exceptionType the specific exception type that should be recovered
-     * @param exceptionHandler the exception handler
-     * @return a function composed of function and exceptionHandler
-     */
-    public static <X extends Throwable, T, R> CheckedFunction<T, R> recover(CheckedFunction<T, R> function,
-                                                                     Class<X> exceptionType,
-                                                                     CheckedFunction<Throwable, R> exceptionHandler) {
-        return t -> {
-            try {
-                return function.apply(t);
-            } catch (Exception exception) {
-                if(exceptionType.isAssignableFrom(exception.getClass())) {
-                    return exceptionHandler.apply(exception);
-                }else{
-                    throw exception;
-                }
-            }
-        };
-    }
 }
diff --git a/resilience4j-core/src/main/java/io/github/resilience4j/core/FunctionUtils.java b/resilience4j-core/src/main/java/io/github/resilience4j/core/FunctionUtils.java
deleted file mode 100644
index b09ef7fd..00000000
--- a/resilience4j-core/src/main/java/io/github/resilience4j/core/FunctionUtils.java
+++ /dev/null
@@ -1,171 +0,0 @@
-package io.github.resilience4j.core;
-
-
-import java.util.List;
-import java.util.function.BiFunction;
-import java.util.function.Function;
-import java.util.function.Predicate;
-import java.util.function.UnaryOperator;
-
-public class FunctionUtils {
-
-    private FunctionUtils() {
-    }
-
-    /**
-     * Returns a composed function that first applies the Function and then applies the
-     * resultHandler.
-     *
-     * @param <T>           function parameter type
-     * @param <U>           return type of function
-     * @param <R>           return type of handler
-     * @param function the function
-     * @param resultHandler the function applied after function
-     * @return a function composed of supplier and resultHandler
-     */
-    public static <T, U, R> Function<T, R> andThen(Function<T, U> function, Function<U, R> resultHandler) {
-        return t -> resultHandler.apply(function.apply(t));
-    }
-
-    /**
-     * Returns a composed function that first applies the Function and then applies {@linkplain
-     * BiFunction} {@code after} to the result.
-     *
-     * @param <T>           function parameter type
-     * @param <U>           return type of function
-     * @param <R>           return type of handler
-     * @param function the function
-     * @param handler the function applied after function
-     * @return a function composed of supplier and handler
-     */
-    public static <T, U, R> Function<T, R> andThen(Function<T, U> function,
-        BiFunction<U, Throwable, R> handler) {
-        return t -> {
-            try {
-                U result = function.apply(t);
-                return handler.apply(result, null);
-            } catch (Exception exception) {
-                return handler.apply(null, exception);
-            }
-        };
-    }
-
-    /**
-     * Returns a composed function that first applies the Function and then applies either the
-     * resultHandler or exceptionHandler.
-     *
-     * @param <T>           function parameter type
-     * @param <U>           return type of function
-     * @param <R>           return type of handler
-     * @param function the function
-     * @param resultHandler    the function applied after function was successful
-     * @param exceptionHandler the function applied after function has failed
-     * @return a function composed of supplier and handler
-     */
-    public static <T, U, R> Function<T, R> andThen(Function<T, U> function, Function<U, R> resultHandler,
-        Function<Throwable, R> exceptionHandler) {
-        return t -> {
-            try {
-                U result = function.apply(t);
-                return resultHandler.apply(result);
-            } catch (Exception exception) {
-                return exceptionHandler.apply(exception);
-            }
-        };
-    }
-
-    /**
-     * Returns a composed function that first executes the Function and optionally recovers from an
-     * exception.
-     *
-     * @param <T>           function parameter type
-     * @param <R>           return type of function
-     * @param function the function which should be recovered from a certain exception
-     * @param exceptionHandler the exception handler
-     * @return a function composed of function and exceptionHandler
-     */
-    public static <T, R> Function<T, R> recover(Function<T, R> function,
-        Function<Throwable, R> exceptionHandler) {
-        return t -> {
-            try {
-                return function.apply(t);
-            } catch (Exception exception) {
-                return exceptionHandler.apply(exception);
-            }
-        };
-    }
-
-    /**
-     * Returns a composed Function that first executes the Function and optionally recovers from a specific result.
-     *
-     * @param <T>           function parameter type
-     * @param <R>           return type of function
-     * @param function the function which should be recovered from a certain exception
-     * @param resultPredicate the result predicate
-     * @param resultHandler the result handler
-     * @return a function composed of supplier and exceptionHandler
-     */
-    public static <T, R> Function<T, R> recover(Function<T, R> function,
-        Predicate<R> resultPredicate, UnaryOperator<R> resultHandler) {
-        return t -> {
-            R result = function.apply(t);
-            if(resultPredicate.test(result)){
-                return resultHandler.apply(result);
-            }
-            return result;
-        };
-    }
-
-    /**
-     * Returns a composed function that first executes the Function and optionally recovers from an
-     * exception.
-     *
-     * @param <T>           function parameter type
-     * @param <R>           return type of function
-     * @param function the function which should be recovered from a certain exception
-     * @param exceptionTypes the specific exception types that should be recovered
-     * @param exceptionHandler the exception handler
-     * @return a function composed of supplier and exceptionHandler
-     */
-    public static <T, R> Function<T, R> recover(Function<T, R> function,
-        List<Class<? extends Throwable>> exceptionTypes,
-        Function<Throwable, R> exceptionHandler) {
-        return t -> {
-            try {
-                return function.apply(t);
-            } catch (Exception exception) {
-                if(exceptionTypes.stream().anyMatch(exceptionType -> exceptionType.isAssignableFrom(exception.getClass()))){
-                    return exceptionHandler.apply(exception);
-                }else{
-                    throw exception;
-                }
-            }
-        };
-    }
-
-    /**
-     * Returns a composed function that first executes the Function and optionally recovers from an
-     * exception.
-     *
-     * @param <T>           function parameter type
-     * @param <R>           return type of function
-     * @param exceptionType the specific exception type that should be recovered
-     * @param exceptionHandler the exception handler
-     * @return a function composed of function and exceptionHandler
-     */
-    public static <X extends Throwable, T, R> Function<T, R> recover(Function<T, R> function,
-        Class<X> exceptionType,
-        Function<Throwable, R> exceptionHandler) {
-        return t -> {
-            try {
-                return function.apply(t);
-            } catch (Exception exception) {
-                if(exceptionType.isAssignableFrom(exception.getClass())) {
-                    return exceptionHandler.apply(exception);
-                }else{
-                    throw exception;
-                }
-            }
-        };
-    }
-}
diff --git a/resilience4j-core/src/test/java/io/github/resilience4j/core/CheckedFunctionUtilsTest.java b/resilience4j-core/src/test/java/io/github/resilience4j/core/CheckedFunctionUtilsTest.java
index 5923735a..7982afc4 100644
--- a/resilience4j-core/src/test/java/io/github/resilience4j/core/CheckedFunctionUtilsTest.java
+++ b/resilience4j-core/src/test/java/io/github/resilience4j/core/CheckedFunctionUtilsTest.java
@@ -18,7 +18,6 @@
  */
 package io.github.resilience4j.core;
 
-import io.github.resilience4j.core.functions.CheckedFunction;
 import io.github.resilience4j.core.functions.CheckedSupplier;
 import org.junit.Test;
 
@@ -121,100 +120,4 @@ public class CheckedFunctionUtilsTest {
 
         callableWithRecovery.get();
     }
-
-    @Test
-    public void shouldChainCheckedFunctionAndResultHandler() throws Throwable {
-        CheckedFunction<String, String> function = ignored -> "foo";
-        CheckedFunction<String, String> functionWithRecovery = CheckedFunctionUtils.andThen(function, result -> "bar");
-
-        String result = functionWithRecovery.apply("baz");
-
-        assertThat(result).isEqualTo("bar");
-    }
-
-
-    @Test
-    public void shouldChainCheckedFunctionAndRecoverFromException() throws Throwable {
-        CheckedFunction<String, String> function = ignored -> {
-            throw new RuntimeException("BAM!");
-        };
-        CheckedFunction<String, String> functionWithRecovery = CheckedFunctionUtils
-                .andThen(function, (result, ex) -> "foo");
-
-        String result = functionWithRecovery.apply("bar");
-
-        assertThat(result).isEqualTo("foo");
-    }
-
-    @Test
-    public void shouldChainCheckedFunctionAndRecoverWithErrorHandler() throws Throwable {
-        CheckedFunction<String, String> function = ignored -> {
-            throw new RuntimeException("BAM!");
-        };
-        CheckedFunction<String, String> functionWithRecovery = CheckedFunctionUtils
-                .andThen(function, (result) -> result, ex -> "foo");
-
-        String result = functionWithRecovery.apply("bar");
-
-        assertThat(result).isEqualTo("foo");
-    }
-
-    @Test
-    public void shouldRecoverCheckedFunctionFromException() throws Throwable {
-        CheckedFunction<String, String> function = ignored -> {
-            throw new RuntimeException("BAM!");
-        };
-        CheckedFunction<String, String> functionWithRecovery = CheckedFunctionUtils.recover(function, (ex) -> "foo");
-
-        String result = functionWithRecovery.apply("bar");
-
-        assertThat(result).isEqualTo("foo");
-    }
-
-    @Test
-    public void shouldRecoverCheckedFunctionFromSpecificExceptions() throws Throwable {
-        CheckedFunction<String, String> function = ignored -> {
-            throw new IllegalArgumentException("BAM!");
-        };
-
-        CheckedFunction<String, String> functionWithRecovery = CheckedFunctionUtils.recover(function,
-                asList(IllegalArgumentException.class, IOException.class),
-                (ex) -> "foo");
-
-        String result = functionWithRecovery.apply("bar");
-
-        assertThat(result).isEqualTo("foo");
-    }
-
-    @Test
-    public void shouldRecoverCheckedFunctionFromSpecificResult() throws Throwable {
-        CheckedFunction<String, String> function = ignored -> "Wrong Result";
-
-        CheckedFunction<String, String> functionWithRecovery = CheckedFunctionUtils.recover(function, (result) -> result.equals("Wrong Result"), (r) -> "Correct Result");
-        String result = functionWithRecovery.apply("foo");
-
-        assertThat(result).isEqualTo("Correct Result");
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void shouldRethrowCheckedFunctionException() throws Throwable {
-        CheckedFunction<String, String> function = ignored -> {
-            throw new IllegalArgumentException("BAM!");
-        };
-        CheckedFunction<String, String> functionWithRecovery = CheckedFunctionUtils.recover(function, (ex) -> {
-            throw new RuntimeException();
-        });
-
-        functionWithRecovery.apply("foo");
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void shouldRethrowCheckedFuntctionException2() throws Throwable {
-        CheckedFunction<String, String> function = ignored -> {
-            throw new RuntimeException("BAM!");
-        };
-        CheckedFunction<String, String> functionWithRecovery = CheckedFunctionUtils.recover(function, IllegalArgumentException.class, (ex) -> "foo");
-
-        functionWithRecovery.apply("bar");
-    }
 }
diff --git a/resilience4j-core/src/test/java/io/github/resilience4j/core/FunctionUtilsTest.java b/resilience4j-core/src/test/java/io/github/resilience4j/core/FunctionUtilsTest.java
deleted file mode 100644
index 82bad9ad..00000000
--- a/resilience4j-core/src/test/java/io/github/resilience4j/core/FunctionUtilsTest.java
+++ /dev/null
@@ -1,108 +0,0 @@
-package io.github.resilience4j.core;
-
-import org.junit.Test;
-
-import java.io.IOException;
-import java.util.function.Function;
-
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class FunctionUtilsTest {
-
-    @Test
-    public void shouldChainFunctionAndResultHandler() {
-        Function<String, String> function = ignored -> "foo";
-        Function<String, String> functionWithRecovery = FunctionUtils.andThen(function, result -> "bar");
-
-        String result = functionWithRecovery.apply("baz");
-
-        assertThat(result).isEqualTo("bar");
-    }
-
-
-    @Test
-    public void shouldChainFunctionAndRecoverFromException() {
-        Function<String, String> function = ignored -> {
-            throw new RuntimeException("BAM!");
-        };
-        Function<String, String> functionWithRecovery = FunctionUtils
-            .andThen(function, (result, ex) -> "foo");
-
-        String result = functionWithRecovery.apply("bar");
-
-        assertThat(result).isEqualTo("foo");
-    }
-
-    @Test
-    public void shouldChainFunctionAndRecoverWithErrorHandler() {
-        Function<String, String> function = ignored -> {
-            throw new RuntimeException("BAM!");
-        };
-        Function<String, String> functionWithRecovery = FunctionUtils
-            .andThen(function, (result) -> result, ex -> "foo");
-
-        String result = functionWithRecovery.apply("bar");
-
-        assertThat(result).isEqualTo("foo");
-    }
-
-    @Test
-    public void shouldRecoverFunctionFromException() {
-        Function<String, String> function = ignored -> {
-            throw new RuntimeException("BAM!");
-        };
-        Function<String, String> functionWithRecovery = FunctionUtils.recover(function, (ex) -> "foo");
-
-        String result = functionWithRecovery.apply("bar");
-
-        assertThat(result).isEqualTo("foo");
-    }
-
-    @Test
-    public void shouldRecoverFunctionFromSpecificExceptions() {
-        Function<String, String> function = ignored -> {
-            throw new IllegalArgumentException("BAM!");
-        };
-
-        Function<String, String> functionWithRecovery = FunctionUtils.recover(function,
-            asList(IllegalArgumentException.class, IOException.class),
-            (ex) -> "foo");
-
-        String result = functionWithRecovery.apply("bar");
-
-        assertThat(result).isEqualTo("foo");
-    }
-
-    @Test
-    public void shouldRecoverFunctionFromSpecificResult() {
-        Function<String, String> function = ignored -> "Wrong Result";
-
-        Function<String, String> functionWithRecovery = FunctionUtils.recover(function, (result) -> result.equals("Wrong Result"), (r) -> "Correct Result");
-        String result = functionWithRecovery.apply("foo");
-
-        assertThat(result).isEqualTo("Correct Result");
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void shouldRethrowException() {
-        Function<String, String> function = ignored -> {
-            throw new IllegalArgumentException("BAM!");
-        };
-        Function<String, String> functionWithRecovery = FunctionUtils.recover(function, (ex) -> {
-            throw new RuntimeException();
-        });
-
-        functionWithRecovery.apply("foo");
-    }
-
-    @Test(expected = RuntimeException.class)
-    public void shouldRethrowException2() throws Exception {
-        Function<String, String> function = ignored -> {
-            throw new RuntimeException("BAM!");
-        };
-        Function<String, String> functionWithRecovery = FunctionUtils.recover(function, IllegalArgumentException.class, (ex) -> "foo");
-
-        functionWithRecovery.apply("bar");
-    }
-}
