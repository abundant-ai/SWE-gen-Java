diff --git a/core/src/main/scala/cats/TraverseFilter.scala b/core/src/main/scala/cats/TraverseFilter.scala
index 59e84ba22..9f2d00ec7 100644
--- a/core/src/main/scala/cats/TraverseFilter.scala
+++ b/core/src/main/scala/cats/TraverseFilter.scala
@@ -23,7 +23,7 @@ package cats
 
 import cats.data.State
 
-import scala.collection.immutable.{IntMap, TreeSet}
+import scala.collection.immutable.{HashSet, TreeSet}
 
 /**
  * `TraverseFilter`, also known as `Witherable`, represents list-like structures
@@ -141,19 +141,12 @@ trait TraverseFilter[F[_]] extends FunctorFilter[F] {
    * This is usually faster than ordDistinct, especially for things that have a slow comparion (like String).
    */
   def hashDistinct[A](fa: F[A])(implicit H: Hash[A]): F[A] =
-    traverseFilter(fa) { a =>
-      State { (distinct: IntMap[List[A]]) =>
-        val ahash = H.hash(a)
-        distinct.get(ahash) match {
-          case None => (distinct.updated(ahash, a :: Nil), Some(a))
-          case Some(existing) =>
-            if (Traverse[List].contains_(existing, a))
-              (distinct, None)
-            else
-              (distinct.updated(ahash, a :: existing), Some(a))
-        }
-      }
-    }.run(IntMap.empty).value._2
+    traverseFilter[State[HashSet[A], *], A, A](fa)(a =>
+      State(alreadyIn => if (alreadyIn(a)) (alreadyIn, None) else (alreadyIn + a, Some(a)))
+    )
+      .run(HashSet.empty)
+      .value
+      ._2
 }
 
 object TraverseFilter {
diff --git a/free/src/test/scala-2.13+/cats/free/FreeStructuralSuite.scala b/free/src/test/scala-2.13+/cats/free/FreeStructuralSuite.scala
index 7aee33b77..2436a7b81 100644
--- a/free/src/test/scala-2.13+/cats/free/FreeStructuralSuite.scala
+++ b/free/src/test/scala-2.13+/cats/free/FreeStructuralSuite.scala
@@ -22,7 +22,7 @@
 package cats.free
 
 import cats.{Applicative, Eq, Eval, Functor, Show, Traverse}
-import cats.kernel.laws.discipline.{EqTests, HashTests, PartialOrderTests}
+import cats.kernel.laws.discipline.{EqTests, PartialOrderTests}
 import cats.syntax.all._
 import cats.tests.CatsSuite
 
@@ -46,7 +46,8 @@ class FreeStructuralSuite extends CatsSuite {
 
   Show[Free[Option, Int]]
 
-  checkAll("Free[Option, Int]", HashTests[Free[Option, Int]].hash)
+  // TODO HashLaws#sameAsUniversalHash is really dodgy
+  // checkAll("Free[Option, Int]", HashTests[Free[Option, Int]].hash)
   checkAll("Free[Option, Int]", PartialOrderTests[Free[Option, Int]].partialOrder)
   checkAll("Free[ExprF, String]", EqTests[Free[ExprF, String]].eqv)
 }
diff --git a/kernel-laws/shared/src/main/scala/cats/kernel/laws/HashLaws.scala b/kernel-laws/shared/src/main/scala/cats/kernel/laws/HashLaws.scala
index 346d031b8..c7107c6fd 100644
--- a/kernel-laws/shared/src/main/scala/cats/kernel/laws/HashLaws.scala
+++ b/kernel-laws/shared/src/main/scala/cats/kernel/laws/HashLaws.scala
@@ -30,12 +30,10 @@ trait HashLaws[A] extends EqLaws[A] {
   def hashCompatibility(x: A, y: A): IsEq[Boolean] =
     (!E.eqv(x, y) || (Hash.hash(x) == Hash.hash(y))) <-> true
 
-  @deprecated("This law is no longer enforced", "2.9.0")
   def sameAsUniversalHash(x: A, y: A): IsEq[Boolean] =
     ((E.hash(x) == x.hashCode) && (Hash.fromUniversalHashCode[A].hash(x) == x.hashCode()) &&
       (E.eqv(x, y) == Hash.fromUniversalHashCode[A].eqv(x, y))) <-> true
 
-  @deprecated("This law is no longer enforced", "2.9.0")
   def sameAsScalaHashing(x: A, y: A, scalaHashing: Hashing[A]): IsEq[Boolean] =
     ((E.hash(x) == Hash.fromHashing(scalaHashing).hash(x)) &&
       (E.eqv(x, y) == Hash.fromHashing(scalaHashing).eqv(x, y))) <-> true
diff --git a/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/HashTests.scala b/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/HashTests.scala
index b4aeb0989..160cee00f 100644
--- a/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/HashTests.scala
+++ b/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/HashTests.scala
@@ -38,7 +38,9 @@ trait HashTests[A] extends EqTests[A] {
     new DefaultRuleSet(
       "hash",
       Some(eqv),
-      "hash compatibility" -> forAll(laws.hashCompatibility _)
+      "hash compatibility" -> forAll(laws.hashCompatibility _),
+      "same as universal hash" -> forAll(laws.sameAsUniversalHash _),
+      "same as scala hashing" -> forAll((x: A, y: A) => laws.sameAsScalaHashing(x, y, hashA))
     )
 
 }
diff --git a/tests/shared/src/test/scala/cats/tests/FunctionSuite.scala b/tests/shared/src/test/scala/cats/tests/FunctionSuite.scala
index 4be40b092..e807c0d35 100644
--- a/tests/shared/src/test/scala/cats/tests/FunctionSuite.scala
+++ b/tests/shared/src/test/scala/cats/tests/FunctionSuite.scala
@@ -36,6 +36,7 @@ import cats.{
 }
 import cats.arrow.{ArrowChoice, Choice, CommutativeArrow}
 import cats.kernel._
+import cats.kernel.laws.HashLaws
 import cats.kernel.laws.discipline.{
   BandTests,
   BoundedSemilatticeTests,
@@ -44,7 +45,6 @@ import cats.kernel.laws.discipline.{
   CommutativeSemigroupTests,
   EqTests,
   GroupTests,
-  HashTests,
   MonoidTests,
   OrderTests,
   PartialOrderTests,
@@ -136,7 +136,12 @@ class FunctionSuite extends CatsSuite {
   checkAll("Function0[Grp]", GroupTests[Function0[Grp]].group)
   checkAll("Function0[CGrp]", CommutativeGroupTests[Function0[CGrp]].commutativeGroup)
   checkAll("Function0[Distributive]", DistributiveTests[Function0].distributive[Int, Int, Int, Id, Function0])
-  checkAll("Function0[Hsh]", HashTests[Function0[Hsh]].hash)
+
+  property("Function0[Hsh]") {
+    forAll { (x: Function0[Hsh], y: Function0[Hsh]) =>
+      HashLaws[Function0[Hsh]].hashCompatibility(x, y)
+    }
+  }
 
   // Test for Arrow applicative
   Applicative[String => *]
