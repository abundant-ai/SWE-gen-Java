diff --git a/core/src/main/scala/cats/TraverseFilter.scala b/core/src/main/scala/cats/TraverseFilter.scala
index 9f2d00ec7..59e84ba22 100644
--- a/core/src/main/scala/cats/TraverseFilter.scala
+++ b/core/src/main/scala/cats/TraverseFilter.scala
@@ -23,7 +23,7 @@ package cats
 
 import cats.data.State
 
-import scala.collection.immutable.{HashSet, TreeSet}
+import scala.collection.immutable.{IntMap, TreeSet}
 
 /**
  * `TraverseFilter`, also known as `Witherable`, represents list-like structures
@@ -141,12 +141,19 @@ trait TraverseFilter[F[_]] extends FunctorFilter[F] {
    * This is usually faster than ordDistinct, especially for things that have a slow comparion (like String).
    */
   def hashDistinct[A](fa: F[A])(implicit H: Hash[A]): F[A] =
-    traverseFilter[State[HashSet[A], *], A, A](fa)(a =>
-      State(alreadyIn => if (alreadyIn(a)) (alreadyIn, None) else (alreadyIn + a, Some(a)))
-    )
-      .run(HashSet.empty)
-      .value
-      ._2
+    traverseFilter(fa) { a =>
+      State { (distinct: IntMap[List[A]]) =>
+        val ahash = H.hash(a)
+        distinct.get(ahash) match {
+          case None => (distinct.updated(ahash, a :: Nil), Some(a))
+          case Some(existing) =>
+            if (Traverse[List].contains_(existing, a))
+              (distinct, None)
+            else
+              (distinct.updated(ahash, a :: existing), Some(a))
+        }
+      }
+    }.run(IntMap.empty).value._2
 }
 
 object TraverseFilter {
diff --git a/kernel-laws/shared/src/main/scala/cats/kernel/laws/HashLaws.scala b/kernel-laws/shared/src/main/scala/cats/kernel/laws/HashLaws.scala
index c7107c6fd..346d031b8 100644
--- a/kernel-laws/shared/src/main/scala/cats/kernel/laws/HashLaws.scala
+++ b/kernel-laws/shared/src/main/scala/cats/kernel/laws/HashLaws.scala
@@ -30,10 +30,12 @@ trait HashLaws[A] extends EqLaws[A] {
   def hashCompatibility(x: A, y: A): IsEq[Boolean] =
     (!E.eqv(x, y) || (Hash.hash(x) == Hash.hash(y))) <-> true
 
+  @deprecated("This law is no longer enforced", "2.9.0")
   def sameAsUniversalHash(x: A, y: A): IsEq[Boolean] =
     ((E.hash(x) == x.hashCode) && (Hash.fromUniversalHashCode[A].hash(x) == x.hashCode()) &&
       (E.eqv(x, y) == Hash.fromUniversalHashCode[A].eqv(x, y))) <-> true
 
+  @deprecated("This law is no longer enforced", "2.9.0")
   def sameAsScalaHashing(x: A, y: A, scalaHashing: Hashing[A]): IsEq[Boolean] =
     ((E.hash(x) == Hash.fromHashing(scalaHashing).hash(x)) &&
       (E.eqv(x, y) == Hash.fromHashing(scalaHashing).eqv(x, y))) <-> true
diff --git a/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/HashTests.scala b/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/HashTests.scala
index 160cee00f..b4aeb0989 100644
--- a/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/HashTests.scala
+++ b/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/HashTests.scala
@@ -38,9 +38,7 @@ trait HashTests[A] extends EqTests[A] {
     new DefaultRuleSet(
       "hash",
       Some(eqv),
-      "hash compatibility" -> forAll(laws.hashCompatibility _),
-      "same as universal hash" -> forAll(laws.sameAsUniversalHash _),
-      "same as scala hashing" -> forAll((x: A, y: A) => laws.sameAsScalaHashing(x, y, hashA))
+      "hash compatibility" -> forAll(laws.hashCompatibility _)
     )
 
 }
