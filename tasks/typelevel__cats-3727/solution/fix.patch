diff --git a/core/src/main/scala/cats/Foldable.scala b/core/src/main/scala/cats/Foldable.scala
index 688dc79cb..71b847e5e 100644
--- a/core/src/main/scala/cats/Foldable.scala
+++ b/core/src/main/scala/cats/Foldable.scala
@@ -30,7 +30,7 @@ import scala.annotation.implicitNotFound
  * See: [[http://www.cs.nott.ac.uk/~pszgmh/fold.pdf A tutorial on the universality and expressiveness of fold]]
  */
 @implicitNotFound("Could not find an instance of Foldable for ${F}")
-@typeclass trait Foldable[F[_]] extends UnorderedFoldable[F] { self =>
+@typeclass trait Foldable[F[_]] extends UnorderedFoldable[F] with FoldableNFunctions[F] { self =>
 
   /**
    * Left associative fold on 'F' using the function 'f'.
diff --git a/core/src/main/scala/cats/syntax/foldable.scala b/core/src/main/scala/cats/syntax/foldable.scala
index 78fed4ee7..9bd3c351f 100644
--- a/core/src/main/scala/cats/syntax/foldable.scala
+++ b/core/src/main/scala/cats/syntax/foldable.scala
@@ -283,6 +283,32 @@ final class FoldableOps0[F[_], A](private val fa: F[A]) extends AnyVal {
     f: A => G[Either[B, C]]
   )(implicit A: Alternative[F], F: Foldable[F], M: Monad[G]): G[(F[B], F[C])] =
     F.partitionEitherM[G, A, B, C](fa)(f)(A, M)
+
+  def sliding2(implicit F: Foldable[F]): List[(A, A)] = F.sliding2(fa)
+  def sliding3(implicit F: Foldable[F]): List[(A, A, A)] = F.sliding3(fa)
+  def sliding4(implicit F: Foldable[F]): List[(A, A, A, A)] = F.sliding4(fa)
+  def sliding5(implicit F: Foldable[F]): List[(A, A, A, A, A)] = F.sliding5(fa)
+  def sliding6(implicit F: Foldable[F]): List[(A, A, A, A, A, A)] = F.sliding6(fa)
+  def sliding7(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A)] = F.sliding7(fa)
+  def sliding8(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A)] = F.sliding8(fa)
+  def sliding9(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A)] = F.sliding9(fa)
+  def sliding10(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A)] = F.sliding10(fa)
+  def sliding11(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A)] = F.sliding11(fa)
+  def sliding12(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A)] = F.sliding12(fa)
+  def sliding13(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A)] = F.sliding13(fa)
+  def sliding14(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A, A)] = F.sliding14(fa)
+  def sliding15(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)] = F.sliding15(fa)
+  def sliding16(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)] = F.sliding16(fa)
+  def sliding17(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)] = F.sliding17(fa)
+  def sliding18(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)] = F.sliding18(fa)
+  def sliding19(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)] =
+    F.sliding19(fa)
+  def sliding20(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)] =
+    F.sliding20(fa)
+  def sliding21(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)] =
+    F.sliding21(fa)
+  def sliding22(implicit F: Foldable[F]): List[(A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A, A)] =
+    F.sliding22(fa)
 }
 
 @deprecated("Use methods on Foldable", "2.1.0-RC1")
diff --git a/project/Boilerplate.scala b/project/Boilerplate.scala
index 338789542..e2100d1f5 100644
--- a/project/Boilerplate.scala
+++ b/project/Boilerplate.scala
@@ -28,7 +28,8 @@ object Boilerplate {
     GenTupleSemigroupalSyntax,
     GenParallelArityFunctions,
     GenParallelArityFunctions2,
-    GenTupleParallelSyntax
+    GenTupleParallelSyntax,
+    GenFoldableArityFunctions
   )
 
   val header = "// auto-generated boilerplate by /project/Boilerplate.scala" // TODO: put something meaningful here?
@@ -503,4 +504,59 @@ object Boilerplate {
     }
   }
 
+  object GenFoldableArityFunctions extends Template {
+    def filename(root: File) = root / "cats" / "FoldableNFunctions.scala"
+    override def range = 2 to maxArity
+    def content(tv: TemplateVals) = {
+      import tv._
+
+      val tupleTpe = (1 to arity).map(_ => "A").mkString("(", ", ", ")")
+      def listXN(range: Range) = range.map("x" + _).mkString(" :: ")
+      val reverseXN = listXN(1 to arity - 1)
+      val tupleXN = (1 to arity).map("x" + _).mkString("(", ", ", ")")
+
+      block"""
+      |package cats
+      |
+      |/**
+      | * @groupprio Ungrouped 0
+      | *
+      | * @groupname FoldableSlidingN foldable arity
+      | * @groupdesc FoldableSlidingN
+      | *   Group sequential elements into fixed sized tuples by passing a "sliding window" over them.
+      | * 
+      | *   A foldable with fewer elements than the window size will return an empty list unlike `Iterable#sliding(size: Int)`.
+      | *   Example:
+      | *   {{{
+      | *   import cats.Foldable
+      | *   scala> Foldable[List].sliding2((1 to 10).toList)
+      | *   val res0: List[(Int, Int)] = List((1,2), (2,3), (3,4), (4,5), (5,6), (6,7), (7,8), (8,9), (9,10))
+      | *
+      | *   scala> Foldable[List].sliding4((1 to 10).toList)
+      | *   val res1: List[(Int, Int, Int, Int)] = List((1,2,3,4), (2,3,4,5), (3,4,5,6), (4,5,6,7), (5,6,7,8), (6,7,8,9), (7,8,9,10))
+      | *   
+      | *   scala> Foldable[List].sliding4((1 to 2).toList)
+      | *   val res2: List[(Int, Int, Int, Int)] = List()
+      | *
+      | *   }}}
+      | *   
+      | * @groupprio FoldableSlidingN 999
+      | *
+      | */
+      |trait FoldableNFunctions[F[_]] { self: Foldable[F] =>
+        -  /** @group FoldableSlidingN */
+        -  def sliding$arity[A](fa: F[A]): List[$tupleTpe] =
+        -    foldRight(fa, Now((List.empty[$tupleTpe], List.empty[A]))) { (x1, eval) =>
+        -      val (acc, l) = eval.value
+        -      l match {
+        -        case ${listXN(2 to arity)} :: Nil =>
+        -          Now(($tupleXN :: acc, ${listXN(1 to arity - 1)} :: Nil))
+        -        case l =>
+        -          Now((acc, x1 :: l))
+        -      }
+        -    }.value._1
+      |}
+      """
+    }
+  }
 }
