diff --git a/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java b/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
index dd64b8ec..6362d015 100644
--- a/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
@@ -47,11 +47,10 @@ final class BufferedSourceJsonReader extends JsonReader {
   private static final int PEEKED_SINGLE_QUOTED_NAME = 12;
   private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;
   private static final int PEEKED_UNQUOTED_NAME = 14;
-  private static final int PEEKED_BUFFERED_NAME = 15;
   /** When this is returned, the integer value is stored in peekedLong. */
-  private static final int PEEKED_LONG = 16;
-  private static final int PEEKED_NUMBER = 17;
-  private static final int PEEKED_EOF = 18;
+  private static final int PEEKED_LONG = 15;
+  private static final int PEEKED_NUMBER = 16;
+  private static final int PEEKED_EOF = 17;
 
   /* State machine when parsing numbers */
   private static final int NUMBER_CHAR_NONE = 0;
@@ -99,7 +98,6 @@ final class BufferedSourceJsonReader extends JsonReader {
   // StackOverflowErrors.
   private final int[] stack = new int[32];
   private int stackSize = 0;
-
   {
     stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
   }
@@ -217,7 +215,6 @@ final class BufferedSourceJsonReader extends JsonReader {
       case PEEKED_SINGLE_QUOTED_NAME:
       case PEEKED_DOUBLE_QUOTED_NAME:
       case PEEKED_UNQUOTED_NAME:
-      case PEEKED_BUFFERED_NAME:
         return Token.NAME;
       case PEEKED_TRUE:
       case PEEKED_FALSE:
@@ -548,8 +545,6 @@ final class BufferedSourceJsonReader extends JsonReader {
       result = nextQuotedValue(DOUBLE_QUOTE_OR_SLASH);
     } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
       result = nextQuotedValue(SINGLE_QUOTE_OR_SLASH);
-    } else if (p == PEEKED_BUFFERED_NAME) {
-      result = peekedString;
     } else {
       throw new JsonDataException("Expected a name but was " + peek() + " at path " + getPath());
     }
@@ -558,12 +553,12 @@ final class BufferedSourceJsonReader extends JsonReader {
     return result;
   }
 
-  @Override public int selectName(Options options) throws IOException {
+  @Override int selectName(Options options) throws IOException {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
     }
-    if (p  < PEEKED_SINGLE_QUOTED_NAME || p > PEEKED_BUFFERED_NAME) {
+    if (p != PEEKED_DOUBLE_QUOTED_NAME) {
       return -1;
     }
 
@@ -571,30 +566,8 @@ final class BufferedSourceJsonReader extends JsonReader {
     if (result != -1) {
       peeked = PEEKED_NONE;
       pathNames[stackSize - 1] = options.strings[result];
-
-      return result;
     }
-
-    // The next name may be unnecessary escaped. Save the last recorded path name, so that we
-    // can restore the peek state in case we fail to find a match.
-    String lastPathName = pathNames[stackSize - 1];
-
-    String nextName = nextName();
-    for (int i = 0, size = options.strings.length; i < size; i++) {
-      if (nextName.equals(options.strings[i])) {
-        peeked = PEEKED_NONE;
-        pathNames[stackSize - 1] = nextName;
-
-        return i;
-      }
-    }
-
-    peeked = PEEKED_BUFFERED_NAME;
-    peekedString = nextName;
-    // We can't push the path further, make it seem like nothing happened.
-    pathNames[stackSize - 1] = lastPathName;
-
-    return -1;
+    return result;
   }
 
   @Override public String nextString() throws IOException {
@@ -624,12 +597,12 @@ final class BufferedSourceJsonReader extends JsonReader {
     return result;
   }
 
-  @Override public int selectString(Options options) throws IOException {
+  @Override int selectString(Options options) throws IOException {
     int p = peeked;
     if (p == PEEKED_NONE) {
       p = doPeek();
     }
-    if (p < PEEKED_SINGLE_QUOTED || p > PEEKED_BUFFERED) {
+    if (p != PEEKED_DOUBLE_QUOTED) {
       return -1;
     }
 
@@ -637,25 +610,8 @@ final class BufferedSourceJsonReader extends JsonReader {
     if (result != -1) {
       peeked = PEEKED_NONE;
       pathIndices[stackSize - 1]++;
-
-      return result;
-    }
-
-    String nextString = nextString();
-    for (int i = 0, size = options.strings.length; i < size; i++) {
-      if (nextString.equals(options.strings[i])) {
-        peeked = PEEKED_NONE;
-        pathIndices[stackSize - 1]++;
-
-        return i;
-      }
     }
-
-    peeked = PEEKED_BUFFERED;
-    peekedString = nextString;
-    pathIndices[stackSize - 1]--;
-
-    return -1;
+    return result;
   }
 
   @Override public boolean nextBoolean() throws IOException {
@@ -1039,7 +995,7 @@ final class BufferedSourceJsonReader extends JsonReader {
    */
   private boolean skipTo(String toFind) throws IOException {
     outer:
-    for (; source.request(toFind.length()); ) {
+    for (; source.request(toFind.length());) {
       for (int c = 0; c < toFind.length(); c++) {
         if (buffer.getByte(c) != toFind.charAt(c)) {
           buffer.readByte();
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index b3ee721b..7592ad7c 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -274,7 +274,7 @@ public abstract class JsonReader implements Closeable {
    * If the next token is a {@linkplain Token#NAME property name} that's in {@code options}, this
    * consumes it and returns its index. Otherwise this returns -1 and no name is consumed.
    */
-  public abstract int selectName(Options options) throws IOException;
+  abstract int selectName(Options options) throws IOException;
 
   /**
    * Returns the {@linkplain Token#STRING string} value of the next token, consuming it. If the next
@@ -288,7 +288,7 @@ public abstract class JsonReader implements Closeable {
    * If the next token is a {@linkplain Token#STRING string} that's in {@code options}, this
    * consumes it and returns its index. Otherwise this returns -1 and no string is consumed.
    */
-  public abstract int selectString(Options options) throws IOException;
+  abstract int selectString(Options options) throws IOException;
 
   /**
    * Returns the {@linkplain Token#BOOLEAN boolean} value of the next token, consuming it.
@@ -359,9 +359,13 @@ public abstract class JsonReader implements Closeable {
 
   /**
    * A set of strings to be chosen with {@link #selectName} or {@link #selectString}. This prepares
-   * the encoded values of the strings so they can be read directly from the input source.
+   * the encoded values of the strings so they can be read directly from the input source. It cannot
+   * read arbitrary encodings of the strings: if any of a string's characters are unnecessarily
+   * escaped in the source JSON, that string will not be selected. Similarly, if the string is
+   * unquoted or uses single quotes in the source JSON, it will not be selected. Client code that
+   * uses this class should fall back to another mechanism to accommodate this possibility.
    */
-  public static final class Options {
+  static final class Options {
     final String[] strings;
     final okio.Options doubleQuoteSuffix;
 
diff --git a/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java b/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java
index 090b5851..41fe0782 100644
--- a/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/ObjectJsonReader.java
@@ -158,7 +158,7 @@ final class ObjectJsonReader extends JsonReader {
     return result;
   }
 
-  @Override public int selectName(Options options) throws IOException {
+  @Override int selectName(Options options) throws IOException {
     Map.Entry<?, ?> peeked = require(Map.Entry.class, Token.NAME);
     String name = stringKey(peeked);
     for (int i = 0, length = options.strings.length; i < length; i++) {
@@ -178,7 +178,7 @@ final class ObjectJsonReader extends JsonReader {
     return peeked;
   }
 
-  @Override public int selectString(Options options) throws IOException {
+  @Override int selectString(Options options) throws IOException {
     String peeked = require(String.class, Token.STRING);
     for (int i = 0, length = options.strings.length; i < length; i++) {
       if (options.strings[i].equals(peeked)) {
diff --git a/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java b/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java
index 9d734d8e..a1dd9352 100644
--- a/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java
@@ -1161,12 +1161,9 @@ public final class BufferedSourceJsonReaderTest {
     assertDocument("{\"name\":,", BEGIN_OBJECT, NAME, JsonEncodingException.class);
     assertDocument("{\"name\"=}", BEGIN_OBJECT, NAME, JsonEncodingException.class);
     assertDocument("{\"name\"=>}", BEGIN_OBJECT, NAME, JsonEncodingException.class);
-    assertDocument("{\"name\"=>\"string\":", BEGIN_OBJECT, NAME, STRING,
-        JsonEncodingException.class);
-    assertDocument("{\"name\"=>\"string\"=", BEGIN_OBJECT, NAME, STRING,
-        JsonEncodingException.class);
-    assertDocument("{\"name\"=>\"string\"=>", BEGIN_OBJECT, NAME, STRING,
-        JsonEncodingException.class);
+    assertDocument("{\"name\"=>\"string\":", BEGIN_OBJECT, NAME, STRING, JsonEncodingException.class);
+    assertDocument("{\"name\"=>\"string\"=", BEGIN_OBJECT, NAME, STRING, JsonEncodingException.class);
+    assertDocument("{\"name\"=>\"string\"=>", BEGIN_OBJECT, NAME, STRING, JsonEncodingException.class);
     assertDocument("{\"name\"=>\"string\",", BEGIN_OBJECT, NAME, STRING, EOFException.class);
     assertDocument("{\"name\"=>\"string\",\"name\"", BEGIN_OBJECT, NAME, STRING, NAME);
     assertDocument("[}", BEGIN_ARRAY, JsonEncodingException.class);
@@ -1227,6 +1224,41 @@ public final class BufferedSourceJsonReaderTest {
     assertThat(reader.nextString()).isEqualTo("string");
   }
 
+  /** Select doesn't match unquoted strings. */
+  @Test public void selectStringUnquoted() throws IOException {
+    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
+
+    JsonReader reader = newReader("[a]");
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals(-1, reader.selectString(abc));
+    assertEquals("a", reader.nextString());
+    reader.endArray();
+  }
+
+  /** Select doesn't match single quoted strings. */
+  @Test public void selectStringSingleQuoted() throws IOException {
+    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
+
+    JsonReader reader = newReader("['a']");
+    reader.setLenient(true);
+    reader.beginArray();
+    assertEquals(-1, reader.selectString(abc));
+    assertEquals("a", reader.nextString());
+    reader.endArray();
+  }
+
+  /** Select doesn't match unnecessarily-escaped strings. */
+  @Test public void selectUnnecessaryEscaping() throws IOException {
+    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
+
+    JsonReader reader = newReader("[\"\\u0061\"]");
+    reader.beginArray();
+    assertEquals(-1, reader.selectString(abc));
+    assertEquals("a", reader.nextString());
+    reader.endArray();
+  }
+
   private void assertDocument(String document, Object... expectations) throws IOException {
     JsonReader reader = newReader(document);
     reader.setLenient(true);
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonReaderFactory.java b/moshi/src/test/java/com/squareup/moshi/JsonReaderFactory.java
index 21db1c5c..8b2cc466 100644
--- a/moshi/src/test/java/com/squareup/moshi/JsonReaderFactory.java
+++ b/moshi/src/test/java/com/squareup/moshi/JsonReaderFactory.java
@@ -26,6 +26,10 @@ abstract class JsonReaderFactory {
       Buffer buffer = new Buffer().writeUtf8(json);
       return JsonReader.of(buffer);
     }
+
+    @Override public String toString() {
+      return "BufferedSourceJsonReader";
+    }
   };
 
   public static final JsonReaderFactory JSON_OBJECT = new JsonReaderFactory() {
@@ -34,6 +38,10 @@ abstract class JsonReaderFactory {
       Object object = moshi.adapter(Object.class).lenient().fromJson(json);
       return new ObjectJsonReader(object);
     }
+
+    @Override public String toString() {
+      return "ObjectJsonReader";
+    }
   };
 
   static List<Object[]> factories() {
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java b/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java
index b8c3a060..db56a7eb 100644
--- a/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java
@@ -28,7 +28,6 @@ import static com.squareup.moshi.JsonReader.Token.BEGIN_ARRAY;
 import static com.squareup.moshi.JsonReader.Token.BEGIN_OBJECT;
 import static com.squareup.moshi.JsonReader.Token.NAME;
 import static com.squareup.moshi.JsonReader.Token.STRING;
-import static com.squareup.moshi.TestUtil.newReader;
 import static com.squareup.moshi.TestUtil.repeat;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertEquals;
@@ -691,78 +690,6 @@ public final class JsonReaderTest {
     reader.endObject();
   }
 
-  /** Select does match necessarily escaping. The decoded value is used in the path. */
-  @Test public void selectNameNecessaryEscaping() throws IOException {
-    JsonReader.Options options = JsonReader.Options.of("\n", "\u0000", "\"");
-
-    JsonReader reader = newReader("{\"\\n\": 5,\"\\u0000\": 5, \"\\\"\": 5}");
-    reader.beginObject();
-    assertEquals(0, reader.selectName(options));
-    assertEquals(5, reader.nextInt());
-    assertEquals("$.\n", reader.getPath());
-    assertEquals(1, reader.selectName(options));
-    assertEquals(5, reader.nextInt());
-    assertEquals("$.\u0000", reader.getPath());
-    assertEquals(2, reader.selectName(options));
-    assertEquals(5, reader.nextInt());
-    assertEquals("$.\"", reader.getPath());
-    reader.endObject();
-  }
-
-  /** Select removes unnecessary escaping from the source JSON. */
-  @Test public void selectNameUnnecessaryEscaping() throws IOException {
-    JsonReader.Options options = JsonReader.Options.of("coffee", "tea");
-
-    JsonReader reader = newReader("{\"cof\\u0066ee\":5, \"\\u0074e\\u0061\":4, \"water\":3}");
-    reader.beginObject();
-    assertEquals(0, reader.selectName(options));
-    assertEquals(5, reader.nextInt());
-    assertEquals("$.coffee", reader.getPath());
-    assertEquals(1, reader.selectName(options));
-    assertEquals(4, reader.nextInt());
-    assertEquals("$.tea", reader.getPath());
-
-    // Ensure select name doesn't advance the stack in case there are no matches.
-    assertEquals(-1, reader.selectName(options));
-    assertEquals(JsonReader.Token.NAME, reader.peek());
-    assertEquals("$.tea", reader.getPath());
-
-    // Consume the last token.
-    assertEquals("water", reader.nextName());
-    assertEquals(3, reader.nextInt());
-    reader.endObject();
-  }
-
-  @Test public void selectNameUnquoted() throws Exception {
-    JsonReader.Options options = JsonReader.Options.of("a", "b");
-
-    JsonReader reader = newReader("{a:2}");
-    reader.setLenient(true);
-    reader.beginObject();
-
-    assertEquals(0, reader.selectName(options));
-    assertEquals("$.a", reader.getPath());
-    assertEquals(2, reader.nextInt());
-    assertEquals("$.a", reader.getPath());
-
-    reader.endObject();
-  }
-
-  @Test public void selectNameSingleQuoted() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b");
-
-    JsonReader reader = newReader("{'a':5}");
-    reader.setLenient(true);
-    reader.beginObject();
-
-    assertEquals(0, reader.selectName(abc));
-    assertEquals("$.a", reader.getPath());
-    assertEquals(5, reader.nextInt());
-    assertEquals("$.a", reader.getPath());
-
-    reader.endObject();
-  }
-
   @Test public void selectString() throws IOException {
     JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
 
@@ -790,64 +717,22 @@ public final class JsonReaderTest {
     reader.endArray();
   }
 
-  @Test public void selectStringNecessaryEscaping() throws Exception {
+  /** Select does match necessarily escaping. The decoded value is used in the path. */
+  @Test public void selectNecessaryEscaping() throws IOException {
     JsonReader.Options options = JsonReader.Options.of("\n", "\u0000", "\"");
 
-    JsonReader reader = newReader("[\"\\n\",\"\\u0000\", \"\\\"\"]");
-    reader.beginArray();
-    assertEquals(0, reader.selectString(options));
-    assertEquals(1, reader.selectString(options));
-    assertEquals(2, reader.selectString(options));
-    reader.endArray();
-  }
-
-  /** Select strips unnecessarily-escaped strings. */
-  @Test public void selectStringUnnecessaryEscaping() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
-
-    JsonReader reader = newReader("[\"\\u0061\", \"b\", \"\\u0063\"]");
-    reader.beginArray();
-    assertEquals(0, reader.selectString(abc));
-    assertEquals(1, reader.selectString(abc));
-    assertEquals(2, reader.selectString(abc));
-    reader.endArray();
-  }
-
-  @Test public void selectStringUnquoted() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
-
-    JsonReader reader = newReader("[a, \"b\", c]");
-    reader.setLenient(true);
-    reader.beginArray();
-    assertEquals(0, reader.selectString(abc));
-    assertEquals(1, reader.selectString(abc));
-    assertEquals(2, reader.selectString(abc));
-    reader.endArray();
-  }
-
-  @Test public void selectStringSingleQuoted() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
-
-    JsonReader reader = newReader("['a', \"b\", c]");
-    reader.setLenient(true);
-    reader.beginArray();
-    assertEquals(0, reader.selectString(abc));
-    assertEquals(1, reader.selectString(abc));
-    assertEquals(2, reader.selectString(abc));
-    reader.endArray();
-  }
-
-  @Test public void selectStringMaintainsReaderState() throws IOException {
-    JsonReader.Options abc = JsonReader.Options.of("a", "b", "c");
-
-    JsonReader reader = newReader("[\"\\u0061\", \"42\"]");
-    reader.beginArray();
-    assertEquals(0, reader.selectString(abc));
-    assertEquals(-1, reader.selectString(abc));
-    assertEquals(JsonReader.Token.STRING, reader.peek());
-    // Next long can retrieve a value from a buffered string.
-    assertEquals(42, reader.nextLong());
-    reader.endArray();
+    JsonReader reader = newReader("{\"\\n\": 5,\"\\u0000\": 5, \"\\\"\": 5}");
+    reader.beginObject();
+    assertEquals(0, reader.selectName(options));
+    assertEquals(5, reader.nextInt());
+    assertEquals("$.\n", reader.getPath());
+    assertEquals(1, reader.selectName(options));
+    assertEquals(5, reader.nextInt());
+    assertEquals("$.\u0000", reader.getPath());
+    assertEquals(2, reader.selectName(options));
+    assertEquals(5, reader.nextInt());
+    assertEquals("$.\"", reader.getPath());
+    reader.endObject();
   }
 
   @Test public void stringToNumberCoersion() throws Exception {
