diff --git a/core-processor/src/main/java/io/micronaut/inject/annotation/AbstractAnnotationMetadataBuilder.java b/core-processor/src/main/java/io/micronaut/inject/annotation/AbstractAnnotationMetadataBuilder.java
index 6acce22873..4e5f1ddd05 100644
--- a/core-processor/src/main/java/io/micronaut/inject/annotation/AbstractAnnotationMetadataBuilder.java
+++ b/core-processor/src/main/java/io/micronaut/inject/annotation/AbstractAnnotationMetadataBuilder.java
@@ -1578,6 +1578,8 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
 
     /**
      * Used to clear mutated metadata at the end of a compilation cycle.
+     *
+     * @param key The key
      */
     @Internal
     public static void clearMutated(@NonNull Object key) {
diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/ClassElement.java b/core-processor/src/main/java/io/micronaut/inject/ast/ClassElement.java
index 07d33ab206..60d1960574 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/ClassElement.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/ClassElement.java
@@ -101,6 +101,17 @@ public interface ClassElement extends TypedElement {
         return false;
     }
 
+    /**
+     *
+     * @param kind The kind of error
+     * @return Whether errors are present in the type element.
+     * @since 4.7.18
+     */
+    @Experimental
+    default boolean hasUnresolvedTypes(UnresolvedTypeKind... kind) {
+        return false;
+    }
+
     /**
      * @return Whether this is a generic placeholder.
      * @see GenericPlaceholderElement
diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/UnresolvedTypeKind.java b/core-processor/src/main/java/io/micronaut/inject/ast/UnresolvedTypeKind.java
new file mode 100644
index 0000000000..65fce3c521
--- /dev/null
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/UnresolvedTypeKind.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2017-2025 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.inject.ast;
+
+import io.micronaut.core.annotation.Experimental;
+
+/**
+ * Used in conjunction with {@link ClassElement#hasUnresolvedTypes(UnresolvedTypeKind...)} to support
+ * checking whether a type has unresolved type references.
+ *
+ * <p>Currently only checking the interface and class hierarchy is supported but this enum could be extended further
+ * in the future to support other cases.
+ * </p>
+ *
+ * @since 4.7.18
+ * @see ClassElement#hasUnresolvedTypes(UnresolvedTypeKind...)
+ */
+@Experimental
+public enum UnresolvedTypeKind {
+    /**
+     * An interface type reference.
+     */
+    INTERFACE,
+    /**
+     * A super class type reference.
+     */
+    SUPERCLASS
+}
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java b/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java
index f8c531a325..0c28b0d290 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java
@@ -37,7 +37,6 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/BeanDefinitionInjectProcessor.java b/inject-java/src/main/java/io/micronaut/annotation/processing/BeanDefinitionInjectProcessor.java
index 54d464c87e..ced60e6b8d 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/BeanDefinitionInjectProcessor.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/BeanDefinitionInjectProcessor.java
@@ -24,6 +24,7 @@ import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Vetoed;
 import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.util.CollectionUtils;
+import io.micronaut.inject.ast.UnresolvedTypeKind;
 import io.micronaut.inject.ast.annotation.ElementAnnotationMetadataFactory;
 import io.micronaut.inject.processing.BeanDefinitionCreator;
 import io.micronaut.inject.processing.BeanDefinitionCreatorFactory;
@@ -184,6 +185,14 @@ public class BeanDefinitionInjectProcessor extends AbstractInjectAnnotationProce
                             if (classElement.hasAnnotation(Vetoed.class) || classElement.getPackage().hasAnnotation(Vetoed.class)) {
                                 continue;
                             }
+
+                            if (!postponed.containsKey(classElement.getName()) && // don't throw again if it was already postponed
+                                classElement.hasUnresolvedTypes(UnresolvedTypeKind.INTERFACE, UnresolvedTypeKind.SUPERCLASS)) {
+                                throw new PostponeToNextRoundException(
+                                    classElement.getNativeType().element(),
+                                    classElement.getName()
+                                );
+                            }
                             BeanDefinitionCreator beanDefinitionCreator = BeanDefinitionCreatorFactory.produce(classElement, javaVisitorContext);
                             for (BeanDefinitionVisitor writer : beanDefinitionCreator.build()) {
                                 if (processed.contains(writer.getBeanDefinitionName())) {
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
index ba6ec0721e..f25af484a9 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
@@ -36,6 +36,7 @@ import io.micronaut.inject.ast.PackageElement;
 import io.micronaut.inject.ast.ParameterElement;
 import io.micronaut.inject.ast.PropertyElement;
 import io.micronaut.inject.ast.PropertyElementQuery;
+import io.micronaut.inject.ast.UnresolvedTypeKind;
 import io.micronaut.inject.ast.annotation.ElementAnnotationMetadata;
 import io.micronaut.inject.ast.annotation.ElementAnnotationMetadataFactory;
 import io.micronaut.inject.ast.annotation.MutableAnnotationMetadataDelegate;
@@ -189,6 +190,32 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
         return classElement.getQualifiedName().toString();
     }
 
+    @Override
+    public boolean hasUnresolvedTypes(UnresolvedTypeKind... kind) {
+        List<? extends TypeMirror> interfaces = this.classElement.getInterfaces();
+        for (UnresolvedTypeKind unresolvedTypeKind : kind) {
+            switch (unresolvedTypeKind) {
+                case INTERFACE -> {
+                    for (TypeMirror anInterface : interfaces) {
+                        if (anInterface.getKind() == TypeKind.ERROR) {
+                            return true;
+                        }
+                    }
+                }
+                case SUPERCLASS -> {
+                    TypeMirror superclass = this.classElement.getSuperclass();
+                    if (superclass.getKind() == TypeKind.ERROR) {
+                        return true;
+                    }
+                }
+                default -> {
+                    // no-op
+                }
+            }
+        }
+        return false;
+    }
+
     @Override
     public JavaNativeElement.@NonNull Class getNativeType() {
         return (JavaNativeElement.Class) super.getNativeType();
@@ -271,7 +298,9 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
     @Override
     public Collection<ClassElement> getInterfaces() {
         if (resolvedInterfaces == null) {
-            resolvedInterfaces = classElement.getInterfaces().stream().filter(this::onlyAvailable).map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
+            resolvedInterfaces = classElement.getInterfaces().stream()
+                .filter(this::onlyAvailable)
+                .map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
         }
         return resolvedInterfaces;
     }
