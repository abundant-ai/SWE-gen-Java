diff --git a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
index 7633261b4..e9ac67ac7 100644
--- a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
+++ b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
@@ -417,6 +417,27 @@ class NonEmptyLazyListOps[A](private val value: NonEmptyLazyList[A])
   final def groupByNem[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NonEmptyLazyList[A]] =
     NonEmptyMap.fromMapUnsafe(groupBy(f))
 
+  /**
+   * Partitions elements in fixed size `NonEmptyLazyList`s.
+   *
+   * {{{
+   * scala> import cats.data.NonEmptyLazyList
+   * scala> import cats.implicits._
+   * scala> val nel = NonEmptyLazyList.fromLazyListUnsafe(LazyList(12, -2, 3, -5))
+   * scala> val expectedResult = List(
+   *      |   NonEmptyLazyList.fromLazyListUnsafe(LazyList(12, -2)),
+   *      |   NonEmptyLazyList.fromLazyListUnsafe(LazyList(3, -5))
+   *      | )
+   * scala> val result = nel.grouped(2)
+   * scala> result.toList === expectedResult
+   * res0: Boolean = true
+   * }}}
+   */
+  def grouped(size: Int): Iterator[NonEmptyLazyList[A]] = {
+    require(size >= 1, f"size=$size%d, but size must be positive")
+    toLazyList.grouped(size).map(NonEmptyLazyList.fromLazyListUnsafe)
+  }
+
   /**
    * Creates new `NonEmptyMap`, similarly to List#toMap from scala standard library.
    * {{{
diff --git a/core/src/main/scala/cats/data/NonEmptyChain.scala b/core/src/main/scala/cats/data/NonEmptyChain.scala
index bcb32b579..6d0f53f6e 100644
--- a/core/src/main/scala/cats/data/NonEmptyChain.scala
+++ b/core/src/main/scala/cats/data/NonEmptyChain.scala
@@ -7,7 +7,7 @@ import scala.collection.immutable.SortedMap
 
 private[data] object NonEmptyChainImpl extends NonEmptyChainInstances with ScalaVersionSpecificNonEmptyChainImpl {
   // The following 3 types are components of a technique to
-  // create a no-boxing newtype. It's coped from the
+  // create a no-boxing newtype. It's copied from the
   // newtypes lib by @alexknvl
   // For more detail see https://github.com/alexknvl/newtypes
   private[data] type Base
@@ -397,6 +397,24 @@ class NonEmptyChainOps[A](private val value: NonEmptyChain[A])
   final def groupBy[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NonEmptyChain[A]] =
     toChain.groupBy(f).asInstanceOf[NonEmptyMap[B, NonEmptyChain[A]]]
 
+  /**
+   * Partitions elements in fixed size `NonEmptyChain`s.
+   *
+   * {{{
+   * scala> import cats.data.NonEmptyChain
+   * scala> import cats.implicits._
+   * scala> val nel = NonEmptyChain.of(12, -2, 3, -5)
+   * scala> val expectedResult = List(NonEmptyChain.of(12, -2), NonEmptyChain.of(3, -5))
+   * scala> val result = nel.grouped(2)
+   * scala> result.toList === expectedResult
+   * res0: Boolean = true
+   * }}}
+   */
+  final def grouped(size: Int): Iterator[NonEmptyChain[A]] = {
+    require(size >= 1, f"size=$size%d, but size must be positive")
+    toNonEmptyVector.grouped(size).map(NonEmptyChain.fromNonEmptyVector)
+  }
+
   /**
    * Groups elements inside this `NonEmptyChain` according to the `Order`
    * of the keys produced by the given mapping function.
diff --git a/core/src/main/scala/cats/data/NonEmptyCollection.scala b/core/src/main/scala/cats/data/NonEmptyCollection.scala
index eebef180a..5c8e4d562 100644
--- a/core/src/main/scala/cats/data/NonEmptyCollection.scala
+++ b/core/src/main/scala/cats/data/NonEmptyCollection.scala
@@ -33,6 +33,7 @@ private[cats] trait NonEmptyCollection[+A, U[+_], NE[+_]] extends Any {
   def sortBy[B](f: A => B)(implicit B: Order[B]): NE[A]
   def sorted[AA >: A](implicit AA: Order[AA]): NE[AA]
   def groupByNem[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NE[A]]
+  def grouped(size: Int): Iterator[NE[A]]
   def toNem[T, V](implicit ev: A <:< (T, V), order: Order[T]): NonEmptyMap[T, V]
   def toNes[B >: A](implicit order: Order[B]): NonEmptySet[B]
 
diff --git a/core/src/main/scala/cats/data/NonEmptyList.scala b/core/src/main/scala/cats/data/NonEmptyList.scala
index dc7d87275..26944c873 100644
--- a/core/src/main/scala/cats/data/NonEmptyList.scala
+++ b/core/src/main/scala/cats/data/NonEmptyList.scala
@@ -577,6 +577,24 @@ final case class NonEmptyList[+A](head: A, tail: List[A]) extends NonEmptyCollec
   ): NonEmptyMap[K, B] =
     NonEmptyMap.fromMapUnsafe(groupMapReduceWith(key)(f)(combine))
 
+  /**
+   * Partitions elements in fixed size `NonEmptyList`s.
+   *
+   * {{{
+   * scala> import cats.data.NonEmptyList
+   * scala> import cats.implicits._
+   * scala> val nel = NonEmptyList.of(12, -2, 3, -5)
+   * scala> val expectedResult = List(NonEmptyList.of(12, -2), NonEmptyList.of(3, -5))
+   * scala> val result = nel.grouped(2)
+   * scala> result.toList === expectedResult
+   * res0: Boolean = true
+   * }}}
+   */
+  def grouped(size: Int): Iterator[NonEmptyList[A]] = {
+    require(size >= 1, f"size=$size%d, but size must be positive")
+    toList.grouped(size).map(NonEmptyList.fromListUnsafe)
+  }
+
   /**
    * Creates new `NonEmptyMap`, similarly to List#toMap from scala standard library.
    * {{{
diff --git a/core/src/main/scala/cats/data/NonEmptySeq.scala b/core/src/main/scala/cats/data/NonEmptySeq.scala
index efd677bf6..482c7c189 100644
--- a/core/src/main/scala/cats/data/NonEmptySeq.scala
+++ b/core/src/main/scala/cats/data/NonEmptySeq.scala
@@ -298,6 +298,24 @@ final class NonEmptySeq[+A] private (val toSeq: Seq[A]) extends AnyVal with NonE
   final def groupByNem[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NonEmptySeq[A]] =
     NonEmptyMap.fromMapUnsafe(groupBy(f))
 
+  /**
+   * Partitions elements in fixed size `NonEmptySeq`s.
+   *
+   * {{{
+   * scala> import cats.data.NonEmptySeq
+   * scala> import cats.implicits._
+   * scala> val nel = NonEmptySeq.of(12, -2, 3, -5)
+   * scala> val expectedResult = List(NonEmptySeq.of(12, -2), NonEmptySeq.of(3, -5))
+   * scala> val result = nel.grouped(2)
+   * scala> result.toList === expectedResult
+   * res0: Boolean = true
+   * }}}
+   */
+  def grouped(size: Int): Iterator[NonEmptySeq[A]] = {
+    require(size >= 1, f"size=$size%d, but size must be positive")
+    toSeq.grouped(size).map(NonEmptySeq.fromSeqUnsafe)
+  }
+
   /**
    * Creates new `NonEmptyMap`, similarly to List#toMap from scala standard library.
    * {{{
diff --git a/core/src/main/scala/cats/data/NonEmptyVector.scala b/core/src/main/scala/cats/data/NonEmptyVector.scala
index ec8da72de..cfd8d4c33 100644
--- a/core/src/main/scala/cats/data/NonEmptyVector.scala
+++ b/core/src/main/scala/cats/data/NonEmptyVector.scala
@@ -300,6 +300,24 @@ final class NonEmptyVector[+A] private (val toVector: Vector[A])
   final def groupByNem[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NonEmptyVector[A]] =
     NonEmptyMap.fromMapUnsafe(groupBy(f))
 
+  /**
+   * Partitions elements in fixed size `NonEmptyVector`s.
+   *
+   * {{{
+   * scala> import cats.data.NonEmptyVector
+   * scala> import cats.implicits._
+   * scala> val nel = NonEmptyVector.of(12, -2, 3, -5)
+   * scala> val expectedResult = List(NonEmptyVector.of(12, -2), NonEmptyVector.of(3, -5))
+   * scala> val result = nel.grouped(2)
+   * scala> result.toList === expectedResult
+   * res0: Boolean = true
+   * }}}
+   */
+  def grouped(size: Int): Iterator[NonEmptyVector[A]] = {
+    require(size >= 1, f"size=$size%d, but size must be positive")
+    toVector.grouped(size).map(NonEmptyVector.fromVectorUnsafe)
+  }
+
   /**
    * Creates new `NonEmptyMap`, similarly to List#toMap from scala standard library.
    * {{{
