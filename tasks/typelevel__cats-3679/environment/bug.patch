diff --git a/build.sbt b/build.sbt
index 2126a80b0..6717d42d9 100644
--- a/build.sbt
+++ b/build.sbt
@@ -470,9 +470,6 @@ def mimaSettings(moduleName: String, includeCats1: Boolean = true) =
           exclude[NewMixinForwarderProblem]("cats.kernel.Band#mcF#sp.combineN"),
           exclude[NewMixinForwarderProblem]("cats.data.Tuple2KApply.product"),
           exclude[NewMixinForwarderProblem]("cats.InvariantInstances0.catsApplicativeForArrow")
-        ) ++ // Additional methods in package-private traits
-        Seq(
-          exclude[ReversedMissingMethodProblem]("cats.data.NonEmptyCollection.grouped")
         )
     }
   )
diff --git a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
index e9ac67ac7..7633261b4 100644
--- a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
+++ b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
@@ -417,27 +417,6 @@ class NonEmptyLazyListOps[A](private val value: NonEmptyLazyList[A])
   final def groupByNem[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NonEmptyLazyList[A]] =
     NonEmptyMap.fromMapUnsafe(groupBy(f))
 
-  /**
-   * Partitions elements in fixed size `NonEmptyLazyList`s.
-   *
-   * {{{
-   * scala> import cats.data.NonEmptyLazyList
-   * scala> import cats.implicits._
-   * scala> val nel = NonEmptyLazyList.fromLazyListUnsafe(LazyList(12, -2, 3, -5))
-   * scala> val expectedResult = List(
-   *      |   NonEmptyLazyList.fromLazyListUnsafe(LazyList(12, -2)),
-   *      |   NonEmptyLazyList.fromLazyListUnsafe(LazyList(3, -5))
-   *      | )
-   * scala> val result = nel.grouped(2)
-   * scala> result.toList === expectedResult
-   * res0: Boolean = true
-   * }}}
-   */
-  def grouped(size: Int): Iterator[NonEmptyLazyList[A]] = {
-    require(size >= 1, f"size=$size%d, but size must be positive")
-    toLazyList.grouped(size).map(NonEmptyLazyList.fromLazyListUnsafe)
-  }
-
   /**
    * Creates new `NonEmptyMap`, similarly to List#toMap from scala standard library.
    * {{{
diff --git a/core/src/main/scala/cats/data/NonEmptyChain.scala b/core/src/main/scala/cats/data/NonEmptyChain.scala
index 6d0f53f6e..bcb32b579 100644
--- a/core/src/main/scala/cats/data/NonEmptyChain.scala
+++ b/core/src/main/scala/cats/data/NonEmptyChain.scala
@@ -7,7 +7,7 @@ import scala.collection.immutable.SortedMap
 
 private[data] object NonEmptyChainImpl extends NonEmptyChainInstances with ScalaVersionSpecificNonEmptyChainImpl {
   // The following 3 types are components of a technique to
-  // create a no-boxing newtype. It's copied from the
+  // create a no-boxing newtype. It's coped from the
   // newtypes lib by @alexknvl
   // For more detail see https://github.com/alexknvl/newtypes
   private[data] type Base
@@ -397,24 +397,6 @@ class NonEmptyChainOps[A](private val value: NonEmptyChain[A])
   final def groupBy[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NonEmptyChain[A]] =
     toChain.groupBy(f).asInstanceOf[NonEmptyMap[B, NonEmptyChain[A]]]
 
-  /**
-   * Partitions elements in fixed size `NonEmptyChain`s.
-   *
-   * {{{
-   * scala> import cats.data.NonEmptyChain
-   * scala> import cats.implicits._
-   * scala> val nel = NonEmptyChain.of(12, -2, 3, -5)
-   * scala> val expectedResult = List(NonEmptyChain.of(12, -2), NonEmptyChain.of(3, -5))
-   * scala> val result = nel.grouped(2)
-   * scala> result.toList === expectedResult
-   * res0: Boolean = true
-   * }}}
-   */
-  final def grouped(size: Int): Iterator[NonEmptyChain[A]] = {
-    require(size >= 1, f"size=$size%d, but size must be positive")
-    toNonEmptyVector.grouped(size).map(NonEmptyChain.fromNonEmptyVector)
-  }
-
   /**
    * Groups elements inside this `NonEmptyChain` according to the `Order`
    * of the keys produced by the given mapping function.
diff --git a/core/src/main/scala/cats/data/NonEmptyCollection.scala b/core/src/main/scala/cats/data/NonEmptyCollection.scala
index 5c8e4d562..eebef180a 100644
--- a/core/src/main/scala/cats/data/NonEmptyCollection.scala
+++ b/core/src/main/scala/cats/data/NonEmptyCollection.scala
@@ -33,7 +33,6 @@ private[cats] trait NonEmptyCollection[+A, U[+_], NE[+_]] extends Any {
   def sortBy[B](f: A => B)(implicit B: Order[B]): NE[A]
   def sorted[AA >: A](implicit AA: Order[AA]): NE[AA]
   def groupByNem[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NE[A]]
-  def grouped(size: Int): Iterator[NE[A]]
   def toNem[T, V](implicit ev: A <:< (T, V), order: Order[T]): NonEmptyMap[T, V]
   def toNes[B >: A](implicit order: Order[B]): NonEmptySet[B]
 
diff --git a/core/src/main/scala/cats/data/NonEmptyList.scala b/core/src/main/scala/cats/data/NonEmptyList.scala
index 26944c873..dc7d87275 100644
--- a/core/src/main/scala/cats/data/NonEmptyList.scala
+++ b/core/src/main/scala/cats/data/NonEmptyList.scala
@@ -577,24 +577,6 @@ final case class NonEmptyList[+A](head: A, tail: List[A]) extends NonEmptyCollec
   ): NonEmptyMap[K, B] =
     NonEmptyMap.fromMapUnsafe(groupMapReduceWith(key)(f)(combine))
 
-  /**
-   * Partitions elements in fixed size `NonEmptyList`s.
-   *
-   * {{{
-   * scala> import cats.data.NonEmptyList
-   * scala> import cats.implicits._
-   * scala> val nel = NonEmptyList.of(12, -2, 3, -5)
-   * scala> val expectedResult = List(NonEmptyList.of(12, -2), NonEmptyList.of(3, -5))
-   * scala> val result = nel.grouped(2)
-   * scala> result.toList === expectedResult
-   * res0: Boolean = true
-   * }}}
-   */
-  def grouped(size: Int): Iterator[NonEmptyList[A]] = {
-    require(size >= 1, f"size=$size%d, but size must be positive")
-    toList.grouped(size).map(NonEmptyList.fromListUnsafe)
-  }
-
   /**
    * Creates new `NonEmptyMap`, similarly to List#toMap from scala standard library.
    * {{{
diff --git a/core/src/main/scala/cats/data/NonEmptySeq.scala b/core/src/main/scala/cats/data/NonEmptySeq.scala
index 482c7c189..efd677bf6 100644
--- a/core/src/main/scala/cats/data/NonEmptySeq.scala
+++ b/core/src/main/scala/cats/data/NonEmptySeq.scala
@@ -298,24 +298,6 @@ final class NonEmptySeq[+A] private (val toSeq: Seq[A]) extends AnyVal with NonE
   final def groupByNem[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NonEmptySeq[A]] =
     NonEmptyMap.fromMapUnsafe(groupBy(f))
 
-  /**
-   * Partitions elements in fixed size `NonEmptySeq`s.
-   *
-   * {{{
-   * scala> import cats.data.NonEmptySeq
-   * scala> import cats.implicits._
-   * scala> val nel = NonEmptySeq.of(12, -2, 3, -5)
-   * scala> val expectedResult = List(NonEmptySeq.of(12, -2), NonEmptySeq.of(3, -5))
-   * scala> val result = nel.grouped(2)
-   * scala> result.toList === expectedResult
-   * res0: Boolean = true
-   * }}}
-   */
-  def grouped(size: Int): Iterator[NonEmptySeq[A]] = {
-    require(size >= 1, f"size=$size%d, but size must be positive")
-    toSeq.grouped(size).map(NonEmptySeq.fromSeqUnsafe)
-  }
-
   /**
    * Creates new `NonEmptyMap`, similarly to List#toMap from scala standard library.
    * {{{
diff --git a/core/src/main/scala/cats/data/NonEmptyVector.scala b/core/src/main/scala/cats/data/NonEmptyVector.scala
index cfd8d4c33..ec8da72de 100644
--- a/core/src/main/scala/cats/data/NonEmptyVector.scala
+++ b/core/src/main/scala/cats/data/NonEmptyVector.scala
@@ -300,24 +300,6 @@ final class NonEmptyVector[+A] private (val toVector: Vector[A])
   final def groupByNem[B](f: A => B)(implicit B: Order[B]): NonEmptyMap[B, NonEmptyVector[A]] =
     NonEmptyMap.fromMapUnsafe(groupBy(f))
 
-  /**
-   * Partitions elements in fixed size `NonEmptyVector`s.
-   *
-   * {{{
-   * scala> import cats.data.NonEmptyVector
-   * scala> import cats.implicits._
-   * scala> val nel = NonEmptyVector.of(12, -2, 3, -5)
-   * scala> val expectedResult = List(NonEmptyVector.of(12, -2), NonEmptyVector.of(3, -5))
-   * scala> val result = nel.grouped(2)
-   * scala> result.toList === expectedResult
-   * res0: Boolean = true
-   * }}}
-   */
-  def grouped(size: Int): Iterator[NonEmptyVector[A]] = {
-    require(size >= 1, f"size=$size%d, but size must be positive")
-    toVector.grouped(size).map(NonEmptyVector.fromVectorUnsafe)
-  }
-
   /**
    * Creates new `NonEmptyMap`, similarly to List#toMap from scala standard library.
    * {{{
diff --git a/tests/src/test/scala/cats/tests/NonEmptyCollectionSuite.scala b/tests/src/test/scala/cats/tests/NonEmptyCollectionSuite.scala
index 7b55bd95f..89c54bf64 100644
--- a/tests/src/test/scala/cats/tests/NonEmptyCollectionSuite.scala
+++ b/tests/src/test/scala/cats/tests/NonEmptyCollectionSuite.scala
@@ -153,12 +153,6 @@ abstract class NonEmptyCollectionSuite[U[+_], NE[+_], NEC[x] <: NonEmptyCollecti
     }
   }
 
-  test("grouped is consistent with iterator.toList.grouped") {
-    forAll { (is: NE[Int], i: Int) =>
-      (i > 0) ==> (is.grouped(i).toList.map(toList) === is.iterator.toList.grouped(i).toList)
-    }
-  }
-
   test("toNem is consistent with iterator.toMap") {
     forAll { (is: NE[Int]) =>
       assert((is.zipWithIndex.toNem.toSortedMap: Map[Int, Int]) === (is.zipWithIndex.iterator.toMap))
