diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 5f778af51e..b35a6ec7c1 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -32,14 +32,14 @@ junit-platform="1.9.3"
 logback = "1.4.8"
 logbook-netty = "2.16.0"
 log4j = "2.20.0"
-micronaut-aws = "4.0.1"
-micronaut-groovy = "4.0.1"
+micronaut-aws = "4.0.0-M11"
+micronaut-groovy = "4.0.0-M4"
 micronaut-session = "4.0.0-M3"
 micronaut-sql = "5.0.0-M7"
 micronaut-test = "4.0.0-M4"
 micronaut-validation = "4.0.0-M9"
-micronaut-rxjava2 = "2.0.1"
-micronaut-rxjava3 = "3.0.1"
+micronaut-rxjava2 = "2.0.0-M6"
+micronaut-rxjava3 = "3.0.0-M6"
 micronaut-reactor = "3.0.0-M7"
 neo4j-java-driver = "1.4.5"
 selenium = "4.9.1"
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java b/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java
index 33a41f8dd5..808df35b38 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java
@@ -25,8 +25,6 @@ import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.DefaultLastHttpContent;
 import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
@@ -113,15 +111,6 @@ public interface NettyHttpResponseBuilder {
             response.getHeaders()
                 .forEach((s, strings) -> fullHttpResponse.headers().add(s, strings));
         }
-
-        // does the response have a body
-        if (response instanceof FullHttpResponse || response instanceof StreamedHttpResponse) {
-            io.netty.handler.codec.http.HttpHeaders nettyHeaders = fullHttpResponse.headers();
-            // default to Transfer-Encoding: chunked if Content-Length not set or not already set
-            if (!nettyHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) && !nettyHeaders.contains(HttpHeaderNames.TRANSFER_ENCODING)) {
-                nettyHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
-            }
-        }
         return fullHttpResponse;
     }
 
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java
index f8f651eee9..1493a52878 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java
@@ -46,7 +46,18 @@ public interface NettyWriteContext {
      *
      * @param response The response to write
      */
-    void writeFull(@NonNull FullHttpResponse response);
+    default void writeFull(@NonNull FullHttpResponse response) {
+        writeFull(response, false);
+    }
+
+    /**
+     * Write a full response.
+     *
+     * @param response The response to write
+     * @param headResponse If {@code true}, this is a response to a {@code HEAD} request, so the
+     * {@code Content-Length} header should not be overwritten.
+     */
+    void writeFull(@NonNull FullHttpResponse response, boolean headResponse);
 
     /**
      * Write a streamed response.
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
index e0e4d96305..0f2bb91f13 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
@@ -32,7 +32,6 @@ import io.micronaut.http.HttpMethod;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpResponse;
 import io.micronaut.http.MediaType;
-import io.micronaut.http.MutableHttpHeaders;
 import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.body.DynamicMessageBodyWriter;
 import io.micronaut.http.body.MediaTypeProvider;
@@ -68,8 +67,6 @@ import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpContent;
-import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
 import org.reactivestreams.Processor;
@@ -333,7 +330,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
                 actualResponseType = responseBodyType;
             }
             NettyBodyWriter<Object> closure = wrap(messageBodyWriter);
-            handleMissingConnectionHeader(response, nettyRequest, outboundAccess);
+            closeConnectionIfError(response, nettyRequest, outboundAccess);
             if (closure.isBlocking()) {
                 MediaType finalResponseMediaType = responseMediaType;
                 getIoExecutor().execute(() -> writeNettyMessageBody(nettyRequest, (MutableHttpResponse<Object>) response, actualResponseType, finalResponseMediaType, body, closure, outboundAccess));
@@ -426,7 +423,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
 
     private void writeFinalNettyResponse(MutableHttpResponse<?> message, NettyHttpRequest<?> request, PipeliningServerHandler.OutboundAccess outboundAccess) {
         // default Connection header if not set explicitly
-        handleMissingConnectionHeader(message, request, outboundAccess);
+        closeConnectionIfError(message, request, outboundAccess);
         io.netty.handler.codec.http.HttpResponse nettyResponse = NettyHttpResponseBuilder.toHttpResponse(message);
         // close handled by HttpServerKeepAliveHandler
         if (request.getNativeRequest() instanceof StreamedHttpRequest streamed && !streamed.isConsumed()) {
@@ -434,14 +431,10 @@ public final class RoutingInBoundHandler implements RequestHandler {
             Flux.from(streamed).subscribe(HttpContent::release);
         }
         if (nettyResponse instanceof StreamedHttpResponse streamed) {
-            nettyResponse.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
             writeStreamedWithErrorHandling(request, outboundAccess, streamed);
         } else {
             FullHttpResponse fullResponse = (FullHttpResponse) nettyResponse;
-            if (PipeliningServerHandler.canHaveBody(fullResponse.status()) && request.getMethod() != HttpMethod.HEAD) {
-                nettyResponse.headers().set(HttpHeaderNames.CONTENT_LENGTH, fullResponse.content().readableBytes());
-            }
-            outboundAccess.writeFull(fullResponse);
+            outboundAccess.writeFull(fullResponse, request.getMethod() == HttpMethod.HEAD);
         }
 
         if (LOG.isDebugEnabled()) {
@@ -457,7 +450,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
         streamed.subscribe(sub);
     }
 
-    private void handleMissingConnectionHeader(MutableHttpResponse<?> message, HttpRequest<?> request, PipeliningServerHandler.OutboundAccess outboundAccess) {
+    private void closeConnectionIfError(MutableHttpResponse<?> message, HttpRequest<?> request, PipeliningServerHandler.OutboundAccess outboundAccess) {
         boolean decodeError = request instanceof NettyHttpRequest<?> nettyRequest &&
             nettyRequest.getNativeRequest().decoderResult().isFailure();
 
@@ -488,13 +481,6 @@ public final class RoutingInBoundHandler implements RequestHandler {
         );
     }
 
-    private static void setResponseBody(MutableHttpResponse<?> response, ByteBuf byteBuf) {
-        int len = byteBuf.readableBytes();
-        MutableHttpHeaders headers = response.getHeaders();
-        headers.set(HttpHeaderNames.CONTENT_LENGTH, String.valueOf(len));
-        response.body((Object) byteBuf);
-    }
-
     /**
      * Is the exception ignorable by Micronaut.
      *
@@ -548,7 +534,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
                 mediaType,
                 object,
                 outgoingResponse.getHeaders(), bufferFactory);
-            setResponseBody(outgoingResponse, (ByteBuf) byteBuffer.asNativeBuffer());
+            outgoingResponse.body((Object) byteBuffer.asNativeBuffer());
             writeFinalNettyResponse(outgoingResponse, (NettyHttpRequest<?>) request, (PipeliningServerHandler.OutboundAccess) nettyContext);
         }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
index f0bfcaaee7..68496e4995 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
@@ -634,19 +634,28 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
             }
         }
 
-        /**
-         * Write a full response.
-         *
-         * @param response The response to write
-         */
         @Override
-        public void writeFull(FullHttpResponse response) {
+        public void writeFull(FullHttpResponse response, boolean headResponse) {
+            response.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);
+            if (canHaveBody(response.status())) {
+                if (!headResponse) {
+                    response.headers().set(HttpHeaderNames.CONTENT_LENGTH, response.content().readableBytes());
+                }
+            } else {
+                response.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
+            }
             preprocess(response);
             write(new FullOutboundHandler(this, response));
         }
 
         @Override
         public void writeStreamed(HttpResponse response, Publisher<HttpContent> content) {
+            response.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
+            if (canHaveBody(response.status())) {
+                response.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
+            } else {
+                response.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);
+            }
             preprocess(response);
             content.subscribe(new StreamingOutboundHandler(this, response));
         }
diff --git a/src/main/docs/guide/httpServer/filters/filterPatterns.adoc b/src/main/docs/guide/httpServer/filters/filterPatterns.adoc
index d3aaa285bf..eb0cf62c13 100644
--- a/src/main/docs/guide/httpServer/filters/filterPatterns.adoc
+++ b/src/main/docs/guide/httpServer/filters/filterPatterns.adoc
@@ -17,7 +17,7 @@ You can use different styles of pattern for path matching by setting `patternSty
 |customer/joy, customer/jay
 
 |`customer/*/id`
-|customer/adam/id, customer/amy/id
+|customer/adam/id, com/amy/id
 
 |`customer/**`
 |customer/adam, customer/adam/id, customer/adam/name
diff --git a/src/main/docs/guide/languageSupport/kotlin/coroutines.adoc b/src/main/docs/guide/languageSupport/kotlin/coroutines.adoc
index 49089efc7c..b05b81f018 100644
--- a/src/main/docs/guide/languageSupport/kotlin/coroutines.adoc
+++ b/src/main/docs/guide/languageSupport/kotlin/coroutines.adoc
@@ -1,39 +1,23 @@
 Kotlin coroutines allow you to create asynchronous applications with imperative style code. A Micronaut controller action can be a `suspend` function:
 
-.Controller suspend function example
-[source, kotlin]
-----
-include::{testsuitekotlin}/server/suspend/SuspendController.kt[tags="suspend", indent=0]
-----
+snippet::io.micronaut.docs.server.suspend.SuspendController[tags="suspend", indent=0, title="Controller suspend function example"]
 
 <1> The function is marked as `suspend`, though in reality it won't be suspended.
 
-snippet::io.micronaut.docs.server.suspend.SuspendController.kt[tags="suspendDelayed", indent=0, title="Controller suspend function example"]
+snippet::io.micronaut.docs.server.suspend.SuspendController[tags="suspendDelayed", indent=0, title="Controller suspend function example"]
 
 <1> The function is marked as `suspend`.
 <2> The `delay` is called to make sure that a function is suspended and the response is returned from a different thread.
 
-.Controller suspend function example
-[source, kotlin]
-----
-include::{testsuitekotlin}/server/suspend/SuspendController.kt[tags="suspendStatus", indent=0]
-----
+snippet::io.micronaut.docs.server.suspend.SuspendController[tags="suspendStatus", indent=0, title="Controller suspend function example"]
 
 <1> `suspend` function also works when all we want is to return a status.
 
-.Controller suspend function example
-[source, kotlin]
-----
-include::{testsuitekotlin}/server/suspend/SuspendController.kt[tags="suspendStatusDelayed", indent=0]
-----
+snippet::io.micronaut.docs.server.suspend.SuspendController[tags="suspendStatusDelayed", indent=0, title="Controller suspend function example"]
 
 You can also use `Flow` type for streaming server and client. A streaming controller can return `Flow`, for example:
 
-.Streaming JSON on the Server with Flow
-[source, kotlin]
-----
-include::{testsuitekotlin}/streaming/HeadlineFlowController.kt[tags="streamingWithFlow", indent=0]
-----
+snippet::io.micronaut.docs.streaming.HeadlineFlowController[tags="streamingWithFlow", indent=0, title="Streaming JSON on the Server with Flow"]
 
 <1> A method `streamHeadlinesWithFlow` is defined that produces `application/x-json-stream`
 <2> A `Flow` is created using `flow`
@@ -43,12 +27,7 @@ include::{testsuitekotlin}/streaming/HeadlineFlowController.kt[tags="streamingWi
 
 A streaming client can simply return a `Flow`, for example:
 
-
-.Streaming client with Flow
-[source, kotlin]
-----
-include::{testsuitekotlin}/streaming/HeadlineFlowClient.kt[tags="imports,class, streamingWithFlow", indent=0]
-----
+snippet::io.micronaut.docs.streaming.HeadlineFlowClient[tags="imports, class, streamingWithFlow", indent=0, title="Streaming client with Flow"]
 
 <1> The `@Get` method is defined as processing responses of type `APPLICATION_JSON_STREAM`
 <2> The return type is `Flow`
