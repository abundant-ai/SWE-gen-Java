diff --git a/core/src/main/scala/cats/Align.scala b/core/src/main/scala/cats/Align.scala
index d943105e6..49f0df1b4 100644
--- a/core/src/main/scala/cats/Align.scala
+++ b/core/src/main/scala/cats/Align.scala
@@ -56,19 +56,6 @@ import scala.annotation.implicitNotFound
   def alignCombine[A: Semigroup](fa1: F[A], fa2: F[A]): F[A] =
     alignWith(fa1, fa2)(_.merge)
 
-  /**
-   * Align two structures with the same element, combining results according to the given function.
-   *
-   * Example:
-   * {{{
-   * scala> import cats.implicits._
-   * scala> Align[List].alignMergeWith(List(1, 2), List(10, 11, 12))(_ + _)
-   * res0: List[Int] = List(11, 13, 12)
-   * }}}
-   */
-  def alignMergeWith[A](fa1: F[A], fa2: F[A])(f: (A, A) => A): F[A] =
-    functor.map(align(fa1, fa2))(_.mergeWith(f))
-
   /**
    * Same as `align`, but forgets from the type that one of the two elements must be present.
    *
@@ -171,7 +158,6 @@ object Align extends ScalaVersionSpecificAlignInstances {
     def align[B](fb: F[B]): F[Ior[A, B]] = typeClassInstance.align[A, B](self, fb)
     def alignWith[B, C](fb: F[B])(f: Ior[A, B] => C): F[C] = typeClassInstance.alignWith[A, B, C](self, fb)(f)
     def alignCombine(fa2: F[A])(implicit ev$1: Semigroup[A]): F[A] = typeClassInstance.alignCombine[A](self, fa2)
-    def alignMergeWith(fa2: F[A])(f: (A, A) => A): F[A] = typeClassInstance.alignMergeWith[A](self, fa2)(f)
     def padZip[B](fb: F[B]): F[(Option[A], Option[B])] = typeClassInstance.padZip[A, B](self, fb)
     def padZipWith[B, C](fb: F[B])(f: (Option[A], Option[B]) => C): F[C] =
       typeClassInstance.padZipWith[A, B, C](self, fb)(f)
diff --git a/core/src/main/scala/cats/data/Ior.scala b/core/src/main/scala/cats/data/Ior.scala
index b127a251b..09ce924ac 100644
--- a/core/src/main/scala/cats/data/Ior.scala
+++ b/core/src/main/scala/cats/data/Ior.scala
@@ -702,8 +702,6 @@ sealed abstract class Ior[+A, +B] extends Product with Serializable {
     fold(identity, ev, (a, _) => a)
   final def mergeRight[AA >: A](implicit ev: B <:< AA): AA =
     fold(identity, ev, (_, b) => ev(b))
-  final def mergeWith[AA >: A](f: (A, B) => AA)(implicit ev: B <:< AA): AA =
-    fold(identity, ev, f)
 
   /**
    * Example:
diff --git a/tests/src/test/scala/cats/tests/IorSuite.scala b/tests/src/test/scala/cats/tests/IorSuite.scala
index 84602deea..4c5f5746b 100644
--- a/tests/src/test/scala/cats/tests/IorSuite.scala
+++ b/tests/src/test/scala/cats/tests/IorSuite.scala
@@ -160,12 +160,6 @@ class IorSuite extends CatsSuite {
     }
   }
 
-  test("mergeWith") {
-    forAll { (i: Int Ior Int, f: (Int, Int) => Int) =>
-      assert(i.mergeWith(f) === i.onlyBoth.map(f.tupled).orElse(i.left).orElse(i.right).get)
-    }
-  }
-
   test("putLeft") {
     forAll { (i: Int Ior Int) =>
       val expectedResult =
diff --git a/tests/src/test/scala/cats/tests/SyntaxSuite.scala b/tests/src/test/scala/cats/tests/SyntaxSuite.scala
index 3f39b55bd..4396e705d 100644
--- a/tests/src/test/scala/cats/tests/SyntaxSuite.scala
+++ b/tests/src/test/scala/cats/tests/SyntaxSuite.scala
@@ -481,7 +481,6 @@ object SyntaxSuite {
     val fb = mock[F[B]]
     val f = mock[A Ior B => C]
     val f2 = mock[(Option[A], Option[B]) => C]
-    val f3 = mock[(A, A) => A]
     val a = mock[A]
     val b = mock[B]
 
@@ -493,7 +492,6 @@ object SyntaxSuite {
 
     implicit val sa: Semigroup[A] = mock[Semigroup[A]]
     val fa2 = fa.alignCombine(fa)
-    val fa3 = fa.alignMergeWith(fa)(f3)
 
     val zippedAll = fa.zipAll(fb, a, b)
   }
