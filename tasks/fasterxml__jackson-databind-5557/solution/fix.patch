diff --git a/release-notes/VERSION b/release-notes/VERSION
index 788647365..6422f3a2b 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -44,6 +44,10 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #3964: Deserialization issue: MismatchedInputException, Bean not
   yet resolved
  (reported by @detomarco)
+#4118: Deserialization of a certain kinds of parametrized properties fail to
+  resolve `?` into expected bounds, resulting in `LinkedHashMap`
+ (reported by @Mariusz)
+ (fix by @cowtowncoder, w/ Claude code)
 #4277: Deserialization `@JsonFormat(shape = JsonFormat.Shape.ARRAY)` POJO with
   `JsonTypeInfo.As.EXTERNAL_PROPERTY` does not work
  (reported by James M)
diff --git a/src/main/java/tools/jackson/databind/type/TypeFactory.java b/src/main/java/tools/jackson/databind/type/TypeFactory.java
index 71aa4737c..c0e7d8e18 100644
--- a/src/main/java/tools/jackson/databind/type/TypeFactory.java
+++ b/src/main/java/tools/jackson/databind/type/TypeFactory.java
@@ -1544,21 +1544,22 @@ ClassUtil.nameOf(rawClass), pc, (pc == 1) ? "" : "s", bindings));
             }
             newBindings = TypeBindings.create(rawType, pt);
 
-            // [databind#4118] Unbind any wildcards with a less specific upper bound than
-            // declared on the type variable
-
-            // [databind#4147] Regressum Maximum, alas! Need to undo fix due to side effects;
-            // plan is to re-tackle in 2.17
-            /*
+            // [databind#4118] Unbind wildcards in (direct) self-referential type parameters
+            // to allow deserializers to use the class definition's bounds instead of Object.
+            // [databind#4147] Only unbind for self-referential parameters to avoid
+            // breaking multi-parameter types like Either<L, R> where only some are wildcards.
             for (int i = 0; i < paramCount; ++i) {
                 if (args[i] instanceof WildcardType && !pt[i].hasGenericTypes()) {
                     TypeVariable<? extends Class<?>> typeVariable = rawType.getTypeParameters()[i];
-                    if (pt[i].getRawClass().isAssignableFrom(rawClass(typeVariable))) {
-                        newBindings = newBindings.withoutVariable(typeVariable.getName());
+
+                    // Only unbind if this is a (direct) self-referential type parameter
+                    if (_isSelfReferentialTypeParameter(typeVariable, rawType)) {
+                        if (pt[i].getRawClass().isAssignableFrom(rawClass(typeVariable))) {
+                            newBindings = newBindings.withoutVariable(typeVariable.getName());
+                        }
                     }
                 }
             }
-            */
         }
         return _fromClass(context, rawType, newBindings);
     }
@@ -1608,4 +1609,37 @@ ClassUtil.nameOf(rawClass), pc, (pc == 1) ? "" : "s", bindings));
          */
         return _fromAny(context, type.getUpperBounds()[0], bindings);
     }
+
+    /**
+     * Helper method to determine if a type parameter is directly self-referential,
+     * meaning its bound references the declaring class itself.
+     * For example, in {@code class Foo<T extends Foo<?>>}, T is self-referential.
+     * This is used to handle recursive wildcard types correctly (see [databind#4118]).
+     *<p>
+     * NOTE: does NOT check for indirect (nested) self-references: should be rare
+     * in practice but potential concern.
+     *
+     * @param typeVar Type variable to check
+     * @param declaringClass The class that declares this type variable
+     * @return {@code true} if the type variable's bound references the declaring class
+     *
+     * @since 3.1
+     */
+    protected boolean _isSelfReferentialTypeParameter(TypeVariable<?> typeVar, Class<?> declaringClass) {
+        Type[] bounds = typeVar.getBounds();
+        if (bounds == null || bounds.length == 0) {
+            return false;
+        }
+
+        // Check the first bound (typically the important one)
+        Type bound = bounds[0];
+
+        // May be directly the class (raw type bound)
+        if (bound == declaringClass) {
+            return true;
+        }
+
+        // Or if bound is a ParameterizedType, check if its raw type is the declaring class
+       return (bound instanceof ParameterizedType pt && pt.getRawType() == declaringClass);
+    }
 }
