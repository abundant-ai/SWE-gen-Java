diff --git a/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt b/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
index 46c2f4a9a..10404f7dd 100644
--- a/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
+++ b/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
@@ -13,6 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+@file:Suppress(
+  "CANNOT_OVERRIDE_INVISIBLE_MEMBER",
+  "INVISIBLE_MEMBER",
+  "INVISIBLE_REFERENCE",
+)
+
 package okhttp3
 
 import java.io.Closeable
@@ -28,6 +34,7 @@ import javax.net.ssl.SSLSocketFactory
 import okhttp3.internal.RecordingOkAuthenticator
 import okhttp3.internal.concurrent.TaskFaker
 import okhttp3.internal.concurrent.TaskRunner
+import okhttp3.internal.connection.CallConnectionUser
 import okhttp3.internal.connection.RealCall
 import okhttp3.internal.connection.RealConnection
 import okhttp3.internal.connection.RealConnectionPool
@@ -177,7 +184,26 @@ class TestValueFactory : Closeable {
     address: Address = newAddress(),
   ): RealRoutePlanner {
     val call = RealCall(client, Request(address.url), forWebSocket = false)
-    return RealRoutePlanner(client, address, call, newChain(call), ConnectionListener.NONE)
+    val chain = newChain(call)
+    return RealRoutePlanner(
+      taskRunner = client.taskRunner,
+      connectionPool = client.connectionPool.delegate,
+      readTimeoutMillis = client.readTimeoutMillis,
+      writeTimeoutMillis = client.writeTimeoutMillis,
+      socketConnectTimeoutMillis = chain.connectTimeoutMillis,
+      socketReadTimeoutMillis = chain.readTimeoutMillis,
+      pingIntervalMillis = client.pingIntervalMillis,
+      retryOnConnectionFailure = client.retryOnConnectionFailure,
+      fastFallback = client.fastFallback,
+      address = address,
+      routeDatabase = client.routeDatabase,
+      connectionUser =
+        CallConnectionUser(
+          call,
+          client.connectionPool.delegate.connectionListener,
+          chain,
+        ),
+    )
   }
 
   override fun close() {
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/CallConnectionUser.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/CallConnectionUser.kt
new file mode 100644
index 000000000..8a28086a4
--- /dev/null
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/CallConnectionUser.kt
@@ -0,0 +1,140 @@
+package okhttp3.internal.connection
+
+import java.io.IOException
+import java.net.InetAddress
+import java.net.Proxy
+import java.net.Socket
+import okhttp3.Connection
+import okhttp3.ConnectionListener
+import okhttp3.EventListener
+import okhttp3.Handshake
+import okhttp3.HttpUrl
+import okhttp3.Protocol
+import okhttp3.Route
+import okhttp3.internal.http.RealInterceptorChain
+
+/**
+ * A connection user that is a specific [RealCall].
+ */
+internal class CallConnectionUser(
+  private val call: RealCall,
+  private val poolConnectionListener: ConnectionListener,
+  private val chain: RealInterceptorChain,
+) : ConnectionUser {
+  private val eventListener: EventListener
+    get() = call.eventListener
+
+  override fun addPlanToCancel(connectPlan: ConnectPlan) {
+    call.plansToCancel += connectPlan
+  }
+
+  override fun removePlanToCancel(connectPlan: ConnectPlan) {
+    call.plansToCancel -= connectPlan
+  }
+
+  override fun updateRouteDatabaseAfterSuccess(route: Route) {
+    call.client.routeDatabase.connected(route)
+  }
+
+  override fun connectStart(route: Route) {
+    eventListener.connectStart(call, route.socketAddress, route.proxy)
+    poolConnectionListener.connectStart(route, call)
+  }
+
+  override fun connectFailed(
+    route: Route,
+    protocol: Protocol?,
+    e: IOException,
+  ) {
+    eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
+    poolConnectionListener.connectFailed(route, call, e)
+  }
+
+  override fun secureConnectStart() {
+    eventListener.secureConnectStart(call)
+  }
+
+  override fun secureConnectEnd(handshake: Handshake?) {
+    eventListener.secureConnectEnd(call, handshake)
+  }
+
+  override fun callConnectEnd(
+    route: Route,
+    protocol: Protocol?,
+  ) {
+    eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
+  }
+
+  override fun connectionConnectEnd(
+    connection: Connection,
+    route: Route,
+  ) {
+    poolConnectionListener.connectEnd(connection, route, call)
+  }
+
+  override fun connectionAcquired(connection: Connection) {
+    eventListener.connectionAcquired(call, connection)
+  }
+
+  override fun acquireConnectionNoEvents(connection: RealConnection) {
+    call.acquireConnectionNoEvents(connection)
+  }
+
+  override fun releaseConnectionNoEvents(): Socket? {
+    return call.releaseConnectionNoEvents()
+  }
+
+  override fun connectionReleased(connection: Connection) {
+    eventListener.connectionReleased(call, connection)
+  }
+
+  override fun connectionConnectionAcquired(connection: RealConnection) {
+    connection.connectionListener.connectionAcquired(connection, call)
+  }
+
+  override fun connectionConnectionReleased(connection: RealConnection) {
+    connection.connectionListener.connectionReleased(connection, call)
+  }
+
+  override fun connectionConnectionClosed(connection: RealConnection) {
+    connection.connectionListener.connectionClosed(connection)
+  }
+
+  override fun noNewExchanges(connection: RealConnection) {
+    connection.connectionListener.noNewExchanges(connection)
+  }
+
+  override fun doExtensiveHealthChecks(): Boolean {
+    return chain.request.method != "GET"
+  }
+
+  override fun isCanceled(): Boolean {
+    return call.isCanceled()
+  }
+
+  override fun candidateConnection(): RealConnection? {
+    return call.connection
+  }
+
+  override fun proxySelectStart(url: HttpUrl) {
+    eventListener.proxySelectStart(call, url)
+  }
+
+  override fun proxySelectEnd(
+    url: HttpUrl,
+    proxies: List<Proxy>,
+  ) {
+    eventListener.proxySelectEnd(call, url, proxies)
+  }
+
+  override fun dnsStart(socketHost: String) {
+    eventListener.dnsStart(call, socketHost)
+  }
+
+  override fun dnsEnd(
+    socketHost: String,
+    result: List<InetAddress>,
+  ) {
+    eventListener.dnsEnd(call, socketHost, result)
+  }
+}
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectPlan.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectPlan.kt
index fd6c8a125..a5c31f9cf 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectPlan.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectPlan.kt
@@ -27,16 +27,14 @@ import java.util.concurrent.TimeUnit
 import javax.net.ssl.SSLPeerUnverifiedException
 import javax.net.ssl.SSLSocket
 import okhttp3.CertificatePinner
-import okhttp3.ConnectionListener
 import okhttp3.ConnectionSpec
 import okhttp3.Handshake
 import okhttp3.Handshake.Companion.handshake
-import okhttp3.Interceptor
-import okhttp3.OkHttpClient
 import okhttp3.Protocol
 import okhttp3.Request
 import okhttp3.Route
 import okhttp3.internal.closeQuietly
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.connection.RoutePlanner.ConnectResult
 import okhttp3.internal.http.ExchangeCodec
 import okhttp3.internal.http1.Http1ExchangeCodec
@@ -61,10 +59,15 @@ import okio.source
  * will be configured differently.
  */
 class ConnectPlan(
-  // Configuration and state scoped to the call.
-  private val client: OkHttpClient,
-  private val call: RealCall,
-  private val chain: Interceptor.Chain,
+  private val taskRunner: TaskRunner,
+  private val connectionPool: RealConnectionPool,
+  private val readTimeoutMillis: Int,
+  private val writeTimeoutMillis: Int,
+  private val socketConnectTimeoutMillis: Int,
+  private val socketReadTimeoutMillis: Int,
+  private val pingIntervalMillis: Int,
+  private val retryOnConnectionFailure: Boolean,
+  private val user: ConnectionUser,
   private val routePlanner: RealRoutePlanner,
   // Specifics to this plan.
   override val route: Route,
@@ -73,10 +76,7 @@ class ConnectPlan(
   private val tunnelRequest: Request?,
   internal val connectionSpecIndex: Int,
   internal val isTlsFallback: Boolean,
-  internal val connectionListener: ConnectionListener,
 ) : RoutePlanner.Plan, ExchangeCodec.Carrier {
-  private val eventListener = call.eventListener
-
   /** True if this connect was canceled; typically because it lost a race. */
   @Volatile private var canceled = false
 
@@ -107,9 +107,15 @@ class ConnectPlan(
     isTlsFallback: Boolean = this.isTlsFallback,
   ): ConnectPlan {
     return ConnectPlan(
-      client = client,
-      call = call,
-      chain = chain,
+      taskRunner = taskRunner,
+      connectionPool = connectionPool,
+      readTimeoutMillis = readTimeoutMillis,
+      writeTimeoutMillis = writeTimeoutMillis,
+      socketConnectTimeoutMillis = socketConnectTimeoutMillis,
+      socketReadTimeoutMillis = socketReadTimeoutMillis,
+      pingIntervalMillis = pingIntervalMillis,
+      retryOnConnectionFailure = retryOnConnectionFailure,
+      user = user,
       routePlanner = routePlanner,
       route = route,
       routes = routes,
@@ -117,7 +123,6 @@ class ConnectPlan(
       tunnelRequest = tunnelRequest,
       connectionSpecIndex = connectionSpecIndex,
       isTlsFallback = isTlsFallback,
-      connectionListener = connectionListener,
     )
   }
 
@@ -127,20 +132,18 @@ class ConnectPlan(
     var success = false
 
     // Tell the call about the connecting call so async cancels work.
-    call.plansToCancel += this
+    user.addPlanToCancel(this)
     try {
-      eventListener.connectStart(call, route.socketAddress, route.proxy)
-      connectionListener.connectStart(route, call)
+      user.connectStart(route)
 
       connectSocket()
       success = true
       return ConnectResult(plan = this)
     } catch (e: IOException) {
-      eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
-      connectionListener.connectFailed(route, call, e)
+      user.connectFailed(route, null, e)
       return ConnectResult(plan = this, throwable = e)
     } finally {
-      call.plansToCancel -= this
+      user.removePlanToCancel(this)
       if (!success) {
         rawSocket?.closeQuietly()
       }
@@ -156,7 +159,7 @@ class ConnectPlan(
     var success = false
 
     // Tell the call about the connecting call so async cancels work.
-    call.plansToCancel += this
+    user.addPlanToCancel(this)
     try {
       if (tunnelRequest != null) {
         val tunnelResult = connectTunnel()
@@ -176,7 +179,7 @@ class ConnectPlan(
           throw IOException("TLS tunnel buffered too many bytes!")
         }
 
-        eventListener.secureConnectStart(call)
+        user.secureConnectStart()
 
         // Create the wrapper over the connected socket.
         val sslSocket =
@@ -196,7 +199,7 @@ class ConnectPlan(
 
         connectionSpec.apply(sslSocket, isFallback = tlsEquipPlan.isTlsFallback)
         connectTls(sslSocket, connectionSpec)
-        eventListener.secureConnectEnd(call, handshake)
+        user.secureConnectEnd(handshake)
       } else {
         socket = rawSocket
         protocol =
@@ -208,8 +211,8 @@ class ConnectPlan(
 
       val connection =
         RealConnection(
-          taskRunner = client.taskRunner,
-          connectionPool = client.connectionPool.delegate,
+          taskRunner = taskRunner,
+          connectionPool = connectionPool,
           route = route,
           rawSocket = rawSocket,
           socket = socket,
@@ -217,21 +220,20 @@ class ConnectPlan(
           protocol = protocol,
           source = source,
           sink = sink,
-          pingIntervalMillis = client.pingIntervalMillis,
-          connectionListener = client.connectionPool.connectionListener,
+          pingIntervalMillis = pingIntervalMillis,
+          connectionListener = connectionPool.connectionListener,
         )
       this.connection = connection
       connection.start()
 
       // Success.
-      eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
+      user.callConnectEnd(route, protocol)
       success = true
       return ConnectResult(plan = this)
     } catch (e: IOException) {
-      eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
-      connectionListener.connectFailed(route, call, e)
+      user.connectFailed(route, null, e)
 
-      if (!client.retryOnConnectionFailure || !retryTlsHandshake(e)) {
+      if (!retryOnConnectionFailure || !retryTlsHandshake(e)) {
         retryTlsConnection = null
       }
 
@@ -241,7 +243,7 @@ class ConnectPlan(
         throwable = e,
       )
     } finally {
-      call.plansToCancel -= this
+      user.removePlanToCancel(this)
       if (!success) {
         socket?.closeQuietly()
         rawSocket?.closeQuietly()
@@ -264,9 +266,9 @@ class ConnectPlan(
       throw IOException("canceled")
     }
 
-    rawSocket.soTimeout = chain.readTimeoutMillis()
+    rawSocket.soTimeout = socketReadTimeoutMillis
     try {
-      Platform.get().connectSocket(rawSocket, route.socketAddress, chain.connectTimeoutMillis())
+      Platform.get().connectSocket(rawSocket, route.socketAddress, socketConnectTimeoutMillis)
     } catch (e: ConnectException) {
       throw ConnectException("Failed to connect to ${route.socketAddress}").apply {
         initCause(e)
@@ -307,7 +309,7 @@ class ConnectPlan(
     val nextAttempt = attempt + 1
     return when {
       nextAttempt < MAX_TUNNEL_ATTEMPTS -> {
-        eventListener.connectEnd(call, route.socketAddress, route.proxy, null)
+        user.callConnectEnd(route, null)
         ConnectResult(
           plan = this,
           nextPlan =
@@ -322,8 +324,7 @@ class ConnectPlan(
           ProtocolException(
             "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS",
           )
-        eventListener.connectFailed(call, route.socketAddress, route.proxy, null, failure)
-        connectionListener.connectFailed(route, call, failure)
+        user.connectFailed(route, null, failure)
         return ConnectResult(plan = this, throwable = failure)
       }
     }
@@ -428,8 +429,8 @@ class ConnectPlan(
           source = source,
           sink = sink,
         )
-      source.timeout().timeout(client.readTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)
-      sink.timeout().timeout(client.writeTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)
+      source.timeout().timeout(readTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)
+      sink.timeout().timeout(writeTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)
       tunnelCodec.writeRequest(nextRequest.headers, requestLine)
       tunnelCodec.finishRequest()
       val response =
@@ -492,10 +493,10 @@ class ConnectPlan(
 
   /** Returns the connection to use, which might be different from [connection]. */
   override fun handleSuccess(): RealConnection {
-    call.client.routeDatabase.connected(route)
+    user.updateRouteDatabaseAfterSuccess(route)
 
     val connection = this.connection!!
-    connectionListener.connectEnd(connection, route, call)
+    user.connectionConnectEnd(connection, route)
 
     // If we raced another call connecting to this host, coalesce the connections. This makes for
     // 3 different lookups in the connection pool!
@@ -503,12 +504,12 @@ class ConnectPlan(
     if (pooled3 != null) return pooled3.connection
 
     synchronized(connection) {
-      client.connectionPool.delegate.put(connection)
-      call.acquireConnectionNoEvents(connection)
+      connectionPool.put(connection)
+      user.acquireConnectionNoEvents(connection)
     }
 
-    eventListener.connectionAcquired(call, connection)
-    connection.connectionListener.connectionAcquired(connection, call)
+    user.connectionAcquired(connection)
+    user.connectionConnectionAcquired(connection)
     return connection
   }
 
@@ -531,9 +532,15 @@ class ConnectPlan(
 
   override fun retry(): RoutePlanner.Plan {
     return ConnectPlan(
-      client = client,
-      call = call,
-      chain = chain,
+      taskRunner = taskRunner,
+      connectionPool = connectionPool,
+      readTimeoutMillis = readTimeoutMillis,
+      writeTimeoutMillis = writeTimeoutMillis,
+      socketConnectTimeoutMillis = socketConnectTimeoutMillis,
+      socketReadTimeoutMillis = socketReadTimeoutMillis,
+      pingIntervalMillis = pingIntervalMillis,
+      retryOnConnectionFailure = retryOnConnectionFailure,
+      user = user,
       routePlanner = routePlanner,
       route = route,
       routes = routes,
@@ -541,7 +548,6 @@ class ConnectPlan(
       tunnelRequest = tunnelRequest,
       connectionSpecIndex = connectionSpecIndex,
       isTlsFallback = isTlsFallback,
-      connectionListener = connectionListener,
     )
   }
 
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectionUser.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectionUser.kt
new file mode 100644
index 000000000..5ebde3688
--- /dev/null
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectionUser.kt
@@ -0,0 +1,80 @@
+package okhttp3.internal.connection
+
+import java.io.IOException
+import java.net.InetAddress
+import java.net.Proxy
+import java.net.Socket
+import okhttp3.Connection
+import okhttp3.Handshake
+import okhttp3.HttpUrl
+import okhttp3.Protocol
+import okhttp3.Route
+
+/**
+ * The object that is asking for a connection. Either a call or a connect policy from the pool.
+ */
+interface ConnectionUser {
+  fun addPlanToCancel(connectPlan: ConnectPlan)
+
+  fun removePlanToCancel(connectPlan: ConnectPlan)
+
+  fun updateRouteDatabaseAfterSuccess(route: Route)
+
+  fun connectStart(route: Route)
+
+  fun secureConnectStart()
+
+  fun secureConnectEnd(handshake: Handshake?)
+
+  fun callConnectEnd(
+    route: Route,
+    protocol: Protocol?,
+  )
+
+  fun connectionConnectEnd(
+    connection: Connection,
+    route: Route,
+  )
+
+  fun connectFailed(
+    route: Route,
+    protocol: Protocol?,
+    e: IOException,
+  )
+
+  fun connectionAcquired(connection: Connection)
+
+  fun acquireConnectionNoEvents(connection: RealConnection)
+
+  fun releaseConnectionNoEvents(): Socket?
+
+  fun connectionReleased(connection: Connection)
+
+  fun connectionConnectionAcquired(connection: RealConnection)
+
+  fun connectionConnectionReleased(connection: RealConnection)
+
+  fun connectionConnectionClosed(connection: RealConnection)
+
+  fun noNewExchanges(connection: RealConnection)
+
+  fun doExtensiveHealthChecks(): Boolean
+
+  fun isCanceled(): Boolean
+
+  fun candidateConnection(): RealConnection?
+
+  fun proxySelectStart(url: HttpUrl)
+
+  fun proxySelectEnd(
+    url: HttpUrl,
+    proxies: List<Proxy>,
+  )
+
+  fun dnsStart(socketHost: String)
+
+  fun dnsEnd(
+    socketHost: String,
+    result: List<InetAddress>,
+  )
+}
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealCall.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealCall.kt
index 682af618e..b35bfe485 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealCall.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealCall.kt
@@ -247,11 +247,18 @@ class RealCall(
     if (newRoutePlanner) {
       val routePlanner =
         RealRoutePlanner(
-          client,
-          createAddress(request.url),
-          this,
-          chain,
-          connectionListener = connectionPool.connectionListener,
+          taskRunner = client.taskRunner,
+          connectionPool = connectionPool,
+          readTimeoutMillis = client.readTimeoutMillis,
+          writeTimeoutMillis = client.writeTimeoutMillis,
+          socketConnectTimeoutMillis = chain.connectTimeoutMillis,
+          socketReadTimeoutMillis = chain.readTimeoutMillis,
+          pingIntervalMillis = client.pingIntervalMillis,
+          retryOnConnectionFailure = client.retryOnConnectionFailure,
+          fastFallback = client.fastFallback,
+          address = createAddress(request.url),
+          connectionUser = CallConnectionUser(this, connectionPool.connectionListener, chain),
+          routeDatabase = client.routeDatabase,
         )
       this.exchangeFinder =
         when {
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealConnectionPool.kt
index 37974480f..8f2f345fe 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealConnectionPool.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealConnectionPool.kt
@@ -71,9 +71,9 @@ class RealConnectionPool(
   }
 
   /**
-   * Attempts to acquire a recycled connection to [address] for [call]. Returns the connection if it
+   * Attempts to acquire a recycled connection to [address] for [connectionUser]. Returns the connection if it
    * was acquired, or null if no connection was acquired. The acquired connection will also be
-   * assigned to [RealCall.connection].
+   * given to [connectionUser] who may (for example) assign it to a [RealCall.connection].
    *
    * This confirms the returned connection is healthy before returning it. If this encounters any
    * unhealthy connections in its search, this will clean them up.
@@ -85,7 +85,7 @@ class RealConnectionPool(
   fun callAcquirePooledConnection(
     doExtensiveHealthChecks: Boolean,
     address: Address,
-    call: RealCall,
+    connectionUser: ConnectionUser,
     routes: List<Route>?,
     requireMultiplexed: Boolean,
   ): RealConnection? {
@@ -97,7 +97,7 @@ class RealConnectionPool(
             requireMultiplexed && !connection.isMultiplexed -> false
             !connection.isEligible(address, routes) -> false
             else -> {
-              call.acquireConnectionNoEvents(connection)
+              connectionUser.acquireConnectionNoEvents(connection)
               true
             }
           }
@@ -114,7 +114,7 @@ class RealConnectionPool(
         synchronized(connection) {
           noNewExchangesEvent = !connection.noNewExchanges
           connection.noNewExchanges = true
-          call.releaseConnectionNoEvents()
+          connectionUser.releaseConnectionNoEvents()
         }
       if (toClose != null) {
         toClose.closeQuietly()
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt
index 886df21d0..dc81e4bbe 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt
@@ -20,10 +20,8 @@ import java.net.HttpURLConnection
 import java.net.Socket
 import java.net.UnknownServiceException
 import okhttp3.Address
-import okhttp3.ConnectionListener
 import okhttp3.ConnectionSpec
 import okhttp3.HttpUrl
-import okhttp3.OkHttpClient
 import okhttp3.Protocol
 import okhttp3.Request
 import okhttp3.Response
@@ -31,27 +29,32 @@ import okhttp3.Route
 import okhttp3.internal.USER_AGENT
 import okhttp3.internal.canReuseConnectionFor
 import okhttp3.internal.closeQuietly
+import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.connection.RoutePlanner.Plan
-import okhttp3.internal.http.RealInterceptorChain
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.toHostHeader
 
 class RealRoutePlanner(
-  private val client: OkHttpClient,
+  private val taskRunner: TaskRunner,
+  private val connectionPool: RealConnectionPool,
+  private val readTimeoutMillis: Int,
+  private val writeTimeoutMillis: Int,
+  private val socketConnectTimeoutMillis: Int,
+  private val socketReadTimeoutMillis: Int,
+  private val pingIntervalMillis: Int,
+  private val retryOnConnectionFailure: Boolean,
+  private val fastFallback: Boolean,
   override val address: Address,
-  private val call: RealCall,
-  private val chain: RealInterceptorChain,
-  private val connectionListener: ConnectionListener,
+  private val routeDatabase: RouteDatabase,
+  private val connectionUser: ConnectionUser,
 ) : RoutePlanner {
-  private val doExtensiveHealthChecks = chain.request.method != "GET"
-
   private var routeSelection: RouteSelector.Selection? = null
   private var routeSelector: RouteSelector? = null
   private var nextRouteToTry: Route? = null
 
   override val deferredPlans = ArrayDeque<Plan>()
 
-  override fun isCanceled(): Boolean = call.isCanceled()
+  override fun isCanceled(): Boolean = connectionUser.isCanceled()
 
   @Throws(IOException::class)
   override fun plan(): Plan {
@@ -84,11 +87,11 @@ class RealRoutePlanner(
    */
   private fun planReuseCallConnection(): ReusePlan? {
     // This may be mutated by releaseConnectionNoEvents()!
-    val candidate = call.connection ?: return null
+    val candidate = connectionUser.candidateConnection() ?: return null
 
     // Make sure this connection is healthy & eligible for new exchanges. If it's no longer needed
     // then we're on the hook to close it.
-    val healthy = candidate.isHealthy(doExtensiveHealthChecks)
+    val healthy = candidate.isHealthy(connectionUser.doExtensiveHealthChecks())
     var noNewExchangesEvent = false
     val toClose: Socket? =
       synchronized(candidate) {
@@ -96,10 +99,10 @@ class RealRoutePlanner(
           !healthy -> {
             noNewExchangesEvent = !candidate.noNewExchanges
             candidate.noNewExchanges = true
-            call.releaseConnectionNoEvents()
+            connectionUser.releaseConnectionNoEvents()
           }
           candidate.noNewExchanges || !sameHostAndPort(candidate.route().address.url) -> {
-            call.releaseConnectionNoEvents()
+            connectionUser.releaseConnectionNoEvents()
           }
           else -> null
         }
@@ -107,19 +110,19 @@ class RealRoutePlanner(
 
     // If the call's connection wasn't released, reuse it. We don't call connectionAcquired() here
     // because we already acquired it.
-    if (call.connection != null) {
+    if (connectionUser.candidateConnection() != null) {
       check(toClose == null)
       return ReusePlan(candidate)
     }
 
     // The call's connection was released.
     toClose?.closeQuietly()
-    call.eventListener.connectionReleased(call, candidate)
-    candidate.connectionListener.connectionReleased(candidate, call)
+    connectionUser.connectionReleased(candidate)
+    connectionUser.connectionConnectionReleased(candidate)
     if (toClose != null) {
-      candidate.connectionListener.connectionClosed(candidate)
+      connectionUser.connectionConnectionClosed(candidate)
     } else if (noNewExchangesEvent) {
-      candidate.connectionListener.noNewExchanges(candidate)
+      connectionUser.noNewExchanges(candidate)
     }
     return null
   }
@@ -146,10 +149,9 @@ class RealRoutePlanner(
       newRouteSelector =
         RouteSelector(
           address = address,
-          routeDatabase = call.client.routeDatabase,
-          call = call,
-          fastFallback = client.fastFallback,
-          eventListener = call.eventListener,
+          routeDatabase = routeDatabase,
+          connectionUser = connectionUser,
+          fastFallback = fastFallback,
         )
       routeSelector = newRouteSelector
     }
@@ -159,7 +161,7 @@ class RealRoutePlanner(
     val newRouteSelection = newRouteSelector.next()
     routeSelection = newRouteSelection
 
-    if (call.isCanceled()) throw IOException("Canceled")
+    if (isCanceled()) throw IOException("Canceled")
 
     return planConnectToRoute(newRouteSelection.next(), newRouteSelection.routes)
   }
@@ -176,10 +178,10 @@ class RealRoutePlanner(
     routes: List<Route>? = null,
   ): ReusePlan? {
     val result =
-      client.connectionPool.delegate.callAcquirePooledConnection(
-        doExtensiveHealthChecks = doExtensiveHealthChecks,
+      connectionPool.callAcquirePooledConnection(
+        doExtensiveHealthChecks = connectionUser.doExtensiveHealthChecks(),
         address = address,
-        call = call,
+        connectionUser = connectionUser,
         routes = routes,
         requireMultiplexed = planToReplace != null && planToReplace.isReady,
       ) ?: return null
@@ -191,8 +193,8 @@ class RealRoutePlanner(
       planToReplace.closeQuietly()
     }
 
-    call.eventListener.connectionAcquired(call, result)
-    result.connectionListener.connectionAcquired(result, call)
+    connectionUser.connectionAcquired(result)
+    connectionUser.connectionConnectionAcquired(result)
     return ReusePlan(result)
   }
 
@@ -226,9 +228,15 @@ class RealRoutePlanner(
       }
 
     return ConnectPlan(
-      client = client,
-      call = call,
-      chain = chain,
+      taskRunner = taskRunner,
+      connectionPool = connectionPool,
+      readTimeoutMillis = readTimeoutMillis,
+      writeTimeoutMillis = writeTimeoutMillis,
+      socketConnectTimeoutMillis = socketConnectTimeoutMillis,
+      socketReadTimeoutMillis = socketReadTimeoutMillis,
+      pingIntervalMillis = pingIntervalMillis,
+      retryOnConnectionFailure = retryOnConnectionFailure,
+      user = connectionUser,
       routePlanner = this,
       route = route,
       routes = routes,
@@ -236,7 +244,6 @@ class RealRoutePlanner(
       tunnelRequest = tunnelRequest,
       connectionSpecIndex = -1,
       isTlsFallback = false,
-      connectionListener = connectionListener,
     )
   }
 
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/RouteSelector.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/RouteSelector.kt
index 4b44dba16..e5f206fc2 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/RouteSelector.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/RouteSelector.kt
@@ -23,8 +23,6 @@ import java.net.SocketException
 import java.net.UnknownHostException
 import java.util.NoSuchElementException
 import okhttp3.Address
-import okhttp3.Call
-import okhttp3.EventListener
 import okhttp3.HttpUrl
 import okhttp3.Route
 import okhttp3.internal.canParseAsIpAddress
@@ -38,9 +36,8 @@ import okhttp3.internal.toImmutableList
 class RouteSelector(
   private val address: Address,
   private val routeDatabase: RouteDatabase,
-  private val call: Call,
+  private val connectionUser: ConnectionUser,
   private val fastFallback: Boolean,
-  private val eventListener: EventListener,
 ) {
   // State for negotiating the next proxy to use.
   private var proxies = emptyList<Proxy>()
@@ -115,10 +112,10 @@ class RouteSelector(
       return proxiesOrNull.toImmutableList()
     }
 
-    eventListener.proxySelectStart(call, url)
+    connectionUser.proxySelectStart(url)
     proxies = selectProxies()
     nextProxyIndex = 0
-    eventListener.proxySelectEnd(call, url, proxies)
+    connectionUser.proxySelectEnd(url, proxies)
   }
 
   /** Returns true if there's another proxy to try. */
@@ -169,14 +166,14 @@ class RouteSelector(
         if (socketHost.canParseAsIpAddress()) {
           listOf(InetAddress.getByName(socketHost))
         } else {
-          eventListener.dnsStart(call, socketHost)
+          connectionUser.dnsStart(socketHost)
 
           val result = address.dns.lookup(socketHost)
           if (result.isEmpty()) {
             throw UnknownHostException("${address.dns} returned no addresses for $socketHost")
           }
 
-          eventListener.dnsEnd(call, socketHost, result)
+          connectionUser.dnsEnd(socketHost, result)
           result
         }
 
