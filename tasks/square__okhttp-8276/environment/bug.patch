diff --git a/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt b/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
index 10404f7dd..46c2f4a9a 100644
--- a/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
+++ b/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
@@ -13,12 +13,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-@file:Suppress(
-  "CANNOT_OVERRIDE_INVISIBLE_MEMBER",
-  "INVISIBLE_MEMBER",
-  "INVISIBLE_REFERENCE",
-)
-
 package okhttp3
 
 import java.io.Closeable
@@ -34,7 +28,6 @@ import javax.net.ssl.SSLSocketFactory
 import okhttp3.internal.RecordingOkAuthenticator
 import okhttp3.internal.concurrent.TaskFaker
 import okhttp3.internal.concurrent.TaskRunner
-import okhttp3.internal.connection.CallConnectionUser
 import okhttp3.internal.connection.RealCall
 import okhttp3.internal.connection.RealConnection
 import okhttp3.internal.connection.RealConnectionPool
@@ -184,26 +177,7 @@ class TestValueFactory : Closeable {
     address: Address = newAddress(),
   ): RealRoutePlanner {
     val call = RealCall(client, Request(address.url), forWebSocket = false)
-    val chain = newChain(call)
-    return RealRoutePlanner(
-      taskRunner = client.taskRunner,
-      connectionPool = client.connectionPool.delegate,
-      readTimeoutMillis = client.readTimeoutMillis,
-      writeTimeoutMillis = client.writeTimeoutMillis,
-      socketConnectTimeoutMillis = chain.connectTimeoutMillis,
-      socketReadTimeoutMillis = chain.readTimeoutMillis,
-      pingIntervalMillis = client.pingIntervalMillis,
-      retryOnConnectionFailure = client.retryOnConnectionFailure,
-      fastFallback = client.fastFallback,
-      address = address,
-      routeDatabase = client.routeDatabase,
-      connectionUser =
-        CallConnectionUser(
-          call,
-          client.connectionPool.delegate.connectionListener,
-          chain,
-        ),
-    )
+    return RealRoutePlanner(client, address, call, newChain(call), ConnectionListener.NONE)
   }
 
   override fun close() {
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/CallConnectionUser.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/CallConnectionUser.kt
deleted file mode 100644
index 8a28086a4..000000000
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/CallConnectionUser.kt
+++ /dev/null
@@ -1,140 +0,0 @@
-package okhttp3.internal.connection
-
-import java.io.IOException
-import java.net.InetAddress
-import java.net.Proxy
-import java.net.Socket
-import okhttp3.Connection
-import okhttp3.ConnectionListener
-import okhttp3.EventListener
-import okhttp3.Handshake
-import okhttp3.HttpUrl
-import okhttp3.Protocol
-import okhttp3.Route
-import okhttp3.internal.http.RealInterceptorChain
-
-/**
- * A connection user that is a specific [RealCall].
- */
-internal class CallConnectionUser(
-  private val call: RealCall,
-  private val poolConnectionListener: ConnectionListener,
-  private val chain: RealInterceptorChain,
-) : ConnectionUser {
-  private val eventListener: EventListener
-    get() = call.eventListener
-
-  override fun addPlanToCancel(connectPlan: ConnectPlan) {
-    call.plansToCancel += connectPlan
-  }
-
-  override fun removePlanToCancel(connectPlan: ConnectPlan) {
-    call.plansToCancel -= connectPlan
-  }
-
-  override fun updateRouteDatabaseAfterSuccess(route: Route) {
-    call.client.routeDatabase.connected(route)
-  }
-
-  override fun connectStart(route: Route) {
-    eventListener.connectStart(call, route.socketAddress, route.proxy)
-    poolConnectionListener.connectStart(route, call)
-  }
-
-  override fun connectFailed(
-    route: Route,
-    protocol: Protocol?,
-    e: IOException,
-  ) {
-    eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
-    poolConnectionListener.connectFailed(route, call, e)
-  }
-
-  override fun secureConnectStart() {
-    eventListener.secureConnectStart(call)
-  }
-
-  override fun secureConnectEnd(handshake: Handshake?) {
-    eventListener.secureConnectEnd(call, handshake)
-  }
-
-  override fun callConnectEnd(
-    route: Route,
-    protocol: Protocol?,
-  ) {
-    eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
-  }
-
-  override fun connectionConnectEnd(
-    connection: Connection,
-    route: Route,
-  ) {
-    poolConnectionListener.connectEnd(connection, route, call)
-  }
-
-  override fun connectionAcquired(connection: Connection) {
-    eventListener.connectionAcquired(call, connection)
-  }
-
-  override fun acquireConnectionNoEvents(connection: RealConnection) {
-    call.acquireConnectionNoEvents(connection)
-  }
-
-  override fun releaseConnectionNoEvents(): Socket? {
-    return call.releaseConnectionNoEvents()
-  }
-
-  override fun connectionReleased(connection: Connection) {
-    eventListener.connectionReleased(call, connection)
-  }
-
-  override fun connectionConnectionAcquired(connection: RealConnection) {
-    connection.connectionListener.connectionAcquired(connection, call)
-  }
-
-  override fun connectionConnectionReleased(connection: RealConnection) {
-    connection.connectionListener.connectionReleased(connection, call)
-  }
-
-  override fun connectionConnectionClosed(connection: RealConnection) {
-    connection.connectionListener.connectionClosed(connection)
-  }
-
-  override fun noNewExchanges(connection: RealConnection) {
-    connection.connectionListener.noNewExchanges(connection)
-  }
-
-  override fun doExtensiveHealthChecks(): Boolean {
-    return chain.request.method != "GET"
-  }
-
-  override fun isCanceled(): Boolean {
-    return call.isCanceled()
-  }
-
-  override fun candidateConnection(): RealConnection? {
-    return call.connection
-  }
-
-  override fun proxySelectStart(url: HttpUrl) {
-    eventListener.proxySelectStart(call, url)
-  }
-
-  override fun proxySelectEnd(
-    url: HttpUrl,
-    proxies: List<Proxy>,
-  ) {
-    eventListener.proxySelectEnd(call, url, proxies)
-  }
-
-  override fun dnsStart(socketHost: String) {
-    eventListener.dnsStart(call, socketHost)
-  }
-
-  override fun dnsEnd(
-    socketHost: String,
-    result: List<InetAddress>,
-  ) {
-    eventListener.dnsEnd(call, socketHost, result)
-  }
-}
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectPlan.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectPlan.kt
index a5c31f9cf..fd6c8a125 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectPlan.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectPlan.kt
@@ -27,14 +27,16 @@ import java.util.concurrent.TimeUnit
 import javax.net.ssl.SSLPeerUnverifiedException
 import javax.net.ssl.SSLSocket
 import okhttp3.CertificatePinner
+import okhttp3.ConnectionListener
 import okhttp3.ConnectionSpec
 import okhttp3.Handshake
 import okhttp3.Handshake.Companion.handshake
+import okhttp3.Interceptor
+import okhttp3.OkHttpClient
 import okhttp3.Protocol
 import okhttp3.Request
 import okhttp3.Route
 import okhttp3.internal.closeQuietly
-import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.connection.RoutePlanner.ConnectResult
 import okhttp3.internal.http.ExchangeCodec
 import okhttp3.internal.http1.Http1ExchangeCodec
@@ -59,15 +61,10 @@ import okio.source
  * will be configured differently.
  */
 class ConnectPlan(
-  private val taskRunner: TaskRunner,
-  private val connectionPool: RealConnectionPool,
-  private val readTimeoutMillis: Int,
-  private val writeTimeoutMillis: Int,
-  private val socketConnectTimeoutMillis: Int,
-  private val socketReadTimeoutMillis: Int,
-  private val pingIntervalMillis: Int,
-  private val retryOnConnectionFailure: Boolean,
-  private val user: ConnectionUser,
+  // Configuration and state scoped to the call.
+  private val client: OkHttpClient,
+  private val call: RealCall,
+  private val chain: Interceptor.Chain,
   private val routePlanner: RealRoutePlanner,
   // Specifics to this plan.
   override val route: Route,
@@ -76,7 +73,10 @@ class ConnectPlan(
   private val tunnelRequest: Request?,
   internal val connectionSpecIndex: Int,
   internal val isTlsFallback: Boolean,
+  internal val connectionListener: ConnectionListener,
 ) : RoutePlanner.Plan, ExchangeCodec.Carrier {
+  private val eventListener = call.eventListener
+
   /** True if this connect was canceled; typically because it lost a race. */
   @Volatile private var canceled = false
 
@@ -107,15 +107,9 @@ class ConnectPlan(
     isTlsFallback: Boolean = this.isTlsFallback,
   ): ConnectPlan {
     return ConnectPlan(
-      taskRunner = taskRunner,
-      connectionPool = connectionPool,
-      readTimeoutMillis = readTimeoutMillis,
-      writeTimeoutMillis = writeTimeoutMillis,
-      socketConnectTimeoutMillis = socketConnectTimeoutMillis,
-      socketReadTimeoutMillis = socketReadTimeoutMillis,
-      pingIntervalMillis = pingIntervalMillis,
-      retryOnConnectionFailure = retryOnConnectionFailure,
-      user = user,
+      client = client,
+      call = call,
+      chain = chain,
       routePlanner = routePlanner,
       route = route,
       routes = routes,
@@ -123,6 +117,7 @@ class ConnectPlan(
       tunnelRequest = tunnelRequest,
       connectionSpecIndex = connectionSpecIndex,
       isTlsFallback = isTlsFallback,
+      connectionListener = connectionListener,
     )
   }
 
@@ -132,18 +127,20 @@ class ConnectPlan(
     var success = false
 
     // Tell the call about the connecting call so async cancels work.
-    user.addPlanToCancel(this)
+    call.plansToCancel += this
     try {
-      user.connectStart(route)
+      eventListener.connectStart(call, route.socketAddress, route.proxy)
+      connectionListener.connectStart(route, call)
 
       connectSocket()
       success = true
       return ConnectResult(plan = this)
     } catch (e: IOException) {
-      user.connectFailed(route, null, e)
+      eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
+      connectionListener.connectFailed(route, call, e)
       return ConnectResult(plan = this, throwable = e)
     } finally {
-      user.removePlanToCancel(this)
+      call.plansToCancel -= this
       if (!success) {
         rawSocket?.closeQuietly()
       }
@@ -159,7 +156,7 @@ class ConnectPlan(
     var success = false
 
     // Tell the call about the connecting call so async cancels work.
-    user.addPlanToCancel(this)
+    call.plansToCancel += this
     try {
       if (tunnelRequest != null) {
         val tunnelResult = connectTunnel()
@@ -179,7 +176,7 @@ class ConnectPlan(
           throw IOException("TLS tunnel buffered too many bytes!")
         }
 
-        user.secureConnectStart()
+        eventListener.secureConnectStart(call)
 
         // Create the wrapper over the connected socket.
         val sslSocket =
@@ -199,7 +196,7 @@ class ConnectPlan(
 
         connectionSpec.apply(sslSocket, isFallback = tlsEquipPlan.isTlsFallback)
         connectTls(sslSocket, connectionSpec)
-        user.secureConnectEnd(handshake)
+        eventListener.secureConnectEnd(call, handshake)
       } else {
         socket = rawSocket
         protocol =
@@ -211,8 +208,8 @@ class ConnectPlan(
 
       val connection =
         RealConnection(
-          taskRunner = taskRunner,
-          connectionPool = connectionPool,
+          taskRunner = client.taskRunner,
+          connectionPool = client.connectionPool.delegate,
           route = route,
           rawSocket = rawSocket,
           socket = socket,
@@ -220,20 +217,21 @@ class ConnectPlan(
           protocol = protocol,
           source = source,
           sink = sink,
-          pingIntervalMillis = pingIntervalMillis,
-          connectionListener = connectionPool.connectionListener,
+          pingIntervalMillis = client.pingIntervalMillis,
+          connectionListener = client.connectionPool.connectionListener,
         )
       this.connection = connection
       connection.start()
 
       // Success.
-      user.callConnectEnd(route, protocol)
+      eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
       success = true
       return ConnectResult(plan = this)
     } catch (e: IOException) {
-      user.connectFailed(route, null, e)
+      eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
+      connectionListener.connectFailed(route, call, e)
 
-      if (!retryOnConnectionFailure || !retryTlsHandshake(e)) {
+      if (!client.retryOnConnectionFailure || !retryTlsHandshake(e)) {
         retryTlsConnection = null
       }
 
@@ -243,7 +241,7 @@ class ConnectPlan(
         throwable = e,
       )
     } finally {
-      user.removePlanToCancel(this)
+      call.plansToCancel -= this
       if (!success) {
         socket?.closeQuietly()
         rawSocket?.closeQuietly()
@@ -266,9 +264,9 @@ class ConnectPlan(
       throw IOException("canceled")
     }
 
-    rawSocket.soTimeout = socketReadTimeoutMillis
+    rawSocket.soTimeout = chain.readTimeoutMillis()
     try {
-      Platform.get().connectSocket(rawSocket, route.socketAddress, socketConnectTimeoutMillis)
+      Platform.get().connectSocket(rawSocket, route.socketAddress, chain.connectTimeoutMillis())
     } catch (e: ConnectException) {
       throw ConnectException("Failed to connect to ${route.socketAddress}").apply {
         initCause(e)
@@ -309,7 +307,7 @@ class ConnectPlan(
     val nextAttempt = attempt + 1
     return when {
       nextAttempt < MAX_TUNNEL_ATTEMPTS -> {
-        user.callConnectEnd(route, null)
+        eventListener.connectEnd(call, route.socketAddress, route.proxy, null)
         ConnectResult(
           plan = this,
           nextPlan =
@@ -324,7 +322,8 @@ class ConnectPlan(
           ProtocolException(
             "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS",
           )
-        user.connectFailed(route, null, failure)
+        eventListener.connectFailed(call, route.socketAddress, route.proxy, null, failure)
+        connectionListener.connectFailed(route, call, failure)
         return ConnectResult(plan = this, throwable = failure)
       }
     }
@@ -429,8 +428,8 @@ class ConnectPlan(
           source = source,
           sink = sink,
         )
-      source.timeout().timeout(readTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)
-      sink.timeout().timeout(writeTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)
+      source.timeout().timeout(client.readTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)
+      sink.timeout().timeout(client.writeTimeoutMillis.toLong(), TimeUnit.MILLISECONDS)
       tunnelCodec.writeRequest(nextRequest.headers, requestLine)
       tunnelCodec.finishRequest()
       val response =
@@ -493,10 +492,10 @@ class ConnectPlan(
 
   /** Returns the connection to use, which might be different from [connection]. */
   override fun handleSuccess(): RealConnection {
-    user.updateRouteDatabaseAfterSuccess(route)
+    call.client.routeDatabase.connected(route)
 
     val connection = this.connection!!
-    user.connectionConnectEnd(connection, route)
+    connectionListener.connectEnd(connection, route, call)
 
     // If we raced another call connecting to this host, coalesce the connections. This makes for
     // 3 different lookups in the connection pool!
@@ -504,12 +503,12 @@ class ConnectPlan(
     if (pooled3 != null) return pooled3.connection
 
     synchronized(connection) {
-      connectionPool.put(connection)
-      user.acquireConnectionNoEvents(connection)
+      client.connectionPool.delegate.put(connection)
+      call.acquireConnectionNoEvents(connection)
     }
 
-    user.connectionAcquired(connection)
-    user.connectionConnectionAcquired(connection)
+    eventListener.connectionAcquired(call, connection)
+    connection.connectionListener.connectionAcquired(connection, call)
     return connection
   }
 
@@ -532,15 +531,9 @@ class ConnectPlan(
 
   override fun retry(): RoutePlanner.Plan {
     return ConnectPlan(
-      taskRunner = taskRunner,
-      connectionPool = connectionPool,
-      readTimeoutMillis = readTimeoutMillis,
-      writeTimeoutMillis = writeTimeoutMillis,
-      socketConnectTimeoutMillis = socketConnectTimeoutMillis,
-      socketReadTimeoutMillis = socketReadTimeoutMillis,
-      pingIntervalMillis = pingIntervalMillis,
-      retryOnConnectionFailure = retryOnConnectionFailure,
-      user = user,
+      client = client,
+      call = call,
+      chain = chain,
       routePlanner = routePlanner,
       route = route,
       routes = routes,
@@ -548,6 +541,7 @@ class ConnectPlan(
       tunnelRequest = tunnelRequest,
       connectionSpecIndex = connectionSpecIndex,
       isTlsFallback = isTlsFallback,
+      connectionListener = connectionListener,
     )
   }
 
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectionUser.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectionUser.kt
deleted file mode 100644
index 5ebde3688..000000000
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/ConnectionUser.kt
+++ /dev/null
@@ -1,80 +0,0 @@
-package okhttp3.internal.connection
-
-import java.io.IOException
-import java.net.InetAddress
-import java.net.Proxy
-import java.net.Socket
-import okhttp3.Connection
-import okhttp3.Handshake
-import okhttp3.HttpUrl
-import okhttp3.Protocol
-import okhttp3.Route
-
-/**
- * The object that is asking for a connection. Either a call or a connect policy from the pool.
- */
-interface ConnectionUser {
-  fun addPlanToCancel(connectPlan: ConnectPlan)
-
-  fun removePlanToCancel(connectPlan: ConnectPlan)
-
-  fun updateRouteDatabaseAfterSuccess(route: Route)
-
-  fun connectStart(route: Route)
-
-  fun secureConnectStart()
-
-  fun secureConnectEnd(handshake: Handshake?)
-
-  fun callConnectEnd(
-    route: Route,
-    protocol: Protocol?,
-  )
-
-  fun connectionConnectEnd(
-    connection: Connection,
-    route: Route,
-  )
-
-  fun connectFailed(
-    route: Route,
-    protocol: Protocol?,
-    e: IOException,
-  )
-
-  fun connectionAcquired(connection: Connection)
-
-  fun acquireConnectionNoEvents(connection: RealConnection)
-
-  fun releaseConnectionNoEvents(): Socket?
-
-  fun connectionReleased(connection: Connection)
-
-  fun connectionConnectionAcquired(connection: RealConnection)
-
-  fun connectionConnectionReleased(connection: RealConnection)
-
-  fun connectionConnectionClosed(connection: RealConnection)
-
-  fun noNewExchanges(connection: RealConnection)
-
-  fun doExtensiveHealthChecks(): Boolean
-
-  fun isCanceled(): Boolean
-
-  fun candidateConnection(): RealConnection?
-
-  fun proxySelectStart(url: HttpUrl)
-
-  fun proxySelectEnd(
-    url: HttpUrl,
-    proxies: List<Proxy>,
-  )
-
-  fun dnsStart(socketHost: String)
-
-  fun dnsEnd(
-    socketHost: String,
-    result: List<InetAddress>,
-  )
-}
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealCall.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealCall.kt
index b35bfe485..682af618e 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealCall.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealCall.kt
@@ -247,18 +247,11 @@ class RealCall(
     if (newRoutePlanner) {
       val routePlanner =
         RealRoutePlanner(
-          taskRunner = client.taskRunner,
-          connectionPool = connectionPool,
-          readTimeoutMillis = client.readTimeoutMillis,
-          writeTimeoutMillis = client.writeTimeoutMillis,
-          socketConnectTimeoutMillis = chain.connectTimeoutMillis,
-          socketReadTimeoutMillis = chain.readTimeoutMillis,
-          pingIntervalMillis = client.pingIntervalMillis,
-          retryOnConnectionFailure = client.retryOnConnectionFailure,
-          fastFallback = client.fastFallback,
-          address = createAddress(request.url),
-          connectionUser = CallConnectionUser(this, connectionPool.connectionListener, chain),
-          routeDatabase = client.routeDatabase,
+          client,
+          createAddress(request.url),
+          this,
+          chain,
+          connectionListener = connectionPool.connectionListener,
         )
       this.exchangeFinder =
         when {
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealConnectionPool.kt
index 8f2f345fe..37974480f 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealConnectionPool.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealConnectionPool.kt
@@ -71,9 +71,9 @@ class RealConnectionPool(
   }
 
   /**
-   * Attempts to acquire a recycled connection to [address] for [connectionUser]. Returns the connection if it
+   * Attempts to acquire a recycled connection to [address] for [call]. Returns the connection if it
    * was acquired, or null if no connection was acquired. The acquired connection will also be
-   * given to [connectionUser] who may (for example) assign it to a [RealCall.connection].
+   * assigned to [RealCall.connection].
    *
    * This confirms the returned connection is healthy before returning it. If this encounters any
    * unhealthy connections in its search, this will clean them up.
@@ -85,7 +85,7 @@ class RealConnectionPool(
   fun callAcquirePooledConnection(
     doExtensiveHealthChecks: Boolean,
     address: Address,
-    connectionUser: ConnectionUser,
+    call: RealCall,
     routes: List<Route>?,
     requireMultiplexed: Boolean,
   ): RealConnection? {
@@ -97,7 +97,7 @@ class RealConnectionPool(
             requireMultiplexed && !connection.isMultiplexed -> false
             !connection.isEligible(address, routes) -> false
             else -> {
-              connectionUser.acquireConnectionNoEvents(connection)
+              call.acquireConnectionNoEvents(connection)
               true
             }
           }
@@ -114,7 +114,7 @@ class RealConnectionPool(
         synchronized(connection) {
           noNewExchangesEvent = !connection.noNewExchanges
           connection.noNewExchanges = true
-          connectionUser.releaseConnectionNoEvents()
+          call.releaseConnectionNoEvents()
         }
       if (toClose != null) {
         toClose.closeQuietly()
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt
index dc81e4bbe..886df21d0 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt
@@ -20,8 +20,10 @@ import java.net.HttpURLConnection
 import java.net.Socket
 import java.net.UnknownServiceException
 import okhttp3.Address
+import okhttp3.ConnectionListener
 import okhttp3.ConnectionSpec
 import okhttp3.HttpUrl
+import okhttp3.OkHttpClient
 import okhttp3.Protocol
 import okhttp3.Request
 import okhttp3.Response
@@ -29,32 +31,27 @@ import okhttp3.Route
 import okhttp3.internal.USER_AGENT
 import okhttp3.internal.canReuseConnectionFor
 import okhttp3.internal.closeQuietly
-import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.connection.RoutePlanner.Plan
+import okhttp3.internal.http.RealInterceptorChain
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.toHostHeader
 
 class RealRoutePlanner(
-  private val taskRunner: TaskRunner,
-  private val connectionPool: RealConnectionPool,
-  private val readTimeoutMillis: Int,
-  private val writeTimeoutMillis: Int,
-  private val socketConnectTimeoutMillis: Int,
-  private val socketReadTimeoutMillis: Int,
-  private val pingIntervalMillis: Int,
-  private val retryOnConnectionFailure: Boolean,
-  private val fastFallback: Boolean,
+  private val client: OkHttpClient,
   override val address: Address,
-  private val routeDatabase: RouteDatabase,
-  private val connectionUser: ConnectionUser,
+  private val call: RealCall,
+  private val chain: RealInterceptorChain,
+  private val connectionListener: ConnectionListener,
 ) : RoutePlanner {
+  private val doExtensiveHealthChecks = chain.request.method != "GET"
+
   private var routeSelection: RouteSelector.Selection? = null
   private var routeSelector: RouteSelector? = null
   private var nextRouteToTry: Route? = null
 
   override val deferredPlans = ArrayDeque<Plan>()
 
-  override fun isCanceled(): Boolean = connectionUser.isCanceled()
+  override fun isCanceled(): Boolean = call.isCanceled()
 
   @Throws(IOException::class)
   override fun plan(): Plan {
@@ -87,11 +84,11 @@ class RealRoutePlanner(
    */
   private fun planReuseCallConnection(): ReusePlan? {
     // This may be mutated by releaseConnectionNoEvents()!
-    val candidate = connectionUser.candidateConnection() ?: return null
+    val candidate = call.connection ?: return null
 
     // Make sure this connection is healthy & eligible for new exchanges. If it's no longer needed
     // then we're on the hook to close it.
-    val healthy = candidate.isHealthy(connectionUser.doExtensiveHealthChecks())
+    val healthy = candidate.isHealthy(doExtensiveHealthChecks)
     var noNewExchangesEvent = false
     val toClose: Socket? =
       synchronized(candidate) {
@@ -99,10 +96,10 @@ class RealRoutePlanner(
           !healthy -> {
             noNewExchangesEvent = !candidate.noNewExchanges
             candidate.noNewExchanges = true
-            connectionUser.releaseConnectionNoEvents()
+            call.releaseConnectionNoEvents()
           }
           candidate.noNewExchanges || !sameHostAndPort(candidate.route().address.url) -> {
-            connectionUser.releaseConnectionNoEvents()
+            call.releaseConnectionNoEvents()
           }
           else -> null
         }
@@ -110,19 +107,19 @@ class RealRoutePlanner(
 
     // If the call's connection wasn't released, reuse it. We don't call connectionAcquired() here
     // because we already acquired it.
-    if (connectionUser.candidateConnection() != null) {
+    if (call.connection != null) {
       check(toClose == null)
       return ReusePlan(candidate)
     }
 
     // The call's connection was released.
     toClose?.closeQuietly()
-    connectionUser.connectionReleased(candidate)
-    connectionUser.connectionConnectionReleased(candidate)
+    call.eventListener.connectionReleased(call, candidate)
+    candidate.connectionListener.connectionReleased(candidate, call)
     if (toClose != null) {
-      connectionUser.connectionConnectionClosed(candidate)
+      candidate.connectionListener.connectionClosed(candidate)
     } else if (noNewExchangesEvent) {
-      connectionUser.noNewExchanges(candidate)
+      candidate.connectionListener.noNewExchanges(candidate)
     }
     return null
   }
@@ -149,9 +146,10 @@ class RealRoutePlanner(
       newRouteSelector =
         RouteSelector(
           address = address,
-          routeDatabase = routeDatabase,
-          connectionUser = connectionUser,
-          fastFallback = fastFallback,
+          routeDatabase = call.client.routeDatabase,
+          call = call,
+          fastFallback = client.fastFallback,
+          eventListener = call.eventListener,
         )
       routeSelector = newRouteSelector
     }
@@ -161,7 +159,7 @@ class RealRoutePlanner(
     val newRouteSelection = newRouteSelector.next()
     routeSelection = newRouteSelection
 
-    if (isCanceled()) throw IOException("Canceled")
+    if (call.isCanceled()) throw IOException("Canceled")
 
     return planConnectToRoute(newRouteSelection.next(), newRouteSelection.routes)
   }
@@ -178,10 +176,10 @@ class RealRoutePlanner(
     routes: List<Route>? = null,
   ): ReusePlan? {
     val result =
-      connectionPool.callAcquirePooledConnection(
-        doExtensiveHealthChecks = connectionUser.doExtensiveHealthChecks(),
+      client.connectionPool.delegate.callAcquirePooledConnection(
+        doExtensiveHealthChecks = doExtensiveHealthChecks,
         address = address,
-        connectionUser = connectionUser,
+        call = call,
         routes = routes,
         requireMultiplexed = planToReplace != null && planToReplace.isReady,
       ) ?: return null
@@ -193,8 +191,8 @@ class RealRoutePlanner(
       planToReplace.closeQuietly()
     }
 
-    connectionUser.connectionAcquired(result)
-    connectionUser.connectionConnectionAcquired(result)
+    call.eventListener.connectionAcquired(call, result)
+    result.connectionListener.connectionAcquired(result, call)
     return ReusePlan(result)
   }
 
@@ -228,15 +226,9 @@ class RealRoutePlanner(
       }
 
     return ConnectPlan(
-      taskRunner = taskRunner,
-      connectionPool = connectionPool,
-      readTimeoutMillis = readTimeoutMillis,
-      writeTimeoutMillis = writeTimeoutMillis,
-      socketConnectTimeoutMillis = socketConnectTimeoutMillis,
-      socketReadTimeoutMillis = socketReadTimeoutMillis,
-      pingIntervalMillis = pingIntervalMillis,
-      retryOnConnectionFailure = retryOnConnectionFailure,
-      user = connectionUser,
+      client = client,
+      call = call,
+      chain = chain,
       routePlanner = this,
       route = route,
       routes = routes,
@@ -244,6 +236,7 @@ class RealRoutePlanner(
       tunnelRequest = tunnelRequest,
       connectionSpecIndex = -1,
       isTlsFallback = false,
+      connectionListener = connectionListener,
     )
   }
 
diff --git a/okhttp/src/main/kotlin/okhttp3/internal/connection/RouteSelector.kt b/okhttp/src/main/kotlin/okhttp3/internal/connection/RouteSelector.kt
index e5f206fc2..4b44dba16 100644
--- a/okhttp/src/main/kotlin/okhttp3/internal/connection/RouteSelector.kt
+++ b/okhttp/src/main/kotlin/okhttp3/internal/connection/RouteSelector.kt
@@ -23,6 +23,8 @@ import java.net.SocketException
 import java.net.UnknownHostException
 import java.util.NoSuchElementException
 import okhttp3.Address
+import okhttp3.Call
+import okhttp3.EventListener
 import okhttp3.HttpUrl
 import okhttp3.Route
 import okhttp3.internal.canParseAsIpAddress
@@ -36,8 +38,9 @@ import okhttp3.internal.toImmutableList
 class RouteSelector(
   private val address: Address,
   private val routeDatabase: RouteDatabase,
-  private val connectionUser: ConnectionUser,
+  private val call: Call,
   private val fastFallback: Boolean,
+  private val eventListener: EventListener,
 ) {
   // State for negotiating the next proxy to use.
   private var proxies = emptyList<Proxy>()
@@ -112,10 +115,10 @@ class RouteSelector(
       return proxiesOrNull.toImmutableList()
     }
 
-    connectionUser.proxySelectStart(url)
+    eventListener.proxySelectStart(call, url)
     proxies = selectProxies()
     nextProxyIndex = 0
-    connectionUser.proxySelectEnd(url, proxies)
+    eventListener.proxySelectEnd(call, url, proxies)
   }
 
   /** Returns true if there's another proxy to try. */
@@ -166,14 +169,14 @@ class RouteSelector(
         if (socketHost.canParseAsIpAddress()) {
           listOf(InetAddress.getByName(socketHost))
         } else {
-          connectionUser.dnsStart(socketHost)
+          eventListener.dnsStart(call, socketHost)
 
           val result = address.dns.lookup(socketHost)
           if (result.isEmpty()) {
             throw UnknownHostException("${address.dns} returned no addresses for $socketHost")
           }
 
-          connectionUser.dnsEnd(socketHost, result)
+          eventListener.dnsEnd(call, socketHost, result)
           result
         }
 
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.kt b/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.kt
index fd2c27503..8bd37d39b 100644
--- a/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.kt
+++ b/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.kt
@@ -31,14 +31,14 @@ import java.net.URI
 import java.net.UnknownHostException
 import kotlin.test.assertFailsWith
 import okhttp3.Address
-import okhttp3.ConnectionListener
+import okhttp3.Call
+import okhttp3.EventListener
 import okhttp3.FakeDns
 import okhttp3.OkHttpClientTestRule
 import okhttp3.Request
 import okhttp3.Route
 import okhttp3.TestValueFactory
 import okhttp3.internal.connection.RouteSelector.Companion.socketHost
-import okhttp3.internal.http.RealInterceptorChain
 import okhttp3.internal.http.RecordingProxySelector
 import okhttp3.testing.PlatformRule
 import org.junit.jupiter.api.AfterEach
@@ -65,7 +65,7 @@ class RouteSelectorTest {
       this.uriPort = this@RouteSelectorTest.uriPort
     }
 
-  private lateinit var call: RealCall
+  private lateinit var call: Call
   private val routeDatabase = RouteDatabase()
 
   @BeforeEach fun setUp() {
@@ -74,7 +74,7 @@ class RouteSelectorTest {
         Request.Builder()
           .url("https://$uriHost:$uriPort/")
           .build(),
-      ) as RealCall
+      )
   }
 
   @AfterEach fun tearDown() {
@@ -550,26 +550,14 @@ class RouteSelectorTest {
     address: Address,
     routeDatabase: RouteDatabase = this.routeDatabase,
     fastFallback: Boolean = false,
-    call: RealCall = this.call,
+    call: Call = this.call,
   ): RouteSelector {
     return RouteSelector(
       address = address,
       routeDatabase = routeDatabase,
-      fastFallback = fastFallback,
-      connectionUser = CallConnectionUser(call, ConnectionListener.NONE, newChain(call)),
-    )
-  }
-
-  private fun newChain(call: RealCall): RealInterceptorChain {
-    return RealInterceptorChain(
       call = call,
-      interceptors = listOf(),
-      index = 0,
-      exchange = null,
-      request = call.request(),
-      connectTimeoutMillis = 10_000,
-      readTimeoutMillis = 10_000,
-      writeTimeoutMillis = 10_000,
+      fastFallback = fastFallback,
+      eventListener = EventListener.NONE,
     )
   }
 
