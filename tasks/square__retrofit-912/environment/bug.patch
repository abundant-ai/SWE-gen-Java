diff --git a/retrofit/src/main/java/retrofit/DefaultCallAdapterFactory.java b/retrofit/src/main/java/retrofit/DefaultCallAdapterFactory.java
index a1147cc0..a4919c3d 100644
--- a/retrofit/src/main/java/retrofit/DefaultCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit/DefaultCallAdapterFactory.java
@@ -28,7 +28,7 @@ final class DefaultCallAdapterFactory implements CallAdapter.Factory {
   }
 
   @Override public String toString() {
-    return "Default CallAdapterFactory";
+    return "Built-in CallAdapterFactory";
   }
 
   @Override public CallAdapter<?> get(Type returnType) {
diff --git a/retrofit/src/main/java/retrofit/MethodHandler.java b/retrofit/src/main/java/retrofit/MethodHandler.java
deleted file mode 100644
index 5886a224..00000000
--- a/retrofit/src/main/java/retrofit/MethodHandler.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.ResponseBody;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import retrofit.http.Streaming;
-
-import static retrofit.Utils.methodError;
-
-final class MethodHandler<T> {
-  @SuppressWarnings("unchecked")
-  static MethodHandler<?> create(Method method, OkHttpClient client, Endpoint endpoint,
-      CallAdapter.Factory callAdapterFactory, Converter.Factory converterFactory) {
-    CallAdapter<Object> callAdapter =
-        (CallAdapter<Object>) createCallAdapter(method, callAdapterFactory);
-    Converter<Object> responseConverter =
-        (Converter<Object>) createResponseConverter(method, callAdapter.responseType(),
-            converterFactory);
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, endpoint, converterFactory);
-    return new MethodHandler<>(client, requestFactory, callAdapter, responseConverter);
-  }
-
-  private static CallAdapter<?> createCallAdapter(Method method,
-      CallAdapter.Factory adapterFactory) {
-    Type returnType = method.getGenericReturnType();
-    if (Utils.hasUnresolvableType(returnType)) {
-      throw methodError(method,
-          "Method return type must not include a type variable or wildcard: %s", returnType);
-    }
-
-    if (returnType == void.class) {
-      throw methodError(method, "Service methods cannot return void.");
-    }
-
-    CallAdapter<?> adapter = adapterFactory.get(returnType);
-    if (adapter == null) {
-      throw methodError(method, "Call adapter factory '%s' was unable to handle return type %s",
-          adapterFactory, returnType);
-    }
-    return adapter;
-  }
-
-  private static Converter<?> createResponseConverter(Method method, Type responseType,
-      Converter.Factory converterFactory) {
-    if (responseType == ResponseBody.class) {
-      boolean isStreaming = method.isAnnotationPresent(Streaming.class);
-      return new OkHttpResponseBodyConverter(isStreaming);
-    }
-
-    if (converterFactory == null) {
-      throw methodError(method, "Method response type is "
-          + responseType
-          + " but no converter factory registered. "
-          + "Either add a converter factory to the Retrofit instance or use ResponseBody.");
-    }
-
-    Converter<?> converter = converterFactory.get(responseType);
-    if (converter == null) {
-      throw methodError(method, "Converter factory '%s' was unable to handle response type %s",
-          converterFactory, responseType);
-    }
-    return converter;
-  }
-
-  private final OkHttpClient client;
-  private final RequestFactory requestFactory;
-  private final CallAdapter<T> callAdapter;
-  private final Converter<T> responseConverter;
-
-  private MethodHandler(OkHttpClient client, RequestFactory requestFactory,
-      CallAdapter<T> callAdapter, Converter<T> responseConverter) {
-    this.client = client;
-    this.requestFactory = requestFactory;
-    this.callAdapter = callAdapter;
-    this.responseConverter = responseConverter;
-  }
-
-  Object invoke(Object... args) {
-    return callAdapter.adapt(new OkHttpCall<>(client, requestFactory, responseConverter, args));
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/RequestFactoryParser.java b/retrofit/src/main/java/retrofit/MethodInfo.java
similarity index 56%
rename from retrofit/src/main/java/retrofit/RequestFactoryParser.java
rename to retrofit/src/main/java/retrofit/MethodInfo.java
index f20f36cf..89b9c7df 100644
--- a/retrofit/src/main/java/retrofit/RequestFactoryParser.java
+++ b/retrofit/src/main/java/retrofit/MethodInfo.java
@@ -17,6 +17,7 @@ package retrofit;
 
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
@@ -44,143 +45,155 @@ import retrofit.http.PartMap;
 import retrofit.http.Path;
 import retrofit.http.Query;
 import retrofit.http.QueryMap;
-
-import static retrofit.Utils.methodError;
+import retrofit.http.Streaming;
 
 /** Request metadata about a service interface declaration. */
-final class RequestFactoryParser {
+final class MethodInfo {
   // Upper and lower characters, digits, underscores, and hyphens, starting with a character.
   private static final String PARAM = "[a-zA-Z][a-zA-Z0-9_-]*";
   private static final Pattern PARAM_NAME_REGEX = Pattern.compile(PARAM);
   private static final Pattern PARAM_URL_REGEX = Pattern.compile("\\{(" + PARAM + ")\\}");
 
-  static RequestFactory parse(Method method, Endpoint endpoint,
-      Converter.Factory converterFactory) {
-    RequestFactoryParser parser = new RequestFactoryParser(method);
-    parser.parseMethodAnnotations();
-    parser.parseParameters(converterFactory);
-    return parser.toRequestFactory(endpoint);
+  enum BodyEncoding {
+    NONE,
+    MULTIPART,
+    FORM_URL_ENCODED
   }
 
   private final Method method;
-
-  private String httpMethod;
-  private boolean hasBody;
-  private boolean isFormEncoded;
-  private boolean isMultipart;
-  private String pathUrl;
-  private String queryParams;
-  private com.squareup.okhttp.Headers headers;
-  private MediaType mediaType;
-  private RequestBuilderAction[] requestBuilderActions;
-
-  private Set<String> pathUrlParamNames;
-
-  private RequestFactoryParser(Method method) {
+  private final CallAdapter.Factory adapterFactory;
+  private final Converter.Factory converterFactory;
+
+  CallAdapter<?> adapter;
+  Converter<?> responseConverter;
+  BodyEncoding bodyEncoding = BodyEncoding.NONE;
+  String requestMethod;
+  boolean requestHasBody;
+  String requestUrl;
+  String requestQuery;
+  com.squareup.okhttp.Headers headers;
+  MediaType mediaType;
+  RequestBuilderAction[] requestBuilderActions;
+
+  private Set<String> requestUrlParamNames;
+
+  MethodInfo(Method method, CallAdapter.Factory adapterFactory,
+      Converter.Factory converterFactory) {
     this.method = method;
+    this.adapterFactory = adapterFactory;
+    this.converterFactory = converterFactory;
+    parseMethodAnnotations();
+    parseResponseType();
+    parseParameters();
   }
 
-  private RequestFactory toRequestFactory(Endpoint endpoint) {
-    return new RequestFactory(httpMethod, endpoint, pathUrl, queryParams, headers, mediaType,
-        hasBody, isFormEncoded, isMultipart, requestBuilderActions);
+  private RuntimeException methodError(String message, Object... args) {
+    if (args.length > 0) {
+      message = String.format(message, args);
+    }
+    return new IllegalArgumentException(
+        method.getDeclaringClass().getSimpleName() + "." + method.getName() + ": " + message);
   }
 
   private RuntimeException parameterError(int index, String message, Object... args) {
-    return methodError(method, message + " (parameter #" + (index + 1) + ")", args);
+    return methodError(message + " (parameter #" + (index + 1) + ")", args);
   }
 
+  /** Loads {@link #requestMethod} and {@link #bodyEncoding}. */
   private void parseMethodAnnotations() {
-    for (Annotation annotation : method.getAnnotations()) {
-      if (annotation instanceof DELETE) {
-        parseHttpMethodAndPath("DELETE", ((DELETE) annotation).value(), false);
-      } else if (annotation instanceof GET) {
-        parseHttpMethodAndPath("GET", ((GET) annotation).value(), false);
-      } else if (annotation instanceof HEAD) {
-        parseHttpMethodAndPath("HEAD", ((HEAD) annotation).value(), false);
-      } else if (annotation instanceof PATCH) {
-        parseHttpMethodAndPath("PATCH", ((PATCH) annotation).value(), true);
-      } else if (annotation instanceof POST) {
-        parseHttpMethodAndPath("POST", ((POST) annotation).value(), true);
-      } else if (annotation instanceof PUT) {
-        parseHttpMethodAndPath("PUT", ((PUT) annotation).value(), true);
-      } else if (annotation instanceof HTTP) {
-        HTTP http = (HTTP) annotation;
+    for (Annotation methodAnnotation : method.getAnnotations()) {
+      Class<? extends Annotation> annotationType = methodAnnotation.annotationType();
+      if (annotationType == DELETE.class) {
+        parseHttpMethodAndPath("DELETE", ((DELETE) methodAnnotation).value(), false);
+      } else if (annotationType == GET.class) {
+        parseHttpMethodAndPath("GET", ((GET) methodAnnotation).value(), false);
+      } else if (annotationType == HEAD.class) {
+        parseHttpMethodAndPath("HEAD", ((HEAD) methodAnnotation).value(), false);
+      } else if (annotationType == PATCH.class) {
+        parseHttpMethodAndPath("PATCH", ((PATCH) methodAnnotation).value(), true);
+      } else if (annotationType == POST.class) {
+        parseHttpMethodAndPath("POST", ((POST) methodAnnotation).value(), true);
+      } else if (annotationType == PUT.class) {
+        parseHttpMethodAndPath("PUT", ((PUT) methodAnnotation).value(), true);
+      } else if (annotationType == HTTP.class) {
+        HTTP http = (HTTP) methodAnnotation;
         parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
-      } else if (annotation instanceof Headers) {
-        String[] headersToParse = ((Headers) annotation).value();
+      } else if (annotationType == Headers.class) {
+        String[] headersToParse = ((Headers) methodAnnotation).value();
         if (headersToParse.length == 0) {
-          throw methodError(method, "@Headers annotation is empty.");
+          throw methodError("@Headers annotation is empty.");
         }
         headers = parseHeaders(headersToParse);
-      } else if (annotation instanceof Multipart) {
-        if (isFormEncoded) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
+      } else if (annotationType == Multipart.class) {
+        if (bodyEncoding != BodyEncoding.NONE) {
+          throw methodError("Only one encoding annotation is allowed.");
         }
-        isMultipart = true;
-      } else if (annotation instanceof FormUrlEncoded) {
-        if (isMultipart) {
-          throw methodError(method, "Only one encoding annotation is allowed.");
+        bodyEncoding = BodyEncoding.MULTIPART;
+      } else if (annotationType == FormUrlEncoded.class) {
+        if (bodyEncoding != BodyEncoding.NONE) {
+          throw methodError("Only one encoding annotation is allowed.");
         }
-        isFormEncoded = true;
+        bodyEncoding = BodyEncoding.FORM_URL_ENCODED;
       }
     }
 
-    if (httpMethod == null) {
-      throw methodError(method, "HTTP method annotation is required (e.g., @GET, @POST, etc.).");
+    if (requestMethod == null) {
+      throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.).");
     }
-    if (!hasBody) {
-      if (isMultipart) {
-        throw methodError(method,
+    if (!requestHasBody) {
+      if (bodyEncoding == BodyEncoding.MULTIPART) {
+        throw methodError(
             "Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
       }
-      if (isFormEncoded) {
-        throw methodError(method,
-            "FormUrlEncoded can only be specified on HTTP methods with request body "
+      if (bodyEncoding == BodyEncoding.FORM_URL_ENCODED) {
+        throw methodError("FormUrlEncoded can only be specified on HTTP methods with request body "
                 + "(e.g., @POST).");
       }
     }
   }
 
-  private void parseHttpMethodAndPath(String httpMethod, String value, boolean hasBody) {
-    if (this.httpMethod != null) {
-      throw methodError(method, "Only one HTTP method is allowed. Found: %s and %s.",
-          this.httpMethod, httpMethod);
+  /** Loads {@link #requestUrl}, {@link #requestUrlParamNames}, and {@link #requestQuery}. */
+  private void parseHttpMethodAndPath(String method, String path, boolean hasBody) {
+    if (requestMethod != null) {
+      throw methodError("Only one HTTP method is allowed. Found: %s and %s.", requestMethod,
+          method);
     }
-    if (value == null || value.length() == 0 || value.charAt(0) != '/') {
-      throw methodError(method, "URL path \"%s\" must start with '/'.", value);
+    if (path == null || path.length() == 0 || path.charAt(0) != '/') {
+      throw methodError("URL path \"%s\" must start with '/'.", path);
     }
 
     // Get the relative URL path and existing query string, if present.
-    String pathUrl = value;
-    String queryParams = null;
-    int question = value.indexOf('?');
-    if (question != -1 && question < value.length() - 1) {
-      pathUrl = value.substring(0, question);
-      queryParams = value.substring(question + 1);
+    String url = path;
+    String query = null;
+    int question = path.indexOf('?');
+    if (question != -1 && question < path.length() - 1) {
+      url = path.substring(0, question);
+      query = path.substring(question + 1);
 
       // Ensure the query string does not have any named parameters.
-      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(queryParams);
+      Matcher queryParamMatcher = PARAM_URL_REGEX.matcher(query);
       if (queryParamMatcher.find()) {
-        throw methodError(method,
-            "URL query string \"%s\" must not have replace block. For dynamic query"
-                + " parameters use @Query.", queryParams);
+        throw methodError("URL query string \"%s\" must not have replace block. For dynamic query"
+            + " parameters use @Query.", query);
       }
     }
 
-    this.httpMethod = httpMethod;
-    this.hasBody = hasBody;
-    this.pathUrl = pathUrl;
-    this.pathUrlParamNames = parsePathParameters(pathUrl);
-    this.queryParams = queryParams;
+    Set<String> urlParams = parsePathParameters(path);
+
+    requestMethod = method;
+    requestHasBody = hasBody;
+    requestUrl = url;
+    requestUrlParamNames = urlParams;
+    requestQuery = query;
   }
 
-  private com.squareup.okhttp.Headers parseHeaders(String[] headers) {
+  com.squareup.okhttp.Headers parseHeaders(String[] headers) {
     com.squareup.okhttp.Headers.Builder builder = new com.squareup.okhttp.Headers.Builder();
     for (String header : headers) {
       int colon = header.indexOf(':');
       if (colon == -1 || colon == 0 || colon == header.length() - 1) {
-        throw methodError(method,
-            "@Headers value must be in the form \"Name: Value\". Found: \"%s\"", header);
+        throw methodError("@Headers value must be in the form \"Name: Value\". Found: \"%s\"",
+            header);
       }
       String headerName = header.substring(0, colon);
       String headerValue = header.substring(colon + 1).trim();
@@ -193,7 +206,45 @@ final class RequestFactoryParser {
     return builder.build();
   }
 
-  private void parseParameters(Converter.Factory converterFactory) {
+  /** Loads {@link #adapter} and {@link #responseConverter}. */
+  private void parseResponseType() {
+    Type returnType = method.getGenericReturnType();
+    if (Utils.hasUnresolvableType(returnType)) {
+      throw methodError("Method return type must not include a type variable or wildcard.");
+    }
+
+    // Check for invalid configurations.
+    if (returnType == void.class) {
+      throw methodError("Service methods cannot return void.");
+    }
+
+    CallAdapter adapter = adapterFactory.get(returnType);
+    if (adapter == null) {
+      throw methodError(
+          "Registered call adapter factory was unable to handle return type " + returnType);
+    }
+    this.adapter = adapter;
+
+    Type responseType = adapter.responseType();
+    if (responseType == ResponseBody.class) {
+      boolean isStreaming = method.isAnnotationPresent(Streaming.class);
+      responseConverter = new OkHttpResponseBodyConverter(isStreaming);
+    } else {
+      if (converterFactory == null) {
+        throw methodError("Method response type is "
+            + responseType
+            + " but no converter registered. "
+            + "Either add a converter to the Retrofit instance or use ResponseBody.");
+      }
+
+      responseConverter = converterFactory.get(responseType);
+    }
+  }
+
+  /**
+   * Loads {@link #requestBuilderActions}. Must be called after {@link #parseMethodAnnotations()}.
+   */
+  private void parseParameters() {
     Type[] methodParameterTypes = method.getGenericParameterTypes();
     Annotation[][] methodParameterAnnotationArrays = method.getParameterAnnotations();
 
@@ -235,7 +286,7 @@ final class RequestFactoryParser {
             requestBuilderActions[i] = new RequestBuilderAction.Header(header.value());
 
           } else if (methodParameterAnnotation instanceof Field) {
-            if (!isFormEncoded) {
+            if (bodyEncoding != BodyEncoding.FORM_URL_ENCODED) {
               throw parameterError(i, "@Field parameters can only be used with form encoding.");
             }
             Field field = (Field) methodParameterAnnotation;
@@ -244,7 +295,7 @@ final class RequestFactoryParser {
             gotField = true;
 
           } else if (methodParameterAnnotation instanceof FieldMap) {
-            if (!isFormEncoded) {
+            if (bodyEncoding != BodyEncoding.FORM_URL_ENCODED) {
               throw parameterError(i, "@FieldMap parameters can only be used with form encoding.");
             }
             if (!Map.class.isAssignableFrom(Utils.getRawType(methodParameterType))) {
@@ -255,7 +306,7 @@ final class RequestFactoryParser {
             gotField = true;
 
           } else if (methodParameterAnnotation instanceof Part) {
-            if (!isMultipart) {
+            if (bodyEncoding != BodyEncoding.MULTIPART) {
               throw parameterError(i, "@Part parameters can only be used with multipart encoding.");
             }
             Part part = (Part) methodParameterAnnotation;
@@ -267,10 +318,10 @@ final class RequestFactoryParser {
               converter = new OkHttpRequestBodyConverter();
             } else {
               if (converterFactory == null) {
-                throw parameterError(i, "@Part parameter is %s"
-                    + " but no converter factory registered. Either add a converter factory"
-                    + " to the Retrofit instance or use RequestBody.",
-                    methodParameterType);
+                throw parameterError(i, "@Part parameter is "
+                    + methodParameterType
+                    + " but no converter registered. "
+                    + "Either add a converter to the Retrofit instance or use RequestBody.");
               }
               converter = converterFactory.get(methodParameterType);
             }
@@ -278,7 +329,7 @@ final class RequestFactoryParser {
             gotPart = true;
 
           } else if (methodParameterAnnotation instanceof PartMap) {
-            if (!isMultipart) {
+            if (bodyEncoding != BodyEncoding.MULTIPART) {
               throw parameterError(i,
                   "@PartMap parameters can only be used with multipart encoding.");
             }
@@ -291,12 +342,12 @@ final class RequestFactoryParser {
             gotPart = true;
 
           } else if (methodParameterAnnotation instanceof Body) {
-            if (isFormEncoded || isMultipart) {
+            if (bodyEncoding != BodyEncoding.NONE) {
               throw parameterError(i,
                   "@Body parameters cannot be used with form or multi-part encoding.");
             }
             if (gotBody) {
-              throw methodError(method, "Multiple @Body method annotations found.");
+              throw methodError("Multiple @Body method annotations found.");
             }
 
             Converter<?> converter;
@@ -304,10 +355,10 @@ final class RequestFactoryParser {
               converter = new OkHttpRequestBodyConverter();
             } else {
               if (converterFactory == null) {
-                throw parameterError(i, "@Body parameter is %s"
-                        + " but no converter factory registered. Either add a converter factory"
-                        + " to the Retrofit instance or use RequestBody.",
-                    methodParameterType);
+                throw parameterError(i, "@Body parameter is "
+                    + methodParameterType
+                    + " but no converter registered. "
+                    + "Either add a converter to the Retrofit instance or use RequestBody.");
               }
               converter = converterFactory.get(methodParameterType);
             }
@@ -323,14 +374,14 @@ final class RequestFactoryParser {
       }
     }
 
-    if (!isFormEncoded && !isMultipart && !hasBody && gotBody) {
-      throw methodError(method, "Non-body HTTP method cannot contain @Body.");
+    if (bodyEncoding == BodyEncoding.NONE && !requestHasBody && gotBody) {
+      throw methodError("Non-body HTTP method cannot contain @Body.");
     }
-    if (isFormEncoded && !gotField) {
-      throw methodError(method, "Form-encoded method must contain at least one @Field.");
+    if (bodyEncoding == BodyEncoding.FORM_URL_ENCODED && !gotField) {
+      throw methodError("Form-encoded method must contain at least one @Field.");
     }
-    if (isMultipart && !gotPart) {
-      throw methodError(method, "Multipart method must contain at least one @Part.");
+    if (bodyEncoding == BodyEncoding.MULTIPART && !gotPart) {
+      throw methodError("Multipart method must contain at least one @Part.");
     }
 
     this.requestBuilderActions = requestBuilderActions;
@@ -342,8 +393,8 @@ final class RequestFactoryParser {
           PARAM_URL_REGEX.pattern(), name);
     }
     // Verify URL replacement name is actually present in the URL path.
-    if (!pathUrlParamNames.contains(name)) {
-      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", pathUrl, name);
+    if (!requestUrlParamNames.contains(name)) {
+      throw parameterError(index, "URL \"%s\" does not contain \"{%s}\".", requestUrl, name);
     }
   }
 
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index 6ba1ca99..0c33f230 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -15,33 +15,36 @@
  */
 package retrofit;
 
+import com.squareup.okhttp.HttpUrl;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 
-import static retrofit.Utils.closeQuietly;
+import static retrofit.Utils.closeQueitly;
 
 final class OkHttpCall<T> implements Call<T> {
   private final OkHttpClient client;
-  private final RequestFactory requestFactory;
+  private final Endpoint endpoint;
   private final Converter<T> responseConverter;
+  private final MethodInfo methodInfo;
   private final Object[] args;
 
   private volatile com.squareup.okhttp.Call rawCall;
   private boolean executed; // Guarded by this.
 
-  OkHttpCall(OkHttpClient client, RequestFactory requestFactory, Converter<T> responseConverter,
-      Object[] args) {
+  OkHttpCall(OkHttpClient client, Endpoint endpoint, Converter<T> responseConverter,
+      MethodInfo methodInfo, Object[] args) {
     this.client = client;
-    this.requestFactory = requestFactory;
+    this.endpoint = endpoint;
     this.responseConverter = responseConverter;
+    this.methodInfo = methodInfo;
     this.args = args;
   }
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(client, requestFactory, responseConverter, args);
+    return new OkHttpCall<>(client, endpoint, responseConverter, methodInfo, args);
   }
 
   public void enqueue(final Callback<T> callback) {
@@ -106,7 +109,20 @@ final class OkHttpCall<T> implements Call<T> {
   }
 
   private com.squareup.okhttp.Call createRawCall() {
-    return client.newCall(requestFactory.create(args));
+    HttpUrl url = endpoint.url();
+    RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo);
+
+    Object[] args = this.args;
+    if (args != null) {
+      RequestBuilderAction[] actions = methodInfo.requestBuilderActions;
+      for (int i = 0, count = args.length; i < count; i++) {
+        actions[i].perform(requestBuilder, args[i]);
+      }
+    }
+
+    Request request = requestBuilder.build();
+
+    return client.newCall(request);
   }
 
   private Response<T> parseResponse(com.squareup.okhttp.Response rawResponse) throws IOException {
@@ -124,7 +140,7 @@ final class OkHttpCall<T> implements Call<T> {
         ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
         return Response.error(bufferedBody, rawResponse);
       } finally {
-        closeQuietly(rawBody);
+        closeQueitly(rawBody);
       }
     }
 
diff --git a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
index 3538c789..039a464c 100644
--- a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
+++ b/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
@@ -19,7 +19,7 @@ import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 
-import static retrofit.Utils.closeQuietly;
+import static retrofit.Utils.closeQueitly;
 
 final class OkHttpResponseBodyConverter implements Converter<ResponseBody> {
   private final boolean isStreaming;
@@ -37,7 +37,7 @@ final class OkHttpResponseBodyConverter implements Converter<ResponseBody> {
     try {
       return Utils.readBodyToBytesIfNecessary(body);
     } finally {
-      closeQuietly(body);
+      closeQueitly(body);
     }
   }
 
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index b6d89fc5..7e7d73ba 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -28,44 +28,51 @@ import java.net.URLEncoder;
 import okio.BufferedSink;
 
 final class RequestBuilder {
-  private final String method;
+  private final String requestMethod;
+  private final boolean requestHasBody;
   private final HttpUrl.Builder urlBuilder;
-  private String pathUrl;
-
   private final Request.Builder requestBuilder;
-  private MediaType mediaType;
 
-  private final boolean hasBody;
   private MultipartBuilder multipartBuilder;
   private FormEncodingBuilder formEncodingBuilder;
   private RequestBody body;
 
-  RequestBuilder(String method, HttpUrl url, String pathUrl, String queryParams, Headers headers,
-      MediaType mediaType, boolean hasBody, boolean isFormEncoded, boolean isMultipart) {
-    this.method = method;
+  private String relativeUrl;
+  private MediaType mediaType;
+
+  RequestBuilder(HttpUrl url, MethodInfo methodInfo) {
+    requestMethod = methodInfo.requestMethod;
+    requestHasBody = methodInfo.requestHasBody;
+    mediaType = methodInfo.mediaType;
+    relativeUrl = methodInfo.requestUrl;
 
-    HttpUrl.Builder urlBuilder = url.newBuilder();
-    if (queryParams != null) {
-      urlBuilder.query(queryParams);
-    }
-    this.urlBuilder = urlBuilder;
-    this.pathUrl = pathUrl;
+    urlBuilder = url.newBuilder();
+    requestBuilder = new Request.Builder();
 
-    Request.Builder requestBuilder = new Request.Builder();
+    Headers headers = methodInfo.headers;
     if (headers != null) {
       requestBuilder.headers(headers);
     }
-    this.requestBuilder = requestBuilder;
-    this.mediaType = mediaType;
 
-    this.hasBody = hasBody;
+    String requestQuery = methodInfo.requestQuery;
+    if (requestQuery != null) {
+      urlBuilder.query(requestQuery);
+    }
 
-    if (isFormEncoded) {
-      // Will be set to 'body' in 'build'.
-      formEncodingBuilder = new FormEncodingBuilder();
-    } else if (isMultipart) {
-      // Will be set to 'body' in 'build'.
-      multipartBuilder = new MultipartBuilder();
+    switch (methodInfo.bodyEncoding) {
+      case FORM_URL_ENCODED:
+        // Will be set to 'body' in 'build'.
+        formEncodingBuilder = new FormEncodingBuilder();
+        break;
+      case MULTIPART:
+        // Will be set to 'body' in 'build'.
+        multipartBuilder = new MultipartBuilder();
+        break;
+      case NONE:
+        // If present, 'body' will be set in 'setArguments' call.
+        break;
+      default:
+        throw new IllegalArgumentException("Unknown request type: " + methodInfo.bodyEncoding);
     }
   }
 
@@ -85,9 +92,9 @@ final class RequestBuilder {
         // encode spaces rather than +. Query encoding difference specified in HTML spec.
         // Any remaining plus signs represent spaces as already URLEncoded.
         encodedValue = encodedValue.replace("+", "%20");
-        pathUrl = pathUrl.replace("{" + name + "}", encodedValue);
+        relativeUrl = relativeUrl.replace("{" + name + "}", encodedValue);
       } else {
-        pathUrl = pathUrl.replace("{" + name + "}", String.valueOf(value));
+        relativeUrl = relativeUrl.replace("{" + name + "}", String.valueOf(value));
       }
     } catch (UnsupportedEncodingException e) {
       throw new RuntimeException(
@@ -120,8 +127,7 @@ final class RequestBuilder {
   }
 
   Request build() {
-    // TODO this should append, not replace.
-    HttpUrl url = urlBuilder.encodedPath(pathUrl).build();
+    urlBuilder.encodedPath(relativeUrl);
 
     RequestBody body = this.body;
     if (body == null) {
@@ -130,7 +136,7 @@ final class RequestBuilder {
         body = formEncodingBuilder.build();
       } else if (multipartBuilder != null) {
         body = multipartBuilder.build();
-      } else if (hasBody) {
+      } else if (requestHasBody) {
         // Body is absent, make an empty body.
         body = RequestBody.create(null, new byte[0]);
       }
@@ -146,8 +152,8 @@ final class RequestBuilder {
     }
 
     return requestBuilder
-        .url(url)
-        .method(method, body)
+        .url(urlBuilder.build())
+        .method(requestMethod, body)
         .build();
   }
 
diff --git a/retrofit/src/main/java/retrofit/RequestFactory.java b/retrofit/src/main/java/retrofit/RequestFactory.java
deleted file mode 100644
index 96b98eb4..00000000
--- a/retrofit/src/main/java/retrofit/RequestFactory.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.HttpUrl;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Request;
-
-final class RequestFactory {
-  private final String method;
-  private final Endpoint endpoint;
-  private final String pathUrl;
-  private final String queryParams;
-  private final Headers headers;
-  private final MediaType mediaType;
-  private final boolean hasBody;
-  private final boolean isFormEncoded;
-  private final boolean isMultipart;
-  private final RequestBuilderAction[] requestBuilderActions;
-
-  RequestFactory(String method, Endpoint endpoint, String pathUrl, String queryParams,
-      Headers headers, MediaType mediaType, boolean hasBody, boolean isFormEncoded,
-      boolean isMultipart, RequestBuilderAction[] requestBuilderActions) {
-    this.method = method;
-    this.endpoint = endpoint;
-    this.pathUrl = pathUrl;
-    this.queryParams = queryParams;
-    this.headers = headers;
-    this.mediaType = mediaType;
-    this.hasBody = hasBody;
-    this.isFormEncoded = isFormEncoded;
-    this.isMultipart = isMultipart;
-    this.requestBuilderActions = requestBuilderActions;
-  }
-
-  Request create(Object... args) {
-    HttpUrl url = endpoint.url();
-    RequestBuilder requestBuilder =
-        new RequestBuilder(method, url, pathUrl, queryParams, headers, mediaType, hasBody,
-            isFormEncoded, isMultipart);
-
-    if (args != null) {
-      RequestBuilderAction[] actions = requestBuilderActions;
-      for (int i = 0, count = args.length; i < count; i++) {
-        actions[i].perform(requestBuilder, args[i]);
-      }
-    }
-
-    return requestBuilder.build();
-  }
-}
diff --git a/retrofit/src/main/java/retrofit/Response.java b/retrofit/src/main/java/retrofit/Response.java
index b3a63e61..5492a7a0 100644
--- a/retrofit/src/main/java/retrofit/Response.java
+++ b/retrofit/src/main/java/retrofit/Response.java
@@ -29,7 +29,7 @@ public final class Response<T> {
   /**
    * TODO
    */
-  public static <T> Response<T> fakeSuccess(T body) {
+  public static <T, B extends T> Response<T> fakeSuccess(B body) {
     return success(body, new com.squareup.okhttp.Response.Builder() //
         .code(200)
         .protocol(Protocol.HTTP_1_1)
@@ -41,8 +41,9 @@ public final class Response<T> {
   /**
    * TODO
    */
-  public static <T> Response<T> success(T body, com.squareup.okhttp.Response rawResponse) {
-    return new Response<>(rawResponse, body, null);
+  public static <T, B extends T> Response<T> success(B body,
+      com.squareup.okhttp.Response rawResponse) {
+    return new Response<T>(rawResponse, body, null);
   }
 
   /**
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
index d0d0589c..0c79f145 100644
--- a/retrofit/src/main/java/retrofit/Retrofit.java
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -85,8 +85,7 @@ import static retrofit.Utils.checkNotNull;
  * @author Jake Wharton (jw@squareup.com)
  */
 public final class Retrofit {
-  private final Map<Method, MethodHandler<?>> methodHandlerCache = new LinkedHashMap<>();
-
+  private final Map<Method, MethodInfo> methodInfoCache = new LinkedHashMap<>();
   private final OkHttpClient client;
   private final Endpoint endpoint;
   private final Converter.Factory converterFactory;
@@ -109,27 +108,35 @@ public final class Retrofit {
   }
 
   private final InvocationHandler handler = new InvocationHandler() {
-    @Override public Object invoke(Object proxy, Method method, Object... args) throws Throwable {
+    @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       // If the method is a method from Object then defer to normal invocation.
       if (method.getDeclaringClass() == Object.class) {
         return method.invoke(this, args);
       }
-      return loadMethodHandler(method).invoke(args);
+      return invokeMethod(method, args);
     }
   };
 
-  MethodHandler<?> loadMethodHandler(Method method) {
-    Map<Method, MethodHandler<?>> cache = methodHandlerCache;
+  // Package-private avoids synthetic accessor method from InvocationHandler. Also for testing.
+  Object invokeMethod(Method method, Object... args) {
+    MethodInfo methodInfo = loadMethodInfo(method);
+    Converter<?> responseConverter = methodInfo.responseConverter;
+    Call call = new OkHttpCall<>(client, endpoint, responseConverter, methodInfo, args);
+    return methodInfo.adapter.adapt(call);
+  }
 
-    MethodHandler<?> handler;
-    synchronized (cache) {
-      handler = cache.get(method);
-      if (handler == null) {
-        handler = MethodHandler.create(method, client, endpoint, adapterFactory, converterFactory);
-        cache.put(method, handler);
+  private MethodInfo loadMethodInfo(Method method) {
+    MethodInfo methodInfo = methodInfoCache.get(method);
+    if (methodInfo == null) {
+      synchronized (methodInfoCache) {
+        methodInfo = methodInfoCache.get(method);
+        if (methodInfo == null) {
+          methodInfo = new MethodInfo(method, adapterFactory, converterFactory);
+          methodInfoCache.put(method, methodInfo);
+        }
       }
     }
-    return handler;
+    return methodInfo;
   }
 
   public OkHttpClient client() {
diff --git a/retrofit/src/main/java/retrofit/Utils.java b/retrofit/src/main/java/retrofit/Utils.java
index 42038b67..decdad80 100644
--- a/retrofit/src/main/java/retrofit/Utils.java
+++ b/retrofit/src/main/java/retrofit/Utils.java
@@ -22,7 +22,6 @@ import java.io.Closeable;
 import java.io.IOException;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
@@ -41,7 +40,7 @@ final class Utils {
     return object;
   }
 
-  static void closeQuietly(Closeable closeable) {
+  static void closeQueitly(Closeable closeable) {
     if (closeable == null) return;
     try {
       closeable.close();
@@ -152,15 +151,6 @@ final class Utils {
     }
   }
 
-  static RuntimeException methodError(Method method, String message, Object... args) {
-    message = String.format(message, args);
-    return new IllegalArgumentException(message
-        + "\n    for method "
-        + method.getDeclaringClass().getSimpleName()
-        + "."
-        + method.getName());
-  }
-
   static class SynchronousExecutor implements Executor {
     @Override public void execute(Runnable runnable) {
       runnable.run();
diff --git a/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java b/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java
index 9e5c96fd..b29aa05e 100644
--- a/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java
+++ b/retrofit/src/test/java/retrofit/DefaultCallAdapterFactoryTest.java
@@ -30,9 +30,9 @@ import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.verifyNoMoreInteractions;
 
-@SuppressWarnings("unchecked")
 public final class DefaultCallAdapterFactoryTest {
-  private final Callback<String> callback = mock(Callback.class);
+  @SuppressWarnings("unchecked")
+  private final Callback<Object> callback = mock(Callback.class);
   private final Executor callbackExecutor = spy(new Utils.SynchronousExecutor());
   private final CallAdapter.Factory factory = new DefaultCallAdapterFactory(callbackExecutor);
 
@@ -68,10 +68,10 @@ public final class DefaultCallAdapterFactoryTest {
 
   @Test public void adaptedCallExecute() throws IOException {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
-    final Response<String> response = Response.fakeSuccess("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
-      @Override public Response<String> execute() throws IOException {
+    CallAdapter adapter = factory.get(returnType);
+    final Response<Object> response = Response.fakeSuccess("Hi");
+    Call<Object> call = (Call<Object>) adapter.adapt(new EmptyCall() {
+      @Override public Response<Object> execute() throws IOException {
         return response;
       }
     });
@@ -80,10 +80,10 @@ public final class DefaultCallAdapterFactoryTest {
 
   @Test public void adaptedCallEnqueueUsesExecutorForSuccessCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
-    final Response<String> response = Response.fakeSuccess("Hi");
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
+    CallAdapter adapter = factory.get(returnType);
+    final Response<Object> response = Response.fakeSuccess("Hi");
+    Call call = (Call) adapter.adapt(new EmptyCall() {
+      @Override public void enqueue(Callback<Object> callback) {
         callback.success(response);
       }
     });
@@ -94,10 +94,10 @@ public final class DefaultCallAdapterFactoryTest {
 
   @Test public void adaptedCallEnqueueUsesExecutorForFailureCallback() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
+    CallAdapter adapter = factory.get(returnType);
     final Throwable throwable = new IOException();
-    Call<String> call = (Call<String>) adapter.adapt(new EmptyCall() {
-      @Override public void enqueue(Callback<String> callback) {
+    Call call = (Call) adapter.adapt(new EmptyCall() {
+      @Override public void enqueue(Callback<Object> callback) {
         callback.failure(throwable);
       }
     });
@@ -110,10 +110,10 @@ public final class DefaultCallAdapterFactoryTest {
 
   @Test public void adaptedCallCloneDeepCopy() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
-    Call<String> cloned = call.clone();
+    CallAdapter adapter = factory.get(returnType);
+    Call delegate = mock(Call.class);
+    Call call = (Call) adapter.adapt(delegate);
+    Call cloned = call.clone();
     assertThat(cloned).isNotSameAs(call);
     verify(delegate).clone();
     verifyNoMoreInteractions(delegate);
@@ -121,20 +121,20 @@ public final class DefaultCallAdapterFactoryTest {
 
   @Test public void adaptedCallCancel() {
     Type returnType = new TypeToken<Call<String>>() {}.getType();
-    CallAdapter<String> adapter = (CallAdapter<String>) factory.get(returnType);
-    Call<String> delegate = mock(Call.class);
-    Call<String> call = (Call<String>) adapter.adapt(delegate);
+    CallAdapter adapter = factory.get(returnType);
+    Call delegate = mock(Call.class);
+    Call call = (Call) adapter.adapt(delegate);
     call.cancel();
     verify(delegate).cancel();
     verifyNoMoreInteractions(delegate);
   }
 
-  static class EmptyCall implements Call<String> {
-    @Override public void enqueue(Callback<String> callback) {
+  static class EmptyCall implements Call<Object> {
+    @Override public void enqueue(Callback<Object> callback) {
       throw new UnsupportedOperationException();
     }
 
-    @Override public Response<String> execute() throws IOException {
+    @Override public Response<Object> execute() throws IOException {
       throw new UnsupportedOperationException();
     }
 
@@ -142,7 +142,7 @@ public final class DefaultCallAdapterFactoryTest {
       throw new UnsupportedOperationException();
     }
 
-    @Override public Call<String> clone() {
+    @Override public Call<Object> clone() {
       throw new UnsupportedOperationException();
     }
   }
diff --git a/retrofit/src/test/java/retrofit/RequestFactoryParserTest.java b/retrofit/src/test/java/retrofit/MethodInfoTest.java
similarity index 81%
rename from retrofit/src/test/java/retrofit/RequestFactoryParserTest.java
rename to retrofit/src/test/java/retrofit/MethodInfoTest.java
index 59d9cd9a..4e58bb93 100644
--- a/retrofit/src/test/java/retrofit/RequestFactoryParserTest.java
+++ b/retrofit/src/test/java/retrofit/MethodInfoTest.java
@@ -6,7 +6,7 @@ import org.junit.Test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-public final class RequestFactoryParserTest {
+public final class MethodInfoTest {
   @Test public void pathParameterParsing() throws Exception {
     expectParams("/");
     expectParams("/foo");
@@ -27,7 +27,10 @@ public final class RequestFactoryParserTest {
   }
 
   private static void expectParams(String path, String... expected) {
-    Set<String> calculated = RequestFactoryParser.parsePathParameters(path);
-    assertThat(calculated).containsExactly(expected);
+    Set<String> calculated = MethodInfo.parsePathParameters(path);
+    assertThat(calculated).hasSize(expected.length);
+    if (expected.length > 0) {
+      assertThat(calculated).containsExactly(expected);
+    }
   }
 }
diff --git a/retrofit/src/test/java/retrofit/RequestBuilderTest.java b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
index de85d028..7497d90a 100644
--- a/retrofit/src/test/java/retrofit/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit/RequestBuilderTest.java
@@ -86,8 +86,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
     }
   }
 
@@ -104,8 +103,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Only one encoding annotation is allowed.\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: Only one encoding annotation is allowed.");
     }
   }
 
@@ -122,8 +120,8 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
-              + " Found: hey! (parameter #1)\n    for method Example.method");
+          "Example.method: @Path parameter name must match \\{([a-zA-Z][a-zA-Z0-9_-]*)\\}."
+              + " Found: hey! (parameter #1)");
     }
   }
 
@@ -139,8 +137,8 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "URL query string \"bar={bar}\" must not have replace block."
-              + " For dynamic query parameters use @Query.\n    for method Example.method");
+          "Example.method: URL query string \"bar={bar}\" must not have replace block."
+              + " For dynamic query parameters use @Query.");
     }
   }
 
@@ -156,7 +154,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Multiple Retrofit annotations found, only one allowed. (parameter #1)\n    for method Example.method");
+          "Example.method: Multiple Retrofit annotations found, only one allowed. (parameter #1)");
     }
   }
 
@@ -174,7 +172,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Only one HTTP method is allowed. Found: PATCH and POST.\n    for method Example.method");
+          "Example.method: Only one HTTP method is allowed. Found: PATCH and POST.");
     }
   }
 
@@ -190,8 +188,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL path \"foo/bar\" must start with '/'.\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: URL path \"foo/bar\" must start with '/'.");
     }
   }
 
@@ -206,7 +203,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "HTTP method annotation is required (e.g., @GET, @POST, etc.).\n    for method Example.method");
+          "Example.method: HTTP method annotation is required (e.g., @GET, @POST, etc.).");
     }
   }
 
@@ -222,7 +219,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Part parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+          "Example.method: @Part parameters can only be used with multipart encoding. (parameter #1)");
     }
   }
 
@@ -238,7 +235,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@PartMap parameters can only be used with multipart encoding. (parameter #1)\n    for method Example.method");
+          "Example.method: @PartMap parameters can only be used with multipart encoding. (parameter #1)");
     }
   }
 
@@ -255,7 +252,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Multipart can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+          "Example.method: Multipart can only be specified on HTTP methods with request body (e.g., @POST).");
     }
   }
 
@@ -271,8 +268,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multipart method must contain at least one @Part.\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: Multipart method must contain at least one @Part.");
     }
   }
 
@@ -288,7 +284,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Field parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+          "Example.method: @Field parameters can only be used with form encoding. (parameter #1)");
     }
   }
 
@@ -304,7 +300,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@FieldMap parameters can only be used with form encoding. (parameter #1)\n    for method Example.method");
+          "Example.method: @FieldMap parameters can only be used with form encoding. (parameter #1)");
     }
   }
 
@@ -321,7 +317,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\n    for method Example.method");
+          "Example.method: FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).");
     }
   }
 
@@ -337,7 +333,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Form-encoded method must contain at least one @Field.\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: Form-encoded method must contain at least one @Field.");
     }
   }
 
@@ -353,7 +349,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("@Headers annotation is empty.\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: @Headers annotation is empty.");
     }
   }
 
@@ -370,7 +366,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Headers value must be in the form \"Name: Value\". Found: \"Malformed\"\n    for method Example.method");
+          "Example.method: @Headers value must be in the form \"Name: Value\". Found: \"Malformed\"");
     }
   }
 
@@ -385,8 +381,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "URL \"/{a}\" does not contain \"{b}\". (parameter #2)\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: URL \"/{a}\" does not contain \"{b}\". (parameter #2)");
     }
   }
 
@@ -401,8 +396,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "No Retrofit annotation found. (parameter #1)\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: No Retrofit annotation found. (parameter #1)");
     }
   }
 
@@ -417,8 +411,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Non-body HTTP method cannot contain @Body.\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: Non-body HTTP method cannot contain @Body.");
     }
   }
 
@@ -433,8 +426,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@QueryMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: @QueryMap parameter type must be Map. (parameter #1)");
     }
   }
 
@@ -469,8 +461,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Multiple @Body method annotations found.\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: Multiple @Body method annotations found.");
     }
   }
 
@@ -487,7 +478,7 @@ public final class RequestBuilderTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\n    for method Example.method");
+          "Example.method: @Body parameters cannot be used with form or multi-part encoding. (parameter #2)");
     }
   }
 
@@ -1283,8 +1274,7 @@ public final class RequestBuilderTest {
       buildRequest(Example.class);
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "@FieldMap parameter type must be Map. (parameter #1)\n    for method Example.method");
+      assertThat(e).hasMessage("Example.method: @FieldMap parameter type must be Map. (parameter #1)");
     }
   }
 
@@ -1424,16 +1414,24 @@ public final class RequestBuilderTest {
   }
 
   private Request buildRequest(Class<?> cls, Object... args) {
+    HttpUrl url = HttpUrl.parse("http://example.com/");
+    Converter.Factory converterFactory = new ToStringConverterFactory();
+    CallAdapter.Factory callAdapterFactory =
+        new DefaultCallAdapterFactory(new Utils.SynchronousExecutor());
+
     Method method = TestingUtils.onlyMethod(cls);
+    MethodInfo methodInfo = new MethodInfo(method, callAdapterFactory, converterFactory);
 
-    Endpoint endpoint = new Endpoint() {
-      @Override public HttpUrl url() {
-        return HttpUrl.parse("http://example.com/");
-      }
-    };
-    Converter.Factory converterFactory = new ToStringConverterFactory();
+    RequestBuilder builder = new RequestBuilder(url, methodInfo);
+
+    RequestBuilderAction[] actions = methodInfo.requestBuilderActions;
+    if (args.length != actions.length) {
+      throw new IllegalStateException("Wrong number of arguments.");
+    }
+    for (int i = 0, count = args.length; i < count; i++) {
+      actions[i].perform(builder, args[i]);
+    }
 
-    RequestFactory requestFactory = RequestFactoryParser.parse(method, endpoint, converterFactory);
-    return requestFactory.create(args);
+    return builder.build();
   }
 }
diff --git a/retrofit/src/test/java/retrofit/RetrofitTest.java b/retrofit/src/test/java/retrofit/RetrofitTest.java
index 43ef6594..71e22720 100644
--- a/retrofit/src/test/java/retrofit/RetrofitTest.java
+++ b/retrofit/src/test/java/retrofit/RetrofitTest.java
@@ -151,8 +151,7 @@ public final class RetrofitTest {
       example.method();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage(
-          "Call adapter factory 'Default CallAdapterFactory' was unable to handle return type java.util.concurrent.Future<java.lang.String>\n    for method FutureMethod.method");
+      assertThat(e).hasMessage("FutureMethod.method: Registered call adapter factory was unable to handle return type java.util.concurrent.Future<java.lang.String>");
     }
   }
 
@@ -166,8 +165,8 @@ public final class RetrofitTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "@Body parameter is class java.lang.String but no converter factory registered. "
-              + "Either add a converter factory to the Retrofit instance or use RequestBody. (parameter #1)\n    for method CallMethod.disallowed");
+          "CallMethod.disallowed: @Body parameter is class java.lang.String but no converter registered. "
+              + "Either add a converter to the Retrofit instance or use RequestBody. (parameter #1)");
     }
   }
 
@@ -184,8 +183,8 @@ public final class RetrofitTest {
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage(
-          "Method response type is class java.lang.String but no converter factory registered. "
-              + "Either add a converter factory to the Retrofit instance or use ResponseBody.\n    for method CallMethod.disallowed");
+          "CallMethod.disallowed: Method response type is class java.lang.String but no converter registered. "
+              + "Either add a converter to the Retrofit instance or use ResponseBody.");
     }
   }
 
@@ -227,36 +226,36 @@ public final class RetrofitTest {
       example.typeVariable();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit.Call<T>\n    for method Unresolvable.typeVariable");
+      assertThat(e).hasMessage(
+          "Unresolvable.typeVariable: Method return type must not include a type variable or wildcard.");
     }
     try {
       example.typeVariableUpperBound();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit.Call<T>\n    for method Unresolvable.typeVariableUpperBound");
+      assertThat(e).hasMessage(
+          "Unresolvable.typeVariableUpperBound: Method return type must not include a type variable or wildcard.");
     }
     try {
       example.crazy();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit.Call<java.util.List<java.util.Map<java.lang.String, java.util.Set<T[]>>>>\n    for method Unresolvable.crazy");
+      assertThat(e).hasMessage(
+          "Unresolvable.crazy: Method return type must not include a type variable or wildcard.");
     }
     try {
       example.wildcard();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit.Call<?>\n    for method Unresolvable.wildcard");
+      assertThat(e).hasMessage(
+          "Unresolvable.wildcard: Method return type must not include a type variable or wildcard.");
     }
     try {
       example.wildcardUpperBound();
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Method return type must not include a type variable or wildcard: "
-          + "retrofit.Call<? extends com.squareup.okhttp.ResponseBody>\n    for method Unresolvable.wildcardUpperBound");
+      assertThat(e).hasMessage(
+          "Unresolvable.wildcardUpperBound: Method return type must not include a type variable or wildcard.");
     }
   }
 
