diff --git a/aop/src/main/java/io/micronaut/aop/Adapter.java b/aop/src/main/java/io/micronaut/aop/Adapter.java
index 5dc496ae34..64549e2af6 100644
--- a/aop/src/main/java/io/micronaut/aop/Adapter.java
+++ b/aop/src/main/java/io/micronaut/aop/Adapter.java
@@ -15,10 +15,8 @@
  */
 package io.micronaut.aop;
 
-import io.micronaut.context.annotation.AliasFor;
 import io.micronaut.context.annotation.DefaultScope;
 import io.micronaut.context.annotation.Executable;
-import io.micronaut.core.annotation.Indexed;
 import io.micronaut.core.annotation.Internal;
 import jakarta.inject.Singleton;
 
@@ -67,7 +65,6 @@ public @interface Adapter {
      *
      * @return An interface to adapt
      */
-    @AliasFor(member = "value", annotation = Indexed.class)
     Class<?> value();
 
     /**
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java b/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java
index e958cc9b43..43d0cac7ab 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java
@@ -38,7 +38,6 @@ import io.micronaut.context.annotation.DefaultScope;
 import io.micronaut.context.annotation.EachBean;
 import io.micronaut.context.annotation.EachProperty;
 import io.micronaut.context.annotation.InjectScope;
-import io.micronaut.context.annotation.Parallel;
 import io.micronaut.context.annotation.Parameter;
 import io.micronaut.context.annotation.Primary;
 import io.micronaut.context.annotation.Property;
@@ -74,7 +73,6 @@ import io.micronaut.core.annotation.AnnotationUtil;
 import io.micronaut.core.annotation.AnnotationValue;
 import io.micronaut.core.annotation.AnnotationValueBuilder;
 import io.micronaut.core.annotation.Generated;
-import io.micronaut.core.annotation.Indexed;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NextMajorVersion;
 import io.micronaut.core.annotation.NonNull;
@@ -604,8 +602,6 @@ public final class BeanDefinitionWriter implements ClassOutputWriter, BeanDefini
     private static final Constructor<AbstractExecutableMethod> ABSTRACT_EXECUTABLE_METHOD_CONSTRUCTOR = ReflectionUtils.getRequiredInternalConstructor(AbstractExecutableMethod.class, Class.class, String.class);
     private static final Method GET_TYPE_PARAMETERS_METHOD = ReflectionUtils.getRequiredInternalMethod(TypeVariableResolver.class, "getTypeParameters");
     private static final Method ARGUMENT_OF_METHOD = ReflectionUtils.getRequiredInternalMethod(Argument.class, "of", Class.class);
-    private static final Method GET_INDEXES_METHOD = ReflectionUtils.getRequiredMethod(BeanDefinitionReference.class, "getIndexes");
-    private static final Method IS_PARALLEL_METHOD = ReflectionUtils.getRequiredMethod(BeanDefinitionReference.class, "isParallel");
 
     private final String beanFullClassName;
     private final String beanDefinitionName;
@@ -1260,12 +1256,6 @@ public final class BeanDefinitionWriter implements ClassOutputWriter, BeanDefini
 
         addConstructor(staticBlock);
 
-        boolean isParallel = annotationMetadata.hasStereotype(Parallel.class);
-        // In v6 we can assume everything was recompiled with v5 so we can modify the default method to return false and only add this one on true
-        classDefBuilder.addMethod(
-            MethodDef.override(IS_PARALLEL_METHOD).build((aThis, methodParameters) -> ExpressionDef.constant(isParallel).returning())
-        );
-
         loadTypeMethods.values().forEach(classDefBuilder::addMethod);
 
         output = new LinkedHashMap<>();
@@ -1893,6 +1883,7 @@ public final class BeanDefinitionWriter implements ClassOutputWriter, BeanDefini
             .superclass(ClassTypeDef.of(AbstractBeanDefinitionBeanConstructor.class))
             .addAnnotation(Generated.class);
 
+
         // for factory methods we have to store the factory instance in a field and modify the constructor pass the factory instance
         ClassTypeDef factoryType = ClassTypeDef.of(factoryBuildMethodDefinition.factoryClass);
 
@@ -2079,29 +2070,6 @@ public final class BeanDefinitionWriter implements ClassOutputWriter, BeanDefini
                 )
         );
 
-        List<AnnotationValue<Indexed>> indexes = annotationMetadata.getAnnotationValuesByType(Indexed.class);
-        if (!indexes.isEmpty()) {
-            TypeDef.Array arrayOfClasses = TypeDef.Primitive.CLASS.array();
-            FieldDef indexesField = FieldDef.builder("$INDEXES")
-                .ofType(arrayOfClasses)
-                .addModifiers(Modifier.PRIVATE, Modifier.FINAL, Modifier.STATIC)
-                .build();
-            initStatements.add(
-                beanDefinitionTypeDef.getStaticField(indexesField).put(
-                    arrayOfClasses.instantiate(
-                        indexes.stream().map(av -> asClassExpression(av.stringValue().orElseThrow())).toArray(ExpressionDef[]::new)
-                    )
-                )
-            );
-
-            classDefBuilder.addField(indexesField);
-            classDefBuilder.addMethod(
-                MethodDef.override(GET_INDEXES_METHOD).build((aThis, methodParameters) -> aThis.type().getStaticField(indexesField).returning())
-            );
-
-            failStatements.add(beanDefinitionTypeDef.getStaticField(indexesField).put(arrayOfClasses.instantiate()));
-        }
-
         statements.add(
             StatementDef.doTry(
                 StatementDef.multi(
diff --git a/inject-java/src/test/groovy/io/micronaut/aop/adapter/MethodAdapterSpec.groovy b/inject-java/src/test/groovy/io/micronaut/aop/adapter/MethodAdapterSpec.groovy
index c5454a3af5..91dd315e13 100644
--- a/inject-java/src/test/groovy/io/micronaut/aop/adapter/MethodAdapterSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/aop/adapter/MethodAdapterSpec.groovy
@@ -107,7 +107,6 @@ interface Parser {
         expect:
         beanDef.getBeanDescription(TypeInformation.TypeFormat.SHORTENED) == '@j.i.Singleton i.AsciiParser.parseAsAscii()'
         result == 'test'
-        (beanDef as io.micronaut.inject.BeanDefinitionReference<?>).getIndexes() == [adaptedType]
     }
 
     void "test method adapter inherits metadata"() {
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/indexed/IndexedTest.java b/inject-java/src/test/groovy/io/micronaut/inject/indexed/IndexedTest.java
deleted file mode 100644
index bcc833891c..0000000000
--- a/inject-java/src/test/groovy/io/micronaut/inject/indexed/IndexedTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package io.micronaut.inject.indexed;
-
-import io.micronaut.context.ApplicationContext;
-import io.micronaut.context.annotation.Requires;
-import io.micronaut.core.annotation.Indexed;
-import io.micronaut.inject.BeanDefinition;
-import io.micronaut.inject.BeanDefinitionReference;
-import jakarta.inject.Singleton;
-import org.junit.jupiter.api.Assertions;
-import org.junit.jupiter.api.Test;
-
-import java.util.List;
-import java.util.Map;
-
-public class IndexedTest {
-
-    @Test
-    void test() {
-        try (ApplicationContext context = ApplicationContext.run(Map.of("spec.name", "IndexedTest"))) {
-            BeanDefinition<MyBean> beanDefinition = context.getBeanDefinition(MyBean.class);
-            BeanDefinitionReference<MyBean> beanDefinitionReference = (BeanDefinitionReference<MyBean>) beanDefinition;
-            Assertions.assertEquals(List.of(MySupplier.class), List.of(beanDefinitionReference.getIndexes()));
-        }
-    }
-
-}
-
-@Requires(property = "spec.name", value = "IndexedTest")
-@Singleton
-@Indexed(MySupplier.class)
-class MyBean implements MySupplier {
-
-    @Override
-    public String get() {
-        return "foobar";
-    }
-}
-
-interface MySupplier {
-
-    String get();
-
-}
diff --git a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
index 6172f581ac..4a64c41dec 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
@@ -293,37 +293,23 @@ final class DefaultApplicationContext extends DefaultBeanContext implements Conf
     @Override
     @NonNull
     public synchronized ApplicationContext start() {
-        environment.start();
+        startEnvironment();
         return (ApplicationContext) super.start();
     }
 
     @Override
     protected void registerConversionService() {
-        RuntimeBeanDefinition.Builder<? extends Environment> definition = RuntimeBeanDefinition
-            .builder(Environment.class, () -> environment);
-
-        //noinspection unchecked
-        definition = definition
-            .singleton(true)
-            .qualifier(PrimaryQualifier.INSTANCE);
-
-        RuntimeBeanDefinition<? extends Environment> beanDefinition = definition.build();
-        BeanDefinition<? extends Environment> existing = findBeanDefinition(beanDefinition.getBeanType()).orElse(null);
-        if (existing instanceof RuntimeBeanDefinition<?> runtimeBeanDefinition) {
-            removeBeanDefinition(runtimeBeanDefinition);
-        }
-        registerBeanDefinition(beanDefinition);
-        registerSingleton(MutableConversionService.class, environment.getConversionService());
+        // Conversion service is represented by the environment
     }
 
     @Override
     @NonNull
     public synchronized ApplicationContext stop() {
-        super.stop();
+        ApplicationContext stop = (ApplicationContext) super.stop();
         if (environmentManaged) {
             environment.stop();
         }
-        return this;
+        return stop;
     }
 
     @Override
@@ -343,6 +329,29 @@ final class DefaultApplicationContext extends DefaultBeanContext implements Conf
         }
     }
 
+    /**
+     * Start the environment.
+     */
+    private void startEnvironment() {
+        environment.start();
+
+        RuntimeBeanDefinition.Builder<? extends Environment> definition = RuntimeBeanDefinition
+                .builder(Environment.class, () -> environment);
+
+        //noinspection unchecked
+        definition = definition
+                        .singleton(true)
+                        .qualifier(PrimaryQualifier.INSTANCE);
+
+        RuntimeBeanDefinition<? extends Environment> beanDefinition = definition.build();
+        BeanDefinition<? extends Environment> existing = findBeanDefinition(beanDefinition.getBeanType()).orElse(null);
+        if (existing instanceof RuntimeBeanDefinition<?> runtimeBeanDefinition) {
+            removeBeanDefinition(runtimeBeanDefinition);
+        }
+        registerBeanDefinition(beanDefinition);
+        registerSingleton(MutableConversionService.class, environment.getConversionService());
+    }
+
     @Override
     protected <T> NoSuchBeanException newNoSuchBeanException(@Nullable BeanResolutionContext resolutionContext,
                                                              Argument<T> beanType,
diff --git a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
index 3fa51b1b47..0a68af5383 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
@@ -61,6 +61,7 @@ import io.micronaut.core.annotation.AnnotationMetadataProvider;
 import io.micronaut.core.annotation.AnnotationMetadataResolver;
 import io.micronaut.core.annotation.AnnotationUtil;
 import io.micronaut.core.annotation.AnnotationValue;
+import io.micronaut.core.annotation.Indexes;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NextMajorVersion;
 import io.micronaut.core.annotation.NonNull;
@@ -148,7 +149,6 @@ import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
-import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
@@ -170,15 +170,10 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
     protected static final Logger LOG_LIFECYCLE = LoggerFactory.getLogger(DefaultBeanContext.class.getPackage().getName() + ".lifecycle");
     private static final String SCOPED_PROXY_ANN = "io.micronaut.runtime.context.scope.ScopedProxy";
     private static final String INTRODUCTION_TYPE = "io.micronaut.aop.Introduction";
+    private static final String ADAPTER_TYPE = "io.micronaut.aop.Adapter";
+    private static final String PARALLEL_TYPE = Parallel.class.getName();
+    private static final String INDEXES_TYPE = Indexes.class.getName();
     private static final String REPLACES_ANN = Replaces.class.getName();
-    private static final List<Class<?>> KNOWN_INDEX_TYPE = List.of(
-        ResourceLoader.class,
-        TypeConverter.class,
-        TypeConverterRegistrar.class,
-        ApplicationEventListener.class,
-        BeanCreatedEventListener.class,
-        BeanInitializedEventListener.class
-    );
 
     private static final String MSG_COULD_NOT_BE_LOADED = "] could not be loaded: ";
     public static final String MSG_BEAN_DEFINITION = "Bean definition [";
@@ -231,13 +226,14 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
             ValueResolver.class,
             PropertyPlaceholderResolver.class
     );
-    private final Function<Class<?>, Collection<BeanDefinitionProducer>> COMPUTE_INDEXES_FN = new Function<Class<?>, Collection<BeanDefinitionProducer>>() {
-        // Keep an anonymous class for performance
-        @Override
-        public Collection<BeanDefinitionProducer> apply(Class<?> indexedType) {
-            return new ArrayList<>(20);
-        }
-    };
+    private final Set<Class<?>> indexedTypes = CollectionUtils.setOf(
+            ResourceLoader.class,
+            TypeConverter.class,
+            TypeConverterRegistrar.class,
+            ApplicationEventListener.class,
+            BeanCreatedEventListener.class,
+            BeanInitializedEventListener.class
+    );
     private final CustomScopeRegistry customScopeRegistry;
     private final String[] eagerInitStereotypes;
     private final boolean eagerInitStereotypesPresent;
@@ -369,6 +365,7 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
                 if (LOG.isDebugEnabled()) {
                     LOG.debug("Starting BeanContext");
                 }
+                registerConversionService();
                 configureAndStartContext();
                 if (LOG.isDebugEnabled()) {
                     String activeConfigurations = beanConfigurations
@@ -1719,7 +1716,7 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
         Class<B> beanType = definition.getBeanType();
         BeanDefinitionProducer producer = new BeanDefinitionProducer(definition);
         this.beanDefinitionsClasses.add(producer);
-        for (Class<?> indexedType : beanIndex.keySet()) {
+        for (Class<?> indexedType : indexedTypes) {
             if (indexedType == beanType || indexedType.isAssignableFrom(beanType)) {
                 final Collection<BeanDefinitionProducer> indexed = resolveTypeIndex(indexedType);
                 indexed.add(producer);
@@ -1745,7 +1742,7 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
     @Internal
     <B> void removeBeanDefinition(RuntimeBeanDefinition<B> definition) {
         Class<B> beanType = definition.getBeanType();
-        for (Class<?> indexedType : beanIndex.keySet()) {
+        for (Class<?> indexedType : indexedTypes) {
             if (indexedType == beanType || indexedType.isAssignableFrom(beanType)) {
                 resolveTypeIndex(indexedType).forEach(p -> p.disableIfMatch(definition));
                 break;
@@ -2166,16 +2163,29 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
                                                                    boolean collectIterables,
                                                                    Predicate<BeanDefinition<T>> predicate) {
         ArgumentUtils.requireNonNull("beanType", beanType);
+        final Class<T> beanClass = beanType.getType();
         if (LOG.isDebugEnabled()) {
             LOG.debug("Finding candidate beans for type: {}", beanType);
         }
+        // first traverse component definition classes and load candidates
+
+        Collection<BeanDefinitionProducer> beanDefinitionsClasses;
+
+        if (indexedTypes.contains(beanClass)) {
+            beanDefinitionsClasses = beanIndex.get(beanClass);
+            if (beanDefinitionsClasses == null) {
+                beanDefinitionsClasses = Collections.emptyList();
+            }
+        } else {
+            beanDefinitionsClasses = this.beanDefinitionsClasses;
+        }
 
         return collectBeanCandidates(
             resolutionContext,
             beanType,
             collectIterables,
             predicate,
-            beanIndex.getOrDefault(beanType.getType(), beanDefinitionsClasses)
+            beanDefinitionsClasses
         );
     }
 
@@ -3346,7 +3356,6 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
 
     private void configureAndStartContext() {
         configureContextInternal();
-        registerConversionService();
         initializeEventListeners();
         initializeTypeConverters();
         initializeContext(
@@ -3407,17 +3416,32 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
                     continue;
                 }
 
-                for (Class<?> indexedType : beanDefinitionReference.getIndexes()) {
-                    resolveTypeIndex(indexedType).add(beanDefinitionProducer);
+                final AnnotationMetadata annotationMetadata = beanDefinitionReference.getAnnotationMetadata();
+                Class<?>[] indexes = annotationMetadata.classValues(INDEXES_TYPE);
+                if (indexes.length > 0) {
+                    //noinspection ForLoopReplaceableByForEach
+                    for (int i = 0; i < indexes.length; i++) {
+                        Class<?> indexedType = indexes[i];
+                        resolveTypeIndex(indexedType).add(beanDefinitionProducer);
+                    }
+                } else {
+                    if (annotationMetadata.hasStereotype(ADAPTER_TYPE)) {
+                        final Class<?> aClass = annotationMetadata.classValue(ADAPTER_TYPE, AnnotationMetadata.VALUE_MEMBER).orElse(null);
+                        if (indexedTypes.contains(aClass)) {
+                            resolveTypeIndex(aClass).add(beanDefinitionProducer);
+                        }
+                    }
                 }
                 if (isEagerInit(beanDefinitionReference)) {
                     eagerInitBeans.add(beanDefinitionProducer);
-                } else if (beanDefinitionReference.isParallel()) {
+                } else if (annotationMetadata.hasDeclaredStereotype(PARALLEL_TYPE)) {
                     parallelBeans.add(beanDefinitionProducer);
                 }
+
                 if (beanDefinitionReference.requiresMethodProcessing()) {
                     processedBeans.add(beanDefinitionProducer);
                 }
+
             }
 
             this.beanDefinitionReferences = null;
@@ -3429,7 +3453,7 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
         return startupBeans;
     }
 
-    private boolean isEagerInit(BeanDefinitionReference<?> beanDefinitionReference) {
+    private boolean isEagerInit(BeanDefinitionReference beanDefinitionReference) {
         return beanDefinitionReference.isContextScope() ||
                 (eagerInitSingletons && beanDefinitionReference.isSingleton()) ||
                 (eagerInitStereotypesPresent && beanDefinitionReference.getAnnotationMetadata().hasDeclaredStereotype(eagerInitStereotypes));
@@ -3437,7 +3461,10 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
 
     @NonNull
     private Collection<BeanDefinitionProducer> resolveTypeIndex(Class<?> indexedType) {
-        return beanIndex.computeIfAbsent(indexedType, COMPUTE_INDEXES_FN);
+        return beanIndex.computeIfAbsent(indexedType, aClass -> {
+            indexedTypes.add(indexedType);
+            return new ArrayList<>(20);
+        });
     }
 
     @SuppressWarnings("unchecked")
@@ -3798,9 +3825,6 @@ public sealed class DefaultBeanContext implements ConfigurableBeanContext permit
             readAllBeanConfigurations();
             readBeanDefinitionReferences();
         }
-        for (Class<?> indexType : KNOWN_INDEX_TYPE) {
-            resolveTypeIndex(indexType);
-        }
     }
 
     private static void configurationFailure(String message) {
diff --git a/inject/src/main/java/io/micronaut/inject/BeanDefinitionReference.java b/inject/src/main/java/io/micronaut/inject/BeanDefinitionReference.java
index 303f61aecb..2816e32195 100644
--- a/inject/src/main/java/io/micronaut/inject/BeanDefinitionReference.java
+++ b/inject/src/main/java/io/micronaut/inject/BeanDefinitionReference.java
@@ -18,12 +18,9 @@ package io.micronaut.inject;
 import io.micronaut.context.BeanContext;
 import io.micronaut.context.annotation.ConfigurationReader;
 import io.micronaut.context.annotation.DefaultScope;
-import io.micronaut.context.annotation.Parallel;
 import io.micronaut.core.annotation.AnnotationMetadata;
 import io.micronaut.core.annotation.AnnotationUtil;
-import io.micronaut.core.annotation.Indexes;
 import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.NonNull;
 import jakarta.inject.Singleton;
 
 /**
@@ -130,24 +127,4 @@ public interface BeanDefinitionReference<T> extends QualifiedBeanType<T> {
     default boolean isProxyTarget() {
         return false;
     }
-
-    /**
-     * The indexed types for this bean.
-     *
-     * @return An array of indexes.
-     * @since 5.0
-     */
-    @NonNull
-    default Class<?>[] getIndexes() {
-        return getAnnotationMetadata().classValues(Indexes.class);
-    }
-
-    /**
-     * Is parallel initialization enabled for this bean.
-     * @return true if enabled
-     * @since 5.0
-     */
-    default boolean isParallel() {
-        return getAnnotationMetadata().hasDeclaredStereotype(Parallel.class);
-    }
 }
