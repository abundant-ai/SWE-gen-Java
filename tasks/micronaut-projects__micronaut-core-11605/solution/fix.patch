diff --git a/aop/src/main/java/io/micronaut/aop/chain/AdapterIntroduction.java b/aop/src/main/java/io/micronaut/aop/chain/AdapterIntroduction.java
index 2b6e3f500b..9eb28b7266 100644
--- a/aop/src/main/java/io/micronaut/aop/chain/AdapterIntroduction.java
+++ b/aop/src/main/java/io/micronaut/aop/chain/AdapterIntroduction.java
@@ -19,6 +19,7 @@ import io.micronaut.aop.Adapter;
 import io.micronaut.aop.MethodInterceptor;
 import io.micronaut.aop.MethodInvocationContext;
 import io.micronaut.context.BeanContext;
+import io.micronaut.core.annotation.AnnotationValue;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.util.StringUtils;
@@ -49,19 +50,22 @@ final class AdapterIntroduction implements MethodInterceptor<Object, Object> {
      * @param method The target method
      */
     AdapterIntroduction(BeanContext beanContext, ExecutableMethod<?, ?> method) {
-        Class<?> beanType = method.classValue(Adapter.class, ADAPTED_BEAN).orElse(null);
-
+        AnnotationValue<Adapter> adapterAnnotationValue = method.getAnnotation(Adapter.class);
+        if (adapterAnnotationValue == null) {
+            throw new IllegalStateException("Adapter method must have @Adapter annotation");
+        }
+        Class<?> beanType = adapterAnnotationValue.classValue(ADAPTED_BEAN).orElse(null);
         if (beanType == null) {
             throw new IllegalStateException("No bean type to adapt found in Adapter configuration for method: " + method);
         }
 
-        String beanMethod = method.stringValue(Adapter.class, ADAPTED_METHOD).orElse(null);
+        String beanMethod = adapterAnnotationValue.stringValue(ADAPTED_METHOD).orElse(null);
         if (StringUtils.isEmpty(beanMethod)) {
             throw new IllegalStateException("No bean method to adapt found in Adapter configuration for method: " + method);
         }
 
-        String beanQualifier = method.stringValue(Adapter.class, ADAPTED_QUALIFIER).orElse(null);
-        Class<?>[] argumentTypes = method.classValues(Adapter.class, ADAPTED_ARGUMENT_TYPES);
+        String beanQualifier = adapterAnnotationValue.stringValue(ADAPTED_QUALIFIER).orElse(null);
+        Class<?>[] argumentTypes = adapterAnnotationValue.classValues(ADAPTED_ARGUMENT_TYPES);
         Class<?>[] methodArgumentTypes = method.getArgumentTypes();
         Class<?>[] arguments = argumentTypes.length == methodArgumentTypes.length ? argumentTypes : methodArgumentTypes;
         if (StringUtils.isNotEmpty(beanQualifier)) {
diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
index 2a66bb242e..4fdf2a77ec 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
@@ -151,6 +151,12 @@ internal open class KotlinClassElement(
             // We need to aggregate all the hierarchy properties because
             // getAllProperties doesn't return correct parent of the property
             properties.addAll(clazz.getDeclaredSyntheticBeanProperties())
+            clazz.interfaces.forEach {
+                if (it is KotlinClassElement) {
+                    properties.addAll(it.getDeclaredSyntheticBeanProperties())
+                }
+            }
+
             clazz = clazz.superType.orElse(null) as KotlinClassElement?
         }
         properties
