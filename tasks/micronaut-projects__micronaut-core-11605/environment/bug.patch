diff --git a/aop/src/main/java/io/micronaut/aop/chain/AdapterIntroduction.java b/aop/src/main/java/io/micronaut/aop/chain/AdapterIntroduction.java
index 9eb28b7266..2b6e3f500b 100644
--- a/aop/src/main/java/io/micronaut/aop/chain/AdapterIntroduction.java
+++ b/aop/src/main/java/io/micronaut/aop/chain/AdapterIntroduction.java
@@ -19,7 +19,6 @@ import io.micronaut.aop.Adapter;
 import io.micronaut.aop.MethodInterceptor;
 import io.micronaut.aop.MethodInvocationContext;
 import io.micronaut.context.BeanContext;
-import io.micronaut.core.annotation.AnnotationValue;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.util.StringUtils;
@@ -50,22 +49,19 @@ final class AdapterIntroduction implements MethodInterceptor<Object, Object> {
      * @param method The target method
      */
     AdapterIntroduction(BeanContext beanContext, ExecutableMethod<?, ?> method) {
-        AnnotationValue<Adapter> adapterAnnotationValue = method.getAnnotation(Adapter.class);
-        if (adapterAnnotationValue == null) {
-            throw new IllegalStateException("Adapter method must have @Adapter annotation");
-        }
-        Class<?> beanType = adapterAnnotationValue.classValue(ADAPTED_BEAN).orElse(null);
+        Class<?> beanType = method.classValue(Adapter.class, ADAPTED_BEAN).orElse(null);
+
         if (beanType == null) {
             throw new IllegalStateException("No bean type to adapt found in Adapter configuration for method: " + method);
         }
 
-        String beanMethod = adapterAnnotationValue.stringValue(ADAPTED_METHOD).orElse(null);
+        String beanMethod = method.stringValue(Adapter.class, ADAPTED_METHOD).orElse(null);
         if (StringUtils.isEmpty(beanMethod)) {
             throw new IllegalStateException("No bean method to adapt found in Adapter configuration for method: " + method);
         }
 
-        String beanQualifier = adapterAnnotationValue.stringValue(ADAPTED_QUALIFIER).orElse(null);
-        Class<?>[] argumentTypes = adapterAnnotationValue.classValues(ADAPTED_ARGUMENT_TYPES);
+        String beanQualifier = method.stringValue(Adapter.class, ADAPTED_QUALIFIER).orElse(null);
+        Class<?>[] argumentTypes = method.classValues(Adapter.class, ADAPTED_ARGUMENT_TYPES);
         Class<?>[] methodArgumentTypes = method.getArgumentTypes();
         Class<?>[] arguments = argumentTypes.length == methodArgumentTypes.length ? argumentTypes : methodArgumentTypes;
         if (StringUtils.isNotEmpty(beanQualifier)) {
diff --git a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
index 4fdf2a77ec..2a66bb242e 100644
--- a/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
+++ b/inject-kotlin/src/main/kotlin/io/micronaut/kotlin/processing/visitor/KotlinClassElement.kt
@@ -151,12 +151,6 @@ internal open class KotlinClassElement(
             // We need to aggregate all the hierarchy properties because
             // getAllProperties doesn't return correct parent of the property
             properties.addAll(clazz.getDeclaredSyntheticBeanProperties())
-            clazz.interfaces.forEach {
-                if (it is KotlinClassElement) {
-                    properties.addAll(it.getDeclaredSyntheticBeanProperties())
-                }
-            }
-
             clazz = clazz.superType.orElse(null) as KotlinClassElement?
         }
         properties
diff --git a/inject-kotlin/src/test/groovy/io/micronaut/kotlin/processing/inject/ast/ClassElementSpec.groovy b/inject-kotlin/src/test/groovy/io/micronaut/kotlin/processing/inject/ast/ClassElementSpec.groovy
index 50cfd42312..89c33d5db5 100644
--- a/inject-kotlin/src/test/groovy/io/micronaut/kotlin/processing/inject/ast/ClassElementSpec.groovy
+++ b/inject-kotlin/src/test/groovy/io/micronaut/kotlin/processing/inject/ast/ClassElementSpec.groovy
@@ -26,8 +26,6 @@ import io.micronaut.runtime.context.env.ConfigurationAdvice
 import jakarta.validation.Valid
 import spock.lang.PendingFeature
 
-import static io.micronaut.annotation.processing.test.KotlinCompiler.buildContext
-
 class ClassElementSpec extends AbstractKotlinCompilerSpec {
 
     void "test Java Record compile"() {
@@ -173,29 +171,6 @@ class MyBean {}
         } != null
     }
 
-    void "test interface native properties"() {
-
-        when:
-        def nativeProps = buildClassElementMapped('test.BaseConfiguration', '''
-package test
-
-import io.micronaut.context.annotation.ConfigurationProperties
-
-@ConfigurationProperties("base")
-interface BaseConfiguration : Other {
-    val port: Int
-}
-
-interface Other {
-    val host: String
-}
-''', ce -> ce.syntheticBeanProperties)
-
-        then:
-            nativeProps.size() == 2
-            nativeProps.collect { it.name } == ["port", "host"]
-    }
-
     void "test visitGeneratedFile"() {
         given:
         AllElementsVisitor.VISITED_CLASS_ELEMENTS.clear()
