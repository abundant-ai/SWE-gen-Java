diff --git a/gradle.properties b/gradle.properties
index 3ccf4c9a6..7947b0df2 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,14 +1,7 @@
 org.gradle.daemon=true
 org.gradle.parallel=true
 org.gradle.caching=true
-org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 \
-  -XX:+IgnoreUnrecognizedVMOptions \
-  --add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED \
-  --add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
-  --add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED \
-  --add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
-  --add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED
-
+org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
 # AndroidX package structure to make it clearer which packages are bundled with the
 # Android operating system, and which are packaged with your app"s APK
 # https://developer.android.com/topic/libraries/support-library/androidx-rn
diff --git a/gradle/dependencies.gradle b/gradle/dependencies.gradle
index 8c6a8b69f..861b83ad3 100644
--- a/gradle/dependencies.gradle
+++ b/gradle/dependencies.gradle
@@ -4,9 +4,9 @@ ext {
 
 def versions = [:]
 
-versions.bytebuddy = '1.12.9'
+versions.bytebuddy = '1.12.6'
 versions.junitJupiter = '5.8.2'
-versions.errorprone = '2.12.1'
+versions.errorprone = '2.10.0'
 
 libraries.junit4 = 'junit:junit:4.13.2'
 libraries.junitJupiterApi = "org.junit.jupiter:junit-jupiter-api:${versions.junitJupiter}"
@@ -29,12 +29,12 @@ libraries.autoservice = "com.google.auto.service:auto-service:1.0.1"
 libraries.objenesis = 'org.objenesis:objenesis:3.2'
 
 libraries.osgi = 'org.osgi:osgi.core:8.0.0'
-libraries.equinox = 'org.eclipse.platform:org.eclipse.osgi:3.17.200'
-libraries.bndGradle =  'biz.aQute.bnd:biz.aQute.bnd.gradle:6.2.0'
+libraries.equinox = 'org.eclipse.platform:org.eclipse.osgi:3.17.100'
+libraries.bndGradle =  'biz.aQute.bnd:biz.aQute.bnd.gradle:6.1.0'
 
-libraries.groovy = 'org.codehaus.groovy:groovy:3.0.10'
+libraries.groovy = 'org.codehaus.groovy:groovy:3.0.9'
 
-def kotlinVersion = '1.6.20'
+def kotlinVersion = '1.6.10'
 libraries.kotlin = [
     version: kotlinVersion,
 
@@ -44,8 +44,8 @@ libraries.kotlin = [
 ]
 libraries.android = [
     ktx: 'androidx.core:core-ktx:1.7.0',
-    compat: 'androidx.appcompat:appcompat:1.4.1',
-    material: 'com.google.android.material:material:1.5.0',
+    compat: 'androidx.appcompat:appcompat:1.4.0',
+    material: 'com.google.android.material:material:1.4.0',
     junit: 'androidx.test.ext:junit:1.1.3',
     espresso: 'androidx.test.espresso:espresso-core:3.4.0',
 ]
diff --git a/settings.gradle.kts b/settings.gradle.kts
index 5aad31c67..45a4679e4 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -6,6 +6,7 @@ include("inline",
     "proxy",
     "extTest",
     "groovyTest",
+    "groovyInlineTest",
     "kotlinTest",
     "kotlinReleaseCoroutinesTest",
     "android",
@@ -14,16 +15,11 @@ include("inline",
     "junitJupiterInlineMockMakerExtensionTest",
     "module-test",
     "memory-test",
+    "errorprone",
     "junitJupiterParallelTest",
     "osgi-test",
     "bom")
 
-if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_11)) {
-    include("errorprone")
-} else {
-    logger.info("Not including errorprone, which requires minimum JDK 11+")
-}
-
 if (!JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_17) && (System.getenv("ANDROID_SDK_ROOT") != null || File(".local.properties").exists())) {
     include("androidTest")
 } else {
diff --git a/src/main/java/org/mockito/InOrder.java b/src/main/java/org/mockito/InOrder.java
index 3cb047a4c..02ea019c0 100644
--- a/src/main/java/org/mockito/InOrder.java
+++ b/src/main/java/org/mockito/InOrder.java
@@ -4,8 +4,6 @@
  */
 package org.mockito;
 
-import static org.mockito.Mockito.times;
-
 import org.mockito.verification.VerificationMode;
 
 /**
@@ -64,42 +62,6 @@ public interface InOrder {
      */
     <T> T verify(T mock, VerificationMode mode);
 
-    /**
-     * Verifies static interaction in order, with exactly one number of invocations.
-     *
-     * @see #verify(MockedStatic, MockedStatic.Verification, VerificationMode)
-     */
-    default void verify(MockedStatic<?> mockedStatic, MockedStatic.Verification verification) {
-        verify(mockedStatic, verification, times(1));
-    }
-
-    /**
-     * Verifies static interaction in order. E.g:
-     *
-     * <pre class="code"><code class="java">
-     * try (MockedStatic<Foo> mocked = mockStatic(Foo.class)) {
-     *   InOrder inOrder = inOrder(Foo.class);
-     *
-     *   mocked.when(Foo::firstMethod).thenReturn("first");
-     *   mocked.when(Foo::secondMethod).thenReturn("second");
-     *
-     *   assertEquals("first", Foo.firstMethod());
-     *   assertEquals("second", Foo.secondMethod());
-     *
-     *   inOrder.verify(mocked, Foo::firstMethod, times(1));
-     *   inOrder.verify(mocked, Foo::secondMethod, atLeastOnce());
-     * }
-     * </code></pre>
-     *
-     * @param mockedStatic static mock to be verified
-     * @param verification verification to be verified
-     * @param mode         for example times(x) or atLeastOnce()
-     */
-    void verify(
-            MockedStatic<?> mockedStatic,
-            MockedStatic.Verification verification,
-            VerificationMode mode);
-
     /**
      * Verifies that no more interactions happened <b>in order</b>.
      * Different from {@link Mockito#verifyNoMoreInteractions(Object...)} because the order of verification matters.
diff --git a/src/main/java/org/mockito/InjectMocks.java b/src/main/java/org/mockito/InjectMocks.java
index ea8f18898..6ed02abc6 100644
--- a/src/main/java/org/mockito/InjectMocks.java
+++ b/src/main/java/org/mockito/InjectMocks.java
@@ -149,6 +149,7 @@ import org.mockito.junit.MockitoJUnitRunner;
  * <p>
  * <strong><code>MockitoAnnotations.openMocks(this)</code></strong> method has to be called to initialize annotated objects.
  * In above example, <code>openMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
+ * For JUnit3 <code>openMocks()</code> can go to <code>setup()</code> method of a base class.
  * <strong>Instead</strong> you can also put openMocks() in your JUnit runner (&#064;RunWith) or use the built-in
  * {@link MockitoJUnitRunner}. Also, make sure to release any mocks after disposing your test class with a corresponding hook.
  * </p>
diff --git a/src/main/java/org/mockito/Mock.java b/src/main/java/org/mockito/Mock.java
index 62c4faa2d..8b8132000 100644
--- a/src/main/java/org/mockito/Mock.java
+++ b/src/main/java/org/mockito/Mock.java
@@ -59,6 +59,7 @@ import org.mockito.stubbing.Answer;
  * <p>
  * <strong><code>MockitoAnnotations.openMocks(this)</code></strong> method has to be called to initialize annotated objects.
  * In above example, <code>openMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
+ * For JUnit3 <code>openMocks()</code> can go to <code>setup()</code> method of a base class.
  * <strong>Instead</strong> you can also put openMocks() in your JUnit runner (&#064;RunWith) or use the built-in
  * {@link MockitoJUnitRunner}. Also, make sure to release any mocks after disposing your test class with a corresponding hook.
  * </p>
diff --git a/src/main/java/org/mockito/Mockito.java b/src/main/java/org/mockito/Mockito.java
index 8c1a0cff9..a0502a6ee 100644
--- a/src/main/java/org/mockito/Mockito.java
+++ b/src/main/java/org/mockito/Mockito.java
@@ -2185,7 +2185,7 @@ public class Mockito extends ArgumentMatchers {
                 context -> {
                     if (context.getCount() == 1 || additionalAnswers.length == 0) {
                         return withSettings().defaultAnswer(defaultAnswer);
-                    } else if (context.getCount() > additionalAnswers.length) {
+                    } else if (context.getCount() >= additionalAnswers.length) {
                         return withSettings()
                                 .defaultAnswer(additionalAnswers[additionalAnswers.length - 1]);
                     } else {
diff --git a/src/main/java/org/mockito/MockitoAnnotations.java b/src/main/java/org/mockito/MockitoAnnotations.java
index 5857478ca..167242229 100644
--- a/src/main/java/org/mockito/MockitoAnnotations.java
+++ b/src/main/java/org/mockito/MockitoAnnotations.java
@@ -56,6 +56,7 @@ import org.mockito.plugins.AnnotationEngine;
  * <b><code>MockitoAnnotations.openMocks(this)</code></b> method has to be called to initialize annotated fields.
  * <p>
  * In above example, <code>openMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
+ * For JUnit3 <code>openMocks()</code> can go to <code>setup()</code> method of a base class.
  * You can also put openMocks() in your JUnit runner (&#064;RunWith) or use built-in runner: {@link MockitoJUnitRunner}.
  * If static method mocks are used, it is required to close the initialization. Additionally, if using third-party
  * mock-makers, other life-cycles might be handled by the open-release routine.
diff --git a/src/main/java/org/mockito/internal/InOrderImpl.java b/src/main/java/org/mockito/internal/InOrderImpl.java
index 93f5991af..af852e49a 100644
--- a/src/main/java/org/mockito/internal/InOrderImpl.java
+++ b/src/main/java/org/mockito/internal/InOrderImpl.java
@@ -10,7 +10,6 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.mockito.InOrder;
-import org.mockito.MockedStatic;
 import org.mockito.MockingDetails;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.verification.InOrderContextImpl;
@@ -62,8 +61,7 @@ public class InOrderImpl implements InOrder, InOrderContext {
         }
         if (mode instanceof VerificationWrapper) {
             return mockitoCore.verify(
-                    mock,
-                    new VerificationWrapperInOrderWrapper((VerificationWrapper<?>) mode, this));
+                    mock, new VerificationWrapperInOrderWrapper((VerificationWrapper) mode, this));
         } else if (!(mode instanceof VerificationInOrderMode)) {
             throw new MockitoException(
                     mode.getClass().getSimpleName() + " is not implemented to work with InOrder");
@@ -71,24 +69,6 @@ public class InOrderImpl implements InOrder, InOrderContext {
         return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, this));
     }
 
-    @Override
-    public void verify(
-            MockedStatic<?> mockedStatic,
-            MockedStatic.Verification verification,
-            VerificationMode mode) {
-        if (mode instanceof VerificationWrapper) {
-            mockedStatic.verify(
-                    verification,
-                    new VerificationWrapperInOrderWrapper((VerificationWrapper<?>) mode, this));
-        } else if (mode instanceof VerificationInOrderMode) {
-            mockedStatic.verify(
-                    verification, new InOrderWrapper((VerificationInOrderMode) mode, this));
-        } else {
-            throw new MockitoException(
-                    mode.getClass().getSimpleName() + " is not implemented to work with InOrder");
-        }
-    }
-
     // We can't use `this.mocksToBeVerifiedInOrder.contains`, since that in turn calls `.equals` on
     // the mock. Since mocks can be spies and spies get their real equals method calls called, the
     // result is that Mockito incorrectly would register an invocation on a mock. This normally
diff --git a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
index 7f267d2c5..06e340e50 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
@@ -16,13 +16,13 @@ import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;
 import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;
 import org.mockito.internal.configuration.injection.filter.TerminalMockCandidateFilter;
 import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;
+import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.internal.util.reflection.FieldInitializationReport;
 import org.mockito.internal.util.reflection.FieldInitializer;
 
@@ -66,6 +66,15 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
             new TypeBasedCandidateFilter(
                     new NameBasedCandidateFilter(new TerminalMockCandidateFilter()));
 
+    private final ListUtil.Filter<Field> notFinalOrStatic =
+            new ListUtil.Filter<Field>() {
+                @Override
+                public boolean isOut(Field object) {
+                    return Modifier.isFinal(object.getModifiers())
+                            || Modifier.isStatic(object.getModifiers());
+                }
+            };
+
     @Override
     public boolean processInjection(
             Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {
@@ -137,12 +146,9 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
     }
 
     private List<Field> orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {
-        return sortSuperTypesLast(
-                Arrays.stream(awaitingInjectionClazz.getDeclaredFields())
-                        .filter(
-                                field ->
-                                        !Modifier.isFinal(field.getModifiers())
-                                                && !Modifier.isStatic(field.getModifiers()))
-                        .collect(Collectors.toList()));
+        List<Field> declaredFields = Arrays.asList(awaitingInjectionClazz.getDeclaredFields());
+        declaredFields = ListUtil.filter(declaredFields, notFinalOrStatic);
+
+        return sortSuperTypesLast(declaredFields);
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java
index 392392d2d..5040c1757 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java
@@ -4,6 +4,12 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import net.bytebuddy.description.method.MethodDescription;
+import net.bytebuddy.matcher.ElementMatcher;
+
+import static net.bytebuddy.matcher.ElementMatchers.*;
+import static net.bytebuddy.matcher.ElementMatchers.named;
+
 public interface BytecodeGenerator {
 
     <T> Class<? extends T> mockClass(MockFeatures<T> features);
@@ -13,4 +19,16 @@ public interface BytecodeGenerator {
     void mockClassStatic(Class<?> type);
 
     default void clearAllCaches() {}
+
+    static ElementMatcher<MethodDescription> isGroovyMethod(boolean inline) {
+        ElementMatcher.Junction<MethodDescription> matcher =
+                isDeclaredBy(named("groovy.lang.GroovyObjectSupport"))
+                        .or(isAnnotatedWith(named("groovy.transform.Internal")));
+        if (inline) {
+            return matcher.or(
+                    named("$getStaticMetaClass").and(returns(named("groovy.lang.MetaClass"))));
+        } else {
+            return matcher;
+        }
+    }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
index 10b73c81a..72ab81adb 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
@@ -117,15 +117,19 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
                                                                 .or(isEquals())
                                                                 .or(isDefaultFinalizer())))
                                         .and(
-                                                not(
-                                                        isDeclaredBy(nameStartsWith("java."))
+                                                not(isDeclaredBy(nameStartsWith("java."))
                                                                 .<MethodDescription>and(
-                                                                        isPackagePrivate()))),
+                                                                        isPackagePrivate()))
+                                                        .and(
+                                                                not(
+                                                                        BytecodeGenerator
+                                                                                .isGroovyMethod(
+                                                                                        true)))),
                                 Advice.withCustomMapping()
                                         .bind(MockMethodAdvice.Identifier.class, identifier)
                                         .to(MockMethodAdvice.class))
                         .method(
-                                isStatic(),
+                                isStatic().and(not(BytecodeGenerator.isGroovyMethod(true))),
                                 Advice.withCustomMapping()
                                         .bind(MockMethodAdvice.Identifier.class, identifier)
                                         .to(MockMethodAdvice.ForStatic.class))
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
index 580f22b30..1490501ea 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
@@ -19,9 +19,6 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
 import java.util.Map;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Comparator;
 import java.util.concurrent.Callable;
 import java.util.function.Predicate;
 
@@ -117,6 +114,27 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         }
     }
 
+    static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
+        try {
+            StackTraceElement[] stack = throwable.getStackTrace();
+            int skip = 0;
+            StackTraceElement next;
+            do {
+                next = stack[stack.length - current - ++skip];
+            } while (!next.getClassName().equals(targetType.getName()));
+            int top = stack.length - current - skip;
+            StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
+            System.arraycopy(stack, 0, cleared, 0, top);
+            System.arraycopy(stack, top + skip, cleared, top, current);
+            throwable.setStackTrace(cleared);
+            return throwable;
+        } catch (RuntimeException ignored) {
+            // This should not happen unless someone instrumented or manipulated exception stack
+            // traces.
+            return throwable;
+        }
+    }
+
     @Override
     public Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable {
         MockMethodInterceptor interceptor = interceptors.get(instance);
@@ -315,34 +333,25 @@ public class MockMethodAdvice extends MockMethodDispatcher {
             return accessor.invoke(origin, instance, arguments);
         } catch (InvocationTargetException exception) {
             Throwable cause = exception.getCause();
+            StackTraceElement[] tmpStack = new Throwable().getStackTrace();
+
+            int skip = tmpStack.length;
+            // if there is a suitable instance, do not skip the root-cause for the exception
+            if (instance != null) {
+                skip = 0;
+                String causingClassName = instance.getClass().getName();
+                StackTraceElement stackFrame;
+                do {
+                    stackFrame = tmpStack[skip++];
+                } while (stackFrame.getClassName().startsWith(causingClassName));
+            }
+
             new ConditionalStackTraceFilter()
-                    .filter(removeRecursiveCalls(cause, origin.getDeclaringClass()));
+                    .filter(hideRecursiveCall(cause, skip, origin.getDeclaringClass()));
             throw cause;
         }
     }
 
-    static Throwable removeRecursiveCalls(final Throwable cause, final Class<?> declaringClass) {
-        final List<String> uniqueStackTraceItems = new ArrayList<>();
-        final List<Integer> indexesToBeRemoved = new ArrayList<>();
-        for (StackTraceElement element : cause.getStackTrace()) {
-            final String key = element.getClassName() + element.getLineNumber();
-            final int elementIndex = uniqueStackTraceItems.lastIndexOf(key);
-            uniqueStackTraceItems.add(key);
-
-            if (elementIndex > -1 && declaringClass.getName().equals(element.getClassName())) {
-                indexesToBeRemoved.add(elementIndex);
-            }
-        }
-        final List<StackTraceElement> adjustedList =
-                new ArrayList<>(Arrays.asList(cause.getStackTrace()));
-        indexesToBeRemoved.stream()
-                .sorted(Comparator.reverseOrder())
-                .mapToInt(Integer::intValue)
-                .forEach(adjustedList::remove);
-        cause.setStackTrace(adjustedList.toArray(new StackTraceElement[] {}));
-        return cause;
-    }
-
     private static class ReturnValueWrapper implements Callable<Object> {
 
         private final Object returned;
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
index f67fdfc5a..d27b5f82c 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
@@ -12,12 +12,9 @@ import static net.bytebuddy.implementation.attribute.MethodAttributeAppender.For
 import static net.bytebuddy.matcher.ElementMatchers.any;
 import static net.bytebuddy.matcher.ElementMatchers.hasParameters;
 import static net.bytebuddy.matcher.ElementMatchers.hasType;
-import static net.bytebuddy.matcher.ElementMatchers.isAnnotatedWith;
-import static net.bytebuddy.matcher.ElementMatchers.isDeclaredBy;
 import static net.bytebuddy.matcher.ElementMatchers.isEquals;
 import static net.bytebuddy.matcher.ElementMatchers.isHashCode;
 import static net.bytebuddy.matcher.ElementMatchers.isPackagePrivate;
-import static net.bytebuddy.matcher.ElementMatchers.named;
 import static net.bytebuddy.matcher.ElementMatchers.returns;
 import static net.bytebuddy.matcher.ElementMatchers.whereAny;
 import static org.mockito.internal.util.StringUtil.join;
@@ -29,9 +26,7 @@ import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Iterator;
-import java.util.LinkedList;
 import java.util.Random;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.method.MethodDescription;
@@ -224,7 +219,7 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
                 byteBuddy
                         .subclass(features.mockedType)
                         .name(name)
-                        .ignoreAlso(isGroovyMethod())
+                        .ignoreAlso(BytecodeGenerator.isGroovyMethod(false))
                         .annotateType(
                                 features.stripAnnotations
                                         ? new Annotation[0]
@@ -282,22 +277,6 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
                 "The subclass byte code generator cannot create construction mocks");
     }
 
-    private <T> Collection<Class<? super T>> getAllTypes(Class<T> type) {
-        Collection<Class<? super T>> supertypes = new LinkedList<>();
-        supertypes.add(type);
-        Class<? super T> superType = type;
-        while (superType != null) {
-            supertypes.add(superType);
-            superType = superType.getSuperclass();
-        }
-        return supertypes;
-    }
-
-    private static ElementMatcher<MethodDescription> isGroovyMethod() {
-        return isDeclaredBy(named("groovy.lang.GroovyObjectSupport"))
-                .or(isAnnotatedWith(named("groovy.transform.Internal")));
-    }
-
     private boolean isComingFromJDK(Class<?> type) {
         // Comes from the manifest entry :
         // Implementation-Title: Java Runtime Environment
diff --git a/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java b/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java
index d53abf107..7e26169ef 100644
--- a/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java
+++ b/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java
@@ -5,10 +5,10 @@
 package org.mockito.internal.debugging;
 
 import java.util.Collection;
-import java.util.List;
-import java.util.stream.Collectors;
+import java.util.LinkedList;
 
 import org.mockito.Mockito;
+import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.invocation.Invocation;
 import org.mockito.stubbing.Stubbing;
 
@@ -37,10 +37,15 @@ public class InvocationsPrinter {
             }
         }
 
-        List<Stubbing> unused =
-                stubbings.stream()
-                        .filter(stubbing -> !stubbing.wasUsed())
-                        .collect(Collectors.toList());
+        LinkedList<Stubbing> unused =
+                ListUtil.filter(
+                        stubbings,
+                        new ListUtil.Filter<Stubbing>() {
+                            @Override
+                            public boolean isOut(Stubbing s) {
+                                return s.wasUsed();
+                            }
+                        });
 
         if (unused.isEmpty()) {
             return sb.toString();
diff --git a/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java b/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java
index 111b588cc..fc0cb2213 100644
--- a/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java
+++ b/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java
@@ -6,8 +6,9 @@ package org.mockito.internal.invocation;
 
 import java.util.LinkedList;
 import java.util.List;
-import java.util.stream.Collectors;
 
+import org.mockito.internal.util.collections.ListUtil;
+import org.mockito.internal.util.collections.ListUtil.Filter;
 import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.Location;
@@ -19,7 +20,7 @@ public class InvocationsFinder {
 
     public static List<Invocation> findInvocations(
             List<Invocation> invocations, MatchableInvocation wanted) {
-        return invocations.stream().filter(wanted::matches).collect(Collectors.toList());
+        return ListUtil.filter(invocations, new RemoveNotMatching(wanted));
     }
 
     public static List<Invocation> findAllMatchingUnverifiedChunks(
@@ -27,7 +28,7 @@ public class InvocationsFinder {
             MatchableInvocation wanted,
             InOrderContext orderingContext) {
         List<Invocation> unverified = removeVerifiedInOrder(invocations, orderingContext);
-        return unverified.stream().filter(wanted::matches).collect(Collectors.toList());
+        return ListUtil.filter(unverified, new RemoveNotMatching(wanted));
     }
 
     /**
@@ -126,13 +127,13 @@ public class InvocationsFinder {
 
     public static Invocation findPreviousVerifiedInOrder(
             List<Invocation> invocations, InOrderContext context) {
-        List<Invocation> verifiedOnly =
-                invocations.stream().filter(context::isVerified).collect(Collectors.toList());
+        LinkedList<Invocation> verifiedOnly =
+                ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));
 
         if (verifiedOnly.isEmpty()) {
             return null;
         } else {
-            return verifiedOnly.get(verifiedOnly.size() - 1);
+            return verifiedOnly.getLast();
         }
     }
 
@@ -157,6 +158,32 @@ public class InvocationsFinder {
         return locations;
     }
 
+    private static class RemoveNotMatching implements Filter<Invocation> {
+        private final MatchableInvocation wanted;
+
+        private RemoveNotMatching(MatchableInvocation wanted) {
+            this.wanted = wanted;
+        }
+
+        @Override
+        public boolean isOut(Invocation invocation) {
+            return !wanted.matches(invocation);
+        }
+    }
+
+    private static class RemoveUnverifiedInOrder implements Filter<Invocation> {
+        private final InOrderContext orderingContext;
+
+        public RemoveUnverifiedInOrder(InOrderContext orderingContext) {
+            this.orderingContext = orderingContext;
+        }
+
+        @Override
+        public boolean isOut(Invocation invocation) {
+            return !orderingContext.isVerified(invocation);
+        }
+    }
+
     /**
      * i3 is unverified here:
      *
diff --git a/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java b/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java
index 9f60910af..19b0ac054 100644
--- a/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java
+++ b/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java
@@ -5,8 +5,9 @@
 package org.mockito.internal.invocation.finder;
 
 import java.util.List;
-import java.util.stream.Collectors;
 
+import org.mockito.internal.util.collections.ListUtil;
+import org.mockito.internal.util.collections.ListUtil.Filter;
 import org.mockito.invocation.Invocation;
 
 /**
@@ -17,8 +18,14 @@ public class VerifiableInvocationsFinder {
     private VerifiableInvocationsFinder() {}
 
     public static List<Invocation> find(List<?> mocks) {
-        return AllInvocationsFinder.find(mocks).stream()
-                .filter(invocation -> !invocation.isIgnoredForVerification())
-                .collect(Collectors.toList());
+        List<Invocation> invocations = AllInvocationsFinder.find(mocks);
+        return ListUtil.filter(invocations, new RemoveIgnoredForVerification());
+    }
+
+    private static class RemoveIgnoredForVerification implements Filter<Invocation> {
+        @Override
+        public boolean isOut(Invocation invocation) {
+            return invocation.isIgnoredForVerification();
+        }
     }
 }
diff --git a/src/main/java/org/mockito/internal/junit/ExceptionFactory.java b/src/main/java/org/mockito/internal/junit/ExceptionFactory.java
index a1331d260..7c5a841ab 100644
--- a/src/main/java/org/mockito/internal/junit/ExceptionFactory.java
+++ b/src/main/java/org/mockito/internal/junit/ExceptionFactory.java
@@ -36,7 +36,7 @@ public class ExceptionFactory {
      * Returns an AssertionError that describes the fact that the arguments of an invocation are different.
      * If {@link org.opentest4j.AssertionFailedError} is on the class path (used by JUnit 5 and others),
      * it returns a class that extends it. Otherwise, if {@link junit.framework.ComparisonFailure} is on the
-     * class path (shipped with JUnit 4), it will return a class that extends that. This provides
+     * class path (shipped with JUnit 3 and 4), it will return a class that extends that. This provides
      * better IDE support as the comparison result can be opened in a visual diff. If neither are available,
      * it returns an instance of
      * {@link org.mockito.exceptions.verification.ArgumentsAreDifferent}.
diff --git a/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java b/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
index e51d2ebd4..c7fd12a7b 100644
--- a/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
+++ b/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
@@ -4,15 +4,18 @@
  */
 package org.mockito.internal.junit;
 
+import static org.mockito.internal.util.collections.ListUtil.filter;
+
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import org.mockito.internal.invocation.finder.AllInvocationsFinder;
 import org.mockito.internal.stubbing.UnusedStubbingReporting;
+import org.mockito.internal.util.collections.ListUtil.Filter;
 import org.mockito.invocation.Invocation;
 import org.mockito.stubbing.Stubbing;
 
@@ -26,10 +29,19 @@ public class UnusedStubbingsFinder {
      * Stubbings explicitily marked as LENIENT are not included.
      */
     public UnusedStubbings getUnusedStubbings(Iterable<Object> mocks) {
-        return new UnusedStubbings(
-                AllInvocationsFinder.findStubbings(mocks).stream()
-                        .filter(UnusedStubbingReporting::shouldBeReported)
-                        .collect(Collectors.toList()));
+        Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(mocks);
+
+        List<Stubbing> unused =
+                filter(
+                        stubbings,
+                        new Filter<Stubbing>() {
+                            @Override
+                            public boolean isOut(Stubbing s) {
+                                return !UnusedStubbingReporting.shouldBeReported(s);
+                            }
+                        });
+
+        return new UnusedStubbings(unused);
     }
 
     /**
diff --git a/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java b/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
index e417ec2c5..46fd4d6f0 100644
--- a/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
+++ b/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
@@ -6,7 +6,6 @@ package org.mockito.internal.matchers;
 
 import java.io.Serializable;
 
-import java.util.Objects;
 import org.mockito.ArgumentMatcher;
 
 public class EqualsWithDelta implements ArgumentMatcher<Number>, Serializable {
@@ -25,7 +24,7 @@ public class EqualsWithDelta implements ArgumentMatcher<Number>, Serializable {
             return false;
         }
 
-        if (Objects.equals(wanted, actual)) {
+        if (wanted == actual) {
             return true;
         }
 
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java b/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java
index c159906af..8bfffca2f 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java
@@ -6,9 +6,6 @@ package org.mockito.internal.stubbing.answers;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
 
 import org.mockito.internal.invocation.AbstractAwareMethod;
 import org.mockito.internal.util.MockUtil;
@@ -27,52 +24,15 @@ public class InvocationInfo implements AbstractAwareMethod {
         this.invocation = theInvocation;
     }
 
-    public boolean isValidException(final Throwable throwable) {
-        if (isValidException(method, throwable)) {
-            return true;
-        }
-
-        return isValidExceptionForParents(method.getDeclaringClass(), throwable);
-    }
-
-    private boolean isValidExceptionForParents(final Class<?> parent, final Throwable throwable) {
-        final List<Class<?>> ancestors = new ArrayList<>(Arrays.asList(parent.getInterfaces()));
-
-        if (parent.getSuperclass() != null) {
-            ancestors.add(parent.getSuperclass());
-        }
-
-        final boolean validException =
-                ancestors.stream()
-                        .anyMatch(ancestor -> isValidExceptionForClass(ancestor, throwable));
-
-        if (validException) {
-            return true;
-        }
-
-        return ancestors.stream()
-                .anyMatch(ancestor -> isValidExceptionForParents(ancestor, throwable));
-    }
-
-    private boolean isValidExceptionForClass(final Class<?> parent, final Throwable throwable) {
-        try {
-            final Method parentMethod =
-                    parent.getMethod(this.method.getName(), this.method.getParameterTypes());
-            return isValidException(parentMethod, throwable);
-        } catch (NoSuchMethodException e) {
-            // ignore interfaces that doesn't have such a method
-            return false;
-        }
-    }
-
-    private boolean isValidException(final Method method, final Throwable throwable) {
-        final Class<?>[] exceptions = method.getExceptionTypes();
-        final Class<?> throwableClass = throwable.getClass();
-        for (final Class<?> exception : exceptions) {
+    public boolean isValidException(Throwable throwable) {
+        Class<?>[] exceptions = method.getExceptionTypes();
+        Class<?> throwableClass = throwable.getClass();
+        for (Class<?> exception : exceptions) {
             if (exception.isAssignableFrom(throwableClass)) {
                 return true;
             }
         }
+
         return false;
     }
 
diff --git a/src/main/java/org/mockito/internal/util/collections/ListUtil.java b/src/main/java/org/mockito/internal/util/collections/ListUtil.java
new file mode 100644
index 000000000..f94afd89f
--- /dev/null
+++ b/src/main/java/org/mockito/internal/util/collections/ListUtil.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.util.collections;
+
+import java.util.Collection;
+import java.util.LinkedList;
+
+/**
+ * Basic list/collection operators. We know that there are existing libraries that implement those
+ * use cases neatly. However, we want to keep Mockito dependencies minimal. In Java8 we should be
+ * able to get rid of this class.
+ */
+public final class ListUtil {
+
+    public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {
+        LinkedList<T> filtered = new LinkedList<T>();
+        for (T t : collection) {
+            if (!filter.isOut(t)) {
+                filtered.add(t);
+            }
+        }
+        return filtered;
+    }
+
+    public static <FromT, To> LinkedList<To> convert(
+            Collection<FromT> collection, Converter<FromT, To> converter) {
+        LinkedList<To> converted = new LinkedList<To>();
+        for (FromT f : collection) {
+            converted.add(converter.convert(f));
+        }
+        return converted;
+    }
+
+    public interface Filter<T> {
+        boolean isOut(T object);
+    }
+
+    public interface Converter<FromT, To> {
+        To convert(FromT from);
+    }
+
+    private ListUtil() {}
+}
diff --git a/src/main/java/org/mockito/internal/util/reflection/Fields.java b/src/main/java/org/mockito/internal/util/reflection/Fields.java
new file mode 100644
index 000000000..f749649aa
--- /dev/null
+++ b/src/main/java/org/mockito/internal/util/reflection/Fields.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.util.reflection;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.mockito.internal.util.Checks;
+import org.mockito.internal.util.collections.ListUtil;
+import org.mockito.internal.util.collections.ListUtil.Filter;
+
+/**
+ * Small fluent reflection tools to work with fields.
+ *
+ * Code is very new and might need rework.
+ */
+public abstract class Fields {
+
+    /**
+     * Instance fields declared in the class and superclasses of the given instance.
+     *
+     * @param instance Instance from which declared fields will be retrieved.
+     * @return InstanceFields of this object instance.
+     */
+    public static InstanceFields allDeclaredFieldsOf(Object instance) {
+        List<InstanceField> instanceFields = new ArrayList<>();
+        for (Class<?> clazz = instance.getClass();
+                clazz != Object.class;
+                clazz = clazz.getSuperclass()) {
+            instanceFields.addAll(instanceFieldsIn(instance, clazz.getDeclaredFields()));
+        }
+        return new InstanceFields(instance, instanceFields);
+    }
+
+    /**
+     * Instance fields declared in the class of the given instance.
+     *
+     * @param instance Instance from which declared fields will be retrieved.
+     * @return InstanceFields of this object instance.
+     */
+    public static InstanceFields declaredFieldsOf(Object instance) {
+        List<InstanceField> instanceFields = new ArrayList<>();
+        instanceFields.addAll(instanceFieldsIn(instance, instance.getClass().getDeclaredFields()));
+        return new InstanceFields(instance, instanceFields);
+    }
+
+    private static List<InstanceField> instanceFieldsIn(Object instance, Field[] fields) {
+        List<InstanceField> instanceDeclaredFields = new ArrayList<>();
+        for (Field field : fields) {
+            InstanceField instanceField = new InstanceField(field, instance);
+            instanceDeclaredFields.add(instanceField);
+        }
+        return instanceDeclaredFields;
+    }
+
+    /**
+     * Accept fields annotated by the given annotations.
+     *
+     * @param annotations Annotation types to check.
+     * @return The filter.
+     */
+    @SuppressWarnings({"unchecked", "vararg"})
+    public static Filter<InstanceField> annotatedBy(
+            final Class<? extends Annotation>... annotations) {
+        return new Filter<InstanceField>() {
+            @Override
+            public boolean isOut(InstanceField instanceField) {
+                Checks.checkNotNull(annotations, "Provide at least one annotation class");
+
+                for (Class<? extends Annotation> annotation : annotations) {
+                    if (instanceField.isAnnotatedBy(annotation)) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+        };
+    }
+
+    /**
+     * Accept fields with non null value.
+     *
+     * @return The filter.
+     */
+    private static Filter<InstanceField> nullField() {
+        return new Filter<InstanceField>() {
+            @Override
+            public boolean isOut(InstanceField instanceField) {
+                return instanceField.isNull();
+            }
+        };
+    }
+
+    /**
+     * Accept fields with non null value.
+     *
+     * @return The filter.
+     */
+    public static Filter<InstanceField> syntheticField() {
+        return new Filter<InstanceField>() {
+            @Override
+            public boolean isOut(InstanceField instanceField) {
+                return instanceField.isSynthetic();
+            }
+        };
+    }
+
+    public static class InstanceFields {
+        private final Object instance;
+
+        private final List<InstanceField> instanceFields;
+
+        public InstanceFields(Object instance, List<InstanceField> instanceFields) {
+            this.instance = instance;
+            this.instanceFields = instanceFields;
+        }
+
+        public InstanceFields filter(Filter<InstanceField> withFilter) {
+            return new InstanceFields(instance, ListUtil.filter(instanceFields, withFilter));
+        }
+
+        public InstanceFields notNull() {
+            return filter(nullField());
+        }
+
+        public List<InstanceField> instanceFields() {
+            return new ArrayList<>(instanceFields);
+        }
+
+        public List<Object> assignedValues() {
+            List<Object> values = new ArrayList<>(instanceFields.size());
+            for (InstanceField instanceField : instanceFields) {
+                values.add(instanceField.read());
+            }
+            return values;
+        }
+
+        public List<String> names() {
+            List<String> fieldNames = new ArrayList<>(instanceFields.size());
+            for (InstanceField instanceField : instanceFields) {
+                fieldNames.add(instanceField.name());
+            }
+            return fieldNames;
+        }
+    }
+}
diff --git a/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java b/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java
index b32a5a458..f81a53792 100644
--- a/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java
+++ b/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java
@@ -9,8 +9,9 @@ import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
 import java.io.Serializable;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.stream.Collectors;
 
+import org.mockito.internal.util.collections.ListUtil;
+import org.mockito.internal.util.collections.ListUtil.Filter;
 import org.mockito.invocation.Invocation;
 
 public class DefaultRegisteredInvocations implements RegisteredInvocations, Serializable {
@@ -43,9 +44,7 @@ public class DefaultRegisteredInvocations implements RegisteredInvocations, Seri
             copiedList = new LinkedList<>(invocations);
         }
 
-        return copiedList.stream()
-                .filter(invocation -> !isToStringMethod(invocation.getMethod()))
-                .collect(Collectors.toList());
+        return ListUtil.filter(copiedList, new RemoveToString());
     }
 
     @Override
@@ -61,4 +60,11 @@ public class DefaultRegisteredInvocations implements RegisteredInvocations, Seri
             return invocations.isEmpty();
         }
     }
+
+    private static class RemoveToString implements Filter<Invocation> {
+        @Override
+        public boolean isOut(Invocation invocation) {
+            return isToStringMethod(invocation.getMethod());
+        }
+    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
index 9ceb48300..aeb86b962 100644
--- a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
+++ b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
@@ -16,9 +16,9 @@ import static org.mockito.internal.verification.argumentmatching.ArgumentMatchin
 
 import java.util.List;
 import java.util.Set;
-import java.util.stream.Collectors;
 
 import org.mockito.internal.reporting.SmartPrinter;
+import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.Location;
@@ -49,7 +49,14 @@ public class MissingInvocationChecker {
                 new SmartPrinter(
                         wanted, invocations, indexesOfSuspiciousArgs, classesWithSameSimpleName);
         List<Location> actualLocations =
-                invocations.stream().map(Invocation::getLocation).collect(Collectors.toList());
+                ListUtil.convert(
+                        invocations,
+                        new ListUtil.Converter<Invocation, Location>() {
+                            @Override
+                            public Location convert(Invocation invocation) {
+                                return invocation.getLocation();
+                            }
+                        });
 
         throw argumentsAreDifferent(
                 smartPrinter.getWanted(), smartPrinter.getActuals(), actualLocations);
diff --git a/subprojects/bom/bom.gradle b/subprojects/bom/bom.gradle
index 3582cfa78..569f6d658 100644
--- a/subprojects/bom/bom.gradle
+++ b/subprojects/bom/bom.gradle
@@ -12,7 +12,6 @@ apply from: "$rootDir/gradle/java-publication.gradle"
 
 dependencies {
     constraints {
-        api(project.rootProject)
         project.rootProject.subprojects.forEach { subproject ->
             if (!subproject.name.endsWith("Test") &&
                 !subproject.name.endsWith("-test") &&
diff --git a/subprojects/errorprone/src/main/java/org/mockito/errorprone/bugpatterns/MockitoAnyIncorrectPrimitiveType.java b/subprojects/errorprone/src/main/java/org/mockito/errorprone/bugpatterns/MockitoAnyIncorrectPrimitiveType.java
index b73610b45..48b7ee11e 100644
--- a/subprojects/errorprone/src/main/java/org/mockito/errorprone/bugpatterns/MockitoAnyIncorrectPrimitiveType.java
+++ b/subprojects/errorprone/src/main/java/org/mockito/errorprone/bugpatterns/MockitoAnyIncorrectPrimitiveType.java
@@ -49,7 +49,7 @@ public class MockitoAnyIncorrectPrimitiveType extends AbstractMockitoAnyForPrimi
   };
 
   private static final Matcher<ExpressionTree> METHOD_MATCHER =
-      staticMethod().onClassAny(CLASS_NAMES).withNameMatching(METHOD_NAME_PATTERN).withNoParameters();
+      staticMethod().onClassAny(CLASS_NAMES).withNameMatching(METHOD_NAME_PATTERN).withParameters();
 
   @Override
   protected Matcher<? super MethodInvocationTree> matcher() {
diff --git a/subprojects/groovyInlineTest/groovyInlineTest.gradle b/subprojects/groovyInlineTest/groovyInlineTest.gradle
new file mode 100644
index 000000000..1618ac600
--- /dev/null
+++ b/subprojects/groovyInlineTest/groovyInlineTest.gradle
@@ -0,0 +1,11 @@
+apply plugin: 'groovy'
+
+description = "Integration test for using mockito-inline with Groovy."
+
+apply from: "$rootDir/gradle/dependencies.gradle"
+
+dependencies {
+    testImplementation project(":inline")
+    testImplementation libraries.groovy
+    testImplementation libraries.junit4
+}
