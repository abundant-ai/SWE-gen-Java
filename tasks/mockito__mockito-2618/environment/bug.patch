diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index 83471178e..bf878a9b4 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -34,12 +34,12 @@ jobs:
     steps:
 
     - name: 1. Check out code
-      uses: actions/checkout@v2.4.0 # https://github.com/actions/checkout
+      uses: actions/checkout@v3 # https://github.com/actions/checkout
       with:
         fetch-depth: '0' # https://github.com/shipkit/shipkit-changelog#fetch-depth-on-ci
 
     - name: 2. Set up Java ${{ matrix.java }}
-      uses: actions/setup-java@v2
+      uses: actions/setup-java@v3
       with:
         distribution: 'zulu'
         java-version: ${{ matrix.java }}
@@ -92,12 +92,12 @@ jobs:
     steps:
 
       - name: Check out code
-        uses: actions/checkout@v2.4.0 # https://github.com/actions/checkout
+        uses: actions/checkout@v3 # https://github.com/actions/checkout
         with:
           fetch-depth: '0' # https://github.com/shipkit/shipkit-changelog#fetch-depth-on-ci
 
       - name: Set up Java 8
-        uses: actions/setup-java@v2
+        uses: actions/setup-java@v3
         with:
           distribution: 'adopt'
           java-version: 8
diff --git a/build.gradle b/build.gradle
index c63db7aaf..3930e187c 100644
--- a/build.gradle
+++ b/build.gradle
@@ -11,19 +11,19 @@ buildscript {
 
         classpath "io.github.gradle-nexus:publish-plugin:1.1.0"
         classpath 'org.shipkit:shipkit-changelog:1.1.15'
-        classpath 'org.shipkit:shipkit-auto-version:1.1.19'
+        classpath 'org.shipkit:shipkit-auto-version:1.1.20'
 
-        classpath 'com.google.googlejavaformat:google-java-format:1.13.0'
+        classpath 'com.google.googlejavaformat:google-java-format:1.15.0'
         classpath 'com.android.tools.build:gradle:4.2.0'
-        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.10"
+        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.6.20"
     }
 }
 
 plugins {
-    id 'com.diffplug.spotless' version '6.1.2'
+    id 'com.diffplug.spotless' version '6.4.2'
     id 'eclipse'
-    id 'com.github.ben-manes.versions' version '0.41.0'
-    id 'biz.aQute.bnd.builder' version '6.1.0'
+    id 'com.github.ben-manes.versions' version '0.42.0'
+    id 'biz.aQute.bnd.builder' version '6.2.0'
     id 'ru.vyarus.animalsniffer' version '1.5.2'
 }
 
@@ -52,8 +52,10 @@ allprojects { proj ->
         mavenCentral()
         google()
     }
-    plugins.withId('java') {
-        proj.apply from: "$rootDir/gradle/errorprone.gradle"
+    if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_11)) {
+        plugins.withId('java') {
+            proj.apply from: "$rootDir/gradle/errorprone.gradle"
+        }
     }
     tasks.withType(JavaCompile) {
         //I don't believe those warnings add value given modern IDEs
diff --git a/gradle.properties b/gradle.properties
index 7947b0df2..3ccf4c9a6 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,7 +1,14 @@
 org.gradle.daemon=true
 org.gradle.parallel=true
 org.gradle.caching=true
-org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
+org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8 \
+  -XX:+IgnoreUnrecognizedVMOptions \
+  --add-exports=jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED \
+  --add-exports=jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED
+
 # AndroidX package structure to make it clearer which packages are bundled with the
 # Android operating system, and which are packaged with your app"s APK
 # https://developer.android.com/topic/libraries/support-library/androidx-rn
diff --git a/gradle/dependencies.gradle b/gradle/dependencies.gradle
index 861b83ad3..8c6a8b69f 100644
--- a/gradle/dependencies.gradle
+++ b/gradle/dependencies.gradle
@@ -4,9 +4,9 @@ ext {
 
 def versions = [:]
 
-versions.bytebuddy = '1.12.6'
+versions.bytebuddy = '1.12.9'
 versions.junitJupiter = '5.8.2'
-versions.errorprone = '2.10.0'
+versions.errorprone = '2.12.1'
 
 libraries.junit4 = 'junit:junit:4.13.2'
 libraries.junitJupiterApi = "org.junit.jupiter:junit-jupiter-api:${versions.junitJupiter}"
@@ -29,12 +29,12 @@ libraries.autoservice = "com.google.auto.service:auto-service:1.0.1"
 libraries.objenesis = 'org.objenesis:objenesis:3.2'
 
 libraries.osgi = 'org.osgi:osgi.core:8.0.0'
-libraries.equinox = 'org.eclipse.platform:org.eclipse.osgi:3.17.100'
-libraries.bndGradle =  'biz.aQute.bnd:biz.aQute.bnd.gradle:6.1.0'
+libraries.equinox = 'org.eclipse.platform:org.eclipse.osgi:3.17.200'
+libraries.bndGradle =  'biz.aQute.bnd:biz.aQute.bnd.gradle:6.2.0'
 
-libraries.groovy = 'org.codehaus.groovy:groovy:3.0.9'
+libraries.groovy = 'org.codehaus.groovy:groovy:3.0.10'
 
-def kotlinVersion = '1.6.10'
+def kotlinVersion = '1.6.20'
 libraries.kotlin = [
     version: kotlinVersion,
 
@@ -44,8 +44,8 @@ libraries.kotlin = [
 ]
 libraries.android = [
     ktx: 'androidx.core:core-ktx:1.7.0',
-    compat: 'androidx.appcompat:appcompat:1.4.0',
-    material: 'com.google.android.material:material:1.4.0',
+    compat: 'androidx.appcompat:appcompat:1.4.1',
+    material: 'com.google.android.material:material:1.5.0',
     junit: 'androidx.test.ext:junit:1.1.3',
     espresso: 'androidx.test.espresso:espresso-core:3.4.0',
 ]
diff --git a/settings.gradle.kts b/settings.gradle.kts
index 45a4679e4..5aad31c67 100644
--- a/settings.gradle.kts
+++ b/settings.gradle.kts
@@ -6,7 +6,6 @@ include("inline",
     "proxy",
     "extTest",
     "groovyTest",
-    "groovyInlineTest",
     "kotlinTest",
     "kotlinReleaseCoroutinesTest",
     "android",
@@ -15,11 +14,16 @@ include("inline",
     "junitJupiterInlineMockMakerExtensionTest",
     "module-test",
     "memory-test",
-    "errorprone",
     "junitJupiterParallelTest",
     "osgi-test",
     "bom")
 
+if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_11)) {
+    include("errorprone")
+} else {
+    logger.info("Not including errorprone, which requires minimum JDK 11+")
+}
+
 if (!JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_17) && (System.getenv("ANDROID_SDK_ROOT") != null || File(".local.properties").exists())) {
     include("androidTest")
 } else {
diff --git a/src/main/java/org/mockito/InOrder.java b/src/main/java/org/mockito/InOrder.java
index 02ea019c0..3cb047a4c 100644
--- a/src/main/java/org/mockito/InOrder.java
+++ b/src/main/java/org/mockito/InOrder.java
@@ -4,6 +4,8 @@
  */
 package org.mockito;
 
+import static org.mockito.Mockito.times;
+
 import org.mockito.verification.VerificationMode;
 
 /**
@@ -62,6 +64,42 @@ public interface InOrder {
      */
     <T> T verify(T mock, VerificationMode mode);
 
+    /**
+     * Verifies static interaction in order, with exactly one number of invocations.
+     *
+     * @see #verify(MockedStatic, MockedStatic.Verification, VerificationMode)
+     */
+    default void verify(MockedStatic<?> mockedStatic, MockedStatic.Verification verification) {
+        verify(mockedStatic, verification, times(1));
+    }
+
+    /**
+     * Verifies static interaction in order. E.g:
+     *
+     * <pre class="code"><code class="java">
+     * try (MockedStatic<Foo> mocked = mockStatic(Foo.class)) {
+     *   InOrder inOrder = inOrder(Foo.class);
+     *
+     *   mocked.when(Foo::firstMethod).thenReturn("first");
+     *   mocked.when(Foo::secondMethod).thenReturn("second");
+     *
+     *   assertEquals("first", Foo.firstMethod());
+     *   assertEquals("second", Foo.secondMethod());
+     *
+     *   inOrder.verify(mocked, Foo::firstMethod, times(1));
+     *   inOrder.verify(mocked, Foo::secondMethod, atLeastOnce());
+     * }
+     * </code></pre>
+     *
+     * @param mockedStatic static mock to be verified
+     * @param verification verification to be verified
+     * @param mode         for example times(x) or atLeastOnce()
+     */
+    void verify(
+            MockedStatic<?> mockedStatic,
+            MockedStatic.Verification verification,
+            VerificationMode mode);
+
     /**
      * Verifies that no more interactions happened <b>in order</b>.
      * Different from {@link Mockito#verifyNoMoreInteractions(Object...)} because the order of verification matters.
diff --git a/src/main/java/org/mockito/InjectMocks.java b/src/main/java/org/mockito/InjectMocks.java
index 6ed02abc6..ea8f18898 100644
--- a/src/main/java/org/mockito/InjectMocks.java
+++ b/src/main/java/org/mockito/InjectMocks.java
@@ -149,7 +149,6 @@ import org.mockito.junit.MockitoJUnitRunner;
  * <p>
  * <strong><code>MockitoAnnotations.openMocks(this)</code></strong> method has to be called to initialize annotated objects.
  * In above example, <code>openMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
- * For JUnit3 <code>openMocks()</code> can go to <code>setup()</code> method of a base class.
  * <strong>Instead</strong> you can also put openMocks() in your JUnit runner (&#064;RunWith) or use the built-in
  * {@link MockitoJUnitRunner}. Also, make sure to release any mocks after disposing your test class with a corresponding hook.
  * </p>
diff --git a/src/main/java/org/mockito/Mock.java b/src/main/java/org/mockito/Mock.java
index 8b8132000..62c4faa2d 100644
--- a/src/main/java/org/mockito/Mock.java
+++ b/src/main/java/org/mockito/Mock.java
@@ -59,7 +59,6 @@ import org.mockito.stubbing.Answer;
  * <p>
  * <strong><code>MockitoAnnotations.openMocks(this)</code></strong> method has to be called to initialize annotated objects.
  * In above example, <code>openMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
- * For JUnit3 <code>openMocks()</code> can go to <code>setup()</code> method of a base class.
  * <strong>Instead</strong> you can also put openMocks() in your JUnit runner (&#064;RunWith) or use the built-in
  * {@link MockitoJUnitRunner}. Also, make sure to release any mocks after disposing your test class with a corresponding hook.
  * </p>
diff --git a/src/main/java/org/mockito/Mockito.java b/src/main/java/org/mockito/Mockito.java
index a0502a6ee..8c1a0cff9 100644
--- a/src/main/java/org/mockito/Mockito.java
+++ b/src/main/java/org/mockito/Mockito.java
@@ -2185,7 +2185,7 @@ public class Mockito extends ArgumentMatchers {
                 context -> {
                     if (context.getCount() == 1 || additionalAnswers.length == 0) {
                         return withSettings().defaultAnswer(defaultAnswer);
-                    } else if (context.getCount() >= additionalAnswers.length) {
+                    } else if (context.getCount() > additionalAnswers.length) {
                         return withSettings()
                                 .defaultAnswer(additionalAnswers[additionalAnswers.length - 1]);
                     } else {
diff --git a/src/main/java/org/mockito/MockitoAnnotations.java b/src/main/java/org/mockito/MockitoAnnotations.java
index 167242229..5857478ca 100644
--- a/src/main/java/org/mockito/MockitoAnnotations.java
+++ b/src/main/java/org/mockito/MockitoAnnotations.java
@@ -56,7 +56,6 @@ import org.mockito.plugins.AnnotationEngine;
  * <b><code>MockitoAnnotations.openMocks(this)</code></b> method has to be called to initialize annotated fields.
  * <p>
  * In above example, <code>openMocks()</code> is called in &#064;Before (JUnit4) method of test's base class.
- * For JUnit3 <code>openMocks()</code> can go to <code>setup()</code> method of a base class.
  * You can also put openMocks() in your JUnit runner (&#064;RunWith) or use built-in runner: {@link MockitoJUnitRunner}.
  * If static method mocks are used, it is required to close the initialization. Additionally, if using third-party
  * mock-makers, other life-cycles might be handled by the open-release routine.
diff --git a/src/main/java/org/mockito/internal/InOrderImpl.java b/src/main/java/org/mockito/internal/InOrderImpl.java
index af852e49a..93f5991af 100644
--- a/src/main/java/org/mockito/internal/InOrderImpl.java
+++ b/src/main/java/org/mockito/internal/InOrderImpl.java
@@ -10,6 +10,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.mockito.InOrder;
+import org.mockito.MockedStatic;
 import org.mockito.MockingDetails;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.verification.InOrderContextImpl;
@@ -61,7 +62,8 @@ public class InOrderImpl implements InOrder, InOrderContext {
         }
         if (mode instanceof VerificationWrapper) {
             return mockitoCore.verify(
-                    mock, new VerificationWrapperInOrderWrapper((VerificationWrapper) mode, this));
+                    mock,
+                    new VerificationWrapperInOrderWrapper((VerificationWrapper<?>) mode, this));
         } else if (!(mode instanceof VerificationInOrderMode)) {
             throw new MockitoException(
                     mode.getClass().getSimpleName() + " is not implemented to work with InOrder");
@@ -69,6 +71,24 @@ public class InOrderImpl implements InOrder, InOrderContext {
         return mockitoCore.verify(mock, new InOrderWrapper((VerificationInOrderMode) mode, this));
     }
 
+    @Override
+    public void verify(
+            MockedStatic<?> mockedStatic,
+            MockedStatic.Verification verification,
+            VerificationMode mode) {
+        if (mode instanceof VerificationWrapper) {
+            mockedStatic.verify(
+                    verification,
+                    new VerificationWrapperInOrderWrapper((VerificationWrapper<?>) mode, this));
+        } else if (mode instanceof VerificationInOrderMode) {
+            mockedStatic.verify(
+                    verification, new InOrderWrapper((VerificationInOrderMode) mode, this));
+        } else {
+            throw new MockitoException(
+                    mode.getClass().getSimpleName() + " is not implemented to work with InOrder");
+        }
+    }
+
     // We can't use `this.mocksToBeVerifiedInOrder.contains`, since that in turn calls `.equals` on
     // the mock. Since mocks can be spies and spies get their real equals method calls called, the
     // result is that Mockito incorrectly would register an invocation on a mock. This normally
diff --git a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
index 06e340e50..7f267d2c5 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
@@ -16,13 +16,13 @@ import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.configuration.injection.filter.MockCandidateFilter;
 import org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter;
 import org.mockito.internal.configuration.injection.filter.TerminalMockCandidateFilter;
 import org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter;
-import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.internal.util.reflection.FieldInitializationReport;
 import org.mockito.internal.util.reflection.FieldInitializer;
 
@@ -66,15 +66,6 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
             new TypeBasedCandidateFilter(
                     new NameBasedCandidateFilter(new TerminalMockCandidateFilter()));
 
-    private final ListUtil.Filter<Field> notFinalOrStatic =
-            new ListUtil.Filter<Field>() {
-                @Override
-                public boolean isOut(Field object) {
-                    return Modifier.isFinal(object.getModifiers())
-                            || Modifier.isStatic(object.getModifiers());
-                }
-            };
-
     @Override
     public boolean processInjection(
             Field injectMocksField, Object injectMocksFieldOwner, Set<Object> mockCandidates) {
@@ -146,9 +137,12 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
     }
 
     private List<Field> orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {
-        List<Field> declaredFields = Arrays.asList(awaitingInjectionClazz.getDeclaredFields());
-        declaredFields = ListUtil.filter(declaredFields, notFinalOrStatic);
-
-        return sortSuperTypesLast(declaredFields);
+        return sortSuperTypesLast(
+                Arrays.stream(awaitingInjectionClazz.getDeclaredFields())
+                        .filter(
+                                field ->
+                                        !Modifier.isFinal(field.getModifiers())
+                                                && !Modifier.isStatic(field.getModifiers()))
+                        .collect(Collectors.toList()));
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java
index 5040c1757..392392d2d 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/BytecodeGenerator.java
@@ -4,12 +4,6 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
-import net.bytebuddy.description.method.MethodDescription;
-import net.bytebuddy.matcher.ElementMatcher;
-
-import static net.bytebuddy.matcher.ElementMatchers.*;
-import static net.bytebuddy.matcher.ElementMatchers.named;
-
 public interface BytecodeGenerator {
 
     <T> Class<? extends T> mockClass(MockFeatures<T> features);
@@ -19,16 +13,4 @@ public interface BytecodeGenerator {
     void mockClassStatic(Class<?> type);
 
     default void clearAllCaches() {}
-
-    static ElementMatcher<MethodDescription> isGroovyMethod(boolean inline) {
-        ElementMatcher.Junction<MethodDescription> matcher =
-                isDeclaredBy(named("groovy.lang.GroovyObjectSupport"))
-                        .or(isAnnotatedWith(named("groovy.transform.Internal")));
-        if (inline) {
-            return matcher.or(
-                    named("$getStaticMetaClass").and(returns(named("groovy.lang.MetaClass"))));
-        } else {
-            return matcher;
-        }
-    }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
index 72ab81adb..10b73c81a 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
@@ -117,19 +117,15 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
                                                                 .or(isEquals())
                                                                 .or(isDefaultFinalizer())))
                                         .and(
-                                                not(isDeclaredBy(nameStartsWith("java."))
+                                                not(
+                                                        isDeclaredBy(nameStartsWith("java."))
                                                                 .<MethodDescription>and(
-                                                                        isPackagePrivate()))
-                                                        .and(
-                                                                not(
-                                                                        BytecodeGenerator
-                                                                                .isGroovyMethod(
-                                                                                        true)))),
+                                                                        isPackagePrivate()))),
                                 Advice.withCustomMapping()
                                         .bind(MockMethodAdvice.Identifier.class, identifier)
                                         .to(MockMethodAdvice.class))
                         .method(
-                                isStatic().and(not(BytecodeGenerator.isGroovyMethod(true))),
+                                isStatic(),
                                 Advice.withCustomMapping()
                                         .bind(MockMethodAdvice.Identifier.class, identifier)
                                         .to(MockMethodAdvice.ForStatic.class))
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
index 1490501ea..580f22b30 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/MockMethodAdvice.java
@@ -19,6 +19,9 @@ import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
 import java.util.Map;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
 import java.util.concurrent.Callable;
 import java.util.function.Predicate;
 
@@ -114,27 +117,6 @@ public class MockMethodAdvice extends MockMethodDispatcher {
         }
     }
 
-    static Throwable hideRecursiveCall(Throwable throwable, int current, Class<?> targetType) {
-        try {
-            StackTraceElement[] stack = throwable.getStackTrace();
-            int skip = 0;
-            StackTraceElement next;
-            do {
-                next = stack[stack.length - current - ++skip];
-            } while (!next.getClassName().equals(targetType.getName()));
-            int top = stack.length - current - skip;
-            StackTraceElement[] cleared = new StackTraceElement[stack.length - skip];
-            System.arraycopy(stack, 0, cleared, 0, top);
-            System.arraycopy(stack, top + skip, cleared, top, current);
-            throwable.setStackTrace(cleared);
-            return throwable;
-        } catch (RuntimeException ignored) {
-            // This should not happen unless someone instrumented or manipulated exception stack
-            // traces.
-            return throwable;
-        }
-    }
-
     @Override
     public Callable<?> handle(Object instance, Method origin, Object[] arguments) throws Throwable {
         MockMethodInterceptor interceptor = interceptors.get(instance);
@@ -333,25 +315,34 @@ public class MockMethodAdvice extends MockMethodDispatcher {
             return accessor.invoke(origin, instance, arguments);
         } catch (InvocationTargetException exception) {
             Throwable cause = exception.getCause();
-            StackTraceElement[] tmpStack = new Throwable().getStackTrace();
-
-            int skip = tmpStack.length;
-            // if there is a suitable instance, do not skip the root-cause for the exception
-            if (instance != null) {
-                skip = 0;
-                String causingClassName = instance.getClass().getName();
-                StackTraceElement stackFrame;
-                do {
-                    stackFrame = tmpStack[skip++];
-                } while (stackFrame.getClassName().startsWith(causingClassName));
-            }
-
             new ConditionalStackTraceFilter()
-                    .filter(hideRecursiveCall(cause, skip, origin.getDeclaringClass()));
+                    .filter(removeRecursiveCalls(cause, origin.getDeclaringClass()));
             throw cause;
         }
     }
 
+    static Throwable removeRecursiveCalls(final Throwable cause, final Class<?> declaringClass) {
+        final List<String> uniqueStackTraceItems = new ArrayList<>();
+        final List<Integer> indexesToBeRemoved = new ArrayList<>();
+        for (StackTraceElement element : cause.getStackTrace()) {
+            final String key = element.getClassName() + element.getLineNumber();
+            final int elementIndex = uniqueStackTraceItems.lastIndexOf(key);
+            uniqueStackTraceItems.add(key);
+
+            if (elementIndex > -1 && declaringClass.getName().equals(element.getClassName())) {
+                indexesToBeRemoved.add(elementIndex);
+            }
+        }
+        final List<StackTraceElement> adjustedList =
+                new ArrayList<>(Arrays.asList(cause.getStackTrace()));
+        indexesToBeRemoved.stream()
+                .sorted(Comparator.reverseOrder())
+                .mapToInt(Integer::intValue)
+                .forEach(adjustedList::remove);
+        cause.setStackTrace(adjustedList.toArray(new StackTraceElement[] {}));
+        return cause;
+    }
+
     private static class ReturnValueWrapper implements Callable<Object> {
 
         private final Object returned;
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
index d27b5f82c..f67fdfc5a 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
@@ -12,9 +12,12 @@ import static net.bytebuddy.implementation.attribute.MethodAttributeAppender.For
 import static net.bytebuddy.matcher.ElementMatchers.any;
 import static net.bytebuddy.matcher.ElementMatchers.hasParameters;
 import static net.bytebuddy.matcher.ElementMatchers.hasType;
+import static net.bytebuddy.matcher.ElementMatchers.isAnnotatedWith;
+import static net.bytebuddy.matcher.ElementMatchers.isDeclaredBy;
 import static net.bytebuddy.matcher.ElementMatchers.isEquals;
 import static net.bytebuddy.matcher.ElementMatchers.isHashCode;
 import static net.bytebuddy.matcher.ElementMatchers.isPackagePrivate;
+import static net.bytebuddy.matcher.ElementMatchers.named;
 import static net.bytebuddy.matcher.ElementMatchers.returns;
 import static net.bytebuddy.matcher.ElementMatchers.whereAny;
 import static org.mockito.internal.util.StringUtil.join;
@@ -26,7 +29,9 @@ import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.Random;
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.description.method.MethodDescription;
@@ -219,7 +224,7 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
                 byteBuddy
                         .subclass(features.mockedType)
                         .name(name)
-                        .ignoreAlso(BytecodeGenerator.isGroovyMethod(false))
+                        .ignoreAlso(isGroovyMethod())
                         .annotateType(
                                 features.stripAnnotations
                                         ? new Annotation[0]
@@ -277,6 +282,22 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
                 "The subclass byte code generator cannot create construction mocks");
     }
 
+    private <T> Collection<Class<? super T>> getAllTypes(Class<T> type) {
+        Collection<Class<? super T>> supertypes = new LinkedList<>();
+        supertypes.add(type);
+        Class<? super T> superType = type;
+        while (superType != null) {
+            supertypes.add(superType);
+            superType = superType.getSuperclass();
+        }
+        return supertypes;
+    }
+
+    private static ElementMatcher<MethodDescription> isGroovyMethod() {
+        return isDeclaredBy(named("groovy.lang.GroovyObjectSupport"))
+                .or(isAnnotatedWith(named("groovy.transform.Internal")));
+    }
+
     private boolean isComingFromJDK(Class<?> type) {
         // Comes from the manifest entry :
         // Implementation-Title: Java Runtime Environment
diff --git a/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java b/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java
index 7e26169ef..d53abf107 100644
--- a/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java
+++ b/src/main/java/org/mockito/internal/debugging/InvocationsPrinter.java
@@ -5,10 +5,10 @@
 package org.mockito.internal.debugging;
 
 import java.util.Collection;
-import java.util.LinkedList;
+import java.util.List;
+import java.util.stream.Collectors;
 
 import org.mockito.Mockito;
-import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.invocation.Invocation;
 import org.mockito.stubbing.Stubbing;
 
@@ -37,15 +37,10 @@ public class InvocationsPrinter {
             }
         }
 
-        LinkedList<Stubbing> unused =
-                ListUtil.filter(
-                        stubbings,
-                        new ListUtil.Filter<Stubbing>() {
-                            @Override
-                            public boolean isOut(Stubbing s) {
-                                return s.wasUsed();
-                            }
-                        });
+        List<Stubbing> unused =
+                stubbings.stream()
+                        .filter(stubbing -> !stubbing.wasUsed())
+                        .collect(Collectors.toList());
 
         if (unused.isEmpty()) {
             return sb.toString();
diff --git a/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java b/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java
index fc0cb2213..111b588cc 100644
--- a/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java
+++ b/src/main/java/org/mockito/internal/invocation/InvocationsFinder.java
@@ -6,9 +6,8 @@ package org.mockito.internal.invocation;
 
 import java.util.LinkedList;
 import java.util.List;
+import java.util.stream.Collectors;
 
-import org.mockito.internal.util.collections.ListUtil;
-import org.mockito.internal.util.collections.ListUtil.Filter;
 import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.Location;
@@ -20,7 +19,7 @@ public class InvocationsFinder {
 
     public static List<Invocation> findInvocations(
             List<Invocation> invocations, MatchableInvocation wanted) {
-        return ListUtil.filter(invocations, new RemoveNotMatching(wanted));
+        return invocations.stream().filter(wanted::matches).collect(Collectors.toList());
     }
 
     public static List<Invocation> findAllMatchingUnverifiedChunks(
@@ -28,7 +27,7 @@ public class InvocationsFinder {
             MatchableInvocation wanted,
             InOrderContext orderingContext) {
         List<Invocation> unverified = removeVerifiedInOrder(invocations, orderingContext);
-        return ListUtil.filter(unverified, new RemoveNotMatching(wanted));
+        return unverified.stream().filter(wanted::matches).collect(Collectors.toList());
     }
 
     /**
@@ -127,13 +126,13 @@ public class InvocationsFinder {
 
     public static Invocation findPreviousVerifiedInOrder(
             List<Invocation> invocations, InOrderContext context) {
-        LinkedList<Invocation> verifiedOnly =
-                ListUtil.filter(invocations, new RemoveUnverifiedInOrder(context));
+        List<Invocation> verifiedOnly =
+                invocations.stream().filter(context::isVerified).collect(Collectors.toList());
 
         if (verifiedOnly.isEmpty()) {
             return null;
         } else {
-            return verifiedOnly.getLast();
+            return verifiedOnly.get(verifiedOnly.size() - 1);
         }
     }
 
@@ -158,32 +157,6 @@ public class InvocationsFinder {
         return locations;
     }
 
-    private static class RemoveNotMatching implements Filter<Invocation> {
-        private final MatchableInvocation wanted;
-
-        private RemoveNotMatching(MatchableInvocation wanted) {
-            this.wanted = wanted;
-        }
-
-        @Override
-        public boolean isOut(Invocation invocation) {
-            return !wanted.matches(invocation);
-        }
-    }
-
-    private static class RemoveUnverifiedInOrder implements Filter<Invocation> {
-        private final InOrderContext orderingContext;
-
-        public RemoveUnverifiedInOrder(InOrderContext orderingContext) {
-            this.orderingContext = orderingContext;
-        }
-
-        @Override
-        public boolean isOut(Invocation invocation) {
-            return !orderingContext.isVerified(invocation);
-        }
-    }
-
     /**
      * i3 is unverified here:
      *
diff --git a/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java b/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java
index 19b0ac054..9f60910af 100644
--- a/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java
+++ b/src/main/java/org/mockito/internal/invocation/finder/VerifiableInvocationsFinder.java
@@ -5,9 +5,8 @@
 package org.mockito.internal.invocation.finder;
 
 import java.util.List;
+import java.util.stream.Collectors;
 
-import org.mockito.internal.util.collections.ListUtil;
-import org.mockito.internal.util.collections.ListUtil.Filter;
 import org.mockito.invocation.Invocation;
 
 /**
@@ -18,14 +17,8 @@ public class VerifiableInvocationsFinder {
     private VerifiableInvocationsFinder() {}
 
     public static List<Invocation> find(List<?> mocks) {
-        List<Invocation> invocations = AllInvocationsFinder.find(mocks);
-        return ListUtil.filter(invocations, new RemoveIgnoredForVerification());
-    }
-
-    private static class RemoveIgnoredForVerification implements Filter<Invocation> {
-        @Override
-        public boolean isOut(Invocation invocation) {
-            return invocation.isIgnoredForVerification();
-        }
+        return AllInvocationsFinder.find(mocks).stream()
+                .filter(invocation -> !invocation.isIgnoredForVerification())
+                .collect(Collectors.toList());
     }
 }
diff --git a/src/main/java/org/mockito/internal/junit/ExceptionFactory.java b/src/main/java/org/mockito/internal/junit/ExceptionFactory.java
index 7c5a841ab..a1331d260 100644
--- a/src/main/java/org/mockito/internal/junit/ExceptionFactory.java
+++ b/src/main/java/org/mockito/internal/junit/ExceptionFactory.java
@@ -36,7 +36,7 @@ public class ExceptionFactory {
      * Returns an AssertionError that describes the fact that the arguments of an invocation are different.
      * If {@link org.opentest4j.AssertionFailedError} is on the class path (used by JUnit 5 and others),
      * it returns a class that extends it. Otherwise, if {@link junit.framework.ComparisonFailure} is on the
-     * class path (shipped with JUnit 3 and 4), it will return a class that extends that. This provides
+     * class path (shipped with JUnit 4), it will return a class that extends that. This provides
      * better IDE support as the comparison result can be opened in a visual diff. If neither are available,
      * it returns an instance of
      * {@link org.mockito.exceptions.verification.ArgumentsAreDifferent}.
diff --git a/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java b/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
index c7fd12a7b..e51d2ebd4 100644
--- a/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
+++ b/src/main/java/org/mockito/internal/junit/UnusedStubbingsFinder.java
@@ -4,18 +4,15 @@
  */
 package org.mockito.internal.junit;
 
-import static org.mockito.internal.util.collections.ListUtil.filter;
-
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import org.mockito.internal.invocation.finder.AllInvocationsFinder;
 import org.mockito.internal.stubbing.UnusedStubbingReporting;
-import org.mockito.internal.util.collections.ListUtil.Filter;
 import org.mockito.invocation.Invocation;
 import org.mockito.stubbing.Stubbing;
 
@@ -29,19 +26,10 @@ public class UnusedStubbingsFinder {
      * Stubbings explicitily marked as LENIENT are not included.
      */
     public UnusedStubbings getUnusedStubbings(Iterable<Object> mocks) {
-        Set<Stubbing> stubbings = AllInvocationsFinder.findStubbings(mocks);
-
-        List<Stubbing> unused =
-                filter(
-                        stubbings,
-                        new Filter<Stubbing>() {
-                            @Override
-                            public boolean isOut(Stubbing s) {
-                                return !UnusedStubbingReporting.shouldBeReported(s);
-                            }
-                        });
-
-        return new UnusedStubbings(unused);
+        return new UnusedStubbings(
+                AllInvocationsFinder.findStubbings(mocks).stream()
+                        .filter(UnusedStubbingReporting::shouldBeReported)
+                        .collect(Collectors.toList()));
     }
 
     /**
diff --git a/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java b/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
index 46fd4d6f0..e417ec2c5 100644
--- a/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
+++ b/src/main/java/org/mockito/internal/matchers/EqualsWithDelta.java
@@ -6,6 +6,7 @@ package org.mockito.internal.matchers;
 
 import java.io.Serializable;
 
+import java.util.Objects;
 import org.mockito.ArgumentMatcher;
 
 public class EqualsWithDelta implements ArgumentMatcher<Number>, Serializable {
@@ -24,7 +25,7 @@ public class EqualsWithDelta implements ArgumentMatcher<Number>, Serializable {
             return false;
         }
 
-        if (wanted == actual) {
+        if (Objects.equals(wanted, actual)) {
             return true;
         }
 
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java b/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java
index 8bfffca2f..c159906af 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/InvocationInfo.java
@@ -6,6 +6,9 @@ package org.mockito.internal.stubbing.answers;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 
 import org.mockito.internal.invocation.AbstractAwareMethod;
 import org.mockito.internal.util.MockUtil;
@@ -24,15 +27,52 @@ public class InvocationInfo implements AbstractAwareMethod {
         this.invocation = theInvocation;
     }
 
-    public boolean isValidException(Throwable throwable) {
-        Class<?>[] exceptions = method.getExceptionTypes();
-        Class<?> throwableClass = throwable.getClass();
-        for (Class<?> exception : exceptions) {
+    public boolean isValidException(final Throwable throwable) {
+        if (isValidException(method, throwable)) {
+            return true;
+        }
+
+        return isValidExceptionForParents(method.getDeclaringClass(), throwable);
+    }
+
+    private boolean isValidExceptionForParents(final Class<?> parent, final Throwable throwable) {
+        final List<Class<?>> ancestors = new ArrayList<>(Arrays.asList(parent.getInterfaces()));
+
+        if (parent.getSuperclass() != null) {
+            ancestors.add(parent.getSuperclass());
+        }
+
+        final boolean validException =
+                ancestors.stream()
+                        .anyMatch(ancestor -> isValidExceptionForClass(ancestor, throwable));
+
+        if (validException) {
+            return true;
+        }
+
+        return ancestors.stream()
+                .anyMatch(ancestor -> isValidExceptionForParents(ancestor, throwable));
+    }
+
+    private boolean isValidExceptionForClass(final Class<?> parent, final Throwable throwable) {
+        try {
+            final Method parentMethod =
+                    parent.getMethod(this.method.getName(), this.method.getParameterTypes());
+            return isValidException(parentMethod, throwable);
+        } catch (NoSuchMethodException e) {
+            // ignore interfaces that doesn't have such a method
+            return false;
+        }
+    }
+
+    private boolean isValidException(final Method method, final Throwable throwable) {
+        final Class<?>[] exceptions = method.getExceptionTypes();
+        final Class<?> throwableClass = throwable.getClass();
+        for (final Class<?> exception : exceptions) {
             if (exception.isAssignableFrom(throwableClass)) {
                 return true;
             }
         }
-
         return false;
     }
 
diff --git a/src/main/java/org/mockito/internal/util/collections/ListUtil.java b/src/main/java/org/mockito/internal/util/collections/ListUtil.java
deleted file mode 100644
index f94afd89f..000000000
--- a/src/main/java/org/mockito/internal/util/collections/ListUtil.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.util.collections;
-
-import java.util.Collection;
-import java.util.LinkedList;
-
-/**
- * Basic list/collection operators. We know that there are existing libraries that implement those
- * use cases neatly. However, we want to keep Mockito dependencies minimal. In Java8 we should be
- * able to get rid of this class.
- */
-public final class ListUtil {
-
-    public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {
-        LinkedList<T> filtered = new LinkedList<T>();
-        for (T t : collection) {
-            if (!filter.isOut(t)) {
-                filtered.add(t);
-            }
-        }
-        return filtered;
-    }
-
-    public static <FromT, To> LinkedList<To> convert(
-            Collection<FromT> collection, Converter<FromT, To> converter) {
-        LinkedList<To> converted = new LinkedList<To>();
-        for (FromT f : collection) {
-            converted.add(converter.convert(f));
-        }
-        return converted;
-    }
-
-    public interface Filter<T> {
-        boolean isOut(T object);
-    }
-
-    public interface Converter<FromT, To> {
-        To convert(FromT from);
-    }
-
-    private ListUtil() {}
-}
diff --git a/src/main/java/org/mockito/internal/util/reflection/Fields.java b/src/main/java/org/mockito/internal/util/reflection/Fields.java
deleted file mode 100644
index f749649aa..000000000
--- a/src/main/java/org/mockito/internal/util/reflection/Fields.java
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.util.reflection;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.mockito.internal.util.Checks;
-import org.mockito.internal.util.collections.ListUtil;
-import org.mockito.internal.util.collections.ListUtil.Filter;
-
-/**
- * Small fluent reflection tools to work with fields.
- *
- * Code is very new and might need rework.
- */
-public abstract class Fields {
-
-    /**
-     * Instance fields declared in the class and superclasses of the given instance.
-     *
-     * @param instance Instance from which declared fields will be retrieved.
-     * @return InstanceFields of this object instance.
-     */
-    public static InstanceFields allDeclaredFieldsOf(Object instance) {
-        List<InstanceField> instanceFields = new ArrayList<>();
-        for (Class<?> clazz = instance.getClass();
-                clazz != Object.class;
-                clazz = clazz.getSuperclass()) {
-            instanceFields.addAll(instanceFieldsIn(instance, clazz.getDeclaredFields()));
-        }
-        return new InstanceFields(instance, instanceFields);
-    }
-
-    /**
-     * Instance fields declared in the class of the given instance.
-     *
-     * @param instance Instance from which declared fields will be retrieved.
-     * @return InstanceFields of this object instance.
-     */
-    public static InstanceFields declaredFieldsOf(Object instance) {
-        List<InstanceField> instanceFields = new ArrayList<>();
-        instanceFields.addAll(instanceFieldsIn(instance, instance.getClass().getDeclaredFields()));
-        return new InstanceFields(instance, instanceFields);
-    }
-
-    private static List<InstanceField> instanceFieldsIn(Object instance, Field[] fields) {
-        List<InstanceField> instanceDeclaredFields = new ArrayList<>();
-        for (Field field : fields) {
-            InstanceField instanceField = new InstanceField(field, instance);
-            instanceDeclaredFields.add(instanceField);
-        }
-        return instanceDeclaredFields;
-    }
-
-    /**
-     * Accept fields annotated by the given annotations.
-     *
-     * @param annotations Annotation types to check.
-     * @return The filter.
-     */
-    @SuppressWarnings({"unchecked", "vararg"})
-    public static Filter<InstanceField> annotatedBy(
-            final Class<? extends Annotation>... annotations) {
-        return new Filter<InstanceField>() {
-            @Override
-            public boolean isOut(InstanceField instanceField) {
-                Checks.checkNotNull(annotations, "Provide at least one annotation class");
-
-                for (Class<? extends Annotation> annotation : annotations) {
-                    if (instanceField.isAnnotatedBy(annotation)) {
-                        return false;
-                    }
-                }
-                return true;
-            }
-        };
-    }
-
-    /**
-     * Accept fields with non null value.
-     *
-     * @return The filter.
-     */
-    private static Filter<InstanceField> nullField() {
-        return new Filter<InstanceField>() {
-            @Override
-            public boolean isOut(InstanceField instanceField) {
-                return instanceField.isNull();
-            }
-        };
-    }
-
-    /**
-     * Accept fields with non null value.
-     *
-     * @return The filter.
-     */
-    public static Filter<InstanceField> syntheticField() {
-        return new Filter<InstanceField>() {
-            @Override
-            public boolean isOut(InstanceField instanceField) {
-                return instanceField.isSynthetic();
-            }
-        };
-    }
-
-    public static class InstanceFields {
-        private final Object instance;
-
-        private final List<InstanceField> instanceFields;
-
-        public InstanceFields(Object instance, List<InstanceField> instanceFields) {
-            this.instance = instance;
-            this.instanceFields = instanceFields;
-        }
-
-        public InstanceFields filter(Filter<InstanceField> withFilter) {
-            return new InstanceFields(instance, ListUtil.filter(instanceFields, withFilter));
-        }
-
-        public InstanceFields notNull() {
-            return filter(nullField());
-        }
-
-        public List<InstanceField> instanceFields() {
-            return new ArrayList<>(instanceFields);
-        }
-
-        public List<Object> assignedValues() {
-            List<Object> values = new ArrayList<>(instanceFields.size());
-            for (InstanceField instanceField : instanceFields) {
-                values.add(instanceField.read());
-            }
-            return values;
-        }
-
-        public List<String> names() {
-            List<String> fieldNames = new ArrayList<>(instanceFields.size());
-            for (InstanceField instanceField : instanceFields) {
-                fieldNames.add(instanceField.name());
-            }
-            return fieldNames;
-        }
-    }
-}
diff --git a/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java b/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java
index f81a53792..b32a5a458 100644
--- a/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java
+++ b/src/main/java/org/mockito/internal/verification/DefaultRegisteredInvocations.java
@@ -9,9 +9,8 @@ import static org.mockito.internal.util.ObjectMethodsGuru.isToStringMethod;
 import java.io.Serializable;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.stream.Collectors;
 
-import org.mockito.internal.util.collections.ListUtil;
-import org.mockito.internal.util.collections.ListUtil.Filter;
 import org.mockito.invocation.Invocation;
 
 public class DefaultRegisteredInvocations implements RegisteredInvocations, Serializable {
@@ -44,7 +43,9 @@ public class DefaultRegisteredInvocations implements RegisteredInvocations, Seri
             copiedList = new LinkedList<>(invocations);
         }
 
-        return ListUtil.filter(copiedList, new RemoveToString());
+        return copiedList.stream()
+                .filter(invocation -> !isToStringMethod(invocation.getMethod()))
+                .collect(Collectors.toList());
     }
 
     @Override
@@ -60,11 +61,4 @@ public class DefaultRegisteredInvocations implements RegisteredInvocations, Seri
             return invocations.isEmpty();
         }
     }
-
-    private static class RemoveToString implements Filter<Invocation> {
-        @Override
-        public boolean isOut(Invocation invocation) {
-            return isToStringMethod(invocation.getMethod());
-        }
-    }
 }
diff --git a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
index aeb86b962..9ceb48300 100644
--- a/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
+++ b/src/main/java/org/mockito/internal/verification/checkers/MissingInvocationChecker.java
@@ -16,9 +16,9 @@ import static org.mockito.internal.verification.argumentmatching.ArgumentMatchin
 
 import java.util.List;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import org.mockito.internal.reporting.SmartPrinter;
-import org.mockito.internal.util.collections.ListUtil;
 import org.mockito.internal.verification.api.InOrderContext;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.Location;
@@ -49,14 +49,7 @@ public class MissingInvocationChecker {
                 new SmartPrinter(
                         wanted, invocations, indexesOfSuspiciousArgs, classesWithSameSimpleName);
         List<Location> actualLocations =
-                ListUtil.convert(
-                        invocations,
-                        new ListUtil.Converter<Invocation, Location>() {
-                            @Override
-                            public Location convert(Invocation invocation) {
-                                return invocation.getLocation();
-                            }
-                        });
+                invocations.stream().map(Invocation::getLocation).collect(Collectors.toList());
 
         throw argumentsAreDifferent(
                 smartPrinter.getWanted(), smartPrinter.getActuals(), actualLocations);
diff --git a/src/test/java/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java b/src/test/java/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java
index 3443c79c8..a56330cee 100644
--- a/src/test/java/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java
+++ b/src/test/java/org/concurrentmockito/ThreadsRunAllTestsHalfManualTest.java
@@ -34,7 +34,6 @@ import org.mockito.internal.progress.TimesTest;
 import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest;
 import org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest;
 import org.mockito.internal.util.MockUtilTest;
-import org.mockito.internal.util.collections.ListUtilTest;
 import org.mockito.internal.verification.DefaultRegisteredInvocationsTest;
 import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest;
 import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest;
@@ -57,7 +56,20 @@ import org.mockitousage.stacktrace.StackTraceFilteringTest;
 import org.mockitousage.stubbing.BasicStubbingTest;
 import org.mockitousage.stubbing.ReturningDefaultValuesTest;
 import org.mockitousage.stubbing.StubbingWithThrowablesTest;
-import org.mockitousage.verification.*;
+import org.mockitousage.verification.AtMostXVerificationTest;
+import org.mockitousage.verification.BasicVerificationInOrderTest;
+import org.mockitousage.verification.BasicVerificationTest;
+import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest;
+import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest;
+import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest;
+import org.mockitousage.verification.ExactNumberOfTimesVerificationTest;
+import org.mockitousage.verification.NoMoreInteractionsVerificationTest;
+import org.mockitousage.verification.RelaxedVerificationInOrderTest;
+import org.mockitousage.verification.SelectedMocksInOrderVerificationTest;
+import org.mockitousage.verification.VerificationInOrderMixedWithOrdinaryVerificationTest;
+import org.mockitousage.verification.VerificationInOrderTest;
+import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest;
+import org.mockitousage.verification.VerificationUsingMatchersTest;
 import org.mockitoutil.TestBase;
 
 public class ThreadsRunAllTestsHalfManualTest extends TestBase {
@@ -70,7 +82,6 @@ public class ThreadsRunAllTestsHalfManualTest extends TestBase {
             Result result =
                     JUnitCore.runClasses(
                             EqualsTest.class,
-                            ListUtilTest.class,
                             MockingProgressImplTest.class,
                             TimesTest.class,
                             MockHandlerImplTest.class,
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java
index e27605640..3d42f3a37 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java
@@ -9,19 +9,14 @@ import static net.bytebuddy.ClassFileVersion.JAVA_V8;
 import static net.bytebuddy.matcher.ElementMatchers.named;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.*;
 import static org.junit.Assume.assumeTrue;
 
 import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Observable;
-import java.util.Observer;
-import java.util.Optional;
-import java.util.Set;
+import java.util.*;
 import java.util.concurrent.Callable;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 
 import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.ClassFileVersion;
@@ -253,17 +248,56 @@ public class InlineDelegateByteBuddyMockMakerTest
                 mockMaker.createSpy(
                         settings, new MockHandlerImpl<>(settings), new ExceptionThrowingClass());
 
-        StackTraceElement[] returnedStack = null;
-        try {
-            proxy.get().throwException();
-        } catch (IOException ex) {
-            returnedStack = ex.getStackTrace();
-        }
+        StackTraceElement[] returnedStack =
+                assertThrows(IOException.class, () -> proxy.get().throwException()).getStackTrace();
 
         assertNotNull("Stack trace from mockito expected", returnedStack);
 
-        assertEquals(ExceptionThrowingClass.class.getName(), returnedStack[0].getClassName());
-        assertEquals("internalThrowException", returnedStack[0].getMethodName());
+        List<StackTraceElement> exceptionClassElements =
+                Arrays.stream(returnedStack)
+                        .filter(
+                                element ->
+                                        element.getClassName()
+                                                .equals(ExceptionThrowingClass.class.getName()))
+                        .collect(Collectors.toList());
+        assertEquals(3, exceptionClassElements.size());
+        assertEquals("internalThrowException", exceptionClassElements.get(0).getMethodName());
+        assertEquals("internalThrowException", exceptionClassElements.get(1).getMethodName());
+        assertEquals("throwException", exceptionClassElements.get(2).getMethodName());
+    }
+
+    @Test
+    public void should_leave_causing_stack_with_two_spies() throws Exception {
+        // given
+        MockSettingsImpl<ExceptionThrowingClass> settingsEx = new MockSettingsImpl<>();
+        settingsEx.setTypeToMock(ExceptionThrowingClass.class);
+        settingsEx.defaultAnswer(Answers.CALLS_REAL_METHODS);
+        Optional<ExceptionThrowingClass> proxyEx =
+                mockMaker.createSpy(
+                        settingsEx,
+                        new MockHandlerImpl<>(settingsEx),
+                        new ExceptionThrowingClass());
+
+        MockSettingsImpl<WrapperClass> settingsWr = new MockSettingsImpl<>();
+        settingsWr.setTypeToMock(WrapperClass.class);
+        settingsWr.defaultAnswer(Answers.CALLS_REAL_METHODS);
+        Optional<WrapperClass> proxyWr =
+                mockMaker.createSpy(
+                        settingsWr, new MockHandlerImpl<>(settingsWr), new WrapperClass());
+
+        // when
+        IOException ex =
+                assertThrows(IOException.class, () -> proxyWr.get().callWrapped(proxyEx.get()));
+        List<StackTraceElement> wrapperClassElements =
+                Arrays.stream(ex.getStackTrace())
+                        .filter(
+                                element ->
+                                        element.getClassName().equals(WrapperClass.class.getName()))
+                        .collect(Collectors.toList());
+
+        // then
+        assertEquals(1, wrapperClassElements.size());
+        assertEquals("callWrapped", wrapperClassElements.get(0).getMethodName());
     }
 
     @Test
@@ -271,30 +305,33 @@ public class InlineDelegateByteBuddyMockMakerTest
         StackTraceElement[] stack =
                 new StackTraceElement[] {
                     new StackTraceElement("foo", "", "", -1),
-                    new StackTraceElement(SampleInterface.class.getName(), "", "", -1),
+                    new StackTraceElement(SampleInterface.class.getName(), "", "", 15),
                     new StackTraceElement("qux", "", "", -1),
                     new StackTraceElement("bar", "", "", -1),
+                    new StackTraceElement(SampleInterface.class.getName(), "", "", 15),
                     new StackTraceElement("baz", "", "", -1)
                 };
 
         Throwable throwable = new Throwable();
         throwable.setStackTrace(stack);
-        throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
+        throwable = MockMethodAdvice.removeRecursiveCalls(throwable, SampleInterface.class);
 
         assertThat(throwable.getStackTrace())
                 .isEqualTo(
                         new StackTraceElement[] {
                             new StackTraceElement("foo", "", "", -1),
+                            new StackTraceElement("qux", "", "", -1),
                             new StackTraceElement("bar", "", "", -1),
+                            new StackTraceElement(SampleInterface.class.getName(), "", "", 15),
                             new StackTraceElement("baz", "", "", -1)
                         });
     }
 
     @Test
-    public void should_handle_missing_or_inconsistent_stack_trace() throws Exception {
+    public void should_handle_missing_or_inconsistent_stack_trace() {
         Throwable throwable = new Throwable();
         throwable.setStackTrace(new StackTraceElement[0]);
-        assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class))
+        assertThat(MockMethodAdvice.removeRecursiveCalls(throwable, SampleInterface.class))
                 .isSameAs(throwable);
     }
 
@@ -579,6 +616,12 @@ public class InlineDelegateByteBuddyMockMakerTest
         }
     }
 
+    public static class WrapperClass {
+        public void callWrapped(ExceptionThrowingClass exceptionThrowingClass) throws IOException {
+            exceptionThrowingClass.throwException();
+        }
+    }
+
     public static class GenericSubClass extends GenericClass<String> {}
 
     public static class ExceptionThrowingClass {
diff --git a/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java b/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
index 281d41b3c..9900db9d9 100644
--- a/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
+++ b/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
@@ -30,6 +30,7 @@ public class InvocationBuilder {
     private int sequenceNumber = 0;
     private Object[] args = new Object[] {};
     private Object mock = Mockito.mock(IMethods.class);
+    private Class<?> mockClass = IMethods.class;
     private Method method;
     private boolean verified;
     private List<Class<?>> argTypes;
@@ -57,7 +58,7 @@ public class InvocationBuilder {
 
             try {
                 method =
-                        IMethods.class.getMethod(
+                        mockClass.getMethod(
                                 methodName, argTypes.toArray(new Class[argTypes.size()]));
             } catch (Exception e) {
                 throw new RuntimeException(
@@ -115,6 +116,12 @@ public class InvocationBuilder {
         return this;
     }
 
+    public InvocationBuilder mockClass(Class<?> mockClass) {
+        this.mockClass = mockClass;
+        this.mock = mock(mockClass);
+        return this;
+    }
+
     public InvocationBuilder method(Method method) {
         this.method = method;
         return this;
diff --git a/src/test/java/org/mockito/internal/junit/ExceptionFactoryTest.java b/src/test/java/org/mockito/internal/junit/ExceptionFactoryTest.java
index 69baf3042..394d0fb39 100644
--- a/src/test/java/org/mockito/internal/junit/ExceptionFactoryTest.java
+++ b/src/test/java/org/mockito/internal/junit/ExceptionFactoryTest.java
@@ -15,28 +15,19 @@ import org.mockito.exceptions.verification.ArgumentsAreDifferent;
 
 public class ExceptionFactoryTest {
 
-    private static ClassLoader classLoaderWithoutJUnitOrOpenTest =
+    private static final ClassLoader classLoaderWithoutJUnitOrOpenTest =
             excludingClassLoader()
                     .withCodeSourceUrlOf(ExceptionFactory.class)
                     .without("org.junit", "junit", "org.opentest4j")
                     .build();
-    private static ClassLoader classLoaderWithoutOpenTest =
-            excludingClassLoader()
-                    .withCodeSourceUrlOf(ExceptionFactory.class, org.junit.ComparisonFailure.class)
-                    .without("org.opentest4j")
-                    .build();
-    private static ClassLoader currentClassLoader = ExceptionFactoryTest.class.getClassLoader();
+    private static final ClassLoader currentClassLoader =
+            ExceptionFactoryTest.class.getClassLoader();
 
     /** loaded by the current classloader */
     private static Class<?> opentestComparisonFailure;
 
     private static Class<?> opentestArgumentsAreDifferent;
 
-    /** loaded by the classloader {@value #classLoaderWithoutOpenTest}, which excludes OpenTest4J classes */
-    private static Class<?> junit3ComparisonFailure;
-
-    private static Class<?> junit3ArgumentsAreDifferent;
-
     /** loaded by the custom classloader {@value #classLoaderWithoutJUnitOrOpenTest}, which excludes JUnit and OpenTest4J classes */
     private static Class<?> nonJunitArgumentsAreDifferent;
 
@@ -44,13 +35,6 @@ public class ExceptionFactoryTest {
     public static void init() throws ClassNotFoundException {
         nonJunitArgumentsAreDifferent =
                 classLoaderWithoutJUnitOrOpenTest.loadClass(ArgumentsAreDifferent.class.getName());
-        junit3ComparisonFailure =
-                classLoaderWithoutOpenTest.loadClass(
-                        junit.framework.ComparisonFailure.class.getName());
-        junit3ArgumentsAreDifferent =
-                classLoaderWithoutOpenTest.loadClass(
-                        org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.class
-                                .getName());
         opentestComparisonFailure = org.opentest4j.AssertionFailedError.class;
         opentestArgumentsAreDifferent =
                 org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent.class;
@@ -63,15 +47,6 @@ public class ExceptionFactoryTest {
         assertThat(e).isExactlyInstanceOf(nonJunitArgumentsAreDifferent);
     }
 
-    @Test
-    public void createArgumentsAreDifferentException_withJUnit3_butNotOpenTest() throws Exception {
-        AssertionError e = invokeFactoryThroughLoader(classLoaderWithoutOpenTest);
-
-        assertThat(e)
-                .isExactlyInstanceOf(junit3ArgumentsAreDifferent)
-                .isInstanceOf(junit3ComparisonFailure);
-    }
-
     @Test
     public void createArgumentsAreDifferentException_withOpenTest() throws Exception {
         AssertionError e = invokeFactoryThroughLoader(currentClassLoader);
@@ -92,17 +67,6 @@ public class ExceptionFactoryTest {
         assertThat(e).isExactlyInstanceOf(nonJunitArgumentsAreDifferent);
     }
 
-    @Test
-    public void createArgumentsAreDifferentException_withJUnit3_2x() throws Exception {
-        AssertionError e;
-
-        e = invokeFactoryThroughLoader(classLoaderWithoutOpenTest);
-        assertThat(e).isExactlyInstanceOf(junit3ArgumentsAreDifferent);
-
-        e = invokeFactoryThroughLoader(classLoaderWithoutOpenTest);
-        assertThat(e).isExactlyInstanceOf(junit3ArgumentsAreDifferent);
-    }
-
     @Test
     public void createArgumentsAreDifferentException_withOpenTest_2x() throws Exception {
         AssertionError e;
diff --git a/src/test/java/org/mockito/internal/matchers/text/ValuePrinterTest.java b/src/test/java/org/mockito/internal/matchers/text/ValuePrinterTest.java
index 1ece06ca1..56b5e5fad 100644
--- a/src/test/java/org/mockito/internal/matchers/text/ValuePrinterTest.java
+++ b/src/test/java/org/mockito/internal/matchers/text/ValuePrinterTest.java
@@ -9,7 +9,7 @@ import static org.junit.Assert.assertTrue;
 import static org.mockito.internal.matchers.text.ValuePrinter.print;
 
 import java.util.LinkedHashMap;
-
+import java.util.Map;
 import org.junit.Test;
 
 public class ValuePrinterTest {
@@ -24,29 +24,23 @@ public class ValuePrinterTest {
         assertThat(print(3.14d)).isEqualTo("3.14d");
         assertThat(print(3.14f)).isEqualTo("3.14f");
         assertThat(print(new int[] {1, 2})).isEqualTo("[1, 2]");
-        assertThat(
-                        print(
-                                new LinkedHashMap<String, Object>() {
-                                    {
-                                        put("foo", 2L);
-                                    }
-                                }))
-                .isEqualTo("{\"foo\" = 2L}");
-        assertThat(
-                        print(
-                                new LinkedHashMap<String, Object>() {
-                                    {
-                                        put("int passed as hex", 0x01);
-                                        put("byte", (byte) 0x01);
-                                        put("short", (short) 2);
-                                        put("int", 3);
-                                        put("long", 4L);
-                                        put("float", 2.71f);
-                                        put("double", 3.14d);
-                                    }
-                                }))
+
+        Map<String, Object> map1 = new LinkedHashMap<>();
+        map1.put("foo", 2L);
+        assertThat(print(map1)).isEqualTo("{\"foo\" = 2L}");
+
+        Map<String, Object> map2 = new LinkedHashMap<>();
+        map2.put("int passed as hex", 0x01);
+        map2.put("byte", (byte) 0x01);
+        map2.put("short", (short) 2);
+        map2.put("int", 3);
+        map2.put("long", 4L);
+        map2.put("float", 2.71f);
+        map2.put("double", 3.14d);
+        assertThat(print(map2))
                 .isEqualTo(
                         "{\"int passed as hex\" = 1, \"byte\" = (byte) 0x01, \"short\" = (short) 2, \"int\" = 3, \"long\" = 4L, \"float\" = 2.71f, \"double\" = 3.14d}");
+
         assertTrue(print(new UnsafeToString()).contains("UnsafeToString"));
         assertThat(print(new ToString())).isEqualTo("ToString");
         assertThat(print(new FormattedText("formatted"))).isEqualTo("formatted");
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoExceptionTest.java b/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoExceptionTest.java
new file mode 100644
index 000000000..21802c1f5
--- /dev/null
+++ b/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoExceptionTest.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2022 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.stubbing.answers;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.mockito.internal.invocation.InvocationBuilder;
+import org.mockito.invocation.Invocation;
+
+import java.nio.charset.CharacterCodingException;
+import java.util.Arrays;
+import java.util.Collection;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+@RunWith(Parameterized.class)
+public class InvocationInfoExceptionTest {
+
+    private final String methodName;
+
+    public InvocationInfoExceptionTest(final String methodName) {
+        this.methodName = methodName;
+    }
+
+    @Parameterized.Parameters
+    public static Collection<Object[]> data() {
+        return Arrays.asList(
+                new Object[][] {
+                    {"throwException"},
+                    {"parentThrowsException"},
+                    {"grandParentThrowsException"},
+                    {"interfaceThrowsException"},
+                    {"grandInterfaceThrowsException"},
+                    {"interfaceOfParentThrowsException"}
+                });
+    }
+
+    @Test
+    public void should_know_valid_throwables() throws Exception {
+        // when
+        final Invocation invocation =
+                new InvocationBuilder()
+                        .method(methodName)
+                        .mockClass(CurrentClass.class)
+                        .toInvocation();
+        final InvocationInfo info = new InvocationInfo(invocation);
+
+        // then
+        assertThat(info.isValidException(new Exception())).isFalse();
+        assertThat(info.isValidException(new CharacterCodingException())).isTrue();
+    }
+
+    private abstract static class GrandParent {
+        public abstract void grandParentThrowsException() throws CharacterCodingException;
+    }
+
+    private interface InterfaceOfParent {
+        abstract void interfaceOfParentThrowsException() throws CharacterCodingException;
+    }
+
+    private abstract static class Parent extends GrandParent implements InterfaceOfParent {
+        public abstract void parentThrowsException() throws CharacterCodingException;
+    }
+
+    private interface GrandInterface {
+        void grandInterfaceThrowsException() throws CharacterCodingException;
+    }
+
+    private interface Interface extends GrandInterface {
+        void interfaceThrowsException() throws CharacterCodingException;
+    }
+
+    private static class CurrentClass extends Parent implements Interface {
+
+        public void throwException() throws CharacterCodingException {}
+
+        @Override
+        public void grandParentThrowsException() {}
+
+        @Override
+        public void parentThrowsException() {}
+
+        @Override
+        public void grandInterfaceThrowsException() {}
+
+        @Override
+        public void interfaceThrowsException() {}
+
+        @Override
+        public void interfaceOfParentThrowsException() {}
+    }
+}
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoTest.java b/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoTest.java
index 3c9d96983..fea0ec36e 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/InvocationInfoTest.java
@@ -9,26 +9,13 @@ import static org.mockito.Mockito.mock;
 import static org.mockitoutil.TestBase.getLastInvocation;
 
 import java.lang.reflect.Method;
-import java.nio.charset.CharacterCodingException;
 
 import org.junit.Test;
 import org.mockito.internal.invocation.InvocationBuilder;
-import org.mockito.invocation.Invocation;
 import org.mockitousage.IMethods;
 
 public class InvocationInfoTest {
 
-    @Test
-    public void should_know_valid_throwables() throws Exception {
-        // when
-        Invocation invocation = new InvocationBuilder().method("canThrowException").toInvocation();
-        InvocationInfo info = new InvocationInfo(invocation);
-
-        // then
-        assertThat(info.isValidException(new Exception())).isFalse();
-        assertThat(info.isValidException(new CharacterCodingException())).isTrue();
-    }
-
     @Test
     public void should_know_valid_return_types() throws Exception {
         assertThat(
diff --git a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java
index 870f0cee3..984e07da2 100644
--- a/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNullsTest.java
@@ -16,7 +16,6 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.ThrowableAssert;
 import org.junit.Test;
@@ -307,20 +306,14 @@ public class ReturnsSmartNullsTest extends TestBase {
             should_return_a_empty_map_that_has_been_defined_with_method_generic_and_provided_in_var_args()
                     throws Throwable {
 
-        final Map<String, String> map1 =
-                new HashMap<String, String>() {
-                    {
-                        put("key-1", "value-1");
-                        put("key-2", "value-2");
-                    }
-                };
-        final Map<String, String> map2 =
-                new HashMap<String, String>() {
-                    {
-                        put("key-3", "value-1");
-                        put("key-4", "value-2");
-                    }
-                };
+        final Map<String, String> map1 = new HashMap<>();
+        map1.put("key-1", "value-1");
+        map1.put("key-2", "value-2");
+
+        final Map<String, String> map2 = new HashMap<>();
+        map2.put("key-3", "value-1");
+        map2.put("key-4", "value-2");
+
         Answer<Object> answer = new ReturnsSmartNulls();
 
         Object smartNull = answer.answer(invocationMethodWithVarArgs(new Map[] {map1, map2}));
diff --git a/src/test/java/org/mockito/internal/util/PlatformTest.java b/src/test/java/org/mockito/internal/util/PlatformTest.java
index b72c71d39..d4c453386 100644
--- a/src/test/java/org/mockito/internal/util/PlatformTest.java
+++ b/src/test/java/org/mockito/internal/util/PlatformTest.java
@@ -8,7 +8,6 @@ import static org.assertj.core.api.Assertions.assertThat;
 
 import java.util.HashMap;
 import java.util.Map;
-
 import org.junit.Test;
 
 // Possible description on a IBM J9 VM (see #801)
@@ -75,23 +74,19 @@ public class PlatformTest {
         // https://stackoverflow.com/questions/35844985/how-do-we-get-sr-and-fp-of-ibm-jre-using-java
         //  -
         // https://www.ibm.com/support/knowledgecenter/SSYKE2_8.0.0/com.ibm.java.80.doc/user/build_number.html
-        Map<String, Boolean> versions =
-                new HashMap<String, Boolean>() {
-                    {
-                        put("1.8.0_92-b14", false);
-                        put("1.8.0-b24", true);
-                        put("1.8.0_5", true);
-                        put("1.8.0b5_u44", true);
-                        put("1.8.0b5_u92", false);
-                        put("1.7.0_4", false);
-                        put("1.4.0_03-b04", false);
-                        put("1.4.0_03-ea-b01", false);
-                        put("pxi3270_27sr4-20160303_03 (SR4)", false);
-                        put("pwi3260sr11-20120412_01 (SR11)", false);
-                        put("pwa6480sr1fp10-20150711_01 (SR1 FP10)", false);
-                        put("null", false);
-                    }
-                };
+        Map<String, Boolean> versions = new HashMap<>();
+        versions.put("1.8.0_92-b14", false);
+        versions.put("1.8.0-b24", true);
+        versions.put("1.8.0_5", true);
+        versions.put("1.8.0b5_u44", true);
+        versions.put("1.8.0b5_u92", false);
+        versions.put("1.7.0_4", false);
+        versions.put("1.4.0_03-b04", false);
+        versions.put("1.4.0_03-ea-b01", false);
+        versions.put("pxi3270_27sr4-20160303_03 (SR4)", false);
+        versions.put("pwi3260sr11-20120412_01 (SR11)", false);
+        versions.put("pwa6480sr1fp10-20150711_01 (SR1 FP10)", false);
+        versions.put("null", false);
 
         assertPlatformParsesCorrectlyVariousVersionScheme(versions);
     }
@@ -134,15 +129,11 @@ public class PlatformTest {
         // java.specification.version      1.9           9
         // java.vm.specification.version   1.9           9
         //
-        Map<String, Boolean> versions =
-                new HashMap<String, Boolean>() {
-                    {
-                        put("9-ea+73", false);
-                        put("9+100", false);
-                        put("9.1.2+62", false);
-                        put("9.0.1+20", false);
-                    }
-                };
+        Map<String, Boolean> versions = new HashMap<>();
+        versions.put("9-ea+73", false);
+        versions.put("9+100", false);
+        versions.put("9.1.2+62", false);
+        versions.put("9.0.1+20", false);
 
         assertPlatformParsesCorrectlyVariousVersionScheme(versions);
     }
diff --git a/src/test/java/org/mockito/internal/util/collections/ListUtilTest.java b/src/test/java/org/mockito/internal/util/collections/ListUtilTest.java
deleted file mode 100644
index 6f47fe29b..000000000
--- a/src/test/java/org/mockito/internal/util/collections/ListUtilTest.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.util.collections;
-
-import static java.util.Arrays.asList;
-
-import static org.junit.Assert.assertTrue;
-
-import java.util.LinkedList;
-import java.util.List;
-
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
-import org.mockito.internal.util.collections.ListUtil.Filter;
-import org.mockitoutil.TestBase;
-
-public class ListUtilTest extends TestBase {
-
-    @Test
-    public void shouldFilterList() throws Exception {
-        List<String> list = asList("one", "x", "two", "x", "three");
-        List<String> filtered =
-                ListUtil.filter(
-                        list,
-                        new Filter<String>() {
-                            public boolean isOut(String object) {
-                                return object == "x";
-                            }
-                        });
-
-        Assertions.assertThat(filtered).containsSequence("one", "two", "three");
-    }
-
-    @Test
-    public void shouldReturnEmptyIfEmptyListGiven() throws Exception {
-        List<Object> list = new LinkedList<Object>();
-        List<Object> filtered = ListUtil.filter(list, null);
-        assertTrue(filtered.isEmpty());
-    }
-}
diff --git a/src/test/java/org/mockito/internal/util/reflection/FieldsTest.java b/src/test/java/org/mockito/internal/util/reflection/FieldsTest.java
deleted file mode 100644
index 270cfaefd..000000000
--- a/src/test/java/org/mockito/internal/util/reflection/FieldsTest.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.util.reflection;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.mockito.internal.util.reflection.Fields.syntheticField;
-
-import java.lang.reflect.Field;
-
-import org.junit.Test;
-
-public class FieldsTest {
-
-    @Test
-    public void fields_should_return_all_declared_fields_in_hierarchy() throws Exception {
-        assertThat(
-                        Fields.allDeclaredFieldsOf(new HierarchyOfClasses())
-                                .filter(syntheticField())
-                                .names())
-                .containsOnly("a", "b", "static_a", "static_b");
-    }
-
-    @Test
-    public void fields_should_return_declared_fields() throws Exception {
-        assertThat(
-                        Fields.declaredFieldsOf(new HierarchyOfClasses())
-                                .filter(syntheticField())
-                                .names())
-                .containsOnly("b", "static_b");
-    }
-
-    @Test
-    public void can_filter_not_null_fields() throws Exception {
-        assertThat(
-                        Fields.declaredFieldsOf(new NullOrNotNullFields())
-                                .notNull()
-                                .filter(syntheticField())
-                                .names())
-                .containsOnly("c");
-    }
-
-    @Test
-    public void can_get_values_of_instance_fields() throws Exception {
-        assertThat(
-                        Fields.declaredFieldsOf(new ValuedFields())
-                                .filter(syntheticField())
-                                .assignedValues())
-                .containsOnly("a", "b");
-    }
-
-    @Test
-    public void can_get_list_of_InstanceField() throws Exception {
-        ValuedFields instance = new ValuedFields();
-
-        assertThat(Fields.declaredFieldsOf(instance).filter(syntheticField()).instanceFields())
-                .containsOnly(
-                        new InstanceField(field("a", instance), instance),
-                        new InstanceField(field("b", instance), instance));
-    }
-
-    private Field field(String name, Object instance) throws NoSuchFieldException {
-        return instance.getClass().getDeclaredField(name);
-    }
-
-    interface AnInterface {
-        int someStaticInInterface = 0;
-    }
-
-    public static class ParentClass implements AnInterface {
-        static int static_a;
-        int a;
-    }
-
-    public static class HierarchyOfClasses extends ParentClass {
-        static int static_b;
-        int b = 1;
-    }
-
-    public static class NullOrNotNullFields {
-        static Object static_b;
-        Object b;
-        Object c = new Object();
-    }
-
-    public static class ValuedFields {
-        String a = "a";
-        String b = "b";
-    }
-}
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
index 045a8b659..efc3e8f33 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
@@ -24,6 +24,7 @@ import java.util.LinkedList;
 import java.util.Map;
 
 import org.assertj.core.api.Assertions;
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
@@ -248,34 +249,34 @@ public class StubbingWithThrowablesTest extends TestBase {
                 .hasMessageContaining("Cannot stub with null throwable");
     }
 
-    @Test
-    public void shouldNotAllowSettingNullThrowableClass() {
-        assertThatThrownBy(
-                        () -> {
-                            when(mock.isEmpty()).thenThrow((Class) null);
-                        })
+    private void assertExceptionTypeCanNotBeNull(ThrowingCallable throwingCallable) {
+        assertThatThrownBy(throwingCallable)
                 .isInstanceOf(MockitoException.class)
                 .hasMessageContaining("Exception type cannot be null");
     }
 
+    @Test
+    public void shouldNotAllowSettingNullThrowableClass() {
+        assertExceptionTypeCanNotBeNull(
+                () -> {
+                    when(mock.isEmpty()).thenThrow((Class) null);
+                });
+    }
+
     @Test
     public void shouldNotAllowSettingNullThrowableClasses() {
-        assertThatThrownBy(
-                        () -> {
-                            when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class[]) null);
-                        })
-                .isInstanceOf(MockitoException.class)
-                .hasMessageContaining("Exception type cannot be null");
+        assertExceptionTypeCanNotBeNull(
+                () -> {
+                    when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class[]) null);
+                });
     }
 
     @Test
     public void shouldNotAllowSettingNullVarArgThrowableClass() {
-        assertThatThrownBy(
-                        () -> {
-                            when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class) null);
-                        })
-                .isInstanceOf(MockitoException.class)
-                .hasMessageContaining("Exception type cannot be null");
+        assertExceptionTypeCanNotBeNull(
+                () -> {
+                    when(mock.isEmpty()).thenThrow(RuntimeException.class, (Class) null);
+                });
     }
 
     @Test
diff --git a/subprojects/bom/bom.gradle b/subprojects/bom/bom.gradle
index 569f6d658..3582cfa78 100644
--- a/subprojects/bom/bom.gradle
+++ b/subprojects/bom/bom.gradle
@@ -12,6 +12,7 @@ apply from: "$rootDir/gradle/java-publication.gradle"
 
 dependencies {
     constraints {
+        api(project.rootProject)
         project.rootProject.subprojects.forEach { subproject ->
             if (!subproject.name.endsWith("Test") &&
                 !subproject.name.endsWith("-test") &&
diff --git a/subprojects/errorprone/src/main/java/org/mockito/errorprone/bugpatterns/MockitoAnyIncorrectPrimitiveType.java b/subprojects/errorprone/src/main/java/org/mockito/errorprone/bugpatterns/MockitoAnyIncorrectPrimitiveType.java
index 48b7ee11e..b73610b45 100644
--- a/subprojects/errorprone/src/main/java/org/mockito/errorprone/bugpatterns/MockitoAnyIncorrectPrimitiveType.java
+++ b/subprojects/errorprone/src/main/java/org/mockito/errorprone/bugpatterns/MockitoAnyIncorrectPrimitiveType.java
@@ -49,7 +49,7 @@ public class MockitoAnyIncorrectPrimitiveType extends AbstractMockitoAnyForPrimi
   };
 
   private static final Matcher<ExpressionTree> METHOD_MATCHER =
-      staticMethod().onClassAny(CLASS_NAMES).withNameMatching(METHOD_NAME_PATTERN).withParameters();
+      staticMethod().onClassAny(CLASS_NAMES).withNameMatching(METHOD_NAME_PATTERN).withNoParameters();
 
   @Override
   protected Matcher<? super MethodInvocationTree> matcher() {
diff --git a/subprojects/groovyInlineTest/groovyInlineTest.gradle b/subprojects/groovyInlineTest/groovyInlineTest.gradle
deleted file mode 100644
index 1618ac600..000000000
--- a/subprojects/groovyInlineTest/groovyInlineTest.gradle
+++ /dev/null
@@ -1,11 +0,0 @@
-apply plugin: 'groovy'
-
-description = "Integration test for using mockito-inline with Groovy."
-
-apply from: "$rootDir/gradle/dependencies.gradle"
-
-dependencies {
-    testImplementation project(":inline")
-    testImplementation libraries.groovy
-    testImplementation libraries.junit4
-}
diff --git a/subprojects/groovyInlineTest/src/test/groovy/org/mockito/groovy/GroovyMockitoTest.groovy b/subprojects/groovyInlineTest/src/test/groovy/org/mockito/groovy/GroovyMockitoTest.groovy
deleted file mode 100644
index c327d0e1b..000000000
--- a/subprojects/groovyInlineTest/src/test/groovy/org/mockito/groovy/GroovyMockitoTest.groovy
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (c) 2022 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.groovy
-
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.mockito.InjectMocks
-import org.mockito.Mock
-import org.mockito.junit.MockitoJUnitRunner
-
-import static org.mockito.Mockito.verify
-
-@RunWith(MockitoJUnitRunner)
-class GroovyMockitoTest {
-
-    @Mock Helper helper
-    @InjectMocks ClassUnderTest classUnderTest
-
-    /**
-     * Test that the Groovy class under test can call methods on a mocked Groovy
-     * helper class.
-     */
-    @Test
-    void testCallGroovyFromGroovy() {
-        classUnderTest.methodUnderTest()
-        verify(helper).helperMethod()
-    }
-
-    static class ClassUnderTest {
-        private final Helper helper
-
-        ClassUnderTest(Helper helper) {
-            this.helper = helper
-        }
-
-        void methodUnderTest() {
-            helper.helperMethod()
-        }
-    }
-
-    static class Helper {
-        void helperMethod() { }
-    }
-}
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockTest.java b/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockTest.java
index 419508081..7eb87c570 100644
--- a/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockTest.java
+++ b/subprojects/inline/src/test/java/org/mockitoinline/ConstructionMockTest.java
@@ -57,6 +57,19 @@ public final class ConstructionMockTest {
         }
     }
 
+    /**
+     * Tests issue #2544
+     */
+    @Test
+    public void testConstructionMockDefaultAnswerMultipleMoreThanTwo() {
+        try (MockedConstruction<Dummy> ignored = Mockito.mockConstructionWithAnswer(Dummy.class, invocation -> "bar", invocation -> "qux", invocation -> "baz")) {
+            assertEquals("bar", new Dummy().foo());
+            assertEquals("qux", new Dummy().foo());
+            assertEquals("baz", new Dummy().foo());
+            assertEquals("baz", new Dummy().foo());
+        }
+    }
+
     @Test
     public void testConstructionMockPrepared() {
         try (MockedConstruction<Dummy> ignored = Mockito.mockConstruction(Dummy.class, (mock, context) -> when(mock.foo()).thenReturn("bar"))) {
diff --git a/subprojects/inline/src/test/java/org/mockitoinline/InOrderVerificationTest.java b/subprojects/inline/src/test/java/org/mockitoinline/InOrderVerificationTest.java
new file mode 100644
index 000000000..fb35adc76
--- /dev/null
+++ b/subprojects/inline/src/test/java/org/mockitoinline/InOrderVerificationTest.java
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2022 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitoinline;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.mockStatic;
+import static org.mockito.Mockito.timeout;
+import static org.mockito.Mockito.times;
+
+import org.assertj.core.api.Assert;
+import org.junit.Test;
+import org.mockito.InOrder;
+import org.mockito.MockedStatic;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.misusing.NotAMockException;
+import org.mockito.exceptions.verification.VerificationInOrderFailure;
+import org.mockito.verification.VerificationMode;
+
+public class InOrderVerificationTest {
+    @Test
+    public void shouldVerifyStaticMethods() {
+        try (MockedStatic<StaticContext> mockedStatic = mockStatic(StaticContext.class)) {
+            // given
+            InOrder inOrder = inOrder(StaticContext.class);
+
+            // when
+            StaticContext.firstMethod();
+            StaticContext.secondMethod(0);
+
+            // then
+            inOrder.verify(mockedStatic, StaticContext::firstMethod);
+            inOrder.verify(mockedStatic, () -> StaticContext.secondMethod(0));
+        }
+    }
+
+    @Test
+    public void shouldVerifyStaticAndInstanceMethods() {
+        try (MockedStatic<StaticContext> mockedStatic = mockStatic(StaticContext.class)) {
+            // given
+            StaticContext mocked = mock(StaticContext.class);
+            InOrder inOrder = inOrder(mocked, StaticContext.class);
+
+            // when
+            StaticContext.firstMethod();
+            mocked.instanceMethod();
+            StaticContext.secondMethod(10);
+
+            // then
+            inOrder.verify(mockedStatic, StaticContext::firstMethod);
+            inOrder.verify(mocked).instanceMethod();
+            inOrder.verify(mockedStatic, () -> StaticContext.secondMethod(10));
+        }
+    }
+
+    @Test
+    public void shouldVerifyStaticMethodsWithSimpleAndWrapperModes() {
+        try (MockedStatic<StaticContext> mockedStatic = mockStatic(StaticContext.class)) {
+            // given
+            InOrder inOrder = inOrder(StaticContext.class);
+
+            // when
+            StaticContext.firstMethod();
+            StaticContext.firstMethod();
+            StaticContext.secondMethod(0);
+
+            // then
+            inOrder.verify(mockedStatic, StaticContext::firstMethod, times(2));
+            inOrder.verify(mockedStatic, () -> StaticContext.secondMethod(0), timeout(100).atLeastOnce());
+        }
+    }
+
+    @Test
+    public void shouldThrowExceptionWhenModeIsUnsupported() {
+        try (MockedStatic<StaticContext> mockedStatic = mockStatic(StaticContext.class)) {
+            // given
+            VerificationMode unsupportedMode = data -> { };
+            InOrder inOrder = inOrder(StaticContext.class);
+
+            // when
+            StaticContext.firstMethod();
+
+            // then
+            assertThatThrownBy(() ->
+                inOrder.verify(mockedStatic, StaticContext::firstMethod, unsupportedMode)
+            ).isInstanceOf(MockitoException.class);
+        }
+    }
+
+    @Test
+    public void shouldThrowExceptionWhenOrderIsWrong() {
+        try (MockedStatic<StaticContext> mockedStatic = mockStatic(StaticContext.class)) {
+            // given
+            InOrder inOrder = inOrder(StaticContext.class);
+
+            // when
+            StaticContext.firstMethod();
+            StaticContext.secondMethod(0);
+
+            // then
+            assertThatThrownBy(() -> {
+                inOrder.verify(mockedStatic, () -> StaticContext.secondMethod(0));
+                inOrder.verify(mockedStatic, StaticContext::firstMethod);
+            }).isInstanceOf(VerificationInOrderFailure.class);
+        }
+    }
+
+    @Test
+    public void shouldThrowExceptionWhenNoMoreInteractionsInvokedButThereAre() {
+        try (MockedStatic<StaticContext> mockedStatic = mockStatic(StaticContext.class)) {
+            // given
+            InOrder inOrder = inOrder(StaticContext.class);
+
+            // when
+            StaticContext.firstMethod();
+            StaticContext.secondMethod(0);
+
+            // then
+            inOrder.verify(mockedStatic, StaticContext::firstMethod);
+            assertThatThrownBy(inOrder::verifyNoMoreInteractions)
+                .isInstanceOf(VerificationInOrderFailure.class);
+        }
+    }
+
+    @Test
+    public void shouldThrowExceptionWhenNoMoreInteractionsInvokedWithoutVerifyingStaticMethods() {
+        try (MockedStatic<StaticContext> ignored = mockStatic(StaticContext.class)) {
+            // given
+            StaticContext mocked = mock(StaticContext.class);
+            InOrder inOrder = inOrder(StaticContext.class, mocked);
+
+            // when
+            mocked.instanceMethod();
+            StaticContext.firstMethod();
+
+            // then
+            inOrder.verify(mocked).instanceMethod();
+            assertThatThrownBy(inOrder::verifyNoMoreInteractions)
+                .isInstanceOf(VerificationInOrderFailure.class);
+        }
+    }
+
+    @Test
+    public void shouldThrowExceptionWhenClassIsNotMocked() {
+        assertThatThrownBy(
+            () -> inOrder(StaticContext.class)
+        ).isInstanceOf(NotAMockException.class);
+    }
+
+    @Test
+    public void shouldVerifyStaticMethodsWithoutInterferingWithMocking() {
+        try (MockedStatic<StaticContext> mockedStatic = mockStatic(StaticContext.class)) {
+            // given
+            InOrder inOrder = inOrder(StaticContext.class);
+            Exception expected = new RuntimeException();
+            mockedStatic.when(StaticContext::firstMethod).thenThrow(expected);
+
+            // when
+            Assert<?, ?> actual = assertThatThrownBy(StaticContext::firstMethod);
+
+            // then
+            actual.isSameAs(expected);
+            inOrder.verify(mockedStatic, StaticContext::firstMethod);
+            inOrder.verifyNoMoreInteractions();
+        }
+    }
+
+    @Test
+    public void shouldThrowExceptionWhenVerifyUsingInOrderWithoutValidClass() {
+        try (MockedStatic<StaticContext> mockedStaticContext = mockStatic(StaticContext.class)) {
+            try (MockedStatic<AnotherStaticContext> mockedAnotherStaticContext = mockStatic(AnotherStaticContext.class)) {
+                // given
+                InOrder inOrder = inOrder(AnotherStaticContext.class);
+
+                // when
+                mockedAnotherStaticContext.when(AnotherStaticContext::otherMethod).thenReturn("mocked value");
+                StaticContext.firstMethod();
+
+                // then
+                assertThat(AnotherStaticContext.otherMethod())
+                    .isEqualTo("mocked value");
+                inOrder.verify(mockedAnotherStaticContext, AnotherStaticContext::otherMethod);
+                assertThatThrownBy(() -> inOrder.verify(mockedStaticContext, StaticContext::firstMethod))
+                    .isInstanceOf(VerificationInOrderFailure.class);
+            }
+        }
+    }
+
+    private static class AnotherStaticContext {
+        static String otherMethod() {
+            throw new AssertionError("otherMethod should be mocked");
+        }
+    }
+
+    private static class StaticContext {
+        static void firstMethod() {
+            fail("firstMethod should be mocked");
+        }
+
+        static void secondMethod(int n) {
+            fail("secondMethod should be mocked but was invoked with argument " + n);
+        }
+
+        void instanceMethod() {
+            fail("instanceMethod should be mocked");
+        }
+    }
+}
