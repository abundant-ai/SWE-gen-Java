diff --git a/build.gradle b/build.gradle
index aa273359e..9b914880f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -10,7 +10,7 @@ buildscript {
         classpath 'net.ltgt.gradle:gradle-errorprone-plugin:2.0.1'
 
         //Using buildscript.classpath so that we can resolve plugins from maven local, during local testing
-        classpath "org.shipkit:shipkit-auto-version:1.1.8"
+        classpath "org.shipkit:shipkit-auto-version:1.1.9"
         classpath "org.shipkit:shipkit-changelog:1.1.15"
         classpath "com.jfrog.bintray.gradle:gradle-bintray-plugin:1.+"
 
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java
index 35c379c4a..8153f526e 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java
@@ -6,7 +6,6 @@ package org.mockito.internal.creation.bytebuddy;
 
 import org.mockito.Incubating;
 import org.mockito.MockedConstruction;
-import org.mockito.internal.exceptions.Reporter;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 
@@ -23,57 +22,44 @@ import java.util.function.Function;
  * The programmatic API could look like {@code mock(Final.class, withSettings().finalClasses())}.
  */
 public class ByteBuddyMockMaker implements ClassCreatingMockMaker {
-    private final SubclassByteBuddyMockMaker subclassByteBuddyMockMaker;
-
-    public ByteBuddyMockMaker() {
-        try {
-            subclassByteBuddyMockMaker = new SubclassByteBuddyMockMaker();
-        } catch (NoClassDefFoundError e) {
-            Reporter.missingByteBuddyDependency(e);
-            throw e;
-        }
-    }
-
-    ByteBuddyMockMaker(SubclassByteBuddyMockMaker subclassByteBuddyMockMaker) {
-        this.subclassByteBuddyMockMaker = subclassByteBuddyMockMaker;
-    }
+    private ClassCreatingMockMaker defaultByteBuddyMockMaker = new SubclassByteBuddyMockMaker();
 
     @Override
     public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
-        return subclassByteBuddyMockMaker.createMock(settings, handler);
+        return defaultByteBuddyMockMaker.createMock(settings, handler);
     }
 
     @Override
     public <T> Optional<T> createSpy(
             MockCreationSettings<T> settings, MockHandler handler, T object) {
-        return subclassByteBuddyMockMaker.createSpy(settings, handler, object);
+        return defaultByteBuddyMockMaker.createSpy(settings, handler, object);
     }
 
     @Override
     public <T> Class<? extends T> createMockType(MockCreationSettings<T> creationSettings) {
-        return subclassByteBuddyMockMaker.createMockType(creationSettings);
+        return defaultByteBuddyMockMaker.createMockType(creationSettings);
     }
 
     @Override
     public MockHandler getHandler(Object mock) {
-        return subclassByteBuddyMockMaker.getHandler(mock);
+        return defaultByteBuddyMockMaker.getHandler(mock);
     }
 
     @Override
     public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
-        subclassByteBuddyMockMaker.resetMock(mock, newHandler, settings);
+        defaultByteBuddyMockMaker.resetMock(mock, newHandler, settings);
     }
 
     @Override
     @Incubating
     public TypeMockability isTypeMockable(Class<?> type) {
-        return subclassByteBuddyMockMaker.isTypeMockable(type);
+        return defaultByteBuddyMockMaker.isTypeMockable(type);
     }
 
     @Override
     public <T> StaticMockControl<T> createStaticMock(
             Class<T> type, MockCreationSettings<T> settings, MockHandler handler) {
-        return subclassByteBuddyMockMaker.createStaticMock(type, settings, handler);
+        return defaultByteBuddyMockMaker.createStaticMock(type, settings, handler);
     }
 
     @Override
@@ -82,12 +68,12 @@ public class ByteBuddyMockMaker implements ClassCreatingMockMaker {
             Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
             Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
             MockedConstruction.MockInitializer<T> mockInitializer) {
-        return subclassByteBuddyMockMaker.createConstructionMock(
+        return defaultByteBuddyMockMaker.createConstructionMock(
                 type, settingsFactory, handlerFactory, mockInitializer);
     }
 
     @Override
     public void clearAllCaches() {
-        subclassByteBuddyMockMaker.clearAllCaches();
+        defaultByteBuddyMockMaker.clearAllCaches();
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
index 92593ded9..32e5b99f2 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMaker.java
@@ -4,85 +4,557 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.lang.instrument.Instrumentation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
+import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.JarOutputStream;
+
+import net.bytebuddy.agent.ByteBuddyAgent;
 import org.mockito.Incubating;
 import org.mockito.MockedConstruction;
+import org.mockito.creation.instance.InstantiationException;
 import org.mockito.creation.instance.Instantiator;
-import org.mockito.internal.exceptions.Reporter;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.exceptions.base.MockitoInitializationException;
+import org.mockito.exceptions.misusing.MockitoConfigurationException;
+import org.mockito.internal.SuppressSignatureCheck;
+import org.mockito.internal.configuration.plugins.Plugins;
+import org.mockito.internal.creation.instance.ConstructorInstantiator;
+import org.mockito.internal.util.Platform;
+import org.mockito.internal.util.concurrent.DetachedThreadLocal;
+import org.mockito.internal.util.concurrent.WeakConcurrentMap;
 import org.mockito.invocation.MockHandler;
 import org.mockito.mock.MockCreationSettings;
 import org.mockito.plugins.InlineMockMaker;
+import org.mockito.plugins.MemberAccessor;
 
-import java.util.Optional;
-import java.util.function.Function;
+import static org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.*;
+import static org.mockito.internal.util.StringUtil.*;
 
+/**
+ * Agent and subclass based mock maker.
+ * <p>
+ * This mock maker which uses a combination of the Java instrumentation API and sub-classing rather than creating
+ * a new sub-class to create a mock. This way, it becomes possible to mock final types and methods. This mock
+ * maker <strong>must to be activated explicitly</strong> for supporting mocking final types and methods:
+ * <p>
+ * <p>
+ * This mock maker can be activated by creating the file <code>/mockito-extensions/org.mockito.plugins.MockMaker</code>
+ * containing the text <code>mock-maker-inline</code> or <code>org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker</code>.
+ * <p>
+ * <p>
+ * This mock maker will make a best effort to avoid subclass creation when creating a mock. Otherwise it will use the
+ * <code>org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker</code> to create the mock class. That means
+ * that the following condition is true
+ * <p>
+ * <pre class="code"><code class="java">
+ * class Foo { }
+ * assert mock(Foo.class).getClass() == Foo.class;
+ * </pre></code>
+ * <p>
+ * unless any of the following conditions is met, in such case the mock maker <em>fall backs</em> to the
+ * the creation of a subclass.
+ * <p>
+ * <ul>
+ * <li>the type to mock is an abstract class.</li>
+ * <li>the mock is set to require additional interfaces.</li>
+ * <li>the mock is <a href="#20">explicitly set to support serialization</a>.</li>
+ * </ul>
+ * <p>
+ * <p>
+ * Some type of the JDK cannot be mocked, this includes <code>Class</code>, <code>String</code>, and wrapper types.
+ * <p>
+ * <p>
+ * Nevertheless, final methods of such types are mocked when using the inlining mock maker. Mocking final types and enums
+ * does however remain impossible when explicitly requiring serialization support or when adding ancillary interfaces.
+ * <p>
+ * <p>
+ * Important behavioral changes when using inline-mocks:
+ * <ul>
+ * <li>Mockito is capable of mocking package-private methods even if they are defined in different packages than
+ * the mocked type. Mockito voluntarily never mocks package-visible methods within <code>java.*</code> packages.</li>
+ * <li>Additionally to final types, Mockito can now mock types that are not visible for extension; such types
+ * include private types in a protected package.</li>
+ * <li>Mockito can no longer mock <code>native</code> methods. Inline mocks require byte code manipulation of a
+ * method where native methods do not offer any byte code to manipulate.</li>
+ * <li>Mockito cannot longer strip <code>synchronized</code> modifiers from mocked instances.</li>
+ * </ul>
+ * <p>
+ * <p>
+ * Note that inline mocks require a Java agent to be attached. Mockito will attempt an attachment of a Java agent upon
+ * loading the mock maker for creating inline mocks. Such runtime attachment is only possible when using a JVM that
+ * is part of a JDK or when using a Java 9 VM. When running on a non-JDK VM prior to Java 9, it is however possible to
+ * manually add the <a href="https://bytebuddy.net">Byte Buddy Java agent jar</a> using the <code>-javaagent</code>
+ * parameter upon starting the JVM. Furthermore, the inlining mock maker requires the VM to support class retransformation
+ * (also known as HotSwap). All major VM distributions such as HotSpot (OpenJDK), J9 (IBM/Websphere) or Zing (Azul)
+ * support this feature.
+ */
 @Incubating
+@SuppressSignatureCheck
 public class InlineByteBuddyMockMaker
         implements ClassCreatingMockMaker, InlineMockMaker, Instantiator {
-    private final InlineDelegateByteBuddyMockMaker inlineDelegateByteBuddyMockMaker;
 
-    public InlineByteBuddyMockMaker() {
+    private static final Instrumentation INSTRUMENTATION;
+
+    private static final Throwable INITIALIZATION_ERROR;
+
+    static {
+        Instrumentation instrumentation;
+        Throwable initializationError = null;
         try {
-            inlineDelegateByteBuddyMockMaker = new InlineDelegateByteBuddyMockMaker();
-        } catch (NoClassDefFoundError e) {
-            Reporter.missingByteBuddyDependency(e);
-            throw e;
+            try {
+                instrumentation = ByteBuddyAgent.install();
+                if (!instrumentation.isRetransformClassesSupported()) {
+                    throw new IllegalStateException(
+                            join(
+                                    "Byte Buddy requires retransformation for creating inline mocks. This feature is unavailable on the current VM.",
+                                    "",
+                                    "You cannot use this mock maker on this VM"));
+                }
+                File boot = File.createTempFile("mockitoboot", ".jar");
+                boot.deleteOnExit();
+                JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot));
+                try {
+                    String source =
+                            "org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher";
+                    InputStream inputStream =
+                            InlineByteBuddyMockMaker.class
+                                    .getClassLoader()
+                                    .getResourceAsStream(source + ".raw");
+                    if (inputStream == null) {
+                        throw new IllegalStateException(
+                                join(
+                                        "The MockMethodDispatcher class file is not locatable: "
+                                                + source
+                                                + ".raw",
+                                        "",
+                                        "The class loader responsible for looking up the resource: "
+                                                + InlineByteBuddyMockMaker.class.getClassLoader()));
+                    }
+                    outputStream.putNextEntry(new JarEntry(source + ".class"));
+                    try {
+                        int length;
+                        byte[] buffer = new byte[1024];
+                        while ((length = inputStream.read(buffer)) != -1) {
+                            outputStream.write(buffer, 0, length);
+                        }
+                    } finally {
+                        inputStream.close();
+                    }
+                    outputStream.closeEntry();
+                } finally {
+                    outputStream.close();
+                }
+                try (JarFile jarfile = new JarFile(boot)) {
+                    instrumentation.appendToBootstrapClassLoaderSearch(jarfile);
+                }
+                try {
+                    Class.forName(
+                            "org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher",
+                            false,
+                            null);
+                } catch (ClassNotFoundException cnfe) {
+                    throw new IllegalStateException(
+                            join(
+                                    "Mockito failed to inject the MockMethodDispatcher class into the bootstrap class loader",
+                                    "",
+                                    "It seems like your current VM does not support the instrumentation API correctly."),
+                            cnfe);
+                }
+            } catch (IOException ioe) {
+                throw new IllegalStateException(
+                        join(
+                                "Mockito could not self-attach a Java agent to the current VM. This feature is required for inline mocking.",
+                                "This error occured due to an I/O error during the creation of this agent: "
+                                        + ioe,
+                                "",
+                                "Potentially, the current VM does not support the instrumentation API correctly"),
+                        ioe);
+            }
+        } catch (Throwable throwable) {
+            instrumentation = null;
+            initializationError = throwable;
         }
+        INSTRUMENTATION = instrumentation;
+        INITIALIZATION_ERROR = initializationError;
     }
 
-    InlineByteBuddyMockMaker(InlineDelegateByteBuddyMockMaker inlineDelegateByteBuddyMockMaker) {
-        this.inlineDelegateByteBuddyMockMaker = inlineDelegateByteBuddyMockMaker;
+    private final BytecodeGenerator bytecodeGenerator;
+
+    private final WeakConcurrentMap<Object, MockMethodInterceptor> mocks =
+            new WeakConcurrentMap.WithInlinedExpunction<Object, MockMethodInterceptor>();
+
+    private final DetachedThreadLocal<Map<Class<?>, MockMethodInterceptor>> mockedStatics =
+            new DetachedThreadLocal<>(DetachedThreadLocal.Cleaner.INLINE);
+
+    private final DetachedThreadLocal<Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>>>
+            mockedConstruction = new DetachedThreadLocal<>(DetachedThreadLocal.Cleaner.INLINE);
+
+    private final ThreadLocal<Boolean> mockitoConstruction = ThreadLocal.withInitial(() -> false);
+
+    private final ThreadLocal<Object> currentSpied = new ThreadLocal<>();
+
+    public InlineByteBuddyMockMaker() {
+        if (INITIALIZATION_ERROR != null) {
+            String detail;
+            if (System.getProperty("java.specification.vendor", "")
+                    .toLowerCase()
+                    .contains("android")) {
+                detail =
+                        "It appears as if you are trying to run this mock maker on Android which does not support the instrumentation API.";
+            } else {
+                try {
+                    if (Class.forName("javax.tools.ToolProvider")
+                                    .getMethod("getSystemJavaCompiler")
+                                    .invoke(null)
+                            == null) {
+                        detail =
+                                "It appears as if you are running on a JRE. Either install a JDK or add JNA to the class path.";
+                    } else {
+                        detail =
+                                "It appears as if your JDK does not supply a working agent attachment mechanism.";
+                    }
+                } catch (Throwable ignored) {
+                    detail =
+                            "It appears as if you are running an incomplete JVM installation that might not support all tooling APIs";
+                }
+            }
+            throw new MockitoInitializationException(
+                    join(
+                            "Could not initialize inline Byte Buddy mock maker.",
+                            "",
+                            detail,
+                            Platform.describe()),
+                    INITIALIZATION_ERROR);
+        }
+
+        ThreadLocal<Class<?>> currentConstruction = new ThreadLocal<>();
+        ThreadLocal<Boolean> isSuspended = ThreadLocal.withInitial(() -> false);
+        Predicate<Class<?>> isMockConstruction =
+                type -> {
+                    if (isSuspended.get()) {
+                        return false;
+                    } else if (mockitoConstruction.get() || currentConstruction.get() != null) {
+                        return true;
+                    }
+                    Map<Class<?>, ?> interceptors = mockedConstruction.get();
+                    if (interceptors != null && interceptors.containsKey(type)) {
+                        currentConstruction.set(type);
+                        return true;
+                    } else {
+                        return false;
+                    }
+                };
+        ConstructionCallback onConstruction =
+                (type, object, arguments, parameterTypeNames) -> {
+                    if (mockitoConstruction.get()) {
+                        Object spy = currentSpied.get();
+                        if (spy == null) {
+                            return null;
+                        } else if (type.isInstance(spy)) {
+                            return spy;
+                        } else {
+                            isSuspended.set(true);
+                            try {
+                                // Unexpected construction of non-spied object
+                                throw new MockitoException(
+                                        "Unexpected spy for "
+                                                + type.getName()
+                                                + " on instance of "
+                                                + object.getClass().getName(),
+                                        object instanceof Throwable ? (Throwable) object : null);
+                            } finally {
+                                isSuspended.set(false);
+                            }
+                        }
+                    } else if (currentConstruction.get() != type) {
+                        return null;
+                    }
+                    currentConstruction.remove();
+                    isSuspended.set(true);
+                    try {
+                        Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors =
+                                mockedConstruction.get();
+                        if (interceptors != null) {
+                            BiConsumer<Object, MockedConstruction.Context> interceptor =
+                                    interceptors.get(type);
+                            if (interceptor != null) {
+                                interceptor.accept(
+                                        object,
+                                        new InlineConstructionMockContext(
+                                                arguments, object.getClass(), parameterTypeNames));
+                            }
+                        }
+                    } finally {
+                        isSuspended.set(false);
+                    }
+                    return null;
+                };
+
+        bytecodeGenerator =
+                new TypeCachingBytecodeGenerator(
+                        new InlineBytecodeGenerator(
+                                INSTRUMENTATION,
+                                mocks,
+                                mockedStatics,
+                                isMockConstruction,
+                                onConstruction),
+                        true);
     }
 
     @Override
-    public <T> T newInstance(Class<T> cls) {
-        return inlineDelegateByteBuddyMockMaker.newInstance(cls);
+    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
+        return doCreateMock(settings, handler, false);
     }
 
     @Override
-    public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
-        return inlineDelegateByteBuddyMockMaker.createMockType(settings);
+    public <T> Optional<T> createSpy(
+            MockCreationSettings<T> settings, MockHandler handler, T object) {
+        if (object == null) {
+            throw new MockitoConfigurationException("Spy instance must not be null");
+        }
+        currentSpied.set(object);
+        try {
+            return Optional.ofNullable(doCreateMock(settings, handler, true));
+        } finally {
+            currentSpied.remove();
+        }
+    }
+
+    private <T> T doCreateMock(
+            MockCreationSettings<T> settings,
+            MockHandler handler,
+            boolean nullOnNonInlineConstruction) {
+        Class<? extends T> type = createMockType(settings);
+
+        try {
+            T instance;
+            if (settings.isUsingConstructor()) {
+                instance =
+                        new ConstructorInstantiator(
+                                        settings.getOuterClassInstance() != null,
+                                        settings.getConstructorArgs())
+                                .newInstance(type);
+            } else {
+                try {
+                    // We attempt to use the "native" mock maker first that avoids
+                    // Objenesis and Unsafe
+                    instance = newInstance(type);
+                } catch (InstantiationException ignored) {
+                    if (nullOnNonInlineConstruction) {
+                        return null;
+                    }
+                    Instantiator instantiator =
+                            Plugins.getInstantiatorProvider().getInstantiator(settings);
+                    instance = instantiator.newInstance(type);
+                }
+            }
+            MockMethodInterceptor mockMethodInterceptor =
+                    new MockMethodInterceptor(handler, settings);
+            mocks.put(instance, mockMethodInterceptor);
+            if (instance instanceof MockAccess) {
+                ((MockAccess) instance).setMockitoInterceptor(mockMethodInterceptor);
+            }
+            return instance;
+        } catch (org.mockito.creation.instance.InstantiationException e) {
+            throw new MockitoException(
+                    "Unable to create mock instance of type '" + type.getSimpleName() + "'", e);
+        }
     }
 
     @Override
-    public void clearMock(Object mock) {
-        inlineDelegateByteBuddyMockMaker.clearMock(mock);
+    public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
+        try {
+            return bytecodeGenerator.mockClass(
+                    MockFeatures.withMockFeatures(
+                            settings.getTypeToMock(),
+                            settings.getExtraInterfaces(),
+                            settings.getSerializableMode(),
+                            settings.isStripAnnotations()));
+        } catch (Exception bytecodeGenerationFailed) {
+            throw prettifyFailure(settings, bytecodeGenerationFailed);
+        }
+    }
+
+    private <T> RuntimeException prettifyFailure(
+            MockCreationSettings<T> mockFeatures, Exception generationFailed) {
+        if (mockFeatures.getTypeToMock().isArray()) {
+            throw new MockitoException(
+                    join("Arrays cannot be mocked: " + mockFeatures.getTypeToMock() + ".", ""),
+                    generationFailed);
+        }
+        if (Modifier.isFinal(mockFeatures.getTypeToMock().getModifiers())) {
+            throw new MockitoException(
+                    join(
+                            "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
+                            "Can not mock final classes with the following settings :",
+                            " - explicit serialization (e.g. withSettings().serializable())",
+                            " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
+                            "",
+                            "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
+                            "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
+                            "",
+                            "Underlying exception : " + generationFailed),
+                    generationFailed);
+        }
+        if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
+            throw new MockitoException(
+                    join(
+                            "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
+                            "Most likely it is a private class that is not visible by Mockito",
+                            "",
+                            "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
+                            "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
+                            ""),
+                    generationFailed);
+        }
+        throw new MockitoException(
+                join(
+                        "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
+                        "",
+                        "If you're not sure why you're getting this error, please report to the mailing list.",
+                        "",
+                        Platform.warnForVM(
+                                "IBM J9 VM",
+                                "Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n",
+                                "Hotspot",
+                                Platform.isJava8BelowUpdate45()
+                                        ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n"
+                                        : ""),
+                        Platform.describe(),
+                        "",
+                        "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
+                        "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
+                        "",
+                        "Underlying exception : " + generationFailed),
+                generationFailed);
     }
 
     @Override
-    public void clearAllMocks() {
-        inlineDelegateByteBuddyMockMaker.clearAllMocks();
+    public MockHandler getHandler(Object mock) {
+        MockMethodInterceptor interceptor;
+        if (mock instanceof Class<?>) {
+            Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
+            interceptor = interceptors != null ? interceptors.get(mock) : null;
+        } else {
+            interceptor = mocks.get(mock);
+        }
+        if (interceptor == null) {
+            return null;
+        } else {
+            return interceptor.handler;
+        }
     }
 
     @Override
-    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
-        return inlineDelegateByteBuddyMockMaker.createMock(settings, handler);
+    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
+        MockMethodInterceptor mockMethodInterceptor =
+                new MockMethodInterceptor(newHandler, settings);
+        if (mock instanceof Class<?>) {
+            Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
+            if (interceptors == null || !interceptors.containsKey(mock)) {
+                throw new MockitoException(
+                        "Cannot reset "
+                                + mock
+                                + " which is not currently registered as a static mock");
+            }
+            interceptors.put((Class<?>) mock, mockMethodInterceptor);
+        } else {
+            if (!mocks.containsKey(mock)) {
+                throw new MockitoException(
+                        "Cannot reset " + mock + " which is not currently registered as a mock");
+            }
+            mocks.put(mock, mockMethodInterceptor);
+            if (mock instanceof MockAccess) {
+                ((MockAccess) mock).setMockitoInterceptor(mockMethodInterceptor);
+            }
+        }
     }
 
     @Override
-    public <T> Optional<T> createSpy(
-            MockCreationSettings<T> settings, MockHandler handler, T instance) {
-        return inlineDelegateByteBuddyMockMaker.createSpy(settings, handler, instance);
+    public void clearAllCaches() {
+        clearAllMocks();
+        bytecodeGenerator.clearAllCaches();
     }
 
     @Override
-    public MockHandler getHandler(Object mock) {
-        return inlineDelegateByteBuddyMockMaker.getHandler(mock);
+    public void clearMock(Object mock) {
+        if (mock instanceof Class<?>) {
+            for (Map<Class<?>, ?> entry : mockedStatics.getBackingMap().target.values()) {
+                entry.remove(mock);
+            }
+        } else {
+            mocks.remove(mock);
+        }
     }
 
     @Override
-    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
-        inlineDelegateByteBuddyMockMaker.resetMock(mock, newHandler, settings);
+    public void clearAllMocks() {
+        mockedStatics.getBackingMap().clear();
+        mocks.clear();
     }
 
     @Override
-    public TypeMockability isTypeMockable(Class<?> type) {
-        return inlineDelegateByteBuddyMockMaker.isTypeMockable(type);
+    public TypeMockability isTypeMockable(final Class<?> type) {
+        return new TypeMockability() {
+            @Override
+            public boolean mockable() {
+                return INSTRUMENTATION.isModifiableClass(type) && !EXCLUDES.contains(type);
+            }
+
+            @Override
+            public String nonMockableReason() {
+                if (mockable()) {
+                    return "";
+                }
+                if (type.isPrimitive()) {
+                    return "primitive type";
+                }
+                if (EXCLUDES.contains(type)) {
+                    return "Cannot mock wrapper types, String.class or Class.class";
+                }
+                return "VM does not support modification of given type";
+            }
+        };
     }
 
     @Override
     public <T> StaticMockControl<T> createStaticMock(
             Class<T> type, MockCreationSettings<T> settings, MockHandler handler) {
-        return inlineDelegateByteBuddyMockMaker.createStaticMock(type, settings, handler);
+        if (type == ConcurrentHashMap.class) {
+            throw new MockitoException(
+                    "It is not possible to mock static methods of ConcurrentHashMap "
+                            + "to avoid infinitive loops within Mockito's implementation of static mock handling");
+        } else if (type == Thread.class
+                || type == System.class
+                || type == Arrays.class
+                || ClassLoader.class.isAssignableFrom(type)) {
+            throw new MockitoException(
+                    "It is not possible to mock static methods of "
+                            + type.getName()
+                            + " to avoid interfering with class loading what leads to infinite loops");
+        }
+
+        bytecodeGenerator.mockClassStatic(type);
+
+        Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
+        if (interceptors == null) {
+            interceptors = new WeakHashMap<>();
+            mockedStatics.set(interceptors);
+        }
+
+        return new InlineStaticMockControl<>(type, interceptors, settings, handler);
     }
 
     @Override
@@ -91,12 +563,306 @@ public class InlineByteBuddyMockMaker
             Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
             Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
             MockedConstruction.MockInitializer<T> mockInitializer) {
-        return inlineDelegateByteBuddyMockMaker.createConstructionMock(
-                type, settingsFactory, handlerFactory, mockInitializer);
+        if (type == Object.class) {
+            throw new MockitoException(
+                    "It is not possible to mock construction of the Object class "
+                            + "to avoid inference with default object constructor chains");
+        } else if (type.isPrimitive() || Modifier.isAbstract(type.getModifiers())) {
+            throw new MockitoException(
+                    "It is not possible to construct primitive types or abstract types: "
+                            + type.getName());
+        }
+
+        bytecodeGenerator.mockClassConstruction(type);
+
+        Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors =
+                mockedConstruction.get();
+        if (interceptors == null) {
+            interceptors = new WeakHashMap<>();
+            mockedConstruction.set(interceptors);
+        }
+
+        return new InlineConstructionMockControl<>(
+                type, settingsFactory, handlerFactory, mockInitializer, interceptors);
     }
 
     @Override
-    public void clearAllCaches() {
-        inlineDelegateByteBuddyMockMaker.clearAllCaches();
+    @SuppressWarnings("unchecked")
+    public <T> T newInstance(Class<T> cls) throws InstantiationException {
+        Constructor<?>[] constructors = cls.getDeclaredConstructors();
+        if (constructors.length == 0) {
+            throw new InstantiationException(cls.getName() + " does not define a constructor");
+        }
+        Constructor<?> selected = constructors[0];
+        for (Constructor<?> constructor : constructors) {
+            if (Modifier.isPublic(constructor.getModifiers())) {
+                selected = constructor;
+                break;
+            }
+        }
+        Class<?>[] types = selected.getParameterTypes();
+        Object[] arguments = new Object[types.length];
+        int index = 0;
+        for (Class<?> type : types) {
+            arguments[index++] = makeStandardArgument(type);
+        }
+        MemberAccessor accessor = Plugins.getMemberAccessor();
+        try {
+            return (T)
+                    accessor.newInstance(
+                            selected,
+                            callback -> {
+                                mockitoConstruction.set(true);
+                                try {
+                                    return callback.newInstance();
+                                } finally {
+                                    mockitoConstruction.set(false);
+                                }
+                            },
+                            arguments);
+        } catch (Exception e) {
+            throw new InstantiationException("Could not instantiate " + cls.getName(), e);
+        }
+    }
+
+    private Object makeStandardArgument(Class<?> type) {
+        if (type == boolean.class) {
+            return false;
+        } else if (type == byte.class) {
+            return (byte) 0;
+        } else if (type == short.class) {
+            return (short) 0;
+        } else if (type == char.class) {
+            return (char) 0;
+        } else if (type == int.class) {
+            return 0;
+        } else if (type == long.class) {
+            return 0L;
+        } else if (type == float.class) {
+            return 0f;
+        } else if (type == double.class) {
+            return 0d;
+        } else {
+            return null;
+        }
+    }
+
+    private static class InlineStaticMockControl<T> implements StaticMockControl<T> {
+
+        private final Class<T> type;
+
+        private final Map<Class<?>, MockMethodInterceptor> interceptors;
+
+        private final MockCreationSettings<T> settings;
+
+        private final MockHandler handler;
+
+        private InlineStaticMockControl(
+                Class<T> type,
+                Map<Class<?>, MockMethodInterceptor> interceptors,
+                MockCreationSettings<T> settings,
+                MockHandler handler) {
+            this.type = type;
+            this.interceptors = interceptors;
+            this.settings = settings;
+            this.handler = handler;
+        }
+
+        @Override
+        public Class<T> getType() {
+            return type;
+        }
+
+        @Override
+        public void enable() {
+            if (interceptors.putIfAbsent(type, new MockMethodInterceptor(handler, settings))
+                    != null) {
+                throw new MockitoException(
+                        join(
+                                "For "
+                                        + type.getName()
+                                        + ", static mocking is already registered in the current thread",
+                                "",
+                                "To create a new mock, the existing static mock registration must be deregistered"));
+            }
+        }
+
+        @Override
+        public void disable() {
+            if (interceptors.remove(type) == null) {
+                throw new MockitoException(
+                        join(
+                                "Could not deregister "
+                                        + type.getName()
+                                        + " as a static mock since it is not currently registered",
+                                "",
+                                "To register a static mock, use Mockito.mockStatic("
+                                        + type.getSimpleName()
+                                        + ".class)"));
+            }
+        }
+    }
+
+    private class InlineConstructionMockControl<T> implements ConstructionMockControl<T> {
+
+        private final Class<T> type;
+
+        private final Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory;
+        private final Function<MockedConstruction.Context, MockHandler<T>> handlerFactory;
+
+        private final MockedConstruction.MockInitializer<T> mockInitializer;
+
+        private final Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors;
+
+        private final List<Object> all = new ArrayList<>();
+        private int count;
+
+        private InlineConstructionMockControl(
+                Class<T> type,
+                Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
+                Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
+                MockedConstruction.MockInitializer<T> mockInitializer,
+                Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors) {
+            this.type = type;
+            this.settingsFactory = settingsFactory;
+            this.handlerFactory = handlerFactory;
+            this.mockInitializer = mockInitializer;
+            this.interceptors = interceptors;
+        }
+
+        @Override
+        public Class<T> getType() {
+            return type;
+        }
+
+        @Override
+        public void enable() {
+            if (interceptors.putIfAbsent(
+                            type,
+                            (object, context) -> {
+                                ((InlineConstructionMockContext) context).count = ++count;
+                                MockMethodInterceptor interceptor =
+                                        new MockMethodInterceptor(
+                                                handlerFactory.apply(context),
+                                                settingsFactory.apply(context));
+                                mocks.put(object, interceptor);
+                                try {
+                                    @SuppressWarnings("unchecked")
+                                    T cast = (T) object;
+                                    mockInitializer.prepare(cast, context);
+                                } catch (Throwable t) {
+                                    mocks.remove(object); // TODO: filter stack trace?
+                                    throw new MockitoException(
+                                            "Could not initialize mocked construction", t);
+                                }
+                                all.add(object);
+                            })
+                    != null) {
+                throw new MockitoException(
+                        join(
+                                "For "
+                                        + type.getName()
+                                        + ", static mocking is already registered in the current thread",
+                                "",
+                                "To create a new mock, the existing static mock registration must be deregistered"));
+            }
+        }
+
+        @Override
+        public void disable() {
+            if (interceptors.remove(type) == null) {
+                throw new MockitoException(
+                        join(
+                                "Could not deregister "
+                                        + type.getName()
+                                        + " as a static mock since it is not currently registered",
+                                "",
+                                "To register a static mock, use Mockito.mockStatic("
+                                        + type.getSimpleName()
+                                        + ".class)"));
+            }
+            all.clear();
+        }
+
+        @Override
+        @SuppressWarnings("unchecked")
+        public List<T> getMocks() {
+            return (List<T>) all;
+        }
+    }
+
+    private static class InlineConstructionMockContext implements MockedConstruction.Context {
+
+        private static final Map<String, Class<?>> PRIMITIVES = new HashMap<>();
+
+        static {
+            PRIMITIVES.put(boolean.class.getName(), boolean.class);
+            PRIMITIVES.put(byte.class.getName(), byte.class);
+            PRIMITIVES.put(short.class.getName(), short.class);
+            PRIMITIVES.put(char.class.getName(), char.class);
+            PRIMITIVES.put(int.class.getName(), int.class);
+            PRIMITIVES.put(long.class.getName(), long.class);
+            PRIMITIVES.put(float.class.getName(), float.class);
+            PRIMITIVES.put(double.class.getName(), double.class);
+        }
+
+        private int count;
+
+        private final Object[] arguments;
+        private final Class<?> type;
+        private final String[] parameterTypeNames;
+
+        private InlineConstructionMockContext(
+                Object[] arguments, Class<?> type, String[] parameterTypeNames) {
+            this.arguments = arguments;
+            this.type = type;
+            this.parameterTypeNames = parameterTypeNames;
+        }
+
+        @Override
+        public int getCount() {
+            if (count == 0) {
+                throw new MockitoConfigurationException(
+                        "mocked construction context is not initialized");
+            }
+            return count;
+        }
+
+        @Override
+        public Constructor<?> constructor() {
+            Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length];
+            int index = 0;
+            for (String parameterTypeName : parameterTypeNames) {
+                if (PRIMITIVES.containsKey(parameterTypeName)) {
+                    parameterTypes[index++] = PRIMITIVES.get(parameterTypeName);
+                } else {
+                    try {
+                        parameterTypes[index++] =
+                                Class.forName(parameterTypeName, false, type.getClassLoader());
+                    } catch (ClassNotFoundException e) {
+                        throw new MockitoException(
+                                "Could not find parameter of type " + parameterTypeName, e);
+                    }
+                }
+            }
+            try {
+                return type.getDeclaredConstructor(parameterTypes);
+            } catch (NoSuchMethodException e) {
+                throw new MockitoException(
+                        join(
+                                "Could not resolve constructor of type",
+                                "",
+                                type.getName(),
+                                "",
+                                "with arguments of types",
+                                Arrays.toString(parameterTypes)),
+                        e);
+            }
+        }
+
+        @Override
+        public List<?> arguments() {
+            return Collections.unmodifiableList(Arrays.asList(arguments));
+        }
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java
deleted file mode 100644
index 553a02e24..000000000
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMaker.java
+++ /dev/null
@@ -1,880 +0,0 @@
-/*
- * Copyright (c) 2016 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.bytebuddy;
-
-import net.bytebuddy.agent.ByteBuddyAgent;
-import org.mockito.Incubating;
-import org.mockito.MockedConstruction;
-import org.mockito.creation.instance.InstantiationException;
-import org.mockito.creation.instance.Instantiator;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.exceptions.base.MockitoInitializationException;
-import org.mockito.exceptions.misusing.MockitoConfigurationException;
-import org.mockito.internal.SuppressSignatureCheck;
-import org.mockito.internal.configuration.plugins.Plugins;
-import org.mockito.internal.creation.instance.ConstructorInstantiator;
-import org.mockito.internal.util.Platform;
-import org.mockito.internal.util.concurrent.DetachedThreadLocal;
-import org.mockito.internal.util.concurrent.WeakConcurrentMap;
-import org.mockito.invocation.MockHandler;
-import org.mockito.mock.MockCreationSettings;
-import org.mockito.plugins.InlineMockMaker;
-import org.mockito.plugins.MemberAccessor;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.instrument.Instrumentation;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Modifier;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.function.BiConsumer;
-import java.util.function.Function;
-import java.util.function.Predicate;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-import java.util.jar.JarOutputStream;
-
-import static org.mockito.internal.creation.bytebuddy.InlineBytecodeGenerator.EXCLUDES;
-import static org.mockito.internal.util.StringUtil.join;
-
-/**
- * Agent and subclass based mock maker.
- * <p>
- * This mock maker which uses a combination of the Java instrumentation API and sub-classing rather than creating
- * a new sub-class to create a mock. This way, it becomes possible to mock final types and methods. This mock
- * maker <strong>must to be activated explicitly</strong> for supporting mocking final types and methods:
- * <p>
- * <p>
- * This mock maker can be activated by creating the file <code>/mockito-extensions/org.mockito.plugins.MockMaker</code>
- * containing the text <code>mock-maker-inline</code> or <code>org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker</code>.
- * <p>
- * <p>
- * This mock maker will make a best effort to avoid subclass creation when creating a mock. Otherwise it will use the
- * <code>org.mockito.internal.creation.bytebuddy.SubclassByteBuddyMockMaker</code> to create the mock class. That means
- * that the following condition is true
- * <p>
- * <pre class="code"><code class="java">
- * class Foo { }
- * assert mock(Foo.class).getClass() == Foo.class;
- * </pre></code>
- * <p>
- * unless any of the following conditions is met, in such case the mock maker <em>fall backs</em> to the
- * the creation of a subclass.
- * <p>
- * <ul>
- * <li>the type to mock is an abstract class.</li>
- * <li>the mock is set to require additional interfaces.</li>
- * <li>the mock is <a href="#20">explicitly set to support serialization</a>.</li>
- * </ul>
- * <p>
- * <p>
- * Some type of the JDK cannot be mocked, this includes <code>Class</code>, <code>String</code>, and wrapper types.
- * <p>
- * <p>
- * Nevertheless, final methods of such types are mocked when using the inlining mock maker. Mocking final types and enums
- * does however remain impossible when explicitly requiring serialization support or when adding ancillary interfaces.
- * <p>
- * <p>
- * Important behavioral changes when using inline-mocks:
- * <ul>
- * <li>Mockito is capable of mocking package-private methods even if they are defined in different packages than
- * the mocked type. Mockito voluntarily never mocks package-visible methods within <code>java.*</code> packages.</li>
- * <li>Additionally to final types, Mockito can now mock types that are not visible for extension; such types
- * include private types in a protected package.</li>
- * <li>Mockito can no longer mock <code>native</code> methods. Inline mocks require byte code manipulation of a
- * method where native methods do not offer any byte code to manipulate.</li>
- * <li>Mockito cannot longer strip <code>synchronized</code> modifiers from mocked instances.</li>
- * </ul>
- * <p>
- * <p>
- * Note that inline mocks require a Java agent to be attached. Mockito will attempt an attachment of a Java agent upon
- * loading the mock maker for creating inline mocks. Such runtime attachment is only possible when using a JVM that
- * is part of a JDK or when using a Java 9 VM. When running on a non-JDK VM prior to Java 9, it is however possible to
- * manually add the <a href="https://bytebuddy.net">Byte Buddy Java agent jar</a> using the <code>-javaagent</code>
- * parameter upon starting the JVM. Furthermore, the inlining mock maker requires the VM to support class retransformation
- * (also known as HotSwap). All major VM distributions such as HotSpot (OpenJDK), J9 (IBM/Websphere) or Zing (Azul)
- * support this feature.
- */
-@Incubating
-@SuppressSignatureCheck
-class InlineDelegateByteBuddyMockMaker
-        implements ClassCreatingMockMaker, InlineMockMaker, Instantiator {
-
-    private static final Instrumentation INSTRUMENTATION;
-
-    private static final Throwable INITIALIZATION_ERROR;
-
-    static {
-        Instrumentation instrumentation;
-        Throwable initializationError = null;
-        try {
-            try {
-                instrumentation = ByteBuddyAgent.install();
-                if (!instrumentation.isRetransformClassesSupported()) {
-                    throw new IllegalStateException(
-                            join(
-                                    "Byte Buddy requires retransformation for creating inline mocks. This feature is unavailable on the current VM.",
-                                    "",
-                                    "You cannot use this mock maker on this VM"));
-                }
-                File boot = File.createTempFile("mockitoboot", ".jar");
-                boot.deleteOnExit();
-                JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(boot));
-                try {
-                    String source =
-                            "org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher";
-                    InputStream inputStream =
-                            InlineDelegateByteBuddyMockMaker.class
-                                    .getClassLoader()
-                                    .getResourceAsStream(source + ".raw");
-                    if (inputStream == null) {
-                        throw new IllegalStateException(
-                                join(
-                                        "The MockMethodDispatcher class file is not locatable: "
-                                                + source
-                                                + ".raw",
-                                        "",
-                                        "The class loader responsible for looking up the resource: "
-                                                + InlineDelegateByteBuddyMockMaker.class
-                                                        .getClassLoader()));
-                    }
-                    outputStream.putNextEntry(new JarEntry(source + ".class"));
-                    try {
-                        int length;
-                        byte[] buffer = new byte[1024];
-                        while ((length = inputStream.read(buffer)) != -1) {
-                            outputStream.write(buffer, 0, length);
-                        }
-                    } finally {
-                        inputStream.close();
-                    }
-                    outputStream.closeEntry();
-                } finally {
-                    outputStream.close();
-                }
-                try (JarFile jarfile = new JarFile(boot)) {
-                    instrumentation.appendToBootstrapClassLoaderSearch(jarfile);
-                }
-                try {
-                    Class.forName(
-                            "org.mockito.internal.creation.bytebuddy.inject.MockMethodDispatcher",
-                            false,
-                            null);
-                } catch (ClassNotFoundException cnfe) {
-                    throw new IllegalStateException(
-                            join(
-                                    "Mockito failed to inject the MockMethodDispatcher class into the bootstrap class loader",
-                                    "",
-                                    "It seems like your current VM does not support the instrumentation API correctly."),
-                            cnfe);
-                }
-            } catch (IOException ioe) {
-                throw new IllegalStateException(
-                        join(
-                                "Mockito could not self-attach a Java agent to the current VM. This feature is required for inline mocking.",
-                                "This error occured due to an I/O error during the creation of this agent: "
-                                        + ioe,
-                                "",
-                                "Potentially, the current VM does not support the instrumentation API correctly"),
-                        ioe);
-            }
-        } catch (Throwable throwable) {
-            instrumentation = null;
-            initializationError = throwable;
-        }
-        INSTRUMENTATION = instrumentation;
-        INITIALIZATION_ERROR = initializationError;
-    }
-
-    private final BytecodeGenerator bytecodeGenerator;
-
-    private final WeakConcurrentMap<Object, MockMethodInterceptor> mocks =
-            new WeakConcurrentMap.WithInlinedExpunction<Object, MockMethodInterceptor>();
-
-    private final DetachedThreadLocal<Map<Class<?>, MockMethodInterceptor>> mockedStatics =
-            new DetachedThreadLocal<>(DetachedThreadLocal.Cleaner.INLINE);
-
-    private final DetachedThreadLocal<Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>>>
-            mockedConstruction = new DetachedThreadLocal<>(DetachedThreadLocal.Cleaner.INLINE);
-
-    private final ThreadLocal<Boolean> mockitoConstruction = ThreadLocal.withInitial(() -> false);
-
-    private final ThreadLocal<Object> currentSpied = new ThreadLocal<>();
-
-    InlineDelegateByteBuddyMockMaker() {
-        if (INITIALIZATION_ERROR != null) {
-            String detail;
-            if (System.getProperty("java.specification.vendor", "")
-                    .toLowerCase()
-                    .contains("android")) {
-                detail =
-                        "It appears as if you are trying to run this mock maker on Android which does not support the instrumentation API.";
-            } else {
-                try {
-                    if (INITIALIZATION_ERROR instanceof NoClassDefFoundError
-                            && INITIALIZATION_ERROR.getMessage() != null
-                            && INITIALIZATION_ERROR
-                                    .getMessage()
-                                    .startsWith("net/bytebuddy/agent/")) {
-                        detail =
-                                join(
-                                        "It seems like you are running Mockito with an incomplete or inconsistent class path. Byte Buddy Agent could not be loaded.",
-                                        "",
-                                        "Byte Buddy Agent is available on Maven Central as 'net.bytebuddy:byte-buddy-agent' with the module name 'net.bytebuddy.agent'.",
-                                        "Normally, your IDE or build tool (such as Maven or Gradle) should take care of your class path completion but ");
-                    } else if (Class.forName("javax.tools.ToolProvider")
-                                    .getMethod("getSystemJavaCompiler")
-                                    .invoke(null)
-                            == null) {
-                        detail =
-                                "It appears as if you are running on a JRE. Either install a JDK or add JNA to the class path.";
-                    } else {
-                        detail =
-                                "It appears as if your JDK does not supply a working agent attachment mechanism.";
-                    }
-                } catch (Throwable ignored) {
-                    detail =
-                            "It appears as if you are running an incomplete JVM installation that might not support all tooling APIs";
-                }
-            }
-            throw new MockitoInitializationException(
-                    join(
-                            "Could not initialize inline Byte Buddy mock maker.",
-                            "",
-                            detail,
-                            Platform.describe()),
-                    INITIALIZATION_ERROR);
-        }
-
-        ThreadLocal<Class<?>> currentConstruction = new ThreadLocal<>();
-        ThreadLocal<Boolean> isSuspended = ThreadLocal.withInitial(() -> false);
-        Predicate<Class<?>> isMockConstruction =
-                type -> {
-                    if (isSuspended.get()) {
-                        return false;
-                    } else if (mockitoConstruction.get() || currentConstruction.get() != null) {
-                        return true;
-                    }
-                    Map<Class<?>, ?> interceptors = mockedConstruction.get();
-                    if (interceptors != null && interceptors.containsKey(type)) {
-                        currentConstruction.set(type);
-                        return true;
-                    } else {
-                        return false;
-                    }
-                };
-        ConstructionCallback onConstruction =
-                (type, object, arguments, parameterTypeNames) -> {
-                    if (mockitoConstruction.get()) {
-                        Object spy = currentSpied.get();
-                        if (spy == null) {
-                            return null;
-                        } else if (type.isInstance(spy)) {
-                            return spy;
-                        } else {
-                            isSuspended.set(true);
-                            try {
-                                // Unexpected construction of non-spied object
-                                throw new MockitoException(
-                                        "Unexpected spy for "
-                                                + type.getName()
-                                                + " on instance of "
-                                                + object.getClass().getName(),
-                                        object instanceof Throwable ? (Throwable) object : null);
-                            } finally {
-                                isSuspended.set(false);
-                            }
-                        }
-                    } else if (currentConstruction.get() != type) {
-                        return null;
-                    }
-                    currentConstruction.remove();
-                    isSuspended.set(true);
-                    try {
-                        Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors =
-                                mockedConstruction.get();
-                        if (interceptors != null) {
-                            BiConsumer<Object, MockedConstruction.Context> interceptor =
-                                    interceptors.get(type);
-                            if (interceptor != null) {
-                                interceptor.accept(
-                                        object,
-                                        new InlineConstructionMockContext(
-                                                arguments, object.getClass(), parameterTypeNames));
-                            }
-                        }
-                    } finally {
-                        isSuspended.set(false);
-                    }
-                    return null;
-                };
-
-        bytecodeGenerator =
-                new TypeCachingBytecodeGenerator(
-                        new InlineBytecodeGenerator(
-                                INSTRUMENTATION,
-                                mocks,
-                                mockedStatics,
-                                isMockConstruction,
-                                onConstruction),
-                        true);
-    }
-
-    @Override
-    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
-        return doCreateMock(settings, handler, false);
-    }
-
-    @Override
-    public <T> Optional<T> createSpy(
-            MockCreationSettings<T> settings, MockHandler handler, T object) {
-        if (object == null) {
-            throw new MockitoConfigurationException("Spy instance must not be null");
-        }
-        currentSpied.set(object);
-        try {
-            return Optional.ofNullable(doCreateMock(settings, handler, true));
-        } finally {
-            currentSpied.remove();
-        }
-    }
-
-    private <T> T doCreateMock(
-            MockCreationSettings<T> settings,
-            MockHandler handler,
-            boolean nullOnNonInlineConstruction) {
-        Class<? extends T> type = createMockType(settings);
-
-        try {
-            T instance;
-            if (settings.isUsingConstructor()) {
-                instance =
-                        new ConstructorInstantiator(
-                                        settings.getOuterClassInstance() != null,
-                                        settings.getConstructorArgs())
-                                .newInstance(type);
-            } else {
-                try {
-                    // We attempt to use the "native" mock maker first that avoids
-                    // Objenesis and Unsafe
-                    instance = newInstance(type);
-                } catch (InstantiationException ignored) {
-                    if (nullOnNonInlineConstruction) {
-                        return null;
-                    }
-                    Instantiator instantiator =
-                            Plugins.getInstantiatorProvider().getInstantiator(settings);
-                    instance = instantiator.newInstance(type);
-                }
-            }
-            MockMethodInterceptor mockMethodInterceptor =
-                    new MockMethodInterceptor(handler, settings);
-            mocks.put(instance, mockMethodInterceptor);
-            if (instance instanceof MockAccess) {
-                ((MockAccess) instance).setMockitoInterceptor(mockMethodInterceptor);
-            }
-            return instance;
-        } catch (InstantiationException e) {
-            throw new MockitoException(
-                    "Unable to create mock instance of type '" + type.getSimpleName() + "'", e);
-        }
-    }
-
-    @Override
-    public <T> Class<? extends T> createMockType(MockCreationSettings<T> settings) {
-        try {
-            return bytecodeGenerator.mockClass(
-                    MockFeatures.withMockFeatures(
-                            settings.getTypeToMock(),
-                            settings.getExtraInterfaces(),
-                            settings.getSerializableMode(),
-                            settings.isStripAnnotations()));
-        } catch (Exception bytecodeGenerationFailed) {
-            throw prettifyFailure(settings, bytecodeGenerationFailed);
-        }
-    }
-
-    private <T> RuntimeException prettifyFailure(
-            MockCreationSettings<T> mockFeatures, Exception generationFailed) {
-        if (mockFeatures.getTypeToMock().isArray()) {
-            throw new MockitoException(
-                    join("Arrays cannot be mocked: " + mockFeatures.getTypeToMock() + ".", ""),
-                    generationFailed);
-        }
-        if (Modifier.isFinal(mockFeatures.getTypeToMock().getModifiers())) {
-            throw new MockitoException(
-                    join(
-                            "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
-                            "Can not mock final classes with the following settings :",
-                            " - explicit serialization (e.g. withSettings().serializable())",
-                            " - extra interfaces (e.g. withSettings().extraInterfaces(...))",
-                            "",
-                            "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
-                            "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
-                            "",
-                            "Underlying exception : " + generationFailed),
-                    generationFailed);
-        }
-        if (Modifier.isPrivate(mockFeatures.getTypeToMock().getModifiers())) {
-            throw new MockitoException(
-                    join(
-                            "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
-                            "Most likely it is a private class that is not visible by Mockito",
-                            "",
-                            "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
-                            "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
-                            ""),
-                    generationFailed);
-        }
-        throw new MockitoException(
-                join(
-                        "Mockito cannot mock this class: " + mockFeatures.getTypeToMock() + ".",
-                        "",
-                        "If you're not sure why you're getting this error, please report to the mailing list.",
-                        "",
-                        Platform.warnForVM(
-                                "IBM J9 VM",
-                                "Early IBM virtual machine are known to have issues with Mockito, please upgrade to an up-to-date version.\n",
-                                "Hotspot",
-                                Platform.isJava8BelowUpdate45()
-                                        ? "Java 8 early builds have bugs that were addressed in Java 1.8.0_45, please update your JDK!\n"
-                                        : ""),
-                        Platform.describe(),
-                        "",
-                        "You are seeing this disclaimer because Mockito is configured to create inlined mocks.",
-                        "You can learn about inline mocks and their limitations under item #39 of the Mockito class javadoc.",
-                        "",
-                        "Underlying exception : " + generationFailed),
-                generationFailed);
-    }
-
-    @Override
-    public MockHandler getHandler(Object mock) {
-        MockMethodInterceptor interceptor;
-        if (mock instanceof Class<?>) {
-            Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
-            interceptor = interceptors != null ? interceptors.get(mock) : null;
-        } else {
-            interceptor = mocks.get(mock);
-        }
-        if (interceptor == null) {
-            return null;
-        } else {
-            return interceptor.handler;
-        }
-    }
-
-    @Override
-    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {
-        MockMethodInterceptor mockMethodInterceptor =
-                new MockMethodInterceptor(newHandler, settings);
-        if (mock instanceof Class<?>) {
-            Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
-            if (interceptors == null || !interceptors.containsKey(mock)) {
-                throw new MockitoException(
-                        "Cannot reset "
-                                + mock
-                                + " which is not currently registered as a static mock");
-            }
-            interceptors.put((Class<?>) mock, mockMethodInterceptor);
-        } else {
-            if (!mocks.containsKey(mock)) {
-                throw new MockitoException(
-                        "Cannot reset " + mock + " which is not currently registered as a mock");
-            }
-            mocks.put(mock, mockMethodInterceptor);
-            if (mock instanceof MockAccess) {
-                ((MockAccess) mock).setMockitoInterceptor(mockMethodInterceptor);
-            }
-        }
-    }
-
-    @Override
-    public void clearAllCaches() {
-        clearAllMocks();
-        bytecodeGenerator.clearAllCaches();
-    }
-
-    @Override
-    public void clearMock(Object mock) {
-        if (mock instanceof Class<?>) {
-            for (Map<Class<?>, ?> entry : mockedStatics.getBackingMap().target.values()) {
-                entry.remove(mock);
-            }
-        } else {
-            mocks.remove(mock);
-        }
-    }
-
-    @Override
-    public void clearAllMocks() {
-        mockedStatics.getBackingMap().clear();
-        mocks.clear();
-    }
-
-    @Override
-    public TypeMockability isTypeMockable(final Class<?> type) {
-        return new TypeMockability() {
-            @Override
-            public boolean mockable() {
-                return INSTRUMENTATION.isModifiableClass(type) && !EXCLUDES.contains(type);
-            }
-
-            @Override
-            public String nonMockableReason() {
-                if (mockable()) {
-                    return "";
-                }
-                if (type.isPrimitive()) {
-                    return "primitive type";
-                }
-                if (EXCLUDES.contains(type)) {
-                    return "Cannot mock wrapper types, String.class or Class.class";
-                }
-                return "VM does not support modification of given type";
-            }
-        };
-    }
-
-    @Override
-    public <T> StaticMockControl<T> createStaticMock(
-            Class<T> type, MockCreationSettings<T> settings, MockHandler handler) {
-        if (type == ConcurrentHashMap.class) {
-            throw new MockitoException(
-                    "It is not possible to mock static methods of ConcurrentHashMap "
-                            + "to avoid infinitive loops within Mockito's implementation of static mock handling");
-        } else if (type == Thread.class
-                || type == System.class
-                || type == Arrays.class
-                || ClassLoader.class.isAssignableFrom(type)) {
-            throw new MockitoException(
-                    "It is not possible to mock static methods of "
-                            + type.getName()
-                            + " to avoid interfering with class loading what leads to infinite loops");
-        }
-
-        bytecodeGenerator.mockClassStatic(type);
-
-        Map<Class<?>, MockMethodInterceptor> interceptors = mockedStatics.get();
-        if (interceptors == null) {
-            interceptors = new WeakHashMap<>();
-            mockedStatics.set(interceptors);
-        }
-
-        return new InlineStaticMockControl<>(type, interceptors, settings, handler);
-    }
-
-    @Override
-    public <T> ConstructionMockControl<T> createConstructionMock(
-            Class<T> type,
-            Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
-            Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
-            MockedConstruction.MockInitializer<T> mockInitializer) {
-        if (type == Object.class) {
-            throw new MockitoException(
-                    "It is not possible to mock construction of the Object class "
-                            + "to avoid inference with default object constructor chains");
-        } else if (type.isPrimitive() || Modifier.isAbstract(type.getModifiers())) {
-            throw new MockitoException(
-                    "It is not possible to construct primitive types or abstract types: "
-                            + type.getName());
-        }
-
-        bytecodeGenerator.mockClassConstruction(type);
-
-        Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors =
-                mockedConstruction.get();
-        if (interceptors == null) {
-            interceptors = new WeakHashMap<>();
-            mockedConstruction.set(interceptors);
-        }
-
-        return new InlineConstructionMockControl<>(
-                type, settingsFactory, handlerFactory, mockInitializer, interceptors);
-    }
-
-    @Override
-    @SuppressWarnings("unchecked")
-    public <T> T newInstance(Class<T> cls) throws InstantiationException {
-        Constructor<?>[] constructors = cls.getDeclaredConstructors();
-        if (constructors.length == 0) {
-            throw new InstantiationException(cls.getName() + " does not define a constructor");
-        }
-        Constructor<?> selected = constructors[0];
-        for (Constructor<?> constructor : constructors) {
-            if (Modifier.isPublic(constructor.getModifiers())) {
-                selected = constructor;
-                break;
-            }
-        }
-        Class<?>[] types = selected.getParameterTypes();
-        Object[] arguments = new Object[types.length];
-        int index = 0;
-        for (Class<?> type : types) {
-            arguments[index++] = makeStandardArgument(type);
-        }
-        MemberAccessor accessor = Plugins.getMemberAccessor();
-        try {
-            return (T)
-                    accessor.newInstance(
-                            selected,
-                            callback -> {
-                                mockitoConstruction.set(true);
-                                try {
-                                    return callback.newInstance();
-                                } finally {
-                                    mockitoConstruction.set(false);
-                                }
-                            },
-                            arguments);
-        } catch (Exception e) {
-            throw new InstantiationException("Could not instantiate " + cls.getName(), e);
-        }
-    }
-
-    private Object makeStandardArgument(Class<?> type) {
-        if (type == boolean.class) {
-            return false;
-        } else if (type == byte.class) {
-            return (byte) 0;
-        } else if (type == short.class) {
-            return (short) 0;
-        } else if (type == char.class) {
-            return (char) 0;
-        } else if (type == int.class) {
-            return 0;
-        } else if (type == long.class) {
-            return 0L;
-        } else if (type == float.class) {
-            return 0f;
-        } else if (type == double.class) {
-            return 0d;
-        } else {
-            return null;
-        }
-    }
-
-    private static class InlineStaticMockControl<T> implements StaticMockControl<T> {
-
-        private final Class<T> type;
-
-        private final Map<Class<?>, MockMethodInterceptor> interceptors;
-
-        private final MockCreationSettings<T> settings;
-
-        private final MockHandler handler;
-
-        private InlineStaticMockControl(
-                Class<T> type,
-                Map<Class<?>, MockMethodInterceptor> interceptors,
-                MockCreationSettings<T> settings,
-                MockHandler handler) {
-            this.type = type;
-            this.interceptors = interceptors;
-            this.settings = settings;
-            this.handler = handler;
-        }
-
-        @Override
-        public Class<T> getType() {
-            return type;
-        }
-
-        @Override
-        public void enable() {
-            if (interceptors.putIfAbsent(type, new MockMethodInterceptor(handler, settings))
-                    != null) {
-                throw new MockitoException(
-                        join(
-                                "For "
-                                        + type.getName()
-                                        + ", static mocking is already registered in the current thread",
-                                "",
-                                "To create a new mock, the existing static mock registration must be deregistered"));
-            }
-        }
-
-        @Override
-        public void disable() {
-            if (interceptors.remove(type) == null) {
-                throw new MockitoException(
-                        join(
-                                "Could not deregister "
-                                        + type.getName()
-                                        + " as a static mock since it is not currently registered",
-                                "",
-                                "To register a static mock, use Mockito.mockStatic("
-                                        + type.getSimpleName()
-                                        + ".class)"));
-            }
-        }
-    }
-
-    private class InlineConstructionMockControl<T> implements ConstructionMockControl<T> {
-
-        private final Class<T> type;
-
-        private final Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory;
-        private final Function<MockedConstruction.Context, MockHandler<T>> handlerFactory;
-
-        private final MockedConstruction.MockInitializer<T> mockInitializer;
-
-        private final Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors;
-
-        private final List<Object> all = new ArrayList<>();
-        private int count;
-
-        private InlineConstructionMockControl(
-                Class<T> type,
-                Function<MockedConstruction.Context, MockCreationSettings<T>> settingsFactory,
-                Function<MockedConstruction.Context, MockHandler<T>> handlerFactory,
-                MockedConstruction.MockInitializer<T> mockInitializer,
-                Map<Class<?>, BiConsumer<Object, MockedConstruction.Context>> interceptors) {
-            this.type = type;
-            this.settingsFactory = settingsFactory;
-            this.handlerFactory = handlerFactory;
-            this.mockInitializer = mockInitializer;
-            this.interceptors = interceptors;
-        }
-
-        @Override
-        public Class<T> getType() {
-            return type;
-        }
-
-        @Override
-        public void enable() {
-            if (interceptors.putIfAbsent(
-                            type,
-                            (object, context) -> {
-                                ((InlineConstructionMockContext) context).count = ++count;
-                                MockMethodInterceptor interceptor =
-                                        new MockMethodInterceptor(
-                                                handlerFactory.apply(context),
-                                                settingsFactory.apply(context));
-                                mocks.put(object, interceptor);
-                                try {
-                                    @SuppressWarnings("unchecked")
-                                    T cast = (T) object;
-                                    mockInitializer.prepare(cast, context);
-                                } catch (Throwable t) {
-                                    mocks.remove(object); // TODO: filter stack trace?
-                                    throw new MockitoException(
-                                            "Could not initialize mocked construction", t);
-                                }
-                                all.add(object);
-                            })
-                    != null) {
-                throw new MockitoException(
-                        join(
-                                "For "
-                                        + type.getName()
-                                        + ", static mocking is already registered in the current thread",
-                                "",
-                                "To create a new mock, the existing static mock registration must be deregistered"));
-            }
-        }
-
-        @Override
-        public void disable() {
-            if (interceptors.remove(type) == null) {
-                throw new MockitoException(
-                        join(
-                                "Could not deregister "
-                                        + type.getName()
-                                        + " as a static mock since it is not currently registered",
-                                "",
-                                "To register a static mock, use Mockito.mockStatic("
-                                        + type.getSimpleName()
-                                        + ".class)"));
-            }
-            all.clear();
-        }
-
-        @Override
-        @SuppressWarnings("unchecked")
-        public List<T> getMocks() {
-            return (List<T>) all;
-        }
-    }
-
-    private static class InlineConstructionMockContext implements MockedConstruction.Context {
-
-        private static final Map<String, Class<?>> PRIMITIVES = new HashMap<>();
-
-        static {
-            PRIMITIVES.put(boolean.class.getName(), boolean.class);
-            PRIMITIVES.put(byte.class.getName(), byte.class);
-            PRIMITIVES.put(short.class.getName(), short.class);
-            PRIMITIVES.put(char.class.getName(), char.class);
-            PRIMITIVES.put(int.class.getName(), int.class);
-            PRIMITIVES.put(long.class.getName(), long.class);
-            PRIMITIVES.put(float.class.getName(), float.class);
-            PRIMITIVES.put(double.class.getName(), double.class);
-        }
-
-        private int count;
-
-        private final Object[] arguments;
-        private final Class<?> type;
-        private final String[] parameterTypeNames;
-
-        private InlineConstructionMockContext(
-                Object[] arguments, Class<?> type, String[] parameterTypeNames) {
-            this.arguments = arguments;
-            this.type = type;
-            this.parameterTypeNames = parameterTypeNames;
-        }
-
-        @Override
-        public int getCount() {
-            if (count == 0) {
-                throw new MockitoConfigurationException(
-                        "mocked construction context is not initialized");
-            }
-            return count;
-        }
-
-        @Override
-        public Constructor<?> constructor() {
-            Class<?>[] parameterTypes = new Class<?>[parameterTypeNames.length];
-            int index = 0;
-            for (String parameterTypeName : parameterTypeNames) {
-                if (PRIMITIVES.containsKey(parameterTypeName)) {
-                    parameterTypes[index++] = PRIMITIVES.get(parameterTypeName);
-                } else {
-                    try {
-                        parameterTypes[index++] =
-                                Class.forName(parameterTypeName, false, type.getClassLoader());
-                    } catch (ClassNotFoundException e) {
-                        throw new MockitoException(
-                                "Could not find parameter of type " + parameterTypeName, e);
-                    }
-                }
-            }
-            try {
-                return type.getDeclaredConstructor(parameterTypes);
-            } catch (NoSuchMethodException e) {
-                throw new MockitoException(
-                        join(
-                                "Could not resolve constructor of type",
-                                "",
-                                type.getName(),
-                                "",
-                                "with arguments of types",
-                                Arrays.toString(parameterTypes)),
-                        e);
-            }
-        }
-
-        @Override
-        public List<?> arguments() {
-            return Collections.unmodifiableList(Arrays.asList(arguments));
-        }
-    }
-}
diff --git a/src/main/java/org/mockito/internal/exceptions/Reporter.java b/src/main/java/org/mockito/internal/exceptions/Reporter.java
index 4c0cb35ff..8c6ed9a8a 100644
--- a/src/main/java/org/mockito/internal/exceptions/Reporter.java
+++ b/src/main/java/org/mockito/internal/exceptions/Reporter.java
@@ -13,7 +13,6 @@ import java.lang.reflect.Method;
 import java.util.*;
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.mockito.exceptions.base.MockitoException;
-import org.mockito.exceptions.base.MockitoInitializationException;
 import org.mockito.exceptions.misusing.*;
 import org.mockito.exceptions.verification.MoreThanAllowedActualInvocations;
 import org.mockito.exceptions.verification.NeverWantedButInvoked;
@@ -1109,19 +1108,4 @@ public class Reporter {
                         "Previous MockitoSession was not concluded with 'finishMocking()'.",
                         "For examples of correct usage see javadoc for MockitoSession class."));
     }
-
-    public static void missingByteBuddyDependency(Throwable t) {
-        if (t instanceof NoClassDefFoundError
-                && t.getMessage() != null
-                && t.getMessage().startsWith("net/bytebuddy/")) {
-            throw new MockitoInitializationException(
-                    join(
-                            "It seems like you are running Mockito with an incomplete or inconsistent class path. Byte Buddy could not be loaded.",
-                            "",
-                            "Byte Buddy is available on Maven Central as 'net.bytebuddy:byte-buddy' with the module name 'net.bytebuddy'.",
-                            "For the inline mock maker, 'net.bytebuddy:byte-buddy-agent' with the module name 'net.bytebuddy.agent' is also required.",
-                            "Normally, your IDE or build tool (such as Maven or Gradle) should take care of your class path completion but "),
-                    t);
-        }
-    }
 }
diff --git a/src/main/java/org/mockito/internal/util/reflection/ModuleMemberAccessor.java b/src/main/java/org/mockito/internal/util/reflection/ModuleMemberAccessor.java
index 08e55a5db..1eb25c6b0 100644
--- a/src/main/java/org/mockito/internal/util/reflection/ModuleMemberAccessor.java
+++ b/src/main/java/org/mockito/internal/util/reflection/ModuleMemberAccessor.java
@@ -17,22 +17,10 @@ public class ModuleMemberAccessor implements MemberAccessor {
     private final MemberAccessor delegate;
 
     public ModuleMemberAccessor() {
-        MemberAccessor delegate;
-        try {
-            delegate = delegate();
-        } catch (Throwable ignored) {
-            // Fallback in case Byte Buddy is not used as a mock maker and not available on the
-            // class loader.
-            delegate = new ReflectionMemberAccessor();
-        }
-        this.delegate = delegate;
-    }
-
-    private static MemberAccessor delegate() {
         if (ClassFileVersion.ofThisVm().isAtLeast(ClassFileVersion.JAVA_V9)) {
-            return new InstrumentationMemberAccessor();
+            delegate = new InstrumentationMemberAccessor();
         } else {
-            return new ReflectionMemberAccessor();
+            delegate = new ReflectionMemberAccessor();
         }
     }
 
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMakerTest.java
index 1a9eebec8..f4891a762 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMakerTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMakerTest.java
@@ -7,6 +7,7 @@ package org.mockito.internal.creation.bytebuddy;
 import static org.mockito.Mockito.verify;
 
 import org.junit.Test;
+import org.mockito.InjectMocks;
 import org.mockito.Mock;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.handler.MockHandlerImpl;
@@ -14,12 +15,12 @@ import org.mockitoutil.TestBase;
 
 public class ByteBuddyMockMakerTest extends TestBase {
 
-    @Mock private SubclassByteBuddyMockMaker delegate;
+    @InjectMocks private ByteBuddyMockMaker mockMaker = new ByteBuddyMockMaker();
+
+    @Mock private ClassCreatingMockMaker delegate;
 
     @Test
     public void should_delegate_call() {
-        ByteBuddyMockMaker mockMaker = new ByteBuddyMockMaker(delegate);
-
         CreationSettings<Object> creationSettings = new CreationSettings<Object>();
         MockHandlerImpl<Object> handler = new MockHandlerImpl<Object>(creationSettings);
 
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
index 9069e50b8..ccd140a2d 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineByteBuddyMockMakerTest.java
@@ -4,45 +4,603 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
+import static net.bytebuddy.ClassFileVersion.JAVA_V11;
+import static net.bytebuddy.ClassFileVersion.JAVA_V8;
+import static net.bytebuddy.matcher.ElementMatchers.named;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assume.assumeTrue;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Observable;
+import java.util.Observer;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.regex.Pattern;
+
+import net.bytebuddy.ByteBuddy;
+import net.bytebuddy.ClassFileVersion;
+import net.bytebuddy.description.modifier.Visibility;
+import net.bytebuddy.description.type.TypeDescription;
+import net.bytebuddy.implementation.FixedValue;
+import net.bytebuddy.implementation.StubMethod;
+import net.bytebuddy.utility.JavaConstant;
 import org.junit.Test;
-import org.mockito.Mock;
+import org.mockito.Answers;
+import org.mockito.exceptions.base.MockitoException;
+import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.creation.settings.CreationSettings;
 import org.mockito.internal.handler.MockHandlerImpl;
-import org.mockitoutil.TestBase;
+import org.mockito.internal.stubbing.answers.Returns;
+import org.mockito.internal.util.collections.Sets;
+import org.mockito.mock.MockCreationSettings;
+import org.mockito.mock.SerializableMode;
+import org.mockito.plugins.MockMaker;
+
+public class InlineByteBuddyMockMakerTest
+        extends AbstractByteBuddyMockMakerTest<InlineByteBuddyMockMaker> {
 
-import static org.mockito.Mockito.verify;
+    public InlineByteBuddyMockMakerTest() {
+        super(new InlineByteBuddyMockMaker());
+    }
+
+    @Override
+    protected Class<?> mockTypeOf(Class<?> type) {
+        return type;
+    }
 
-public class InlineByteBuddyMockMakerTest extends TestBase {
+    @Test
+    public void should_create_mock_from_final_class() throws Exception {
+        MockCreationSettings<FinalClass> settings = settingsFor(FinalClass.class);
+        FinalClass proxy =
+                mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_final_spy() throws Exception {
+        MockCreationSettings<FinalSpy> settings = settingsFor(FinalSpy.class);
+        Optional<FinalSpy> proxy =
+                mockMaker.createSpy(
+                        settings,
+                        new MockHandlerImpl<>(settings),
+                        new FinalSpy("value", true, (byte) 1, (short) 1, (char) 1, 1, 1L, 1f, 1d));
+        assertThat(proxy)
+                .hasValueSatisfying(
+                        spy -> {
+                            assertThat(spy.aString).isEqualTo("value");
+                            assertThat(spy.aBoolean).isTrue();
+                            assertThat(spy.aByte).isEqualTo((byte) 1);
+                            assertThat(spy.aShort).isEqualTo((short) 1);
+                            assertThat(spy.aChar).isEqualTo((char) 1);
+                            assertThat(spy.anInt).isEqualTo(1);
+                            assertThat(spy.aLong).isEqualTo(1L);
+                            assertThat(spy.aFloat).isEqualTo(1f);
+                            assertThat(spy.aDouble).isEqualTo(1d);
+                        });
+    }
 
-    @Mock private InlineDelegateByteBuddyMockMaker delegate;
+    @Test
+    public void should_create_mock_from_non_constructable_class() throws Exception {
+        MockCreationSettings<NonConstructableClass> settings =
+                settingsFor(NonConstructableClass.class);
+        NonConstructableClass proxy =
+                mockMaker.createMock(
+                        settings, new MockHandlerImpl<NonConstructableClass>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_final_class_in_the_JDK() throws Exception {
+        MockCreationSettings<Pattern> settings = settingsFor(Pattern.class);
+        Pattern proxy = mockMaker.createMock(settings, new MockHandlerImpl<Pattern>(settings));
+        assertThat(proxy.pattern()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_abstract_class_with_final_method() throws Exception {
+        MockCreationSettings<FinalMethodAbstractType> settings =
+                settingsFor(FinalMethodAbstractType.class);
+        FinalMethodAbstractType proxy =
+                mockMaker.createMock(
+                        settings, new MockHandlerImpl<FinalMethodAbstractType>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+        assertThat(proxy.bar()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_final_class_with_interface_methods() throws Exception {
+        MockCreationSettings<FinalMethod> settings =
+                settingsFor(FinalMethod.class, SampleInterface.class);
+        FinalMethod proxy =
+                mockMaker.createMock(settings, new MockHandlerImpl<FinalMethod>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+        assertThat(((SampleInterface) proxy).bar()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_detect_non_overridden_generic_method_of_supertype() throws Exception {
+        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
+        GenericSubClass proxy =
+                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
+        assertThat(proxy.value()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_create_mock_from_hashmap() throws Exception {
+        MockCreationSettings<HashMap> settings = settingsFor(HashMap.class);
+        HashMap proxy = mockMaker.createMock(settings, new MockHandlerImpl<HashMap>(settings));
+        assertThat(proxy.get(null)).isEqualTo("bar");
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void should_throw_exception_redefining_unmodifiable_class() {
+        MockCreationSettings settings = settingsFor(int.class);
+        try {
+            mockMaker.createMock(settings, new MockHandlerImpl(settings));
+            fail("Expected a MockitoException");
+        } catch (MockitoException e) {
+            e.printStackTrace();
+            assertThat(e).hasMessageContaining("Could not modify all classes");
+        }
+    }
+
+    @Test
+    @SuppressWarnings("unchecked")
+    public void should_throw_exception_redefining_array() {
+        int[] array = new int[5];
+        MockCreationSettings<? extends int[]> settings = settingsFor(array.getClass());
+        try {
+            mockMaker.createMock(settings, new MockHandlerImpl(settings));
+            fail("Expected a MockitoException");
+        } catch (MockitoException e) {
+            assertThat(e).hasMessageContaining("Arrays cannot be mocked");
+        }
+    }
+
+    @Test
+    public void should_create_mock_from_enum() throws Exception {
+        MockCreationSettings<EnumClass> settings = settingsFor(EnumClass.class);
+        EnumClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<EnumClass>(settings));
+        assertThat(proxy.foo()).isEqualTo("bar");
+    }
+
+    @Test
+    public void should_fail_at_creating_a_mock_of_a_final_class_with_explicit_serialization()
+            throws Exception {
+        MockCreationSettings<FinalClass> settings =
+                new CreationSettings<FinalClass>()
+                        .setTypeToMock(FinalClass.class)
+                        .setSerializableMode(SerializableMode.BASIC);
+
+        try {
+            mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
+            fail("Expected a MockitoException");
+        } catch (MockitoException e) {
+            assertThat(e)
+                    .hasMessageContaining("Unsupported settings")
+                    .hasMessageContaining("serialization")
+                    .hasMessageContaining("extra interfaces");
+        }
+    }
 
     @Test
-    public void should_delegate_call() {
-        InlineByteBuddyMockMaker mockMaker = new InlineByteBuddyMockMaker(delegate);
+    public void should_fail_at_creating_a_mock_of_a_final_class_with_extra_interfaces()
+            throws Exception {
+        MockCreationSettings<FinalClass> settings =
+                new CreationSettings<FinalClass>()
+                        .setTypeToMock(FinalClass.class)
+                        .setExtraInterfaces(Sets.<Class<?>>newSet(List.class));
 
-        CreationSettings<Object> creationSettings = new CreationSettings<Object>();
-        MockHandlerImpl<Object> handler = new MockHandlerImpl<Object>(creationSettings);
+        try {
+            mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
+            fail("Expected a MockitoException");
+        } catch (MockitoException e) {
+            assertThat(e)
+                    .hasMessageContaining("Unsupported settings")
+                    .hasMessageContaining("serialization")
+                    .hasMessageContaining("extra interfaces");
+        }
+    }
+
+    @Test
+    public void should_mock_interface() {
+        MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
+        mockSettings.setTypeToMock(Set.class);
+        mockSettings.defaultAnswer(new Returns(10));
+        Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
+
+        assertThat(proxy.size()).isEqualTo(10);
+    }
+
+    @Test
+    public void should_mock_interface_to_string() {
+        MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
+        mockSettings.setTypeToMock(Set.class);
+        mockSettings.defaultAnswer(new Returns("foo"));
+        Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
+
+        assertThat(proxy.toString()).isEqualTo("foo");
+    }
+
+    /**
+     * @see <a href="https://github.com/mockito/mockito/issues/2154">https://github.com/mockito/mockito/issues/2154</a>
+     */
+    @Test
+    public void should_mock_class_to_string() {
+        MockSettingsImpl<Object> mockSettings = new MockSettingsImpl<Object>();
+        mockSettings.setTypeToMock(Object.class);
+        mockSettings.defaultAnswer(new Returns("foo"));
+        Object proxy =
+                mockMaker.createMock(mockSettings, new MockHandlerImpl<Object>(mockSettings));
+
+        assertThat(proxy.toString()).isEqualTo("foo");
+    }
+
+    @Test
+    public void should_leave_causing_stack() throws Exception {
+        MockSettingsImpl<ExceptionThrowingClass> settings = new MockSettingsImpl<>();
+        settings.setTypeToMock(ExceptionThrowingClass.class);
+        settings.defaultAnswer(Answers.CALLS_REAL_METHODS);
+
+        Optional<ExceptionThrowingClass> proxy =
+                mockMaker.createSpy(
+                        settings, new MockHandlerImpl<>(settings), new ExceptionThrowingClass());
+
+        StackTraceElement[] returnedStack = null;
+        try {
+            proxy.get().throwException();
+        } catch (IOException ex) {
+            returnedStack = ex.getStackTrace();
+        }
+
+        assertNotNull("Stack trace from mockito expected", returnedStack);
+
+        assertEquals(ExceptionThrowingClass.class.getName(), returnedStack[0].getClassName());
+        assertEquals("internalThrowException", returnedStack[0].getMethodName());
+    }
+
+    @Test
+    public void should_remove_recursive_self_call_from_stack_trace() throws Exception {
+        StackTraceElement[] stack =
+                new StackTraceElement[] {
+                    new StackTraceElement("foo", "", "", -1),
+                    new StackTraceElement(SampleInterface.class.getName(), "", "", -1),
+                    new StackTraceElement("qux", "", "", -1),
+                    new StackTraceElement("bar", "", "", -1),
+                    new StackTraceElement("baz", "", "", -1)
+                };
+
+        Throwable throwable = new Throwable();
+        throwable.setStackTrace(stack);
+        throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
+
+        assertThat(throwable.getStackTrace())
+                .isEqualTo(
+                        new StackTraceElement[] {
+                            new StackTraceElement("foo", "", "", -1),
+                            new StackTraceElement("bar", "", "", -1),
+                            new StackTraceElement("baz", "", "", -1)
+                        });
+    }
+
+    @Test
+    public void should_handle_missing_or_inconsistent_stack_trace() throws Exception {
+        Throwable throwable = new Throwable();
+        throwable.setStackTrace(new StackTraceElement[0]);
+        assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class))
+                .isSameAs(throwable);
+    }
+
+    @Test
+    public void should_provide_reason_for_wrapper_class() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
+        assertThat(mockable.nonMockableReason())
+                .isEqualTo("Cannot mock wrapper types, String.class or Class.class");
+    }
+
+    @Test
+    public void should_provide_reason_for_vm_unsupported() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(int[].class);
+        assertThat(mockable.nonMockableReason())
+                .isEqualTo("VM does not support modification of given type");
+    }
+
+    @Test
+    public void should_mock_method_of_package_private_class() throws Exception {
+        MockCreationSettings<NonPackagePrivateSubClass> settings =
+                settingsFor(NonPackagePrivateSubClass.class);
+        NonPackagePrivateSubClass proxy =
+                mockMaker.createMock(
+                        settings, new MockHandlerImpl<NonPackagePrivateSubClass>(settings));
+        assertThat(proxy.value()).isEqualTo("bar");
+    }
+
+    @Test
+    public void is_type_mockable_excludes_String() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(String.class);
+        assertThat(mockable.mockable()).isFalse();
+        assertThat(mockable.nonMockableReason())
+                .contains("Cannot mock wrapper types, String.class or Class.class");
+    }
 
-        mockMaker.createMockType(creationSettings);
-        mockMaker.createMock(creationSettings, handler);
-        mockMaker.createStaticMock(Object.class, creationSettings, handler);
-        mockMaker.createConstructionMock(Object.class, null, null, null);
-        mockMaker.getHandler(this);
-        mockMaker.isTypeMockable(Object.class);
-        mockMaker.resetMock(this, handler, creationSettings);
-        mockMaker.clearMock(this);
+    @Test
+    public void is_type_mockable_excludes_Class() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Class.class);
+        assertThat(mockable.mockable()).isFalse();
+        assertThat(mockable.nonMockableReason())
+                .contains("Cannot mock wrapper types, String.class or Class.class");
+    }
+
+    @Test
+    public void is_type_mockable_excludes_primitive_classes() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(int.class);
+        assertThat(mockable.mockable()).isFalse();
+        assertThat(mockable.nonMockableReason()).contains("primitive");
+    }
+
+    @Test
+    public void is_type_mockable_allows_anonymous() {
+        Observer anonymous =
+                new Observer() {
+                    @Override
+                    public void update(Observable o, Object arg) {}
+                };
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(anonymous.getClass());
+        assertThat(mockable.mockable()).isTrue();
+        assertThat(mockable.nonMockableReason()).contains("");
+    }
+
+    @Test
+    public void is_type_mockable_give_empty_reason_if_type_is_mockable() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(SomeClass.class);
+        assertThat(mockable.mockable()).isTrue();
+        assertThat(mockable.nonMockableReason()).isEqualTo("");
+    }
+
+    @Test
+    public void is_type_mockable_give_allow_final_mockable_from_JDK() {
+        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Pattern.class);
+        assertThat(mockable.mockable()).isTrue();
+        assertThat(mockable.nonMockableReason()).isEqualTo("");
+    }
+
+    @Test
+    public void test_parameters_retention() throws Exception {
+        assumeTrue(ClassFileVersion.ofThisVm().isAtLeast(JAVA_V8));
+
+        Class<?> typeWithParameters =
+                new ByteBuddy()
+                        .subclass(Object.class)
+                        .defineMethod("foo", void.class, Visibility.PUBLIC)
+                        .withParameter(String.class, "bar")
+                        .intercept(StubMethod.INSTANCE)
+                        .make()
+                        .load(null)
+                        .getLoaded();
+
+        MockCreationSettings<?> settings = settingsFor(typeWithParameters);
+        @SuppressWarnings("unchecked")
+        Object proxy = mockMaker.createMock(settings, new MockHandlerImpl(settings));
+
+        assertThat(proxy.getClass()).isEqualTo(typeWithParameters);
+        assertThat(
+                        new TypeDescription.ForLoadedType(typeWithParameters)
+                                .getDeclaredMethods()
+                                .filter(named("foo"))
+                                .getOnly()
+                                .getParameters()
+                                .getOnly()
+                                .getName())
+                .isEqualTo("bar");
+    }
+
+    @Test
+    public void test_constant_dynamic_compatibility() throws Exception {
+        assumeTrue(ClassFileVersion.ofThisVm().isAtLeast(JAVA_V11));
+
+        Class<?> typeWithCondy =
+                new ByteBuddy()
+                        .subclass(Callable.class)
+                        .method(named("call"))
+                        .intercept(FixedValue.value(JavaConstant.Dynamic.ofNullConstant()))
+                        .make()
+                        .load(null)
+                        .getLoaded();
+
+        MockCreationSettings<?> settings = settingsFor(typeWithCondy);
+        @SuppressWarnings("unchecked")
+        Object proxy = mockMaker.createMock(settings, new MockHandlerImpl(settings));
+
+        assertThat(proxy.getClass()).isEqualTo(typeWithCondy);
+    }
+
+    @Test
+    public void test_clear_mock_clears_handler() {
+        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
+        GenericSubClass proxy =
+                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
+        assertThat(mockMaker.getHandler(proxy)).isNotNull();
+
+        // when
+        mockMaker.clearMock(proxy);
+
+        // then
+        assertThat(mockMaker.getHandler(proxy)).isNull();
+    }
+
+    @Test
+    public void test_clear_all_mock_clears_handler() {
+        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
+        GenericSubClass proxy1 =
+                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
+        assertThat(mockMaker.getHandler(proxy1)).isNotNull();
+
+        settings = settingsFor(GenericSubClass.class);
+        GenericSubClass proxy2 =
+                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
+        assertThat(mockMaker.getHandler(proxy1)).isNotNull();
+
+        // when
         mockMaker.clearAllMocks();
-        mockMaker.clearAllCaches();
-
-        verify(delegate).createMock(creationSettings, handler);
-        verify(delegate).createStaticMock(Object.class, creationSettings, handler);
-        verify(delegate).createConstructionMock(Object.class, null, null, null);
-        verify(delegate).createMockType(creationSettings);
-        verify(delegate).getHandler(this);
-        verify(delegate).isTypeMockable(Object.class);
-        verify(delegate).resetMock(this, handler, creationSettings);
-        verify(delegate).clearMock(this);
-        verify(delegate).clearAllMocks();
-        verify(delegate).clearAllCaches();
+
+        // then
+        assertThat(mockMaker.getHandler(proxy1)).isNull();
+        assertThat(mockMaker.getHandler(proxy2)).isNull();
+    }
+
+    private static <T> MockCreationSettings<T> settingsFor(
+            Class<T> type, Class<?>... extraInterfaces) {
+        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
+        mockSettings.setTypeToMock(type);
+        mockSettings.defaultAnswer(new Returns("bar"));
+        if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
+        return mockSettings;
+    }
+
+    @Test
+    public void testMockDispatcherIsRelocated() throws Exception {
+        assertThat(
+                        InlineByteBuddyMockMaker.class
+                                .getClassLoader()
+                                .getResource(
+                                        "org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher.raw"))
+                .isNotNull();
+    }
+
+    private static final class FinalClass {
+
+        public String foo() {
+            return "foo";
+        }
+    }
+
+    private static final class FinalSpy {
+
+        private final String aString;
+        private final boolean aBoolean;
+        private final byte aByte;
+        private final short aShort;
+        private final char aChar;
+        private final int anInt;
+        private final long aLong;
+        private final float aFloat;
+        private final double aDouble;
+
+        private FinalSpy(
+                String aString,
+                boolean aBoolean,
+                byte aByte,
+                short aShort,
+                char aChar,
+                int anInt,
+                long aLong,
+                float aFloat,
+                double aDouble) {
+            this.aString = aString;
+            this.aBoolean = aBoolean;
+            this.aByte = aByte;
+            this.aShort = aShort;
+            this.aChar = aChar;
+            this.anInt = anInt;
+            this.aLong = aLong;
+            this.aFloat = aFloat;
+            this.aDouble = aDouble;
+        }
+    }
+
+    private static class NonConstructableClass {
+
+        private NonConstructableClass() {
+            throw new AssertionError();
+        }
+
+        public String foo() {
+            return "foo";
+        }
+    }
+
+    private enum EnumClass {
+        INSTANCE;
+
+        public String foo() {
+            return "foo";
+        }
+    }
+
+    private abstract static class FinalMethodAbstractType {
+
+        public final String foo() {
+            return "foo";
+        }
+
+        public abstract String bar();
+    }
+
+    private static class FinalMethod {
+
+        public final String foo() {
+            return "foo";
+        }
+    }
+
+    private interface SampleInterface {
+
+        String bar();
+    }
+
+    /*package-private*/ abstract class PackagePrivateSuperClass {
+
+        public abstract String indirect();
+
+        public String value() {
+            return indirect() + "qux";
+        }
+    }
+
+    public class NonPackagePrivateSubClass extends PackagePrivateSuperClass {
+
+        @Override
+        public String indirect() {
+            return "foo";
+        }
+    }
+
+    public static class GenericClass<T> {
+
+        public T value() {
+            return null;
+        }
+    }
+
+    public static class GenericSubClass extends GenericClass<String> {}
+
+    public static class ExceptionThrowingClass {
+        public IOException getException() {
+            try {
+                throwException();
+            } catch (IOException ex) {
+                return ex;
+            }
+            return null;
+        }
+
+        public void throwException() throws IOException {
+            internalThrowException(1);
+        }
+
+        void internalThrowException(int test) throws IOException {
+            // some lines of code, so the exception is not thrown in the first line of the method
+            int i = 0;
+            if (test != i) {
+                throw new IOException("fatal");
+            }
+        }
     }
 }
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java
deleted file mode 100644
index 161fdd5cc..000000000
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/InlineDelegateByteBuddyMockMakerTest.java
+++ /dev/null
@@ -1,606 +0,0 @@
-/*
- * Copyright (c) 2017 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.creation.bytebuddy;
-
-import static net.bytebuddy.ClassFileVersion.JAVA_V11;
-import static net.bytebuddy.ClassFileVersion.JAVA_V8;
-import static net.bytebuddy.matcher.ElementMatchers.named;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.fail;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assume.assumeTrue;
-
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Observable;
-import java.util.Observer;
-import java.util.Optional;
-import java.util.Set;
-import java.util.concurrent.Callable;
-import java.util.regex.Pattern;
-
-import net.bytebuddy.ByteBuddy;
-import net.bytebuddy.ClassFileVersion;
-import net.bytebuddy.description.modifier.Visibility;
-import net.bytebuddy.description.type.TypeDescription;
-import net.bytebuddy.implementation.FixedValue;
-import net.bytebuddy.implementation.StubMethod;
-import net.bytebuddy.utility.JavaConstant;
-import org.junit.Test;
-import org.mockito.Answers;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.creation.MockSettingsImpl;
-import org.mockito.internal.creation.settings.CreationSettings;
-import org.mockito.internal.handler.MockHandlerImpl;
-import org.mockito.internal.stubbing.answers.Returns;
-import org.mockito.internal.util.collections.Sets;
-import org.mockito.mock.MockCreationSettings;
-import org.mockito.mock.SerializableMode;
-import org.mockito.plugins.MockMaker;
-
-public class InlineDelegateByteBuddyMockMakerTest
-        extends AbstractByteBuddyMockMakerTest<InlineByteBuddyMockMaker> {
-
-    public InlineDelegateByteBuddyMockMakerTest() {
-        super(new InlineByteBuddyMockMaker());
-    }
-
-    @Override
-    protected Class<?> mockTypeOf(Class<?> type) {
-        return type;
-    }
-
-    @Test
-    public void should_create_mock_from_final_class() throws Exception {
-        MockCreationSettings<FinalClass> settings = settingsFor(FinalClass.class);
-        FinalClass proxy =
-                mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_create_mock_from_final_spy() throws Exception {
-        MockCreationSettings<FinalSpy> settings = settingsFor(FinalSpy.class);
-        Optional<FinalSpy> proxy =
-                mockMaker.createSpy(
-                        settings,
-                        new MockHandlerImpl<>(settings),
-                        new FinalSpy("value", true, (byte) 1, (short) 1, (char) 1, 1, 1L, 1f, 1d));
-        assertThat(proxy)
-                .hasValueSatisfying(
-                        spy -> {
-                            assertThat(spy.aString).isEqualTo("value");
-                            assertThat(spy.aBoolean).isTrue();
-                            assertThat(spy.aByte).isEqualTo((byte) 1);
-                            assertThat(spy.aShort).isEqualTo((short) 1);
-                            assertThat(spy.aChar).isEqualTo((char) 1);
-                            assertThat(spy.anInt).isEqualTo(1);
-                            assertThat(spy.aLong).isEqualTo(1L);
-                            assertThat(spy.aFloat).isEqualTo(1f);
-                            assertThat(spy.aDouble).isEqualTo(1d);
-                        });
-    }
-
-    @Test
-    public void should_create_mock_from_non_constructable_class() throws Exception {
-        MockCreationSettings<NonConstructableClass> settings =
-                settingsFor(NonConstructableClass.class);
-        NonConstructableClass proxy =
-                mockMaker.createMock(
-                        settings, new MockHandlerImpl<NonConstructableClass>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_create_mock_from_final_class_in_the_JDK() throws Exception {
-        MockCreationSettings<Pattern> settings = settingsFor(Pattern.class);
-        Pattern proxy = mockMaker.createMock(settings, new MockHandlerImpl<Pattern>(settings));
-        assertThat(proxy.pattern()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_create_mock_from_abstract_class_with_final_method() throws Exception {
-        MockCreationSettings<FinalMethodAbstractType> settings =
-                settingsFor(FinalMethodAbstractType.class);
-        FinalMethodAbstractType proxy =
-                mockMaker.createMock(
-                        settings, new MockHandlerImpl<FinalMethodAbstractType>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
-        assertThat(proxy.bar()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_create_mock_from_final_class_with_interface_methods() throws Exception {
-        MockCreationSettings<FinalMethod> settings =
-                settingsFor(FinalMethod.class, SampleInterface.class);
-        FinalMethod proxy =
-                mockMaker.createMock(settings, new MockHandlerImpl<FinalMethod>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
-        assertThat(((SampleInterface) proxy).bar()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_detect_non_overridden_generic_method_of_supertype() throws Exception {
-        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
-        GenericSubClass proxy =
-                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
-        assertThat(proxy.value()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_create_mock_from_hashmap() throws Exception {
-        MockCreationSettings<HashMap> settings = settingsFor(HashMap.class);
-        HashMap proxy = mockMaker.createMock(settings, new MockHandlerImpl<HashMap>(settings));
-        assertThat(proxy.get(null)).isEqualTo("bar");
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    public void should_throw_exception_redefining_unmodifiable_class() {
-        MockCreationSettings settings = settingsFor(int.class);
-        try {
-            mockMaker.createMock(settings, new MockHandlerImpl(settings));
-            fail("Expected a MockitoException");
-        } catch (MockitoException e) {
-            e.printStackTrace();
-            assertThat(e).hasMessageContaining("Could not modify all classes");
-        }
-    }
-
-    @Test
-    @SuppressWarnings("unchecked")
-    public void should_throw_exception_redefining_array() {
-        int[] array = new int[5];
-        MockCreationSettings<? extends int[]> settings = settingsFor(array.getClass());
-        try {
-            mockMaker.createMock(settings, new MockHandlerImpl(settings));
-            fail("Expected a MockitoException");
-        } catch (MockitoException e) {
-            assertThat(e).hasMessageContaining("Arrays cannot be mocked");
-        }
-    }
-
-    @Test
-    public void should_create_mock_from_enum() throws Exception {
-        MockCreationSettings<EnumClass> settings = settingsFor(EnumClass.class);
-        EnumClass proxy = mockMaker.createMock(settings, new MockHandlerImpl<EnumClass>(settings));
-        assertThat(proxy.foo()).isEqualTo("bar");
-    }
-
-    @Test
-    public void should_fail_at_creating_a_mock_of_a_final_class_with_explicit_serialization()
-            throws Exception {
-        MockCreationSettings<FinalClass> settings =
-                new CreationSettings<FinalClass>()
-                        .setTypeToMock(FinalClass.class)
-                        .setSerializableMode(SerializableMode.BASIC);
-
-        try {
-            mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
-            fail("Expected a MockitoException");
-        } catch (MockitoException e) {
-            assertThat(e)
-                    .hasMessageContaining("Unsupported settings")
-                    .hasMessageContaining("serialization")
-                    .hasMessageContaining("extra interfaces");
-        }
-    }
-
-    @Test
-    public void should_fail_at_creating_a_mock_of_a_final_class_with_extra_interfaces()
-            throws Exception {
-        MockCreationSettings<FinalClass> settings =
-                new CreationSettings<FinalClass>()
-                        .setTypeToMock(FinalClass.class)
-                        .setExtraInterfaces(Sets.<Class<?>>newSet(List.class));
-
-        try {
-            mockMaker.createMock(settings, new MockHandlerImpl<FinalClass>(settings));
-            fail("Expected a MockitoException");
-        } catch (MockitoException e) {
-            assertThat(e)
-                    .hasMessageContaining("Unsupported settings")
-                    .hasMessageContaining("serialization")
-                    .hasMessageContaining("extra interfaces");
-        }
-    }
-
-    @Test
-    public void should_mock_interface() {
-        MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
-        mockSettings.setTypeToMock(Set.class);
-        mockSettings.defaultAnswer(new Returns(10));
-        Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
-
-        assertThat(proxy.size()).isEqualTo(10);
-    }
-
-    @Test
-    public void should_mock_interface_to_string() {
-        MockSettingsImpl<Set> mockSettings = new MockSettingsImpl<Set>();
-        mockSettings.setTypeToMock(Set.class);
-        mockSettings.defaultAnswer(new Returns("foo"));
-        Set<?> proxy = mockMaker.createMock(mockSettings, new MockHandlerImpl<Set>(mockSettings));
-
-        assertThat(proxy.toString()).isEqualTo("foo");
-    }
-
-    /**
-     * @see <a href="https://github.com/mockito/mockito/issues/2154">https://github.com/mockito/mockito/issues/2154</a>
-     */
-    @Test
-    public void should_mock_class_to_string() {
-        MockSettingsImpl<Object> mockSettings = new MockSettingsImpl<Object>();
-        mockSettings.setTypeToMock(Object.class);
-        mockSettings.defaultAnswer(new Returns("foo"));
-        Object proxy =
-                mockMaker.createMock(mockSettings, new MockHandlerImpl<Object>(mockSettings));
-
-        assertThat(proxy.toString()).isEqualTo("foo");
-    }
-
-    @Test
-    public void should_leave_causing_stack() throws Exception {
-        MockSettingsImpl<ExceptionThrowingClass> settings = new MockSettingsImpl<>();
-        settings.setTypeToMock(ExceptionThrowingClass.class);
-        settings.defaultAnswer(Answers.CALLS_REAL_METHODS);
-
-        Optional<ExceptionThrowingClass> proxy =
-                mockMaker.createSpy(
-                        settings, new MockHandlerImpl<>(settings), new ExceptionThrowingClass());
-
-        StackTraceElement[] returnedStack = null;
-        try {
-            proxy.get().throwException();
-        } catch (IOException ex) {
-            returnedStack = ex.getStackTrace();
-        }
-
-        assertNotNull("Stack trace from mockito expected", returnedStack);
-
-        assertEquals(ExceptionThrowingClass.class.getName(), returnedStack[0].getClassName());
-        assertEquals("internalThrowException", returnedStack[0].getMethodName());
-    }
-
-    @Test
-    public void should_remove_recursive_self_call_from_stack_trace() throws Exception {
-        StackTraceElement[] stack =
-                new StackTraceElement[] {
-                    new StackTraceElement("foo", "", "", -1),
-                    new StackTraceElement(SampleInterface.class.getName(), "", "", -1),
-                    new StackTraceElement("qux", "", "", -1),
-                    new StackTraceElement("bar", "", "", -1),
-                    new StackTraceElement("baz", "", "", -1)
-                };
-
-        Throwable throwable = new Throwable();
-        throwable.setStackTrace(stack);
-        throwable = MockMethodAdvice.hideRecursiveCall(throwable, 2, SampleInterface.class);
-
-        assertThat(throwable.getStackTrace())
-                .isEqualTo(
-                        new StackTraceElement[] {
-                            new StackTraceElement("foo", "", "", -1),
-                            new StackTraceElement("bar", "", "", -1),
-                            new StackTraceElement("baz", "", "", -1)
-                        });
-    }
-
-    @Test
-    public void should_handle_missing_or_inconsistent_stack_trace() throws Exception {
-        Throwable throwable = new Throwable();
-        throwable.setStackTrace(new StackTraceElement[0]);
-        assertThat(MockMethodAdvice.hideRecursiveCall(throwable, 0, SampleInterface.class))
-                .isSameAs(throwable);
-    }
-
-    @Test
-    public void should_provide_reason_for_wrapper_class() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Integer.class);
-        assertThat(mockable.nonMockableReason())
-                .isEqualTo("Cannot mock wrapper types, String.class or Class.class");
-    }
-
-    @Test
-    public void should_provide_reason_for_vm_unsupported() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(int[].class);
-        assertThat(mockable.nonMockableReason())
-                .isEqualTo("VM does not support modification of given type");
-    }
-
-    @Test
-    public void should_mock_method_of_package_private_class() throws Exception {
-        MockCreationSettings<NonPackagePrivateSubClass> settings =
-                settingsFor(NonPackagePrivateSubClass.class);
-        NonPackagePrivateSubClass proxy =
-                mockMaker.createMock(
-                        settings, new MockHandlerImpl<NonPackagePrivateSubClass>(settings));
-        assertThat(proxy.value()).isEqualTo("bar");
-    }
-
-    @Test
-    public void is_type_mockable_excludes_String() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(String.class);
-        assertThat(mockable.mockable()).isFalse();
-        assertThat(mockable.nonMockableReason())
-                .contains("Cannot mock wrapper types, String.class or Class.class");
-    }
-
-    @Test
-    public void is_type_mockable_excludes_Class() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Class.class);
-        assertThat(mockable.mockable()).isFalse();
-        assertThat(mockable.nonMockableReason())
-                .contains("Cannot mock wrapper types, String.class or Class.class");
-    }
-
-    @Test
-    public void is_type_mockable_excludes_primitive_classes() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(int.class);
-        assertThat(mockable.mockable()).isFalse();
-        assertThat(mockable.nonMockableReason()).contains("primitive");
-    }
-
-    @Test
-    public void is_type_mockable_allows_anonymous() {
-        Observer anonymous =
-                new Observer() {
-                    @Override
-                    public void update(Observable o, Object arg) {}
-                };
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(anonymous.getClass());
-        assertThat(mockable.mockable()).isTrue();
-        assertThat(mockable.nonMockableReason()).contains("");
-    }
-
-    @Test
-    public void is_type_mockable_give_empty_reason_if_type_is_mockable() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(SomeClass.class);
-        assertThat(mockable.mockable()).isTrue();
-        assertThat(mockable.nonMockableReason()).isEqualTo("");
-    }
-
-    @Test
-    public void is_type_mockable_give_allow_final_mockable_from_JDK() {
-        MockMaker.TypeMockability mockable = mockMaker.isTypeMockable(Pattern.class);
-        assertThat(mockable.mockable()).isTrue();
-        assertThat(mockable.nonMockableReason()).isEqualTo("");
-    }
-
-    @Test
-    public void test_parameters_retention() throws Exception {
-        assumeTrue(ClassFileVersion.ofThisVm().isAtLeast(JAVA_V8));
-
-        Class<?> typeWithParameters =
-                new ByteBuddy()
-                        .subclass(Object.class)
-                        .defineMethod("foo", void.class, Visibility.PUBLIC)
-                        .withParameter(String.class, "bar")
-                        .intercept(StubMethod.INSTANCE)
-                        .make()
-                        .load(null)
-                        .getLoaded();
-
-        MockCreationSettings<?> settings = settingsFor(typeWithParameters);
-        @SuppressWarnings("unchecked")
-        Object proxy = mockMaker.createMock(settings, new MockHandlerImpl(settings));
-
-        assertThat(proxy.getClass()).isEqualTo(typeWithParameters);
-        assertThat(
-                        new TypeDescription.ForLoadedType(typeWithParameters)
-                                .getDeclaredMethods()
-                                .filter(named("foo"))
-                                .getOnly()
-                                .getParameters()
-                                .getOnly()
-                                .getName())
-                .isEqualTo("bar");
-    }
-
-    @Test
-    public void test_constant_dynamic_compatibility() throws Exception {
-        assumeTrue(ClassFileVersion.ofThisVm().isAtLeast(JAVA_V11));
-
-        Class<?> typeWithCondy =
-                new ByteBuddy()
-                        .subclass(Callable.class)
-                        .method(named("call"))
-                        .intercept(FixedValue.value(JavaConstant.Dynamic.ofNullConstant()))
-                        .make()
-                        .load(null)
-                        .getLoaded();
-
-        MockCreationSettings<?> settings = settingsFor(typeWithCondy);
-        @SuppressWarnings("unchecked")
-        Object proxy = mockMaker.createMock(settings, new MockHandlerImpl(settings));
-
-        assertThat(proxy.getClass()).isEqualTo(typeWithCondy);
-    }
-
-    @Test
-    public void test_clear_mock_clears_handler() {
-        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
-        GenericSubClass proxy =
-                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
-        assertThat(mockMaker.getHandler(proxy)).isNotNull();
-
-        // when
-        mockMaker.clearMock(proxy);
-
-        // then
-        assertThat(mockMaker.getHandler(proxy)).isNull();
-    }
-
-    @Test
-    public void test_clear_all_mock_clears_handler() {
-        MockCreationSettings<GenericSubClass> settings = settingsFor(GenericSubClass.class);
-        GenericSubClass proxy1 =
-                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
-        assertThat(mockMaker.getHandler(proxy1)).isNotNull();
-
-        settings = settingsFor(GenericSubClass.class);
-        GenericSubClass proxy2 =
-                mockMaker.createMock(settings, new MockHandlerImpl<GenericSubClass>(settings));
-        assertThat(mockMaker.getHandler(proxy1)).isNotNull();
-
-        // when
-        mockMaker.clearAllMocks();
-
-        // then
-        assertThat(mockMaker.getHandler(proxy1)).isNull();
-        assertThat(mockMaker.getHandler(proxy2)).isNull();
-    }
-
-    private static <T> MockCreationSettings<T> settingsFor(
-            Class<T> type, Class<?>... extraInterfaces) {
-        MockSettingsImpl<T> mockSettings = new MockSettingsImpl<T>();
-        mockSettings.setTypeToMock(type);
-        mockSettings.defaultAnswer(new Returns("bar"));
-        if (extraInterfaces.length > 0) mockSettings.extraInterfaces(extraInterfaces);
-        return mockSettings;
-    }
-
-    @Test
-    public void testMockDispatcherIsRelocated() throws Exception {
-        assertThat(
-                        InlineByteBuddyMockMaker.class
-                                .getClassLoader()
-                                .getResource(
-                                        "org/mockito/internal/creation/bytebuddy/inject/MockMethodDispatcher.raw"))
-                .isNotNull();
-    }
-
-    private static final class FinalClass {
-
-        public String foo() {
-            return "foo";
-        }
-    }
-
-    private static final class FinalSpy {
-
-        private final String aString;
-        private final boolean aBoolean;
-        private final byte aByte;
-        private final short aShort;
-        private final char aChar;
-        private final int anInt;
-        private final long aLong;
-        private final float aFloat;
-        private final double aDouble;
-
-        private FinalSpy(
-                String aString,
-                boolean aBoolean,
-                byte aByte,
-                short aShort,
-                char aChar,
-                int anInt,
-                long aLong,
-                float aFloat,
-                double aDouble) {
-            this.aString = aString;
-            this.aBoolean = aBoolean;
-            this.aByte = aByte;
-            this.aShort = aShort;
-            this.aChar = aChar;
-            this.anInt = anInt;
-            this.aLong = aLong;
-            this.aFloat = aFloat;
-            this.aDouble = aDouble;
-        }
-    }
-
-    private static class NonConstructableClass {
-
-        private NonConstructableClass() {
-            throw new AssertionError();
-        }
-
-        public String foo() {
-            return "foo";
-        }
-    }
-
-    private enum EnumClass {
-        INSTANCE;
-
-        public String foo() {
-            return "foo";
-        }
-    }
-
-    private abstract static class FinalMethodAbstractType {
-
-        public final String foo() {
-            return "foo";
-        }
-
-        public abstract String bar();
-    }
-
-    private static class FinalMethod {
-
-        public final String foo() {
-            return "foo";
-        }
-    }
-
-    private interface SampleInterface {
-
-        String bar();
-    }
-
-    /*package-private*/ abstract class PackagePrivateSuperClass {
-
-        public abstract String indirect();
-
-        public String value() {
-            return indirect() + "qux";
-        }
-    }
-
-    public class NonPackagePrivateSubClass extends PackagePrivateSuperClass {
-
-        @Override
-        public String indirect() {
-            return "foo";
-        }
-    }
-
-    public static class GenericClass<T> {
-
-        public T value() {
-            return null;
-        }
-    }
-
-    public static class GenericSubClass extends GenericClass<String> {}
-
-    public static class ExceptionThrowingClass {
-        public IOException getException() {
-            try {
-                throwException();
-            } catch (IOException ex) {
-                return ex;
-            }
-            return null;
-        }
-
-        public void throwException() throws IOException {
-            internalThrowException(1);
-        }
-
-        void internalThrowException(int test) throws IOException {
-            // some lines of code, so the exception is not thrown in the first line of the method
-            int i = 0;
-            if (test != i) {
-                throw new IOException("fatal");
-            }
-        }
-    }
-}
diff --git a/src/test/java/org/mockitointegration/NoJUnitDependenciesTest.java b/src/test/java/org/mockitointegration/NoJUnitDependenciesTest.java
index 7b156f0aa..9cd47da86 100644
--- a/src/test/java/org/mockitointegration/NoJUnitDependenciesTest.java
+++ b/src/test/java/org/mockitointegration/NoJUnitDependenciesTest.java
@@ -46,9 +46,9 @@ public class NoJUnitDependenciesTest {
         // loaded.
         checkDependency(
                 classLoader_without_JUnit,
-                "org.mockito.internal.creation.bytebuddy.InlineDelegateByteBuddyMockMaker");
+                "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker");
         pureMockitoAPIClasses.remove(
-                "org.mockito.internal.creation.bytebuddy.InlineDelegateByteBuddyMockMaker");
+                "org.mockito.internal.creation.bytebuddy.InlineByteBuddyMockMaker");
 
         for (String pureMockitoAPIClass : pureMockitoAPIClasses) {
             checkDependency(classLoader_without_JUnit, pureMockitoAPIClass);
