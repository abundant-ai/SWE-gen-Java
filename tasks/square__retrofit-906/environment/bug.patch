diff --git a/pom.xml b/pom.xml
index f9adffe1..eadd5875 100644
--- a/pom.xml
+++ b/pom.xml
@@ -59,7 +59,7 @@
     <gson.version>2.3.1</gson.version>
     <protobuf.version>2.5.0</protobuf.version>
     <jackson.version>2.4.3</jackson.version>
-    <wire.version>1.7.0</wire.version>
+    <wire.version>1.5.2</wire.version>
     <simplexml.version>2.7.1</simplexml.version>
     <moshi.version>0.9.0</moshi.version>
 
diff --git a/retrofit-converters/gson/pom.xml b/retrofit-converters/gson/pom.xml
index 0cb591ac..e353bb32 100644
--- a/retrofit-converters/gson/pom.xml
+++ b/retrofit-converters/gson/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterTest.java b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterTest.java
index a3037276..a4449757 100644
--- a/retrofit-converters/gson/src/test/java/retrofit/GsonConverterTest.java
+++ b/retrofit-converters/gson/src/test/java/retrofit/GsonConverterTest.java
@@ -1,47 +1,36 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+// Copyright 2015 Square, Inc.
 package retrofit;
 
 import com.google.gson.Gson;
 import com.google.gson.GsonBuilder;
-import com.google.gson.TypeAdapter;
-import com.google.gson.stream.JsonReader;
-import com.google.gson.stream.JsonToken;
-import com.google.gson.stream.JsonWriter;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import java.lang.reflect.Type;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 
 public final class GsonConverterTest {
-  interface AnInterface {
+  private Converter converter;
+
+  interface Example {
     String getName();
   }
 
-  static class AnImplementation implements AnInterface {
+  class Impl implements Example {
     private final String theName;
 
-    AnImplementation(String name) {
+    Impl(String name) {
       theName = name;
     }
 
@@ -50,75 +39,40 @@ public final class GsonConverterTest {
     }
   }
 
-  static class AnInterfaceAdapter extends TypeAdapter<AnInterface> {
-    @Override public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      jsonWriter.beginObject();
-      jsonWriter.name("name").value(anInterface.getName());
-      jsonWriter.endObject();
-    }
-
-    @Override public AnInterface read(JsonReader jsonReader) throws IOException {
-      jsonReader.beginObject();
-
-      String name = null;
-      while (jsonReader.peek() != JsonToken.END_OBJECT) {
-        switch (jsonReader.nextName()) {
-          case "name":
-            name = jsonReader.nextString();
-            break;
-        }
-      }
-
-      jsonReader.endObject();
-      return new AnImplementation(name);
-    }
-  }
-
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-  }
-
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
-
-  private Service service;
-
   @Before public void setUp() {
     Gson gson = new GsonBuilder()
-        .registerTypeAdapter(AnInterface.class, new AnInterfaceAdapter())
+        .registerTypeAdapter(Example.class, new JsonSerializer<Example>() {
+          @Override public JsonElement serialize(Example example, Type type,
+              JsonSerializationContext json) {
+            JsonObject object = new JsonObject();
+            object.addProperty("name", example.getName());
+            return object;
+          }
+        })
         .create();
-    Converter converter = new GsonConverter(gson);
-    Retrofit retrofit = new Retrofit.Builder()
-        .endpoint(server.getUrl("/").toString())
-        .converter(converter)
-        .build();
-    service = retrofit.create(Service.class);
+    converter = new GsonConverter(gson);
   }
 
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  @Test public void serialization() throws IOException {
+    RequestBody body = converter.toBody(new Impl("value"), Impl.class);
+    assertBody(body).isEqualTo("{\"theName\":\"value\"}");
   }
 
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
-
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
+  @Test public void serializationTypeUsed() throws IOException {
+    RequestBody body = converter.toBody(new Impl("value"), Example.class);
+    assertBody(body).isEqualTo("{\"name\":\"value\"}");
+  }
 
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  @Test public void deserialization() throws IOException {
+    ResponseBody body =
+        ResponseBody.create(MediaType.parse("text/plain"), "{\"theName\":\"value\"}");
+    Impl impl = (Impl) converter.fromBody(body, Impl.class);
+    assertEquals("value", impl.getName());
+  }
 
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
   }
 }
diff --git a/retrofit-converters/jackson/pom.xml b/retrofit-converters/jackson/pom.xml
index 18d0340b..06c5a299 100644
--- a/retrofit-converters/jackson/pom.xml
+++ b/retrofit-converters/jackson/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
index d552b7bc..8df5529d 100644
--- a/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
+++ b/retrofit-converters/jackson/src/test/java/retrofit/JacksonConverterTest.java
@@ -1,156 +1,89 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package retrofit;
 
-import com.fasterxml.jackson.annotation.JsonAutoDetect;
-import com.fasterxml.jackson.core.JsonGenerator;
-import com.fasterxml.jackson.core.JsonParser;
-import com.fasterxml.jackson.core.JsonToken;
-import com.fasterxml.jackson.databind.DeserializationContext;
-import com.fasterxml.jackson.databind.MapperFeature;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.fasterxml.jackson.databind.SerializerProvider;
-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
-import com.fasterxml.jackson.databind.module.SimpleModule;
-import com.fasterxml.jackson.databind.ser.std.StdSerializer;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import org.junit.Before;
-import org.junit.Rule;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class JacksonConverterTest {
-  interface AnInterface {
-    String getName();
-  }
-
-  static class AnImplementation implements AnInterface {
-    private String theName;
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/json; charset=UTF-8");
+  private static final MyObject OBJECT = new MyObject("hello world", 10);
+  private final String JSON = "{\"message\":\"hello world\",\"count\":10}";
 
-    AnImplementation() {
-    }
-
-    AnImplementation(String name) {
-      theName = name;
-    }
+  private final JacksonConverter converter = new JacksonConverter();
 
-    @Override public String getName() {
-      return theName;
-    }
+  @Test public void serialize() throws Exception {
+    RequestBody body = converter.toBody(OBJECT, MyObject.class);
+    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+    assertBody(body).isEqualTo(JSON);
   }
 
-  static class AnInterfaceSerializer extends StdSerializer<AnInterface> {
-    AnInterfaceSerializer() {
-      super(AnInterface.class);
-    }
-
-    @Override public void serialize(AnInterface anInterface, JsonGenerator jsonGenerator,
-        SerializerProvider serializerProvider) throws IOException {
-      jsonGenerator.writeStartObject();
-      jsonGenerator.writeFieldName("name");
-      jsonGenerator.writeString(anInterface.getName());
-      jsonGenerator.writeEndObject();
-    }
+  @Test public void deserialize() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
+    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
+    assertThat(result).isEqualTo(OBJECT);
   }
 
-  static class AnInterfaceDeserializer extends StdDeserializer<AnInterface> {
-    AnInterfaceDeserializer() {
-      super(AnInterface.class);
+  @Test public void deserializeWrongValue() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "{\"foo\":\"bar\"}");
+    try {
+      converter.fromBody(body, MyObject.class);
+    } catch (UnrecognizedPropertyException ignored) {
     }
+  }
 
-    @Override public AnInterface deserialize(JsonParser jp, DeserializationContext ctxt)
-        throws IOException {
-      if (jp.getCurrentToken() != JsonToken.START_OBJECT) {
-        throw new AssertionError("Expected start object.");
-      }
-
-      String name = null;
-
-      while (jp.nextToken() != JsonToken.END_OBJECT) {
-        switch (jp.getCurrentName()) {
-          case "name":
-            name = jp.getValueAsString();
-            break;
-        }
-      }
-
-      return new AnImplementation(name);
+  @Test public void deserializeWrongClass() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, JSON);
+    try {
+      converter.fromBody(body, String.class);
+    } catch (JsonMappingException ignored) {
     }
   }
 
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
   }
 
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
-
-  private Service service;
-
-  @Before public void setUp() {
-    SimpleModule module = new SimpleModule();
-    module.addSerializer(AnInterface.class, new AnInterfaceSerializer());
-    module.addDeserializer(AnInterface.class, new AnInterfaceDeserializer());
-    ObjectMapper mapper = new ObjectMapper();
-    mapper.registerModule(module);
-    mapper.configure(MapperFeature.AUTO_DETECT_GETTERS, false);
-    mapper.configure(MapperFeature.AUTO_DETECT_SETTERS, false);
-    mapper.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);
-    mapper.setVisibilityChecker(mapper.getSerializationConfig()
-        .getDefaultVisibilityChecker()
-        .withFieldVisibility(JsonAutoDetect.Visibility.ANY));
-
-    Converter converter = new JacksonConverter(mapper);
-    Retrofit retrofit = new Retrofit.Builder()
-        .endpoint(server.getUrl("/").toString())
-        .converter(converter)
-        .build();
-    service = retrofit.create(Service.class);
-  }
+  static class MyObject {
+    private final String message;
+    private final int count;
 
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
+    public MyObject(@JsonProperty("message") String message, @JsonProperty("count") int count) {
+      this.message = message;
+      this.count = count;
+    }
 
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
+    public String getMessage() {
+      return message;
+    }
 
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
-  }
+    public int getCount() {
+      return count;
+    }
 
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+    @Override public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
 
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
+      MyObject myObject = (MyObject) o;
+      return count == myObject.count
+          && !(message != null ? !message.equals(myObject.message) : myObject.message != null);
+    }
 
-    RecordedRequest request = server.takeRequest();
-    // TODO figure out how to get Jackson to stop using AnInterface's serializer here.
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+    @Override public int hashCode() {
+      int result = message != null ? message.hashCode() : 0;
+      result = 31 * result + count;
+      return result;
+    }
   }
 }
diff --git a/retrofit-converters/moshi/pom.xml b/retrofit-converters/moshi/pom.xml
index 627c62b9..ad406866 100644
--- a/retrofit-converters/moshi/pom.xml
+++ b/retrofit-converters/moshi/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java
index b3f803ad..6dcaa686 100644
--- a/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java
+++ b/retrofit-converters/moshi/src/main/java/retrofit/MoshiConverter.java
@@ -38,7 +38,7 @@ public final class MoshiConverter implements Converter {
   public MoshiConverter(Moshi moshi) {
     if (moshi == null) throw new NullPointerException("moshi == null");
     this.moshi = moshi;
-    this.mediaType = MediaType.parse("application/json; charset=UTF-8");
+    this.mediaType = MediaType.parse("application/json; charset=utf-8");
   }
 
   @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
diff --git a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
index 2e721308..072745cd 100644
--- a/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
+++ b/retrofit-converters/moshi/src/test/java/retrofit/MoshiConverterTest.java
@@ -20,27 +20,29 @@ import com.squareup.moshi.JsonReader;
 import com.squareup.moshi.JsonWriter;
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.ToJson;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 
 public final class MoshiConverterTest {
-  interface AnInterface {
+  private Converter converter;
+
+  interface Example {
     String getName();
   }
 
-  static class AnImplementation implements AnInterface {
+  static class Impl implements Example {
     private final String theName;
 
-    AnImplementation(String name) {
+    Impl(String name) {
       theName = name;
     }
 
@@ -49,75 +51,45 @@ public final class MoshiConverterTest {
     }
   }
 
-  static class AnInterfaceAdapter {
-    @ToJson public void write(JsonWriter jsonWriter, AnInterface anInterface) throws IOException {
-      System.out.println("TO JSON: " + anInterface);
-      jsonWriter.beginObject();
-      jsonWriter.name("name").value(anInterface.getName());
-      jsonWriter.endObject();
+  static class ExampleAdapter {
+    @ToJson public void to(JsonWriter writer, Example example) throws IOException {
+      writer.beginObject();
+      writer.name("name").value(example.getName());
+      writer.endObject();
     }
 
-    @FromJson public AnInterface read(JsonReader jsonReader) throws IOException {
-      jsonReader.beginObject();
-
-      String name = null;
-      while (jsonReader.hasNext()) {
-        switch (jsonReader.nextName()) {
-          case "name":
-            name = jsonReader.nextString();
-            break;
-        }
-      }
-
-      jsonReader.endObject();
-      return new AnImplementation(name);
+    @FromJson public Example from(JsonReader reader) throws IOException {
+      throw new UnsupportedOperationException(); // Moshi requires this method to exist.
     }
   }
 
-  interface Service {
-    @POST("/") Call<AnImplementation> anImplementation(@Body AnImplementation impl);
-    @POST("/") Call<AnInterface> anInterface(@Body AnInterface impl);
-  }
-
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
-
-  private Service service;
-
   @Before public void setUp() {
-    Moshi moshi = new Moshi.Builder()
-        .add(new AnInterfaceAdapter())
-        .build();
-    Converter converter = new MoshiConverter(moshi);
-    Retrofit retrofit = new Retrofit.Builder()
-        .endpoint(server.getUrl("/").toString())
-        .converter(converter)
+    Moshi gson = new Moshi.Builder()
+        .add(new ExampleAdapter())
         .build();
-    service = retrofit.create(Service.class);
+    converter = new MoshiConverter(gson);
   }
 
-  @Test public void anInterface() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"name\":\"value\"}"));
-
-    Call<AnInterface> call = service.anInterface(new AnImplementation("value"));
-    Response<AnInterface> response = call.execute();
-    AnInterface body = response.body();
-    assertThat(body.getName()).isEqualTo("value");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"name\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  @Test public void serialization() throws IOException {
+    RequestBody body = converter.toBody(new Impl("value"), Impl.class);
+    assertBody(body).isEqualTo("{\"theName\":\"value\"}");
   }
 
-  @Test public void anImplementation() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody("{\"theName\":\"value\"}"));
+  @Test public void serializationTypeUsed() throws IOException {
+    RequestBody body = converter.toBody(new Impl("value"), Example.class);
+    assertBody(body).isEqualTo("{\"name\":\"value\"}");
+  }
 
-    Call<AnImplementation> call = service.anImplementation(new AnImplementation("value"));
-    Response<AnImplementation> response = call.execute();
-    AnImplementation body = response.body();
-    assertThat(body.theName).isEqualTo("value");
+  @Test public void deserialization() throws IOException {
+    ResponseBody body =
+        ResponseBody.create(MediaType.parse("text/plain"), "{\"theName\":\"value\"}");
+    Impl impl = (Impl) converter.fromBody(body, Impl.class);
+    assertEquals("value", impl.getName());
+  }
 
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("{\"theName\":\"value\"}");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/json; charset=UTF-8");
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
   }
 }
diff --git a/retrofit-converters/protobuf/pom.xml b/retrofit-converters/protobuf/pom.xml
index c635c485..d2808b7e 100644
--- a/retrofit-converters/protobuf/pom.xml
+++ b/retrofit-converters/protobuf/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
index e04065a0..e10956d9 100644
--- a/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
+++ b/retrofit-converters/protobuf/src/test/java/retrofit/ProtoConverterTest.java
@@ -1,119 +1,73 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+// Copyright 2013 Square, Inc.
 package retrofit;
 
 import com.google.protobuf.InvalidProtocolBufferException;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.util.List;
+import java.util.ArrayList;
 import okio.Buffer;
 import okio.ByteString;
-import org.junit.Before;
-import org.junit.Rule;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.GET;
-import retrofit.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 import static retrofit.PhoneProtos.Phone;
 
 public final class ProtoConverterTest {
-  interface Service {
-    @GET("/") Call<Phone> get();
-    @POST("/") Call<Phone> post(@Body Phone impl);
-    @GET("/") Call<String> wrongClass();
-    @GET("/") Call<List<String>> wrongType();
-  }
-
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  private static final Phone PROTO = Phone.newBuilder().setNumber("(519) 867-5309").build();
+  private static final String ENCODED_PROTO = "Cg4oNTE5KSA4NjctNTMwOQ==";
 
-  private Service service;
+  private final ProtoConverter converter = new ProtoConverter();
 
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .endpoint(server.getUrl("/").toString())
-        .converter(new ProtoConverter())
-        .build();
-    service = retrofit.create(Service.class);
+  @Test public void serialize() throws Exception {
+    RequestBody body = converter.toBody(PROTO, Phone.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
   }
 
-  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<Phone> call = service.post(Phone.newBuilder().setNumber("(519) 867-5309").build());
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.getNumber()).isEqualTo("(519) 867-5309");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
-  }
-
-  @Test public void deserializeEmpty() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call<Phone> call = service.get();
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.hasNumber()).isFalse();
+  @Test public void deserialize() throws Exception {
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Phone.class);
+    assertThat(proto).isEqualTo(PROTO);
   }
 
-  @Test public void deserializeWrongClass() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<?> call = service.wrongClass();
+  @Test public void deserializeWrongClass() throws Exception {
     try {
-      call.execute();
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a protobuf message but was java.lang.String");
     }
   }
 
-  @Test public void deserializeWrongType() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<?> call = service.wrongType();
+  @Test public void deserializeWrongType() throws Exception {
     try {
-      call.execute();
+      converter.fromBody(protoResponse(ENCODED_PROTO), ArrayList.class.getGenericSuperclass());
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.List<java.lang.String>");
+      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
     }
   }
 
-  @Test public void deserializeWrongValue() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("////");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<?> call = service.get();
+  @Test public void deserializeWrongValue() throws Exception {
     try {
-      call.execute();
+      converter.fromBody(protoResponse("////"), Phone.class);
       fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(InvalidProtocolBufferException.class)
-          .hasMessageContaining("input ended unexpectedly");
+    } catch (RuntimeException expected) {
+      assertThat(expected.getCause() instanceof InvalidProtocolBufferException);
     }
   }
+
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"), ByteString.decodeBase64(
+        encodedProto).toByteArray());
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
+  }
 }
diff --git a/retrofit-converters/simplexml/pom.xml b/retrofit-converters/simplexml/pom.xml
index 1eba174c..4a83d0a7 100644
--- a/retrofit-converters/simplexml/pom.xml
+++ b/retrofit-converters/simplexml/pom.xml
@@ -30,13 +30,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
index c737dba2..36ba06f8 100644
--- a/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
+++ b/retrofit-converters/simplexml/src/main/java/retrofit/SimpleXmlConverter.java
@@ -1,18 +1,3 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package retrofit;
 
 import com.squareup.okhttp.MediaType;
@@ -61,12 +46,8 @@ public class SimpleXmlConverter implements Converter {
   @Override public Object fromBody(ResponseBody body, Type type) throws IOException {
     InputStream is = body.byteStream();
     try {
-      Object read = serializer.read((Class<?>) type, is, strict);
-      if (read == null) {
-        throw new IllegalStateException("Could not deserialize body as " + type);
-      }
-      return read;
-    } catch (RuntimeException | IOException e) {
+      return serializer.read((Class<?>) type, is, strict);
+    } catch (IOException e) {
       throw e;
     } catch (Exception e) {
       throw new RuntimeException(e);
@@ -79,15 +60,17 @@ public class SimpleXmlConverter implements Converter {
   }
 
   @Override public RequestBody toBody(Object source, Type type) {
-    Buffer buffer = new Buffer();
+    byte[] bytes;
     try {
+      Buffer buffer = new Buffer();
       OutputStreamWriter osw = new OutputStreamWriter(buffer.outputStream(), CHARSET);
       serializer.write(source, osw);
       osw.flush();
+      bytes = buffer.readByteArray();
     } catch (Exception e) {
-      throw new RuntimeException(e);
+      throw new AssertionError(e);
     }
-    return RequestBody.create(MEDIA_TYPE, buffer.readByteString());
+    return RequestBody.create(MEDIA_TYPE, bytes);
   }
 
   public boolean isStrict() {
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/MyObject.java b/retrofit-converters/simplexml/src/test/java/retrofit/MyObject.java
deleted file mode 100644
index 398854c1..00000000
--- a/retrofit-converters/simplexml/src/test/java/retrofit/MyObject.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit;
-
-import org.simpleframework.xml.Default;
-import org.simpleframework.xml.DefaultType;
-import org.simpleframework.xml.Element;
-
-@Default(value = DefaultType.FIELD)
-final class MyObject {
-  @Element private String message;
-  @Element private int count;
-
-  public MyObject() {
-  }
-
-  public MyObject(String message, int count) {
-    this.message = message;
-    this.count = count;
-  }
-
-  public void setMessage(String message) {
-    this.message = message;
-  }
-
-  public String getMessage() {
-    return message;
-  }
-
-  public void setCount(int count) {
-    this.count = count;
-  }
-
-  public int getCount() {
-    return count;
-  }
-
-  @Override public int hashCode() {
-    int result = 1;
-    result = result * 31 + count;
-    result = result * 31 + (message == null ? 0 : message.hashCode());
-    return result;
-  }
-
-  @Override public boolean equals(Object obj) {
-    if (obj == this) return true;
-    if (!(obj instanceof MyObject)) return false;
-    MyObject other = (MyObject) obj;
-    return count == other.count
-        && (message == null ? other.message == null : message.equals(other.message));
-  }
-}
diff --git a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
index 1c1d0f9a..e47c44a6 100644
--- a/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
+++ b/retrofit-converters/simplexml/src/test/java/retrofit/SimpleXmlConverterTest.java
@@ -1,100 +1,128 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
 package retrofit;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
+import okio.Buffer;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Before;
-import org.junit.Rule;
 import org.junit.Test;
-import org.simpleframework.xml.core.ElementException;
+import org.simpleframework.xml.Default;
+import org.simpleframework.xml.DefaultType;
+import org.simpleframework.xml.Element;
 import org.simpleframework.xml.core.Persister;
 import org.simpleframework.xml.stream.Format;
 import org.simpleframework.xml.stream.HyphenStyle;
 import org.simpleframework.xml.stream.Verbosity;
-import retrofit.http.Body;
-import retrofit.http.GET;
-import retrofit.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
 
 public class SimpleXmlConverterTest {
-  interface Service {
-    @GET("/") Call<MyObject> get();
-    @POST("/") Call<MyObject> post(@Body MyObject impl);
-    @GET("/") Call<String> wrongClass();
-  }
-
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  private static final MediaType MEDIA_TYPE = MediaType.parse("application/xml; charset=UTF-8");
+  private static final MyObject OBJ = new MyObject("hello world", 10);
+  private static final String XML =
+      "<my-object><message>hello world</message><count>10</count></my-object>";
 
-  private Service service;
+  private Converter converter;
 
   @Before public void setUp() {
     Format format = new Format(0, null, new HyphenStyle(), Verbosity.HIGH);
     Persister persister = new Persister(format);
-    Converter converter = new SimpleXmlConverter(persister);
-    Retrofit retrofit = new Retrofit.Builder()
-        .endpoint(server.getUrl("/").toString())
-        .converter(converter)
-        .build();
-    service = retrofit.create(Service.class);
+    converter = new SimpleXmlConverter(persister);
   }
 
-  @Test public void bodyWays() throws IOException, InterruptedException {
-    server.enqueue(new MockResponse().setBody(
-        "<my-object><message>hello world</message><count>10</count></my-object>"));
-
-    Call<MyObject> call = service.post(new MyObject("hello world", 10));
-    Response<MyObject> response = call.execute();
-    MyObject body = response.body();
-    assertThat(body.getMessage()).isEqualTo("hello world");
-    assertThat(body.getCount()).isEqualTo(10);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo(
-        "<my-object><message>hello world</message><count>10</count></my-object>");
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/xml; charset=UTF-8");
+  @Test public void serialize() throws Exception {
+    RequestBody body = converter.toBody(OBJ, MyObject.class);
+    assertThat(body.contentType()).isEqualTo(MEDIA_TYPE);
+    assertBody(body).isEqualTo(XML);
   }
 
-  @Test public void deserializeWrongValue() throws IOException {
-    server.enqueue(new MockResponse().setBody("<myObject><foo/><bar/></myObject>"));
+  @Test public void deserialize() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+    MyObject result = (MyObject) converter.fromBody(body, MyObject.class);
+    assertThat(result).isEqualTo(OBJ);
+  }
 
-    Call<?> call = service.get();
+  @Test public void deserializeWrongValue() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, "<myObject><foo/><bar/></myObject>");
     try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e.getCause()).isInstanceOf(ElementException.class)
-          .hasMessageStartingWith("Element 'foo' does not have a match in class retrofit.MyObject");
+      converter.fromBody(body, MyObject.class);
+    } catch (RuntimeException ignored) {
     }
   }
 
-  @Test public void deserializeWrongClass() throws IOException {
-    server.enqueue(new MockResponse().setBody(
-        "<my-object><message>hello world</message><count>10</count></my-object>"));
+  @Test public void deserializeWrongClass() throws Exception {
+    ResponseBody body = ResponseBody.create(MEDIA_TYPE, XML);
+    Object result = converter.fromBody(body, String.class);
+    assertThat(result).isNull();
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body)
+      throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readUtf8());
+  }
 
-    Call<?> call = service.wrongClass();
-    try {
-      call.execute();
-      fail();
-    } catch (RuntimeException e) {
-      assertThat(e).hasMessage("Could not deserialize body as class java.lang.String");
+  @Default(value = DefaultType.FIELD) static class MyObject {
+    @Element private String message;
+    @Element private int count;
+
+    public MyObject() {
+    }
+
+    public MyObject(String message, int count) {
+      this.message = message;
+      this.count = count;
+    }
+
+    public void setMessage(String message) {
+      this.message = message;
+    }
+
+    public String getMessage() {
+      return message;
+    }
+
+    public void setCount(int count) {
+      this.count = count;
+    }
+
+    public int getCount() {
+      return count;
+    }
+
+    @Override public int hashCode() {
+      final int prime = 31;
+      int result = 1;
+      result = prime * result + count;
+      result = prime * result + ((message == null) ? 0 : message.hashCode());
+      return result;
+    }
+
+    @Override public boolean equals(Object obj) {
+      if (this == obj) {
+        return true;
+      }
+      if (obj == null) {
+        return false;
+      }
+      if (getClass() != obj.getClass()) {
+        return false;
+      }
+      MyObject other = (MyObject) obj;
+      if (count != other.count) {
+        return false;
+      }
+      if (message == null) {
+        if (other.message != null) {
+          return false;
+        }
+      } else if (!message.equals(other.message)) {
+        return false;
+      }
+      return true;
     }
   }
 }
diff --git a/retrofit-converters/wire/pom.xml b/retrofit-converters/wire/pom.xml
index d2bf06f1..f56ef5fc 100644
--- a/retrofit-converters/wire/pom.xml
+++ b/retrofit-converters/wire/pom.xml
@@ -26,13 +26,6 @@
     <dependency>
       <groupId>com.squareup.wire</groupId>
       <artifactId>wire-runtime</artifactId>
-      <exclusions>
-        <!-- Make sure OkHttp's transitive version wins (itself transitive from Retrofit). -->
-        <exclusion>
-          <groupId>com.squareup.okio</groupId>
-          <artifactId>okio</artifactId>
-        </exclusion>
-      </exclusions>
     </dependency>
 
     <dependency>
@@ -41,13 +34,13 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
       <scope>test</scope>
     </dependency>
   </dependencies>
diff --git a/retrofit-converters/wire/src/test/java/retrofit/Person.java b/retrofit-converters/wire/src/test/java/retrofit/Person.java
new file mode 100644
index 00000000..daf0bc32
--- /dev/null
+++ b/retrofit-converters/wire/src/test/java/retrofit/Person.java
@@ -0,0 +1,248 @@
+// Code generated by Wire protocol buffer compiler, do not edit.
+// Source file: ../wire-runtime/src/test/proto/person.proto
+package retrofit;
+
+import com.squareup.wire.Message;
+import com.squareup.wire.ProtoEnum;
+import com.squareup.wire.ProtoField;
+import java.util.Collections;
+import java.util.List;
+
+import static com.squareup.wire.Message.Datatype.ENUM;
+import static com.squareup.wire.Message.Datatype.INT32;
+import static com.squareup.wire.Message.Datatype.STRING;
+import static com.squareup.wire.Message.Label.REPEATED;
+import static com.squareup.wire.Message.Label.REQUIRED;
+
+public final class Person extends Message {
+
+  public static final String DEFAULT_NAME = "";
+  public static final Integer DEFAULT_ID = 0;
+  public static final String DEFAULT_EMAIL = "";
+  public static final List<PhoneNumber> DEFAULT_PHONE = Collections.emptyList();
+
+  /**
+   * The customer's full name.
+   */
+  @ProtoField(tag = 1, type = STRING, label = REQUIRED)
+  public final String name;
+
+  /**
+   * The customer's ID number.
+   */
+  @ProtoField(tag = 2, type = INT32, label = REQUIRED)
+  public final Integer id;
+
+  /**
+   * Email address for the customer.
+   */
+  @ProtoField(tag = 3, type = STRING)
+  public final String email;
+
+  /**
+   * A list of the customer's phone numbers.
+   */
+  @ProtoField(tag = 4, label = REPEATED)
+  public final List<PhoneNumber> phone;
+
+  public Person(String name, Integer id, String email, List<PhoneNumber> phone) {
+    this.name = name;
+    this.id = id;
+    this.email = email;
+    this.phone = immutableCopyOf(phone);
+  }
+
+  private Person(Builder builder) {
+    this(builder.name, builder.id, builder.email, builder.phone);
+    setBuilder(builder);
+  }
+
+  @Override
+  public boolean equals(Object other) {
+    if (other == this) return true;
+    if (!(other instanceof Person)) return false;
+    Person o = (Person) other;
+    return equals(name, o.name)
+        && equals(id, o.id)
+        && equals(email, o.email)
+        && equals(phone, o.phone);
+  }
+
+  @Override
+  public int hashCode() {
+    int result = hashCode;
+    if (result == 0) {
+      result = name != null ? name.hashCode() : 0;
+      result = result * 37 + (id != null ? id.hashCode() : 0);
+      result = result * 37 + (email != null ? email.hashCode() : 0);
+      result = result * 37 + (phone != null ? phone.hashCode() : 1);
+      hashCode = result;
+    }
+    return result;
+  }
+
+  public static final class Builder extends Message.Builder<Person> {
+
+    public String name;
+    public Integer id;
+    public String email;
+    public List<PhoneNumber> phone;
+
+    public Builder() {
+    }
+
+    public Builder(Person message) {
+      super(message);
+      if (message == null) return;
+      this.name = message.name;
+      this.id = message.id;
+      this.email = message.email;
+      this.phone = copyOf(message.phone);
+    }
+
+    /**
+     * The customer's full name.
+     */
+    public Builder name(String name) {
+      this.name = name;
+      return this;
+    }
+
+    /**
+     * The customer's ID number.
+     */
+    public Builder id(Integer id) {
+      this.id = id;
+      return this;
+    }
+
+    /**
+     * Email address for the customer.
+     */
+    public Builder email(String email) {
+      this.email = email;
+      return this;
+    }
+
+    /**
+     * A list of the customer's phone numbers.
+     */
+    public Builder phone(List<PhoneNumber> phone) {
+      this.phone = checkForNulls(phone);
+      return this;
+    }
+
+    @Override
+    public Person build() {
+      checkRequiredFields();
+      return new Person(this);
+    }
+  }
+
+  public enum PhoneType
+      implements ProtoEnum {
+    MOBILE(0),
+    HOME(1),
+    /**
+     * Could be phone or fax.
+     */
+    WORK(2);
+
+    private final int value;
+
+    private PhoneType(int value) {
+      this.value = value;
+    }
+
+    @Override
+    public int getValue() {
+      return value;
+    }
+  }
+
+  public static final class PhoneNumber extends Message {
+
+    public static final String DEFAULT_NUMBER = "";
+    public static final PhoneType DEFAULT_TYPE = PhoneType.HOME;
+
+    /**
+     * The customer's phone number.
+     */
+    @ProtoField(tag = 1, type = STRING, label = REQUIRED)
+    public final String number;
+
+    /**
+     * The type of phone stored here.
+     */
+    @ProtoField(tag = 2, type = ENUM)
+    public final PhoneType type;
+
+    public PhoneNumber(String number, PhoneType type) {
+      this.number = number;
+      this.type = type;
+    }
+
+    private PhoneNumber(Builder builder) {
+      this(builder.number, builder.type);
+      setBuilder(builder);
+    }
+
+    @Override
+    public boolean equals(Object other) {
+      if (other == this) return true;
+      if (!(other instanceof PhoneNumber)) return false;
+      PhoneNumber o = (PhoneNumber) other;
+      return equals(number, o.number)
+          && equals(type, o.type);
+    }
+
+    @Override
+    public int hashCode() {
+      int result = hashCode;
+      if (result == 0) {
+        result = number != null ? number.hashCode() : 0;
+        result = result * 37 + (type != null ? type.hashCode() : 0);
+        hashCode = result;
+      }
+      return result;
+    }
+
+    public static final class Builder extends Message.Builder<PhoneNumber> {
+
+      public String number;
+      public PhoneType type;
+
+      public Builder() {
+      }
+
+      public Builder(PhoneNumber message) {
+        super(message);
+        if (message == null) return;
+        this.number = message.number;
+        this.type = message.type;
+      }
+
+      /**
+       * The customer's phone number.
+       */
+      public Builder number(String number) {
+        this.number = number;
+        return this;
+      }
+
+      /**
+       * The type of phone stored here.
+       */
+      public Builder type(PhoneType type) {
+        this.type = type;
+        return this;
+      }
+
+      @Override
+      public PhoneNumber build() {
+        checkRequiredFields();
+        return new PhoneNumber(this);
+      }
+    }
+  }
+}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/Phone.java b/retrofit-converters/wire/src/test/java/retrofit/Phone.java
deleted file mode 100644
index e8a47989..00000000
--- a/retrofit-converters/wire/src/test/java/retrofit/Phone.java
+++ /dev/null
@@ -1,69 +0,0 @@
-// Code generated by Wire protocol buffer compiler, do not edit.
-// Source file: ../wire-runtime/src/test/proto/person.proto
-package retrofit;
-
-import com.squareup.wire.Message;
-import com.squareup.wire.ProtoField;
-
-import static com.squareup.wire.Message.Datatype.STRING;
-import static com.squareup.wire.Message.Label.OPTIONAL;
-
-public final class Phone extends Message {
-
-  public static final String DEFAULT_PHONE = "";
-
-  @ProtoField(tag = 1, type = STRING, label = OPTIONAL)
-  public final String number;
-
-  public Phone(String number) {
-    this.number = number;
-  }
-
-  private Phone(Builder builder) {
-    this(builder.number);
-    setBuilder(builder);
-  }
-
-  @Override
-  public boolean equals(Object other) {
-    if (other == this) return true;
-    if (!(other instanceof Phone)) return false;
-    Phone o = (Phone) other;
-    return equals(number, o.number);
-  }
-
-  @Override
-  public int hashCode() {
-    int result = hashCode;
-    if (result == 0) {
-      result = number != null ? number.hashCode() : 0;
-      hashCode = result;
-    }
-    return result;
-  }
-
-  public static final class Builder extends Message.Builder<Phone> {
-
-    public String number;
-
-    public Builder() {
-    }
-
-    public Builder(Phone message) {
-      super(message);
-      if (message == null) return;
-      this.number = message.number;
-    }
-
-    public Builder number(String name) {
-      this.number = name;
-      return this;
-    }
-
-    @Override
-    public Phone build() {
-      checkRequiredFields();
-      return new Phone(this);
-    }
-  }
-}
diff --git a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java b/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
index 47e615f7..b72c1f5f 100644
--- a/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
+++ b/retrofit-converters/wire/src/test/java/retrofit/WireConverterTest.java
@@ -1,116 +1,72 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+// Copyright 2013 Square, Inc.
 package retrofit;
 
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.RecordedRequest;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import java.io.EOFException;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.util.List;
+import java.util.ArrayList;
 import okio.Buffer;
 import okio.ByteString;
-import org.junit.Before;
-import org.junit.Rule;
+import org.assertj.core.api.AbstractCharSequenceAssert;
 import org.junit.Test;
-import retrofit.http.Body;
-import retrofit.http.GET;
-import retrofit.http.POST;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
 public final class WireConverterTest {
-  interface Service {
-    @GET("/") Call<Phone> get();
-    @POST("/") Call<Phone> post(@Body Phone impl);
-    @GET("/") Call<String> wrongClass();
-    @GET("/") Call<List<String>> wrongType();
-  }
-
-  @Rule public final MockWebServerRule server = new MockWebServerRule();
+  private static final Person PROTO =
+      new Person.Builder().id(42).name("Omar Little").email("omar@theking.org").build();
+  private static final String ENCODED_PROTO = "CgtPbWFyIExpdHRsZRAqGhBvbWFyQHRoZWtpbmcub3Jn";
 
-  private Service service;
+  private final WireConverter converter = new WireConverter();
 
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .endpoint(server.getUrl("/").toString())
-        .converter(new WireConverter())
-        .build();
-    service = retrofit.create(Service.class);
+  @Test public void serialize() throws Exception {
+    RequestBody body = converter.toBody(PROTO, Person.class);
+    assertThat(body.contentType().toString()).isEqualTo("application/x-protobuf");
+    assertBody(body).isEqualTo(ENCODED_PROTO);
   }
 
-  @Test public void serializeAndDeserialize() throws IOException, InterruptedException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<Phone> call = service.post(new Phone("(519) 867-5309"));
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.number).isEqualTo("(519) 867-5309");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readByteString()).isEqualTo(encoded);
-    assertThat(request.getHeader("Content-Type")).isEqualTo("application/x-protobuf");
-  }
-
-  @Test public void deserializeEmpty() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call<Phone> call = service.get();
-    Response<Phone> response = call.execute();
-    Phone body = response.body();
-    assertThat(body.number).isNull();
+  @Test public void deserialize() throws Exception {
+    Object proto = converter.fromBody(protoResponse(ENCODED_PROTO), Person.class);
+    assertThat(proto).isEqualTo(PROTO);
   }
 
-  @Test public void deserializeWrongClass() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<?> call = service.wrongClass();
+  @Test public void deserializeWrongClass() throws Exception {
     try {
-      call.execute();
+      converter.fromBody(protoResponse(ENCODED_PROTO), String.class);
       fail();
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expected a proto message but was java.lang.String");
     }
   }
 
-  @Test public void deserializeWrongType() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("Cg4oNTE5KSA4NjctNTMwOQ==");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<?> call = service.wrongType();
+  @Test public void deserializeWrongType() throws Exception {
     try {
-      call.execute();
+      converter.fromBody(protoResponse(ENCODED_PROTO),
+          ArrayList.class.getGenericSuperclass());
       fail();
     } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.List<java.lang.String>");
+      assertThat(e).hasMessage("Expected a raw Class<?> but was java.util.AbstractList<E>");
     }
   }
 
-  @Test public void deserializeWrongValue() throws IOException {
-    ByteString encoded = ByteString.decodeBase64("////");
-    server.enqueue(new MockResponse().setBody(new Buffer().write(encoded)));
-
-    Call<?> call = service.get();
+  @Test public void deserializeWrongValue() throws Exception {
     try {
-      call.execute();
+      converter.fromBody(protoResponse("////"), Person.class);
       fail();
-    } catch (EOFException ignored) {
+    } catch (IOException ignored) {
     }
   }
+
+  private static ResponseBody protoResponse(String encodedProto) {
+    return ResponseBody.create(MediaType.parse("application/x-protobuf"),
+        ByteString.decodeBase64(encodedProto).toByteArray());
+  }
+
+  private static AbstractCharSequenceAssert<?, String> assertBody(RequestBody body) throws IOException {
+    Buffer buffer = new Buffer();
+    body.writeTo(buffer);
+    return assertThat(buffer.readByteString().base64());
+  }
 }
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index cf06d4b1..55951df7 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -26,7 +26,6 @@ import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Array;
-import java.lang.reflect.Type;
 import java.net.URLEncoder;
 import java.util.Map;
 import okio.BufferedSink;
@@ -48,7 +47,6 @@ final class RequestBuilder {
   private final Annotation[] paramAnnotations;
   private final String requestMethod;
   private final boolean requestHasBody;
-  private final Type requestType;
   private final HttpUrl.Builder urlBuilder;
 
   private MultipartBuilder multipartBuilder;
@@ -65,7 +63,6 @@ final class RequestBuilder {
     paramAnnotations = methodInfo.requestParamAnnotations;
     requestMethod = methodInfo.requestMethod;
     requestHasBody = methodInfo.requestHasBody;
-    requestType = methodInfo.requestType;
 
     if (methodInfo.headers != null) {
       headers = methodInfo.headers.newBuilder();
@@ -320,11 +317,10 @@ final class RequestBuilder {
         if (value == null) {
           throw new IllegalArgumentException("Body parameter value must not be null.");
         }
-        if (requestType == RequestBody.class
-            || (requestType == Object.class && value instanceof RequestBody)) {
+        if (value instanceof RequestBody) {
           body = (RequestBody) value;
         } else {
-          body = converter.toBody(value, requestType);
+          body = converter.toBody(value, value.getClass());
         }
       } else {
         throw new IllegalArgumentException(
