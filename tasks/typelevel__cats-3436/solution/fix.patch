diff --git a/.codecov.yml b/.codecov.yml
deleted file mode 100644
index 7da17706b..000000000
--- a/.codecov.yml
+++ /dev/null
@@ -1,4 +0,0 @@
-comment:
-  layout: "diff"
-  require_changes: true
-
diff --git a/.gitignore b/.gitignore
index bebf6c3f5..7c99f0ab7 100644
--- a/.gitignore
+++ b/.gitignore
@@ -19,6 +19,8 @@ TAGS
 .DS_Store
 .vscode
 .sbtrc
+.semanticdb
+metals.sbt
 *.sublime-project
 *.sublime-workspace
 tests.iml
diff --git a/.scalafmt.conf b/.scalafmt.conf
index 3abbf3a70..d7a436817 100644
--- a/.scalafmt.conf
+++ b/.scalafmt.conf
@@ -1,10 +1,10 @@
-version=2.5.3
+version=2.4.2
 align.openParenCallSite = true
 align.openParenDefnSite = true
 maxColumn = 120
 continuationIndent.defnSite = 2
 assumeStandardLibraryStripMargin = true
 danglingParentheses = true
-rewrite.rules = [AvoidInfix, SortImports, RedundantParens, SortModifiers]
+rewrite.rules = [AvoidInfix, SortImports, RedundantBraces, RedundantParens, SortModifiers]
 docstrings = JavaDoc
 newlines.afterCurlyLambda = preserve
diff --git a/README.md b/README.md
index 445747e8e..aa7357136 100644
--- a/README.md
+++ b/README.md
@@ -324,7 +324,6 @@ Here's a (non-exhaustive) list of companies that use Cats in production. Don't s
 - [HomeAway](https://www.homeaway.com)
 - [iHeartRadio](https://iheart.com)
 - [ImmobilienScout24](https://www.immobilienscout24.de/)
-- [Iterators](https://www.iteratorshq.com/)
 - [ITV](https://www.itv.com/)
 - [Lightform](https://lightform.com/)
 - [Lookout](https://www.lookout.com)
diff --git a/alleycats-core/src/main/scala/alleycats/ConsK.scala b/alleycats-core/src/main/scala/alleycats/ConsK.scala
index 9e672ca52..71a5a3892 100644
--- a/alleycats-core/src/main/scala/alleycats/ConsK.scala
+++ b/alleycats-core/src/main/scala/alleycats/ConsK.scala
@@ -18,38 +18,35 @@ object ConsK {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[ConsK]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: ConsK[F]): ConsK[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: ConsK[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToConsKOps extends Serializable {
+  trait ToConsKOps {
     implicit def toConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): Ops[F, A] {
       type TypeClassType = ConsK[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = ConsK[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = ConsK[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToConsKOps
   object ops {
     implicit def toAllConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): AllOps[F, A] {
       type TypeClassType = ConsK[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = ConsK[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = ConsK[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/Empty.scala b/alleycats-core/src/main/scala/alleycats/Empty.scala
index 98574e8d7..698e49b4f 100644
--- a/alleycats-core/src/main/scala/alleycats/Empty.scala
+++ b/alleycats-core/src/main/scala/alleycats/Empty.scala
@@ -26,13 +26,12 @@ object Empty extends EmptyInstances0 {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Empty]] for `A`.
    */
   @inline def apply[A](implicit instance: Empty[A]): Empty[A] = instance
 
-  trait Ops[A] extends Serializable {
+  trait Ops[A] {
     type TypeClassType <: Empty[A]
     def self: A
     val typeClassInstance: TypeClassType
@@ -40,26 +39,24 @@ object Empty extends EmptyInstances0 {
     def nonEmpty(implicit ev: Eq[A]): Boolean = typeClassInstance.nonEmpty(self)(ev)
   }
   trait AllOps[A] extends Ops[A]
-  trait ToEmptyOps extends Serializable {
+  trait ToEmptyOps {
     implicit def toEmptyOps[A](target: A)(implicit tc: Empty[A]): Ops[A] {
       type TypeClassType = Empty[A]
-    } =
-      new Ops[A] {
-        type TypeClassType = Empty[A]
-        val self: A = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[A] {
+      type TypeClassType = Empty[A]
+      val self: A = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToEmptyOps
   object ops {
     implicit def toAllEmptyOps[A](target: A)(implicit tc: Empty[A]): AllOps[A] {
       type TypeClassType = Empty[A]
-    } =
-      new AllOps[A] {
-        type TypeClassType = Empty[A]
-        val self: A = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[A] {
+      type TypeClassType = Empty[A]
+      val self: A = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/EmptyK.scala b/alleycats-core/src/main/scala/alleycats/EmptyK.scala
index cb6cf64b5..2a809b9c7 100644
--- a/alleycats-core/src/main/scala/alleycats/EmptyK.scala
+++ b/alleycats-core/src/main/scala/alleycats/EmptyK.scala
@@ -18,38 +18,35 @@ object EmptyK {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[EmptyK]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: EmptyK[F]): EmptyK[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: EmptyK[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToEmptyKOps extends Serializable {
+  trait ToEmptyKOps {
     implicit def toEmptyKOps[F[_], A](target: F[A])(implicit tc: EmptyK[F]): Ops[F, A] {
       type TypeClassType = EmptyK[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = EmptyK[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = EmptyK[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToEmptyKOps
   object ops {
     implicit def toAllEmptyKOps[F[_], A](target: F[A])(implicit tc: EmptyK[F]): AllOps[F, A] {
       type TypeClassType = EmptyK[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = EmptyK[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = EmptyK[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/Extract.scala b/alleycats-core/src/main/scala/alleycats/Extract.scala
index 3b979e0c0..808ae6050 100644
--- a/alleycats-core/src/main/scala/alleycats/Extract.scala
+++ b/alleycats-core/src/main/scala/alleycats/Extract.scala
@@ -28,39 +28,36 @@ object Extract {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Extract]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Extract[F]): Extract[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Extract[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
     def extract: A = typeClassInstance.extract[A](self)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToExtractOps extends Serializable {
+  trait ToExtractOps {
     implicit def toExtractOps[F[_], A](target: F[A])(implicit tc: Extract[F]): Ops[F, A] {
       type TypeClassType = Extract[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Extract[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Extract[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToExtractOps
   object ops {
     implicit def toAllExtractOps[F[_], A](target: F[A])(implicit tc: Extract[F]): AllOps[F, A] {
       type TypeClassType = Extract[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Extract[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Extract[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/One.scala b/alleycats-core/src/main/scala/alleycats/One.scala
index 8adba537e..a70d39ae6 100644
--- a/alleycats-core/src/main/scala/alleycats/One.scala
+++ b/alleycats-core/src/main/scala/alleycats/One.scala
@@ -23,13 +23,12 @@ object One {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[One]] for `A`.
    */
   @inline def apply[A](implicit instance: One[A]): One[A] = instance
 
-  trait Ops[A] extends Serializable {
+  trait Ops[A] {
     type TypeClassType <: One[A]
     def self: A
     val typeClassInstance: TypeClassType
@@ -37,26 +36,24 @@ object One {
     def nonOne(implicit ev: Eq[A]): Boolean = typeClassInstance.nonOne(self)(ev)
   }
   trait AllOps[A] extends Ops[A]
-  trait ToOneOps extends Serializable {
+  trait ToOneOps {
     implicit def toOneOps[A](target: A)(implicit tc: One[A]): Ops[A] {
       type TypeClassType = One[A]
-    } =
-      new Ops[A] {
-        type TypeClassType = One[A]
-        val self: A = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[A] {
+      type TypeClassType = One[A]
+      val self: A = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToOneOps
   object ops {
     implicit def toAllOneOps[A](target: A)(implicit tc: One[A]): AllOps[A] {
       type TypeClassType = One[A]
-    } =
-      new AllOps[A] {
-        type TypeClassType = One[A]
-        val self: A = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[A] {
+      type TypeClassType = One[A]
+      val self: A = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/Pure.scala b/alleycats-core/src/main/scala/alleycats/Pure.scala
index 1005ce92e..cb96acbdc 100644
--- a/alleycats-core/src/main/scala/alleycats/Pure.scala
+++ b/alleycats-core/src/main/scala/alleycats/Pure.scala
@@ -28,38 +28,35 @@ object Pure {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Pure]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Pure[F]): Pure[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Pure[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToPureOps extends Serializable {
+  trait ToPureOps {
     implicit def toPureOps[F[_], A](target: F[A])(implicit tc: Pure[F]): Ops[F, A] {
       type TypeClassType = Pure[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Pure[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Pure[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToPureOps
   object ops {
     implicit def toAllPureOps[F[_], A](target: F[A])(implicit tc: Pure[F]): AllOps[F, A] {
       type TypeClassType = Pure[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Pure[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Pure[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/Zero.scala b/alleycats-core/src/main/scala/alleycats/Zero.scala
index e59a60ec3..80c993c5b 100644
--- a/alleycats-core/src/main/scala/alleycats/Zero.scala
+++ b/alleycats-core/src/main/scala/alleycats/Zero.scala
@@ -24,13 +24,12 @@ object Zero {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Zero]] for `A`.
    */
   @inline def apply[A](implicit instance: Zero[A]): Zero[A] = instance
 
-  trait Ops[A] extends Serializable {
+  trait Ops[A] {
     type TypeClassType <: Zero[A]
     def self: A
     val typeClassInstance: TypeClassType
@@ -38,26 +37,24 @@ object Zero {
     def nonZero(implicit ev: Eq[A]): Boolean = typeClassInstance.nonZero(self)(ev)
   }
   trait AllOps[A] extends Ops[A]
-  trait ToZeroOps extends Serializable {
+  trait ToZeroOps {
     implicit def toZeroOps[A](target: A)(implicit tc: Zero[A]): Ops[A] {
       type TypeClassType = Zero[A]
-    } =
-      new Ops[A] {
-        type TypeClassType = Zero[A]
-        val self: A = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[A] {
+      type TypeClassType = Zero[A]
+      val self: A = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToZeroOps
   object ops {
     implicit def toAllZeroOps[A](target: A)(implicit tc: Zero[A]): AllOps[A] {
       type TypeClassType = Zero[A]
-    } =
-      new AllOps[A] {
-        type TypeClassType = Zero[A]
-        val self: A = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[A] {
+      type TypeClassType = Zero[A]
+      val self: A = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/alleycats-laws/src/main/scala/alleycats/laws/discipline/FlatMapRecTests.scala b/alleycats-laws/src/main/scala/alleycats/laws/discipline/FlatMapRecTests.scala
index a34a5f561..9c4a34ef6 100644
--- a/alleycats-laws/src/main/scala/alleycats/laws/discipline/FlatMapRecTests.scala
+++ b/alleycats-laws/src/main/scala/alleycats/laws/discipline/FlatMapRecTests.scala
@@ -10,7 +10,10 @@ import org.typelevel.discipline.Laws
 trait FlatMapRecTests[F[_]] extends Laws {
   def laws: FlatMapLaws[F]
 
-  def tailRecM[A: Arbitrary](implicit ArbFA: Arbitrary[F[A]], ArbAFA: Arbitrary[A => F[A]], EqFA: Eq[F[A]]): RuleSet =
+  def tailRecM[A: Arbitrary](implicit
+                             ArbFA: Arbitrary[F[A]],
+                             ArbAFA: Arbitrary[A => F[A]],
+                             EqFA: Eq[F[A]]): RuleSet =
     new DefaultRuleSet(
       name = "flatMapTailRec",
       parent = None,
diff --git a/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala b/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
index 211c39f61..e43b11f7c 100644
--- a/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
+++ b/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
@@ -12,8 +12,8 @@ trait ParallelInstances extends ParallelInstances1 {
     cats.instances.either.catsParallelForEitherAndValidated[E]
 
   @deprecated("Use OptionT.catsDataParallelForOptionT", "2.0.0")
-  def catsParallelForOptionTNestedOption[M[_]](implicit
-    P: Parallel[M]
+  def catsParallelForOptionTNestedOption[M[_]](
+    implicit P: Parallel[M]
   ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = OptionT.catsDataParallelForOptionT[M]
 
   @deprecated("Use cats.instances.list.catsStdNonEmptyParallelForListZipList", "2.1.0")
@@ -29,8 +29,8 @@ trait ParallelInstances extends ParallelInstances1 {
     cats.instances.stream.catsStdParallelForStreamZipStream
 
   @deprecated("Use EitherT.catsDataParallelForEitherTWithParallelEffect", "2.0.0")
-  def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](implicit
-    P: Parallel[M]
+  def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](
+    implicit P: Parallel[M]
   ): Parallel.Aux[EitherT[M, E, *], Nested[P.F, Validated[E, *], *]] =
     EitherT.catsDataParallelForEitherTWithParallelEffect[M, E]
 }
diff --git a/core/src/main/scala-2.12/cats/instances/stream.scala b/core/src/main/scala-2.12/cats/instances/stream.scala
index 7927e16cb..eef109e1c 100644
--- a/core/src/main/scala-2.12/cats/instances/stream.scala
+++ b/core/src/main/scala-2.12/cats/instances/stream.scala
@@ -68,39 +68,36 @@ trait StreamInstances extends cats.kernel.instances.StreamInstances {
           var state: Either[Unit, Option[B]] = Left(())
 
           @tailrec
-          def advance(): Unit =
-            stack match {
-              case Right(b) #:: tail =>
-                stack = tail
-                state = Right(Some(b))
-              case Left(a) #:: tail =>
-                stack = fn(a) #::: tail
-                advance()
-              case empty =>
-                state = Right(None)
-            }
+          def advance(): Unit = stack match {
+            case Right(b) #:: tail =>
+              stack = tail
+              state = Right(Some(b))
+            case Left(a) #:: tail =>
+              stack = fn(a) #::: tail
+              advance()
+            case empty =>
+              state = Right(None)
+          }
 
           @tailrec
-          def hasNext: Boolean =
-            state match {
-              case Left(()) =>
-                advance()
-                hasNext
-              case Right(o) =>
-                o.isDefined
-            }
+          def hasNext: Boolean = state match {
+            case Left(()) =>
+              advance()
+              hasNext
+            case Right(o) =>
+              o.isDefined
+          }
 
           @tailrec
-          def next(): B =
-            state match {
-              case Left(()) =>
-                advance()
-                next()
-              case Right(o) =>
-                val b = o.get
-                advance()
-                b
-            }
+          def next(): B = state match {
+            case Left(()) =>
+              advance()
+              next()
+            case Right(o) =>
+              val b = o.get
+              advance()
+              b
+          }
         }
 
         it.toStream
diff --git a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
index d7a9b8d14..3ccfdb301 100644
--- a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
+++ b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
@@ -498,9 +498,8 @@ sealed abstract private[data] class NonEmptyLazyListInstances extends NonEmptyLa
       def align[A, B](fa: NonEmptyLazyList[A], fb: NonEmptyLazyList[B]): NonEmptyLazyList[Ior[A, B]] =
         alignInstance.align(fa, fb)
 
-      override def alignWith[A, B, C](fa: NonEmptyLazyList[A], fb: NonEmptyLazyList[B])(
-        f: Ior[A, B] => C
-      ): NonEmptyLazyList[C] =
+      override def alignWith[A, B, C](fa: NonEmptyLazyList[A],
+                                      fb: NonEmptyLazyList[B])(f: Ior[A, B] => C): NonEmptyLazyList[C] =
         alignInstance.alignWith(fa, fb)(f)
     }
 
diff --git a/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala b/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
index c3ee09061..f3c16fcaa 100644
--- a/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
+++ b/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
@@ -13,8 +13,8 @@ trait ParallelInstances extends ParallelInstances1 {
     cats.instances.either.catsParallelForEitherAndValidated[E]
 
   @deprecated("Use OptionT.catsDataParallelForOptionT", "2.0.0")
-  def catsParallelForOptionTNestedOption[M[_]](implicit
-    P: Parallel[M]
+  def catsParallelForOptionTNestedOption[M[_]](
+    implicit P: Parallel[M]
   ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = OptionT.catsDataParallelForOptionT[M]
 
   @deprecated("Use cats.instances.list.catsStdNonEmptyParallelForListZipList", "2.1.0")
@@ -34,8 +34,8 @@ trait ParallelInstances extends ParallelInstances1 {
     cats.instances.lazyList.catsStdParallelForLazyListZipLazyList[A]
 
   @deprecated("Use EitherT.catsDataParallelForEitherTWithParallelEffect", "2.0.0")
-  def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](implicit
-    P: Parallel[M]
+  def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](
+    implicit P: Parallel[M]
   ): Parallel.Aux[EitherT[M, E, *], Nested[P.F, Validated[E, *], *]] =
     EitherT.catsDataParallelForEitherTWithParallelEffect[M, E]
 }
diff --git a/core/src/main/scala-2.13+/cats/instances/stream.scala b/core/src/main/scala-2.13+/cats/instances/stream.scala
index 8f8137296..14de524ec 100644
--- a/core/src/main/scala-2.13+/cats/instances/stream.scala
+++ b/core/src/main/scala-2.13+/cats/instances/stream.scala
@@ -69,39 +69,36 @@ trait StreamInstances extends cats.kernel.instances.StreamInstances {
           var state: Either[Unit, Option[B]] = Left(())
 
           @tailrec
-          def advance(): Unit =
-            stack match {
-              case Right(b) #:: tail =>
-                stack = tail
-                state = Right(Some(b))
-              case Left(a) #:: tail =>
-                stack = fn(a) #::: tail
-                advance()
-              case empty =>
-                state = Right(None)
-            }
+          def advance(): Unit = stack match {
+            case Right(b) #:: tail =>
+              stack = tail
+              state = Right(Some(b))
+            case Left(a) #:: tail =>
+              stack = fn(a) #::: tail
+              advance()
+            case empty =>
+              state = Right(None)
+          }
 
           @tailrec
-          def hasNext: Boolean =
-            state match {
-              case Left(()) =>
-                advance()
-                hasNext
-              case Right(o) =>
-                o.isDefined
-            }
+          def hasNext: Boolean = state match {
+            case Left(()) =>
+              advance()
+              hasNext
+            case Right(o) =>
+              o.isDefined
+          }
 
           @tailrec
-          def next(): B =
-            state match {
-              case Left(()) =>
-                advance()
-                next()
-              case Right(o) =>
-                val b = o.get
-                advance()
-                b
-            }
+          def next(): B = state match {
+            case Left(()) =>
+              advance()
+              next()
+            case Right(o) =>
+              val b = o.get
+              advance()
+              b
+          }
         }
 
         it.toStream
diff --git a/core/src/main/scala/cats/Align.scala b/core/src/main/scala/cats/Align.scala
index 794eab420..0cf05c9f5 100644
--- a/core/src/main/scala/cats/Align.scala
+++ b/core/src/main/scala/cats/Align.scala
@@ -104,10 +104,9 @@ import scala.annotation.implicitNotFound
 }
 
 object Align extends ScalaVersionSpecificAlignInstances {
-  def semigroup[F[_], A](implicit F: Align[F], A: Semigroup[A]): Semigroup[F[A]] =
-    new Semigroup[F[A]] {
-      def combine(x: F[A], y: F[A]): F[A] = Align[F].alignCombine(x, y)
-    }
+  def semigroup[F[_], A](implicit F: Align[F], A: Semigroup[A]): Semigroup[F[A]] = new Semigroup[F[A]] {
+    def combine(x: F[A], y: F[A]): F[A] = Align[F].alignCombine(x, y)
+  }
 
   implicit def catsAlignForList: Align[List] = cats.instances.list.catsStdInstancesForList
   implicit def catsAlignForOption: Align[Option] = cats.instances.option.catsStdInstancesForOption
@@ -133,13 +132,12 @@ object Align extends ScalaVersionSpecificAlignInstances {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Align]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Align[F]): Align[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Align[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -152,26 +150,24 @@ object Align extends ScalaVersionSpecificAlignInstances {
     def zipAll[B](fb: F[B], a: A, b: B): F[(A, B)] = typeClassInstance.zipAll[A, B](self, fb, a, b)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToAlignOps extends Serializable {
+  trait ToAlignOps {
     implicit def toAlignOps[F[_], A](target: F[A])(implicit tc: Align[F]): Ops[F, A] {
       type TypeClassType = Align[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Align[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Align[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToAlignOps
   object ops {
     implicit def toAllAlignOps[F[_], A](target: F[A])(implicit tc: Align[F]): AllOps[F, A] {
       type TypeClassType = Align[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Align[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Align[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Alternative.scala b/core/src/main/scala/cats/Alternative.scala
index 388e1fc72..3068c9fbd 100644
--- a/core/src/main/scala/cats/Alternative.scala
+++ b/core/src/main/scala/cats/Alternative.scala
@@ -95,13 +95,12 @@ object Alternative {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Alternative]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Alternative[F]): Alternative[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Alternative[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -115,26 +114,24 @@ object Alternative {
   trait AllOps[F[_], A] extends Ops[F, A] with Applicative.AllOps[F, A] with MonoidK.AllOps[F, A] {
     type TypeClassType <: Alternative[F]
   }
-  trait ToAlternativeOps extends Serializable {
+  trait ToAlternativeOps {
     implicit def toAlternativeOps[F[_], A](target: F[A])(implicit tc: Alternative[F]): Ops[F, A] {
       type TypeClassType = Alternative[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Alternative[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Alternative[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToAlternativeOps
   object ops {
     implicit def toAllAlternativeOps[F[_], A](target: F[A])(implicit tc: Alternative[F]): AllOps[F, A] {
       type TypeClassType = Alternative[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Alternative[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Alternative[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Applicative.scala b/core/src/main/scala/cats/Applicative.scala
index 578159b15..9501c676e 100644
--- a/core/src/main/scala/cats/Applicative.scala
+++ b/core/src/main/scala/cats/Applicative.scala
@@ -233,13 +233,12 @@ object Applicative {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Applicative]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Applicative[F]): Applicative[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Applicative[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -247,26 +246,24 @@ object Applicative {
   trait AllOps[F[_], A] extends Ops[F, A] with Apply.AllOps[F, A] with InvariantMonoidal.AllOps[F, A] {
     type TypeClassType <: Applicative[F]
   }
-  trait ToApplicativeOps extends Serializable {
+  trait ToApplicativeOps {
     implicit def toApplicativeOps[F[_], A](target: F[A])(implicit tc: Applicative[F]): Ops[F, A] {
       type TypeClassType = Applicative[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Applicative[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Applicative[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToApplicativeOps
   object ops {
     implicit def toAllApplicativeOps[F[_], A](target: F[A])(implicit tc: Applicative[F]): AllOps[F, A] {
       type TypeClassType = Applicative[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Applicative[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Applicative[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Apply.scala b/core/src/main/scala/cats/Apply.scala
index e92d9e66e..db0f042d7 100644
--- a/core/src/main/scala/cats/Apply.scala
+++ b/core/src/main/scala/cats/Apply.scala
@@ -261,22 +261,20 @@ object Apply {
   def semigroup[F[_], A](implicit f: Apply[F], sg: Semigroup[A]): Semigroup[F[A]] =
     new ApplySemigroup[F, A](f, sg)
 
-  def align[F[_]: Apply]: Align[F] =
-    new Align[F] {
-      def align[A, B](fa: F[A], fb: F[B]): F[Ior[A, B]] = Apply[F].map2(fa, fb)(Ior.both)
-      def functor: Functor[F] = Apply[F]
-    }
+  def align[F[_]: Apply]: Align[F] = new Align[F] {
+    def align[A, B](fa: F[A], fb: F[B]): F[Ior[A, B]] = Apply[F].map2(fa, fb)(Ior.both)
+    def functor: Functor[F] = Apply[F]
+  }
 
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Apply]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Apply[F]): Apply[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Apply[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -296,26 +294,24 @@ object Apply {
   trait AllOps[F[_], A] extends Ops[F, A] with Functor.AllOps[F, A] with InvariantSemigroupal.AllOps[F, A] {
     type TypeClassType <: Apply[F]
   }
-  trait ToApplyOps extends Serializable {
+  trait ToApplyOps {
     implicit def toApplyOps[F[_], A](target: F[A])(implicit tc: Apply[F]): Ops[F, A] {
       type TypeClassType = Apply[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Apply[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Apply[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToApplyOps
   object ops {
     implicit def toAllApplyOps[F[_], A](target: F[A])(implicit tc: Apply[F]): AllOps[F, A] {
       type TypeClassType = Apply[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Apply[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Apply[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Bifoldable.scala b/core/src/main/scala/cats/Bifoldable.scala
index 105df3ddc..528a49f18 100644
--- a/core/src/main/scala/cats/Bifoldable.scala
+++ b/core/src/main/scala/cats/Bifoldable.scala
@@ -41,13 +41,12 @@ object Bifoldable {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Bifoldable]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Bifoldable[F]): Bifoldable[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: Bifoldable[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -59,26 +58,24 @@ object Bifoldable {
     def bifold(implicit A: Monoid[A], B: Monoid[B]): (A, B) = typeClassInstance.bifold[A, B](self)(A, B)
   }
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B]
-  trait ToBifoldableOps extends Serializable {
+  trait ToBifoldableOps {
     implicit def toBifoldableOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bifoldable[F]): Ops[F, A, B] {
       type TypeClassType = Bifoldable[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = Bifoldable[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = Bifoldable[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToBifoldableOps
   object ops {
     implicit def toAllBifoldableOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bifoldable[F]): AllOps[F, A, B] {
       type TypeClassType = Bifoldable[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = Bifoldable[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = Bifoldable[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
@@ -97,9 +94,8 @@ private[cats] trait ComposedBifoldable[F[_, _], G[_, _]] extends Bifoldable[Î»[(
       (c: C, gab: G[A, B]) => G.bifoldLeft(gab, c)(f, g)
     )
 
-  override def bifoldRight[A, B, C](fab: F[G[A, B], G[A, B]],
-                                    c: Eval[C]
-  )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
+  override def bifoldRight[A, B, C](fab: F[G[A, B], G[A, B]], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
+                                                                          g: (B, Eval[C]) => Eval[C]): Eval[C] =
     F.bifoldRight(fab, c)(
       (gab: G[A, B], c: Eval[C]) => G.bifoldRight(gab, c)(f, g),
       (gab: G[A, B], c: Eval[C]) => G.bifoldRight(gab, c)(f, g)
diff --git a/core/src/main/scala/cats/Bifunctor.scala b/core/src/main/scala/cats/Bifunctor.scala
index d613a512c..83f1e54c1 100644
--- a/core/src/main/scala/cats/Bifunctor.scala
+++ b/core/src/main/scala/cats/Bifunctor.scala
@@ -64,13 +64,12 @@ object Bifunctor {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Bifunctor]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Bifunctor[F]): Bifunctor[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: Bifunctor[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -79,26 +78,24 @@ object Bifunctor {
     def leftWiden[C >: A]: F[C, B] = typeClassInstance.leftWiden[A, B, C](self)
   }
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B]
-  trait ToBifunctorOps extends Serializable {
+  trait ToBifunctorOps {
     implicit def toBifunctorOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bifunctor[F]): Ops[F, A, B] {
       type TypeClassType = Bifunctor[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = Bifunctor[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = Bifunctor[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToBifunctorOps
   object ops {
     implicit def toAllBifunctorOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bifunctor[F]): AllOps[F, A, B] {
       type TypeClassType = Bifunctor[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = Bifunctor[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = Bifunctor[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Bimonad.scala b/core/src/main/scala/cats/Bimonad.scala
index 9f40732de..b41df55c5 100644
--- a/core/src/main/scala/cats/Bimonad.scala
+++ b/core/src/main/scala/cats/Bimonad.scala
@@ -11,13 +11,12 @@ object Bimonad {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Bimonad]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Bimonad[F]): Bimonad[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Bimonad[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -25,26 +24,24 @@ object Bimonad {
   trait AllOps[F[_], A] extends Ops[F, A] with Monad.AllOps[F, A] with Comonad.AllOps[F, A] {
     type TypeClassType <: Bimonad[F]
   }
-  trait ToBimonadOps extends Serializable {
+  trait ToBimonadOps {
     implicit def toBimonadOps[F[_], A](target: F[A])(implicit tc: Bimonad[F]): Ops[F, A] {
       type TypeClassType = Bimonad[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Bimonad[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Bimonad[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToBimonadOps
   object ops {
     implicit def toAllBimonadOps[F[_], A](target: F[A])(implicit tc: Bimonad[F]): AllOps[F, A] {
       type TypeClassType = Bimonad[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Bimonad[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Bimonad[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Bitraverse.scala b/core/src/main/scala/cats/Bitraverse.scala
index 630a059af..5eda74313 100644
--- a/core/src/main/scala/cats/Bitraverse.scala
+++ b/core/src/main/scala/cats/Bitraverse.scala
@@ -116,13 +116,12 @@ object Bitraverse {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Bitraverse]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Bitraverse[F]): Bitraverse[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: Bitraverse[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -134,26 +133,24 @@ object Bitraverse {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Bifoldable.AllOps[F, A, B] with Bifunctor.AllOps[F, A, B] {
     type TypeClassType <: Bitraverse[F]
   }
-  trait ToBitraverseOps extends Serializable {
+  trait ToBitraverseOps {
     implicit def toBitraverseOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bitraverse[F]): Ops[F, A, B] {
       type TypeClassType = Bitraverse[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = Bitraverse[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = Bitraverse[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToBitraverseOps
   object ops {
     implicit def toAllBitraverseOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bitraverse[F]): AllOps[F, A, B] {
       type TypeClassType = Bitraverse[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = Bitraverse[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = Bitraverse[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CoflatMap.scala b/core/src/main/scala/cats/CoflatMap.scala
index 653cc0c39..59645bac7 100644
--- a/core/src/main/scala/cats/CoflatMap.scala
+++ b/core/src/main/scala/cats/CoflatMap.scala
@@ -53,13 +53,12 @@ object CoflatMap {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[CoflatMap]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CoflatMap[F]): CoflatMap[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: CoflatMap[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -69,26 +68,24 @@ object CoflatMap {
   trait AllOps[F[_], A] extends Ops[F, A] with Functor.AllOps[F, A] {
     type TypeClassType <: CoflatMap[F]
   }
-  trait ToCoflatMapOps extends Serializable {
+  trait ToCoflatMapOps {
     implicit def toCoflatMapOps[F[_], A](target: F[A])(implicit tc: CoflatMap[F]): Ops[F, A] {
       type TypeClassType = CoflatMap[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = CoflatMap[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = CoflatMap[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToCoflatMapOps
   object ops {
     implicit def toAllCoflatMapOps[F[_], A](target: F[A])(implicit tc: CoflatMap[F]): AllOps[F, A] {
       type TypeClassType = CoflatMap[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = CoflatMap[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = CoflatMap[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CommutativeApplicative.scala b/core/src/main/scala/cats/CommutativeApplicative.scala
index 57bb502c0..26bc936ec 100644
--- a/core/src/main/scala/cats/CommutativeApplicative.scala
+++ b/core/src/main/scala/cats/CommutativeApplicative.scala
@@ -31,13 +31,12 @@ object CommutativeApplicative {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[CommutativeApplicative]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CommutativeApplicative[F]): CommutativeApplicative[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: CommutativeApplicative[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -45,15 +44,14 @@ object CommutativeApplicative {
   trait AllOps[F[_], A] extends Ops[F, A] with Applicative.AllOps[F, A] with CommutativeApply.AllOps[F, A] {
     type TypeClassType <: CommutativeApplicative[F]
   }
-  trait ToCommutativeApplicativeOps extends Serializable {
+  trait ToCommutativeApplicativeOps {
     implicit def toCommutativeApplicativeOps[F[_], A](target: F[A])(implicit tc: CommutativeApplicative[F]): Ops[F, A] {
       type TypeClassType = CommutativeApplicative[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = CommutativeApplicative[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = CommutativeApplicative[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToCommutativeApplicativeOps
   object ops {
@@ -61,12 +59,11 @@ object CommutativeApplicative {
       target: F[A]
     )(implicit tc: CommutativeApplicative[F]): AllOps[F, A] {
       type TypeClassType = CommutativeApplicative[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = CommutativeApplicative[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = CommutativeApplicative[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CommutativeApply.scala b/core/src/main/scala/cats/CommutativeApply.scala
index 9c27cbc1f..65a30e905 100644
--- a/core/src/main/scala/cats/CommutativeApply.scala
+++ b/core/src/main/scala/cats/CommutativeApply.scala
@@ -27,13 +27,12 @@ object CommutativeApply {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[CommutativeApply]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CommutativeApply[F]): CommutativeApply[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: CommutativeApply[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -41,26 +40,24 @@ object CommutativeApply {
   trait AllOps[F[_], A] extends Ops[F, A] with Apply.AllOps[F, A] {
     type TypeClassType <: CommutativeApply[F]
   }
-  trait ToCommutativeApplyOps extends Serializable {
+  trait ToCommutativeApplyOps {
     implicit def toCommutativeApplyOps[F[_], A](target: F[A])(implicit tc: CommutativeApply[F]): Ops[F, A] {
       type TypeClassType = CommutativeApply[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = CommutativeApply[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = CommutativeApply[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToCommutativeApplyOps
   object ops {
     implicit def toAllCommutativeApplyOps[F[_], A](target: F[A])(implicit tc: CommutativeApply[F]): AllOps[F, A] {
       type TypeClassType = CommutativeApply[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = CommutativeApply[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = CommutativeApply[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CommutativeFlatMap.scala b/core/src/main/scala/cats/CommutativeFlatMap.scala
index d595bcd8c..860054dc4 100644
--- a/core/src/main/scala/cats/CommutativeFlatMap.scala
+++ b/core/src/main/scala/cats/CommutativeFlatMap.scala
@@ -20,13 +20,12 @@ object CommutativeFlatMap {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[CommutativeFlatMap]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CommutativeFlatMap[F]): CommutativeFlatMap[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: CommutativeFlatMap[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -34,26 +33,24 @@ object CommutativeFlatMap {
   trait AllOps[F[_], A] extends Ops[F, A] with FlatMap.AllOps[F, A] with CommutativeApply.AllOps[F, A] {
     type TypeClassType <: CommutativeFlatMap[F]
   }
-  trait ToCommutativeFlatMapOps extends Serializable {
+  trait ToCommutativeFlatMapOps {
     implicit def toCommutativeFlatMapOps[F[_], A](target: F[A])(implicit tc: CommutativeFlatMap[F]): Ops[F, A] {
       type TypeClassType = CommutativeFlatMap[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = CommutativeFlatMap[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = CommutativeFlatMap[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToCommutativeFlatMapOps
   object ops {
     implicit def toAllCommutativeFlatMapOps[F[_], A](target: F[A])(implicit tc: CommutativeFlatMap[F]): AllOps[F, A] {
       type TypeClassType = CommutativeFlatMap[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = CommutativeFlatMap[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = CommutativeFlatMap[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CommutativeMonad.scala b/core/src/main/scala/cats/CommutativeMonad.scala
index 301b641f3..8e3258d05 100644
--- a/core/src/main/scala/cats/CommutativeMonad.scala
+++ b/core/src/main/scala/cats/CommutativeMonad.scala
@@ -20,13 +20,12 @@ object CommutativeMonad {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[CommutativeMonad]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CommutativeMonad[F]): CommutativeMonad[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: CommutativeMonad[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -38,26 +37,24 @@ object CommutativeMonad {
       with CommutativeApplicative.AllOps[F, A] {
     type TypeClassType <: CommutativeMonad[F]
   }
-  trait ToCommutativeMonadOps extends Serializable {
+  trait ToCommutativeMonadOps {
     implicit def toCommutativeMonadOps[F[_], A](target: F[A])(implicit tc: CommutativeMonad[F]): Ops[F, A] {
       type TypeClassType = CommutativeMonad[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = CommutativeMonad[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = CommutativeMonad[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToCommutativeMonadOps
   object ops {
     implicit def toAllCommutativeMonadOps[F[_], A](target: F[A])(implicit tc: CommutativeMonad[F]): AllOps[F, A] {
       type TypeClassType = CommutativeMonad[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = CommutativeMonad[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = CommutativeMonad[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Comonad.scala b/core/src/main/scala/cats/Comonad.scala
index 6ac0323ac..df2ed898b 100644
--- a/core/src/main/scala/cats/Comonad.scala
+++ b/core/src/main/scala/cats/Comonad.scala
@@ -35,13 +35,12 @@ object Comonad {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Comonad]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Comonad[F]): Comonad[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Comonad[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -50,26 +49,24 @@ object Comonad {
   trait AllOps[F[_], A] extends Ops[F, A] with CoflatMap.AllOps[F, A] {
     type TypeClassType <: Comonad[F]
   }
-  trait ToComonadOps extends Serializable {
+  trait ToComonadOps {
     implicit def toComonadOps[F[_], A](target: F[A])(implicit tc: Comonad[F]): Ops[F, A] {
       type TypeClassType = Comonad[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Comonad[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Comonad[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToComonadOps
   object ops {
     implicit def toAllComonadOps[F[_], A](target: F[A])(implicit tc: Comonad[F]): AllOps[F, A] {
       type TypeClassType = Comonad[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Comonad[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Comonad[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Composed.scala b/core/src/main/scala/cats/Composed.scala
index 730619f52..ec3b4f22d 100644
--- a/core/src/main/scala/cats/Composed.scala
+++ b/core/src/main/scala/cats/Composed.scala
@@ -50,8 +50,7 @@ private[cats] trait ComposedSemigroupK[F[_], G[_]] extends SemigroupK[Î»[Î± => F
   override def combineK[A](x: F[G[A]], y: F[G[A]]): F[G[A]] = F.combineK(x, y)
 }
 
-private[cats] trait ComposedMonoidK[F[_], G[_]] extends MonoidK[Î»[Î± => F[G[Î±]]]] with ComposedSemigroupK[F, G] {
-  outer =>
+private[cats] trait ComposedMonoidK[F[_], G[_]] extends MonoidK[Î»[Î± => F[G[Î±]]]] with ComposedSemigroupK[F, G] { outer =>
   def F: MonoidK[F]
 
   override def empty[A]: F[G[A]] = F.empty
@@ -97,8 +96,7 @@ private[cats] trait ComposedNonEmptyTraverse[F[_], G[_]]
     F.nonEmptyTraverse(fga)(ga => G.nonEmptyTraverse(ga)(f))
 }
 
-private[cats] trait ComposedReducible[F[_], G[_]] extends Reducible[Î»[Î± => F[G[Î±]]]] with ComposedFoldable[F, G] {
-  outer =>
+private[cats] trait ComposedReducible[F[_], G[_]] extends Reducible[Î»[Î± => F[G[Î±]]]] with ComposedFoldable[F, G] { outer =>
   def F: Reducible[F]
   def G: Reducible[G]
 
diff --git a/core/src/main/scala/cats/Contravariant.scala b/core/src/main/scala/cats/Contravariant.scala
index 2734d6581..14c431836 100644
--- a/core/src/main/scala/cats/Contravariant.scala
+++ b/core/src/main/scala/cats/Contravariant.scala
@@ -36,13 +36,12 @@ object Contravariant {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Contravariant]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Contravariant[F]): Contravariant[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Contravariant[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -52,26 +51,24 @@ object Contravariant {
   trait AllOps[F[_], A] extends Ops[F, A] with Invariant.AllOps[F, A] {
     type TypeClassType <: Contravariant[F]
   }
-  trait ToContravariantOps extends Serializable {
+  trait ToContravariantOps {
     implicit def toContravariantOps[F[_], A](target: F[A])(implicit tc: Contravariant[F]): Ops[F, A] {
       type TypeClassType = Contravariant[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Contravariant[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Contravariant[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToContravariantOps
   object ops {
     implicit def toAllContravariantOps[F[_], A](target: F[A])(implicit tc: Contravariant[F]): AllOps[F, A] {
       type TypeClassType = Contravariant[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Contravariant[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Contravariant[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/ContravariantMonoidal.scala b/core/src/main/scala/cats/ContravariantMonoidal.scala
index 98952f6e9..b6f6e84be 100644
--- a/core/src/main/scala/cats/ContravariantMonoidal.scala
+++ b/core/src/main/scala/cats/ContravariantMonoidal.scala
@@ -30,13 +30,12 @@ object ContravariantMonoidal extends SemigroupalArityFunctions {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[ContravariantMonoidal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: ContravariantMonoidal[F]): ContravariantMonoidal[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: ContravariantMonoidal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -47,15 +46,14 @@ object ContravariantMonoidal extends SemigroupalArityFunctions {
       with InvariantMonoidal.AllOps[F, A] {
     type TypeClassType <: ContravariantMonoidal[F]
   }
-  trait ToContravariantMonoidalOps extends Serializable {
+  trait ToContravariantMonoidalOps {
     implicit def toContravariantMonoidalOps[F[_], A](target: F[A])(implicit tc: ContravariantMonoidal[F]): Ops[F, A] {
       type TypeClassType = ContravariantMonoidal[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = ContravariantMonoidal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = ContravariantMonoidal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToContravariantMonoidalOps
   object ops {
@@ -63,12 +61,11 @@ object ContravariantMonoidal extends SemigroupalArityFunctions {
       target: F[A]
     )(implicit tc: ContravariantMonoidal[F]): AllOps[F, A] {
       type TypeClassType = ContravariantMonoidal[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = ContravariantMonoidal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = ContravariantMonoidal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/ContravariantSemigroupal.scala b/core/src/main/scala/cats/ContravariantSemigroupal.scala
index 347d79a15..b2b834ed7 100644
--- a/core/src/main/scala/cats/ContravariantSemigroupal.scala
+++ b/core/src/main/scala/cats/ContravariantSemigroupal.scala
@@ -24,13 +24,12 @@ object ContravariantSemigroupal extends SemigroupalArityFunctions {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[ContravariantSemigroupal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: ContravariantSemigroupal[F]): ContravariantSemigroupal[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: ContravariantSemigroupal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -38,17 +37,16 @@ object ContravariantSemigroupal extends SemigroupalArityFunctions {
   trait AllOps[F[_], A] extends Ops[F, A] with InvariantSemigroupal.AllOps[F, A] with Contravariant.AllOps[F, A] {
     type TypeClassType <: ContravariantSemigroupal[F]
   }
-  trait ToContravariantSemigroupalOps extends Serializable {
+  trait ToContravariantSemigroupalOps {
     implicit def toContravariantSemigroupalOps[F[_], A](
       target: F[A]
     )(implicit tc: ContravariantSemigroupal[F]): Ops[F, A] {
       type TypeClassType = ContravariantSemigroupal[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = ContravariantSemigroupal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = ContravariantSemigroupal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToContravariantSemigroupalOps
   object ops {
@@ -56,12 +54,11 @@ object ContravariantSemigroupal extends SemigroupalArityFunctions {
       target: F[A]
     )(implicit tc: ContravariantSemigroupal[F]): AllOps[F, A] {
       type TypeClassType = ContravariantSemigroupal[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = ContravariantSemigroupal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = ContravariantSemigroupal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Distributive.scala b/core/src/main/scala/cats/Distributive.scala
index 0f548e0d7..a6694acba 100644
--- a/core/src/main/scala/cats/Distributive.scala
+++ b/core/src/main/scala/cats/Distributive.scala
@@ -28,13 +28,12 @@ object Distributive {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Distributive]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Distributive[F]): Distributive[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Distributive[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -42,26 +41,24 @@ object Distributive {
   trait AllOps[F[_], A] extends Ops[F, A] with Functor.AllOps[F, A] {
     type TypeClassType <: Distributive[F]
   }
-  trait ToDistributiveOps extends Serializable {
+  trait ToDistributiveOps {
     implicit def toDistributiveOps[F[_], A](target: F[A])(implicit tc: Distributive[F]): Ops[F, A] {
       type TypeClassType = Distributive[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Distributive[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Distributive[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToDistributiveOps
   object ops {
     implicit def toAllDistributiveOps[F[_], A](target: F[A])(implicit tc: Distributive[F]): AllOps[F, A] {
       type TypeClassType = Distributive[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Distributive[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Distributive[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/FlatMap.scala b/core/src/main/scala/cats/FlatMap.scala
index fbb49c643..28ecb7ae5 100644
--- a/core/src/main/scala/cats/FlatMap.scala
+++ b/core/src/main/scala/cats/FlatMap.scala
@@ -205,13 +205,12 @@ object FlatMap {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[FlatMap]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: FlatMap[F]): FlatMap[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: FlatMap[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -225,26 +224,24 @@ object FlatMap {
   trait AllOps[F[_], A] extends Ops[F, A] with Apply.AllOps[F, A] {
     type TypeClassType <: FlatMap[F]
   }
-  trait ToFlatMapOps extends Serializable {
+  trait ToFlatMapOps {
     implicit def toFlatMapOps[F[_], A](target: F[A])(implicit tc: FlatMap[F]): Ops[F, A] {
       type TypeClassType = FlatMap[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = FlatMap[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = FlatMap[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToFlatMapOps
   object ops {
     implicit def toAllFlatMapOps[F[_], A](target: F[A])(implicit tc: FlatMap[F]): AllOps[F, A] {
       type TypeClassType = FlatMap[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = FlatMap[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = FlatMap[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Foldable.scala b/core/src/main/scala/cats/Foldable.scala
index 0b7cddcb9..246f913d4 100644
--- a/core/src/main/scala/cats/Foldable.scala
+++ b/core/src/main/scala/cats/Foldable.scala
@@ -799,9 +799,8 @@ import scala.annotation.implicitNotFound
    * }}}
    */
   @noop
-  def partitionBifold[H[_, _], A, B, C](
-    fa: F[A]
-  )(f: A => H[B, C])(implicit A: Alternative[F], H: Bifoldable[H]): (F[B], F[C]) = {
+  def partitionBifold[H[_, _], A, B, C](fa: F[A])(f: A => H[B, C])(implicit A: Alternative[F],
+                                                                   H: Bifoldable[H]): (F[B], F[C]) = {
     import cats.instances.tuple._
 
     implicit val mb: Monoid[F[B]] = A.algebra[B]
@@ -857,9 +856,8 @@ import scala.annotation.implicitNotFound
    * }}}
    */
   @noop
-  def partitionEitherM[G[_], A, B, C](
-    fa: F[A]
-  )(f: A => G[Either[B, C]])(implicit A: Alternative[F], M: Monad[G]): G[(F[B], F[C])] = {
+  def partitionEitherM[G[_], A, B, C](fa: F[A])(f: A => G[Either[B, C]])(implicit A: Alternative[F],
+                                                                         M: Monad[G]): G[(F[B], F[C])] = {
     import cats.instances.either._
     partitionBifoldM[G, Either, A, B, C](fa)(f)(A, M, Bifoldable[Either])
   }
@@ -901,10 +899,9 @@ object Foldable {
       def uncons = None
     }
 
-    def cons[A](a: A, src: Eval[Source[A]]): Source[A] =
-      new Source[A] {
-        def uncons = Some((a, src))
-      }
+    def cons[A](a: A, src: Eval[Source[A]]): Source[A] = new Source[A] {
+      def uncons = Some((a, src))
+    }
 
     def fromFoldable[F[_], A](fa: F[A])(implicit F: Foldable[F]): Source[A] =
       F.foldRight[A, Source[A]](fa, Now(Empty))((a, evalSrc) => Later(cons(a, evalSrc))).value
@@ -913,13 +910,12 @@ object Foldable {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Foldable]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Foldable[F]): Foldable[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Foldable[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -979,26 +975,24 @@ object Foldable {
   trait AllOps[F[_], A] extends Ops[F, A] with UnorderedFoldable.AllOps[F, A] {
     type TypeClassType <: Foldable[F]
   }
-  trait ToFoldableOps extends Serializable {
+  trait ToFoldableOps {
     implicit def toFoldableOps[F[_], A](target: F[A])(implicit tc: Foldable[F]): Ops[F, A] {
       type TypeClassType = Foldable[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Foldable[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Foldable[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToFoldableOps
   object ops {
     implicit def toAllFoldableOps[F[_], A](target: F[A])(implicit tc: Foldable[F]): AllOps[F, A] {
       type TypeClassType = Foldable[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Foldable[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Foldable[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Functor.scala b/core/src/main/scala/cats/Functor.scala
index d3c04e4bb..39a3af229 100644
--- a/core/src/main/scala/cats/Functor.scala
+++ b/core/src/main/scala/cats/Functor.scala
@@ -210,13 +210,12 @@ object Functor {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Functor]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Functor[F]): Functor[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Functor[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -233,26 +232,24 @@ object Functor {
   trait AllOps[F[_], A] extends Ops[F, A] with Invariant.AllOps[F, A] {
     type TypeClassType <: Functor[F]
   }
-  trait ToFunctorOps extends Serializable {
+  trait ToFunctorOps {
     implicit def toFunctorOps[F[_], A](target: F[A])(implicit tc: Functor[F]): Ops[F, A] {
       type TypeClassType = Functor[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Functor[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Functor[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToFunctorOps
   object ops {
     implicit def toAllFunctorOps[F[_], A](target: F[A])(implicit tc: Functor[F]): AllOps[F, A] {
       type TypeClassType = Functor[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Functor[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Functor[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/FunctorFilter.scala b/core/src/main/scala/cats/FunctorFilter.scala
index 16751d534..de5ca15a3 100644
--- a/core/src/main/scala/cats/FunctorFilter.scala
+++ b/core/src/main/scala/cats/FunctorFilter.scala
@@ -94,13 +94,12 @@ object FunctorFilter extends ScalaVersionSpecificTraverseFilterInstances {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[FunctorFilter]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: FunctorFilter[F]): FunctorFilter[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: FunctorFilter[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -112,26 +111,24 @@ object FunctorFilter extends ScalaVersionSpecificTraverseFilterInstances {
     def filterNot(f: A => Boolean): F[A] = typeClassInstance.filterNot[A](self)(f)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToFunctorFilterOps extends Serializable {
+  trait ToFunctorFilterOps {
     implicit def toFunctorFilterOps[F[_], A](target: F[A])(implicit tc: FunctorFilter[F]): Ops[F, A] {
       type TypeClassType = FunctorFilter[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = FunctorFilter[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = FunctorFilter[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToFunctorFilterOps
   object ops {
     implicit def toAllFunctorFilterOps[F[_], A](target: F[A])(implicit tc: FunctorFilter[F]): AllOps[F, A] {
       type TypeClassType = FunctorFilter[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = FunctorFilter[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = FunctorFilter[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Invariant.scala b/core/src/main/scala/cats/Invariant.scala
index 09a0e0405..0f5c77b65 100644
--- a/core/src/main/scala/cats/Invariant.scala
+++ b/core/src/main/scala/cats/Invariant.scala
@@ -102,123 +102,113 @@ object Invariant extends ScalaVersionSpecificInvariantInstances with InvariantIn
 
   implicit val catsInvariantMonoid: Invariant[Monoid] = new Invariant[Monoid] {
 
-    def imap[A, B](fa: Monoid[A])(f: A => B)(g: B => A): Monoid[B] =
-      new Monoid[B] {
-        val empty = f(fa.empty)
-        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-          fa.combineAllOption(bs.iterator.map(g)).map(f)
-      }
+    def imap[A, B](fa: Monoid[A])(f: A => B)(g: B => A): Monoid[B] = new Monoid[B] {
+      val empty = f(fa.empty)
+      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.iterator.map(g)).map(f)
+    }
 
   }
 
   implicit val catsInvariantBand: Invariant[Band] = new Invariant[Band] {
 
-    def imap[A, B](fa: Band[A])(f: A => B)(g: B => A): Band[B] =
-      new Band[B] {
-        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-          fa.combineAllOption(bs.iterator.map(g)).map(f)
-      }
+    def imap[A, B](fa: Band[A])(f: A => B)(g: B => A): Band[B] = new Band[B] {
+      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.iterator.map(g)).map(f)
+    }
   }
 
   implicit val catsInvariantSemilattice: Invariant[Semilattice] = new Invariant[Semilattice] {
 
-    def imap[A, B](fa: Semilattice[A])(f: A => B)(g: B => A): Semilattice[B] =
-      new Semilattice[B] {
-        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-          fa.combineAllOption(bs.iterator.map(g)).map(f)
-      }
+    def imap[A, B](fa: Semilattice[A])(f: A => B)(g: B => A): Semilattice[B] = new Semilattice[B] {
+      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.iterator.map(g)).map(f)
+    }
 
   }
 
   implicit val catsInvariantCommutativeMonoid: Invariant[CommutativeMonoid] = new Invariant[CommutativeMonoid] {
 
-    def imap[A, B](fa: CommutativeMonoid[A])(f: A => B)(g: B => A): CommutativeMonoid[B] =
-      new CommutativeMonoid[B] {
-        val empty = f(fa.empty)
-        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-          fa.combineAllOption(bs.iterator.map(g)).map(f)
-      }
+    def imap[A, B](fa: CommutativeMonoid[A])(f: A => B)(g: B => A): CommutativeMonoid[B] = new CommutativeMonoid[B] {
+      val empty = f(fa.empty)
+      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.iterator.map(g)).map(f)
+    }
 
   }
 
   implicit val catsInvariantBoundedSemilattice: Invariant[BoundedSemilattice] = new Invariant[BoundedSemilattice] {
 
-    def imap[A, B](fa: BoundedSemilattice[A])(f: A => B)(g: B => A): BoundedSemilattice[B] =
-      new BoundedSemilattice[B] {
-        val empty = f(fa.empty)
-        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-          fa.combineAllOption(bs.iterator.map(g)).map(f)
-      }
+    def imap[A, B](fa: BoundedSemilattice[A])(f: A => B)(g: B => A): BoundedSemilattice[B] = new BoundedSemilattice[B] {
+      val empty = f(fa.empty)
+      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.iterator.map(g)).map(f)
+    }
 
   }
 
   implicit val catsInvariantGroup: Invariant[Group] = new Invariant[Group] {
 
-    def imap[A, B](fa: Group[A])(f: A => B)(g: B => A): Group[B] =
-      new Group[B] {
-        val empty = f(fa.empty)
-        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-        def inverse(b: B): B = f(fa.inverse(g(b)))
-        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-          fa.combineAllOption(bs.iterator.map(g)).map(f)
-      }
+    def imap[A, B](fa: Group[A])(f: A => B)(g: B => A): Group[B] = new Group[B] {
+      val empty = f(fa.empty)
+      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+      def inverse(b: B): B = f(fa.inverse(g(b)))
+      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.iterator.map(g)).map(f)
+    }
 
   }
 
   implicit val catsInvariantCommutativeGroup: Invariant[CommutativeGroup] = new Invariant[CommutativeGroup] {
 
-    def imap[A, B](fa: CommutativeGroup[A])(f: A => B)(g: B => A): CommutativeGroup[B] =
-      new CommutativeGroup[B] {
-        val empty = f(fa.empty)
-        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-        def inverse(b: B): B = f(fa.inverse(g(b)))
-        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-          fa.combineAllOption(bs.iterator.map(g)).map(f)
-      }
+    def imap[A, B](fa: CommutativeGroup[A])(f: A => B)(g: B => A): CommutativeGroup[B] = new CommutativeGroup[B] {
+      val empty = f(fa.empty)
+      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+      def inverse(b: B): B = f(fa.inverse(g(b)))
+      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+        fa.combineAllOption(bs.iterator.map(g)).map(f)
+    }
 
   }
 
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Invariant]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Invariant[F]): Invariant[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Invariant[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
     def imap[B](f: A => B)(g: B => A): F[B] = typeClassInstance.imap[A, B](self)(f)(g)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToInvariantOps extends Serializable {
+  trait ToInvariantOps {
     implicit def toInvariantOps[F[_], A](target: F[A])(implicit tc: Invariant[F]): Ops[F, A] {
       type TypeClassType = Invariant[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Invariant[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Invariant[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToInvariantOps
   object ops {
     implicit def toAllInvariantOps[F[_], A](target: F[A])(implicit tc: Invariant[F]): AllOps[F, A] {
       type TypeClassType = Invariant[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Invariant[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Invariant[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/InvariantMonoidal.scala b/core/src/main/scala/cats/InvariantMonoidal.scala
index 14bc382df..c4de33c58 100644
--- a/core/src/main/scala/cats/InvariantMonoidal.scala
+++ b/core/src/main/scala/cats/InvariantMonoidal.scala
@@ -39,13 +39,12 @@ object InvariantMonoidal {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[InvariantMonoidal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: InvariantMonoidal[F]): InvariantMonoidal[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: InvariantMonoidal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -53,26 +52,24 @@ object InvariantMonoidal {
   trait AllOps[F[_], A] extends Ops[F, A] with InvariantSemigroupal.AllOps[F, A] {
     type TypeClassType <: InvariantMonoidal[F]
   }
-  trait ToInvariantMonoidalOps extends Serializable {
+  trait ToInvariantMonoidalOps {
     implicit def toInvariantMonoidalOps[F[_], A](target: F[A])(implicit tc: InvariantMonoidal[F]): Ops[F, A] {
       type TypeClassType = InvariantMonoidal[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = InvariantMonoidal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = InvariantMonoidal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToInvariantMonoidalOps
   object ops {
     implicit def toAllInvariantMonoidalOps[F[_], A](target: F[A])(implicit tc: InvariantMonoidal[F]): AllOps[F, A] {
       type TypeClassType = InvariantMonoidal[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = InvariantMonoidal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = InvariantMonoidal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/InvariantSemigroupal.scala b/core/src/main/scala/cats/InvariantSemigroupal.scala
index c47005c51..da4cd323a 100644
--- a/core/src/main/scala/cats/InvariantSemigroupal.scala
+++ b/core/src/main/scala/cats/InvariantSemigroupal.scala
@@ -29,13 +29,12 @@ object InvariantSemigroupal extends SemigroupalArityFunctions {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[InvariantSemigroupal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: InvariantSemigroupal[F]): InvariantSemigroupal[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: InvariantSemigroupal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -43,15 +42,14 @@ object InvariantSemigroupal extends SemigroupalArityFunctions {
   trait AllOps[F[_], A] extends Ops[F, A] with Semigroupal.AllOps[F, A] with Invariant.AllOps[F, A] {
     type TypeClassType <: InvariantSemigroupal[F]
   }
-  trait ToInvariantSemigroupalOps extends Serializable {
+  trait ToInvariantSemigroupalOps {
     implicit def toInvariantSemigroupalOps[F[_], A](target: F[A])(implicit tc: InvariantSemigroupal[F]): Ops[F, A] {
       type TypeClassType = InvariantSemigroupal[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = InvariantSemigroupal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = InvariantSemigroupal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToInvariantSemigroupalOps
   object ops {
@@ -59,12 +57,11 @@ object InvariantSemigroupal extends SemigroupalArityFunctions {
       target: F[A]
     )(implicit tc: InvariantSemigroupal[F]): AllOps[F, A] {
       type TypeClassType = InvariantSemigroupal[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = InvariantSemigroupal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = InvariantSemigroupal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Monad.scala b/core/src/main/scala/cats/Monad.scala
index 19bbcdcf7..f6baaf800 100644
--- a/core/src/main/scala/cats/Monad.scala
+++ b/core/src/main/scala/cats/Monad.scala
@@ -124,13 +124,12 @@ object Monad {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Monad]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Monad[F]): Monad[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Monad[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -143,26 +142,24 @@ object Monad {
   trait AllOps[F[_], A] extends Ops[F, A] with FlatMap.AllOps[F, A] with Applicative.AllOps[F, A] {
     type TypeClassType <: Monad[F]
   }
-  trait ToMonadOps extends Serializable {
+  trait ToMonadOps {
     implicit def toMonadOps[F[_], A](target: F[A])(implicit tc: Monad[F]): Ops[F, A] {
       type TypeClassType = Monad[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Monad[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Monad[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToMonadOps
   object ops {
     implicit def toAllMonadOps[F[_], A](target: F[A])(implicit tc: Monad[F]): AllOps[F, A] {
       type TypeClassType = Monad[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Monad[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Monad[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/MonoidK.scala b/core/src/main/scala/cats/MonoidK.scala
index 3afdaa9ee..65aec341b 100644
--- a/core/src/main/scala/cats/MonoidK.scala
+++ b/core/src/main/scala/cats/MonoidK.scala
@@ -58,13 +58,12 @@ object MonoidK {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[MonoidK]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: MonoidK[F]): MonoidK[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: MonoidK[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -72,26 +71,24 @@ object MonoidK {
   trait AllOps[F[_], A] extends Ops[F, A] with SemigroupK.AllOps[F, A] {
     type TypeClassType <: MonoidK[F]
   }
-  trait ToMonoidKOps extends Serializable {
+  trait ToMonoidKOps {
     implicit def toMonoidKOps[F[_], A](target: F[A])(implicit tc: MonoidK[F]): Ops[F, A] {
       type TypeClassType = MonoidK[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = MonoidK[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = MonoidK[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToMonoidKOps
   object ops {
     implicit def toAllMonoidKOps[F[_], A](target: F[A])(implicit tc: MonoidK[F]): AllOps[F, A] {
       type TypeClassType = MonoidK[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = MonoidK[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = MonoidK[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/NonEmptyTraverse.scala b/core/src/main/scala/cats/NonEmptyTraverse.scala
index f33994514..581256291 100644
--- a/core/src/main/scala/cats/NonEmptyTraverse.scala
+++ b/core/src/main/scala/cats/NonEmptyTraverse.scala
@@ -101,13 +101,12 @@ object NonEmptyTraverse {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[NonEmptyTraverse]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: NonEmptyTraverse[F]): NonEmptyTraverse[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: NonEmptyTraverse[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -123,26 +122,24 @@ object NonEmptyTraverse {
   trait AllOps[F[_], A] extends Ops[F, A] with Traverse.AllOps[F, A] with Reducible.AllOps[F, A] {
     type TypeClassType <: NonEmptyTraverse[F]
   }
-  trait ToNonEmptyTraverseOps extends Serializable {
+  trait ToNonEmptyTraverseOps {
     implicit def toNonEmptyTraverseOps[F[_], A](target: F[A])(implicit tc: NonEmptyTraverse[F]): Ops[F, A] {
       type TypeClassType = NonEmptyTraverse[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = NonEmptyTraverse[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = NonEmptyTraverse[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToNonEmptyTraverseOps
   object ops {
     implicit def toAllNonEmptyTraverseOps[F[_], A](target: F[A])(implicit tc: NonEmptyTraverse[F]): AllOps[F, A] {
       type TypeClassType = NonEmptyTraverse[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = NonEmptyTraverse[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = NonEmptyTraverse[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Parallel.scala b/core/src/main/scala/cats/Parallel.scala
index 1187b7194..8a3a0c374 100644
--- a/core/src/main/scala/cats/Parallel.scala
+++ b/core/src/main/scala/cats/Parallel.scala
@@ -78,34 +78,33 @@ trait Parallel[M[_]] extends NonEmptyParallel[M] {
    * I.e. if you have a type M[_], that supports parallel composition through type F[_],
    * then you can get `ApplicativeError[F, E]` from `MonadError[M, E]`.
    */
-  def applicativeError[E](implicit E: MonadError[M, E]): ApplicativeError[F, E] =
-    new ApplicativeError[F, E] {
+  def applicativeError[E](implicit E: MonadError[M, E]): ApplicativeError[F, E] = new ApplicativeError[F, E] {
 
-      def raiseError[A](e: E): F[A] =
-        parallel(MonadError[M, E].raiseError(e))
+    def raiseError[A](e: E): F[A] =
+      parallel(MonadError[M, E].raiseError(e))
 
-      def handleErrorWith[A](fa: F[A])(f: E => F[A]): F[A] = {
-        val ma = E.handleErrorWith(sequential(fa))(e => sequential.apply(f(e)))
-        parallel(ma)
-      }
+    def handleErrorWith[A](fa: F[A])(f: E => F[A]): F[A] = {
+      val ma = E.handleErrorWith(sequential(fa))(e => sequential.apply(f(e)))
+      parallel(ma)
+    }
 
-      def pure[A](x: A): F[A] = applicative.pure(x)
+    def pure[A](x: A): F[A] = applicative.pure(x)
 
-      def ap[A, B](ff: F[(A) => B])(fa: F[A]): F[B] = applicative.ap(ff)(fa)
+    def ap[A, B](ff: F[(A) => B])(fa: F[A]): F[B] = applicative.ap(ff)(fa)
 
-      override def map[A, B](fa: F[A])(f: (A) => B): F[B] = applicative.map(fa)(f)
+    override def map[A, B](fa: F[A])(f: (A) => B): F[B] = applicative.map(fa)(f)
 
-      override def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] = applicative.product(fa, fb)
+    override def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] = applicative.product(fa, fb)
 
-      override def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) => Z): F[Z] = applicative.map2(fa, fb)(f)
+    override def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) => Z): F[Z] = applicative.map2(fa, fb)(f)
 
-      override def map2Eval[A, B, Z](fa: F[A], fb: Eval[F[B]])(f: (A, B) => Z): Eval[F[Z]] =
-        applicative.map2Eval(fa, fb)(f)
+    override def map2Eval[A, B, Z](fa: F[A], fb: Eval[F[B]])(f: (A, B) => Z): Eval[F[Z]] =
+      applicative.map2Eval(fa, fb)(f)
 
-      override def unlessA[A](cond: Boolean)(f: => F[A]): F[Unit] = applicative.unlessA(cond)(f)
+    override def unlessA[A](cond: Boolean)(f: => F[A]): F[Unit] = applicative.unlessA(cond)(f)
 
-      override def whenA[A](cond: Boolean)(f: => F[A]): F[Unit] = applicative.whenA(cond)(f)
-    }
+    override def whenA[A](cond: Boolean)(f: => F[A]): F[Unit] = applicative.whenA(cond)(f)
+  }
 }
 
 object NonEmptyParallel extends ScalaVersionSpecificParallelInstances {
@@ -373,16 +372,15 @@ object Parallel extends ParallelArityFunctions2 {
    * but are required to have an instance of `Parallel` defined,
    * in which case parallel composition will actually be sequential.
    */
-  def identity[M[_]: Monad]: Parallel.Aux[M, M] =
-    new Parallel[M] {
-      type F[x] = M[x]
+  def identity[M[_]: Monad]: Parallel.Aux[M, M] = new Parallel[M] {
+    type F[x] = M[x]
 
-      val monad: Monad[M] = implicitly[Monad[M]]
+    val monad: Monad[M] = implicitly[Monad[M]]
 
-      val applicative: Applicative[M] = implicitly[Monad[M]]
+    val applicative: Applicative[M] = implicitly[Monad[M]]
 
-      val sequential: M ~> M = FunctionK.id
+    val sequential: M ~> M = FunctionK.id
 
-      val parallel: M ~> M = FunctionK.id
-    }
+    val parallel: M ~> M = FunctionK.id
+  }
 }
diff --git a/core/src/main/scala/cats/Reducible.scala b/core/src/main/scala/cats/Reducible.scala
index e8a514142..dc48fd246 100644
--- a/core/src/main/scala/cats/Reducible.scala
+++ b/core/src/main/scala/cats/Reducible.scala
@@ -289,13 +289,12 @@ object Reducible {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Reducible]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Reducible[F]): Reducible[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Reducible[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -330,26 +329,24 @@ object Reducible {
   trait AllOps[F[_], A] extends Ops[F, A] with Foldable.AllOps[F, A] {
     type TypeClassType <: Reducible[F]
   }
-  trait ToReducibleOps extends Serializable {
+  trait ToReducibleOps {
     implicit def toReducibleOps[F[_], A](target: F[A])(implicit tc: Reducible[F]): Ops[F, A] {
       type TypeClassType = Reducible[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Reducible[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Reducible[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToReducibleOps
   object ops {
     implicit def toAllReducibleOps[F[_], A](target: F[A])(implicit tc: Reducible[F]): AllOps[F, A] {
       type TypeClassType = Reducible[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Reducible[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Reducible[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Representable.scala b/core/src/main/scala/cats/Representable.scala
index 00efafc28..84d953618 100644
--- a/core/src/main/scala/cats/Representable.scala
+++ b/core/src/main/scala/cats/Representable.scala
@@ -124,10 +124,9 @@ object Representable {
   /**
    * Derives a `Monad` instance for any `Representable` functor
    */
-  def monad[F[_]](implicit Rep: Representable[F]): Monad[F] =
-    new RepresentableMonad[F, Rep.Representation] {
-      override def R: Representable.Aux[F, Rep.Representation] = Rep
-    }
+  def monad[F[_]](implicit Rep: Representable[F]): Monad[F] = new RepresentableMonad[F, Rep.Representation] {
+    override def R: Representable.Aux[F, Rep.Representation] = Rep
+  }
 
   /**
    * Derives a `Bimonad` instance for any `Representable` functor whose representation
@@ -150,7 +149,7 @@ object Representable {
   implicit def catsRepresentableForFunction1[E](implicit EF: Functor[E => *]): Representable.Aux[E => *, E] =
     cats.instances.function.catsStdRepresentableForFunction1[E]
 
-  implicit def catsRepresentableForPair(implicit
-    PF: Functor[Î»[P => (P, P)]]
+  implicit def catsRepresentableForPair(
+    implicit PF: Functor[Î»[P => (P, P)]]
   ): Representable.Aux[Î»[P => (P, P)], Boolean] = cats.instances.tuple.catsDataRepresentableForPair
 }
diff --git a/core/src/main/scala/cats/SemigroupK.scala b/core/src/main/scala/cats/SemigroupK.scala
index 76fbd2c39..c11ed9eda 100644
--- a/core/src/main/scala/cats/SemigroupK.scala
+++ b/core/src/main/scala/cats/SemigroupK.scala
@@ -39,31 +39,6 @@ import scala.annotation.implicitNotFound
   @simulacrum.op("<+>", alias = true)
   def combineK[A](x: F[A], y: F[A]): F[A]
 
-  /**
-   * Similar to [[combineK]] but uses [[Eval]] to allow for laziness in the second
-   * argument. This can allow for "short-circuiting" of computations.
-   *
-   * NOTE: the default implementation of `combineKEval` does not short-circuit
-   * computations. For data structures that can benefit from laziness, [[SemigroupK]]
-   * instances should override this method.
-   *
-   * In the following example, `x.combineK(bomb)` would result in an error,
-   * but `combineKEval` "short-circuits" the computation. `x` is `Some` and thus the
-   * result of `bomb` doesn't even need to be evaluated in order to determine
-   * that the result of `combineKEval` should be `x`.
-   *
-   * {{{
-   * scala> import cats.{Eval, Later}
-   * scala> import cats.implicits._
-   * scala> val bomb: Eval[Option[Int]] = Later(sys.error("boom"))
-   * scala> val x: Option[Int] = Some(42)
-   * scala> x.combineKEval(bomb).value
-   * res0: Option[Int] = Some(42)
-   * }}}
-   */
-  def combineKEval[A](x: F[A], y: Eval[F[A]]): Eval[F[A]] =
-    y.map(yy => combineK(x, yy))
-
   /**
    * Given a type A, create a concrete Semigroup[F[A]].
    *
@@ -113,12 +88,11 @@ import scala.annotation.implicitNotFound
 }
 
 object SemigroupK extends ScalaVersionSpecificMonoidKInstances {
-  def align[F[_]: SemigroupK: Functor]: Align[F] =
-    new Align[F] {
-      def align[A, B](fa: F[A], fb: F[B]): F[Ior[A, B]] =
-        SemigroupK[F].combineK(Functor[F].map(fa)(Ior.left), Functor[F].map(fb)(Ior.right))
-      def functor: Functor[F] = Functor[F]
-    }
+  def align[F[_]: SemigroupK: Functor]: Align[F] = new Align[F] {
+    def align[A, B](fa: F[A], fb: F[B]): F[Ior[A, B]] =
+      SemigroupK[F].combineK(Functor[F].map(fa)(Ior.left), Functor[F].map(fb)(Ior.right))
+    def functor: Functor[F] = Functor[F]
+  }
 
   implicit def catsMonoidKForOption: MonoidK[Option] = cats.instances.option.catsStdInstancesForOption
   implicit def catsMonoidKForList: MonoidK[List] = cats.instances.list.catsStdInstancesForList
@@ -135,42 +109,38 @@ object SemigroupK extends ScalaVersionSpecificMonoidKInstances {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[SemigroupK]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: SemigroupK[F]): SemigroupK[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: SemigroupK[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
     def combineK(y: F[A]): F[A] = typeClassInstance.combineK[A](self, y)
     def <+>(y: F[A]): F[A] = typeClassInstance.combineK[A](self, y)
-    def combineKEval(y: Eval[F[A]]): Eval[F[A]] = typeClassInstance.combineKEval[A](self, y)
     def sum[B](fb: F[B])(implicit F: Functor[F]): F[Either[A, B]] = typeClassInstance.sum[A, B](self, fb)(F)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToSemigroupKOps extends Serializable {
+  trait ToSemigroupKOps {
     implicit def toSemigroupKOps[F[_], A](target: F[A])(implicit tc: SemigroupK[F]): Ops[F, A] {
       type TypeClassType = SemigroupK[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = SemigroupK[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = SemigroupK[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToSemigroupKOps
   object ops {
     implicit def toAllSemigroupKOps[F[_], A](target: F[A])(implicit tc: SemigroupK[F]): AllOps[F, A] {
       type TypeClassType = SemigroupK[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = SemigroupK[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = SemigroupK[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Semigroupal.scala b/core/src/main/scala/cats/Semigroupal.scala
index e7c1398a3..a8160e6c2 100644
--- a/core/src/main/scala/cats/Semigroupal.scala
+++ b/core/src/main/scala/cats/Semigroupal.scala
@@ -87,39 +87,36 @@ object Semigroupal extends ScalaVersionSpecificSemigroupalInstances with Semigro
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Semigroupal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Semigroupal[F]): Semigroupal[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Semigroupal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
     def product[B](fb: F[B]): F[(A, B)] = typeClassInstance.product[A, B](self, fb)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToSemigroupalOps extends Serializable {
+  trait ToSemigroupalOps {
     implicit def toSemigroupalOps[F[_], A](target: F[A])(implicit tc: Semigroupal[F]): Ops[F, A] {
       type TypeClassType = Semigroupal[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Semigroupal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Semigroupal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToSemigroupalOps
   object ops {
     implicit def toAllSemigroupalOps[F[_], A](target: F[A])(implicit tc: Semigroupal[F]): AllOps[F, A] {
       type TypeClassType = Semigroupal[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Semigroupal[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Semigroupal[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Show.scala b/core/src/main/scala/cats/Show.scala
index 2cc858fc0..3b73734c4 100644
--- a/core/src/main/scala/cats/Show.scala
+++ b/core/src/main/scala/cats/Show.scala
@@ -32,24 +32,21 @@ object Show extends ScalaVersionSpecificShowInstances with ShowInstances {
   }
 
   trait ToShowOps {
-    implicit def toShow[A](target: A)(implicit tc: Show[A]): Ops[A] =
-      new Ops[A] {
-        val self = target
-        val typeClassInstance = tc
-      }
+    implicit def toShow[A](target: A)(implicit tc: Show[A]): Ops[A] = new Ops[A] {
+      val self = target
+      val typeClassInstance = tc
+    }
   }
 
   /** creates an instance of [[Show]] using the provided function */
-  def show[A](f: A => String): Show[A] =
-    new Show[A] {
-      def show(a: A): String = f(a)
-    }
+  def show[A](f: A => String): Show[A] = new Show[A] {
+    def show(a: A): String = f(a)
+  }
 
   /** creates an instance of [[Show]] using object toString */
-  def fromToString[A]: Show[A] =
-    new Show[A] {
-      def show(a: A): String = a.toString
-    }
+  def fromToString[A]: Show[A] = new Show[A] {
+    def show(a: A): String = a.toString
+  }
 
   final case class Shown(override val toString: String) extends AnyVal
   object Shown {
diff --git a/core/src/main/scala/cats/StackSafeMonad.scala b/core/src/main/scala/cats/StackSafeMonad.scala
index 8b815dc6f..505b65ceb 100644
--- a/core/src/main/scala/cats/StackSafeMonad.scala
+++ b/core/src/main/scala/cats/StackSafeMonad.scala
@@ -12,9 +12,8 @@ import scala.util.{Either, Left, Right}
  */
 trait StackSafeMonad[F[_]] extends Monad[F] {
 
-  override def tailRecM[A, B](a: A)(f: A => F[Either[A, B]]): F[B] =
-    flatMap(f(a)) {
-      case Left(a)  => tailRecM(a)(f)
-      case Right(b) => pure(b)
-    }
+  override def tailRecM[A, B](a: A)(f: A => F[Either[A, B]]): F[B] = flatMap(f(a)) {
+    case Left(a)  => tailRecM(a)(f)
+    case Right(b) => pure(b)
+  }
 }
diff --git a/core/src/main/scala/cats/Traverse.scala b/core/src/main/scala/cats/Traverse.scala
index c562b95ef..6464364c4 100644
--- a/core/src/main/scala/cats/Traverse.scala
+++ b/core/src/main/scala/cats/Traverse.scala
@@ -138,13 +138,12 @@ object Traverse {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Traverse]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Traverse[F]): Traverse[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: Traverse[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -168,26 +167,24 @@ object Traverse {
       with UnorderedTraverse.AllOps[F, A] {
     type TypeClassType <: Traverse[F]
   }
-  trait ToTraverseOps extends Serializable {
+  trait ToTraverseOps {
     implicit def toTraverseOps[F[_], A](target: F[A])(implicit tc: Traverse[F]): Ops[F, A] {
       type TypeClassType = Traverse[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = Traverse[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = Traverse[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToTraverseOps
   object ops {
     implicit def toAllTraverseOps[F[_], A](target: F[A])(implicit tc: Traverse[F]): AllOps[F, A] {
       type TypeClassType = Traverse[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = Traverse[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = Traverse[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/TraverseFilter.scala b/core/src/main/scala/cats/TraverseFilter.scala
index e6478ca1f..46b3858a3 100644
--- a/core/src/main/scala/cats/TraverseFilter.scala
+++ b/core/src/main/scala/cats/TraverseFilter.scala
@@ -93,13 +93,12 @@ object TraverseFilter {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[TraverseFilter]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: TraverseFilter[F]): TraverseFilter[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: TraverseFilter[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -113,26 +112,24 @@ object TraverseFilter {
   trait AllOps[F[_], A] extends Ops[F, A] with FunctorFilter.AllOps[F, A] {
     type TypeClassType <: TraverseFilter[F]
   }
-  trait ToTraverseFilterOps extends Serializable {
+  trait ToTraverseFilterOps {
     implicit def toTraverseFilterOps[F[_], A](target: F[A])(implicit tc: TraverseFilter[F]): Ops[F, A] {
       type TypeClassType = TraverseFilter[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = TraverseFilter[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = TraverseFilter[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToTraverseFilterOps
   object ops {
     implicit def toAllTraverseFilterOps[F[_], A](target: F[A])(implicit tc: TraverseFilter[F]): AllOps[F, A] {
       type TypeClassType = TraverseFilter[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = TraverseFilter[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = TraverseFilter[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/UnorderedFoldable.scala b/core/src/main/scala/cats/UnorderedFoldable.scala
index 8ca780a63..8092301bf 100644
--- a/core/src/main/scala/cats/UnorderedFoldable.scala
+++ b/core/src/main/scala/cats/UnorderedFoldable.scala
@@ -117,13 +117,12 @@ object UnorderedFoldable extends ScalaVersionSpecificTraverseInstances {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[UnorderedFoldable]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: UnorderedFoldable[F]): UnorderedFoldable[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: UnorderedFoldable[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -137,26 +136,24 @@ object UnorderedFoldable extends ScalaVersionSpecificTraverseInstances {
     def size: Long = typeClassInstance.size[A](self)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToUnorderedFoldableOps extends Serializable {
+  trait ToUnorderedFoldableOps {
     implicit def toUnorderedFoldableOps[F[_], A](target: F[A])(implicit tc: UnorderedFoldable[F]): Ops[F, A] {
       type TypeClassType = UnorderedFoldable[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = UnorderedFoldable[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = UnorderedFoldable[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToUnorderedFoldableOps
   object ops {
     implicit def toAllUnorderedFoldableOps[F[_], A](target: F[A])(implicit tc: UnorderedFoldable[F]): AllOps[F, A] {
       type TypeClassType = UnorderedFoldable[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = UnorderedFoldable[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = UnorderedFoldable[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/UnorderedTraverse.scala b/core/src/main/scala/cats/UnorderedTraverse.scala
index bc1745cdd..2faab8561 100644
--- a/core/src/main/scala/cats/UnorderedTraverse.scala
+++ b/core/src/main/scala/cats/UnorderedTraverse.scala
@@ -19,13 +19,12 @@ object UnorderedTraverse {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[UnorderedTraverse]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: UnorderedTraverse[F]): UnorderedTraverse[F] = instance
 
-  trait Ops[F[_], A] extends Serializable {
+  trait Ops[F[_], A] {
     type TypeClassType <: UnorderedTraverse[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -37,26 +36,24 @@ object UnorderedTraverse {
   trait AllOps[F[_], A] extends Ops[F, A] with UnorderedFoldable.AllOps[F, A] {
     type TypeClassType <: UnorderedTraverse[F]
   }
-  trait ToUnorderedTraverseOps extends Serializable {
+  trait ToUnorderedTraverseOps {
     implicit def toUnorderedTraverseOps[F[_], A](target: F[A])(implicit tc: UnorderedTraverse[F]): Ops[F, A] {
       type TypeClassType = UnorderedTraverse[F]
-    } =
-      new Ops[F, A] {
-        type TypeClassType = UnorderedTraverse[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A] {
+      type TypeClassType = UnorderedTraverse[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToUnorderedTraverseOps
   object ops {
     implicit def toAllUnorderedTraverseOps[F[_], A](target: F[A])(implicit tc: UnorderedTraverse[F]): AllOps[F, A] {
       type TypeClassType = UnorderedTraverse[F]
-    } =
-      new AllOps[F, A] {
-        type TypeClassType = UnorderedTraverse[F]
-        val self: F[A] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A] {
+      type TypeClassType = UnorderedTraverse[F]
+      val self: F[A] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Arrow.scala b/core/src/main/scala/cats/arrow/Arrow.scala
index fca09c9e8..a9f6926e9 100644
--- a/core/src/main/scala/cats/arrow/Arrow.scala
+++ b/core/src/main/scala/cats/arrow/Arrow.scala
@@ -77,13 +77,12 @@ object Arrow {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Arrow]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Arrow[F]): Arrow[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: Arrow[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -95,26 +94,24 @@ object Arrow {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Category.AllOps[F, A, B] with Strong.AllOps[F, A, B] {
     type TypeClassType <: Arrow[F]
   }
-  trait ToArrowOps extends Serializable {
+  trait ToArrowOps {
     implicit def toArrowOps[F[_, _], A, B](target: F[A, B])(implicit tc: Arrow[F]): Ops[F, A, B] {
       type TypeClassType = Arrow[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = Arrow[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = Arrow[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToArrowOps
   object ops {
     implicit def toAllArrowOps[F[_, _], A, B](target: F[A, B])(implicit tc: Arrow[F]): AllOps[F, A, B] {
       type TypeClassType = Arrow[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = Arrow[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = Arrow[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/ArrowChoice.scala b/core/src/main/scala/cats/arrow/ArrowChoice.scala
index e36fff4e3..c01026829 100644
--- a/core/src/main/scala/cats/arrow/ArrowChoice.scala
+++ b/core/src/main/scala/cats/arrow/ArrowChoice.scala
@@ -49,13 +49,12 @@ object ArrowChoice {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[ArrowChoice]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: ArrowChoice[F]): ArrowChoice[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: ArrowChoice[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -67,26 +66,24 @@ object ArrowChoice {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Arrow.AllOps[F, A, B] with Choice.AllOps[F, A, B] {
     type TypeClassType <: ArrowChoice[F]
   }
-  trait ToArrowChoiceOps extends Serializable {
+  trait ToArrowChoiceOps {
     implicit def toArrowChoiceOps[F[_, _], A, B](target: F[A, B])(implicit tc: ArrowChoice[F]): Ops[F, A, B] {
       type TypeClassType = ArrowChoice[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = ArrowChoice[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = ArrowChoice[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToArrowChoiceOps
   object ops {
     implicit def toAllArrowChoiceOps[F[_, _], A, B](target: F[A, B])(implicit tc: ArrowChoice[F]): AllOps[F, A, B] {
       type TypeClassType = ArrowChoice[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = ArrowChoice[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = ArrowChoice[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Category.scala b/core/src/main/scala/cats/arrow/Category.scala
index c80edcfc7..198cbdbfa 100644
--- a/core/src/main/scala/cats/arrow/Category.scala
+++ b/core/src/main/scala/cats/arrow/Category.scala
@@ -30,13 +30,12 @@ object Category {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Category]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Category[F]): Category[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: Category[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -44,26 +43,24 @@ object Category {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Compose.AllOps[F, A, B] {
     type TypeClassType <: Category[F]
   }
-  trait ToCategoryOps extends Serializable {
+  trait ToCategoryOps {
     implicit def toCategoryOps[F[_, _], A, B](target: F[A, B])(implicit tc: Category[F]): Ops[F, A, B] {
       type TypeClassType = Category[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = Category[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = Category[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToCategoryOps
   object ops {
     implicit def toAllCategoryOps[F[_, _], A, B](target: F[A, B])(implicit tc: Category[F]): AllOps[F, A, B] {
       type TypeClassType = Category[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = Category[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = Category[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Choice.scala b/core/src/main/scala/cats/arrow/Choice.scala
index 4b1147843..da97eb7be 100644
--- a/core/src/main/scala/cats/arrow/Choice.scala
+++ b/core/src/main/scala/cats/arrow/Choice.scala
@@ -53,13 +53,12 @@ object Choice {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Choice]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Choice[F]): Choice[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: Choice[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -69,26 +68,24 @@ object Choice {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Category.AllOps[F, A, B] {
     type TypeClassType <: Choice[F]
   }
-  trait ToChoiceOps extends Serializable {
+  trait ToChoiceOps {
     implicit def toChoiceOps[F[_, _], A, B](target: F[A, B])(implicit tc: Choice[F]): Ops[F, A, B] {
       type TypeClassType = Choice[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = Choice[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = Choice[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToChoiceOps
   object ops {
     implicit def toAllChoiceOps[F[_, _], A, B](target: F[A, B])(implicit tc: Choice[F]): AllOps[F, A, B] {
       type TypeClassType = Choice[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = Choice[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = Choice[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/CommutativeArrow.scala b/core/src/main/scala/cats/arrow/CommutativeArrow.scala
index fca4d1351..03fc20fde 100644
--- a/core/src/main/scala/cats/arrow/CommutativeArrow.scala
+++ b/core/src/main/scala/cats/arrow/CommutativeArrow.scala
@@ -18,13 +18,12 @@ object CommutativeArrow {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[CommutativeArrow]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: CommutativeArrow[F]): CommutativeArrow[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: CommutativeArrow[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -32,15 +31,14 @@ object CommutativeArrow {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Arrow.AllOps[F, A, B] {
     type TypeClassType <: CommutativeArrow[F]
   }
-  trait ToCommutativeArrowOps extends Serializable {
+  trait ToCommutativeArrowOps {
     implicit def toCommutativeArrowOps[F[_, _], A, B](target: F[A, B])(implicit tc: CommutativeArrow[F]): Ops[F, A, B] {
       type TypeClassType = CommutativeArrow[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = CommutativeArrow[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = CommutativeArrow[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToCommutativeArrowOps
   object ops {
@@ -48,12 +46,11 @@ object CommutativeArrow {
       target: F[A, B]
     )(implicit tc: CommutativeArrow[F]): AllOps[F, A, B] {
       type TypeClassType = CommutativeArrow[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = CommutativeArrow[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = CommutativeArrow[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Compose.scala b/core/src/main/scala/cats/arrow/Compose.scala
index c6b767f75..34f048bea 100644
--- a/core/src/main/scala/cats/arrow/Compose.scala
+++ b/core/src/main/scala/cats/arrow/Compose.scala
@@ -48,13 +48,12 @@ object Compose {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Compose]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Compose[F]): Compose[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: Compose[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -64,26 +63,24 @@ object Compose {
     def >>>[C](g: F[B, C]): F[A, C] = typeClassInstance.andThen[A, B, C](self, g)
   }
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B]
-  trait ToComposeOps extends Serializable {
+  trait ToComposeOps {
     implicit def toComposeOps[F[_, _], A, B](target: F[A, B])(implicit tc: Compose[F]): Ops[F, A, B] {
       type TypeClassType = Compose[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = Compose[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = Compose[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToComposeOps
   object ops {
     implicit def toAllComposeOps[F[_, _], A, B](target: F[A, B])(implicit tc: Compose[F]): AllOps[F, A, B] {
       type TypeClassType = Compose[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = Compose[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = Compose[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/FunctionK.scala b/core/src/main/scala/cats/arrow/FunctionK.scala
index 295605936..7309cb28d 100644
--- a/core/src/main/scala/cats/arrow/FunctionK.scala
+++ b/core/src/main/scala/cats/arrow/FunctionK.scala
@@ -99,8 +99,8 @@ private[arrow] object FunctionKMacros {
 
   def lift[F[_], G[_]](c: Context)(
     f: c.Expr[(F[Î±] => G[Î±]) forSome { type Î± }]
-  )(implicit
-    evF: c.WeakTypeTag[F[_]],
+  )(
+    implicit evF: c.WeakTypeTag[F[_]],
     evG: c.WeakTypeTag[G[_]]
   ): c.Expr[FunctionK[F, G]] =
     c.Expr[FunctionK[F, G]](new Lifter[c.type](c).lift[F, G](f.tree))
@@ -109,59 +109,54 @@ private[arrow] object FunctionKMacros {
   private[this] class Lifter[C <: Context](val c: C) {
     import c.universe._
 
-    def lift[F[_], G[_]](tree: Tree)(implicit
-      evF: c.WeakTypeTag[F[_]],
+    def lift[F[_], G[_]](tree: Tree)(
+      implicit evF: c.WeakTypeTag[F[_]],
       evG: c.WeakTypeTag[G[_]]
-    ): Tree =
-      unblock(tree) match {
-        case q"($param) => $trans[..$typeArgs](${arg: Ident})" if param.name == arg.name =>
-          typeArgs
-            .collect { case tt: TypeTree => tt }
-            .find(tt => Option(tt.original).isDefined)
-            .foreach { param =>
-              c.abort(param.pos,
-                      s"type parameter $param must not be supplied when lifting function $trans to FunctionK"
-              )
-            }
-
-          val F = punchHole(evF.tpe)
-          val G = punchHole(evG.tpe)
-
-          q"""
+    ): Tree = unblock(tree) match {
+      case q"($param) => $trans[..$typeArgs](${arg: Ident})" if param.name == arg.name =>
+        typeArgs
+          .collect { case tt: TypeTree => tt }
+          .find(tt => Option(tt.original).isDefined)
+          .foreach { param =>
+            c.abort(param.pos, s"type parameter $param must not be supplied when lifting function $trans to FunctionK")
+          }
+
+        val F = punchHole(evF.tpe)
+        val G = punchHole(evG.tpe)
+
+        q"""
         new _root_.cats.arrow.FunctionK[$F, $G] {
           def apply[A](fa: $F[A]): $G[A] = $trans(fa)
         }
        """
-        case other =>
-          c.abort(other.pos, s"Unexpected tree $other when lifting to FunctionK")
-      }
-
-    private[this] def unblock(tree: Tree): Tree =
-      tree match {
-        case Block(Nil, expr) => expr
-        case _                => tree
-      }
-
-    private[this] def punchHole(tpe: Type): Tree =
-      tpe match {
-        case PolyType(undet :: Nil, underlying: TypeRef) =>
-          val Î± = TypeName("Î±")
-          def rebind(typeRef: TypeRef): Tree =
-            if (typeRef.sym == undet) tq"$Î±"
-            else {
-              val args = typeRef.args.map {
-                case ref: TypeRef => rebind(ref)
-                case arg          => tq"$arg"
-              }
-              tq"${typeRef.sym}[..$args]"
+      case other =>
+        c.abort(other.pos, s"Unexpected tree $other when lifting to FunctionK")
+    }
+
+    private[this] def unblock(tree: Tree): Tree = tree match {
+      case Block(Nil, expr) => expr
+      case _                => tree
+    }
+
+    private[this] def punchHole(tpe: Type): Tree = tpe match {
+      case PolyType(undet :: Nil, underlying: TypeRef) =>
+        val Î± = TypeName("Î±")
+        def rebind(typeRef: TypeRef): Tree =
+          if (typeRef.sym == undet) tq"$Î±"
+          else {
+            val args = typeRef.args.map {
+              case ref: TypeRef => rebind(ref)
+              case arg          => tq"$arg"
             }
-          val rebound = rebind(underlying)
-          tq"""({type Î»[$Î±] = $rebound})#Î»"""
-        case TypeRef(pre, sym, Nil) =>
-          tq"$sym"
-        case _ =>
-          c.abort(c.enclosingPosition, s"Unexpected type $tpe when lifting to FunctionK")
-      }
+            tq"${typeRef.sym}[..$args]"
+          }
+        val rebound = rebind(underlying)
+        tq"""({type Î»[$Î±] = $rebound})#Î»"""
+      case TypeRef(pre, sym, Nil) =>
+        tq"$sym"
+      case _ =>
+        c.abort(c.enclosingPosition, s"Unexpected type $tpe when lifting to FunctionK")
+    }
 
   }
 
diff --git a/core/src/main/scala/cats/arrow/Profunctor.scala b/core/src/main/scala/cats/arrow/Profunctor.scala
index fa4753b07..aa6b3c3cf 100644
--- a/core/src/main/scala/cats/arrow/Profunctor.scala
+++ b/core/src/main/scala/cats/arrow/Profunctor.scala
@@ -50,13 +50,12 @@ object Profunctor {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Profunctor]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Profunctor[F]): Profunctor[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: Profunctor[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -65,26 +64,24 @@ object Profunctor {
     def rmap[C](f: B => C): F[A, C] = typeClassInstance.rmap[A, B, C](self)(f)
   }
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B]
-  trait ToProfunctorOps extends Serializable {
+  trait ToProfunctorOps {
     implicit def toProfunctorOps[F[_, _], A, B](target: F[A, B])(implicit tc: Profunctor[F]): Ops[F, A, B] {
       type TypeClassType = Profunctor[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = Profunctor[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = Profunctor[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToProfunctorOps
   object ops {
     implicit def toAllProfunctorOps[F[_, _], A, B](target: F[A, B])(implicit tc: Profunctor[F]): AllOps[F, A, B] {
       type TypeClassType = Profunctor[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = Profunctor[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = Profunctor[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Strong.scala b/core/src/main/scala/cats/arrow/Strong.scala
index 72d2c8a7a..e81e6db7e 100644
--- a/core/src/main/scala/cats/arrow/Strong.scala
+++ b/core/src/main/scala/cats/arrow/Strong.scala
@@ -46,13 +46,12 @@ object Strong {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
-
   /**
    * Summon an instance of [[Strong]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Strong[F]): Strong[F] = instance
 
-  trait Ops[F[_, _], A, B] extends Serializable {
+  trait Ops[F[_, _], A, B] {
     type TypeClassType <: Strong[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -62,26 +61,24 @@ object Strong {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Profunctor.AllOps[F, A, B] {
     type TypeClassType <: Strong[F]
   }
-  trait ToStrongOps extends Serializable {
+  trait ToStrongOps {
     implicit def toStrongOps[F[_, _], A, B](target: F[A, B])(implicit tc: Strong[F]): Ops[F, A, B] {
       type TypeClassType = Strong[F]
-    } =
-      new Ops[F, A, B] {
-        type TypeClassType = Strong[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new Ops[F, A, B] {
+      type TypeClassType = Strong[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
   object nonInheritedOps extends ToStrongOps
   object ops {
     implicit def toAllStrongOps[F[_, _], A, B](target: F[A, B])(implicit tc: Strong[F]): AllOps[F, A, B] {
       type TypeClassType = Strong[F]
-    } =
-      new AllOps[F, A, B] {
-        type TypeClassType = Strong[F]
-        val self: F[A, B] = target
-        val typeClassInstance: TypeClassType = tc
-      }
+    } = new AllOps[F, A, B] {
+      type TypeClassType = Strong[F]
+      val self: F[A, B] = target
+      val typeClassInstance: TypeClassType = tc
+    }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/conversions/VarianceConversions.scala b/core/src/main/scala/cats/conversions/VarianceConversions.scala
new file mode 100644
index 000000000..7e8b7f769
--- /dev/null
+++ b/core/src/main/scala/cats/conversions/VarianceConversions.scala
@@ -0,0 +1,14 @@
+package cats
+package conversions
+
+trait VarianceConversions extends VarianceConversionsLowPriority {
+  implicit def autoWidenBifunctor[F[_, _]: Bifunctor, A, B >: A, C, D >: C](fac: F[A, C]): F[B, D] =
+    Bifunctor[F].leftWiden(Bifunctor[F].rightFunctor.widen(fac))
+
+  implicit def autoNarrowContravariant[F[_]: Contravariant, A, B <: A](fa: F[A]): F[B] = Contravariant[F].narrow(fa)
+
+}
+
+private[cats] trait VarianceConversionsLowPriority {
+  implicit def autoWidenFunctor[F[_]: Functor, A, B >: A](fa: F[A]): F[B] = Functor[F].widen(fa)
+}
diff --git a/core/src/main/scala/cats/conversions/all.scala b/core/src/main/scala/cats/conversions/all.scala
new file mode 100644
index 000000000..676b56354
--- /dev/null
+++ b/core/src/main/scala/cats/conversions/all.scala
@@ -0,0 +1,3 @@
+package cats.conversions
+
+trait AllConversions extends VarianceConversions
diff --git a/core/src/main/scala/cats/conversions/package.scala b/core/src/main/scala/cats/conversions/package.scala
new file mode 100644
index 000000000..ac47bccbf
--- /dev/null
+++ b/core/src/main/scala/cats/conversions/package.scala
@@ -0,0 +1,6 @@
+package cats
+
+package object conversions {
+  object all extends AllConversions
+  object variance extends VarianceConversions
+}
diff --git a/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala b/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala
index b5f4eacd3..2641a4f36 100644
--- a/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala
+++ b/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala
@@ -1,12 +1,11 @@
 package cats
 package data
 
-abstract private[data] class AbstractNonEmptyInstances[F[_], NonEmptyF[_]](implicit
-  MF: Monad[F],
-  CF: CoflatMap[F],
-  TF: Traverse[F],
-  SF: SemigroupK[F]
-) extends Bimonad[NonEmptyF]
+abstract private[data] class AbstractNonEmptyInstances[F[_], NonEmptyF[_]](implicit MF: Monad[F],
+                                                                           CF: CoflatMap[F],
+                                                                           TF: Traverse[F],
+                                                                           SF: SemigroupK[F])
+    extends Bimonad[NonEmptyF]
     with NonEmptyTraverse[NonEmptyF]
     with SemigroupK[NonEmptyF] {
   val monadInstance = MF.asInstanceOf[Monad[NonEmptyF]]
diff --git a/core/src/main/scala/cats/data/Binested.scala b/core/src/main/scala/cats/data/Binested.scala
index 00bea89b1..d5687eede 100644
--- a/core/src/main/scala/cats/data/Binested.scala
+++ b/core/src/main/scala/cats/data/Binested.scala
@@ -26,23 +26,21 @@ final case class Binested[F[_, _], G[_], H[_], A, B](value: F[G[A], H[B]])
 object Binested extends BinestedInstances
 
 trait BinestedInstances extends BinestedInstances0 {
-  implicit def catsDataEqForBinested[F[_, _], G[_], H[_], A, B](implicit
-    F: Eq[F[G[A], H[B]]]
+  implicit def catsDataEqForBinested[F[_, _], G[_], H[_], A, B](
+    implicit F: Eq[F[G[A], H[B]]]
   ): Eq[Binested[F, G, H, A, B]] =
     Eq.by(_.value)
 
-  implicit def catsDataProfunctorForBinested[F[_, _], G[_], H[_]](implicit
-    F: Profunctor[F],
-    G: Functor[G],
-    H: Functor[H]
-  ): Profunctor[Binested[F, G, H, *, *]] =
+  implicit def catsDataProfunctorForBinested[F[_, _], G[_], H[_]](implicit F: Profunctor[F],
+                                                                  G: Functor[G],
+                                                                  H: Functor[H]): Profunctor[Binested[F, G, H, *, *]] =
     new Profunctor[Binested[F, G, H, *, *]] {
       def dimap[A, B, C, D](fab: Binested[F, G, H, A, B])(f: C => A)(g: B => D): Binested[F, G, H, C, D] =
         Binested(F.dimap(fab.value)(G.map(_: G[C])(f))(H.map(_)(g)))
     }
 
-  implicit def catsDataBitraverseForBinested[F[_, _], G[_], H[_]](implicit
-    F0: Bitraverse[F],
+  implicit def catsDataBitraverseForBinested[F[_, _], G[_], H[_]](
+    implicit F0: Bitraverse[F],
     H0: Traverse[H],
     G0: Traverse[G]
   ): Bitraverse[Binested[F, G, H, *, *]] =
@@ -54,8 +52,8 @@ trait BinestedInstances extends BinestedInstances0 {
 }
 
 private[data] trait BinestedInstances0 {
-  implicit def catsDataBifoldableForBinested[F[_, _], G[_], H[_]](implicit
-    F0: Bifoldable[F],
+  implicit def catsDataBifoldableForBinested[F[_, _], G[_], H[_]](
+    implicit F0: Bifoldable[F],
     G0: Foldable[G],
     H0: Foldable[H]
   ): Bifoldable[Binested[F, G, H, *, *]] =
@@ -65,11 +63,9 @@ private[data] trait BinestedInstances0 {
       implicit override def H: Foldable[H] = H0
     }
 
-  implicit def catsDataBifunctorForBinested[F[_, _], G[_], H[_]](implicit
-    F: Bifunctor[F],
-    G: Functor[G],
-    H: Functor[H]
-  ): Bifunctor[Binested[F, G, H, *, *]] =
+  implicit def catsDataBifunctorForBinested[F[_, _], G[_], H[_]](implicit F: Bifunctor[F],
+                                                                 G: Functor[G],
+                                                                 H: Functor[H]): Bifunctor[Binested[F, G, H, *, *]] =
     new Bifunctor[Binested[F, G, H, *, *]] {
       def bimap[A, B, C, D](fab: Binested[F, G, H, A, B])(f: A => C, g: B => D): Binested[F, G, H, C, D] =
         Binested(F.bimap(fab.value)(G.map(_)(f), H.map(_)(g)))
@@ -87,9 +83,8 @@ sealed abstract class BinestedBifoldable[F[_, _], G[_], H[_]] extends Bifoldable
       (c, hb) => H.foldLeft(hb, c)(g)
     )
 
-  def bifoldRight[A, B, C](fab: Binested[F, G, H, A, B],
-                           c: Eval[C]
-  )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
+  def bifoldRight[A, B, C](fab: Binested[F, G, H, A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
+                                                                     g: (B, Eval[C]) => Eval[C]): Eval[C] =
     F.bifoldRight(fab.value, c)(
       (ga, ec) => G.foldRight(ga, ec)(f),
       (hb, ec) => H.foldRight(hb, ec)(g)
diff --git a/core/src/main/scala/cats/data/Chain.scala b/core/src/main/scala/cats/data/Chain.scala
index ceda64437..7e6491541 100644
--- a/core/src/main/scala/cats/data/Chain.scala
+++ b/core/src/main/scala/cats/data/Chain.scala
@@ -136,11 +136,10 @@ sealed abstract class Chain[+A] {
   /**
    * Applies the supplied function to each element and returns a new Chain.
    */
-  final def map[B](f: A => B): Chain[B] =
-    this match {
-      case Wrap(seq) => Wrap(seq.map(f))
-      case _         => fromSeq(iterator.map(f).toVector)
-    }
+  final def map[B](f: A => B): Chain[B] = this match {
+    case Wrap(seq) => Wrap(seq.map(f))
+    case _         => fromSeq(iterator.map(f).toVector)
+  }
 
   /**
    * Applies the supplied function to each element and returns a new Chain from the concatenated results
@@ -327,15 +326,14 @@ sealed abstract class Chain[+A] {
   /**
    * Zips each element of this `Chain` with its index.
    */
-  final def zipWithIndex: Chain[(A, Int)] =
-    this match {
-      case Empty        => Empty
-      case Singleton(a) => Singleton((a, 0))
-      case Append(left, right) =>
-        val leftSize = left.length.toInt
-        Append(left.zipWithIndex, right.zipWithIndex.map { case (a, i) => (a, leftSize + i) })
-      case Wrap(seq) => Wrap(seq.zipWithIndex)
-    }
+  final def zipWithIndex: Chain[(A, Int)] = this match {
+    case Empty        => Empty
+    case Singleton(a) => Singleton((a, 0))
+    case Append(left, right) =>
+      val leftSize = left.length.toInt
+      Append(left.zipWithIndex, right.zipWithIndex.map { case (a, i) => (a, leftSize + i) })
+    case Wrap(seq) => Wrap(seq.zipWithIndex)
+  }
 
   /**
    * Groups elements inside this `Chain` according to the `Order`
@@ -385,10 +383,9 @@ sealed abstract class Chain[+A] {
   /**
    * Applies the supplied function to each element, left to right.
    */
-  final private def foreach(f: A => Unit): Unit =
-    foreachUntil { a =>
-      f(a); false
-    }
+  final private def foreach(f: A => Unit): Unit = foreachUntil { a =>
+    f(a); false
+  }
 
   /**
    * Applies the supplied function to each element, left to right, but stops when true is returned
@@ -426,17 +423,15 @@ sealed abstract class Chain[+A] {
   }
   // scalastyle:on null return cyclomatic.complexity
 
-  final def iterator: Iterator[A] =
-    this match {
-      case Wrap(seq) => seq.iterator
-      case _         => new ChainIterator[A](this)
-    }
+  final def iterator: Iterator[A] = this match {
+    case Wrap(seq) => seq.iterator
+    case _         => new ChainIterator[A](this)
+  }
 
-  final def reverseIterator: Iterator[A] =
-    this match {
-      case Wrap(seq) => seq.reverseIterator
-      case _         => new ChainReverseIterator[A](this)
-    }
+  final def reverseIterator: Iterator[A] = this match {
+    case Wrap(seq) => seq.reverseIterator
+    case _         => new ChainReverseIterator[A](this)
+  }
 
   /**
    * Returns the number of elements in this structure
@@ -546,21 +541,19 @@ sealed abstract class Chain[+A] {
       result
     }
 
-  final def sortBy[B](f: A => B)(implicit B: Order[B]): Chain[A] =
-    this match {
-      case Empty        => this
-      case Singleton(_) => this
-      case Append(_, _) => Wrap(toVector.sortBy(f)(B.toOrdering))
-      case Wrap(seq)    => Wrap(seq.sortBy(f)(B.toOrdering))
-    }
+  final def sortBy[B](f: A => B)(implicit B: Order[B]): Chain[A] = this match {
+    case Empty        => this
+    case Singleton(_) => this
+    case Append(_, _) => Wrap(toVector.sortBy(f)(B.toOrdering))
+    case Wrap(seq)    => Wrap(seq.sortBy(f)(B.toOrdering))
+  }
 
-  final def sorted[AA >: A](implicit AA: Order[AA]): Chain[AA] =
-    this match {
-      case Empty        => this
-      case Singleton(_) => this
-      case Append(_, _) => Wrap(toVector.sorted(AA.toOrdering))
-      case Wrap(seq)    => Wrap(seq.sorted(AA.toOrdering))
-    }
+  final def sorted[AA >: A](implicit AA: Order[AA]): Chain[AA] = this match {
+    case Empty        => this
+    case Singleton(_) => this
+    case Append(_, _) => Wrap(toVector.sorted(AA.toOrdering))
+    case Wrap(seq)    => Wrap(seq.sorted(AA.toOrdering))
+  }
 }
 
 object Chain extends ChainInstances {
@@ -707,11 +700,10 @@ object Chain extends ChainInstances {
 }
 
 sealed abstract private[data] class ChainInstances extends ChainInstances1 {
-  implicit def catsDataMonoidForChain[A]: Monoid[Chain[A]] =
-    new Monoid[Chain[A]] {
-      def empty: Chain[A] = Chain.nil
-      def combine(c: Chain[A], c2: Chain[A]): Chain[A] = Chain.concat(c, c2)
-    }
+  implicit def catsDataMonoidForChain[A]: Monoid[Chain[A]] = new Monoid[Chain[A]] {
+    def empty: Chain[A] = Chain.nil
+    def combine(c: Chain[A], c2: Chain[A]): Chain[A] = Chain.concat(c, c2)
+  }
 
   implicit val catsDataInstancesForChain
     : Traverse[Chain] with Alternative[Chain] with Monad[Chain] with CoflatMap[Chain] with Align[Chain] =
@@ -873,19 +865,17 @@ sealed abstract private[data] class ChainInstances1 extends ChainInstances2 {
 }
 
 sealed abstract private[data] class ChainInstances2 extends ChainInstances3 {
-  implicit def catsDataHashForChain[A](implicit A: Hash[A]): Hash[Chain[A]] =
-    new Hash[Chain[A]] {
-      def eqv(x: Chain[A], y: Chain[A]): Boolean = x === y
+  implicit def catsDataHashForChain[A](implicit A: Hash[A]): Hash[Chain[A]] = new Hash[Chain[A]] {
+    def eqv(x: Chain[A], y: Chain[A]): Boolean = x === y
 
-      def hash(fa: Chain[A]): Int = fa.hash
-    }
+    def hash(fa: Chain[A]): Int = fa.hash
+  }
 }
 
 sealed abstract private[data] class ChainInstances3 {
-  implicit def catsDataEqForChain[A](implicit A: Eq[A]): Eq[Chain[A]] =
-    new Eq[Chain[A]] {
-      def eqv(x: Chain[A], y: Chain[A]): Boolean = x === y
-    }
+  implicit def catsDataEqForChain[A](implicit A: Eq[A]): Eq[Chain[A]] = new Eq[Chain[A]] {
+    def eqv(x: Chain[A], y: Chain[A]): Boolean = x === y
+  }
 }
 
 private[data] trait ChainPartialOrder[A] extends PartialOrder[Chain[A]] {
diff --git a/core/src/main/scala/cats/data/Cokleisli.scala b/core/src/main/scala/cats/data/Cokleisli.scala
index be1c898d3..ccde3d952 100644
--- a/core/src/main/scala/cats/data/Cokleisli.scala
+++ b/core/src/main/scala/cats/data/Cokleisli.scala
@@ -125,11 +125,10 @@ private[data] class CokleisliMonad[F[_], A] extends Monad[Cokleisli[F, A, *]] {
   def tailRecM[B, C](b: B)(fn: B => Cokleisli[F, A, Either[B, C]]): Cokleisli[F, A, C] =
     Cokleisli { (fa: F[A]) =>
       @tailrec
-      def loop(c: Cokleisli[F, A, Either[B, C]]): C =
-        c.run(fa) match {
-          case Right(c) => c
-          case Left(bb) => loop(fn(bb))
-        }
+      def loop(c: Cokleisli[F, A, Either[B, C]]): C = c.run(fa) match {
+        case Right(c) => c
+        case Left(bb) => loop(fn(bb))
+      }
       loop(fn(b))
     }
 
diff --git a/core/src/main/scala/cats/data/Const.scala b/core/src/main/scala/cats/data/Const.scala
index d5b4dcdf5..ab02eb37b 100644
--- a/core/src/main/scala/cats/data/Const.scala
+++ b/core/src/main/scala/cats/data/Const.scala
@@ -69,79 +69,72 @@ sealed abstract private[data] class ConstInstances extends ConstInstances0 {
       override def minBound: Const[A, B] = Const(A.minBound)
     }
 
-  implicit def catsDataOrderForConst[A: Order, B]: Order[Const[A, B]] =
-    new Order[Const[A, B]] {
-      def compare(x: Const[A, B], y: Const[A, B]): Int =
-        x.compare(y)
-    }
+  implicit def catsDataOrderForConst[A: Order, B]: Order[Const[A, B]] = new Order[Const[A, B]] {
+    def compare(x: Const[A, B], y: Const[A, B]): Int =
+      x.compare(y)
+  }
 
-  implicit def catsDataAlignForConst[A: Semigroup]: Align[Const[A, *]] =
-    new Align[Const[A, *]] {
-      def align[B, C](fa: Const[A, B], fb: Const[A, C]): Const[A, Ior[B, C]] =
-        Const(Semigroup[A].combine(fa.getConst, fb.getConst))
-      def functor: Functor[Const[A, *]] = catsDataFunctorForConst
-    }
+  implicit def catsDataAlignForConst[A: Semigroup]: Align[Const[A, *]] = new Align[Const[A, *]] {
+    def align[B, C](fa: Const[A, B], fb: Const[A, C]): Const[A, Ior[B, C]] =
+      Const(Semigroup[A].combine(fa.getConst, fb.getConst))
+    def functor: Functor[Const[A, *]] = catsDataFunctorForConst
+  }
 
-  implicit def catsDataShowForConst[A: Show, B]: Show[Const[A, B]] =
-    new Show[Const[A, B]] {
-      def show(f: Const[A, B]): String = f.show
-    }
+  implicit def catsDataShowForConst[A: Show, B]: Show[Const[A, B]] = new Show[Const[A, B]] {
+    def show(f: Const[A, B]): String = f.show
+  }
 
-  implicit def catsDataTraverseForConst[C]: Traverse[Const[C, *]] =
-    new Traverse[Const[C, *]] {
-      def foldLeft[A, B](fa: Const[C, A], b: B)(f: (B, A) => B): B = b
+  implicit def catsDataTraverseForConst[C]: Traverse[Const[C, *]] = new Traverse[Const[C, *]] {
+    def foldLeft[A, B](fa: Const[C, A], b: B)(f: (B, A) => B): B = b
 
-      def foldRight[A, B](fa: Const[C, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] = lb
+    def foldRight[A, B](fa: Const[C, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] = lb
 
-      override def size[A](fa: Const[C, A]): Long = 0L
+    override def size[A](fa: Const[C, A]): Long = 0L
 
-      override def get[A](fa: Const[C, A])(idx: Long): Option[A] = None
+    override def get[A](fa: Const[C, A])(idx: Long): Option[A] = None
 
-      def traverse[G[_]: Applicative, A, B](fa: Const[C, A])(f: A => G[B]): G[Const[C, B]] =
-        fa.traverse(f)
-    }
+    def traverse[G[_]: Applicative, A, B](fa: Const[C, A])(f: A => G[B]): G[Const[C, B]] =
+      fa.traverse(f)
+  }
 
-  implicit def catsDataTraverseFilterForConst[C]: TraverseFilter[Const[C, *]] =
-    new TraverseFilter[Const[C, *]] {
+  implicit def catsDataTraverseFilterForConst[C]: TraverseFilter[Const[C, *]] = new TraverseFilter[Const[C, *]] {
 
-      override def mapFilter[A, B](fa: Const[C, A])(f: (A) => Option[B]): Const[C, B] = fa.retag
+    override def mapFilter[A, B](fa: Const[C, A])(f: (A) => Option[B]): Const[C, B] = fa.retag
 
-      override def collect[A, B](fa: Const[C, A])(f: PartialFunction[A, B]): Const[C, B] = fa.retag
+    override def collect[A, B](fa: Const[C, A])(f: PartialFunction[A, B]): Const[C, B] = fa.retag
 
-      override def flattenOption[A](fa: Const[C, Option[A]]): Const[C, A] = fa.retag
+    override def flattenOption[A](fa: Const[C, Option[A]]): Const[C, A] = fa.retag
 
-      override def filter[A](fa: Const[C, A])(f: (A) => Boolean): Const[C, A] = fa.retag
+    override def filter[A](fa: Const[C, A])(f: (A) => Boolean): Const[C, A] = fa.retag
 
-      override def filterNot[A](fa: Const[C, A])(f: A => Boolean): Const[C, A] = fa.retag
+    override def filterNot[A](fa: Const[C, A])(f: A => Boolean): Const[C, A] = fa.retag
 
-      def traverseFilter[G[_], A, B](
-        fa: Const[C, A]
-      )(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Const[C, B]] =
-        G.pure(fa.retag[B])
+    def traverseFilter[G[_], A, B](
+      fa: Const[C, A]
+    )(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Const[C, B]] =
+      G.pure(fa.retag[B])
 
-      override def filterA[G[_], A](fa: Const[C, A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Const[C, A]] =
-        G.pure(fa)
+    override def filterA[G[_], A](fa: Const[C, A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Const[C, A]] =
+      G.pure(fa)
 
-      val traverse: Traverse[Const[C, *]] = Const.catsDataTraverseForConst[C]
-    }
+    val traverse: Traverse[Const[C, *]] = Const.catsDataTraverseForConst[C]
+  }
 
-  implicit def catsDataMonoidForConst[A: Monoid, B]: Monoid[Const[A, B]] =
-    new Monoid[Const[A, B]] {
-      def empty: Const[A, B] =
-        Const.empty
+  implicit def catsDataMonoidForConst[A: Monoid, B]: Monoid[Const[A, B]] = new Monoid[Const[A, B]] {
+    def empty: Const[A, B] =
+      Const.empty
 
-      def combine(x: Const[A, B], y: Const[A, B]): Const[A, B] =
-        x.combine(y)
-    }
+    def combine(x: Const[A, B], y: Const[A, B]): Const[A, B] =
+      x.combine(y)
+  }
 
   implicit val catsDataBifoldableForConst: Bifoldable[Const] =
     new Bifoldable[Const] {
       def bifoldLeft[A, B, C](fab: Const[A, B], c: C)(f: (C, A) => C, g: (C, B) => C): C =
         f(c, fab.getConst)
 
-      def bifoldRight[A, B, C](fab: Const[A, B],
-                               c: Eval[C]
-      )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
+      def bifoldRight[A, B, C](fab: Const[A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
+                                                             g: (B, Eval[C]) => Eval[C]): Eval[C] =
         f(fab.getConst, c)
     }
 }
@@ -157,8 +150,8 @@ sealed abstract private[data] class ConstInstances0 extends ConstInstances1 {
         fa.retag[(A, B)].combine(fb.retag[(A, B)])
     }
 
-  implicit def catsDataCommutativeApplicativeForConst[C](implicit
-    C: CommutativeMonoid[C]
+  implicit def catsDataCommutativeApplicativeForConst[C](
+    implicit C: CommutativeMonoid[C]
   ): CommutativeApplicative[Const[C, *]] =
     new ConstApplicative[C] with CommutativeApplicative[Const[C, *]] { val C0: CommutativeMonoid[C] = C }
 }
@@ -171,10 +164,9 @@ sealed abstract private[data] class ConstInstances1 extends ConstInstances2 {
 
 sealed abstract private[data] class ConstInstances2 extends ConstInstances3 {
 
-  implicit def catsDataSemigroupForConst[A: Semigroup, B]: Semigroup[Const[A, B]] =
-    new Semigroup[Const[A, B]] {
-      def combine(x: Const[A, B], y: Const[A, B]): Const[A, B] = x.combine(y)
-    }
+  implicit def catsDataSemigroupForConst[A: Semigroup, B]: Semigroup[Const[A, B]] = new Semigroup[Const[A, B]] {
+    def combine(x: Const[A, B], y: Const[A, B]): Const[A, B] = x.combine(y)
+  }
 
   implicit def catsDataPartialOrderForConst[A: PartialOrder, B]: PartialOrder[Const[A, B]] =
     new PartialOrder[Const[A, B]] {
@@ -188,11 +180,10 @@ sealed abstract private[data] class ConstInstances2 extends ConstInstances3 {
 
 sealed abstract private[data] class ConstInstances3 extends ConstInstances4 {
 
-  implicit def catsDataEqForConst[A: Eq, B]: Eq[Const[A, B]] =
-    new Eq[Const[A, B]] {
-      def eqv(x: Const[A, B], y: Const[A, B]): Boolean =
-        x === y
-    }
+  implicit def catsDataEqForConst[A: Eq, B]: Eq[Const[A, B]] = new Eq[Const[A, B]] {
+    def eqv(x: Const[A, B], y: Const[A, B]): Boolean =
+      x === y
+  }
 
   implicit def catsDataApplyForConst[C](implicit C: Semigroup[C]): Apply[Const[C, *]] =
     new ConstApply[C] { val C0: Semigroup[C] = C }
diff --git a/core/src/main/scala/cats/data/ContT.scala b/core/src/main/scala/cats/data/ContT.scala
index c0180a686..704da6784 100644
--- a/core/src/main/scala/cats/data/ContT.scala
+++ b/core/src/main/scala/cats/data/ContT.scala
@@ -40,7 +40,7 @@ sealed abstract class ContT[M[_], A, +B] extends Serializable {
     // allocate/pattern match once
     val fnAndThen = AndThen(fn)
     ContT[M, A, C] { fn2 =>
-      val contRun: ContT[M, A, C] => M[A] = _.run(fn2)
+      val contRun: ContT[M, A, C] => M[A] = (_.run(fn2))
       val fn3: B => M[A] = fnAndThen.andThen(contRun)
       M.defer(run(fn3))
     }
diff --git a/core/src/main/scala/cats/data/EitherK.scala b/core/src/main/scala/cats/data/EitherK.scala
index a02f65b40..24acdb4bd 100644
--- a/core/src/main/scala/cats/data/EitherK.scala
+++ b/core/src/main/scala/cats/data/EitherK.scala
@@ -127,20 +127,16 @@ sealed abstract private[data] class EitherKInstances3 {
   implicit def catsDataEqForEitherK[F[_], G[_], A](implicit E: Eq[Either[F[A], G[A]]]): Eq[EitherK[F, G, A]] =
     Eq.by(_.run)
 
-  implicit def catsDataFunctorForEitherK[F[_], G[_]](implicit
-    F0: Functor[F],
-    G0: Functor[G]
-  ): Functor[EitherK[F, G, *]] =
+  implicit def catsDataFunctorForEitherK[F[_], G[_]](implicit F0: Functor[F],
+                                                     G0: Functor[G]): Functor[EitherK[F, G, *]] =
     new EitherKFunctor[F, G] {
       implicit def F: Functor[F] = F0
 
       implicit def G: Functor[G] = G0
     }
 
-  implicit def catsDataFoldableForEitherK[F[_], G[_]](implicit
-    F0: Foldable[F],
-    G0: Foldable[G]
-  ): Foldable[EitherK[F, G, *]] =
+  implicit def catsDataFoldableForEitherK[F[_], G[_]](implicit F0: Foldable[F],
+                                                      G0: Foldable[G]): Foldable[EitherK[F, G, *]] =
     new EitherKFoldable[F, G] {
       implicit def F: Foldable[F] = F0
 
@@ -150,10 +146,8 @@ sealed abstract private[data] class EitherKInstances3 {
 
 sealed abstract private[data] class EitherKInstances2 extends EitherKInstances3 {
 
-  implicit def catsDataContravariantForEitherK[F[_], G[_]](implicit
-    F0: Contravariant[F],
-    G0: Contravariant[G]
-  ): Contravariant[EitherK[F, G, *]] =
+  implicit def catsDataContravariantForEitherK[F[_], G[_]](implicit F0: Contravariant[F],
+                                                           G0: Contravariant[G]): Contravariant[EitherK[F, G, *]] =
     new EitherKContravariant[F, G] {
       implicit def F: Contravariant[F] = F0
 
@@ -162,10 +156,8 @@ sealed abstract private[data] class EitherKInstances2 extends EitherKInstances3
 }
 
 sealed abstract private[data] class EitherKInstances1 extends EitherKInstances2 {
-  implicit def catsDataCoflatMapForEitherK[F[_], G[_]](implicit
-    F0: CoflatMap[F],
-    G0: CoflatMap[G]
-  ): CoflatMap[EitherK[F, G, *]] =
+  implicit def catsDataCoflatMapForEitherK[F[_], G[_]](implicit F0: CoflatMap[F],
+                                                       G0: CoflatMap[G]): CoflatMap[EitherK[F, G, *]] =
     new EitherKCoflatMap[F, G] with EitherKFunctor[F, G] {
       implicit def F: CoflatMap[F] = F0
 
@@ -174,10 +166,8 @@ sealed abstract private[data] class EitherKInstances1 extends EitherKInstances2
 }
 
 sealed abstract private[data] class EitherKInstances0 extends EitherKInstances1 {
-  implicit def catsDataTraverseForEitherK[F[_], G[_]](implicit
-    F0: Traverse[F],
-    G0: Traverse[G]
-  ): Traverse[EitherK[F, G, *]] =
+  implicit def catsDataTraverseForEitherK[F[_], G[_]](implicit F0: Traverse[F],
+                                                      G0: Traverse[G]): Traverse[EitherK[F, G, *]] =
     new EitherKTraverse[F, G] with EitherKFunctor[F, G] {
       implicit def F: Traverse[F] = F0
 
@@ -187,10 +177,8 @@ sealed abstract private[data] class EitherKInstances0 extends EitherKInstances1
 
 sealed abstract private[data] class EitherKInstances extends EitherKInstances0 {
 
-  implicit def catsDataComonadForEitherK[F[_], G[_]](implicit
-    F0: Comonad[F],
-    G0: Comonad[G]
-  ): Comonad[EitherK[F, G, *]] =
+  implicit def catsDataComonadForEitherK[F[_], G[_]](implicit F0: Comonad[F],
+                                                     G0: Comonad[G]): Comonad[EitherK[F, G, *]] =
     new EitherKComonad[F, G] with EitherKFunctor[F, G] {
       implicit def F: Comonad[F] = F0
 
diff --git a/core/src/main/scala/cats/data/EitherT.scala b/core/src/main/scala/cats/data/EitherT.scala
index 16f242a74..1f693de06 100644
--- a/core/src/main/scala/cats/data/EitherT.scala
+++ b/core/src/main/scala/cats/data/EitherT.scala
@@ -368,10 +368,8 @@ final case class EitherT[F[_], A, B](value: F[Either[A, B]]) {
       }
     )
 
-  def bitraverse[G[_], C, D](f: A => G[C], g: B => G[D])(implicit
-    traverseF: Traverse[F],
-    applicativeG: Applicative[G]
-  ): G[EitherT[F, C, D]] =
+  def bitraverse[G[_], C, D](f: A => G[C], g: B => G[D])(implicit traverseF: Traverse[F],
+                                                         applicativeG: Applicative[G]): G[EitherT[F, C, D]] =
     applicativeG.map(traverseF.traverse(value)(axb => Bitraverse[Either].bitraverse(axb)(f, g)))(EitherT.apply)
 
   def biflatMap[C, D](fa: A => EitherT[F, C, D], fb: B => EitherT[F, C, D])(implicit F: FlatMap[F]): EitherT[F, C, D] =
@@ -464,9 +462,8 @@ final case class EitherT[F[_], A, B](value: F[Either[A, B]]) {
   def ===(that: EitherT[F, A, B])(implicit eq: Eq[F[Either[A, B]]]): Boolean =
     eq.eqv(value, that.value)
 
-  def traverse[G[_], D](
-    f: B => G[D]
-  )(implicit traverseF: Traverse[F], applicativeG: Applicative[G]): G[EitherT[F, A, D]] =
+  def traverse[G[_], D](f: B => G[D])(implicit traverseF: Traverse[F],
+                                      applicativeG: Applicative[G]): G[EitherT[F, A, D]] =
     applicativeG.map(traverseF.traverse(value)(axb => Traverse[Either[A, *]].traverse(axb)(f)))(EitherT.apply)
 
   def foldLeft[C](c: C)(f: (C, B) => C)(implicit F: Foldable[F]): C =
@@ -762,9 +759,7 @@ object EitherT extends EitherTInstances {
    * }}}
    */
   final def liftAttemptK[F[_], E](implicit F: ApplicativeError[F, E]): F ~> EitherT[F, E, *] =
-    new (F ~> EitherT[F, E, *]) {
-      def apply[A](fa: F[A]): EitherT[F, E, A] = EitherT(F.attempt(fa))
-    }
+    Î»[F ~> EitherT[F, E, *]](fa => EitherT(F.attempt(fa)))
 
   @deprecated("Use EitherT.liftF.", "1.0.0-RC1")
   final def liftT[F[_], A, B](fb: F[B])(implicit F: Functor[F]): EitherT[F, A, B] = right(fb)
@@ -894,8 +889,8 @@ abstract private[data] class EitherTInstances extends EitherTInstances1 {
         EitherT(F.defer(fa.value))
     }
 
-  implicit def catsDataParallelForEitherTWithParallelEffect[M[_], E: Semigroup](implicit
-    P: Parallel[M]
+  implicit def catsDataParallelForEitherTWithParallelEffect[M[_], E: Semigroup](
+    implicit P: Parallel[M]
   ): Parallel.Aux[EitherT[M, E, *], Nested[P.F, Validated[E, *], *]] =
     new Parallel[EitherT[M, E, *]] {
       type F[x] = Nested[P.F, Validated[E, *], x]
@@ -928,8 +923,8 @@ abstract private[data] class EitherTInstances extends EitherTInstances1 {
 
 abstract private[data] class EitherTInstances1 extends EitherTInstances2 {
 
-  implicit def catsSemigroupForEitherT[F[_], L, A](implicit
-    F: Semigroup[F[Either[L, A]]]
+  implicit def catsSemigroupForEitherT[F[_], L, A](
+    implicit F: Semigroup[F[Either[L, A]]]
   ): Semigroup[EitherT[F, L, A]] =
     new EitherTSemigroup[F, L, A] { implicit val F0 = F }
 
@@ -938,8 +933,8 @@ abstract private[data] class EitherTInstances1 extends EitherTInstances2 {
       val F0: Foldable[F] = F
     }
 
-  implicit def catsDataPartialOrderForEitherT[F[_], L, R](implicit
-    F: PartialOrder[F[Either[L, R]]]
+  implicit def catsDataPartialOrderForEitherT[F[_], L, R](
+    implicit F: PartialOrder[F[Either[L, R]]]
   ): PartialOrder[EitherT[F, L, R]] =
     new EitherTPartialOrder[F, L, R] {
       val F0: PartialOrder[F[Either[L, R]]] = F
@@ -1003,8 +998,8 @@ abstract private[data] class EitherTInstances2 extends EitherTInstances3 {
    * res0: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(1)))
    * }}}
    */
-  implicit def catsDataMonadErrorFForEitherT[F[_], E, L](implicit
-    FE0: MonadError[F, E]
+  implicit def catsDataMonadErrorFForEitherT[F[_], E, L](
+    implicit FE0: MonadError[F, E]
   ): MonadError[EitherT[F, L, *], E] =
     new EitherTMonadErrorF[F, E, L] { implicit val F = FE0 }
 
@@ -1115,9 +1110,8 @@ sealed private[data] trait EitherTBifoldable[F[_]] extends Bifoldable[EitherT[F,
   def bifoldLeft[A, B, C](fab: EitherT[F, A, B], c: C)(f: (C, A) => C, g: (C, B) => C): C =
     F0.foldLeft(fab.value, c)((acc, axb) => Bifoldable[Either].bifoldLeft(axb, acc)(f, g))
 
-  def bifoldRight[A, B, C](fab: EitherT[F, A, B],
-                           c: Eval[C]
-  )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
+  def bifoldRight[A, B, C](fab: EitherT[F, A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
+                                                              g: (B, Eval[C]) => Eval[C]): Eval[C] =
     F0.foldRight(fab.value, c)((axb, acc) => Bifoldable[Either].bifoldRight(axb, acc)(f, g))
 }
 
diff --git a/core/src/main/scala/cats/data/Func.scala b/core/src/main/scala/cats/data/Func.scala
index 678262263..1c2daad80 100644
--- a/core/src/main/scala/cats/data/Func.scala
+++ b/core/src/main/scala/cats/data/Func.scala
@@ -57,8 +57,8 @@ abstract private[data] class FuncInstances1 {
       def F: Functor[F] = FF
     }
 
-  implicit def catsDataContravariantForFunc[F[_], C](implicit
-    FC: Contravariant[F]
+  implicit def catsDataContravariantForFunc[F[_], C](
+    implicit FC: Contravariant[F]
   ): Contravariant[Î»[Î± => Func[F, Î±, C]]] =
     new FuncContravariant[F, C] {
       def F: Contravariant[F] = FC
diff --git a/core/src/main/scala/cats/data/IdT.scala b/core/src/main/scala/cats/data/IdT.scala
index fc3276065..dff13cc5c 100644
--- a/core/src/main/scala/cats/data/IdT.scala
+++ b/core/src/main/scala/cats/data/IdT.scala
@@ -139,8 +139,8 @@ sealed private[data] trait IdTNonEmptyTraverse[F[_]]
 }
 
 sealed abstract private[data] class IdTInstances8 {
-  implicit def catsDataCommutativeFlatMapForIdT[F[_]](implicit
-    F: CommutativeFlatMap[F]
+  implicit def catsDataCommutativeFlatMapForIdT[F[_]](
+    implicit F: CommutativeFlatMap[F]
   ): CommutativeFlatMap[IdT[F, *]] =
     new IdTFlatMap[F] with CommutativeFlatMap[IdT[F, *]] { implicit val F0: CommutativeFlatMap[F] = F }
 }
@@ -151,8 +151,8 @@ sealed abstract private[data] class IdTInstances7 extends IdTInstances8 {
 }
 
 sealed abstract private[data] class IdTInstances6 extends IdTInstances7 {
-  implicit def catsDataContravariantMonoidalForIdT[F[_]](implicit
-    F: ContravariantMonoidal[F]
+  implicit def catsDataContravariantMonoidalForIdT[F[_]](
+    implicit F: ContravariantMonoidal[F]
   ): ContravariantMonoidal[IdT[F, *]] =
     new IdTContravariantMonoidal[F] { implicit val F0: ContravariantMonoidal[F] = F }
 }
diff --git a/core/src/main/scala/cats/data/IndexedReaderWriterStateT.scala b/core/src/main/scala/cats/data/IndexedReaderWriterStateT.scala
index d4d260cf9..c45c3df61 100644
--- a/core/src/main/scala/cats/data/IndexedReaderWriterStateT.scala
+++ b/core/src/main/scala/cats/data/IndexedReaderWriterStateT.scala
@@ -292,17 +292,15 @@ sealed private[data] trait CommonIRWSTConstructors {
   /**
    * Return `a` and an empty log without modifying the input state.
    */
-  def pure[F[_], E, L, S, A](
-    a: A
-  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def pure[F[_], E, L, S, A](a: A)(implicit F: Applicative[F],
+                                   L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.pure((L.empty, s, a)))
 
   /**
    * Return an effectful `a` and an empty log without modifying the input state.
    */
-  def liftF[F[_], E, L, S, A](
-    fa: F[A]
-  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def liftF[F[_], E, L, S, A](fa: F[A])(implicit F: Applicative[F],
+                                        L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.map(fa)((L.empty, s, _)))
 
   /**
@@ -321,41 +319,36 @@ sealed private[data] trait CommonIRWSTConstructors {
     }
 
   @deprecated("Use liftF instead", "1.0.0-RC2")
-  def lift[F[_], E, L, S, A](
-    fa: F[A]
-  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def lift[F[_], E, L, S, A](fa: F[A])(implicit F: Applicative[F],
+                                       L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.map(fa)((L.empty, s, _)))
 
   /**
    * Inspect a value from the input state, without modifying the state.
    */
-  def inspect[F[_], E, L, S, A](
-    f: S => A
-  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def inspect[F[_], E, L, S, A](f: S => A)(implicit F: Applicative[F],
+                                           L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.pure((L.empty, s, f(s))))
 
   /**
    * Like [[inspect]], but using an effectful function.
    */
-  def inspectF[F[_], E, L, S, A](
-    f: S => F[A]
-  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def inspectF[F[_], E, L, S, A](f: S => F[A])(implicit F: Applicative[F],
+                                               L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.map(f(s))((L.empty, s, _)))
 
   /**
    * Set the state to `s`.
    */
-  def set[F[_], E, L, S](
-    s: S
-  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, Unit] =
+  def set[F[_], E, L, S](s: S)(implicit F: Applicative[F],
+                               L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, Unit] =
     IndexedReaderWriterStateT((_, _) => F.pure((L.empty, s, ())))
 
   /**
    * Like [[set]], but using an effectful `S` value.
    */
-  def setF[F[_], E, L, S](
-    fs: F[S]
-  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, Unit] =
+  def setF[F[_], E, L, S](fs: F[S])(implicit F: Applicative[F],
+                                    L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, Unit] =
     IndexedReaderWriterStateT((_, _) => F.map(fs)((L.empty, _, ())))
 
   /**
@@ -402,17 +395,15 @@ object IndexedReaderWriterStateT extends IRWSTInstances with CommonIRWSTConstruc
   /**
    * Modify the input state using `f`.
    */
-  def modify[F[_], E, L, SA, SB](
-    f: SA => SB
-  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, SA, SB, Unit] =
+  def modify[F[_], E, L, SA, SB](f: SA => SB)(implicit F: Applicative[F],
+                                              L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, SA, SB, Unit] =
     IndexedReaderWriterStateT((_, s) => F.pure((L.empty, f(s), ())))
 
   /**
    * Like [[modify]], but using an effectful function.
    */
-  def modifyF[F[_], E, L, SA, SB](
-    f: SA => F[SB]
-  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, SA, SB, Unit] =
+  def modifyF[F[_], E, L, SA, SB](f: SA => F[SB])(implicit F: Applicative[F],
+                                                  L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, SA, SB, Unit] =
     IndexedReaderWriterStateT((_, s) => F.map(f(s))((L.empty, _, ())))
 
   /**
@@ -460,13 +451,12 @@ abstract private[data] class RWSTFunctions extends CommonIRWSTConstructors {
   /**
    * Like [[modify]], but using an effectful function.
    */
-  def modifyF[F[_], E, L, S](
-    f: S => F[S]
-  )(implicit F: Applicative[F], L: Monoid[L]): ReaderWriterStateT[F, E, L, S, Unit] =
+  def modifyF[F[_], E, L, S](f: S => F[S])(implicit F: Applicative[F],
+                                           L: Monoid[L]): ReaderWriterStateT[F, E, L, S, Unit] =
     ReaderWriterStateT((_, s) => F.map(f(s))((L.empty, _, ())))
 
-  def listen[F[_], E, L, S, A](rwst: ReaderWriterStateT[F, E, L, S, A])(implicit
-    F: Functor[F]
+  def listen[F[_], E, L, S, A](rwst: ReaderWriterStateT[F, E, L, S, A])(
+    implicit F: Functor[F]
   ): ReaderWriterStateT[F, E, L, S, (A, L)] = rwst.listen
 }
 
@@ -529,29 +519,29 @@ abstract private[data] class RWSFunctions {
 
 sealed abstract private[data] class IRWSTInstances extends IRWSTInstances1 {
 
-  implicit def catsDataStrongForIRWST[F[_], E, L, T](implicit
-    F0: Monad[F]
+  implicit def catsDataStrongForIRWST[F[_], E, L, T](
+    implicit F0: Monad[F]
   ): Strong[IndexedReaderWriterStateT[F, E, L, *, *, T]] =
     new IRWSTStrong[F, E, L, T] {
       implicit def F: Monad[F] = F0
     }
 
-  implicit def catsDataBifunctorForIRWST[F[_], E, L, SA](implicit
-    F0: Functor[F]
+  implicit def catsDataBifunctorForIRWST[F[_], E, L, SA](
+    implicit F0: Functor[F]
   ): Bifunctor[IndexedReaderWriterStateT[F, E, L, SA, *, *]] =
     new IRWSTBifunctor[F, E, L, SA] {
       implicit def F: Functor[F] = F0
     }
 
-  implicit def catsDataContravariantForIRWST[F[_], E, L, SB, T](implicit
-    F0: Functor[F]
+  implicit def catsDataContravariantForIRWST[F[_], E, L, SB, T](
+    implicit F0: Functor[F]
   ): Contravariant[IndexedReaderWriterStateT[F, E, L, *, SB, T]] =
     new IRWSTContravariant[F, E, L, SB, T] {
       implicit def F: Functor[F] = F0
     }
 
-  implicit def catsDataMonadErrorForIRWST[F[_], E, L, S, R](implicit
-    F0: MonadError[F, R],
+  implicit def catsDataMonadErrorForIRWST[F[_], E, L, S, R](
+    implicit F0: MonadError[F, R],
     L0: Monoid[L]
   ): MonadError[IndexedReaderWriterStateT[F, E, L, S, S, *], R] =
     new RWSTMonadError[F, E, L, S, R] {
@@ -559,8 +549,8 @@ sealed abstract private[data] class IRWSTInstances extends IRWSTInstances1 {
       implicit def L: Monoid[L] = L0
     }
 
-  implicit def catsDataDeferForIRWST[F[_], E, L, SA, SB](implicit
-    F: Defer[F]
+  implicit def catsDataDeferForIRWST[F[_], E, L, SA, SB](
+    implicit F: Defer[F]
   ): Defer[IndexedReaderWriterStateT[F, E, L, SA, SB, *]] =
     new Defer[IndexedReaderWriterStateT[F, E, L, SA, SB, *]] {
       def defer[A](
@@ -572,17 +562,15 @@ sealed abstract private[data] class IRWSTInstances extends IRWSTInstances1 {
 }
 
 sealed abstract private[data] class IRWSTInstances1 extends IRWSTInstances2 {
-  implicit def catsDataMonadForRWST[F[_], E, L, S](implicit
-    F0: Monad[F],
-    L0: Monoid[L]
-  ): Monad[ReaderWriterStateT[F, E, L, S, *]] =
+  implicit def catsDataMonadForRWST[F[_], E, L, S](implicit F0: Monad[F],
+                                                   L0: Monoid[L]): Monad[ReaderWriterStateT[F, E, L, S, *]] =
     new RWSTMonad[F, E, L, S] {
       implicit def F: Monad[F] = F0
       implicit def L: Monoid[L] = L0
     }
 
-  implicit def catsDataProfunctorForIRWST[F[_], E, L, T](implicit
-    F0: Functor[F]
+  implicit def catsDataProfunctorForIRWST[F[_], E, L, T](
+    implicit F0: Functor[F]
   ): Profunctor[IndexedReaderWriterStateT[F, E, L, *, *, T]] =
     new IRWSTProfunctor[F, E, L, T] {
       implicit def F: Functor[F] = F0
@@ -591,8 +579,8 @@ sealed abstract private[data] class IRWSTInstances1 extends IRWSTInstances2 {
 }
 
 sealed abstract private[data] class IRWSTInstances2 extends IRWSTInstances3 {
-  implicit def catsDataAlternativeForIRWST[F[_], E, L, S](implicit
-    FM: Monad[F],
+  implicit def catsDataAlternativeForIRWST[F[_], E, L, S](
+    implicit FM: Monad[F],
     FA: Alternative[F],
     L0: Monoid[L]
   ): Alternative[IndexedReaderWriterStateT[F, E, L, S, S, *]] =
@@ -604,8 +592,8 @@ sealed abstract private[data] class IRWSTInstances2 extends IRWSTInstances3 {
 }
 
 sealed abstract private[data] class IRWSTInstances3 {
-  implicit def catsDataSemigroupKForIRWST[F[_], E, L, SA, SB](implicit
-    F0: Monad[F],
+  implicit def catsDataSemigroupKForIRWST[F[_], E, L, SA, SB](
+    implicit F0: Monad[F],
     G0: SemigroupK[F]
   ): SemigroupK[IndexedReaderWriterStateT[F, E, L, SA, SB, *]] =
     new IRWSTSemigroupK[F, E, L, SA, SB] {
@@ -613,8 +601,8 @@ sealed abstract private[data] class IRWSTInstances3 {
       implicit def G: SemigroupK[F] = G0
     }
 
-  implicit def catsDataFunctorForIRWST[F[_], E, L, SA, SB](implicit
-    F0: Functor[F]
+  implicit def catsDataFunctorForIRWST[F[_], E, L, SA, SB](
+    implicit F0: Functor[F]
   ): Functor[IndexedReaderWriterStateT[F, E, L, SA, SB, *]] =
     new IRWSTFunctor[F, E, L, SA, SB] {
       implicit def F: Functor[F] = F0
@@ -741,8 +729,7 @@ private trait IRWSTSemigroupK1[F[_], E, L, SA, SB] extends SemigroupK[IndexedRea
   implicit def G: SemigroupK[F]
 
   def combineK[A](x: IndexedReaderWriterStateT[F, E, L, SA, SB, A],
-                  y: IndexedReaderWriterStateT[F, E, L, SA, SB, A]
-  ): IndexedReaderWriterStateT[F, E, L, SA, SB, A] =
+                  y: IndexedReaderWriterStateT[F, E, L, SA, SB, A]): IndexedReaderWriterStateT[F, E, L, SA, SB, A] =
     IndexedReaderWriterStateT { (e, sa) =>
       G.combineK(x.run(e, sa), y.run(e, sa))
     }
diff --git a/core/src/main/scala/cats/data/IndexedStateT.scala b/core/src/main/scala/cats/data/IndexedStateT.scala
index 758ff042d..43dac315a 100644
--- a/core/src/main/scala/cats/data/IndexedStateT.scala
+++ b/core/src/main/scala/cats/data/IndexedStateT.scala
@@ -119,9 +119,8 @@ final class IndexedStateT[F[_], SA, SB, A](val runF: F[SA => F[(SB, A)]]) extend
    * res1: Option[(Int, Int)] = Some((5,5))
    * }}}
    */
-  def transformF[G[_], B, SC](
-    f: F[(SB, A)] => G[(SC, B)]
-  )(implicit F: FlatMap[F], G: Applicative[G]): IndexedStateT[G, SA, SC, B] =
+  def transformF[G[_], B, SC](f: F[(SB, A)] => G[(SC, B)])(implicit F: FlatMap[F],
+                                                           G: Applicative[G]): IndexedStateT[G, SA, SC, B] =
     IndexedStateT(s => f(run(s)))
 
   /**
@@ -248,8 +247,8 @@ abstract private[data] class StateTFunctions extends CommonStateTConstructors {
 }
 
 sealed abstract private[data] class IndexedStateTInstances extends IndexedStateTInstances1 {
-  implicit def catsDataAlternativeForIndexedStateT[F[_], S](implicit
-    FM: Monad[F],
+  implicit def catsDataAlternativeForIndexedStateT[F[_], S](
+    implicit FM: Monad[F],
     FA: Alternative[F]
   ): Alternative[IndexedStateT[F, S, S, *]] with Monad[IndexedStateT[F, S, S, *]] =
     new IndexedStateTAlternative[F, S] { implicit def F = FM; implicit def G = FA }
@@ -260,7 +259,8 @@ sealed abstract private[data] class IndexedStateTInstances extends IndexedStateT
         IndexedStateT.applyF(F.defer(fa.runF))
     }
 
-  implicit def catsDataFunctorFilterForIndexedStateT[F[_], SA, SB](implicit
+  implicit def catsDataFunctorFilterForIndexedStateT[F[_], SA, SB](
+    implicit
     ev1: Monad[F],
     ev2: FunctorFilter[F]
   ): FunctorFilter[IndexedStateT[F, SA, SB, *]] =
@@ -271,13 +271,13 @@ sealed abstract private[data] class IndexedStateTInstances extends IndexedStateT
 }
 
 sealed abstract private[data] class IndexedStateTInstances1 extends IndexedStateTInstances2 {
-  implicit def catsDataMonadErrorForIndexedStateT[F[_], S, E](implicit
-    F0: MonadError[F, E]
+  implicit def catsDataMonadErrorForIndexedStateT[F[_], S, E](
+    implicit F0: MonadError[F, E]
   ): MonadError[IndexedStateT[F, S, S, *], E] =
     new IndexedStateTMonadError[F, S, E] { implicit def F = F0 }
 
-  implicit def catsDataSemigroupKForIndexedStateT[F[_], SA, SB](implicit
-    F0: Monad[F],
+  implicit def catsDataSemigroupKForIndexedStateT[F[_], SA, SB](
+    implicit F0: Monad[F],
     G0: SemigroupK[F]
   ): SemigroupK[IndexedStateT[F, SA, SB, *]] =
     new IndexedStateTSemigroupK[F, SA, SB] { implicit def F = F0; implicit def G = G0 }
@@ -289,23 +289,23 @@ sealed abstract private[data] class IndexedStateTInstances2 extends IndexedState
 }
 
 sealed abstract private[data] class IndexedStateTInstances3 extends IndexedStateTInstances4 {
-  implicit def catsDataFunctorForIndexedStateT[F[_], SA, SB](implicit
-    F0: Functor[F]
+  implicit def catsDataFunctorForIndexedStateT[F[_], SA, SB](
+    implicit F0: Functor[F]
   ): Functor[IndexedStateT[F, SA, SB, *]] =
     new IndexedStateTFunctor[F, SA, SB] { implicit def F = F0 }
 
-  implicit def catsDataContravariantForIndexedStateT[F[_], SB, V](implicit
-    F0: Functor[F]
+  implicit def catsDataContravariantForIndexedStateT[F[_], SB, V](
+    implicit F0: Functor[F]
   ): Contravariant[IndexedStateT[F, *, SB, V]] =
     new IndexedStateTContravariant[F, SB, V] { implicit def F = F0 }
 
-  implicit def catsDataProfunctorForIndexedStateT[F[_], V](implicit
-    F0: Functor[F]
+  implicit def catsDataProfunctorForIndexedStateT[F[_], V](
+    implicit F0: Functor[F]
   ): Profunctor[IndexedStateT[F, *, *, V]] =
     new IndexedStateTProfunctor[F, V] { implicit def F = F0 }
 
-  implicit def catsDataBifunctorForIndexedStateT[F[_], SA](implicit
-    F0: Functor[F]
+  implicit def catsDataBifunctorForIndexedStateT[F[_], SA](
+    implicit F0: Functor[F]
   ): Bifunctor[IndexedStateT[F, SA, *, *]] =
     new IndexedStateTBifunctor[F, SA] { implicit def F = F0 }
 }
@@ -465,13 +465,11 @@ sealed abstract private[data] class IndexedStateTContravariantMonoidal[F[_], S]
     contramap2(fa, trivial)(((a: A) => (a, a)).compose(f))
 
   override def product[A, B](fa: IndexedStateT[F, S, S, A],
-                             fb: IndexedStateT[F, S, S, B]
-  ): IndexedStateT[F, S, S, (A, B)] =
+                             fb: IndexedStateT[F, S, S, B]): IndexedStateT[F, S, S, (A, B)] =
     contramap2(fa, fb)(identity)
 
-  def contramap2[A, B, C](fb: IndexedStateT[F, S, S, B], fc: IndexedStateT[F, S, S, C])(
-    f: A => (B, C)
-  ): IndexedStateT[F, S, S, A] =
+  def contramap2[A, B, C](fb: IndexedStateT[F, S, S, B],
+                          fc: IndexedStateT[F, S, S, C])(f: A => (B, C)): IndexedStateT[F, S, S, A] =
     IndexedStateT.applyF(
       G.pure((s: S) =>
         ContravariantMonoidal.contramap2(G.map(fb.runF)(_.apply(s)), G.map(fc.runF)(_.apply(s)))((tup: (S, A)) =>
diff --git a/core/src/main/scala/cats/data/Ior.scala b/core/src/main/scala/cats/data/Ior.scala
index 5230df208..6404160aa 100644
--- a/core/src/main/scala/cats/data/Ior.scala
+++ b/core/src/main/scala/cats/data/Ior.scala
@@ -47,12 +47,11 @@ sealed abstract class Ior[+A, +B] extends Product with Serializable {
    * res2: String = abc123
    * }}}
    */
-  final def fold[C](fa: A => C, fb: B => C, fab: (A, B) => C): C =
-    this match {
-      case Ior.Left(a)    => fa(a)
-      case Ior.Right(b)   => fb(b)
-      case Ior.Both(a, b) => fab(a, b)
-    }
+  final def fold[C](fa: A => C, fb: B => C, fab: (A, B) => C): C = this match {
+    case Ior.Left(a)    => fa(a)
+    case Ior.Right(b)   => fb(b)
+    case Ior.Both(a, b) => fab(a, b)
+  }
 
   /**
    * Example:
@@ -563,29 +562,27 @@ sealed abstract class Ior[+A, +B] extends Product with Serializable {
    * res5: Ior[String, Int] = Both(abcerror,456)
    * }}}
    */
-  final def flatMap[AA >: A, D](f: B => AA Ior D)(implicit AA: Semigroup[AA]): AA Ior D =
-    this match {
-      case l @ Ior.Left(_) => l
-      case Ior.Right(b)    => f(b)
-      case Ior.Both(a1, b) =>
-        f(b) match {
-          case Ior.Left(a2)    => Ior.Left(AA.combine(a1, a2))
-          case Ior.Right(b)    => Ior.Both(a1, b)
-          case Ior.Both(a2, d) => Ior.Both(AA.combine(a1, a2), d)
-        }
-    }
+  final def flatMap[AA >: A, D](f: B => AA Ior D)(implicit AA: Semigroup[AA]): AA Ior D = this match {
+    case l @ Ior.Left(_) => l
+    case Ior.Right(b)    => f(b)
+    case Ior.Both(a1, b) =>
+      f(b) match {
+        case Ior.Left(a2)    => Ior.Left(AA.combine(a1, a2))
+        case Ior.Right(b)    => Ior.Both(a1, b)
+        case Ior.Both(a2, d) => Ior.Both(AA.combine(a1, a2), d)
+      }
+  }
 
   final def foreach(f: B => Unit): Unit = {
     bimap(_ => (), f)
     ()
   }
 
-  final def traverse[F[_], AA >: A, D](g: B => F[D])(implicit F: Applicative[F]): F[AA Ior D] =
-    this match {
-      case Ior.Left(a)    => F.pure(Ior.left(a))
-      case Ior.Right(b)   => F.map(g(b))(Ior.right)
-      case Ior.Both(a, b) => F.map(g(b))(d => Ior.both(a, d))
-    }
+  final def traverse[F[_], AA >: A, D](g: B => F[D])(implicit F: Applicative[F]): F[AA Ior D] = this match {
+    case Ior.Left(a)    => F.pure(Ior.left(a))
+    case Ior.Right(b)   => F.map(g(b))(Ior.right)
+    case Ior.Both(a, b) => F.map(g(b))(d => Ior.both(a, d))
+  }
 
   /**
    * Example:
@@ -665,19 +662,17 @@ sealed abstract class Ior[+A, +B] extends Product with Serializable {
     }
   // scalastyle:on cyclomatic.complexity
 
-  final def ===[AA >: A, BB >: B](that: AA Ior BB)(implicit AA: Eq[AA], BB: Eq[BB]): Boolean =
-    fold(
-      a => that.fold(a2 => AA.eqv(a, a2), b2 => false, (a2, b2) => false),
-      b => that.fold(a2 => false, b2 => BB.eqv(b, b2), (a2, b2) => false),
-      (a, b) => that.fold(a2 => false, b2 => false, (a2, b2) => AA.eqv(a, a2) && BB.eqv(b, b2))
-    )
-
-  final def show[AA >: A, BB >: B](implicit AA: Show[AA], BB: Show[BB]): String =
-    fold(
-      a => s"Ior.Left(${AA.show(a)})",
-      b => s"Ior.Right(${BB.show(b)})",
-      (a, b) => s"Ior.Both(${AA.show(a)}, ${BB.show(b)})"
-    )
+  final def ===[AA >: A, BB >: B](that: AA Ior BB)(implicit AA: Eq[AA], BB: Eq[BB]): Boolean = fold(
+    a => that.fold(a2 => AA.eqv(a, a2), b2 => false, (a2, b2) => false),
+    b => that.fold(a2 => false, b2 => BB.eqv(b, b2), (a2, b2) => false),
+    (a, b) => that.fold(a2 => false, b2 => false, (a2, b2) => AA.eqv(a, a2) && BB.eqv(b, b2))
+  )
+
+  final def show[AA >: A, BB >: B](implicit AA: Show[AA], BB: Show[BB]): String = fold(
+    a => s"Ior.Left(${AA.show(a)})",
+    b => s"Ior.Right(${BB.show(b)})",
+    (a, b) => s"Ior.Both(${AA.show(a)}, ${BB.show(b)})"
+  )
 }
 
 object Ior extends IorInstances with IorFunctions with IorFunctions2 {
@@ -690,9 +685,8 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
 
   implicit val catsBitraverseForIor: Bitraverse[Ior] = new Bitraverse[Ior] {
 
-    def bitraverse[G[_], A, B, C, D](
-      fab: Ior[A, B]
-    )(f: A => G[C], g: B => G[D])(implicit G: Applicative[G]): G[Ior[C, D]] =
+    def bitraverse[G[_], A, B, C, D](fab: Ior[A, B])(f: A => G[C],
+                                                     g: B => G[D])(implicit G: Applicative[G]): G[Ior[C, D]] =
       fab match {
         case Ior.Left(a)    => G.map(f(a))(Ior.Left(_))
         case Ior.Right(b)   => G.map(g(b))(Ior.Right(_))
@@ -706,9 +700,8 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
         case Ior.Both(a, b) => g(f(c, a), b)
       }
 
-    def bifoldRight[A, B, C](fab: Ior[A, B],
-                             c: Eval[C]
-    )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
+    def bifoldRight[A, B, C](fab: Ior[A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
+                                                         g: (B, Eval[C]) => Eval[C]): Eval[C] =
       fab match {
         case Ior.Left(a)    => f(a, c)
         case Ior.Right(b)   => g(b, c)
@@ -716,20 +709,17 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
       }
   }
 
-  implicit def catsDataEqForIor[A: Eq, B: Eq]: Eq[A Ior B] =
-    new Eq[A Ior B] {
-      def eqv(x: A Ior B, y: A Ior B): Boolean = x === y
-    }
+  implicit def catsDataEqForIor[A: Eq, B: Eq]: Eq[A Ior B] = new Eq[A Ior B] {
+    def eqv(x: A Ior B, y: A Ior B): Boolean = x === y
+  }
 
-  implicit def catsDataShowForIor[A: Show, B: Show]: Show[A Ior B] =
-    new Show[A Ior B] {
-      def show(f: A Ior B): String = f.show
-    }
+  implicit def catsDataShowForIor[A: Show, B: Show]: Show[A Ior B] = new Show[A Ior B] {
+    def show(f: A Ior B): String = f.show
+  }
 
-  implicit def catsDataSemigroupForIor[A: Semigroup, B: Semigroup]: Semigroup[Ior[A, B]] =
-    new Semigroup[Ior[A, B]] {
-      def combine(x: Ior[A, B], y: Ior[A, B]) = x.combine(y)
-    }
+  implicit def catsDataSemigroupForIor[A: Semigroup, B: Semigroup]: Semigroup[Ior[A, B]] = new Semigroup[Ior[A, B]] {
+    def combine(x: Ior[A, B], y: Ior[A, B]) = x.combine(y)
+  }
 
   implicit def catsDataMonadErrorForIor[A: Semigroup]: MonadError[Ior[A, *], A] =
     new MonadError[Ior[A, *], A] {
@@ -752,19 +742,18 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
 
       def tailRecM[B, C](b: B)(fn: B => Ior[A, Either[B, C]]): A Ior C = {
         @tailrec
-        def loop(v: Ior[A, Either[B, C]]): A Ior C =
-          v match {
-            case Ior.Left(a)           => Ior.left(a)
-            case Ior.Right(Right(c))   => Ior.right(c)
-            case Ior.Both(a, Right(c)) => Ior.both(a, c)
-            case Ior.Right(Left(b))    => loop(fn(b))
-            case Ior.Both(a, Left(b)) =>
-              fn(b) match {
-                case Ior.Left(aa)    => Ior.left(Semigroup[A].combine(a, aa))
-                case Ior.Both(aa, x) => loop(Ior.both(Semigroup[A].combine(a, aa), x))
-                case Ior.Right(x)    => loop(Ior.both(a, x))
-              }
-          }
+        def loop(v: Ior[A, Either[B, C]]): A Ior C = v match {
+          case Ior.Left(a)           => Ior.left(a)
+          case Ior.Right(Right(c))   => Ior.right(c)
+          case Ior.Both(a, Right(c)) => Ior.both(a, c)
+          case Ior.Right(Left(b))    => loop(fn(b))
+          case Ior.Both(a, Left(b)) =>
+            fn(b) match {
+              case Ior.Left(aa)    => Ior.left(Semigroup[A].combine(a, aa))
+              case Ior.Both(aa, x) => loop(Ior.both(Semigroup[A].combine(a, aa), x))
+              case Ior.Right(x)    => loop(Ior.both(a, x))
+            }
+        }
         loop(fn(b))
       }
 
@@ -822,27 +811,26 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
 
 sealed abstract private[data] class IorInstances0 {
 
-  implicit def catsDataTraverseFunctorForIor[A]: Traverse[Ior[A, *]] =
-    new Traverse[Ior[A, *]] {
-      def traverse[F[_]: Applicative, B, C](fa: A Ior B)(f: B => F[C]): F[A Ior C] =
-        fa.traverse(f)
-      def foldLeft[B, C](fa: A Ior B, b: C)(f: (C, B) => C): C =
-        fa.foldLeft(b)(f)
-      def foldRight[B, C](fa: A Ior B, lc: Eval[C])(f: (B, Eval[C]) => Eval[C]): Eval[C] =
-        fa.foldRight(lc)(f)
+  implicit def catsDataTraverseFunctorForIor[A]: Traverse[Ior[A, *]] = new Traverse[Ior[A, *]] {
+    def traverse[F[_]: Applicative, B, C](fa: A Ior B)(f: B => F[C]): F[A Ior C] =
+      fa.traverse(f)
+    def foldLeft[B, C](fa: A Ior B, b: C)(f: (C, B) => C): C =
+      fa.foldLeft(b)(f)
+    def foldRight[B, C](fa: A Ior B, lc: Eval[C])(f: (B, Eval[C]) => Eval[C]): Eval[C] =
+      fa.foldRight(lc)(f)
 
-      override def size[B](fa: A Ior B): Long = fa.fold(_ => 0L, _ => 1L, (_, _) => 1L)
+    override def size[B](fa: A Ior B): Long = fa.fold(_ => 0L, _ => 1L, (_, _) => 1L)
 
-      override def get[B](fa: A Ior B)(idx: Long): Option[B] =
-        if (idx == 0L) fa.toOption else None
+    override def get[B](fa: A Ior B)(idx: Long): Option[B] =
+      if (idx == 0L) fa.toOption else None
 
-      override def forall[B](fa: Ior[A, B])(p: (B) => Boolean): Boolean = fa.forall(p)
+    override def forall[B](fa: Ior[A, B])(p: (B) => Boolean): Boolean = fa.forall(p)
 
-      override def exists[B](fa: Ior[A, B])(p: (B) => Boolean): Boolean = fa.exists(p)
+    override def exists[B](fa: Ior[A, B])(p: (B) => Boolean): Boolean = fa.exists(p)
 
-      override def map[B, C](fa: A Ior B)(f: B => C): A Ior C =
-        fa.map(f)
-    }
+    override def map[B, C](fa: A Ior B)(f: B => C): A Ior C =
+      fa.map(f)
+  }
 }
 
 sealed private[data] trait IorFunctions {
diff --git a/core/src/main/scala/cats/data/IorT.scala b/core/src/main/scala/cats/data/IorT.scala
index cacfa6623..acf8e92d8 100644
--- a/core/src/main/scala/cats/data/IorT.scala
+++ b/core/src/main/scala/cats/data/IorT.scala
@@ -417,38 +417,37 @@ abstract private[data] class IorTInstances extends IorTInstances1 {
   implicit def catsDataMonoidForIorT[F[_], A, B](implicit F: Monoid[F[Ior[A, B]]]): Monoid[IorT[F, A, B]] =
     new IorTMonoid[F, A, B] { val F0: Monoid[F[Ior[A, B]]] = F }
 
-  implicit def catsDataParallelForIorTWithParallelEffect[M[_], E](implicit
-    P: Parallel[M],
+  implicit def catsDataParallelForIorTWithParallelEffect[M[_], E](
+    implicit P: Parallel[M],
     E: Semigroup[E]
-  ): Parallel.Aux[IorT[M, E, *], IorT[P.F, E, *]] { type Dummy } =
-    new Parallel[IorT[M, E, *]] {
-      type F[x] = IorT[P.F, E, x]
-      type Dummy // fix to make this one more specific than the catsDataParallelForIorTWithSequentialEffect, see https://github.com/typelevel/cats/pull/2335#issuecomment-408249775
-
-      val parallel: IorT[M, E, *] ~> IorT[P.F, E, *] =
-        new (IorT[M, E, *] ~> IorT[P.F, E, *]) {
-          def apply[A](fm: IorT[M, E, A]): IorT[P.F, E, A] = IorT(P.parallel(fm.value))
-        }
-      val sequential: IorT[P.F, E, *] ~> IorT[M, E, *] =
-        new (IorT[P.F, E, *] ~> IorT[M, E, *]) {
-          def apply[A](ff: IorT[P.F, E, A]): IorT[M, E, A] = IorT(P.sequential(ff.value))
-        }
+  ): Parallel.Aux[IorT[M, E, *], IorT[P.F, E, *]] { type Dummy } = new Parallel[IorT[M, E, *]] {
+    type F[x] = IorT[P.F, E, x]
+    type Dummy // fix to make this one more specific than the catsDataParallelForIorTWithSequentialEffect, see https://github.com/typelevel/cats/pull/2335#issuecomment-408249775
 
-      private[this] val FA: Applicative[P.F] = P.applicative
-      private[this] val IorA: Applicative[Ior[E, *]] = Parallel[Ior[E, *], Ior[E, *]].applicative
-
-      val applicative: Applicative[IorT[P.F, E, *]] = new Applicative[IorT[P.F, E, *]] {
-        def pure[A](a: A): IorT[P.F, E, A] = IorT.pure(a)(FA)
-        def ap[A, B](ff: IorT[P.F, E, A => B])(fa: IorT[P.F, E, A]): IorT[P.F, E, B] =
-          IorT(FA.map2(ff.value, fa.value)((f, a) => IorA.ap(f)(a)))
+    val parallel: IorT[M, E, *] ~> IorT[P.F, E, *] =
+      new (IorT[M, E, *] ~> IorT[P.F, E, *]) {
+        def apply[A](fm: IorT[M, E, A]): IorT[P.F, E, A] = IorT(P.parallel(fm.value))
       }
-
-      lazy val monad: Monad[IorT[M, E, *]] = {
-        implicit def underlyingMonadM: Monad[M] = P.monad
-        Monad[IorT[M, E, *]]
+    val sequential: IorT[P.F, E, *] ~> IorT[M, E, *] =
+      new (IorT[P.F, E, *] ~> IorT[M, E, *]) {
+        def apply[A](ff: IorT[P.F, E, A]): IorT[M, E, A] = IorT(P.sequential(ff.value))
       }
+
+    private[this] val FA: Applicative[P.F] = P.applicative
+    private[this] val IorA: Applicative[Ior[E, *]] = Parallel[Ior[E, *], Ior[E, *]].applicative
+
+    val applicative: Applicative[IorT[P.F, E, *]] = new Applicative[IorT[P.F, E, *]] {
+      def pure[A](a: A): IorT[P.F, E, A] = IorT.pure(a)(FA)
+      def ap[A, B](ff: IorT[P.F, E, A => B])(fa: IorT[P.F, E, A]): IorT[P.F, E, B] =
+        IorT(FA.map2(ff.value, fa.value)((f, a) => IorA.ap(f)(a)))
     }
 
+    lazy val monad: Monad[IorT[M, E, *]] = {
+      implicit def underlyingMonadM: Monad[M] = P.monad
+      Monad[IorT[M, E, *]]
+    }
+  }
+
   implicit def catsDataDeferForIor[F[_], E](implicit F: Defer[F]): Defer[IorT[F, E, *]] =
     new Defer[IorT[F, E, *]] {
       def defer[A](fa: => IorT[F, E, A]): IorT[F, E, A] =
@@ -469,35 +468,32 @@ abstract private[data] class IorTInstances1 extends IorTInstances2 {
       val F0: Monad[F] = F
     }
 
-  implicit def catsDataParallelForIorTWithSequentialEffect[F0[_], E](implicit
-    F: Monad[F0],
+  implicit def catsDataParallelForIorTWithSequentialEffect[F0[_], E](
+    implicit F: Monad[F0],
     E: Semigroup[E]
-  ): Parallel.Aux[IorT[F0, E, *], IorT[F0, E, *]] =
-    new Parallel[IorT[F0, E, *]] {
-      type F[x] = IorT[F0, E, x]
-      private[this] val identityK: IorT[F0, E, *] ~> IorT[F0, E, *] = FunctionK.id
-      private[this] val underlyingParallel: Parallel.Aux[Ior[E, *], Ior[E, *]] =
-        Ior.catsDataParallelForIor[E]
-
-      def parallel: IorT[F0, E, *] ~> IorT[F0, E, *] = identityK
-      def sequential: IorT[F0, E, *] ~> IorT[F0, E, *] = identityK
-
-      val applicative: Applicative[IorT[F0, E, *]] = new Applicative[IorT[F0, E, *]] {
-        def pure[A](a: A): IorT[F0, E, A] = IorT.pure(a)
-        def ap[A, B](ff: IorT[F0, E, A => B])(fa: IorT[F0, E, A]): IorT[F0, E, B] =
-          IorT(F.map2(ff.value, fa.value)((f, a) => underlyingParallel.applicative.ap[A, B](f)(a)))
-      }
-
-      lazy val monad: Monad[IorT[F0, E, *]] = Monad[IorT[F0, E, *]]
+  ): Parallel.Aux[IorT[F0, E, *], IorT[F0, E, *]] = new Parallel[IorT[F0, E, *]] {
+    type F[x] = IorT[F0, E, x]
+    private[this] val identityK: IorT[F0, E, *] ~> IorT[F0, E, *] = FunctionK.id
+    private[this] val underlyingParallel: Parallel.Aux[Ior[E, *], Ior[E, *]] =
+      Ior.catsDataParallelForIor[E]
+
+    def parallel: IorT[F0, E, *] ~> IorT[F0, E, *] = identityK
+    def sequential: IorT[F0, E, *] ~> IorT[F0, E, *] = identityK
+
+    val applicative: Applicative[IorT[F0, E, *]] = new Applicative[IorT[F0, E, *]] {
+      def pure[A](a: A): IorT[F0, E, A] = IorT.pure(a)
+      def ap[A, B](ff: IorT[F0, E, A => B])(fa: IorT[F0, E, A]): IorT[F0, E, B] =
+        IorT(F.map2(ff.value, fa.value)((f, a) => underlyingParallel.applicative.ap[A, B](f)(a)))
     }
 
+    lazy val monad: Monad[IorT[F0, E, *]] = Monad[IorT[F0, E, *]]
+  }
+
 }
 
 abstract private[data] class IorTInstances2 extends IorTInstances3 {
-  implicit def catsDataMonadErrorFForIorT[F[_], A, E](implicit
-    FE: MonadError[F, E],
-    A: Semigroup[A]
-  ): MonadError[IorT[F, A, *], E] =
+  implicit def catsDataMonadErrorFForIorT[F[_], A, E](implicit FE: MonadError[F, E],
+                                                      A: Semigroup[A]): MonadError[IorT[F, A, *], E] =
     new IorTMonadErrorF[F, A, E] {
       val A0: Semigroup[A] = A
       val F0: MonadError[F, E] = FE
diff --git a/core/src/main/scala/cats/data/Kleisli.scala b/core/src/main/scala/cats/data/Kleisli.scala
index d88556791..a4953cf0b 100644
--- a/core/src/main/scala/cats/data/Kleisli.scala
+++ b/core/src/main/scala/cats/data/Kleisli.scala
@@ -297,21 +297,21 @@ sealed abstract private[data] class KleisliInstances extends KleisliInstances0 {
       }
     }
 
-  implicit def catsDataFunctorFilterForKleisli[F[_], A](implicit
-    ev: FunctorFilter[F]
+  implicit def catsDataFunctorFilterForKleisli[F[_], A](
+    implicit ev: FunctorFilter[F]
   ): FunctorFilter[Kleisli[F, A, *]] =
     new KleisliFunctorFilter[F, A] { val FF = ev }
 }
 
 sealed abstract private[data] class KleisliInstances0 extends KleisliInstances0_5 {
 
-  implicit def catsDataCommutativeArrowForKleisli[F[_]](implicit
-    M: CommutativeMonad[F]
+  implicit def catsDataCommutativeArrowForKleisli[F[_]](
+    implicit M: CommutativeMonad[F]
   ): CommutativeArrow[Kleisli[F, *, *]] with ArrowChoice[Kleisli[F, *, *]] =
     new KleisliCommutativeArrow[F] { def F: CommutativeMonad[F] = M }
 
-  implicit def catsDataCommutativeMonadForKleisli[F[_], A](implicit
-    F0: CommutativeMonad[F]
+  implicit def catsDataCommutativeMonadForKleisli[F[_], A](
+    implicit F0: CommutativeMonad[F]
   ): CommutativeMonad[Kleisli[F, A, *]] =
     new KleisliMonad[F, A] with CommutativeMonad[Kleisli[F, A, *]] {
       implicit def F: Monad[F] = F0
@@ -323,8 +323,8 @@ sealed abstract private[data] class KleisliInstances0_5 extends KleisliInstances
   implicit def catsDataMonoidForKleisli[F[_], A, B](implicit FB0: Monoid[F[B]]): Monoid[Kleisli[F, A, B]] =
     new KleisliMonoid[F, A, B] { def FB: Monoid[F[B]] = FB0 }
 
-  implicit def catsDataMonadErrorForKleisli[F[_], A, E](implicit
-    ME: MonadError[F, E]
+  implicit def catsDataMonadErrorForKleisli[F[_], A, E](
+    implicit ME: MonadError[F, E]
   ): MonadError[Kleisli[F, A, *], E] =
     new KleisliMonadError[F, A, E] { def F: MonadError[F, E] = ME }
 
@@ -333,8 +333,8 @@ sealed abstract private[data] class KleisliInstances0_5 extends KleisliInstances
       def F: Monad[F] = M
     }
 
-  implicit def catsDataContravariantMonoidalForKleisli[F[_], A](implicit
-    F0: ContravariantMonoidal[F]
+  implicit def catsDataContravariantMonoidalForKleisli[F[_], A](
+    implicit F0: ContravariantMonoidal[F]
   ): ContravariantMonoidal[Kleisli[F, A, *]] =
     new KleisliContravariantMonoidal[F, A] { def F: ContravariantMonoidal[F] = F0 }
 
@@ -342,48 +342,47 @@ sealed abstract private[data] class KleisliInstances0_5 extends KleisliInstances
    * Witness for: Kleisli[M, E, A] <-> (E, R) => A
    * if M is Representable
    */
-  implicit def catsDataRepresentableForKleisli[M[_], R, E](implicit
+  implicit def catsDataRepresentableForKleisli[M[_], R, E](
+    implicit
     R: Representable.Aux[M, R],
     FK: Functor[Kleisli[M, E, *]]
-  ): Representable.Aux[Kleisli[M, E, *], (E, R)] =
-    new Representable[Kleisli[M, E, *]] {
+  ): Representable.Aux[Kleisli[M, E, *], (E, R)] = new Representable[Kleisli[M, E, *]] {
 
-      override type Representation = (E, R)
+    override type Representation = (E, R)
 
-      override val F: Functor[Kleisli[M, E, *]] = FK
+    override val F: Functor[Kleisli[M, E, *]] = FK
 
-      def index[A](f: Kleisli[M, E, A]): Representation => A = {
-        case (e, r) => R.index(f.run(e))(r)
-      }
-
-      def tabulate[A](f: Representation => A): Kleisli[M, E, A] =
-        Kleisli[M, E, A](e => R.tabulate(r => f((e, r))))
+    def index[A](f: Kleisli[M, E, A]): Representation => A = {
+      case (e, r) => R.index(f.run(e))(r)
     }
+
+    def tabulate[A](f: Representation => A): Kleisli[M, E, A] =
+      Kleisli[M, E, A](e => R.tabulate(r => f((e, r))))
+  }
 }
 
 sealed abstract private[data] class KleisliInstances1 extends KleisliInstances2 {
   implicit def catsDataMonadForKleisli[F[_], A](implicit M: Monad[F]): Monad[Kleisli[F, A, *]] =
     new KleisliMonad[F, A] { def F: Monad[F] = M }
 
-  implicit def catsDataParallelForKleisli[M[_], A](implicit
-    P: Parallel[M]
-  ): Parallel.Aux[Kleisli[M, A, *], Kleisli[P.F, A, *]] =
-    new Parallel[Kleisli[M, A, *]] {
-      type F[x] = Kleisli[P.F, A, x]
-      implicit val monadM: Monad[M] = P.monad
-      def applicative: Applicative[Kleisli[P.F, A, *]] = catsDataApplicativeForKleisli(P.applicative)
-      def monad: Monad[Kleisli[M, A, *]] = catsDataMonadForKleisli
-
-      def sequential: Kleisli[P.F, A, *] ~> Kleisli[M, A, *] =
-        new (Kleisli[P.F, A, *] ~> Kleisli[M, A, *]) {
-          def apply[B](k: Kleisli[P.F, A, B]): Kleisli[M, A, B] = k.mapK(P.sequential)
-        }
+  implicit def catsDataParallelForKleisli[M[_], A](
+    implicit P: Parallel[M]
+  ): Parallel.Aux[Kleisli[M, A, *], Kleisli[P.F, A, *]] = new Parallel[Kleisli[M, A, *]] {
+    type F[x] = Kleisli[P.F, A, x]
+    implicit val monadM: Monad[M] = P.monad
+    def applicative: Applicative[Kleisli[P.F, A, *]] = catsDataApplicativeForKleisli(P.applicative)
+    def monad: Monad[Kleisli[M, A, *]] = catsDataMonadForKleisli
+
+    def sequential: Kleisli[P.F, A, *] ~> Kleisli[M, A, *] =
+      new (Kleisli[P.F, A, *] ~> Kleisli[M, A, *]) {
+        def apply[B](k: Kleisli[P.F, A, B]): Kleisli[M, A, B] = k.mapK(P.sequential)
+      }
 
-      def parallel: Kleisli[M, A, *] ~> Kleisli[P.F, A, *] =
-        new (Kleisli[M, A, *] ~> Kleisli[P.F, A, *]) {
-          def apply[B](k: Kleisli[M, A, B]): Kleisli[P.F, A, B] = k.mapK(P.parallel)
-        }
-    }
+    def parallel: Kleisli[M, A, *] ~> Kleisli[P.F, A, *] =
+      new (Kleisli[M, A, *] ~> Kleisli[P.F, A, *]) {
+        def apply[B](k: Kleisli[M, A, B]): Kleisli[P.F, A, B] = k.mapK(P.parallel)
+      }
+  }
 
   implicit def catsDataContravariantForKleisli[F[_], C]: Contravariant[Kleisli[F, *, C]] =
     new Contravariant[Kleisli[F, *, C]] {
@@ -401,8 +400,8 @@ sealed abstract private[data] class KleisliInstances3 extends KleisliInstances4
   implicit def catsDataMonoidKForKleisli[F[_], A](implicit F0: MonoidK[F]): MonoidK[Kleisli[F, A, *]] =
     new KleisliMonoidK[F, A] { def F: MonoidK[F] = F0 }
 
-  implicit def catsDataCommutativeFlatMapForKleisli[F[_], A](implicit
-    F0: CommutativeFlatMap[F]
+  implicit def catsDataCommutativeFlatMapForKleisli[F[_], A](
+    implicit F0: CommutativeFlatMap[F]
   ): CommutativeFlatMap[Kleisli[F, A, *]] =
     new KleisliFlatMap[F, A] with CommutativeFlatMap[Kleisli[F, A, *]] { val F: CommutativeFlatMap[F] = F0 }
 
@@ -433,8 +432,8 @@ sealed abstract private[data] class KleisliInstances4 extends KleisliInstances5
 
 sealed abstract private[data] class KleisliInstances5 extends KleisliInstances6 {
 
-  implicit def catsDataApplicativeErrorForKleisli[F[_], E, A](implicit
-    F0: ApplicativeError[F, E]
+  implicit def catsDataApplicativeErrorForKleisli[F[_], E, A](
+    implicit F0: ApplicativeError[F, E]
   ): ApplicativeError[Kleisli[F, A, *], E] =
     new KleisliApplicativeError[F, A, E] { def F: ApplicativeError[F, E] = F0 }
 }
@@ -584,10 +583,9 @@ private[data] trait KleisliApplicativeError[F[_], A, E]
 
   def raiseError[B](e: E): K[B] = Kleisli(_ => F.raiseError(e))
 
-  def handleErrorWith[B](kb: K[B])(f: E => K[B]): K[B] =
-    Kleisli { (a: A) =>
-      F.handleErrorWith(kb.run(a))((e: E) => f(e).run(a))
-    }
+  def handleErrorWith[B](kb: K[B])(f: E => K[B]): K[B] = Kleisli { (a: A) =>
+    F.handleErrorWith(kb.run(a))((e: E) => f(e).run(a))
+  }
 }
 
 private[data] trait KleisliMonad[F[_], A]
diff --git a/core/src/main/scala/cats/data/Nested.scala b/core/src/main/scala/cats/data/Nested.scala
index 411614494..36efa3803 100644
--- a/core/src/main/scala/cats/data/Nested.scala
+++ b/core/src/main/scala/cats/data/Nested.scala
@@ -55,10 +55,8 @@ sealed abstract private[data] class NestedInstances extends NestedInstances0 {
         Nested(F.defer(fa.value))
     }
 
-  implicit def catsDataTraverseFilterForNested[F[_], G[_]](implicit
-    F0: Traverse[F],
-    G0: TraverseFilter[G]
-  ): TraverseFilter[Nested[F, G, *]] =
+  implicit def catsDataTraverseFilterForNested[F[_], G[_]](implicit F0: Traverse[F],
+                                                           G0: TraverseFilter[G]): TraverseFilter[Nested[F, G, *]] =
     new NestedTraverseFilter[F, G] {
       implicit val F: Traverse[F] = F0
       implicit val G: TraverseFilter[G] = G0
@@ -71,10 +69,8 @@ sealed abstract private[data] class NestedInstances0 extends NestedInstances1 {
       val FG: Traverse[Î»[Î± => F[G[Î±]]]] = Traverse[F].compose[G]
     }
 
-  implicit def catsDataFunctorFilterForNested[F[_], G[_]](implicit
-    F0: Functor[F],
-    G0: FunctorFilter[G]
-  ): FunctorFilter[Nested[F, G, *]] =
+  implicit def catsDataFunctorFilterForNested[F[_], G[_]](implicit F0: Functor[F],
+                                                          G0: FunctorFilter[G]): FunctorFilter[Nested[F, G, *]] =
     new NestedFunctorFilter[F, G] {
       implicit val F: Functor[F] = F0
       implicit val G: FunctorFilter[G] = G0
@@ -121,8 +117,8 @@ sealed abstract private[data] class NestedInstances3 extends NestedInstances4 {
 }
 
 sealed abstract private[data] class NestedInstances4 extends NestedInstances5 {
-  implicit def catsDataApplicativeErrorForNested[F[_], G[_], E](implicit
-    F: ApplicativeError[F, E],
+  implicit def catsDataApplicativeErrorForNested[F[_], G[_], E](
+    implicit F: ApplicativeError[F, E],
     G0: Applicative[G]
   ): ApplicativeError[Nested[F, G, *], E] =
     new NestedApplicativeError[F, G, E] {
@@ -134,9 +130,8 @@ sealed abstract private[data] class NestedInstances4 extends NestedInstances5 {
 }
 
 sealed abstract private[data] class NestedInstances5 extends NestedInstances6 {
-  implicit def catsDataCommutativeApplicativeForNestedContravariant[F[_]: CommutativeApplicative, G[
-    _
-  ]: CommutativeApplicative]: CommutativeApplicative[Nested[F, G, *]] =
+  implicit def catsDataCommutativeApplicativeForNestedContravariant[F[_]: CommutativeApplicative, G[_]: CommutativeApplicative]
+    : CommutativeApplicative[Nested[F, G, *]] =
     new NestedApplicative[F, G] with CommutativeApplicative[Nested[F, G, *]] {
       val FG: Applicative[Î»[Î± => F[G[Î±]]]] = Applicative[F].compose[G]
     }
diff --git a/core/src/main/scala/cats/data/NonEmptyList.scala b/core/src/main/scala/cats/data/NonEmptyList.scala
index 6ffd727fd..8c47757d1 100644
--- a/core/src/main/scala/cats/data/NonEmptyList.scala
+++ b/core/src/main/scala/cats/data/NonEmptyList.scala
@@ -46,11 +46,10 @@ final case class NonEmptyList[+A](head: A, tail: List[A]) extends NonEmptyCollec
    * res0: scala.collection.immutable.List[Int] = List(1, 2, 3, 4)
    * }}}
    */
-  def init: List[A] =
-    tail match {
-      case Nil => List.empty
-      case t   => head :: t.init
-    }
+  def init: List[A] = tail match {
+    case Nil => List.empty
+    case t   => head :: t.init
+  }
 
   final def iterator: Iterator[A] = toList.iterator
 
@@ -300,12 +299,11 @@ final case class NonEmptyList[+A](head: A, tail: List[A]) extends NonEmptyCollec
   def zipWith[B, C](b: NonEmptyList[B])(f: (A, B) => C): NonEmptyList[C] = {
 
     @tailrec
-    def zwRev(as: List[A], bs: List[B], acc: List[C]): List[C] =
-      (as, bs) match {
-        case (Nil, _)           => acc
-        case (_, Nil)           => acc
-        case (x :: xs, y :: ys) => zwRev(xs, ys, f(x, y) :: acc)
-      }
+    def zwRev(as: List[A], bs: List[B], acc: List[C]): List[C] = (as, bs) match {
+      case (Nil, _)           => acc
+      case (_, Nil)           => acc
+      case (x :: xs, y :: ys) => zwRev(xs, ys, f(x, y) :: acc)
+    }
 
     NonEmptyList(f(head, b.head), zwRev(tail, b.tail, Nil).reverse)
   }
@@ -589,16 +587,15 @@ sealed abstract private[data] class NonEmptyListInstances extends NonEmptyListIn
 
       def tailRecM[A, B](a: A)(f: A => NonEmptyList[Either[A, B]]): NonEmptyList[B] = {
         val buf = new ListBuffer[B]
-        @tailrec def go(v: NonEmptyList[Either[A, B]]): Unit =
-          v.head match {
-            case Right(b) =>
-              buf += b
-              NonEmptyList.fromList(v.tail) match {
-                case Some(t) => go(t)
-                case None    => ()
-              }
-            case Left(a) => go(f(a) ++ v.tail)
-          }
+        @tailrec def go(v: NonEmptyList[Either[A, B]]): Unit = v.head match {
+          case Right(b) =>
+            buf += b
+            NonEmptyList.fromList(v.tail) match {
+              case Some(t) => go(t)
+              case None    => ()
+            }
+          case Left(a) => go(f(a) ++ v.tail)
+        }
         go(f(a))
         NonEmptyList.fromListUnsafe(buf.result())
       }
@@ -650,13 +647,12 @@ sealed abstract private[data] class NonEmptyListInstances extends NonEmptyListIn
       override def alignWith[A, B, C](fa: NonEmptyList[A], fb: NonEmptyList[B])(f: Ior[A, B] => C): NonEmptyList[C] = {
 
         @tailrec
-        def go(as: List[A], bs: List[B], acc: List[C]): List[C] =
-          (as, bs) match {
-            case (Nil, Nil)         => acc
-            case (Nil, y :: ys)     => go(Nil, ys, f(Ior.right(y)) :: acc)
-            case (x :: xs, Nil)     => go(xs, Nil, f(Ior.left(x)) :: acc)
-            case (x :: xs, y :: ys) => go(xs, ys, f(Ior.both(x, y)) :: acc)
-          }
+        def go(as: List[A], bs: List[B], acc: List[C]): List[C] = (as, bs) match {
+          case (Nil, Nil)         => acc
+          case (Nil, y :: ys)     => go(Nil, ys, f(Ior.right(y)) :: acc)
+          case (x :: xs, Nil)     => go(xs, Nil, f(Ior.left(x)) :: acc)
+          case (x :: xs, y :: ys) => go(xs, ys, f(Ior.both(x, y)) :: acc)
+        }
 
         NonEmptyList(f(Ior.both(fa.head, fb.head)), go(fa.tail, fb.tail, Nil).reverse)
       }
diff --git a/core/src/main/scala/cats/data/NonEmptyMapImpl.scala b/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
index 5f9a34ca8..8762a5976 100644
--- a/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
+++ b/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
@@ -312,10 +312,9 @@ sealed abstract private[data] class NonEmptyMapInstances extends NonEmptyMapInst
   implicit def catsDataShowForNonEmptyMap[K: Show, A: Show]: Show[NonEmptyMap[K, A]] =
     Show.show[NonEmptyMap[K, A]](_.show)
 
-  implicit def catsDataBandForNonEmptyMap[K, A]: Band[NonEmptyMap[K, A]] =
-    new Band[NonEmptyMap[K, A]] {
-      def combine(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): NonEmptyMap[K, A] = x ++ y
-    }
+  implicit def catsDataBandForNonEmptyMap[K, A]: Band[NonEmptyMap[K, A]] = new Band[NonEmptyMap[K, A]] {
+    def combine(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): NonEmptyMap[K, A] = x ++ y
+  }
 }
 
 sealed abstract private[data] class NonEmptyMapInstances0 {
diff --git a/core/src/main/scala/cats/data/NonEmptySet.scala b/core/src/main/scala/cats/data/NonEmptySet.scala
index 9f342642e..740b5021e 100644
--- a/core/src/main/scala/cats/data/NonEmptySet.scala
+++ b/core/src/main/scala/cats/data/NonEmptySet.scala
@@ -399,10 +399,9 @@ sealed abstract private[data] class NonEmptySetInstances extends NonEmptySetInst
   implicit def catsDataShowForNonEmptySet[A](implicit A: Show[A]): Show[NonEmptySet[A]] =
     Show.show[NonEmptySet[A]](_.show)
 
-  implicit def catsDataSemilatticeForNonEmptySet[A]: Semilattice[NonEmptySet[A]] =
-    new Semilattice[NonEmptySet[A]] {
-      def combine(x: NonEmptySet[A], y: NonEmptySet[A]): NonEmptySet[A] = x | y
-    }
+  implicit def catsDataSemilatticeForNonEmptySet[A]: Semilattice[NonEmptySet[A]] = new Semilattice[NonEmptySet[A]] {
+    def combine(x: NonEmptySet[A], y: NonEmptySet[A]): NonEmptySet[A] = x | y
+  }
 }
 
 sealed abstract private[data] class NonEmptySetInstances0 extends NonEmptySetInstances1 {
@@ -411,10 +410,9 @@ sealed abstract private[data] class NonEmptySetInstances0 extends NonEmptySetIns
 }
 
 sealed abstract private[data] class NonEmptySetInstances1 {
-  implicit def catsDataEqForNonEmptySet[A](implicit A: Order[A]): Eq[NonEmptySet[A]] =
-    new NonEmptySetEq[A] {
-      implicit override def A0: Eq[A] = A
-    }
+  implicit def catsDataEqForNonEmptySet[A](implicit A: Order[A]): Eq[NonEmptySet[A]] = new NonEmptySetEq[A] {
+    implicit override def A0: Eq[A] = A
+  }
 }
 
 sealed abstract private[data] class NonEmptySetOrder[A] extends Order[NonEmptySet[A]] with NonEmptySetEq[A] {
diff --git a/core/src/main/scala/cats/data/NonEmptyVector.scala b/core/src/main/scala/cats/data/NonEmptyVector.scala
index b4086cc8e..2cbd15da6 100644
--- a/core/src/main/scala/cats/data/NonEmptyVector.scala
+++ b/core/src/main/scala/cats/data/NonEmptyVector.scala
@@ -424,16 +424,15 @@ sealed abstract private[data] class NonEmptyVectorInstances {
 
       def tailRecM[A, B](a: A)(f: A => NonEmptyVector[Either[A, B]]): NonEmptyVector[B] = {
         val buf = new VectorBuilder[B]
-        @tailrec def go(v: NonEmptyVector[Either[A, B]]): Unit =
-          v.head match {
-            case Right(b) =>
-              buf += b
-              NonEmptyVector.fromVector(v.tail) match {
-                case Some(t) => go(t)
-                case None    => ()
-              }
-            case Left(a) => go(f(a).concat(v.tail))
-          }
+        @tailrec def go(v: NonEmptyVector[Either[A, B]]): Unit = v.head match {
+          case Right(b) =>
+            buf += b
+            NonEmptyVector.fromVector(v.tail) match {
+              case Some(t) => go(t)
+              case None    => ()
+            }
+          case Left(a) => go(f(a).concat(v.tail))
+        }
         go(f(a))
         NonEmptyVector.fromVectorUnsafe(buf.result())
       }
@@ -460,9 +459,8 @@ sealed abstract private[data] class NonEmptyVectorInstances {
       def align[A, B](fa: NonEmptyVector[A], fb: NonEmptyVector[B]): NonEmptyVector[Ior[A, B]] =
         NonEmptyVector.fromVectorUnsafe(Align[Vector].align(fa.toVector, fb.toVector))
 
-      override def alignWith[A, B, C](fa: NonEmptyVector[A], fb: NonEmptyVector[B])(
-        f: Ior[A, B] => C
-      ): NonEmptyVector[C] =
+      override def alignWith[A, B, C](fa: NonEmptyVector[A],
+                                      fb: NonEmptyVector[B])(f: Ior[A, B] => C): NonEmptyVector[C] =
         NonEmptyVector.fromVectorUnsafe(Align[Vector].alignWith(fa.toVector, fb.toVector)(f))
     }
 
diff --git a/core/src/main/scala/cats/data/OneAnd.scala b/core/src/main/scala/cats/data/OneAnd.scala
index a294e5a11..cec3f623d 100644
--- a/core/src/main/scala/cats/data/OneAnd.scala
+++ b/core/src/main/scala/cats/data/OneAnd.scala
@@ -105,8 +105,8 @@ final case class OneAnd[F[_], A](head: A, tail: F[A]) {
 @suppressUnusedImportWarningForScalaVersionSpecific
 sealed abstract private[data] class OneAndInstances extends OneAndLowPriority0 {
 
-  implicit def catsDataParallelForOneAnd[A, M[_]: Alternative, F0[_]: Alternative](implicit
-    P: Parallel.Aux[M, F0]
+  implicit def catsDataParallelForOneAnd[A, M[_]: Alternative, F0[_]: Alternative](
+    implicit P: Parallel.Aux[M, F0]
   ): Parallel.Aux[OneAnd[M, *], OneAnd[F0, *]] =
     new Parallel[OneAnd[M, *]] {
       type F[x] = OneAnd[F0, x]
@@ -143,10 +143,8 @@ sealed abstract private[data] class OneAndInstances extends OneAndLowPriority0 {
   implicit def catsDataSemigroupForOneAnd[F[_]: Alternative, A]: Semigroup[OneAnd[F, A]] =
     catsDataSemigroupKForOneAnd[F].algebra
 
-  implicit def catsDataMonadForOneAnd[F[_]](implicit
-    monad: Monad[F],
-    alternative: Alternative[F]
-  ): Monad[OneAnd[F, *]] =
+  implicit def catsDataMonadForOneAnd[F[_]](implicit monad: Monad[F],
+                                            alternative: Alternative[F]): Monad[OneAnd[F, *]] =
     new Monad[OneAnd[F, *]] {
       override def map[A, B](fa: OneAnd[F, A])(f: A => B): OneAnd[F, B] =
         fa.map(f)(monad)
@@ -168,20 +166,18 @@ sealed abstract private[data] class OneAndInstances extends OneAndLowPriority0 {
           val oneAnd = fn(a)
           alternative.combineK(monad.pure(oneAnd.head), oneAnd.tail)
         }
-        def toFB(in: Either[A, B]): F[B] =
-          in match {
-            case Right(b) => monad.pure(b)
-            case Left(a)  => monad.tailRecM(a)(stepF)
-          }
+        def toFB(in: Either[A, B]): F[B] = in match {
+          case Right(b) => monad.pure(b)
+          case Left(a)  => monad.tailRecM(a)(stepF)
+        }
 
         // This could probably be in SemigroupK to perform well
         @tailrec
-        def combineAll(items: List[F[B]]): F[B] =
-          items match {
-            case Nil              => alternative.empty
-            case h :: Nil         => h
-            case h1 :: h2 :: tail => combineAll(alternative.combineK(h1, h2) :: tail)
-          }
+        def combineAll(items: List[F[B]]): F[B] = items match {
+          case Nil              => alternative.empty
+          case h :: Nil         => h
+          case h1 :: h2 :: tail => combineAll(alternative.combineK(h1, h2) :: tail)
+        }
 
         @tailrec
         def go(in: A, rest: List[F[B]]): OneAnd[F, B] =
@@ -257,10 +253,8 @@ sealed abstract private[data] class OneAndLowPriority0_5 extends OneAndLowPriori
 }
 
 sealed abstract private[data] class OneAndLowPriority0 extends OneAndLowPriority0_5 {
-  implicit def catsDataNonEmptyTraverseForOneAnd[F[_]](implicit
-    F: Traverse[F],
-    F2: Alternative[F]
-  ): NonEmptyTraverse[OneAnd[F, *]] =
+  implicit def catsDataNonEmptyTraverseForOneAnd[F[_]](implicit F: Traverse[F],
+                                                       F2: Alternative[F]): NonEmptyTraverse[OneAnd[F, *]] =
     new NonEmptyReducible[OneAnd[F, *], F] with NonEmptyTraverse[OneAnd[F, *]] {
       def nonEmptyTraverse[G[_], A, B](fa: OneAnd[F, A])(f: (A) => G[B])(implicit G: Apply[G]): G[OneAnd[F, B]] =
         fa.map(a => Apply[G].map(f(a))(OneAnd(_, F2.empty[B])))(F)
diff --git a/core/src/main/scala/cats/data/OptionT.scala b/core/src/main/scala/cats/data/OptionT.scala
index 16cff75a2..1ef981994 100644
--- a/core/src/main/scala/cats/data/OptionT.scala
+++ b/core/src/main/scala/cats/data/OptionT.scala
@@ -342,45 +342,44 @@ sealed abstract private[data] class OptionTInstances extends OptionTInstances0 {
   def catsDateTraverseFilterForOptionT[F[_]](implicit F0: Traverse[F]): TraverseFilter[OptionT[F, *]] =
     catsDataTraverseFilterForOptionT
 
-  implicit def catsDataParallelForOptionT[M[_]](implicit
-    P: Parallel[M]
-  ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] =
-    new Parallel[OptionT[M, *]] {
-      type F[x] = Nested[P.F, Option, x]
+  implicit def catsDataParallelForOptionT[M[_]](
+    implicit P: Parallel[M]
+  ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = new Parallel[OptionT[M, *]] {
+    type F[x] = Nested[P.F, Option, x]
 
-      implicit val monadM: Monad[M] = P.monad
+    implicit val monadM: Monad[M] = P.monad
 
-      def applicative: Applicative[Nested[P.F, Option, *]] =
-        cats.data.Nested.catsDataApplicativeForNested(P.applicative, cats.instances.option.catsStdInstancesForOption)
+    def applicative: Applicative[Nested[P.F, Option, *]] =
+      cats.data.Nested.catsDataApplicativeForNested(P.applicative, cats.instances.option.catsStdInstancesForOption)
 
-      def monad: Monad[OptionT[M, *]] = cats.data.OptionT.catsDataMonadErrorMonadForOptionT[M]
+    def monad: Monad[OptionT[M, *]] = cats.data.OptionT.catsDataMonadErrorMonadForOptionT[M]
 
-      def sequential: Nested[P.F, Option, *] ~> OptionT[M, *] =
-        new (Nested[P.F, Option, *] ~> OptionT[M, *]) {
-          def apply[A](nested: Nested[P.F, Option, A]): OptionT[M, A] = OptionT(P.sequential(nested.value))
-        }
+    def sequential: Nested[P.F, Option, *] ~> OptionT[M, *] =
+      new (Nested[P.F, Option, *] ~> OptionT[M, *]) {
+        def apply[A](nested: Nested[P.F, Option, A]): OptionT[M, A] = OptionT(P.sequential(nested.value))
+      }
 
-      def parallel: OptionT[M, *] ~> Nested[P.F, Option, *] =
-        new (OptionT[M, *] ~> Nested[P.F, Option, *]) {
-          def apply[A](optT: OptionT[M, A]): Nested[P.F, Option, A] = Nested(P.parallel(optT.value))
-        }
-    }
+    def parallel: OptionT[M, *] ~> Nested[P.F, Option, *] =
+      new (OptionT[M, *] ~> Nested[P.F, Option, *]) {
+        def apply[A](optT: OptionT[M, A]): Nested[P.F, Option, A] = Nested(P.parallel(optT.value))
+      }
+  }
 }
 
 sealed abstract private[data] class OptionTInstances0 extends OptionTInstances1 {
 
   // the Dummy type is to make this one more specific than catsDataMonadErrorMonadForOptionT on 2.13.x
   // see https://github.com/typelevel/cats/pull/2335#issuecomment-408249775
-  implicit def catsDataMonadErrorForOptionT[F[_], E](implicit
-    F0: MonadError[F, E]
+  implicit def catsDataMonadErrorForOptionT[F[_], E](
+    implicit F0: MonadError[F, E]
   ): MonadError[OptionT[F, *], E] { type Dummy } =
     new OptionTMonadError[F, E] {
       type Dummy
       implicit val F = F0
     }
 
-  implicit def catsDataContravariantMonoidalForOptionT[F[_]](implicit
-    F0: ContravariantMonoidal[F]
+  implicit def catsDataContravariantMonoidalForOptionT[F[_]](
+    implicit F0: ContravariantMonoidal[F]
   ): ContravariantMonoidal[OptionT[F, *]] =
     new OptionTContravariantMonoidal[F] { implicit val F = F0 }
 
@@ -390,8 +389,8 @@ sealed abstract private[data] class OptionTInstances0 extends OptionTInstances1
   implicit def catsDataSemigroupForOptionT[F[_], A](implicit F0: Semigroup[F[Option[A]]]): Semigroup[OptionT[F, A]] =
     new OptionTSemigroup[F, A] { implicit val F = F0 }
 
-  implicit def catsDataPartialOrderForOptionT[F[_], A](implicit
-    F0: PartialOrder[F[Option[A]]]
+  implicit def catsDataPartialOrderForOptionT[F[_], A](
+    implicit F0: PartialOrder[F[Option[A]]]
   ): PartialOrder[OptionT[F, A]] =
     new OptionTPartialOrder[F, A] { implicit val F = F0 }
 
diff --git a/core/src/main/scala/cats/data/RepresentableStore.scala b/core/src/main/scala/cats/data/RepresentableStore.scala
index 6731db1de..bd7c6d47a 100644
--- a/core/src/main/scala/cats/data/RepresentableStore.scala
+++ b/core/src/main/scala/cats/data/RepresentableStore.scala
@@ -46,8 +46,8 @@ final case class RepresentableStore[F[_], S, A](fa: F[A], index: S)(implicit R:
 
 object RepresentableStore {
 
-  implicit def catsDataRepresentableStoreComonad[F[_], S](implicit
-    R: Representable[F]
+  implicit def catsDataRepresentableStoreComonad[F[_], S](
+    implicit R: Representable[F]
   ): Comonad[RepresentableStore[F, S, *]] =
     new Comonad[RepresentableStore[F, S, *]] {
       override def extract[B](x: RepresentableStore[F, S, B]): B =
diff --git a/core/src/main/scala/cats/data/Tuple2K.scala b/core/src/main/scala/cats/data/Tuple2K.scala
index bd7f009e1..95351ff62 100644
--- a/core/src/main/scala/cats/data/Tuple2K.scala
+++ b/core/src/main/scala/cats/data/Tuple2K.scala
@@ -22,10 +22,8 @@ final case class Tuple2K[F[_], G[_], A](first: F[A], second: G[A]) {
 object Tuple2K extends Tuple2KInstances
 
 sealed abstract private[data] class Tuple2KInstances extends Tuple2KInstances0 {
-  implicit def catsDataOrderForTuple2K[F[_], G[_], A](implicit
-    FF: Order[F[A]],
-    GF: Order[G[A]]
-  ): Order[Tuple2K[F, G, A]] =
+  implicit def catsDataOrderForTuple2K[F[_], G[_], A](implicit FF: Order[F[A]],
+                                                      GF: Order[G[A]]): Order[Tuple2K[F, G, A]] =
     new Tuple2KOrder[F, G, A] {
       def F: Order[F[A]] = FF
       def G: Order[G[A]] = GF
@@ -35,8 +33,8 @@ sealed abstract private[data] class Tuple2KInstances extends Tuple2KInstances0 {
       def F: Show[F[A]] = FF
       def G: Show[G[A]] = GF
     }
-  implicit def catsDataContravariantMonoidalForTuple2k[F[_], G[_]](implicit
-    FD: ContravariantMonoidal[F],
+  implicit def catsDataContravariantMonoidalForTuple2k[F[_], G[_]](
+    implicit FD: ContravariantMonoidal[F],
     GD: ContravariantMonoidal[G]
   ): ContravariantMonoidal[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KContravariantMonoidal[F, G] with Tuple2KContravariant[F, G] {
@@ -56,22 +54,19 @@ sealed abstract private[data] class Tuple2KInstances extends Tuple2KInstances0 {
 }
 
 sealed abstract private[data] class Tuple2KInstances0 extends Tuple2KInstances1 {
-  implicit def catsDataTraverseForTuple2K[F[_], G[_]](implicit
-    FF: Traverse[F],
-    GF: Traverse[G]
-  ): Traverse[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataTraverseForTuple2K[F[_], G[_]](implicit FF: Traverse[F],
+                                                      GF: Traverse[G]): Traverse[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KTraverse[F, G] with Tuple2KFunctor[F, G] {
       def F: Traverse[F] = FF
       def G: Traverse[G] = GF
     }
-  implicit def catsDataContravariantForTuple2K[F[_], G[_]](implicit
-    FC: Contravariant[F],
+  implicit def catsDataContravariantForTuple2K[F[_], G[_]](
+    implicit FC: Contravariant[F],
     GC: Contravariant[G]
-  ): Contravariant[Î»[Î± => Tuple2K[F, G, Î±]]] =
-    new Tuple2KContravariant[F, G] {
-      def F: Contravariant[F] = FC
-      def G: Contravariant[G] = GC
-    }
+  ): Contravariant[Î»[Î± => Tuple2K[F, G, Î±]]] = new Tuple2KContravariant[F, G] {
+    def F: Contravariant[F] = FC
+    def G: Contravariant[G] = GC
+  }
   implicit def catsDataEqForTuple2K[F[_], G[_], A](implicit FF: Eq[F[A]], GG: Eq[G[A]]): Eq[Tuple2K[F, G, A]] =
     new Eq[Tuple2K[F, G, A]] {
       def eqv(x: Tuple2K[F, G, A], y: Tuple2K[F, G, A]): Boolean =
@@ -80,18 +75,14 @@ sealed abstract private[data] class Tuple2KInstances0 extends Tuple2KInstances1
 }
 
 sealed abstract private[data] class Tuple2KInstances1 extends Tuple2KInstances2 {
-  implicit def catsDataAlternativeForTuple2K[F[_], G[_]](implicit
-    FF: Alternative[F],
-    GG: Alternative[G]
-  ): Alternative[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataAlternativeForTuple2K[F[_], G[_]](implicit FF: Alternative[F],
+                                                         GG: Alternative[G]): Alternative[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KAlternative[F, G] {
       def F: Alternative[F] = FF
       def G: Alternative[G] = GG
     }
-  implicit def catsDataFoldableForTuple2K[F[_], G[_]](implicit
-    FF: Foldable[F],
-    GF: Foldable[G]
-  ): Foldable[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataFoldableForTuple2K[F[_], G[_]](implicit FF: Foldable[F],
+                                                      GF: Foldable[G]): Foldable[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KFoldable[F, G] {
       def F: Foldable[F] = FF
       def G: Foldable[G] = GF
@@ -99,18 +90,14 @@ sealed abstract private[data] class Tuple2KInstances1 extends Tuple2KInstances2
 }
 
 sealed abstract private[data] class Tuple2KInstances2 extends Tuple2KInstances3 {
-  implicit def catsDataMonadForTuple2K[F[_], G[_]](implicit
-    FM: Monad[F],
-    GM: Monad[G]
-  ): Monad[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataMonadForTuple2K[F[_], G[_]](implicit FM: Monad[F],
+                                                   GM: Monad[G]): Monad[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KMonad[F, G] {
       def F: Monad[F] = FM
       def G: Monad[G] = GM
     }
-  implicit def catsDataMonoidKForTuple2K[F[_], G[_]](implicit
-    FF: MonoidK[F],
-    GG: MonoidK[G]
-  ): MonoidK[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataMonoidKForTuple2K[F[_], G[_]](implicit FF: MonoidK[F],
+                                                     GG: MonoidK[G]): MonoidK[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KMonoidK[F, G] {
       def F: MonoidK[F] = FF
       def G: MonoidK[G] = GG
@@ -118,8 +105,8 @@ sealed abstract private[data] class Tuple2KInstances2 extends Tuple2KInstances3
 }
 
 sealed abstract private[data] class Tuple2KInstances3 extends Tuple2KInstances4 {
-  implicit def catsDataCommutativeApplicativeForTuple2K[F[_], G[_]](implicit
-    FF: CommutativeApplicative[F],
+  implicit def catsDataCommutativeApplicativeForTuple2K[F[_], G[_]](
+    implicit FF: CommutativeApplicative[F],
     GG: CommutativeApplicative[G]
   ): CommutativeApplicative[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KApplicative[F, G] with CommutativeApplicative[Î»[Î± => Tuple2K[F, G, Î±]]] {
@@ -129,16 +116,14 @@ sealed abstract private[data] class Tuple2KInstances3 extends Tuple2KInstances4
 }
 
 sealed abstract private[data] class Tuple2KInstances4 extends Tuple2KInstances5 {
-  implicit def catsDataSemigroupKForTuple2K[F[_], G[_]](implicit
-    FF: SemigroupK[F],
-    GG: SemigroupK[G]
-  ): SemigroupK[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataSemigroupKForTuple2K[F[_], G[_]](implicit FF: SemigroupK[F],
+                                                        GG: SemigroupK[G]): SemigroupK[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KSemigroupK[F, G] {
       def F: SemigroupK[F] = FF
       def G: SemigroupK[G] = GG
     }
-  implicit def catsDataCommutativeApplyForTuple2K[F[_], G[_]](implicit
-    FF: CommutativeApply[F],
+  implicit def catsDataCommutativeApplyForTuple2K[F[_], G[_]](
+    implicit FF: CommutativeApply[F],
     GG: CommutativeApply[G]
   ): CommutativeApply[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KApply[F, G] with CommutativeApply[Î»[Î± => Tuple2K[F, G, Î±]]] {
@@ -148,10 +133,8 @@ sealed abstract private[data] class Tuple2KInstances4 extends Tuple2KInstances5
 }
 
 sealed abstract private[data] class Tuple2KInstances5 extends Tuple2KInstances6 {
-  implicit def catsDataApplicativeForTuple2K[F[_], G[_]](implicit
-    FF: Applicative[F],
-    GG: Applicative[G]
-  ): Applicative[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataApplicativeForTuple2K[F[_], G[_]](implicit FF: Applicative[F],
+                                                         GG: Applicative[G]): Applicative[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KApplicative[F, G] {
       def F: Applicative[F] = FF
       def G: Applicative[G] = GG
@@ -159,10 +142,8 @@ sealed abstract private[data] class Tuple2KInstances5 extends Tuple2KInstances6
 }
 
 sealed abstract private[data] class Tuple2KInstances6 extends Tuple2KInstances7 {
-  implicit def catsDataApplyForTuple2K[F[_], G[_]](implicit
-    FF: Apply[F],
-    GG: Apply[G]
-  ): Apply[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataApplyForTuple2K[F[_], G[_]](implicit FF: Apply[F],
+                                                   GG: Apply[G]): Apply[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KApply[F, G] {
       def F: Apply[F] = FF
       def G: Apply[G] = GG
@@ -170,10 +151,8 @@ sealed abstract private[data] class Tuple2KInstances6 extends Tuple2KInstances7
 }
 
 sealed abstract private[data] class Tuple2KInstances7 extends Tuple2KInstances8 {
-  implicit def catsDataDistributiveForTuple2K[F[_], G[_]](implicit
-    FF: Distributive[F],
-    GG: Distributive[G]
-  ): Distributive[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataDistributiveForTuple2K[F[_], G[_]](implicit FF: Distributive[F],
+                                                          GG: Distributive[G]): Distributive[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KDistributive[F, G] with Tuple2KFunctor[F, G] {
       def F: Distributive[F] = FF
       def G: Distributive[G] = GG
@@ -181,10 +160,8 @@ sealed abstract private[data] class Tuple2KInstances7 extends Tuple2KInstances8
 }
 
 sealed abstract private[data] class Tuple2KInstances8 {
-  implicit def catsDataFunctorForTuple2K[F[_], G[_]](implicit
-    FF: Functor[F],
-    GG: Functor[G]
-  ): Functor[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataFunctorForTuple2K[F[_], G[_]](implicit FF: Functor[F],
+                                                     GG: Functor[G]): Functor[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KFunctor[F, G] {
       def F: Functor[F] = FF
       def G: Functor[G] = GG
@@ -204,12 +181,10 @@ sealed private[data] trait Tuple2KDistributive[F[_], G[_]] extends Distributive[
 
   override def distribute[H[_]: Functor, A, B](ha: H[A])(f: A => Tuple2K[F, G, B]): Tuple2K[F, G, H[B]] =
     Tuple2K(F.distribute(ha) { a =>
-              f(a).first
-            },
-            G.distribute(ha) { a =>
-              f(a).second
-            }
-    )
+      f(a).first
+    }, G.distribute(ha) { a =>
+      f(a).second
+    })
 
   override def map[A, B](fa: Tuple2K[F, G, A])(f: A => B): Tuple2K[F, G, B] =
     Tuple2K(F.map(fa.first)(f), G.map(fa.second)(f))
@@ -240,9 +215,8 @@ sealed private[data] trait Tuple2KApply[F[_], G[_]] extends Apply[Î»[Î± => Tuple
     Tuple2K(F.ap(f.first)(fa.first), G.ap(f.second)(fa.second))
   override def product[A, B](fa: Tuple2K[F, G, A], fb: Tuple2K[F, G, B]): Tuple2K[F, G, (A, B)] =
     Tuple2K(F.product(fa.first, fb.first), G.product(fa.second, fb.second))
-  override def map2Eval[A, B, Z](fa: Tuple2K[F, G, A], fb: Eval[Tuple2K[F, G, B]])(
-    f: (A, B) => Z
-  ): Eval[Tuple2K[F, G, Z]] = {
+  override def map2Eval[A, B, Z](fa: Tuple2K[F, G, A],
+                                 fb: Eval[Tuple2K[F, G, B]])(f: (A, B) => Z): Eval[Tuple2K[F, G, Z]] = {
     val fbmemo = fb.memoize // don't recompute this twice internally
     for {
       fz <- F.map2Eval(fa.first, fbmemo.map(_.first))(f)
diff --git a/core/src/main/scala/cats/data/Validated.scala b/core/src/main/scala/cats/data/Validated.scala
index c6d287769..20a063092 100644
--- a/core/src/main/scala/cats/data/Validated.scala
+++ b/core/src/main/scala/cats/data/Validated.scala
@@ -40,11 +40,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res0: Boolean = false
    * }}}
    */
-  def isValid: Boolean =
-    this match {
-      case Invalid(_) => false
-      case _          => true
-    }
+  def isValid: Boolean = this match {
+    case Invalid(_) => false
+    case _          => true
+  }
 
   /**
    * Example:
@@ -56,20 +55,18 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res0: Boolean = true
    * }}}
    */
-  def isInvalid: Boolean =
-    this match {
-      case Invalid(_) => true
-      case _          => false
-    }
+  def isInvalid: Boolean = this match {
+    case Invalid(_) => true
+    case _          => false
+  }
 
   /**
    * Run the side-effecting function on the value if it is Valid
    */
-  def foreach(f: A => Unit): Unit =
-    this match {
-      case Valid(a) => f(a)
-      case _        => ()
-    }
+  def foreach(f: A => Unit): Unit = this match {
+    case Valid(a) => f(a)
+    case _        => ()
+  }
 
   /**
    * Return the Valid value, or the default if Invalid
@@ -88,11 +85,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Int = 123
    * }}}
    */
-  def getOrElse[B >: A](default: => B): B =
-    this match {
-      case Valid(a) => a
-      case _        => default
-    }
+  def getOrElse[B >: A](default: => B): B = this match {
+    case Valid(a) => a
+    case _        => default
+  }
 
   /**
    * Return the Valid value, or the result of f if Invalid
@@ -110,11 +106,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: String = OK
    * }}}
    */
-  def valueOr[B >: A](f: E => B): B =
-    this match {
-      case Invalid(e) => f(e)
-      case Valid(a)   => a
-    }
+  def valueOr[B >: A](f: E => B): B = this match {
+    case Invalid(e) => f(e)
+    case Valid(a)   => a
+  }
 
   /**
    * Is this Valid and matching the given predicate
@@ -133,11 +128,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Boolean = true
    * }}}
    */
-  def exists(predicate: A => Boolean): Boolean =
-    this match {
-      case Valid(a) => predicate(a)
-      case _        => false
-    }
+  def exists(predicate: A => Boolean): Boolean = this match {
+    case Valid(a) => predicate(a)
+    case _        => false
+  }
 
   /**
    * Is this Invalid or matching the predicate
@@ -156,11 +150,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Boolean = false
    * }}}
    */
-  def forall(f: A => Boolean): Boolean =
-    this match {
-      case Valid(a) => f(a)
-      case _        => true
-    }
+  def forall(f: A => Boolean): Boolean = this match {
+    case Valid(a) => f(a)
+    case _        => true
+  }
 
   /**
    * Return this if it is Valid, or else fall back to the given default.
@@ -239,11 +232,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * }}}
    *
    */
-  def toEither: Either[E, A] =
-    this match {
-      case Invalid(e) => Left(e)
-      case Valid(a)   => Right(a)
-    }
+  def toEither: Either[E, A] = this match {
+    case Invalid(e) => Left(e)
+    case Valid(a)   => Right(a)
+  }
 
   /**
    * Returns Valid values wrapped in Some, and None for Invalid values
@@ -262,11 +254,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Option[Int] = Some(123)
    * }}}
    */
-  def toOption: Option[A] =
-    this match {
-      case Valid(a) => Some(a)
-      case _        => None
-    }
+  def toOption: Option[A] = this match {
+    case Valid(a) => Some(a)
+    case _        => None
+  }
 
   /**
    * Returns Valid values wrapped in Ior.Right, and None for Ior.Left values
@@ -285,11 +276,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Ior[String, Int] = Right(123)
    * }}}
    */
-  def toIor: Ior[E, A] =
-    this match {
-      case Invalid(e) => Ior.Left(e)
-      case Valid(a)   => Ior.Right(a)
-    }
+  def toIor: Ior[E, A] = this match {
+    case Invalid(e) => Ior.Left(e)
+    case Valid(a)   => Ior.Right(a)
+  }
 
   /**
    * Convert this value to a single element List if it is Valid,
@@ -309,11 +299,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: List[Int] = List(123)
    * }}}
    */
-  def toList: List[A] =
-    this match {
-      case Valid(a) => List(a)
-      case _        => Nil
-    }
+  def toList: List[A] = this match {
+    case Valid(a) => List(a)
+    case _        => Nil
+  }
 
   /**
    * Lift the Invalid value into a NonEmptyList.
@@ -400,11 +389,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Validated[List[String] ,Option[Int]] = Valid(Some(123))
    * }}}
    */
-  def bimap[EE, AA](fe: E => EE, fa: A => AA): Validated[EE, AA] =
-    this match {
-      case Valid(a)   => Valid(fa(a))
-      case Invalid(e) => Invalid(fe(e))
-    }
+  def bimap[EE, AA](fe: E => EE, fa: A => AA): Validated[EE, AA] = this match {
+    case Valid(a)   => Valid(fa(a))
+    case Invalid(e) => Invalid(fe(e))
+  }
 
   /**
    * Example:
@@ -441,15 +429,13 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
       case (Valid(_), _)             => 1
     }
 
-  def partialCompare[EE >: E, AA >: A](
-    that: Validated[EE, AA]
-  )(implicit EE: PartialOrder[EE], AA: PartialOrder[AA]): Double =
-    (this, that) match {
-      case (Valid(a), Valid(aa))     => AA.partialCompare(a, aa)
-      case (Invalid(e), Invalid(ee)) => EE.partialCompare(e, ee)
-      case (Invalid(_), _)           => -1
-      case (Valid(_), _)             => 1
-    }
+  def partialCompare[EE >: E, AA >: A](that: Validated[EE, AA])(implicit EE: PartialOrder[EE],
+                                                                AA: PartialOrder[AA]): Double = (this, that) match {
+    case (Valid(a), Valid(aa))     => AA.partialCompare(a, aa)
+    case (Invalid(e), Invalid(ee)) => EE.partialCompare(e, ee)
+    case (Invalid(_), _)           => -1
+    case (Valid(_), _)             => 1
+  }
 
   /**
    * Example:
@@ -471,12 +457,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res3: Boolean = false
    * }}}
    */
-  def ===[EE >: E, AA >: A](that: Validated[EE, AA])(implicit EE: Eq[EE], AA: Eq[AA]): Boolean =
-    (this, that) match {
-      case (Invalid(e), Invalid(ee)) => EE.eqv(e, ee)
-      case (Valid(a), Valid(aa))     => AA.eqv(a, aa)
-      case _                         => false
-    }
+  def ===[EE >: E, AA >: A](that: Validated[EE, AA])(implicit EE: Eq[EE], AA: Eq[AA]): Boolean = (this, that) match {
+    case (Invalid(e), Invalid(ee)) => EE.eqv(e, ee)
+    case (Valid(a), Valid(aa))     => AA.eqv(a, aa)
+    case _                         => false
+  }
 
   /**
    * From Apply:
@@ -555,11 +540,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Validated[String, Int] = Valid(246)
    * }}}
    */
-  def map[B](f: A => B): Validated[E, B] =
-    this match {
-      case i @ Invalid(_) => i
-      case Valid(a)       => Valid(f(a))
-    }
+  def map[B](f: A => B): Validated[E, B] = this match {
+    case i @ Invalid(_) => i
+    case Valid(a)       => Valid(f(a))
+  }
 
   /**
    * Apply a function to an Invalid value, returning a new Invalid value.
@@ -580,11 +564,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    *
    * }}}
    */
-  def leftMap[EE](f: E => EE): Validated[EE, A] =
-    this match {
-      case a @ Valid(_) => a
-      case Invalid(e)   => Invalid(f(e))
-    }
+  def leftMap[EE](f: E => EE): Validated[EE, A] = this match {
+    case a @ Valid(_) => a
+    case Invalid(e)   => Invalid(f(e))
+  }
 
   /**
    * When Valid, apply the function, marking the result as valid
@@ -605,11 +588,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Option[Validated[String, Int]] = Some(Valid(123))
    * }}}
    */
-  def traverse[F[_], EE >: E, B](f: A => F[B])(implicit F: Applicative[F]): F[Validated[EE, B]] =
-    this match {
-      case Valid(a)       => F.map(f(a))(Valid.apply)
-      case e @ Invalid(_) => F.pure(e)
-    }
+  def traverse[F[_], EE >: E, B](f: A => F[B])(implicit F: Applicative[F]): F[Validated[EE, B]] = this match {
+    case Valid(a)       => F.map(f(a))(Valid.apply)
+    case e @ Invalid(_) => F.pure(e)
+  }
 
   /**
    * apply the given function to the value with the given B when
@@ -629,11 +611,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Int = 579
    * }}}
    */
-  def foldLeft[B](b: B)(f: (B, A) => B): B =
-    this match {
-      case Valid(a) => f(b, a)
-      case _        => b
-    }
+  def foldLeft[B](b: B)(f: (B, A) => B): B = this match {
+    case Valid(a) => f(b, a)
+    case _        => b
+  }
 
   /**
    * Lazily-apply the given function to the value with the given B
@@ -655,17 +636,15 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * }}}
    *
    */
-  def foldRight[B](lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
-    this match {
-      case Valid(a) => f(a, lb)
-      case _        => lb
-    }
+  def foldRight[B](lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] = this match {
+    case Valid(a) => f(a, lb)
+    case _        => lb
+  }
 
-  def show[EE >: E, AA >: A](implicit EE: Show[EE], AA: Show[AA]): String =
-    this match {
-      case Invalid(e) => s"Invalid(${EE.show(e)})"
-      case Valid(a)   => s"Valid(${AA.show(a)})"
-    }
+  def show[EE >: E, AA >: A](implicit EE: Show[EE], AA: Show[AA]): String = this match {
+    case Invalid(e) => s"Invalid(${EE.show(e)})"
+    case Valid(a)   => s"Valid(${AA.show(a)})"
+  }
 
   /**
    * Apply a function (that returns a `Validated`) in the valid case.
@@ -726,9 +705,8 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res2: Validated[NonEmptyList[String], List[Int]] = Valid(List(123, 456))
    * }}}
    */
-  def combine[EE >: E, AA >: A](
-    that: Validated[EE, AA]
-  )(implicit EE: Semigroup[EE], AA: Semigroup[AA]): Validated[EE, AA] =
+  def combine[EE >: E, AA >: A](that: Validated[EE, AA])(implicit EE: Semigroup[EE],
+                                                         AA: Semigroup[AA]): Validated[EE, AA] =
     (this, that) match {
       case (Valid(a), Valid(b))     => Valid(AA.combine(a, b))
       case (Invalid(a), Invalid(b)) => Invalid(EE.combine(a, b))
@@ -752,11 +730,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * }}}
    *
    */
-  def swap: Validated[A, E] =
-    this match {
-      case Valid(a)   => Invalid(a)
-      case Invalid(e) => Valid(e)
-    }
+  def swap: Validated[A, E] = this match {
+    case Valid(a)   => Invalid(a)
+    case Invalid(e) => Valid(e)
+  }
 
   /**
    * Example:
@@ -774,11 +751,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * }}}
    *
    */
-  def merge[EE >: E](implicit ev: A <:< EE): EE =
-    this match {
-      case Invalid(e) => e
-      case Valid(a)   => ev(a)
-    }
+  def merge[EE >: E](implicit ev: A <:< EE): EE = this match {
+    case Invalid(e) => e
+    case Valid(a)   => ev(a)
+  }
 
   /**
    * Ensure that a successful result passes the given predicate,
@@ -791,11 +767,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res0: Validated[IllegalArgumentException, String] = Invalid(java.lang.IllegalArgumentException: Must not be empty)
    * }}}
    */
-  def ensure[EE >: E](onFailure: => EE)(f: A => Boolean): Validated[EE, A] =
-    this match {
-      case Valid(a) => if (f(a)) this else Validated.invalid(onFailure)
-      case _        => this
-    }
+  def ensure[EE >: E](onFailure: => EE)(f: A => Boolean): Validated[EE, A] = this match {
+    case Valid(a) => if (f(a)) this else Validated.invalid(onFailure)
+    case _        => this
+  }
 
   /**
    * Ensure that a successful result passes the given predicate,
@@ -808,11 +783,10 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res0: Validated[IllegalArgumentException, String] = Invalid(java.lang.IllegalArgumentException: Must be longer than 3, provided 'ab')
    * }}}
    */
-  def ensureOr[EE >: E](onFailure: A => EE)(f: A => Boolean): Validated[EE, A] =
-    this match {
-      case Valid(a) => if (f(a)) this else Validated.invalid(onFailure(a))
-      case _        => this
-    }
+  def ensureOr[EE >: E](onFailure: A => EE)(f: A => Boolean): Validated[EE, A] = this match {
+    case Valid(a) => if (f(a)) this else Validated.invalid(onFailure(a))
+    case _        => this
+  }
 }
 
 object Validated extends ValidatedInstances with ValidatedFunctions with ValidatedFunctionsBinCompat0 {
@@ -855,15 +829,14 @@ sealed abstract private[data] class ValidatedInstances extends ValidatedInstance
 
   implicit def catsDataSemigroupKForValidated[A](implicit A: Semigroup[A]): SemigroupK[Validated[A, *]] =
     new SemigroupK[Validated[A, *]] {
-      def combineK[B](x: Validated[A, B], y: Validated[A, B]): Validated[A, B] =
-        x match {
-          case v @ Valid(_) => v
-          case Invalid(ix) =>
-            y match {
-              case Invalid(iy)  => Invalid(A.combine(ix, iy))
-              case v @ Valid(_) => v
-            }
-        }
+      def combineK[B](x: Validated[A, B], y: Validated[A, B]): Validated[A, B] = x match {
+        case v @ Valid(_) => v
+        case Invalid(ix) =>
+          y match {
+            case Invalid(iy)  => Invalid(A.combine(ix, iy))
+            case v @ Valid(_) => v
+          }
+      }
     }
 
   implicit def catsDataAlignForValidated[E: Semigroup]: Align[Validated[E, *]] =
@@ -893,12 +866,11 @@ sealed abstract private[data] class ValidatedInstances extends ValidatedInstance
       def combine(x: Validated[A, B], y: Validated[A, B]): Validated[A, B] = x.combine(y)
     }
 
-  implicit def catsDataOrderForValidated[A: Order, B: Order]: Order[Validated[A, B]] =
-    new Order[Validated[A, B]] {
-      def compare(x: Validated[A, B], y: Validated[A, B]): Int = x.compare(y)
-      override def partialCompare(x: Validated[A, B], y: Validated[A, B]): Double = x.partialCompare(y)
-      override def eqv(x: Validated[A, B], y: Validated[A, B]): Boolean = x === y
-    }
+  implicit def catsDataOrderForValidated[A: Order, B: Order]: Order[Validated[A, B]] = new Order[Validated[A, B]] {
+    def compare(x: Validated[A, B], y: Validated[A, B]): Int = x.compare(y)
+    override def partialCompare(x: Validated[A, B], y: Validated[A, B]): Double = x.partialCompare(y)
+    override def eqv(x: Validated[A, B], y: Validated[A, B]): Boolean = x === y
+  }
 
   implicit def catsDataShowForValidated[A, B](implicit A: Show[A], B: Show[B]): Show[Validated[A, B]] =
     new Show[Validated[A, B]] {
@@ -921,9 +893,8 @@ sealed abstract private[data] class ValidatedInstances extends ValidatedInstance
           case Valid(b)   => g(c, b)
         }
 
-      def bifoldRight[A, B, C](fab: Validated[A, B],
-                               c: Eval[C]
-      )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
+      def bifoldRight[A, B, C](fab: Validated[A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
+                                                                 g: (B, Eval[C]) => Eval[C]): Eval[C] =
         fab match {
           case Invalid(a) => f(a, c)
           case Valid(b)   => g(b, c)
@@ -950,10 +921,8 @@ sealed abstract private[data] class ValidatedInstances extends ValidatedInstance
 
 sealed abstract private[data] class ValidatedInstances1 extends ValidatedInstances2 {
 
-  implicit def catsDataSemigroupForValidated[A, B](implicit
-    A: Semigroup[A],
-    B: Semigroup[B]
-  ): Semigroup[Validated[A, B]] =
+  implicit def catsDataSemigroupForValidated[A, B](implicit A: Semigroup[A],
+                                                   B: Semigroup[B]): Semigroup[Validated[A, B]] =
     new Semigroup[Validated[A, B]] {
       def combine(x: Validated[A, B], y: Validated[A, B]): Validated[A, B] = x.combine(y)
     }
@@ -1005,20 +974,18 @@ sealed abstract private[data] class ValidatedInstances2 {
       override def reduceRightOption[A](fa: Validated[E, A])(f: (A, Eval[A]) => Eval[A]): Eval[Option[A]] =
         Now(fa.toOption)
 
-      override def size[A](fa: Validated[E, A]): Long =
-        fa match {
-          case Invalid(_) => 0L
-          case _          => 1L
-        }
+      override def size[A](fa: Validated[E, A]): Long = fa match {
+        case Invalid(_) => 0L
+        case _          => 1L
+      }
 
       override def get[A](fa: Validated[E, A])(idx: Long): Option[A] =
         if (idx == 0L) fa.toOption else None
 
-      override def foldMap[A, B](fa: Validated[E, A])(f: A => B)(implicit B: Monoid[B]): B =
-        fa match {
-          case Valid(a) => f(a)
-          case _        => B.empty
-        }
+      override def foldMap[A, B](fa: Validated[E, A])(f: A => B)(implicit B: Monoid[B]): B = fa match {
+        case Valid(a) => f(a)
+        case _        => B.empty
+      }
 
       override def find[A](fa: Validated[E, A])(f: A => Boolean): Option[A] =
         fa.toOption.filter(f)
@@ -1029,11 +996,10 @@ sealed abstract private[data] class ValidatedInstances2 {
       override def forall[A](fa: Validated[E, A])(p: A => Boolean): Boolean =
         fa.forall(p)
 
-      override def toList[A](fa: Validated[E, A]): List[A] =
-        fa match {
-          case Valid(a) => a :: Nil
-          case _        => Nil
-        }
+      override def toList[A](fa: Validated[E, A]): List[A] = fa match {
+        case Valid(a) => a :: Nil
+        case _        => Nil
+      }
 
       override def isEmpty[A](fa: Validated[E, A]): Boolean = fa.isInvalid
     }
@@ -1109,11 +1075,10 @@ private[data] trait ValidatedFunctions {
   /**
    * Converts a `Try[A]` to a `Validated[Throwable, A]`.
    */
-  def fromTry[A](t: Try[A]): Validated[Throwable, A] =
-    t match {
-      case Failure(e) => invalid(e)
-      case Success(v) => valid(v)
-    }
+  def fromTry[A](t: Try[A]): Validated[Throwable, A] = t match {
+    case Failure(e) => invalid(e)
+    case Success(v) => valid(v)
+  }
 
   /**
    * Converts an `Either[A, B]` to a `Validated[A, B]`.
diff --git a/core/src/main/scala/cats/data/WriterT.scala b/core/src/main/scala/cats/data/WriterT.scala
index cf3da0594..dc8e9fd7b 100644
--- a/core/src/main/scala/cats/data/WriterT.scala
+++ b/core/src/main/scala/cats/data/WriterT.scala
@@ -358,8 +358,8 @@ sealed abstract private[data] class WriterTInstances extends WriterTInstances0 {
 }
 
 sealed abstract private[data] class WriterTInstances0 extends WriterTInstances1 {
-  implicit def catsDataCommutativeMonadForWriterT[F[_], L](implicit
-    F: CommutativeMonad[F],
+  implicit def catsDataCommutativeMonadForWriterT[F[_], L](
+    implicit F: CommutativeMonad[F],
     L: CommutativeMonoid[L]
   ): CommutativeMonad[WriterT[F, L, *]] =
     new WriterTMonad[F, L] with CommutativeMonad[WriterT[F, L, *]] {
@@ -380,35 +380,32 @@ sealed abstract private[data] class WriterTInstances1 extends WriterTInstances2
 }
 
 sealed abstract private[data] class WriterTInstances2 extends WriterTInstances3 {
-  implicit def catsDataMonadErrorForWriterT[F[_], L, E](implicit
-    F: MonadError[F, E],
-    L: Monoid[L]
-  ): MonadError[WriterT[F, L, *], E] =
+  implicit def catsDataMonadErrorForWriterT[F[_], L, E](implicit F: MonadError[F, E],
+                                                        L: Monoid[L]): MonadError[WriterT[F, L, *], E] =
     new WriterTMonadError[F, L, E] {
       implicit val F0: MonadError[F, E] = F
       implicit val L0: Monoid[L] = L
     }
 
-  implicit def catsDataParallelForWriterT[M[_], L: Monoid](implicit
-    P: Parallel[M]
-  ): Parallel.Aux[WriterT[M, L, *], WriterT[P.F, L, *]] =
-    new Parallel[WriterT[M, L, *]] {
-      type F[x] = WriterT[P.F, L, x]
-      implicit val monadM: Monad[M] = P.monad
+  implicit def catsDataParallelForWriterT[M[_], L: Monoid](
+    implicit P: Parallel[M]
+  ): Parallel.Aux[WriterT[M, L, *], WriterT[P.F, L, *]] = new Parallel[WriterT[M, L, *]] {
+    type F[x] = WriterT[P.F, L, x]
+    implicit val monadM: Monad[M] = P.monad
 
-      def applicative: Applicative[WriterT[P.F, L, *]] = catsDataApplicativeForWriterT(P.applicative, Monoid[L])
-      def monad: Monad[WriterT[M, L, *]] = catsDataMonadForWriterT
+    def applicative: Applicative[WriterT[P.F, L, *]] = catsDataApplicativeForWriterT(P.applicative, Monoid[L])
+    def monad: Monad[WriterT[M, L, *]] = catsDataMonadForWriterT
 
-      def sequential: WriterT[P.F, L, *] ~> WriterT[M, L, *] =
-        new (WriterT[P.F, L, *] ~> WriterT[M, L, *]) {
-          def apply[A](wfl: WriterT[P.F, L, A]): WriterT[M, L, A] = WriterT(P.sequential(wfl.run))
-        }
+    def sequential: WriterT[P.F, L, *] ~> WriterT[M, L, *] =
+      new (WriterT[P.F, L, *] ~> WriterT[M, L, *]) {
+        def apply[A](wfl: WriterT[P.F, L, A]): WriterT[M, L, A] = WriterT(P.sequential(wfl.run))
+      }
 
-      def parallel: WriterT[M, L, *] ~> WriterT[P.F, L, *] =
-        new (WriterT[M, L, *] ~> WriterT[P.F, L, *]) {
-          def apply[A](wml: WriterT[M, L, A]): WriterT[P.F, L, A] = WriterT(P.parallel(wml.run))
-        }
-    }
+    def parallel: WriterT[M, L, *] ~> WriterT[P.F, L, *] =
+      new (WriterT[M, L, *] ~> WriterT[P.F, L, *]) {
+        def apply[A](wml: WriterT[M, L, A]): WriterT[P.F, L, A] = WriterT(P.parallel(wml.run))
+      }
+  }
 
   implicit def catsDataEqForWriterTId[L: Eq, V: Eq]: Eq[WriterT[Id, L, V]] =
     catsDataEqForWriterT[Id, L, V]
@@ -482,10 +479,8 @@ sealed abstract private[data] class WriterTInstances6 extends WriterTInstances7
 }
 
 sealed abstract private[data] class WriterTInstances7 extends WriterTInstances8 {
-  implicit def catsDataApplicativeErrorForWriterT[F[_], L, E](implicit
-    F: ApplicativeError[F, E],
-    L: Monoid[L]
-  ): ApplicativeError[WriterT[F, L, *], E] =
+  implicit def catsDataApplicativeErrorForWriterT[F[_], L, E](implicit F: ApplicativeError[F, E],
+                                                              L: Monoid[L]): ApplicativeError[WriterT[F, L, *], E] =
     new WriterTApplicativeError[F, L, E] {
       implicit val F0: ApplicativeError[F, E] = F
       implicit val L0: Monoid[L] = L
@@ -493,17 +488,15 @@ sealed abstract private[data] class WriterTInstances7 extends WriterTInstances8
 }
 
 sealed abstract private[data] class WriterTInstances8 extends WriterTInstances9 {
-  implicit def catsDataAlternativeForWriterT[F[_], L](implicit
-    F: Alternative[F],
-    L: Monoid[L]
-  ): Alternative[WriterT[F, L, *]] =
+  implicit def catsDataAlternativeForWriterT[F[_], L](implicit F: Alternative[F],
+                                                      L: Monoid[L]): Alternative[WriterT[F, L, *]] =
     new WriterTAlternative[F, L] {
       implicit val F0: Alternative[F] = F
       implicit val L0: Monoid[L] = L
     }
 
-  implicit def catsDataContravariantMonoidalForWriterT[F[_], L](implicit
-    F: ContravariantMonoidal[F]
+  implicit def catsDataContravariantMonoidalForWriterT[F[_], L](
+    implicit F: ContravariantMonoidal[F]
   ): ContravariantMonoidal[WriterT[F, L, *]] =
     new WriterTContravariantMonoidal[F, L] {
       implicit val F0: ContravariantMonoidal[F] = F
@@ -534,10 +527,8 @@ sealed abstract private[data] class WriterTInstances10 extends WriterTInstances1
       implicit val F0: SemigroupK[F] = F
     }
 
-  implicit def catsDataApplicativeForWriterT[F[_], L](implicit
-    F: Applicative[F],
-    L: Monoid[L]
-  ): Applicative[WriterT[F, L, *]] =
+  implicit def catsDataApplicativeForWriterT[F[_], L](implicit F: Applicative[F],
+                                                      L: Monoid[L]): Applicative[WriterT[F, L, *]] =
     new WriterTApplicative[F, L] {
       implicit val F0: Applicative[F] = F
       implicit val L0: Monoid[L] = L
@@ -597,9 +588,8 @@ sealed private[data] trait WriterTApply[F[_], L] extends WriterTFunctor[F, L] wi
   def ap[A, B](f: WriterT[F, L, A => B])(fa: WriterT[F, L, A]): WriterT[F, L, B] =
     fa.ap(f)
 
-  override def map2Eval[A, B, Z](fa: WriterT[F, L, A], fb: Eval[WriterT[F, L, B]])(
-    f: (A, B) => Z
-  ): Eval[WriterT[F, L, Z]] =
+  override def map2Eval[A, B, Z](fa: WriterT[F, L, A],
+                                 fb: Eval[WriterT[F, L, B]])(f: (A, B) => Z): Eval[WriterT[F, L, Z]] =
     F0.map2Eval(fa.run, fb.map(_.run)) { case ((la, a), (lb, b)) => (L0.combine(la, lb), f(a, b)) }
       .map(WriterT(_)) // F0 may have a lazy map2Eval
 
diff --git a/core/src/main/scala/cats/instances/duration.scala b/core/src/main/scala/cats/instances/duration.scala
index 21e2e0829..005904957 100644
--- a/core/src/main/scala/cats/instances/duration.scala
+++ b/core/src/main/scala/cats/instances/duration.scala
@@ -6,8 +6,7 @@ import scala.concurrent.duration.{Duration, FiniteDuration}
 trait DurationInstances extends cats.kernel.instances.DurationInstances {
 
   @deprecated("Left to keep binary compatibility. Use CoreDurationInstances.catsStdShowForDurationUnambiguous instead.",
-              "1.5.0"
-  )
+              "1.5.0")
   def catsStdShowForDuration: Show[Duration] =
     AllCoreDurationInstances.catsStdShowForDurationUnambiguous
 }
diff --git a/core/src/main/scala/cats/instances/either.scala b/core/src/main/scala/cats/instances/either.scala
index a558fd503..aa30e5086 100644
--- a/core/src/main/scala/cats/instances/either.scala
+++ b/core/src/main/scala/cats/instances/either.scala
@@ -12,9 +12,8 @@ import cats.data.Ior
 trait EitherInstances extends cats.kernel.instances.EitherInstances {
   implicit val catsStdBitraverseForEither: Bitraverse[Either] =
     new Bitraverse[Either] {
-      def bitraverse[G[_], A, B, C, D](
-        fab: Either[A, B]
-      )(f: A => G[C], g: B => G[D])(implicit G: Applicative[G]): G[Either[C, D]] =
+      def bitraverse[G[_], A, B, C, D](fab: Either[A, B])(f: A => G[C],
+                                                          g: B => G[D])(implicit G: Applicative[G]): G[Either[C, D]] =
         fab match {
           case Left(a)  => G.map(f(a))(Left(_))
           case Right(b) => G.map(g(b))(Right(_))
@@ -26,9 +25,8 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
           case Right(b) => g(c, b)
         }
 
-      def bifoldRight[A, B, C](fab: Either[A, B],
-                               c: Eval[C]
-      )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
+      def bifoldRight[A, B, C](fab: Either[A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
+                                                              g: (B, Eval[C]) => Eval[C]): Eval[C] =
         fab match {
           case Left(a)  => f(a, c)
           case Right(b) => g(b, c)
@@ -105,9 +103,8 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
       override def redeem[B, R](fab: Either[A, B])(recover: A => R, map: B => R): Either[A, R] =
         Right(fab.fold(recover, map))
 
-      override def redeemWith[B, R](
-        fab: Either[A, B]
-      )(recover: A => Either[A, R], bind: B => Either[A, R]): Either[A, R] =
+      override def redeemWith[B, R](fab: Either[A, B])(recover: A => Either[A, R],
+                                                       bind: B => Either[A, R]): Either[A, R] =
         fab.fold(recover, bind)
 
       override def fromEither[B](fab: Either[A, B]): Either[A, B] =
@@ -162,36 +159,28 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
       def align[B, C](fa: Either[A, B], fb: Either[A, C]): Either[A, Ior[B, C]] =
         alignWith(fa, fb)(identity)
 
-      override def alignWith[B, C, D](fb: Either[A, B], fc: Either[A, C])(f: Ior[B, C] => D): Either[A, D] =
-        fb match {
-          case left @ Left(a) =>
-            fc match {
-              case Left(_)  => left.rightCast[D]
-              case Right(c) => Right(f(Ior.right(c)))
-            }
-          case Right(b) =>
-            fc match {
-              case Left(a)  => Right(f(Ior.left(b)))
-              case Right(c) => Right(f(Ior.both(b, c)))
-            }
-        }
+      override def alignWith[B, C, D](fb: Either[A, B], fc: Either[A, C])(f: Ior[B, C] => D): Either[A, D] = fb match {
+        case left @ Left(a) =>
+          fc match {
+            case Left(_)  => left.rightCast[D]
+            case Right(c) => Right(f(Ior.right(c)))
+          }
+        case Right(b) =>
+          fc match {
+            case Left(a)  => Right(f(Ior.left(b)))
+            case Right(c) => Right(f(Ior.both(b, c)))
+          }
+      }
 
     }
   // scalastyle:on method.length
 
   implicit def catsStdSemigroupKForEither[L]: SemigroupK[Either[L, *]] =
     new SemigroupK[Either[L, *]] {
-      def combineK[A](x: Either[L, A], y: Either[L, A]): Either[L, A] =
-        x match {
-          case Left(_)  => y
-          case Right(_) => x
-        }
-
-      override def combineKEval[A](x: Either[L, A], y: Eval[Either[L, A]]): Eval[Either[L, A]] =
-        x match {
-          case Left(_)  => y
-          case Right(_) => Now(x)
-        }
+      def combineK[A](x: Either[L, A], y: Either[L, A]): Either[L, A] = x match {
+        case Left(_)  => y
+        case Right(_) => x
+      }
     }
 
   implicit def catsStdShowForEither[A, B](implicit A: Show[A], B: Show[B]): Show[Either[A, B]] =
diff --git a/core/src/main/scala/cats/instances/equiv.scala b/core/src/main/scala/cats/instances/equiv.scala
index 12e3bcc67..d441bf5d6 100644
--- a/core/src/main/scala/cats/instances/equiv.scala
+++ b/core/src/main/scala/cats/instances/equiv.scala
@@ -9,10 +9,9 @@ trait EquivInstances {
        * Defaults to trivially contracting the type
        * to a point
        */
-      def unit: Equiv[Unit] =
-        new Equiv[Unit] {
-          def equiv(x: Unit, y: Unit): Boolean = true
-        }
+      def unit: Equiv[Unit] = new Equiv[Unit] {
+        def equiv(x: Unit, y: Unit): Boolean = true
+      }
 
       /** Derive an `Equiv` for `B` given an `Equiv[A]` and a function `B => A`.
        *
diff --git a/core/src/main/scala/cats/instances/function.scala b/core/src/main/scala/cats/instances/function.scala
index a3c640661..77efc0409 100644
--- a/core/src/main/scala/cats/instances/function.scala
+++ b/core/src/main/scala/cats/instances/function.scala
@@ -77,11 +77,10 @@ sealed private[instances] trait Function0Instances extends Function0Instances0 {
       def tailRecM[A, B](a: A)(fn: A => () => Either[A, B]): () => B =
         () => {
           @tailrec
-          def loop(thisA: A): B =
-            fn(thisA)() match {
-              case Right(b)    => b
-              case Left(nextA) => loop(nextA)
-            }
+          def loop(thisA: A): B = fn(thisA)() match {
+            case Right(b)    => b
+            case Left(nextA) => loop(nextA)
+          }
           loop(a)
         }
     }
@@ -89,14 +88,13 @@ sealed private[instances] trait Function0Instances extends Function0Instances0 {
 }
 
 sealed private[instances] trait Function0Instances0 {
-  implicit def function0Distributive: Distributive[Function0] =
-    new Distributive[Function0] {
-      def distribute[F[_]: Functor, A, B](fa: F[A])(f: A => Function0[B]): Function0[F[B]] = { () =>
-        Functor[F].map(fa)(a => f(a)())
-      }
-
-      def map[A, B](fa: Function0[A])(f: A => B): Function0[B] = () => f(fa())
+  implicit def function0Distributive: Distributive[Function0] = new Distributive[Function0] {
+    def distribute[F[_]: Functor, A, B](fa: F[A])(f: A => Function0[B]): Function0[F[B]] = { () =>
+      Functor[F].map(fa)(a => f(a)())
     }
+
+    def map[A, B](fa: Function0[A])(f: A => B): Function0[B] = () => f(fa())
+  }
 }
 
 sealed private[instances] trait Function1Instances extends Function1Instances0 {
@@ -125,11 +123,10 @@ sealed private[instances] trait Function1Instances extends Function1Instances0 {
       def tailRecM[A, B](a: A)(fn: A => T1 => Either[A, B]): T1 => B =
         (t: T1) => {
           @tailrec
-          def step(thisA: A): B =
-            fn(thisA)(t) match {
-              case Right(b)    => b
-              case Left(nextA) => step(nextA)
-            }
+          def step(thisA: A): B = fn(thisA)(t) match {
+            case Right(b)    => b
+            case Left(nextA) => step(nextA)
+          }
           step(a)
         }
     }
@@ -174,14 +171,13 @@ sealed private[instances] trait Function1Instances0 {
         fa.compose(f)
     }
 
-  implicit def catsStdDistributiveForFunction1[T1]: Distributive[T1 => *] =
-    new Distributive[T1 => *] {
-      def distribute[F[_]: Functor, A, B](fa: F[A])(f: A => (T1 => B)): T1 => F[B] = { t1 =>
-        Functor[F].map(fa)(a => f(a)(t1))
-      }
+  implicit def catsStdDistributiveForFunction1[T1]: Distributive[T1 => *] = new Distributive[T1 => *] {
+    def distribute[F[_]: Functor, A, B](fa: F[A])(f: A => (T1 => B)): T1 => F[B] = { t1 =>
+      Functor[F].map(fa)(a => f(a)(t1))
+    }
 
-      def map[A, B](fa: T1 => A)(f: A => B): T1 => B = { t1 =>
-        f(fa(t1))
-      }
+    def map[A, B](fa: T1 => A)(f: A => B): T1 => B = { t1 =>
+      f(fa(t1))
     }
+  }
 }
diff --git a/core/src/main/scala/cats/instances/future.scala b/core/src/main/scala/cats/instances/future.scala
index f8fe44511..93e91e2cc 100644
--- a/core/src/main/scala/cats/instances/future.scala
+++ b/core/src/main/scala/cats/instances/future.scala
@@ -6,8 +6,8 @@ import scala.util.{Failure, Success}
 
 trait FutureInstances extends FutureInstances1 {
 
-  implicit def catsStdInstancesForFuture(implicit
-    ec: ExecutionContext
+  implicit def catsStdInstancesForFuture(
+    implicit ec: ExecutionContext
   ): MonadError[Future, Throwable] with CoflatMap[Future] with Monad[Future] =
     new FutureCoflatMap with MonadError[Future, Throwable] with Monad[Future] with StackSafeMonad[Future] {
       override def pure[A](x: A): Future[A] =
diff --git a/core/src/main/scala/cats/instances/invariant.scala b/core/src/main/scala/cats/instances/invariant.scala
index 34897663f..0479941cb 100644
--- a/core/src/main/scala/cats/instances/invariant.scala
+++ b/core/src/main/scala/cats/instances/invariant.scala
@@ -6,32 +6,27 @@ import cats.{InvariantMonoidal, InvariantSemigroupal, Monoid}
 
 trait InvariantMonoidalInstances {
 
-  implicit def catsSemigroupalForMonoid: InvariantSemigroupal[Monoid] =
-    new InvariantSemigroupal[Monoid] {
-      def product[A, B](fa: Monoid[A], fb: Monoid[B]): Monoid[(A, B)] =
-        new Monoid[(A, B)] {
-          val empty = fa.empty -> fb.empty
-          def combine(x: (A, B), y: (A, B)): (A, B) = fa.combine(x._1, y._1) -> fb.combine(x._2, y._2)
-        }
+  implicit def catsSemigroupalForMonoid: InvariantSemigroupal[Monoid] = new InvariantSemigroupal[Monoid] {
+    def product[A, B](fa: Monoid[A], fb: Monoid[B]): Monoid[(A, B)] = new Monoid[(A, B)] {
+      val empty = fa.empty -> fb.empty
+      def combine(x: (A, B), y: (A, B)): (A, B) = fa.combine(x._1, y._1) -> fb.combine(x._2, y._2)
+    }
 
-      def imap[A, B](fa: Monoid[A])(f: A => B)(g: B => A): Monoid[B] =
-        new Monoid[B] {
-          def empty: B = f(fa.empty)
+    def imap[A, B](fa: Monoid[A])(f: A => B)(g: B => A): Monoid[B] = new Monoid[B] {
+      def empty: B = f(fa.empty)
 
-          def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-        }
+      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
     }
+  }
 
   implicit val catsInvariantMonoidalSemigroup: InvariantMonoidal[Semigroup] = new InvariantMonoidal[Semigroup] {
-    def product[A, B](fa: Semigroup[A], fb: Semigroup[B]): Semigroup[(A, B)] =
-      new Semigroup[(A, B)] {
-        def combine(x: (A, B), y: (A, B)): (A, B) = fa.combine(x._1, y._1) -> fb.combine(x._2, y._2)
-      }
-
-    def imap[A, B](fa: Semigroup[A])(f: A => B)(g: B => A): Semigroup[B] =
-      new Semigroup[B] {
-        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      }
+    def product[A, B](fa: Semigroup[A], fb: Semigroup[B]): Semigroup[(A, B)] = new Semigroup[(A, B)] {
+      def combine(x: (A, B), y: (A, B)): (A, B) = fa.combine(x._1, y._1) -> fb.combine(x._2, y._2)
+    }
+
+    def imap[A, B](fa: Semigroup[A])(f: A => B)(g: B => A): Semigroup[B] = new Semigroup[B] {
+      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+    }
 
     def unit: Semigroup[Unit] = implicitly
   }
diff --git a/core/src/main/scala/cats/instances/list.scala b/core/src/main/scala/cats/instances/list.scala
index a0b271920..98a64742a 100644
--- a/core/src/main/scala/cats/instances/list.scala
+++ b/core/src/main/scala/cats/instances/list.scala
@@ -36,16 +36,15 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
 
       def tailRecM[A, B](a: A)(f: A => List[Either[A, B]]): List[B] = {
         val buf = List.newBuilder[B]
-        @tailrec def go(lists: List[List[Either[A, B]]]): Unit =
-          lists match {
-            case (ab :: abs) :: tail =>
-              ab match {
-                case Right(b) => buf += b; go(abs :: tail)
-                case Left(a)  => go(f(a) :: abs :: tail)
-              }
-            case Nil :: tail => go(tail)
-            case Nil         => ()
-          }
+        @tailrec def go(lists: List[List[Either[A, B]]]): Unit = lists match {
+          case (ab :: abs) :: tail =>
+            ab match {
+              case Right(b) => buf += b; go(abs :: tail)
+              case Left(a)  => go(f(a) :: abs :: tail)
+            }
+          case Nil :: tail => go(tail)
+          case Nil         => ()
+        }
         go(f(a) :: Nil)
         buf.result
       }
@@ -74,21 +73,11 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
       override def foldMap[A, B](fa: List[A])(f: A => B)(implicit B: Monoid[B]): B =
         B.combineAll(fa.iterator.map(f))
 
-      override def foldMapK[G[_], A, B](fa: List[A])(f: A => G[B])(implicit G: MonoidK[G]): G[B] = {
-        def loop(fa: List[A]): Eval[G[B]] =
-          fa match {
-            case head :: tl => G.combineKEval(f(head), Eval.defer(loop(tl)))
-            case Nil        => Eval.now(G.empty)
-          }
-        loop(fa).value
-      }
-
       def traverse[G[_], A, B](fa: List[A])(f: A => G[B])(implicit G: Applicative[G]): G[List[B]] = {
-        def loop(fa: List[A]): Eval[G[List[B]]] =
-          fa match {
-            case h :: t => G.map2Eval(f(h), Eval.defer(loop(t)))(_ :: _)
-            case Nil    => Eval.now(G.pure(Nil))
-          }
+        def loop(fa: List[A]): Eval[G[List[B]]] = fa match {
+          case h :: t => G.map2Eval(f(h), Eval.defer(loop(t)))(_ :: _)
+          case Nil    => Eval.now(G.pure(Nil))
+        }
         loop(fa).value
       }
 
@@ -143,14 +132,13 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
       override def isEmpty[A](fa: List[A]): Boolean = fa.isEmpty
 
       override def foldM[G[_], A, B](fa: List[A], z: B)(f: (B, A) => G[B])(implicit G: Monad[G]): G[B] = {
-        def step(in: (List[A], B)): G[Either[(List[A], B), B]] =
-          in match {
-            case (Nil, b) => G.pure(Right(b))
-            case (a :: tail, b) =>
-              G.map(f(b, a)) { bnext =>
-                Left((tail, bnext))
-              }
-          }
+        def step(in: (List[A], B)): G[Either[(List[A], B), B]] = in match {
+          case (Nil, b) => G.pure(Right(b))
+          case (a :: tail, b) =>
+            G.map(f(b, a)) { bnext =>
+              Left((tail, bnext))
+            }
+        }
 
         G.tailRecM((fa, z))(step)
       }
diff --git a/core/src/main/scala/cats/instances/map.scala b/core/src/main/scala/cats/instances/map.scala
index ed60091ae..0dfd81864 100644
--- a/core/src/main/scala/cats/instances/map.scala
+++ b/core/src/main/scala/cats/instances/map.scala
@@ -165,10 +165,9 @@ private[instances] trait MapInstancesBinCompat0 {
 }
 
 private[instances] trait MapInstancesBinCompat1 {
-  implicit def catsStdMonoidKForMap[K]: MonoidK[Map[K, *]] =
-    new MonoidK[Map[K, *]] {
-      override def empty[A]: Map[K, A] = Map.empty
+  implicit def catsStdMonoidKForMap[K]: MonoidK[Map[K, *]] = new MonoidK[Map[K, *]] {
+    override def empty[A]: Map[K, A] = Map.empty
 
-      override def combineK[A](x: Map[K, A], y: Map[K, A]): Map[K, A] = x ++ y
-    }
+    override def combineK[A](x: Map[K, A], y: Map[K, A]): Map[K, A] = x ++ y
+  }
 }
diff --git a/core/src/main/scala/cats/instances/option.scala b/core/src/main/scala/cats/instances/option.scala
index 64a130093..47ac85954 100644
--- a/core/src/main/scala/cats/instances/option.scala
+++ b/core/src/main/scala/cats/instances/option.scala
@@ -23,12 +23,6 @@ trait OptionInstances extends cats.kernel.instances.OptionInstances {
 
       def combineK[A](x: Option[A], y: Option[A]): Option[A] = x.orElse(y)
 
-      override def combineKEval[A](x: Option[A], y: Eval[Option[A]]): Eval[Option[A]] =
-        x match {
-          case None    => y
-          case Some(_) => Now(x)
-        }
-
       def pure[A](x: A): Option[A] = Some(x)
 
       override def map[A, B](fa: Option[A])(f: A => B): Option[B] =
@@ -159,11 +153,10 @@ trait OptionInstances extends cats.kernel.instances.OptionInstances {
 
   implicit def catsStdShowForOption[A](implicit A: Show[A]): Show[Option[A]] =
     new Show[Option[A]] {
-      def show(fa: Option[A]): String =
-        fa match {
-          case Some(a) => s"Some(${A.show(a)})"
-          case None    => "None"
-        }
+      def show(fa: Option[A]): String = fa match {
+        case Some(a) => s"Some(${A.show(a)})"
+        case None    => "None"
+      }
     }
 }
 
diff --git a/core/src/main/scala/cats/instances/set.scala b/core/src/main/scala/cats/instances/set.scala
index a63d0fe64..0e9e8c223 100644
--- a/core/src/main/scala/cats/instances/set.scala
+++ b/core/src/main/scala/cats/instances/set.scala
@@ -39,9 +39,8 @@ trait SetInstances extends cats.kernel.instances.SetInstances {
 
     }
 
-  implicit def catsStdShowForSet[A: Show]: Show[Set[A]] =
-    new Show[Set[A]] {
-      def show(fa: Set[A]): String =
-        fa.iterator.map(_.show).mkString("Set(", ", ", ")")
-    }
+  implicit def catsStdShowForSet[A: Show]: Show[Set[A]] = new Show[Set[A]] {
+    def show(fa: Set[A]): String =
+      fa.iterator.map(_.show).mkString("Set(", ", ", ")")
+  }
 }
diff --git a/core/src/main/scala/cats/instances/sortedMap.scala b/core/src/main/scala/cats/instances/sortedMap.scala
index 4f3bb9faf..b61eeb5a3 100644
--- a/core/src/main/scala/cats/instances/sortedMap.scala
+++ b/core/src/main/scala/cats/instances/sortedMap.scala
@@ -51,15 +51,13 @@ trait SortedMapInstances extends SortedMapInstances2 {
       override def map[A, B](fa: SortedMap[K, A])(f: A => B): SortedMap[K, B] =
         fa.map { case (k, a) => (k, f(a)) }
 
-      override def map2Eval[A, B, Z](fa: SortedMap[K, A], fb: Eval[SortedMap[K, B]])(
-        f: (A, B) => Z
-      ): Eval[SortedMap[K, Z]] =
+      override def map2Eval[A, B, Z](fa: SortedMap[K, A],
+                                     fb: Eval[SortedMap[K, B]])(f: (A, B) => Z): Eval[SortedMap[K, Z]] =
         if (fa.isEmpty) Eval.now(SortedMap.empty(Order[K].toOrdering)) // no need to evaluate fb
         else fb.map(fb => map2(fa, fb)(f))
 
-      override def ap2[A, B, Z](
-        f: SortedMap[K, (A, B) => Z]
-      )(fa: SortedMap[K, A], fb: SortedMap[K, B]): SortedMap[K, Z] =
+      override def ap2[A, B, Z](f: SortedMap[K, (A, B) => Z])(fa: SortedMap[K, A],
+                                                              fb: SortedMap[K, B]): SortedMap[K, Z] =
         f.flatMap {
           case (k, f) =>
             for { a <- fa.get(k); b <- fb.get(k) } yield (k, f(a, b))
@@ -218,12 +216,11 @@ private[instances] trait SortedMapInstancesBinCompat0 {
 }
 
 private[instances] trait SortedMapInstancesBinCompat1 {
-  implicit def catsStdMonoidKForSortedMap[K: Order]: MonoidK[SortedMap[K, *]] =
-    new MonoidK[SortedMap[K, *]] {
-      override def empty[A]: SortedMap[K, A] = SortedMap.empty[K, A](Order[K].toOrdering)
+  implicit def catsStdMonoidKForSortedMap[K: Order]: MonoidK[SortedMap[K, *]] = new MonoidK[SortedMap[K, *]] {
+    override def empty[A]: SortedMap[K, A] = SortedMap.empty[K, A](Order[K].toOrdering)
 
-      override def combineK[A](x: SortedMap[K, A], y: SortedMap[K, A]): SortedMap[K, A] = x ++ y
-    }
+    override def combineK[A](x: SortedMap[K, A], y: SortedMap[K, A]): SortedMap[K, A] = x ++ y
+  }
 }
 
 private[instances] trait SortedMapInstancesBinCompat2 extends cats.kernel.instances.SortedMapInstances
diff --git a/core/src/main/scala/cats/instances/sortedSet.scala b/core/src/main/scala/cats/instances/sortedSet.scala
index e829be16d..36a9652f6 100644
--- a/core/src/main/scala/cats/instances/sortedSet.scala
+++ b/core/src/main/scala/cats/instances/sortedSet.scala
@@ -60,11 +60,10 @@ trait SortedSetInstances extends SortedSetInstances1 {
         fa.collectFirst(Function.unlift(f))
     }
 
-  implicit def catsStdShowForSortedSet[A: Show]: Show[SortedSet[A]] =
-    new Show[SortedSet[A]] {
-      def show(fa: SortedSet[A]): String =
-        fa.iterator.map(Show[A].show).mkString("SortedSet(", ", ", ")")
-    }
+  implicit def catsStdShowForSortedSet[A: Show]: Show[SortedSet[A]] = new Show[SortedSet[A]] {
+    def show(fa: SortedSet[A]): String =
+      fa.iterator.map(Show[A].show).mkString("SortedSet(", ", ", ")")
+  }
 
   @deprecated("Use cats.kernel.instances.sortedSet.catsKernelStdOrderForSortedSet", "2.0.0-RC2")
   private[instances] def catsKernelStdOrderForSortedSet[A: Order]: Order[SortedSet[A]] =
diff --git a/core/src/main/scala/cats/instances/try.scala b/core/src/main/scala/cats/instances/try.scala
index 5d5f68663..3e98c024f 100644
--- a/core/src/main/scala/cats/instances/try.scala
+++ b/core/src/main/scala/cats/instances/try.scala
@@ -15,19 +15,17 @@ trait TryInstances extends TryInstances1 {
     new TryCoflatMap with MonadError[Try, Throwable] with Traverse[Try] with Monad[Try] {
       def pure[A](x: A): Try[A] = Success(x)
 
-      override def product[A, B](ta: Try[A], tb: Try[B]): Try[(A, B)] =
-        (ta, tb) match {
-          case (Success(a), Success(b)) => Success((a, b))
-          case (f: Failure[_], _)       => castFailure[(A, B)](f)
-          case (_, f: Failure[_])       => castFailure[(A, B)](f)
-        }
-
-      override def map2[A, B, Z](ta: Try[A], tb: Try[B])(f: (A, B) => Z): Try[Z] =
-        (ta, tb) match {
-          case (Success(a), Success(b)) => Try(f(a, b))
-          case (f: Failure[_], _)       => castFailure[Z](f)
-          case (_, f: Failure[_])       => castFailure[Z](f)
-        }
+      override def product[A, B](ta: Try[A], tb: Try[B]): Try[(A, B)] = (ta, tb) match {
+        case (Success(a), Success(b)) => Success((a, b))
+        case (f: Failure[_], _)       => castFailure[(A, B)](f)
+        case (_, f: Failure[_])       => castFailure[(A, B)](f)
+      }
+
+      override def map2[A, B, Z](ta: Try[A], tb: Try[B])(f: (A, B) => Z): Try[Z] = (ta, tb) match {
+        case (Success(a), Success(b)) => Try(f(a, b))
+        case (f: Failure[_], _)       => castFailure[Z](f)
+        case (_, f: Failure[_])       => castFailure[Z](f)
+      }
 
       override def map2Eval[A, B, Z](ta: Try[A], tb: Eval[Try[B]])(f: (A, B) => Z): Eval[Try[Z]] =
         ta match {
@@ -148,11 +146,10 @@ trait TryInstances extends TryInstances1 {
 
   implicit def catsStdShowForTry[A](implicit A: Show[A]): Show[Try[A]] =
     new Show[Try[A]] {
-      def show(fa: Try[A]): String =
-        fa match {
-          case Success(a) => s"Success(${A.show(a)})"
-          case Failure(e) => s"Failure($e)"
-        }
+      def show(fa: Try[A]): String = fa match {
+        case Success(a) => s"Success(${A.show(a)})"
+        case Failure(e) => s"Failure($e)"
+      }
     }
 
   /**
@@ -162,12 +159,11 @@ trait TryInstances extends TryInstances1 {
    */
   implicit def catsStdEqForTry[A, T](implicit A: Eq[A], T: Eq[Throwable]): Eq[Try[A]] =
     new Eq[Try[A]] {
-      def eqv(x: Try[A], y: Try[A]): Boolean =
-        (x, y) match {
-          case (Success(a), Success(b)) => A.eqv(a, b)
-          case (Failure(a), Failure(b)) => T.eqv(a, b)
-          case _                        => false
-        }
+      def eqv(x: Try[A], y: Try[A]): Boolean = (x, y) match {
+        case (Success(a), Success(b)) => A.eqv(a, b)
+        case (Failure(a), Failure(b)) => T.eqv(a, b)
+        case _                        => false
+      }
     }
 }
 
diff --git a/core/src/main/scala/cats/instances/tuple.scala b/core/src/main/scala/cats/instances/tuple.scala
index 78851cda5..850734a42 100644
--- a/core/src/main/scala/cats/instances/tuple.scala
+++ b/core/src/main/scala/cats/instances/tuple.scala
@@ -12,20 +12,19 @@ private[instances] trait Tuple2InstancesBinCompat0 {
   /**
    * Witness for: (A, A) <-> Boolean => A
    */
-  implicit def catsDataRepresentableForPair(implicit
-    PF: Functor[Î»[P => (P, P)]]
-  ): Representable.Aux[Î»[P => (P, P)], Boolean] =
-    new Representable[Î»[P => (P, P)]] {
-      override type Representation = Boolean
-      override val F: Functor[Î»[P => (P, P)]] = PF
-
-      override def tabulate[A](f: Boolean => A): (A, A) = (f(true), f(false))
-
-      override def index[A](pair: (A, A)): Boolean => A = {
-        case true  => pair._1
-        case false => pair._2
-      }
+  implicit def catsDataRepresentableForPair(
+    implicit PF: Functor[Î»[P => (P, P)]]
+  ): Representable.Aux[Î»[P => (P, P)], Boolean] = new Representable[Î»[P => (P, P)]] {
+    override type Representation = Boolean
+    override val F: Functor[Î»[P => (P, P)]] = PF
+
+    override def tabulate[A](f: Boolean => A): (A, A) = (f(true), f(false))
+
+    override def index[A](pair: (A, A)): Boolean => A = {
+      case true  => pair._1
+      case false => pair._2
     }
+  }
 
   implicit val catsDataFunctorForPair: Functor[Î»[P => (P, P)]] = new Functor[Î»[P => (P, P)]] {
     override def map[A, B](fa: (A, A))(f: A => B): (B, B) = (f(fa._1), f(fa._2))
@@ -41,17 +40,15 @@ sealed private[instances] trait Tuple2Instances extends Tuple2Instances1 {
       def bifoldLeft[A, B, C](fab: (A, B), c: C)(f: (C, A) => C, g: (C, B) => C): C =
         g(f(c, fab._1), fab._2)
 
-      def bifoldRight[A, B, C](fab: (A, B),
-                               c: Eval[C]
-      )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
+      def bifoldRight[A, B, C](fab: (A, B), c: Eval[C])(f: (A, Eval[C]) => Eval[C],
+                                                        g: (B, Eval[C]) => Eval[C]): Eval[C] =
         g(fab._2, f(fab._1, c))
     }
 
-  implicit def catsStdShowForTuple2[A, B](implicit aShow: Show[A], bShow: Show[B]): Show[(A, B)] =
-    new Show[(A, B)] {
-      override def show(f: (A, B)): String =
-        s"(${aShow.show(f._1)},${bShow.show(f._2)})"
-    }
+  implicit def catsStdShowForTuple2[A, B](implicit aShow: Show[A], bShow: Show[B]): Show[(A, B)] = new Show[(A, B)] {
+    override def show(f: (A, B)): String =
+      s"(${aShow.show(f._1)},${bShow.show(f._2)})"
+  }
 
   implicit def catsStdInstancesForTuple2[X]: Traverse[(X, *)] with Comonad[(X, *)] with Reducible[(X, *)] =
     new Traverse[(X, *)] with Comonad[(X, *)] with Reducible[(X, *)] {
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index e5828c9f7..0d65766b5 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -59,22 +59,21 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
         val buf = Vector.newBuilder[B]
         var state = List(fn(a).iterator)
         @tailrec
-        def loop(): Unit =
-          state match {
-            case Nil => ()
-            case h :: tail if h.isEmpty =>
-              state = tail
-              loop()
-            case h :: tail =>
-              h.next match {
-                case Right(b) =>
-                  buf += b
-                  loop()
-                case Left(a) =>
-                  state = (fn(a).iterator) :: h :: tail
-                  loop()
-              }
-          }
+        def loop(): Unit = state match {
+          case Nil => ()
+          case h :: tail if h.isEmpty =>
+            state = tail
+            loop()
+          case h :: tail =>
+            h.next match {
+              case Right(b) =>
+                buf += b
+                loop()
+              case Left(a) =>
+                state = (fn(a).iterator) :: h :: tail
+                loop()
+            }
+        }
         loop()
         buf.result
       }
@@ -84,12 +83,6 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
       override def get[A](fa: Vector[A])(idx: Long): Option[A] =
         if (idx < Int.MaxValue && fa.size > idx && idx >= 0) Some(fa(idx.toInt)) else None
 
-      override def foldMapK[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: MonoidK[G]): G[B] = {
-        def loop(i: Int): Eval[G[B]] =
-          if (i < fa.length) G.combineKEval(f(fa(i)), Eval.defer(loop(i + 1))) else Eval.now(G.empty)
-        loop(0).value
-      }
-
       final override def traverse[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: Applicative[G]): G[Vector[B]] = {
         def loop(i: Int): Eval[G[List[B]]] =
           if (i < fa.length) G.map2Eval(f(fa(i)), Eval.defer(loop(i + 1)))(_ :: _) else Eval.now(G.pure(Nil))
@@ -182,9 +175,7 @@ private[instances] trait VectorInstancesBinCompat0 {
 
     def traverseFilter[G[_], A, B](fa: Vector[A])(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Vector[B]] =
       traverse
-        .foldRight(fa, Eval.now(G.pure(Vector.empty[B])))((x, xse) =>
-          G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o))
-        )
+        .foldRight(fa, Eval.now(G.pure(Vector.empty[B])))((x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o)))
         .value
 
     override def filterA[G[_], A](fa: Vector[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Vector[A]] =
diff --git a/core/src/main/scala/cats/package.scala b/core/src/main/scala/cats/package.scala
index e90b835aa..5326e8fcd 100644
--- a/core/src/main/scala/cats/package.scala
+++ b/core/src/main/scala/cats/package.scala
@@ -68,11 +68,10 @@ package object cats {
       def extract[A](a: A): A = a
       def flatMap[A, B](a: A)(f: A => B): B = f(a)
       def coflatMap[A, B](a: A)(f: A => B): B = f(a)
-      @tailrec def tailRecM[A, B](a: A)(f: A => Either[A, B]): B =
-        f(a) match {
-          case Left(a1) => tailRecM(a1)(f)
-          case Right(b) => b
-        }
+      @tailrec def tailRecM[A, B](a: A)(f: A => Either[A, B]): B = f(a) match {
+        case Left(a1) => tailRecM(a1)(f)
+        case Right(b) => b
+      }
       override def distribute[F[_], A, B](fa: F[A])(f: A => B)(implicit F: Functor[F]): Id[F[B]] = F.map(fa)(f)
       override def map[A, B](fa: A)(f: A => B): B = f(fa)
       override def ap[A, B](ff: A => B)(fa: A): B = ff(fa)
diff --git a/core/src/main/scala/cats/syntax/alternative.scala b/core/src/main/scala/cats/syntax/alternative.scala
index 79ac72977..7afdf811d 100644
--- a/core/src/main/scala/cats/syntax/alternative.scala
+++ b/core/src/main/scala/cats/syntax/alternative.scala
@@ -26,7 +26,10 @@ final class UniteOps[F[_], G[_], A](private val fga: F[G[A]]) extends AnyVal {
    * res0: List[Int] = List(1, 2, 3, 4)
    * }}}
    */
-  def unite(implicit F: Monad[F], A: Alternative[F], G: Foldable[G]): F[A] = A.unite[G, A](fga)
+  def unite(implicit
+            F: Monad[F],
+            A: Alternative[F],
+            G: Foldable[G]): F[A] = A.unite[G, A](fga)
 }
 
 final class SeparateOps[F[_], G[_, _], A, B](private val fgab: F[G[A, B]]) extends AnyVal {
@@ -42,7 +45,10 @@ final class SeparateOps[F[_], G[_, _], A, B](private val fgab: F[G[A, B]]) exten
    * res0: (List[String], List[Int]) = (List(error),List(1))
    * }}}
    */
-  def separate(implicit F: Monad[F], A: Alternative[F], G: Bifoldable[G]): (F[A], F[B]) = A.separate[G, A, B](fgab)
+  def separate(implicit
+               F: Monad[F],
+               A: Alternative[F],
+               G: Bifoldable[G]): (F[A], F[B]) = A.separate[G, A, B](fgab)
 
   /**
    * @see [[Alternative.separateFoldable]]
@@ -55,8 +61,10 @@ final class SeparateOps[F[_], G[_, _], A, B](private val fgab: F[G[A, B]]) exten
    * res0: (List[String], List[Int]) = (List(error),List(1))
    * }}}
    */
-  def separateFoldable(implicit F: Foldable[F], A: Alternative[F], G: Bifoldable[G]): (F[A], F[B]) =
-    A.separateFoldable[G, A, B](fgab)
+  def separateFoldable(implicit
+                       F: Foldable[F],
+                       A: Alternative[F],
+                       G: Bifoldable[G]): (F[A], F[B]) = A.separateFoldable[G, A, B](fgab)
 }
 
 final class GuardOps(private val condition: Boolean) extends AnyVal {
diff --git a/core/src/main/scala/cats/syntax/applicativeError.scala b/core/src/main/scala/cats/syntax/applicativeError.scala
index b799f16e0..61ba4b225 100644
--- a/core/src/main/scala/cats/syntax/applicativeError.scala
+++ b/core/src/main/scala/cats/syntax/applicativeError.scala
@@ -51,11 +51,9 @@ final class ApplicativeErrorOps[F[_], E, A](private val fa: F[A]) extends AnyVal
   def attempt(implicit F: ApplicativeError[F, E]): F[Either[E, A]] =
     F.attempt(fa)
 
-  def attemptNarrow[EE <: Throwable](implicit
-    F: ApplicativeError[F, E],
-    tag: ClassTag[EE],
-    ev: EE <:< E
-  ): F[Either[EE, A]] =
+  def attemptNarrow[EE <: Throwable](implicit F: ApplicativeError[F, E],
+                                     tag: ClassTag[EE],
+                                     ev: EE <:< E): F[Either[EE, A]] =
     F.attemptNarrow[EE, A](fa)
 
   def attemptT(implicit F: ApplicativeError[F, E]): EitherT[F, E, A] =
diff --git a/core/src/main/scala/cats/syntax/either.scala b/core/src/main/scala/cats/syntax/either.scala
index 91e95d9c4..dda9b5df6 100644
--- a/core/src/main/scala/cats/syntax/either.scala
+++ b/core/src/main/scala/cats/syntax/either.scala
@@ -38,126 +38,108 @@ object EitherSyntax {
 
 final class EitherOps[A, B](private val eab: Either[A, B]) extends AnyVal {
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def foreach(f: B => Unit): Unit =
-    eab match {
-      case Left(_)  => ()
-      case Right(b) => f(b)
-    }
+  private[syntax] def foreach(f: B => Unit): Unit = eab match {
+    case Left(_)  => ()
+    case Right(b) => f(b)
+  }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def getOrElse[BB >: B](default: => BB): BB =
-    eab match {
-      case Left(_)  => default
-      case Right(b) => b
-    }
+  private[syntax] def getOrElse[BB >: B](default: => BB): BB = eab match {
+    case Left(_)  => default
+    case Right(b) => b
+  }
 
-  def orElse[C, BB >: B](fallback: => Either[C, BB]): Either[C, BB] =
-    eab match {
-      case Left(_)      => fallback
-      case r @ Right(_) => EitherUtil.leftCast(r)
-    }
+  def orElse[C, BB >: B](fallback: => Either[C, BB]): Either[C, BB] = eab match {
+    case Left(_)      => fallback
+    case r @ Right(_) => EitherUtil.leftCast(r)
+  }
 
-  def recover[BB >: B](pf: PartialFunction[A, BB]): Either[A, BB] =
-    eab match {
-      case Left(a) if pf.isDefinedAt(a) => Right(pf(a))
-      case _                            => eab
-    }
+  def recover[BB >: B](pf: PartialFunction[A, BB]): Either[A, BB] = eab match {
+    case Left(a) if pf.isDefinedAt(a) => Right(pf(a))
+    case _                            => eab
+  }
 
-  def recoverWith[AA >: A, BB >: B](pf: PartialFunction[A, Either[AA, BB]]): Either[AA, BB] =
-    eab match {
-      case Left(a) if pf.isDefinedAt(a) => pf(a)
-      case _                            => eab
-    }
+  def recoverWith[AA >: A, BB >: B](pf: PartialFunction[A, Either[AA, BB]]): Either[AA, BB] = eab match {
+    case Left(a) if pf.isDefinedAt(a) => pf(a)
+    case _                            => eab
+  }
 
-  def valueOr[BB >: B](f: A => BB): BB =
-    eab match {
-      case Left(a)  => f(a)
-      case Right(b) => b
-    }
+  def valueOr[BB >: B](f: A => BB): BB = eab match {
+    case Left(a)  => f(a)
+    case Right(b) => b
+  }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def forall(f: B => Boolean): Boolean =
-    eab match {
-      case Left(_)  => true
-      case Right(b) => f(b)
-    }
+  private[syntax] def forall(f: B => Boolean): Boolean = eab match {
+    case Left(_)  => true
+    case Right(b) => f(b)
+  }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def exists(f: B => Boolean): Boolean =
-    eab match {
-      case Left(_)  => false
-      case Right(b) => f(b)
-    }
+  private[syntax] def exists(f: B => Boolean): Boolean = eab match {
+    case Left(_)  => false
+    case Right(b) => f(b)
+  }
 
-  def ensure[AA >: A](onFailure: => AA)(f: B => Boolean): Either[AA, B] =
-    eab match {
-      case Left(_)  => eab
-      case Right(b) => if (f(b)) eab else Left(onFailure)
-    }
+  def ensure[AA >: A](onFailure: => AA)(f: B => Boolean): Either[AA, B] = eab match {
+    case Left(_)  => eab
+    case Right(b) => if (f(b)) eab else Left(onFailure)
+  }
 
-  def ensureOr[AA >: A](onFailure: B => AA)(f: B => Boolean): Either[AA, B] =
-    eab match {
-      case Left(_)  => eab
-      case Right(b) => if (f(b)) eab else Left(onFailure(b))
-    }
+  def ensureOr[AA >: A](onFailure: B => AA)(f: B => Boolean): Either[AA, B] = eab match {
+    case Left(_)  => eab
+    case Right(b) => if (f(b)) eab else Left(onFailure(b))
+  }
 
   def toIor: A Ior B = Ior.fromEither(eab)
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def toOption: Option[B] =
-    eab match {
-      case Left(_)  => None
-      case Right(b) => Some(b)
-    }
+  private[syntax] def toOption: Option[B] = eab match {
+    case Left(_)  => None
+    case Right(b) => Some(b)
+  }
 
-  def toList: List[B] =
-    eab match {
-      case Left(_)  => Nil
-      case Right(b) => List(b)
-    }
+  def toList: List[B] = eab match {
+    case Left(_)  => Nil
+    case Right(b) => List(b)
+  }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def toTry(implicit ev: A <:< Throwable): Try[B] =
-    eab match {
-      case Left(a)  => Failure(ev(a))
-      case Right(b) => Success(b)
-    }
+  private[syntax] def toTry(implicit ev: A <:< Throwable): Try[B] = eab match {
+    case Left(a)  => Failure(ev(a))
+    case Right(b) => Success(b)
+  }
 
-  def toValidated: Validated[A, B] =
-    eab match {
-      case Left(a)  => Validated.invalid(a)
-      case Right(b) => Validated.valid(b)
-    }
+  def toValidated: Validated[A, B] = eab match {
+    case Left(a)  => Validated.invalid(a)
+    case Right(b) => Validated.valid(b)
+  }
 
   /** Returns a [[cats.data.ValidatedNel]] representation of this disjunction with the `Left` value
    * as a single element on the `Invalid` side of the [[cats.data.NonEmptyList]]. */
-  def toValidatedNel[AA >: A]: ValidatedNel[AA, B] =
-    eab match {
-      case Left(a)  => Validated.invalidNel(a)
-      case Right(b) => Validated.valid(b)
-    }
+  def toValidatedNel[AA >: A]: ValidatedNel[AA, B] = eab match {
+    case Left(a)  => Validated.invalidNel(a)
+    case Right(b) => Validated.valid(b)
+  }
 
   def withValidated[AA, BB](f: Validated[A, B] => Validated[AA, BB]): Either[AA, BB] =
     f(toValidated).toEither
 
-  def to[F[_]](implicit F: Alternative[F]): F[B] =
-    eab match {
-      case Left(_)  => F.empty
-      case Right(b) => F.pure(b)
-    }
+  def to[F[_]](implicit F: Alternative[F]): F[B] = eab match {
+    case Left(_)  => F.empty
+    case Right(b) => F.pure(b)
+  }
 
-  def bimap[C, D](fa: A => C, fb: B => D): Either[C, D] =
-    eab match {
-      case Left(a)  => Left(fa(a))
-      case Right(b) => Right(fb(b))
-    }
+  def bimap[C, D](fa: A => C, fb: B => D): Either[C, D] = eab match {
+    case Left(a)  => Left(fa(a))
+    case Right(b) => Right(fb(b))
+  }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def map[C](f: B => C): Either[A, C] =
-    eab match {
-      case l @ Left(_) => EitherUtil.rightCast(l)
-      case Right(b)    => Right(f(b))
-    }
+  private[syntax] def map[C](f: B => C): Either[A, C] = eab match {
+    case l @ Left(_) => EitherUtil.rightCast(l)
+    case Right(b)    => Right(f(b))
+  }
 
   def map2Eval[AA >: A, C, Z](fc: Eval[Either[AA, C]])(f: (B, C) => Z): Eval[Either[AA, Z]] =
     eab match {
@@ -165,86 +147,76 @@ final class EitherOps[A, B](private val eab: Either[A, B]) extends AnyVal {
       case Right(b)    => fc.map(_.map(f(b, _)))
     }
 
-  def leftMap[C](f: A => C): Either[C, B] =
-    eab match {
-      case Left(a)      => Left(f(a))
-      case r @ Right(_) => EitherUtil.leftCast(r)
-    }
+  def leftMap[C](f: A => C): Either[C, B] = eab match {
+    case Left(a)      => Left(f(a))
+    case r @ Right(_) => EitherUtil.leftCast(r)
+  }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def flatMap[AA >: A, D](f: B => Either[AA, D]): Either[AA, D] =
-    eab match {
-      case l @ Left(_) => EitherUtil.rightCast(l)
-      case Right(b)    => f(b)
-    }
+  private[syntax] def flatMap[AA >: A, D](f: B => Either[AA, D]): Either[AA, D] = eab match {
+    case l @ Left(_) => EitherUtil.rightCast(l)
+    case Right(b)    => f(b)
+  }
 
-  def leftFlatMap[C, BB >: B](f: A => Either[C, BB]): Either[C, BB] =
-    eab match {
-      case Left(a)      => f(a)
-      case r @ Right(_) => EitherUtil.leftCast(r)
-    }
+  def leftFlatMap[C, BB >: B](f: A => Either[C, BB]): Either[C, BB] = eab match {
+    case Left(a)      => f(a)
+    case r @ Right(_) => EitherUtil.leftCast(r)
+  }
 
-  def compare[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: Order[AA], BB: Order[BB]): Int =
-    eab match {
-      case Left(a1) =>
-        that match {
-          case Left(a2) => AA.compare(a1, a2)
-          case Right(_) => -1
-        }
-      case Right(b1) =>
-        that match {
-          case Left(_)   => 1
-          case Right(b2) => BB.compare(b1, b2)
-        }
-    }
+  def compare[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: Order[AA], BB: Order[BB]): Int = eab match {
+    case Left(a1) =>
+      that match {
+        case Left(a2) => AA.compare(a1, a2)
+        case Right(_) => -1
+      }
+    case Right(b1) =>
+      that match {
+        case Left(_)   => 1
+        case Right(b2) => BB.compare(b1, b2)
+      }
+  }
 
-  def partialCompare[AA >: A, BB >: B](
-    that: Either[AA, BB]
-  )(implicit AA: PartialOrder[AA], BB: PartialOrder[BB]): Double =
-    eab match {
-      case Left(a1) =>
-        that match {
-          case Left(a2) => AA.partialCompare(a1, a2)
-          case Right(_) => -1
-        }
-      case Right(b1) =>
-        that match {
-          case Left(_)   => 1
-          case Right(b2) => BB.partialCompare(b1, b2)
-        }
-    }
+  def partialCompare[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: PartialOrder[AA],
+                                                             BB: PartialOrder[BB]): Double = eab match {
+    case Left(a1) =>
+      that match {
+        case Left(a2) => AA.partialCompare(a1, a2)
+        case Right(_) => -1
+      }
+    case Right(b1) =>
+      that match {
+        case Left(_)   => 1
+        case Right(b2) => BB.partialCompare(b1, b2)
+      }
+  }
 
-  def ===[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: Eq[AA], BB: Eq[BB]): Boolean =
-    eab match {
-      case Left(a1) =>
-        that match {
-          case Left(a2) => AA.eqv(a1, a2)
-          case Right(_) => false
-        }
-      case Right(b1) =>
-        that match {
-          case Left(_)   => false
-          case Right(b2) => BB.eqv(b1, b2)
-        }
-    }
+  def ===[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: Eq[AA], BB: Eq[BB]): Boolean = eab match {
+    case Left(a1) =>
+      that match {
+        case Left(a2) => AA.eqv(a1, a2)
+        case Right(_) => false
+      }
+    case Right(b1) =>
+      that match {
+        case Left(_)   => false
+        case Right(b2) => BB.eqv(b1, b2)
+      }
+  }
 
-  def traverse[F[_], AA >: A, D](f: B => F[D])(implicit F: Applicative[F]): F[Either[AA, D]] =
-    eab match {
-      case l @ Left(_) => F.pure(EitherUtil.rightCast(l))
-      case Right(b)    => F.map(f(b))(Right(_))
-    }
+  def traverse[F[_], AA >: A, D](f: B => F[D])(implicit F: Applicative[F]): F[Either[AA, D]] = eab match {
+    case l @ Left(_) => F.pure(EitherUtil.rightCast(l))
+    case Right(b)    => F.map(f(b))(Right(_))
+  }
 
-  def foldLeft[C](c: C)(f: (C, B) => C): C =
-    eab match {
-      case Left(_)  => c
-      case Right(b) => f(c, b)
-    }
+  def foldLeft[C](c: C)(f: (C, B) => C): C = eab match {
+    case Left(_)  => c
+    case Right(b) => f(c, b)
+  }
 
-  def foldRight[C](lc: Eval[C])(f: (B, Eval[C]) => Eval[C]): Eval[C] =
-    eab match {
-      case Left(_)  => lc
-      case Right(b) => f(b, lc)
-    }
+  def foldRight[C](lc: Eval[C])(f: (B, Eval[C]) => Eval[C]): Eval[C] = eab match {
+    case Left(_)  => lc
+    case Right(b) => f(b, lc)
+  }
 
   /**
    * Combine with another `Either` value.
@@ -278,21 +250,19 @@ final class EitherOps[A, B](private val eab: Either[A, B]) extends AnyVal {
    * res3: Either[String, Int] = Right(7)
    * }}}
    */
-  final def combine[AA >: A, BB >: B](that: Either[AA, BB])(implicit BB: Semigroup[BB]): Either[AA, BB] =
-    eab match {
-      case left @ Left(_) => left
-      case Right(b1) =>
-        that match {
-          case left @ Left(_) => left
-          case Right(b2)      => Right(BB.combine(b1, b2))
-        }
-    }
+  final def combine[AA >: A, BB >: B](that: Either[AA, BB])(implicit BB: Semigroup[BB]): Either[AA, BB] = eab match {
+    case left @ Left(_) => left
+    case Right(b1) =>
+      that match {
+        case left @ Left(_) => left
+        case Right(b2)      => Right(BB.combine(b1, b2))
+      }
+  }
 
-  def show[AA >: A, BB >: B](implicit AA: Show[AA], BB: Show[BB]): String =
-    eab match {
-      case Left(a)  => s"Left(${AA.show(a)})"
-      case Right(b) => s"Right(${BB.show(b)})"
-    }
+  def show[AA >: A, BB >: B](implicit AA: Show[AA], BB: Show[BB]): String = eab match {
+    case Left(a)  => s"Left(${AA.show(a)})"
+    case Right(b) => s"Right(${BB.show(b)})"
+  }
 
   def ap[AA >: A, BB >: B, C](that: Either[AA, BB => C]): Either[AA, C] = that.flatMap(eab.map)
 
@@ -383,11 +353,10 @@ final class EitherObjectOps(private val either: Either.type) extends AnyVal { //
    * Converts an `Option[B]` to an `Either[A, B]`, where the provided `ifNone` values is returned on
    * the left of the `Either` when the specified `Option` is `None`.
    */
-  def fromOption[A, B](o: Option[B], ifNone: => A): Either[A, B] =
-    o match {
-      case None    => left[A, B](ifNone)
-      case Some(a) => right(a)
-    }
+  def fromOption[A, B](o: Option[B], ifNone: => A): Either[A, B] = o match {
+    case None    => left[A, B](ifNone)
+    case Some(a) => right(a)
+  }
 
   /** Cached value of `Right(())` to avoid allocations for a common case. */
   def unit[A]: Either[A, Unit] = EitherUtil.unit
@@ -478,11 +447,10 @@ final private[syntax] class EitherOpsBinCompat0[A, B](private val value: Either[
 
   /** Returns a [[cats.data.ValidatedNec]] representation of this disjunction with the `Left` value
    * as a single element on the `Invalid` side of the [[cats.data.NonEmptyList]]. */
-  def toValidatedNec: ValidatedNec[A, B] =
-    value match {
-      case Left(a)  => Validated.invalidNec(a)
-      case Right(b) => Validated.valid(b)
-    }
+  def toValidatedNec: ValidatedNec[A, B] = value match {
+    case Left(a)  => Validated.invalidNec(a)
+    case Right(b) => Validated.valid(b)
+  }
 }
 
 /** Convenience methods to use `Either` syntax inside `Either` syntax definitions. */
diff --git a/core/src/main/scala/cats/syntax/foldable.scala b/core/src/main/scala/cats/syntax/foldable.scala
index 87b8a204b..729f3f100 100644
--- a/core/src/main/scala/cats/syntax/foldable.scala
+++ b/core/src/main/scala/cats/syntax/foldable.scala
@@ -289,9 +289,8 @@ final class FoldableOps0[F[_], A](private val fa: F[A]) extends AnyVal {
 final private[syntax] class FoldableOps1[F[_]](private val F: Foldable[F]) extends AnyVal {
 
   @deprecated("Use partitionBifold on Foldable", "2.1.0-RC1")
-  def partitionBifold[H[_, _], A, B, C](
-    fa: F[A]
-  )(f: A => H[B, C])(implicit A: Alternative[F], H: Bifoldable[H]): (F[B], F[C]) =
+  def partitionBifold[H[_, _], A, B, C](fa: F[A])(f: A => H[B, C])(implicit A: Alternative[F],
+                                                                   H: Bifoldable[H]): (F[B], F[C]) =
     F.partitionBifold[H, A, B, C](fa)(f)
 
   @deprecated("Use partitionBifoldM on Foldable", "2.1.0-RC1")
@@ -301,8 +300,7 @@ final private[syntax] class FoldableOps1[F[_]](private val F: Foldable[F]) exten
     F.partitionBifoldM[G, H, A, B, C](fa)(f)
 
   @deprecated("Use partitionEitherM on Foldable", "2.1.0-RC1")
-  def partitionEitherM[G[_], A, B, C](
-    fa: F[A]
-  )(f: A => G[Either[B, C]])(implicit A: Alternative[F], M: Monad[G]): G[(F[B], F[C])] =
+  def partitionEitherM[G[_], A, B, C](fa: F[A])(f: A => G[Either[B, C]])(implicit A: Alternative[F],
+                                                                         M: Monad[G]): G[(F[B], F[C])] =
     F.partitionEitherM[G, A, B, C](fa)(f)
 }
diff --git a/core/src/main/scala/cats/syntax/parallel.scala b/core/src/main/scala/cats/syntax/parallel.scala
index 499c101b1..e7406fe06 100644
--- a/core/src/main/scala/cats/syntax/parallel.scala
+++ b/core/src/main/scala/cats/syntax/parallel.scala
@@ -128,11 +128,9 @@ final class ParallelFlatSequenceOps[T[_], M[_], A](private val tmta: T[M[T[A]]])
 }
 
 final class ParallelUnorderedSequenceOps[T[_], M[_], A](private val tmta: T[M[A]]) extends AnyVal {
-  def parUnorderedSequence[F[_]](implicit
-    P: Parallel.Aux[M, F],
-    F: CommutativeApplicative[F],
-    Tutraverse: UnorderedTraverse[T]
-  ): M[T[A]] =
+  def parUnorderedSequence[F[_]](implicit P: Parallel.Aux[M, F],
+                                 F: CommutativeApplicative[F],
+                                 Tutraverse: UnorderedTraverse[T]): M[T[A]] =
     Parallel.parUnorderedSequence(tmta)
 }
 
@@ -144,22 +142,18 @@ final class ParallelUnorderedTraverseOps[T[_], A](private val ta: T[A]) extends
 
   def parUnorderedFlatTraverse[M[_], F[_], B](
     f: A => M[T[B]]
-  )(implicit
-    P: Parallel.Aux[M, F],
+  )(implicit P: Parallel.Aux[M, F],
     F: CommutativeApplicative[F],
     Tflatmap: FlatMap[T],
-    Tutraverse: UnorderedTraverse[T]
-  ): M[T[B]] =
+    Tutraverse: UnorderedTraverse[T]): M[T[B]] =
     Parallel.parUnorderedFlatTraverse(ta)(f)
 }
 
 final class ParallelUnorderedFlatSequenceOps[T[_], M[_], A](private val tmta: T[M[T[A]]]) extends AnyVal {
-  def parUnorderedFlatSequence[F[_]](implicit
-    P: Parallel.Aux[M, F],
-    Tflatmap: FlatMap[T],
-    F: CommutativeApplicative[F],
-    Tutraverse: UnorderedTraverse[T]
-  ): M[T[A]] =
+  def parUnorderedFlatSequence[F[_]](implicit P: Parallel.Aux[M, F],
+                                     Tflatmap: FlatMap[T],
+                                     F: CommutativeApplicative[F],
+                                     Tutraverse: UnorderedTraverse[T]): M[T[A]] =
     Parallel.parUnorderedFlatSequence(tmta)
 }
 
diff --git a/free/src/main/scala/cats/free/Cofree.scala b/free/src/main/scala/cats/free/Cofree.scala
index c8e814551..b2e9e95e4 100644
--- a/free/src/main/scala/cats/free/Cofree.scala
+++ b/free/src/main/scala/cats/free/Cofree.scala
@@ -71,11 +71,10 @@ object Cofree extends CofreeInstances {
   def anaEval[F[_], A, B](a: A)(coalg: A => Eval[F[A]], f: A => B)(implicit F: Functor[F]): Cofree[F, B] =
     Cofree[F, B](f(a), mapSemilazy(coalg(a))(fa => F.map(fa)(anaEval(_)(coalg, f))))
 
-  private def mapSemilazy[A, B](fa: Eval[A])(f: A => B): Eval[B] =
-    fa match {
-      case Now(a) => Now(f(a))
-      case other  => other.map(f)
-    }
+  private def mapSemilazy[A, B](fa: Eval[A])(f: A => B): Eval[B] = fa match {
+    case Now(a) => Now(f(a))
+    case other  => other.map(f)
+  }
 
   /**
    * A stack-safe algebraic recursive fold out of the cofree comonad.
@@ -115,10 +114,9 @@ sealed abstract private[free] class CofreeInstances1 extends CofreeInstances2 {
 }
 
 sealed abstract private[free] class CofreeInstances extends CofreeInstances1 {
-  implicit def catsFreeComonadForCofree[S[_]: Functor]: Comonad[Cofree[S, *]] =
-    new CofreeComonad[S] {
-      def F = implicitly
-    }
+  implicit def catsFreeComonadForCofree[S[_]: Functor]: Comonad[Cofree[S, *]] = new CofreeComonad[S] {
+    def F = implicitly
+  }
 }
 
 private trait CofreeComonad[S[_]] extends Comonad[Cofree[S, *]] {
diff --git a/free/src/main/scala/cats/free/Free.scala b/free/src/main/scala/cats/free/Free.scala
index f2e8baf7e..c95f4fac3 100644
--- a/free/src/main/scala/cats/free/Free.scala
+++ b/free/src/main/scala/cats/free/Free.scala
@@ -48,28 +48,26 @@ sealed abstract class Free[S[_], A] extends Product with Serializable {
 
   /** Takes one evaluation step in the Free monad, re-associating left-nested binds in the process. */
   @tailrec
-  final def step: Free[S, A] =
-    this match {
-      case FlatMapped(FlatMapped(c, f), g) => c.flatMap(cc => f(cc).flatMap(g)).step
-      case FlatMapped(Pure(a), f)          => f(a).step
-      case x                               => x
-    }
+  final def step: Free[S, A] = this match {
+    case FlatMapped(FlatMapped(c, f), g) => c.flatMap(cc => f(cc).flatMap(g)).step
+    case FlatMapped(Pure(a), f)          => f(a).step
+    case x                               => x
+  }
 
   /**
    * Evaluate a single layer of the free monad.
    */
   @tailrec
-  final def resume(implicit S: Functor[S]): Either[S[Free[S, A]], A] =
-    this match {
-      case Pure(a)    => Right(a)
-      case Suspend(t) => Left(S.map(t)(Pure(_)))
-      case FlatMapped(c, f) =>
-        c match {
-          case Pure(a)          => f(a).resume
-          case Suspend(t)       => Left(S.map(t)(f))
-          case FlatMapped(d, g) => d.flatMap(dd => g(dd).flatMap(f)).resume
-        }
-    }
+  final def resume(implicit S: Functor[S]): Either[S[Free[S, A]], A] = this match {
+    case Pure(a)    => Right(a)
+    case Suspend(t) => Left(S.map(t)(Pure(_)))
+    case FlatMapped(c, f) =>
+      c match {
+        case Pure(a)          => f(a).resume
+        case Suspend(t)       => Left(S.map(t)(f))
+        case FlatMapped(d, g) => d.flatMap(dd => g(dd).flatMap(f)).resume
+      }
+  }
 
   /**
    * A combination of step and fold. May be used to define interpreters with custom
@@ -79,13 +77,12 @@ sealed abstract class Free[S[_], A] extends Product with Serializable {
     onPure: A => B,
     onSuspend: S[A] => B,
     onFlatMapped: ((S[X], X => Free[S, A]) forSome { type X }) => B
-  ): B =
-    this.step match {
-      case Pure(a)                    => onPure(a)
-      case Suspend(a)                 => onSuspend(a)
-      case FlatMapped(Suspend(fa), f) => onFlatMapped((fa, f))
-      case _                          => sys.error("FlatMapped should be right associative after step")
-    }
+  ): B = this.step match {
+    case Pure(a)                    => onPure(a)
+    case Suspend(a)                 => onSuspend(a)
+    case FlatMapped(Suspend(fa), f) => onFlatMapped((fa, f))
+    case _                          => sys.error("FlatMapped should be right associative after step")
+  }
 
   /**
    * Run to completion, using a function that extracts the resumption
@@ -359,14 +356,16 @@ sealed abstract private[free] class FreeInstances extends FreeInstances1 {
 
 sealed abstract private[free] class FreeInstances1 {
 
-  implicit def catsFreeFoldableForFree[F[_]](implicit
+  implicit def catsFreeFoldableForFree[F[_]](
+    implicit
     foldableF: Foldable[F]
   ): Foldable[Free[F, *]] =
     new FreeFoldable[F] {
       val F = foldableF
     }
 
-  implicit def catsFreeTraverseForFree[F[_]](implicit
+  implicit def catsFreeTraverseForFree[F[_]](
+    implicit
     traversableF: Traverse[F]
   ): Traverse[Free[F, *]] =
     new FreeTraverse[F] {
diff --git a/free/src/main/scala/cats/free/FreeT.scala b/free/src/main/scala/cats/free/FreeT.scala
index 5e46381ec..8a9e9e88e 100644
--- a/free/src/main/scala/cats/free/FreeT.scala
+++ b/free/src/main/scala/cats/free/FreeT.scala
@@ -236,8 +236,8 @@ sealed abstract private[free] class FreeTInstances extends FreeTInstances0 {
 
   // retained for binary compatibility. its results are incorrect though and it would fail the laws if we generated things of the form pure(()).flatMap(_ => fa)
   @deprecated("does not handle errors beyond the head suspension; use catsFreeMonadErrorForFreeT2", "2.1.0")
-  def catsFreeMonadErrorForFreeT[S[_], M[_], E](implicit
-    E: MonadError[M, E]
+  def catsFreeMonadErrorForFreeT[S[_], M[_], E](
+    implicit E: MonadError[M, E]
   ): MonadError[FreeT[S, M, *], E] =
     new MonadError[FreeT[S, M, *], E] with FreeTMonad[S, M] {
       override def M = E
@@ -254,10 +254,8 @@ sealed abstract private[free] class FreeTInstances extends FreeTInstances0 {
         FreeT.pure[S, M, Unit](()).flatMap(_ => fa)
     }
 
-  implicit def catsFreeMonadErrorForFreeT2[S[_], M[_], E](implicit
-    E: MonadError[M, E],
-    S: Functor[S]
-  ): MonadError[FreeT[S, M, *], E] =
+  implicit def catsFreeMonadErrorForFreeT2[S[_], M[_], E](implicit E: MonadError[M, E],
+                                                          S: Functor[S]): MonadError[FreeT[S, M, *], E] =
     new MonadError[FreeT[S, M, *], E] with FreeTMonad[S, M] {
       override def M = E
 
diff --git a/js/src/main/scala/cats/js/instances/future.scala b/js/src/main/scala/cats/js/instances/future.scala
index 5b13b9be5..d641b4fdb 100644
--- a/js/src/main/scala/cats/js/instances/future.scala
+++ b/js/src/main/scala/cats/js/instances/future.scala
@@ -12,11 +12,10 @@ import cats.syntax.all._
 object future extends FutureInstances0
 
 object Await {
-  def result[A](f: Future[A], atMost: FiniteDuration): A =
-    f.value match {
-      case Some(v) => v.get
-      case None    => throw new IllegalStateException()
-    }
+  def result[A](f: Future[A], atMost: FiniteDuration): A = f.value match {
+    case Some(v) => v.get
+    case None    => throw new IllegalStateException()
+  }
 }
 
 sealed private[instances] trait FutureInstances0 extends FutureInstances1 {
diff --git a/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/SerializableTests.scala b/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/SerializableTests.scala
index 8f71474d2..4be5b8a16 100644
--- a/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/SerializableTests.scala
+++ b/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/SerializableTests.scala
@@ -7,6 +7,5 @@ object SerializableTests extends Laws {
   def serializable[A](a: A): RuleSet =
     new DefaultRuleSet(name = "serializable",
                        parent = None,
-                       "can serialize and deserialize" -> SerializableLaws.serializable(a)
-    )
+                       "can serialize and deserialize" -> SerializableLaws.serializable(a))
 }
diff --git a/kernel/src/main/scala-2.12/cats/kernel/compat/scalaVersionSpecific.scala b/kernel/src/main/scala-2.12/cats/kernel/compat/scalaVersionSpecific.scala
index d5d827824..a1c8b751e 100644
--- a/kernel/src/main/scala-2.12/cats/kernel/compat/scalaVersionSpecific.scala
+++ b/kernel/src/main/scala-2.12/cats/kernel/compat/scalaVersionSpecific.scala
@@ -23,8 +23,7 @@ private[cats] object scalaVersionSpecific {
   }
 
   implicit class lazyZipExtension[A](private val a: A) extends AnyVal {
-    def lazyZip[El1, Repr1, El2, Repr2, T](
-      that: T
-    )(implicit w1: A => TraversableLike[El1, Repr1], w2: T => IterableLike[El2, Repr2]) = (a, that).zipped
+    def lazyZip[El1, Repr1, El2, Repr2, T](that: T)(implicit w1: A => TraversableLike[El1, Repr1],
+                                                    w2: T => IterableLike[El2, Repr2]) = (a, that).zipped
   }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Band.scala b/kernel/src/main/scala/cats/kernel/Band.scala
index b52322cc2..48ab98ddd 100644
--- a/kernel/src/main/scala/cats/kernel/Band.scala
+++ b/kernel/src/main/scala/cats/kernel/Band.scala
@@ -22,8 +22,7 @@ object Band extends SemigroupFunctions[Band] {
   /**
    * Create a `Band` instance from the given function.
    */
-  @inline def instance[A](cmb: (A, A) => A): Band[A] =
-    new Band[A] {
-      override def combine(x: A, y: A): A = cmb(x, y)
-    }
+  @inline def instance[A](cmb: (A, A) => A): Band[A] = new Band[A] {
+    override def combine(x: A, y: A): A = cmb(x, y)
+  }
 }
diff --git a/kernel/src/main/scala/cats/kernel/BoundedSemilattice.scala b/kernel/src/main/scala/cats/kernel/BoundedSemilattice.scala
index 9204c5096..33211e47c 100644
--- a/kernel/src/main/scala/cats/kernel/BoundedSemilattice.scala
+++ b/kernel/src/main/scala/cats/kernel/BoundedSemilattice.scala
@@ -20,10 +20,9 @@ object BoundedSemilattice extends SemilatticeFunctions[BoundedSemilattice] {
   /**
    * Create a `BoundedSemilattice` instance from the given function and empty value.
    */
-  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): BoundedSemilattice[A] =
-    new BoundedSemilattice[A] {
-      override val empty: A = emptyValue
+  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): BoundedSemilattice[A] = new BoundedSemilattice[A] {
+    override val empty: A = emptyValue
 
-      override def combine(x: A, y: A): A = cmb(x, y)
-    }
+    override def combine(x: A, y: A): A = cmb(x, y)
+  }
 }
diff --git a/kernel/src/main/scala/cats/kernel/CommutativeMonoid.scala b/kernel/src/main/scala/cats/kernel/CommutativeMonoid.scala
index 03ac60421..b03362eda 100644
--- a/kernel/src/main/scala/cats/kernel/CommutativeMonoid.scala
+++ b/kernel/src/main/scala/cats/kernel/CommutativeMonoid.scala
@@ -22,10 +22,9 @@ object CommutativeMonoid extends MonoidFunctions[CommutativeMonoid] {
   /**
    * Create a `CommutativeMonoid` instance from the given function and empty value.
    */
-  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): CommutativeMonoid[A] =
-    new CommutativeMonoid[A] {
-      override val empty: A = emptyValue
+  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): CommutativeMonoid[A] = new CommutativeMonoid[A] {
+    override val empty: A = emptyValue
 
-      override def combine(x: A, y: A): A = cmb(x, y)
-    }
+    override def combine(x: A, y: A): A = cmb(x, y)
+  }
 }
diff --git a/kernel/src/main/scala/cats/kernel/CommutativeSemigroup.scala b/kernel/src/main/scala/cats/kernel/CommutativeSemigroup.scala
index 137fce87c..9cdb22c6a 100644
--- a/kernel/src/main/scala/cats/kernel/CommutativeSemigroup.scala
+++ b/kernel/src/main/scala/cats/kernel/CommutativeSemigroup.scala
@@ -33,8 +33,7 @@ object CommutativeSemigroup extends SemigroupFunctions[CommutativeSemigroup] {
   /**
    * Create a `CommutativeSemigroup` instance from the given function.
    */
-  @inline def instance[A](cmb: (A, A) => A): CommutativeSemigroup[A] =
-    new CommutativeSemigroup[A] {
-      override def combine(x: A, y: A): A = cmb(x, y)
-    }
+  @inline def instance[A](cmb: (A, A) => A): CommutativeSemigroup[A] = new CommutativeSemigroup[A] {
+    override def combine(x: A, y: A): A = cmb(x, y)
+  }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Eq.scala b/kernel/src/main/scala/cats/kernel/Eq.scala
index 554ca74bd..1b88aa6df 100644
--- a/kernel/src/main/scala/cats/kernel/Eq.scala
+++ b/kernel/src/main/scala/cats/kernel/Eq.scala
@@ -41,10 +41,9 @@ trait EqToEquivConversion {
    * Implicitly derive a `scala.math.Equiv[A]` from a `Eq[A]`
    * instance.
    */
-  implicit def catsKernelEquivForEq[A](implicit ev: Eq[A]): Equiv[A] =
-    new Equiv[A] {
-      def equiv(a: A, b: A) = ev.eqv(a, b)
-    }
+  implicit def catsKernelEquivForEq[A](implicit ev: Eq[A]): Equiv[A] = new Equiv[A] {
+    def equiv(a: A, b: A) = ev.eqv(a, b)
+  }
 }
 
 @suppressUnusedImportWarningForScalaVersionSpecific
@@ -109,45 +108,42 @@ object Eq
   /**
    * Everything is the same
    */
-  def allEqual[A]: Eq[A] =
-    new Eq[A] {
-      def eqv(x: A, y: A) = true
-    }
+  def allEqual[A]: Eq[A] = new Eq[A] {
+    def eqv(x: A, y: A) = true
+  }
 
   /**
    * This is a monoid that creates an Eq that
    * checks that all equality checks pass
    */
-  def allEqualBoundedSemilattice[A]: BoundedSemilattice[Eq[A]] =
-    new BoundedSemilattice[Eq[A]] {
-      def empty = allEqual[A]
-      def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.and(e1, e2)
-      override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
-        if (es.iterator.isEmpty) None
-        else {
-          val materialized = es.iterator.toVector
-          Some(new Eq[A] {
-            def eqv(x: A, y: A) = materialized.forall(_.eqv(x, y))
-          })
-        }
-    }
+  def allEqualBoundedSemilattice[A]: BoundedSemilattice[Eq[A]] = new BoundedSemilattice[Eq[A]] {
+    def empty = allEqual[A]
+    def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.and(e1, e2)
+    override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
+      if (es.iterator.isEmpty) None
+      else {
+        val materialized = es.iterator.toVector
+        Some(new Eq[A] {
+          def eqv(x: A, y: A) = materialized.forall(_.eqv(x, y))
+        })
+      }
+  }
 
   /**
    * This is a monoid that creates an Eq that
    * checks that at least one equality check passes
    */
-  def anyEqualSemilattice[A]: Semilattice[Eq[A]] =
-    new Semilattice[Eq[A]] {
-      def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.or(e1, e2)
-      override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
-        if (es.iterator.isEmpty) None
-        else {
-          val materialized = es.iterator.toVector
-          Some(new Eq[A] {
-            def eqv(x: A, y: A) = materialized.exists(_.eqv(x, y))
-          })
-        }
-    }
+  def anyEqualSemilattice[A]: Semilattice[Eq[A]] = new Semilattice[Eq[A]] {
+    def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.or(e1, e2)
+    override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
+      if (es.iterator.isEmpty) None
+      else {
+        val materialized = es.iterator.toVector
+        Some(new Eq[A] {
+          def eqv(x: A, y: A) = materialized.exists(_.eqv(x, y))
+        })
+      }
+  }
 
   implicit def catsKernelInstancesForBitSet: PartialOrder[BitSet] with Hash[BitSet] =
     cats.kernel.instances.bitSet.catsKernelStdOrderForBitSet
@@ -208,12 +204,11 @@ object Eq
    */
   implicit def catsStdEqForTry[A, T](implicit A: Eq[A], T: Eq[Throwable]): Eq[Try[A]] =
     new Eq[Try[A]] {
-      def eqv(x: Try[A], y: Try[A]): Boolean =
-        (x, y) match {
-          case (Success(a), Success(b)) => A.eqv(a, b)
-          case (Failure(a), Failure(b)) => T.eqv(a, b)
-          case _                        => false
-        }
+      def eqv(x: Try[A], y: Try[A]): Boolean = (x, y) match {
+        case (Success(a), Success(b)) => A.eqv(a, b)
+        case (Failure(a), Failure(b)) => T.eqv(a, b)
+        case _                        => false
+      }
     }
 }
 
diff --git a/kernel/src/main/scala/cats/kernel/Hash.scala b/kernel/src/main/scala/cats/kernel/Hash.scala
index f25af8e4d..b833750b8 100644
--- a/kernel/src/main/scala/cats/kernel/Hash.scala
+++ b/kernel/src/main/scala/cats/kernel/Hash.scala
@@ -55,8 +55,7 @@ object Hash extends HashFunctions[Hash] {
 }
 
 trait HashToHashingConversion {
-  implicit def catsKernelHashToHashing[A](implicit ev: Hash[A]): Hashing[A] =
-    new Hashing[A] {
-      override def hash(x: A): Int = ev.hash(x)
-    }
+  implicit def catsKernelHashToHashing[A](implicit ev: Hash[A]): Hashing[A] = new Hashing[A] {
+    override def hash(x: A): Int = ev.hash(x)
+  }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Monoid.scala b/kernel/src/main/scala/cats/kernel/Monoid.scala
index 321761061..5e86dd0cd 100644
--- a/kernel/src/main/scala/cats/kernel/Monoid.scala
+++ b/kernel/src/main/scala/cats/kernel/Monoid.scala
@@ -116,10 +116,9 @@ object Monoid extends MonoidFunctions[Monoid] {
   /**
    * Create a `Monoid` instance from the given function and empty value.
    */
-  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): Monoid[A] =
-    new Monoid[A] {
-      override val empty: A = emptyValue
+  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): Monoid[A] = new Monoid[A] {
+    override val empty: A = emptyValue
 
-      override def combine(x: A, y: A): A = cmb(x, y)
-    }
+    override def combine(x: A, y: A): A = cmb(x, y)
+  }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Order.scala b/kernel/src/main/scala/cats/kernel/Order.scala
index e469d4a2d..603e1f392 100644
--- a/kernel/src/main/scala/cats/kernel/Order.scala
+++ b/kernel/src/main/scala/cats/kernel/Order.scala
@@ -93,10 +93,9 @@ trait Order[@sp A] extends Any with PartialOrder[A] { self =>
    * Convert a `Order[A]` to a `scala.math.Ordering[A]`
    * instance.
    */
-  def toOrdering: Ordering[A] =
-    new Ordering[A] {
-      def compare(x: A, y: A): Int = self.compare(x, y)
-    }
+  def toOrdering: Ordering[A] = new Ordering[A] {
+    def compare(x: A, y: A): Int = self.compare(x, y)
+  }
 }
 
 abstract class OrderFunctions[O[T] <: Order[T]] extends PartialOrderFunctions[O] {
diff --git a/kernel/src/main/scala/cats/kernel/PartialOrder.scala b/kernel/src/main/scala/cats/kernel/PartialOrder.scala
index e5e898479..63b5d560a 100644
--- a/kernel/src/main/scala/cats/kernel/PartialOrder.scala
+++ b/kernel/src/main/scala/cats/kernel/PartialOrder.scala
@@ -158,11 +158,10 @@ object PartialOrder extends PartialOrderFunctions[PartialOrder] with PartialOrde
       def partialCompare(x: A, y: A) = f(x, y)
     }
 
-  def fromPartialOrdering[A](implicit ev: PartialOrdering[A]): PartialOrder[A] =
-    new PartialOrder[A] {
-      def partialCompare(x: A, y: A): Double =
-        ev.tryCompare(x, y).fold(Double.NaN)(_.toDouble)
-    }
+  def fromPartialOrdering[A](implicit ev: PartialOrdering[A]): PartialOrder[A] = new PartialOrder[A] {
+    def partialCompare(x: A, y: A): Double =
+      ev.tryCompare(x, y).fold(Double.NaN)(_.toDouble)
+  }
 }
 
 trait PartialOrderToPartialOrderingConversion {
diff --git a/kernel/src/main/scala/cats/kernel/Semigroup.scala b/kernel/src/main/scala/cats/kernel/Semigroup.scala
index f82eb5557..2cceb5cbf 100644
--- a/kernel/src/main/scala/cats/kernel/Semigroup.scala
+++ b/kernel/src/main/scala/cats/kernel/Semigroup.scala
@@ -147,10 +147,9 @@ object Semigroup
   /**
    * Create a `Semigroup` instance from the given function.
    */
-  @inline def instance[A](cmb: (A, A) => A): Semigroup[A] =
-    new Semigroup[A] {
-      override def combine(x: A, y: A): A = cmb(x, y)
-    }
+  @inline def instance[A](cmb: (A, A) => A): Semigroup[A] = new Semigroup[A] {
+    override def combine(x: A, y: A): A = cmb(x, y)
+  }
 
   implicit def catsKernelBoundedSemilatticeForBitSet: BoundedSemilattice[BitSet] =
     cats.kernel.instances.bitSet.catsKernelStdSemilatticeForBitSet
@@ -275,10 +274,9 @@ private class TryMonoid[A](A: Monoid[A]) extends TrySemigroup[A](A) with Monoid[
 }
 
 private class TrySemigroup[A](A: Semigroup[A]) extends Semigroup[Try[A]] {
-  def combine(x: Try[A], y: Try[A]): Try[A] =
-    (x, y) match {
-      case (Success(xv), Success(yv)) => Success(A.combine(xv, yv))
-      case (f @ Failure(_), _)        => f
-      case (_, f)                     => f
-    }
+  def combine(x: Try[A], y: Try[A]): Try[A] = (x, y) match {
+    case (Success(xv), Success(yv)) => Success(A.combine(xv, yv))
+    case (f @ Failure(_), _)        => f
+    case (_, f)                     => f
+  }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Semilattice.scala b/kernel/src/main/scala/cats/kernel/Semilattice.scala
index 631de852f..55facb8ad 100644
--- a/kernel/src/main/scala/cats/kernel/Semilattice.scala
+++ b/kernel/src/main/scala/cats/kernel/Semilattice.scala
@@ -70,8 +70,7 @@ object Semilattice extends SemilatticeFunctions[Semilattice] {
   /**
    * Create a `Semilattice` instance from the given function.
    */
-  @inline def instance[A](cmb: (A, A) => A): Semilattice[A] =
-    new Semilattice[A] {
-      override def combine(x: A, y: A): A = cmb(x, y)
-    }
+  @inline def instance[A](cmb: (A, A) => A): Semilattice[A] = new Semilattice[A] {
+    override def combine(x: A, y: A): A = cmb(x, y)
+  }
 }
diff --git a/kernel/src/main/scala/cats/kernel/instances/EitherInstances.scala b/kernel/src/main/scala/cats/kernel/instances/EitherInstances.scala
index b57079e2e..00447876b 100644
--- a/kernel/src/main/scala/cats/kernel/instances/EitherInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/EitherInstances.scala
@@ -51,10 +51,8 @@ private[instances] trait EitherInstances0 extends EitherInstances1 {
         }
     }
 
-  implicit def catsStdPartialOrderForEither[A, B](implicit
-    A: PartialOrder[A],
-    B: PartialOrder[B]
-  ): PartialOrder[Either[A, B]] =
+  implicit def catsStdPartialOrderForEither[A, B](implicit A: PartialOrder[A],
+                                                  B: PartialOrder[B]): PartialOrder[Either[A, B]] =
     new PartialOrder[Either[A, B]] {
       def partialCompare(x: Either[A, B], y: Either[A, B]): Double =
         x match {
diff --git a/kernel/src/main/scala/cats/kernel/instances/FunctionInstances.scala b/kernel/src/main/scala/cats/kernel/instances/FunctionInstances.scala
index 87f2bd7c0..05b5272ae 100644
--- a/kernel/src/main/scala/cats/kernel/instances/FunctionInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/FunctionInstances.scala
@@ -34,13 +34,13 @@ private[instances] trait FunctionInstances0 extends FunctionInstances1 {
   implicit def catsKernelGroupForFunction1[A, B](implicit G: Group[B]): Group[A => B] =
     new Function1Group[A, B] { def B: Group[B] = G }
 
-  implicit def catsKernelBoundedSemilatticeForFunction0[A](implicit
-    G: BoundedSemilattice[A]
+  implicit def catsKernelBoundedSemilatticeForFunction0[A](
+    implicit G: BoundedSemilattice[A]
   ): BoundedSemilattice[() => A] =
     new Function0Monoid[A] with BoundedSemilattice[() => A] { def A: Monoid[A] = G }
 
-  implicit def catsKernelBoundedSemilatticeForFunction1[A, B](implicit
-    G: BoundedSemilattice[B]
+  implicit def catsKernelBoundedSemilatticeForFunction1[A, B](
+    implicit G: BoundedSemilattice[B]
   ): BoundedSemilattice[A => B] =
     new Function1Monoid[A, B] with BoundedSemilattice[A => B] { def B: Monoid[B] = G }
 }
@@ -52,13 +52,13 @@ private[instances] trait FunctionInstances1 extends FunctionInstances2 {
       def eqv(x: () => A, y: () => A): Boolean = ev.eqv(x(), y())
     }
 
-  implicit def catsKernelCommutativeMonoidForFunction0[A](implicit
-    M: CommutativeMonoid[A]
+  implicit def catsKernelCommutativeMonoidForFunction0[A](
+    implicit M: CommutativeMonoid[A]
   ): CommutativeMonoid[() => A] =
     new Function0Monoid[A] with CommutativeMonoid[() => A] { def A: Monoid[A] = M }
 
-  implicit def catsKernelCommutativeMonoidForFunction1[A, B](implicit
-    M: CommutativeMonoid[B]
+  implicit def catsKernelCommutativeMonoidForFunction1[A, B](
+    implicit M: CommutativeMonoid[B]
   ): CommutativeMonoid[A => B] =
     new Function1Monoid[A, B] with CommutativeMonoid[A => B] { def B: Monoid[B] = M }
 
@@ -86,13 +86,13 @@ private[instances] trait FunctionInstances2 extends FunctionInstances3 {
 
 private[instances] trait FunctionInstances3 extends FunctionInstances4 {
 
-  implicit def catsKernelCommutativeSemigroupForFunction0[A](implicit
-    S: CommutativeSemigroup[A]
+  implicit def catsKernelCommutativeSemigroupForFunction0[A](
+    implicit S: CommutativeSemigroup[A]
   ): CommutativeSemigroup[() => A] =
     new Function0Semigroup[A] with CommutativeSemigroup[() => A] { def A: Semigroup[A] = S }
 
-  implicit def catsKernelCommutativeSemigroupForFunction1[A, B](implicit
-    S: CommutativeSemigroup[B]
+  implicit def catsKernelCommutativeSemigroupForFunction1[A, B](
+    implicit S: CommutativeSemigroup[B]
   ): CommutativeSemigroup[A => B] =
     new Function1Semigroup[A, B] with CommutativeSemigroup[A => B] { def B: Semigroup[B] = S }
 }
diff --git a/kernel/src/main/scala/cats/kernel/instances/OptionInstances.scala b/kernel/src/main/scala/cats/kernel/instances/OptionInstances.scala
index 121bf4986..dcee07216 100644
--- a/kernel/src/main/scala/cats/kernel/instances/OptionInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/OptionInstances.scala
@@ -52,11 +52,10 @@ class OptionPartialOrder[A](implicit A: PartialOrder[A]) extends PartialOrder[Op
 }
 
 class OptionHash[A](implicit A: Hash[A]) extends OptionEq[A]()(A) with Hash[Option[A]] {
-  def hash(x: Option[A]): Int =
-    x match {
-      case None     => None.hashCode()
-      case Some(xx) => StaticMethods.product1HashWithPrefix(A.hash(xx), x.productPrefix)
-    }
+  def hash(x: Option[A]): Int = x match {
+    case None     => None.hashCode()
+    case Some(xx) => StaticMethods.product1HashWithPrefix(A.hash(xx), x.productPrefix)
+  }
 }
 
 class OptionEq[A](implicit A: Eq[A]) extends Eq[Option[A]] {
diff --git a/laws/src/main/scala/cats/laws/AlignLaws.scala b/laws/src/main/scala/cats/laws/AlignLaws.scala
index 7d1d4c242..590a11fb7 100644
--- a/laws/src/main/scala/cats/laws/AlignLaws.scala
+++ b/laws/src/main/scala/cats/laws/AlignLaws.scala
@@ -24,22 +24,21 @@ trait AlignLaws[F[_]] {
   def alignWithConsistent[A, B, C](fa: F[A], fb: F[B], f: A Ior B => C): IsEq[F[C]] =
     fa.alignWith(fb)(f) <-> fa.align(fb).map(f)
 
-  private def assoc[A, B, C](x: Ior[A, Ior[B, C]]): Ior[Ior[A, B], C] =
-    x match {
-      case Left(a) => Left(Left(a))
-      case Right(bc) =>
-        bc match {
-          case Left(b)    => Left(Right(b))
-          case Right(c)   => Right(c)
-          case Both(b, c) => Both(Right(b), c)
-        }
-      case Both(a, bc) =>
-        bc match {
-          case Left(b)    => Left(Both(a, b))
-          case Right(c)   => Both(Left(a), c)
-          case Both(b, c) => Both(Both(a, b), c)
-        }
-    }
+  private def assoc[A, B, C](x: Ior[A, Ior[B, C]]): Ior[Ior[A, B], C] = x match {
+    case Left(a) => Left(Left(a))
+    case Right(bc) =>
+      bc match {
+        case Left(b)    => Left(Right(b))
+        case Right(c)   => Right(c)
+        case Both(b, c) => Both(Right(b), c)
+      }
+    case Both(a, bc) =>
+      bc match {
+        case Left(b)    => Left(Both(a, b))
+        case Right(c)   => Both(Left(a), c)
+        case Both(b, c) => Both(Both(a, b), c)
+      }
+  }
 }
 
 object AlignLaws {
diff --git a/laws/src/main/scala/cats/laws/BifoldableLaws.scala b/laws/src/main/scala/cats/laws/BifoldableLaws.scala
index 3dc51233f..d82c490bd 100644
--- a/laws/src/main/scala/cats/laws/BifoldableLaws.scala
+++ b/laws/src/main/scala/cats/laws/BifoldableLaws.scala
@@ -12,8 +12,8 @@ trait BifoldableLaws[F[_, _]] {
     expected <-> F.bifoldMap(fab)(f, g)
   }
 
-  def bifoldRightConsistentWithBifoldMap[A, B, C](fab: F[A, B], f: A => C, g: B => C)(implicit
-    C: Monoid[C]
+  def bifoldRightConsistentWithBifoldMap[A, B, C](fab: F[A, B], f: A => C, g: B => C)(
+    implicit C: Monoid[C]
   ): IsEq[C] = {
     val expected = F.bifoldRight(fab, Later(C.empty))(
       (a: A, ec: Eval[C]) => ec.map(c => C.combine(f(a), c)),
diff --git a/laws/src/main/scala/cats/laws/BitraverseLaws.scala b/laws/src/main/scala/cats/laws/BitraverseLaws.scala
index d57eb6986..820ebc445 100644
--- a/laws/src/main/scala/cats/laws/BitraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/BitraverseLaws.scala
@@ -15,7 +15,8 @@ trait BitraverseLaws[F[_, _]] extends BifoldableLaws[F] with BifunctorLaws[F] {
     g: B => G[D],
     h: C => G[E],
     i: D => G[H]
-  )(implicit G: Applicative[G]): IsEq[G[G[F[E, H]]]] = {
+  )(implicit
+    G: Applicative[G]): IsEq[G[G[F[E, H]]]] = {
     val fg = F.bitraverse(fab)(f, g)
     val hi = G.map(fg)(f => F.bitraverse(f)(h, i))
 
diff --git a/laws/src/main/scala/cats/laws/DistributiveLaws.scala b/laws/src/main/scala/cats/laws/DistributiveLaws.scala
index 9bb7f2ab2..b23e3cca5 100644
--- a/laws/src/main/scala/cats/laws/DistributiveLaws.scala
+++ b/laws/src/main/scala/cats/laws/DistributiveLaws.scala
@@ -23,7 +23,9 @@ trait DistributiveLaws[F[_]] extends FunctorLaws[F] {
     ma: M[A],
     f: A => F[B],
     g: B => N[C]
-  )(implicit N: Distributive[N], M: Functor[M]): IsEq[Nested[F, N, M[C]]] = {
+  )(implicit
+    N: Distributive[N],
+    M: Functor[M]): IsEq[Nested[F, N, M[C]]] = {
     val rhs = ma.distribute[Nested[F, N, *], C](a => Nested(F.map(f(a))(g)))
     val lhs = Nested(F.map(ma.distribute(f))(fb => fb.distribute(g)))
     lhs <-> rhs
diff --git a/laws/src/main/scala/cats/laws/FlatMapLaws.scala b/laws/src/main/scala/cats/laws/FlatMapLaws.scala
index 423b91ac7..07f47ce66 100644
--- a/laws/src/main/scala/cats/laws/FlatMapLaws.scala
+++ b/laws/src/main/scala/cats/laws/FlatMapLaws.scala
@@ -31,12 +31,11 @@ trait FlatMapLaws[F[_]] extends ApplyLaws[F] {
     F.mproduct(fa)(fb) <-> F.flatMap(fa)(a => F.map(fb(a))((a, _)))
 
   def tailRecMConsistentFlatMap[A](a: A, f: A => F[A]): IsEq[F[A]] = {
-    def bounce(n: Int) =
-      F.tailRecM[(A, Int), A]((a, n)) {
-        case (a0, i) =>
-          if (i > 0) f(a0).map(a1 => Left((a1, i - 1)))
-          else f(a0).map(Right(_))
-      }
+    def bounce(n: Int) = F.tailRecM[(A, Int), A]((a, n)) {
+      case (a0, i) =>
+        if (i > 0) f(a0).map(a1 => Left((a1, i - 1)))
+        else f(a0).map(Right(_))
+    }
     /*
      * The law is for n >= 1
      * bounce(n) == bounce(n - 1).flatMap(f)
diff --git a/laws/src/main/scala/cats/laws/FoldableLaws.scala b/laws/src/main/scala/cats/laws/FoldableLaws.scala
index 973650ba4..da4b3520c 100644
--- a/laws/src/main/scala/cats/laws/FoldableLaws.scala
+++ b/laws/src/main/scala/cats/laws/FoldableLaws.scala
@@ -21,7 +21,8 @@ trait FoldableLaws[F[_]] extends UnorderedFoldableLaws[F] {
   def leftFoldConsistentWithFoldMap[A, B](
     fa: F[A],
     f: A => B
-  )(implicit M: Monoid[B]): IsEq[B] =
+  )(implicit
+    M: Monoid[B]): IsEq[B] =
     fa.foldMap(f) <-> fa.foldLeft(M.empty) { (b, a) =>
       b |+| f(a)
     }
@@ -29,7 +30,8 @@ trait FoldableLaws[F[_]] extends UnorderedFoldableLaws[F] {
   def rightFoldConsistentWithFoldMap[A, B](
     fa: F[A],
     f: A => B
-  )(implicit M: Monoid[B]): IsEq[B] =
+  )(implicit
+    M: Monoid[B]): IsEq[B] =
     fa.foldMap(f) <-> fa.foldRight(Later(M.empty))((a, lb) => lb.map(f(a) |+| _)).value
 
   def existsConsistentWithFind[A](fa: F[A], p: A => Boolean): Boolean =
@@ -48,7 +50,8 @@ trait FoldableLaws[F[_]] extends UnorderedFoldableLaws[F] {
   def foldRightDeferConsistentWithFoldRight[A, B](
     fa: F[A],
     f: (B, A) => B
-  )(implicit M: Monoid[B]): IsEq[B] = {
+  )(implicit
+    M: Monoid[B]): IsEq[B] = {
     val g: (A, Eval[B]) => Eval[B] = (a, ea) => ea.map(f(_, a))
 
     F.foldRight(fa, Later(M.empty))(g).value <-> F.foldRightDefer(fa, Later(M.empty): Eval[B])(g).value
diff --git a/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala b/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala
index e89d7d4ac..9714e240e 100644
--- a/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala
@@ -15,7 +15,9 @@ trait NonEmptyTraverseLaws[F[_]] extends TraverseLaws[F] with ReducibleLaws[F] {
     fa: F[A],
     f: A => M[B],
     g: B => N[C]
-  )(implicit N: Apply[N], M: Apply[M]): IsEq[Nested[M, N, F[C]]] = {
+  )(implicit
+    N: Apply[N],
+    M: Apply[M]): IsEq[Nested[M, N, F[C]]] = {
 
     val lhs = Nested(M.map(fa.nonEmptyTraverse(f))(fb => fb.nonEmptyTraverse(g)))
     val rhs = fa.nonEmptyTraverse[Nested[M, N, *], C](a => Nested(M.map(f(a))(g)))
@@ -26,7 +28,9 @@ trait NonEmptyTraverseLaws[F[_]] extends TraverseLaws[F] with ReducibleLaws[F] {
     fa: F[A],
     f: A => M[B],
     g: A => N[B]
-  )(implicit N: Apply[N], M: Apply[M]): IsEq[(M[F[B]], N[F[B]])] = {
+  )(implicit
+    N: Apply[N],
+    M: Apply[M]): IsEq[(M[F[B]], N[F[B]])] = {
     type MN[Z] = (M[Z], N[Z])
     implicit val MN: Apply[MN] = new Apply[MN] {
       def ap[X, Y](f: MN[X => Y])(fa: MN[X]): MN[Y] = {
diff --git a/laws/src/main/scala/cats/laws/ProfunctorLaws.scala b/laws/src/main/scala/cats/laws/ProfunctorLaws.scala
index 904b5344a..e391b76cc 100644
--- a/laws/src/main/scala/cats/laws/ProfunctorLaws.scala
+++ b/laws/src/main/scala/cats/laws/ProfunctorLaws.scala
@@ -17,8 +17,7 @@ trait ProfunctorLaws[F[_, _]] {
                                                     f2: A2 => A1,
                                                     f1: A1 => A0,
                                                     g1: B0 => B1,
-                                                    g2: B1 => B2
-  ): IsEq[F[A2, B2]] =
+                                                    g2: B1 => B2): IsEq[F[A2, B2]] =
     fab.dimap(f1)(g1).dimap(f2)(g2) <-> fab.dimap(f1.compose(f2))(g2.compose(g1))
 
   def profunctorLmapIdentity[A, B](fab: F[A, B]): IsEq[F[A, B]] =
diff --git a/laws/src/main/scala/cats/laws/ReducibleLaws.scala b/laws/src/main/scala/cats/laws/ReducibleLaws.scala
index 07fab94be..4d52ebd9e 100644
--- a/laws/src/main/scala/cats/laws/ReducibleLaws.scala
+++ b/laws/src/main/scala/cats/laws/ReducibleLaws.scala
@@ -9,19 +9,22 @@ trait ReducibleLaws[F[_]] extends FoldableLaws[F] {
   def reduceLeftToConsistentWithReduceMap[A, B](
     fa: F[A],
     f: A => B
-  )(implicit B: Semigroup[B]): IsEq[B] =
+  )(implicit
+    B: Semigroup[B]): IsEq[B] =
     fa.reduceMap(f) <-> fa.reduceLeftTo(f)((b, a) => b |+| f(a))
 
   def reduceRightToConsistentWithReduceMap[A, B](
     fa: F[A],
     f: A => B
-  )(implicit B: Semigroup[B]): IsEq[B] =
+  )(implicit
+    B: Semigroup[B]): IsEq[B] =
     fa.reduceMap(f) <-> fa.reduceRightTo(f)((a, eb) => eb.map(f(a) |+| _)).value
 
   def reduceRightToConsistentWithReduceRightToOption[A, B](
     fa: F[A],
     f: A => B
-  )(implicit B: Semigroup[B]): IsEq[Option[B]] =
+  )(implicit
+    B: Semigroup[B]): IsEq[Option[B]] =
     fa.reduceRightToOption(f)((a, eb) => eb.map(f(a) |+| _)).value <->
       fa.reduceRightTo(f)((a, eb) => eb.map(f(a) |+| _)).map(Option(_)).value
 
diff --git a/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala b/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
index 6d4300cc5..0811d6917 100644
--- a/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
+++ b/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
@@ -6,28 +6,10 @@ import cats.instances.option._
 import cats.syntax.foldable._
 import cats.syntax.traverse._
 import cats.syntax.traverseFilter._
-import cats.{Applicative, Foldable, MonoidK, Traverse, TraverseFilter}
+import cats.{Applicative, Traverse, TraverseFilter}
 
 trait ShortCircuitingLaws[F[_]] {
 
-  def foldMapKShortCircuits[A](fa: F[A], empty: A)(implicit F: Foldable[F]): IsEq[Long] = {
-    val size = fa.size
-    val maxInvocationsAllowed = size / 2
-    val f = new RestrictedFunction[A, Option[A]]((a: A) => None, maxInvocationsAllowed, Some(empty))
-
-    fa.foldMapK(f)
-    f.invocations.get <-> (maxInvocationsAllowed + 1).min(size)
-  }
-
-  def foldMapKWontShortCircuit[A](fa: F[A], empty: A)(implicit F: Foldable[F]): IsEq[Long] = {
-    val size = fa.size
-    val maxInvocationsAllowed = size / 2
-    val f = new RestrictedFunction[A, Option[A]]((a: A) => None, maxInvocationsAllowed, Some(empty))
-
-    fa.foldMapK(f)(F, nonShortCircuitingMonoidK)
-    f.invocations.get <-> size
-  }
-
   def traverseShortCircuits[A](fa: F[A])(implicit F: Traverse[F]): IsEq[Long] = {
     val size = fa.size
     val maxInvocationsAllowed = size / 2
@@ -104,11 +86,6 @@ trait ShortCircuitingLaws[F[_]] {
     override def pure[A](a: A): Option[A] = Some(a)
     override def ap[A, B](ff: Option[A => B])(fa: Option[A]): Option[B] = ff.flatMap(f => fa.map(f))
   }
-
-  private[this] val nonShortCircuitingMonoidK: MonoidK[Option] = new MonoidK[Option] {
-    def empty[A]: Option[A] = None
-    def combineK[A](x: Option[A], y: Option[A]): Option[A] = x.orElse(y)
-  }
 }
 
 object ShortCircuitingLaws {
diff --git a/laws/src/main/scala/cats/laws/StrongLaws.scala b/laws/src/main/scala/cats/laws/StrongLaws.scala
index 1001e1abe..82fb89750 100644
--- a/laws/src/main/scala/cats/laws/StrongLaws.scala
+++ b/laws/src/main/scala/cats/laws/StrongLaws.scala
@@ -43,7 +43,7 @@ trait StrongLaws[F[_, _]] extends ProfunctorLaws[F] {
   def dinaturalitySecond[A, B, C, D](fab: F[A, B], f: C => D): IsEq[F[(C, A), (D, B)]] =
     fab.second[C].rmap(mapFirst(f)) <-> fab.second[D].lmap(mapFirst(f))
 
-  private def assoc[A, B, C]: (((A, B), C)) => (A, (B, C)) = { case ((a, c), d) => (a, (c, d)) }
+  private def assoc[A, B, C]: (((A, B), C)) => (A, (B, C)) = { case ((a, c), d)   => (a, (c, d)) }
   private def unassoc[A, B, C]: ((A, (B, C))) => ((A, B), C) = { case (a, (c, d)) => ((a, c), d) }
 
   /** first' . first' == dimap assoc unassoc . first' where
diff --git a/laws/src/main/scala/cats/laws/TraverseFilterLaws.scala b/laws/src/main/scala/cats/laws/TraverseFilterLaws.scala
index 3c45188dd..9e642080d 100644
--- a/laws/src/main/scala/cats/laws/TraverseFilterLaws.scala
+++ b/laws/src/main/scala/cats/laws/TraverseFilterLaws.scala
@@ -14,7 +14,8 @@ trait TraverseFilterLaws[F[_]] extends FunctorFilterLaws[F] {
   def traverseFilterConsistentWithTraverse[G[_]: Applicative, A](fa: F[A], f: A => G[A]): IsEq[G[F[A]]] =
     fa.traverseFilter(a => f(a).map(_.some)) <-> F.traverse.traverse(fa)(f)
 
-  def traverseFilterComposition[A, B, C, M[_], N[_]](fa: F[A], f: A => M[Option[B]], g: B => N[Option[C]])(implicit
+  def traverseFilterComposition[A, B, C, M[_], N[_]](fa: F[A], f: A => M[Option[B]], g: B => N[Option[C]])(
+    implicit
     M: Applicative[M],
     N: Applicative[N]
   ): IsEq[Nested[M, N, F[C]]] = {
@@ -27,8 +28,8 @@ trait TraverseFilterLaws[F[_]] extends FunctorFilterLaws[F] {
   def filterAConsistentWithTraverseFilter[G[_]: Applicative, A](fa: F[A], f: A => G[Boolean]): IsEq[G[F[A]]] =
     fa.filterA(f) <-> fa.traverseFilter(a => f(a).map(if (_) Some(a) else None))
 
-  def traverseEitherConsistentWithTraverseFilter[G[_], E, A, B](fa: F[A], f: A => G[Option[B]], e: E)(implicit
-    G: Monad[G]
+  def traverseEitherConsistentWithTraverseFilter[G[_], E, A, B](fa: F[A], f: A => G[Option[B]], e: E)(
+    implicit G: Monad[G]
   ): IsEq[G[F[B]]] =
     fa.traverseEither(a => f(a).map(_.toRight(e)))((_, _) => Applicative[G].unit) <-> fa.traverseFilter(f)
 }
diff --git a/laws/src/main/scala/cats/laws/TraverseLaws.scala b/laws/src/main/scala/cats/laws/TraverseLaws.scala
index 3e0af9073..896209349 100644
--- a/laws/src/main/scala/cats/laws/TraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/TraverseLaws.scala
@@ -16,7 +16,9 @@ trait TraverseLaws[F[_]] extends FunctorLaws[F] with FoldableLaws[F] with Unorde
     fa: F[A],
     f: A => M[B],
     g: B => N[C]
-  )(implicit N: Applicative[N], M: Applicative[M]): IsEq[Nested[M, N, F[C]]] = {
+  )(implicit
+    N: Applicative[N],
+    M: Applicative[M]): IsEq[Nested[M, N, F[C]]] = {
 
     val lhs = Nested(M.map(fa.traverse(f))(fb => fb.traverse(g)))
     val rhs = fa.traverse[Nested[M, N, *], C](a => Nested(M.map(f(a))(g)))
@@ -27,7 +29,9 @@ trait TraverseLaws[F[_]] extends FunctorLaws[F] with FoldableLaws[F] with Unorde
     fa: F[A],
     f: A => M[B],
     g: A => N[B]
-  )(implicit N: Applicative[N], M: Applicative[M]): IsEq[(M[F[B]], N[F[B]])] = {
+  )(implicit
+    N: Applicative[N],
+    M: Applicative[M]): IsEq[(M[F[B]], N[F[B]])] = {
     type MN[Z] = (M[Z], N[Z])
     implicit val MN: Applicative[MN] = new Applicative[MN] {
       def pure[X](x: X): MN[X] = (M.pure(x), N.pure(x))
diff --git a/laws/src/main/scala/cats/laws/UnorderedTraverseLaws.scala b/laws/src/main/scala/cats/laws/UnorderedTraverseLaws.scala
index d3a3ee125..19dc1a402 100644
--- a/laws/src/main/scala/cats/laws/UnorderedTraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/UnorderedTraverseLaws.scala
@@ -9,8 +9,8 @@ trait UnorderedTraverseLaws[F[_]] extends UnorderedFoldableLaws[F] {
   def unorderedTraverseIdentity[A, B](fa: F[A])(f: A => B)(implicit ev: Functor[F]): IsEq[F[B]] =
     F.unorderedTraverse[Id, A, B](fa)(f) <-> (ev.map(fa)(f))
 
-  def unorderedTraverseSequentialComposition[A, B, C, M[_], N[_]](fa: F[A], f: A => M[B], g: B => N[C])(implicit
-    N: CommutativeApplicative[N],
+  def unorderedTraverseSequentialComposition[A, B, C, M[_], N[_]](fa: F[A], f: A => M[B], g: B => N[C])(
+    implicit N: CommutativeApplicative[N],
     M: CommutativeApplicative[M]
   ): IsEq[Nested[M, N, F[C]]] = {
 
@@ -19,8 +19,8 @@ trait UnorderedTraverseLaws[F[_]] extends UnorderedFoldableLaws[F] {
     lhs <-> rhs
   }
 
-  def unorderedTraverseParallelComposition[A, B, M[_], N[_]](fa: F[A], f: A => M[B], g: A => N[B])(implicit
-    N: CommutativeApplicative[N],
+  def unorderedTraverseParallelComposition[A, B, M[_], N[_]](fa: F[A], f: A => M[B], g: A => N[B])(
+    implicit N: CommutativeApplicative[N],
     M: CommutativeApplicative[M]
   ): IsEq[(M[F[B]], N[F[B]])] = {
 
diff --git a/laws/src/main/scala/cats/laws/discipline/AlignTests.scala b/laws/src/main/scala/cats/laws/discipline/AlignTests.scala
index c7af3738b..8d35bb3ac 100644
--- a/laws/src/main/scala/cats/laws/discipline/AlignTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/AlignTests.scala
@@ -11,8 +11,8 @@ import org.typelevel.discipline.Laws
 trait AlignTests[F[_]] extends Laws {
   def laws: AlignLaws[F]
 
-  def align[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
+  def align[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary](
+    implicit ArbFA: Arbitrary[F[A]],
     ArbFB: Arbitrary[F[B]],
     ArbFC: Arbitrary[F[C]],
     ArbFAtoB: Arbitrary[A => C],
@@ -37,8 +37,7 @@ trait AlignTests[F[_]] extends Laws {
                        },
                        "alignWith consistent" -> forAll { (fa: F[A], fb: F[B], f: A Ior B => C) =>
                          laws.alignWithConsistent[A, B, C](fa, fb, f)
-                       }
-    )
+                       })
 }
 
 object AlignTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/AlternativeTests.scala b/laws/src/main/scala/cats/laws/discipline/AlternativeTests.scala
index dab872524..848710a2d 100644
--- a/laws/src/main/scala/cats/laws/discipline/AlternativeTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/AlternativeTests.scala
@@ -10,20 +10,19 @@ trait AlternativeTests[F[_]] extends ApplicativeTests[F] with MonoidKTests[F] {
   def laws: AlternativeLaws[F]
 
   def alternative[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                            ArbFA: Arbitrary[F[A]],
+                                                            ArbFB: Arbitrary[F[B]],
+                                                            ArbFC: Arbitrary[F[C]],
+                                                            ArbFAtoB: Arbitrary[F[A => B]],
+                                                            ArbFBtoC: Arbitrary[F[B => C]],
+                                                            CogenA: Cogen[A],
+                                                            CogenB: Cogen[B],
+                                                            CogenC: Cogen[C],
+                                                            EqFA: Eq[F[A]],
+                                                            EqFB: Eq[F[B]],
+                                                            EqFC: Eq[F[C]],
+                                                            EqFABC: Eq[F[(A, B, C)]],
+                                                            iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       val name: String = "alternative"
       val bases: Seq[(String, RuleSet)] = Nil
diff --git a/laws/src/main/scala/cats/laws/discipline/ApplicativeErrorTests.scala b/laws/src/main/scala/cats/laws/discipline/ApplicativeErrorTests.scala
index b9066b845..e53d3918f 100644
--- a/laws/src/main/scala/cats/laws/discipline/ApplicativeErrorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ApplicativeErrorTests.scala
@@ -12,60 +12,58 @@ trait ApplicativeErrorTests[F[_], E] extends ApplicativeTests[F] {
   def laws: ApplicativeErrorLaws[F, E]
 
   def applicativeError[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFU: Arbitrary[F[Unit]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    ArbE: Arbitrary[E],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    CogenE: Cogen[E],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqE: Eq[E],
-    EqFEitherEU: Eq[F[Either[E, Unit]]],
-    EqFEitherEA: Eq[F[Either[E, A]]],
-    EqEitherTFEA: Eq[EitherT[F, E, A]],
-    EqFABC: Eq[F[(A, B, C)]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                             ArbFA: Arbitrary[F[A]],
+                                                                             ArbFB: Arbitrary[F[B]],
+                                                                             ArbFC: Arbitrary[F[C]],
+                                                                             ArbFU: Arbitrary[F[Unit]],
+                                                                             ArbFAtoB: Arbitrary[F[A => B]],
+                                                                             ArbFBtoC: Arbitrary[F[B => C]],
+                                                                             ArbE: Arbitrary[E],
+                                                                             CogenA: Cogen[A],
+                                                                             CogenB: Cogen[B],
+                                                                             CogenC: Cogen[C],
+                                                                             CogenE: Cogen[E],
+                                                                             EqFA: Eq[F[A]],
+                                                                             EqFB: Eq[F[B]],
+                                                                             EqFC: Eq[F[C]],
+                                                                             EqE: Eq[E],
+                                                                             EqFEitherEU: Eq[F[Either[E, Unit]]],
+                                                                             EqFEitherEA: Eq[F[Either[E, A]]],
+                                                                             EqEitherTFEA: Eq[EitherT[F, E, A]],
+                                                                             EqFABC: Eq[F[(A, B, C)]],
+                                                                             iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       def name: String = "applicativeError"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(applicative[A, B, C])
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "applicativeError handleWith" -> forAll(laws.applicativeErrorHandleWith[A] _),
-          "applicativeError handle" -> forAll(laws.applicativeErrorHandle[A] _),
-          "applicativeError handleErrorWith pure" -> forAll(laws.handleErrorWithPure[A] _),
-          "applicativeError handleError pure" -> forAll(laws.handleErrorPure[A] _),
-          "applicativeError raiseError attempt" -> forAll(laws.raiseErrorAttempt _),
-          "applicativeError pure attempt" -> forAll(laws.pureAttempt[A] _),
-          "applicativeError handleErrorWith consistent with recoverWith" -> forAll(
-            laws.handleErrorWithConsistentWithRecoverWith[A] _
-          ),
-          "applicativeError handleError consistent with recover" -> forAll(laws.handleErrorConsistentWithRecover[A] _),
-          "applicativeError recover consistent with recoverWith" -> forAll(laws.recoverConsistentWithRecoverWith[A] _),
-          "applicativeError attempt consistent with attemptT" -> forAll(laws.attemptConsistentWithAttemptT[A] _),
-          "applicativeError attempt fromEither consistent with pure" -> forAll(
-            laws.attemptFromEitherConsistentWithPure[A] _
-          ),
-          "applicativeError onError pure" -> forAll(laws.onErrorPure[A] _),
-          "applicativeError onError raise" -> forAll(laws.onErrorRaise[A] _),
-          "applicativeError adaptError pure" -> forAll(laws.adaptErrorPure[A] _),
-          "applicativeError adaptError raise" -> forAll(laws.adaptErrorRaise[A] _),
-          "applicativeError redeem is derived from attempt and map" -> forAll(laws.redeemDerivedFromAttemptMap[A, B] _),
-          "applicativeError handleError . raiseError left-distributes over ap" -> forAll(
-            laws.raiseErrorDistributesOverApLeft[A] _
-          ),
-          "applicativeError handleError . raiseError right-distributes over ap" -> forAll(
-            laws.raiseErrorDistributesOverApRight[A] _
-          )
+      def props: Seq[(String, Prop)] = Seq(
+        "applicativeError handleWith" -> forAll(laws.applicativeErrorHandleWith[A] _),
+        "applicativeError handle" -> forAll(laws.applicativeErrorHandle[A] _),
+        "applicativeError handleErrorWith pure" -> forAll(laws.handleErrorWithPure[A] _),
+        "applicativeError handleError pure" -> forAll(laws.handleErrorPure[A] _),
+        "applicativeError raiseError attempt" -> forAll(laws.raiseErrorAttempt _),
+        "applicativeError pure attempt" -> forAll(laws.pureAttempt[A] _),
+        "applicativeError handleErrorWith consistent with recoverWith" -> forAll(
+          laws.handleErrorWithConsistentWithRecoverWith[A] _
+        ),
+        "applicativeError handleError consistent with recover" -> forAll(laws.handleErrorConsistentWithRecover[A] _),
+        "applicativeError recover consistent with recoverWith" -> forAll(laws.recoverConsistentWithRecoverWith[A] _),
+        "applicativeError attempt consistent with attemptT" -> forAll(laws.attemptConsistentWithAttemptT[A] _),
+        "applicativeError attempt fromEither consistent with pure" -> forAll(
+          laws.attemptFromEitherConsistentWithPure[A] _
+        ),
+        "applicativeError onError pure" -> forAll(laws.onErrorPure[A] _),
+        "applicativeError onError raise" -> forAll(laws.onErrorRaise[A] _),
+        "applicativeError adaptError pure" -> forAll(laws.adaptErrorPure[A] _),
+        "applicativeError adaptError raise" -> forAll(laws.adaptErrorRaise[A] _),
+        "applicativeError redeem is derived from attempt and map" -> forAll(laws.redeemDerivedFromAttemptMap[A, B] _),
+        "applicativeError handleError . raiseError left-distributes over ap" -> forAll(
+          laws.raiseErrorDistributesOverApLeft[A] _
+        ),
+        "applicativeError handleError . raiseError right-distributes over ap" -> forAll(
+          laws.raiseErrorDistributesOverApRight[A] _
         )
+      )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala b/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala
index 510024fa0..62852aad9 100644
--- a/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala
@@ -10,20 +10,19 @@ trait ApplicativeTests[F[_]] extends ApplyTests[F] {
   def laws: ApplicativeLaws[F]
 
   def applicative[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                            ArbFA: Arbitrary[F[A]],
+                                                            ArbFB: Arbitrary[F[B]],
+                                                            ArbFC: Arbitrary[F[C]],
+                                                            ArbFAtoB: Arbitrary[F[A => B]],
+                                                            ArbFBtoC: Arbitrary[F[B => C]],
+                                                            CogenA: Cogen[A],
+                                                            CogenB: Cogen[B],
+                                                            CogenC: Cogen[C],
+                                                            EqFA: Eq[F[A]],
+                                                            EqFB: Eq[F[B]],
+                                                            EqFC: Eq[F[C]],
+                                                            EqFABC: Eq[F[(A, B, C)]],
+                                                            iso: Isomorphisms[F]): RuleSet =
     new DefaultRuleSet(
       name = "applicative",
       parent = Some(apply[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/ApplyTests.scala b/laws/src/main/scala/cats/laws/discipline/ApplyTests.scala
index 57ba7983a..2a43c3c4b 100644
--- a/laws/src/main/scala/cats/laws/discipline/ApplyTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ApplyTests.scala
@@ -10,31 +10,29 @@ trait ApplyTests[F[_]] extends FunctorTests[F] with SemigroupalTests[F] {
   def laws: ApplyLaws[F]
 
   def apply[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
-    new RuleSet {
-      val name = "apply"
-      val parents = Seq(functor[A, B, C], semigroupal[A, B, C])
-      val bases = Seq.empty
-      val props = Seq(
-        "apply composition" -> forAll(laws.applyComposition[A, B, C] _),
-        "map2/product-map consistency" -> forAll(laws.map2ProductConsistency[A, B, C] _),
-        "map2/map2Eval consistency" -> forAll(laws.map2EvalConsistency[A, B, C] _),
-        "productR consistent map2" -> forAll(laws.productRConsistency[A, C] _),
-        "productL consistent map2" -> forAll(laws.productLConsistency[A, C] _)
-      )
-    }
+                                                      ArbFA: Arbitrary[F[A]],
+                                                      ArbFB: Arbitrary[F[B]],
+                                                      ArbFC: Arbitrary[F[C]],
+                                                      ArbFAtoB: Arbitrary[F[A => B]],
+                                                      ArbFBtoC: Arbitrary[F[B => C]],
+                                                      CogenA: Cogen[A],
+                                                      CogenB: Cogen[B],
+                                                      CogenC: Cogen[C],
+                                                      EqFA: Eq[F[A]],
+                                                      EqFC: Eq[F[C]],
+                                                      EqFABC: Eq[F[(A, B, C)]],
+                                                      iso: Isomorphisms[F]): RuleSet = new RuleSet {
+    val name = "apply"
+    val parents = Seq(functor[A, B, C], semigroupal[A, B, C])
+    val bases = Seq.empty
+    val props = Seq(
+      "apply composition" -> forAll(laws.applyComposition[A, B, C] _),
+      "map2/product-map consistency" -> forAll(laws.map2ProductConsistency[A, B, C] _),
+      "map2/map2Eval consistency" -> forAll(laws.map2EvalConsistency[A, B, C] _),
+      "productR consistent map2" -> forAll(laws.productRConsistency[A, C] _),
+      "productL consistent map2" -> forAll(laws.productLConsistency[A, C] _)
+    )
+  }
 }
 
 object ApplyTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/ArrowChoiceTests.scala b/laws/src/main/scala/cats/laws/discipline/ArrowChoiceTests.scala
index affff0ee7..f1e23137f 100644
--- a/laws/src/main/scala/cats/laws/discipline/ArrowChoiceTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ArrowChoiceTests.scala
@@ -10,7 +10,8 @@ import Prop._
 trait ArrowChoiceTests[F[_, _]] extends ArrowTests[F] with ChoiceTests[F] {
   def laws: ArrowChoiceLaws[F]
 
-  def arrowChoice[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
+  def arrowChoice[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
+    implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFBC: Arbitrary[F[B, C]],
     ArbFAC: Arbitrary[F[A, C]],
@@ -51,20 +52,18 @@ trait ArrowChoiceTests[F[_, _]] extends ArrowTests[F] with ChoiceTests[F] {
     new RuleSet {
       def name: String = "arrowChoice"
       def bases: Seq[(String, RuleSet)] = Nil
-      def parents: Seq[RuleSet] =
-        Seq(
-          arrow[A, B, C, D, E, G],
-          choice[A, B, C, D]
-        )
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "left and lift commute" -> forAll(laws.leftLiftCommute[A, B, C] _),
-          "left and compose commute" -> forAll(laws.leftComposeCommute[A, B, C, D] _),
-          "left and right consistent" -> forAll(laws.leftRightConsistent[A, B, C] _),
-          "left and then lift (Left.apply) commutes" -> forAll(laws.leftAndThenLiftedLeftApplyCommutes[A, B, C] _),
-          "left and then identity +++ _ commutes" -> forAll(laws.leftAndThenRightIdentityCommutes[A, B, C, D] _),
-          "left commutes with sum association" -> forAll(laws.leftTwiceCommutesWithSumAssociation[A, B, C, D] _)
-        )
+      def parents: Seq[RuleSet] = Seq(
+        arrow[A, B, C, D, E, G],
+        choice[A, B, C, D]
+      )
+      def props: Seq[(String, Prop)] = Seq(
+        "left and lift commute" -> forAll(laws.leftLiftCommute[A, B, C] _),
+        "left and compose commute" -> forAll(laws.leftComposeCommute[A, B, C, D] _),
+        "left and right consistent" -> forAll(laws.leftRightConsistent[A, B, C] _),
+        "left and then lift (Left.apply) commutes" -> forAll(laws.leftAndThenLiftedLeftApplyCommutes[A, B, C] _),
+        "left and then identity +++ _ commutes" -> forAll(laws.leftAndThenRightIdentityCommutes[A, B, C, D] _),
+        "left commutes with sum association" -> forAll(laws.leftTwiceCommutesWithSumAssociation[A, B, C, D] _)
+      )
     }
 }
 object ArrowChoiceTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/ArrowTests.scala b/laws/src/main/scala/cats/laws/discipline/ArrowTests.scala
index 13332b462..a627c45b2 100644
--- a/laws/src/main/scala/cats/laws/discipline/ArrowTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ArrowTests.scala
@@ -9,7 +9,8 @@ import Prop._
 trait ArrowTests[F[_, _]] extends CategoryTests[F] with StrongTests[F] {
   def laws: ArrowLaws[F]
 
-  def arrow[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
+  def arrow[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
+    implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFBC: Arbitrary[F[B, C]],
     ArbFAC: Arbitrary[F[A, C]],
@@ -42,23 +43,21 @@ trait ArrowTests[F[_, _]] extends CategoryTests[F] with StrongTests[F] {
     new RuleSet {
       def name: String = "arrow"
       def bases: Seq[(String, RuleSet)] = Nil
-      def parents: Seq[RuleSet] =
-        Seq(
-          category[A, B, C, D],
-          strong[A, B, C, D, E, G]
-        )
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "arrow identity" -> laws.arrowIdentity[A],
-          "arrow composition" -> forAll(laws.arrowComposition[A, B, C] _),
-          "arrow extension" -> forAll(laws.arrowExtension[A, B, C] _),
-          "arrow functor" -> forAll(laws.arrowFunctor[A, B, C, D] _),
-          "arrow exchange" -> forAll(laws.arrowExchange[A, B, C, D] _),
-          "arrow unit" -> forAll(laws.arrowUnit[A, B, C] _),
-          "arrow association" -> forAll(laws.arrowAssociation[A, B, C, D] _),
-          "split consistent with andThen" -> forAll(laws.splitConsistentWithAndThen[A, B, C, D] _),
-          "merge consistent with andThen" -> forAll(laws.mergeConsistentWithAndThen[A, B, C] _)
-        )
+      def parents: Seq[RuleSet] = Seq(
+        category[A, B, C, D],
+        strong[A, B, C, D, E, G]
+      )
+      def props: Seq[(String, Prop)] = Seq(
+        "arrow identity" -> laws.arrowIdentity[A],
+        "arrow composition" -> forAll(laws.arrowComposition[A, B, C] _),
+        "arrow extension" -> forAll(laws.arrowExtension[A, B, C] _),
+        "arrow functor" -> forAll(laws.arrowFunctor[A, B, C, D] _),
+        "arrow exchange" -> forAll(laws.arrowExchange[A, B, C, D] _),
+        "arrow unit" -> forAll(laws.arrowUnit[A, B, C] _),
+        "arrow association" -> forAll(laws.arrowAssociation[A, B, C, D] _),
+        "split consistent with andThen" -> forAll(laws.splitConsistentWithAndThen[A, B, C, D] _),
+        "merge consistent with andThen" -> forAll(laws.mergeConsistentWithAndThen[A, B, C] _)
+      )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/BifoldableTests.scala b/laws/src/main/scala/cats/laws/discipline/BifoldableTests.scala
index 2e391109f..c53e83db4 100644
--- a/laws/src/main/scala/cats/laws/discipline/BifoldableTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/BifoldableTests.scala
@@ -10,10 +10,9 @@ trait BifoldableTests[F[_, _]] extends Laws {
   def laws: BifoldableLaws[F]
 
   def bifoldable[A: Arbitrary, B: Arbitrary, C: Arbitrary: Monoid: Eq](implicit
-    ArbFAB: Arbitrary[F[A, B]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B]
-  ): RuleSet =
+                                                                       ArbFAB: Arbitrary[F[A, B]],
+                                                                       CogenA: Cogen[A],
+                                                                       CogenB: Cogen[B]): RuleSet =
     new DefaultRuleSet(
       name = "bifoldable",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/BifunctorTests.scala b/laws/src/main/scala/cats/laws/discipline/BifunctorTests.scala
index 7ca82461c..a8f5c3511 100644
--- a/laws/src/main/scala/cats/laws/discipline/BifunctorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/BifunctorTests.scala
@@ -10,16 +10,15 @@ trait BifunctorTests[F[_, _]] extends Laws {
   def laws: BifunctorLaws[F]
 
   def bifunctor[A, A2, A3, B, B2, B3](implicit
-    ArbFAB: Arbitrary[F[A, B]],
-    ArbA2: Arbitrary[A => A2],
-    ArbA3: Arbitrary[A2 => A3],
-    ArbB2: Arbitrary[B => B2],
-    ArbB3: Arbitrary[B2 => B3],
-    EqFAB: Eq[F[A, B]],
-    EqFCZ: Eq[F[A3, B3]],
-    EqFA3B: Eq[F[A3, B]],
-    EqFAB3: Eq[F[A, B3]]
-  ): RuleSet =
+                                      ArbFAB: Arbitrary[F[A, B]],
+                                      ArbA2: Arbitrary[A => A2],
+                                      ArbA3: Arbitrary[A2 => A3],
+                                      ArbB2: Arbitrary[B => B2],
+                                      ArbB3: Arbitrary[B2 => B3],
+                                      EqFAB: Eq[F[A, B]],
+                                      EqFCZ: Eq[F[A3, B3]],
+                                      EqFA3B: Eq[F[A3, B]],
+                                      EqFAB3: Eq[F[A, B3]]): RuleSet =
     new DefaultRuleSet(
       name = "Bifunctor",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/BimonadTests.scala b/laws/src/main/scala/cats/laws/discipline/BimonadTests.scala
index 7ff7c7161..85e6713b3 100644
--- a/laws/src/main/scala/cats/laws/discipline/BimonadTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/BimonadTests.scala
@@ -10,36 +10,34 @@ trait BimonadTests[F[_]] extends MonadTests[F] with ComonadTests[F] {
   def laws: BimonadLaws[F]
 
   def bimonad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFFA: Arbitrary[F[F[A]]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    CogenFA: Cogen[F[A]],
-    CogenFB: Cogen[F[B]],
-    EqFFFA: Eq[F[F[A]]],
-    EqFFA: Eq[F[F[F[A]]]],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    EqFInt: Eq[F[Int]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                    ArbFA: Arbitrary[F[A]],
+                                                                    ArbFFA: Arbitrary[F[F[A]]],
+                                                                    ArbFB: Arbitrary[F[B]],
+                                                                    ArbFC: Arbitrary[F[C]],
+                                                                    ArbFAtoB: Arbitrary[F[A => B]],
+                                                                    ArbFBtoC: Arbitrary[F[B => C]],
+                                                                    CogenA: Cogen[A],
+                                                                    CogenB: Cogen[B],
+                                                                    CogenC: Cogen[C],
+                                                                    CogenFA: Cogen[F[A]],
+                                                                    CogenFB: Cogen[F[B]],
+                                                                    EqFFFA: Eq[F[F[A]]],
+                                                                    EqFFA: Eq[F[F[F[A]]]],
+                                                                    EqFA: Eq[F[A]],
+                                                                    EqFB: Eq[F[B]],
+                                                                    EqFC: Eq[F[C]],
+                                                                    EqFABC: Eq[F[(A, B, C)]],
+                                                                    EqFInt: Eq[F[Int]],
+                                                                    iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       def name: String = "bimonad"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(monad[A, B, C], comonad[A, B, C])
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "pure andThen extract = id" -> forAll(laws.pureExtractIsId[A] _),
-          "extract/flatMap entwining" -> forAll(laws.extractFlatMapEntwining[A] _),
-          "pure/coflatMap entwining" -> forAll(laws.pureCoflatMapEntwining[A] _)
-        )
+      def props: Seq[(String, Prop)] = Seq(
+        "pure andThen extract = id" -> forAll(laws.pureExtractIsId[A] _),
+        "extract/flatMap entwining" -> forAll(laws.extractFlatMapEntwining[A] _),
+        "pure/coflatMap entwining" -> forAll(laws.pureCoflatMapEntwining[A] _)
+      )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/BitraverseTests.scala b/laws/src/main/scala/cats/laws/discipline/BitraverseTests.scala
index 706077f7a..a8083298d 100644
--- a/laws/src/main/scala/cats/laws/discipline/BitraverseTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/BitraverseTests.scala
@@ -9,32 +9,31 @@ trait BitraverseTests[F[_, _]] extends BifoldableTests[F] with BifunctorTests[F]
   def laws: BitraverseLaws[F]
 
   def bitraverse[G[_], A, B, C, D, E, H](implicit
-    G: Applicative[G],
-    C: Monoid[C],
-    ArbFAB: Arbitrary[F[A, B]],
-    ArbFAD: Arbitrary[F[A, D]],
-    ArbGC: Arbitrary[G[C]],
-    ArbGD: Arbitrary[G[D]],
-    ArbGE: Arbitrary[G[E]],
-    ArbGH: Arbitrary[G[H]],
-    ArbA: Arbitrary[A],
-    ArbB: Arbitrary[B],
-    ArbC: Arbitrary[C],
-    ArbE: Arbitrary[E],
-    ArbH: Arbitrary[H],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    CogenD: Cogen[D],
-    CogenE: Cogen[E],
-    EqFAB: Eq[F[A, B]],
-    EqFAD: Eq[F[A, D]],
-    EqFAH: Eq[F[A, H]],
-    EqFCD: Eq[F[C, D]],
-    EqFCH: Eq[F[C, H]],
-    EqGGFEH: Eq[G[G[F[E, H]]]],
-    EqC: Eq[C]
-  ): RuleSet =
+                                         G: Applicative[G],
+                                         C: Monoid[C],
+                                         ArbFAB: Arbitrary[F[A, B]],
+                                         ArbFAD: Arbitrary[F[A, D]],
+                                         ArbGC: Arbitrary[G[C]],
+                                         ArbGD: Arbitrary[G[D]],
+                                         ArbGE: Arbitrary[G[E]],
+                                         ArbGH: Arbitrary[G[H]],
+                                         ArbA: Arbitrary[A],
+                                         ArbB: Arbitrary[B],
+                                         ArbC: Arbitrary[C],
+                                         ArbE: Arbitrary[E],
+                                         ArbH: Arbitrary[H],
+                                         CogenA: Cogen[A],
+                                         CogenB: Cogen[B],
+                                         CogenC: Cogen[C],
+                                         CogenD: Cogen[D],
+                                         CogenE: Cogen[E],
+                                         EqFAB: Eq[F[A, B]],
+                                         EqFAD: Eq[F[A, D]],
+                                         EqFAH: Eq[F[A, H]],
+                                         EqFCD: Eq[F[C, D]],
+                                         EqFCH: Eq[F[C, H]],
+                                         EqGGFEH: Eq[G[G[F[E, H]]]],
+                                         EqC: Eq[C]): RuleSet =
     new RuleSet {
       val name = "bitraverse"
       val parents = Seq(bifoldable[A, B, C], bifunctor[A, B, C, D, E, H])
diff --git a/laws/src/main/scala/cats/laws/discipline/CategoryTests.scala b/laws/src/main/scala/cats/laws/discipline/CategoryTests.scala
index 038fa7850..013420d3d 100644
--- a/laws/src/main/scala/cats/laws/discipline/CategoryTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CategoryTests.scala
@@ -11,12 +11,11 @@ trait CategoryTests[F[_, _]] extends ComposeTests[F] {
   def laws: CategoryLaws[F]
 
   def category[A, B, C, D](implicit
-    ArbFAB: Arbitrary[F[A, B]],
-    ArbFBC: Arbitrary[F[B, C]],
-    ArbFCD: Arbitrary[F[C, D]],
-    EqFAB: Eq[F[A, B]],
-    EqFAD: Eq[F[A, D]]
-  ): RuleSet =
+                           ArbFAB: Arbitrary[F[A, B]],
+                           ArbFBC: Arbitrary[F[B, C]],
+                           ArbFCD: Arbitrary[F[C, D]],
+                           EqFAB: Eq[F[A, B]],
+                           EqFAD: Eq[F[A, D]]): RuleSet =
     new DefaultRuleSet(
       name = "category",
       parent = Some(compose[A, B, C, D]),
diff --git a/laws/src/main/scala/cats/laws/discipline/ChoiceTests.scala b/laws/src/main/scala/cats/laws/discipline/ChoiceTests.scala
index 4db1af117..97f0ebcc2 100644
--- a/laws/src/main/scala/cats/laws/discipline/ChoiceTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ChoiceTests.scala
@@ -10,14 +10,13 @@ trait ChoiceTests[F[_, _]] extends CategoryTests[F] {
   def laws: ChoiceLaws[F]
 
   def choice[A, B, C, D](implicit
-    ArbFAB: Arbitrary[F[A, B]],
-    ArbFAC: Arbitrary[F[A, C]],
-    ArbFBC: Arbitrary[F[B, C]],
-    ArbFCD: Arbitrary[F[C, D]],
-    EqFAB: Eq[F[A, B]],
-    EqFAD: Eq[F[A, D]],
-    EqFEitherABD: Eq[F[Either[A, B], D]]
-  ): RuleSet =
+                         ArbFAB: Arbitrary[F[A, B]],
+                         ArbFAC: Arbitrary[F[A, C]],
+                         ArbFBC: Arbitrary[F[B, C]],
+                         ArbFCD: Arbitrary[F[C, D]],
+                         EqFAB: Eq[F[A, B]],
+                         EqFAD: Eq[F[A, D]],
+                         EqFEitherABD: Eq[F[Either[A, B], D]]): RuleSet =
     new DefaultRuleSet(
       name = "choice",
       parent = Some(category[A, B, C, D]),
diff --git a/laws/src/main/scala/cats/laws/discipline/CoflatMapTests.scala b/laws/src/main/scala/cats/laws/discipline/CoflatMapTests.scala
index 14c4cfbe6..e9f067fe4 100644
--- a/laws/src/main/scala/cats/laws/discipline/CoflatMapTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CoflatMapTests.scala
@@ -10,18 +10,17 @@ trait CoflatMapTests[F[_]] extends Laws with FunctorTests[F] {
   def laws: CoflatMapLaws[F]
 
   def coflatMap[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    CogenFA: Cogen[F[A]],
-    CogenFB: Cogen[F[B]],
-    EqFA: Eq[F[A]],
-    EqFC: Eq[F[C]],
-    EqFFA: Eq[F[F[A]]],
-    EqFB: Eq[F[B]],
-    EqFFFA: Eq[F[F[F[A]]]]
-  ): RuleSet =
+                                                          ArbFA: Arbitrary[F[A]],
+                                                          CogenA: Cogen[A],
+                                                          CogenB: Cogen[B],
+                                                          CogenC: Cogen[C],
+                                                          CogenFA: Cogen[F[A]],
+                                                          CogenFB: Cogen[F[B]],
+                                                          EqFA: Eq[F[A]],
+                                                          EqFC: Eq[F[C]],
+                                                          EqFFA: Eq[F[F[A]]],
+                                                          EqFB: Eq[F[B]],
+                                                          EqFFFA: Eq[F[F[F[A]]]]): RuleSet =
     new DefaultRuleSet(
       name = "coflatMap",
       parent = Some(functor[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeApplicativeTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeApplicativeTests.scala
index 483e1701d..0f453416a 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeApplicativeTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeApplicativeTests.scala
@@ -10,21 +10,20 @@ trait CommutativeApplicativeTests[F[_]] extends CommutativeApplyTests[F] with Ap
   def laws: CommutativeApplicativeLaws[F]
 
   def commutativeApplicative[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    EqFInt: Eq[F[Int]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                                   ArbFA: Arbitrary[F[A]],
+                                                                                   ArbFB: Arbitrary[F[B]],
+                                                                                   ArbFC: Arbitrary[F[C]],
+                                                                                   ArbFAtoB: Arbitrary[F[A => B]],
+                                                                                   ArbFBtoC: Arbitrary[F[B => C]],
+                                                                                   CogenA: Cogen[A],
+                                                                                   CogenB: Cogen[B],
+                                                                                   CogenC: Cogen[C],
+                                                                                   EqFA: Eq[F[A]],
+                                                                                   EqFB: Eq[F[B]],
+                                                                                   EqFC: Eq[F[C]],
+                                                                                   EqFABC: Eq[F[(A, B, C)]],
+                                                                                   EqFInt: Eq[F[Int]],
+                                                                                   iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       def name: String = "commutative applicative"
       def bases: Seq[(String, RuleSet)] = Nil
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeApplyTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeApplyTests.scala
index 58790dfb7..9daa9fd30 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeApplyTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeApplyTests.scala
@@ -10,29 +10,27 @@ trait CommutativeApplyTests[F[_]] extends ApplyTests[F] {
   def laws: CommutativeApplyLaws[F]
 
   def commutativeApply[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    EqFInt: Eq[F[Int]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                             ArbFA: Arbitrary[F[A]],
+                                                                             ArbFB: Arbitrary[F[B]],
+                                                                             ArbFC: Arbitrary[F[C]],
+                                                                             ArbFAtoB: Arbitrary[F[A => B]],
+                                                                             ArbFBtoC: Arbitrary[F[B => C]],
+                                                                             CogenA: Cogen[A],
+                                                                             CogenB: Cogen[B],
+                                                                             CogenC: Cogen[C],
+                                                                             EqFA: Eq[F[A]],
+                                                                             EqFB: Eq[F[B]],
+                                                                             EqFC: Eq[F[C]],
+                                                                             EqFABC: Eq[F[(A, B, C)]],
+                                                                             EqFInt: Eq[F[Int]],
+                                                                             iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       def name: String = "commutative apply"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(apply[A, B, C])
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "apply commutativity" -> forAll(laws.applyCommutative[A, B, C] _)
-        )
+      def props: Seq[(String, Prop)] = Seq(
+        "apply commutativity" -> forAll(laws.applyCommutative[A, B, C] _)
+      )
     }
 
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeArrowTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeArrowTests.scala
index 6a9fb2853..53695eee3 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeArrowTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeArrowTests.scala
@@ -9,7 +9,8 @@ import Prop._
 trait CommutativeArrowTests[F[_, _]] extends ArrowTests[F] {
   def laws: CommutativeArrowLaws[F]
 
-  def commutativeArrow[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
+  def commutativeArrow[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
+    implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFAC: Arbitrary[F[A, C]],
     ArbFBC: Arbitrary[F[B, C]],
@@ -41,8 +42,7 @@ trait CommutativeArrowTests[F[_, _]] extends ArrowTests[F] {
   ): RuleSet =
     new DefaultRuleSet(name = "commutative arrow",
                        parent = Some(arrow[A, B, C, D, E, G]),
-                       "arrow commutativity" -> forAll(laws.arrowCommutative[A, B, C, D] _)
-    )
+                       "arrow commutativity" -> forAll(laws.arrowCommutative[A, B, C, D] _))
 }
 
 object CommutativeArrowTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeFlatMapTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeFlatMapTests.scala
index f83585153..15a763b1a 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeFlatMapTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeFlatMapTests.scala
@@ -10,29 +10,27 @@ trait CommutativeFlatMapTests[F[_]] extends FlatMapTests[F] with CommutativeAppl
   def laws: CommutativeFlatMapLaws[F]
 
   def commutativeFlatMap[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    EqFInt: Eq[F[Int]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                               ArbFA: Arbitrary[F[A]],
+                                                                               ArbFB: Arbitrary[F[B]],
+                                                                               ArbFC: Arbitrary[F[C]],
+                                                                               ArbFAtoB: Arbitrary[F[A => B]],
+                                                                               ArbFBtoC: Arbitrary[F[B => C]],
+                                                                               CogenA: Cogen[A],
+                                                                               CogenB: Cogen[B],
+                                                                               CogenC: Cogen[C],
+                                                                               EqFA: Eq[F[A]],
+                                                                               EqFB: Eq[F[B]],
+                                                                               EqFC: Eq[F[C]],
+                                                                               EqFABC: Eq[F[(A, B, C)]],
+                                                                               EqFInt: Eq[F[Int]],
+                                                                               iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       def name: String = "commutative flatMap"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(flatMap[A, B, C], commutativeApply[A, B, C])
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "flatmap commutativity" -> forAll(laws.flatmapCommutative[A, B, C] _)
-        )
+      def props: Seq[(String, Prop)] = Seq(
+        "flatmap commutativity" -> forAll(laws.flatmapCommutative[A, B, C] _)
+      )
     }
 
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeMonadTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeMonadTests.scala
index 0407fc107..3ae9a5c69 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeMonadTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeMonadTests.scala
@@ -12,21 +12,20 @@ trait CommutativeMonadTests[F[_]]
   def laws: CommutativeMonadLaws[F]
 
   def commutativeMonad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    EqFInt: Eq[F[Int]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                             ArbFA: Arbitrary[F[A]],
+                                                                             ArbFB: Arbitrary[F[B]],
+                                                                             ArbFC: Arbitrary[F[C]],
+                                                                             ArbFAtoB: Arbitrary[F[A => B]],
+                                                                             ArbFBtoC: Arbitrary[F[B => C]],
+                                                                             CogenA: Cogen[A],
+                                                                             CogenB: Cogen[B],
+                                                                             CogenC: Cogen[C],
+                                                                             EqFA: Eq[F[A]],
+                                                                             EqFB: Eq[F[B]],
+                                                                             EqFC: Eq[F[C]],
+                                                                             EqFABC: Eq[F[(A, B, C)]],
+                                                                             EqFInt: Eq[F[Int]],
+                                                                             iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       def name: String = "commutative monad"
       def bases: Seq[(String, RuleSet)] = Nil
diff --git a/laws/src/main/scala/cats/laws/discipline/ComonadTests.scala b/laws/src/main/scala/cats/laws/discipline/ComonadTests.scala
index 342f39fa0..9fa4c9b2a 100644
--- a/laws/src/main/scala/cats/laws/discipline/ComonadTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ComonadTests.scala
@@ -10,18 +10,17 @@ trait ComonadTests[F[_]] extends CoflatMapTests[F] {
   def laws: ComonadLaws[F]
 
   def comonad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    CogenFA: Cogen[F[A]],
-    CogenFB: Cogen[F[B]],
-    EqFA: Eq[F[A]],
-    EqFFA: Eq[F[F[A]]],
-    EqFFFA: Eq[F[F[F[A]]]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]]
-  ): RuleSet =
+                                                                    ArbFA: Arbitrary[F[A]],
+                                                                    CogenA: Cogen[A],
+                                                                    CogenB: Cogen[B],
+                                                                    CogenC: Cogen[C],
+                                                                    CogenFA: Cogen[F[A]],
+                                                                    CogenFB: Cogen[F[B]],
+                                                                    EqFA: Eq[F[A]],
+                                                                    EqFFA: Eq[F[F[A]]],
+                                                                    EqFFFA: Eq[F[F[F[A]]]],
+                                                                    EqFB: Eq[F[B]],
+                                                                    EqFC: Eq[F[C]]): RuleSet =
     new DefaultRuleSet(
       name = "comonad",
       parent = Some(coflatMap[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/ComposeTests.scala b/laws/src/main/scala/cats/laws/discipline/ComposeTests.scala
index ff82550a4..335f5dfd0 100644
--- a/laws/src/main/scala/cats/laws/discipline/ComposeTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ComposeTests.scala
@@ -12,15 +12,13 @@ trait ComposeTests[F[_, _]] extends Laws {
   def laws: ComposeLaws[F]
 
   def compose[A, B, C, D](implicit
-    ArbFAB: Arbitrary[F[A, B]],
-    ArbFBC: Arbitrary[F[B, C]],
-    ArbFCD: Arbitrary[F[C, D]],
-    EqFAD: Eq[F[A, D]]
-  ): RuleSet =
+                          ArbFAB: Arbitrary[F[A, B]],
+                          ArbFBC: Arbitrary[F[B, C]],
+                          ArbFCD: Arbitrary[F[C, D]],
+                          EqFAD: Eq[F[A, D]]): RuleSet =
     new DefaultRuleSet(name = "compose",
                        parent = None,
-                       "compose associativity" -> forAll(laws.composeAssociativity[A, B, C, D] _)
-    )
+                       "compose associativity" -> forAll(laws.composeAssociativity[A, B, C, D] _))
 }
 
 object ComposeTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/ContravariantMonoidalTests.scala b/laws/src/main/scala/cats/laws/discipline/ContravariantMonoidalTests.scala
index 171875e1e..bf5c9101c 100644
--- a/laws/src/main/scala/cats/laws/discipline/ContravariantMonoidalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ContravariantMonoidalTests.scala
@@ -11,18 +11,17 @@ trait ContravariantMonoidalTests[F[_]] extends ContravariantSemigroupalTests[F]
   def laws: ContravariantMonoidalLaws[F]
 
   def contravariantMonoidal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    arbFA: Arbitrary[F[A]],
-    arbFB: Arbitrary[F[B]],
-    arbFC: Arbitrary[F[C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                      arbFA: Arbitrary[F[A]],
+                                                                      arbFB: Arbitrary[F[B]],
+                                                                      arbFC: Arbitrary[F[C]],
+                                                                      CogenA: Cogen[A],
+                                                                      CogenB: Cogen[B],
+                                                                      CogenC: Cogen[C],
+                                                                      EqFA: Eq[F[A]],
+                                                                      EqFB: Eq[F[B]],
+                                                                      EqFC: Eq[F[C]],
+                                                                      EqFABC: Eq[F[(A, B, C)]],
+                                                                      iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       val name = "contravariantMonoidal"
       val parents = Seq(contravariantSemigroupal[A, B, C])
diff --git a/laws/src/main/scala/cats/laws/discipline/ContravariantSemigroupalTests.scala b/laws/src/main/scala/cats/laws/discipline/ContravariantSemigroupalTests.scala
index 47bbdc0df..539440959 100644
--- a/laws/src/main/scala/cats/laws/discipline/ContravariantSemigroupalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ContravariantSemigroupalTests.scala
@@ -11,18 +11,17 @@ trait ContravariantSemigroupalTests[F[_]] extends ContravariantTests[F] with Sem
   def laws: ContravariantSemigroupalLaws[F]
 
   def contravariantSemigroupal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    arbFA: Arbitrary[F[A]],
-    arbFB: Arbitrary[F[B]],
-    arbFC: Arbitrary[F[C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                         arbFA: Arbitrary[F[A]],
+                                                                         arbFB: Arbitrary[F[B]],
+                                                                         arbFC: Arbitrary[F[C]],
+                                                                         CogenA: Cogen[A],
+                                                                         CogenB: Cogen[B],
+                                                                         CogenC: Cogen[C],
+                                                                         EqFA: Eq[F[A]],
+                                                                         EqFB: Eq[F[B]],
+                                                                         EqFC: Eq[F[C]],
+                                                                         EqFABC: Eq[F[(A, B, C)]],
+                                                                         iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       val name = "contravariantSemigroupal"
       val parents = Seq(contravariant[A, B, C], semigroupal[A, B, C])
diff --git a/laws/src/main/scala/cats/laws/discipline/ContravariantTests.scala b/laws/src/main/scala/cats/laws/discipline/ContravariantTests.scala
index cd0d72d64..35be0addc 100644
--- a/laws/src/main/scala/cats/laws/discipline/ContravariantTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ContravariantTests.scala
@@ -10,13 +10,12 @@ trait ContravariantTests[F[_]] extends InvariantTests[F] {
   def laws: ContravariantLaws[F]
 
   def contravariant[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFC: Eq[F[C]]
-  ): RuleSet =
+                                                              ArbFA: Arbitrary[F[A]],
+                                                              CogenA: Cogen[A],
+                                                              CogenB: Cogen[B],
+                                                              CogenC: Cogen[C],
+                                                              EqFA: Eq[F[A]],
+                                                              EqFC: Eq[F[C]]): RuleSet =
     new DefaultRuleSet(
       name = "contravariant",
       parent = Some(invariant[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/DeferTests.scala b/laws/src/main/scala/cats/laws/discipline/DeferTests.scala
index be07b4719..d90bf8719 100644
--- a/laws/src/main/scala/cats/laws/discipline/DeferTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/DeferTests.scala
@@ -9,7 +9,10 @@ import org.typelevel.discipline.Laws
 trait DeferTests[F[_]] extends Laws {
   def laws: DeferLaws[F]
 
-  def defer[A: Arbitrary](implicit ArbFA: Arbitrary[F[A]], EqFA: Eq[F[A]], EqBool: Eq[Boolean]): RuleSet =
+  def defer[A: Arbitrary](implicit
+                          ArbFA: Arbitrary[F[A]],
+                          EqFA: Eq[F[A]],
+                          EqBool: Eq[Boolean]): RuleSet =
     new DefaultRuleSet(
       name = "defer",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/DistributiveTests.scala b/laws/src/main/scala/cats/laws/discipline/DistributiveTests.scala
index 66546831c..5f7da0243 100644
--- a/laws/src/main/scala/cats/laws/discipline/DistributiveTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/DistributiveTests.scala
@@ -8,7 +8,8 @@ import Prop._
 trait DistributiveTests[F[_]] extends FunctorTests[F] {
   def laws: DistributiveLaws[F]
 
-  def distributive[A: Arbitrary, B: Arbitrary, C: Arbitrary, X[_]: Functor, Y[_]: Distributive](implicit
+  def distributive[A: Arbitrary, B: Arbitrary, C: Arbitrary, X[_]: Functor, Y[_]: Distributive](
+    implicit
     ArbFA: Arbitrary[F[A]],
     ArbFB: Arbitrary[F[B]],
     ArbXA: Arbitrary[X[A]],
@@ -29,13 +30,12 @@ trait DistributiveTests[F[_]] extends FunctorTests[F] {
       def name: String = "distributive"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(functor[A, B, C])
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "distributive distribute identity" -> forAll(laws.distributeIdentity[A, B] _),
-          "distributive identity" -> forAll(laws.cosequenceIdentity[A] _),
-          "distributive composition" -> forAll(laws.composition[A, B, C, X, Y] _),
-          "distributive double cosequence identity" -> forAll(laws.cosequenceTwiceIsId[A, Y] _)
-        )
+      def props: Seq[(String, Prop)] = Seq(
+        "distributive distribute identity" -> forAll(laws.distributeIdentity[A, B] _),
+        "distributive identity" -> forAll(laws.cosequenceIdentity[A] _),
+        "distributive composition" -> forAll(laws.composition[A, B, C, X, Y] _),
+        "distributive double cosequence identity" -> forAll(laws.cosequenceTwiceIsId[A, Y] _)
+      )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/Eq.scala b/laws/src/main/scala/cats/laws/discipline/Eq.scala
index e2938add4..9e3c3dbe5 100644
--- a/laws/src/main/scala/cats/laws/discipline/Eq.scala
+++ b/laws/src/main/scala/cats/laws/discipline/Eq.scala
@@ -37,8 +37,8 @@ object eq {
   implicit def catsLawsEqForPartialOrder[A](implicit ev: Eq[(A, A) => Option[Int]]): Eq[PartialOrder[A]] =
     Eq.by[PartialOrder[A], (A, A) => Option[Int]](o => (a1, a2) => o.tryCompare(a1, a2))
 
-  implicit def catsLawsEqForPartialOrdering[A](implicit
-    ev: Eq[(A, A) => Option[Int]]
+  implicit def catsLawsEqForPartialOrdering[A](
+    implicit ev: Eq[(A, A) => Option[Int]]
   ): Eq[PartialOrdering[A]] =
     Eq.by[PartialOrdering[A], (A, A) => Option[Int]]((o: PartialOrdering[A]) => (a1, a2) => o.tryCompare(a1, a2))
 
@@ -54,10 +54,8 @@ object eq {
   implicit def catsLawsEqForSemigroup[A](implicit ev: Eq[(A, A) => A]): Eq[Semigroup[A]] =
     Eq.by[Semigroup[A], (A, A) => A](s => (a1, a2) => s.combine(a1, a2))
 
-  implicit def catsLawsEqForCommutativeSemigroup[A](implicit
-    eqA: Eq[A],
-    ev: Eq[(A, A) => (A, A)]
-  ): Eq[CommutativeSemigroup[A]] =
+  implicit def catsLawsEqForCommutativeSemigroup[A](implicit eqA: Eq[A],
+                                                    ev: Eq[(A, A) => (A, A)]): Eq[CommutativeSemigroup[A]] =
     Eq.by[CommutativeSemigroup[A], (A, A) => (A, A)](s => (x, y) => (s.combine(x, y), s.combine(y, x)))
 
   implicit def catsLawsEqForBand[A](implicit ev: Eq[(A, A) => (A, A)]): Eq[Band[A]] =
@@ -74,44 +72,33 @@ object eq {
         )
     )
 
-  implicit def catsLawsEqForMonoid[A](implicit eqSA: Eq[Semigroup[A]], eqA: Eq[A]): Eq[Monoid[A]] =
-    new Eq[Monoid[A]] {
-      def eqv(f: Monoid[A], g: Monoid[A]): Boolean =
-        eqSA.eqv(f, g) && eqA.eqv(f.empty, g.empty)
-    }
+  implicit def catsLawsEqForMonoid[A](implicit eqSA: Eq[Semigroup[A]], eqA: Eq[A]): Eq[Monoid[A]] = new Eq[Monoid[A]] {
+    def eqv(f: Monoid[A], g: Monoid[A]): Boolean =
+      eqSA.eqv(f, g) && eqA.eqv(f.empty, g.empty)
+  }
 
-  implicit def catsLawsEqForSemilattice[A](implicit
-    eqBA: Eq[Band[A]],
-    eqCA: Eq[CommutativeSemigroup[A]],
-    eqA: Eq[A]
-  ): Eq[Semilattice[A]] =
+  implicit def catsLawsEqForSemilattice[A](implicit eqBA: Eq[Band[A]],
+                                           eqCA: Eq[CommutativeSemigroup[A]],
+                                           eqA: Eq[A]): Eq[Semilattice[A]] =
     Eq.instance((f, g) => eqBA.eqv(f, g) && eqCA.eqv(f, g))
 
-  implicit def catsLawsEqForCommutativeMonoid[A](implicit
-    eqSA: Eq[CommutativeSemigroup[A]],
-    eqMA: Eq[Monoid[A]],
-    eqA: Eq[A]
-  ): Eq[CommutativeMonoid[A]] =
+  implicit def catsLawsEqForCommutativeMonoid[A](implicit eqSA: Eq[CommutativeSemigroup[A]],
+                                                 eqMA: Eq[Monoid[A]],
+                                                 eqA: Eq[A]): Eq[CommutativeMonoid[A]] =
     Eq.instance((f, g) => eqSA.eqv(f, g) && eqMA.eqv(f, g))
 
-  implicit def catsLawsEqForBoundedSemilattice[A](implicit
-    eqSA: Eq[Semilattice[A]],
-    eqCA: Eq[CommutativeMonoid[A]],
-    eqA: Eq[A]
-  ): Eq[BoundedSemilattice[A]] =
+  implicit def catsLawsEqForBoundedSemilattice[A](implicit eqSA: Eq[Semilattice[A]],
+                                                  eqCA: Eq[CommutativeMonoid[A]],
+                                                  eqA: Eq[A]): Eq[BoundedSemilattice[A]] =
     Eq.instance((f, g) => eqSA.eqv(f, g) && eqCA.eqv(f, g))
 
-  implicit def catsLawsEqForCommutativeGroup[A](implicit
-    eqMA: Eq[CommutativeMonoid[A]],
-    eqGA: Eq[Group[A]],
-    eqA: Eq[A]
-  ): Eq[CommutativeGroup[A]] =
+  implicit def catsLawsEqForCommutativeGroup[A](implicit eqMA: Eq[CommutativeMonoid[A]],
+                                                eqGA: Eq[Group[A]],
+                                                eqA: Eq[A]): Eq[CommutativeGroup[A]] =
     Eq.instance((f, g) => eqMA.eqv(f, g) && eqGA.eqv(f, g))
 
-  implicit def catsLawsEqForRepresentableStore[F[_]: Representable, S, A](implicit
-    eqFA: Eq[F[A]],
-    eqS: Eq[S]
-  ): Eq[RepresentableStore[F, S, A]] =
+  implicit def catsLawsEqForRepresentableStore[F[_]: Representable, S, A](implicit eqFA: Eq[F[A]],
+                                                                          eqS: Eq[S]): Eq[RepresentableStore[F, S, A]] =
     Eq.instance((s1, s2) => eqFA.eqv(s1.fa, s2.fa) && eqS.eqv(s1.index, s2.index))
 }
 
@@ -128,18 +115,17 @@ object eq {
     "This instance is problematic and will most likely be removed in a future version of Cats. Use catsLawsEqForFn1Exhaustive instead. See https://github.com/typelevel/cats/pull/2577 for more information.",
     "1.7"
   )
-  implicit def catsLawsEqForFn1[A, B](implicit A: Arbitrary[A], B: Eq[B]): Eq[A => B] =
-    new Eq[A => B] {
-      val sampleCnt: Int = if (Platform.isJvm) 50 else 30
-
-      def eqv(f: A => B, g: A => B): Boolean = {
-        val samples = List.fill(sampleCnt)(A.arbitrary.sample).collect {
-          case Some(a) => a
-          case None    => sys.error("Could not generate arbitrary values to compare two functions")
-        }
-        samples.forall(s => B.eqv(f(s), g(s)))
+  implicit def catsLawsEqForFn1[A, B](implicit A: Arbitrary[A], B: Eq[B]): Eq[A => B] = new Eq[A => B] {
+    val sampleCnt: Int = if (Platform.isJvm) 50 else 30
+
+    def eqv(f: A => B, g: A => B): Boolean = {
+      val samples = List.fill(sampleCnt)(A.arbitrary.sample).collect {
+        case Some(a) => a
+        case None    => sys.error("Could not generate arbitrary values to compare two functions")
       }
+      samples.forall(s => B.eqv(f(s), g(s)))
     }
+  }
 
   /**
    * Create an approximation of Eq[(A, B) => C] by generating random values for A and B
@@ -181,16 +167,12 @@ object eq {
   implicit def catsLawsEqForEquiv[A](implicit arbA: Arbitrary[(A, A)]): Eq[Equiv[A]] =
     sampledEq[Equiv[A], (A, A), Boolean](100) { case (e, (l, r)) => e.equiv(l, r) }
 
-  implicit def catsLawsEqForPartialOrder[A](implicit
-    arbA: Arbitrary[(A, A)],
-    optIntEq: Eq[Option[Int]]
-  ): Eq[PartialOrder[A]] =
+  implicit def catsLawsEqForPartialOrder[A](implicit arbA: Arbitrary[(A, A)],
+                                            optIntEq: Eq[Option[Int]]): Eq[PartialOrder[A]] =
     sampledEq[PartialOrder[A], (A, A), Option[Int]](100) { case (p, (l, r)) => p.tryCompare(l, r) }
 
-  implicit def catsLawsEqForPartialOrdering[A](implicit
-    arbA: Arbitrary[(A, A)],
-    optIntEq: Eq[Option[Int]]
-  ): Eq[PartialOrdering[A]] =
+  implicit def catsLawsEqForPartialOrdering[A](implicit arbA: Arbitrary[(A, A)],
+                                               optIntEq: Eq[Option[Int]]): Eq[PartialOrdering[A]] =
     sampledEq[PartialOrdering[A], (A, A), Option[Int]](100) { case (p, (l, r)) => p.tryCompare(l, r) }
 
   implicit def catsLawsEqForOrder[A](implicit arbA: Arbitrary[(A, A)]): Eq[Order[A]] =
@@ -203,18 +185,17 @@ object eq {
    * Creates an approximation of Eq[Hash[A]] by generating 100 values for A
    * and comparing the application of the two hash functions.
    */
-  implicit def catsLawsEqForHash[A](implicit arbA: Arbitrary[A]): Eq[Hash[A]] =
-    new Eq[Hash[A]] {
-      def eqv(f: Hash[A], g: Hash[A]): Boolean = {
-        val samples = List.fill(100)(arbA.arbitrary.sample).collect {
-          case Some(a) => a
-          case None    => sys.error("Could not generate arbitrary values to compare two Hash[A]")
-        }
-        samples.forall { x =>
-          f.hash(x) == g.hash(x)
-        }
+  implicit def catsLawsEqForHash[A](implicit arbA: Arbitrary[A]): Eq[Hash[A]] = new Eq[Hash[A]] {
+    def eqv(f: Hash[A], g: Hash[A]): Boolean = {
+      val samples = List.fill(100)(arbA.arbitrary.sample).collect {
+        case Some(a) => a
+        case None    => sys.error("Could not generate arbitrary values to compare two Hash[A]")
+      }
+      samples.forall { x =>
+        f.hash(x) == g.hash(x)
       }
     }
+  }
 
   /**
    * Create an approximation of Eq[Semigroup[A]] by generating values for A
@@ -225,10 +206,8 @@ object eq {
     Eq.by[Semigroup[A], ((A, A)) => A](f => Function.tupled((x, y) => f.combine(x, y)))(instance)
   }
 
-  implicit def catsLawsEqForCommutativeSemigroup[A](implicit
-    arbAA: Arbitrary[(A, A)],
-    eqA: Eq[A]
-  ): Eq[CommutativeSemigroup[A]] = {
+  implicit def catsLawsEqForCommutativeSemigroup[A](implicit arbAA: Arbitrary[(A, A)],
+                                                    eqA: Eq[A]): Eq[CommutativeSemigroup[A]] = {
     implicit val eqABool: Eq[(A, Boolean)] = Eq.instance {
       case ((x, boolX), (y, boolY)) => x === y && boolX === boolY
     }
@@ -238,20 +217,16 @@ object eq {
     )(catsLawsEqForFn1[(A, A), (A, Boolean)])
   }
 
-  implicit def catsLawsEqForBand[A](implicit
-    arbAA: Arbitrary[(A, A)],
-    eqSA: Eq[Semigroup[A]],
-    eqA: Eq[A]
-  ): Eq[Band[A]] =
+  implicit def catsLawsEqForBand[A](implicit arbAA: Arbitrary[(A, A)],
+                                    eqSA: Eq[Semigroup[A]],
+                                    eqA: Eq[A]): Eq[Band[A]] =
     Eq.by[Band[A], ((A, A)) => Boolean](f =>
       Function.tupled((x, y) => f.combine(x, y) === f.combine(f.combine(x, y), y))
     )(catsLawsEqForFn1[(A, A), Boolean])
 
-  implicit def catsLawsEqForGroup[A](implicit
-    arbAA: Arbitrary[(A, A)],
-    eqMA: Eq[Monoid[A]],
-    eqA: Eq[A]
-  ): Eq[Group[A]] = {
+  implicit def catsLawsEqForGroup[A](implicit arbAA: Arbitrary[(A, A)],
+                                     eqMA: Eq[Monoid[A]],
+                                     eqA: Eq[A]): Eq[Group[A]] = {
     implicit val eqABool: Eq[(A, Boolean)] = Eq.instance {
       case ((x, boolX), (y, boolY)) => x === y && boolX === boolY
     }
diff --git a/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala b/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
index f821f0cdb..3c3d398d3 100644
--- a/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
@@ -14,10 +14,9 @@ trait ExhaustiveCheck[A] extends Serializable { self =>
 object ExhaustiveCheck {
   def apply[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[A] = A
 
-  def instance[A](values: List[A]): ExhaustiveCheck[A] =
-    new ExhaustiveCheck[A] {
-      val allValues: List[A] = values
-    }
+  def instance[A](values: List[A]): ExhaustiveCheck[A] = new ExhaustiveCheck[A] {
+    val allValues: List[A] = values
+  }
 
   implicit val catsLawsExhaustiveCheckForBoolean: ExhaustiveCheck[Boolean] =
     instance(List(false, true))
@@ -28,20 +27,16 @@ object ExhaustiveCheck {
   /**
    * Warning: the domain of (A, B) is the cross-product of the domain of `A` and the domain of `B`.
    */
-  implicit def catsLawsExhaustiveCheckForTuple2[A, B](implicit
-    A: ExhaustiveCheck[A],
-    B: ExhaustiveCheck[B]
-  ): ExhaustiveCheck[(A, B)] =
+  implicit def catsLawsExhaustiveCheckForTuple2[A, B](implicit A: ExhaustiveCheck[A],
+                                                      B: ExhaustiveCheck[B]): ExhaustiveCheck[(A, B)] =
     instance(A.allValues.flatMap(a => B.allValues.map(b => (a, b))))
 
   /**
    * Warning: the domain of (A, B, C) is the cross-product of the 3 domains.
    */
-  implicit def catsLawsExhaustiveCheckForTuple3[A, B, C](implicit
-    A: ExhaustiveCheck[A],
-    B: ExhaustiveCheck[B],
-    C: ExhaustiveCheck[C]
-  ): ExhaustiveCheck[(A, B, C)] =
+  implicit def catsLawsExhaustiveCheckForTuple3[A, B, C](implicit A: ExhaustiveCheck[A],
+                                                         B: ExhaustiveCheck[B],
+                                                         C: ExhaustiveCheck[C]): ExhaustiveCheck[(A, B, C)] =
     instance(
       for {
         a <- A.allValues
@@ -50,10 +45,8 @@ object ExhaustiveCheck {
       } yield (a, b, c)
     )
 
-  implicit def catsLawsExhaustiveCheckForEither[A, B](implicit
-    A: ExhaustiveCheck[A],
-    B: ExhaustiveCheck[B]
-  ): ExhaustiveCheck[Either[A, B]] =
+  implicit def catsLawsExhaustiveCheckForEither[A, B](implicit A: ExhaustiveCheck[A],
+                                                      B: ExhaustiveCheck[B]): ExhaustiveCheck[Either[A, B]] =
     instance(A.allValues.map(Left(_)) ++ B.allValues.map(Right(_)))
 
   implicit def catsLawsExhaustiveCheckForOption[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[Option[A]] =
diff --git a/laws/src/main/scala/cats/laws/discipline/FlatMapTests.scala b/laws/src/main/scala/cats/laws/discipline/FlatMapTests.scala
index 4a91d99fc..57a9f1760 100644
--- a/laws/src/main/scala/cats/laws/discipline/FlatMapTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/FlatMapTests.scala
@@ -12,20 +12,19 @@ trait FlatMapTests[F[_]] extends ApplyTests[F] {
   def laws: FlatMapLaws[F]
 
   def flatMap[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    iso: Isomorphisms[F]
-  ): RuleSet = {
+                                                        ArbFA: Arbitrary[F[A]],
+                                                        ArbFB: Arbitrary[F[B]],
+                                                        ArbFC: Arbitrary[F[C]],
+                                                        ArbFAtoB: Arbitrary[F[A => B]],
+                                                        ArbFBtoC: Arbitrary[F[B => C]],
+                                                        CogenA: Cogen[A],
+                                                        CogenB: Cogen[B],
+                                                        CogenC: Cogen[C],
+                                                        EqFA: Eq[F[A]],
+                                                        EqFB: Eq[F[B]],
+                                                        EqFC: Eq[F[C]],
+                                                        EqFABC: Eq[F[(A, B, C)]],
+                                                        iso: Isomorphisms[F]): RuleSet = {
     implicit def functorF: Functor[F] = laws.F
     implicit val EqFAB: Eq[F[(A, B)]] =
       ContravariantSemigroupal[Eq].composeFunctor[F].product(EqFA, EqFB)
diff --git a/laws/src/main/scala/cats/laws/discipline/FoldableTests.scala b/laws/src/main/scala/cats/laws/discipline/FoldableTests.scala
index b2b97df2e..2689fad9d 100644
--- a/laws/src/main/scala/cats/laws/discipline/FoldableTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/FoldableTests.scala
@@ -12,17 +12,16 @@ trait FoldableTests[F[_]] extends UnorderedFoldableTests[F] {
   def laws: FoldableLaws[F]
 
   def foldable[A: Arbitrary, B: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    A: CommutativeMonoid[A],
-    B: CommutativeMonoid[B],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    EqA: Eq[A],
-    EqFA: Eq[F[A]],
-    EqB: Eq[B],
-    EqOptionB: Eq[Option[B]],
-    EqOptionA: Eq[Option[A]]
-  ): RuleSet =
+                                           ArbFA: Arbitrary[F[A]],
+                                           A: CommutativeMonoid[A],
+                                           B: CommutativeMonoid[B],
+                                           CogenA: Cogen[A],
+                                           CogenB: Cogen[B],
+                                           EqA: Eq[A],
+                                           EqFA: Eq[F[A]],
+                                           EqB: Eq[B],
+                                           EqOptionB: Eq[Option[B]],
+                                           EqOptionA: Eq[Option[A]]): RuleSet =
     new DefaultRuleSet(
       name = "foldable",
       parent = Some(unorderedFoldable[A, B]),
diff --git a/laws/src/main/scala/cats/laws/discipline/FunctorFilterTests.scala b/laws/src/main/scala/cats/laws/discipline/FunctorFilterTests.scala
index be33e0be8..f5c154d19 100644
--- a/laws/src/main/scala/cats/laws/discipline/FunctorFilterTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/FunctorFilterTests.scala
@@ -10,17 +10,16 @@ trait FunctorFilterTests[F[_]] extends Laws {
   def laws: FunctorFilterLaws[F]
 
   def functorFilter[A, B, C](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFABoo: Arbitrary[PartialFunction[A, B]],
-    ArbFOA: Arbitrary[F[Option[A]]],
-    ArbAOB: Arbitrary[A => Option[B]],
-    ArbBOC: Arbitrary[B => Option[C]],
-    ArbAB: Arbitrary[A => B],
-    ArbABoo: Arbitrary[A => Boolean],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]]
-  ): RuleSet =
+                             ArbFA: Arbitrary[F[A]],
+                             ArbFABoo: Arbitrary[PartialFunction[A, B]],
+                             ArbFOA: Arbitrary[F[Option[A]]],
+                             ArbAOB: Arbitrary[A => Option[B]],
+                             ArbBOC: Arbitrary[B => Option[C]],
+                             ArbAB: Arbitrary[A => B],
+                             ArbABoo: Arbitrary[A => Boolean],
+                             EqFA: Eq[F[A]],
+                             EqFB: Eq[F[B]],
+                             EqFC: Eq[F[C]]): RuleSet =
     new DefaultRuleSet(
       name = "functorFilter",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/FunctorTests.scala b/laws/src/main/scala/cats/laws/discipline/FunctorTests.scala
index c751475ea..7cf0d085a 100644
--- a/laws/src/main/scala/cats/laws/discipline/FunctorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/FunctorTests.scala
@@ -9,13 +9,12 @@ trait FunctorTests[F[_]] extends InvariantTests[F] {
   def laws: FunctorLaws[F]
 
   def functor[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFC: Eq[F[C]]
-  ): RuleSet =
+                                                        ArbFA: Arbitrary[F[A]],
+                                                        CogenA: Cogen[A],
+                                                        CogenB: Cogen[B],
+                                                        CogenC: Cogen[C],
+                                                        EqFA: Eq[F[A]],
+                                                        EqFC: Eq[F[C]]): RuleSet =
     new DefaultRuleSet(
       name = "functor",
       parent = Some(invariant[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/InjectKTests.scala b/laws/src/main/scala/cats/laws/discipline/InjectKTests.scala
index a6eed7fe6..a2f0b5004 100644
--- a/laws/src/main/scala/cats/laws/discipline/InjectKTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InjectKTests.scala
@@ -11,11 +11,10 @@ trait InjectKTests[F[_], G[_]] extends Laws {
   def laws: InjectKLaws[F, G]
 
   def injectK[A](implicit
-    ArbFA: Arbitrary[F[A]],
-    EqOptionFA: Eq[Option[F[A]]],
-    ArbGA: Arbitrary[G[A]],
-    EqOptionGA: Eq[Option[G[A]]]
-  ): RuleSet =
+                 ArbFA: Arbitrary[F[A]],
+                 EqOptionFA: Eq[Option[F[A]]],
+                 ArbGA: Arbitrary[G[A]],
+                 EqOptionGA: Eq[Option[G[A]]]): RuleSet =
     new DefaultRuleSet(
       "injectK",
       None,
diff --git a/laws/src/main/scala/cats/laws/discipline/InjectTests.scala b/laws/src/main/scala/cats/laws/discipline/InjectTests.scala
index 8619d84cb..3f3f00160 100644
--- a/laws/src/main/scala/cats/laws/discipline/InjectTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InjectTests.scala
@@ -11,11 +11,10 @@ trait InjectTests[A, B] extends Laws {
   def laws: InjectLaws[A, B]
 
   def inject(implicit
-    ArbA: Arbitrary[A],
-    EqOptionA: Eq[Option[A]],
-    ArbB: Arbitrary[B],
-    EqOptionB: Eq[Option[B]]
-  ): RuleSet =
+             ArbA: Arbitrary[A],
+             EqOptionA: Eq[Option[A]],
+             ArbB: Arbitrary[B],
+             EqOptionB: Eq[Option[B]]): RuleSet =
     new DefaultRuleSet(
       "inject",
       None,
diff --git a/laws/src/main/scala/cats/laws/discipline/InvariantMonoidalTests.scala b/laws/src/main/scala/cats/laws/discipline/InvariantMonoidalTests.scala
index fda5324ee..5c1b7bad5 100644
--- a/laws/src/main/scala/cats/laws/discipline/InvariantMonoidalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InvariantMonoidalTests.scala
@@ -10,19 +10,18 @@ trait InvariantMonoidalTests[F[_]] extends InvariantSemigroupalTests[F] {
   def laws: InvariantMonoidalLaws[F]
 
   def invariantMonoidal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFABC: Eq[F[(A, (B, C))]],
-    EqFABC2: Eq[F[(A, B, C)]],
-    iso: Isomorphisms[F],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]]
-  ): RuleSet =
+                                                                  ArbFA: Arbitrary[F[A]],
+                                                                  ArbFB: Arbitrary[F[B]],
+                                                                  ArbFC: Arbitrary[F[C]],
+                                                                  CogenA: Cogen[A],
+                                                                  CogenB: Cogen[B],
+                                                                  CogenC: Cogen[C],
+                                                                  EqFABC: Eq[F[(A, (B, C))]],
+                                                                  EqFABC2: Eq[F[(A, B, C)]],
+                                                                  iso: Isomorphisms[F],
+                                                                  EqFA: Eq[F[A]],
+                                                                  EqFB: Eq[F[B]],
+                                                                  EqFC: Eq[F[C]]): RuleSet =
     new RuleSet {
       val name = "invariantMonoidal"
       val parents = Seq(invariantSemigroupal[A, B, C])
diff --git a/laws/src/main/scala/cats/laws/discipline/InvariantSemigroupalTests.scala b/laws/src/main/scala/cats/laws/discipline/InvariantSemigroupalTests.scala
index 4717d27bd..3305b07c8 100644
--- a/laws/src/main/scala/cats/laws/discipline/InvariantSemigroupalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InvariantSemigroupalTests.scala
@@ -10,29 +10,27 @@ trait InvariantSemigroupalTests[F[_]] extends InvariantTests[F] with Semigroupal
   def laws: InvariantSemigroupalLaws[F]
 
   def invariantSemigroupal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    arbFA: Arbitrary[F[A]],
-    arbFB: Arbitrary[F[B]],
-    arbFC: Arbitrary[F[C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, (B, C))]],
-    EqFABC2: Eq[F[(A, B, C)]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
-    new RuleSet {
-      val name = "invariantSemigroupal"
-      val parents = Seq(invariant[A, B, C], semigroupal[A, B, C])
-      val bases = Nil
-      val props = Seq(
-        "invariant semigroupal associativity" -> forAll((fa: F[A], fb: F[B], fc: F[C]) =>
-          laws.invariantSemigroupalAssociativity(fa, fb, fc)
-        )
+                                                                     arbFA: Arbitrary[F[A]],
+                                                                     arbFB: Arbitrary[F[B]],
+                                                                     arbFC: Arbitrary[F[C]],
+                                                                     CogenA: Cogen[A],
+                                                                     CogenB: Cogen[B],
+                                                                     CogenC: Cogen[C],
+                                                                     EqFA: Eq[F[A]],
+                                                                     EqFB: Eq[F[B]],
+                                                                     EqFC: Eq[F[C]],
+                                                                     EqFABC: Eq[F[(A, (B, C))]],
+                                                                     EqFABC2: Eq[F[(A, B, C)]],
+                                                                     iso: Isomorphisms[F]): RuleSet = new RuleSet {
+    val name = "invariantSemigroupal"
+    val parents = Seq(invariant[A, B, C], semigroupal[A, B, C])
+    val bases = Nil
+    val props = Seq(
+      "invariant semigroupal associativity" -> forAll((fa: F[A], fb: F[B], fc: F[C]) =>
+        laws.invariantSemigroupalAssociativity(fa, fb, fc)
       )
-    }
+    )
+  }
 }
 
 object InvariantSemigroupalTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/InvariantTests.scala b/laws/src/main/scala/cats/laws/discipline/InvariantTests.scala
index 14dbc2441..4594eed29 100644
--- a/laws/src/main/scala/cats/laws/discipline/InvariantTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InvariantTests.scala
@@ -11,13 +11,12 @@ trait InvariantTests[F[_]] extends Laws {
   def laws: InvariantLaws[F]
 
   def invariant[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFC: Eq[F[C]]
-  ): RuleSet =
+                                                          ArbFA: Arbitrary[F[A]],
+                                                          CogenA: Cogen[A],
+                                                          CogenB: Cogen[B],
+                                                          CogenC: Cogen[C],
+                                                          EqFA: Eq[F[A]],
+                                                          EqFC: Eq[F[C]]): RuleSet =
     new DefaultRuleSet(
       name = "invariant",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/MonadErrorTests.scala b/laws/src/main/scala/cats/laws/discipline/MonadErrorTests.scala
index 8673fb7b1..009a78afb 100644
--- a/laws/src/main/scala/cats/laws/discipline/MonadErrorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/MonadErrorTests.scala
@@ -11,42 +11,40 @@ trait MonadErrorTests[F[_], E] extends ApplicativeErrorTests[F, E] with MonadTes
   def laws: MonadErrorLaws[F, E]
 
   def monadError[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFU: Arbitrary[F[Unit]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    ArbE: Arbitrary[E],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    CogenE: Cogen[E],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqE: Eq[E],
-    EqFEitherEU: Eq[F[Either[E, Unit]]],
-    EqFEitherEA: Eq[F[Either[E, A]]],
-    EqEitherTFEA: Eq[EitherT[F, E, A]],
-    EqFABC: Eq[F[(A, B, C)]],
-    EqFInt: Eq[F[Int]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                       ArbFA: Arbitrary[F[A]],
+                                                                       ArbFB: Arbitrary[F[B]],
+                                                                       ArbFC: Arbitrary[F[C]],
+                                                                       ArbFU: Arbitrary[F[Unit]],
+                                                                       ArbFAtoB: Arbitrary[F[A => B]],
+                                                                       ArbFBtoC: Arbitrary[F[B => C]],
+                                                                       ArbE: Arbitrary[E],
+                                                                       CogenA: Cogen[A],
+                                                                       CogenB: Cogen[B],
+                                                                       CogenC: Cogen[C],
+                                                                       CogenE: Cogen[E],
+                                                                       EqFA: Eq[F[A]],
+                                                                       EqFB: Eq[F[B]],
+                                                                       EqFC: Eq[F[C]],
+                                                                       EqE: Eq[E],
+                                                                       EqFEitherEU: Eq[F[Either[E, Unit]]],
+                                                                       EqFEitherEA: Eq[F[Either[E, A]]],
+                                                                       EqEitherTFEA: Eq[EitherT[F, E, A]],
+                                                                       EqFABC: Eq[F[(A, B, C)]],
+                                                                       EqFInt: Eq[F[Int]],
+                                                                       iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       def name: String = "monadError"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(applicativeError[A, B, C], monad[A, B, C])
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "monadError left zero" -> forAll(laws.monadErrorLeftZero[A, B] _),
-          "monadError ensure consistency" -> forAll(laws.monadErrorEnsureConsistency[A] _),
-          "monadError ensureOr consistency" -> forAll(laws.monadErrorEnsureOrConsistency[A] _),
-          "monadError rethrow attempt" -> forAll(laws.rethrowAttempt[A] _),
-          "monadError redeemWith is derived from attempt and flatMap" -> forAll(
-            laws.redeemWithDerivedFromAttemptFlatMap[A, B] _
-          )
+      def props: Seq[(String, Prop)] = Seq(
+        "monadError left zero" -> forAll(laws.monadErrorLeftZero[A, B] _),
+        "monadError ensure consistency" -> forAll(laws.monadErrorEnsureConsistency[A] _),
+        "monadError ensureOr consistency" -> forAll(laws.monadErrorEnsureOrConsistency[A] _),
+        "monadError rethrow attempt" -> forAll(laws.rethrowAttempt[A] _),
+        "monadError redeemWith is derived from attempt and flatMap" -> forAll(
+          laws.redeemWithDerivedFromAttemptFlatMap[A, B] _
         )
+      )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/MonadTests.scala b/laws/src/main/scala/cats/laws/discipline/MonadTests.scala
index 82459d34d..aeee404f3 100644
--- a/laws/src/main/scala/cats/laws/discipline/MonadTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/MonadTests.scala
@@ -11,21 +11,20 @@ trait MonadTests[F[_]] extends ApplicativeTests[F] with FlatMapTests[F] {
   def laws: MonadLaws[F]
 
   def monad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    EqFInt: Eq[F[Int]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                  ArbFA: Arbitrary[F[A]],
+                                                                  ArbFB: Arbitrary[F[B]],
+                                                                  ArbFC: Arbitrary[F[C]],
+                                                                  ArbFAtoB: Arbitrary[F[A => B]],
+                                                                  ArbFBtoC: Arbitrary[F[B => C]],
+                                                                  CogenA: Cogen[A],
+                                                                  CogenB: Cogen[B],
+                                                                  CogenC: Cogen[C],
+                                                                  EqFA: Eq[F[A]],
+                                                                  EqFB: Eq[F[B]],
+                                                                  EqFC: Eq[F[C]],
+                                                                  EqFABC: Eq[F[(A, B, C)]],
+                                                                  EqFInt: Eq[F[Int]],
+                                                                  iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       def name: String = "monad"
       def bases: Seq[(String, RuleSet)] = Nil
@@ -40,31 +39,29 @@ trait MonadTests[F[_]] extends ApplicativeTests[F] with FlatMapTests[F] {
     }
 
   def stackUnsafeMonad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    ArbFAtoB: Arbitrary[F[A => B]],
-    ArbFBtoC: Arbitrary[F[B => C]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    CogenC: Cogen[C],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqFABC: Eq[F[(A, B, C)]],
-    EqFInt: Eq[F[Int]],
-    iso: Isomorphisms[F]
-  ): RuleSet =
+                                                                             ArbFA: Arbitrary[F[A]],
+                                                                             ArbFB: Arbitrary[F[B]],
+                                                                             ArbFC: Arbitrary[F[C]],
+                                                                             ArbFAtoB: Arbitrary[F[A => B]],
+                                                                             ArbFBtoC: Arbitrary[F[B => C]],
+                                                                             CogenA: Cogen[A],
+                                                                             CogenB: Cogen[B],
+                                                                             CogenC: Cogen[C],
+                                                                             EqFA: Eq[F[A]],
+                                                                             EqFB: Eq[F[B]],
+                                                                             EqFC: Eq[F[C]],
+                                                                             EqFABC: Eq[F[(A, B, C)]],
+                                                                             EqFInt: Eq[F[Int]],
+                                                                             iso: Isomorphisms[F]): RuleSet =
     new RuleSet {
       def name: String = "monad (stack-unsafe)"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(applicative[A, B, C], flatMap[A, B, C])
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "monad left identity" -> forAll(laws.monadLeftIdentity[A, B] _),
-          "monad right identity" -> forAll(laws.monadRightIdentity[A] _),
-          "map flatMap coherence" -> forAll(laws.mapFlatMapCoherence[A, B] _)
-        )
+      def props: Seq[(String, Prop)] = Seq(
+        "monad left identity" -> forAll(laws.monadLeftIdentity[A, B] _),
+        "monad right identity" -> forAll(laws.monadRightIdentity[A] _),
+        "map flatMap coherence" -> forAll(laws.mapFlatMapCoherence[A, B] _)
+      )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/MonoidKTests.scala b/laws/src/main/scala/cats/laws/discipline/MonoidKTests.scala
index f1465a3e1..5cabd7f04 100644
--- a/laws/src/main/scala/cats/laws/discipline/MonoidKTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/MonoidKTests.scala
@@ -8,7 +8,9 @@ import org.scalacheck.Arbitrary
 trait MonoidKTests[F[_]] extends SemigroupKTests[F] {
   def laws: MonoidKLaws[F]
 
-  def monoidK[A: Arbitrary](implicit ArbFA: Arbitrary[F[A]], EqFA: Eq[F[A]]): RuleSet =
+  def monoidK[A: Arbitrary](implicit
+                            ArbFA: Arbitrary[F[A]],
+                            EqFA: Eq[F[A]]): RuleSet =
     new DefaultRuleSet(
       "monoidK",
       Some(semigroupK[A]),
diff --git a/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala b/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
index 05fd98b31..b503b3329 100644
--- a/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
@@ -10,16 +10,14 @@ trait NonEmptyParallelTests[M[_]] extends Laws {
   val laws: NonEmptyParallelLaws[M]
   type F[A] = laws.F[A]
 
-  def nonEmptyParallel[A, B](implicit
-    ArbA: Arbitrary[A],
-    ArbM: Arbitrary[M[A]],
-    ArbMb: Arbitrary[M[B]],
-    Arbf: Arbitrary[A => B],
-    EqMa: Eq[M[A]],
-    EqMb: Eq[M[B]],
-    ArbF: Arbitrary[F[A]],
-    EqFa: Eq[F[A]]
-  ): RuleSet =
+  def nonEmptyParallel[A, B](implicit ArbA: Arbitrary[A],
+                             ArbM: Arbitrary[M[A]],
+                             ArbMb: Arbitrary[M[B]],
+                             Arbf: Arbitrary[A => B],
+                             EqMa: Eq[M[A]],
+                             EqMb: Eq[M[B]],
+                             ArbF: Arbitrary[F[A]],
+                             EqFa: Eq[F[A]]): RuleSet =
     new DefaultRuleSet(
       "parallel",
       None,
diff --git a/laws/src/main/scala/cats/laws/discipline/NonEmptyTraverseTests.scala b/laws/src/main/scala/cats/laws/discipline/NonEmptyTraverseTests.scala
index 011c3ae97..7603236a8 100644
--- a/laws/src/main/scala/cats/laws/discipline/NonEmptyTraverseTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/NonEmptyTraverseTests.scala
@@ -9,7 +9,8 @@ import cats.laws.NonEmptyTraverseLaws
 trait NonEmptyTraverseTests[F[_]] extends TraverseTests[F] with ReducibleTests[F] {
   def laws: NonEmptyTraverseLaws[F]
 
-  def nonEmptyTraverse[G[_]: Applicative, A: Arbitrary, B: Arbitrary, C: Arbitrary, M: Arbitrary, X[_], Y[_]](implicit
+  def nonEmptyTraverse[G[_]: Applicative, A: Arbitrary, B: Arbitrary, C: Arbitrary, M: Arbitrary, X[_], Y[_]](
+    implicit
     ArbFA: Arbitrary[F[A]],
     ArbXB: Arbitrary[X[B]],
     ArbYB: Arbitrary[Y[B]],
@@ -44,24 +45,22 @@ trait NonEmptyTraverseTests[F[_]] extends TraverseTests[F] with ReducibleTests[F
     EqYFM: Eq[Y[F[M]]],
     EqOptionA: Eq[Option[A]]
   ): RuleSet = {
-    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] =
-      new Eq[(X[F[B]], Y[F[B]])] {
-        override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
-          EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
-      }
+    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] = new Eq[(X[F[B]], Y[F[B]])] {
+      override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
+        EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
+    }
     new RuleSet {
       def name: String = "nonEmptyTraverse"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(traverse[A, B, C, M, X, Y], reducible[G, A, B])
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "nonEmptyTraverse identity" -> forAll(laws.nonEmptyTraverseIdentity[A, C] _),
-          "nonEmptyTraverse sequential composition" -> forAll(
-            laws.nonEmptyTraverseSequentialComposition[A, B, C, X, Y] _
-          ),
-          "nonEmptyTraverse parallel composition" -> forAll(laws.nonEmptyTraverseParallelComposition[A, B, X, Y] _),
-          "nonEmptyTraverse derive reduceMap" -> forAll(laws.reduceMapDerived[A, M] _)
-        )
+      def props: Seq[(String, Prop)] = Seq(
+        "nonEmptyTraverse identity" -> forAll(laws.nonEmptyTraverseIdentity[A, C] _),
+        "nonEmptyTraverse sequential composition" -> forAll(
+          laws.nonEmptyTraverseSequentialComposition[A, B, C, X, Y] _
+        ),
+        "nonEmptyTraverse parallel composition" -> forAll(laws.nonEmptyTraverseParallelComposition[A, B, X, Y] _),
+        "nonEmptyTraverse derive reduceMap" -> forAll(laws.reduceMapDerived[A, M] _)
+      )
     }
   }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala b/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
index d8827ce81..5f4e28fa8 100644
--- a/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
@@ -8,16 +8,14 @@ import org.scalacheck.Prop.forAll
 trait ParallelTests[M[_]] extends NonEmptyParallelTests[M] {
   val laws: ParallelLaws[M]
 
-  def parallel[A, B](implicit
-    ArbA: Arbitrary[A],
-    ArbM: Arbitrary[M[A]],
-    ArbMb: Arbitrary[M[B]],
-    Arbf: Arbitrary[A => B],
-    EqMa: Eq[M[A]],
-    EqMb: Eq[M[B]],
-    ArbF: Arbitrary[F[A]],
-    EqFa: Eq[F[A]]
-  ): RuleSet =
+  def parallel[A, B](implicit ArbA: Arbitrary[A],
+                     ArbM: Arbitrary[M[A]],
+                     ArbMb: Arbitrary[M[B]],
+                     Arbf: Arbitrary[A => B],
+                     EqMa: Eq[M[A]],
+                     EqMb: Eq[M[B]],
+                     ArbF: Arbitrary[F[A]],
+                     EqFa: Eq[F[A]]): RuleSet =
     new DefaultRuleSet(
       "parallel",
       Some(nonEmptyParallel[A, B]),
diff --git a/laws/src/main/scala/cats/laws/discipline/ProfunctorTests.scala b/laws/src/main/scala/cats/laws/discipline/ProfunctorTests.scala
index 3e4110909..30d08656b 100644
--- a/laws/src/main/scala/cats/laws/discipline/ProfunctorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ProfunctorTests.scala
@@ -10,7 +10,8 @@ import org.typelevel.discipline.Laws
 trait ProfunctorTests[F[_, _]] extends Laws {
   def laws: ProfunctorLaws[F]
 
-  def profunctor[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
+  def profunctor[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
+    implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFCD: Arbitrary[F[C, D]],
     CogenA: Cogen[A],
diff --git a/laws/src/main/scala/cats/laws/discipline/ReducibleTests.scala b/laws/src/main/scala/cats/laws/discipline/ReducibleTests.scala
index 3ad769624..0b260bef2 100644
--- a/laws/src/main/scala/cats/laws/discipline/ReducibleTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ReducibleTests.scala
@@ -12,20 +12,19 @@ trait ReducibleTests[F[_]] extends FoldableTests[F] {
   def laws: ReducibleLaws[F]
 
   def reducible[G[_]: Applicative, A: Arbitrary, B: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFGA: Arbitrary[F[G[A]]],
-    ArbGB: Arbitrary[G[B]],
-    CogenA: Cogen[A],
-    CogenB: Cogen[B],
-    EqG: Eq[G[Unit]],
-    EqA: Eq[A],
-    EqB: Eq[B],
-    EqFA: Eq[F[A]],
-    EqOptionA: Eq[Option[A]],
-    MonoidA: CommutativeMonoid[A],
-    MonoidB: CommutativeMonoid[B]
-  ): RuleSet =
+                                                               ArbFA: Arbitrary[F[A]],
+                                                               ArbFB: Arbitrary[F[B]],
+                                                               ArbFGA: Arbitrary[F[G[A]]],
+                                                               ArbGB: Arbitrary[G[B]],
+                                                               CogenA: Cogen[A],
+                                                               CogenB: Cogen[B],
+                                                               EqG: Eq[G[Unit]],
+                                                               EqA: Eq[A],
+                                                               EqB: Eq[B],
+                                                               EqFA: Eq[F[A]],
+                                                               EqOptionA: Eq[Option[A]],
+                                                               MonoidA: CommutativeMonoid[A],
+                                                               MonoidB: CommutativeMonoid[B]): RuleSet =
     new DefaultRuleSet(
       name = "reducible",
       parent = Some(foldable[A, B]),
diff --git a/laws/src/main/scala/cats/laws/discipline/RepresentableTests.scala b/laws/src/main/scala/cats/laws/discipline/RepresentableTests.scala
index 22e290682..2630f379f 100644
--- a/laws/src/main/scala/cats/laws/discipline/RepresentableTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/RepresentableTests.scala
@@ -11,24 +11,21 @@ trait RepresentableTests[F[_], R] extends Laws {
   val laws: RepresentableLaws[F, R]
 
   def representable[A](implicit
-    ArbA: Arbitrary[A],
-    ArbFA: Arbitrary[F[A]],
-    ArbRep: Arbitrary[R],
-    ArbRepFn: Arbitrary[R => A],
-    EqFA: Eq[F[A]],
-    EqA: Eq[A]
-  ): RuleSet =
-    new DefaultRuleSet(
-      name = "representable",
-      parent = None,
-      "index andThen tabulate = id" -> forAll(laws.indexTabulateIsId[A] _),
-      "tabulate andThen index = id" -> forAll(laws.tabulateIndexIsId[A] _)
-    )
+                       ArbA: Arbitrary[A],
+                       ArbFA: Arbitrary[F[A]],
+                       ArbRep: Arbitrary[R],
+                       ArbRepFn: Arbitrary[R => A],
+                       EqFA: Eq[F[A]],
+                       EqA: Eq[A]): RuleSet = new DefaultRuleSet(
+    name = "representable",
+    parent = None,
+    "index andThen tabulate = id" -> forAll(laws.indexTabulateIsId[A] _),
+    "tabulate andThen index = id" -> forAll(laws.tabulateIndexIsId[A] _)
+  )
 }
 
 object RepresentableTests {
-  def apply[F[_], R](implicit RF: Representable.Aux[F, R]): RepresentableTests[F, R] =
-    new RepresentableTests[F, R] {
-      implicit override val laws: RepresentableLaws[F, R] = RepresentableLaws[F, R]
-    }
+  def apply[F[_], R](implicit RF: Representable.Aux[F, R]): RepresentableTests[F, R] = new RepresentableTests[F, R] {
+    implicit override val laws: RepresentableLaws[F, R] = RepresentableLaws[F, R]
+  }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/SemigroupKTests.scala b/laws/src/main/scala/cats/laws/discipline/SemigroupKTests.scala
index 11964342c..54c9e569f 100644
--- a/laws/src/main/scala/cats/laws/discipline/SemigroupKTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/SemigroupKTests.scala
@@ -9,7 +9,9 @@ import org.typelevel.discipline.Laws
 trait SemigroupKTests[F[_]] extends Laws {
   def laws: SemigroupKLaws[F]
 
-  def semigroupK[A: Arbitrary](implicit ArbFA: Arbitrary[F[A]], EqFA: Eq[F[A]]): RuleSet =
+  def semigroupK[A: Arbitrary](implicit
+                               ArbFA: Arbitrary[F[A]],
+                               EqFA: Eq[F[A]]): RuleSet =
     new DefaultRuleSet("semigroupK", None, "semigroupK associative" -> forAll(laws.semigroupKAssociative[A] _))
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/SemigroupalTests.scala b/laws/src/main/scala/cats/laws/discipline/SemigroupalTests.scala
index 631c6375d..d76b8eb04 100644
--- a/laws/src/main/scala/cats/laws/discipline/SemigroupalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/SemigroupalTests.scala
@@ -12,13 +12,12 @@ trait SemigroupalTests[F[_]] extends Laws {
   def laws: SemigroupalLaws[F]
 
   def semigroupal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-    iso: Isomorphisms[F],
-    ArbFA: Arbitrary[F[A]],
-    ArbFB: Arbitrary[F[B]],
-    ArbFC: Arbitrary[F[C]],
-    EqFA: Eq[F[A]],
-    EqFABC: Eq[F[(A, B, C)]]
-  ): RuleSet =
+                                                            iso: Isomorphisms[F],
+                                                            ArbFA: Arbitrary[F[A]],
+                                                            ArbFB: Arbitrary[F[B]],
+                                                            ArbFC: Arbitrary[F[C]],
+                                                            EqFA: Eq[F[A]],
+                                                            EqFABC: Eq[F[(A, B, C)]]): RuleSet =
     new DefaultRuleSet(
       name = "semigroupal",
       parent = None,
@@ -44,7 +43,7 @@ object SemigroupalTests {
     implicit def invariant[F[_]](implicit F: Invariant[F]): Isomorphisms[F] =
       new Isomorphisms[F] {
         def associativity[A, B, C](fs: (F[(A, (B, C))], F[((A, B), C)])): IsEq[F[(A, B, C)]] =
-          F.imap(fs._1) { case (a, (b, c)) => (a, b, c) } { case (a, b, c) => (a, (b, c)) } <->
+          F.imap(fs._1) { case (a, (b, c))   => (a, b, c) } { case (a, b, c) => (a, (b, c)) } <->
             F.imap(fs._2) { case ((a, b), c) => (a, b, c) } { case (a, b, c) => ((a, b), c) }
 
         def leftIdentity[A](fs: (F[(Unit, A)], F[A])): IsEq[F[A]] =
diff --git a/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala b/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
index 1f40605a1..412c5d524 100644
--- a/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
@@ -1,7 +1,7 @@
 package cats.laws.discipline
 
 import cats.laws.ShortCircuitingLaws
-import cats.{Eq, Foldable, Traverse, TraverseFilter}
+import cats.{Eq, Traverse, TraverseFilter}
 import org.scalacheck.Arbitrary
 import org.scalacheck.Prop.forAll
 import org.typelevel.discipline.Laws
@@ -9,14 +9,6 @@ import org.typelevel.discipline.Laws
 trait ShortCircuitingTests[F[_]] extends Laws {
   def laws: ShortCircuitingLaws[F]
 
-  def foldable[A: Arbitrary](implicit F: Foldable[F], ArbFA: Arbitrary[F[A]], lEq: Eq[Long]): RuleSet =
-    new DefaultRuleSet(
-      name = "foldMapKShortCircuiting",
-      parent = None,
-      "foldMapK short-circuits if MonoidK[G].combineKEval shorts" -> forAll(laws.foldMapKShortCircuits[A] _),
-      "foldMapK won't short-circuit if MonoidK[G].combineKEval won't" -> forAll(laws.foldMapKWontShortCircuit[A] _)
-    )
-
   def traverse[A: Arbitrary](implicit F: Traverse[F], ArbFA: Arbitrary[F[A]], lEq: Eq[Long]): RuleSet =
     new DefaultRuleSet(
       name = "traverseShortCircuiting",
@@ -25,8 +17,8 @@ trait ShortCircuitingTests[F[_]] extends Laws {
       "traverse won't short-circuit if Applicative[G].map2Eval won't" -> forAll(laws.traverseWontShortCircuit[A] _)
     )
 
-  def traverseFilter[A: Arbitrary](implicit
-    TF: TraverseFilter[F],
+  def traverseFilter[A: Arbitrary](
+    implicit TF: TraverseFilter[F],
     ArbFA: Arbitrary[F[A]],
     lEq: Eq[Long]
   ): RuleSet = {
@@ -45,8 +37,7 @@ trait ShortCircuitingTests[F[_]] extends Laws {
 }
 
 object ShortCircuitingTests {
-  def apply[F[_]]: ShortCircuitingTests[F] =
-    new ShortCircuitingTests[F] {
-      override def laws: ShortCircuitingLaws[F] = ShortCircuitingLaws[F]
-    }
+  def apply[F[_]]: ShortCircuitingTests[F] = new ShortCircuitingTests[F] {
+    override def laws: ShortCircuitingLaws[F] = ShortCircuitingLaws[F]
+  }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/StrongTests.scala b/laws/src/main/scala/cats/laws/discipline/StrongTests.scala
index 963578e77..7c4ff859c 100644
--- a/laws/src/main/scala/cats/laws/discipline/StrongTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/StrongTests.scala
@@ -9,7 +9,8 @@ import cats.arrow.Strong
 trait StrongTests[F[_, _]] extends ProfunctorTests[F] {
   def laws: StrongLaws[F]
 
-  def strong[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
+  def strong[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
+    implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFCD: Arbitrary[F[C, D]],
     CogenA: Cogen[A],
diff --git a/laws/src/main/scala/cats/laws/discipline/TraverseFilterTests.scala b/laws/src/main/scala/cats/laws/discipline/TraverseFilterTests.scala
index ce75f2cee..a79eb3bcc 100644
--- a/laws/src/main/scala/cats/laws/discipline/TraverseFilterTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/TraverseFilterTests.scala
@@ -11,23 +11,22 @@ trait TraverseFilterTests[F[_]] extends FunctorFilterTests[F] {
   def laws: TraverseFilterLaws[F]
 
   def traverseFilter[A, B, C](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbFOA: Arbitrary[F[Option[A]]],
-    ArbFABoo: Arbitrary[PartialFunction[A, B]],
-    ArbAOB: Arbitrary[A => Option[B]],
-    ArbAOA: Arbitrary[A => Option[A]],
-    ArbAOOB: Arbitrary[A => Option[Option[B]]],
-    ArbBOC: Arbitrary[B => Option[C]],
-    ArbBOOC: Arbitrary[B => Option[Option[C]]],
-    ArbAB: Arbitrary[A => B],
-    ArbABoo: Arbitrary[A => Boolean],
-    ArbAOBoo: Arbitrary[A => Option[Boolean]],
-    EqFA: Eq[F[A]],
-    EqFB: Eq[F[B]],
-    EqFC: Eq[F[C]],
-    EqGFA: Eq[Option[F[A]]],
-    EqMNFC: Eq[Nested[Option, Option, F[C]]]
-  ): RuleSet =
+                              ArbFA: Arbitrary[F[A]],
+                              ArbFOA: Arbitrary[F[Option[A]]],
+                              ArbFABoo: Arbitrary[PartialFunction[A, B]],
+                              ArbAOB: Arbitrary[A => Option[B]],
+                              ArbAOA: Arbitrary[A => Option[A]],
+                              ArbAOOB: Arbitrary[A => Option[Option[B]]],
+                              ArbBOC: Arbitrary[B => Option[C]],
+                              ArbBOOC: Arbitrary[B => Option[Option[C]]],
+                              ArbAB: Arbitrary[A => B],
+                              ArbABoo: Arbitrary[A => Boolean],
+                              ArbAOBoo: Arbitrary[A => Option[Boolean]],
+                              EqFA: Eq[F[A]],
+                              EqFB: Eq[F[B]],
+                              EqFC: Eq[F[C]],
+                              EqGFA: Eq[Option[F[A]]],
+                              EqMNFC: Eq[Nested[Option, Option, F[C]]]): RuleSet =
     new DefaultRuleSet(
       name = "traverseFilter",
       parent = Some(functorFilter[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/TraverseTests.scala b/laws/src/main/scala/cats/laws/discipline/TraverseTests.scala
index 0231b83d4..41455de70 100644
--- a/laws/src/main/scala/cats/laws/discipline/TraverseTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/TraverseTests.scala
@@ -10,9 +10,8 @@ import Prop._
 trait TraverseTests[F[_]] extends FunctorTests[F] with FoldableTests[F] with UnorderedTraverseTests[F] {
   def laws: TraverseLaws[F]
 
-  def traverse[A: Arbitrary, B: Arbitrary, C: Arbitrary, M: Arbitrary, X[_]: CommutativeApplicative, Y[
-    _
-  ]: CommutativeApplicative](implicit
+  def traverse[A: Arbitrary, B: Arbitrary, C: Arbitrary, M: Arbitrary, X[_]: CommutativeApplicative, Y[_]: CommutativeApplicative](
+    implicit
     ArbFA: Arbitrary[F[A]],
     ArbFB: Arbitrary[F[B]],
     ArbXB: Arbitrary[X[B]],
@@ -38,26 +37,24 @@ trait TraverseTests[F[_]] extends FunctorTests[F] with FoldableTests[F] with Uno
     EqYFM: Eq[Y[F[M]]],
     EqOptionA: Eq[Option[A]]
   ): RuleSet = {
-    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] =
-      new Eq[(X[F[B]], Y[F[B]])] {
-        override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
-          EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
-      }
+    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] = new Eq[(X[F[B]], Y[F[B]])] {
+      override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
+        EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
+    }
     new RuleSet {
       def name: String = "traverse"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(functor[A, B, C], foldable[A, M], unorderedTraverse[A, M, C, X, Y])
-      def props: Seq[(String, Prop)] =
-        Seq(
-          "traverse identity" -> forAll(laws.traverseIdentity[A, C] _),
-          "traverse sequential composition" -> forAll(laws.traverseSequentialComposition[A, B, C, X, Y] _),
-          "traverse parallel composition" -> forAll(laws.traverseParallelComposition[A, B, X, Y] _),
-          "traverse derive foldMap" -> forAll(laws.foldMapDerived[A, M] _),
-          "traverse order consistency" -> forAll(laws.traverseOrderConsistent[A] _),
-          "traverse ref mapWithIndex" -> forAll(laws.mapWithIndexRef[A, C] _),
-          "traverse ref traverseWithIndexM" -> forAll(laws.traverseWithIndexMRef[Option, A, C] _),
-          "traverse ref zipWithIndex" -> forAll(laws.zipWithIndexRef[A, C] _)
-        )
+      def props: Seq[(String, Prop)] = Seq(
+        "traverse identity" -> forAll(laws.traverseIdentity[A, C] _),
+        "traverse sequential composition" -> forAll(laws.traverseSequentialComposition[A, B, C, X, Y] _),
+        "traverse parallel composition" -> forAll(laws.traverseParallelComposition[A, B, X, Y] _),
+        "traverse derive foldMap" -> forAll(laws.foldMapDerived[A, M] _),
+        "traverse order consistency" -> forAll(laws.traverseOrderConsistent[A] _),
+        "traverse ref mapWithIndex" -> forAll(laws.mapWithIndexRef[A, C] _),
+        "traverse ref traverseWithIndexM" -> forAll(laws.traverseWithIndexMRef[Option, A, C] _),
+        "traverse ref zipWithIndex" -> forAll(laws.zipWithIndexRef[A, C] _)
+      )
     }
   }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/UnorderedFoldableTests.scala b/laws/src/main/scala/cats/laws/discipline/UnorderedFoldableTests.scala
index 8eccd4639..2ec35220d 100644
--- a/laws/src/main/scala/cats/laws/discipline/UnorderedFoldableTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/UnorderedFoldableTests.scala
@@ -12,14 +12,13 @@ trait UnorderedFoldableTests[F[_]] extends Laws {
   def laws: UnorderedFoldableLaws[F]
 
   def unorderedFoldable[A: Arbitrary, B: Arbitrary](implicit
-    ArbFA: Arbitrary[F[A]],
-    ArbF: Arbitrary[A => B],
-    CogenA: Cogen[A],
-    A: CommutativeMonoid[A],
-    B: CommutativeMonoid[B],
-    EqFA: Eq[A],
-    EqFB: Eq[B]
-  ): RuleSet =
+                                                    ArbFA: Arbitrary[F[A]],
+                                                    ArbF: Arbitrary[A => B],
+                                                    CogenA: Cogen[A],
+                                                    A: CommutativeMonoid[A],
+                                                    B: CommutativeMonoid[B],
+                                                    EqFA: Eq[A],
+                                                    EqFB: Eq[B]): RuleSet =
     new DefaultRuleSet(
       name = "unorderedFoldable",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/UnorderedTraverseTests.scala b/laws/src/main/scala/cats/laws/discipline/UnorderedTraverseTests.scala
index cdcb86cf2..9edc6bdb3 100644
--- a/laws/src/main/scala/cats/laws/discipline/UnorderedTraverseTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/UnorderedTraverseTests.scala
@@ -9,10 +9,8 @@ import cats.kernel.CommutativeMonoid
 trait UnorderedTraverseTests[F[_]] extends UnorderedFoldableTests[F] {
   def laws: UnorderedTraverseLaws[F]
 
-  def unorderedTraverse[A: Arbitrary, B: Arbitrary, C: Arbitrary, X[_]: CommutativeApplicative, Y[
-    _
-  ]: CommutativeApplicative](implicit
-    ArbFA: Arbitrary[F[A]],
+  def unorderedTraverse[A: Arbitrary, B: Arbitrary, C: Arbitrary, X[_]: CommutativeApplicative, Y[_]: CommutativeApplicative](
+    implicit ArbFA: Arbitrary[F[A]],
     ArbFXB: Arbitrary[F[X[B]]],
     ArbXB: Arbitrary[X[B]],
     ArbYB: Arbitrary[Y[B]],
@@ -27,11 +25,10 @@ trait UnorderedTraverseTests[F[_]] extends UnorderedFoldableTests[F] {
     EqXFB: Eq[X[F[B]]],
     EqYFB: Eq[Y[F[B]]]
   ): RuleSet = {
-    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] =
-      new Eq[(X[F[B]], Y[F[B]])] {
-        override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
-          EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
-      }
+    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] = new Eq[(X[F[B]], Y[F[B]])] {
+      override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
+        EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
+    }
     new DefaultRuleSet(
       name = "unorderedTraverse",
       parent = Some(unorderedFoldable[A, B]),
diff --git a/laws/src/main/scala/cats/laws/discipline/arbitrary.scala b/laws/src/main/scala/cats/laws/discipline/arbitrary.scala
index d8414e1d9..ecf688424 100644
--- a/laws/src/main/scala/cats/laws/discipline/arbitrary.scala
+++ b/laws/src/main/scala/cats/laws/discipline/arbitrary.scala
@@ -43,10 +43,8 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
   implicit def catsLawsCogenForConst[A, B](implicit A: Cogen[A]): Cogen[Const[A, B]] =
     A.contramap(_.getConst)
 
-  implicit def catsLawsArbitraryForOneAnd[F[_], A](implicit
-    A: Arbitrary[A],
-    F: Arbitrary[F[A]]
-  ): Arbitrary[OneAnd[F, A]] =
+  implicit def catsLawsArbitraryForOneAnd[F[_], A](implicit A: Arbitrary[A],
+                                                   F: Arbitrary[F[A]]): Arbitrary[OneAnd[F, A]] =
     Arbitrary(F.arbitrary.flatMap(fa => A.arbitrary.map(a => OneAnd(a, fa))))
 
   implicit def catsLawsCogenForOneAnd[F[_], A](implicit A: Cogen[A], F: Cogen[F[A]]): Cogen[OneAnd[F, A]] =
@@ -103,32 +101,25 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
   implicit def cogenNonEmptyMap[K: Order: Cogen, A: Order: Cogen]: Cogen[NonEmptyMap[K, A]] =
     Cogen[SortedMap[K, A]].contramap(_.toSortedMap)
 
-  implicit def catsLawsArbitraryForEitherT[F[_], A, B](implicit
-    F: Arbitrary[F[Either[A, B]]]
+  implicit def catsLawsArbitraryForEitherT[F[_], A, B](
+    implicit F: Arbitrary[F[Either[A, B]]]
   ): Arbitrary[EitherT[F, A, B]] =
     Arbitrary(F.arbitrary.map(EitherT(_)))
 
   implicit def catsLawsCogenForEitherT[F[_], A, B](implicit F: Cogen[F[Either[A, B]]]): Cogen[EitherT[F, A, B]] =
     F.contramap(_.value)
 
-  implicit def catsLawsArbitraryForValidated[A, B](implicit
-    A: Arbitrary[A],
-    B: Arbitrary[B]
-  ): Arbitrary[Validated[A, B]] =
+  implicit def catsLawsArbitraryForValidated[A, B](implicit A: Arbitrary[A],
+                                                   B: Arbitrary[B]): Arbitrary[Validated[A, B]] =
     Arbitrary(Gen.oneOf(A.arbitrary.map(Validated.invalid), B.arbitrary.map(Validated.valid)))
 
   implicit def catsLawsCogenForValidated[A, B](implicit A: Cogen[A], B: Cogen[B]): Cogen[Validated[A, B]] =
     Cogen((seed, x) => x.fold(A.perturb(seed, _), B.perturb(seed, _)))
 
   implicit def catsLawsArbitraryForIor[A, B](implicit A: Arbitrary[A], B: Arbitrary[B]): Arbitrary[A Ior B] =
-    Arbitrary(
-      Gen.oneOf(A.arbitrary.map(Ior.left),
-                B.arbitrary.map(Ior.right),
-                for {
-                  a <- A.arbitrary; b <- B.arbitrary
-                } yield Ior.both(a, b)
-      )
-    )
+    Arbitrary(Gen.oneOf(A.arbitrary.map(Ior.left), B.arbitrary.map(Ior.right), for {
+      a <- A.arbitrary; b <- B.arbitrary
+    } yield Ior.both(a, b)))
 
   implicit def catsLawsCogenForIor[A, B](implicit A: Cogen[A], B: Cogen[B]): Cogen[A Ior B] =
     Cogen((seed, x) => x.fold(A.perturb(seed, _), B.perturb(seed, _), (a, b) => A.perturb(B.perturb(seed, b), a)))
@@ -155,32 +146,25 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
     Arbitrary(
       Gen.oneOf(getArbitrary[A].map(a => Eval.now(a)),
                 getArbitrary[() => A].map(f => Eval.later(f())),
-                getArbitrary[() => A].map(f => Eval.always(f()))
-      )
+                getArbitrary[() => A].map(f => Eval.always(f())))
     )
 
   implicit def catsLawsCogenForEval[A: Cogen]: Cogen[Eval[A]] =
     Cogen[A].contramap(_.value)
 
-  implicit def catsLawsArbitraryForTuple2K[F[_], G[_], A](implicit
-    F: Arbitrary[F[A]],
-    G: Arbitrary[G[A]]
-  ): Arbitrary[Tuple2K[F, G, A]] =
+  implicit def catsLawsArbitraryForTuple2K[F[_], G[_], A](implicit F: Arbitrary[F[A]],
+                                                          G: Arbitrary[G[A]]): Arbitrary[Tuple2K[F, G, A]] =
     Arbitrary(F.arbitrary.flatMap(fa => G.arbitrary.map(ga => Tuple2K[F, G, A](fa, ga))))
 
-  implicit def catsLawsArbitraryForFunc[F[_], A, B](implicit
-    AA: Arbitrary[A],
-    CA: Cogen[A],
-    F: Arbitrary[F[B]]
-  ): Arbitrary[Func[F, A, B]] =
+  implicit def catsLawsArbitraryForFunc[F[_], A, B](implicit AA: Arbitrary[A],
+                                                    CA: Cogen[A],
+                                                    F: Arbitrary[F[B]]): Arbitrary[Func[F, A, B]] =
     Arbitrary(Arbitrary.arbitrary[A => F[B]].map(Func.func))
 
-  implicit def catsLawsArbitraryForAppFunc[F[_], A, B](implicit
-    AA: Arbitrary[A],
-    CA: Cogen[A],
-    F: Arbitrary[F[B]],
-    FF: Applicative[F]
-  ): Arbitrary[AppFunc[F, A, B]] =
+  implicit def catsLawsArbitraryForAppFunc[F[_], A, B](implicit AA: Arbitrary[A],
+                                                       CA: Cogen[A],
+                                                       F: Arbitrary[F[B]],
+                                                       FF: Applicative[F]): Arbitrary[AppFunc[F, A, B]] =
     Arbitrary(Arbitrary.arbitrary[A => F[B]].map(Func.appFunc(_)))
 
   implicit def catsLawsArbitraryForWriter[L: Arbitrary, V: Arbitrary]: Arbitrary[Writer[L, V]] =
@@ -190,21 +174,17 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
     Cogen[(L, V)].contramap(_.run)
 
   // until this is provided by ScalaCheck
-  implicit def catsLawsArbitraryForPartialFunction[A, B](implicit
-    F: Arbitrary[A => Option[B]]
+  implicit def catsLawsArbitraryForPartialFunction[A, B](
+    implicit F: Arbitrary[A => Option[B]]
   ): Arbitrary[PartialFunction[A, B]] =
     Arbitrary(F.arbitrary.map(Function.unlift))
 
-  implicit def catsLawsArbitraryForEitherK[F[_], G[_], A](implicit
-    F: Arbitrary[F[A]],
-    G: Arbitrary[G[A]]
-  ): Arbitrary[EitherK[F, G, A]] =
+  implicit def catsLawsArbitraryForEitherK[F[_], G[_], A](implicit F: Arbitrary[F[A]],
+                                                          G: Arbitrary[G[A]]): Arbitrary[EitherK[F, G, A]] =
     Arbitrary(Gen.oneOf(F.arbitrary.map(EitherK.leftc[F, G, A]), G.arbitrary.map(EitherK.rightc[F, G, A])))
 
-  implicit def catsLawsCogenForEitherK[F[_], G[_], A](implicit
-    F: Cogen[F[A]],
-    G: Cogen[G[A]]
-  ): Cogen[EitherK[F, G, A]] =
+  implicit def catsLawsCogenForEitherK[F[_], G[_], A](implicit F: Cogen[F[A]],
+                                                      G: Cogen[G[A]]): Cogen[EitherK[F, G, A]] =
     Cogen((seed, x) => x.run.fold(F.perturb(seed, _), G.perturb(seed, _)))
 
   implicit def catLawsCogenForTuple2K[F[_], G[_], A](implicit F: Cogen[F[A]], G: Cogen[G[A]]): Cogen[Tuple2K[F, G, A]] =
@@ -282,8 +262,8 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
   implicit def catsLawsArbitraryForNested[F[_], G[_], A](implicit FG: Arbitrary[F[G[A]]]): Arbitrary[Nested[F, G, A]] =
     Arbitrary(FG.arbitrary.map(Nested(_)))
 
-  implicit def catsLawsArbitraryForBinested[F[_, _], G[_], H[_], A, B](implicit
-    F: Arbitrary[F[G[A], H[B]]]
+  implicit def catsLawsArbitraryForBinested[F[_, _], G[_], H[_], A, B](
+    implicit F: Arbitrary[F[G[A], H[B]]]
   ): Arbitrary[Binested[F, G, H, A, B]] =
     Arbitrary(F.arbitrary.map(Binested(_)))
 
@@ -302,12 +282,14 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
   implicit def catsLawsCogenForOp[Arr[_, _], A, B](implicit Arr: Cogen[Arr[B, A]]): Cogen[Op[Arr, A, B]] =
     Arr.contramap(_.run)
 
-  implicit def catsLawsArbitraryForIRWST[F[_]: Applicative, E, L, SA, SB, A](implicit
+  implicit def catsLawsArbitraryForIRWST[F[_]: Applicative, E, L, SA, SB, A](
+    implicit
     F: Arbitrary[(E, SA) => F[(L, SB, A)]]
   ): Arbitrary[IndexedReaderWriterStateT[F, E, L, SA, SB, A]] =
     Arbitrary(F.arbitrary.map(IndexedReaderWriterStateT(_)))
 
-  implicit def catsLawsArbitraryForRepresentableStore[F[_], S, A](implicit
+  implicit def catsLawsArbitraryForRepresentableStore[F[_], S, A](
+    implicit
     R: Representable.Aux[F, S],
     ArbS: Arbitrary[S],
     ArbFA: Arbitrary[F[A]]
@@ -321,8 +303,8 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
       }
     }
 
-  implicit def catsLawsCogenForRepresentableStore[F[_]: Representable, S, A](implicit
-    CA: Cogen[A]
+  implicit def catsLawsCogenForRepresentableStore[F[_]: Representable, S, A](
+    implicit CA: Cogen[A]
   ): Cogen[RepresentableStore[F, S, A]] =
     CA.contramap(_.extract)
 
@@ -371,8 +353,8 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
 
 sealed private[discipline] trait ArbitraryInstances0 {
 
-  implicit def catsLawArbitraryForIndexedStateT[F[_], SA, SB, A](implicit
-    F: Arbitrary[F[SA => F[(SB, A)]]]
+  implicit def catsLawArbitraryForIndexedStateT[F[_], SA, SB, A](
+    implicit F: Arbitrary[F[SA => F[(SB, A)]]]
   ): Arbitrary[IndexedStateT[F, SA, SB, A]] =
     Arbitrary(F.arbitrary.map(IndexedStateT.applyF))
 
@@ -382,17 +364,13 @@ sealed private[discipline] trait ArbitraryInstances0 {
   implicit def catsLawsCogenForWriterT[F[_], L, V](implicit F: Cogen[F[(L, V)]]): Cogen[WriterT[F, L, V]] =
     F.contramap(_.run)
 
-  implicit def catsLawsArbitraryForKleisli[F[_], A, B](implicit
-    AA: Arbitrary[A],
-    CA: Cogen[A],
-    F: Arbitrary[F[B]]
-  ): Arbitrary[Kleisli[F, A, B]] =
+  implicit def catsLawsArbitraryForKleisli[F[_], A, B](implicit AA: Arbitrary[A],
+                                                       CA: Cogen[A],
+                                                       F: Arbitrary[F[B]]): Arbitrary[Kleisli[F, A, B]] =
     Arbitrary(Arbitrary.arbitrary[A => F[B]].map(Kleisli(_)))
 
-  implicit def catsLawsArbitraryForCokleisli[F[_], A, B](implicit
-    AFA: Arbitrary[F[A]],
-    CFA: Cogen[F[A]],
-    B: Arbitrary[B]
-  ): Arbitrary[Cokleisli[F, A, B]] =
+  implicit def catsLawsArbitraryForCokleisli[F[_], A, B](implicit AFA: Arbitrary[F[A]],
+                                                         CFA: Cogen[F[A]],
+                                                         B: Arbitrary[B]): Arbitrary[Cokleisli[F, A, B]] =
     Arbitrary(Arbitrary.arbitrary[F[A] => B].map(Cokleisli(_)))
 }
diff --git a/project/Boilerplate.scala b/project/Boilerplate.scala
index d999516ea..72447bdef 100644
--- a/project/Boilerplate.scala
+++ b/project/Boilerplate.scala
@@ -34,12 +34,11 @@ object Boilerplate {
   val header = "// auto-generated boilerplate by /project/Boilerplate.scala" // TODO: put something meaningful here?
 
   /** Returns a seq of the generated files.  As a side-effect, it actually generates them... */
-  def gen(dir: File) =
-    for (t <- templates) yield {
-      val tgtFile = t.filename(dir)
-      IO.write(tgtFile, t.body)
-      tgtFile
-    }
+  def gen(dir: File) = for (t <- templates) yield {
+    val tgtFile = t.filename(dir)
+    IO.write(tgtFile, t.body)
+    tgtFile
+  }
 
   val maxArity = 22
 
@@ -150,10 +149,10 @@ object Boilerplate {
       |
       |
       |@deprecated("replaced by apply syntax", "1.0.0-MF")
-      |private[syntax] final class SemigroupalBuilder[F[_]] extends Serializable {
+      |private[syntax] final class SemigroupalBuilder[F[_]] {
       |  def |@|[A](a: F[A]) = new SemigroupalBuilder1(a)
       |
-        -  private[syntax] final class SemigroupalBuilder$arity[${`A..N`}]($params) extends Serializable {
+        -  private[syntax] final class SemigroupalBuilder$arity[${`A..N`}]($params) {
         -    $next
         -    def apWith[Z](f: F[(${`A..N`}) => Z])(implicit apply: Apply[F]): F[Z] = apply.ap$n(f)(${`a..n`})
         -    $map
@@ -418,7 +417,7 @@ object Boilerplate {
          -  implicit def catsSyntaxTuple${arity}Parallel[M[_], ${`A..N`}]($tupleTpe): Tuple${arity}ParallelOps[M, ${`A..N`}] = new Tuple${arity}ParallelOps(t$arity)
       |}
       |
-         -private[syntax] final class Tuple${arity}ParallelOps[M[_], ${`A..N`}](private val $tupleTpe) extends Serializable {
+         -private[syntax] final class Tuple${arity}ParallelOps[M[_], ${`A..N`}](private val $tupleTpe) {
          -  $parMap
          -  $parTupled
          -}
@@ -488,7 +487,7 @@ object Boilerplate {
         -  implicit def catsSyntaxTuple${arity}Semigroupal[F[_], ${`A..N`}]($tupleTpe): Tuple${arity}SemigroupalOps[F, ${`A..N`}] = new Tuple${arity}SemigroupalOps(t$arity)
       |}
       |
-        -private[syntax] final class Tuple${arity}SemigroupalOps[F[_], ${`A..N`}](private val $tupleTpe) extends Serializable {
+        -private[syntax] final class Tuple${arity}SemigroupalOps[F[_], ${`A..N`}](private val $tupleTpe) {
         -  $map
         -  $contramap
         -  $imap
diff --git a/project/KernelBoiler.scala b/project/KernelBoiler.scala
index f444d8478..304d485be 100644
--- a/project/KernelBoiler.scala
+++ b/project/KernelBoiler.scala
@@ -32,12 +32,11 @@ object KernelBoiler {
    *
    * As a side-effect, it actually generates them...
    */
-  def gen(dir: File): Seq[File] =
-    templates.map { template =>
-      val tgtFile = template.filename(dir)
-      IO.write(tgtFile, template.body)
-      tgtFile
-    }
+  def gen(dir: File): Seq[File] = templates.map { template =>
+    val tgtFile = template.filename(dir)
+    IO.write(tgtFile, template.body)
+    tgtFile
+  }
 
   class TemplateVals(val arity: Int) {
     val synTypes = (0 until arity).map(n => s"A$n")
diff --git a/project/build.properties b/project/build.properties
index 654fe70c4..797e7ccfd 100644
--- a/project/build.properties
+++ b/project/build.properties
@@ -1 +1 @@
-sbt.version=1.3.12
+sbt.version=1.3.10
diff --git a/project/plugins.sbt b/project/plugins.sbt
index 49478dc3c..1be459ed6 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -1,4 +1,4 @@
-addSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "0.9.16")
+addSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "0.9.15-3")
 addSbtPlugin("com.eed3si9n" % "sbt-unidoc" % "0.4.3")
 addSbtPlugin("com.github.gseitz" %% "sbt-release" % "1.0.13")
 addSbtPlugin("com.jsuereth" % "sbt-pgp" % "2.0.1")
diff --git a/scalafix/project/build.properties b/scalafix/project/build.properties
index 654fe70c4..797e7ccfd 100644
--- a/scalafix/project/build.properties
+++ b/scalafix/project/build.properties
@@ -1 +1 @@
-sbt.version=1.3.12
+sbt.version=1.3.10
