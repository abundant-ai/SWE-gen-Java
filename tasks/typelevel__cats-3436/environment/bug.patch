diff --git a/.codecov.yml b/.codecov.yml
new file mode 100644
index 000000000..7da17706b
--- /dev/null
+++ b/.codecov.yml
@@ -0,0 +1,4 @@
+comment:
+  layout: "diff"
+  require_changes: true
+
diff --git a/.gitignore b/.gitignore
index 7c99f0ab7..bebf6c3f5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -19,8 +19,6 @@ TAGS
 .DS_Store
 .vscode
 .sbtrc
-.semanticdb
-metals.sbt
 *.sublime-project
 *.sublime-workspace
 tests.iml
diff --git a/.scalafmt.conf b/.scalafmt.conf
index d7a436817..3abbf3a70 100644
--- a/.scalafmt.conf
+++ b/.scalafmt.conf
@@ -1,10 +1,10 @@
-version=2.4.2
+version=2.5.3
 align.openParenCallSite = true
 align.openParenDefnSite = true
 maxColumn = 120
 continuationIndent.defnSite = 2
 assumeStandardLibraryStripMargin = true
 danglingParentheses = true
-rewrite.rules = [AvoidInfix, SortImports, RedundantBraces, RedundantParens, SortModifiers]
+rewrite.rules = [AvoidInfix, SortImports, RedundantParens, SortModifiers]
 docstrings = JavaDoc
 newlines.afterCurlyLambda = preserve
diff --git a/README.md b/README.md
index aa7357136..445747e8e 100644
--- a/README.md
+++ b/README.md
@@ -324,6 +324,7 @@ Here's a (non-exhaustive) list of companies that use Cats in production. Don't s
 - [HomeAway](https://www.homeaway.com)
 - [iHeartRadio](https://iheart.com)
 - [ImmobilienScout24](https://www.immobilienscout24.de/)
+- [Iterators](https://www.iteratorshq.com/)
 - [ITV](https://www.itv.com/)
 - [Lightform](https://lightform.com/)
 - [Lookout](https://www.lookout.com)
diff --git a/alleycats-core/src/main/scala/alleycats/ConsK.scala b/alleycats-core/src/main/scala/alleycats/ConsK.scala
index 71a5a3892..9e672ca52 100644
--- a/alleycats-core/src/main/scala/alleycats/ConsK.scala
+++ b/alleycats-core/src/main/scala/alleycats/ConsK.scala
@@ -18,35 +18,38 @@ object ConsK {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[ConsK]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: ConsK[F]): ConsK[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: ConsK[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToConsKOps {
+  trait ToConsKOps extends Serializable {
     implicit def toConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): Ops[F, A] {
       type TypeClassType = ConsK[F]
-    } = new Ops[F, A] {
-      type TypeClassType = ConsK[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = ConsK[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToConsKOps
   object ops {
     implicit def toAllConsKOps[F[_], A](target: F[A])(implicit tc: ConsK[F]): AllOps[F, A] {
       type TypeClassType = ConsK[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = ConsK[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = ConsK[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/Empty.scala b/alleycats-core/src/main/scala/alleycats/Empty.scala
index 698e49b4f..98574e8d7 100644
--- a/alleycats-core/src/main/scala/alleycats/Empty.scala
+++ b/alleycats-core/src/main/scala/alleycats/Empty.scala
@@ -26,12 +26,13 @@ object Empty extends EmptyInstances0 {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Empty]] for `A`.
    */
   @inline def apply[A](implicit instance: Empty[A]): Empty[A] = instance
 
-  trait Ops[A] {
+  trait Ops[A] extends Serializable {
     type TypeClassType <: Empty[A]
     def self: A
     val typeClassInstance: TypeClassType
@@ -39,24 +40,26 @@ object Empty extends EmptyInstances0 {
     def nonEmpty(implicit ev: Eq[A]): Boolean = typeClassInstance.nonEmpty(self)(ev)
   }
   trait AllOps[A] extends Ops[A]
-  trait ToEmptyOps {
+  trait ToEmptyOps extends Serializable {
     implicit def toEmptyOps[A](target: A)(implicit tc: Empty[A]): Ops[A] {
       type TypeClassType = Empty[A]
-    } = new Ops[A] {
-      type TypeClassType = Empty[A]
-      val self: A = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[A] {
+        type TypeClassType = Empty[A]
+        val self: A = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToEmptyOps
   object ops {
     implicit def toAllEmptyOps[A](target: A)(implicit tc: Empty[A]): AllOps[A] {
       type TypeClassType = Empty[A]
-    } = new AllOps[A] {
-      type TypeClassType = Empty[A]
-      val self: A = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[A] {
+        type TypeClassType = Empty[A]
+        val self: A = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/EmptyK.scala b/alleycats-core/src/main/scala/alleycats/EmptyK.scala
index 2a809b9c7..cb6cf64b5 100644
--- a/alleycats-core/src/main/scala/alleycats/EmptyK.scala
+++ b/alleycats-core/src/main/scala/alleycats/EmptyK.scala
@@ -18,35 +18,38 @@ object EmptyK {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[EmptyK]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: EmptyK[F]): EmptyK[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: EmptyK[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToEmptyKOps {
+  trait ToEmptyKOps extends Serializable {
     implicit def toEmptyKOps[F[_], A](target: F[A])(implicit tc: EmptyK[F]): Ops[F, A] {
       type TypeClassType = EmptyK[F]
-    } = new Ops[F, A] {
-      type TypeClassType = EmptyK[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = EmptyK[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToEmptyKOps
   object ops {
     implicit def toAllEmptyKOps[F[_], A](target: F[A])(implicit tc: EmptyK[F]): AllOps[F, A] {
       type TypeClassType = EmptyK[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = EmptyK[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = EmptyK[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/Extract.scala b/alleycats-core/src/main/scala/alleycats/Extract.scala
index 808ae6050..3b979e0c0 100644
--- a/alleycats-core/src/main/scala/alleycats/Extract.scala
+++ b/alleycats-core/src/main/scala/alleycats/Extract.scala
@@ -28,36 +28,39 @@ object Extract {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Extract]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Extract[F]): Extract[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Extract[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
     def extract: A = typeClassInstance.extract[A](self)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToExtractOps {
+  trait ToExtractOps extends Serializable {
     implicit def toExtractOps[F[_], A](target: F[A])(implicit tc: Extract[F]): Ops[F, A] {
       type TypeClassType = Extract[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Extract[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Extract[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToExtractOps
   object ops {
     implicit def toAllExtractOps[F[_], A](target: F[A])(implicit tc: Extract[F]): AllOps[F, A] {
       type TypeClassType = Extract[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Extract[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Extract[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/One.scala b/alleycats-core/src/main/scala/alleycats/One.scala
index a70d39ae6..8adba537e 100644
--- a/alleycats-core/src/main/scala/alleycats/One.scala
+++ b/alleycats-core/src/main/scala/alleycats/One.scala
@@ -23,12 +23,13 @@ object One {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[One]] for `A`.
    */
   @inline def apply[A](implicit instance: One[A]): One[A] = instance
 
-  trait Ops[A] {
+  trait Ops[A] extends Serializable {
     type TypeClassType <: One[A]
     def self: A
     val typeClassInstance: TypeClassType
@@ -36,24 +37,26 @@ object One {
     def nonOne(implicit ev: Eq[A]): Boolean = typeClassInstance.nonOne(self)(ev)
   }
   trait AllOps[A] extends Ops[A]
-  trait ToOneOps {
+  trait ToOneOps extends Serializable {
     implicit def toOneOps[A](target: A)(implicit tc: One[A]): Ops[A] {
       type TypeClassType = One[A]
-    } = new Ops[A] {
-      type TypeClassType = One[A]
-      val self: A = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[A] {
+        type TypeClassType = One[A]
+        val self: A = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToOneOps
   object ops {
     implicit def toAllOneOps[A](target: A)(implicit tc: One[A]): AllOps[A] {
       type TypeClassType = One[A]
-    } = new AllOps[A] {
-      type TypeClassType = One[A]
-      val self: A = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[A] {
+        type TypeClassType = One[A]
+        val self: A = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/Pure.scala b/alleycats-core/src/main/scala/alleycats/Pure.scala
index cb96acbdc..1005ce92e 100644
--- a/alleycats-core/src/main/scala/alleycats/Pure.scala
+++ b/alleycats-core/src/main/scala/alleycats/Pure.scala
@@ -28,35 +28,38 @@ object Pure {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Pure]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Pure[F]): Pure[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Pure[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToPureOps {
+  trait ToPureOps extends Serializable {
     implicit def toPureOps[F[_], A](target: F[A])(implicit tc: Pure[F]): Ops[F, A] {
       type TypeClassType = Pure[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Pure[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Pure[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToPureOps
   object ops {
     implicit def toAllPureOps[F[_], A](target: F[A])(implicit tc: Pure[F]): AllOps[F, A] {
       type TypeClassType = Pure[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Pure[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Pure[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/alleycats-core/src/main/scala/alleycats/Zero.scala b/alleycats-core/src/main/scala/alleycats/Zero.scala
index 80c993c5b..e59a60ec3 100644
--- a/alleycats-core/src/main/scala/alleycats/Zero.scala
+++ b/alleycats-core/src/main/scala/alleycats/Zero.scala
@@ -24,12 +24,13 @@ object Zero {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Zero]] for `A`.
    */
   @inline def apply[A](implicit instance: Zero[A]): Zero[A] = instance
 
-  trait Ops[A] {
+  trait Ops[A] extends Serializable {
     type TypeClassType <: Zero[A]
     def self: A
     val typeClassInstance: TypeClassType
@@ -37,24 +38,26 @@ object Zero {
     def nonZero(implicit ev: Eq[A]): Boolean = typeClassInstance.nonZero(self)(ev)
   }
   trait AllOps[A] extends Ops[A]
-  trait ToZeroOps {
+  trait ToZeroOps extends Serializable {
     implicit def toZeroOps[A](target: A)(implicit tc: Zero[A]): Ops[A] {
       type TypeClassType = Zero[A]
-    } = new Ops[A] {
-      type TypeClassType = Zero[A]
-      val self: A = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[A] {
+        type TypeClassType = Zero[A]
+        val self: A = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToZeroOps
   object ops {
     implicit def toAllZeroOps[A](target: A)(implicit tc: Zero[A]): AllOps[A] {
       type TypeClassType = Zero[A]
-    } = new AllOps[A] {
-      type TypeClassType = Zero[A]
-      val self: A = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[A] {
+        type TypeClassType = Zero[A]
+        val self: A = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/alleycats-laws/src/main/scala/alleycats/laws/discipline/FlatMapRecTests.scala b/alleycats-laws/src/main/scala/alleycats/laws/discipline/FlatMapRecTests.scala
index 9c4a34ef6..a34a5f561 100644
--- a/alleycats-laws/src/main/scala/alleycats/laws/discipline/FlatMapRecTests.scala
+++ b/alleycats-laws/src/main/scala/alleycats/laws/discipline/FlatMapRecTests.scala
@@ -10,10 +10,7 @@ import org.typelevel.discipline.Laws
 trait FlatMapRecTests[F[_]] extends Laws {
   def laws: FlatMapLaws[F]
 
-  def tailRecM[A: Arbitrary](implicit
-                             ArbFA: Arbitrary[F[A]],
-                             ArbAFA: Arbitrary[A => F[A]],
-                             EqFA: Eq[F[A]]): RuleSet =
+  def tailRecM[A: Arbitrary](implicit ArbFA: Arbitrary[F[A]], ArbAFA: Arbitrary[A => F[A]], EqFA: Eq[F[A]]): RuleSet =
     new DefaultRuleSet(
       name = "flatMapTailRec",
       parent = None,
diff --git a/build.sbt b/build.sbt
index 751ace24b..2d1ae5593 100644
--- a/build.sbt
+++ b/build.sbt
@@ -12,7 +12,7 @@ lazy val scoverageSettings = Seq(
 )
 
 organization in ThisBuild := "org.typelevel"
-scalafixDependencies in ThisBuild += "org.typelevel" %% "simulacrum-scalafix" % "0.2.0"
+scalafixDependencies in ThisBuild += "org.typelevel" %% "simulacrum-scalafix" % "0.3.0"
 
 val isTravisBuild = settingKey[Boolean]("Flag indicating whether the current build is running under Travis")
 val crossScalaVersionsFromTravis = settingKey[Seq[String]]("Scala versions set in .travis.yml as scala_version_XXX")
@@ -83,14 +83,15 @@ lazy val simulacrumSettings = Seq(
   libraryDependencies += "org.typelevel" %% "simulacrum-scalafix-annotations" % "0.2.0",
   pomPostProcess := { (node: xml.Node) =>
     new RuleTransformer(new RewriteRule {
-      override def transform(node: xml.Node): Seq[xml.Node] = node match {
-        case e: xml.Elem
-            if e.label == "dependency" &&
-              e.child.exists(child => child.label == "groupId" && child.text == "org.typelevel") &&
-              e.child.exists(child => child.label == "artifactId" && child.text.startsWith("simulacrum")) =>
-          Nil
-        case _ => Seq(node)
-      }
+      override def transform(node: xml.Node): Seq[xml.Node] =
+        node match {
+          case e: xml.Elem
+              if e.label == "dependency" &&
+                e.child.exists(child => child.label == "groupId" && child.text == "org.typelevel") &&
+                e.child.exists(child => child.label == "artifactId" && child.text.startsWith("simulacrum")) =>
+            Nil
+          case _ => Seq(node)
+        }
     }).transform(node).head
   }
 )
@@ -109,7 +110,7 @@ lazy val commonJsSettings = Seq(
     val g = "https://raw.githubusercontent.com/typelevel/cats/" + tagOrHash
     s"-P:scalajs:mapSourceURI:$a->$g/"
   },
-  scalaJSStage in Global := FastOptStage,
+  scalaJSStage in Global := FullOptStage,
   parallelExecution := false,
   jsEnv := new org.scalajs.jsenv.nodejs.NodeJSEnv(),
   // batch mode decreases the amount of memory needed to compile Scala.js code
@@ -140,7 +141,8 @@ lazy val includeGeneratedSrc: Setting[_] = {
 
 lazy val disciplineDependencies = Seq(
   libraryDependencies ++= Seq("org.scalacheck" %%% "scalacheck" % scalaCheckVersion,
-                              "org.typelevel" %%% "discipline-core" % disciplineVersion)
+                              "org.typelevel" %%% "discipline-core" % disciplineVersion
+  )
 )
 
 lazy val testingDependencies = Seq(
@@ -424,7 +426,8 @@ lazy val catsJVM = project
              alleycatsLaws.jvm,
              alleycatsTests.jvm,
              jvm,
-             docs)
+             docs
+  )
   .dependsOn(
     kernel.jvm,
     kernelLaws.jvm,
@@ -455,7 +458,8 @@ lazy val catsJS = project
              alleycatsCore.js,
              alleycatsLaws.js,
              alleycatsTests.js,
-             js)
+             js
+  )
   .dependsOn(
     kernel.js,
     kernelLaws.js,
diff --git a/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala b/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
index e43b11f7c..211c39f61 100644
--- a/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
+++ b/core/src/main/scala-2.12/cats/instances/ScalaVersionSpecificParallelInstances.scala
@@ -12,8 +12,8 @@ trait ParallelInstances extends ParallelInstances1 {
     cats.instances.either.catsParallelForEitherAndValidated[E]
 
   @deprecated("Use OptionT.catsDataParallelForOptionT", "2.0.0")
-  def catsParallelForOptionTNestedOption[M[_]](
-    implicit P: Parallel[M]
+  def catsParallelForOptionTNestedOption[M[_]](implicit
+    P: Parallel[M]
   ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = OptionT.catsDataParallelForOptionT[M]
 
   @deprecated("Use cats.instances.list.catsStdNonEmptyParallelForListZipList", "2.1.0")
@@ -29,8 +29,8 @@ trait ParallelInstances extends ParallelInstances1 {
     cats.instances.stream.catsStdParallelForStreamZipStream
 
   @deprecated("Use EitherT.catsDataParallelForEitherTWithParallelEffect", "2.0.0")
-  def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](
-    implicit P: Parallel[M]
+  def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](implicit
+    P: Parallel[M]
   ): Parallel.Aux[EitherT[M, E, *], Nested[P.F, Validated[E, *], *]] =
     EitherT.catsDataParallelForEitherTWithParallelEffect[M, E]
 }
diff --git a/core/src/main/scala-2.12/cats/instances/stream.scala b/core/src/main/scala-2.12/cats/instances/stream.scala
index eef109e1c..7927e16cb 100644
--- a/core/src/main/scala-2.12/cats/instances/stream.scala
+++ b/core/src/main/scala-2.12/cats/instances/stream.scala
@@ -68,36 +68,39 @@ trait StreamInstances extends cats.kernel.instances.StreamInstances {
           var state: Either[Unit, Option[B]] = Left(())
 
           @tailrec
-          def advance(): Unit = stack match {
-            case Right(b) #:: tail =>
-              stack = tail
-              state = Right(Some(b))
-            case Left(a) #:: tail =>
-              stack = fn(a) #::: tail
-              advance()
-            case empty =>
-              state = Right(None)
-          }
+          def advance(): Unit =
+            stack match {
+              case Right(b) #:: tail =>
+                stack = tail
+                state = Right(Some(b))
+              case Left(a) #:: tail =>
+                stack = fn(a) #::: tail
+                advance()
+              case empty =>
+                state = Right(None)
+            }
 
           @tailrec
-          def hasNext: Boolean = state match {
-            case Left(()) =>
-              advance()
-              hasNext
-            case Right(o) =>
-              o.isDefined
-          }
+          def hasNext: Boolean =
+            state match {
+              case Left(()) =>
+                advance()
+                hasNext
+              case Right(o) =>
+                o.isDefined
+            }
 
           @tailrec
-          def next(): B = state match {
-            case Left(()) =>
-              advance()
-              next()
-            case Right(o) =>
-              val b = o.get
-              advance()
-              b
-          }
+          def next(): B =
+            state match {
+              case Left(()) =>
+                advance()
+                next()
+              case Right(o) =>
+                val b = o.get
+                advance()
+                b
+            }
         }
 
         it.toStream
diff --git a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
index 3ccfdb301..d7a9b8d14 100644
--- a/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
+++ b/core/src/main/scala-2.13+/cats/data/NonEmptyLazyList.scala
@@ -498,8 +498,9 @@ sealed abstract private[data] class NonEmptyLazyListInstances extends NonEmptyLa
       def align[A, B](fa: NonEmptyLazyList[A], fb: NonEmptyLazyList[B]): NonEmptyLazyList[Ior[A, B]] =
         alignInstance.align(fa, fb)
 
-      override def alignWith[A, B, C](fa: NonEmptyLazyList[A],
-                                      fb: NonEmptyLazyList[B])(f: Ior[A, B] => C): NonEmptyLazyList[C] =
+      override def alignWith[A, B, C](fa: NonEmptyLazyList[A], fb: NonEmptyLazyList[B])(
+        f: Ior[A, B] => C
+      ): NonEmptyLazyList[C] =
         alignInstance.alignWith(fa, fb)(f)
     }
 
diff --git a/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala b/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
index f3c16fcaa..c3ee09061 100644
--- a/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
+++ b/core/src/main/scala-2.13+/cats/instances/ScalaVersionSpecificParallelInstances.scala
@@ -13,8 +13,8 @@ trait ParallelInstances extends ParallelInstances1 {
     cats.instances.either.catsParallelForEitherAndValidated[E]
 
   @deprecated("Use OptionT.catsDataParallelForOptionT", "2.0.0")
-  def catsParallelForOptionTNestedOption[M[_]](
-    implicit P: Parallel[M]
+  def catsParallelForOptionTNestedOption[M[_]](implicit
+    P: Parallel[M]
   ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = OptionT.catsDataParallelForOptionT[M]
 
   @deprecated("Use cats.instances.list.catsStdNonEmptyParallelForListZipList", "2.1.0")
@@ -34,8 +34,8 @@ trait ParallelInstances extends ParallelInstances1 {
     cats.instances.lazyList.catsStdParallelForLazyListZipLazyList[A]
 
   @deprecated("Use EitherT.catsDataParallelForEitherTWithParallelEffect", "2.0.0")
-  def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](
-    implicit P: Parallel[M]
+  def catsParallelForEitherTNestedParallelValidated[M[_], E: Semigroup](implicit
+    P: Parallel[M]
   ): Parallel.Aux[EitherT[M, E, *], Nested[P.F, Validated[E, *], *]] =
     EitherT.catsDataParallelForEitherTWithParallelEffect[M, E]
 }
diff --git a/core/src/main/scala-2.13+/cats/instances/stream.scala b/core/src/main/scala-2.13+/cats/instances/stream.scala
index 14de524ec..8f8137296 100644
--- a/core/src/main/scala-2.13+/cats/instances/stream.scala
+++ b/core/src/main/scala-2.13+/cats/instances/stream.scala
@@ -69,36 +69,39 @@ trait StreamInstances extends cats.kernel.instances.StreamInstances {
           var state: Either[Unit, Option[B]] = Left(())
 
           @tailrec
-          def advance(): Unit = stack match {
-            case Right(b) #:: tail =>
-              stack = tail
-              state = Right(Some(b))
-            case Left(a) #:: tail =>
-              stack = fn(a) #::: tail
-              advance()
-            case empty =>
-              state = Right(None)
-          }
+          def advance(): Unit =
+            stack match {
+              case Right(b) #:: tail =>
+                stack = tail
+                state = Right(Some(b))
+              case Left(a) #:: tail =>
+                stack = fn(a) #::: tail
+                advance()
+              case empty =>
+                state = Right(None)
+            }
 
           @tailrec
-          def hasNext: Boolean = state match {
-            case Left(()) =>
-              advance()
-              hasNext
-            case Right(o) =>
-              o.isDefined
-          }
+          def hasNext: Boolean =
+            state match {
+              case Left(()) =>
+                advance()
+                hasNext
+              case Right(o) =>
+                o.isDefined
+            }
 
           @tailrec
-          def next(): B = state match {
-            case Left(()) =>
-              advance()
-              next()
-            case Right(o) =>
-              val b = o.get
-              advance()
-              b
-          }
+          def next(): B =
+            state match {
+              case Left(()) =>
+                advance()
+                next()
+              case Right(o) =>
+                val b = o.get
+                advance()
+                b
+            }
         }
 
         it.toStream
diff --git a/core/src/main/scala/cats/Align.scala b/core/src/main/scala/cats/Align.scala
index 0cf05c9f5..794eab420 100644
--- a/core/src/main/scala/cats/Align.scala
+++ b/core/src/main/scala/cats/Align.scala
@@ -104,9 +104,10 @@ import scala.annotation.implicitNotFound
 }
 
 object Align extends ScalaVersionSpecificAlignInstances {
-  def semigroup[F[_], A](implicit F: Align[F], A: Semigroup[A]): Semigroup[F[A]] = new Semigroup[F[A]] {
-    def combine(x: F[A], y: F[A]): F[A] = Align[F].alignCombine(x, y)
-  }
+  def semigroup[F[_], A](implicit F: Align[F], A: Semigroup[A]): Semigroup[F[A]] =
+    new Semigroup[F[A]] {
+      def combine(x: F[A], y: F[A]): F[A] = Align[F].alignCombine(x, y)
+    }
 
   implicit def catsAlignForList: Align[List] = cats.instances.list.catsStdInstancesForList
   implicit def catsAlignForOption: Align[Option] = cats.instances.option.catsStdInstancesForOption
@@ -132,12 +133,13 @@ object Align extends ScalaVersionSpecificAlignInstances {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Align]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Align[F]): Align[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Align[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -150,24 +152,26 @@ object Align extends ScalaVersionSpecificAlignInstances {
     def zipAll[B](fb: F[B], a: A, b: B): F[(A, B)] = typeClassInstance.zipAll[A, B](self, fb, a, b)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToAlignOps {
+  trait ToAlignOps extends Serializable {
     implicit def toAlignOps[F[_], A](target: F[A])(implicit tc: Align[F]): Ops[F, A] {
       type TypeClassType = Align[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Align[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Align[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToAlignOps
   object ops {
     implicit def toAllAlignOps[F[_], A](target: F[A])(implicit tc: Align[F]): AllOps[F, A] {
       type TypeClassType = Align[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Align[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Align[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Alternative.scala b/core/src/main/scala/cats/Alternative.scala
index 3068c9fbd..388e1fc72 100644
--- a/core/src/main/scala/cats/Alternative.scala
+++ b/core/src/main/scala/cats/Alternative.scala
@@ -95,12 +95,13 @@ object Alternative {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Alternative]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Alternative[F]): Alternative[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Alternative[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -114,24 +115,26 @@ object Alternative {
   trait AllOps[F[_], A] extends Ops[F, A] with Applicative.AllOps[F, A] with MonoidK.AllOps[F, A] {
     type TypeClassType <: Alternative[F]
   }
-  trait ToAlternativeOps {
+  trait ToAlternativeOps extends Serializable {
     implicit def toAlternativeOps[F[_], A](target: F[A])(implicit tc: Alternative[F]): Ops[F, A] {
       type TypeClassType = Alternative[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Alternative[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Alternative[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToAlternativeOps
   object ops {
     implicit def toAllAlternativeOps[F[_], A](target: F[A])(implicit tc: Alternative[F]): AllOps[F, A] {
       type TypeClassType = Alternative[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Alternative[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Alternative[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Applicative.scala b/core/src/main/scala/cats/Applicative.scala
index 9501c676e..578159b15 100644
--- a/core/src/main/scala/cats/Applicative.scala
+++ b/core/src/main/scala/cats/Applicative.scala
@@ -233,12 +233,13 @@ object Applicative {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Applicative]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Applicative[F]): Applicative[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Applicative[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -246,24 +247,26 @@ object Applicative {
   trait AllOps[F[_], A] extends Ops[F, A] with Apply.AllOps[F, A] with InvariantMonoidal.AllOps[F, A] {
     type TypeClassType <: Applicative[F]
   }
-  trait ToApplicativeOps {
+  trait ToApplicativeOps extends Serializable {
     implicit def toApplicativeOps[F[_], A](target: F[A])(implicit tc: Applicative[F]): Ops[F, A] {
       type TypeClassType = Applicative[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Applicative[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Applicative[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToApplicativeOps
   object ops {
     implicit def toAllApplicativeOps[F[_], A](target: F[A])(implicit tc: Applicative[F]): AllOps[F, A] {
       type TypeClassType = Applicative[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Applicative[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Applicative[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Apply.scala b/core/src/main/scala/cats/Apply.scala
index db0f042d7..e92d9e66e 100644
--- a/core/src/main/scala/cats/Apply.scala
+++ b/core/src/main/scala/cats/Apply.scala
@@ -261,20 +261,22 @@ object Apply {
   def semigroup[F[_], A](implicit f: Apply[F], sg: Semigroup[A]): Semigroup[F[A]] =
     new ApplySemigroup[F, A](f, sg)
 
-  def align[F[_]: Apply]: Align[F] = new Align[F] {
-    def align[A, B](fa: F[A], fb: F[B]): F[Ior[A, B]] = Apply[F].map2(fa, fb)(Ior.both)
-    def functor: Functor[F] = Apply[F]
-  }
+  def align[F[_]: Apply]: Align[F] =
+    new Align[F] {
+      def align[A, B](fa: F[A], fb: F[B]): F[Ior[A, B]] = Apply[F].map2(fa, fb)(Ior.both)
+      def functor: Functor[F] = Apply[F]
+    }
 
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Apply]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Apply[F]): Apply[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Apply[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -294,24 +296,26 @@ object Apply {
   trait AllOps[F[_], A] extends Ops[F, A] with Functor.AllOps[F, A] with InvariantSemigroupal.AllOps[F, A] {
     type TypeClassType <: Apply[F]
   }
-  trait ToApplyOps {
+  trait ToApplyOps extends Serializable {
     implicit def toApplyOps[F[_], A](target: F[A])(implicit tc: Apply[F]): Ops[F, A] {
       type TypeClassType = Apply[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Apply[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Apply[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToApplyOps
   object ops {
     implicit def toAllApplyOps[F[_], A](target: F[A])(implicit tc: Apply[F]): AllOps[F, A] {
       type TypeClassType = Apply[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Apply[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Apply[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Bifoldable.scala b/core/src/main/scala/cats/Bifoldable.scala
index 528a49f18..105df3ddc 100644
--- a/core/src/main/scala/cats/Bifoldable.scala
+++ b/core/src/main/scala/cats/Bifoldable.scala
@@ -41,12 +41,13 @@ object Bifoldable {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Bifoldable]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Bifoldable[F]): Bifoldable[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: Bifoldable[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -58,24 +59,26 @@ object Bifoldable {
     def bifold(implicit A: Monoid[A], B: Monoid[B]): (A, B) = typeClassInstance.bifold[A, B](self)(A, B)
   }
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B]
-  trait ToBifoldableOps {
+  trait ToBifoldableOps extends Serializable {
     implicit def toBifoldableOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bifoldable[F]): Ops[F, A, B] {
       type TypeClassType = Bifoldable[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = Bifoldable[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = Bifoldable[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToBifoldableOps
   object ops {
     implicit def toAllBifoldableOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bifoldable[F]): AllOps[F, A, B] {
       type TypeClassType = Bifoldable[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = Bifoldable[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = Bifoldable[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
@@ -94,8 +97,9 @@ private[cats] trait ComposedBifoldable[F[_, _], G[_, _]] extends Bifoldable[Î»[(
       (c: C, gab: G[A, B]) => G.bifoldLeft(gab, c)(f, g)
     )
 
-  override def bifoldRight[A, B, C](fab: F[G[A, B], G[A, B]], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
-                                                                          g: (B, Eval[C]) => Eval[C]): Eval[C] =
+  override def bifoldRight[A, B, C](fab: F[G[A, B], G[A, B]],
+                                    c: Eval[C]
+  )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
     F.bifoldRight(fab, c)(
       (gab: G[A, B], c: Eval[C]) => G.bifoldRight(gab, c)(f, g),
       (gab: G[A, B], c: Eval[C]) => G.bifoldRight(gab, c)(f, g)
diff --git a/core/src/main/scala/cats/Bifunctor.scala b/core/src/main/scala/cats/Bifunctor.scala
index 83f1e54c1..d613a512c 100644
--- a/core/src/main/scala/cats/Bifunctor.scala
+++ b/core/src/main/scala/cats/Bifunctor.scala
@@ -64,12 +64,13 @@ object Bifunctor {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Bifunctor]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Bifunctor[F]): Bifunctor[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: Bifunctor[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -78,24 +79,26 @@ object Bifunctor {
     def leftWiden[C >: A]: F[C, B] = typeClassInstance.leftWiden[A, B, C](self)
   }
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B]
-  trait ToBifunctorOps {
+  trait ToBifunctorOps extends Serializable {
     implicit def toBifunctorOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bifunctor[F]): Ops[F, A, B] {
       type TypeClassType = Bifunctor[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = Bifunctor[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = Bifunctor[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToBifunctorOps
   object ops {
     implicit def toAllBifunctorOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bifunctor[F]): AllOps[F, A, B] {
       type TypeClassType = Bifunctor[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = Bifunctor[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = Bifunctor[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Bimonad.scala b/core/src/main/scala/cats/Bimonad.scala
index b41df55c5..9f40732de 100644
--- a/core/src/main/scala/cats/Bimonad.scala
+++ b/core/src/main/scala/cats/Bimonad.scala
@@ -11,12 +11,13 @@ object Bimonad {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Bimonad]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Bimonad[F]): Bimonad[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Bimonad[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -24,24 +25,26 @@ object Bimonad {
   trait AllOps[F[_], A] extends Ops[F, A] with Monad.AllOps[F, A] with Comonad.AllOps[F, A] {
     type TypeClassType <: Bimonad[F]
   }
-  trait ToBimonadOps {
+  trait ToBimonadOps extends Serializable {
     implicit def toBimonadOps[F[_], A](target: F[A])(implicit tc: Bimonad[F]): Ops[F, A] {
       type TypeClassType = Bimonad[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Bimonad[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Bimonad[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToBimonadOps
   object ops {
     implicit def toAllBimonadOps[F[_], A](target: F[A])(implicit tc: Bimonad[F]): AllOps[F, A] {
       type TypeClassType = Bimonad[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Bimonad[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Bimonad[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Bitraverse.scala b/core/src/main/scala/cats/Bitraverse.scala
index 5eda74313..630a059af 100644
--- a/core/src/main/scala/cats/Bitraverse.scala
+++ b/core/src/main/scala/cats/Bitraverse.scala
@@ -116,12 +116,13 @@ object Bitraverse {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Bitraverse]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Bitraverse[F]): Bitraverse[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: Bitraverse[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -133,24 +134,26 @@ object Bitraverse {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Bifoldable.AllOps[F, A, B] with Bifunctor.AllOps[F, A, B] {
     type TypeClassType <: Bitraverse[F]
   }
-  trait ToBitraverseOps {
+  trait ToBitraverseOps extends Serializable {
     implicit def toBitraverseOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bitraverse[F]): Ops[F, A, B] {
       type TypeClassType = Bitraverse[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = Bitraverse[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = Bitraverse[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToBitraverseOps
   object ops {
     implicit def toAllBitraverseOps[F[_, _], A, B](target: F[A, B])(implicit tc: Bitraverse[F]): AllOps[F, A, B] {
       type TypeClassType = Bitraverse[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = Bitraverse[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = Bitraverse[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CoflatMap.scala b/core/src/main/scala/cats/CoflatMap.scala
index 59645bac7..653cc0c39 100644
--- a/core/src/main/scala/cats/CoflatMap.scala
+++ b/core/src/main/scala/cats/CoflatMap.scala
@@ -53,12 +53,13 @@ object CoflatMap {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[CoflatMap]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CoflatMap[F]): CoflatMap[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: CoflatMap[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -68,24 +69,26 @@ object CoflatMap {
   trait AllOps[F[_], A] extends Ops[F, A] with Functor.AllOps[F, A] {
     type TypeClassType <: CoflatMap[F]
   }
-  trait ToCoflatMapOps {
+  trait ToCoflatMapOps extends Serializable {
     implicit def toCoflatMapOps[F[_], A](target: F[A])(implicit tc: CoflatMap[F]): Ops[F, A] {
       type TypeClassType = CoflatMap[F]
-    } = new Ops[F, A] {
-      type TypeClassType = CoflatMap[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = CoflatMap[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToCoflatMapOps
   object ops {
     implicit def toAllCoflatMapOps[F[_], A](target: F[A])(implicit tc: CoflatMap[F]): AllOps[F, A] {
       type TypeClassType = CoflatMap[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = CoflatMap[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = CoflatMap[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CommutativeApplicative.scala b/core/src/main/scala/cats/CommutativeApplicative.scala
index 26bc936ec..57bb502c0 100644
--- a/core/src/main/scala/cats/CommutativeApplicative.scala
+++ b/core/src/main/scala/cats/CommutativeApplicative.scala
@@ -31,12 +31,13 @@ object CommutativeApplicative {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[CommutativeApplicative]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CommutativeApplicative[F]): CommutativeApplicative[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: CommutativeApplicative[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -44,14 +45,15 @@ object CommutativeApplicative {
   trait AllOps[F[_], A] extends Ops[F, A] with Applicative.AllOps[F, A] with CommutativeApply.AllOps[F, A] {
     type TypeClassType <: CommutativeApplicative[F]
   }
-  trait ToCommutativeApplicativeOps {
+  trait ToCommutativeApplicativeOps extends Serializable {
     implicit def toCommutativeApplicativeOps[F[_], A](target: F[A])(implicit tc: CommutativeApplicative[F]): Ops[F, A] {
       type TypeClassType = CommutativeApplicative[F]
-    } = new Ops[F, A] {
-      type TypeClassType = CommutativeApplicative[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = CommutativeApplicative[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToCommutativeApplicativeOps
   object ops {
@@ -59,11 +61,12 @@ object CommutativeApplicative {
       target: F[A]
     )(implicit tc: CommutativeApplicative[F]): AllOps[F, A] {
       type TypeClassType = CommutativeApplicative[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = CommutativeApplicative[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = CommutativeApplicative[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CommutativeApply.scala b/core/src/main/scala/cats/CommutativeApply.scala
index 65a30e905..9c27cbc1f 100644
--- a/core/src/main/scala/cats/CommutativeApply.scala
+++ b/core/src/main/scala/cats/CommutativeApply.scala
@@ -27,12 +27,13 @@ object CommutativeApply {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[CommutativeApply]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CommutativeApply[F]): CommutativeApply[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: CommutativeApply[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -40,24 +41,26 @@ object CommutativeApply {
   trait AllOps[F[_], A] extends Ops[F, A] with Apply.AllOps[F, A] {
     type TypeClassType <: CommutativeApply[F]
   }
-  trait ToCommutativeApplyOps {
+  trait ToCommutativeApplyOps extends Serializable {
     implicit def toCommutativeApplyOps[F[_], A](target: F[A])(implicit tc: CommutativeApply[F]): Ops[F, A] {
       type TypeClassType = CommutativeApply[F]
-    } = new Ops[F, A] {
-      type TypeClassType = CommutativeApply[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = CommutativeApply[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToCommutativeApplyOps
   object ops {
     implicit def toAllCommutativeApplyOps[F[_], A](target: F[A])(implicit tc: CommutativeApply[F]): AllOps[F, A] {
       type TypeClassType = CommutativeApply[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = CommutativeApply[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = CommutativeApply[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CommutativeFlatMap.scala b/core/src/main/scala/cats/CommutativeFlatMap.scala
index 860054dc4..d595bcd8c 100644
--- a/core/src/main/scala/cats/CommutativeFlatMap.scala
+++ b/core/src/main/scala/cats/CommutativeFlatMap.scala
@@ -20,12 +20,13 @@ object CommutativeFlatMap {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[CommutativeFlatMap]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CommutativeFlatMap[F]): CommutativeFlatMap[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: CommutativeFlatMap[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -33,24 +34,26 @@ object CommutativeFlatMap {
   trait AllOps[F[_], A] extends Ops[F, A] with FlatMap.AllOps[F, A] with CommutativeApply.AllOps[F, A] {
     type TypeClassType <: CommutativeFlatMap[F]
   }
-  trait ToCommutativeFlatMapOps {
+  trait ToCommutativeFlatMapOps extends Serializable {
     implicit def toCommutativeFlatMapOps[F[_], A](target: F[A])(implicit tc: CommutativeFlatMap[F]): Ops[F, A] {
       type TypeClassType = CommutativeFlatMap[F]
-    } = new Ops[F, A] {
-      type TypeClassType = CommutativeFlatMap[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = CommutativeFlatMap[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToCommutativeFlatMapOps
   object ops {
     implicit def toAllCommutativeFlatMapOps[F[_], A](target: F[A])(implicit tc: CommutativeFlatMap[F]): AllOps[F, A] {
       type TypeClassType = CommutativeFlatMap[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = CommutativeFlatMap[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = CommutativeFlatMap[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/CommutativeMonad.scala b/core/src/main/scala/cats/CommutativeMonad.scala
index 8e3258d05..301b641f3 100644
--- a/core/src/main/scala/cats/CommutativeMonad.scala
+++ b/core/src/main/scala/cats/CommutativeMonad.scala
@@ -20,12 +20,13 @@ object CommutativeMonad {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[CommutativeMonad]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: CommutativeMonad[F]): CommutativeMonad[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: CommutativeMonad[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -37,24 +38,26 @@ object CommutativeMonad {
       with CommutativeApplicative.AllOps[F, A] {
     type TypeClassType <: CommutativeMonad[F]
   }
-  trait ToCommutativeMonadOps {
+  trait ToCommutativeMonadOps extends Serializable {
     implicit def toCommutativeMonadOps[F[_], A](target: F[A])(implicit tc: CommutativeMonad[F]): Ops[F, A] {
       type TypeClassType = CommutativeMonad[F]
-    } = new Ops[F, A] {
-      type TypeClassType = CommutativeMonad[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = CommutativeMonad[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToCommutativeMonadOps
   object ops {
     implicit def toAllCommutativeMonadOps[F[_], A](target: F[A])(implicit tc: CommutativeMonad[F]): AllOps[F, A] {
       type TypeClassType = CommutativeMonad[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = CommutativeMonad[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = CommutativeMonad[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Comonad.scala b/core/src/main/scala/cats/Comonad.scala
index df2ed898b..6ac0323ac 100644
--- a/core/src/main/scala/cats/Comonad.scala
+++ b/core/src/main/scala/cats/Comonad.scala
@@ -35,12 +35,13 @@ object Comonad {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Comonad]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Comonad[F]): Comonad[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Comonad[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -49,24 +50,26 @@ object Comonad {
   trait AllOps[F[_], A] extends Ops[F, A] with CoflatMap.AllOps[F, A] {
     type TypeClassType <: Comonad[F]
   }
-  trait ToComonadOps {
+  trait ToComonadOps extends Serializable {
     implicit def toComonadOps[F[_], A](target: F[A])(implicit tc: Comonad[F]): Ops[F, A] {
       type TypeClassType = Comonad[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Comonad[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Comonad[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToComonadOps
   object ops {
     implicit def toAllComonadOps[F[_], A](target: F[A])(implicit tc: Comonad[F]): AllOps[F, A] {
       type TypeClassType = Comonad[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Comonad[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Comonad[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Composed.scala b/core/src/main/scala/cats/Composed.scala
index ec3b4f22d..730619f52 100644
--- a/core/src/main/scala/cats/Composed.scala
+++ b/core/src/main/scala/cats/Composed.scala
@@ -50,7 +50,8 @@ private[cats] trait ComposedSemigroupK[F[_], G[_]] extends SemigroupK[Î»[Î± => F
   override def combineK[A](x: F[G[A]], y: F[G[A]]): F[G[A]] = F.combineK(x, y)
 }
 
-private[cats] trait ComposedMonoidK[F[_], G[_]] extends MonoidK[Î»[Î± => F[G[Î±]]]] with ComposedSemigroupK[F, G] { outer =>
+private[cats] trait ComposedMonoidK[F[_], G[_]] extends MonoidK[Î»[Î± => F[G[Î±]]]] with ComposedSemigroupK[F, G] {
+  outer =>
   def F: MonoidK[F]
 
   override def empty[A]: F[G[A]] = F.empty
@@ -96,7 +97,8 @@ private[cats] trait ComposedNonEmptyTraverse[F[_], G[_]]
     F.nonEmptyTraverse(fga)(ga => G.nonEmptyTraverse(ga)(f))
 }
 
-private[cats] trait ComposedReducible[F[_], G[_]] extends Reducible[Î»[Î± => F[G[Î±]]]] with ComposedFoldable[F, G] { outer =>
+private[cats] trait ComposedReducible[F[_], G[_]] extends Reducible[Î»[Î± => F[G[Î±]]]] with ComposedFoldable[F, G] {
+  outer =>
   def F: Reducible[F]
   def G: Reducible[G]
 
diff --git a/core/src/main/scala/cats/Contravariant.scala b/core/src/main/scala/cats/Contravariant.scala
index 14c431836..2734d6581 100644
--- a/core/src/main/scala/cats/Contravariant.scala
+++ b/core/src/main/scala/cats/Contravariant.scala
@@ -36,12 +36,13 @@ object Contravariant {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Contravariant]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Contravariant[F]): Contravariant[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Contravariant[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -51,24 +52,26 @@ object Contravariant {
   trait AllOps[F[_], A] extends Ops[F, A] with Invariant.AllOps[F, A] {
     type TypeClassType <: Contravariant[F]
   }
-  trait ToContravariantOps {
+  trait ToContravariantOps extends Serializable {
     implicit def toContravariantOps[F[_], A](target: F[A])(implicit tc: Contravariant[F]): Ops[F, A] {
       type TypeClassType = Contravariant[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Contravariant[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Contravariant[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToContravariantOps
   object ops {
     implicit def toAllContravariantOps[F[_], A](target: F[A])(implicit tc: Contravariant[F]): AllOps[F, A] {
       type TypeClassType = Contravariant[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Contravariant[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Contravariant[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/ContravariantMonoidal.scala b/core/src/main/scala/cats/ContravariantMonoidal.scala
index b6f6e84be..98952f6e9 100644
--- a/core/src/main/scala/cats/ContravariantMonoidal.scala
+++ b/core/src/main/scala/cats/ContravariantMonoidal.scala
@@ -30,12 +30,13 @@ object ContravariantMonoidal extends SemigroupalArityFunctions {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[ContravariantMonoidal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: ContravariantMonoidal[F]): ContravariantMonoidal[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: ContravariantMonoidal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -46,14 +47,15 @@ object ContravariantMonoidal extends SemigroupalArityFunctions {
       with InvariantMonoidal.AllOps[F, A] {
     type TypeClassType <: ContravariantMonoidal[F]
   }
-  trait ToContravariantMonoidalOps {
+  trait ToContravariantMonoidalOps extends Serializable {
     implicit def toContravariantMonoidalOps[F[_], A](target: F[A])(implicit tc: ContravariantMonoidal[F]): Ops[F, A] {
       type TypeClassType = ContravariantMonoidal[F]
-    } = new Ops[F, A] {
-      type TypeClassType = ContravariantMonoidal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = ContravariantMonoidal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToContravariantMonoidalOps
   object ops {
@@ -61,11 +63,12 @@ object ContravariantMonoidal extends SemigroupalArityFunctions {
       target: F[A]
     )(implicit tc: ContravariantMonoidal[F]): AllOps[F, A] {
       type TypeClassType = ContravariantMonoidal[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = ContravariantMonoidal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = ContravariantMonoidal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/ContravariantSemigroupal.scala b/core/src/main/scala/cats/ContravariantSemigroupal.scala
index b2b834ed7..347d79a15 100644
--- a/core/src/main/scala/cats/ContravariantSemigroupal.scala
+++ b/core/src/main/scala/cats/ContravariantSemigroupal.scala
@@ -24,12 +24,13 @@ object ContravariantSemigroupal extends SemigroupalArityFunctions {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[ContravariantSemigroupal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: ContravariantSemigroupal[F]): ContravariantSemigroupal[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: ContravariantSemigroupal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -37,16 +38,17 @@ object ContravariantSemigroupal extends SemigroupalArityFunctions {
   trait AllOps[F[_], A] extends Ops[F, A] with InvariantSemigroupal.AllOps[F, A] with Contravariant.AllOps[F, A] {
     type TypeClassType <: ContravariantSemigroupal[F]
   }
-  trait ToContravariantSemigroupalOps {
+  trait ToContravariantSemigroupalOps extends Serializable {
     implicit def toContravariantSemigroupalOps[F[_], A](
       target: F[A]
     )(implicit tc: ContravariantSemigroupal[F]): Ops[F, A] {
       type TypeClassType = ContravariantSemigroupal[F]
-    } = new Ops[F, A] {
-      type TypeClassType = ContravariantSemigroupal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = ContravariantSemigroupal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToContravariantSemigroupalOps
   object ops {
@@ -54,11 +56,12 @@ object ContravariantSemigroupal extends SemigroupalArityFunctions {
       target: F[A]
     )(implicit tc: ContravariantSemigroupal[F]): AllOps[F, A] {
       type TypeClassType = ContravariantSemigroupal[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = ContravariantSemigroupal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = ContravariantSemigroupal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Distributive.scala b/core/src/main/scala/cats/Distributive.scala
index a6694acba..0f548e0d7 100644
--- a/core/src/main/scala/cats/Distributive.scala
+++ b/core/src/main/scala/cats/Distributive.scala
@@ -28,12 +28,13 @@ object Distributive {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Distributive]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Distributive[F]): Distributive[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Distributive[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -41,24 +42,26 @@ object Distributive {
   trait AllOps[F[_], A] extends Ops[F, A] with Functor.AllOps[F, A] {
     type TypeClassType <: Distributive[F]
   }
-  trait ToDistributiveOps {
+  trait ToDistributiveOps extends Serializable {
     implicit def toDistributiveOps[F[_], A](target: F[A])(implicit tc: Distributive[F]): Ops[F, A] {
       type TypeClassType = Distributive[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Distributive[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Distributive[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToDistributiveOps
   object ops {
     implicit def toAllDistributiveOps[F[_], A](target: F[A])(implicit tc: Distributive[F]): AllOps[F, A] {
       type TypeClassType = Distributive[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Distributive[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Distributive[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/FlatMap.scala b/core/src/main/scala/cats/FlatMap.scala
index 28ecb7ae5..fbb49c643 100644
--- a/core/src/main/scala/cats/FlatMap.scala
+++ b/core/src/main/scala/cats/FlatMap.scala
@@ -205,12 +205,13 @@ object FlatMap {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[FlatMap]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: FlatMap[F]): FlatMap[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: FlatMap[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -224,24 +225,26 @@ object FlatMap {
   trait AllOps[F[_], A] extends Ops[F, A] with Apply.AllOps[F, A] {
     type TypeClassType <: FlatMap[F]
   }
-  trait ToFlatMapOps {
+  trait ToFlatMapOps extends Serializable {
     implicit def toFlatMapOps[F[_], A](target: F[A])(implicit tc: FlatMap[F]): Ops[F, A] {
       type TypeClassType = FlatMap[F]
-    } = new Ops[F, A] {
-      type TypeClassType = FlatMap[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = FlatMap[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToFlatMapOps
   object ops {
     implicit def toAllFlatMapOps[F[_], A](target: F[A])(implicit tc: FlatMap[F]): AllOps[F, A] {
       type TypeClassType = FlatMap[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = FlatMap[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = FlatMap[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Foldable.scala b/core/src/main/scala/cats/Foldable.scala
index 246f913d4..0b7cddcb9 100644
--- a/core/src/main/scala/cats/Foldable.scala
+++ b/core/src/main/scala/cats/Foldable.scala
@@ -799,8 +799,9 @@ import scala.annotation.implicitNotFound
    * }}}
    */
   @noop
-  def partitionBifold[H[_, _], A, B, C](fa: F[A])(f: A => H[B, C])(implicit A: Alternative[F],
-                                                                   H: Bifoldable[H]): (F[B], F[C]) = {
+  def partitionBifold[H[_, _], A, B, C](
+    fa: F[A]
+  )(f: A => H[B, C])(implicit A: Alternative[F], H: Bifoldable[H]): (F[B], F[C]) = {
     import cats.instances.tuple._
 
     implicit val mb: Monoid[F[B]] = A.algebra[B]
@@ -856,8 +857,9 @@ import scala.annotation.implicitNotFound
    * }}}
    */
   @noop
-  def partitionEitherM[G[_], A, B, C](fa: F[A])(f: A => G[Either[B, C]])(implicit A: Alternative[F],
-                                                                         M: Monad[G]): G[(F[B], F[C])] = {
+  def partitionEitherM[G[_], A, B, C](
+    fa: F[A]
+  )(f: A => G[Either[B, C]])(implicit A: Alternative[F], M: Monad[G]): G[(F[B], F[C])] = {
     import cats.instances.either._
     partitionBifoldM[G, Either, A, B, C](fa)(f)(A, M, Bifoldable[Either])
   }
@@ -899,9 +901,10 @@ object Foldable {
       def uncons = None
     }
 
-    def cons[A](a: A, src: Eval[Source[A]]): Source[A] = new Source[A] {
-      def uncons = Some((a, src))
-    }
+    def cons[A](a: A, src: Eval[Source[A]]): Source[A] =
+      new Source[A] {
+        def uncons = Some((a, src))
+      }
 
     def fromFoldable[F[_], A](fa: F[A])(implicit F: Foldable[F]): Source[A] =
       F.foldRight[A, Source[A]](fa, Now(Empty))((a, evalSrc) => Later(cons(a, evalSrc))).value
@@ -910,12 +913,13 @@ object Foldable {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Foldable]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Foldable[F]): Foldable[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Foldable[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -975,24 +979,26 @@ object Foldable {
   trait AllOps[F[_], A] extends Ops[F, A] with UnorderedFoldable.AllOps[F, A] {
     type TypeClassType <: Foldable[F]
   }
-  trait ToFoldableOps {
+  trait ToFoldableOps extends Serializable {
     implicit def toFoldableOps[F[_], A](target: F[A])(implicit tc: Foldable[F]): Ops[F, A] {
       type TypeClassType = Foldable[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Foldable[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Foldable[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToFoldableOps
   object ops {
     implicit def toAllFoldableOps[F[_], A](target: F[A])(implicit tc: Foldable[F]): AllOps[F, A] {
       type TypeClassType = Foldable[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Foldable[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Foldable[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Functor.scala b/core/src/main/scala/cats/Functor.scala
index 39a3af229..d3c04e4bb 100644
--- a/core/src/main/scala/cats/Functor.scala
+++ b/core/src/main/scala/cats/Functor.scala
@@ -210,12 +210,13 @@ object Functor {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Functor]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Functor[F]): Functor[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Functor[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -232,24 +233,26 @@ object Functor {
   trait AllOps[F[_], A] extends Ops[F, A] with Invariant.AllOps[F, A] {
     type TypeClassType <: Functor[F]
   }
-  trait ToFunctorOps {
+  trait ToFunctorOps extends Serializable {
     implicit def toFunctorOps[F[_], A](target: F[A])(implicit tc: Functor[F]): Ops[F, A] {
       type TypeClassType = Functor[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Functor[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Functor[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToFunctorOps
   object ops {
     implicit def toAllFunctorOps[F[_], A](target: F[A])(implicit tc: Functor[F]): AllOps[F, A] {
       type TypeClassType = Functor[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Functor[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Functor[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/FunctorFilter.scala b/core/src/main/scala/cats/FunctorFilter.scala
index de5ca15a3..16751d534 100644
--- a/core/src/main/scala/cats/FunctorFilter.scala
+++ b/core/src/main/scala/cats/FunctorFilter.scala
@@ -94,12 +94,13 @@ object FunctorFilter extends ScalaVersionSpecificTraverseFilterInstances {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[FunctorFilter]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: FunctorFilter[F]): FunctorFilter[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: FunctorFilter[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -111,24 +112,26 @@ object FunctorFilter extends ScalaVersionSpecificTraverseFilterInstances {
     def filterNot(f: A => Boolean): F[A] = typeClassInstance.filterNot[A](self)(f)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToFunctorFilterOps {
+  trait ToFunctorFilterOps extends Serializable {
     implicit def toFunctorFilterOps[F[_], A](target: F[A])(implicit tc: FunctorFilter[F]): Ops[F, A] {
       type TypeClassType = FunctorFilter[F]
-    } = new Ops[F, A] {
-      type TypeClassType = FunctorFilter[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = FunctorFilter[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToFunctorFilterOps
   object ops {
     implicit def toAllFunctorFilterOps[F[_], A](target: F[A])(implicit tc: FunctorFilter[F]): AllOps[F, A] {
       type TypeClassType = FunctorFilter[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = FunctorFilter[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = FunctorFilter[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Invariant.scala b/core/src/main/scala/cats/Invariant.scala
index 0f5c77b65..09a0e0405 100644
--- a/core/src/main/scala/cats/Invariant.scala
+++ b/core/src/main/scala/cats/Invariant.scala
@@ -102,113 +102,123 @@ object Invariant extends ScalaVersionSpecificInvariantInstances with InvariantIn
 
   implicit val catsInvariantMonoid: Invariant[Monoid] = new Invariant[Monoid] {
 
-    def imap[A, B](fa: Monoid[A])(f: A => B)(g: B => A): Monoid[B] = new Monoid[B] {
-      val empty = f(fa.empty)
-      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
-    }
+    def imap[A, B](fa: Monoid[A])(f: A => B)(g: B => A): Monoid[B] =
+      new Monoid[B] {
+        val empty = f(fa.empty)
+        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+          fa.combineAllOption(bs.iterator.map(g)).map(f)
+      }
 
   }
 
   implicit val catsInvariantBand: Invariant[Band] = new Invariant[Band] {
 
-    def imap[A, B](fa: Band[A])(f: A => B)(g: B => A): Band[B] = new Band[B] {
-      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
-    }
+    def imap[A, B](fa: Band[A])(f: A => B)(g: B => A): Band[B] =
+      new Band[B] {
+        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+          fa.combineAllOption(bs.iterator.map(g)).map(f)
+      }
   }
 
   implicit val catsInvariantSemilattice: Invariant[Semilattice] = new Invariant[Semilattice] {
 
-    def imap[A, B](fa: Semilattice[A])(f: A => B)(g: B => A): Semilattice[B] = new Semilattice[B] {
-      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
-    }
+    def imap[A, B](fa: Semilattice[A])(f: A => B)(g: B => A): Semilattice[B] =
+      new Semilattice[B] {
+        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+          fa.combineAllOption(bs.iterator.map(g)).map(f)
+      }
 
   }
 
   implicit val catsInvariantCommutativeMonoid: Invariant[CommutativeMonoid] = new Invariant[CommutativeMonoid] {
 
-    def imap[A, B](fa: CommutativeMonoid[A])(f: A => B)(g: B => A): CommutativeMonoid[B] = new CommutativeMonoid[B] {
-      val empty = f(fa.empty)
-      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
-    }
+    def imap[A, B](fa: CommutativeMonoid[A])(f: A => B)(g: B => A): CommutativeMonoid[B] =
+      new CommutativeMonoid[B] {
+        val empty = f(fa.empty)
+        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+          fa.combineAllOption(bs.iterator.map(g)).map(f)
+      }
 
   }
 
   implicit val catsInvariantBoundedSemilattice: Invariant[BoundedSemilattice] = new Invariant[BoundedSemilattice] {
 
-    def imap[A, B](fa: BoundedSemilattice[A])(f: A => B)(g: B => A): BoundedSemilattice[B] = new BoundedSemilattice[B] {
-      val empty = f(fa.empty)
-      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
-    }
+    def imap[A, B](fa: BoundedSemilattice[A])(f: A => B)(g: B => A): BoundedSemilattice[B] =
+      new BoundedSemilattice[B] {
+        val empty = f(fa.empty)
+        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+          fa.combineAllOption(bs.iterator.map(g)).map(f)
+      }
 
   }
 
   implicit val catsInvariantGroup: Invariant[Group] = new Invariant[Group] {
 
-    def imap[A, B](fa: Group[A])(f: A => B)(g: B => A): Group[B] = new Group[B] {
-      val empty = f(fa.empty)
-      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      def inverse(b: B): B = f(fa.inverse(g(b)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
-    }
+    def imap[A, B](fa: Group[A])(f: A => B)(g: B => A): Group[B] =
+      new Group[B] {
+        val empty = f(fa.empty)
+        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+        def inverse(b: B): B = f(fa.inverse(g(b)))
+        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+          fa.combineAllOption(bs.iterator.map(g)).map(f)
+      }
 
   }
 
   implicit val catsInvariantCommutativeGroup: Invariant[CommutativeGroup] = new Invariant[CommutativeGroup] {
 
-    def imap[A, B](fa: CommutativeGroup[A])(f: A => B)(g: B => A): CommutativeGroup[B] = new CommutativeGroup[B] {
-      val empty = f(fa.empty)
-      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-      def inverse(b: B): B = f(fa.inverse(g(b)))
-      override def combineAllOption(bs: IterableOnce[B]): Option[B] =
-        fa.combineAllOption(bs.iterator.map(g)).map(f)
-    }
+    def imap[A, B](fa: CommutativeGroup[A])(f: A => B)(g: B => A): CommutativeGroup[B] =
+      new CommutativeGroup[B] {
+        val empty = f(fa.empty)
+        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+        def inverse(b: B): B = f(fa.inverse(g(b)))
+        override def combineAllOption(bs: IterableOnce[B]): Option[B] =
+          fa.combineAllOption(bs.iterator.map(g)).map(f)
+      }
 
   }
 
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Invariant]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Invariant[F]): Invariant[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Invariant[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
     def imap[B](f: A => B)(g: B => A): F[B] = typeClassInstance.imap[A, B](self)(f)(g)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToInvariantOps {
+  trait ToInvariantOps extends Serializable {
     implicit def toInvariantOps[F[_], A](target: F[A])(implicit tc: Invariant[F]): Ops[F, A] {
       type TypeClassType = Invariant[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Invariant[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Invariant[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToInvariantOps
   object ops {
     implicit def toAllInvariantOps[F[_], A](target: F[A])(implicit tc: Invariant[F]): AllOps[F, A] {
       type TypeClassType = Invariant[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Invariant[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Invariant[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/InvariantMonoidal.scala b/core/src/main/scala/cats/InvariantMonoidal.scala
index c4de33c58..14bc382df 100644
--- a/core/src/main/scala/cats/InvariantMonoidal.scala
+++ b/core/src/main/scala/cats/InvariantMonoidal.scala
@@ -39,12 +39,13 @@ object InvariantMonoidal {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[InvariantMonoidal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: InvariantMonoidal[F]): InvariantMonoidal[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: InvariantMonoidal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -52,24 +53,26 @@ object InvariantMonoidal {
   trait AllOps[F[_], A] extends Ops[F, A] with InvariantSemigroupal.AllOps[F, A] {
     type TypeClassType <: InvariantMonoidal[F]
   }
-  trait ToInvariantMonoidalOps {
+  trait ToInvariantMonoidalOps extends Serializable {
     implicit def toInvariantMonoidalOps[F[_], A](target: F[A])(implicit tc: InvariantMonoidal[F]): Ops[F, A] {
       type TypeClassType = InvariantMonoidal[F]
-    } = new Ops[F, A] {
-      type TypeClassType = InvariantMonoidal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = InvariantMonoidal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToInvariantMonoidalOps
   object ops {
     implicit def toAllInvariantMonoidalOps[F[_], A](target: F[A])(implicit tc: InvariantMonoidal[F]): AllOps[F, A] {
       type TypeClassType = InvariantMonoidal[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = InvariantMonoidal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = InvariantMonoidal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/InvariantSemigroupal.scala b/core/src/main/scala/cats/InvariantSemigroupal.scala
index da4cd323a..c47005c51 100644
--- a/core/src/main/scala/cats/InvariantSemigroupal.scala
+++ b/core/src/main/scala/cats/InvariantSemigroupal.scala
@@ -29,12 +29,13 @@ object InvariantSemigroupal extends SemigroupalArityFunctions {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[InvariantSemigroupal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: InvariantSemigroupal[F]): InvariantSemigroupal[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: InvariantSemigroupal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -42,14 +43,15 @@ object InvariantSemigroupal extends SemigroupalArityFunctions {
   trait AllOps[F[_], A] extends Ops[F, A] with Semigroupal.AllOps[F, A] with Invariant.AllOps[F, A] {
     type TypeClassType <: InvariantSemigroupal[F]
   }
-  trait ToInvariantSemigroupalOps {
+  trait ToInvariantSemigroupalOps extends Serializable {
     implicit def toInvariantSemigroupalOps[F[_], A](target: F[A])(implicit tc: InvariantSemigroupal[F]): Ops[F, A] {
       type TypeClassType = InvariantSemigroupal[F]
-    } = new Ops[F, A] {
-      type TypeClassType = InvariantSemigroupal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = InvariantSemigroupal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToInvariantSemigroupalOps
   object ops {
@@ -57,11 +59,12 @@ object InvariantSemigroupal extends SemigroupalArityFunctions {
       target: F[A]
     )(implicit tc: InvariantSemigroupal[F]): AllOps[F, A] {
       type TypeClassType = InvariantSemigroupal[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = InvariantSemigroupal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = InvariantSemigroupal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Monad.scala b/core/src/main/scala/cats/Monad.scala
index f6baaf800..19bbcdcf7 100644
--- a/core/src/main/scala/cats/Monad.scala
+++ b/core/src/main/scala/cats/Monad.scala
@@ -124,12 +124,13 @@ object Monad {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Monad]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Monad[F]): Monad[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Monad[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -142,24 +143,26 @@ object Monad {
   trait AllOps[F[_], A] extends Ops[F, A] with FlatMap.AllOps[F, A] with Applicative.AllOps[F, A] {
     type TypeClassType <: Monad[F]
   }
-  trait ToMonadOps {
+  trait ToMonadOps extends Serializable {
     implicit def toMonadOps[F[_], A](target: F[A])(implicit tc: Monad[F]): Ops[F, A] {
       type TypeClassType = Monad[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Monad[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Monad[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToMonadOps
   object ops {
     implicit def toAllMonadOps[F[_], A](target: F[A])(implicit tc: Monad[F]): AllOps[F, A] {
       type TypeClassType = Monad[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Monad[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Monad[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/MonoidK.scala b/core/src/main/scala/cats/MonoidK.scala
index 65aec341b..3afdaa9ee 100644
--- a/core/src/main/scala/cats/MonoidK.scala
+++ b/core/src/main/scala/cats/MonoidK.scala
@@ -58,12 +58,13 @@ object MonoidK {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[MonoidK]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: MonoidK[F]): MonoidK[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: MonoidK[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -71,24 +72,26 @@ object MonoidK {
   trait AllOps[F[_], A] extends Ops[F, A] with SemigroupK.AllOps[F, A] {
     type TypeClassType <: MonoidK[F]
   }
-  trait ToMonoidKOps {
+  trait ToMonoidKOps extends Serializable {
     implicit def toMonoidKOps[F[_], A](target: F[A])(implicit tc: MonoidK[F]): Ops[F, A] {
       type TypeClassType = MonoidK[F]
-    } = new Ops[F, A] {
-      type TypeClassType = MonoidK[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = MonoidK[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToMonoidKOps
   object ops {
     implicit def toAllMonoidKOps[F[_], A](target: F[A])(implicit tc: MonoidK[F]): AllOps[F, A] {
       type TypeClassType = MonoidK[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = MonoidK[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = MonoidK[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/NonEmptyTraverse.scala b/core/src/main/scala/cats/NonEmptyTraverse.scala
index 581256291..f33994514 100644
--- a/core/src/main/scala/cats/NonEmptyTraverse.scala
+++ b/core/src/main/scala/cats/NonEmptyTraverse.scala
@@ -101,12 +101,13 @@ object NonEmptyTraverse {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[NonEmptyTraverse]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: NonEmptyTraverse[F]): NonEmptyTraverse[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: NonEmptyTraverse[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -122,24 +123,26 @@ object NonEmptyTraverse {
   trait AllOps[F[_], A] extends Ops[F, A] with Traverse.AllOps[F, A] with Reducible.AllOps[F, A] {
     type TypeClassType <: NonEmptyTraverse[F]
   }
-  trait ToNonEmptyTraverseOps {
+  trait ToNonEmptyTraverseOps extends Serializable {
     implicit def toNonEmptyTraverseOps[F[_], A](target: F[A])(implicit tc: NonEmptyTraverse[F]): Ops[F, A] {
       type TypeClassType = NonEmptyTraverse[F]
-    } = new Ops[F, A] {
-      type TypeClassType = NonEmptyTraverse[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = NonEmptyTraverse[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToNonEmptyTraverseOps
   object ops {
     implicit def toAllNonEmptyTraverseOps[F[_], A](target: F[A])(implicit tc: NonEmptyTraverse[F]): AllOps[F, A] {
       type TypeClassType = NonEmptyTraverse[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = NonEmptyTraverse[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = NonEmptyTraverse[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Parallel.scala b/core/src/main/scala/cats/Parallel.scala
index 8a3a0c374..1187b7194 100644
--- a/core/src/main/scala/cats/Parallel.scala
+++ b/core/src/main/scala/cats/Parallel.scala
@@ -78,33 +78,34 @@ trait Parallel[M[_]] extends NonEmptyParallel[M] {
    * I.e. if you have a type M[_], that supports parallel composition through type F[_],
    * then you can get `ApplicativeError[F, E]` from `MonadError[M, E]`.
    */
-  def applicativeError[E](implicit E: MonadError[M, E]): ApplicativeError[F, E] = new ApplicativeError[F, E] {
+  def applicativeError[E](implicit E: MonadError[M, E]): ApplicativeError[F, E] =
+    new ApplicativeError[F, E] {
 
-    def raiseError[A](e: E): F[A] =
-      parallel(MonadError[M, E].raiseError(e))
+      def raiseError[A](e: E): F[A] =
+        parallel(MonadError[M, E].raiseError(e))
 
-    def handleErrorWith[A](fa: F[A])(f: E => F[A]): F[A] = {
-      val ma = E.handleErrorWith(sequential(fa))(e => sequential.apply(f(e)))
-      parallel(ma)
-    }
+      def handleErrorWith[A](fa: F[A])(f: E => F[A]): F[A] = {
+        val ma = E.handleErrorWith(sequential(fa))(e => sequential.apply(f(e)))
+        parallel(ma)
+      }
 
-    def pure[A](x: A): F[A] = applicative.pure(x)
+      def pure[A](x: A): F[A] = applicative.pure(x)
 
-    def ap[A, B](ff: F[(A) => B])(fa: F[A]): F[B] = applicative.ap(ff)(fa)
+      def ap[A, B](ff: F[(A) => B])(fa: F[A]): F[B] = applicative.ap(ff)(fa)
 
-    override def map[A, B](fa: F[A])(f: (A) => B): F[B] = applicative.map(fa)(f)
+      override def map[A, B](fa: F[A])(f: (A) => B): F[B] = applicative.map(fa)(f)
 
-    override def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] = applicative.product(fa, fb)
+      override def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] = applicative.product(fa, fb)
 
-    override def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) => Z): F[Z] = applicative.map2(fa, fb)(f)
+      override def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) => Z): F[Z] = applicative.map2(fa, fb)(f)
 
-    override def map2Eval[A, B, Z](fa: F[A], fb: Eval[F[B]])(f: (A, B) => Z): Eval[F[Z]] =
-      applicative.map2Eval(fa, fb)(f)
+      override def map2Eval[A, B, Z](fa: F[A], fb: Eval[F[B]])(f: (A, B) => Z): Eval[F[Z]] =
+        applicative.map2Eval(fa, fb)(f)
 
-    override def unlessA[A](cond: Boolean)(f: => F[A]): F[Unit] = applicative.unlessA(cond)(f)
+      override def unlessA[A](cond: Boolean)(f: => F[A]): F[Unit] = applicative.unlessA(cond)(f)
 
-    override def whenA[A](cond: Boolean)(f: => F[A]): F[Unit] = applicative.whenA(cond)(f)
-  }
+      override def whenA[A](cond: Boolean)(f: => F[A]): F[Unit] = applicative.whenA(cond)(f)
+    }
 }
 
 object NonEmptyParallel extends ScalaVersionSpecificParallelInstances {
@@ -372,15 +373,16 @@ object Parallel extends ParallelArityFunctions2 {
    * but are required to have an instance of `Parallel` defined,
    * in which case parallel composition will actually be sequential.
    */
-  def identity[M[_]: Monad]: Parallel.Aux[M, M] = new Parallel[M] {
-    type F[x] = M[x]
+  def identity[M[_]: Monad]: Parallel.Aux[M, M] =
+    new Parallel[M] {
+      type F[x] = M[x]
 
-    val monad: Monad[M] = implicitly[Monad[M]]
+      val monad: Monad[M] = implicitly[Monad[M]]
 
-    val applicative: Applicative[M] = implicitly[Monad[M]]
+      val applicative: Applicative[M] = implicitly[Monad[M]]
 
-    val sequential: M ~> M = FunctionK.id
+      val sequential: M ~> M = FunctionK.id
 
-    val parallel: M ~> M = FunctionK.id
-  }
+      val parallel: M ~> M = FunctionK.id
+    }
 }
diff --git a/core/src/main/scala/cats/Reducible.scala b/core/src/main/scala/cats/Reducible.scala
index dc48fd246..e8a514142 100644
--- a/core/src/main/scala/cats/Reducible.scala
+++ b/core/src/main/scala/cats/Reducible.scala
@@ -289,12 +289,13 @@ object Reducible {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Reducible]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Reducible[F]): Reducible[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Reducible[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -329,24 +330,26 @@ object Reducible {
   trait AllOps[F[_], A] extends Ops[F, A] with Foldable.AllOps[F, A] {
     type TypeClassType <: Reducible[F]
   }
-  trait ToReducibleOps {
+  trait ToReducibleOps extends Serializable {
     implicit def toReducibleOps[F[_], A](target: F[A])(implicit tc: Reducible[F]): Ops[F, A] {
       type TypeClassType = Reducible[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Reducible[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Reducible[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToReducibleOps
   object ops {
     implicit def toAllReducibleOps[F[_], A](target: F[A])(implicit tc: Reducible[F]): AllOps[F, A] {
       type TypeClassType = Reducible[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Reducible[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Reducible[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Representable.scala b/core/src/main/scala/cats/Representable.scala
index 84d953618..00efafc28 100644
--- a/core/src/main/scala/cats/Representable.scala
+++ b/core/src/main/scala/cats/Representable.scala
@@ -124,9 +124,10 @@ object Representable {
   /**
    * Derives a `Monad` instance for any `Representable` functor
    */
-  def monad[F[_]](implicit Rep: Representable[F]): Monad[F] = new RepresentableMonad[F, Rep.Representation] {
-    override def R: Representable.Aux[F, Rep.Representation] = Rep
-  }
+  def monad[F[_]](implicit Rep: Representable[F]): Monad[F] =
+    new RepresentableMonad[F, Rep.Representation] {
+      override def R: Representable.Aux[F, Rep.Representation] = Rep
+    }
 
   /**
    * Derives a `Bimonad` instance for any `Representable` functor whose representation
@@ -149,7 +150,7 @@ object Representable {
   implicit def catsRepresentableForFunction1[E](implicit EF: Functor[E => *]): Representable.Aux[E => *, E] =
     cats.instances.function.catsStdRepresentableForFunction1[E]
 
-  implicit def catsRepresentableForPair(
-    implicit PF: Functor[Î»[P => (P, P)]]
+  implicit def catsRepresentableForPair(implicit
+    PF: Functor[Î»[P => (P, P)]]
   ): Representable.Aux[Î»[P => (P, P)], Boolean] = cats.instances.tuple.catsDataRepresentableForPair
 }
diff --git a/core/src/main/scala/cats/SemigroupK.scala b/core/src/main/scala/cats/SemigroupK.scala
index c11ed9eda..76fbd2c39 100644
--- a/core/src/main/scala/cats/SemigroupK.scala
+++ b/core/src/main/scala/cats/SemigroupK.scala
@@ -39,6 +39,31 @@ import scala.annotation.implicitNotFound
   @simulacrum.op("<+>", alias = true)
   def combineK[A](x: F[A], y: F[A]): F[A]
 
+  /**
+   * Similar to [[combineK]] but uses [[Eval]] to allow for laziness in the second
+   * argument. This can allow for "short-circuiting" of computations.
+   *
+   * NOTE: the default implementation of `combineKEval` does not short-circuit
+   * computations. For data structures that can benefit from laziness, [[SemigroupK]]
+   * instances should override this method.
+   *
+   * In the following example, `x.combineK(bomb)` would result in an error,
+   * but `combineKEval` "short-circuits" the computation. `x` is `Some` and thus the
+   * result of `bomb` doesn't even need to be evaluated in order to determine
+   * that the result of `combineKEval` should be `x`.
+   *
+   * {{{
+   * scala> import cats.{Eval, Later}
+   * scala> import cats.implicits._
+   * scala> val bomb: Eval[Option[Int]] = Later(sys.error("boom"))
+   * scala> val x: Option[Int] = Some(42)
+   * scala> x.combineKEval(bomb).value
+   * res0: Option[Int] = Some(42)
+   * }}}
+   */
+  def combineKEval[A](x: F[A], y: Eval[F[A]]): Eval[F[A]] =
+    y.map(yy => combineK(x, yy))
+
   /**
    * Given a type A, create a concrete Semigroup[F[A]].
    *
@@ -88,11 +113,12 @@ import scala.annotation.implicitNotFound
 }
 
 object SemigroupK extends ScalaVersionSpecificMonoidKInstances {
-  def align[F[_]: SemigroupK: Functor]: Align[F] = new Align[F] {
-    def align[A, B](fa: F[A], fb: F[B]): F[Ior[A, B]] =
-      SemigroupK[F].combineK(Functor[F].map(fa)(Ior.left), Functor[F].map(fb)(Ior.right))
-    def functor: Functor[F] = Functor[F]
-  }
+  def align[F[_]: SemigroupK: Functor]: Align[F] =
+    new Align[F] {
+      def align[A, B](fa: F[A], fb: F[B]): F[Ior[A, B]] =
+        SemigroupK[F].combineK(Functor[F].map(fa)(Ior.left), Functor[F].map(fb)(Ior.right))
+      def functor: Functor[F] = Functor[F]
+    }
 
   implicit def catsMonoidKForOption: MonoidK[Option] = cats.instances.option.catsStdInstancesForOption
   implicit def catsMonoidKForList: MonoidK[List] = cats.instances.list.catsStdInstancesForList
@@ -109,38 +135,42 @@ object SemigroupK extends ScalaVersionSpecificMonoidKInstances {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[SemigroupK]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: SemigroupK[F]): SemigroupK[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: SemigroupK[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
     def combineK(y: F[A]): F[A] = typeClassInstance.combineK[A](self, y)
     def <+>(y: F[A]): F[A] = typeClassInstance.combineK[A](self, y)
+    def combineKEval(y: Eval[F[A]]): Eval[F[A]] = typeClassInstance.combineKEval[A](self, y)
     def sum[B](fb: F[B])(implicit F: Functor[F]): F[Either[A, B]] = typeClassInstance.sum[A, B](self, fb)(F)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToSemigroupKOps {
+  trait ToSemigroupKOps extends Serializable {
     implicit def toSemigroupKOps[F[_], A](target: F[A])(implicit tc: SemigroupK[F]): Ops[F, A] {
       type TypeClassType = SemigroupK[F]
-    } = new Ops[F, A] {
-      type TypeClassType = SemigroupK[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = SemigroupK[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToSemigroupKOps
   object ops {
     implicit def toAllSemigroupKOps[F[_], A](target: F[A])(implicit tc: SemigroupK[F]): AllOps[F, A] {
       type TypeClassType = SemigroupK[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = SemigroupK[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = SemigroupK[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Semigroupal.scala b/core/src/main/scala/cats/Semigroupal.scala
index a8160e6c2..e7c1398a3 100644
--- a/core/src/main/scala/cats/Semigroupal.scala
+++ b/core/src/main/scala/cats/Semigroupal.scala
@@ -87,36 +87,39 @@ object Semigroupal extends ScalaVersionSpecificSemigroupalInstances with Semigro
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Semigroupal]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Semigroupal[F]): Semigroupal[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Semigroupal[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
     def product[B](fb: F[B]): F[(A, B)] = typeClassInstance.product[A, B](self, fb)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToSemigroupalOps {
+  trait ToSemigroupalOps extends Serializable {
     implicit def toSemigroupalOps[F[_], A](target: F[A])(implicit tc: Semigroupal[F]): Ops[F, A] {
       type TypeClassType = Semigroupal[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Semigroupal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Semigroupal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToSemigroupalOps
   object ops {
     implicit def toAllSemigroupalOps[F[_], A](target: F[A])(implicit tc: Semigroupal[F]): AllOps[F, A] {
       type TypeClassType = Semigroupal[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Semigroupal[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Semigroupal[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/Show.scala b/core/src/main/scala/cats/Show.scala
index 3b73734c4..2cc858fc0 100644
--- a/core/src/main/scala/cats/Show.scala
+++ b/core/src/main/scala/cats/Show.scala
@@ -32,21 +32,24 @@ object Show extends ScalaVersionSpecificShowInstances with ShowInstances {
   }
 
   trait ToShowOps {
-    implicit def toShow[A](target: A)(implicit tc: Show[A]): Ops[A] = new Ops[A] {
-      val self = target
-      val typeClassInstance = tc
-    }
+    implicit def toShow[A](target: A)(implicit tc: Show[A]): Ops[A] =
+      new Ops[A] {
+        val self = target
+        val typeClassInstance = tc
+      }
   }
 
   /** creates an instance of [[Show]] using the provided function */
-  def show[A](f: A => String): Show[A] = new Show[A] {
-    def show(a: A): String = f(a)
-  }
+  def show[A](f: A => String): Show[A] =
+    new Show[A] {
+      def show(a: A): String = f(a)
+    }
 
   /** creates an instance of [[Show]] using object toString */
-  def fromToString[A]: Show[A] = new Show[A] {
-    def show(a: A): String = a.toString
-  }
+  def fromToString[A]: Show[A] =
+    new Show[A] {
+      def show(a: A): String = a.toString
+    }
 
   final case class Shown(override val toString: String) extends AnyVal
   object Shown {
diff --git a/core/src/main/scala/cats/StackSafeMonad.scala b/core/src/main/scala/cats/StackSafeMonad.scala
index 505b65ceb..8b815dc6f 100644
--- a/core/src/main/scala/cats/StackSafeMonad.scala
+++ b/core/src/main/scala/cats/StackSafeMonad.scala
@@ -12,8 +12,9 @@ import scala.util.{Either, Left, Right}
  */
 trait StackSafeMonad[F[_]] extends Monad[F] {
 
-  override def tailRecM[A, B](a: A)(f: A => F[Either[A, B]]): F[B] = flatMap(f(a)) {
-    case Left(a)  => tailRecM(a)(f)
-    case Right(b) => pure(b)
-  }
+  override def tailRecM[A, B](a: A)(f: A => F[Either[A, B]]): F[B] =
+    flatMap(f(a)) {
+      case Left(a)  => tailRecM(a)(f)
+      case Right(b) => pure(b)
+    }
 }
diff --git a/core/src/main/scala/cats/Traverse.scala b/core/src/main/scala/cats/Traverse.scala
index 6464364c4..c562b95ef 100644
--- a/core/src/main/scala/cats/Traverse.scala
+++ b/core/src/main/scala/cats/Traverse.scala
@@ -138,12 +138,13 @@ object Traverse {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Traverse]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: Traverse[F]): Traverse[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: Traverse[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -167,24 +168,26 @@ object Traverse {
       with UnorderedTraverse.AllOps[F, A] {
     type TypeClassType <: Traverse[F]
   }
-  trait ToTraverseOps {
+  trait ToTraverseOps extends Serializable {
     implicit def toTraverseOps[F[_], A](target: F[A])(implicit tc: Traverse[F]): Ops[F, A] {
       type TypeClassType = Traverse[F]
-    } = new Ops[F, A] {
-      type TypeClassType = Traverse[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = Traverse[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToTraverseOps
   object ops {
     implicit def toAllTraverseOps[F[_], A](target: F[A])(implicit tc: Traverse[F]): AllOps[F, A] {
       type TypeClassType = Traverse[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = Traverse[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = Traverse[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/TraverseFilter.scala b/core/src/main/scala/cats/TraverseFilter.scala
index 46b3858a3..e6478ca1f 100644
--- a/core/src/main/scala/cats/TraverseFilter.scala
+++ b/core/src/main/scala/cats/TraverseFilter.scala
@@ -93,12 +93,13 @@ object TraverseFilter {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[TraverseFilter]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: TraverseFilter[F]): TraverseFilter[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: TraverseFilter[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -112,24 +113,26 @@ object TraverseFilter {
   trait AllOps[F[_], A] extends Ops[F, A] with FunctorFilter.AllOps[F, A] {
     type TypeClassType <: TraverseFilter[F]
   }
-  trait ToTraverseFilterOps {
+  trait ToTraverseFilterOps extends Serializable {
     implicit def toTraverseFilterOps[F[_], A](target: F[A])(implicit tc: TraverseFilter[F]): Ops[F, A] {
       type TypeClassType = TraverseFilter[F]
-    } = new Ops[F, A] {
-      type TypeClassType = TraverseFilter[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = TraverseFilter[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToTraverseFilterOps
   object ops {
     implicit def toAllTraverseFilterOps[F[_], A](target: F[A])(implicit tc: TraverseFilter[F]): AllOps[F, A] {
       type TypeClassType = TraverseFilter[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = TraverseFilter[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = TraverseFilter[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/UnorderedFoldable.scala b/core/src/main/scala/cats/UnorderedFoldable.scala
index 8092301bf..8ca780a63 100644
--- a/core/src/main/scala/cats/UnorderedFoldable.scala
+++ b/core/src/main/scala/cats/UnorderedFoldable.scala
@@ -117,12 +117,13 @@ object UnorderedFoldable extends ScalaVersionSpecificTraverseInstances {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[UnorderedFoldable]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: UnorderedFoldable[F]): UnorderedFoldable[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: UnorderedFoldable[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -136,24 +137,26 @@ object UnorderedFoldable extends ScalaVersionSpecificTraverseInstances {
     def size: Long = typeClassInstance.size[A](self)
   }
   trait AllOps[F[_], A] extends Ops[F, A]
-  trait ToUnorderedFoldableOps {
+  trait ToUnorderedFoldableOps extends Serializable {
     implicit def toUnorderedFoldableOps[F[_], A](target: F[A])(implicit tc: UnorderedFoldable[F]): Ops[F, A] {
       type TypeClassType = UnorderedFoldable[F]
-    } = new Ops[F, A] {
-      type TypeClassType = UnorderedFoldable[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = UnorderedFoldable[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToUnorderedFoldableOps
   object ops {
     implicit def toAllUnorderedFoldableOps[F[_], A](target: F[A])(implicit tc: UnorderedFoldable[F]): AllOps[F, A] {
       type TypeClassType = UnorderedFoldable[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = UnorderedFoldable[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = UnorderedFoldable[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/UnorderedTraverse.scala b/core/src/main/scala/cats/UnorderedTraverse.scala
index 2faab8561..bc1745cdd 100644
--- a/core/src/main/scala/cats/UnorderedTraverse.scala
+++ b/core/src/main/scala/cats/UnorderedTraverse.scala
@@ -19,12 +19,13 @@ object UnorderedTraverse {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[UnorderedTraverse]] for `F`.
    */
   @inline def apply[F[_]](implicit instance: UnorderedTraverse[F]): UnorderedTraverse[F] = instance
 
-  trait Ops[F[_], A] {
+  trait Ops[F[_], A] extends Serializable {
     type TypeClassType <: UnorderedTraverse[F]
     def self: F[A]
     val typeClassInstance: TypeClassType
@@ -36,24 +37,26 @@ object UnorderedTraverse {
   trait AllOps[F[_], A] extends Ops[F, A] with UnorderedFoldable.AllOps[F, A] {
     type TypeClassType <: UnorderedTraverse[F]
   }
-  trait ToUnorderedTraverseOps {
+  trait ToUnorderedTraverseOps extends Serializable {
     implicit def toUnorderedTraverseOps[F[_], A](target: F[A])(implicit tc: UnorderedTraverse[F]): Ops[F, A] {
       type TypeClassType = UnorderedTraverse[F]
-    } = new Ops[F, A] {
-      type TypeClassType = UnorderedTraverse[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A] {
+        type TypeClassType = UnorderedTraverse[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToUnorderedTraverseOps
   object ops {
     implicit def toAllUnorderedTraverseOps[F[_], A](target: F[A])(implicit tc: UnorderedTraverse[F]): AllOps[F, A] {
       type TypeClassType = UnorderedTraverse[F]
-    } = new AllOps[F, A] {
-      type TypeClassType = UnorderedTraverse[F]
-      val self: F[A] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A] {
+        type TypeClassType = UnorderedTraverse[F]
+        val self: F[A] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Arrow.scala b/core/src/main/scala/cats/arrow/Arrow.scala
index a9f6926e9..fca09c9e8 100644
--- a/core/src/main/scala/cats/arrow/Arrow.scala
+++ b/core/src/main/scala/cats/arrow/Arrow.scala
@@ -77,12 +77,13 @@ object Arrow {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Arrow]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Arrow[F]): Arrow[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: Arrow[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -94,24 +95,26 @@ object Arrow {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Category.AllOps[F, A, B] with Strong.AllOps[F, A, B] {
     type TypeClassType <: Arrow[F]
   }
-  trait ToArrowOps {
+  trait ToArrowOps extends Serializable {
     implicit def toArrowOps[F[_, _], A, B](target: F[A, B])(implicit tc: Arrow[F]): Ops[F, A, B] {
       type TypeClassType = Arrow[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = Arrow[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = Arrow[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToArrowOps
   object ops {
     implicit def toAllArrowOps[F[_, _], A, B](target: F[A, B])(implicit tc: Arrow[F]): AllOps[F, A, B] {
       type TypeClassType = Arrow[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = Arrow[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = Arrow[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/ArrowChoice.scala b/core/src/main/scala/cats/arrow/ArrowChoice.scala
index c01026829..e36fff4e3 100644
--- a/core/src/main/scala/cats/arrow/ArrowChoice.scala
+++ b/core/src/main/scala/cats/arrow/ArrowChoice.scala
@@ -49,12 +49,13 @@ object ArrowChoice {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[ArrowChoice]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: ArrowChoice[F]): ArrowChoice[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: ArrowChoice[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -66,24 +67,26 @@ object ArrowChoice {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Arrow.AllOps[F, A, B] with Choice.AllOps[F, A, B] {
     type TypeClassType <: ArrowChoice[F]
   }
-  trait ToArrowChoiceOps {
+  trait ToArrowChoiceOps extends Serializable {
     implicit def toArrowChoiceOps[F[_, _], A, B](target: F[A, B])(implicit tc: ArrowChoice[F]): Ops[F, A, B] {
       type TypeClassType = ArrowChoice[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = ArrowChoice[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = ArrowChoice[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToArrowChoiceOps
   object ops {
     implicit def toAllArrowChoiceOps[F[_, _], A, B](target: F[A, B])(implicit tc: ArrowChoice[F]): AllOps[F, A, B] {
       type TypeClassType = ArrowChoice[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = ArrowChoice[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = ArrowChoice[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Category.scala b/core/src/main/scala/cats/arrow/Category.scala
index 198cbdbfa..c80edcfc7 100644
--- a/core/src/main/scala/cats/arrow/Category.scala
+++ b/core/src/main/scala/cats/arrow/Category.scala
@@ -30,12 +30,13 @@ object Category {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Category]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Category[F]): Category[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: Category[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -43,24 +44,26 @@ object Category {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Compose.AllOps[F, A, B] {
     type TypeClassType <: Category[F]
   }
-  trait ToCategoryOps {
+  trait ToCategoryOps extends Serializable {
     implicit def toCategoryOps[F[_, _], A, B](target: F[A, B])(implicit tc: Category[F]): Ops[F, A, B] {
       type TypeClassType = Category[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = Category[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = Category[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToCategoryOps
   object ops {
     implicit def toAllCategoryOps[F[_, _], A, B](target: F[A, B])(implicit tc: Category[F]): AllOps[F, A, B] {
       type TypeClassType = Category[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = Category[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = Category[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Choice.scala b/core/src/main/scala/cats/arrow/Choice.scala
index da97eb7be..4b1147843 100644
--- a/core/src/main/scala/cats/arrow/Choice.scala
+++ b/core/src/main/scala/cats/arrow/Choice.scala
@@ -53,12 +53,13 @@ object Choice {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Choice]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Choice[F]): Choice[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: Choice[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -68,24 +69,26 @@ object Choice {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Category.AllOps[F, A, B] {
     type TypeClassType <: Choice[F]
   }
-  trait ToChoiceOps {
+  trait ToChoiceOps extends Serializable {
     implicit def toChoiceOps[F[_, _], A, B](target: F[A, B])(implicit tc: Choice[F]): Ops[F, A, B] {
       type TypeClassType = Choice[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = Choice[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = Choice[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToChoiceOps
   object ops {
     implicit def toAllChoiceOps[F[_, _], A, B](target: F[A, B])(implicit tc: Choice[F]): AllOps[F, A, B] {
       type TypeClassType = Choice[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = Choice[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = Choice[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/CommutativeArrow.scala b/core/src/main/scala/cats/arrow/CommutativeArrow.scala
index 03fc20fde..fca4d1351 100644
--- a/core/src/main/scala/cats/arrow/CommutativeArrow.scala
+++ b/core/src/main/scala/cats/arrow/CommutativeArrow.scala
@@ -18,12 +18,13 @@ object CommutativeArrow {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[CommutativeArrow]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: CommutativeArrow[F]): CommutativeArrow[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: CommutativeArrow[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -31,14 +32,15 @@ object CommutativeArrow {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Arrow.AllOps[F, A, B] {
     type TypeClassType <: CommutativeArrow[F]
   }
-  trait ToCommutativeArrowOps {
+  trait ToCommutativeArrowOps extends Serializable {
     implicit def toCommutativeArrowOps[F[_, _], A, B](target: F[A, B])(implicit tc: CommutativeArrow[F]): Ops[F, A, B] {
       type TypeClassType = CommutativeArrow[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = CommutativeArrow[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = CommutativeArrow[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToCommutativeArrowOps
   object ops {
@@ -46,11 +48,12 @@ object CommutativeArrow {
       target: F[A, B]
     )(implicit tc: CommutativeArrow[F]): AllOps[F, A, B] {
       type TypeClassType = CommutativeArrow[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = CommutativeArrow[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = CommutativeArrow[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Compose.scala b/core/src/main/scala/cats/arrow/Compose.scala
index 34f048bea..c6b767f75 100644
--- a/core/src/main/scala/cats/arrow/Compose.scala
+++ b/core/src/main/scala/cats/arrow/Compose.scala
@@ -48,12 +48,13 @@ object Compose {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Compose]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Compose[F]): Compose[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: Compose[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -63,24 +64,26 @@ object Compose {
     def >>>[C](g: F[B, C]): F[A, C] = typeClassInstance.andThen[A, B, C](self, g)
   }
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B]
-  trait ToComposeOps {
+  trait ToComposeOps extends Serializable {
     implicit def toComposeOps[F[_, _], A, B](target: F[A, B])(implicit tc: Compose[F]): Ops[F, A, B] {
       type TypeClassType = Compose[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = Compose[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = Compose[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToComposeOps
   object ops {
     implicit def toAllComposeOps[F[_, _], A, B](target: F[A, B])(implicit tc: Compose[F]): AllOps[F, A, B] {
       type TypeClassType = Compose[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = Compose[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = Compose[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/FunctionK.scala b/core/src/main/scala/cats/arrow/FunctionK.scala
index 7309cb28d..295605936 100644
--- a/core/src/main/scala/cats/arrow/FunctionK.scala
+++ b/core/src/main/scala/cats/arrow/FunctionK.scala
@@ -99,8 +99,8 @@ private[arrow] object FunctionKMacros {
 
   def lift[F[_], G[_]](c: Context)(
     f: c.Expr[(F[Î±] => G[Î±]) forSome { type Î± }]
-  )(
-    implicit evF: c.WeakTypeTag[F[_]],
+  )(implicit
+    evF: c.WeakTypeTag[F[_]],
     evG: c.WeakTypeTag[G[_]]
   ): c.Expr[FunctionK[F, G]] =
     c.Expr[FunctionK[F, G]](new Lifter[c.type](c).lift[F, G](f.tree))
@@ -109,54 +109,59 @@ private[arrow] object FunctionKMacros {
   private[this] class Lifter[C <: Context](val c: C) {
     import c.universe._
 
-    def lift[F[_], G[_]](tree: Tree)(
-      implicit evF: c.WeakTypeTag[F[_]],
+    def lift[F[_], G[_]](tree: Tree)(implicit
+      evF: c.WeakTypeTag[F[_]],
       evG: c.WeakTypeTag[G[_]]
-    ): Tree = unblock(tree) match {
-      case q"($param) => $trans[..$typeArgs](${arg: Ident})" if param.name == arg.name =>
-        typeArgs
-          .collect { case tt: TypeTree => tt }
-          .find(tt => Option(tt.original).isDefined)
-          .foreach { param =>
-            c.abort(param.pos, s"type parameter $param must not be supplied when lifting function $trans to FunctionK")
-          }
-
-        val F = punchHole(evF.tpe)
-        val G = punchHole(evG.tpe)
-
-        q"""
+    ): Tree =
+      unblock(tree) match {
+        case q"($param) => $trans[..$typeArgs](${arg: Ident})" if param.name == arg.name =>
+          typeArgs
+            .collect { case tt: TypeTree => tt }
+            .find(tt => Option(tt.original).isDefined)
+            .foreach { param =>
+              c.abort(param.pos,
+                      s"type parameter $param must not be supplied when lifting function $trans to FunctionK"
+              )
+            }
+
+          val F = punchHole(evF.tpe)
+          val G = punchHole(evG.tpe)
+
+          q"""
         new _root_.cats.arrow.FunctionK[$F, $G] {
           def apply[A](fa: $F[A]): $G[A] = $trans(fa)
         }
        """
-      case other =>
-        c.abort(other.pos, s"Unexpected tree $other when lifting to FunctionK")
-    }
-
-    private[this] def unblock(tree: Tree): Tree = tree match {
-      case Block(Nil, expr) => expr
-      case _                => tree
-    }
-
-    private[this] def punchHole(tpe: Type): Tree = tpe match {
-      case PolyType(undet :: Nil, underlying: TypeRef) =>
-        val Î± = TypeName("Î±")
-        def rebind(typeRef: TypeRef): Tree =
-          if (typeRef.sym == undet) tq"$Î±"
-          else {
-            val args = typeRef.args.map {
-              case ref: TypeRef => rebind(ref)
-              case arg          => tq"$arg"
+        case other =>
+          c.abort(other.pos, s"Unexpected tree $other when lifting to FunctionK")
+      }
+
+    private[this] def unblock(tree: Tree): Tree =
+      tree match {
+        case Block(Nil, expr) => expr
+        case _                => tree
+      }
+
+    private[this] def punchHole(tpe: Type): Tree =
+      tpe match {
+        case PolyType(undet :: Nil, underlying: TypeRef) =>
+          val Î± = TypeName("Î±")
+          def rebind(typeRef: TypeRef): Tree =
+            if (typeRef.sym == undet) tq"$Î±"
+            else {
+              val args = typeRef.args.map {
+                case ref: TypeRef => rebind(ref)
+                case arg          => tq"$arg"
+              }
+              tq"${typeRef.sym}[..$args]"
             }
-            tq"${typeRef.sym}[..$args]"
-          }
-        val rebound = rebind(underlying)
-        tq"""({type Î»[$Î±] = $rebound})#Î»"""
-      case TypeRef(pre, sym, Nil) =>
-        tq"$sym"
-      case _ =>
-        c.abort(c.enclosingPosition, s"Unexpected type $tpe when lifting to FunctionK")
-    }
+          val rebound = rebind(underlying)
+          tq"""({type Î»[$Î±] = $rebound})#Î»"""
+        case TypeRef(pre, sym, Nil) =>
+          tq"$sym"
+        case _ =>
+          c.abort(c.enclosingPosition, s"Unexpected type $tpe when lifting to FunctionK")
+      }
 
   }
 
diff --git a/core/src/main/scala/cats/arrow/Profunctor.scala b/core/src/main/scala/cats/arrow/Profunctor.scala
index aa6b3c3cf..fa4753b07 100644
--- a/core/src/main/scala/cats/arrow/Profunctor.scala
+++ b/core/src/main/scala/cats/arrow/Profunctor.scala
@@ -50,12 +50,13 @@ object Profunctor {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Profunctor]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Profunctor[F]): Profunctor[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: Profunctor[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -64,24 +65,26 @@ object Profunctor {
     def rmap[C](f: B => C): F[A, C] = typeClassInstance.rmap[A, B, C](self)(f)
   }
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B]
-  trait ToProfunctorOps {
+  trait ToProfunctorOps extends Serializable {
     implicit def toProfunctorOps[F[_, _], A, B](target: F[A, B])(implicit tc: Profunctor[F]): Ops[F, A, B] {
       type TypeClassType = Profunctor[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = Profunctor[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = Profunctor[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToProfunctorOps
   object ops {
     implicit def toAllProfunctorOps[F[_, _], A, B](target: F[A, B])(implicit tc: Profunctor[F]): AllOps[F, A, B] {
       type TypeClassType = Profunctor[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = Profunctor[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = Profunctor[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/arrow/Strong.scala b/core/src/main/scala/cats/arrow/Strong.scala
index e81e6db7e..72d2c8a7a 100644
--- a/core/src/main/scala/cats/arrow/Strong.scala
+++ b/core/src/main/scala/cats/arrow/Strong.scala
@@ -46,12 +46,13 @@ object Strong {
   /****************************************************************************/
   /* THE FOLLOWING CODE IS MANAGED BY SIMULACRUM; PLEASE DO NOT EDIT!!!!      */
   /****************************************************************************/
+
   /**
    * Summon an instance of [[Strong]] for `F`.
    */
   @inline def apply[F[_, _]](implicit instance: Strong[F]): Strong[F] = instance
 
-  trait Ops[F[_, _], A, B] {
+  trait Ops[F[_, _], A, B] extends Serializable {
     type TypeClassType <: Strong[F]
     def self: F[A, B]
     val typeClassInstance: TypeClassType
@@ -61,24 +62,26 @@ object Strong {
   trait AllOps[F[_, _], A, B] extends Ops[F, A, B] with Profunctor.AllOps[F, A, B] {
     type TypeClassType <: Strong[F]
   }
-  trait ToStrongOps {
+  trait ToStrongOps extends Serializable {
     implicit def toStrongOps[F[_, _], A, B](target: F[A, B])(implicit tc: Strong[F]): Ops[F, A, B] {
       type TypeClassType = Strong[F]
-    } = new Ops[F, A, B] {
-      type TypeClassType = Strong[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new Ops[F, A, B] {
+        type TypeClassType = Strong[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
   object nonInheritedOps extends ToStrongOps
   object ops {
     implicit def toAllStrongOps[F[_, _], A, B](target: F[A, B])(implicit tc: Strong[F]): AllOps[F, A, B] {
       type TypeClassType = Strong[F]
-    } = new AllOps[F, A, B] {
-      type TypeClassType = Strong[F]
-      val self: F[A, B] = target
-      val typeClassInstance: TypeClassType = tc
-    }
+    } =
+      new AllOps[F, A, B] {
+        type TypeClassType = Strong[F]
+        val self: F[A, B] = target
+        val typeClassInstance: TypeClassType = tc
+      }
   }
 
   /****************************************************************************/
diff --git a/core/src/main/scala/cats/conversions/VarianceConversions.scala b/core/src/main/scala/cats/conversions/VarianceConversions.scala
deleted file mode 100644
index 7e8b7f769..000000000
--- a/core/src/main/scala/cats/conversions/VarianceConversions.scala
+++ /dev/null
@@ -1,14 +0,0 @@
-package cats
-package conversions
-
-trait VarianceConversions extends VarianceConversionsLowPriority {
-  implicit def autoWidenBifunctor[F[_, _]: Bifunctor, A, B >: A, C, D >: C](fac: F[A, C]): F[B, D] =
-    Bifunctor[F].leftWiden(Bifunctor[F].rightFunctor.widen(fac))
-
-  implicit def autoNarrowContravariant[F[_]: Contravariant, A, B <: A](fa: F[A]): F[B] = Contravariant[F].narrow(fa)
-
-}
-
-private[cats] trait VarianceConversionsLowPriority {
-  implicit def autoWidenFunctor[F[_]: Functor, A, B >: A](fa: F[A]): F[B] = Functor[F].widen(fa)
-}
diff --git a/core/src/main/scala/cats/conversions/all.scala b/core/src/main/scala/cats/conversions/all.scala
deleted file mode 100644
index 676b56354..000000000
--- a/core/src/main/scala/cats/conversions/all.scala
+++ /dev/null
@@ -1,3 +0,0 @@
-package cats.conversions
-
-trait AllConversions extends VarianceConversions
diff --git a/core/src/main/scala/cats/conversions/package.scala b/core/src/main/scala/cats/conversions/package.scala
deleted file mode 100644
index ac47bccbf..000000000
--- a/core/src/main/scala/cats/conversions/package.scala
+++ /dev/null
@@ -1,6 +0,0 @@
-package cats
-
-package object conversions {
-  object all extends AllConversions
-  object variance extends VarianceConversions
-}
diff --git a/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala b/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala
index 2641a4f36..b5f4eacd3 100644
--- a/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala
+++ b/core/src/main/scala/cats/data/AbstractNonEmptyInstances.scala
@@ -1,11 +1,12 @@
 package cats
 package data
 
-abstract private[data] class AbstractNonEmptyInstances[F[_], NonEmptyF[_]](implicit MF: Monad[F],
-                                                                           CF: CoflatMap[F],
-                                                                           TF: Traverse[F],
-                                                                           SF: SemigroupK[F])
-    extends Bimonad[NonEmptyF]
+abstract private[data] class AbstractNonEmptyInstances[F[_], NonEmptyF[_]](implicit
+  MF: Monad[F],
+  CF: CoflatMap[F],
+  TF: Traverse[F],
+  SF: SemigroupK[F]
+) extends Bimonad[NonEmptyF]
     with NonEmptyTraverse[NonEmptyF]
     with SemigroupK[NonEmptyF] {
   val monadInstance = MF.asInstanceOf[Monad[NonEmptyF]]
diff --git a/core/src/main/scala/cats/data/Binested.scala b/core/src/main/scala/cats/data/Binested.scala
index d5687eede..00bea89b1 100644
--- a/core/src/main/scala/cats/data/Binested.scala
+++ b/core/src/main/scala/cats/data/Binested.scala
@@ -26,21 +26,23 @@ final case class Binested[F[_, _], G[_], H[_], A, B](value: F[G[A], H[B]])
 object Binested extends BinestedInstances
 
 trait BinestedInstances extends BinestedInstances0 {
-  implicit def catsDataEqForBinested[F[_, _], G[_], H[_], A, B](
-    implicit F: Eq[F[G[A], H[B]]]
+  implicit def catsDataEqForBinested[F[_, _], G[_], H[_], A, B](implicit
+    F: Eq[F[G[A], H[B]]]
   ): Eq[Binested[F, G, H, A, B]] =
     Eq.by(_.value)
 
-  implicit def catsDataProfunctorForBinested[F[_, _], G[_], H[_]](implicit F: Profunctor[F],
-                                                                  G: Functor[G],
-                                                                  H: Functor[H]): Profunctor[Binested[F, G, H, *, *]] =
+  implicit def catsDataProfunctorForBinested[F[_, _], G[_], H[_]](implicit
+    F: Profunctor[F],
+    G: Functor[G],
+    H: Functor[H]
+  ): Profunctor[Binested[F, G, H, *, *]] =
     new Profunctor[Binested[F, G, H, *, *]] {
       def dimap[A, B, C, D](fab: Binested[F, G, H, A, B])(f: C => A)(g: B => D): Binested[F, G, H, C, D] =
         Binested(F.dimap(fab.value)(G.map(_: G[C])(f))(H.map(_)(g)))
     }
 
-  implicit def catsDataBitraverseForBinested[F[_, _], G[_], H[_]](
-    implicit F0: Bitraverse[F],
+  implicit def catsDataBitraverseForBinested[F[_, _], G[_], H[_]](implicit
+    F0: Bitraverse[F],
     H0: Traverse[H],
     G0: Traverse[G]
   ): Bitraverse[Binested[F, G, H, *, *]] =
@@ -52,8 +54,8 @@ trait BinestedInstances extends BinestedInstances0 {
 }
 
 private[data] trait BinestedInstances0 {
-  implicit def catsDataBifoldableForBinested[F[_, _], G[_], H[_]](
-    implicit F0: Bifoldable[F],
+  implicit def catsDataBifoldableForBinested[F[_, _], G[_], H[_]](implicit
+    F0: Bifoldable[F],
     G0: Foldable[G],
     H0: Foldable[H]
   ): Bifoldable[Binested[F, G, H, *, *]] =
@@ -63,9 +65,11 @@ private[data] trait BinestedInstances0 {
       implicit override def H: Foldable[H] = H0
     }
 
-  implicit def catsDataBifunctorForBinested[F[_, _], G[_], H[_]](implicit F: Bifunctor[F],
-                                                                 G: Functor[G],
-                                                                 H: Functor[H]): Bifunctor[Binested[F, G, H, *, *]] =
+  implicit def catsDataBifunctorForBinested[F[_, _], G[_], H[_]](implicit
+    F: Bifunctor[F],
+    G: Functor[G],
+    H: Functor[H]
+  ): Bifunctor[Binested[F, G, H, *, *]] =
     new Bifunctor[Binested[F, G, H, *, *]] {
       def bimap[A, B, C, D](fab: Binested[F, G, H, A, B])(f: A => C, g: B => D): Binested[F, G, H, C, D] =
         Binested(F.bimap(fab.value)(G.map(_)(f), H.map(_)(g)))
@@ -83,8 +87,9 @@ sealed abstract class BinestedBifoldable[F[_, _], G[_], H[_]] extends Bifoldable
       (c, hb) => H.foldLeft(hb, c)(g)
     )
 
-  def bifoldRight[A, B, C](fab: Binested[F, G, H, A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
-                                                                     g: (B, Eval[C]) => Eval[C]): Eval[C] =
+  def bifoldRight[A, B, C](fab: Binested[F, G, H, A, B],
+                           c: Eval[C]
+  )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
     F.bifoldRight(fab.value, c)(
       (ga, ec) => G.foldRight(ga, ec)(f),
       (hb, ec) => H.foldRight(hb, ec)(g)
diff --git a/core/src/main/scala/cats/data/Chain.scala b/core/src/main/scala/cats/data/Chain.scala
index 7e6491541..ceda64437 100644
--- a/core/src/main/scala/cats/data/Chain.scala
+++ b/core/src/main/scala/cats/data/Chain.scala
@@ -136,10 +136,11 @@ sealed abstract class Chain[+A] {
   /**
    * Applies the supplied function to each element and returns a new Chain.
    */
-  final def map[B](f: A => B): Chain[B] = this match {
-    case Wrap(seq) => Wrap(seq.map(f))
-    case _         => fromSeq(iterator.map(f).toVector)
-  }
+  final def map[B](f: A => B): Chain[B] =
+    this match {
+      case Wrap(seq) => Wrap(seq.map(f))
+      case _         => fromSeq(iterator.map(f).toVector)
+    }
 
   /**
    * Applies the supplied function to each element and returns a new Chain from the concatenated results
@@ -326,14 +327,15 @@ sealed abstract class Chain[+A] {
   /**
    * Zips each element of this `Chain` with its index.
    */
-  final def zipWithIndex: Chain[(A, Int)] = this match {
-    case Empty        => Empty
-    case Singleton(a) => Singleton((a, 0))
-    case Append(left, right) =>
-      val leftSize = left.length.toInt
-      Append(left.zipWithIndex, right.zipWithIndex.map { case (a, i) => (a, leftSize + i) })
-    case Wrap(seq) => Wrap(seq.zipWithIndex)
-  }
+  final def zipWithIndex: Chain[(A, Int)] =
+    this match {
+      case Empty        => Empty
+      case Singleton(a) => Singleton((a, 0))
+      case Append(left, right) =>
+        val leftSize = left.length.toInt
+        Append(left.zipWithIndex, right.zipWithIndex.map { case (a, i) => (a, leftSize + i) })
+      case Wrap(seq) => Wrap(seq.zipWithIndex)
+    }
 
   /**
    * Groups elements inside this `Chain` according to the `Order`
@@ -383,9 +385,10 @@ sealed abstract class Chain[+A] {
   /**
    * Applies the supplied function to each element, left to right.
    */
-  final private def foreach(f: A => Unit): Unit = foreachUntil { a =>
-    f(a); false
-  }
+  final private def foreach(f: A => Unit): Unit =
+    foreachUntil { a =>
+      f(a); false
+    }
 
   /**
    * Applies the supplied function to each element, left to right, but stops when true is returned
@@ -423,15 +426,17 @@ sealed abstract class Chain[+A] {
   }
   // scalastyle:on null return cyclomatic.complexity
 
-  final def iterator: Iterator[A] = this match {
-    case Wrap(seq) => seq.iterator
-    case _         => new ChainIterator[A](this)
-  }
+  final def iterator: Iterator[A] =
+    this match {
+      case Wrap(seq) => seq.iterator
+      case _         => new ChainIterator[A](this)
+    }
 
-  final def reverseIterator: Iterator[A] = this match {
-    case Wrap(seq) => seq.reverseIterator
-    case _         => new ChainReverseIterator[A](this)
-  }
+  final def reverseIterator: Iterator[A] =
+    this match {
+      case Wrap(seq) => seq.reverseIterator
+      case _         => new ChainReverseIterator[A](this)
+    }
 
   /**
    * Returns the number of elements in this structure
@@ -541,19 +546,21 @@ sealed abstract class Chain[+A] {
       result
     }
 
-  final def sortBy[B](f: A => B)(implicit B: Order[B]): Chain[A] = this match {
-    case Empty        => this
-    case Singleton(_) => this
-    case Append(_, _) => Wrap(toVector.sortBy(f)(B.toOrdering))
-    case Wrap(seq)    => Wrap(seq.sortBy(f)(B.toOrdering))
-  }
+  final def sortBy[B](f: A => B)(implicit B: Order[B]): Chain[A] =
+    this match {
+      case Empty        => this
+      case Singleton(_) => this
+      case Append(_, _) => Wrap(toVector.sortBy(f)(B.toOrdering))
+      case Wrap(seq)    => Wrap(seq.sortBy(f)(B.toOrdering))
+    }
 
-  final def sorted[AA >: A](implicit AA: Order[AA]): Chain[AA] = this match {
-    case Empty        => this
-    case Singleton(_) => this
-    case Append(_, _) => Wrap(toVector.sorted(AA.toOrdering))
-    case Wrap(seq)    => Wrap(seq.sorted(AA.toOrdering))
-  }
+  final def sorted[AA >: A](implicit AA: Order[AA]): Chain[AA] =
+    this match {
+      case Empty        => this
+      case Singleton(_) => this
+      case Append(_, _) => Wrap(toVector.sorted(AA.toOrdering))
+      case Wrap(seq)    => Wrap(seq.sorted(AA.toOrdering))
+    }
 }
 
 object Chain extends ChainInstances {
@@ -700,10 +707,11 @@ object Chain extends ChainInstances {
 }
 
 sealed abstract private[data] class ChainInstances extends ChainInstances1 {
-  implicit def catsDataMonoidForChain[A]: Monoid[Chain[A]] = new Monoid[Chain[A]] {
-    def empty: Chain[A] = Chain.nil
-    def combine(c: Chain[A], c2: Chain[A]): Chain[A] = Chain.concat(c, c2)
-  }
+  implicit def catsDataMonoidForChain[A]: Monoid[Chain[A]] =
+    new Monoid[Chain[A]] {
+      def empty: Chain[A] = Chain.nil
+      def combine(c: Chain[A], c2: Chain[A]): Chain[A] = Chain.concat(c, c2)
+    }
 
   implicit val catsDataInstancesForChain
     : Traverse[Chain] with Alternative[Chain] with Monad[Chain] with CoflatMap[Chain] with Align[Chain] =
@@ -865,17 +873,19 @@ sealed abstract private[data] class ChainInstances1 extends ChainInstances2 {
 }
 
 sealed abstract private[data] class ChainInstances2 extends ChainInstances3 {
-  implicit def catsDataHashForChain[A](implicit A: Hash[A]): Hash[Chain[A]] = new Hash[Chain[A]] {
-    def eqv(x: Chain[A], y: Chain[A]): Boolean = x === y
+  implicit def catsDataHashForChain[A](implicit A: Hash[A]): Hash[Chain[A]] =
+    new Hash[Chain[A]] {
+      def eqv(x: Chain[A], y: Chain[A]): Boolean = x === y
 
-    def hash(fa: Chain[A]): Int = fa.hash
-  }
+      def hash(fa: Chain[A]): Int = fa.hash
+    }
 }
 
 sealed abstract private[data] class ChainInstances3 {
-  implicit def catsDataEqForChain[A](implicit A: Eq[A]): Eq[Chain[A]] = new Eq[Chain[A]] {
-    def eqv(x: Chain[A], y: Chain[A]): Boolean = x === y
-  }
+  implicit def catsDataEqForChain[A](implicit A: Eq[A]): Eq[Chain[A]] =
+    new Eq[Chain[A]] {
+      def eqv(x: Chain[A], y: Chain[A]): Boolean = x === y
+    }
 }
 
 private[data] trait ChainPartialOrder[A] extends PartialOrder[Chain[A]] {
diff --git a/core/src/main/scala/cats/data/Cokleisli.scala b/core/src/main/scala/cats/data/Cokleisli.scala
index ccde3d952..be1c898d3 100644
--- a/core/src/main/scala/cats/data/Cokleisli.scala
+++ b/core/src/main/scala/cats/data/Cokleisli.scala
@@ -125,10 +125,11 @@ private[data] class CokleisliMonad[F[_], A] extends Monad[Cokleisli[F, A, *]] {
   def tailRecM[B, C](b: B)(fn: B => Cokleisli[F, A, Either[B, C]]): Cokleisli[F, A, C] =
     Cokleisli { (fa: F[A]) =>
       @tailrec
-      def loop(c: Cokleisli[F, A, Either[B, C]]): C = c.run(fa) match {
-        case Right(c) => c
-        case Left(bb) => loop(fn(bb))
-      }
+      def loop(c: Cokleisli[F, A, Either[B, C]]): C =
+        c.run(fa) match {
+          case Right(c) => c
+          case Left(bb) => loop(fn(bb))
+        }
       loop(fn(b))
     }
 
diff --git a/core/src/main/scala/cats/data/Const.scala b/core/src/main/scala/cats/data/Const.scala
index ab02eb37b..d5b4dcdf5 100644
--- a/core/src/main/scala/cats/data/Const.scala
+++ b/core/src/main/scala/cats/data/Const.scala
@@ -69,72 +69,79 @@ sealed abstract private[data] class ConstInstances extends ConstInstances0 {
       override def minBound: Const[A, B] = Const(A.minBound)
     }
 
-  implicit def catsDataOrderForConst[A: Order, B]: Order[Const[A, B]] = new Order[Const[A, B]] {
-    def compare(x: Const[A, B], y: Const[A, B]): Int =
-      x.compare(y)
-  }
+  implicit def catsDataOrderForConst[A: Order, B]: Order[Const[A, B]] =
+    new Order[Const[A, B]] {
+      def compare(x: Const[A, B], y: Const[A, B]): Int =
+        x.compare(y)
+    }
 
-  implicit def catsDataAlignForConst[A: Semigroup]: Align[Const[A, *]] = new Align[Const[A, *]] {
-    def align[B, C](fa: Const[A, B], fb: Const[A, C]): Const[A, Ior[B, C]] =
-      Const(Semigroup[A].combine(fa.getConst, fb.getConst))
-    def functor: Functor[Const[A, *]] = catsDataFunctorForConst
-  }
+  implicit def catsDataAlignForConst[A: Semigroup]: Align[Const[A, *]] =
+    new Align[Const[A, *]] {
+      def align[B, C](fa: Const[A, B], fb: Const[A, C]): Const[A, Ior[B, C]] =
+        Const(Semigroup[A].combine(fa.getConst, fb.getConst))
+      def functor: Functor[Const[A, *]] = catsDataFunctorForConst
+    }
 
-  implicit def catsDataShowForConst[A: Show, B]: Show[Const[A, B]] = new Show[Const[A, B]] {
-    def show(f: Const[A, B]): String = f.show
-  }
+  implicit def catsDataShowForConst[A: Show, B]: Show[Const[A, B]] =
+    new Show[Const[A, B]] {
+      def show(f: Const[A, B]): String = f.show
+    }
 
-  implicit def catsDataTraverseForConst[C]: Traverse[Const[C, *]] = new Traverse[Const[C, *]] {
-    def foldLeft[A, B](fa: Const[C, A], b: B)(f: (B, A) => B): B = b
+  implicit def catsDataTraverseForConst[C]: Traverse[Const[C, *]] =
+    new Traverse[Const[C, *]] {
+      def foldLeft[A, B](fa: Const[C, A], b: B)(f: (B, A) => B): B = b
 
-    def foldRight[A, B](fa: Const[C, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] = lb
+      def foldRight[A, B](fa: Const[C, A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] = lb
 
-    override def size[A](fa: Const[C, A]): Long = 0L
+      override def size[A](fa: Const[C, A]): Long = 0L
 
-    override def get[A](fa: Const[C, A])(idx: Long): Option[A] = None
+      override def get[A](fa: Const[C, A])(idx: Long): Option[A] = None
 
-    def traverse[G[_]: Applicative, A, B](fa: Const[C, A])(f: A => G[B]): G[Const[C, B]] =
-      fa.traverse(f)
-  }
+      def traverse[G[_]: Applicative, A, B](fa: Const[C, A])(f: A => G[B]): G[Const[C, B]] =
+        fa.traverse(f)
+    }
 
-  implicit def catsDataTraverseFilterForConst[C]: TraverseFilter[Const[C, *]] = new TraverseFilter[Const[C, *]] {
+  implicit def catsDataTraverseFilterForConst[C]: TraverseFilter[Const[C, *]] =
+    new TraverseFilter[Const[C, *]] {
 
-    override def mapFilter[A, B](fa: Const[C, A])(f: (A) => Option[B]): Const[C, B] = fa.retag
+      override def mapFilter[A, B](fa: Const[C, A])(f: (A) => Option[B]): Const[C, B] = fa.retag
 
-    override def collect[A, B](fa: Const[C, A])(f: PartialFunction[A, B]): Const[C, B] = fa.retag
+      override def collect[A, B](fa: Const[C, A])(f: PartialFunction[A, B]): Const[C, B] = fa.retag
 
-    override def flattenOption[A](fa: Const[C, Option[A]]): Const[C, A] = fa.retag
+      override def flattenOption[A](fa: Const[C, Option[A]]): Const[C, A] = fa.retag
 
-    override def filter[A](fa: Const[C, A])(f: (A) => Boolean): Const[C, A] = fa.retag
+      override def filter[A](fa: Const[C, A])(f: (A) => Boolean): Const[C, A] = fa.retag
 
-    override def filterNot[A](fa: Const[C, A])(f: A => Boolean): Const[C, A] = fa.retag
+      override def filterNot[A](fa: Const[C, A])(f: A => Boolean): Const[C, A] = fa.retag
 
-    def traverseFilter[G[_], A, B](
-      fa: Const[C, A]
-    )(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Const[C, B]] =
-      G.pure(fa.retag[B])
+      def traverseFilter[G[_], A, B](
+        fa: Const[C, A]
+      )(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Const[C, B]] =
+        G.pure(fa.retag[B])
 
-    override def filterA[G[_], A](fa: Const[C, A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Const[C, A]] =
-      G.pure(fa)
+      override def filterA[G[_], A](fa: Const[C, A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Const[C, A]] =
+        G.pure(fa)
 
-    val traverse: Traverse[Const[C, *]] = Const.catsDataTraverseForConst[C]
-  }
+      val traverse: Traverse[Const[C, *]] = Const.catsDataTraverseForConst[C]
+    }
 
-  implicit def catsDataMonoidForConst[A: Monoid, B]: Monoid[Const[A, B]] = new Monoid[Const[A, B]] {
-    def empty: Const[A, B] =
-      Const.empty
+  implicit def catsDataMonoidForConst[A: Monoid, B]: Monoid[Const[A, B]] =
+    new Monoid[Const[A, B]] {
+      def empty: Const[A, B] =
+        Const.empty
 
-    def combine(x: Const[A, B], y: Const[A, B]): Const[A, B] =
-      x.combine(y)
-  }
+      def combine(x: Const[A, B], y: Const[A, B]): Const[A, B] =
+        x.combine(y)
+    }
 
   implicit val catsDataBifoldableForConst: Bifoldable[Const] =
     new Bifoldable[Const] {
       def bifoldLeft[A, B, C](fab: Const[A, B], c: C)(f: (C, A) => C, g: (C, B) => C): C =
         f(c, fab.getConst)
 
-      def bifoldRight[A, B, C](fab: Const[A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
-                                                             g: (B, Eval[C]) => Eval[C]): Eval[C] =
+      def bifoldRight[A, B, C](fab: Const[A, B],
+                               c: Eval[C]
+      )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
         f(fab.getConst, c)
     }
 }
@@ -150,8 +157,8 @@ sealed abstract private[data] class ConstInstances0 extends ConstInstances1 {
         fa.retag[(A, B)].combine(fb.retag[(A, B)])
     }
 
-  implicit def catsDataCommutativeApplicativeForConst[C](
-    implicit C: CommutativeMonoid[C]
+  implicit def catsDataCommutativeApplicativeForConst[C](implicit
+    C: CommutativeMonoid[C]
   ): CommutativeApplicative[Const[C, *]] =
     new ConstApplicative[C] with CommutativeApplicative[Const[C, *]] { val C0: CommutativeMonoid[C] = C }
 }
@@ -164,9 +171,10 @@ sealed abstract private[data] class ConstInstances1 extends ConstInstances2 {
 
 sealed abstract private[data] class ConstInstances2 extends ConstInstances3 {
 
-  implicit def catsDataSemigroupForConst[A: Semigroup, B]: Semigroup[Const[A, B]] = new Semigroup[Const[A, B]] {
-    def combine(x: Const[A, B], y: Const[A, B]): Const[A, B] = x.combine(y)
-  }
+  implicit def catsDataSemigroupForConst[A: Semigroup, B]: Semigroup[Const[A, B]] =
+    new Semigroup[Const[A, B]] {
+      def combine(x: Const[A, B], y: Const[A, B]): Const[A, B] = x.combine(y)
+    }
 
   implicit def catsDataPartialOrderForConst[A: PartialOrder, B]: PartialOrder[Const[A, B]] =
     new PartialOrder[Const[A, B]] {
@@ -180,10 +188,11 @@ sealed abstract private[data] class ConstInstances2 extends ConstInstances3 {
 
 sealed abstract private[data] class ConstInstances3 extends ConstInstances4 {
 
-  implicit def catsDataEqForConst[A: Eq, B]: Eq[Const[A, B]] = new Eq[Const[A, B]] {
-    def eqv(x: Const[A, B], y: Const[A, B]): Boolean =
-      x === y
-  }
+  implicit def catsDataEqForConst[A: Eq, B]: Eq[Const[A, B]] =
+    new Eq[Const[A, B]] {
+      def eqv(x: Const[A, B], y: Const[A, B]): Boolean =
+        x === y
+    }
 
   implicit def catsDataApplyForConst[C](implicit C: Semigroup[C]): Apply[Const[C, *]] =
     new ConstApply[C] { val C0: Semigroup[C] = C }
diff --git a/core/src/main/scala/cats/data/ContT.scala b/core/src/main/scala/cats/data/ContT.scala
index 704da6784..c0180a686 100644
--- a/core/src/main/scala/cats/data/ContT.scala
+++ b/core/src/main/scala/cats/data/ContT.scala
@@ -40,7 +40,7 @@ sealed abstract class ContT[M[_], A, +B] extends Serializable {
     // allocate/pattern match once
     val fnAndThen = AndThen(fn)
     ContT[M, A, C] { fn2 =>
-      val contRun: ContT[M, A, C] => M[A] = (_.run(fn2))
+      val contRun: ContT[M, A, C] => M[A] = _.run(fn2)
       val fn3: B => M[A] = fnAndThen.andThen(contRun)
       M.defer(run(fn3))
     }
diff --git a/core/src/main/scala/cats/data/EitherK.scala b/core/src/main/scala/cats/data/EitherK.scala
index 24acdb4bd..a02f65b40 100644
--- a/core/src/main/scala/cats/data/EitherK.scala
+++ b/core/src/main/scala/cats/data/EitherK.scala
@@ -127,16 +127,20 @@ sealed abstract private[data] class EitherKInstances3 {
   implicit def catsDataEqForEitherK[F[_], G[_], A](implicit E: Eq[Either[F[A], G[A]]]): Eq[EitherK[F, G, A]] =
     Eq.by(_.run)
 
-  implicit def catsDataFunctorForEitherK[F[_], G[_]](implicit F0: Functor[F],
-                                                     G0: Functor[G]): Functor[EitherK[F, G, *]] =
+  implicit def catsDataFunctorForEitherK[F[_], G[_]](implicit
+    F0: Functor[F],
+    G0: Functor[G]
+  ): Functor[EitherK[F, G, *]] =
     new EitherKFunctor[F, G] {
       implicit def F: Functor[F] = F0
 
       implicit def G: Functor[G] = G0
     }
 
-  implicit def catsDataFoldableForEitherK[F[_], G[_]](implicit F0: Foldable[F],
-                                                      G0: Foldable[G]): Foldable[EitherK[F, G, *]] =
+  implicit def catsDataFoldableForEitherK[F[_], G[_]](implicit
+    F0: Foldable[F],
+    G0: Foldable[G]
+  ): Foldable[EitherK[F, G, *]] =
     new EitherKFoldable[F, G] {
       implicit def F: Foldable[F] = F0
 
@@ -146,8 +150,10 @@ sealed abstract private[data] class EitherKInstances3 {
 
 sealed abstract private[data] class EitherKInstances2 extends EitherKInstances3 {
 
-  implicit def catsDataContravariantForEitherK[F[_], G[_]](implicit F0: Contravariant[F],
-                                                           G0: Contravariant[G]): Contravariant[EitherK[F, G, *]] =
+  implicit def catsDataContravariantForEitherK[F[_], G[_]](implicit
+    F0: Contravariant[F],
+    G0: Contravariant[G]
+  ): Contravariant[EitherK[F, G, *]] =
     new EitherKContravariant[F, G] {
       implicit def F: Contravariant[F] = F0
 
@@ -156,8 +162,10 @@ sealed abstract private[data] class EitherKInstances2 extends EitherKInstances3
 }
 
 sealed abstract private[data] class EitherKInstances1 extends EitherKInstances2 {
-  implicit def catsDataCoflatMapForEitherK[F[_], G[_]](implicit F0: CoflatMap[F],
-                                                       G0: CoflatMap[G]): CoflatMap[EitherK[F, G, *]] =
+  implicit def catsDataCoflatMapForEitherK[F[_], G[_]](implicit
+    F0: CoflatMap[F],
+    G0: CoflatMap[G]
+  ): CoflatMap[EitherK[F, G, *]] =
     new EitherKCoflatMap[F, G] with EitherKFunctor[F, G] {
       implicit def F: CoflatMap[F] = F0
 
@@ -166,8 +174,10 @@ sealed abstract private[data] class EitherKInstances1 extends EitherKInstances2
 }
 
 sealed abstract private[data] class EitherKInstances0 extends EitherKInstances1 {
-  implicit def catsDataTraverseForEitherK[F[_], G[_]](implicit F0: Traverse[F],
-                                                      G0: Traverse[G]): Traverse[EitherK[F, G, *]] =
+  implicit def catsDataTraverseForEitherK[F[_], G[_]](implicit
+    F0: Traverse[F],
+    G0: Traverse[G]
+  ): Traverse[EitherK[F, G, *]] =
     new EitherKTraverse[F, G] with EitherKFunctor[F, G] {
       implicit def F: Traverse[F] = F0
 
@@ -177,8 +187,10 @@ sealed abstract private[data] class EitherKInstances0 extends EitherKInstances1
 
 sealed abstract private[data] class EitherKInstances extends EitherKInstances0 {
 
-  implicit def catsDataComonadForEitherK[F[_], G[_]](implicit F0: Comonad[F],
-                                                     G0: Comonad[G]): Comonad[EitherK[F, G, *]] =
+  implicit def catsDataComonadForEitherK[F[_], G[_]](implicit
+    F0: Comonad[F],
+    G0: Comonad[G]
+  ): Comonad[EitherK[F, G, *]] =
     new EitherKComonad[F, G] with EitherKFunctor[F, G] {
       implicit def F: Comonad[F] = F0
 
diff --git a/core/src/main/scala/cats/data/EitherT.scala b/core/src/main/scala/cats/data/EitherT.scala
index 1f693de06..16f242a74 100644
--- a/core/src/main/scala/cats/data/EitherT.scala
+++ b/core/src/main/scala/cats/data/EitherT.scala
@@ -368,8 +368,10 @@ final case class EitherT[F[_], A, B](value: F[Either[A, B]]) {
       }
     )
 
-  def bitraverse[G[_], C, D](f: A => G[C], g: B => G[D])(implicit traverseF: Traverse[F],
-                                                         applicativeG: Applicative[G]): G[EitherT[F, C, D]] =
+  def bitraverse[G[_], C, D](f: A => G[C], g: B => G[D])(implicit
+    traverseF: Traverse[F],
+    applicativeG: Applicative[G]
+  ): G[EitherT[F, C, D]] =
     applicativeG.map(traverseF.traverse(value)(axb => Bitraverse[Either].bitraverse(axb)(f, g)))(EitherT.apply)
 
   def biflatMap[C, D](fa: A => EitherT[F, C, D], fb: B => EitherT[F, C, D])(implicit F: FlatMap[F]): EitherT[F, C, D] =
@@ -462,8 +464,9 @@ final case class EitherT[F[_], A, B](value: F[Either[A, B]]) {
   def ===(that: EitherT[F, A, B])(implicit eq: Eq[F[Either[A, B]]]): Boolean =
     eq.eqv(value, that.value)
 
-  def traverse[G[_], D](f: B => G[D])(implicit traverseF: Traverse[F],
-                                      applicativeG: Applicative[G]): G[EitherT[F, A, D]] =
+  def traverse[G[_], D](
+    f: B => G[D]
+  )(implicit traverseF: Traverse[F], applicativeG: Applicative[G]): G[EitherT[F, A, D]] =
     applicativeG.map(traverseF.traverse(value)(axb => Traverse[Either[A, *]].traverse(axb)(f)))(EitherT.apply)
 
   def foldLeft[C](c: C)(f: (C, B) => C)(implicit F: Foldable[F]): C =
@@ -759,7 +762,9 @@ object EitherT extends EitherTInstances {
    * }}}
    */
   final def liftAttemptK[F[_], E](implicit F: ApplicativeError[F, E]): F ~> EitherT[F, E, *] =
-    Î»[F ~> EitherT[F, E, *]](fa => EitherT(F.attempt(fa)))
+    new (F ~> EitherT[F, E, *]) {
+      def apply[A](fa: F[A]): EitherT[F, E, A] = EitherT(F.attempt(fa))
+    }
 
   @deprecated("Use EitherT.liftF.", "1.0.0-RC1")
   final def liftT[F[_], A, B](fb: F[B])(implicit F: Functor[F]): EitherT[F, A, B] = right(fb)
@@ -889,8 +894,8 @@ abstract private[data] class EitherTInstances extends EitherTInstances1 {
         EitherT(F.defer(fa.value))
     }
 
-  implicit def catsDataParallelForEitherTWithParallelEffect[M[_], E: Semigroup](
-    implicit P: Parallel[M]
+  implicit def catsDataParallelForEitherTWithParallelEffect[M[_], E: Semigroup](implicit
+    P: Parallel[M]
   ): Parallel.Aux[EitherT[M, E, *], Nested[P.F, Validated[E, *], *]] =
     new Parallel[EitherT[M, E, *]] {
       type F[x] = Nested[P.F, Validated[E, *], x]
@@ -923,8 +928,8 @@ abstract private[data] class EitherTInstances extends EitherTInstances1 {
 
 abstract private[data] class EitherTInstances1 extends EitherTInstances2 {
 
-  implicit def catsSemigroupForEitherT[F[_], L, A](
-    implicit F: Semigroup[F[Either[L, A]]]
+  implicit def catsSemigroupForEitherT[F[_], L, A](implicit
+    F: Semigroup[F[Either[L, A]]]
   ): Semigroup[EitherT[F, L, A]] =
     new EitherTSemigroup[F, L, A] { implicit val F0 = F }
 
@@ -933,8 +938,8 @@ abstract private[data] class EitherTInstances1 extends EitherTInstances2 {
       val F0: Foldable[F] = F
     }
 
-  implicit def catsDataPartialOrderForEitherT[F[_], L, R](
-    implicit F: PartialOrder[F[Either[L, R]]]
+  implicit def catsDataPartialOrderForEitherT[F[_], L, R](implicit
+    F: PartialOrder[F[Either[L, R]]]
   ): PartialOrder[EitherT[F, L, R]] =
     new EitherTPartialOrder[F, L, R] {
       val F0: PartialOrder[F[Either[L, R]]] = F
@@ -998,8 +1003,8 @@ abstract private[data] class EitherTInstances2 extends EitherTInstances3 {
    * res0: cats.data.EitherT[Option,String,Int] = EitherT(Some(Right(1)))
    * }}}
    */
-  implicit def catsDataMonadErrorFForEitherT[F[_], E, L](
-    implicit FE0: MonadError[F, E]
+  implicit def catsDataMonadErrorFForEitherT[F[_], E, L](implicit
+    FE0: MonadError[F, E]
   ): MonadError[EitherT[F, L, *], E] =
     new EitherTMonadErrorF[F, E, L] { implicit val F = FE0 }
 
@@ -1110,8 +1115,9 @@ sealed private[data] trait EitherTBifoldable[F[_]] extends Bifoldable[EitherT[F,
   def bifoldLeft[A, B, C](fab: EitherT[F, A, B], c: C)(f: (C, A) => C, g: (C, B) => C): C =
     F0.foldLeft(fab.value, c)((acc, axb) => Bifoldable[Either].bifoldLeft(axb, acc)(f, g))
 
-  def bifoldRight[A, B, C](fab: EitherT[F, A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
-                                                              g: (B, Eval[C]) => Eval[C]): Eval[C] =
+  def bifoldRight[A, B, C](fab: EitherT[F, A, B],
+                           c: Eval[C]
+  )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
     F0.foldRight(fab.value, c)((axb, acc) => Bifoldable[Either].bifoldRight(axb, acc)(f, g))
 }
 
diff --git a/core/src/main/scala/cats/data/Func.scala b/core/src/main/scala/cats/data/Func.scala
index 1c2daad80..678262263 100644
--- a/core/src/main/scala/cats/data/Func.scala
+++ b/core/src/main/scala/cats/data/Func.scala
@@ -57,8 +57,8 @@ abstract private[data] class FuncInstances1 {
       def F: Functor[F] = FF
     }
 
-  implicit def catsDataContravariantForFunc[F[_], C](
-    implicit FC: Contravariant[F]
+  implicit def catsDataContravariantForFunc[F[_], C](implicit
+    FC: Contravariant[F]
   ): Contravariant[Î»[Î± => Func[F, Î±, C]]] =
     new FuncContravariant[F, C] {
       def F: Contravariant[F] = FC
diff --git a/core/src/main/scala/cats/data/IdT.scala b/core/src/main/scala/cats/data/IdT.scala
index dff13cc5c..fc3276065 100644
--- a/core/src/main/scala/cats/data/IdT.scala
+++ b/core/src/main/scala/cats/data/IdT.scala
@@ -139,8 +139,8 @@ sealed private[data] trait IdTNonEmptyTraverse[F[_]]
 }
 
 sealed abstract private[data] class IdTInstances8 {
-  implicit def catsDataCommutativeFlatMapForIdT[F[_]](
-    implicit F: CommutativeFlatMap[F]
+  implicit def catsDataCommutativeFlatMapForIdT[F[_]](implicit
+    F: CommutativeFlatMap[F]
   ): CommutativeFlatMap[IdT[F, *]] =
     new IdTFlatMap[F] with CommutativeFlatMap[IdT[F, *]] { implicit val F0: CommutativeFlatMap[F] = F }
 }
@@ -151,8 +151,8 @@ sealed abstract private[data] class IdTInstances7 extends IdTInstances8 {
 }
 
 sealed abstract private[data] class IdTInstances6 extends IdTInstances7 {
-  implicit def catsDataContravariantMonoidalForIdT[F[_]](
-    implicit F: ContravariantMonoidal[F]
+  implicit def catsDataContravariantMonoidalForIdT[F[_]](implicit
+    F: ContravariantMonoidal[F]
   ): ContravariantMonoidal[IdT[F, *]] =
     new IdTContravariantMonoidal[F] { implicit val F0: ContravariantMonoidal[F] = F }
 }
diff --git a/core/src/main/scala/cats/data/IndexedReaderWriterStateT.scala b/core/src/main/scala/cats/data/IndexedReaderWriterStateT.scala
index c45c3df61..d4d260cf9 100644
--- a/core/src/main/scala/cats/data/IndexedReaderWriterStateT.scala
+++ b/core/src/main/scala/cats/data/IndexedReaderWriterStateT.scala
@@ -292,15 +292,17 @@ sealed private[data] trait CommonIRWSTConstructors {
   /**
    * Return `a` and an empty log without modifying the input state.
    */
-  def pure[F[_], E, L, S, A](a: A)(implicit F: Applicative[F],
-                                   L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def pure[F[_], E, L, S, A](
+    a: A
+  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.pure((L.empty, s, a)))
 
   /**
    * Return an effectful `a` and an empty log without modifying the input state.
    */
-  def liftF[F[_], E, L, S, A](fa: F[A])(implicit F: Applicative[F],
-                                        L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def liftF[F[_], E, L, S, A](
+    fa: F[A]
+  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.map(fa)((L.empty, s, _)))
 
   /**
@@ -319,36 +321,41 @@ sealed private[data] trait CommonIRWSTConstructors {
     }
 
   @deprecated("Use liftF instead", "1.0.0-RC2")
-  def lift[F[_], E, L, S, A](fa: F[A])(implicit F: Applicative[F],
-                                       L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def lift[F[_], E, L, S, A](
+    fa: F[A]
+  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.map(fa)((L.empty, s, _)))
 
   /**
    * Inspect a value from the input state, without modifying the state.
    */
-  def inspect[F[_], E, L, S, A](f: S => A)(implicit F: Applicative[F],
-                                           L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def inspect[F[_], E, L, S, A](
+    f: S => A
+  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.pure((L.empty, s, f(s))))
 
   /**
    * Like [[inspect]], but using an effectful function.
    */
-  def inspectF[F[_], E, L, S, A](f: S => F[A])(implicit F: Applicative[F],
-                                               L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
+  def inspectF[F[_], E, L, S, A](
+    f: S => F[A]
+  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, A] =
     IndexedReaderWriterStateT((_, s) => F.map(f(s))((L.empty, s, _)))
 
   /**
    * Set the state to `s`.
    */
-  def set[F[_], E, L, S](s: S)(implicit F: Applicative[F],
-                               L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, Unit] =
+  def set[F[_], E, L, S](
+    s: S
+  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, Unit] =
     IndexedReaderWriterStateT((_, _) => F.pure((L.empty, s, ())))
 
   /**
    * Like [[set]], but using an effectful `S` value.
    */
-  def setF[F[_], E, L, S](fs: F[S])(implicit F: Applicative[F],
-                                    L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, Unit] =
+  def setF[F[_], E, L, S](
+    fs: F[S]
+  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, S, S, Unit] =
     IndexedReaderWriterStateT((_, _) => F.map(fs)((L.empty, _, ())))
 
   /**
@@ -395,15 +402,17 @@ object IndexedReaderWriterStateT extends IRWSTInstances with CommonIRWSTConstruc
   /**
    * Modify the input state using `f`.
    */
-  def modify[F[_], E, L, SA, SB](f: SA => SB)(implicit F: Applicative[F],
-                                              L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, SA, SB, Unit] =
+  def modify[F[_], E, L, SA, SB](
+    f: SA => SB
+  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, SA, SB, Unit] =
     IndexedReaderWriterStateT((_, s) => F.pure((L.empty, f(s), ())))
 
   /**
    * Like [[modify]], but using an effectful function.
    */
-  def modifyF[F[_], E, L, SA, SB](f: SA => F[SB])(implicit F: Applicative[F],
-                                                  L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, SA, SB, Unit] =
+  def modifyF[F[_], E, L, SA, SB](
+    f: SA => F[SB]
+  )(implicit F: Applicative[F], L: Monoid[L]): IndexedReaderWriterStateT[F, E, L, SA, SB, Unit] =
     IndexedReaderWriterStateT((_, s) => F.map(f(s))((L.empty, _, ())))
 
   /**
@@ -451,12 +460,13 @@ abstract private[data] class RWSTFunctions extends CommonIRWSTConstructors {
   /**
    * Like [[modify]], but using an effectful function.
    */
-  def modifyF[F[_], E, L, S](f: S => F[S])(implicit F: Applicative[F],
-                                           L: Monoid[L]): ReaderWriterStateT[F, E, L, S, Unit] =
+  def modifyF[F[_], E, L, S](
+    f: S => F[S]
+  )(implicit F: Applicative[F], L: Monoid[L]): ReaderWriterStateT[F, E, L, S, Unit] =
     ReaderWriterStateT((_, s) => F.map(f(s))((L.empty, _, ())))
 
-  def listen[F[_], E, L, S, A](rwst: ReaderWriterStateT[F, E, L, S, A])(
-    implicit F: Functor[F]
+  def listen[F[_], E, L, S, A](rwst: ReaderWriterStateT[F, E, L, S, A])(implicit
+    F: Functor[F]
   ): ReaderWriterStateT[F, E, L, S, (A, L)] = rwst.listen
 }
 
@@ -519,29 +529,29 @@ abstract private[data] class RWSFunctions {
 
 sealed abstract private[data] class IRWSTInstances extends IRWSTInstances1 {
 
-  implicit def catsDataStrongForIRWST[F[_], E, L, T](
-    implicit F0: Monad[F]
+  implicit def catsDataStrongForIRWST[F[_], E, L, T](implicit
+    F0: Monad[F]
   ): Strong[IndexedReaderWriterStateT[F, E, L, *, *, T]] =
     new IRWSTStrong[F, E, L, T] {
       implicit def F: Monad[F] = F0
     }
 
-  implicit def catsDataBifunctorForIRWST[F[_], E, L, SA](
-    implicit F0: Functor[F]
+  implicit def catsDataBifunctorForIRWST[F[_], E, L, SA](implicit
+    F0: Functor[F]
   ): Bifunctor[IndexedReaderWriterStateT[F, E, L, SA, *, *]] =
     new IRWSTBifunctor[F, E, L, SA] {
       implicit def F: Functor[F] = F0
     }
 
-  implicit def catsDataContravariantForIRWST[F[_], E, L, SB, T](
-    implicit F0: Functor[F]
+  implicit def catsDataContravariantForIRWST[F[_], E, L, SB, T](implicit
+    F0: Functor[F]
   ): Contravariant[IndexedReaderWriterStateT[F, E, L, *, SB, T]] =
     new IRWSTContravariant[F, E, L, SB, T] {
       implicit def F: Functor[F] = F0
     }
 
-  implicit def catsDataMonadErrorForIRWST[F[_], E, L, S, R](
-    implicit F0: MonadError[F, R],
+  implicit def catsDataMonadErrorForIRWST[F[_], E, L, S, R](implicit
+    F0: MonadError[F, R],
     L0: Monoid[L]
   ): MonadError[IndexedReaderWriterStateT[F, E, L, S, S, *], R] =
     new RWSTMonadError[F, E, L, S, R] {
@@ -549,8 +559,8 @@ sealed abstract private[data] class IRWSTInstances extends IRWSTInstances1 {
       implicit def L: Monoid[L] = L0
     }
 
-  implicit def catsDataDeferForIRWST[F[_], E, L, SA, SB](
-    implicit F: Defer[F]
+  implicit def catsDataDeferForIRWST[F[_], E, L, SA, SB](implicit
+    F: Defer[F]
   ): Defer[IndexedReaderWriterStateT[F, E, L, SA, SB, *]] =
     new Defer[IndexedReaderWriterStateT[F, E, L, SA, SB, *]] {
       def defer[A](
@@ -562,15 +572,17 @@ sealed abstract private[data] class IRWSTInstances extends IRWSTInstances1 {
 }
 
 sealed abstract private[data] class IRWSTInstances1 extends IRWSTInstances2 {
-  implicit def catsDataMonadForRWST[F[_], E, L, S](implicit F0: Monad[F],
-                                                   L0: Monoid[L]): Monad[ReaderWriterStateT[F, E, L, S, *]] =
+  implicit def catsDataMonadForRWST[F[_], E, L, S](implicit
+    F0: Monad[F],
+    L0: Monoid[L]
+  ): Monad[ReaderWriterStateT[F, E, L, S, *]] =
     new RWSTMonad[F, E, L, S] {
       implicit def F: Monad[F] = F0
       implicit def L: Monoid[L] = L0
     }
 
-  implicit def catsDataProfunctorForIRWST[F[_], E, L, T](
-    implicit F0: Functor[F]
+  implicit def catsDataProfunctorForIRWST[F[_], E, L, T](implicit
+    F0: Functor[F]
   ): Profunctor[IndexedReaderWriterStateT[F, E, L, *, *, T]] =
     new IRWSTProfunctor[F, E, L, T] {
       implicit def F: Functor[F] = F0
@@ -579,8 +591,8 @@ sealed abstract private[data] class IRWSTInstances1 extends IRWSTInstances2 {
 }
 
 sealed abstract private[data] class IRWSTInstances2 extends IRWSTInstances3 {
-  implicit def catsDataAlternativeForIRWST[F[_], E, L, S](
-    implicit FM: Monad[F],
+  implicit def catsDataAlternativeForIRWST[F[_], E, L, S](implicit
+    FM: Monad[F],
     FA: Alternative[F],
     L0: Monoid[L]
   ): Alternative[IndexedReaderWriterStateT[F, E, L, S, S, *]] =
@@ -592,8 +604,8 @@ sealed abstract private[data] class IRWSTInstances2 extends IRWSTInstances3 {
 }
 
 sealed abstract private[data] class IRWSTInstances3 {
-  implicit def catsDataSemigroupKForIRWST[F[_], E, L, SA, SB](
-    implicit F0: Monad[F],
+  implicit def catsDataSemigroupKForIRWST[F[_], E, L, SA, SB](implicit
+    F0: Monad[F],
     G0: SemigroupK[F]
   ): SemigroupK[IndexedReaderWriterStateT[F, E, L, SA, SB, *]] =
     new IRWSTSemigroupK[F, E, L, SA, SB] {
@@ -601,8 +613,8 @@ sealed abstract private[data] class IRWSTInstances3 {
       implicit def G: SemigroupK[F] = G0
     }
 
-  implicit def catsDataFunctorForIRWST[F[_], E, L, SA, SB](
-    implicit F0: Functor[F]
+  implicit def catsDataFunctorForIRWST[F[_], E, L, SA, SB](implicit
+    F0: Functor[F]
   ): Functor[IndexedReaderWriterStateT[F, E, L, SA, SB, *]] =
     new IRWSTFunctor[F, E, L, SA, SB] {
       implicit def F: Functor[F] = F0
@@ -729,7 +741,8 @@ private trait IRWSTSemigroupK1[F[_], E, L, SA, SB] extends SemigroupK[IndexedRea
   implicit def G: SemigroupK[F]
 
   def combineK[A](x: IndexedReaderWriterStateT[F, E, L, SA, SB, A],
-                  y: IndexedReaderWriterStateT[F, E, L, SA, SB, A]): IndexedReaderWriterStateT[F, E, L, SA, SB, A] =
+                  y: IndexedReaderWriterStateT[F, E, L, SA, SB, A]
+  ): IndexedReaderWriterStateT[F, E, L, SA, SB, A] =
     IndexedReaderWriterStateT { (e, sa) =>
       G.combineK(x.run(e, sa), y.run(e, sa))
     }
diff --git a/core/src/main/scala/cats/data/IndexedStateT.scala b/core/src/main/scala/cats/data/IndexedStateT.scala
index 43dac315a..758ff042d 100644
--- a/core/src/main/scala/cats/data/IndexedStateT.scala
+++ b/core/src/main/scala/cats/data/IndexedStateT.scala
@@ -119,8 +119,9 @@ final class IndexedStateT[F[_], SA, SB, A](val runF: F[SA => F[(SB, A)]]) extend
    * res1: Option[(Int, Int)] = Some((5,5))
    * }}}
    */
-  def transformF[G[_], B, SC](f: F[(SB, A)] => G[(SC, B)])(implicit F: FlatMap[F],
-                                                           G: Applicative[G]): IndexedStateT[G, SA, SC, B] =
+  def transformF[G[_], B, SC](
+    f: F[(SB, A)] => G[(SC, B)]
+  )(implicit F: FlatMap[F], G: Applicative[G]): IndexedStateT[G, SA, SC, B] =
     IndexedStateT(s => f(run(s)))
 
   /**
@@ -247,8 +248,8 @@ abstract private[data] class StateTFunctions extends CommonStateTConstructors {
 }
 
 sealed abstract private[data] class IndexedStateTInstances extends IndexedStateTInstances1 {
-  implicit def catsDataAlternativeForIndexedStateT[F[_], S](
-    implicit FM: Monad[F],
+  implicit def catsDataAlternativeForIndexedStateT[F[_], S](implicit
+    FM: Monad[F],
     FA: Alternative[F]
   ): Alternative[IndexedStateT[F, S, S, *]] with Monad[IndexedStateT[F, S, S, *]] =
     new IndexedStateTAlternative[F, S] { implicit def F = FM; implicit def G = FA }
@@ -259,8 +260,7 @@ sealed abstract private[data] class IndexedStateTInstances extends IndexedStateT
         IndexedStateT.applyF(F.defer(fa.runF))
     }
 
-  implicit def catsDataFunctorFilterForIndexedStateT[F[_], SA, SB](
-    implicit
+  implicit def catsDataFunctorFilterForIndexedStateT[F[_], SA, SB](implicit
     ev1: Monad[F],
     ev2: FunctorFilter[F]
   ): FunctorFilter[IndexedStateT[F, SA, SB, *]] =
@@ -271,13 +271,13 @@ sealed abstract private[data] class IndexedStateTInstances extends IndexedStateT
 }
 
 sealed abstract private[data] class IndexedStateTInstances1 extends IndexedStateTInstances2 {
-  implicit def catsDataMonadErrorForIndexedStateT[F[_], S, E](
-    implicit F0: MonadError[F, E]
+  implicit def catsDataMonadErrorForIndexedStateT[F[_], S, E](implicit
+    F0: MonadError[F, E]
   ): MonadError[IndexedStateT[F, S, S, *], E] =
     new IndexedStateTMonadError[F, S, E] { implicit def F = F0 }
 
-  implicit def catsDataSemigroupKForIndexedStateT[F[_], SA, SB](
-    implicit F0: Monad[F],
+  implicit def catsDataSemigroupKForIndexedStateT[F[_], SA, SB](implicit
+    F0: Monad[F],
     G0: SemigroupK[F]
   ): SemigroupK[IndexedStateT[F, SA, SB, *]] =
     new IndexedStateTSemigroupK[F, SA, SB] { implicit def F = F0; implicit def G = G0 }
@@ -289,23 +289,23 @@ sealed abstract private[data] class IndexedStateTInstances2 extends IndexedState
 }
 
 sealed abstract private[data] class IndexedStateTInstances3 extends IndexedStateTInstances4 {
-  implicit def catsDataFunctorForIndexedStateT[F[_], SA, SB](
-    implicit F0: Functor[F]
+  implicit def catsDataFunctorForIndexedStateT[F[_], SA, SB](implicit
+    F0: Functor[F]
   ): Functor[IndexedStateT[F, SA, SB, *]] =
     new IndexedStateTFunctor[F, SA, SB] { implicit def F = F0 }
 
-  implicit def catsDataContravariantForIndexedStateT[F[_], SB, V](
-    implicit F0: Functor[F]
+  implicit def catsDataContravariantForIndexedStateT[F[_], SB, V](implicit
+    F0: Functor[F]
   ): Contravariant[IndexedStateT[F, *, SB, V]] =
     new IndexedStateTContravariant[F, SB, V] { implicit def F = F0 }
 
-  implicit def catsDataProfunctorForIndexedStateT[F[_], V](
-    implicit F0: Functor[F]
+  implicit def catsDataProfunctorForIndexedStateT[F[_], V](implicit
+    F0: Functor[F]
   ): Profunctor[IndexedStateT[F, *, *, V]] =
     new IndexedStateTProfunctor[F, V] { implicit def F = F0 }
 
-  implicit def catsDataBifunctorForIndexedStateT[F[_], SA](
-    implicit F0: Functor[F]
+  implicit def catsDataBifunctorForIndexedStateT[F[_], SA](implicit
+    F0: Functor[F]
   ): Bifunctor[IndexedStateT[F, SA, *, *]] =
     new IndexedStateTBifunctor[F, SA] { implicit def F = F0 }
 }
@@ -465,11 +465,13 @@ sealed abstract private[data] class IndexedStateTContravariantMonoidal[F[_], S]
     contramap2(fa, trivial)(((a: A) => (a, a)).compose(f))
 
   override def product[A, B](fa: IndexedStateT[F, S, S, A],
-                             fb: IndexedStateT[F, S, S, B]): IndexedStateT[F, S, S, (A, B)] =
+                             fb: IndexedStateT[F, S, S, B]
+  ): IndexedStateT[F, S, S, (A, B)] =
     contramap2(fa, fb)(identity)
 
-  def contramap2[A, B, C](fb: IndexedStateT[F, S, S, B],
-                          fc: IndexedStateT[F, S, S, C])(f: A => (B, C)): IndexedStateT[F, S, S, A] =
+  def contramap2[A, B, C](fb: IndexedStateT[F, S, S, B], fc: IndexedStateT[F, S, S, C])(
+    f: A => (B, C)
+  ): IndexedStateT[F, S, S, A] =
     IndexedStateT.applyF(
       G.pure((s: S) =>
         ContravariantMonoidal.contramap2(G.map(fb.runF)(_.apply(s)), G.map(fc.runF)(_.apply(s)))((tup: (S, A)) =>
diff --git a/core/src/main/scala/cats/data/Ior.scala b/core/src/main/scala/cats/data/Ior.scala
index 6404160aa..5230df208 100644
--- a/core/src/main/scala/cats/data/Ior.scala
+++ b/core/src/main/scala/cats/data/Ior.scala
@@ -47,11 +47,12 @@ sealed abstract class Ior[+A, +B] extends Product with Serializable {
    * res2: String = abc123
    * }}}
    */
-  final def fold[C](fa: A => C, fb: B => C, fab: (A, B) => C): C = this match {
-    case Ior.Left(a)    => fa(a)
-    case Ior.Right(b)   => fb(b)
-    case Ior.Both(a, b) => fab(a, b)
-  }
+  final def fold[C](fa: A => C, fb: B => C, fab: (A, B) => C): C =
+    this match {
+      case Ior.Left(a)    => fa(a)
+      case Ior.Right(b)   => fb(b)
+      case Ior.Both(a, b) => fab(a, b)
+    }
 
   /**
    * Example:
@@ -562,27 +563,29 @@ sealed abstract class Ior[+A, +B] extends Product with Serializable {
    * res5: Ior[String, Int] = Both(abcerror,456)
    * }}}
    */
-  final def flatMap[AA >: A, D](f: B => AA Ior D)(implicit AA: Semigroup[AA]): AA Ior D = this match {
-    case l @ Ior.Left(_) => l
-    case Ior.Right(b)    => f(b)
-    case Ior.Both(a1, b) =>
-      f(b) match {
-        case Ior.Left(a2)    => Ior.Left(AA.combine(a1, a2))
-        case Ior.Right(b)    => Ior.Both(a1, b)
-        case Ior.Both(a2, d) => Ior.Both(AA.combine(a1, a2), d)
-      }
-  }
+  final def flatMap[AA >: A, D](f: B => AA Ior D)(implicit AA: Semigroup[AA]): AA Ior D =
+    this match {
+      case l @ Ior.Left(_) => l
+      case Ior.Right(b)    => f(b)
+      case Ior.Both(a1, b) =>
+        f(b) match {
+          case Ior.Left(a2)    => Ior.Left(AA.combine(a1, a2))
+          case Ior.Right(b)    => Ior.Both(a1, b)
+          case Ior.Both(a2, d) => Ior.Both(AA.combine(a1, a2), d)
+        }
+    }
 
   final def foreach(f: B => Unit): Unit = {
     bimap(_ => (), f)
     ()
   }
 
-  final def traverse[F[_], AA >: A, D](g: B => F[D])(implicit F: Applicative[F]): F[AA Ior D] = this match {
-    case Ior.Left(a)    => F.pure(Ior.left(a))
-    case Ior.Right(b)   => F.map(g(b))(Ior.right)
-    case Ior.Both(a, b) => F.map(g(b))(d => Ior.both(a, d))
-  }
+  final def traverse[F[_], AA >: A, D](g: B => F[D])(implicit F: Applicative[F]): F[AA Ior D] =
+    this match {
+      case Ior.Left(a)    => F.pure(Ior.left(a))
+      case Ior.Right(b)   => F.map(g(b))(Ior.right)
+      case Ior.Both(a, b) => F.map(g(b))(d => Ior.both(a, d))
+    }
 
   /**
    * Example:
@@ -662,17 +665,19 @@ sealed abstract class Ior[+A, +B] extends Product with Serializable {
     }
   // scalastyle:on cyclomatic.complexity
 
-  final def ===[AA >: A, BB >: B](that: AA Ior BB)(implicit AA: Eq[AA], BB: Eq[BB]): Boolean = fold(
-    a => that.fold(a2 => AA.eqv(a, a2), b2 => false, (a2, b2) => false),
-    b => that.fold(a2 => false, b2 => BB.eqv(b, b2), (a2, b2) => false),
-    (a, b) => that.fold(a2 => false, b2 => false, (a2, b2) => AA.eqv(a, a2) && BB.eqv(b, b2))
-  )
-
-  final def show[AA >: A, BB >: B](implicit AA: Show[AA], BB: Show[BB]): String = fold(
-    a => s"Ior.Left(${AA.show(a)})",
-    b => s"Ior.Right(${BB.show(b)})",
-    (a, b) => s"Ior.Both(${AA.show(a)}, ${BB.show(b)})"
-  )
+  final def ===[AA >: A, BB >: B](that: AA Ior BB)(implicit AA: Eq[AA], BB: Eq[BB]): Boolean =
+    fold(
+      a => that.fold(a2 => AA.eqv(a, a2), b2 => false, (a2, b2) => false),
+      b => that.fold(a2 => false, b2 => BB.eqv(b, b2), (a2, b2) => false),
+      (a, b) => that.fold(a2 => false, b2 => false, (a2, b2) => AA.eqv(a, a2) && BB.eqv(b, b2))
+    )
+
+  final def show[AA >: A, BB >: B](implicit AA: Show[AA], BB: Show[BB]): String =
+    fold(
+      a => s"Ior.Left(${AA.show(a)})",
+      b => s"Ior.Right(${BB.show(b)})",
+      (a, b) => s"Ior.Both(${AA.show(a)}, ${BB.show(b)})"
+    )
 }
 
 object Ior extends IorInstances with IorFunctions with IorFunctions2 {
@@ -685,8 +690,9 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
 
   implicit val catsBitraverseForIor: Bitraverse[Ior] = new Bitraverse[Ior] {
 
-    def bitraverse[G[_], A, B, C, D](fab: Ior[A, B])(f: A => G[C],
-                                                     g: B => G[D])(implicit G: Applicative[G]): G[Ior[C, D]] =
+    def bitraverse[G[_], A, B, C, D](
+      fab: Ior[A, B]
+    )(f: A => G[C], g: B => G[D])(implicit G: Applicative[G]): G[Ior[C, D]] =
       fab match {
         case Ior.Left(a)    => G.map(f(a))(Ior.Left(_))
         case Ior.Right(b)   => G.map(g(b))(Ior.Right(_))
@@ -700,8 +706,9 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
         case Ior.Both(a, b) => g(f(c, a), b)
       }
 
-    def bifoldRight[A, B, C](fab: Ior[A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
-                                                         g: (B, Eval[C]) => Eval[C]): Eval[C] =
+    def bifoldRight[A, B, C](fab: Ior[A, B],
+                             c: Eval[C]
+    )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
       fab match {
         case Ior.Left(a)    => f(a, c)
         case Ior.Right(b)   => g(b, c)
@@ -709,17 +716,20 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
       }
   }
 
-  implicit def catsDataEqForIor[A: Eq, B: Eq]: Eq[A Ior B] = new Eq[A Ior B] {
-    def eqv(x: A Ior B, y: A Ior B): Boolean = x === y
-  }
+  implicit def catsDataEqForIor[A: Eq, B: Eq]: Eq[A Ior B] =
+    new Eq[A Ior B] {
+      def eqv(x: A Ior B, y: A Ior B): Boolean = x === y
+    }
 
-  implicit def catsDataShowForIor[A: Show, B: Show]: Show[A Ior B] = new Show[A Ior B] {
-    def show(f: A Ior B): String = f.show
-  }
+  implicit def catsDataShowForIor[A: Show, B: Show]: Show[A Ior B] =
+    new Show[A Ior B] {
+      def show(f: A Ior B): String = f.show
+    }
 
-  implicit def catsDataSemigroupForIor[A: Semigroup, B: Semigroup]: Semigroup[Ior[A, B]] = new Semigroup[Ior[A, B]] {
-    def combine(x: Ior[A, B], y: Ior[A, B]) = x.combine(y)
-  }
+  implicit def catsDataSemigroupForIor[A: Semigroup, B: Semigroup]: Semigroup[Ior[A, B]] =
+    new Semigroup[Ior[A, B]] {
+      def combine(x: Ior[A, B], y: Ior[A, B]) = x.combine(y)
+    }
 
   implicit def catsDataMonadErrorForIor[A: Semigroup]: MonadError[Ior[A, *], A] =
     new MonadError[Ior[A, *], A] {
@@ -742,18 +752,19 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
 
       def tailRecM[B, C](b: B)(fn: B => Ior[A, Either[B, C]]): A Ior C = {
         @tailrec
-        def loop(v: Ior[A, Either[B, C]]): A Ior C = v match {
-          case Ior.Left(a)           => Ior.left(a)
-          case Ior.Right(Right(c))   => Ior.right(c)
-          case Ior.Both(a, Right(c)) => Ior.both(a, c)
-          case Ior.Right(Left(b))    => loop(fn(b))
-          case Ior.Both(a, Left(b)) =>
-            fn(b) match {
-              case Ior.Left(aa)    => Ior.left(Semigroup[A].combine(a, aa))
-              case Ior.Both(aa, x) => loop(Ior.both(Semigroup[A].combine(a, aa), x))
-              case Ior.Right(x)    => loop(Ior.both(a, x))
-            }
-        }
+        def loop(v: Ior[A, Either[B, C]]): A Ior C =
+          v match {
+            case Ior.Left(a)           => Ior.left(a)
+            case Ior.Right(Right(c))   => Ior.right(c)
+            case Ior.Both(a, Right(c)) => Ior.both(a, c)
+            case Ior.Right(Left(b))    => loop(fn(b))
+            case Ior.Both(a, Left(b)) =>
+              fn(b) match {
+                case Ior.Left(aa)    => Ior.left(Semigroup[A].combine(a, aa))
+                case Ior.Both(aa, x) => loop(Ior.both(Semigroup[A].combine(a, aa), x))
+                case Ior.Right(x)    => loop(Ior.both(a, x))
+              }
+          }
         loop(fn(b))
       }
 
@@ -811,26 +822,27 @@ sealed abstract private[data] class IorInstances extends IorInstances0 {
 
 sealed abstract private[data] class IorInstances0 {
 
-  implicit def catsDataTraverseFunctorForIor[A]: Traverse[Ior[A, *]] = new Traverse[Ior[A, *]] {
-    def traverse[F[_]: Applicative, B, C](fa: A Ior B)(f: B => F[C]): F[A Ior C] =
-      fa.traverse(f)
-    def foldLeft[B, C](fa: A Ior B, b: C)(f: (C, B) => C): C =
-      fa.foldLeft(b)(f)
-    def foldRight[B, C](fa: A Ior B, lc: Eval[C])(f: (B, Eval[C]) => Eval[C]): Eval[C] =
-      fa.foldRight(lc)(f)
+  implicit def catsDataTraverseFunctorForIor[A]: Traverse[Ior[A, *]] =
+    new Traverse[Ior[A, *]] {
+      def traverse[F[_]: Applicative, B, C](fa: A Ior B)(f: B => F[C]): F[A Ior C] =
+        fa.traverse(f)
+      def foldLeft[B, C](fa: A Ior B, b: C)(f: (C, B) => C): C =
+        fa.foldLeft(b)(f)
+      def foldRight[B, C](fa: A Ior B, lc: Eval[C])(f: (B, Eval[C]) => Eval[C]): Eval[C] =
+        fa.foldRight(lc)(f)
 
-    override def size[B](fa: A Ior B): Long = fa.fold(_ => 0L, _ => 1L, (_, _) => 1L)
+      override def size[B](fa: A Ior B): Long = fa.fold(_ => 0L, _ => 1L, (_, _) => 1L)
 
-    override def get[B](fa: A Ior B)(idx: Long): Option[B] =
-      if (idx == 0L) fa.toOption else None
+      override def get[B](fa: A Ior B)(idx: Long): Option[B] =
+        if (idx == 0L) fa.toOption else None
 
-    override def forall[B](fa: Ior[A, B])(p: (B) => Boolean): Boolean = fa.forall(p)
+      override def forall[B](fa: Ior[A, B])(p: (B) => Boolean): Boolean = fa.forall(p)
 
-    override def exists[B](fa: Ior[A, B])(p: (B) => Boolean): Boolean = fa.exists(p)
+      override def exists[B](fa: Ior[A, B])(p: (B) => Boolean): Boolean = fa.exists(p)
 
-    override def map[B, C](fa: A Ior B)(f: B => C): A Ior C =
-      fa.map(f)
-  }
+      override def map[B, C](fa: A Ior B)(f: B => C): A Ior C =
+        fa.map(f)
+    }
 }
 
 sealed private[data] trait IorFunctions {
diff --git a/core/src/main/scala/cats/data/IorT.scala b/core/src/main/scala/cats/data/IorT.scala
index acf8e92d8..cacfa6623 100644
--- a/core/src/main/scala/cats/data/IorT.scala
+++ b/core/src/main/scala/cats/data/IorT.scala
@@ -417,36 +417,37 @@ abstract private[data] class IorTInstances extends IorTInstances1 {
   implicit def catsDataMonoidForIorT[F[_], A, B](implicit F: Monoid[F[Ior[A, B]]]): Monoid[IorT[F, A, B]] =
     new IorTMonoid[F, A, B] { val F0: Monoid[F[Ior[A, B]]] = F }
 
-  implicit def catsDataParallelForIorTWithParallelEffect[M[_], E](
-    implicit P: Parallel[M],
+  implicit def catsDataParallelForIorTWithParallelEffect[M[_], E](implicit
+    P: Parallel[M],
     E: Semigroup[E]
-  ): Parallel.Aux[IorT[M, E, *], IorT[P.F, E, *]] { type Dummy } = new Parallel[IorT[M, E, *]] {
-    type F[x] = IorT[P.F, E, x]
-    type Dummy // fix to make this one more specific than the catsDataParallelForIorTWithSequentialEffect, see https://github.com/typelevel/cats/pull/2335#issuecomment-408249775
-
-    val parallel: IorT[M, E, *] ~> IorT[P.F, E, *] =
-      new (IorT[M, E, *] ~> IorT[P.F, E, *]) {
-        def apply[A](fm: IorT[M, E, A]): IorT[P.F, E, A] = IorT(P.parallel(fm.value))
-      }
-    val sequential: IorT[P.F, E, *] ~> IorT[M, E, *] =
-      new (IorT[P.F, E, *] ~> IorT[M, E, *]) {
-        def apply[A](ff: IorT[P.F, E, A]): IorT[M, E, A] = IorT(P.sequential(ff.value))
-      }
+  ): Parallel.Aux[IorT[M, E, *], IorT[P.F, E, *]] { type Dummy } =
+    new Parallel[IorT[M, E, *]] {
+      type F[x] = IorT[P.F, E, x]
+      type Dummy // fix to make this one more specific than the catsDataParallelForIorTWithSequentialEffect, see https://github.com/typelevel/cats/pull/2335#issuecomment-408249775
+
+      val parallel: IorT[M, E, *] ~> IorT[P.F, E, *] =
+        new (IorT[M, E, *] ~> IorT[P.F, E, *]) {
+          def apply[A](fm: IorT[M, E, A]): IorT[P.F, E, A] = IorT(P.parallel(fm.value))
+        }
+      val sequential: IorT[P.F, E, *] ~> IorT[M, E, *] =
+        new (IorT[P.F, E, *] ~> IorT[M, E, *]) {
+          def apply[A](ff: IorT[P.F, E, A]): IorT[M, E, A] = IorT(P.sequential(ff.value))
+        }
 
-    private[this] val FA: Applicative[P.F] = P.applicative
-    private[this] val IorA: Applicative[Ior[E, *]] = Parallel[Ior[E, *], Ior[E, *]].applicative
+      private[this] val FA: Applicative[P.F] = P.applicative
+      private[this] val IorA: Applicative[Ior[E, *]] = Parallel[Ior[E, *], Ior[E, *]].applicative
 
-    val applicative: Applicative[IorT[P.F, E, *]] = new Applicative[IorT[P.F, E, *]] {
-      def pure[A](a: A): IorT[P.F, E, A] = IorT.pure(a)(FA)
-      def ap[A, B](ff: IorT[P.F, E, A => B])(fa: IorT[P.F, E, A]): IorT[P.F, E, B] =
-        IorT(FA.map2(ff.value, fa.value)((f, a) => IorA.ap(f)(a)))
-    }
+      val applicative: Applicative[IorT[P.F, E, *]] = new Applicative[IorT[P.F, E, *]] {
+        def pure[A](a: A): IorT[P.F, E, A] = IorT.pure(a)(FA)
+        def ap[A, B](ff: IorT[P.F, E, A => B])(fa: IorT[P.F, E, A]): IorT[P.F, E, B] =
+          IorT(FA.map2(ff.value, fa.value)((f, a) => IorA.ap(f)(a)))
+      }
 
-    lazy val monad: Monad[IorT[M, E, *]] = {
-      implicit def underlyingMonadM: Monad[M] = P.monad
-      Monad[IorT[M, E, *]]
+      lazy val monad: Monad[IorT[M, E, *]] = {
+        implicit def underlyingMonadM: Monad[M] = P.monad
+        Monad[IorT[M, E, *]]
+      }
     }
-  }
 
   implicit def catsDataDeferForIor[F[_], E](implicit F: Defer[F]): Defer[IorT[F, E, *]] =
     new Defer[IorT[F, E, *]] {
@@ -468,32 +469,35 @@ abstract private[data] class IorTInstances1 extends IorTInstances2 {
       val F0: Monad[F] = F
     }
 
-  implicit def catsDataParallelForIorTWithSequentialEffect[F0[_], E](
-    implicit F: Monad[F0],
+  implicit def catsDataParallelForIorTWithSequentialEffect[F0[_], E](implicit
+    F: Monad[F0],
     E: Semigroup[E]
-  ): Parallel.Aux[IorT[F0, E, *], IorT[F0, E, *]] = new Parallel[IorT[F0, E, *]] {
-    type F[x] = IorT[F0, E, x]
-    private[this] val identityK: IorT[F0, E, *] ~> IorT[F0, E, *] = FunctionK.id
-    private[this] val underlyingParallel: Parallel.Aux[Ior[E, *], Ior[E, *]] =
-      Ior.catsDataParallelForIor[E]
-
-    def parallel: IorT[F0, E, *] ~> IorT[F0, E, *] = identityK
-    def sequential: IorT[F0, E, *] ~> IorT[F0, E, *] = identityK
-
-    val applicative: Applicative[IorT[F0, E, *]] = new Applicative[IorT[F0, E, *]] {
-      def pure[A](a: A): IorT[F0, E, A] = IorT.pure(a)
-      def ap[A, B](ff: IorT[F0, E, A => B])(fa: IorT[F0, E, A]): IorT[F0, E, B] =
-        IorT(F.map2(ff.value, fa.value)((f, a) => underlyingParallel.applicative.ap[A, B](f)(a)))
-    }
+  ): Parallel.Aux[IorT[F0, E, *], IorT[F0, E, *]] =
+    new Parallel[IorT[F0, E, *]] {
+      type F[x] = IorT[F0, E, x]
+      private[this] val identityK: IorT[F0, E, *] ~> IorT[F0, E, *] = FunctionK.id
+      private[this] val underlyingParallel: Parallel.Aux[Ior[E, *], Ior[E, *]] =
+        Ior.catsDataParallelForIor[E]
+
+      def parallel: IorT[F0, E, *] ~> IorT[F0, E, *] = identityK
+      def sequential: IorT[F0, E, *] ~> IorT[F0, E, *] = identityK
+
+      val applicative: Applicative[IorT[F0, E, *]] = new Applicative[IorT[F0, E, *]] {
+        def pure[A](a: A): IorT[F0, E, A] = IorT.pure(a)
+        def ap[A, B](ff: IorT[F0, E, A => B])(fa: IorT[F0, E, A]): IorT[F0, E, B] =
+          IorT(F.map2(ff.value, fa.value)((f, a) => underlyingParallel.applicative.ap[A, B](f)(a)))
+      }
 
-    lazy val monad: Monad[IorT[F0, E, *]] = Monad[IorT[F0, E, *]]
-  }
+      lazy val monad: Monad[IorT[F0, E, *]] = Monad[IorT[F0, E, *]]
+    }
 
 }
 
 abstract private[data] class IorTInstances2 extends IorTInstances3 {
-  implicit def catsDataMonadErrorFForIorT[F[_], A, E](implicit FE: MonadError[F, E],
-                                                      A: Semigroup[A]): MonadError[IorT[F, A, *], E] =
+  implicit def catsDataMonadErrorFForIorT[F[_], A, E](implicit
+    FE: MonadError[F, E],
+    A: Semigroup[A]
+  ): MonadError[IorT[F, A, *], E] =
     new IorTMonadErrorF[F, A, E] {
       val A0: Semigroup[A] = A
       val F0: MonadError[F, E] = FE
diff --git a/core/src/main/scala/cats/data/Kleisli.scala b/core/src/main/scala/cats/data/Kleisli.scala
index a4953cf0b..d88556791 100644
--- a/core/src/main/scala/cats/data/Kleisli.scala
+++ b/core/src/main/scala/cats/data/Kleisli.scala
@@ -297,21 +297,21 @@ sealed abstract private[data] class KleisliInstances extends KleisliInstances0 {
       }
     }
 
-  implicit def catsDataFunctorFilterForKleisli[F[_], A](
-    implicit ev: FunctorFilter[F]
+  implicit def catsDataFunctorFilterForKleisli[F[_], A](implicit
+    ev: FunctorFilter[F]
   ): FunctorFilter[Kleisli[F, A, *]] =
     new KleisliFunctorFilter[F, A] { val FF = ev }
 }
 
 sealed abstract private[data] class KleisliInstances0 extends KleisliInstances0_5 {
 
-  implicit def catsDataCommutativeArrowForKleisli[F[_]](
-    implicit M: CommutativeMonad[F]
+  implicit def catsDataCommutativeArrowForKleisli[F[_]](implicit
+    M: CommutativeMonad[F]
   ): CommutativeArrow[Kleisli[F, *, *]] with ArrowChoice[Kleisli[F, *, *]] =
     new KleisliCommutativeArrow[F] { def F: CommutativeMonad[F] = M }
 
-  implicit def catsDataCommutativeMonadForKleisli[F[_], A](
-    implicit F0: CommutativeMonad[F]
+  implicit def catsDataCommutativeMonadForKleisli[F[_], A](implicit
+    F0: CommutativeMonad[F]
   ): CommutativeMonad[Kleisli[F, A, *]] =
     new KleisliMonad[F, A] with CommutativeMonad[Kleisli[F, A, *]] {
       implicit def F: Monad[F] = F0
@@ -323,8 +323,8 @@ sealed abstract private[data] class KleisliInstances0_5 extends KleisliInstances
   implicit def catsDataMonoidForKleisli[F[_], A, B](implicit FB0: Monoid[F[B]]): Monoid[Kleisli[F, A, B]] =
     new KleisliMonoid[F, A, B] { def FB: Monoid[F[B]] = FB0 }
 
-  implicit def catsDataMonadErrorForKleisli[F[_], A, E](
-    implicit ME: MonadError[F, E]
+  implicit def catsDataMonadErrorForKleisli[F[_], A, E](implicit
+    ME: MonadError[F, E]
   ): MonadError[Kleisli[F, A, *], E] =
     new KleisliMonadError[F, A, E] { def F: MonadError[F, E] = ME }
 
@@ -333,8 +333,8 @@ sealed abstract private[data] class KleisliInstances0_5 extends KleisliInstances
       def F: Monad[F] = M
     }
 
-  implicit def catsDataContravariantMonoidalForKleisli[F[_], A](
-    implicit F0: ContravariantMonoidal[F]
+  implicit def catsDataContravariantMonoidalForKleisli[F[_], A](implicit
+    F0: ContravariantMonoidal[F]
   ): ContravariantMonoidal[Kleisli[F, A, *]] =
     new KleisliContravariantMonoidal[F, A] { def F: ContravariantMonoidal[F] = F0 }
 
@@ -342,47 +342,48 @@ sealed abstract private[data] class KleisliInstances0_5 extends KleisliInstances
    * Witness for: Kleisli[M, E, A] <-> (E, R) => A
    * if M is Representable
    */
-  implicit def catsDataRepresentableForKleisli[M[_], R, E](
-    implicit
+  implicit def catsDataRepresentableForKleisli[M[_], R, E](implicit
     R: Representable.Aux[M, R],
     FK: Functor[Kleisli[M, E, *]]
-  ): Representable.Aux[Kleisli[M, E, *], (E, R)] = new Representable[Kleisli[M, E, *]] {
+  ): Representable.Aux[Kleisli[M, E, *], (E, R)] =
+    new Representable[Kleisli[M, E, *]] {
 
-    override type Representation = (E, R)
+      override type Representation = (E, R)
 
-    override val F: Functor[Kleisli[M, E, *]] = FK
+      override val F: Functor[Kleisli[M, E, *]] = FK
 
-    def index[A](f: Kleisli[M, E, A]): Representation => A = {
-      case (e, r) => R.index(f.run(e))(r)
-    }
+      def index[A](f: Kleisli[M, E, A]): Representation => A = {
+        case (e, r) => R.index(f.run(e))(r)
+      }
 
-    def tabulate[A](f: Representation => A): Kleisli[M, E, A] =
-      Kleisli[M, E, A](e => R.tabulate(r => f((e, r))))
-  }
+      def tabulate[A](f: Representation => A): Kleisli[M, E, A] =
+        Kleisli[M, E, A](e => R.tabulate(r => f((e, r))))
+    }
 }
 
 sealed abstract private[data] class KleisliInstances1 extends KleisliInstances2 {
   implicit def catsDataMonadForKleisli[F[_], A](implicit M: Monad[F]): Monad[Kleisli[F, A, *]] =
     new KleisliMonad[F, A] { def F: Monad[F] = M }
 
-  implicit def catsDataParallelForKleisli[M[_], A](
-    implicit P: Parallel[M]
-  ): Parallel.Aux[Kleisli[M, A, *], Kleisli[P.F, A, *]] = new Parallel[Kleisli[M, A, *]] {
-    type F[x] = Kleisli[P.F, A, x]
-    implicit val monadM: Monad[M] = P.monad
-    def applicative: Applicative[Kleisli[P.F, A, *]] = catsDataApplicativeForKleisli(P.applicative)
-    def monad: Monad[Kleisli[M, A, *]] = catsDataMonadForKleisli
-
-    def sequential: Kleisli[P.F, A, *] ~> Kleisli[M, A, *] =
-      new (Kleisli[P.F, A, *] ~> Kleisli[M, A, *]) {
-        def apply[B](k: Kleisli[P.F, A, B]): Kleisli[M, A, B] = k.mapK(P.sequential)
-      }
+  implicit def catsDataParallelForKleisli[M[_], A](implicit
+    P: Parallel[M]
+  ): Parallel.Aux[Kleisli[M, A, *], Kleisli[P.F, A, *]] =
+    new Parallel[Kleisli[M, A, *]] {
+      type F[x] = Kleisli[P.F, A, x]
+      implicit val monadM: Monad[M] = P.monad
+      def applicative: Applicative[Kleisli[P.F, A, *]] = catsDataApplicativeForKleisli(P.applicative)
+      def monad: Monad[Kleisli[M, A, *]] = catsDataMonadForKleisli
+
+      def sequential: Kleisli[P.F, A, *] ~> Kleisli[M, A, *] =
+        new (Kleisli[P.F, A, *] ~> Kleisli[M, A, *]) {
+          def apply[B](k: Kleisli[P.F, A, B]): Kleisli[M, A, B] = k.mapK(P.sequential)
+        }
 
-    def parallel: Kleisli[M, A, *] ~> Kleisli[P.F, A, *] =
-      new (Kleisli[M, A, *] ~> Kleisli[P.F, A, *]) {
-        def apply[B](k: Kleisli[M, A, B]): Kleisli[P.F, A, B] = k.mapK(P.parallel)
-      }
-  }
+      def parallel: Kleisli[M, A, *] ~> Kleisli[P.F, A, *] =
+        new (Kleisli[M, A, *] ~> Kleisli[P.F, A, *]) {
+          def apply[B](k: Kleisli[M, A, B]): Kleisli[P.F, A, B] = k.mapK(P.parallel)
+        }
+    }
 
   implicit def catsDataContravariantForKleisli[F[_], C]: Contravariant[Kleisli[F, *, C]] =
     new Contravariant[Kleisli[F, *, C]] {
@@ -400,8 +401,8 @@ sealed abstract private[data] class KleisliInstances3 extends KleisliInstances4
   implicit def catsDataMonoidKForKleisli[F[_], A](implicit F0: MonoidK[F]): MonoidK[Kleisli[F, A, *]] =
     new KleisliMonoidK[F, A] { def F: MonoidK[F] = F0 }
 
-  implicit def catsDataCommutativeFlatMapForKleisli[F[_], A](
-    implicit F0: CommutativeFlatMap[F]
+  implicit def catsDataCommutativeFlatMapForKleisli[F[_], A](implicit
+    F0: CommutativeFlatMap[F]
   ): CommutativeFlatMap[Kleisli[F, A, *]] =
     new KleisliFlatMap[F, A] with CommutativeFlatMap[Kleisli[F, A, *]] { val F: CommutativeFlatMap[F] = F0 }
 
@@ -432,8 +433,8 @@ sealed abstract private[data] class KleisliInstances4 extends KleisliInstances5
 
 sealed abstract private[data] class KleisliInstances5 extends KleisliInstances6 {
 
-  implicit def catsDataApplicativeErrorForKleisli[F[_], E, A](
-    implicit F0: ApplicativeError[F, E]
+  implicit def catsDataApplicativeErrorForKleisli[F[_], E, A](implicit
+    F0: ApplicativeError[F, E]
   ): ApplicativeError[Kleisli[F, A, *], E] =
     new KleisliApplicativeError[F, A, E] { def F: ApplicativeError[F, E] = F0 }
 }
@@ -583,9 +584,10 @@ private[data] trait KleisliApplicativeError[F[_], A, E]
 
   def raiseError[B](e: E): K[B] = Kleisli(_ => F.raiseError(e))
 
-  def handleErrorWith[B](kb: K[B])(f: E => K[B]): K[B] = Kleisli { (a: A) =>
-    F.handleErrorWith(kb.run(a))((e: E) => f(e).run(a))
-  }
+  def handleErrorWith[B](kb: K[B])(f: E => K[B]): K[B] =
+    Kleisli { (a: A) =>
+      F.handleErrorWith(kb.run(a))((e: E) => f(e).run(a))
+    }
 }
 
 private[data] trait KleisliMonad[F[_], A]
diff --git a/core/src/main/scala/cats/data/Nested.scala b/core/src/main/scala/cats/data/Nested.scala
index 36efa3803..411614494 100644
--- a/core/src/main/scala/cats/data/Nested.scala
+++ b/core/src/main/scala/cats/data/Nested.scala
@@ -55,8 +55,10 @@ sealed abstract private[data] class NestedInstances extends NestedInstances0 {
         Nested(F.defer(fa.value))
     }
 
-  implicit def catsDataTraverseFilterForNested[F[_], G[_]](implicit F0: Traverse[F],
-                                                           G0: TraverseFilter[G]): TraverseFilter[Nested[F, G, *]] =
+  implicit def catsDataTraverseFilterForNested[F[_], G[_]](implicit
+    F0: Traverse[F],
+    G0: TraverseFilter[G]
+  ): TraverseFilter[Nested[F, G, *]] =
     new NestedTraverseFilter[F, G] {
       implicit val F: Traverse[F] = F0
       implicit val G: TraverseFilter[G] = G0
@@ -69,8 +71,10 @@ sealed abstract private[data] class NestedInstances0 extends NestedInstances1 {
       val FG: Traverse[Î»[Î± => F[G[Î±]]]] = Traverse[F].compose[G]
     }
 
-  implicit def catsDataFunctorFilterForNested[F[_], G[_]](implicit F0: Functor[F],
-                                                          G0: FunctorFilter[G]): FunctorFilter[Nested[F, G, *]] =
+  implicit def catsDataFunctorFilterForNested[F[_], G[_]](implicit
+    F0: Functor[F],
+    G0: FunctorFilter[G]
+  ): FunctorFilter[Nested[F, G, *]] =
     new NestedFunctorFilter[F, G] {
       implicit val F: Functor[F] = F0
       implicit val G: FunctorFilter[G] = G0
@@ -117,8 +121,8 @@ sealed abstract private[data] class NestedInstances3 extends NestedInstances4 {
 }
 
 sealed abstract private[data] class NestedInstances4 extends NestedInstances5 {
-  implicit def catsDataApplicativeErrorForNested[F[_], G[_], E](
-    implicit F: ApplicativeError[F, E],
+  implicit def catsDataApplicativeErrorForNested[F[_], G[_], E](implicit
+    F: ApplicativeError[F, E],
     G0: Applicative[G]
   ): ApplicativeError[Nested[F, G, *], E] =
     new NestedApplicativeError[F, G, E] {
@@ -130,8 +134,9 @@ sealed abstract private[data] class NestedInstances4 extends NestedInstances5 {
 }
 
 sealed abstract private[data] class NestedInstances5 extends NestedInstances6 {
-  implicit def catsDataCommutativeApplicativeForNestedContravariant[F[_]: CommutativeApplicative, G[_]: CommutativeApplicative]
-    : CommutativeApplicative[Nested[F, G, *]] =
+  implicit def catsDataCommutativeApplicativeForNestedContravariant[F[_]: CommutativeApplicative, G[
+    _
+  ]: CommutativeApplicative]: CommutativeApplicative[Nested[F, G, *]] =
     new NestedApplicative[F, G] with CommutativeApplicative[Nested[F, G, *]] {
       val FG: Applicative[Î»[Î± => F[G[Î±]]]] = Applicative[F].compose[G]
     }
diff --git a/core/src/main/scala/cats/data/NonEmptyList.scala b/core/src/main/scala/cats/data/NonEmptyList.scala
index 8c47757d1..6ffd727fd 100644
--- a/core/src/main/scala/cats/data/NonEmptyList.scala
+++ b/core/src/main/scala/cats/data/NonEmptyList.scala
@@ -46,10 +46,11 @@ final case class NonEmptyList[+A](head: A, tail: List[A]) extends NonEmptyCollec
    * res0: scala.collection.immutable.List[Int] = List(1, 2, 3, 4)
    * }}}
    */
-  def init: List[A] = tail match {
-    case Nil => List.empty
-    case t   => head :: t.init
-  }
+  def init: List[A] =
+    tail match {
+      case Nil => List.empty
+      case t   => head :: t.init
+    }
 
   final def iterator: Iterator[A] = toList.iterator
 
@@ -299,11 +300,12 @@ final case class NonEmptyList[+A](head: A, tail: List[A]) extends NonEmptyCollec
   def zipWith[B, C](b: NonEmptyList[B])(f: (A, B) => C): NonEmptyList[C] = {
 
     @tailrec
-    def zwRev(as: List[A], bs: List[B], acc: List[C]): List[C] = (as, bs) match {
-      case (Nil, _)           => acc
-      case (_, Nil)           => acc
-      case (x :: xs, y :: ys) => zwRev(xs, ys, f(x, y) :: acc)
-    }
+    def zwRev(as: List[A], bs: List[B], acc: List[C]): List[C] =
+      (as, bs) match {
+        case (Nil, _)           => acc
+        case (_, Nil)           => acc
+        case (x :: xs, y :: ys) => zwRev(xs, ys, f(x, y) :: acc)
+      }
 
     NonEmptyList(f(head, b.head), zwRev(tail, b.tail, Nil).reverse)
   }
@@ -587,15 +589,16 @@ sealed abstract private[data] class NonEmptyListInstances extends NonEmptyListIn
 
       def tailRecM[A, B](a: A)(f: A => NonEmptyList[Either[A, B]]): NonEmptyList[B] = {
         val buf = new ListBuffer[B]
-        @tailrec def go(v: NonEmptyList[Either[A, B]]): Unit = v.head match {
-          case Right(b) =>
-            buf += b
-            NonEmptyList.fromList(v.tail) match {
-              case Some(t) => go(t)
-              case None    => ()
-            }
-          case Left(a) => go(f(a) ++ v.tail)
-        }
+        @tailrec def go(v: NonEmptyList[Either[A, B]]): Unit =
+          v.head match {
+            case Right(b) =>
+              buf += b
+              NonEmptyList.fromList(v.tail) match {
+                case Some(t) => go(t)
+                case None    => ()
+              }
+            case Left(a) => go(f(a) ++ v.tail)
+          }
         go(f(a))
         NonEmptyList.fromListUnsafe(buf.result())
       }
@@ -647,12 +650,13 @@ sealed abstract private[data] class NonEmptyListInstances extends NonEmptyListIn
       override def alignWith[A, B, C](fa: NonEmptyList[A], fb: NonEmptyList[B])(f: Ior[A, B] => C): NonEmptyList[C] = {
 
         @tailrec
-        def go(as: List[A], bs: List[B], acc: List[C]): List[C] = (as, bs) match {
-          case (Nil, Nil)         => acc
-          case (Nil, y :: ys)     => go(Nil, ys, f(Ior.right(y)) :: acc)
-          case (x :: xs, Nil)     => go(xs, Nil, f(Ior.left(x)) :: acc)
-          case (x :: xs, y :: ys) => go(xs, ys, f(Ior.both(x, y)) :: acc)
-        }
+        def go(as: List[A], bs: List[B], acc: List[C]): List[C] =
+          (as, bs) match {
+            case (Nil, Nil)         => acc
+            case (Nil, y :: ys)     => go(Nil, ys, f(Ior.right(y)) :: acc)
+            case (x :: xs, Nil)     => go(xs, Nil, f(Ior.left(x)) :: acc)
+            case (x :: xs, y :: ys) => go(xs, ys, f(Ior.both(x, y)) :: acc)
+          }
 
         NonEmptyList(f(Ior.both(fa.head, fb.head)), go(fa.tail, fb.tail, Nil).reverse)
       }
diff --git a/core/src/main/scala/cats/data/NonEmptyMapImpl.scala b/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
index 8762a5976..5f9a34ca8 100644
--- a/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
+++ b/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
@@ -312,9 +312,10 @@ sealed abstract private[data] class NonEmptyMapInstances extends NonEmptyMapInst
   implicit def catsDataShowForNonEmptyMap[K: Show, A: Show]: Show[NonEmptyMap[K, A]] =
     Show.show[NonEmptyMap[K, A]](_.show)
 
-  implicit def catsDataBandForNonEmptyMap[K, A]: Band[NonEmptyMap[K, A]] = new Band[NonEmptyMap[K, A]] {
-    def combine(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): NonEmptyMap[K, A] = x ++ y
-  }
+  implicit def catsDataBandForNonEmptyMap[K, A]: Band[NonEmptyMap[K, A]] =
+    new Band[NonEmptyMap[K, A]] {
+      def combine(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): NonEmptyMap[K, A] = x ++ y
+    }
 }
 
 sealed abstract private[data] class NonEmptyMapInstances0 {
diff --git a/core/src/main/scala/cats/data/NonEmptySet.scala b/core/src/main/scala/cats/data/NonEmptySet.scala
index 740b5021e..9f342642e 100644
--- a/core/src/main/scala/cats/data/NonEmptySet.scala
+++ b/core/src/main/scala/cats/data/NonEmptySet.scala
@@ -399,9 +399,10 @@ sealed abstract private[data] class NonEmptySetInstances extends NonEmptySetInst
   implicit def catsDataShowForNonEmptySet[A](implicit A: Show[A]): Show[NonEmptySet[A]] =
     Show.show[NonEmptySet[A]](_.show)
 
-  implicit def catsDataSemilatticeForNonEmptySet[A]: Semilattice[NonEmptySet[A]] = new Semilattice[NonEmptySet[A]] {
-    def combine(x: NonEmptySet[A], y: NonEmptySet[A]): NonEmptySet[A] = x | y
-  }
+  implicit def catsDataSemilatticeForNonEmptySet[A]: Semilattice[NonEmptySet[A]] =
+    new Semilattice[NonEmptySet[A]] {
+      def combine(x: NonEmptySet[A], y: NonEmptySet[A]): NonEmptySet[A] = x | y
+    }
 }
 
 sealed abstract private[data] class NonEmptySetInstances0 extends NonEmptySetInstances1 {
@@ -410,9 +411,10 @@ sealed abstract private[data] class NonEmptySetInstances0 extends NonEmptySetIns
 }
 
 sealed abstract private[data] class NonEmptySetInstances1 {
-  implicit def catsDataEqForNonEmptySet[A](implicit A: Order[A]): Eq[NonEmptySet[A]] = new NonEmptySetEq[A] {
-    implicit override def A0: Eq[A] = A
-  }
+  implicit def catsDataEqForNonEmptySet[A](implicit A: Order[A]): Eq[NonEmptySet[A]] =
+    new NonEmptySetEq[A] {
+      implicit override def A0: Eq[A] = A
+    }
 }
 
 sealed abstract private[data] class NonEmptySetOrder[A] extends Order[NonEmptySet[A]] with NonEmptySetEq[A] {
diff --git a/core/src/main/scala/cats/data/NonEmptyVector.scala b/core/src/main/scala/cats/data/NonEmptyVector.scala
index 2cbd15da6..b4086cc8e 100644
--- a/core/src/main/scala/cats/data/NonEmptyVector.scala
+++ b/core/src/main/scala/cats/data/NonEmptyVector.scala
@@ -424,15 +424,16 @@ sealed abstract private[data] class NonEmptyVectorInstances {
 
       def tailRecM[A, B](a: A)(f: A => NonEmptyVector[Either[A, B]]): NonEmptyVector[B] = {
         val buf = new VectorBuilder[B]
-        @tailrec def go(v: NonEmptyVector[Either[A, B]]): Unit = v.head match {
-          case Right(b) =>
-            buf += b
-            NonEmptyVector.fromVector(v.tail) match {
-              case Some(t) => go(t)
-              case None    => ()
-            }
-          case Left(a) => go(f(a).concat(v.tail))
-        }
+        @tailrec def go(v: NonEmptyVector[Either[A, B]]): Unit =
+          v.head match {
+            case Right(b) =>
+              buf += b
+              NonEmptyVector.fromVector(v.tail) match {
+                case Some(t) => go(t)
+                case None    => ()
+              }
+            case Left(a) => go(f(a).concat(v.tail))
+          }
         go(f(a))
         NonEmptyVector.fromVectorUnsafe(buf.result())
       }
@@ -459,8 +460,9 @@ sealed abstract private[data] class NonEmptyVectorInstances {
       def align[A, B](fa: NonEmptyVector[A], fb: NonEmptyVector[B]): NonEmptyVector[Ior[A, B]] =
         NonEmptyVector.fromVectorUnsafe(Align[Vector].align(fa.toVector, fb.toVector))
 
-      override def alignWith[A, B, C](fa: NonEmptyVector[A],
-                                      fb: NonEmptyVector[B])(f: Ior[A, B] => C): NonEmptyVector[C] =
+      override def alignWith[A, B, C](fa: NonEmptyVector[A], fb: NonEmptyVector[B])(
+        f: Ior[A, B] => C
+      ): NonEmptyVector[C] =
         NonEmptyVector.fromVectorUnsafe(Align[Vector].alignWith(fa.toVector, fb.toVector)(f))
     }
 
diff --git a/core/src/main/scala/cats/data/OneAnd.scala b/core/src/main/scala/cats/data/OneAnd.scala
index cec3f623d..a294e5a11 100644
--- a/core/src/main/scala/cats/data/OneAnd.scala
+++ b/core/src/main/scala/cats/data/OneAnd.scala
@@ -105,8 +105,8 @@ final case class OneAnd[F[_], A](head: A, tail: F[A]) {
 @suppressUnusedImportWarningForScalaVersionSpecific
 sealed abstract private[data] class OneAndInstances extends OneAndLowPriority0 {
 
-  implicit def catsDataParallelForOneAnd[A, M[_]: Alternative, F0[_]: Alternative](
-    implicit P: Parallel.Aux[M, F0]
+  implicit def catsDataParallelForOneAnd[A, M[_]: Alternative, F0[_]: Alternative](implicit
+    P: Parallel.Aux[M, F0]
   ): Parallel.Aux[OneAnd[M, *], OneAnd[F0, *]] =
     new Parallel[OneAnd[M, *]] {
       type F[x] = OneAnd[F0, x]
@@ -143,8 +143,10 @@ sealed abstract private[data] class OneAndInstances extends OneAndLowPriority0 {
   implicit def catsDataSemigroupForOneAnd[F[_]: Alternative, A]: Semigroup[OneAnd[F, A]] =
     catsDataSemigroupKForOneAnd[F].algebra
 
-  implicit def catsDataMonadForOneAnd[F[_]](implicit monad: Monad[F],
-                                            alternative: Alternative[F]): Monad[OneAnd[F, *]] =
+  implicit def catsDataMonadForOneAnd[F[_]](implicit
+    monad: Monad[F],
+    alternative: Alternative[F]
+  ): Monad[OneAnd[F, *]] =
     new Monad[OneAnd[F, *]] {
       override def map[A, B](fa: OneAnd[F, A])(f: A => B): OneAnd[F, B] =
         fa.map(f)(monad)
@@ -166,18 +168,20 @@ sealed abstract private[data] class OneAndInstances extends OneAndLowPriority0 {
           val oneAnd = fn(a)
           alternative.combineK(monad.pure(oneAnd.head), oneAnd.tail)
         }
-        def toFB(in: Either[A, B]): F[B] = in match {
-          case Right(b) => monad.pure(b)
-          case Left(a)  => monad.tailRecM(a)(stepF)
-        }
+        def toFB(in: Either[A, B]): F[B] =
+          in match {
+            case Right(b) => monad.pure(b)
+            case Left(a)  => monad.tailRecM(a)(stepF)
+          }
 
         // This could probably be in SemigroupK to perform well
         @tailrec
-        def combineAll(items: List[F[B]]): F[B] = items match {
-          case Nil              => alternative.empty
-          case h :: Nil         => h
-          case h1 :: h2 :: tail => combineAll(alternative.combineK(h1, h2) :: tail)
-        }
+        def combineAll(items: List[F[B]]): F[B] =
+          items match {
+            case Nil              => alternative.empty
+            case h :: Nil         => h
+            case h1 :: h2 :: tail => combineAll(alternative.combineK(h1, h2) :: tail)
+          }
 
         @tailrec
         def go(in: A, rest: List[F[B]]): OneAnd[F, B] =
@@ -253,8 +257,10 @@ sealed abstract private[data] class OneAndLowPriority0_5 extends OneAndLowPriori
 }
 
 sealed abstract private[data] class OneAndLowPriority0 extends OneAndLowPriority0_5 {
-  implicit def catsDataNonEmptyTraverseForOneAnd[F[_]](implicit F: Traverse[F],
-                                                       F2: Alternative[F]): NonEmptyTraverse[OneAnd[F, *]] =
+  implicit def catsDataNonEmptyTraverseForOneAnd[F[_]](implicit
+    F: Traverse[F],
+    F2: Alternative[F]
+  ): NonEmptyTraverse[OneAnd[F, *]] =
     new NonEmptyReducible[OneAnd[F, *], F] with NonEmptyTraverse[OneAnd[F, *]] {
       def nonEmptyTraverse[G[_], A, B](fa: OneAnd[F, A])(f: (A) => G[B])(implicit G: Apply[G]): G[OneAnd[F, B]] =
         fa.map(a => Apply[G].map(f(a))(OneAnd(_, F2.empty[B])))(F)
diff --git a/core/src/main/scala/cats/data/OptionT.scala b/core/src/main/scala/cats/data/OptionT.scala
index 1ef981994..16cff75a2 100644
--- a/core/src/main/scala/cats/data/OptionT.scala
+++ b/core/src/main/scala/cats/data/OptionT.scala
@@ -342,44 +342,45 @@ sealed abstract private[data] class OptionTInstances extends OptionTInstances0 {
   def catsDateTraverseFilterForOptionT[F[_]](implicit F0: Traverse[F]): TraverseFilter[OptionT[F, *]] =
     catsDataTraverseFilterForOptionT
 
-  implicit def catsDataParallelForOptionT[M[_]](
-    implicit P: Parallel[M]
-  ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] = new Parallel[OptionT[M, *]] {
-    type F[x] = Nested[P.F, Option, x]
+  implicit def catsDataParallelForOptionT[M[_]](implicit
+    P: Parallel[M]
+  ): Parallel.Aux[OptionT[M, *], Nested[P.F, Option, *]] =
+    new Parallel[OptionT[M, *]] {
+      type F[x] = Nested[P.F, Option, x]
 
-    implicit val monadM: Monad[M] = P.monad
+      implicit val monadM: Monad[M] = P.monad
 
-    def applicative: Applicative[Nested[P.F, Option, *]] =
-      cats.data.Nested.catsDataApplicativeForNested(P.applicative, cats.instances.option.catsStdInstancesForOption)
+      def applicative: Applicative[Nested[P.F, Option, *]] =
+        cats.data.Nested.catsDataApplicativeForNested(P.applicative, cats.instances.option.catsStdInstancesForOption)
 
-    def monad: Monad[OptionT[M, *]] = cats.data.OptionT.catsDataMonadErrorMonadForOptionT[M]
+      def monad: Monad[OptionT[M, *]] = cats.data.OptionT.catsDataMonadErrorMonadForOptionT[M]
 
-    def sequential: Nested[P.F, Option, *] ~> OptionT[M, *] =
-      new (Nested[P.F, Option, *] ~> OptionT[M, *]) {
-        def apply[A](nested: Nested[P.F, Option, A]): OptionT[M, A] = OptionT(P.sequential(nested.value))
-      }
+      def sequential: Nested[P.F, Option, *] ~> OptionT[M, *] =
+        new (Nested[P.F, Option, *] ~> OptionT[M, *]) {
+          def apply[A](nested: Nested[P.F, Option, A]): OptionT[M, A] = OptionT(P.sequential(nested.value))
+        }
 
-    def parallel: OptionT[M, *] ~> Nested[P.F, Option, *] =
-      new (OptionT[M, *] ~> Nested[P.F, Option, *]) {
-        def apply[A](optT: OptionT[M, A]): Nested[P.F, Option, A] = Nested(P.parallel(optT.value))
-      }
-  }
+      def parallel: OptionT[M, *] ~> Nested[P.F, Option, *] =
+        new (OptionT[M, *] ~> Nested[P.F, Option, *]) {
+          def apply[A](optT: OptionT[M, A]): Nested[P.F, Option, A] = Nested(P.parallel(optT.value))
+        }
+    }
 }
 
 sealed abstract private[data] class OptionTInstances0 extends OptionTInstances1 {
 
   // the Dummy type is to make this one more specific than catsDataMonadErrorMonadForOptionT on 2.13.x
   // see https://github.com/typelevel/cats/pull/2335#issuecomment-408249775
-  implicit def catsDataMonadErrorForOptionT[F[_], E](
-    implicit F0: MonadError[F, E]
+  implicit def catsDataMonadErrorForOptionT[F[_], E](implicit
+    F0: MonadError[F, E]
   ): MonadError[OptionT[F, *], E] { type Dummy } =
     new OptionTMonadError[F, E] {
       type Dummy
       implicit val F = F0
     }
 
-  implicit def catsDataContravariantMonoidalForOptionT[F[_]](
-    implicit F0: ContravariantMonoidal[F]
+  implicit def catsDataContravariantMonoidalForOptionT[F[_]](implicit
+    F0: ContravariantMonoidal[F]
   ): ContravariantMonoidal[OptionT[F, *]] =
     new OptionTContravariantMonoidal[F] { implicit val F = F0 }
 
@@ -389,8 +390,8 @@ sealed abstract private[data] class OptionTInstances0 extends OptionTInstances1
   implicit def catsDataSemigroupForOptionT[F[_], A](implicit F0: Semigroup[F[Option[A]]]): Semigroup[OptionT[F, A]] =
     new OptionTSemigroup[F, A] { implicit val F = F0 }
 
-  implicit def catsDataPartialOrderForOptionT[F[_], A](
-    implicit F0: PartialOrder[F[Option[A]]]
+  implicit def catsDataPartialOrderForOptionT[F[_], A](implicit
+    F0: PartialOrder[F[Option[A]]]
   ): PartialOrder[OptionT[F, A]] =
     new OptionTPartialOrder[F, A] { implicit val F = F0 }
 
diff --git a/core/src/main/scala/cats/data/RepresentableStore.scala b/core/src/main/scala/cats/data/RepresentableStore.scala
index bd7c6d47a..6731db1de 100644
--- a/core/src/main/scala/cats/data/RepresentableStore.scala
+++ b/core/src/main/scala/cats/data/RepresentableStore.scala
@@ -46,8 +46,8 @@ final case class RepresentableStore[F[_], S, A](fa: F[A], index: S)(implicit R:
 
 object RepresentableStore {
 
-  implicit def catsDataRepresentableStoreComonad[F[_], S](
-    implicit R: Representable[F]
+  implicit def catsDataRepresentableStoreComonad[F[_], S](implicit
+    R: Representable[F]
   ): Comonad[RepresentableStore[F, S, *]] =
     new Comonad[RepresentableStore[F, S, *]] {
       override def extract[B](x: RepresentableStore[F, S, B]): B =
diff --git a/core/src/main/scala/cats/data/Tuple2K.scala b/core/src/main/scala/cats/data/Tuple2K.scala
index 95351ff62..bd7f009e1 100644
--- a/core/src/main/scala/cats/data/Tuple2K.scala
+++ b/core/src/main/scala/cats/data/Tuple2K.scala
@@ -22,8 +22,10 @@ final case class Tuple2K[F[_], G[_], A](first: F[A], second: G[A]) {
 object Tuple2K extends Tuple2KInstances
 
 sealed abstract private[data] class Tuple2KInstances extends Tuple2KInstances0 {
-  implicit def catsDataOrderForTuple2K[F[_], G[_], A](implicit FF: Order[F[A]],
-                                                      GF: Order[G[A]]): Order[Tuple2K[F, G, A]] =
+  implicit def catsDataOrderForTuple2K[F[_], G[_], A](implicit
+    FF: Order[F[A]],
+    GF: Order[G[A]]
+  ): Order[Tuple2K[F, G, A]] =
     new Tuple2KOrder[F, G, A] {
       def F: Order[F[A]] = FF
       def G: Order[G[A]] = GF
@@ -33,8 +35,8 @@ sealed abstract private[data] class Tuple2KInstances extends Tuple2KInstances0 {
       def F: Show[F[A]] = FF
       def G: Show[G[A]] = GF
     }
-  implicit def catsDataContravariantMonoidalForTuple2k[F[_], G[_]](
-    implicit FD: ContravariantMonoidal[F],
+  implicit def catsDataContravariantMonoidalForTuple2k[F[_], G[_]](implicit
+    FD: ContravariantMonoidal[F],
     GD: ContravariantMonoidal[G]
   ): ContravariantMonoidal[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KContravariantMonoidal[F, G] with Tuple2KContravariant[F, G] {
@@ -54,19 +56,22 @@ sealed abstract private[data] class Tuple2KInstances extends Tuple2KInstances0 {
 }
 
 sealed abstract private[data] class Tuple2KInstances0 extends Tuple2KInstances1 {
-  implicit def catsDataTraverseForTuple2K[F[_], G[_]](implicit FF: Traverse[F],
-                                                      GF: Traverse[G]): Traverse[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataTraverseForTuple2K[F[_], G[_]](implicit
+    FF: Traverse[F],
+    GF: Traverse[G]
+  ): Traverse[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KTraverse[F, G] with Tuple2KFunctor[F, G] {
       def F: Traverse[F] = FF
       def G: Traverse[G] = GF
     }
-  implicit def catsDataContravariantForTuple2K[F[_], G[_]](
-    implicit FC: Contravariant[F],
+  implicit def catsDataContravariantForTuple2K[F[_], G[_]](implicit
+    FC: Contravariant[F],
     GC: Contravariant[G]
-  ): Contravariant[Î»[Î± => Tuple2K[F, G, Î±]]] = new Tuple2KContravariant[F, G] {
-    def F: Contravariant[F] = FC
-    def G: Contravariant[G] = GC
-  }
+  ): Contravariant[Î»[Î± => Tuple2K[F, G, Î±]]] =
+    new Tuple2KContravariant[F, G] {
+      def F: Contravariant[F] = FC
+      def G: Contravariant[G] = GC
+    }
   implicit def catsDataEqForTuple2K[F[_], G[_], A](implicit FF: Eq[F[A]], GG: Eq[G[A]]): Eq[Tuple2K[F, G, A]] =
     new Eq[Tuple2K[F, G, A]] {
       def eqv(x: Tuple2K[F, G, A], y: Tuple2K[F, G, A]): Boolean =
@@ -75,14 +80,18 @@ sealed abstract private[data] class Tuple2KInstances0 extends Tuple2KInstances1
 }
 
 sealed abstract private[data] class Tuple2KInstances1 extends Tuple2KInstances2 {
-  implicit def catsDataAlternativeForTuple2K[F[_], G[_]](implicit FF: Alternative[F],
-                                                         GG: Alternative[G]): Alternative[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataAlternativeForTuple2K[F[_], G[_]](implicit
+    FF: Alternative[F],
+    GG: Alternative[G]
+  ): Alternative[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KAlternative[F, G] {
       def F: Alternative[F] = FF
       def G: Alternative[G] = GG
     }
-  implicit def catsDataFoldableForTuple2K[F[_], G[_]](implicit FF: Foldable[F],
-                                                      GF: Foldable[G]): Foldable[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataFoldableForTuple2K[F[_], G[_]](implicit
+    FF: Foldable[F],
+    GF: Foldable[G]
+  ): Foldable[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KFoldable[F, G] {
       def F: Foldable[F] = FF
       def G: Foldable[G] = GF
@@ -90,14 +99,18 @@ sealed abstract private[data] class Tuple2KInstances1 extends Tuple2KInstances2
 }
 
 sealed abstract private[data] class Tuple2KInstances2 extends Tuple2KInstances3 {
-  implicit def catsDataMonadForTuple2K[F[_], G[_]](implicit FM: Monad[F],
-                                                   GM: Monad[G]): Monad[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataMonadForTuple2K[F[_], G[_]](implicit
+    FM: Monad[F],
+    GM: Monad[G]
+  ): Monad[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KMonad[F, G] {
       def F: Monad[F] = FM
       def G: Monad[G] = GM
     }
-  implicit def catsDataMonoidKForTuple2K[F[_], G[_]](implicit FF: MonoidK[F],
-                                                     GG: MonoidK[G]): MonoidK[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataMonoidKForTuple2K[F[_], G[_]](implicit
+    FF: MonoidK[F],
+    GG: MonoidK[G]
+  ): MonoidK[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KMonoidK[F, G] {
       def F: MonoidK[F] = FF
       def G: MonoidK[G] = GG
@@ -105,8 +118,8 @@ sealed abstract private[data] class Tuple2KInstances2 extends Tuple2KInstances3
 }
 
 sealed abstract private[data] class Tuple2KInstances3 extends Tuple2KInstances4 {
-  implicit def catsDataCommutativeApplicativeForTuple2K[F[_], G[_]](
-    implicit FF: CommutativeApplicative[F],
+  implicit def catsDataCommutativeApplicativeForTuple2K[F[_], G[_]](implicit
+    FF: CommutativeApplicative[F],
     GG: CommutativeApplicative[G]
   ): CommutativeApplicative[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KApplicative[F, G] with CommutativeApplicative[Î»[Î± => Tuple2K[F, G, Î±]]] {
@@ -116,14 +129,16 @@ sealed abstract private[data] class Tuple2KInstances3 extends Tuple2KInstances4
 }
 
 sealed abstract private[data] class Tuple2KInstances4 extends Tuple2KInstances5 {
-  implicit def catsDataSemigroupKForTuple2K[F[_], G[_]](implicit FF: SemigroupK[F],
-                                                        GG: SemigroupK[G]): SemigroupK[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataSemigroupKForTuple2K[F[_], G[_]](implicit
+    FF: SemigroupK[F],
+    GG: SemigroupK[G]
+  ): SemigroupK[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KSemigroupK[F, G] {
       def F: SemigroupK[F] = FF
       def G: SemigroupK[G] = GG
     }
-  implicit def catsDataCommutativeApplyForTuple2K[F[_], G[_]](
-    implicit FF: CommutativeApply[F],
+  implicit def catsDataCommutativeApplyForTuple2K[F[_], G[_]](implicit
+    FF: CommutativeApply[F],
     GG: CommutativeApply[G]
   ): CommutativeApply[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KApply[F, G] with CommutativeApply[Î»[Î± => Tuple2K[F, G, Î±]]] {
@@ -133,8 +148,10 @@ sealed abstract private[data] class Tuple2KInstances4 extends Tuple2KInstances5
 }
 
 sealed abstract private[data] class Tuple2KInstances5 extends Tuple2KInstances6 {
-  implicit def catsDataApplicativeForTuple2K[F[_], G[_]](implicit FF: Applicative[F],
-                                                         GG: Applicative[G]): Applicative[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataApplicativeForTuple2K[F[_], G[_]](implicit
+    FF: Applicative[F],
+    GG: Applicative[G]
+  ): Applicative[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KApplicative[F, G] {
       def F: Applicative[F] = FF
       def G: Applicative[G] = GG
@@ -142,8 +159,10 @@ sealed abstract private[data] class Tuple2KInstances5 extends Tuple2KInstances6
 }
 
 sealed abstract private[data] class Tuple2KInstances6 extends Tuple2KInstances7 {
-  implicit def catsDataApplyForTuple2K[F[_], G[_]](implicit FF: Apply[F],
-                                                   GG: Apply[G]): Apply[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataApplyForTuple2K[F[_], G[_]](implicit
+    FF: Apply[F],
+    GG: Apply[G]
+  ): Apply[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KApply[F, G] {
       def F: Apply[F] = FF
       def G: Apply[G] = GG
@@ -151,8 +170,10 @@ sealed abstract private[data] class Tuple2KInstances6 extends Tuple2KInstances7
 }
 
 sealed abstract private[data] class Tuple2KInstances7 extends Tuple2KInstances8 {
-  implicit def catsDataDistributiveForTuple2K[F[_], G[_]](implicit FF: Distributive[F],
-                                                          GG: Distributive[G]): Distributive[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataDistributiveForTuple2K[F[_], G[_]](implicit
+    FF: Distributive[F],
+    GG: Distributive[G]
+  ): Distributive[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KDistributive[F, G] with Tuple2KFunctor[F, G] {
       def F: Distributive[F] = FF
       def G: Distributive[G] = GG
@@ -160,8 +181,10 @@ sealed abstract private[data] class Tuple2KInstances7 extends Tuple2KInstances8
 }
 
 sealed abstract private[data] class Tuple2KInstances8 {
-  implicit def catsDataFunctorForTuple2K[F[_], G[_]](implicit FF: Functor[F],
-                                                     GG: Functor[G]): Functor[Î»[Î± => Tuple2K[F, G, Î±]]] =
+  implicit def catsDataFunctorForTuple2K[F[_], G[_]](implicit
+    FF: Functor[F],
+    GG: Functor[G]
+  ): Functor[Î»[Î± => Tuple2K[F, G, Î±]]] =
     new Tuple2KFunctor[F, G] {
       def F: Functor[F] = FF
       def G: Functor[G] = GG
@@ -181,10 +204,12 @@ sealed private[data] trait Tuple2KDistributive[F[_], G[_]] extends Distributive[
 
   override def distribute[H[_]: Functor, A, B](ha: H[A])(f: A => Tuple2K[F, G, B]): Tuple2K[F, G, H[B]] =
     Tuple2K(F.distribute(ha) { a =>
-      f(a).first
-    }, G.distribute(ha) { a =>
-      f(a).second
-    })
+              f(a).first
+            },
+            G.distribute(ha) { a =>
+              f(a).second
+            }
+    )
 
   override def map[A, B](fa: Tuple2K[F, G, A])(f: A => B): Tuple2K[F, G, B] =
     Tuple2K(F.map(fa.first)(f), G.map(fa.second)(f))
@@ -215,8 +240,9 @@ sealed private[data] trait Tuple2KApply[F[_], G[_]] extends Apply[Î»[Î± => Tuple
     Tuple2K(F.ap(f.first)(fa.first), G.ap(f.second)(fa.second))
   override def product[A, B](fa: Tuple2K[F, G, A], fb: Tuple2K[F, G, B]): Tuple2K[F, G, (A, B)] =
     Tuple2K(F.product(fa.first, fb.first), G.product(fa.second, fb.second))
-  override def map2Eval[A, B, Z](fa: Tuple2K[F, G, A],
-                                 fb: Eval[Tuple2K[F, G, B]])(f: (A, B) => Z): Eval[Tuple2K[F, G, Z]] = {
+  override def map2Eval[A, B, Z](fa: Tuple2K[F, G, A], fb: Eval[Tuple2K[F, G, B]])(
+    f: (A, B) => Z
+  ): Eval[Tuple2K[F, G, Z]] = {
     val fbmemo = fb.memoize // don't recompute this twice internally
     for {
       fz <- F.map2Eval(fa.first, fbmemo.map(_.first))(f)
diff --git a/core/src/main/scala/cats/data/Validated.scala b/core/src/main/scala/cats/data/Validated.scala
index 20a063092..c6d287769 100644
--- a/core/src/main/scala/cats/data/Validated.scala
+++ b/core/src/main/scala/cats/data/Validated.scala
@@ -40,10 +40,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res0: Boolean = false
    * }}}
    */
-  def isValid: Boolean = this match {
-    case Invalid(_) => false
-    case _          => true
-  }
+  def isValid: Boolean =
+    this match {
+      case Invalid(_) => false
+      case _          => true
+    }
 
   /**
    * Example:
@@ -55,18 +56,20 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res0: Boolean = true
    * }}}
    */
-  def isInvalid: Boolean = this match {
-    case Invalid(_) => true
-    case _          => false
-  }
+  def isInvalid: Boolean =
+    this match {
+      case Invalid(_) => true
+      case _          => false
+    }
 
   /**
    * Run the side-effecting function on the value if it is Valid
    */
-  def foreach(f: A => Unit): Unit = this match {
-    case Valid(a) => f(a)
-    case _        => ()
-  }
+  def foreach(f: A => Unit): Unit =
+    this match {
+      case Valid(a) => f(a)
+      case _        => ()
+    }
 
   /**
    * Return the Valid value, or the default if Invalid
@@ -85,10 +88,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Int = 123
    * }}}
    */
-  def getOrElse[B >: A](default: => B): B = this match {
-    case Valid(a) => a
-    case _        => default
-  }
+  def getOrElse[B >: A](default: => B): B =
+    this match {
+      case Valid(a) => a
+      case _        => default
+    }
 
   /**
    * Return the Valid value, or the result of f if Invalid
@@ -106,10 +110,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: String = OK
    * }}}
    */
-  def valueOr[B >: A](f: E => B): B = this match {
-    case Invalid(e) => f(e)
-    case Valid(a)   => a
-  }
+  def valueOr[B >: A](f: E => B): B =
+    this match {
+      case Invalid(e) => f(e)
+      case Valid(a)   => a
+    }
 
   /**
    * Is this Valid and matching the given predicate
@@ -128,10 +133,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Boolean = true
    * }}}
    */
-  def exists(predicate: A => Boolean): Boolean = this match {
-    case Valid(a) => predicate(a)
-    case _        => false
-  }
+  def exists(predicate: A => Boolean): Boolean =
+    this match {
+      case Valid(a) => predicate(a)
+      case _        => false
+    }
 
   /**
    * Is this Invalid or matching the predicate
@@ -150,10 +156,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Boolean = false
    * }}}
    */
-  def forall(f: A => Boolean): Boolean = this match {
-    case Valid(a) => f(a)
-    case _        => true
-  }
+  def forall(f: A => Boolean): Boolean =
+    this match {
+      case Valid(a) => f(a)
+      case _        => true
+    }
 
   /**
    * Return this if it is Valid, or else fall back to the given default.
@@ -232,10 +239,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * }}}
    *
    */
-  def toEither: Either[E, A] = this match {
-    case Invalid(e) => Left(e)
-    case Valid(a)   => Right(a)
-  }
+  def toEither: Either[E, A] =
+    this match {
+      case Invalid(e) => Left(e)
+      case Valid(a)   => Right(a)
+    }
 
   /**
    * Returns Valid values wrapped in Some, and None for Invalid values
@@ -254,10 +262,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Option[Int] = Some(123)
    * }}}
    */
-  def toOption: Option[A] = this match {
-    case Valid(a) => Some(a)
-    case _        => None
-  }
+  def toOption: Option[A] =
+    this match {
+      case Valid(a) => Some(a)
+      case _        => None
+    }
 
   /**
    * Returns Valid values wrapped in Ior.Right, and None for Ior.Left values
@@ -276,10 +285,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Ior[String, Int] = Right(123)
    * }}}
    */
-  def toIor: Ior[E, A] = this match {
-    case Invalid(e) => Ior.Left(e)
-    case Valid(a)   => Ior.Right(a)
-  }
+  def toIor: Ior[E, A] =
+    this match {
+      case Invalid(e) => Ior.Left(e)
+      case Valid(a)   => Ior.Right(a)
+    }
 
   /**
    * Convert this value to a single element List if it is Valid,
@@ -299,10 +309,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: List[Int] = List(123)
    * }}}
    */
-  def toList: List[A] = this match {
-    case Valid(a) => List(a)
-    case _        => Nil
-  }
+  def toList: List[A] =
+    this match {
+      case Valid(a) => List(a)
+      case _        => Nil
+    }
 
   /**
    * Lift the Invalid value into a NonEmptyList.
@@ -389,10 +400,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Validated[List[String] ,Option[Int]] = Valid(Some(123))
    * }}}
    */
-  def bimap[EE, AA](fe: E => EE, fa: A => AA): Validated[EE, AA] = this match {
-    case Valid(a)   => Valid(fa(a))
-    case Invalid(e) => Invalid(fe(e))
-  }
+  def bimap[EE, AA](fe: E => EE, fa: A => AA): Validated[EE, AA] =
+    this match {
+      case Valid(a)   => Valid(fa(a))
+      case Invalid(e) => Invalid(fe(e))
+    }
 
   /**
    * Example:
@@ -429,13 +441,15 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
       case (Valid(_), _)             => 1
     }
 
-  def partialCompare[EE >: E, AA >: A](that: Validated[EE, AA])(implicit EE: PartialOrder[EE],
-                                                                AA: PartialOrder[AA]): Double = (this, that) match {
-    case (Valid(a), Valid(aa))     => AA.partialCompare(a, aa)
-    case (Invalid(e), Invalid(ee)) => EE.partialCompare(e, ee)
-    case (Invalid(_), _)           => -1
-    case (Valid(_), _)             => 1
-  }
+  def partialCompare[EE >: E, AA >: A](
+    that: Validated[EE, AA]
+  )(implicit EE: PartialOrder[EE], AA: PartialOrder[AA]): Double =
+    (this, that) match {
+      case (Valid(a), Valid(aa))     => AA.partialCompare(a, aa)
+      case (Invalid(e), Invalid(ee)) => EE.partialCompare(e, ee)
+      case (Invalid(_), _)           => -1
+      case (Valid(_), _)             => 1
+    }
 
   /**
    * Example:
@@ -457,11 +471,12 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res3: Boolean = false
    * }}}
    */
-  def ===[EE >: E, AA >: A](that: Validated[EE, AA])(implicit EE: Eq[EE], AA: Eq[AA]): Boolean = (this, that) match {
-    case (Invalid(e), Invalid(ee)) => EE.eqv(e, ee)
-    case (Valid(a), Valid(aa))     => AA.eqv(a, aa)
-    case _                         => false
-  }
+  def ===[EE >: E, AA >: A](that: Validated[EE, AA])(implicit EE: Eq[EE], AA: Eq[AA]): Boolean =
+    (this, that) match {
+      case (Invalid(e), Invalid(ee)) => EE.eqv(e, ee)
+      case (Valid(a), Valid(aa))     => AA.eqv(a, aa)
+      case _                         => false
+    }
 
   /**
    * From Apply:
@@ -540,10 +555,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Validated[String, Int] = Valid(246)
    * }}}
    */
-  def map[B](f: A => B): Validated[E, B] = this match {
-    case i @ Invalid(_) => i
-    case Valid(a)       => Valid(f(a))
-  }
+  def map[B](f: A => B): Validated[E, B] =
+    this match {
+      case i @ Invalid(_) => i
+      case Valid(a)       => Valid(f(a))
+    }
 
   /**
    * Apply a function to an Invalid value, returning a new Invalid value.
@@ -564,10 +580,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    *
    * }}}
    */
-  def leftMap[EE](f: E => EE): Validated[EE, A] = this match {
-    case a @ Valid(_) => a
-    case Invalid(e)   => Invalid(f(e))
-  }
+  def leftMap[EE](f: E => EE): Validated[EE, A] =
+    this match {
+      case a @ Valid(_) => a
+      case Invalid(e)   => Invalid(f(e))
+    }
 
   /**
    * When Valid, apply the function, marking the result as valid
@@ -588,10 +605,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Option[Validated[String, Int]] = Some(Valid(123))
    * }}}
    */
-  def traverse[F[_], EE >: E, B](f: A => F[B])(implicit F: Applicative[F]): F[Validated[EE, B]] = this match {
-    case Valid(a)       => F.map(f(a))(Valid.apply)
-    case e @ Invalid(_) => F.pure(e)
-  }
+  def traverse[F[_], EE >: E, B](f: A => F[B])(implicit F: Applicative[F]): F[Validated[EE, B]] =
+    this match {
+      case Valid(a)       => F.map(f(a))(Valid.apply)
+      case e @ Invalid(_) => F.pure(e)
+    }
 
   /**
    * apply the given function to the value with the given B when
@@ -611,10 +629,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res1: Int = 579
    * }}}
    */
-  def foldLeft[B](b: B)(f: (B, A) => B): B = this match {
-    case Valid(a) => f(b, a)
-    case _        => b
-  }
+  def foldLeft[B](b: B)(f: (B, A) => B): B =
+    this match {
+      case Valid(a) => f(b, a)
+      case _        => b
+    }
 
   /**
    * Lazily-apply the given function to the value with the given B
@@ -636,15 +655,17 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * }}}
    *
    */
-  def foldRight[B](lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] = this match {
-    case Valid(a) => f(a, lb)
-    case _        => lb
-  }
+  def foldRight[B](lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
+    this match {
+      case Valid(a) => f(a, lb)
+      case _        => lb
+    }
 
-  def show[EE >: E, AA >: A](implicit EE: Show[EE], AA: Show[AA]): String = this match {
-    case Invalid(e) => s"Invalid(${EE.show(e)})"
-    case Valid(a)   => s"Valid(${AA.show(a)})"
-  }
+  def show[EE >: E, AA >: A](implicit EE: Show[EE], AA: Show[AA]): String =
+    this match {
+      case Invalid(e) => s"Invalid(${EE.show(e)})"
+      case Valid(a)   => s"Valid(${AA.show(a)})"
+    }
 
   /**
    * Apply a function (that returns a `Validated`) in the valid case.
@@ -705,8 +726,9 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res2: Validated[NonEmptyList[String], List[Int]] = Valid(List(123, 456))
    * }}}
    */
-  def combine[EE >: E, AA >: A](that: Validated[EE, AA])(implicit EE: Semigroup[EE],
-                                                         AA: Semigroup[AA]): Validated[EE, AA] =
+  def combine[EE >: E, AA >: A](
+    that: Validated[EE, AA]
+  )(implicit EE: Semigroup[EE], AA: Semigroup[AA]): Validated[EE, AA] =
     (this, that) match {
       case (Valid(a), Valid(b))     => Valid(AA.combine(a, b))
       case (Invalid(a), Invalid(b)) => Invalid(EE.combine(a, b))
@@ -730,10 +752,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * }}}
    *
    */
-  def swap: Validated[A, E] = this match {
-    case Valid(a)   => Invalid(a)
-    case Invalid(e) => Valid(e)
-  }
+  def swap: Validated[A, E] =
+    this match {
+      case Valid(a)   => Invalid(a)
+      case Invalid(e) => Valid(e)
+    }
 
   /**
    * Example:
@@ -751,10 +774,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * }}}
    *
    */
-  def merge[EE >: E](implicit ev: A <:< EE): EE = this match {
-    case Invalid(e) => e
-    case Valid(a)   => ev(a)
-  }
+  def merge[EE >: E](implicit ev: A <:< EE): EE =
+    this match {
+      case Invalid(e) => e
+      case Valid(a)   => ev(a)
+    }
 
   /**
    * Ensure that a successful result passes the given predicate,
@@ -767,10 +791,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res0: Validated[IllegalArgumentException, String] = Invalid(java.lang.IllegalArgumentException: Must not be empty)
    * }}}
    */
-  def ensure[EE >: E](onFailure: => EE)(f: A => Boolean): Validated[EE, A] = this match {
-    case Valid(a) => if (f(a)) this else Validated.invalid(onFailure)
-    case _        => this
-  }
+  def ensure[EE >: E](onFailure: => EE)(f: A => Boolean): Validated[EE, A] =
+    this match {
+      case Valid(a) => if (f(a)) this else Validated.invalid(onFailure)
+      case _        => this
+    }
 
   /**
    * Ensure that a successful result passes the given predicate,
@@ -783,10 +808,11 @@ sealed abstract class Validated[+E, +A] extends Product with Serializable {
    * res0: Validated[IllegalArgumentException, String] = Invalid(java.lang.IllegalArgumentException: Must be longer than 3, provided 'ab')
    * }}}
    */
-  def ensureOr[EE >: E](onFailure: A => EE)(f: A => Boolean): Validated[EE, A] = this match {
-    case Valid(a) => if (f(a)) this else Validated.invalid(onFailure(a))
-    case _        => this
-  }
+  def ensureOr[EE >: E](onFailure: A => EE)(f: A => Boolean): Validated[EE, A] =
+    this match {
+      case Valid(a) => if (f(a)) this else Validated.invalid(onFailure(a))
+      case _        => this
+    }
 }
 
 object Validated extends ValidatedInstances with ValidatedFunctions with ValidatedFunctionsBinCompat0 {
@@ -829,14 +855,15 @@ sealed abstract private[data] class ValidatedInstances extends ValidatedInstance
 
   implicit def catsDataSemigroupKForValidated[A](implicit A: Semigroup[A]): SemigroupK[Validated[A, *]] =
     new SemigroupK[Validated[A, *]] {
-      def combineK[B](x: Validated[A, B], y: Validated[A, B]): Validated[A, B] = x match {
-        case v @ Valid(_) => v
-        case Invalid(ix) =>
-          y match {
-            case Invalid(iy)  => Invalid(A.combine(ix, iy))
-            case v @ Valid(_) => v
-          }
-      }
+      def combineK[B](x: Validated[A, B], y: Validated[A, B]): Validated[A, B] =
+        x match {
+          case v @ Valid(_) => v
+          case Invalid(ix) =>
+            y match {
+              case Invalid(iy)  => Invalid(A.combine(ix, iy))
+              case v @ Valid(_) => v
+            }
+        }
     }
 
   implicit def catsDataAlignForValidated[E: Semigroup]: Align[Validated[E, *]] =
@@ -866,11 +893,12 @@ sealed abstract private[data] class ValidatedInstances extends ValidatedInstance
       def combine(x: Validated[A, B], y: Validated[A, B]): Validated[A, B] = x.combine(y)
     }
 
-  implicit def catsDataOrderForValidated[A: Order, B: Order]: Order[Validated[A, B]] = new Order[Validated[A, B]] {
-    def compare(x: Validated[A, B], y: Validated[A, B]): Int = x.compare(y)
-    override def partialCompare(x: Validated[A, B], y: Validated[A, B]): Double = x.partialCompare(y)
-    override def eqv(x: Validated[A, B], y: Validated[A, B]): Boolean = x === y
-  }
+  implicit def catsDataOrderForValidated[A: Order, B: Order]: Order[Validated[A, B]] =
+    new Order[Validated[A, B]] {
+      def compare(x: Validated[A, B], y: Validated[A, B]): Int = x.compare(y)
+      override def partialCompare(x: Validated[A, B], y: Validated[A, B]): Double = x.partialCompare(y)
+      override def eqv(x: Validated[A, B], y: Validated[A, B]): Boolean = x === y
+    }
 
   implicit def catsDataShowForValidated[A, B](implicit A: Show[A], B: Show[B]): Show[Validated[A, B]] =
     new Show[Validated[A, B]] {
@@ -893,8 +921,9 @@ sealed abstract private[data] class ValidatedInstances extends ValidatedInstance
           case Valid(b)   => g(c, b)
         }
 
-      def bifoldRight[A, B, C](fab: Validated[A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
-                                                                 g: (B, Eval[C]) => Eval[C]): Eval[C] =
+      def bifoldRight[A, B, C](fab: Validated[A, B],
+                               c: Eval[C]
+      )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
         fab match {
           case Invalid(a) => f(a, c)
           case Valid(b)   => g(b, c)
@@ -921,8 +950,10 @@ sealed abstract private[data] class ValidatedInstances extends ValidatedInstance
 
 sealed abstract private[data] class ValidatedInstances1 extends ValidatedInstances2 {
 
-  implicit def catsDataSemigroupForValidated[A, B](implicit A: Semigroup[A],
-                                                   B: Semigroup[B]): Semigroup[Validated[A, B]] =
+  implicit def catsDataSemigroupForValidated[A, B](implicit
+    A: Semigroup[A],
+    B: Semigroup[B]
+  ): Semigroup[Validated[A, B]] =
     new Semigroup[Validated[A, B]] {
       def combine(x: Validated[A, B], y: Validated[A, B]): Validated[A, B] = x.combine(y)
     }
@@ -974,18 +1005,20 @@ sealed abstract private[data] class ValidatedInstances2 {
       override def reduceRightOption[A](fa: Validated[E, A])(f: (A, Eval[A]) => Eval[A]): Eval[Option[A]] =
         Now(fa.toOption)
 
-      override def size[A](fa: Validated[E, A]): Long = fa match {
-        case Invalid(_) => 0L
-        case _          => 1L
-      }
+      override def size[A](fa: Validated[E, A]): Long =
+        fa match {
+          case Invalid(_) => 0L
+          case _          => 1L
+        }
 
       override def get[A](fa: Validated[E, A])(idx: Long): Option[A] =
         if (idx == 0L) fa.toOption else None
 
-      override def foldMap[A, B](fa: Validated[E, A])(f: A => B)(implicit B: Monoid[B]): B = fa match {
-        case Valid(a) => f(a)
-        case _        => B.empty
-      }
+      override def foldMap[A, B](fa: Validated[E, A])(f: A => B)(implicit B: Monoid[B]): B =
+        fa match {
+          case Valid(a) => f(a)
+          case _        => B.empty
+        }
 
       override def find[A](fa: Validated[E, A])(f: A => Boolean): Option[A] =
         fa.toOption.filter(f)
@@ -996,10 +1029,11 @@ sealed abstract private[data] class ValidatedInstances2 {
       override def forall[A](fa: Validated[E, A])(p: A => Boolean): Boolean =
         fa.forall(p)
 
-      override def toList[A](fa: Validated[E, A]): List[A] = fa match {
-        case Valid(a) => a :: Nil
-        case _        => Nil
-      }
+      override def toList[A](fa: Validated[E, A]): List[A] =
+        fa match {
+          case Valid(a) => a :: Nil
+          case _        => Nil
+        }
 
       override def isEmpty[A](fa: Validated[E, A]): Boolean = fa.isInvalid
     }
@@ -1075,10 +1109,11 @@ private[data] trait ValidatedFunctions {
   /**
    * Converts a `Try[A]` to a `Validated[Throwable, A]`.
    */
-  def fromTry[A](t: Try[A]): Validated[Throwable, A] = t match {
-    case Failure(e) => invalid(e)
-    case Success(v) => valid(v)
-  }
+  def fromTry[A](t: Try[A]): Validated[Throwable, A] =
+    t match {
+      case Failure(e) => invalid(e)
+      case Success(v) => valid(v)
+    }
 
   /**
    * Converts an `Either[A, B]` to a `Validated[A, B]`.
diff --git a/core/src/main/scala/cats/data/WriterT.scala b/core/src/main/scala/cats/data/WriterT.scala
index dc8e9fd7b..cf3da0594 100644
--- a/core/src/main/scala/cats/data/WriterT.scala
+++ b/core/src/main/scala/cats/data/WriterT.scala
@@ -358,8 +358,8 @@ sealed abstract private[data] class WriterTInstances extends WriterTInstances0 {
 }
 
 sealed abstract private[data] class WriterTInstances0 extends WriterTInstances1 {
-  implicit def catsDataCommutativeMonadForWriterT[F[_], L](
-    implicit F: CommutativeMonad[F],
+  implicit def catsDataCommutativeMonadForWriterT[F[_], L](implicit
+    F: CommutativeMonad[F],
     L: CommutativeMonoid[L]
   ): CommutativeMonad[WriterT[F, L, *]] =
     new WriterTMonad[F, L] with CommutativeMonad[WriterT[F, L, *]] {
@@ -380,32 +380,35 @@ sealed abstract private[data] class WriterTInstances1 extends WriterTInstances2
 }
 
 sealed abstract private[data] class WriterTInstances2 extends WriterTInstances3 {
-  implicit def catsDataMonadErrorForWriterT[F[_], L, E](implicit F: MonadError[F, E],
-                                                        L: Monoid[L]): MonadError[WriterT[F, L, *], E] =
+  implicit def catsDataMonadErrorForWriterT[F[_], L, E](implicit
+    F: MonadError[F, E],
+    L: Monoid[L]
+  ): MonadError[WriterT[F, L, *], E] =
     new WriterTMonadError[F, L, E] {
       implicit val F0: MonadError[F, E] = F
       implicit val L0: Monoid[L] = L
     }
 
-  implicit def catsDataParallelForWriterT[M[_], L: Monoid](
-    implicit P: Parallel[M]
-  ): Parallel.Aux[WriterT[M, L, *], WriterT[P.F, L, *]] = new Parallel[WriterT[M, L, *]] {
-    type F[x] = WriterT[P.F, L, x]
-    implicit val monadM: Monad[M] = P.monad
+  implicit def catsDataParallelForWriterT[M[_], L: Monoid](implicit
+    P: Parallel[M]
+  ): Parallel.Aux[WriterT[M, L, *], WriterT[P.F, L, *]] =
+    new Parallel[WriterT[M, L, *]] {
+      type F[x] = WriterT[P.F, L, x]
+      implicit val monadM: Monad[M] = P.monad
 
-    def applicative: Applicative[WriterT[P.F, L, *]] = catsDataApplicativeForWriterT(P.applicative, Monoid[L])
-    def monad: Monad[WriterT[M, L, *]] = catsDataMonadForWriterT
+      def applicative: Applicative[WriterT[P.F, L, *]] = catsDataApplicativeForWriterT(P.applicative, Monoid[L])
+      def monad: Monad[WriterT[M, L, *]] = catsDataMonadForWriterT
 
-    def sequential: WriterT[P.F, L, *] ~> WriterT[M, L, *] =
-      new (WriterT[P.F, L, *] ~> WriterT[M, L, *]) {
-        def apply[A](wfl: WriterT[P.F, L, A]): WriterT[M, L, A] = WriterT(P.sequential(wfl.run))
-      }
+      def sequential: WriterT[P.F, L, *] ~> WriterT[M, L, *] =
+        new (WriterT[P.F, L, *] ~> WriterT[M, L, *]) {
+          def apply[A](wfl: WriterT[P.F, L, A]): WriterT[M, L, A] = WriterT(P.sequential(wfl.run))
+        }
 
-    def parallel: WriterT[M, L, *] ~> WriterT[P.F, L, *] =
-      new (WriterT[M, L, *] ~> WriterT[P.F, L, *]) {
-        def apply[A](wml: WriterT[M, L, A]): WriterT[P.F, L, A] = WriterT(P.parallel(wml.run))
-      }
-  }
+      def parallel: WriterT[M, L, *] ~> WriterT[P.F, L, *] =
+        new (WriterT[M, L, *] ~> WriterT[P.F, L, *]) {
+          def apply[A](wml: WriterT[M, L, A]): WriterT[P.F, L, A] = WriterT(P.parallel(wml.run))
+        }
+    }
 
   implicit def catsDataEqForWriterTId[L: Eq, V: Eq]: Eq[WriterT[Id, L, V]] =
     catsDataEqForWriterT[Id, L, V]
@@ -479,8 +482,10 @@ sealed abstract private[data] class WriterTInstances6 extends WriterTInstances7
 }
 
 sealed abstract private[data] class WriterTInstances7 extends WriterTInstances8 {
-  implicit def catsDataApplicativeErrorForWriterT[F[_], L, E](implicit F: ApplicativeError[F, E],
-                                                              L: Monoid[L]): ApplicativeError[WriterT[F, L, *], E] =
+  implicit def catsDataApplicativeErrorForWriterT[F[_], L, E](implicit
+    F: ApplicativeError[F, E],
+    L: Monoid[L]
+  ): ApplicativeError[WriterT[F, L, *], E] =
     new WriterTApplicativeError[F, L, E] {
       implicit val F0: ApplicativeError[F, E] = F
       implicit val L0: Monoid[L] = L
@@ -488,15 +493,17 @@ sealed abstract private[data] class WriterTInstances7 extends WriterTInstances8
 }
 
 sealed abstract private[data] class WriterTInstances8 extends WriterTInstances9 {
-  implicit def catsDataAlternativeForWriterT[F[_], L](implicit F: Alternative[F],
-                                                      L: Monoid[L]): Alternative[WriterT[F, L, *]] =
+  implicit def catsDataAlternativeForWriterT[F[_], L](implicit
+    F: Alternative[F],
+    L: Monoid[L]
+  ): Alternative[WriterT[F, L, *]] =
     new WriterTAlternative[F, L] {
       implicit val F0: Alternative[F] = F
       implicit val L0: Monoid[L] = L
     }
 
-  implicit def catsDataContravariantMonoidalForWriterT[F[_], L](
-    implicit F: ContravariantMonoidal[F]
+  implicit def catsDataContravariantMonoidalForWriterT[F[_], L](implicit
+    F: ContravariantMonoidal[F]
   ): ContravariantMonoidal[WriterT[F, L, *]] =
     new WriterTContravariantMonoidal[F, L] {
       implicit val F0: ContravariantMonoidal[F] = F
@@ -527,8 +534,10 @@ sealed abstract private[data] class WriterTInstances10 extends WriterTInstances1
       implicit val F0: SemigroupK[F] = F
     }
 
-  implicit def catsDataApplicativeForWriterT[F[_], L](implicit F: Applicative[F],
-                                                      L: Monoid[L]): Applicative[WriterT[F, L, *]] =
+  implicit def catsDataApplicativeForWriterT[F[_], L](implicit
+    F: Applicative[F],
+    L: Monoid[L]
+  ): Applicative[WriterT[F, L, *]] =
     new WriterTApplicative[F, L] {
       implicit val F0: Applicative[F] = F
       implicit val L0: Monoid[L] = L
@@ -588,8 +597,9 @@ sealed private[data] trait WriterTApply[F[_], L] extends WriterTFunctor[F, L] wi
   def ap[A, B](f: WriterT[F, L, A => B])(fa: WriterT[F, L, A]): WriterT[F, L, B] =
     fa.ap(f)
 
-  override def map2Eval[A, B, Z](fa: WriterT[F, L, A],
-                                 fb: Eval[WriterT[F, L, B]])(f: (A, B) => Z): Eval[WriterT[F, L, Z]] =
+  override def map2Eval[A, B, Z](fa: WriterT[F, L, A], fb: Eval[WriterT[F, L, B]])(
+    f: (A, B) => Z
+  ): Eval[WriterT[F, L, Z]] =
     F0.map2Eval(fa.run, fb.map(_.run)) { case ((la, a), (lb, b)) => (L0.combine(la, lb), f(a, b)) }
       .map(WriterT(_)) // F0 may have a lazy map2Eval
 
diff --git a/core/src/main/scala/cats/instances/duration.scala b/core/src/main/scala/cats/instances/duration.scala
index 005904957..21e2e0829 100644
--- a/core/src/main/scala/cats/instances/duration.scala
+++ b/core/src/main/scala/cats/instances/duration.scala
@@ -6,7 +6,8 @@ import scala.concurrent.duration.{Duration, FiniteDuration}
 trait DurationInstances extends cats.kernel.instances.DurationInstances {
 
   @deprecated("Left to keep binary compatibility. Use CoreDurationInstances.catsStdShowForDurationUnambiguous instead.",
-              "1.5.0")
+              "1.5.0"
+  )
   def catsStdShowForDuration: Show[Duration] =
     AllCoreDurationInstances.catsStdShowForDurationUnambiguous
 }
diff --git a/core/src/main/scala/cats/instances/either.scala b/core/src/main/scala/cats/instances/either.scala
index aa30e5086..a558fd503 100644
--- a/core/src/main/scala/cats/instances/either.scala
+++ b/core/src/main/scala/cats/instances/either.scala
@@ -12,8 +12,9 @@ import cats.data.Ior
 trait EitherInstances extends cats.kernel.instances.EitherInstances {
   implicit val catsStdBitraverseForEither: Bitraverse[Either] =
     new Bitraverse[Either] {
-      def bitraverse[G[_], A, B, C, D](fab: Either[A, B])(f: A => G[C],
-                                                          g: B => G[D])(implicit G: Applicative[G]): G[Either[C, D]] =
+      def bitraverse[G[_], A, B, C, D](
+        fab: Either[A, B]
+      )(f: A => G[C], g: B => G[D])(implicit G: Applicative[G]): G[Either[C, D]] =
         fab match {
           case Left(a)  => G.map(f(a))(Left(_))
           case Right(b) => G.map(g(b))(Right(_))
@@ -25,8 +26,9 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
           case Right(b) => g(c, b)
         }
 
-      def bifoldRight[A, B, C](fab: Either[A, B], c: Eval[C])(f: (A, Eval[C]) => Eval[C],
-                                                              g: (B, Eval[C]) => Eval[C]): Eval[C] =
+      def bifoldRight[A, B, C](fab: Either[A, B],
+                               c: Eval[C]
+      )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
         fab match {
           case Left(a)  => f(a, c)
           case Right(b) => g(b, c)
@@ -103,8 +105,9 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
       override def redeem[B, R](fab: Either[A, B])(recover: A => R, map: B => R): Either[A, R] =
         Right(fab.fold(recover, map))
 
-      override def redeemWith[B, R](fab: Either[A, B])(recover: A => Either[A, R],
-                                                       bind: B => Either[A, R]): Either[A, R] =
+      override def redeemWith[B, R](
+        fab: Either[A, B]
+      )(recover: A => Either[A, R], bind: B => Either[A, R]): Either[A, R] =
         fab.fold(recover, bind)
 
       override def fromEither[B](fab: Either[A, B]): Either[A, B] =
@@ -159,28 +162,36 @@ trait EitherInstances extends cats.kernel.instances.EitherInstances {
       def align[B, C](fa: Either[A, B], fb: Either[A, C]): Either[A, Ior[B, C]] =
         alignWith(fa, fb)(identity)
 
-      override def alignWith[B, C, D](fb: Either[A, B], fc: Either[A, C])(f: Ior[B, C] => D): Either[A, D] = fb match {
-        case left @ Left(a) =>
-          fc match {
-            case Left(_)  => left.rightCast[D]
-            case Right(c) => Right(f(Ior.right(c)))
-          }
-        case Right(b) =>
-          fc match {
-            case Left(a)  => Right(f(Ior.left(b)))
-            case Right(c) => Right(f(Ior.both(b, c)))
-          }
-      }
+      override def alignWith[B, C, D](fb: Either[A, B], fc: Either[A, C])(f: Ior[B, C] => D): Either[A, D] =
+        fb match {
+          case left @ Left(a) =>
+            fc match {
+              case Left(_)  => left.rightCast[D]
+              case Right(c) => Right(f(Ior.right(c)))
+            }
+          case Right(b) =>
+            fc match {
+              case Left(a)  => Right(f(Ior.left(b)))
+              case Right(c) => Right(f(Ior.both(b, c)))
+            }
+        }
 
     }
   // scalastyle:on method.length
 
   implicit def catsStdSemigroupKForEither[L]: SemigroupK[Either[L, *]] =
     new SemigroupK[Either[L, *]] {
-      def combineK[A](x: Either[L, A], y: Either[L, A]): Either[L, A] = x match {
-        case Left(_)  => y
-        case Right(_) => x
-      }
+      def combineK[A](x: Either[L, A], y: Either[L, A]): Either[L, A] =
+        x match {
+          case Left(_)  => y
+          case Right(_) => x
+        }
+
+      override def combineKEval[A](x: Either[L, A], y: Eval[Either[L, A]]): Eval[Either[L, A]] =
+        x match {
+          case Left(_)  => y
+          case Right(_) => Now(x)
+        }
     }
 
   implicit def catsStdShowForEither[A, B](implicit A: Show[A], B: Show[B]): Show[Either[A, B]] =
diff --git a/core/src/main/scala/cats/instances/equiv.scala b/core/src/main/scala/cats/instances/equiv.scala
index d441bf5d6..12e3bcc67 100644
--- a/core/src/main/scala/cats/instances/equiv.scala
+++ b/core/src/main/scala/cats/instances/equiv.scala
@@ -9,9 +9,10 @@ trait EquivInstances {
        * Defaults to trivially contracting the type
        * to a point
        */
-      def unit: Equiv[Unit] = new Equiv[Unit] {
-        def equiv(x: Unit, y: Unit): Boolean = true
-      }
+      def unit: Equiv[Unit] =
+        new Equiv[Unit] {
+          def equiv(x: Unit, y: Unit): Boolean = true
+        }
 
       /** Derive an `Equiv` for `B` given an `Equiv[A]` and a function `B => A`.
        *
diff --git a/core/src/main/scala/cats/instances/function.scala b/core/src/main/scala/cats/instances/function.scala
index 77efc0409..a3c640661 100644
--- a/core/src/main/scala/cats/instances/function.scala
+++ b/core/src/main/scala/cats/instances/function.scala
@@ -77,10 +77,11 @@ sealed private[instances] trait Function0Instances extends Function0Instances0 {
       def tailRecM[A, B](a: A)(fn: A => () => Either[A, B]): () => B =
         () => {
           @tailrec
-          def loop(thisA: A): B = fn(thisA)() match {
-            case Right(b)    => b
-            case Left(nextA) => loop(nextA)
-          }
+          def loop(thisA: A): B =
+            fn(thisA)() match {
+              case Right(b)    => b
+              case Left(nextA) => loop(nextA)
+            }
           loop(a)
         }
     }
@@ -88,13 +89,14 @@ sealed private[instances] trait Function0Instances extends Function0Instances0 {
 }
 
 sealed private[instances] trait Function0Instances0 {
-  implicit def function0Distributive: Distributive[Function0] = new Distributive[Function0] {
-    def distribute[F[_]: Functor, A, B](fa: F[A])(f: A => Function0[B]): Function0[F[B]] = { () =>
-      Functor[F].map(fa)(a => f(a)())
-    }
+  implicit def function0Distributive: Distributive[Function0] =
+    new Distributive[Function0] {
+      def distribute[F[_]: Functor, A, B](fa: F[A])(f: A => Function0[B]): Function0[F[B]] = { () =>
+        Functor[F].map(fa)(a => f(a)())
+      }
 
-    def map[A, B](fa: Function0[A])(f: A => B): Function0[B] = () => f(fa())
-  }
+      def map[A, B](fa: Function0[A])(f: A => B): Function0[B] = () => f(fa())
+    }
 }
 
 sealed private[instances] trait Function1Instances extends Function1Instances0 {
@@ -123,10 +125,11 @@ sealed private[instances] trait Function1Instances extends Function1Instances0 {
       def tailRecM[A, B](a: A)(fn: A => T1 => Either[A, B]): T1 => B =
         (t: T1) => {
           @tailrec
-          def step(thisA: A): B = fn(thisA)(t) match {
-            case Right(b)    => b
-            case Left(nextA) => step(nextA)
-          }
+          def step(thisA: A): B =
+            fn(thisA)(t) match {
+              case Right(b)    => b
+              case Left(nextA) => step(nextA)
+            }
           step(a)
         }
     }
@@ -171,13 +174,14 @@ sealed private[instances] trait Function1Instances0 {
         fa.compose(f)
     }
 
-  implicit def catsStdDistributiveForFunction1[T1]: Distributive[T1 => *] = new Distributive[T1 => *] {
-    def distribute[F[_]: Functor, A, B](fa: F[A])(f: A => (T1 => B)): T1 => F[B] = { t1 =>
-      Functor[F].map(fa)(a => f(a)(t1))
-    }
+  implicit def catsStdDistributiveForFunction1[T1]: Distributive[T1 => *] =
+    new Distributive[T1 => *] {
+      def distribute[F[_]: Functor, A, B](fa: F[A])(f: A => (T1 => B)): T1 => F[B] = { t1 =>
+        Functor[F].map(fa)(a => f(a)(t1))
+      }
 
-    def map[A, B](fa: T1 => A)(f: A => B): T1 => B = { t1 =>
-      f(fa(t1))
+      def map[A, B](fa: T1 => A)(f: A => B): T1 => B = { t1 =>
+        f(fa(t1))
+      }
     }
-  }
 }
diff --git a/core/src/main/scala/cats/instances/future.scala b/core/src/main/scala/cats/instances/future.scala
index 93e91e2cc..f8fe44511 100644
--- a/core/src/main/scala/cats/instances/future.scala
+++ b/core/src/main/scala/cats/instances/future.scala
@@ -6,8 +6,8 @@ import scala.util.{Failure, Success}
 
 trait FutureInstances extends FutureInstances1 {
 
-  implicit def catsStdInstancesForFuture(
-    implicit ec: ExecutionContext
+  implicit def catsStdInstancesForFuture(implicit
+    ec: ExecutionContext
   ): MonadError[Future, Throwable] with CoflatMap[Future] with Monad[Future] =
     new FutureCoflatMap with MonadError[Future, Throwable] with Monad[Future] with StackSafeMonad[Future] {
       override def pure[A](x: A): Future[A] =
diff --git a/core/src/main/scala/cats/instances/invariant.scala b/core/src/main/scala/cats/instances/invariant.scala
index 0479941cb..34897663f 100644
--- a/core/src/main/scala/cats/instances/invariant.scala
+++ b/core/src/main/scala/cats/instances/invariant.scala
@@ -6,27 +6,32 @@ import cats.{InvariantMonoidal, InvariantSemigroupal, Monoid}
 
 trait InvariantMonoidalInstances {
 
-  implicit def catsSemigroupalForMonoid: InvariantSemigroupal[Monoid] = new InvariantSemigroupal[Monoid] {
-    def product[A, B](fa: Monoid[A], fb: Monoid[B]): Monoid[(A, B)] = new Monoid[(A, B)] {
-      val empty = fa.empty -> fb.empty
-      def combine(x: (A, B), y: (A, B)): (A, B) = fa.combine(x._1, y._1) -> fb.combine(x._2, y._2)
-    }
+  implicit def catsSemigroupalForMonoid: InvariantSemigroupal[Monoid] =
+    new InvariantSemigroupal[Monoid] {
+      def product[A, B](fa: Monoid[A], fb: Monoid[B]): Monoid[(A, B)] =
+        new Monoid[(A, B)] {
+          val empty = fa.empty -> fb.empty
+          def combine(x: (A, B), y: (A, B)): (A, B) = fa.combine(x._1, y._1) -> fb.combine(x._2, y._2)
+        }
 
-    def imap[A, B](fa: Monoid[A])(f: A => B)(g: B => A): Monoid[B] = new Monoid[B] {
-      def empty: B = f(fa.empty)
+      def imap[A, B](fa: Monoid[A])(f: A => B)(g: B => A): Monoid[B] =
+        new Monoid[B] {
+          def empty: B = f(fa.empty)
 
-      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+          def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+        }
     }
-  }
 
   implicit val catsInvariantMonoidalSemigroup: InvariantMonoidal[Semigroup] = new InvariantMonoidal[Semigroup] {
-    def product[A, B](fa: Semigroup[A], fb: Semigroup[B]): Semigroup[(A, B)] = new Semigroup[(A, B)] {
-      def combine(x: (A, B), y: (A, B)): (A, B) = fa.combine(x._1, y._1) -> fb.combine(x._2, y._2)
-    }
-
-    def imap[A, B](fa: Semigroup[A])(f: A => B)(g: B => A): Semigroup[B] = new Semigroup[B] {
-      def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
-    }
+    def product[A, B](fa: Semigroup[A], fb: Semigroup[B]): Semigroup[(A, B)] =
+      new Semigroup[(A, B)] {
+        def combine(x: (A, B), y: (A, B)): (A, B) = fa.combine(x._1, y._1) -> fb.combine(x._2, y._2)
+      }
+
+    def imap[A, B](fa: Semigroup[A])(f: A => B)(g: B => A): Semigroup[B] =
+      new Semigroup[B] {
+        def combine(x: B, y: B): B = f(fa.combine(g(x), g(y)))
+      }
 
     def unit: Semigroup[Unit] = implicitly
   }
diff --git a/core/src/main/scala/cats/instances/list.scala b/core/src/main/scala/cats/instances/list.scala
index 98a64742a..a0b271920 100644
--- a/core/src/main/scala/cats/instances/list.scala
+++ b/core/src/main/scala/cats/instances/list.scala
@@ -36,15 +36,16 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
 
       def tailRecM[A, B](a: A)(f: A => List[Either[A, B]]): List[B] = {
         val buf = List.newBuilder[B]
-        @tailrec def go(lists: List[List[Either[A, B]]]): Unit = lists match {
-          case (ab :: abs) :: tail =>
-            ab match {
-              case Right(b) => buf += b; go(abs :: tail)
-              case Left(a)  => go(f(a) :: abs :: tail)
-            }
-          case Nil :: tail => go(tail)
-          case Nil         => ()
-        }
+        @tailrec def go(lists: List[List[Either[A, B]]]): Unit =
+          lists match {
+            case (ab :: abs) :: tail =>
+              ab match {
+                case Right(b) => buf += b; go(abs :: tail)
+                case Left(a)  => go(f(a) :: abs :: tail)
+              }
+            case Nil :: tail => go(tail)
+            case Nil         => ()
+          }
         go(f(a) :: Nil)
         buf.result
       }
@@ -73,11 +74,21 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
       override def foldMap[A, B](fa: List[A])(f: A => B)(implicit B: Monoid[B]): B =
         B.combineAll(fa.iterator.map(f))
 
+      override def foldMapK[G[_], A, B](fa: List[A])(f: A => G[B])(implicit G: MonoidK[G]): G[B] = {
+        def loop(fa: List[A]): Eval[G[B]] =
+          fa match {
+            case head :: tl => G.combineKEval(f(head), Eval.defer(loop(tl)))
+            case Nil        => Eval.now(G.empty)
+          }
+        loop(fa).value
+      }
+
       def traverse[G[_], A, B](fa: List[A])(f: A => G[B])(implicit G: Applicative[G]): G[List[B]] = {
-        def loop(fa: List[A]): Eval[G[List[B]]] = fa match {
-          case h :: t => G.map2Eval(f(h), Eval.defer(loop(t)))(_ :: _)
-          case Nil    => Eval.now(G.pure(Nil))
-        }
+        def loop(fa: List[A]): Eval[G[List[B]]] =
+          fa match {
+            case h :: t => G.map2Eval(f(h), Eval.defer(loop(t)))(_ :: _)
+            case Nil    => Eval.now(G.pure(Nil))
+          }
         loop(fa).value
       }
 
@@ -132,13 +143,14 @@ trait ListInstances extends cats.kernel.instances.ListInstances {
       override def isEmpty[A](fa: List[A]): Boolean = fa.isEmpty
 
       override def foldM[G[_], A, B](fa: List[A], z: B)(f: (B, A) => G[B])(implicit G: Monad[G]): G[B] = {
-        def step(in: (List[A], B)): G[Either[(List[A], B), B]] = in match {
-          case (Nil, b) => G.pure(Right(b))
-          case (a :: tail, b) =>
-            G.map(f(b, a)) { bnext =>
-              Left((tail, bnext))
-            }
-        }
+        def step(in: (List[A], B)): G[Either[(List[A], B), B]] =
+          in match {
+            case (Nil, b) => G.pure(Right(b))
+            case (a :: tail, b) =>
+              G.map(f(b, a)) { bnext =>
+                Left((tail, bnext))
+              }
+          }
 
         G.tailRecM((fa, z))(step)
       }
diff --git a/core/src/main/scala/cats/instances/map.scala b/core/src/main/scala/cats/instances/map.scala
index 0dfd81864..ed60091ae 100644
--- a/core/src/main/scala/cats/instances/map.scala
+++ b/core/src/main/scala/cats/instances/map.scala
@@ -165,9 +165,10 @@ private[instances] trait MapInstancesBinCompat0 {
 }
 
 private[instances] trait MapInstancesBinCompat1 {
-  implicit def catsStdMonoidKForMap[K]: MonoidK[Map[K, *]] = new MonoidK[Map[K, *]] {
-    override def empty[A]: Map[K, A] = Map.empty
+  implicit def catsStdMonoidKForMap[K]: MonoidK[Map[K, *]] =
+    new MonoidK[Map[K, *]] {
+      override def empty[A]: Map[K, A] = Map.empty
 
-    override def combineK[A](x: Map[K, A], y: Map[K, A]): Map[K, A] = x ++ y
-  }
+      override def combineK[A](x: Map[K, A], y: Map[K, A]): Map[K, A] = x ++ y
+    }
 }
diff --git a/core/src/main/scala/cats/instances/option.scala b/core/src/main/scala/cats/instances/option.scala
index 47ac85954..64a130093 100644
--- a/core/src/main/scala/cats/instances/option.scala
+++ b/core/src/main/scala/cats/instances/option.scala
@@ -23,6 +23,12 @@ trait OptionInstances extends cats.kernel.instances.OptionInstances {
 
       def combineK[A](x: Option[A], y: Option[A]): Option[A] = x.orElse(y)
 
+      override def combineKEval[A](x: Option[A], y: Eval[Option[A]]): Eval[Option[A]] =
+        x match {
+          case None    => y
+          case Some(_) => Now(x)
+        }
+
       def pure[A](x: A): Option[A] = Some(x)
 
       override def map[A, B](fa: Option[A])(f: A => B): Option[B] =
@@ -153,10 +159,11 @@ trait OptionInstances extends cats.kernel.instances.OptionInstances {
 
   implicit def catsStdShowForOption[A](implicit A: Show[A]): Show[Option[A]] =
     new Show[Option[A]] {
-      def show(fa: Option[A]): String = fa match {
-        case Some(a) => s"Some(${A.show(a)})"
-        case None    => "None"
-      }
+      def show(fa: Option[A]): String =
+        fa match {
+          case Some(a) => s"Some(${A.show(a)})"
+          case None    => "None"
+        }
     }
 }
 
diff --git a/core/src/main/scala/cats/instances/set.scala b/core/src/main/scala/cats/instances/set.scala
index 0e9e8c223..a63d0fe64 100644
--- a/core/src/main/scala/cats/instances/set.scala
+++ b/core/src/main/scala/cats/instances/set.scala
@@ -39,8 +39,9 @@ trait SetInstances extends cats.kernel.instances.SetInstances {
 
     }
 
-  implicit def catsStdShowForSet[A: Show]: Show[Set[A]] = new Show[Set[A]] {
-    def show(fa: Set[A]): String =
-      fa.iterator.map(_.show).mkString("Set(", ", ", ")")
-  }
+  implicit def catsStdShowForSet[A: Show]: Show[Set[A]] =
+    new Show[Set[A]] {
+      def show(fa: Set[A]): String =
+        fa.iterator.map(_.show).mkString("Set(", ", ", ")")
+    }
 }
diff --git a/core/src/main/scala/cats/instances/sortedMap.scala b/core/src/main/scala/cats/instances/sortedMap.scala
index b61eeb5a3..4f3bb9faf 100644
--- a/core/src/main/scala/cats/instances/sortedMap.scala
+++ b/core/src/main/scala/cats/instances/sortedMap.scala
@@ -51,13 +51,15 @@ trait SortedMapInstances extends SortedMapInstances2 {
       override def map[A, B](fa: SortedMap[K, A])(f: A => B): SortedMap[K, B] =
         fa.map { case (k, a) => (k, f(a)) }
 
-      override def map2Eval[A, B, Z](fa: SortedMap[K, A],
-                                     fb: Eval[SortedMap[K, B]])(f: (A, B) => Z): Eval[SortedMap[K, Z]] =
+      override def map2Eval[A, B, Z](fa: SortedMap[K, A], fb: Eval[SortedMap[K, B]])(
+        f: (A, B) => Z
+      ): Eval[SortedMap[K, Z]] =
         if (fa.isEmpty) Eval.now(SortedMap.empty(Order[K].toOrdering)) // no need to evaluate fb
         else fb.map(fb => map2(fa, fb)(f))
 
-      override def ap2[A, B, Z](f: SortedMap[K, (A, B) => Z])(fa: SortedMap[K, A],
-                                                              fb: SortedMap[K, B]): SortedMap[K, Z] =
+      override def ap2[A, B, Z](
+        f: SortedMap[K, (A, B) => Z]
+      )(fa: SortedMap[K, A], fb: SortedMap[K, B]): SortedMap[K, Z] =
         f.flatMap {
           case (k, f) =>
             for { a <- fa.get(k); b <- fb.get(k) } yield (k, f(a, b))
@@ -216,11 +218,12 @@ private[instances] trait SortedMapInstancesBinCompat0 {
 }
 
 private[instances] trait SortedMapInstancesBinCompat1 {
-  implicit def catsStdMonoidKForSortedMap[K: Order]: MonoidK[SortedMap[K, *]] = new MonoidK[SortedMap[K, *]] {
-    override def empty[A]: SortedMap[K, A] = SortedMap.empty[K, A](Order[K].toOrdering)
+  implicit def catsStdMonoidKForSortedMap[K: Order]: MonoidK[SortedMap[K, *]] =
+    new MonoidK[SortedMap[K, *]] {
+      override def empty[A]: SortedMap[K, A] = SortedMap.empty[K, A](Order[K].toOrdering)
 
-    override def combineK[A](x: SortedMap[K, A], y: SortedMap[K, A]): SortedMap[K, A] = x ++ y
-  }
+      override def combineK[A](x: SortedMap[K, A], y: SortedMap[K, A]): SortedMap[K, A] = x ++ y
+    }
 }
 
 private[instances] trait SortedMapInstancesBinCompat2 extends cats.kernel.instances.SortedMapInstances
diff --git a/core/src/main/scala/cats/instances/sortedSet.scala b/core/src/main/scala/cats/instances/sortedSet.scala
index 36a9652f6..e829be16d 100644
--- a/core/src/main/scala/cats/instances/sortedSet.scala
+++ b/core/src/main/scala/cats/instances/sortedSet.scala
@@ -60,10 +60,11 @@ trait SortedSetInstances extends SortedSetInstances1 {
         fa.collectFirst(Function.unlift(f))
     }
 
-  implicit def catsStdShowForSortedSet[A: Show]: Show[SortedSet[A]] = new Show[SortedSet[A]] {
-    def show(fa: SortedSet[A]): String =
-      fa.iterator.map(Show[A].show).mkString("SortedSet(", ", ", ")")
-  }
+  implicit def catsStdShowForSortedSet[A: Show]: Show[SortedSet[A]] =
+    new Show[SortedSet[A]] {
+      def show(fa: SortedSet[A]): String =
+        fa.iterator.map(Show[A].show).mkString("SortedSet(", ", ", ")")
+    }
 
   @deprecated("Use cats.kernel.instances.sortedSet.catsKernelStdOrderForSortedSet", "2.0.0-RC2")
   private[instances] def catsKernelStdOrderForSortedSet[A: Order]: Order[SortedSet[A]] =
diff --git a/core/src/main/scala/cats/instances/try.scala b/core/src/main/scala/cats/instances/try.scala
index 3e98c024f..5d5f68663 100644
--- a/core/src/main/scala/cats/instances/try.scala
+++ b/core/src/main/scala/cats/instances/try.scala
@@ -15,17 +15,19 @@ trait TryInstances extends TryInstances1 {
     new TryCoflatMap with MonadError[Try, Throwable] with Traverse[Try] with Monad[Try] {
       def pure[A](x: A): Try[A] = Success(x)
 
-      override def product[A, B](ta: Try[A], tb: Try[B]): Try[(A, B)] = (ta, tb) match {
-        case (Success(a), Success(b)) => Success((a, b))
-        case (f: Failure[_], _)       => castFailure[(A, B)](f)
-        case (_, f: Failure[_])       => castFailure[(A, B)](f)
-      }
-
-      override def map2[A, B, Z](ta: Try[A], tb: Try[B])(f: (A, B) => Z): Try[Z] = (ta, tb) match {
-        case (Success(a), Success(b)) => Try(f(a, b))
-        case (f: Failure[_], _)       => castFailure[Z](f)
-        case (_, f: Failure[_])       => castFailure[Z](f)
-      }
+      override def product[A, B](ta: Try[A], tb: Try[B]): Try[(A, B)] =
+        (ta, tb) match {
+          case (Success(a), Success(b)) => Success((a, b))
+          case (f: Failure[_], _)       => castFailure[(A, B)](f)
+          case (_, f: Failure[_])       => castFailure[(A, B)](f)
+        }
+
+      override def map2[A, B, Z](ta: Try[A], tb: Try[B])(f: (A, B) => Z): Try[Z] =
+        (ta, tb) match {
+          case (Success(a), Success(b)) => Try(f(a, b))
+          case (f: Failure[_], _)       => castFailure[Z](f)
+          case (_, f: Failure[_])       => castFailure[Z](f)
+        }
 
       override def map2Eval[A, B, Z](ta: Try[A], tb: Eval[Try[B]])(f: (A, B) => Z): Eval[Try[Z]] =
         ta match {
@@ -146,10 +148,11 @@ trait TryInstances extends TryInstances1 {
 
   implicit def catsStdShowForTry[A](implicit A: Show[A]): Show[Try[A]] =
     new Show[Try[A]] {
-      def show(fa: Try[A]): String = fa match {
-        case Success(a) => s"Success(${A.show(a)})"
-        case Failure(e) => s"Failure($e)"
-      }
+      def show(fa: Try[A]): String =
+        fa match {
+          case Success(a) => s"Success(${A.show(a)})"
+          case Failure(e) => s"Failure($e)"
+        }
     }
 
   /**
@@ -159,11 +162,12 @@ trait TryInstances extends TryInstances1 {
    */
   implicit def catsStdEqForTry[A, T](implicit A: Eq[A], T: Eq[Throwable]): Eq[Try[A]] =
     new Eq[Try[A]] {
-      def eqv(x: Try[A], y: Try[A]): Boolean = (x, y) match {
-        case (Success(a), Success(b)) => A.eqv(a, b)
-        case (Failure(a), Failure(b)) => T.eqv(a, b)
-        case _                        => false
-      }
+      def eqv(x: Try[A], y: Try[A]): Boolean =
+        (x, y) match {
+          case (Success(a), Success(b)) => A.eqv(a, b)
+          case (Failure(a), Failure(b)) => T.eqv(a, b)
+          case _                        => false
+        }
     }
 }
 
diff --git a/core/src/main/scala/cats/instances/tuple.scala b/core/src/main/scala/cats/instances/tuple.scala
index 850734a42..78851cda5 100644
--- a/core/src/main/scala/cats/instances/tuple.scala
+++ b/core/src/main/scala/cats/instances/tuple.scala
@@ -12,19 +12,20 @@ private[instances] trait Tuple2InstancesBinCompat0 {
   /**
    * Witness for: (A, A) <-> Boolean => A
    */
-  implicit def catsDataRepresentableForPair(
-    implicit PF: Functor[Î»[P => (P, P)]]
-  ): Representable.Aux[Î»[P => (P, P)], Boolean] = new Representable[Î»[P => (P, P)]] {
-    override type Representation = Boolean
-    override val F: Functor[Î»[P => (P, P)]] = PF
-
-    override def tabulate[A](f: Boolean => A): (A, A) = (f(true), f(false))
-
-    override def index[A](pair: (A, A)): Boolean => A = {
-      case true  => pair._1
-      case false => pair._2
+  implicit def catsDataRepresentableForPair(implicit
+    PF: Functor[Î»[P => (P, P)]]
+  ): Representable.Aux[Î»[P => (P, P)], Boolean] =
+    new Representable[Î»[P => (P, P)]] {
+      override type Representation = Boolean
+      override val F: Functor[Î»[P => (P, P)]] = PF
+
+      override def tabulate[A](f: Boolean => A): (A, A) = (f(true), f(false))
+
+      override def index[A](pair: (A, A)): Boolean => A = {
+        case true  => pair._1
+        case false => pair._2
+      }
     }
-  }
 
   implicit val catsDataFunctorForPair: Functor[Î»[P => (P, P)]] = new Functor[Î»[P => (P, P)]] {
     override def map[A, B](fa: (A, A))(f: A => B): (B, B) = (f(fa._1), f(fa._2))
@@ -40,15 +41,17 @@ sealed private[instances] trait Tuple2Instances extends Tuple2Instances1 {
       def bifoldLeft[A, B, C](fab: (A, B), c: C)(f: (C, A) => C, g: (C, B) => C): C =
         g(f(c, fab._1), fab._2)
 
-      def bifoldRight[A, B, C](fab: (A, B), c: Eval[C])(f: (A, Eval[C]) => Eval[C],
-                                                        g: (B, Eval[C]) => Eval[C]): Eval[C] =
+      def bifoldRight[A, B, C](fab: (A, B),
+                               c: Eval[C]
+      )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] =
         g(fab._2, f(fab._1, c))
     }
 
-  implicit def catsStdShowForTuple2[A, B](implicit aShow: Show[A], bShow: Show[B]): Show[(A, B)] = new Show[(A, B)] {
-    override def show(f: (A, B)): String =
-      s"(${aShow.show(f._1)},${bShow.show(f._2)})"
-  }
+  implicit def catsStdShowForTuple2[A, B](implicit aShow: Show[A], bShow: Show[B]): Show[(A, B)] =
+    new Show[(A, B)] {
+      override def show(f: (A, B)): String =
+        s"(${aShow.show(f._1)},${bShow.show(f._2)})"
+    }
 
   implicit def catsStdInstancesForTuple2[X]: Traverse[(X, *)] with Comonad[(X, *)] with Reducible[(X, *)] =
     new Traverse[(X, *)] with Comonad[(X, *)] with Reducible[(X, *)] {
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index 0d65766b5..e5828c9f7 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -59,21 +59,22 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
         val buf = Vector.newBuilder[B]
         var state = List(fn(a).iterator)
         @tailrec
-        def loop(): Unit = state match {
-          case Nil => ()
-          case h :: tail if h.isEmpty =>
-            state = tail
-            loop()
-          case h :: tail =>
-            h.next match {
-              case Right(b) =>
-                buf += b
-                loop()
-              case Left(a) =>
-                state = (fn(a).iterator) :: h :: tail
-                loop()
-            }
-        }
+        def loop(): Unit =
+          state match {
+            case Nil => ()
+            case h :: tail if h.isEmpty =>
+              state = tail
+              loop()
+            case h :: tail =>
+              h.next match {
+                case Right(b) =>
+                  buf += b
+                  loop()
+                case Left(a) =>
+                  state = (fn(a).iterator) :: h :: tail
+                  loop()
+              }
+          }
         loop()
         buf.result
       }
@@ -83,6 +84,12 @@ trait VectorInstances extends cats.kernel.instances.VectorInstances {
       override def get[A](fa: Vector[A])(idx: Long): Option[A] =
         if (idx < Int.MaxValue && fa.size > idx && idx >= 0) Some(fa(idx.toInt)) else None
 
+      override def foldMapK[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: MonoidK[G]): G[B] = {
+        def loop(i: Int): Eval[G[B]] =
+          if (i < fa.length) G.combineKEval(f(fa(i)), Eval.defer(loop(i + 1))) else Eval.now(G.empty)
+        loop(0).value
+      }
+
       final override def traverse[G[_], A, B](fa: Vector[A])(f: A => G[B])(implicit G: Applicative[G]): G[Vector[B]] = {
         def loop(i: Int): Eval[G[List[B]]] =
           if (i < fa.length) G.map2Eval(f(fa(i)), Eval.defer(loop(i + 1)))(_ :: _) else Eval.now(G.pure(Nil))
@@ -175,7 +182,9 @@ private[instances] trait VectorInstancesBinCompat0 {
 
     def traverseFilter[G[_], A, B](fa: Vector[A])(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Vector[B]] =
       traverse
-        .foldRight(fa, Eval.now(G.pure(Vector.empty[B])))((x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o)))
+        .foldRight(fa, Eval.now(G.pure(Vector.empty[B])))((x, xse) =>
+          G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o))
+        )
         .value
 
     override def filterA[G[_], A](fa: Vector[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Vector[A]] =
diff --git a/core/src/main/scala/cats/package.scala b/core/src/main/scala/cats/package.scala
index 5326e8fcd..e90b835aa 100644
--- a/core/src/main/scala/cats/package.scala
+++ b/core/src/main/scala/cats/package.scala
@@ -68,10 +68,11 @@ package object cats {
       def extract[A](a: A): A = a
       def flatMap[A, B](a: A)(f: A => B): B = f(a)
       def coflatMap[A, B](a: A)(f: A => B): B = f(a)
-      @tailrec def tailRecM[A, B](a: A)(f: A => Either[A, B]): B = f(a) match {
-        case Left(a1) => tailRecM(a1)(f)
-        case Right(b) => b
-      }
+      @tailrec def tailRecM[A, B](a: A)(f: A => Either[A, B]): B =
+        f(a) match {
+          case Left(a1) => tailRecM(a1)(f)
+          case Right(b) => b
+        }
       override def distribute[F[_], A, B](fa: F[A])(f: A => B)(implicit F: Functor[F]): Id[F[B]] = F.map(fa)(f)
       override def map[A, B](fa: A)(f: A => B): B = f(fa)
       override def ap[A, B](ff: A => B)(fa: A): B = ff(fa)
diff --git a/core/src/main/scala/cats/syntax/alternative.scala b/core/src/main/scala/cats/syntax/alternative.scala
index 7afdf811d..79ac72977 100644
--- a/core/src/main/scala/cats/syntax/alternative.scala
+++ b/core/src/main/scala/cats/syntax/alternative.scala
@@ -26,10 +26,7 @@ final class UniteOps[F[_], G[_], A](private val fga: F[G[A]]) extends AnyVal {
    * res0: List[Int] = List(1, 2, 3, 4)
    * }}}
    */
-  def unite(implicit
-            F: Monad[F],
-            A: Alternative[F],
-            G: Foldable[G]): F[A] = A.unite[G, A](fga)
+  def unite(implicit F: Monad[F], A: Alternative[F], G: Foldable[G]): F[A] = A.unite[G, A](fga)
 }
 
 final class SeparateOps[F[_], G[_, _], A, B](private val fgab: F[G[A, B]]) extends AnyVal {
@@ -45,10 +42,7 @@ final class SeparateOps[F[_], G[_, _], A, B](private val fgab: F[G[A, B]]) exten
    * res0: (List[String], List[Int]) = (List(error),List(1))
    * }}}
    */
-  def separate(implicit
-               F: Monad[F],
-               A: Alternative[F],
-               G: Bifoldable[G]): (F[A], F[B]) = A.separate[G, A, B](fgab)
+  def separate(implicit F: Monad[F], A: Alternative[F], G: Bifoldable[G]): (F[A], F[B]) = A.separate[G, A, B](fgab)
 
   /**
    * @see [[Alternative.separateFoldable]]
@@ -61,10 +55,8 @@ final class SeparateOps[F[_], G[_, _], A, B](private val fgab: F[G[A, B]]) exten
    * res0: (List[String], List[Int]) = (List(error),List(1))
    * }}}
    */
-  def separateFoldable(implicit
-                       F: Foldable[F],
-                       A: Alternative[F],
-                       G: Bifoldable[G]): (F[A], F[B]) = A.separateFoldable[G, A, B](fgab)
+  def separateFoldable(implicit F: Foldable[F], A: Alternative[F], G: Bifoldable[G]): (F[A], F[B]) =
+    A.separateFoldable[G, A, B](fgab)
 }
 
 final class GuardOps(private val condition: Boolean) extends AnyVal {
diff --git a/core/src/main/scala/cats/syntax/applicativeError.scala b/core/src/main/scala/cats/syntax/applicativeError.scala
index 61ba4b225..b799f16e0 100644
--- a/core/src/main/scala/cats/syntax/applicativeError.scala
+++ b/core/src/main/scala/cats/syntax/applicativeError.scala
@@ -51,9 +51,11 @@ final class ApplicativeErrorOps[F[_], E, A](private val fa: F[A]) extends AnyVal
   def attempt(implicit F: ApplicativeError[F, E]): F[Either[E, A]] =
     F.attempt(fa)
 
-  def attemptNarrow[EE <: Throwable](implicit F: ApplicativeError[F, E],
-                                     tag: ClassTag[EE],
-                                     ev: EE <:< E): F[Either[EE, A]] =
+  def attemptNarrow[EE <: Throwable](implicit
+    F: ApplicativeError[F, E],
+    tag: ClassTag[EE],
+    ev: EE <:< E
+  ): F[Either[EE, A]] =
     F.attemptNarrow[EE, A](fa)
 
   def attemptT(implicit F: ApplicativeError[F, E]): EitherT[F, E, A] =
diff --git a/core/src/main/scala/cats/syntax/either.scala b/core/src/main/scala/cats/syntax/either.scala
index dda9b5df6..91e95d9c4 100644
--- a/core/src/main/scala/cats/syntax/either.scala
+++ b/core/src/main/scala/cats/syntax/either.scala
@@ -38,108 +38,126 @@ object EitherSyntax {
 
 final class EitherOps[A, B](private val eab: Either[A, B]) extends AnyVal {
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def foreach(f: B => Unit): Unit = eab match {
-    case Left(_)  => ()
-    case Right(b) => f(b)
-  }
+  private[syntax] def foreach(f: B => Unit): Unit =
+    eab match {
+      case Left(_)  => ()
+      case Right(b) => f(b)
+    }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def getOrElse[BB >: B](default: => BB): BB = eab match {
-    case Left(_)  => default
-    case Right(b) => b
-  }
+  private[syntax] def getOrElse[BB >: B](default: => BB): BB =
+    eab match {
+      case Left(_)  => default
+      case Right(b) => b
+    }
 
-  def orElse[C, BB >: B](fallback: => Either[C, BB]): Either[C, BB] = eab match {
-    case Left(_)      => fallback
-    case r @ Right(_) => EitherUtil.leftCast(r)
-  }
+  def orElse[C, BB >: B](fallback: => Either[C, BB]): Either[C, BB] =
+    eab match {
+      case Left(_)      => fallback
+      case r @ Right(_) => EitherUtil.leftCast(r)
+    }
 
-  def recover[BB >: B](pf: PartialFunction[A, BB]): Either[A, BB] = eab match {
-    case Left(a) if pf.isDefinedAt(a) => Right(pf(a))
-    case _                            => eab
-  }
+  def recover[BB >: B](pf: PartialFunction[A, BB]): Either[A, BB] =
+    eab match {
+      case Left(a) if pf.isDefinedAt(a) => Right(pf(a))
+      case _                            => eab
+    }
 
-  def recoverWith[AA >: A, BB >: B](pf: PartialFunction[A, Either[AA, BB]]): Either[AA, BB] = eab match {
-    case Left(a) if pf.isDefinedAt(a) => pf(a)
-    case _                            => eab
-  }
+  def recoverWith[AA >: A, BB >: B](pf: PartialFunction[A, Either[AA, BB]]): Either[AA, BB] =
+    eab match {
+      case Left(a) if pf.isDefinedAt(a) => pf(a)
+      case _                            => eab
+    }
 
-  def valueOr[BB >: B](f: A => BB): BB = eab match {
-    case Left(a)  => f(a)
-    case Right(b) => b
-  }
+  def valueOr[BB >: B](f: A => BB): BB =
+    eab match {
+      case Left(a)  => f(a)
+      case Right(b) => b
+    }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def forall(f: B => Boolean): Boolean = eab match {
-    case Left(_)  => true
-    case Right(b) => f(b)
-  }
+  private[syntax] def forall(f: B => Boolean): Boolean =
+    eab match {
+      case Left(_)  => true
+      case Right(b) => f(b)
+    }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def exists(f: B => Boolean): Boolean = eab match {
-    case Left(_)  => false
-    case Right(b) => f(b)
-  }
+  private[syntax] def exists(f: B => Boolean): Boolean =
+    eab match {
+      case Left(_)  => false
+      case Right(b) => f(b)
+    }
 
-  def ensure[AA >: A](onFailure: => AA)(f: B => Boolean): Either[AA, B] = eab match {
-    case Left(_)  => eab
-    case Right(b) => if (f(b)) eab else Left(onFailure)
-  }
+  def ensure[AA >: A](onFailure: => AA)(f: B => Boolean): Either[AA, B] =
+    eab match {
+      case Left(_)  => eab
+      case Right(b) => if (f(b)) eab else Left(onFailure)
+    }
 
-  def ensureOr[AA >: A](onFailure: B => AA)(f: B => Boolean): Either[AA, B] = eab match {
-    case Left(_)  => eab
-    case Right(b) => if (f(b)) eab else Left(onFailure(b))
-  }
+  def ensureOr[AA >: A](onFailure: B => AA)(f: B => Boolean): Either[AA, B] =
+    eab match {
+      case Left(_)  => eab
+      case Right(b) => if (f(b)) eab else Left(onFailure(b))
+    }
 
   def toIor: A Ior B = Ior.fromEither(eab)
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def toOption: Option[B] = eab match {
-    case Left(_)  => None
-    case Right(b) => Some(b)
-  }
+  private[syntax] def toOption: Option[B] =
+    eab match {
+      case Left(_)  => None
+      case Right(b) => Some(b)
+    }
 
-  def toList: List[B] = eab match {
-    case Left(_)  => Nil
-    case Right(b) => List(b)
-  }
+  def toList: List[B] =
+    eab match {
+      case Left(_)  => Nil
+      case Right(b) => List(b)
+    }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def toTry(implicit ev: A <:< Throwable): Try[B] = eab match {
-    case Left(a)  => Failure(ev(a))
-    case Right(b) => Success(b)
-  }
+  private[syntax] def toTry(implicit ev: A <:< Throwable): Try[B] =
+    eab match {
+      case Left(a)  => Failure(ev(a))
+      case Right(b) => Success(b)
+    }
 
-  def toValidated: Validated[A, B] = eab match {
-    case Left(a)  => Validated.invalid(a)
-    case Right(b) => Validated.valid(b)
-  }
+  def toValidated: Validated[A, B] =
+    eab match {
+      case Left(a)  => Validated.invalid(a)
+      case Right(b) => Validated.valid(b)
+    }
 
   /** Returns a [[cats.data.ValidatedNel]] representation of this disjunction with the `Left` value
    * as a single element on the `Invalid` side of the [[cats.data.NonEmptyList]]. */
-  def toValidatedNel[AA >: A]: ValidatedNel[AA, B] = eab match {
-    case Left(a)  => Validated.invalidNel(a)
-    case Right(b) => Validated.valid(b)
-  }
+  def toValidatedNel[AA >: A]: ValidatedNel[AA, B] =
+    eab match {
+      case Left(a)  => Validated.invalidNel(a)
+      case Right(b) => Validated.valid(b)
+    }
 
   def withValidated[AA, BB](f: Validated[A, B] => Validated[AA, BB]): Either[AA, BB] =
     f(toValidated).toEither
 
-  def to[F[_]](implicit F: Alternative[F]): F[B] = eab match {
-    case Left(_)  => F.empty
-    case Right(b) => F.pure(b)
-  }
+  def to[F[_]](implicit F: Alternative[F]): F[B] =
+    eab match {
+      case Left(_)  => F.empty
+      case Right(b) => F.pure(b)
+    }
 
-  def bimap[C, D](fa: A => C, fb: B => D): Either[C, D] = eab match {
-    case Left(a)  => Left(fa(a))
-    case Right(b) => Right(fb(b))
-  }
+  def bimap[C, D](fa: A => C, fb: B => D): Either[C, D] =
+    eab match {
+      case Left(a)  => Left(fa(a))
+      case Right(b) => Right(fb(b))
+    }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def map[C](f: B => C): Either[A, C] = eab match {
-    case l @ Left(_) => EitherUtil.rightCast(l)
-    case Right(b)    => Right(f(b))
-  }
+  private[syntax] def map[C](f: B => C): Either[A, C] =
+    eab match {
+      case l @ Left(_) => EitherUtil.rightCast(l)
+      case Right(b)    => Right(f(b))
+    }
 
   def map2Eval[AA >: A, C, Z](fc: Eval[Either[AA, C]])(f: (B, C) => Z): Eval[Either[AA, Z]] =
     eab match {
@@ -147,76 +165,86 @@ final class EitherOps[A, B](private val eab: Either[A, B]) extends AnyVal {
       case Right(b)    => fc.map(_.map(f(b, _)))
     }
 
-  def leftMap[C](f: A => C): Either[C, B] = eab match {
-    case Left(a)      => Left(f(a))
-    case r @ Right(_) => EitherUtil.leftCast(r)
-  }
+  def leftMap[C](f: A => C): Either[C, B] =
+    eab match {
+      case Left(a)      => Left(f(a))
+      case r @ Right(_) => EitherUtil.leftCast(r)
+    }
 
   @deprecated("Included in the standard library", "2.1.0-RC1")
-  private[syntax] def flatMap[AA >: A, D](f: B => Either[AA, D]): Either[AA, D] = eab match {
-    case l @ Left(_) => EitherUtil.rightCast(l)
-    case Right(b)    => f(b)
-  }
+  private[syntax] def flatMap[AA >: A, D](f: B => Either[AA, D]): Either[AA, D] =
+    eab match {
+      case l @ Left(_) => EitherUtil.rightCast(l)
+      case Right(b)    => f(b)
+    }
 
-  def leftFlatMap[C, BB >: B](f: A => Either[C, BB]): Either[C, BB] = eab match {
-    case Left(a)      => f(a)
-    case r @ Right(_) => EitherUtil.leftCast(r)
-  }
+  def leftFlatMap[C, BB >: B](f: A => Either[C, BB]): Either[C, BB] =
+    eab match {
+      case Left(a)      => f(a)
+      case r @ Right(_) => EitherUtil.leftCast(r)
+    }
 
-  def compare[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: Order[AA], BB: Order[BB]): Int = eab match {
-    case Left(a1) =>
-      that match {
-        case Left(a2) => AA.compare(a1, a2)
-        case Right(_) => -1
-      }
-    case Right(b1) =>
-      that match {
-        case Left(_)   => 1
-        case Right(b2) => BB.compare(b1, b2)
-      }
-  }
+  def compare[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: Order[AA], BB: Order[BB]): Int =
+    eab match {
+      case Left(a1) =>
+        that match {
+          case Left(a2) => AA.compare(a1, a2)
+          case Right(_) => -1
+        }
+      case Right(b1) =>
+        that match {
+          case Left(_)   => 1
+          case Right(b2) => BB.compare(b1, b2)
+        }
+    }
 
-  def partialCompare[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: PartialOrder[AA],
-                                                             BB: PartialOrder[BB]): Double = eab match {
-    case Left(a1) =>
-      that match {
-        case Left(a2) => AA.partialCompare(a1, a2)
-        case Right(_) => -1
-      }
-    case Right(b1) =>
-      that match {
-        case Left(_)   => 1
-        case Right(b2) => BB.partialCompare(b1, b2)
-      }
-  }
+  def partialCompare[AA >: A, BB >: B](
+    that: Either[AA, BB]
+  )(implicit AA: PartialOrder[AA], BB: PartialOrder[BB]): Double =
+    eab match {
+      case Left(a1) =>
+        that match {
+          case Left(a2) => AA.partialCompare(a1, a2)
+          case Right(_) => -1
+        }
+      case Right(b1) =>
+        that match {
+          case Left(_)   => 1
+          case Right(b2) => BB.partialCompare(b1, b2)
+        }
+    }
 
-  def ===[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: Eq[AA], BB: Eq[BB]): Boolean = eab match {
-    case Left(a1) =>
-      that match {
-        case Left(a2) => AA.eqv(a1, a2)
-        case Right(_) => false
-      }
-    case Right(b1) =>
-      that match {
-        case Left(_)   => false
-        case Right(b2) => BB.eqv(b1, b2)
-      }
-  }
+  def ===[AA >: A, BB >: B](that: Either[AA, BB])(implicit AA: Eq[AA], BB: Eq[BB]): Boolean =
+    eab match {
+      case Left(a1) =>
+        that match {
+          case Left(a2) => AA.eqv(a1, a2)
+          case Right(_) => false
+        }
+      case Right(b1) =>
+        that match {
+          case Left(_)   => false
+          case Right(b2) => BB.eqv(b1, b2)
+        }
+    }
 
-  def traverse[F[_], AA >: A, D](f: B => F[D])(implicit F: Applicative[F]): F[Either[AA, D]] = eab match {
-    case l @ Left(_) => F.pure(EitherUtil.rightCast(l))
-    case Right(b)    => F.map(f(b))(Right(_))
-  }
+  def traverse[F[_], AA >: A, D](f: B => F[D])(implicit F: Applicative[F]): F[Either[AA, D]] =
+    eab match {
+      case l @ Left(_) => F.pure(EitherUtil.rightCast(l))
+      case Right(b)    => F.map(f(b))(Right(_))
+    }
 
-  def foldLeft[C](c: C)(f: (C, B) => C): C = eab match {
-    case Left(_)  => c
-    case Right(b) => f(c, b)
-  }
+  def foldLeft[C](c: C)(f: (C, B) => C): C =
+    eab match {
+      case Left(_)  => c
+      case Right(b) => f(c, b)
+    }
 
-  def foldRight[C](lc: Eval[C])(f: (B, Eval[C]) => Eval[C]): Eval[C] = eab match {
-    case Left(_)  => lc
-    case Right(b) => f(b, lc)
-  }
+  def foldRight[C](lc: Eval[C])(f: (B, Eval[C]) => Eval[C]): Eval[C] =
+    eab match {
+      case Left(_)  => lc
+      case Right(b) => f(b, lc)
+    }
 
   /**
    * Combine with another `Either` value.
@@ -250,19 +278,21 @@ final class EitherOps[A, B](private val eab: Either[A, B]) extends AnyVal {
    * res3: Either[String, Int] = Right(7)
    * }}}
    */
-  final def combine[AA >: A, BB >: B](that: Either[AA, BB])(implicit BB: Semigroup[BB]): Either[AA, BB] = eab match {
-    case left @ Left(_) => left
-    case Right(b1) =>
-      that match {
-        case left @ Left(_) => left
-        case Right(b2)      => Right(BB.combine(b1, b2))
-      }
-  }
+  final def combine[AA >: A, BB >: B](that: Either[AA, BB])(implicit BB: Semigroup[BB]): Either[AA, BB] =
+    eab match {
+      case left @ Left(_) => left
+      case Right(b1) =>
+        that match {
+          case left @ Left(_) => left
+          case Right(b2)      => Right(BB.combine(b1, b2))
+        }
+    }
 
-  def show[AA >: A, BB >: B](implicit AA: Show[AA], BB: Show[BB]): String = eab match {
-    case Left(a)  => s"Left(${AA.show(a)})"
-    case Right(b) => s"Right(${BB.show(b)})"
-  }
+  def show[AA >: A, BB >: B](implicit AA: Show[AA], BB: Show[BB]): String =
+    eab match {
+      case Left(a)  => s"Left(${AA.show(a)})"
+      case Right(b) => s"Right(${BB.show(b)})"
+    }
 
   def ap[AA >: A, BB >: B, C](that: Either[AA, BB => C]): Either[AA, C] = that.flatMap(eab.map)
 
@@ -353,10 +383,11 @@ final class EitherObjectOps(private val either: Either.type) extends AnyVal { //
    * Converts an `Option[B]` to an `Either[A, B]`, where the provided `ifNone` values is returned on
    * the left of the `Either` when the specified `Option` is `None`.
    */
-  def fromOption[A, B](o: Option[B], ifNone: => A): Either[A, B] = o match {
-    case None    => left[A, B](ifNone)
-    case Some(a) => right(a)
-  }
+  def fromOption[A, B](o: Option[B], ifNone: => A): Either[A, B] =
+    o match {
+      case None    => left[A, B](ifNone)
+      case Some(a) => right(a)
+    }
 
   /** Cached value of `Right(())` to avoid allocations for a common case. */
   def unit[A]: Either[A, Unit] = EitherUtil.unit
@@ -447,10 +478,11 @@ final private[syntax] class EitherOpsBinCompat0[A, B](private val value: Either[
 
   /** Returns a [[cats.data.ValidatedNec]] representation of this disjunction with the `Left` value
    * as a single element on the `Invalid` side of the [[cats.data.NonEmptyList]]. */
-  def toValidatedNec: ValidatedNec[A, B] = value match {
-    case Left(a)  => Validated.invalidNec(a)
-    case Right(b) => Validated.valid(b)
-  }
+  def toValidatedNec: ValidatedNec[A, B] =
+    value match {
+      case Left(a)  => Validated.invalidNec(a)
+      case Right(b) => Validated.valid(b)
+    }
 }
 
 /** Convenience methods to use `Either` syntax inside `Either` syntax definitions. */
diff --git a/core/src/main/scala/cats/syntax/foldable.scala b/core/src/main/scala/cats/syntax/foldable.scala
index 729f3f100..87b8a204b 100644
--- a/core/src/main/scala/cats/syntax/foldable.scala
+++ b/core/src/main/scala/cats/syntax/foldable.scala
@@ -289,8 +289,9 @@ final class FoldableOps0[F[_], A](private val fa: F[A]) extends AnyVal {
 final private[syntax] class FoldableOps1[F[_]](private val F: Foldable[F]) extends AnyVal {
 
   @deprecated("Use partitionBifold on Foldable", "2.1.0-RC1")
-  def partitionBifold[H[_, _], A, B, C](fa: F[A])(f: A => H[B, C])(implicit A: Alternative[F],
-                                                                   H: Bifoldable[H]): (F[B], F[C]) =
+  def partitionBifold[H[_, _], A, B, C](
+    fa: F[A]
+  )(f: A => H[B, C])(implicit A: Alternative[F], H: Bifoldable[H]): (F[B], F[C]) =
     F.partitionBifold[H, A, B, C](fa)(f)
 
   @deprecated("Use partitionBifoldM on Foldable", "2.1.0-RC1")
@@ -300,7 +301,8 @@ final private[syntax] class FoldableOps1[F[_]](private val F: Foldable[F]) exten
     F.partitionBifoldM[G, H, A, B, C](fa)(f)
 
   @deprecated("Use partitionEitherM on Foldable", "2.1.0-RC1")
-  def partitionEitherM[G[_], A, B, C](fa: F[A])(f: A => G[Either[B, C]])(implicit A: Alternative[F],
-                                                                         M: Monad[G]): G[(F[B], F[C])] =
+  def partitionEitherM[G[_], A, B, C](
+    fa: F[A]
+  )(f: A => G[Either[B, C]])(implicit A: Alternative[F], M: Monad[G]): G[(F[B], F[C])] =
     F.partitionEitherM[G, A, B, C](fa)(f)
 }
diff --git a/core/src/main/scala/cats/syntax/parallel.scala b/core/src/main/scala/cats/syntax/parallel.scala
index e7406fe06..499c101b1 100644
--- a/core/src/main/scala/cats/syntax/parallel.scala
+++ b/core/src/main/scala/cats/syntax/parallel.scala
@@ -128,9 +128,11 @@ final class ParallelFlatSequenceOps[T[_], M[_], A](private val tmta: T[M[T[A]]])
 }
 
 final class ParallelUnorderedSequenceOps[T[_], M[_], A](private val tmta: T[M[A]]) extends AnyVal {
-  def parUnorderedSequence[F[_]](implicit P: Parallel.Aux[M, F],
-                                 F: CommutativeApplicative[F],
-                                 Tutraverse: UnorderedTraverse[T]): M[T[A]] =
+  def parUnorderedSequence[F[_]](implicit
+    P: Parallel.Aux[M, F],
+    F: CommutativeApplicative[F],
+    Tutraverse: UnorderedTraverse[T]
+  ): M[T[A]] =
     Parallel.parUnorderedSequence(tmta)
 }
 
@@ -142,18 +144,22 @@ final class ParallelUnorderedTraverseOps[T[_], A](private val ta: T[A]) extends
 
   def parUnorderedFlatTraverse[M[_], F[_], B](
     f: A => M[T[B]]
-  )(implicit P: Parallel.Aux[M, F],
+  )(implicit
+    P: Parallel.Aux[M, F],
     F: CommutativeApplicative[F],
     Tflatmap: FlatMap[T],
-    Tutraverse: UnorderedTraverse[T]): M[T[B]] =
+    Tutraverse: UnorderedTraverse[T]
+  ): M[T[B]] =
     Parallel.parUnorderedFlatTraverse(ta)(f)
 }
 
 final class ParallelUnorderedFlatSequenceOps[T[_], M[_], A](private val tmta: T[M[T[A]]]) extends AnyVal {
-  def parUnorderedFlatSequence[F[_]](implicit P: Parallel.Aux[M, F],
-                                     Tflatmap: FlatMap[T],
-                                     F: CommutativeApplicative[F],
-                                     Tutraverse: UnorderedTraverse[T]): M[T[A]] =
+  def parUnorderedFlatSequence[F[_]](implicit
+    P: Parallel.Aux[M, F],
+    Tflatmap: FlatMap[T],
+    F: CommutativeApplicative[F],
+    Tutraverse: UnorderedTraverse[T]
+  ): M[T[A]] =
     Parallel.parUnorderedFlatSequence(tmta)
 }
 
diff --git a/free/src/main/scala/cats/free/Cofree.scala b/free/src/main/scala/cats/free/Cofree.scala
index b2e9e95e4..c8e814551 100644
--- a/free/src/main/scala/cats/free/Cofree.scala
+++ b/free/src/main/scala/cats/free/Cofree.scala
@@ -71,10 +71,11 @@ object Cofree extends CofreeInstances {
   def anaEval[F[_], A, B](a: A)(coalg: A => Eval[F[A]], f: A => B)(implicit F: Functor[F]): Cofree[F, B] =
     Cofree[F, B](f(a), mapSemilazy(coalg(a))(fa => F.map(fa)(anaEval(_)(coalg, f))))
 
-  private def mapSemilazy[A, B](fa: Eval[A])(f: A => B): Eval[B] = fa match {
-    case Now(a) => Now(f(a))
-    case other  => other.map(f)
-  }
+  private def mapSemilazy[A, B](fa: Eval[A])(f: A => B): Eval[B] =
+    fa match {
+      case Now(a) => Now(f(a))
+      case other  => other.map(f)
+    }
 
   /**
    * A stack-safe algebraic recursive fold out of the cofree comonad.
@@ -114,9 +115,10 @@ sealed abstract private[free] class CofreeInstances1 extends CofreeInstances2 {
 }
 
 sealed abstract private[free] class CofreeInstances extends CofreeInstances1 {
-  implicit def catsFreeComonadForCofree[S[_]: Functor]: Comonad[Cofree[S, *]] = new CofreeComonad[S] {
-    def F = implicitly
-  }
+  implicit def catsFreeComonadForCofree[S[_]: Functor]: Comonad[Cofree[S, *]] =
+    new CofreeComonad[S] {
+      def F = implicitly
+    }
 }
 
 private trait CofreeComonad[S[_]] extends Comonad[Cofree[S, *]] {
diff --git a/free/src/main/scala/cats/free/Free.scala b/free/src/main/scala/cats/free/Free.scala
index c95f4fac3..f2e8baf7e 100644
--- a/free/src/main/scala/cats/free/Free.scala
+++ b/free/src/main/scala/cats/free/Free.scala
@@ -48,26 +48,28 @@ sealed abstract class Free[S[_], A] extends Product with Serializable {
 
   /** Takes one evaluation step in the Free monad, re-associating left-nested binds in the process. */
   @tailrec
-  final def step: Free[S, A] = this match {
-    case FlatMapped(FlatMapped(c, f), g) => c.flatMap(cc => f(cc).flatMap(g)).step
-    case FlatMapped(Pure(a), f)          => f(a).step
-    case x                               => x
-  }
+  final def step: Free[S, A] =
+    this match {
+      case FlatMapped(FlatMapped(c, f), g) => c.flatMap(cc => f(cc).flatMap(g)).step
+      case FlatMapped(Pure(a), f)          => f(a).step
+      case x                               => x
+    }
 
   /**
    * Evaluate a single layer of the free monad.
    */
   @tailrec
-  final def resume(implicit S: Functor[S]): Either[S[Free[S, A]], A] = this match {
-    case Pure(a)    => Right(a)
-    case Suspend(t) => Left(S.map(t)(Pure(_)))
-    case FlatMapped(c, f) =>
-      c match {
-        case Pure(a)          => f(a).resume
-        case Suspend(t)       => Left(S.map(t)(f))
-        case FlatMapped(d, g) => d.flatMap(dd => g(dd).flatMap(f)).resume
-      }
-  }
+  final def resume(implicit S: Functor[S]): Either[S[Free[S, A]], A] =
+    this match {
+      case Pure(a)    => Right(a)
+      case Suspend(t) => Left(S.map(t)(Pure(_)))
+      case FlatMapped(c, f) =>
+        c match {
+          case Pure(a)          => f(a).resume
+          case Suspend(t)       => Left(S.map(t)(f))
+          case FlatMapped(d, g) => d.flatMap(dd => g(dd).flatMap(f)).resume
+        }
+    }
 
   /**
    * A combination of step and fold. May be used to define interpreters with custom
@@ -77,12 +79,13 @@ sealed abstract class Free[S[_], A] extends Product with Serializable {
     onPure: A => B,
     onSuspend: S[A] => B,
     onFlatMapped: ((S[X], X => Free[S, A]) forSome { type X }) => B
-  ): B = this.step match {
-    case Pure(a)                    => onPure(a)
-    case Suspend(a)                 => onSuspend(a)
-    case FlatMapped(Suspend(fa), f) => onFlatMapped((fa, f))
-    case _                          => sys.error("FlatMapped should be right associative after step")
-  }
+  ): B =
+    this.step match {
+      case Pure(a)                    => onPure(a)
+      case Suspend(a)                 => onSuspend(a)
+      case FlatMapped(Suspend(fa), f) => onFlatMapped((fa, f))
+      case _                          => sys.error("FlatMapped should be right associative after step")
+    }
 
   /**
    * Run to completion, using a function that extracts the resumption
@@ -356,16 +359,14 @@ sealed abstract private[free] class FreeInstances extends FreeInstances1 {
 
 sealed abstract private[free] class FreeInstances1 {
 
-  implicit def catsFreeFoldableForFree[F[_]](
-    implicit
+  implicit def catsFreeFoldableForFree[F[_]](implicit
     foldableF: Foldable[F]
   ): Foldable[Free[F, *]] =
     new FreeFoldable[F] {
       val F = foldableF
     }
 
-  implicit def catsFreeTraverseForFree[F[_]](
-    implicit
+  implicit def catsFreeTraverseForFree[F[_]](implicit
     traversableF: Traverse[F]
   ): Traverse[Free[F, *]] =
     new FreeTraverse[F] {
diff --git a/free/src/main/scala/cats/free/FreeT.scala b/free/src/main/scala/cats/free/FreeT.scala
index 8a9e9e88e..5e46381ec 100644
--- a/free/src/main/scala/cats/free/FreeT.scala
+++ b/free/src/main/scala/cats/free/FreeT.scala
@@ -236,8 +236,8 @@ sealed abstract private[free] class FreeTInstances extends FreeTInstances0 {
 
   // retained for binary compatibility. its results are incorrect though and it would fail the laws if we generated things of the form pure(()).flatMap(_ => fa)
   @deprecated("does not handle errors beyond the head suspension; use catsFreeMonadErrorForFreeT2", "2.1.0")
-  def catsFreeMonadErrorForFreeT[S[_], M[_], E](
-    implicit E: MonadError[M, E]
+  def catsFreeMonadErrorForFreeT[S[_], M[_], E](implicit
+    E: MonadError[M, E]
   ): MonadError[FreeT[S, M, *], E] =
     new MonadError[FreeT[S, M, *], E] with FreeTMonad[S, M] {
       override def M = E
@@ -254,8 +254,10 @@ sealed abstract private[free] class FreeTInstances extends FreeTInstances0 {
         FreeT.pure[S, M, Unit](()).flatMap(_ => fa)
     }
 
-  implicit def catsFreeMonadErrorForFreeT2[S[_], M[_], E](implicit E: MonadError[M, E],
-                                                          S: Functor[S]): MonadError[FreeT[S, M, *], E] =
+  implicit def catsFreeMonadErrorForFreeT2[S[_], M[_], E](implicit
+    E: MonadError[M, E],
+    S: Functor[S]
+  ): MonadError[FreeT[S, M, *], E] =
     new MonadError[FreeT[S, M, *], E] with FreeTMonad[S, M] {
       override def M = E
 
diff --git a/free/src/test/scala/cats/free/CofreeSuite.scala b/free/src/test/scala/cats/free/CofreeSuite.scala
index 909cdcca7..1e7942335 100644
--- a/free/src/test/scala/cats/free/CofreeSuite.scala
+++ b/free/src/test/scala/cats/free/CofreeSuite.scala
@@ -38,7 +38,8 @@ class CofreeSuite extends CatsSuite {
   test("Cofree.ana") {
     val anaHundred: CofreeNel[Int] =
       Cofree.ana[Option, List[Int], Int](List.tabulate(101)(identity))(l => if (l.tail.isEmpty) None else Some(l.tail),
-                                                                       _.head)
+                                                                       _.head
+      )
     val nelUnfoldedHundred: NonEmptyList[Int] = NonEmptyList.fromListUnsafe(List.tabulate(101)(identity))
     cofNelToNel(anaHundred) should ===(nelUnfoldedHundred)
   }
@@ -153,17 +154,18 @@ sealed trait CofreeSuiteInstances {
   type CofreeNel[A] = Cofree[Option, A]
   type CofreeRoseTree[A] = Cofree[List, A]
 
-  implicit def cofNelEq[A](implicit e: Eq[A]): Eq[CofreeNel[A]] = new Eq[CofreeNel[A]] {
-    override def eqv(a: CofreeNel[A], b: CofreeNel[A]): Boolean = {
-      def tr(a: CofreeNel[A], b: CofreeNel[A]): Boolean =
-        (a.tailForced, b.tailForced) match {
-          case (Some(at), Some(bt)) if e.eqv(a.head, b.head) => tr(at, bt)
-          case (None, None) if e.eqv(a.head, b.head)         => true
-          case _                                             => false
-        }
-      tr(a, b)
+  implicit def cofNelEq[A](implicit e: Eq[A]): Eq[CofreeNel[A]] =
+    new Eq[CofreeNel[A]] {
+      override def eqv(a: CofreeNel[A], b: CofreeNel[A]): Boolean = {
+        def tr(a: CofreeNel[A], b: CofreeNel[A]): Boolean =
+          (a.tailForced, b.tailForced) match {
+            case (Some(at), Some(bt)) if e.eqv(a.head, b.head) => tr(at, bt)
+            case (None, None) if e.eqv(a.head, b.head)         => true
+            case _                                             => false
+          }
+        tr(a, b)
+      }
     }
-  }
 
   implicit def CofreeOptionCogen[A: Cogen]: Cogen[CofreeNel[A]] =
     implicitly[Cogen[List[A]]].contramap[CofreeNel[A]](cofNelToNel(_).toList)
diff --git a/free/src/test/scala/cats/free/ContravariantCoyonedaSuite.scala b/free/src/test/scala/cats/free/ContravariantCoyonedaSuite.scala
index ba8327da3..dceb68228 100644
--- a/free/src/test/scala/cats/free/ContravariantCoyonedaSuite.scala
+++ b/free/src/test/scala/cats/free/ContravariantCoyonedaSuite.scala
@@ -11,8 +11,8 @@ import org.scalacheck.{Arbitrary}
 class ContravariantCoyonedaSuite extends CatsSuite {
 
   // If we can generate functions we can generate an interesting ContravariantCoyoneda.
-  implicit def contravariantCoyonedaArbitrary[F[_], A, T](
-    implicit F: Arbitrary[A => T]
+  implicit def contravariantCoyonedaArbitrary[F[_], A, T](implicit
+    F: Arbitrary[A => T]
   ): Arbitrary[ContravariantCoyoneda[* => T, A]] =
     Arbitrary(F.arbitrary.map(ContravariantCoyoneda.lift[* => T, A](_)))
 
@@ -31,9 +31,11 @@ class ContravariantCoyonedaSuite extends CatsSuite {
     ContravariantCoyoneda.catsFreeContravariantFunctorForContravariantCoyoneda[* => String]
 
   checkAll("ContravariantCoyoneda[* => String, Int]",
-           ContravariantTests[ContravariantCoyoneda[* => String, *]].contravariant[Int, Int, Int])
+           ContravariantTests[ContravariantCoyoneda[* => String, *]].contravariant[Int, Int, Int]
+  )
   checkAll("Contravariant[ContravariantCoyoneda[Option, *]]",
-           SerializableTests.serializable(Contravariant[ContravariantCoyoneda[Option, *]]))
+           SerializableTests.serializable(Contravariant[ContravariantCoyoneda[Option, *]])
+  )
 
   test("mapK and run is same as applying natural trans") {
     forAll { (b: Boolean) =>
diff --git a/free/src/test/scala/cats/free/FreeApplicativeSuite.scala b/free/src/test/scala/cats/free/FreeApplicativeSuite.scala
index f5b0cbb4f..e61e9fe75 100644
--- a/free/src/test/scala/cats/free/FreeApplicativeSuite.scala
+++ b/free/src/test/scala/cats/free/FreeApplicativeSuite.scala
@@ -18,7 +18,8 @@ class FreeApplicativeSuite extends CatsSuite {
 
   checkAll("FreeApplicative[Option, *]", ApplicativeTests[FreeApplicative[Option, *]].applicative[Int, Int, Int])
   checkAll("Applicative[FreeApplicative[Option, *]]",
-           SerializableTests.serializable(Applicative[FreeApplicative[Option, *]]))
+           SerializableTests.serializable(Applicative[FreeApplicative[Option, *]])
+  )
 
   test("toString is stack-safe") {
     val r = FreeApplicative.pure[List, Int](333)
@@ -158,9 +159,11 @@ object FreeApplicativeSuite {
     else Gen.oneOf(noFlatMapped, withFlatMapped)
   }
 
-  implicit def freeArbitrary[F[_], A](implicit F: Arbitrary[F[A]],
-                                      FF: Arbitrary[(A, A) => A],
-                                      A: Arbitrary[A]): Arbitrary[FreeApplicative[F, A]] =
+  implicit def freeArbitrary[F[_], A](implicit
+    F: Arbitrary[F[A]],
+    FF: Arbitrary[(A, A) => A],
+    A: Arbitrary[A]
+  ): Arbitrary[FreeApplicative[F, A]] =
     Arbitrary(freeGen[F, A](4))
 
   implicit def freeApplicativeEq[S[_]: Applicative, A](implicit SA: Eq[S[A]]): Eq[FreeApplicative[S, A]] =
@@ -170,9 +173,13 @@ object FreeApplicativeSuite {
     }
 
   implicit def catsLawsArbitraryForListNatTrans: Arbitrary[List ~> List] =
-    Arbitrary(Gen.oneOf(FunctionK.id[List], new (List ~> List) {
-      def apply[A](fa: List[A]): List[A] =
-        fa ++ fa
-    }))
+    Arbitrary(
+      Gen.oneOf(FunctionK.id[List],
+                new (List ~> List) {
+                  def apply[A](fa: List[A]): List[A] =
+                    fa ++ fa
+                }
+      )
+    )
 
 }
diff --git a/free/src/test/scala/cats/free/FreeInvariantMonoidalSuite.scala b/free/src/test/scala/cats/free/FreeInvariantMonoidalSuite.scala
index f467cf87f..b1150e858 100644
--- a/free/src/test/scala/cats/free/FreeInvariantMonoidalSuite.scala
+++ b/free/src/test/scala/cats/free/FreeInvariantMonoidalSuite.scala
@@ -14,14 +14,16 @@ import cats.tests.CatsSuite
 import org.scalacheck.{Arbitrary, Gen}
 
 class FreeInvariantMonoidalSuite extends CatsSuite {
-  implicit def freeInvariantMonoidalArbitrary[F[_], A](implicit F: Arbitrary[F[A]],
-                                                       A: Arbitrary[A]): Arbitrary[FreeInvariantMonoidal[F, A]] =
+  implicit def freeInvariantMonoidalArbitrary[F[_], A](implicit
+    F: Arbitrary[F[A]],
+    A: Arbitrary[A]
+  ): Arbitrary[FreeInvariantMonoidal[F, A]] =
     Arbitrary(
       Gen.oneOf(A.arbitrary.map(FreeInvariantMonoidal.pure[F, A]), F.arbitrary.map(FreeInvariantMonoidal.lift[F, A]))
     )
 
-  implicit def freeInvariantMonoidalEq[S[_]: InvariantMonoidal, A](
-    implicit SA: Eq[S[A]]
+  implicit def freeInvariantMonoidalEq[S[_]: InvariantMonoidal, A](implicit
+    SA: Eq[S[A]]
   ): Eq[FreeInvariantMonoidal[S, A]] =
     new Eq[FreeInvariantMonoidal[S, A]] {
       def eqv(a: FreeInvariantMonoidal[S, A], b: FreeInvariantMonoidal[S, A]): Boolean = {
@@ -34,9 +36,11 @@ class FreeInvariantMonoidalSuite extends CatsSuite {
     Isomorphisms.invariant[FreeInvariantMonoidal[BinCodec, *]]
 
   checkAll("FreeInvariantMonoidal[BinCodec, *]",
-           InvariantMonoidalTests[FreeInvariantMonoidal[BinCodec, *]].invariantMonoidal[MiniInt, Boolean, Boolean])
+           InvariantMonoidalTests[FreeInvariantMonoidal[BinCodec, *]].invariantMonoidal[MiniInt, Boolean, Boolean]
+  )
   checkAll("InvariantMonoidal[FreeInvariantMonoidal[BinCodec, *]]",
-           SerializableTests.serializable(InvariantMonoidal[FreeInvariantMonoidal[BinCodec, *]]))
+           SerializableTests.serializable(InvariantMonoidal[FreeInvariantMonoidal[BinCodec, *]])
+  )
 
   test("FreeInvariantMonoidal#fold") {
     forAll { (i1: BinCodec[MiniInt]) =>
diff --git a/free/src/test/scala/cats/free/FreeSuite.scala b/free/src/test/scala/cats/free/FreeSuite.scala
index ea95dccb6..3a4a36119 100644
--- a/free/src/test/scala/cats/free/FreeSuite.scala
+++ b/free/src/test/scala/cats/free/FreeSuite.scala
@@ -99,11 +99,13 @@ class FreeSuite extends CatsSuite {
         z <- if (j < 10000) a(j) else Free.pure[FTestApi, Int](j)
       } yield z
 
-    def runner: FunctionK[FTestApi, Id] = new FunctionK[FTestApi, Id] {
-      def apply[A](a: FTestApi[A]): A = a match {
-        case TB(i) => i + 1
+    def runner: FunctionK[FTestApi, Id] =
+      new FunctionK[FTestApi, Id] {
+        def apply[A](a: FTestApi[A]): A =
+          a match {
+            case TB(i) => i + 1
+          }
       }
-    }
   }
 
   test("foldMap is stack safe") {
@@ -139,13 +141,16 @@ class FreeSuite extends CatsSuite {
   object Test1Algebra {
     implicit def test1AlgebraAFunctor: Functor[Test1Algebra] =
       new Functor[Test1Algebra] {
-        def map[A, B](a: Test1Algebra[A])(f: A => B): Test1Algebra[B] = a match {
-          case Test1(k, h) => Test1(k, x => f(h(x)))
-        }
+        def map[A, B](a: Test1Algebra[A])(f: A => B): Test1Algebra[B] =
+          a match {
+            case Test1(k, h) => Test1(k, x => f(h(x)))
+          }
       }
 
-    implicit def test1AlgebraArbitrary[A](implicit seqArb: Arbitrary[Int],
-                                          intAArb: Arbitrary[Int => A]): Arbitrary[Test1Algebra[A]] =
+    implicit def test1AlgebraArbitrary[A](implicit
+      seqArb: Arbitrary[Int],
+      intAArb: Arbitrary[Int => A]
+    ): Arbitrary[Test1Algebra[A]] =
       Arbitrary(for { s <- seqArb.arbitrary; f <- intAArb.arbitrary } yield Test1(s, f))
   }
 
@@ -158,28 +163,33 @@ class FreeSuite extends CatsSuite {
   object Test2Algebra {
     implicit def test2AlgebraAFunctor: Functor[Test2Algebra] =
       new Functor[Test2Algebra] {
-        def map[A, B](a: Test2Algebra[A])(f: A => B): Test2Algebra[B] = a match {
-          case Test2(k, h) => Test2(k, x => f(h(x)))
-        }
+        def map[A, B](a: Test2Algebra[A])(f: A => B): Test2Algebra[B] =
+          a match {
+            case Test2(k, h) => Test2(k, x => f(h(x)))
+          }
       }
 
-    implicit def test2AlgebraArbitrary[A](implicit seqArb: Arbitrary[Int],
-                                          intAArb: Arbitrary[Int => A]): Arbitrary[Test2Algebra[A]] =
+    implicit def test2AlgebraArbitrary[A](implicit
+      seqArb: Arbitrary[Int],
+      intAArb: Arbitrary[Int => A]
+    ): Arbitrary[Test2Algebra[A]] =
       Arbitrary(for { s <- seqArb.arbitrary; f <- intAArb.arbitrary } yield Test2(s, f))
   }
 
   type T[A] = EitherK[Test1Algebra, Test2Algebra, A]
 
   object Test1Interpreter extends FunctionK[Test1Algebra, Id] {
-    override def apply[A](fa: Test1Algebra[A]): Id[A] = fa match {
-      case Test1(k, h) => h(k)
-    }
+    override def apply[A](fa: Test1Algebra[A]): Id[A] =
+      fa match {
+        case Test1(k, h) => h(k)
+      }
   }
 
   object Test2Interpreter extends FunctionK[Test2Algebra, Id] {
-    override def apply[A](fa: Test2Algebra[A]): Id[A] = fa match {
-      case Test2(k, h) => h(k)
-    }
+    override def apply[A](fa: Test2Algebra[A]): Id[A] =
+      fa match {
+        case Test2(k, h) => h(k)
+      }
   }
 
   val eitherKInterpreter: FunctionK[T, Id] = Test1Interpreter.or(Test2Interpreter)
@@ -209,10 +219,9 @@ class FreeSuite extends CatsSuite {
   val x: Free[T, Int] = Free.inject[Test1Algebra, T](Test1(1, identity))
 
   test(".injectRoll") {
-    def distr[F[_], A](f: Free[F, A])(implicit
-                                      F: Functor[F],
-                                      I0: Test1Algebra :<: F,
-                                      I1: Test2Algebra :<: F): Option[Free[F, A]] =
+    def distr[F[_], A](
+      f: Free[F, A]
+    )(implicit F: Functor[F], I0: Test1Algebra :<: F, I1: Test2Algebra :<: F): Option[Free[F, A]] =
       for {
         Test1(x, h) <- Free.match_[F, Test1Algebra, A](f)
         Test2(y, k) <- Free.match_[F, Test2Algebra, A](h(x))
diff --git a/free/src/test/scala/cats/free/FreeTSuite.scala b/free/src/test/scala/cats/free/FreeTSuite.scala
index 39a523d0f..8a477005d 100644
--- a/free/src/test/scala/cats/free/FreeTSuite.scala
+++ b/free/src/test/scala/cats/free/FreeTSuite.scala
@@ -42,7 +42,8 @@ class FreeTSuite extends CatsSuite {
     implicit val eqEitherTFA: Eq[EitherT[FreeTOption, Unit, Int]] = EitherT.catsDataEqForEitherT[FreeTOption, Unit, Int]
     checkAll("FreeT[Option, Option, Int]", MonadErrorTests[FreeTOption, Unit].monadError[Int, Int, Int])
     checkAll("MonadError[FreeT[Option, Option, *], Unit]",
-             SerializableTests.serializable(MonadError[FreeTOption, Unit]))
+             SerializableTests.serializable(MonadError[FreeTOption, Unit])
+    )
   }
 
   checkAll("FreeT[Option, Option, Int", DeferTests[FreeTOption].defer[Int])
@@ -136,13 +137,16 @@ class FreeTSuite extends CatsSuite {
   object Test1Algebra {
     implicit def test1AlgebraAFunctor: Functor[Test1Algebra] =
       new Functor[Test1Algebra] {
-        def map[A, B](a: Test1Algebra[A])(f: A => B): Test1Algebra[B] = a match {
-          case Test1(k, h) => Test1(k, x => f(h(x)))
-        }
+        def map[A, B](a: Test1Algebra[A])(f: A => B): Test1Algebra[B] =
+          a match {
+            case Test1(k, h) => Test1(k, x => f(h(x)))
+          }
       }
 
-    implicit def test1AlgebraArbitrary[A](implicit seqArb: Arbitrary[Int],
-                                          intAArb: Arbitrary[Int => A]): Arbitrary[Test1Algebra[A]] =
+    implicit def test1AlgebraArbitrary[A](implicit
+      seqArb: Arbitrary[Int],
+      intAArb: Arbitrary[Int => A]
+    ): Arbitrary[Test1Algebra[A]] =
       Arbitrary(for { s <- seqArb.arbitrary; f <- intAArb.arbitrary } yield Test1(s, f))
   }
 
@@ -155,28 +159,33 @@ class FreeTSuite extends CatsSuite {
   object Test2Algebra {
     implicit def test2AlgebraAFunctor: Functor[Test2Algebra] =
       new Functor[Test2Algebra] {
-        def map[A, B](a: Test2Algebra[A])(f: A => B): Test2Algebra[B] = a match {
-          case Test2(k, h) => Test2(k, x => f(h(x)))
-        }
+        def map[A, B](a: Test2Algebra[A])(f: A => B): Test2Algebra[B] =
+          a match {
+            case Test2(k, h) => Test2(k, x => f(h(x)))
+          }
       }
 
-    implicit def test2AlgebraArbitrary[A](implicit seqArb: Arbitrary[Int],
-                                          intAArb: Arbitrary[Int => A]): Arbitrary[Test2Algebra[A]] =
+    implicit def test2AlgebraArbitrary[A](implicit
+      seqArb: Arbitrary[Int],
+      intAArb: Arbitrary[Int => A]
+    ): Arbitrary[Test2Algebra[A]] =
       Arbitrary(for { s <- seqArb.arbitrary; f <- intAArb.arbitrary } yield Test2(s, f))
   }
 
   type T[A] = EitherK[Test1Algebra, Test2Algebra, A]
 
   object Test1Interpreter extends FunctionK[Test1Algebra, Id] {
-    override def apply[A](fa: Test1Algebra[A]): Id[A] = fa match {
-      case Test1(k, h) => h(k)
-    }
+    override def apply[A](fa: Test1Algebra[A]): Id[A] =
+      fa match {
+        case Test1(k, h) => h(k)
+      }
   }
 
   object Test2Interpreter extends FunctionK[Test2Algebra, Id] {
-    override def apply[A](fa: Test2Algebra[A]): Id[A] = fa match {
-      case Test2(k, h) => h(k)
-    }
+    override def apply[A](fa: Test2Algebra[A]): Id[A] =
+      fa match {
+        case Test2(k, h) => h(k)
+      }
   }
 
   val eitherKInterpreter: FunctionK[T, Id] = Test1Interpreter.or(Test2Interpreter)
@@ -216,9 +225,11 @@ object FreeTSuite extends FreeTSuiteInstances {
   import Arbitrary._
   import org.scalacheck.Arbitrary
 
-  implicit def freeTArb[F[_], G[_]: Applicative, A](implicit F: Arbitrary[F[A]],
-                                                    G: Arbitrary[G[A]],
-                                                    A: Arbitrary[A]): Arbitrary[FreeT[F, G, A]] =
+  implicit def freeTArb[F[_], G[_]: Applicative, A](implicit
+    F: Arbitrary[F[A]],
+    G: Arbitrary[G[A]],
+    A: Arbitrary[A]
+  ): Arbitrary[FreeT[F, G, A]] =
     Arbitrary(freeTGen[F, G, A](4))
 
   private def freeTGen[F[_], G[_]: Applicative, A](
@@ -235,7 +246,9 @@ object FreeTSuite extends FreeTSuiteInstances {
       for {
         fDepth <- nextDepth
         freeDepth <- nextDepth
-        f <- arbFunction1[A, FreeT[F, G, A]](Arbitrary(freeTGen[F, G, A](fDepth)), Cogen[Unit].contramap(_ => ())).arbitrary
+        f <- arbFunction1[A, FreeT[F, G, A]](Arbitrary(freeTGen[F, G, A](fDepth)),
+                                             Cogen[Unit].contramap(_ => ())
+        ).arbitrary
         freeFGA <- freeTGen[F, G, A](freeDepth)
       } yield freeFGA.flatMap(f)
 
@@ -266,12 +279,14 @@ trait FreeTSuiteInstances {
     override def map[A, B](fa: JustFunctor[A])(f: A => B): JustFunctor[B] = JustFunctor(f(fa.a))
   }
 
-  implicit def freeTOptionEq[A](implicit A: Eq[A], OM: Monad[Option]): Eq[FreeTOption[A]] = new Eq[FreeTOption[A]] {
-    def eqv(a: FreeTOption[A], b: FreeTOption[A]) = Eq[Option[A]].eqv(a.runM(identity), b.runM(identity))
-  }
+  implicit def freeTOptionEq[A](implicit A: Eq[A], OM: Monad[Option]): Eq[FreeTOption[A]] =
+    new Eq[FreeTOption[A]] {
+      def eqv(a: FreeTOption[A], b: FreeTOption[A]) = Eq[Option[A]].eqv(a.runM(identity), b.runM(identity))
+    }
 
-  implicit def freeTStateEq[A](implicit A: Eq[A], SM: Monad[IntState]): Eq[FreeTState[A]] = new Eq[FreeTState[A]] {
-    def eqv(a: FreeTState[A], b: FreeTState[A]) =
-      Eq[IntState[A]].eqv(a.runM(identity)(SM, SM), b.runM(identity)(SM, SM))
-  }
+  implicit def freeTStateEq[A](implicit A: Eq[A], SM: Monad[IntState]): Eq[FreeTState[A]] =
+    new Eq[FreeTState[A]] {
+      def eqv(a: FreeTState[A], b: FreeTState[A]) =
+        Eq[IntState[A]].eqv(a.runM(identity)(SM, SM), b.runM(identity)(SM, SM))
+    }
 }
diff --git a/js/src/main/scala/cats/js/instances/future.scala b/js/src/main/scala/cats/js/instances/future.scala
index d641b4fdb..5b13b9be5 100644
--- a/js/src/main/scala/cats/js/instances/future.scala
+++ b/js/src/main/scala/cats/js/instances/future.scala
@@ -12,10 +12,11 @@ import cats.syntax.all._
 object future extends FutureInstances0
 
 object Await {
-  def result[A](f: Future[A], atMost: FiniteDuration): A = f.value match {
-    case Some(v) => v.get
-    case None    => throw new IllegalStateException()
-  }
+  def result[A](f: Future[A], atMost: FiniteDuration): A =
+    f.value match {
+      case Some(v) => v.get
+      case None    => throw new IllegalStateException()
+    }
 }
 
 sealed private[instances] trait FutureInstances0 extends FutureInstances1 {
diff --git a/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/SerializableTests.scala b/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/SerializableTests.scala
index 4be5b8a16..8f71474d2 100644
--- a/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/SerializableTests.scala
+++ b/kernel-laws/shared/src/main/scala/cats/kernel/laws/discipline/SerializableTests.scala
@@ -7,5 +7,6 @@ object SerializableTests extends Laws {
   def serializable[A](a: A): RuleSet =
     new DefaultRuleSet(name = "serializable",
                        parent = None,
-                       "can serialize and deserialize" -> SerializableLaws.serializable(a))
+                       "can serialize and deserialize" -> SerializableLaws.serializable(a)
+    )
 }
diff --git a/kernel-laws/shared/src/test/scala-2.13+/cats/kernel/laws/ScalaVersionSpecificTests.scala b/kernel-laws/shared/src/test/scala-2.13+/cats/kernel/laws/ScalaVersionSpecificTests.scala
index dc37dcc08..c9e6b3cdd 100644
--- a/kernel-laws/shared/src/test/scala-2.13+/cats/kernel/laws/ScalaVersionSpecificTests.scala
+++ b/kernel-laws/shared/src/test/scala-2.13+/cats/kernel/laws/ScalaVersionSpecificTests.scala
@@ -9,7 +9,8 @@ import cats.kernel.laws.discipline.{EqTests, HashTests, MonoidTests, OrderTests,
 trait ScalaVersionSpecificTests { this: Tests =>
   checkAll("Eq[LazyList[HasEq[Int]]]", EqTests[LazyList[HasEq[Int]]].eqv)
   checkAll("PartialOrder[LazyList[HasPartialOrder[Int]]]",
-           PartialOrderTests[LazyList[HasPartialOrder[Int]]].partialOrder)
+           PartialOrderTests[LazyList[HasPartialOrder[Int]]].partialOrder
+  )
   checkAll("Order[LazyList[Int]]", OrderTests[LazyList[Int]].order)
   checkAll("Monoid[LazyList[Int]]", MonoidTests[LazyList[Int]].monoid)
   checkAll("Monoid[LazyList[Int]]", SerializableTests.serializable(Monoid[LazyList[Int]]))
diff --git a/kernel-laws/shared/src/test/scala/cats/kernel/laws/LawTests.scala b/kernel-laws/shared/src/test/scala/cats/kernel/laws/LawTests.scala
index 42a5c84ca..61f9c9867 100644
--- a/kernel-laws/shared/src/test/scala/cats/kernel/laws/LawTests.scala
+++ b/kernel-laws/shared/src/test/scala/cats/kernel/laws/LawTests.scala
@@ -163,7 +163,8 @@ class Tests extends TestsConfig with AnyFunSuiteLike with FunSuiteDiscipline wit
 
   checkAll("PartialOrder[Set[Int]]", PartialOrderTests[Set[Int]].partialOrder)
   checkAll("PartialOrder.reverse(PartialOrder[Set[Int]])",
-           PartialOrderTests(PartialOrder.reverse(PartialOrder[Set[Int]])).partialOrder)
+           PartialOrderTests(PartialOrder.reverse(PartialOrder[Set[Int]])).partialOrder
+  )
   checkAll(
     "PartialOrder.reverse(PartialOrder.reverse(PartialOrder[Set[Int]]))",
     PartialOrderTests(PartialOrder.reverse(PartialOrder.reverse(PartialOrder[Set[Int]]))).partialOrder
@@ -174,9 +175,11 @@ class Tests extends TestsConfig with AnyFunSuiteLike with FunSuiteDiscipline wit
   checkAll("PartialOrder[Stream[HasPartialOrder[Int]]]", PartialOrderTests[Stream[HasPartialOrder[Int]]].partialOrder)
   checkAll("PartialOrder[Queue[HasPartialOrder[Int]]]", PartialOrderTests[Queue[HasPartialOrder[Int]]].partialOrder)
   checkAll("Semilattice.asMeetPartialOrder[Set[Int]]",
-           PartialOrderTests(Semilattice.asMeetPartialOrder[Set[Int]]).partialOrder)
+           PartialOrderTests(Semilattice.asMeetPartialOrder[Set[Int]]).partialOrder
+  )
   checkAll("Semilattice.asJoinPartialOrder[Set[Int]]",
-           PartialOrderTests(Semilattice.asJoinPartialOrder[Set[Int]]).partialOrder)
+           PartialOrderTests(Semilattice.asJoinPartialOrder[Set[Int]]).partialOrder
+  )
 
   checkAll("Order[Unit]", OrderTests[Unit].order)
   checkAll("Order[Boolean]", OrderTests[Boolean].order)
@@ -252,9 +255,11 @@ class Tests extends TestsConfig with AnyFunSuiteLike with FunSuiteDiscipline wit
   checkAll("CommutativeMonoid[Map[String, Int]]", CommutativeMonoidTests[Map[String, Int]].commutativeMonoid)
   checkAll("CommutativeMonoid[Map[String, Int]]", SerializableTests.serializable(CommutativeMonoid[Map[String, Int]]))
   checkAll("CommutativeMonoid[SortedMap[String, Int]]",
-           CommutativeMonoidTests[SortedMap[String, Int]].commutativeMonoid)
+           CommutativeMonoidTests[SortedMap[String, Int]].commutativeMonoid
+  )
   checkAll("CommutativeMonoid[SortedMap[String, Int]]",
-           SerializableTests.serializable(CommutativeMonoid[SortedMap[String, Int]]))
+           SerializableTests.serializable(CommutativeMonoid[SortedMap[String, Int]])
+  )
 
   checkAll("BoundedSemilattice[BitSet]", BoundedSemilatticeTests[BitSet].boundedSemilattice)
   checkAll("BoundedSemilattice[BitSet]", SerializableTests.serializable(BoundedSemilattice[BitSet]))
@@ -347,27 +352,29 @@ class Tests extends TestsConfig with AnyFunSuiteLike with FunSuiteDiscipline wit
   // Comparison related
 
   // Something that can give NaN for test
-  def subsetPartialOrder[A]: PartialOrder[Set[A]] = new PartialOrder[Set[A]] {
-    def partialCompare(x: Set[A], y: Set[A]): Double =
-      if (x == y) 0.0
-      else if (x.subsetOf(y)) -1.0
-      else if (y.subsetOf(x)) 1.0
-      else Double.NaN
-  }
+  def subsetPartialOrder[A]: PartialOrder[Set[A]] =
+    new PartialOrder[Set[A]] {
+      def partialCompare(x: Set[A], y: Set[A]): Double =
+        if (x == y) 0.0
+        else if (x.subsetOf(y)) -1.0
+        else if (y.subsetOf(x)) 1.0
+        else Double.NaN
+    }
 
   checkAll("subsetPartialOrder[Int]", PartialOrderTests(subsetPartialOrder[Int]).partialOrder)
 
   {
-    implicit def subsetPartialOrdering[A]: PartialOrdering[Set[A]] = new PartialOrdering[Set[A]] {
+    implicit def subsetPartialOrdering[A]: PartialOrdering[Set[A]] =
+      new PartialOrdering[Set[A]] {
 
-      override def tryCompare(x: Set[A], y: Set[A]): Option[Int] =
-        if (x == y) Some(0)
-        else if (x.subsetOf(y)) Some(-1)
-        else if (y.subsetOf(x)) Some(1)
-        else None
+        override def tryCompare(x: Set[A], y: Set[A]): Option[Int] =
+          if (x == y) Some(0)
+          else if (x.subsetOf(y)) Some(-1)
+          else if (y.subsetOf(x)) Some(1)
+          else None
 
-      override def lteq(x: Set[A], y: Set[A]): Boolean = (x.subsetOf(y)) || (x == y)
-    }
+        override def lteq(x: Set[A], y: Set[A]): Boolean = (x.subsetOf(y)) || (x == y)
+      }
     checkAll("fromPartialOrdering[Int]", PartialOrderTests(PartialOrder.fromPartialOrdering[Set[Int]]).partialOrder)
   }
 
diff --git a/kernel/src/main/scala-2.12/cats/kernel/compat/scalaVersionSpecific.scala b/kernel/src/main/scala-2.12/cats/kernel/compat/scalaVersionSpecific.scala
index a1c8b751e..d5d827824 100644
--- a/kernel/src/main/scala-2.12/cats/kernel/compat/scalaVersionSpecific.scala
+++ b/kernel/src/main/scala-2.12/cats/kernel/compat/scalaVersionSpecific.scala
@@ -23,7 +23,8 @@ private[cats] object scalaVersionSpecific {
   }
 
   implicit class lazyZipExtension[A](private val a: A) extends AnyVal {
-    def lazyZip[El1, Repr1, El2, Repr2, T](that: T)(implicit w1: A => TraversableLike[El1, Repr1],
-                                                    w2: T => IterableLike[El2, Repr2]) = (a, that).zipped
+    def lazyZip[El1, Repr1, El2, Repr2, T](
+      that: T
+    )(implicit w1: A => TraversableLike[El1, Repr1], w2: T => IterableLike[El2, Repr2]) = (a, that).zipped
   }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Band.scala b/kernel/src/main/scala/cats/kernel/Band.scala
index 48ab98ddd..b52322cc2 100644
--- a/kernel/src/main/scala/cats/kernel/Band.scala
+++ b/kernel/src/main/scala/cats/kernel/Band.scala
@@ -22,7 +22,8 @@ object Band extends SemigroupFunctions[Band] {
   /**
    * Create a `Band` instance from the given function.
    */
-  @inline def instance[A](cmb: (A, A) => A): Band[A] = new Band[A] {
-    override def combine(x: A, y: A): A = cmb(x, y)
-  }
+  @inline def instance[A](cmb: (A, A) => A): Band[A] =
+    new Band[A] {
+      override def combine(x: A, y: A): A = cmb(x, y)
+    }
 }
diff --git a/kernel/src/main/scala/cats/kernel/BoundedSemilattice.scala b/kernel/src/main/scala/cats/kernel/BoundedSemilattice.scala
index 33211e47c..9204c5096 100644
--- a/kernel/src/main/scala/cats/kernel/BoundedSemilattice.scala
+++ b/kernel/src/main/scala/cats/kernel/BoundedSemilattice.scala
@@ -20,9 +20,10 @@ object BoundedSemilattice extends SemilatticeFunctions[BoundedSemilattice] {
   /**
    * Create a `BoundedSemilattice` instance from the given function and empty value.
    */
-  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): BoundedSemilattice[A] = new BoundedSemilattice[A] {
-    override val empty: A = emptyValue
+  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): BoundedSemilattice[A] =
+    new BoundedSemilattice[A] {
+      override val empty: A = emptyValue
 
-    override def combine(x: A, y: A): A = cmb(x, y)
-  }
+      override def combine(x: A, y: A): A = cmb(x, y)
+    }
 }
diff --git a/kernel/src/main/scala/cats/kernel/CommutativeMonoid.scala b/kernel/src/main/scala/cats/kernel/CommutativeMonoid.scala
index b03362eda..03ac60421 100644
--- a/kernel/src/main/scala/cats/kernel/CommutativeMonoid.scala
+++ b/kernel/src/main/scala/cats/kernel/CommutativeMonoid.scala
@@ -22,9 +22,10 @@ object CommutativeMonoid extends MonoidFunctions[CommutativeMonoid] {
   /**
    * Create a `CommutativeMonoid` instance from the given function and empty value.
    */
-  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): CommutativeMonoid[A] = new CommutativeMonoid[A] {
-    override val empty: A = emptyValue
+  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): CommutativeMonoid[A] =
+    new CommutativeMonoid[A] {
+      override val empty: A = emptyValue
 
-    override def combine(x: A, y: A): A = cmb(x, y)
-  }
+      override def combine(x: A, y: A): A = cmb(x, y)
+    }
 }
diff --git a/kernel/src/main/scala/cats/kernel/CommutativeSemigroup.scala b/kernel/src/main/scala/cats/kernel/CommutativeSemigroup.scala
index 9cdb22c6a..137fce87c 100644
--- a/kernel/src/main/scala/cats/kernel/CommutativeSemigroup.scala
+++ b/kernel/src/main/scala/cats/kernel/CommutativeSemigroup.scala
@@ -33,7 +33,8 @@ object CommutativeSemigroup extends SemigroupFunctions[CommutativeSemigroup] {
   /**
    * Create a `CommutativeSemigroup` instance from the given function.
    */
-  @inline def instance[A](cmb: (A, A) => A): CommutativeSemigroup[A] = new CommutativeSemigroup[A] {
-    override def combine(x: A, y: A): A = cmb(x, y)
-  }
+  @inline def instance[A](cmb: (A, A) => A): CommutativeSemigroup[A] =
+    new CommutativeSemigroup[A] {
+      override def combine(x: A, y: A): A = cmb(x, y)
+    }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Eq.scala b/kernel/src/main/scala/cats/kernel/Eq.scala
index 1b88aa6df..554ca74bd 100644
--- a/kernel/src/main/scala/cats/kernel/Eq.scala
+++ b/kernel/src/main/scala/cats/kernel/Eq.scala
@@ -41,9 +41,10 @@ trait EqToEquivConversion {
    * Implicitly derive a `scala.math.Equiv[A]` from a `Eq[A]`
    * instance.
    */
-  implicit def catsKernelEquivForEq[A](implicit ev: Eq[A]): Equiv[A] = new Equiv[A] {
-    def equiv(a: A, b: A) = ev.eqv(a, b)
-  }
+  implicit def catsKernelEquivForEq[A](implicit ev: Eq[A]): Equiv[A] =
+    new Equiv[A] {
+      def equiv(a: A, b: A) = ev.eqv(a, b)
+    }
 }
 
 @suppressUnusedImportWarningForScalaVersionSpecific
@@ -108,42 +109,45 @@ object Eq
   /**
    * Everything is the same
    */
-  def allEqual[A]: Eq[A] = new Eq[A] {
-    def eqv(x: A, y: A) = true
-  }
+  def allEqual[A]: Eq[A] =
+    new Eq[A] {
+      def eqv(x: A, y: A) = true
+    }
 
   /**
    * This is a monoid that creates an Eq that
    * checks that all equality checks pass
    */
-  def allEqualBoundedSemilattice[A]: BoundedSemilattice[Eq[A]] = new BoundedSemilattice[Eq[A]] {
-    def empty = allEqual[A]
-    def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.and(e1, e2)
-    override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
-      if (es.iterator.isEmpty) None
-      else {
-        val materialized = es.iterator.toVector
-        Some(new Eq[A] {
-          def eqv(x: A, y: A) = materialized.forall(_.eqv(x, y))
-        })
-      }
-  }
+  def allEqualBoundedSemilattice[A]: BoundedSemilattice[Eq[A]] =
+    new BoundedSemilattice[Eq[A]] {
+      def empty = allEqual[A]
+      def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.and(e1, e2)
+      override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
+        if (es.iterator.isEmpty) None
+        else {
+          val materialized = es.iterator.toVector
+          Some(new Eq[A] {
+            def eqv(x: A, y: A) = materialized.forall(_.eqv(x, y))
+          })
+        }
+    }
 
   /**
    * This is a monoid that creates an Eq that
    * checks that at least one equality check passes
    */
-  def anyEqualSemilattice[A]: Semilattice[Eq[A]] = new Semilattice[Eq[A]] {
-    def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.or(e1, e2)
-    override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
-      if (es.iterator.isEmpty) None
-      else {
-        val materialized = es.iterator.toVector
-        Some(new Eq[A] {
-          def eqv(x: A, y: A) = materialized.exists(_.eqv(x, y))
-        })
-      }
-  }
+  def anyEqualSemilattice[A]: Semilattice[Eq[A]] =
+    new Semilattice[Eq[A]] {
+      def combine(e1: Eq[A], e2: Eq[A]): Eq[A] = Eq.or(e1, e2)
+      override def combineAllOption(es: IterableOnce[Eq[A]]): Option[Eq[A]] =
+        if (es.iterator.isEmpty) None
+        else {
+          val materialized = es.iterator.toVector
+          Some(new Eq[A] {
+            def eqv(x: A, y: A) = materialized.exists(_.eqv(x, y))
+          })
+        }
+    }
 
   implicit def catsKernelInstancesForBitSet: PartialOrder[BitSet] with Hash[BitSet] =
     cats.kernel.instances.bitSet.catsKernelStdOrderForBitSet
@@ -204,11 +208,12 @@ object Eq
    */
   implicit def catsStdEqForTry[A, T](implicit A: Eq[A], T: Eq[Throwable]): Eq[Try[A]] =
     new Eq[Try[A]] {
-      def eqv(x: Try[A], y: Try[A]): Boolean = (x, y) match {
-        case (Success(a), Success(b)) => A.eqv(a, b)
-        case (Failure(a), Failure(b)) => T.eqv(a, b)
-        case _                        => false
-      }
+      def eqv(x: Try[A], y: Try[A]): Boolean =
+        (x, y) match {
+          case (Success(a), Success(b)) => A.eqv(a, b)
+          case (Failure(a), Failure(b)) => T.eqv(a, b)
+          case _                        => false
+        }
     }
 }
 
diff --git a/kernel/src/main/scala/cats/kernel/Hash.scala b/kernel/src/main/scala/cats/kernel/Hash.scala
index b833750b8..f25af8e4d 100644
--- a/kernel/src/main/scala/cats/kernel/Hash.scala
+++ b/kernel/src/main/scala/cats/kernel/Hash.scala
@@ -55,7 +55,8 @@ object Hash extends HashFunctions[Hash] {
 }
 
 trait HashToHashingConversion {
-  implicit def catsKernelHashToHashing[A](implicit ev: Hash[A]): Hashing[A] = new Hashing[A] {
-    override def hash(x: A): Int = ev.hash(x)
-  }
+  implicit def catsKernelHashToHashing[A](implicit ev: Hash[A]): Hashing[A] =
+    new Hashing[A] {
+      override def hash(x: A): Int = ev.hash(x)
+    }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Monoid.scala b/kernel/src/main/scala/cats/kernel/Monoid.scala
index 5e86dd0cd..321761061 100644
--- a/kernel/src/main/scala/cats/kernel/Monoid.scala
+++ b/kernel/src/main/scala/cats/kernel/Monoid.scala
@@ -116,9 +116,10 @@ object Monoid extends MonoidFunctions[Monoid] {
   /**
    * Create a `Monoid` instance from the given function and empty value.
    */
-  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): Monoid[A] = new Monoid[A] {
-    override val empty: A = emptyValue
+  @inline def instance[A](emptyValue: A, cmb: (A, A) => A): Monoid[A] =
+    new Monoid[A] {
+      override val empty: A = emptyValue
 
-    override def combine(x: A, y: A): A = cmb(x, y)
-  }
+      override def combine(x: A, y: A): A = cmb(x, y)
+    }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Order.scala b/kernel/src/main/scala/cats/kernel/Order.scala
index 603e1f392..e469d4a2d 100644
--- a/kernel/src/main/scala/cats/kernel/Order.scala
+++ b/kernel/src/main/scala/cats/kernel/Order.scala
@@ -93,9 +93,10 @@ trait Order[@sp A] extends Any with PartialOrder[A] { self =>
    * Convert a `Order[A]` to a `scala.math.Ordering[A]`
    * instance.
    */
-  def toOrdering: Ordering[A] = new Ordering[A] {
-    def compare(x: A, y: A): Int = self.compare(x, y)
-  }
+  def toOrdering: Ordering[A] =
+    new Ordering[A] {
+      def compare(x: A, y: A): Int = self.compare(x, y)
+    }
 }
 
 abstract class OrderFunctions[O[T] <: Order[T]] extends PartialOrderFunctions[O] {
diff --git a/kernel/src/main/scala/cats/kernel/PartialOrder.scala b/kernel/src/main/scala/cats/kernel/PartialOrder.scala
index 63b5d560a..e5e898479 100644
--- a/kernel/src/main/scala/cats/kernel/PartialOrder.scala
+++ b/kernel/src/main/scala/cats/kernel/PartialOrder.scala
@@ -158,10 +158,11 @@ object PartialOrder extends PartialOrderFunctions[PartialOrder] with PartialOrde
       def partialCompare(x: A, y: A) = f(x, y)
     }
 
-  def fromPartialOrdering[A](implicit ev: PartialOrdering[A]): PartialOrder[A] = new PartialOrder[A] {
-    def partialCompare(x: A, y: A): Double =
-      ev.tryCompare(x, y).fold(Double.NaN)(_.toDouble)
-  }
+  def fromPartialOrdering[A](implicit ev: PartialOrdering[A]): PartialOrder[A] =
+    new PartialOrder[A] {
+      def partialCompare(x: A, y: A): Double =
+        ev.tryCompare(x, y).fold(Double.NaN)(_.toDouble)
+    }
 }
 
 trait PartialOrderToPartialOrderingConversion {
diff --git a/kernel/src/main/scala/cats/kernel/Semigroup.scala b/kernel/src/main/scala/cats/kernel/Semigroup.scala
index 2cceb5cbf..f82eb5557 100644
--- a/kernel/src/main/scala/cats/kernel/Semigroup.scala
+++ b/kernel/src/main/scala/cats/kernel/Semigroup.scala
@@ -147,9 +147,10 @@ object Semigroup
   /**
    * Create a `Semigroup` instance from the given function.
    */
-  @inline def instance[A](cmb: (A, A) => A): Semigroup[A] = new Semigroup[A] {
-    override def combine(x: A, y: A): A = cmb(x, y)
-  }
+  @inline def instance[A](cmb: (A, A) => A): Semigroup[A] =
+    new Semigroup[A] {
+      override def combine(x: A, y: A): A = cmb(x, y)
+    }
 
   implicit def catsKernelBoundedSemilatticeForBitSet: BoundedSemilattice[BitSet] =
     cats.kernel.instances.bitSet.catsKernelStdSemilatticeForBitSet
@@ -274,9 +275,10 @@ private class TryMonoid[A](A: Monoid[A]) extends TrySemigroup[A](A) with Monoid[
 }
 
 private class TrySemigroup[A](A: Semigroup[A]) extends Semigroup[Try[A]] {
-  def combine(x: Try[A], y: Try[A]): Try[A] = (x, y) match {
-    case (Success(xv), Success(yv)) => Success(A.combine(xv, yv))
-    case (f @ Failure(_), _)        => f
-    case (_, f)                     => f
-  }
+  def combine(x: Try[A], y: Try[A]): Try[A] =
+    (x, y) match {
+      case (Success(xv), Success(yv)) => Success(A.combine(xv, yv))
+      case (f @ Failure(_), _)        => f
+      case (_, f)                     => f
+    }
 }
diff --git a/kernel/src/main/scala/cats/kernel/Semilattice.scala b/kernel/src/main/scala/cats/kernel/Semilattice.scala
index 55facb8ad..631de852f 100644
--- a/kernel/src/main/scala/cats/kernel/Semilattice.scala
+++ b/kernel/src/main/scala/cats/kernel/Semilattice.scala
@@ -70,7 +70,8 @@ object Semilattice extends SemilatticeFunctions[Semilattice] {
   /**
    * Create a `Semilattice` instance from the given function.
    */
-  @inline def instance[A](cmb: (A, A) => A): Semilattice[A] = new Semilattice[A] {
-    override def combine(x: A, y: A): A = cmb(x, y)
-  }
+  @inline def instance[A](cmb: (A, A) => A): Semilattice[A] =
+    new Semilattice[A] {
+      override def combine(x: A, y: A): A = cmb(x, y)
+    }
 }
diff --git a/kernel/src/main/scala/cats/kernel/instances/EitherInstances.scala b/kernel/src/main/scala/cats/kernel/instances/EitherInstances.scala
index 00447876b..b57079e2e 100644
--- a/kernel/src/main/scala/cats/kernel/instances/EitherInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/EitherInstances.scala
@@ -51,8 +51,10 @@ private[instances] trait EitherInstances0 extends EitherInstances1 {
         }
     }
 
-  implicit def catsStdPartialOrderForEither[A, B](implicit A: PartialOrder[A],
-                                                  B: PartialOrder[B]): PartialOrder[Either[A, B]] =
+  implicit def catsStdPartialOrderForEither[A, B](implicit
+    A: PartialOrder[A],
+    B: PartialOrder[B]
+  ): PartialOrder[Either[A, B]] =
     new PartialOrder[Either[A, B]] {
       def partialCompare(x: Either[A, B], y: Either[A, B]): Double =
         x match {
diff --git a/kernel/src/main/scala/cats/kernel/instances/FunctionInstances.scala b/kernel/src/main/scala/cats/kernel/instances/FunctionInstances.scala
index 05b5272ae..87f2bd7c0 100644
--- a/kernel/src/main/scala/cats/kernel/instances/FunctionInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/FunctionInstances.scala
@@ -34,13 +34,13 @@ private[instances] trait FunctionInstances0 extends FunctionInstances1 {
   implicit def catsKernelGroupForFunction1[A, B](implicit G: Group[B]): Group[A => B] =
     new Function1Group[A, B] { def B: Group[B] = G }
 
-  implicit def catsKernelBoundedSemilatticeForFunction0[A](
-    implicit G: BoundedSemilattice[A]
+  implicit def catsKernelBoundedSemilatticeForFunction0[A](implicit
+    G: BoundedSemilattice[A]
   ): BoundedSemilattice[() => A] =
     new Function0Monoid[A] with BoundedSemilattice[() => A] { def A: Monoid[A] = G }
 
-  implicit def catsKernelBoundedSemilatticeForFunction1[A, B](
-    implicit G: BoundedSemilattice[B]
+  implicit def catsKernelBoundedSemilatticeForFunction1[A, B](implicit
+    G: BoundedSemilattice[B]
   ): BoundedSemilattice[A => B] =
     new Function1Monoid[A, B] with BoundedSemilattice[A => B] { def B: Monoid[B] = G }
 }
@@ -52,13 +52,13 @@ private[instances] trait FunctionInstances1 extends FunctionInstances2 {
       def eqv(x: () => A, y: () => A): Boolean = ev.eqv(x(), y())
     }
 
-  implicit def catsKernelCommutativeMonoidForFunction0[A](
-    implicit M: CommutativeMonoid[A]
+  implicit def catsKernelCommutativeMonoidForFunction0[A](implicit
+    M: CommutativeMonoid[A]
   ): CommutativeMonoid[() => A] =
     new Function0Monoid[A] with CommutativeMonoid[() => A] { def A: Monoid[A] = M }
 
-  implicit def catsKernelCommutativeMonoidForFunction1[A, B](
-    implicit M: CommutativeMonoid[B]
+  implicit def catsKernelCommutativeMonoidForFunction1[A, B](implicit
+    M: CommutativeMonoid[B]
   ): CommutativeMonoid[A => B] =
     new Function1Monoid[A, B] with CommutativeMonoid[A => B] { def B: Monoid[B] = M }
 
@@ -86,13 +86,13 @@ private[instances] trait FunctionInstances2 extends FunctionInstances3 {
 
 private[instances] trait FunctionInstances3 extends FunctionInstances4 {
 
-  implicit def catsKernelCommutativeSemigroupForFunction0[A](
-    implicit S: CommutativeSemigroup[A]
+  implicit def catsKernelCommutativeSemigroupForFunction0[A](implicit
+    S: CommutativeSemigroup[A]
   ): CommutativeSemigroup[() => A] =
     new Function0Semigroup[A] with CommutativeSemigroup[() => A] { def A: Semigroup[A] = S }
 
-  implicit def catsKernelCommutativeSemigroupForFunction1[A, B](
-    implicit S: CommutativeSemigroup[B]
+  implicit def catsKernelCommutativeSemigroupForFunction1[A, B](implicit
+    S: CommutativeSemigroup[B]
   ): CommutativeSemigroup[A => B] =
     new Function1Semigroup[A, B] with CommutativeSemigroup[A => B] { def B: Semigroup[B] = S }
 }
diff --git a/kernel/src/main/scala/cats/kernel/instances/OptionInstances.scala b/kernel/src/main/scala/cats/kernel/instances/OptionInstances.scala
index dcee07216..121bf4986 100644
--- a/kernel/src/main/scala/cats/kernel/instances/OptionInstances.scala
+++ b/kernel/src/main/scala/cats/kernel/instances/OptionInstances.scala
@@ -52,10 +52,11 @@ class OptionPartialOrder[A](implicit A: PartialOrder[A]) extends PartialOrder[Op
 }
 
 class OptionHash[A](implicit A: Hash[A]) extends OptionEq[A]()(A) with Hash[Option[A]] {
-  def hash(x: Option[A]): Int = x match {
-    case None     => None.hashCode()
-    case Some(xx) => StaticMethods.product1HashWithPrefix(A.hash(xx), x.productPrefix)
-  }
+  def hash(x: Option[A]): Int =
+    x match {
+      case None     => None.hashCode()
+      case Some(xx) => StaticMethods.product1HashWithPrefix(A.hash(xx), x.productPrefix)
+    }
 }
 
 class OptionEq[A](implicit A: Eq[A]) extends Eq[Option[A]] {
diff --git a/laws/src/main/scala/cats/laws/AlignLaws.scala b/laws/src/main/scala/cats/laws/AlignLaws.scala
index 590a11fb7..7d1d4c242 100644
--- a/laws/src/main/scala/cats/laws/AlignLaws.scala
+++ b/laws/src/main/scala/cats/laws/AlignLaws.scala
@@ -24,21 +24,22 @@ trait AlignLaws[F[_]] {
   def alignWithConsistent[A, B, C](fa: F[A], fb: F[B], f: A Ior B => C): IsEq[F[C]] =
     fa.alignWith(fb)(f) <-> fa.align(fb).map(f)
 
-  private def assoc[A, B, C](x: Ior[A, Ior[B, C]]): Ior[Ior[A, B], C] = x match {
-    case Left(a) => Left(Left(a))
-    case Right(bc) =>
-      bc match {
-        case Left(b)    => Left(Right(b))
-        case Right(c)   => Right(c)
-        case Both(b, c) => Both(Right(b), c)
-      }
-    case Both(a, bc) =>
-      bc match {
-        case Left(b)    => Left(Both(a, b))
-        case Right(c)   => Both(Left(a), c)
-        case Both(b, c) => Both(Both(a, b), c)
-      }
-  }
+  private def assoc[A, B, C](x: Ior[A, Ior[B, C]]): Ior[Ior[A, B], C] =
+    x match {
+      case Left(a) => Left(Left(a))
+      case Right(bc) =>
+        bc match {
+          case Left(b)    => Left(Right(b))
+          case Right(c)   => Right(c)
+          case Both(b, c) => Both(Right(b), c)
+        }
+      case Both(a, bc) =>
+        bc match {
+          case Left(b)    => Left(Both(a, b))
+          case Right(c)   => Both(Left(a), c)
+          case Both(b, c) => Both(Both(a, b), c)
+        }
+    }
 }
 
 object AlignLaws {
diff --git a/laws/src/main/scala/cats/laws/BifoldableLaws.scala b/laws/src/main/scala/cats/laws/BifoldableLaws.scala
index d82c490bd..3dc51233f 100644
--- a/laws/src/main/scala/cats/laws/BifoldableLaws.scala
+++ b/laws/src/main/scala/cats/laws/BifoldableLaws.scala
@@ -12,8 +12,8 @@ trait BifoldableLaws[F[_, _]] {
     expected <-> F.bifoldMap(fab)(f, g)
   }
 
-  def bifoldRightConsistentWithBifoldMap[A, B, C](fab: F[A, B], f: A => C, g: B => C)(
-    implicit C: Monoid[C]
+  def bifoldRightConsistentWithBifoldMap[A, B, C](fab: F[A, B], f: A => C, g: B => C)(implicit
+    C: Monoid[C]
   ): IsEq[C] = {
     val expected = F.bifoldRight(fab, Later(C.empty))(
       (a: A, ec: Eval[C]) => ec.map(c => C.combine(f(a), c)),
diff --git a/laws/src/main/scala/cats/laws/BitraverseLaws.scala b/laws/src/main/scala/cats/laws/BitraverseLaws.scala
index 820ebc445..d57eb6986 100644
--- a/laws/src/main/scala/cats/laws/BitraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/BitraverseLaws.scala
@@ -15,8 +15,7 @@ trait BitraverseLaws[F[_, _]] extends BifoldableLaws[F] with BifunctorLaws[F] {
     g: B => G[D],
     h: C => G[E],
     i: D => G[H]
-  )(implicit
-    G: Applicative[G]): IsEq[G[G[F[E, H]]]] = {
+  )(implicit G: Applicative[G]): IsEq[G[G[F[E, H]]]] = {
     val fg = F.bitraverse(fab)(f, g)
     val hi = G.map(fg)(f => F.bitraverse(f)(h, i))
 
diff --git a/laws/src/main/scala/cats/laws/DistributiveLaws.scala b/laws/src/main/scala/cats/laws/DistributiveLaws.scala
index b23e3cca5..9bb7f2ab2 100644
--- a/laws/src/main/scala/cats/laws/DistributiveLaws.scala
+++ b/laws/src/main/scala/cats/laws/DistributiveLaws.scala
@@ -23,9 +23,7 @@ trait DistributiveLaws[F[_]] extends FunctorLaws[F] {
     ma: M[A],
     f: A => F[B],
     g: B => N[C]
-  )(implicit
-    N: Distributive[N],
-    M: Functor[M]): IsEq[Nested[F, N, M[C]]] = {
+  )(implicit N: Distributive[N], M: Functor[M]): IsEq[Nested[F, N, M[C]]] = {
     val rhs = ma.distribute[Nested[F, N, *], C](a => Nested(F.map(f(a))(g)))
     val lhs = Nested(F.map(ma.distribute(f))(fb => fb.distribute(g)))
     lhs <-> rhs
diff --git a/laws/src/main/scala/cats/laws/FlatMapLaws.scala b/laws/src/main/scala/cats/laws/FlatMapLaws.scala
index 07f47ce66..423b91ac7 100644
--- a/laws/src/main/scala/cats/laws/FlatMapLaws.scala
+++ b/laws/src/main/scala/cats/laws/FlatMapLaws.scala
@@ -31,11 +31,12 @@ trait FlatMapLaws[F[_]] extends ApplyLaws[F] {
     F.mproduct(fa)(fb) <-> F.flatMap(fa)(a => F.map(fb(a))((a, _)))
 
   def tailRecMConsistentFlatMap[A](a: A, f: A => F[A]): IsEq[F[A]] = {
-    def bounce(n: Int) = F.tailRecM[(A, Int), A]((a, n)) {
-      case (a0, i) =>
-        if (i > 0) f(a0).map(a1 => Left((a1, i - 1)))
-        else f(a0).map(Right(_))
-    }
+    def bounce(n: Int) =
+      F.tailRecM[(A, Int), A]((a, n)) {
+        case (a0, i) =>
+          if (i > 0) f(a0).map(a1 => Left((a1, i - 1)))
+          else f(a0).map(Right(_))
+      }
     /*
      * The law is for n >= 1
      * bounce(n) == bounce(n - 1).flatMap(f)
diff --git a/laws/src/main/scala/cats/laws/FoldableLaws.scala b/laws/src/main/scala/cats/laws/FoldableLaws.scala
index da4b3520c..973650ba4 100644
--- a/laws/src/main/scala/cats/laws/FoldableLaws.scala
+++ b/laws/src/main/scala/cats/laws/FoldableLaws.scala
@@ -21,8 +21,7 @@ trait FoldableLaws[F[_]] extends UnorderedFoldableLaws[F] {
   def leftFoldConsistentWithFoldMap[A, B](
     fa: F[A],
     f: A => B
-  )(implicit
-    M: Monoid[B]): IsEq[B] =
+  )(implicit M: Monoid[B]): IsEq[B] =
     fa.foldMap(f) <-> fa.foldLeft(M.empty) { (b, a) =>
       b |+| f(a)
     }
@@ -30,8 +29,7 @@ trait FoldableLaws[F[_]] extends UnorderedFoldableLaws[F] {
   def rightFoldConsistentWithFoldMap[A, B](
     fa: F[A],
     f: A => B
-  )(implicit
-    M: Monoid[B]): IsEq[B] =
+  )(implicit M: Monoid[B]): IsEq[B] =
     fa.foldMap(f) <-> fa.foldRight(Later(M.empty))((a, lb) => lb.map(f(a) |+| _)).value
 
   def existsConsistentWithFind[A](fa: F[A], p: A => Boolean): Boolean =
@@ -50,8 +48,7 @@ trait FoldableLaws[F[_]] extends UnorderedFoldableLaws[F] {
   def foldRightDeferConsistentWithFoldRight[A, B](
     fa: F[A],
     f: (B, A) => B
-  )(implicit
-    M: Monoid[B]): IsEq[B] = {
+  )(implicit M: Monoid[B]): IsEq[B] = {
     val g: (A, Eval[B]) => Eval[B] = (a, ea) => ea.map(f(_, a))
 
     F.foldRight(fa, Later(M.empty))(g).value <-> F.foldRightDefer(fa, Later(M.empty): Eval[B])(g).value
diff --git a/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala b/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala
index 9714e240e..e89d7d4ac 100644
--- a/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/NonEmptyTraverseLaws.scala
@@ -15,9 +15,7 @@ trait NonEmptyTraverseLaws[F[_]] extends TraverseLaws[F] with ReducibleLaws[F] {
     fa: F[A],
     f: A => M[B],
     g: B => N[C]
-  )(implicit
-    N: Apply[N],
-    M: Apply[M]): IsEq[Nested[M, N, F[C]]] = {
+  )(implicit N: Apply[N], M: Apply[M]): IsEq[Nested[M, N, F[C]]] = {
 
     val lhs = Nested(M.map(fa.nonEmptyTraverse(f))(fb => fb.nonEmptyTraverse(g)))
     val rhs = fa.nonEmptyTraverse[Nested[M, N, *], C](a => Nested(M.map(f(a))(g)))
@@ -28,9 +26,7 @@ trait NonEmptyTraverseLaws[F[_]] extends TraverseLaws[F] with ReducibleLaws[F] {
     fa: F[A],
     f: A => M[B],
     g: A => N[B]
-  )(implicit
-    N: Apply[N],
-    M: Apply[M]): IsEq[(M[F[B]], N[F[B]])] = {
+  )(implicit N: Apply[N], M: Apply[M]): IsEq[(M[F[B]], N[F[B]])] = {
     type MN[Z] = (M[Z], N[Z])
     implicit val MN: Apply[MN] = new Apply[MN] {
       def ap[X, Y](f: MN[X => Y])(fa: MN[X]): MN[Y] = {
diff --git a/laws/src/main/scala/cats/laws/ProfunctorLaws.scala b/laws/src/main/scala/cats/laws/ProfunctorLaws.scala
index e391b76cc..904b5344a 100644
--- a/laws/src/main/scala/cats/laws/ProfunctorLaws.scala
+++ b/laws/src/main/scala/cats/laws/ProfunctorLaws.scala
@@ -17,7 +17,8 @@ trait ProfunctorLaws[F[_, _]] {
                                                     f2: A2 => A1,
                                                     f1: A1 => A0,
                                                     g1: B0 => B1,
-                                                    g2: B1 => B2): IsEq[F[A2, B2]] =
+                                                    g2: B1 => B2
+  ): IsEq[F[A2, B2]] =
     fab.dimap(f1)(g1).dimap(f2)(g2) <-> fab.dimap(f1.compose(f2))(g2.compose(g1))
 
   def profunctorLmapIdentity[A, B](fab: F[A, B]): IsEq[F[A, B]] =
diff --git a/laws/src/main/scala/cats/laws/ReducibleLaws.scala b/laws/src/main/scala/cats/laws/ReducibleLaws.scala
index 4d52ebd9e..07fab94be 100644
--- a/laws/src/main/scala/cats/laws/ReducibleLaws.scala
+++ b/laws/src/main/scala/cats/laws/ReducibleLaws.scala
@@ -9,22 +9,19 @@ trait ReducibleLaws[F[_]] extends FoldableLaws[F] {
   def reduceLeftToConsistentWithReduceMap[A, B](
     fa: F[A],
     f: A => B
-  )(implicit
-    B: Semigroup[B]): IsEq[B] =
+  )(implicit B: Semigroup[B]): IsEq[B] =
     fa.reduceMap(f) <-> fa.reduceLeftTo(f)((b, a) => b |+| f(a))
 
   def reduceRightToConsistentWithReduceMap[A, B](
     fa: F[A],
     f: A => B
-  )(implicit
-    B: Semigroup[B]): IsEq[B] =
+  )(implicit B: Semigroup[B]): IsEq[B] =
     fa.reduceMap(f) <-> fa.reduceRightTo(f)((a, eb) => eb.map(f(a) |+| _)).value
 
   def reduceRightToConsistentWithReduceRightToOption[A, B](
     fa: F[A],
     f: A => B
-  )(implicit
-    B: Semigroup[B]): IsEq[Option[B]] =
+  )(implicit B: Semigroup[B]): IsEq[Option[B]] =
     fa.reduceRightToOption(f)((a, eb) => eb.map(f(a) |+| _)).value <->
       fa.reduceRightTo(f)((a, eb) => eb.map(f(a) |+| _)).map(Option(_)).value
 
diff --git a/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala b/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
index 0811d6917..6d4300cc5 100644
--- a/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
+++ b/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
@@ -6,10 +6,28 @@ import cats.instances.option._
 import cats.syntax.foldable._
 import cats.syntax.traverse._
 import cats.syntax.traverseFilter._
-import cats.{Applicative, Traverse, TraverseFilter}
+import cats.{Applicative, Foldable, MonoidK, Traverse, TraverseFilter}
 
 trait ShortCircuitingLaws[F[_]] {
 
+  def foldMapKShortCircuits[A](fa: F[A], empty: A)(implicit F: Foldable[F]): IsEq[Long] = {
+    val size = fa.size
+    val maxInvocationsAllowed = size / 2
+    val f = new RestrictedFunction[A, Option[A]]((a: A) => None, maxInvocationsAllowed, Some(empty))
+
+    fa.foldMapK(f)
+    f.invocations.get <-> (maxInvocationsAllowed + 1).min(size)
+  }
+
+  def foldMapKWontShortCircuit[A](fa: F[A], empty: A)(implicit F: Foldable[F]): IsEq[Long] = {
+    val size = fa.size
+    val maxInvocationsAllowed = size / 2
+    val f = new RestrictedFunction[A, Option[A]]((a: A) => None, maxInvocationsAllowed, Some(empty))
+
+    fa.foldMapK(f)(F, nonShortCircuitingMonoidK)
+    f.invocations.get <-> size
+  }
+
   def traverseShortCircuits[A](fa: F[A])(implicit F: Traverse[F]): IsEq[Long] = {
     val size = fa.size
     val maxInvocationsAllowed = size / 2
@@ -86,6 +104,11 @@ trait ShortCircuitingLaws[F[_]] {
     override def pure[A](a: A): Option[A] = Some(a)
     override def ap[A, B](ff: Option[A => B])(fa: Option[A]): Option[B] = ff.flatMap(f => fa.map(f))
   }
+
+  private[this] val nonShortCircuitingMonoidK: MonoidK[Option] = new MonoidK[Option] {
+    def empty[A]: Option[A] = None
+    def combineK[A](x: Option[A], y: Option[A]): Option[A] = x.orElse(y)
+  }
 }
 
 object ShortCircuitingLaws {
diff --git a/laws/src/main/scala/cats/laws/StrongLaws.scala b/laws/src/main/scala/cats/laws/StrongLaws.scala
index 82fb89750..1001e1abe 100644
--- a/laws/src/main/scala/cats/laws/StrongLaws.scala
+++ b/laws/src/main/scala/cats/laws/StrongLaws.scala
@@ -43,7 +43,7 @@ trait StrongLaws[F[_, _]] extends ProfunctorLaws[F] {
   def dinaturalitySecond[A, B, C, D](fab: F[A, B], f: C => D): IsEq[F[(C, A), (D, B)]] =
     fab.second[C].rmap(mapFirst(f)) <-> fab.second[D].lmap(mapFirst(f))
 
-  private def assoc[A, B, C]: (((A, B), C)) => (A, (B, C)) = { case ((a, c), d)   => (a, (c, d)) }
+  private def assoc[A, B, C]: (((A, B), C)) => (A, (B, C)) = { case ((a, c), d) => (a, (c, d)) }
   private def unassoc[A, B, C]: ((A, (B, C))) => ((A, B), C) = { case (a, (c, d)) => ((a, c), d) }
 
   /** first' . first' == dimap assoc unassoc . first' where
diff --git a/laws/src/main/scala/cats/laws/TraverseFilterLaws.scala b/laws/src/main/scala/cats/laws/TraverseFilterLaws.scala
index 9e642080d..3c45188dd 100644
--- a/laws/src/main/scala/cats/laws/TraverseFilterLaws.scala
+++ b/laws/src/main/scala/cats/laws/TraverseFilterLaws.scala
@@ -14,8 +14,7 @@ trait TraverseFilterLaws[F[_]] extends FunctorFilterLaws[F] {
   def traverseFilterConsistentWithTraverse[G[_]: Applicative, A](fa: F[A], f: A => G[A]): IsEq[G[F[A]]] =
     fa.traverseFilter(a => f(a).map(_.some)) <-> F.traverse.traverse(fa)(f)
 
-  def traverseFilterComposition[A, B, C, M[_], N[_]](fa: F[A], f: A => M[Option[B]], g: B => N[Option[C]])(
-    implicit
+  def traverseFilterComposition[A, B, C, M[_], N[_]](fa: F[A], f: A => M[Option[B]], g: B => N[Option[C]])(implicit
     M: Applicative[M],
     N: Applicative[N]
   ): IsEq[Nested[M, N, F[C]]] = {
@@ -28,8 +27,8 @@ trait TraverseFilterLaws[F[_]] extends FunctorFilterLaws[F] {
   def filterAConsistentWithTraverseFilter[G[_]: Applicative, A](fa: F[A], f: A => G[Boolean]): IsEq[G[F[A]]] =
     fa.filterA(f) <-> fa.traverseFilter(a => f(a).map(if (_) Some(a) else None))
 
-  def traverseEitherConsistentWithTraverseFilter[G[_], E, A, B](fa: F[A], f: A => G[Option[B]], e: E)(
-    implicit G: Monad[G]
+  def traverseEitherConsistentWithTraverseFilter[G[_], E, A, B](fa: F[A], f: A => G[Option[B]], e: E)(implicit
+    G: Monad[G]
   ): IsEq[G[F[B]]] =
     fa.traverseEither(a => f(a).map(_.toRight(e)))((_, _) => Applicative[G].unit) <-> fa.traverseFilter(f)
 }
diff --git a/laws/src/main/scala/cats/laws/TraverseLaws.scala b/laws/src/main/scala/cats/laws/TraverseLaws.scala
index 896209349..3e0af9073 100644
--- a/laws/src/main/scala/cats/laws/TraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/TraverseLaws.scala
@@ -16,9 +16,7 @@ trait TraverseLaws[F[_]] extends FunctorLaws[F] with FoldableLaws[F] with Unorde
     fa: F[A],
     f: A => M[B],
     g: B => N[C]
-  )(implicit
-    N: Applicative[N],
-    M: Applicative[M]): IsEq[Nested[M, N, F[C]]] = {
+  )(implicit N: Applicative[N], M: Applicative[M]): IsEq[Nested[M, N, F[C]]] = {
 
     val lhs = Nested(M.map(fa.traverse(f))(fb => fb.traverse(g)))
     val rhs = fa.traverse[Nested[M, N, *], C](a => Nested(M.map(f(a))(g)))
@@ -29,9 +27,7 @@ trait TraverseLaws[F[_]] extends FunctorLaws[F] with FoldableLaws[F] with Unorde
     fa: F[A],
     f: A => M[B],
     g: A => N[B]
-  )(implicit
-    N: Applicative[N],
-    M: Applicative[M]): IsEq[(M[F[B]], N[F[B]])] = {
+  )(implicit N: Applicative[N], M: Applicative[M]): IsEq[(M[F[B]], N[F[B]])] = {
     type MN[Z] = (M[Z], N[Z])
     implicit val MN: Applicative[MN] = new Applicative[MN] {
       def pure[X](x: X): MN[X] = (M.pure(x), N.pure(x))
diff --git a/laws/src/main/scala/cats/laws/UnorderedTraverseLaws.scala b/laws/src/main/scala/cats/laws/UnorderedTraverseLaws.scala
index 19dc1a402..d3a3ee125 100644
--- a/laws/src/main/scala/cats/laws/UnorderedTraverseLaws.scala
+++ b/laws/src/main/scala/cats/laws/UnorderedTraverseLaws.scala
@@ -9,8 +9,8 @@ trait UnorderedTraverseLaws[F[_]] extends UnorderedFoldableLaws[F] {
   def unorderedTraverseIdentity[A, B](fa: F[A])(f: A => B)(implicit ev: Functor[F]): IsEq[F[B]] =
     F.unorderedTraverse[Id, A, B](fa)(f) <-> (ev.map(fa)(f))
 
-  def unorderedTraverseSequentialComposition[A, B, C, M[_], N[_]](fa: F[A], f: A => M[B], g: B => N[C])(
-    implicit N: CommutativeApplicative[N],
+  def unorderedTraverseSequentialComposition[A, B, C, M[_], N[_]](fa: F[A], f: A => M[B], g: B => N[C])(implicit
+    N: CommutativeApplicative[N],
     M: CommutativeApplicative[M]
   ): IsEq[Nested[M, N, F[C]]] = {
 
@@ -19,8 +19,8 @@ trait UnorderedTraverseLaws[F[_]] extends UnorderedFoldableLaws[F] {
     lhs <-> rhs
   }
 
-  def unorderedTraverseParallelComposition[A, B, M[_], N[_]](fa: F[A], f: A => M[B], g: A => N[B])(
-    implicit N: CommutativeApplicative[N],
+  def unorderedTraverseParallelComposition[A, B, M[_], N[_]](fa: F[A], f: A => M[B], g: A => N[B])(implicit
+    N: CommutativeApplicative[N],
     M: CommutativeApplicative[M]
   ): IsEq[(M[F[B]], N[F[B]])] = {
 
diff --git a/laws/src/main/scala/cats/laws/discipline/AlignTests.scala b/laws/src/main/scala/cats/laws/discipline/AlignTests.scala
index 8d35bb3ac..c7af3738b 100644
--- a/laws/src/main/scala/cats/laws/discipline/AlignTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/AlignTests.scala
@@ -11,8 +11,8 @@ import org.typelevel.discipline.Laws
 trait AlignTests[F[_]] extends Laws {
   def laws: AlignLaws[F]
 
-  def align[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary](
-    implicit ArbFA: Arbitrary[F[A]],
+  def align[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary](implicit
+    ArbFA: Arbitrary[F[A]],
     ArbFB: Arbitrary[F[B]],
     ArbFC: Arbitrary[F[C]],
     ArbFAtoB: Arbitrary[A => C],
@@ -37,7 +37,8 @@ trait AlignTests[F[_]] extends Laws {
                        },
                        "alignWith consistent" -> forAll { (fa: F[A], fb: F[B], f: A Ior B => C) =>
                          laws.alignWithConsistent[A, B, C](fa, fb, f)
-                       })
+                       }
+    )
 }
 
 object AlignTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/AlternativeTests.scala b/laws/src/main/scala/cats/laws/discipline/AlternativeTests.scala
index 848710a2d..dab872524 100644
--- a/laws/src/main/scala/cats/laws/discipline/AlternativeTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/AlternativeTests.scala
@@ -10,19 +10,20 @@ trait AlternativeTests[F[_]] extends ApplicativeTests[F] with MonoidKTests[F] {
   def laws: AlternativeLaws[F]
 
   def alternative[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                            ArbFA: Arbitrary[F[A]],
-                                                            ArbFB: Arbitrary[F[B]],
-                                                            ArbFC: Arbitrary[F[C]],
-                                                            ArbFAtoB: Arbitrary[F[A => B]],
-                                                            ArbFBtoC: Arbitrary[F[B => C]],
-                                                            CogenA: Cogen[A],
-                                                            CogenB: Cogen[B],
-                                                            CogenC: Cogen[C],
-                                                            EqFA: Eq[F[A]],
-                                                            EqFB: Eq[F[B]],
-                                                            EqFC: Eq[F[C]],
-                                                            EqFABC: Eq[F[(A, B, C)]],
-                                                            iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       val name: String = "alternative"
       val bases: Seq[(String, RuleSet)] = Nil
diff --git a/laws/src/main/scala/cats/laws/discipline/ApplicativeErrorTests.scala b/laws/src/main/scala/cats/laws/discipline/ApplicativeErrorTests.scala
index e53d3918f..b9066b845 100644
--- a/laws/src/main/scala/cats/laws/discipline/ApplicativeErrorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ApplicativeErrorTests.scala
@@ -12,58 +12,60 @@ trait ApplicativeErrorTests[F[_], E] extends ApplicativeTests[F] {
   def laws: ApplicativeErrorLaws[F, E]
 
   def applicativeError[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                             ArbFA: Arbitrary[F[A]],
-                                                                             ArbFB: Arbitrary[F[B]],
-                                                                             ArbFC: Arbitrary[F[C]],
-                                                                             ArbFU: Arbitrary[F[Unit]],
-                                                                             ArbFAtoB: Arbitrary[F[A => B]],
-                                                                             ArbFBtoC: Arbitrary[F[B => C]],
-                                                                             ArbE: Arbitrary[E],
-                                                                             CogenA: Cogen[A],
-                                                                             CogenB: Cogen[B],
-                                                                             CogenC: Cogen[C],
-                                                                             CogenE: Cogen[E],
-                                                                             EqFA: Eq[F[A]],
-                                                                             EqFB: Eq[F[B]],
-                                                                             EqFC: Eq[F[C]],
-                                                                             EqE: Eq[E],
-                                                                             EqFEitherEU: Eq[F[Either[E, Unit]]],
-                                                                             EqFEitherEA: Eq[F[Either[E, A]]],
-                                                                             EqEitherTFEA: Eq[EitherT[F, E, A]],
-                                                                             EqFABC: Eq[F[(A, B, C)]],
-                                                                             iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFU: Arbitrary[F[Unit]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    ArbE: Arbitrary[E],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    CogenE: Cogen[E],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqE: Eq[E],
+    EqFEitherEU: Eq[F[Either[E, Unit]]],
+    EqFEitherEA: Eq[F[Either[E, A]]],
+    EqEitherTFEA: Eq[EitherT[F, E, A]],
+    EqFABC: Eq[F[(A, B, C)]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       def name: String = "applicativeError"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(applicative[A, B, C])
-      def props: Seq[(String, Prop)] = Seq(
-        "applicativeError handleWith" -> forAll(laws.applicativeErrorHandleWith[A] _),
-        "applicativeError handle" -> forAll(laws.applicativeErrorHandle[A] _),
-        "applicativeError handleErrorWith pure" -> forAll(laws.handleErrorWithPure[A] _),
-        "applicativeError handleError pure" -> forAll(laws.handleErrorPure[A] _),
-        "applicativeError raiseError attempt" -> forAll(laws.raiseErrorAttempt _),
-        "applicativeError pure attempt" -> forAll(laws.pureAttempt[A] _),
-        "applicativeError handleErrorWith consistent with recoverWith" -> forAll(
-          laws.handleErrorWithConsistentWithRecoverWith[A] _
-        ),
-        "applicativeError handleError consistent with recover" -> forAll(laws.handleErrorConsistentWithRecover[A] _),
-        "applicativeError recover consistent with recoverWith" -> forAll(laws.recoverConsistentWithRecoverWith[A] _),
-        "applicativeError attempt consistent with attemptT" -> forAll(laws.attemptConsistentWithAttemptT[A] _),
-        "applicativeError attempt fromEither consistent with pure" -> forAll(
-          laws.attemptFromEitherConsistentWithPure[A] _
-        ),
-        "applicativeError onError pure" -> forAll(laws.onErrorPure[A] _),
-        "applicativeError onError raise" -> forAll(laws.onErrorRaise[A] _),
-        "applicativeError adaptError pure" -> forAll(laws.adaptErrorPure[A] _),
-        "applicativeError adaptError raise" -> forAll(laws.adaptErrorRaise[A] _),
-        "applicativeError redeem is derived from attempt and map" -> forAll(laws.redeemDerivedFromAttemptMap[A, B] _),
-        "applicativeError handleError . raiseError left-distributes over ap" -> forAll(
-          laws.raiseErrorDistributesOverApLeft[A] _
-        ),
-        "applicativeError handleError . raiseError right-distributes over ap" -> forAll(
-          laws.raiseErrorDistributesOverApRight[A] _
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "applicativeError handleWith" -> forAll(laws.applicativeErrorHandleWith[A] _),
+          "applicativeError handle" -> forAll(laws.applicativeErrorHandle[A] _),
+          "applicativeError handleErrorWith pure" -> forAll(laws.handleErrorWithPure[A] _),
+          "applicativeError handleError pure" -> forAll(laws.handleErrorPure[A] _),
+          "applicativeError raiseError attempt" -> forAll(laws.raiseErrorAttempt _),
+          "applicativeError pure attempt" -> forAll(laws.pureAttempt[A] _),
+          "applicativeError handleErrorWith consistent with recoverWith" -> forAll(
+            laws.handleErrorWithConsistentWithRecoverWith[A] _
+          ),
+          "applicativeError handleError consistent with recover" -> forAll(laws.handleErrorConsistentWithRecover[A] _),
+          "applicativeError recover consistent with recoverWith" -> forAll(laws.recoverConsistentWithRecoverWith[A] _),
+          "applicativeError attempt consistent with attemptT" -> forAll(laws.attemptConsistentWithAttemptT[A] _),
+          "applicativeError attempt fromEither consistent with pure" -> forAll(
+            laws.attemptFromEitherConsistentWithPure[A] _
+          ),
+          "applicativeError onError pure" -> forAll(laws.onErrorPure[A] _),
+          "applicativeError onError raise" -> forAll(laws.onErrorRaise[A] _),
+          "applicativeError adaptError pure" -> forAll(laws.adaptErrorPure[A] _),
+          "applicativeError adaptError raise" -> forAll(laws.adaptErrorRaise[A] _),
+          "applicativeError redeem is derived from attempt and map" -> forAll(laws.redeemDerivedFromAttemptMap[A, B] _),
+          "applicativeError handleError . raiseError left-distributes over ap" -> forAll(
+            laws.raiseErrorDistributesOverApLeft[A] _
+          ),
+          "applicativeError handleError . raiseError right-distributes over ap" -> forAll(
+            laws.raiseErrorDistributesOverApRight[A] _
+          )
         )
-      )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala b/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala
index 62852aad9..510024fa0 100644
--- a/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ApplicativeTests.scala
@@ -10,19 +10,20 @@ trait ApplicativeTests[F[_]] extends ApplyTests[F] {
   def laws: ApplicativeLaws[F]
 
   def applicative[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                            ArbFA: Arbitrary[F[A]],
-                                                            ArbFB: Arbitrary[F[B]],
-                                                            ArbFC: Arbitrary[F[C]],
-                                                            ArbFAtoB: Arbitrary[F[A => B]],
-                                                            ArbFBtoC: Arbitrary[F[B => C]],
-                                                            CogenA: Cogen[A],
-                                                            CogenB: Cogen[B],
-                                                            CogenC: Cogen[C],
-                                                            EqFA: Eq[F[A]],
-                                                            EqFB: Eq[F[B]],
-                                                            EqFC: Eq[F[C]],
-                                                            EqFABC: Eq[F[(A, B, C)]],
-                                                            iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "applicative",
       parent = Some(apply[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/ApplyTests.scala b/laws/src/main/scala/cats/laws/discipline/ApplyTests.scala
index 2a43c3c4b..57ba7983a 100644
--- a/laws/src/main/scala/cats/laws/discipline/ApplyTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ApplyTests.scala
@@ -10,29 +10,31 @@ trait ApplyTests[F[_]] extends FunctorTests[F] with SemigroupalTests[F] {
   def laws: ApplyLaws[F]
 
   def apply[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                      ArbFA: Arbitrary[F[A]],
-                                                      ArbFB: Arbitrary[F[B]],
-                                                      ArbFC: Arbitrary[F[C]],
-                                                      ArbFAtoB: Arbitrary[F[A => B]],
-                                                      ArbFBtoC: Arbitrary[F[B => C]],
-                                                      CogenA: Cogen[A],
-                                                      CogenB: Cogen[B],
-                                                      CogenC: Cogen[C],
-                                                      EqFA: Eq[F[A]],
-                                                      EqFC: Eq[F[C]],
-                                                      EqFABC: Eq[F[(A, B, C)]],
-                                                      iso: Isomorphisms[F]): RuleSet = new RuleSet {
-    val name = "apply"
-    val parents = Seq(functor[A, B, C], semigroupal[A, B, C])
-    val bases = Seq.empty
-    val props = Seq(
-      "apply composition" -> forAll(laws.applyComposition[A, B, C] _),
-      "map2/product-map consistency" -> forAll(laws.map2ProductConsistency[A, B, C] _),
-      "map2/map2Eval consistency" -> forAll(laws.map2EvalConsistency[A, B, C] _),
-      "productR consistent map2" -> forAll(laws.productRConsistency[A, C] _),
-      "productL consistent map2" -> forAll(laws.productLConsistency[A, C] _)
-    )
-  }
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
+    new RuleSet {
+      val name = "apply"
+      val parents = Seq(functor[A, B, C], semigroupal[A, B, C])
+      val bases = Seq.empty
+      val props = Seq(
+        "apply composition" -> forAll(laws.applyComposition[A, B, C] _),
+        "map2/product-map consistency" -> forAll(laws.map2ProductConsistency[A, B, C] _),
+        "map2/map2Eval consistency" -> forAll(laws.map2EvalConsistency[A, B, C] _),
+        "productR consistent map2" -> forAll(laws.productRConsistency[A, C] _),
+        "productL consistent map2" -> forAll(laws.productLConsistency[A, C] _)
+      )
+    }
 }
 
 object ApplyTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/ArrowChoiceTests.scala b/laws/src/main/scala/cats/laws/discipline/ArrowChoiceTests.scala
index f1e23137f..affff0ee7 100644
--- a/laws/src/main/scala/cats/laws/discipline/ArrowChoiceTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ArrowChoiceTests.scala
@@ -10,8 +10,7 @@ import Prop._
 trait ArrowChoiceTests[F[_, _]] extends ArrowTests[F] with ChoiceTests[F] {
   def laws: ArrowChoiceLaws[F]
 
-  def arrowChoice[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
-    implicit
+  def arrowChoice[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFBC: Arbitrary[F[B, C]],
     ArbFAC: Arbitrary[F[A, C]],
@@ -52,18 +51,20 @@ trait ArrowChoiceTests[F[_, _]] extends ArrowTests[F] with ChoiceTests[F] {
     new RuleSet {
       def name: String = "arrowChoice"
       def bases: Seq[(String, RuleSet)] = Nil
-      def parents: Seq[RuleSet] = Seq(
-        arrow[A, B, C, D, E, G],
-        choice[A, B, C, D]
-      )
-      def props: Seq[(String, Prop)] = Seq(
-        "left and lift commute" -> forAll(laws.leftLiftCommute[A, B, C] _),
-        "left and compose commute" -> forAll(laws.leftComposeCommute[A, B, C, D] _),
-        "left and right consistent" -> forAll(laws.leftRightConsistent[A, B, C] _),
-        "left and then lift (Left.apply) commutes" -> forAll(laws.leftAndThenLiftedLeftApplyCommutes[A, B, C] _),
-        "left and then identity +++ _ commutes" -> forAll(laws.leftAndThenRightIdentityCommutes[A, B, C, D] _),
-        "left commutes with sum association" -> forAll(laws.leftTwiceCommutesWithSumAssociation[A, B, C, D] _)
-      )
+      def parents: Seq[RuleSet] =
+        Seq(
+          arrow[A, B, C, D, E, G],
+          choice[A, B, C, D]
+        )
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "left and lift commute" -> forAll(laws.leftLiftCommute[A, B, C] _),
+          "left and compose commute" -> forAll(laws.leftComposeCommute[A, B, C, D] _),
+          "left and right consistent" -> forAll(laws.leftRightConsistent[A, B, C] _),
+          "left and then lift (Left.apply) commutes" -> forAll(laws.leftAndThenLiftedLeftApplyCommutes[A, B, C] _),
+          "left and then identity +++ _ commutes" -> forAll(laws.leftAndThenRightIdentityCommutes[A, B, C, D] _),
+          "left commutes with sum association" -> forAll(laws.leftTwiceCommutesWithSumAssociation[A, B, C, D] _)
+        )
     }
 }
 object ArrowChoiceTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/ArrowTests.scala b/laws/src/main/scala/cats/laws/discipline/ArrowTests.scala
index a627c45b2..13332b462 100644
--- a/laws/src/main/scala/cats/laws/discipline/ArrowTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ArrowTests.scala
@@ -9,8 +9,7 @@ import Prop._
 trait ArrowTests[F[_, _]] extends CategoryTests[F] with StrongTests[F] {
   def laws: ArrowLaws[F]
 
-  def arrow[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
-    implicit
+  def arrow[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFBC: Arbitrary[F[B, C]],
     ArbFAC: Arbitrary[F[A, C]],
@@ -43,21 +42,23 @@ trait ArrowTests[F[_, _]] extends CategoryTests[F] with StrongTests[F] {
     new RuleSet {
       def name: String = "arrow"
       def bases: Seq[(String, RuleSet)] = Nil
-      def parents: Seq[RuleSet] = Seq(
-        category[A, B, C, D],
-        strong[A, B, C, D, E, G]
-      )
-      def props: Seq[(String, Prop)] = Seq(
-        "arrow identity" -> laws.arrowIdentity[A],
-        "arrow composition" -> forAll(laws.arrowComposition[A, B, C] _),
-        "arrow extension" -> forAll(laws.arrowExtension[A, B, C] _),
-        "arrow functor" -> forAll(laws.arrowFunctor[A, B, C, D] _),
-        "arrow exchange" -> forAll(laws.arrowExchange[A, B, C, D] _),
-        "arrow unit" -> forAll(laws.arrowUnit[A, B, C] _),
-        "arrow association" -> forAll(laws.arrowAssociation[A, B, C, D] _),
-        "split consistent with andThen" -> forAll(laws.splitConsistentWithAndThen[A, B, C, D] _),
-        "merge consistent with andThen" -> forAll(laws.mergeConsistentWithAndThen[A, B, C] _)
-      )
+      def parents: Seq[RuleSet] =
+        Seq(
+          category[A, B, C, D],
+          strong[A, B, C, D, E, G]
+        )
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "arrow identity" -> laws.arrowIdentity[A],
+          "arrow composition" -> forAll(laws.arrowComposition[A, B, C] _),
+          "arrow extension" -> forAll(laws.arrowExtension[A, B, C] _),
+          "arrow functor" -> forAll(laws.arrowFunctor[A, B, C, D] _),
+          "arrow exchange" -> forAll(laws.arrowExchange[A, B, C, D] _),
+          "arrow unit" -> forAll(laws.arrowUnit[A, B, C] _),
+          "arrow association" -> forAll(laws.arrowAssociation[A, B, C, D] _),
+          "split consistent with andThen" -> forAll(laws.splitConsistentWithAndThen[A, B, C, D] _),
+          "merge consistent with andThen" -> forAll(laws.mergeConsistentWithAndThen[A, B, C] _)
+        )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/BifoldableTests.scala b/laws/src/main/scala/cats/laws/discipline/BifoldableTests.scala
index c53e83db4..2e391109f 100644
--- a/laws/src/main/scala/cats/laws/discipline/BifoldableTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/BifoldableTests.scala
@@ -10,9 +10,10 @@ trait BifoldableTests[F[_, _]] extends Laws {
   def laws: BifoldableLaws[F]
 
   def bifoldable[A: Arbitrary, B: Arbitrary, C: Arbitrary: Monoid: Eq](implicit
-                                                                       ArbFAB: Arbitrary[F[A, B]],
-                                                                       CogenA: Cogen[A],
-                                                                       CogenB: Cogen[B]): RuleSet =
+    ArbFAB: Arbitrary[F[A, B]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "bifoldable",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/BifunctorTests.scala b/laws/src/main/scala/cats/laws/discipline/BifunctorTests.scala
index a8f5c3511..7ca82461c 100644
--- a/laws/src/main/scala/cats/laws/discipline/BifunctorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/BifunctorTests.scala
@@ -10,15 +10,16 @@ trait BifunctorTests[F[_, _]] extends Laws {
   def laws: BifunctorLaws[F]
 
   def bifunctor[A, A2, A3, B, B2, B3](implicit
-                                      ArbFAB: Arbitrary[F[A, B]],
-                                      ArbA2: Arbitrary[A => A2],
-                                      ArbA3: Arbitrary[A2 => A3],
-                                      ArbB2: Arbitrary[B => B2],
-                                      ArbB3: Arbitrary[B2 => B3],
-                                      EqFAB: Eq[F[A, B]],
-                                      EqFCZ: Eq[F[A3, B3]],
-                                      EqFA3B: Eq[F[A3, B]],
-                                      EqFAB3: Eq[F[A, B3]]): RuleSet =
+    ArbFAB: Arbitrary[F[A, B]],
+    ArbA2: Arbitrary[A => A2],
+    ArbA3: Arbitrary[A2 => A3],
+    ArbB2: Arbitrary[B => B2],
+    ArbB3: Arbitrary[B2 => B3],
+    EqFAB: Eq[F[A, B]],
+    EqFCZ: Eq[F[A3, B3]],
+    EqFA3B: Eq[F[A3, B]],
+    EqFAB3: Eq[F[A, B3]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "Bifunctor",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/BimonadTests.scala b/laws/src/main/scala/cats/laws/discipline/BimonadTests.scala
index 85e6713b3..7ff7c7161 100644
--- a/laws/src/main/scala/cats/laws/discipline/BimonadTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/BimonadTests.scala
@@ -10,34 +10,36 @@ trait BimonadTests[F[_]] extends MonadTests[F] with ComonadTests[F] {
   def laws: BimonadLaws[F]
 
   def bimonad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                    ArbFA: Arbitrary[F[A]],
-                                                                    ArbFFA: Arbitrary[F[F[A]]],
-                                                                    ArbFB: Arbitrary[F[B]],
-                                                                    ArbFC: Arbitrary[F[C]],
-                                                                    ArbFAtoB: Arbitrary[F[A => B]],
-                                                                    ArbFBtoC: Arbitrary[F[B => C]],
-                                                                    CogenA: Cogen[A],
-                                                                    CogenB: Cogen[B],
-                                                                    CogenC: Cogen[C],
-                                                                    CogenFA: Cogen[F[A]],
-                                                                    CogenFB: Cogen[F[B]],
-                                                                    EqFFFA: Eq[F[F[A]]],
-                                                                    EqFFA: Eq[F[F[F[A]]]],
-                                                                    EqFA: Eq[F[A]],
-                                                                    EqFB: Eq[F[B]],
-                                                                    EqFC: Eq[F[C]],
-                                                                    EqFABC: Eq[F[(A, B, C)]],
-                                                                    EqFInt: Eq[F[Int]],
-                                                                    iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFFA: Arbitrary[F[F[A]]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    CogenFA: Cogen[F[A]],
+    CogenFB: Cogen[F[B]],
+    EqFFFA: Eq[F[F[A]]],
+    EqFFA: Eq[F[F[F[A]]]],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    EqFInt: Eq[F[Int]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       def name: String = "bimonad"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(monad[A, B, C], comonad[A, B, C])
-      def props: Seq[(String, Prop)] = Seq(
-        "pure andThen extract = id" -> forAll(laws.pureExtractIsId[A] _),
-        "extract/flatMap entwining" -> forAll(laws.extractFlatMapEntwining[A] _),
-        "pure/coflatMap entwining" -> forAll(laws.pureCoflatMapEntwining[A] _)
-      )
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "pure andThen extract = id" -> forAll(laws.pureExtractIsId[A] _),
+          "extract/flatMap entwining" -> forAll(laws.extractFlatMapEntwining[A] _),
+          "pure/coflatMap entwining" -> forAll(laws.pureCoflatMapEntwining[A] _)
+        )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/BitraverseTests.scala b/laws/src/main/scala/cats/laws/discipline/BitraverseTests.scala
index a8083298d..706077f7a 100644
--- a/laws/src/main/scala/cats/laws/discipline/BitraverseTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/BitraverseTests.scala
@@ -9,31 +9,32 @@ trait BitraverseTests[F[_, _]] extends BifoldableTests[F] with BifunctorTests[F]
   def laws: BitraverseLaws[F]
 
   def bitraverse[G[_], A, B, C, D, E, H](implicit
-                                         G: Applicative[G],
-                                         C: Monoid[C],
-                                         ArbFAB: Arbitrary[F[A, B]],
-                                         ArbFAD: Arbitrary[F[A, D]],
-                                         ArbGC: Arbitrary[G[C]],
-                                         ArbGD: Arbitrary[G[D]],
-                                         ArbGE: Arbitrary[G[E]],
-                                         ArbGH: Arbitrary[G[H]],
-                                         ArbA: Arbitrary[A],
-                                         ArbB: Arbitrary[B],
-                                         ArbC: Arbitrary[C],
-                                         ArbE: Arbitrary[E],
-                                         ArbH: Arbitrary[H],
-                                         CogenA: Cogen[A],
-                                         CogenB: Cogen[B],
-                                         CogenC: Cogen[C],
-                                         CogenD: Cogen[D],
-                                         CogenE: Cogen[E],
-                                         EqFAB: Eq[F[A, B]],
-                                         EqFAD: Eq[F[A, D]],
-                                         EqFAH: Eq[F[A, H]],
-                                         EqFCD: Eq[F[C, D]],
-                                         EqFCH: Eq[F[C, H]],
-                                         EqGGFEH: Eq[G[G[F[E, H]]]],
-                                         EqC: Eq[C]): RuleSet =
+    G: Applicative[G],
+    C: Monoid[C],
+    ArbFAB: Arbitrary[F[A, B]],
+    ArbFAD: Arbitrary[F[A, D]],
+    ArbGC: Arbitrary[G[C]],
+    ArbGD: Arbitrary[G[D]],
+    ArbGE: Arbitrary[G[E]],
+    ArbGH: Arbitrary[G[H]],
+    ArbA: Arbitrary[A],
+    ArbB: Arbitrary[B],
+    ArbC: Arbitrary[C],
+    ArbE: Arbitrary[E],
+    ArbH: Arbitrary[H],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    CogenD: Cogen[D],
+    CogenE: Cogen[E],
+    EqFAB: Eq[F[A, B]],
+    EqFAD: Eq[F[A, D]],
+    EqFAH: Eq[F[A, H]],
+    EqFCD: Eq[F[C, D]],
+    EqFCH: Eq[F[C, H]],
+    EqGGFEH: Eq[G[G[F[E, H]]]],
+    EqC: Eq[C]
+  ): RuleSet =
     new RuleSet {
       val name = "bitraverse"
       val parents = Seq(bifoldable[A, B, C], bifunctor[A, B, C, D, E, H])
diff --git a/laws/src/main/scala/cats/laws/discipline/CategoryTests.scala b/laws/src/main/scala/cats/laws/discipline/CategoryTests.scala
index 013420d3d..038fa7850 100644
--- a/laws/src/main/scala/cats/laws/discipline/CategoryTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CategoryTests.scala
@@ -11,11 +11,12 @@ trait CategoryTests[F[_, _]] extends ComposeTests[F] {
   def laws: CategoryLaws[F]
 
   def category[A, B, C, D](implicit
-                           ArbFAB: Arbitrary[F[A, B]],
-                           ArbFBC: Arbitrary[F[B, C]],
-                           ArbFCD: Arbitrary[F[C, D]],
-                           EqFAB: Eq[F[A, B]],
-                           EqFAD: Eq[F[A, D]]): RuleSet =
+    ArbFAB: Arbitrary[F[A, B]],
+    ArbFBC: Arbitrary[F[B, C]],
+    ArbFCD: Arbitrary[F[C, D]],
+    EqFAB: Eq[F[A, B]],
+    EqFAD: Eq[F[A, D]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "category",
       parent = Some(compose[A, B, C, D]),
diff --git a/laws/src/main/scala/cats/laws/discipline/ChoiceTests.scala b/laws/src/main/scala/cats/laws/discipline/ChoiceTests.scala
index 97f0ebcc2..4db1af117 100644
--- a/laws/src/main/scala/cats/laws/discipline/ChoiceTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ChoiceTests.scala
@@ -10,13 +10,14 @@ trait ChoiceTests[F[_, _]] extends CategoryTests[F] {
   def laws: ChoiceLaws[F]
 
   def choice[A, B, C, D](implicit
-                         ArbFAB: Arbitrary[F[A, B]],
-                         ArbFAC: Arbitrary[F[A, C]],
-                         ArbFBC: Arbitrary[F[B, C]],
-                         ArbFCD: Arbitrary[F[C, D]],
-                         EqFAB: Eq[F[A, B]],
-                         EqFAD: Eq[F[A, D]],
-                         EqFEitherABD: Eq[F[Either[A, B], D]]): RuleSet =
+    ArbFAB: Arbitrary[F[A, B]],
+    ArbFAC: Arbitrary[F[A, C]],
+    ArbFBC: Arbitrary[F[B, C]],
+    ArbFCD: Arbitrary[F[C, D]],
+    EqFAB: Eq[F[A, B]],
+    EqFAD: Eq[F[A, D]],
+    EqFEitherABD: Eq[F[Either[A, B], D]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "choice",
       parent = Some(category[A, B, C, D]),
diff --git a/laws/src/main/scala/cats/laws/discipline/CoflatMapTests.scala b/laws/src/main/scala/cats/laws/discipline/CoflatMapTests.scala
index e9f067fe4..14c4cfbe6 100644
--- a/laws/src/main/scala/cats/laws/discipline/CoflatMapTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CoflatMapTests.scala
@@ -10,17 +10,18 @@ trait CoflatMapTests[F[_]] extends Laws with FunctorTests[F] {
   def laws: CoflatMapLaws[F]
 
   def coflatMap[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                          ArbFA: Arbitrary[F[A]],
-                                                          CogenA: Cogen[A],
-                                                          CogenB: Cogen[B],
-                                                          CogenC: Cogen[C],
-                                                          CogenFA: Cogen[F[A]],
-                                                          CogenFB: Cogen[F[B]],
-                                                          EqFA: Eq[F[A]],
-                                                          EqFC: Eq[F[C]],
-                                                          EqFFA: Eq[F[F[A]]],
-                                                          EqFB: Eq[F[B]],
-                                                          EqFFFA: Eq[F[F[F[A]]]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    CogenFA: Cogen[F[A]],
+    CogenFB: Cogen[F[B]],
+    EqFA: Eq[F[A]],
+    EqFC: Eq[F[C]],
+    EqFFA: Eq[F[F[A]]],
+    EqFB: Eq[F[B]],
+    EqFFFA: Eq[F[F[F[A]]]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "coflatMap",
       parent = Some(functor[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeApplicativeTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeApplicativeTests.scala
index 0f453416a..483e1701d 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeApplicativeTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeApplicativeTests.scala
@@ -10,20 +10,21 @@ trait CommutativeApplicativeTests[F[_]] extends CommutativeApplyTests[F] with Ap
   def laws: CommutativeApplicativeLaws[F]
 
   def commutativeApplicative[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                                   ArbFA: Arbitrary[F[A]],
-                                                                                   ArbFB: Arbitrary[F[B]],
-                                                                                   ArbFC: Arbitrary[F[C]],
-                                                                                   ArbFAtoB: Arbitrary[F[A => B]],
-                                                                                   ArbFBtoC: Arbitrary[F[B => C]],
-                                                                                   CogenA: Cogen[A],
-                                                                                   CogenB: Cogen[B],
-                                                                                   CogenC: Cogen[C],
-                                                                                   EqFA: Eq[F[A]],
-                                                                                   EqFB: Eq[F[B]],
-                                                                                   EqFC: Eq[F[C]],
-                                                                                   EqFABC: Eq[F[(A, B, C)]],
-                                                                                   EqFInt: Eq[F[Int]],
-                                                                                   iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    EqFInt: Eq[F[Int]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       def name: String = "commutative applicative"
       def bases: Seq[(String, RuleSet)] = Nil
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeApplyTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeApplyTests.scala
index 9daa9fd30..58790dfb7 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeApplyTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeApplyTests.scala
@@ -10,27 +10,29 @@ trait CommutativeApplyTests[F[_]] extends ApplyTests[F] {
   def laws: CommutativeApplyLaws[F]
 
   def commutativeApply[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                             ArbFA: Arbitrary[F[A]],
-                                                                             ArbFB: Arbitrary[F[B]],
-                                                                             ArbFC: Arbitrary[F[C]],
-                                                                             ArbFAtoB: Arbitrary[F[A => B]],
-                                                                             ArbFBtoC: Arbitrary[F[B => C]],
-                                                                             CogenA: Cogen[A],
-                                                                             CogenB: Cogen[B],
-                                                                             CogenC: Cogen[C],
-                                                                             EqFA: Eq[F[A]],
-                                                                             EqFB: Eq[F[B]],
-                                                                             EqFC: Eq[F[C]],
-                                                                             EqFABC: Eq[F[(A, B, C)]],
-                                                                             EqFInt: Eq[F[Int]],
-                                                                             iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    EqFInt: Eq[F[Int]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       def name: String = "commutative apply"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(apply[A, B, C])
-      def props: Seq[(String, Prop)] = Seq(
-        "apply commutativity" -> forAll(laws.applyCommutative[A, B, C] _)
-      )
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "apply commutativity" -> forAll(laws.applyCommutative[A, B, C] _)
+        )
     }
 
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeArrowTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeArrowTests.scala
index 53695eee3..6a9fb2853 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeArrowTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeArrowTests.scala
@@ -9,8 +9,7 @@ import Prop._
 trait CommutativeArrowTests[F[_, _]] extends ArrowTests[F] {
   def laws: CommutativeArrowLaws[F]
 
-  def commutativeArrow[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
-    implicit
+  def commutativeArrow[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFAC: Arbitrary[F[A, C]],
     ArbFBC: Arbitrary[F[B, C]],
@@ -42,7 +41,8 @@ trait CommutativeArrowTests[F[_, _]] extends ArrowTests[F] {
   ): RuleSet =
     new DefaultRuleSet(name = "commutative arrow",
                        parent = Some(arrow[A, B, C, D, E, G]),
-                       "arrow commutativity" -> forAll(laws.arrowCommutative[A, B, C, D] _))
+                       "arrow commutativity" -> forAll(laws.arrowCommutative[A, B, C, D] _)
+    )
 }
 
 object CommutativeArrowTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeFlatMapTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeFlatMapTests.scala
index 15a763b1a..f83585153 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeFlatMapTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeFlatMapTests.scala
@@ -10,27 +10,29 @@ trait CommutativeFlatMapTests[F[_]] extends FlatMapTests[F] with CommutativeAppl
   def laws: CommutativeFlatMapLaws[F]
 
   def commutativeFlatMap[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                               ArbFA: Arbitrary[F[A]],
-                                                                               ArbFB: Arbitrary[F[B]],
-                                                                               ArbFC: Arbitrary[F[C]],
-                                                                               ArbFAtoB: Arbitrary[F[A => B]],
-                                                                               ArbFBtoC: Arbitrary[F[B => C]],
-                                                                               CogenA: Cogen[A],
-                                                                               CogenB: Cogen[B],
-                                                                               CogenC: Cogen[C],
-                                                                               EqFA: Eq[F[A]],
-                                                                               EqFB: Eq[F[B]],
-                                                                               EqFC: Eq[F[C]],
-                                                                               EqFABC: Eq[F[(A, B, C)]],
-                                                                               EqFInt: Eq[F[Int]],
-                                                                               iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    EqFInt: Eq[F[Int]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       def name: String = "commutative flatMap"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(flatMap[A, B, C], commutativeApply[A, B, C])
-      def props: Seq[(String, Prop)] = Seq(
-        "flatmap commutativity" -> forAll(laws.flatmapCommutative[A, B, C] _)
-      )
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "flatmap commutativity" -> forAll(laws.flatmapCommutative[A, B, C] _)
+        )
     }
 
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/CommutativeMonadTests.scala b/laws/src/main/scala/cats/laws/discipline/CommutativeMonadTests.scala
index 3ae9a5c69..0407fc107 100644
--- a/laws/src/main/scala/cats/laws/discipline/CommutativeMonadTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/CommutativeMonadTests.scala
@@ -12,20 +12,21 @@ trait CommutativeMonadTests[F[_]]
   def laws: CommutativeMonadLaws[F]
 
   def commutativeMonad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                             ArbFA: Arbitrary[F[A]],
-                                                                             ArbFB: Arbitrary[F[B]],
-                                                                             ArbFC: Arbitrary[F[C]],
-                                                                             ArbFAtoB: Arbitrary[F[A => B]],
-                                                                             ArbFBtoC: Arbitrary[F[B => C]],
-                                                                             CogenA: Cogen[A],
-                                                                             CogenB: Cogen[B],
-                                                                             CogenC: Cogen[C],
-                                                                             EqFA: Eq[F[A]],
-                                                                             EqFB: Eq[F[B]],
-                                                                             EqFC: Eq[F[C]],
-                                                                             EqFABC: Eq[F[(A, B, C)]],
-                                                                             EqFInt: Eq[F[Int]],
-                                                                             iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    EqFInt: Eq[F[Int]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       def name: String = "commutative monad"
       def bases: Seq[(String, RuleSet)] = Nil
diff --git a/laws/src/main/scala/cats/laws/discipline/ComonadTests.scala b/laws/src/main/scala/cats/laws/discipline/ComonadTests.scala
index 9fa4c9b2a..342f39fa0 100644
--- a/laws/src/main/scala/cats/laws/discipline/ComonadTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ComonadTests.scala
@@ -10,17 +10,18 @@ trait ComonadTests[F[_]] extends CoflatMapTests[F] {
   def laws: ComonadLaws[F]
 
   def comonad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                    ArbFA: Arbitrary[F[A]],
-                                                                    CogenA: Cogen[A],
-                                                                    CogenB: Cogen[B],
-                                                                    CogenC: Cogen[C],
-                                                                    CogenFA: Cogen[F[A]],
-                                                                    CogenFB: Cogen[F[B]],
-                                                                    EqFA: Eq[F[A]],
-                                                                    EqFFA: Eq[F[F[A]]],
-                                                                    EqFFFA: Eq[F[F[F[A]]]],
-                                                                    EqFB: Eq[F[B]],
-                                                                    EqFC: Eq[F[C]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    CogenFA: Cogen[F[A]],
+    CogenFB: Cogen[F[B]],
+    EqFA: Eq[F[A]],
+    EqFFA: Eq[F[F[A]]],
+    EqFFFA: Eq[F[F[F[A]]]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "comonad",
       parent = Some(coflatMap[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/ComposeTests.scala b/laws/src/main/scala/cats/laws/discipline/ComposeTests.scala
index 335f5dfd0..ff82550a4 100644
--- a/laws/src/main/scala/cats/laws/discipline/ComposeTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ComposeTests.scala
@@ -12,13 +12,15 @@ trait ComposeTests[F[_, _]] extends Laws {
   def laws: ComposeLaws[F]
 
   def compose[A, B, C, D](implicit
-                          ArbFAB: Arbitrary[F[A, B]],
-                          ArbFBC: Arbitrary[F[B, C]],
-                          ArbFCD: Arbitrary[F[C, D]],
-                          EqFAD: Eq[F[A, D]]): RuleSet =
+    ArbFAB: Arbitrary[F[A, B]],
+    ArbFBC: Arbitrary[F[B, C]],
+    ArbFCD: Arbitrary[F[C, D]],
+    EqFAD: Eq[F[A, D]]
+  ): RuleSet =
     new DefaultRuleSet(name = "compose",
                        parent = None,
-                       "compose associativity" -> forAll(laws.composeAssociativity[A, B, C, D] _))
+                       "compose associativity" -> forAll(laws.composeAssociativity[A, B, C, D] _)
+    )
 }
 
 object ComposeTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/ContravariantMonoidalTests.scala b/laws/src/main/scala/cats/laws/discipline/ContravariantMonoidalTests.scala
index bf5c9101c..171875e1e 100644
--- a/laws/src/main/scala/cats/laws/discipline/ContravariantMonoidalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ContravariantMonoidalTests.scala
@@ -11,17 +11,18 @@ trait ContravariantMonoidalTests[F[_]] extends ContravariantSemigroupalTests[F]
   def laws: ContravariantMonoidalLaws[F]
 
   def contravariantMonoidal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                                      arbFA: Arbitrary[F[A]],
-                                                                      arbFB: Arbitrary[F[B]],
-                                                                      arbFC: Arbitrary[F[C]],
-                                                                      CogenA: Cogen[A],
-                                                                      CogenB: Cogen[B],
-                                                                      CogenC: Cogen[C],
-                                                                      EqFA: Eq[F[A]],
-                                                                      EqFB: Eq[F[B]],
-                                                                      EqFC: Eq[F[C]],
-                                                                      EqFABC: Eq[F[(A, B, C)]],
-                                                                      iso: Isomorphisms[F]): RuleSet =
+    arbFA: Arbitrary[F[A]],
+    arbFB: Arbitrary[F[B]],
+    arbFC: Arbitrary[F[C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       val name = "contravariantMonoidal"
       val parents = Seq(contravariantSemigroupal[A, B, C])
diff --git a/laws/src/main/scala/cats/laws/discipline/ContravariantSemigroupalTests.scala b/laws/src/main/scala/cats/laws/discipline/ContravariantSemigroupalTests.scala
index 539440959..47bbdc0df 100644
--- a/laws/src/main/scala/cats/laws/discipline/ContravariantSemigroupalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ContravariantSemigroupalTests.scala
@@ -11,17 +11,18 @@ trait ContravariantSemigroupalTests[F[_]] extends ContravariantTests[F] with Sem
   def laws: ContravariantSemigroupalLaws[F]
 
   def contravariantSemigroupal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                                         arbFA: Arbitrary[F[A]],
-                                                                         arbFB: Arbitrary[F[B]],
-                                                                         arbFC: Arbitrary[F[C]],
-                                                                         CogenA: Cogen[A],
-                                                                         CogenB: Cogen[B],
-                                                                         CogenC: Cogen[C],
-                                                                         EqFA: Eq[F[A]],
-                                                                         EqFB: Eq[F[B]],
-                                                                         EqFC: Eq[F[C]],
-                                                                         EqFABC: Eq[F[(A, B, C)]],
-                                                                         iso: Isomorphisms[F]): RuleSet =
+    arbFA: Arbitrary[F[A]],
+    arbFB: Arbitrary[F[B]],
+    arbFC: Arbitrary[F[C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       val name = "contravariantSemigroupal"
       val parents = Seq(contravariant[A, B, C], semigroupal[A, B, C])
diff --git a/laws/src/main/scala/cats/laws/discipline/ContravariantTests.scala b/laws/src/main/scala/cats/laws/discipline/ContravariantTests.scala
index 35be0addc..cd0d72d64 100644
--- a/laws/src/main/scala/cats/laws/discipline/ContravariantTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ContravariantTests.scala
@@ -10,12 +10,13 @@ trait ContravariantTests[F[_]] extends InvariantTests[F] {
   def laws: ContravariantLaws[F]
 
   def contravariant[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                              ArbFA: Arbitrary[F[A]],
-                                                              CogenA: Cogen[A],
-                                                              CogenB: Cogen[B],
-                                                              CogenC: Cogen[C],
-                                                              EqFA: Eq[F[A]],
-                                                              EqFC: Eq[F[C]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFC: Eq[F[C]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "contravariant",
       parent = Some(invariant[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/DeferTests.scala b/laws/src/main/scala/cats/laws/discipline/DeferTests.scala
index d90bf8719..be07b4719 100644
--- a/laws/src/main/scala/cats/laws/discipline/DeferTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/DeferTests.scala
@@ -9,10 +9,7 @@ import org.typelevel.discipline.Laws
 trait DeferTests[F[_]] extends Laws {
   def laws: DeferLaws[F]
 
-  def defer[A: Arbitrary](implicit
-                          ArbFA: Arbitrary[F[A]],
-                          EqFA: Eq[F[A]],
-                          EqBool: Eq[Boolean]): RuleSet =
+  def defer[A: Arbitrary](implicit ArbFA: Arbitrary[F[A]], EqFA: Eq[F[A]], EqBool: Eq[Boolean]): RuleSet =
     new DefaultRuleSet(
       name = "defer",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/DistributiveTests.scala b/laws/src/main/scala/cats/laws/discipline/DistributiveTests.scala
index 5f7da0243..66546831c 100644
--- a/laws/src/main/scala/cats/laws/discipline/DistributiveTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/DistributiveTests.scala
@@ -8,8 +8,7 @@ import Prop._
 trait DistributiveTests[F[_]] extends FunctorTests[F] {
   def laws: DistributiveLaws[F]
 
-  def distributive[A: Arbitrary, B: Arbitrary, C: Arbitrary, X[_]: Functor, Y[_]: Distributive](
-    implicit
+  def distributive[A: Arbitrary, B: Arbitrary, C: Arbitrary, X[_]: Functor, Y[_]: Distributive](implicit
     ArbFA: Arbitrary[F[A]],
     ArbFB: Arbitrary[F[B]],
     ArbXA: Arbitrary[X[A]],
@@ -30,12 +29,13 @@ trait DistributiveTests[F[_]] extends FunctorTests[F] {
       def name: String = "distributive"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(functor[A, B, C])
-      def props: Seq[(String, Prop)] = Seq(
-        "distributive distribute identity" -> forAll(laws.distributeIdentity[A, B] _),
-        "distributive identity" -> forAll(laws.cosequenceIdentity[A] _),
-        "distributive composition" -> forAll(laws.composition[A, B, C, X, Y] _),
-        "distributive double cosequence identity" -> forAll(laws.cosequenceTwiceIsId[A, Y] _)
-      )
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "distributive distribute identity" -> forAll(laws.distributeIdentity[A, B] _),
+          "distributive identity" -> forAll(laws.cosequenceIdentity[A] _),
+          "distributive composition" -> forAll(laws.composition[A, B, C, X, Y] _),
+          "distributive double cosequence identity" -> forAll(laws.cosequenceTwiceIsId[A, Y] _)
+        )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/Eq.scala b/laws/src/main/scala/cats/laws/discipline/Eq.scala
index 9e3c3dbe5..e2938add4 100644
--- a/laws/src/main/scala/cats/laws/discipline/Eq.scala
+++ b/laws/src/main/scala/cats/laws/discipline/Eq.scala
@@ -37,8 +37,8 @@ object eq {
   implicit def catsLawsEqForPartialOrder[A](implicit ev: Eq[(A, A) => Option[Int]]): Eq[PartialOrder[A]] =
     Eq.by[PartialOrder[A], (A, A) => Option[Int]](o => (a1, a2) => o.tryCompare(a1, a2))
 
-  implicit def catsLawsEqForPartialOrdering[A](
-    implicit ev: Eq[(A, A) => Option[Int]]
+  implicit def catsLawsEqForPartialOrdering[A](implicit
+    ev: Eq[(A, A) => Option[Int]]
   ): Eq[PartialOrdering[A]] =
     Eq.by[PartialOrdering[A], (A, A) => Option[Int]]((o: PartialOrdering[A]) => (a1, a2) => o.tryCompare(a1, a2))
 
@@ -54,8 +54,10 @@ object eq {
   implicit def catsLawsEqForSemigroup[A](implicit ev: Eq[(A, A) => A]): Eq[Semigroup[A]] =
     Eq.by[Semigroup[A], (A, A) => A](s => (a1, a2) => s.combine(a1, a2))
 
-  implicit def catsLawsEqForCommutativeSemigroup[A](implicit eqA: Eq[A],
-                                                    ev: Eq[(A, A) => (A, A)]): Eq[CommutativeSemigroup[A]] =
+  implicit def catsLawsEqForCommutativeSemigroup[A](implicit
+    eqA: Eq[A],
+    ev: Eq[(A, A) => (A, A)]
+  ): Eq[CommutativeSemigroup[A]] =
     Eq.by[CommutativeSemigroup[A], (A, A) => (A, A)](s => (x, y) => (s.combine(x, y), s.combine(y, x)))
 
   implicit def catsLawsEqForBand[A](implicit ev: Eq[(A, A) => (A, A)]): Eq[Band[A]] =
@@ -72,33 +74,44 @@ object eq {
         )
     )
 
-  implicit def catsLawsEqForMonoid[A](implicit eqSA: Eq[Semigroup[A]], eqA: Eq[A]): Eq[Monoid[A]] = new Eq[Monoid[A]] {
-    def eqv(f: Monoid[A], g: Monoid[A]): Boolean =
-      eqSA.eqv(f, g) && eqA.eqv(f.empty, g.empty)
-  }
+  implicit def catsLawsEqForMonoid[A](implicit eqSA: Eq[Semigroup[A]], eqA: Eq[A]): Eq[Monoid[A]] =
+    new Eq[Monoid[A]] {
+      def eqv(f: Monoid[A], g: Monoid[A]): Boolean =
+        eqSA.eqv(f, g) && eqA.eqv(f.empty, g.empty)
+    }
 
-  implicit def catsLawsEqForSemilattice[A](implicit eqBA: Eq[Band[A]],
-                                           eqCA: Eq[CommutativeSemigroup[A]],
-                                           eqA: Eq[A]): Eq[Semilattice[A]] =
+  implicit def catsLawsEqForSemilattice[A](implicit
+    eqBA: Eq[Band[A]],
+    eqCA: Eq[CommutativeSemigroup[A]],
+    eqA: Eq[A]
+  ): Eq[Semilattice[A]] =
     Eq.instance((f, g) => eqBA.eqv(f, g) && eqCA.eqv(f, g))
 
-  implicit def catsLawsEqForCommutativeMonoid[A](implicit eqSA: Eq[CommutativeSemigroup[A]],
-                                                 eqMA: Eq[Monoid[A]],
-                                                 eqA: Eq[A]): Eq[CommutativeMonoid[A]] =
+  implicit def catsLawsEqForCommutativeMonoid[A](implicit
+    eqSA: Eq[CommutativeSemigroup[A]],
+    eqMA: Eq[Monoid[A]],
+    eqA: Eq[A]
+  ): Eq[CommutativeMonoid[A]] =
     Eq.instance((f, g) => eqSA.eqv(f, g) && eqMA.eqv(f, g))
 
-  implicit def catsLawsEqForBoundedSemilattice[A](implicit eqSA: Eq[Semilattice[A]],
-                                                  eqCA: Eq[CommutativeMonoid[A]],
-                                                  eqA: Eq[A]): Eq[BoundedSemilattice[A]] =
+  implicit def catsLawsEqForBoundedSemilattice[A](implicit
+    eqSA: Eq[Semilattice[A]],
+    eqCA: Eq[CommutativeMonoid[A]],
+    eqA: Eq[A]
+  ): Eq[BoundedSemilattice[A]] =
     Eq.instance((f, g) => eqSA.eqv(f, g) && eqCA.eqv(f, g))
 
-  implicit def catsLawsEqForCommutativeGroup[A](implicit eqMA: Eq[CommutativeMonoid[A]],
-                                                eqGA: Eq[Group[A]],
-                                                eqA: Eq[A]): Eq[CommutativeGroup[A]] =
+  implicit def catsLawsEqForCommutativeGroup[A](implicit
+    eqMA: Eq[CommutativeMonoid[A]],
+    eqGA: Eq[Group[A]],
+    eqA: Eq[A]
+  ): Eq[CommutativeGroup[A]] =
     Eq.instance((f, g) => eqMA.eqv(f, g) && eqGA.eqv(f, g))
 
-  implicit def catsLawsEqForRepresentableStore[F[_]: Representable, S, A](implicit eqFA: Eq[F[A]],
-                                                                          eqS: Eq[S]): Eq[RepresentableStore[F, S, A]] =
+  implicit def catsLawsEqForRepresentableStore[F[_]: Representable, S, A](implicit
+    eqFA: Eq[F[A]],
+    eqS: Eq[S]
+  ): Eq[RepresentableStore[F, S, A]] =
     Eq.instance((s1, s2) => eqFA.eqv(s1.fa, s2.fa) && eqS.eqv(s1.index, s2.index))
 }
 
@@ -115,17 +128,18 @@ object eq {
     "This instance is problematic and will most likely be removed in a future version of Cats. Use catsLawsEqForFn1Exhaustive instead. See https://github.com/typelevel/cats/pull/2577 for more information.",
     "1.7"
   )
-  implicit def catsLawsEqForFn1[A, B](implicit A: Arbitrary[A], B: Eq[B]): Eq[A => B] = new Eq[A => B] {
-    val sampleCnt: Int = if (Platform.isJvm) 50 else 30
-
-    def eqv(f: A => B, g: A => B): Boolean = {
-      val samples = List.fill(sampleCnt)(A.arbitrary.sample).collect {
-        case Some(a) => a
-        case None    => sys.error("Could not generate arbitrary values to compare two functions")
+  implicit def catsLawsEqForFn1[A, B](implicit A: Arbitrary[A], B: Eq[B]): Eq[A => B] =
+    new Eq[A => B] {
+      val sampleCnt: Int = if (Platform.isJvm) 50 else 30
+
+      def eqv(f: A => B, g: A => B): Boolean = {
+        val samples = List.fill(sampleCnt)(A.arbitrary.sample).collect {
+          case Some(a) => a
+          case None    => sys.error("Could not generate arbitrary values to compare two functions")
+        }
+        samples.forall(s => B.eqv(f(s), g(s)))
       }
-      samples.forall(s => B.eqv(f(s), g(s)))
     }
-  }
 
   /**
    * Create an approximation of Eq[(A, B) => C] by generating random values for A and B
@@ -167,12 +181,16 @@ object eq {
   implicit def catsLawsEqForEquiv[A](implicit arbA: Arbitrary[(A, A)]): Eq[Equiv[A]] =
     sampledEq[Equiv[A], (A, A), Boolean](100) { case (e, (l, r)) => e.equiv(l, r) }
 
-  implicit def catsLawsEqForPartialOrder[A](implicit arbA: Arbitrary[(A, A)],
-                                            optIntEq: Eq[Option[Int]]): Eq[PartialOrder[A]] =
+  implicit def catsLawsEqForPartialOrder[A](implicit
+    arbA: Arbitrary[(A, A)],
+    optIntEq: Eq[Option[Int]]
+  ): Eq[PartialOrder[A]] =
     sampledEq[PartialOrder[A], (A, A), Option[Int]](100) { case (p, (l, r)) => p.tryCompare(l, r) }
 
-  implicit def catsLawsEqForPartialOrdering[A](implicit arbA: Arbitrary[(A, A)],
-                                               optIntEq: Eq[Option[Int]]): Eq[PartialOrdering[A]] =
+  implicit def catsLawsEqForPartialOrdering[A](implicit
+    arbA: Arbitrary[(A, A)],
+    optIntEq: Eq[Option[Int]]
+  ): Eq[PartialOrdering[A]] =
     sampledEq[PartialOrdering[A], (A, A), Option[Int]](100) { case (p, (l, r)) => p.tryCompare(l, r) }
 
   implicit def catsLawsEqForOrder[A](implicit arbA: Arbitrary[(A, A)]): Eq[Order[A]] =
@@ -185,17 +203,18 @@ object eq {
    * Creates an approximation of Eq[Hash[A]] by generating 100 values for A
    * and comparing the application of the two hash functions.
    */
-  implicit def catsLawsEqForHash[A](implicit arbA: Arbitrary[A]): Eq[Hash[A]] = new Eq[Hash[A]] {
-    def eqv(f: Hash[A], g: Hash[A]): Boolean = {
-      val samples = List.fill(100)(arbA.arbitrary.sample).collect {
-        case Some(a) => a
-        case None    => sys.error("Could not generate arbitrary values to compare two Hash[A]")
-      }
-      samples.forall { x =>
-        f.hash(x) == g.hash(x)
+  implicit def catsLawsEqForHash[A](implicit arbA: Arbitrary[A]): Eq[Hash[A]] =
+    new Eq[Hash[A]] {
+      def eqv(f: Hash[A], g: Hash[A]): Boolean = {
+        val samples = List.fill(100)(arbA.arbitrary.sample).collect {
+          case Some(a) => a
+          case None    => sys.error("Could not generate arbitrary values to compare two Hash[A]")
+        }
+        samples.forall { x =>
+          f.hash(x) == g.hash(x)
+        }
       }
     }
-  }
 
   /**
    * Create an approximation of Eq[Semigroup[A]] by generating values for A
@@ -206,8 +225,10 @@ object eq {
     Eq.by[Semigroup[A], ((A, A)) => A](f => Function.tupled((x, y) => f.combine(x, y)))(instance)
   }
 
-  implicit def catsLawsEqForCommutativeSemigroup[A](implicit arbAA: Arbitrary[(A, A)],
-                                                    eqA: Eq[A]): Eq[CommutativeSemigroup[A]] = {
+  implicit def catsLawsEqForCommutativeSemigroup[A](implicit
+    arbAA: Arbitrary[(A, A)],
+    eqA: Eq[A]
+  ): Eq[CommutativeSemigroup[A]] = {
     implicit val eqABool: Eq[(A, Boolean)] = Eq.instance {
       case ((x, boolX), (y, boolY)) => x === y && boolX === boolY
     }
@@ -217,16 +238,20 @@ object eq {
     )(catsLawsEqForFn1[(A, A), (A, Boolean)])
   }
 
-  implicit def catsLawsEqForBand[A](implicit arbAA: Arbitrary[(A, A)],
-                                    eqSA: Eq[Semigroup[A]],
-                                    eqA: Eq[A]): Eq[Band[A]] =
+  implicit def catsLawsEqForBand[A](implicit
+    arbAA: Arbitrary[(A, A)],
+    eqSA: Eq[Semigroup[A]],
+    eqA: Eq[A]
+  ): Eq[Band[A]] =
     Eq.by[Band[A], ((A, A)) => Boolean](f =>
       Function.tupled((x, y) => f.combine(x, y) === f.combine(f.combine(x, y), y))
     )(catsLawsEqForFn1[(A, A), Boolean])
 
-  implicit def catsLawsEqForGroup[A](implicit arbAA: Arbitrary[(A, A)],
-                                     eqMA: Eq[Monoid[A]],
-                                     eqA: Eq[A]): Eq[Group[A]] = {
+  implicit def catsLawsEqForGroup[A](implicit
+    arbAA: Arbitrary[(A, A)],
+    eqMA: Eq[Monoid[A]],
+    eqA: Eq[A]
+  ): Eq[Group[A]] = {
     implicit val eqABool: Eq[(A, Boolean)] = Eq.instance {
       case ((x, boolX), (y, boolY)) => x === y && boolX === boolY
     }
diff --git a/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala b/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
index 3c3d398d3..f821f0cdb 100644
--- a/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ExhaustiveCheck.scala
@@ -14,9 +14,10 @@ trait ExhaustiveCheck[A] extends Serializable { self =>
 object ExhaustiveCheck {
   def apply[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[A] = A
 
-  def instance[A](values: List[A]): ExhaustiveCheck[A] = new ExhaustiveCheck[A] {
-    val allValues: List[A] = values
-  }
+  def instance[A](values: List[A]): ExhaustiveCheck[A] =
+    new ExhaustiveCheck[A] {
+      val allValues: List[A] = values
+    }
 
   implicit val catsLawsExhaustiveCheckForBoolean: ExhaustiveCheck[Boolean] =
     instance(List(false, true))
@@ -27,16 +28,20 @@ object ExhaustiveCheck {
   /**
    * Warning: the domain of (A, B) is the cross-product of the domain of `A` and the domain of `B`.
    */
-  implicit def catsLawsExhaustiveCheckForTuple2[A, B](implicit A: ExhaustiveCheck[A],
-                                                      B: ExhaustiveCheck[B]): ExhaustiveCheck[(A, B)] =
+  implicit def catsLawsExhaustiveCheckForTuple2[A, B](implicit
+    A: ExhaustiveCheck[A],
+    B: ExhaustiveCheck[B]
+  ): ExhaustiveCheck[(A, B)] =
     instance(A.allValues.flatMap(a => B.allValues.map(b => (a, b))))
 
   /**
    * Warning: the domain of (A, B, C) is the cross-product of the 3 domains.
    */
-  implicit def catsLawsExhaustiveCheckForTuple3[A, B, C](implicit A: ExhaustiveCheck[A],
-                                                         B: ExhaustiveCheck[B],
-                                                         C: ExhaustiveCheck[C]): ExhaustiveCheck[(A, B, C)] =
+  implicit def catsLawsExhaustiveCheckForTuple3[A, B, C](implicit
+    A: ExhaustiveCheck[A],
+    B: ExhaustiveCheck[B],
+    C: ExhaustiveCheck[C]
+  ): ExhaustiveCheck[(A, B, C)] =
     instance(
       for {
         a <- A.allValues
@@ -45,8 +50,10 @@ object ExhaustiveCheck {
       } yield (a, b, c)
     )
 
-  implicit def catsLawsExhaustiveCheckForEither[A, B](implicit A: ExhaustiveCheck[A],
-                                                      B: ExhaustiveCheck[B]): ExhaustiveCheck[Either[A, B]] =
+  implicit def catsLawsExhaustiveCheckForEither[A, B](implicit
+    A: ExhaustiveCheck[A],
+    B: ExhaustiveCheck[B]
+  ): ExhaustiveCheck[Either[A, B]] =
     instance(A.allValues.map(Left(_)) ++ B.allValues.map(Right(_)))
 
   implicit def catsLawsExhaustiveCheckForOption[A](implicit A: ExhaustiveCheck[A]): ExhaustiveCheck[Option[A]] =
diff --git a/laws/src/main/scala/cats/laws/discipline/FlatMapTests.scala b/laws/src/main/scala/cats/laws/discipline/FlatMapTests.scala
index 57a9f1760..4a91d99fc 100644
--- a/laws/src/main/scala/cats/laws/discipline/FlatMapTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/FlatMapTests.scala
@@ -12,19 +12,20 @@ trait FlatMapTests[F[_]] extends ApplyTests[F] {
   def laws: FlatMapLaws[F]
 
   def flatMap[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                        ArbFA: Arbitrary[F[A]],
-                                                        ArbFB: Arbitrary[F[B]],
-                                                        ArbFC: Arbitrary[F[C]],
-                                                        ArbFAtoB: Arbitrary[F[A => B]],
-                                                        ArbFBtoC: Arbitrary[F[B => C]],
-                                                        CogenA: Cogen[A],
-                                                        CogenB: Cogen[B],
-                                                        CogenC: Cogen[C],
-                                                        EqFA: Eq[F[A]],
-                                                        EqFB: Eq[F[B]],
-                                                        EqFC: Eq[F[C]],
-                                                        EqFABC: Eq[F[(A, B, C)]],
-                                                        iso: Isomorphisms[F]): RuleSet = {
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    iso: Isomorphisms[F]
+  ): RuleSet = {
     implicit def functorF: Functor[F] = laws.F
     implicit val EqFAB: Eq[F[(A, B)]] =
       ContravariantSemigroupal[Eq].composeFunctor[F].product(EqFA, EqFB)
diff --git a/laws/src/main/scala/cats/laws/discipline/FoldableTests.scala b/laws/src/main/scala/cats/laws/discipline/FoldableTests.scala
index 2689fad9d..b2b97df2e 100644
--- a/laws/src/main/scala/cats/laws/discipline/FoldableTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/FoldableTests.scala
@@ -12,16 +12,17 @@ trait FoldableTests[F[_]] extends UnorderedFoldableTests[F] {
   def laws: FoldableLaws[F]
 
   def foldable[A: Arbitrary, B: Arbitrary](implicit
-                                           ArbFA: Arbitrary[F[A]],
-                                           A: CommutativeMonoid[A],
-                                           B: CommutativeMonoid[B],
-                                           CogenA: Cogen[A],
-                                           CogenB: Cogen[B],
-                                           EqA: Eq[A],
-                                           EqFA: Eq[F[A]],
-                                           EqB: Eq[B],
-                                           EqOptionB: Eq[Option[B]],
-                                           EqOptionA: Eq[Option[A]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    A: CommutativeMonoid[A],
+    B: CommutativeMonoid[B],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    EqA: Eq[A],
+    EqFA: Eq[F[A]],
+    EqB: Eq[B],
+    EqOptionB: Eq[Option[B]],
+    EqOptionA: Eq[Option[A]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "foldable",
       parent = Some(unorderedFoldable[A, B]),
diff --git a/laws/src/main/scala/cats/laws/discipline/FunctorFilterTests.scala b/laws/src/main/scala/cats/laws/discipline/FunctorFilterTests.scala
index f5c154d19..be33e0be8 100644
--- a/laws/src/main/scala/cats/laws/discipline/FunctorFilterTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/FunctorFilterTests.scala
@@ -10,16 +10,17 @@ trait FunctorFilterTests[F[_]] extends Laws {
   def laws: FunctorFilterLaws[F]
 
   def functorFilter[A, B, C](implicit
-                             ArbFA: Arbitrary[F[A]],
-                             ArbFABoo: Arbitrary[PartialFunction[A, B]],
-                             ArbFOA: Arbitrary[F[Option[A]]],
-                             ArbAOB: Arbitrary[A => Option[B]],
-                             ArbBOC: Arbitrary[B => Option[C]],
-                             ArbAB: Arbitrary[A => B],
-                             ArbABoo: Arbitrary[A => Boolean],
-                             EqFA: Eq[F[A]],
-                             EqFB: Eq[F[B]],
-                             EqFC: Eq[F[C]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFABoo: Arbitrary[PartialFunction[A, B]],
+    ArbFOA: Arbitrary[F[Option[A]]],
+    ArbAOB: Arbitrary[A => Option[B]],
+    ArbBOC: Arbitrary[B => Option[C]],
+    ArbAB: Arbitrary[A => B],
+    ArbABoo: Arbitrary[A => Boolean],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "functorFilter",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/FunctorTests.scala b/laws/src/main/scala/cats/laws/discipline/FunctorTests.scala
index 7cf0d085a..c751475ea 100644
--- a/laws/src/main/scala/cats/laws/discipline/FunctorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/FunctorTests.scala
@@ -9,12 +9,13 @@ trait FunctorTests[F[_]] extends InvariantTests[F] {
   def laws: FunctorLaws[F]
 
   def functor[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                        ArbFA: Arbitrary[F[A]],
-                                                        CogenA: Cogen[A],
-                                                        CogenB: Cogen[B],
-                                                        CogenC: Cogen[C],
-                                                        EqFA: Eq[F[A]],
-                                                        EqFC: Eq[F[C]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFC: Eq[F[C]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "functor",
       parent = Some(invariant[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/InjectKTests.scala b/laws/src/main/scala/cats/laws/discipline/InjectKTests.scala
index a2f0b5004..a6eed7fe6 100644
--- a/laws/src/main/scala/cats/laws/discipline/InjectKTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InjectKTests.scala
@@ -11,10 +11,11 @@ trait InjectKTests[F[_], G[_]] extends Laws {
   def laws: InjectKLaws[F, G]
 
   def injectK[A](implicit
-                 ArbFA: Arbitrary[F[A]],
-                 EqOptionFA: Eq[Option[F[A]]],
-                 ArbGA: Arbitrary[G[A]],
-                 EqOptionGA: Eq[Option[G[A]]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    EqOptionFA: Eq[Option[F[A]]],
+    ArbGA: Arbitrary[G[A]],
+    EqOptionGA: Eq[Option[G[A]]]
+  ): RuleSet =
     new DefaultRuleSet(
       "injectK",
       None,
diff --git a/laws/src/main/scala/cats/laws/discipline/InjectTests.scala b/laws/src/main/scala/cats/laws/discipline/InjectTests.scala
index 3f3f00160..8619d84cb 100644
--- a/laws/src/main/scala/cats/laws/discipline/InjectTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InjectTests.scala
@@ -11,10 +11,11 @@ trait InjectTests[A, B] extends Laws {
   def laws: InjectLaws[A, B]
 
   def inject(implicit
-             ArbA: Arbitrary[A],
-             EqOptionA: Eq[Option[A]],
-             ArbB: Arbitrary[B],
-             EqOptionB: Eq[Option[B]]): RuleSet =
+    ArbA: Arbitrary[A],
+    EqOptionA: Eq[Option[A]],
+    ArbB: Arbitrary[B],
+    EqOptionB: Eq[Option[B]]
+  ): RuleSet =
     new DefaultRuleSet(
       "inject",
       None,
diff --git a/laws/src/main/scala/cats/laws/discipline/InvariantMonoidalTests.scala b/laws/src/main/scala/cats/laws/discipline/InvariantMonoidalTests.scala
index 5c1b7bad5..fda5324ee 100644
--- a/laws/src/main/scala/cats/laws/discipline/InvariantMonoidalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InvariantMonoidalTests.scala
@@ -10,18 +10,19 @@ trait InvariantMonoidalTests[F[_]] extends InvariantSemigroupalTests[F] {
   def laws: InvariantMonoidalLaws[F]
 
   def invariantMonoidal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                                  ArbFA: Arbitrary[F[A]],
-                                                                  ArbFB: Arbitrary[F[B]],
-                                                                  ArbFC: Arbitrary[F[C]],
-                                                                  CogenA: Cogen[A],
-                                                                  CogenB: Cogen[B],
-                                                                  CogenC: Cogen[C],
-                                                                  EqFABC: Eq[F[(A, (B, C))]],
-                                                                  EqFABC2: Eq[F[(A, B, C)]],
-                                                                  iso: Isomorphisms[F],
-                                                                  EqFA: Eq[F[A]],
-                                                                  EqFB: Eq[F[B]],
-                                                                  EqFC: Eq[F[C]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFABC: Eq[F[(A, (B, C))]],
+    EqFABC2: Eq[F[(A, B, C)]],
+    iso: Isomorphisms[F],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]]
+  ): RuleSet =
     new RuleSet {
       val name = "invariantMonoidal"
       val parents = Seq(invariantSemigroupal[A, B, C])
diff --git a/laws/src/main/scala/cats/laws/discipline/InvariantSemigroupalTests.scala b/laws/src/main/scala/cats/laws/discipline/InvariantSemigroupalTests.scala
index 3305b07c8..4717d27bd 100644
--- a/laws/src/main/scala/cats/laws/discipline/InvariantSemigroupalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InvariantSemigroupalTests.scala
@@ -10,27 +10,29 @@ trait InvariantSemigroupalTests[F[_]] extends InvariantTests[F] with Semigroupal
   def laws: InvariantSemigroupalLaws[F]
 
   def invariantSemigroupal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                                     arbFA: Arbitrary[F[A]],
-                                                                     arbFB: Arbitrary[F[B]],
-                                                                     arbFC: Arbitrary[F[C]],
-                                                                     CogenA: Cogen[A],
-                                                                     CogenB: Cogen[B],
-                                                                     CogenC: Cogen[C],
-                                                                     EqFA: Eq[F[A]],
-                                                                     EqFB: Eq[F[B]],
-                                                                     EqFC: Eq[F[C]],
-                                                                     EqFABC: Eq[F[(A, (B, C))]],
-                                                                     EqFABC2: Eq[F[(A, B, C)]],
-                                                                     iso: Isomorphisms[F]): RuleSet = new RuleSet {
-    val name = "invariantSemigroupal"
-    val parents = Seq(invariant[A, B, C], semigroupal[A, B, C])
-    val bases = Nil
-    val props = Seq(
-      "invariant semigroupal associativity" -> forAll((fa: F[A], fb: F[B], fc: F[C]) =>
-        laws.invariantSemigroupalAssociativity(fa, fb, fc)
+    arbFA: Arbitrary[F[A]],
+    arbFB: Arbitrary[F[B]],
+    arbFC: Arbitrary[F[C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, (B, C))]],
+    EqFABC2: Eq[F[(A, B, C)]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
+    new RuleSet {
+      val name = "invariantSemigroupal"
+      val parents = Seq(invariant[A, B, C], semigroupal[A, B, C])
+      val bases = Nil
+      val props = Seq(
+        "invariant semigroupal associativity" -> forAll((fa: F[A], fb: F[B], fc: F[C]) =>
+          laws.invariantSemigroupalAssociativity(fa, fb, fc)
+        )
       )
-    )
-  }
+    }
 }
 
 object InvariantSemigroupalTests {
diff --git a/laws/src/main/scala/cats/laws/discipline/InvariantTests.scala b/laws/src/main/scala/cats/laws/discipline/InvariantTests.scala
index 4594eed29..14dbc2441 100644
--- a/laws/src/main/scala/cats/laws/discipline/InvariantTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/InvariantTests.scala
@@ -11,12 +11,13 @@ trait InvariantTests[F[_]] extends Laws {
   def laws: InvariantLaws[F]
 
   def invariant[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                          ArbFA: Arbitrary[F[A]],
-                                                          CogenA: Cogen[A],
-                                                          CogenB: Cogen[B],
-                                                          CogenC: Cogen[C],
-                                                          EqFA: Eq[F[A]],
-                                                          EqFC: Eq[F[C]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFC: Eq[F[C]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "invariant",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/MonadErrorTests.scala b/laws/src/main/scala/cats/laws/discipline/MonadErrorTests.scala
index 009a78afb..8673fb7b1 100644
--- a/laws/src/main/scala/cats/laws/discipline/MonadErrorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/MonadErrorTests.scala
@@ -11,40 +11,42 @@ trait MonadErrorTests[F[_], E] extends ApplicativeErrorTests[F, E] with MonadTes
   def laws: MonadErrorLaws[F, E]
 
   def monadError[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                       ArbFA: Arbitrary[F[A]],
-                                                                       ArbFB: Arbitrary[F[B]],
-                                                                       ArbFC: Arbitrary[F[C]],
-                                                                       ArbFU: Arbitrary[F[Unit]],
-                                                                       ArbFAtoB: Arbitrary[F[A => B]],
-                                                                       ArbFBtoC: Arbitrary[F[B => C]],
-                                                                       ArbE: Arbitrary[E],
-                                                                       CogenA: Cogen[A],
-                                                                       CogenB: Cogen[B],
-                                                                       CogenC: Cogen[C],
-                                                                       CogenE: Cogen[E],
-                                                                       EqFA: Eq[F[A]],
-                                                                       EqFB: Eq[F[B]],
-                                                                       EqFC: Eq[F[C]],
-                                                                       EqE: Eq[E],
-                                                                       EqFEitherEU: Eq[F[Either[E, Unit]]],
-                                                                       EqFEitherEA: Eq[F[Either[E, A]]],
-                                                                       EqEitherTFEA: Eq[EitherT[F, E, A]],
-                                                                       EqFABC: Eq[F[(A, B, C)]],
-                                                                       EqFInt: Eq[F[Int]],
-                                                                       iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFU: Arbitrary[F[Unit]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    ArbE: Arbitrary[E],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    CogenE: Cogen[E],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqE: Eq[E],
+    EqFEitherEU: Eq[F[Either[E, Unit]]],
+    EqFEitherEA: Eq[F[Either[E, A]]],
+    EqEitherTFEA: Eq[EitherT[F, E, A]],
+    EqFABC: Eq[F[(A, B, C)]],
+    EqFInt: Eq[F[Int]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       def name: String = "monadError"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(applicativeError[A, B, C], monad[A, B, C])
-      def props: Seq[(String, Prop)] = Seq(
-        "monadError left zero" -> forAll(laws.monadErrorLeftZero[A, B] _),
-        "monadError ensure consistency" -> forAll(laws.monadErrorEnsureConsistency[A] _),
-        "monadError ensureOr consistency" -> forAll(laws.monadErrorEnsureOrConsistency[A] _),
-        "monadError rethrow attempt" -> forAll(laws.rethrowAttempt[A] _),
-        "monadError redeemWith is derived from attempt and flatMap" -> forAll(
-          laws.redeemWithDerivedFromAttemptFlatMap[A, B] _
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "monadError left zero" -> forAll(laws.monadErrorLeftZero[A, B] _),
+          "monadError ensure consistency" -> forAll(laws.monadErrorEnsureConsistency[A] _),
+          "monadError ensureOr consistency" -> forAll(laws.monadErrorEnsureOrConsistency[A] _),
+          "monadError rethrow attempt" -> forAll(laws.rethrowAttempt[A] _),
+          "monadError redeemWith is derived from attempt and flatMap" -> forAll(
+            laws.redeemWithDerivedFromAttemptFlatMap[A, B] _
+          )
         )
-      )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/MonadTests.scala b/laws/src/main/scala/cats/laws/discipline/MonadTests.scala
index aeee404f3..82459d34d 100644
--- a/laws/src/main/scala/cats/laws/discipline/MonadTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/MonadTests.scala
@@ -11,20 +11,21 @@ trait MonadTests[F[_]] extends ApplicativeTests[F] with FlatMapTests[F] {
   def laws: MonadLaws[F]
 
   def monad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                  ArbFA: Arbitrary[F[A]],
-                                                                  ArbFB: Arbitrary[F[B]],
-                                                                  ArbFC: Arbitrary[F[C]],
-                                                                  ArbFAtoB: Arbitrary[F[A => B]],
-                                                                  ArbFBtoC: Arbitrary[F[B => C]],
-                                                                  CogenA: Cogen[A],
-                                                                  CogenB: Cogen[B],
-                                                                  CogenC: Cogen[C],
-                                                                  EqFA: Eq[F[A]],
-                                                                  EqFB: Eq[F[B]],
-                                                                  EqFC: Eq[F[C]],
-                                                                  EqFABC: Eq[F[(A, B, C)]],
-                                                                  EqFInt: Eq[F[Int]],
-                                                                  iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    EqFInt: Eq[F[Int]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       def name: String = "monad"
       def bases: Seq[(String, RuleSet)] = Nil
@@ -39,29 +40,31 @@ trait MonadTests[F[_]] extends ApplicativeTests[F] with FlatMapTests[F] {
     }
 
   def stackUnsafeMonad[A: Arbitrary: Eq, B: Arbitrary: Eq, C: Arbitrary: Eq](implicit
-                                                                             ArbFA: Arbitrary[F[A]],
-                                                                             ArbFB: Arbitrary[F[B]],
-                                                                             ArbFC: Arbitrary[F[C]],
-                                                                             ArbFAtoB: Arbitrary[F[A => B]],
-                                                                             ArbFBtoC: Arbitrary[F[B => C]],
-                                                                             CogenA: Cogen[A],
-                                                                             CogenB: Cogen[B],
-                                                                             CogenC: Cogen[C],
-                                                                             EqFA: Eq[F[A]],
-                                                                             EqFB: Eq[F[B]],
-                                                                             EqFC: Eq[F[C]],
-                                                                             EqFABC: Eq[F[(A, B, C)]],
-                                                                             EqFInt: Eq[F[Int]],
-                                                                             iso: Isomorphisms[F]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    ArbFAtoB: Arbitrary[F[A => B]],
+    ArbFBtoC: Arbitrary[F[B => C]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    CogenC: Cogen[C],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqFABC: Eq[F[(A, B, C)]],
+    EqFInt: Eq[F[Int]],
+    iso: Isomorphisms[F]
+  ): RuleSet =
     new RuleSet {
       def name: String = "monad (stack-unsafe)"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(applicative[A, B, C], flatMap[A, B, C])
-      def props: Seq[(String, Prop)] = Seq(
-        "monad left identity" -> forAll(laws.monadLeftIdentity[A, B] _),
-        "monad right identity" -> forAll(laws.monadRightIdentity[A] _),
-        "map flatMap coherence" -> forAll(laws.mapFlatMapCoherence[A, B] _)
-      )
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "monad left identity" -> forAll(laws.monadLeftIdentity[A, B] _),
+          "monad right identity" -> forAll(laws.monadRightIdentity[A] _),
+          "map flatMap coherence" -> forAll(laws.mapFlatMapCoherence[A, B] _)
+        )
     }
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/MonoidKTests.scala b/laws/src/main/scala/cats/laws/discipline/MonoidKTests.scala
index 5cabd7f04..f1465a3e1 100644
--- a/laws/src/main/scala/cats/laws/discipline/MonoidKTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/MonoidKTests.scala
@@ -8,9 +8,7 @@ import org.scalacheck.Arbitrary
 trait MonoidKTests[F[_]] extends SemigroupKTests[F] {
   def laws: MonoidKLaws[F]
 
-  def monoidK[A: Arbitrary](implicit
-                            ArbFA: Arbitrary[F[A]],
-                            EqFA: Eq[F[A]]): RuleSet =
+  def monoidK[A: Arbitrary](implicit ArbFA: Arbitrary[F[A]], EqFA: Eq[F[A]]): RuleSet =
     new DefaultRuleSet(
       "monoidK",
       Some(semigroupK[A]),
diff --git a/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala b/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
index b503b3329..05fd98b31 100644
--- a/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/NonEmptyParallelTests.scala
@@ -10,14 +10,16 @@ trait NonEmptyParallelTests[M[_]] extends Laws {
   val laws: NonEmptyParallelLaws[M]
   type F[A] = laws.F[A]
 
-  def nonEmptyParallel[A, B](implicit ArbA: Arbitrary[A],
-                             ArbM: Arbitrary[M[A]],
-                             ArbMb: Arbitrary[M[B]],
-                             Arbf: Arbitrary[A => B],
-                             EqMa: Eq[M[A]],
-                             EqMb: Eq[M[B]],
-                             ArbF: Arbitrary[F[A]],
-                             EqFa: Eq[F[A]]): RuleSet =
+  def nonEmptyParallel[A, B](implicit
+    ArbA: Arbitrary[A],
+    ArbM: Arbitrary[M[A]],
+    ArbMb: Arbitrary[M[B]],
+    Arbf: Arbitrary[A => B],
+    EqMa: Eq[M[A]],
+    EqMb: Eq[M[B]],
+    ArbF: Arbitrary[F[A]],
+    EqFa: Eq[F[A]]
+  ): RuleSet =
     new DefaultRuleSet(
       "parallel",
       None,
diff --git a/laws/src/main/scala/cats/laws/discipline/NonEmptyTraverseTests.scala b/laws/src/main/scala/cats/laws/discipline/NonEmptyTraverseTests.scala
index 7603236a8..011c3ae97 100644
--- a/laws/src/main/scala/cats/laws/discipline/NonEmptyTraverseTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/NonEmptyTraverseTests.scala
@@ -9,8 +9,7 @@ import cats.laws.NonEmptyTraverseLaws
 trait NonEmptyTraverseTests[F[_]] extends TraverseTests[F] with ReducibleTests[F] {
   def laws: NonEmptyTraverseLaws[F]
 
-  def nonEmptyTraverse[G[_]: Applicative, A: Arbitrary, B: Arbitrary, C: Arbitrary, M: Arbitrary, X[_], Y[_]](
-    implicit
+  def nonEmptyTraverse[G[_]: Applicative, A: Arbitrary, B: Arbitrary, C: Arbitrary, M: Arbitrary, X[_], Y[_]](implicit
     ArbFA: Arbitrary[F[A]],
     ArbXB: Arbitrary[X[B]],
     ArbYB: Arbitrary[Y[B]],
@@ -45,22 +44,24 @@ trait NonEmptyTraverseTests[F[_]] extends TraverseTests[F] with ReducibleTests[F
     EqYFM: Eq[Y[F[M]]],
     EqOptionA: Eq[Option[A]]
   ): RuleSet = {
-    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] = new Eq[(X[F[B]], Y[F[B]])] {
-      override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
-        EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
-    }
+    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] =
+      new Eq[(X[F[B]], Y[F[B]])] {
+        override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
+          EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
+      }
     new RuleSet {
       def name: String = "nonEmptyTraverse"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(traverse[A, B, C, M, X, Y], reducible[G, A, B])
-      def props: Seq[(String, Prop)] = Seq(
-        "nonEmptyTraverse identity" -> forAll(laws.nonEmptyTraverseIdentity[A, C] _),
-        "nonEmptyTraverse sequential composition" -> forAll(
-          laws.nonEmptyTraverseSequentialComposition[A, B, C, X, Y] _
-        ),
-        "nonEmptyTraverse parallel composition" -> forAll(laws.nonEmptyTraverseParallelComposition[A, B, X, Y] _),
-        "nonEmptyTraverse derive reduceMap" -> forAll(laws.reduceMapDerived[A, M] _)
-      )
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "nonEmptyTraverse identity" -> forAll(laws.nonEmptyTraverseIdentity[A, C] _),
+          "nonEmptyTraverse sequential composition" -> forAll(
+            laws.nonEmptyTraverseSequentialComposition[A, B, C, X, Y] _
+          ),
+          "nonEmptyTraverse parallel composition" -> forAll(laws.nonEmptyTraverseParallelComposition[A, B, X, Y] _),
+          "nonEmptyTraverse derive reduceMap" -> forAll(laws.reduceMapDerived[A, M] _)
+        )
     }
   }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala b/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
index 5f4e28fa8..d8827ce81 100644
--- a/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ParallelTests.scala
@@ -8,14 +8,16 @@ import org.scalacheck.Prop.forAll
 trait ParallelTests[M[_]] extends NonEmptyParallelTests[M] {
   val laws: ParallelLaws[M]
 
-  def parallel[A, B](implicit ArbA: Arbitrary[A],
-                     ArbM: Arbitrary[M[A]],
-                     ArbMb: Arbitrary[M[B]],
-                     Arbf: Arbitrary[A => B],
-                     EqMa: Eq[M[A]],
-                     EqMb: Eq[M[B]],
-                     ArbF: Arbitrary[F[A]],
-                     EqFa: Eq[F[A]]): RuleSet =
+  def parallel[A, B](implicit
+    ArbA: Arbitrary[A],
+    ArbM: Arbitrary[M[A]],
+    ArbMb: Arbitrary[M[B]],
+    Arbf: Arbitrary[A => B],
+    EqMa: Eq[M[A]],
+    EqMb: Eq[M[B]],
+    ArbF: Arbitrary[F[A]],
+    EqFa: Eq[F[A]]
+  ): RuleSet =
     new DefaultRuleSet(
       "parallel",
       Some(nonEmptyParallel[A, B]),
diff --git a/laws/src/main/scala/cats/laws/discipline/ProfunctorTests.scala b/laws/src/main/scala/cats/laws/discipline/ProfunctorTests.scala
index 30d08656b..3e4110909 100644
--- a/laws/src/main/scala/cats/laws/discipline/ProfunctorTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ProfunctorTests.scala
@@ -10,8 +10,7 @@ import org.typelevel.discipline.Laws
 trait ProfunctorTests[F[_, _]] extends Laws {
   def laws: ProfunctorLaws[F]
 
-  def profunctor[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
-    implicit
+  def profunctor[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFCD: Arbitrary[F[C, D]],
     CogenA: Cogen[A],
diff --git a/laws/src/main/scala/cats/laws/discipline/ReducibleTests.scala b/laws/src/main/scala/cats/laws/discipline/ReducibleTests.scala
index 0b260bef2..3ad769624 100644
--- a/laws/src/main/scala/cats/laws/discipline/ReducibleTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ReducibleTests.scala
@@ -12,19 +12,20 @@ trait ReducibleTests[F[_]] extends FoldableTests[F] {
   def laws: ReducibleLaws[F]
 
   def reducible[G[_]: Applicative, A: Arbitrary, B: Arbitrary](implicit
-                                                               ArbFA: Arbitrary[F[A]],
-                                                               ArbFB: Arbitrary[F[B]],
-                                                               ArbFGA: Arbitrary[F[G[A]]],
-                                                               ArbGB: Arbitrary[G[B]],
-                                                               CogenA: Cogen[A],
-                                                               CogenB: Cogen[B],
-                                                               EqG: Eq[G[Unit]],
-                                                               EqA: Eq[A],
-                                                               EqB: Eq[B],
-                                                               EqFA: Eq[F[A]],
-                                                               EqOptionA: Eq[Option[A]],
-                                                               MonoidA: CommutativeMonoid[A],
-                                                               MonoidB: CommutativeMonoid[B]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFGA: Arbitrary[F[G[A]]],
+    ArbGB: Arbitrary[G[B]],
+    CogenA: Cogen[A],
+    CogenB: Cogen[B],
+    EqG: Eq[G[Unit]],
+    EqA: Eq[A],
+    EqB: Eq[B],
+    EqFA: Eq[F[A]],
+    EqOptionA: Eq[Option[A]],
+    MonoidA: CommutativeMonoid[A],
+    MonoidB: CommutativeMonoid[B]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "reducible",
       parent = Some(foldable[A, B]),
diff --git a/laws/src/main/scala/cats/laws/discipline/RepresentableTests.scala b/laws/src/main/scala/cats/laws/discipline/RepresentableTests.scala
index 2630f379f..22e290682 100644
--- a/laws/src/main/scala/cats/laws/discipline/RepresentableTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/RepresentableTests.scala
@@ -11,21 +11,24 @@ trait RepresentableTests[F[_], R] extends Laws {
   val laws: RepresentableLaws[F, R]
 
   def representable[A](implicit
-                       ArbA: Arbitrary[A],
-                       ArbFA: Arbitrary[F[A]],
-                       ArbRep: Arbitrary[R],
-                       ArbRepFn: Arbitrary[R => A],
-                       EqFA: Eq[F[A]],
-                       EqA: Eq[A]): RuleSet = new DefaultRuleSet(
-    name = "representable",
-    parent = None,
-    "index andThen tabulate = id" -> forAll(laws.indexTabulateIsId[A] _),
-    "tabulate andThen index = id" -> forAll(laws.tabulateIndexIsId[A] _)
-  )
+    ArbA: Arbitrary[A],
+    ArbFA: Arbitrary[F[A]],
+    ArbRep: Arbitrary[R],
+    ArbRepFn: Arbitrary[R => A],
+    EqFA: Eq[F[A]],
+    EqA: Eq[A]
+  ): RuleSet =
+    new DefaultRuleSet(
+      name = "representable",
+      parent = None,
+      "index andThen tabulate = id" -> forAll(laws.indexTabulateIsId[A] _),
+      "tabulate andThen index = id" -> forAll(laws.tabulateIndexIsId[A] _)
+    )
 }
 
 object RepresentableTests {
-  def apply[F[_], R](implicit RF: Representable.Aux[F, R]): RepresentableTests[F, R] = new RepresentableTests[F, R] {
-    implicit override val laws: RepresentableLaws[F, R] = RepresentableLaws[F, R]
-  }
+  def apply[F[_], R](implicit RF: Representable.Aux[F, R]): RepresentableTests[F, R] =
+    new RepresentableTests[F, R] {
+      implicit override val laws: RepresentableLaws[F, R] = RepresentableLaws[F, R]
+    }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/SemigroupKTests.scala b/laws/src/main/scala/cats/laws/discipline/SemigroupKTests.scala
index 54c9e569f..11964342c 100644
--- a/laws/src/main/scala/cats/laws/discipline/SemigroupKTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/SemigroupKTests.scala
@@ -9,9 +9,7 @@ import org.typelevel.discipline.Laws
 trait SemigroupKTests[F[_]] extends Laws {
   def laws: SemigroupKLaws[F]
 
-  def semigroupK[A: Arbitrary](implicit
-                               ArbFA: Arbitrary[F[A]],
-                               EqFA: Eq[F[A]]): RuleSet =
+  def semigroupK[A: Arbitrary](implicit ArbFA: Arbitrary[F[A]], EqFA: Eq[F[A]]): RuleSet =
     new DefaultRuleSet("semigroupK", None, "semigroupK associative" -> forAll(laws.semigroupKAssociative[A] _))
 }
 
diff --git a/laws/src/main/scala/cats/laws/discipline/SemigroupalTests.scala b/laws/src/main/scala/cats/laws/discipline/SemigroupalTests.scala
index d76b8eb04..631c6375d 100644
--- a/laws/src/main/scala/cats/laws/discipline/SemigroupalTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/SemigroupalTests.scala
@@ -12,12 +12,13 @@ trait SemigroupalTests[F[_]] extends Laws {
   def laws: SemigroupalLaws[F]
 
   def semigroupal[A: Arbitrary, B: Arbitrary, C: Arbitrary](implicit
-                                                            iso: Isomorphisms[F],
-                                                            ArbFA: Arbitrary[F[A]],
-                                                            ArbFB: Arbitrary[F[B]],
-                                                            ArbFC: Arbitrary[F[C]],
-                                                            EqFA: Eq[F[A]],
-                                                            EqFABC: Eq[F[(A, B, C)]]): RuleSet =
+    iso: Isomorphisms[F],
+    ArbFA: Arbitrary[F[A]],
+    ArbFB: Arbitrary[F[B]],
+    ArbFC: Arbitrary[F[C]],
+    EqFA: Eq[F[A]],
+    EqFABC: Eq[F[(A, B, C)]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "semigroupal",
       parent = None,
@@ -43,7 +44,7 @@ object SemigroupalTests {
     implicit def invariant[F[_]](implicit F: Invariant[F]): Isomorphisms[F] =
       new Isomorphisms[F] {
         def associativity[A, B, C](fs: (F[(A, (B, C))], F[((A, B), C)])): IsEq[F[(A, B, C)]] =
-          F.imap(fs._1) { case (a, (b, c))   => (a, b, c) } { case (a, b, c) => (a, (b, c)) } <->
+          F.imap(fs._1) { case (a, (b, c)) => (a, b, c) } { case (a, b, c) => (a, (b, c)) } <->
             F.imap(fs._2) { case ((a, b), c) => (a, b, c) } { case (a, b, c) => ((a, b), c) }
 
         def leftIdentity[A](fs: (F[(Unit, A)], F[A])): IsEq[F[A]] =
diff --git a/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala b/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
index 412c5d524..1f40605a1 100644
--- a/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
@@ -1,7 +1,7 @@
 package cats.laws.discipline
 
 import cats.laws.ShortCircuitingLaws
-import cats.{Eq, Traverse, TraverseFilter}
+import cats.{Eq, Foldable, Traverse, TraverseFilter}
 import org.scalacheck.Arbitrary
 import org.scalacheck.Prop.forAll
 import org.typelevel.discipline.Laws
@@ -9,6 +9,14 @@ import org.typelevel.discipline.Laws
 trait ShortCircuitingTests[F[_]] extends Laws {
   def laws: ShortCircuitingLaws[F]
 
+  def foldable[A: Arbitrary](implicit F: Foldable[F], ArbFA: Arbitrary[F[A]], lEq: Eq[Long]): RuleSet =
+    new DefaultRuleSet(
+      name = "foldMapKShortCircuiting",
+      parent = None,
+      "foldMapK short-circuits if MonoidK[G].combineKEval shorts" -> forAll(laws.foldMapKShortCircuits[A] _),
+      "foldMapK won't short-circuit if MonoidK[G].combineKEval won't" -> forAll(laws.foldMapKWontShortCircuit[A] _)
+    )
+
   def traverse[A: Arbitrary](implicit F: Traverse[F], ArbFA: Arbitrary[F[A]], lEq: Eq[Long]): RuleSet =
     new DefaultRuleSet(
       name = "traverseShortCircuiting",
@@ -17,8 +25,8 @@ trait ShortCircuitingTests[F[_]] extends Laws {
       "traverse won't short-circuit if Applicative[G].map2Eval won't" -> forAll(laws.traverseWontShortCircuit[A] _)
     )
 
-  def traverseFilter[A: Arbitrary](
-    implicit TF: TraverseFilter[F],
+  def traverseFilter[A: Arbitrary](implicit
+    TF: TraverseFilter[F],
     ArbFA: Arbitrary[F[A]],
     lEq: Eq[Long]
   ): RuleSet = {
@@ -37,7 +45,8 @@ trait ShortCircuitingTests[F[_]] extends Laws {
 }
 
 object ShortCircuitingTests {
-  def apply[F[_]]: ShortCircuitingTests[F] = new ShortCircuitingTests[F] {
-    override def laws: ShortCircuitingLaws[F] = ShortCircuitingLaws[F]
-  }
+  def apply[F[_]]: ShortCircuitingTests[F] =
+    new ShortCircuitingTests[F] {
+      override def laws: ShortCircuitingLaws[F] = ShortCircuitingLaws[F]
+    }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/StrongTests.scala b/laws/src/main/scala/cats/laws/discipline/StrongTests.scala
index 7c4ff859c..963578e77 100644
--- a/laws/src/main/scala/cats/laws/discipline/StrongTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/StrongTests.scala
@@ -9,8 +9,7 @@ import cats.arrow.Strong
 trait StrongTests[F[_, _]] extends ProfunctorTests[F] {
   def laws: StrongLaws[F]
 
-  def strong[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](
-    implicit
+  def strong[A: Arbitrary, B: Arbitrary, C: Arbitrary, D: Arbitrary, E: Arbitrary, G: Arbitrary](implicit
     ArbFAB: Arbitrary[F[A, B]],
     ArbFCD: Arbitrary[F[C, D]],
     CogenA: Cogen[A],
diff --git a/laws/src/main/scala/cats/laws/discipline/TraverseFilterTests.scala b/laws/src/main/scala/cats/laws/discipline/TraverseFilterTests.scala
index a79eb3bcc..ce75f2cee 100644
--- a/laws/src/main/scala/cats/laws/discipline/TraverseFilterTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/TraverseFilterTests.scala
@@ -11,22 +11,23 @@ trait TraverseFilterTests[F[_]] extends FunctorFilterTests[F] {
   def laws: TraverseFilterLaws[F]
 
   def traverseFilter[A, B, C](implicit
-                              ArbFA: Arbitrary[F[A]],
-                              ArbFOA: Arbitrary[F[Option[A]]],
-                              ArbFABoo: Arbitrary[PartialFunction[A, B]],
-                              ArbAOB: Arbitrary[A => Option[B]],
-                              ArbAOA: Arbitrary[A => Option[A]],
-                              ArbAOOB: Arbitrary[A => Option[Option[B]]],
-                              ArbBOC: Arbitrary[B => Option[C]],
-                              ArbBOOC: Arbitrary[B => Option[Option[C]]],
-                              ArbAB: Arbitrary[A => B],
-                              ArbABoo: Arbitrary[A => Boolean],
-                              ArbAOBoo: Arbitrary[A => Option[Boolean]],
-                              EqFA: Eq[F[A]],
-                              EqFB: Eq[F[B]],
-                              EqFC: Eq[F[C]],
-                              EqGFA: Eq[Option[F[A]]],
-                              EqMNFC: Eq[Nested[Option, Option, F[C]]]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbFOA: Arbitrary[F[Option[A]]],
+    ArbFABoo: Arbitrary[PartialFunction[A, B]],
+    ArbAOB: Arbitrary[A => Option[B]],
+    ArbAOA: Arbitrary[A => Option[A]],
+    ArbAOOB: Arbitrary[A => Option[Option[B]]],
+    ArbBOC: Arbitrary[B => Option[C]],
+    ArbBOOC: Arbitrary[B => Option[Option[C]]],
+    ArbAB: Arbitrary[A => B],
+    ArbABoo: Arbitrary[A => Boolean],
+    ArbAOBoo: Arbitrary[A => Option[Boolean]],
+    EqFA: Eq[F[A]],
+    EqFB: Eq[F[B]],
+    EqFC: Eq[F[C]],
+    EqGFA: Eq[Option[F[A]]],
+    EqMNFC: Eq[Nested[Option, Option, F[C]]]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "traverseFilter",
       parent = Some(functorFilter[A, B, C]),
diff --git a/laws/src/main/scala/cats/laws/discipline/TraverseTests.scala b/laws/src/main/scala/cats/laws/discipline/TraverseTests.scala
index 41455de70..0231b83d4 100644
--- a/laws/src/main/scala/cats/laws/discipline/TraverseTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/TraverseTests.scala
@@ -10,8 +10,9 @@ import Prop._
 trait TraverseTests[F[_]] extends FunctorTests[F] with FoldableTests[F] with UnorderedTraverseTests[F] {
   def laws: TraverseLaws[F]
 
-  def traverse[A: Arbitrary, B: Arbitrary, C: Arbitrary, M: Arbitrary, X[_]: CommutativeApplicative, Y[_]: CommutativeApplicative](
-    implicit
+  def traverse[A: Arbitrary, B: Arbitrary, C: Arbitrary, M: Arbitrary, X[_]: CommutativeApplicative, Y[
+    _
+  ]: CommutativeApplicative](implicit
     ArbFA: Arbitrary[F[A]],
     ArbFB: Arbitrary[F[B]],
     ArbXB: Arbitrary[X[B]],
@@ -37,24 +38,26 @@ trait TraverseTests[F[_]] extends FunctorTests[F] with FoldableTests[F] with Uno
     EqYFM: Eq[Y[F[M]]],
     EqOptionA: Eq[Option[A]]
   ): RuleSet = {
-    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] = new Eq[(X[F[B]], Y[F[B]])] {
-      override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
-        EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
-    }
+    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] =
+      new Eq[(X[F[B]], Y[F[B]])] {
+        override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
+          EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
+      }
     new RuleSet {
       def name: String = "traverse"
       def bases: Seq[(String, RuleSet)] = Nil
       def parents: Seq[RuleSet] = Seq(functor[A, B, C], foldable[A, M], unorderedTraverse[A, M, C, X, Y])
-      def props: Seq[(String, Prop)] = Seq(
-        "traverse identity" -> forAll(laws.traverseIdentity[A, C] _),
-        "traverse sequential composition" -> forAll(laws.traverseSequentialComposition[A, B, C, X, Y] _),
-        "traverse parallel composition" -> forAll(laws.traverseParallelComposition[A, B, X, Y] _),
-        "traverse derive foldMap" -> forAll(laws.foldMapDerived[A, M] _),
-        "traverse order consistency" -> forAll(laws.traverseOrderConsistent[A] _),
-        "traverse ref mapWithIndex" -> forAll(laws.mapWithIndexRef[A, C] _),
-        "traverse ref traverseWithIndexM" -> forAll(laws.traverseWithIndexMRef[Option, A, C] _),
-        "traverse ref zipWithIndex" -> forAll(laws.zipWithIndexRef[A, C] _)
-      )
+      def props: Seq[(String, Prop)] =
+        Seq(
+          "traverse identity" -> forAll(laws.traverseIdentity[A, C] _),
+          "traverse sequential composition" -> forAll(laws.traverseSequentialComposition[A, B, C, X, Y] _),
+          "traverse parallel composition" -> forAll(laws.traverseParallelComposition[A, B, X, Y] _),
+          "traverse derive foldMap" -> forAll(laws.foldMapDerived[A, M] _),
+          "traverse order consistency" -> forAll(laws.traverseOrderConsistent[A] _),
+          "traverse ref mapWithIndex" -> forAll(laws.mapWithIndexRef[A, C] _),
+          "traverse ref traverseWithIndexM" -> forAll(laws.traverseWithIndexMRef[Option, A, C] _),
+          "traverse ref zipWithIndex" -> forAll(laws.zipWithIndexRef[A, C] _)
+        )
     }
   }
 }
diff --git a/laws/src/main/scala/cats/laws/discipline/UnorderedFoldableTests.scala b/laws/src/main/scala/cats/laws/discipline/UnorderedFoldableTests.scala
index 2ec35220d..8eccd4639 100644
--- a/laws/src/main/scala/cats/laws/discipline/UnorderedFoldableTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/UnorderedFoldableTests.scala
@@ -12,13 +12,14 @@ trait UnorderedFoldableTests[F[_]] extends Laws {
   def laws: UnorderedFoldableLaws[F]
 
   def unorderedFoldable[A: Arbitrary, B: Arbitrary](implicit
-                                                    ArbFA: Arbitrary[F[A]],
-                                                    ArbF: Arbitrary[A => B],
-                                                    CogenA: Cogen[A],
-                                                    A: CommutativeMonoid[A],
-                                                    B: CommutativeMonoid[B],
-                                                    EqFA: Eq[A],
-                                                    EqFB: Eq[B]): RuleSet =
+    ArbFA: Arbitrary[F[A]],
+    ArbF: Arbitrary[A => B],
+    CogenA: Cogen[A],
+    A: CommutativeMonoid[A],
+    B: CommutativeMonoid[B],
+    EqFA: Eq[A],
+    EqFB: Eq[B]
+  ): RuleSet =
     new DefaultRuleSet(
       name = "unorderedFoldable",
       parent = None,
diff --git a/laws/src/main/scala/cats/laws/discipline/UnorderedTraverseTests.scala b/laws/src/main/scala/cats/laws/discipline/UnorderedTraverseTests.scala
index 9edc6bdb3..cdcb86cf2 100644
--- a/laws/src/main/scala/cats/laws/discipline/UnorderedTraverseTests.scala
+++ b/laws/src/main/scala/cats/laws/discipline/UnorderedTraverseTests.scala
@@ -9,8 +9,10 @@ import cats.kernel.CommutativeMonoid
 trait UnorderedTraverseTests[F[_]] extends UnorderedFoldableTests[F] {
   def laws: UnorderedTraverseLaws[F]
 
-  def unorderedTraverse[A: Arbitrary, B: Arbitrary, C: Arbitrary, X[_]: CommutativeApplicative, Y[_]: CommutativeApplicative](
-    implicit ArbFA: Arbitrary[F[A]],
+  def unorderedTraverse[A: Arbitrary, B: Arbitrary, C: Arbitrary, X[_]: CommutativeApplicative, Y[
+    _
+  ]: CommutativeApplicative](implicit
+    ArbFA: Arbitrary[F[A]],
     ArbFXB: Arbitrary[F[X[B]]],
     ArbXB: Arbitrary[X[B]],
     ArbYB: Arbitrary[Y[B]],
@@ -25,10 +27,11 @@ trait UnorderedTraverseTests[F[_]] extends UnorderedFoldableTests[F] {
     EqXFB: Eq[X[F[B]]],
     EqYFB: Eq[Y[F[B]]]
   ): RuleSet = {
-    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] = new Eq[(X[F[B]], Y[F[B]])] {
-      override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
-        EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
-    }
+    implicit def EqXFBYFB: Eq[(X[F[B]], Y[F[B]])] =
+      new Eq[(X[F[B]], Y[F[B]])] {
+        override def eqv(x: (X[F[B]], Y[F[B]]), y: (X[F[B]], Y[F[B]])): Boolean =
+          EqXFB.eqv(x._1, y._1) && EqYFB.eqv(x._2, y._2)
+      }
     new DefaultRuleSet(
       name = "unorderedTraverse",
       parent = Some(unorderedFoldable[A, B]),
diff --git a/laws/src/main/scala/cats/laws/discipline/arbitrary.scala b/laws/src/main/scala/cats/laws/discipline/arbitrary.scala
index ecf688424..d8414e1d9 100644
--- a/laws/src/main/scala/cats/laws/discipline/arbitrary.scala
+++ b/laws/src/main/scala/cats/laws/discipline/arbitrary.scala
@@ -43,8 +43,10 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
   implicit def catsLawsCogenForConst[A, B](implicit A: Cogen[A]): Cogen[Const[A, B]] =
     A.contramap(_.getConst)
 
-  implicit def catsLawsArbitraryForOneAnd[F[_], A](implicit A: Arbitrary[A],
-                                                   F: Arbitrary[F[A]]): Arbitrary[OneAnd[F, A]] =
+  implicit def catsLawsArbitraryForOneAnd[F[_], A](implicit
+    A: Arbitrary[A],
+    F: Arbitrary[F[A]]
+  ): Arbitrary[OneAnd[F, A]] =
     Arbitrary(F.arbitrary.flatMap(fa => A.arbitrary.map(a => OneAnd(a, fa))))
 
   implicit def catsLawsCogenForOneAnd[F[_], A](implicit A: Cogen[A], F: Cogen[F[A]]): Cogen[OneAnd[F, A]] =
@@ -101,25 +103,32 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
   implicit def cogenNonEmptyMap[K: Order: Cogen, A: Order: Cogen]: Cogen[NonEmptyMap[K, A]] =
     Cogen[SortedMap[K, A]].contramap(_.toSortedMap)
 
-  implicit def catsLawsArbitraryForEitherT[F[_], A, B](
-    implicit F: Arbitrary[F[Either[A, B]]]
+  implicit def catsLawsArbitraryForEitherT[F[_], A, B](implicit
+    F: Arbitrary[F[Either[A, B]]]
   ): Arbitrary[EitherT[F, A, B]] =
     Arbitrary(F.arbitrary.map(EitherT(_)))
 
   implicit def catsLawsCogenForEitherT[F[_], A, B](implicit F: Cogen[F[Either[A, B]]]): Cogen[EitherT[F, A, B]] =
     F.contramap(_.value)
 
-  implicit def catsLawsArbitraryForValidated[A, B](implicit A: Arbitrary[A],
-                                                   B: Arbitrary[B]): Arbitrary[Validated[A, B]] =
+  implicit def catsLawsArbitraryForValidated[A, B](implicit
+    A: Arbitrary[A],
+    B: Arbitrary[B]
+  ): Arbitrary[Validated[A, B]] =
     Arbitrary(Gen.oneOf(A.arbitrary.map(Validated.invalid), B.arbitrary.map(Validated.valid)))
 
   implicit def catsLawsCogenForValidated[A, B](implicit A: Cogen[A], B: Cogen[B]): Cogen[Validated[A, B]] =
     Cogen((seed, x) => x.fold(A.perturb(seed, _), B.perturb(seed, _)))
 
   implicit def catsLawsArbitraryForIor[A, B](implicit A: Arbitrary[A], B: Arbitrary[B]): Arbitrary[A Ior B] =
-    Arbitrary(Gen.oneOf(A.arbitrary.map(Ior.left), B.arbitrary.map(Ior.right), for {
-      a <- A.arbitrary; b <- B.arbitrary
-    } yield Ior.both(a, b)))
+    Arbitrary(
+      Gen.oneOf(A.arbitrary.map(Ior.left),
+                B.arbitrary.map(Ior.right),
+                for {
+                  a <- A.arbitrary; b <- B.arbitrary
+                } yield Ior.both(a, b)
+      )
+    )
 
   implicit def catsLawsCogenForIor[A, B](implicit A: Cogen[A], B: Cogen[B]): Cogen[A Ior B] =
     Cogen((seed, x) => x.fold(A.perturb(seed, _), B.perturb(seed, _), (a, b) => A.perturb(B.perturb(seed, b), a)))
@@ -146,25 +155,32 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
     Arbitrary(
       Gen.oneOf(getArbitrary[A].map(a => Eval.now(a)),
                 getArbitrary[() => A].map(f => Eval.later(f())),
-                getArbitrary[() => A].map(f => Eval.always(f())))
+                getArbitrary[() => A].map(f => Eval.always(f()))
+      )
     )
 
   implicit def catsLawsCogenForEval[A: Cogen]: Cogen[Eval[A]] =
     Cogen[A].contramap(_.value)
 
-  implicit def catsLawsArbitraryForTuple2K[F[_], G[_], A](implicit F: Arbitrary[F[A]],
-                                                          G: Arbitrary[G[A]]): Arbitrary[Tuple2K[F, G, A]] =
+  implicit def catsLawsArbitraryForTuple2K[F[_], G[_], A](implicit
+    F: Arbitrary[F[A]],
+    G: Arbitrary[G[A]]
+  ): Arbitrary[Tuple2K[F, G, A]] =
     Arbitrary(F.arbitrary.flatMap(fa => G.arbitrary.map(ga => Tuple2K[F, G, A](fa, ga))))
 
-  implicit def catsLawsArbitraryForFunc[F[_], A, B](implicit AA: Arbitrary[A],
-                                                    CA: Cogen[A],
-                                                    F: Arbitrary[F[B]]): Arbitrary[Func[F, A, B]] =
+  implicit def catsLawsArbitraryForFunc[F[_], A, B](implicit
+    AA: Arbitrary[A],
+    CA: Cogen[A],
+    F: Arbitrary[F[B]]
+  ): Arbitrary[Func[F, A, B]] =
     Arbitrary(Arbitrary.arbitrary[A => F[B]].map(Func.func))
 
-  implicit def catsLawsArbitraryForAppFunc[F[_], A, B](implicit AA: Arbitrary[A],
-                                                       CA: Cogen[A],
-                                                       F: Arbitrary[F[B]],
-                                                       FF: Applicative[F]): Arbitrary[AppFunc[F, A, B]] =
+  implicit def catsLawsArbitraryForAppFunc[F[_], A, B](implicit
+    AA: Arbitrary[A],
+    CA: Cogen[A],
+    F: Arbitrary[F[B]],
+    FF: Applicative[F]
+  ): Arbitrary[AppFunc[F, A, B]] =
     Arbitrary(Arbitrary.arbitrary[A => F[B]].map(Func.appFunc(_)))
 
   implicit def catsLawsArbitraryForWriter[L: Arbitrary, V: Arbitrary]: Arbitrary[Writer[L, V]] =
@@ -174,17 +190,21 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
     Cogen[(L, V)].contramap(_.run)
 
   // until this is provided by ScalaCheck
-  implicit def catsLawsArbitraryForPartialFunction[A, B](
-    implicit F: Arbitrary[A => Option[B]]
+  implicit def catsLawsArbitraryForPartialFunction[A, B](implicit
+    F: Arbitrary[A => Option[B]]
   ): Arbitrary[PartialFunction[A, B]] =
     Arbitrary(F.arbitrary.map(Function.unlift))
 
-  implicit def catsLawsArbitraryForEitherK[F[_], G[_], A](implicit F: Arbitrary[F[A]],
-                                                          G: Arbitrary[G[A]]): Arbitrary[EitherK[F, G, A]] =
+  implicit def catsLawsArbitraryForEitherK[F[_], G[_], A](implicit
+    F: Arbitrary[F[A]],
+    G: Arbitrary[G[A]]
+  ): Arbitrary[EitherK[F, G, A]] =
     Arbitrary(Gen.oneOf(F.arbitrary.map(EitherK.leftc[F, G, A]), G.arbitrary.map(EitherK.rightc[F, G, A])))
 
-  implicit def catsLawsCogenForEitherK[F[_], G[_], A](implicit F: Cogen[F[A]],
-                                                      G: Cogen[G[A]]): Cogen[EitherK[F, G, A]] =
+  implicit def catsLawsCogenForEitherK[F[_], G[_], A](implicit
+    F: Cogen[F[A]],
+    G: Cogen[G[A]]
+  ): Cogen[EitherK[F, G, A]] =
     Cogen((seed, x) => x.run.fold(F.perturb(seed, _), G.perturb(seed, _)))
 
   implicit def catLawsCogenForTuple2K[F[_], G[_], A](implicit F: Cogen[F[A]], G: Cogen[G[A]]): Cogen[Tuple2K[F, G, A]] =
@@ -262,8 +282,8 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
   implicit def catsLawsArbitraryForNested[F[_], G[_], A](implicit FG: Arbitrary[F[G[A]]]): Arbitrary[Nested[F, G, A]] =
     Arbitrary(FG.arbitrary.map(Nested(_)))
 
-  implicit def catsLawsArbitraryForBinested[F[_, _], G[_], H[_], A, B](
-    implicit F: Arbitrary[F[G[A], H[B]]]
+  implicit def catsLawsArbitraryForBinested[F[_, _], G[_], H[_], A, B](implicit
+    F: Arbitrary[F[G[A], H[B]]]
   ): Arbitrary[Binested[F, G, H, A, B]] =
     Arbitrary(F.arbitrary.map(Binested(_)))
 
@@ -282,14 +302,12 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
   implicit def catsLawsCogenForOp[Arr[_, _], A, B](implicit Arr: Cogen[Arr[B, A]]): Cogen[Op[Arr, A, B]] =
     Arr.contramap(_.run)
 
-  implicit def catsLawsArbitraryForIRWST[F[_]: Applicative, E, L, SA, SB, A](
-    implicit
+  implicit def catsLawsArbitraryForIRWST[F[_]: Applicative, E, L, SA, SB, A](implicit
     F: Arbitrary[(E, SA) => F[(L, SB, A)]]
   ): Arbitrary[IndexedReaderWriterStateT[F, E, L, SA, SB, A]] =
     Arbitrary(F.arbitrary.map(IndexedReaderWriterStateT(_)))
 
-  implicit def catsLawsArbitraryForRepresentableStore[F[_], S, A](
-    implicit
+  implicit def catsLawsArbitraryForRepresentableStore[F[_], S, A](implicit
     R: Representable.Aux[F, S],
     ArbS: Arbitrary[S],
     ArbFA: Arbitrary[F[A]]
@@ -303,8 +321,8 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
       }
     }
 
-  implicit def catsLawsCogenForRepresentableStore[F[_]: Representable, S, A](
-    implicit CA: Cogen[A]
+  implicit def catsLawsCogenForRepresentableStore[F[_]: Representable, S, A](implicit
+    CA: Cogen[A]
   ): Cogen[RepresentableStore[F, S, A]] =
     CA.contramap(_.extract)
 
@@ -353,8 +371,8 @@ object arbitrary extends ArbitraryInstances0 with ScalaVersionSpecific.Arbitrary
 
 sealed private[discipline] trait ArbitraryInstances0 {
 
-  implicit def catsLawArbitraryForIndexedStateT[F[_], SA, SB, A](
-    implicit F: Arbitrary[F[SA => F[(SB, A)]]]
+  implicit def catsLawArbitraryForIndexedStateT[F[_], SA, SB, A](implicit
+    F: Arbitrary[F[SA => F[(SB, A)]]]
   ): Arbitrary[IndexedStateT[F, SA, SB, A]] =
     Arbitrary(F.arbitrary.map(IndexedStateT.applyF))
 
@@ -364,13 +382,17 @@ sealed private[discipline] trait ArbitraryInstances0 {
   implicit def catsLawsCogenForWriterT[F[_], L, V](implicit F: Cogen[F[(L, V)]]): Cogen[WriterT[F, L, V]] =
     F.contramap(_.run)
 
-  implicit def catsLawsArbitraryForKleisli[F[_], A, B](implicit AA: Arbitrary[A],
-                                                       CA: Cogen[A],
-                                                       F: Arbitrary[F[B]]): Arbitrary[Kleisli[F, A, B]] =
+  implicit def catsLawsArbitraryForKleisli[F[_], A, B](implicit
+    AA: Arbitrary[A],
+    CA: Cogen[A],
+    F: Arbitrary[F[B]]
+  ): Arbitrary[Kleisli[F, A, B]] =
     Arbitrary(Arbitrary.arbitrary[A => F[B]].map(Kleisli(_)))
 
-  implicit def catsLawsArbitraryForCokleisli[F[_], A, B](implicit AFA: Arbitrary[F[A]],
-                                                         CFA: Cogen[F[A]],
-                                                         B: Arbitrary[B]): Arbitrary[Cokleisli[F, A, B]] =
+  implicit def catsLawsArbitraryForCokleisli[F[_], A, B](implicit
+    AFA: Arbitrary[F[A]],
+    CFA: Cogen[F[A]],
+    B: Arbitrary[B]
+  ): Arbitrary[Cokleisli[F, A, B]] =
     Arbitrary(Arbitrary.arbitrary[F[A] => B].map(Cokleisli(_)))
 }
diff --git a/project/Boilerplate.scala b/project/Boilerplate.scala
index 72447bdef..d999516ea 100644
--- a/project/Boilerplate.scala
+++ b/project/Boilerplate.scala
@@ -34,11 +34,12 @@ object Boilerplate {
   val header = "// auto-generated boilerplate by /project/Boilerplate.scala" // TODO: put something meaningful here?
 
   /** Returns a seq of the generated files.  As a side-effect, it actually generates them... */
-  def gen(dir: File) = for (t <- templates) yield {
-    val tgtFile = t.filename(dir)
-    IO.write(tgtFile, t.body)
-    tgtFile
-  }
+  def gen(dir: File) =
+    for (t <- templates) yield {
+      val tgtFile = t.filename(dir)
+      IO.write(tgtFile, t.body)
+      tgtFile
+    }
 
   val maxArity = 22
 
@@ -149,10 +150,10 @@ object Boilerplate {
       |
       |
       |@deprecated("replaced by apply syntax", "1.0.0-MF")
-      |private[syntax] final class SemigroupalBuilder[F[_]] {
+      |private[syntax] final class SemigroupalBuilder[F[_]] extends Serializable {
       |  def |@|[A](a: F[A]) = new SemigroupalBuilder1(a)
       |
-        -  private[syntax] final class SemigroupalBuilder$arity[${`A..N`}]($params) {
+        -  private[syntax] final class SemigroupalBuilder$arity[${`A..N`}]($params) extends Serializable {
         -    $next
         -    def apWith[Z](f: F[(${`A..N`}) => Z])(implicit apply: Apply[F]): F[Z] = apply.ap$n(f)(${`a..n`})
         -    $map
@@ -417,7 +418,7 @@ object Boilerplate {
          -  implicit def catsSyntaxTuple${arity}Parallel[M[_], ${`A..N`}]($tupleTpe): Tuple${arity}ParallelOps[M, ${`A..N`}] = new Tuple${arity}ParallelOps(t$arity)
       |}
       |
-         -private[syntax] final class Tuple${arity}ParallelOps[M[_], ${`A..N`}](private val $tupleTpe) {
+         -private[syntax] final class Tuple${arity}ParallelOps[M[_], ${`A..N`}](private val $tupleTpe) extends Serializable {
          -  $parMap
          -  $parTupled
          -}
@@ -487,7 +488,7 @@ object Boilerplate {
         -  implicit def catsSyntaxTuple${arity}Semigroupal[F[_], ${`A..N`}]($tupleTpe): Tuple${arity}SemigroupalOps[F, ${`A..N`}] = new Tuple${arity}SemigroupalOps(t$arity)
       |}
       |
-        -private[syntax] final class Tuple${arity}SemigroupalOps[F[_], ${`A..N`}](private val $tupleTpe) {
+        -private[syntax] final class Tuple${arity}SemigroupalOps[F[_], ${`A..N`}](private val $tupleTpe) extends Serializable {
         -  $map
         -  $contramap
         -  $imap
diff --git a/project/KernelBoiler.scala b/project/KernelBoiler.scala
index 304d485be..f444d8478 100644
--- a/project/KernelBoiler.scala
+++ b/project/KernelBoiler.scala
@@ -32,11 +32,12 @@ object KernelBoiler {
    *
    * As a side-effect, it actually generates them...
    */
-  def gen(dir: File): Seq[File] = templates.map { template =>
-    val tgtFile = template.filename(dir)
-    IO.write(tgtFile, template.body)
-    tgtFile
-  }
+  def gen(dir: File): Seq[File] =
+    templates.map { template =>
+      val tgtFile = template.filename(dir)
+      IO.write(tgtFile, template.body)
+      tgtFile
+    }
 
   class TemplateVals(val arity: Int) {
     val synTypes = (0 until arity).map(n => s"A$n")
diff --git a/project/build.properties b/project/build.properties
index 797e7ccfd..654fe70c4 100644
--- a/project/build.properties
+++ b/project/build.properties
@@ -1 +1 @@
-sbt.version=1.3.10
+sbt.version=1.3.12
diff --git a/project/plugins.sbt b/project/plugins.sbt
index 1be459ed6..49478dc3c 100644
--- a/project/plugins.sbt
+++ b/project/plugins.sbt
@@ -1,4 +1,4 @@
-addSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "0.9.15-3")
+addSbtPlugin("ch.epfl.scala" % "sbt-scalafix" % "0.9.16")
 addSbtPlugin("com.eed3si9n" % "sbt-unidoc" % "0.4.3")
 addSbtPlugin("com.github.gseitz" %% "sbt-release" % "1.0.13")
 addSbtPlugin("com.jsuereth" % "sbt-pgp" % "2.0.1")
diff --git a/scalafix/project/build.properties b/scalafix/project/build.properties
index 797e7ccfd..654fe70c4 100644
--- a/scalafix/project/build.properties
+++ b/scalafix/project/build.properties
@@ -1 +1 @@
-sbt.version=1.3.10
+sbt.version=1.3.12
diff --git a/tests/src/test/scala-2.12/cats/tests/NonEmptyStreamSuite.scala b/tests/src/test/scala-2.12/cats/tests/NonEmptyStreamSuite.scala
index 4b017b140..81ef943eb 100644
--- a/tests/src/test/scala-2.12/cats/tests/NonEmptyStreamSuite.scala
+++ b/tests/src/test/scala-2.12/cats/tests/NonEmptyStreamSuite.scala
@@ -20,7 +20,8 @@ class NonEmptyStreamSuite extends CatsSuite {
   checkAll("NonEmptyStream[Int]", EqTests[NonEmptyStream[Int]].eqv)
 
   checkAll("NonEmptyStream[Int] with Option",
-           NonEmptyTraverseTests[NonEmptyStream].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option])
+           NonEmptyTraverseTests[NonEmptyStream].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option]
+  )
   checkAll("NonEmptyTraverse[NonEmptyStream[A]]", SerializableTests.serializable(NonEmptyTraverse[NonEmptyStream[*]]))
 
   checkAll("NonEmptyStream[Int]", ReducibleTests[NonEmptyStream].reducible[Option, Int, Int])
diff --git a/tests/src/test/scala-2.13+/cats/tests/NonEmptyLazyListSuite.scala b/tests/src/test/scala-2.13+/cats/tests/NonEmptyLazyListSuite.scala
index a27fceeb5..431c3283f 100644
--- a/tests/src/test/scala-2.13+/cats/tests/NonEmptyLazyListSuite.scala
+++ b/tests/src/test/scala-2.13+/cats/tests/NonEmptyLazyListSuite.scala
@@ -31,7 +31,8 @@ class NonEmptyLazyListSuite extends NonEmptyCollectionSuite[LazyList, NonEmptyLa
   checkAll("SemigroupK[NonEmptyLazyList]", SerializableTests.serializable(SemigroupK[NonEmptyLazyList]))
 
   checkAll("NonEmptyLazyList[Int] with Option",
-           NonEmptyTraverseTests[NonEmptyLazyList].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option])
+           NonEmptyTraverseTests[NonEmptyLazyList].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option]
+  )
   checkAll("NonEmptyTraverse[NonEmptyLazyList]", SerializableTests.serializable(Traverse[NonEmptyLazyList]))
 
   checkAll("NonEmptyLazyList[Int]", BimonadTests[NonEmptyLazyList].bimonad[Int, Int, Int])
@@ -54,14 +55,16 @@ class NonEmptyLazyListSuite extends NonEmptyCollectionSuite[LazyList, NonEmptyLa
     implicit val partialOrder: PartialOrder[ListWrapper[Int]] = ListWrapper.partialOrder[Int]
     checkAll("NonEmptyLazyList[ListWrapper[Int]]", PartialOrderTests[NonEmptyLazyList[ListWrapper[Int]]].partialOrder)
     checkAll("PartialOrder[NonEmptyLazyList[ListWrapper[Int]]",
-             SerializableTests.serializable(PartialOrder[NonEmptyLazyList[ListWrapper[Int]]]))
+             SerializableTests.serializable(PartialOrder[NonEmptyLazyList[ListWrapper[Int]]])
+    )
   }
 
   {
     implicit val eqv: Eq[ListWrapper[Int]] = ListWrapper.eqv[Int]
     checkAll("NonEmptyLazyList[ListWrapper[Int]]", EqTests[NonEmptyLazyList[ListWrapper[Int]]].eqv)
     checkAll("Eq[NonEmptyLazyList[ListWrapper[Int]]",
-             SerializableTests.serializable(Eq[NonEmptyLazyList[ListWrapper[Int]]]))
+             SerializableTests.serializable(Eq[NonEmptyLazyList[ListWrapper[Int]]])
+    )
   }
 
   test("size is consistent with toLazyList.size") {
diff --git a/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala b/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala
index c211a96df..091d2d0f8 100644
--- a/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala
+++ b/tests/src/test/scala-2.13+/cats/tests/ScalaVersionSpecific.scala
@@ -51,13 +51,14 @@ trait ScalaVersionSpecificFoldableSuite { self: FoldableSuiteAdditional =>
     dangerous.foldM(0)((acc, a) => if (a < 2) Some(acc + a) else None) should ===(None)
   }
 
-  def foldableLazyListWithDefaultImpl: Foldable[LazyList] = new Foldable[LazyList] {
-    def foldLeft[A, B](fa: LazyList[A], b: B)(f: (B, A) => B): B =
-      Foldable[LazyList].foldLeft(fa, b)(f)
+  def foldableLazyListWithDefaultImpl: Foldable[LazyList] =
+    new Foldable[LazyList] {
+      def foldLeft[A, B](fa: LazyList[A], b: B)(f: (B, A) => B): B =
+        Foldable[LazyList].foldLeft(fa, b)(f)
 
-    def foldRight[A, B](fa: LazyList[A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
-      Foldable[LazyList].foldRight(fa, lb)(f)
-  }
+      def foldRight[A, B](fa: LazyList[A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
+        Foldable[LazyList].foldRight(fa, lb)(f)
+    }
 
   test("Foldable[LazyList].foldLeftM short-circuiting") {
     implicit val F: Foldable[LazyList] = foldableLazyListWithDefaultImpl
diff --git a/tests/src/test/scala/cats/tests/AlgebraInvariantSuite.scala b/tests/src/test/scala/cats/tests/AlgebraInvariantSuite.scala
index 786b96c61..227c534f6 100644
--- a/tests/src/test/scala/cats/tests/AlgebraInvariantSuite.scala
+++ b/tests/src/test/scala/cats/tests/AlgebraInvariantSuite.scala
@@ -25,16 +25,17 @@ class AlgebraInvariantSuite extends CatsSuite {
   catsLawsEqForBand[Set[Boolean]]
 
   // https://github.com/typelevel/cats/issues/2725
-  implicit private def commutativeMonoidForSemigroup[A](
-    implicit csA: CommutativeSemigroup[A]
+  implicit private def commutativeMonoidForSemigroup[A](implicit
+    csA: CommutativeSemigroup[A]
   ): CommutativeMonoid[Option[A]] =
     new CommutativeMonoid[Option[A]] {
       def empty: Option[A] = None
-      def combine(x: Option[A], y: Option[A]): Option[A] = (x, y) match {
-        case (None, r)          => r
-        case (l, None)          => l
-        case (Some(l), Some(r)) => Some(csA.combine(l, r))
-      }
+      def combine(x: Option[A], y: Option[A]): Option[A] =
+        (x, y) match {
+          case (None, r)          => r
+          case (l, None)          => l
+          case (Some(l), Some(r)) => Some(csA.combine(l, r))
+        }
     }
 
   private def leftOptionMonoid[A]: Monoid[Option[A]] =
@@ -123,7 +124,8 @@ class AlgebraInvariantSuite extends CatsSuite {
     Gen.oneOf(commutativeMonoidForSemigroup(boolAnd),
               commutativeMonoidForSemigroup(boolOr),
               leftOptionMonoid[Boolean],
-              rightOptionMonoid[Boolean])
+              rightOptionMonoid[Boolean]
+    )
 
   implicit private val arbMonoidOptionBoolean: Arbitrary[Monoid[Option[Boolean]]] =
     Arbitrary(genMonoidOptionBoolean)
@@ -157,10 +159,12 @@ class AlgebraInvariantSuite extends CatsSuite {
 
   checkAll("InvariantMonoidal[Semigroup]", SemigroupTests[Int](InvariantMonoidal[Semigroup].point(0)).semigroup)
   checkAll("InvariantMonoidal[CommutativeSemigroup]",
-           CommutativeSemigroupTests[Int](InvariantMonoidal[CommutativeSemigroup].point(0)).commutativeSemigroup)
+           CommutativeSemigroupTests[Int](InvariantMonoidal[CommutativeSemigroup].point(0)).commutativeSemigroup
+  )
 
   checkAll("InvariantSemigroupal[Monoid]",
-           InvariantSemigroupalTests[Monoid].invariantSemigroupal[Option[MiniInt], Option[Boolean], Option[Boolean]])
+           InvariantSemigroupalTests[Monoid].invariantSemigroupal[Option[MiniInt], Option[Boolean], Option[Boolean]]
+  )
 
   {
     val S: Semigroup[Int] = Semigroup[Int].imap(identity)(identity)
@@ -245,7 +249,8 @@ class AlgebraInvariantSuite extends CatsSuite {
   checkAll("Invariant[CommutativeMonoid]", SerializableTests.serializable(Invariant[CommutativeMonoid]))
 
   checkAll("Invariant[BoundedSemilattice]",
-           InvariantTests[BoundedSemilattice].invariant[MiniInt, Set[Boolean], Set[Boolean]])
+           InvariantTests[BoundedSemilattice].invariant[MiniInt, Set[Boolean], Set[Boolean]]
+  )
   checkAll("Invariant[BoundedSemilattice]", SerializableTests.serializable(Invariant[BoundedSemilattice]))
 
   checkAll("Invariant[Group]", InvariantTests[Group].invariant[MiniInt, Boolean, Boolean])
@@ -255,12 +260,15 @@ class AlgebraInvariantSuite extends CatsSuite {
   checkAll("Invariant[CommutativeGroup]", SerializableTests.serializable(Invariant[CommutativeGroup]))
 
   checkAll("InvariantMonoidal[Semigroup]",
-           InvariantMonoidalTests[Semigroup].invariantMonoidal[Option[MiniInt], Option[Boolean], Option[Boolean]])
+           InvariantMonoidalTests[Semigroup].invariantMonoidal[Option[MiniInt], Option[Boolean], Option[Boolean]]
+  )
   checkAll("InvariantMonoidal[Semigroup]", SerializableTests.serializable(InvariantMonoidal[Semigroup]))
 
   checkAll("InvariantMonoidal[CommutativeSemigroup]",
-           InvariantMonoidalTests[CommutativeSemigroup].invariantMonoidal[MiniInt, Boolean, Boolean])
+           InvariantMonoidalTests[CommutativeSemigroup].invariantMonoidal[MiniInt, Boolean, Boolean]
+  )
   checkAll("InvariantMonoidal[CommutativeSemigroup]",
-           SerializableTests.serializable(InvariantMonoidal[CommutativeSemigroup]))
+           SerializableTests.serializable(InvariantMonoidal[CommutativeSemigroup])
+  )
 
 }
diff --git a/tests/src/test/scala/cats/tests/AlternativeSuite.scala b/tests/src/test/scala/cats/tests/AlternativeSuite.scala
index 5f57d3594..0e7b5055f 100644
--- a/tests/src/test/scala/cats/tests/AlternativeSuite.scala
+++ b/tests/src/test/scala/cats/tests/AlternativeSuite.scala
@@ -13,7 +13,7 @@ class AlternativeSuite extends CatsSuite {
 
   test("separate") {
     forAll { (list: List[Either[Int, String]]) =>
-      val ints = list.collect { case Left(i)     => i }
+      val ints = list.collect { case Left(i) => i }
       val strings = list.collect { case Right(s) => s }
       val expected = (ints, strings)
 
@@ -23,7 +23,7 @@ class AlternativeSuite extends CatsSuite {
 
   test("separateFoldable") {
     forAll { (list: List[Either[Int, String]]) =>
-      val ints = list.collect { case Left(i)     => i }
+      val ints = list.collect { case Left(i) => i }
       val strings = list.collect { case Right(s) => s }
       val expected = (ints, strings)
 
diff --git a/tests/src/test/scala/cats/tests/AndThenSuite.scala b/tests/src/test/scala/cats/tests/AndThenSuite.scala
index bfdeb9bcb..04c018690 100644
--- a/tests/src/test/scala/cats/tests/AndThenSuite.scala
+++ b/tests/src/test/scala/cats/tests/AndThenSuite.scala
@@ -18,16 +18,19 @@ class AndThenSuite extends CatsSuite with Checkers {
     implicit val iso: SemigroupalTests.Isomorphisms[AndThen[*, Int]] =
       SemigroupalTests.Isomorphisms.invariant[AndThen[*, Int]]
     checkAll("AndThen[*, Int]",
-             ContravariantMonoidalTests[AndThen[*, Int]].contravariantMonoidal[MiniInt, Boolean, Boolean])
+             ContravariantMonoidalTests[AndThen[*, Int]].contravariantMonoidal[MiniInt, Boolean, Boolean]
+    )
     checkAll("ContravariantMonoidal[AndThen[*, Int]]",
-             SerializableTests.serializable(ContravariantMonoidal[AndThen[*, Int]]))
+             SerializableTests.serializable(ContravariantMonoidal[AndThen[*, Int]])
+    )
   }
 
   checkAll("AndThen[MiniInt, Int]", MonadTests[AndThen[MiniInt, *]].monad[Int, Int, Int])
   checkAll("Monad[AndThen[Int, *]]", SerializableTests.serializable(Monad[AndThen[Int, *]]))
 
   checkAll("AndThen",
-           CommutativeArrowTests[AndThen].commutativeArrow[MiniInt, Boolean, Boolean, Boolean, Boolean, Boolean])
+           CommutativeArrowTests[AndThen].commutativeArrow[MiniInt, Boolean, Boolean, Boolean, Boolean, Boolean]
+  )
   checkAll("Arrow[AndThen]", SerializableTests.serializable(CommutativeArrow[AndThen]))
 
   checkAll("AndThen", ChoiceTests[AndThen].choice[MiniInt, Boolean, Int, Int])
diff --git a/tests/src/test/scala/cats/tests/ApplicativeErrorSuite.scala b/tests/src/test/scala/cats/tests/ApplicativeErrorSuite.scala
index 1c00d5bdd..c7306ba29 100644
--- a/tests/src/test/scala/cats/tests/ApplicativeErrorSuite.scala
+++ b/tests/src/test/scala/cats/tests/ApplicativeErrorSuite.scala
@@ -9,7 +9,7 @@ import cats.syntax.option._
 
 class ApplicativeErrorSuite extends CatsSuite {
   val failed: Option[Int] =
-    (()).raiseError[Option, Int]
+    ().raiseError[Option, Int]
 
   test("raiseError syntax creates an Option with the correct value") {
     failed should ===(None: Option[Int])
@@ -79,8 +79,8 @@ class ApplicativeErrorSuite extends CatsSuite {
   {
     final case class OptionWrapper[A](option: Option[A])
 
-    implicit def mayBeApplicativeError[E](
-      implicit ev: ApplicativeError[Option, E]
+    implicit def mayBeApplicativeError[E](implicit
+      ev: ApplicativeError[Option, E]
     ): ApplicativeError[OptionWrapper, E] =
       new ApplicativeError[OptionWrapper, E] {
 
diff --git a/tests/src/test/scala/cats/tests/BifunctorSuite.scala b/tests/src/test/scala/cats/tests/BifunctorSuite.scala
index e6800ba8c..534e3b6e8 100644
--- a/tests/src/test/scala/cats/tests/BifunctorSuite.scala
+++ b/tests/src/test/scala/cats/tests/BifunctorSuite.scala
@@ -9,7 +9,8 @@ class BifunctorSuite extends CatsSuite {
     Bifunctor[Tuple2].compose[Either]
 
   checkAll("Tuple2 compose Either",
-           BifunctorTests(tuple2ComposeEither).bifunctor[Int, Int, Int, String, String, String])
+           BifunctorTests(tuple2ComposeEither).bifunctor[Int, Int, Int, String, String, String]
+  )
   checkAll("Bifunctor[Tuple2 compose Either]", SerializableTests.serializable(tuple2ComposeEither))
 
   {
diff --git a/tests/src/test/scala/cats/tests/BinCodecInvariantMonoidalSuite.scala b/tests/src/test/scala/cats/tests/BinCodecInvariantMonoidalSuite.scala
index c43355ea4..0e5c42c0e 100644
--- a/tests/src/test/scala/cats/tests/BinCodecInvariantMonoidalSuite.scala
+++ b/tests/src/test/scala/cats/tests/BinCodecInvariantMonoidalSuite.scala
@@ -82,10 +82,11 @@ object BinCodecInvariantMonoidalSuite {
     // In tut/invariantmonoidal.md pure, product and imap are defined in
     // their own trait to be introduced one by one,
     trait CCPure {
-      def unit: BinCodec[Unit] = new BinCodec[Unit] {
-        def read(s: Bin): (Option[Unit], Bin) = (Some(()), s)
-        def write(a: Unit): Bin = MiniList.empty
-      }
+      def unit: BinCodec[Unit] =
+        new BinCodec[Unit] {
+          def read(s: Bin): (Option[Unit], Bin) = (Some(()), s)
+          def write(a: Unit): Bin = MiniList.empty
+        }
     }
 
     trait CCProduct {
diff --git a/tests/src/test/scala/cats/tests/BinestedSuite.scala b/tests/src/test/scala/cats/tests/BinestedSuite.scala
index c435e1f36..203b4e5ab 100644
--- a/tests/src/test/scala/cats/tests/BinestedSuite.scala
+++ b/tests/src/test/scala/cats/tests/BinestedSuite.scala
@@ -25,7 +25,8 @@ class BinestedSuite extends CatsSuite {
       BifunctorTests[Binested[Either, ListWrapper, Option, *, *]].bifunctor[Int, Int, Int, String, String, String]
     )
     checkAll("Bifunctor[Binested[Either, ListWrapper, Option, *, *]]",
-             SerializableTests.serializable(Bifunctor[Binested[Either, ListWrapper, Option, *, *]]))
+             SerializableTests.serializable(Bifunctor[Binested[Either, ListWrapper, Option, *, *]])
+    )
   }
 
   {
@@ -47,7 +48,8 @@ class BinestedSuite extends CatsSuite {
     // Bifoldable + foldable + foldable = Bifoldable
     implicit val instance: Foldable[ListWrapper] = ListWrapper.foldable
     checkAll("Binested[Either, ListWrapper, ListWrapper, *, *]",
-             BifoldableTests[Binested[Either, ListWrapper, ListWrapper, *, *]].bifoldable[Int, Int, Int])
+             BifoldableTests[Binested[Either, ListWrapper, ListWrapper, *, *]].bifoldable[Int, Int, Int]
+    )
     checkAll(
       "Bifoldable[Binested[Either, ListWrapper, ListWrapper, *, *]]",
       SerializableTests.serializable(Bifoldable[Binested[Either, ListWrapper, ListWrapper, *, *]])
diff --git a/tests/src/test/scala/cats/tests/BitraverseSuite.scala b/tests/src/test/scala/cats/tests/BitraverseSuite.scala
index bc1908da6..bf4f35159 100644
--- a/tests/src/test/scala/cats/tests/BitraverseSuite.scala
+++ b/tests/src/test/scala/cats/tests/BitraverseSuite.scala
@@ -9,6 +9,7 @@ class BitraverseSuite extends CatsSuite {
     Bitraverse[Either].compose[Tuple2]
 
   checkAll("Either compose Tuple2",
-           BitraverseTests(eitherComposeTuple2).bitraverse[Option, Int, Int, Int, String, String, String])
+           BitraverseTests(eitherComposeTuple2).bitraverse[Option, Int, Int, Int, String, String, String]
+  )
   checkAll("Bitraverse[Either compose Tuple2]", SerializableTests.serializable(eitherComposeTuple2))
 }
diff --git a/tests/src/test/scala/cats/tests/ChainSuite.scala b/tests/src/test/scala/cats/tests/ChainSuite.scala
index 0a299601d..e29788884 100644
--- a/tests/src/test/scala/cats/tests/ChainSuite.scala
+++ b/tests/src/test/scala/cats/tests/ChainSuite.scala
@@ -51,7 +51,8 @@ class ChainSuite extends CatsSuite {
     implicit val partialOrder: PartialOrder[ListWrapper[Int]] = ListWrapper.partialOrder[Int]
     checkAll("Chain[ListWrapper[Int]]", PartialOrderTests[Chain[ListWrapper[Int]]].partialOrder)
     checkAll("PartialOrder[Chain[ListWrapper[Int]]",
-             SerializableTests.serializable(PartialOrder[Chain[ListWrapper[Int]]]))
+             SerializableTests.serializable(PartialOrder[Chain[ListWrapper[Int]]])
+    )
   }
 
   {
diff --git a/tests/src/test/scala/cats/tests/CokleisliSuite.scala b/tests/src/test/scala/cats/tests/CokleisliSuite.scala
index e729d2884..4a1c9eb14 100644
--- a/tests/src/test/scala/cats/tests/CokleisliSuite.scala
+++ b/tests/src/test/scala/cats/tests/CokleisliSuite.scala
@@ -13,7 +13,8 @@ class CokleisliSuite extends SlowCatsSuite {
 
   implicit override val generatorDrivenConfig: PropertyCheckConfiguration =
     slowCheckConfiguration.copy(sizeRange = slowCheckConfiguration.sizeRange.min(5),
-                                minSuccessful = slowCheckConfiguration.minSuccessful.min(20))
+                                minSuccessful = slowCheckConfiguration.minSuccessful.min(20)
+    )
 
   implicit def cokleisliEq[F[_], A, B](implicit ev: Eq[F[A] => B]): Eq[Cokleisli[F, A, B]] =
     Eq.by[Cokleisli[F, A, B], F[A] => B](_.run)
@@ -21,33 +22,42 @@ class CokleisliSuite extends SlowCatsSuite {
   implicit val iso: Isomorphisms[Cokleisli[Option, Int, *]] = Isomorphisms.invariant[Cokleisli[Option, Int, *]]
 
   checkAll("Cokleisli[Option, MiniInt, Int]",
-           SemigroupalTests[Cokleisli[Option, MiniInt, *]].semigroupal[Int, Int, Int])
+           SemigroupalTests[Cokleisli[Option, MiniInt, *]].semigroupal[Int, Int, Int]
+  )
   checkAll("Semigroupal[Cokleisli[Option, Int, *]]",
-           SerializableTests.serializable(Semigroupal[Cokleisli[Option, Int, *]]))
+           SerializableTests.serializable(Semigroupal[Cokleisli[Option, Int, *]])
+  )
 
   checkAll("Cokleisli[Option, MiniInt, Int]", MonadTests[Cokleisli[Option, MiniInt, *]].monad[Int, Int, Int])
   checkAll("Monad[Cokleisli[Option, Int, *]]", SerializableTests.serializable(Monad[Cokleisli[Option, Int, *]]))
 
   checkAll("Cokleisli[Option, MiniInt, Int]",
-           ProfunctorTests[Cokleisli[Option, *, *]].profunctor[MiniInt, Int, Int, Int, Int, Int])
+           ProfunctorTests[Cokleisli[Option, *, *]].profunctor[MiniInt, Int, Int, Int, Int, Int]
+  )
   checkAll("Profunctor[Cokleisli[Option, *, *]]", SerializableTests.serializable(Profunctor[Cokleisli[Option, *, *]]))
 
   checkAll("Cokleisli[Option, MiniInt, MiniInt]",
-           ContravariantTests[Cokleisli[Option, *, MiniInt]].contravariant[MiniInt, MiniInt, MiniInt])
+           ContravariantTests[Cokleisli[Option, *, MiniInt]].contravariant[MiniInt, MiniInt, MiniInt]
+  )
   checkAll("Contravariant[Cokleisli[Option, *, MiniInt]]",
-           SerializableTests.serializable(Contravariant[Cokleisli[Option, *, Int]]))
+           SerializableTests.serializable(Contravariant[Cokleisli[Option, *, Int]])
+  )
 
   checkAll("Cokleisli[(Boolean, *), MiniInt, MiniInt]",
-           MonoidKTests[Î»[Î± => Cokleisli[(Boolean, *), Î±, Î±]]].monoidK[MiniInt])
+           MonoidKTests[Î»[Î± => Cokleisli[(Boolean, *), Î±, Î±]]].monoidK[MiniInt]
+  )
   checkAll("MonoidK[Î»[Î± => Cokleisli[NonEmptyList, Î±, Î±]]]",
-           SerializableTests.serializable(MonoidK[Î»[Î± => Cokleisli[NonEmptyList, Î±, Î±]]]))
+           SerializableTests.serializable(MonoidK[Î»[Î± => Cokleisli[NonEmptyList, Î±, Î±]]])
+  )
 
   checkAll("Cokleisli[Option, MiniInt, MiniInt]", SemigroupKTests[Î»[Î± => Cokleisli[Option, Î±, Î±]]].semigroupK[MiniInt])
   checkAll("SemigroupK[Î»[Î± => Cokleisli[List, Î±, Î±]]]",
-           SerializableTests.serializable(SemigroupK[Î»[Î± => Cokleisli[List, Î±, Î±]]]))
+           SerializableTests.serializable(SemigroupK[Î»[Î± => Cokleisli[List, Î±, Î±]]])
+  )
 
   checkAll("Cokleisli[(Boolean, *), MiniInt, MiniInt]",
-           ArrowTests[Cokleisli[(Boolean, *), *, *]].arrow[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, MiniInt])
+           ArrowTests[Cokleisli[(Boolean, *), *, *]].arrow[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, MiniInt]
+  )
   checkAll("Arrow[Cokleisli[NonEmptyList, *, *]]", SerializableTests.serializable(Arrow[Cokleisli[NonEmptyList, *, *]]))
 
   {
@@ -59,7 +69,8 @@ class CokleisliSuite extends SlowCatsSuite {
       CommutativeArrowTests[Cokleisli[Id, *, *]].commutativeArrow[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, MiniInt]
     )
     checkAll("CommutativeArrow[Cokleisli[Id, *, *]]",
-             SerializableTests.serializable(CommutativeArrow[Cokleisli[Id, *, *]]))
+             SerializableTests.serializable(CommutativeArrow[Cokleisli[Id, *, *]])
+    )
   }
 
   test("contramapValue with Id consistent with lmap") {
diff --git a/tests/src/test/scala/cats/tests/ConstSuite.scala b/tests/src/test/scala/cats/tests/ConstSuite.scala
index 981572633..1d4a1b187 100644
--- a/tests/src/test/scala/cats/tests/ConstSuite.scala
+++ b/tests/src/test/scala/cats/tests/ConstSuite.scala
@@ -30,7 +30,8 @@ class ConstSuite extends CatsSuite {
   checkAll("Applicative[Const[String, *]]", SerializableTests.serializable(Applicative[Const[String, *]]))
 
   checkAll("Const[String, Int] with Option",
-           TraverseTests[Const[String, *]].traverse[Int, Int, Int, Int, Option, Option])
+           TraverseTests[Const[String, *]].traverse[Int, Int, Int, Int, Option, Option]
+  )
   checkAll("Traverse[Const[String, *]]", SerializableTests.serializable(Traverse[Const[String, *]]))
 
   checkAll("Const[String, Int]", TraverseFilterTests[Const[String, *]].traverseFilter[Int, Int, Int])
@@ -46,7 +47,8 @@ class ConstSuite extends CatsSuite {
       Isomorphisms.invariant[Const[NonEmptyList[String], *]](Const.catsDataContravariantForConst)
     checkAll("Apply[Const[NonEmptyList[String], Int]]", ApplyTests[Const[NonEmptyList[String], *]].apply[Int, Int, Int])
     checkAll("Apply[Const[NonEmptyList[String], *]]",
-             SerializableTests.serializable(Apply[Const[NonEmptyList[String], *]]))
+             SerializableTests.serializable(Apply[Const[NonEmptyList[String], *]])
+    )
   }
 
   // Algebra checks for Serializability of instances as part of the laws
@@ -77,13 +79,15 @@ class ConstSuite extends CatsSuite {
 
   checkAll("Const[String, Int]", ContravariantMonoidalTests[Const[String, *]].contravariantMonoidal[Int, Int, Int])
   checkAll("ContravariantMonoidal[Const[String, *]]",
-           SerializableTests.serializable(ContravariantMonoidal[Const[String, *]]))
+           SerializableTests.serializable(ContravariantMonoidal[Const[String, *]])
+  )
 
   checkAll("Const[*, *]", BifoldableTests[Const].bifoldable[Int, Int, Int])
   checkAll("Bifoldable[Const]", SerializableTests.serializable(Bifoldable[Const]))
 
   checkAll("InvariantMonoidal[Const[String, *]]",
-           InvariantMonoidalTests[Const[String, *]].invariantMonoidal[Int, Int, Int])
+           InvariantMonoidalTests[Const[String, *]].invariantMonoidal[Int, Int, Int]
+  )
   checkAll("InvariantMonoidal[Const[String, *]]", SerializableTests.serializable(InvariantMonoidal[Const[String, *]]))
 
   test("show") {
@@ -106,7 +110,8 @@ class ConstSuite extends CatsSuite {
       Isomorphisms.invariant[Const[CMono, *]](Const.catsDataFunctorForConst)
     checkAll("Const[CMono, Int]", CommutativeApplicativeTests[Const[CMono, *]].commutativeApplicative[Int, Int, Int])
     checkAll("CommutativeApplicative[Const[CMono, *]]",
-             SerializableTests.serializable(CommutativeApplicative[Const[CMono, *]]))
+             SerializableTests.serializable(CommutativeApplicative[Const[CMono, *]])
+    )
   }
 
   checkAll("Const[CSemi, Int]", CommutativeApplyTests[Const[CSemi, *]].commutativeApply[Int, Int, Int])
diff --git a/tests/src/test/scala/cats/tests/ContTSuite.scala b/tests/src/test/scala/cats/tests/ContTSuite.scala
index 6d4ba8938..670b1bf10 100644
--- a/tests/src/test/scala/cats/tests/ContTSuite.scala
+++ b/tests/src/test/scala/cats/tests/ContTSuite.scala
@@ -30,10 +30,12 @@ class ContTSuite extends CatsSuite {
   /**
    * c.mapCont(f).run(g) == f(c.run(g))
    */
-  def mapContLaw[M[_], A, B](implicit eqma: Eq[M[A]],
-                             cArb: Arbitrary[ContT[M, A, B]],
-                             fnArb: Arbitrary[M[A] => M[A]],
-                             gnArb: Arbitrary[B => M[A]]) =
+  def mapContLaw[M[_], A, B](implicit
+    eqma: Eq[M[A]],
+    cArb: Arbitrary[ContT[M, A, B]],
+    fnArb: Arbitrary[M[A] => M[A]],
+    gnArb: Arbitrary[B => M[A]]
+  ) =
     forAll { (cont: ContT[M, A, B], fn: M[A] => M[A], gn: B => M[A]) =>
       assert(eqma.eqv(cont.mapCont(fn).run(gn), fn(cont.run(gn))))
     }
@@ -41,10 +43,12 @@ class ContTSuite extends CatsSuite {
   /**
    * cont.withCont(f).run(g) == cont.run(f(g))
    */
-  def withContLaw[M[_], A, B, C](implicit eqma: Eq[M[A]],
-                                 cArb: Arbitrary[ContT[M, A, B]],
-                                 fnArb: Arbitrary[(C => M[A]) => B => M[A]],
-                                 gnArb: Arbitrary[C => M[A]]) =
+  def withContLaw[M[_], A, B, C](implicit
+    eqma: Eq[M[A]],
+    cArb: Arbitrary[ContT[M, A, B]],
+    fnArb: Arbitrary[(C => M[A]) => B => M[A]],
+    gnArb: Arbitrary[C => M[A]]
+  ) =
     forAll { (cont: ContT[M, A, B], fn: (C => M[A]) => B => M[A], gn: C => M[A]) =>
       assert(eqma.eqv(cont.withCont(fn).run(gn), cont.run(fn(gn))))
     }
diff --git a/tests/src/test/scala/cats/tests/ContravariantSuite.scala b/tests/src/test/scala/cats/tests/ContravariantSuite.scala
index 33c7a6797..cfba03766 100644
--- a/tests/src/test/scala/cats/tests/ContravariantSuite.scala
+++ b/tests/src/test/scala/cats/tests/ContravariantSuite.scala
@@ -39,7 +39,8 @@ class ContravariantSuite extends CatsSuite {
     Arbitrary(implicitly[Arbitrary[A => Boolean]].arbitrary.map(f => Predicate(f)))
 
   checkAll("ContravariantMonoidal[Predicate]",
-           ContravariantMonoidalTests[Predicate].contravariantMonoidal[Boolean, Boolean, Boolean])
+           ContravariantMonoidalTests[Predicate].contravariantMonoidal[Boolean, Boolean, Boolean]
+  )
 
   {
     implicit val predicateMonoid: Monoid[Predicate[MiniInt]] = ContravariantMonoidal.monoid[Predicate, MiniInt]
diff --git a/tests/src/test/scala/cats/tests/EitherKSuite.scala b/tests/src/test/scala/cats/tests/EitherKSuite.scala
index e03ceaeec..d7945433d 100644
--- a/tests/src/test/scala/cats/tests/EitherKSuite.scala
+++ b/tests/src/test/scala/cats/tests/EitherKSuite.scala
@@ -10,14 +10,16 @@ import cats.laws.discipline.eq._
 class EitherKSuite extends CatsSuite {
 
   checkAll("EitherK[Option, Option, *]",
-           TraverseTests[EitherK[Option, Option, *]].traverse[Int, Int, Int, Int, Option, Option])
+           TraverseTests[EitherK[Option, Option, *]].traverse[Int, Int, Int, Int, Option, Option]
+  )
   checkAll("Traverse[EitherK[Option, Option, *]]", SerializableTests.serializable(Traverse[EitherK[Option, Option, *]]))
 
   {
     implicit val foldable: Foldable[EitherK[Option, Option, *]] = EitherK.catsDataFoldableForEitherK[Option, Option]
     checkAll("EitherK[Option, Option, *]", FoldableTests[EitherK[Option, Option, *]].foldable[Int, Int])
     checkAll("Foldable[EitherK[Option, Option, *]]",
-             SerializableTests.serializable(Foldable[EitherK[Option, Option, *]]))
+             SerializableTests.serializable(Foldable[EitherK[Option, Option, *]])
+    )
   }
 
   checkAll("EitherK[Eval, Eval, *]", ComonadTests[EitherK[Eval, Eval, *]].comonad[Int, Int, Int])
@@ -34,7 +36,8 @@ class EitherKSuite extends CatsSuite {
 
   checkAll("EitherK[Show, Show, *]", ContravariantTests[EitherK[Show, Show, *]].contravariant[MiniInt, Int, Boolean])
   checkAll("Contravariant[EitherK[Show, Show, *]]",
-           SerializableTests.serializable(Contravariant[EitherK[Show, Show, *]]))
+           SerializableTests.serializable(Contravariant[EitherK[Show, Show, *]])
+  )
 
   test("double swap is identity") {
     forAll { (x: EitherK[Option, Option, Int]) =>
diff --git a/tests/src/test/scala/cats/tests/EitherSuite.scala b/tests/src/test/scala/cats/tests/EitherSuite.scala
index a23fdc16c..e0bd200c6 100644
--- a/tests/src/test/scala/cats/tests/EitherSuite.scala
+++ b/tests/src/test/scala/cats/tests/EitherSuite.scala
@@ -35,11 +35,13 @@ class EitherSuite extends CatsSuite {
 
   checkAll("Either[ListWrapper[String], *]", SemigroupKTests[Either[ListWrapper[String], *]].semigroupK[Int])
   checkAll("SemigroupK[Either[ListWrapper[String], *]]",
-           SerializableTests.serializable(SemigroupK[Either[ListWrapper[String], *]]))
+           SerializableTests.serializable(SemigroupK[Either[ListWrapper[String], *]])
+  )
 
   checkAll("Either[ListWrapper[String], Int]", SemigroupTests[Either[ListWrapper[String], Int]].semigroup)
   checkAll("Semigroup[Either[ListWrapper[String], Int]]",
-           SerializableTests.serializable(Semigroup[Either[ListWrapper[String], Int]]))
+           SerializableTests.serializable(Semigroup[Either[ListWrapper[String], Int]])
+  )
 
   val partialOrder = cats.kernel.instances.either.catsStdPartialOrderForEither[Int, String]
   val order = implicitly[Order[Either[Int, String]]]
@@ -50,9 +52,11 @@ class EitherSuite extends CatsSuite {
     implicit val S: Eq[ListWrapper[String]] = ListWrapper.eqv[String]
     implicit val I: Eq[ListWrapper[Int]] = ListWrapper.eqv[Int]
     checkAll("Either[ListWrapper[String], ListWrapper[Int]]",
-             EqTests[Either[ListWrapper[String], ListWrapper[Int]]].eqv)
+             EqTests[Either[ListWrapper[String], ListWrapper[Int]]].eqv
+    )
     checkAll("Eq[Either[ListWrapper[String], ListWrapper[Int]]]",
-             SerializableTests.serializable(Eq[Either[ListWrapper[String], ListWrapper[Int]]]))
+             SerializableTests.serializable(Eq[Either[ListWrapper[String], ListWrapper[Int]]])
+    )
   }
 
   checkAll("Either[Int, String]", PartialOrderTests[Either[Int, String]](partialOrder).partialOrder)
diff --git a/tests/src/test/scala/cats/tests/EitherTSuite.scala b/tests/src/test/scala/cats/tests/EitherTSuite.scala
index f8da53918..04de557b1 100644
--- a/tests/src/test/scala/cats/tests/EitherTSuite.scala
+++ b/tests/src/test/scala/cats/tests/EitherTSuite.scala
@@ -19,9 +19,11 @@ class EitherTSuite extends CatsSuite {
 
   {
     checkAll("EitherT[Option, ListWrapper[String], *]",
-             SemigroupKTests[EitherT[Option, ListWrapper[String], *]].semigroupK[Int])
+             SemigroupKTests[EitherT[Option, ListWrapper[String], *]].semigroupK[Int]
+    )
     checkAll("SemigroupK[EitherT[Option, ListWrapper[String], *]]",
-             SerializableTests.serializable(SemigroupK[EitherT[Option, ListWrapper[String], *]]))
+             SerializableTests.serializable(SemigroupK[EitherT[Option, ListWrapper[String], *]])
+    )
   }
 
   {
@@ -29,7 +31,8 @@ class EitherTSuite extends CatsSuite {
 
     checkAll("EitherT[List, String, Int]", OrderTests[EitherT[ListWrapper, String, Int]].order)
     checkAll("Order[EitherT[List, String, Int]]",
-             SerializableTests.serializable(Order[EitherT[ListWrapper, String, Int]]))
+             SerializableTests.serializable(Order[EitherT[ListWrapper, String, Int]])
+    )
   }
 
   {
@@ -37,12 +40,15 @@ class EitherTSuite extends CatsSuite {
     implicit val F: Functor[ListWrapper] = ListWrapper.functor
 
     checkAll("EitherT[ListWrapper, *, *]",
-             BifunctorTests[EitherT[ListWrapper, *, *]].bifunctor[Int, Int, Int, String, String, String])
+             BifunctorTests[EitherT[ListWrapper, *, *]].bifunctor[Int, Int, Int, String, String, String]
+    )
     checkAll("Bifunctor[EitherT[ListWrapper, *, *]]",
-             SerializableTests.serializable(Bifunctor[EitherT[ListWrapper, *, *]]))
+             SerializableTests.serializable(Bifunctor[EitherT[ListWrapper, *, *]])
+    )
     checkAll("EitherT[ListWrapper, Int, *]", FunctorTests[EitherT[ListWrapper, Int, *]].functor[Int, Int, Int])
     checkAll("Functor[EitherT[ListWrapper, Int, *]]",
-             SerializableTests.serializable(Functor[EitherT[ListWrapper, Int, *]]))
+             SerializableTests.serializable(Functor[EitherT[ListWrapper, Int, *]])
+    )
   }
 
   {
@@ -50,13 +56,17 @@ class EitherTSuite extends CatsSuite {
     implicit val F: Traverse[ListWrapper] = ListWrapper.traverse
 
     checkAll("EitherT[ListWrapper, Int, *]",
-             TraverseTests[EitherT[ListWrapper, Int, *]].traverse[Int, Int, Int, Int, Option, Option])
+             TraverseTests[EitherT[ListWrapper, Int, *]].traverse[Int, Int, Int, Int, Option, Option]
+    )
     checkAll("Traverse[EitherT[ListWrapper, Int, *]]",
-             SerializableTests.serializable(Traverse[EitherT[ListWrapper, Int, *]]))
+             SerializableTests.serializable(Traverse[EitherT[ListWrapper, Int, *]])
+    )
     checkAll("EitherT[ListWrapper, *, *]",
-             BitraverseTests[EitherT[ListWrapper, *, *]].bitraverse[Option, Int, Int, Int, String, String, String])
+             BitraverseTests[EitherT[ListWrapper, *, *]].bitraverse[Option, Int, Int, Int, String, String, String]
+    )
     checkAll("Bitraverse[EitherT[ListWrapper, *, *]]",
-             SerializableTests.serializable(Bitraverse[EitherT[ListWrapper, *, *]]))
+             SerializableTests.serializable(Bitraverse[EitherT[ListWrapper, *, *]])
+    )
 
   }
 
@@ -74,9 +84,11 @@ class EitherTSuite extends CatsSuite {
     Monad[EitherT[ListWrapper, String, *]]
 
     checkAll("EitherT[ListWrapper, String, Int]",
-             MonadErrorTests[EitherT[ListWrapper, String, *], String].monadError[Int, Int, Int])
+             MonadErrorTests[EitherT[ListWrapper, String, *], String].monadError[Int, Int, Int]
+    )
     checkAll("MonadError[EitherT[List, *, *]]",
-             SerializableTests.serializable(MonadError[EitherT[ListWrapper, String, *], String]))
+             SerializableTests.serializable(MonadError[EitherT[ListWrapper, String, *], String])
+    )
 
   }
 
@@ -96,9 +108,11 @@ class EitherTSuite extends CatsSuite {
     Monad[EitherT[Option, String, *]]
 
     checkAll("EitherT[Option, String, String]",
-             MonadErrorTests[EitherT[Option, String, *], Unit].monadError[String, String, String])
+             MonadErrorTests[EitherT[Option, String, *], Unit].monadError[String, String, String]
+    )
     checkAll("MonadError[EitherT[Option, *, *]]",
-             SerializableTests.serializable(MonadError[EitherT[Option, String, *], Unit]))
+             SerializableTests.serializable(MonadError[EitherT[Option, String, *], Unit])
+    )
   }
 
   {
@@ -111,7 +125,8 @@ class EitherTSuite extends CatsSuite {
 
     checkAll("EitherT[ListWrapper, String, Int]", MonadTests[EitherT[ListWrapper, String, *]].monad[Int, Int, Int])
     checkAll("Monad[EitherT[ListWrapper, String, *]]",
-             SerializableTests.serializable(Monad[EitherT[ListWrapper, String, *]]))
+             SerializableTests.serializable(Monad[EitherT[ListWrapper, String, *]])
+    )
   }
 
   {
@@ -120,7 +135,8 @@ class EitherTSuite extends CatsSuite {
 
     checkAll("EitherT[ListWrapper, Int, *]", FoldableTests[EitherT[ListWrapper, Int, *]].foldable[Int, Int])
     checkAll("Foldable[EitherT[ListWrapper, Int, *]]",
-             SerializableTests.serializable(Foldable[EitherT[ListWrapper, Int, *]]))
+             SerializableTests.serializable(Foldable[EitherT[ListWrapper, Int, *]])
+    )
   }
 
   {
@@ -128,7 +144,8 @@ class EitherTSuite extends CatsSuite {
 
     checkAll("EitherT[ListWrapper, String, Int]", PartialOrderTests[EitherT[ListWrapper, String, Int]].partialOrder)
     checkAll("PartialOrder[EitherT[ListWrapper, String, Int]]",
-             SerializableTests.serializable(PartialOrder[EitherT[ListWrapper, String, Int]]))
+             SerializableTests.serializable(PartialOrder[EitherT[ListWrapper, String, Int]])
+    )
   }
 
   {
@@ -136,7 +153,8 @@ class EitherTSuite extends CatsSuite {
 
     checkAll("EitherT[ListWrapper, String, Int]", SemigroupTests[EitherT[ListWrapper, String, Int]].semigroup)
     checkAll("Semigroup[EitherT[ListWrapper, String, Int]]",
-             SerializableTests.serializable(Semigroup[EitherT[ListWrapper, String, Int]]))
+             SerializableTests.serializable(Semigroup[EitherT[ListWrapper, String, Int]])
+    )
   }
 
   {
@@ -146,7 +164,8 @@ class EitherTSuite extends CatsSuite {
 
     checkAll("EitherT[ListWrapper, String, Int]", MonoidTests[EitherT[ListWrapper, String, Int]].monoid)
     checkAll("Monoid[EitherT[ListWrapper, String, Int]]",
-             SerializableTests.serializable(Monoid[EitherT[ListWrapper, String, Int]]))
+             SerializableTests.serializable(Monoid[EitherT[ListWrapper, String, Int]])
+    )
   }
 
   {
@@ -154,7 +173,8 @@ class EitherTSuite extends CatsSuite {
 
     checkAll("EitherT[ListWrapper, String, Int]", EqTests[EitherT[ListWrapper, String, Int]].eqv)
     checkAll("Eq[EitherT[ListWrapper, String, Int]]",
-             SerializableTests.serializable(Eq[EitherT[ListWrapper, String, Int]]))
+             SerializableTests.serializable(Eq[EitherT[ListWrapper, String, Int]])
+    )
   }
 
   test("toValidated") {
diff --git a/tests/src/test/scala/cats/tests/EquivSuite.scala b/tests/src/test/scala/cats/tests/EquivSuite.scala
index 75417f99a..f8757dc7b 100644
--- a/tests/src/test/scala/cats/tests/EquivSuite.scala
+++ b/tests/src/test/scala/cats/tests/EquivSuite.scala
@@ -16,6 +16,7 @@ class EquivSuite extends CatsSuite {
   checkAll("Contravariant[Equiv]", ContravariantTests[Equiv].contravariant[MiniInt, Int, Boolean])
   checkAll("Semigroupal[Equiv]", SemigroupalTests[Equiv].semigroupal[MiniInt, Boolean, Boolean])
   checkAll("ContravariantMonoidal[Equiv]",
-           ContravariantMonoidalTests[Equiv].contravariantMonoidal[MiniInt, Boolean, Boolean])
+           ContravariantMonoidalTests[Equiv].contravariantMonoidal[MiniInt, Boolean, Boolean]
+  )
   checkAll("ContravariantMonoidal[Equiv]", SerializableTests.serializable(ContravariantMonoidal[Equiv]))
 }
diff --git a/tests/src/test/scala/cats/tests/EvalSuite.scala b/tests/src/test/scala/cats/tests/EvalSuite.scala
index 1fc422cbb..e0a9479c1 100644
--- a/tests/src/test/scala/cats/tests/EvalSuite.scala
+++ b/tests/src/test/scala/cats/tests/EvalSuite.scala
@@ -197,7 +197,8 @@ class EvalSuite extends CatsSuite {
         Gen.oneOf(arbitrary[A => A].map(OMap(_)),
                   arbitrary[A => Eval[A]].map(OFlatMap(_)),
                   Gen.const(OMemoize[A]()),
-                  Gen.const(ODefer[A]()))
+                  Gen.const(ODefer[A]())
+        )
       )
 
     def build[A](leaf: () => Eval[A], os: Vector[O[A]]): DeepEval[A] = {
diff --git a/tests/src/test/scala/cats/tests/ExtraRegressionSuite.scala b/tests/src/test/scala/cats/tests/ExtraRegressionSuite.scala
index 19e28bf97..65c92e825 100644
--- a/tests/src/test/scala/cats/tests/ExtraRegressionSuite.scala
+++ b/tests/src/test/scala/cats/tests/ExtraRegressionSuite.scala
@@ -16,9 +16,10 @@ class ExtraRegressionSuite extends CatsSuite {
 object ExtraRegressionSuite {
   final case class First[A](getFirst: A) extends AnyVal
   object First {
-    implicit def showInstance[A](implicit ev: Show[A]): Show[First[A]] = new Show[First[A]] {
-      override def show(f: First[A]): String = s"First(${ev.show(f.getFirst)})"
-    }
+    implicit def showInstance[A](implicit ev: Show[A]): Show[First[A]] =
+      new Show[First[A]] {
+        override def show(f: First[A]): String = s"First(${ev.show(f.getFirst)})"
+      }
   }
 
 }
diff --git a/tests/src/test/scala/cats/tests/FoldableSuite.scala b/tests/src/test/scala/cats/tests/FoldableSuite.scala
index adb242a17..5de4b99cb 100644
--- a/tests/src/test/scala/cats/tests/FoldableSuite.scala
+++ b/tests/src/test/scala/cats/tests/FoldableSuite.scala
@@ -18,9 +18,10 @@ import scala.collection.immutable.{SortedMap, SortedSet}
 import scala.util.Try
 
 @suppressUnusedImportWarningForScalaVersionSpecific
-abstract class FoldableSuite[F[_]: Foldable](name: String)(implicit ArbFInt: Arbitrary[F[Int]],
-                                                           ArbFString: Arbitrary[F[String]])
-    extends CatsSuite {
+abstract class FoldableSuite[F[_]: Foldable](name: String)(implicit
+  ArbFInt: Arbitrary[F[Int]],
+  ArbFString: Arbitrary[F[String]]
+) extends CatsSuite {
 
   def iterator[T](fa: F[T]): Iterator[T]
 
@@ -463,13 +464,14 @@ class FoldableSuiteAdditional extends CatsSuite with ScalaVersionSpecificFoldabl
     dangerous.foldM(0)((acc, a) => if (a < 2) Some(acc + a) else None) should ===(None)
   }
 
-  def foldableStreamWithDefaultImpl: Foldable[Stream] = new Foldable[Stream] {
-    def foldLeft[A, B](fa: Stream[A], b: B)(f: (B, A) => B): B =
-      Foldable[Stream].foldLeft(fa, b)(f)
+  def foldableStreamWithDefaultImpl: Foldable[Stream] =
+    new Foldable[Stream] {
+      def foldLeft[A, B](fa: Stream[A], b: B)(f: (B, A) => B): B =
+        Foldable[Stream].foldLeft(fa, b)(f)
 
-    def foldRight[A, B](fa: Stream[A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
-      Foldable[Stream].foldRight(fa, lb)(f)
-  }
+      def foldRight[A, B](fa: Stream[A], lb: Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
+        Foldable[Stream].foldRight(fa, lb)(f)
+    }
 
   test(".foldA successful case") {
     implicit val F: Foldable[Stream] = foldableStreamWithDefaultImpl
diff --git a/tests/src/test/scala/cats/tests/FuncSuite.scala b/tests/src/test/scala/cats/tests/FuncSuite.scala
index 1527abdd8..2ce7e31ee 100644
--- a/tests/src/test/scala/cats/tests/FuncSuite.scala
+++ b/tests/src/test/scala/cats/tests/FuncSuite.scala
@@ -43,7 +43,8 @@ class FuncSuite extends CatsSuite {
     implicit val funcContravariant: Contravariant[Func[Show, *, MiniInt]] =
       Func.catsDataContravariantForFunc[Show, MiniInt]
     checkAll("Func[Show, MiniInt, MiniInt]",
-             ContravariantTests[Func[Show, *, MiniInt]].contravariant[MiniInt, MiniInt, MiniInt])
+             ContravariantTests[Func[Show, *, MiniInt]].contravariant[MiniInt, MiniInt, MiniInt]
+    )
     checkAll("Contravariant[Func[Show, *, Int]]", SerializableTests.serializable(Contravariant[Func[Show, *, Int]]))
   }
 
@@ -51,9 +52,11 @@ class FuncSuite extends CatsSuite {
     implicit val appFuncApp: Applicative[AppFunc[Option, Int, *]] = AppFunc.appFuncApplicative[Option, Int]
     implicit val iso: Isomorphisms[AppFunc[Option, Int, *]] = Isomorphisms.invariant[AppFunc[Option, Int, *]]
     checkAll("AppFunc[Option, MiniInt, MiniInt]",
-             ApplicativeTests[AppFunc[Option, MiniInt, *]].applicative[MiniInt, MiniInt, MiniInt])
+             ApplicativeTests[AppFunc[Option, MiniInt, *]].applicative[MiniInt, MiniInt, MiniInt]
+    )
     checkAll("Applicative[AppFunc[Option, Int, *]]",
-             SerializableTests.serializable(Applicative[AppFunc[Option, Int, *]]))
+             SerializableTests.serializable(Applicative[AppFunc[Option, Int, *]])
+    )
   }
 
   test("product") {
diff --git a/tests/src/test/scala/cats/tests/FunctionSuite.scala b/tests/src/test/scala/cats/tests/FunctionSuite.scala
index 652307f5d..2a3e02463 100644
--- a/tests/src/test/scala/cats/tests/FunctionSuite.scala
+++ b/tests/src/test/scala/cats/tests/FunctionSuite.scala
@@ -79,7 +79,8 @@ class FunctionSuite extends CatsSuite {
   checkAll("Monad[Int => *]", SerializableTests.serializable(Monad[Int => *]))
 
   checkAll("Function1[MiniInt, MiniInt]",
-           CommutativeArrowTests[Function1].commutativeArrow[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, MiniInt])
+           CommutativeArrowTests[Function1].commutativeArrow[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, MiniInt]
+  )
   checkAll("Arrow[Function1]", SerializableTests.serializable(CommutativeArrow[Function1]))
 
   checkAll("Function1", ChoiceTests[Function1].choice[MiniInt, Boolean, Int, Long])
@@ -95,7 +96,8 @@ class FunctionSuite extends CatsSuite {
   checkAll("MonoidK[Î»[Î± => Î± => Î±]", SerializableTests.serializable(MonoidK[Endo]))
 
   checkAll("Function1[MiniInt, *]",
-           DistributiveTests[MiniInt => *].distributive[Int, Int, Int, Id, Function1[MiniInt, *]])
+           DistributiveTests[MiniInt => *].distributive[Int, Int, Int, Id, Function1[MiniInt, *]]
+  )
   checkAll("Distributive[Int => *]", SerializableTests.serializable(Distributive[Int => *]))
 
   // law checks for the various Function0-related instances
@@ -123,7 +125,8 @@ class FunctionSuite extends CatsSuite {
   Applicative[String => *]
   checkAll("Function1[MiniInt, *]",
            ApplicativeTests[Function1[MiniInt, *]](Applicative.catsApplicativeForArrow[Function1, MiniInt])
-             .applicative[Int, Int, Int])
+             .applicative[Int, Int, Int]
+  )
 
   // serialization tests for the various Function0-related instances
   checkAll("Eq[() => Eqed]", SerializableTests.serializable(Eq[() => Eqed]))
@@ -153,12 +156,14 @@ class FunctionSuite extends CatsSuite {
   // Isos for ContravariantMonoidal
   implicit val isoCodomain: Isomorphisms[Function1[*, Long]] = Isomorphisms.invariant[Function1[*, Long]]
   checkAll("Function1[*, Monoid]",
-           ContravariantMonoidalTests[Function1[*, Long]].contravariantMonoidal[MiniInt, MiniInt, MiniInt])
+           ContravariantMonoidalTests[Function1[*, Long]].contravariantMonoidal[MiniInt, MiniInt, MiniInt]
+  )
 
   // serialization tests for the various Function1-related instances
   checkAll("Semigroup[String => Semi]", SerializableTests.serializable(Semigroup[String => Semi]))
   checkAll("CommutativeSemigroup[String => Semi]",
-           SerializableTests.serializable(CommutativeSemigroup[String => CSemi]))
+           SerializableTests.serializable(CommutativeSemigroup[String => CSemi])
+  )
   checkAll("Band[String => Bnd]", SerializableTests.serializable(Band[String => Bnd]))
   checkAll("Semilattice[String => SL]", SerializableTests.serializable(Semilattice[String => SL]))
   checkAll("BoundedSemilattice[String => BSL]", SerializableTests.serializable(BoundedSemilattice[String => BSL]))
@@ -167,7 +172,8 @@ class FunctionSuite extends CatsSuite {
   checkAll("Group[String => Grp]", SerializableTests.serializable(Group[String => Grp]))
   checkAll("CommutativeGroup[String => CGrp]", SerializableTests.serializable(CommutativeGroup[String => CGrp]))
   checkAll("ContravariantMonoidal[Function1[*, Monoid]]",
-           SerializableTests.serializable(ContravariantMonoidal[* => Long]))
+           SerializableTests.serializable(ContravariantMonoidal[* => Long])
+  )
 
   test("MonoidK[Endo] is stack safe on combineK") {
     def incrementAll(as: Int): Int = as + 1
diff --git a/tests/src/test/scala/cats/tests/IdTSuite.scala b/tests/src/test/scala/cats/tests/IdTSuite.scala
index 336a7e207..ad6e0f8f2 100644
--- a/tests/src/test/scala/cats/tests/IdTSuite.scala
+++ b/tests/src/test/scala/cats/tests/IdTSuite.scala
@@ -15,7 +15,8 @@ class IdTSuite extends CatsSuite {
 
   checkAll("IdT[(CSemi, *), Int]", CommutativeFlatMapTests[IdT[(CSemi, *), *]].commutativeFlatMap[Int, Int, Int])
   checkAll("CommutativeFlatMap[IdT[(CSemi, *), *]]",
-           SerializableTests.serializable(CommutativeFlatMap[IdT[(CSemi, *), *]]))
+           SerializableTests.serializable(CommutativeFlatMap[IdT[(CSemi, *), *]])
+  )
 
   checkAll("IdT[Option, Int]", CommutativeMonadTests[IdT[Option, *]].commutativeMonad[Int, Int, Int])
   checkAll("CommutativeMonad[IdT[Option, *]]", SerializableTests.serializable(CommutativeMonad[IdT[Option, *]]))
@@ -57,9 +58,11 @@ class IdTSuite extends CatsSuite {
 
   {
     checkAll("IdT[Const[String, *], *]",
-             ContravariantMonoidalTests[IdT[Const[String, *], *]].contravariantMonoidal[Int, Int, Int])
+             ContravariantMonoidalTests[IdT[Const[String, *], *]].contravariantMonoidal[Int, Int, Int]
+    )
     checkAll("ContravariantMonoidal[IdT[Const[String, *], *]]",
-             SerializableTests.serializable(ContravariantMonoidal[IdT[Const[String, *], *]]))
+             SerializableTests.serializable(ContravariantMonoidal[IdT[Const[String, *], *]])
+    )
   }
 
   {
@@ -87,7 +90,8 @@ class IdTSuite extends CatsSuite {
     implicit val F: Traverse[ListWrapper] = ListWrapper.traverse
 
     checkAll("IdT[ListWrapper, Int] with Option",
-             TraverseTests[IdT[ListWrapper, *]].traverse[Int, Int, Int, Int, Option, Option])
+             TraverseTests[IdT[ListWrapper, *]].traverse[Int, Int, Int, Int, Option, Option]
+    )
     checkAll("Traverse[IdT[ListWrapper, *]]", SerializableTests.serializable(Traverse[IdT[ListWrapper, *]]))
   }
 
@@ -95,9 +99,11 @@ class IdTSuite extends CatsSuite {
     implicit val F: Traverse[NonEmptyList] = NonEmptyList.catsDataInstancesForNonEmptyList
 
     checkAll("IdT[NonEmptyList, Int]",
-             NonEmptyTraverseTests[IdT[NonEmptyList, *]].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option])
+             NonEmptyTraverseTests[IdT[NonEmptyList, *]].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option]
+    )
     checkAll("NonEmptyTraverse[IdT[NonEmptyList, *]]",
-             SerializableTests.serializable(NonEmptyTraverse[IdT[NonEmptyList, *]]))
+             SerializableTests.serializable(NonEmptyTraverse[IdT[NonEmptyList, *]])
+    )
   }
 
   test("flatMap and flatMapF consistent") {
diff --git a/tests/src/test/scala/cats/tests/IndexedReaderWriterStateTSuite.scala b/tests/src/test/scala/cats/tests/IndexedReaderWriterStateTSuite.scala
index 02fd56486..643bea5bc 100644
--- a/tests/src/test/scala/cats/tests/IndexedReaderWriterStateTSuite.scala
+++ b/tests/src/test/scala/cats/tests/IndexedReaderWriterStateTSuite.scala
@@ -54,7 +54,8 @@ class ReaderWriterStateTSuite extends CatsSuite {
       (rwsa: ReaderWriterState[String, Vector[Int], Int, Int],
        rwsb: ReaderWriterState[String, Vector[Int], Int, Int],
        c: String,
-       s: Int) =>
+       s: Int
+      ) =>
         val logMap2 = rwsa.map2(rwsb)((_, _) => ()).runL(c, s).value
 
         val (logA, stateA, _) = rwsa.run(c, s).value
@@ -239,7 +240,8 @@ class ReaderWriterStateTSuite extends CatsSuite {
        f: Int => Option[Int],
        initial: String,
        context: String,
-       log: String) =>
+       log: String
+      ) =>
         val flatMap = rwst.flatMap { a =>
           ReaderWriterStateT { (e, s) =>
             f(a).map((log, s, _))
@@ -424,14 +426,16 @@ class ReaderWriterStateTSuite extends CatsSuite {
 
     val SA = IRWST.catsDataAlternativeForIRWST[ListWrapper, Boolean, String, MiniInt](ListWrapper.monad,
                                                                                       ListWrapper.alternative,
-                                                                                      Monoid[String])
+                                                                                      Monoid[String]
+    )
 
     checkAll(
       "IndexedReaderWriterStateT[ListWrapper, String, String, Int, Int, *]",
       AlternativeTests[IRWST[ListWrapper, Boolean, String, MiniInt, MiniInt, *]](SA).alternative[Int, Int, Int]
     )
     checkAll("Alternative[IndexedReaderWriterStateT[ListWrapper, String, String, Int, Int, *]]",
-             SerializableTests.serializable(SA))
+             SerializableTests.serializable(SA)
+    )
   }
 
   {
@@ -490,11 +494,13 @@ object ReaderWriterStateTSuite {
       ((), state + i, state + i)
     }
 
-  implicit def IRWSTEq[F[_], E, L, SA, SB, A](implicit SA: ExhaustiveCheck[SA],
-                                              SB: Arbitrary[SB],
-                                              E: ExhaustiveCheck[E],
-                                              FLSB: Eq[F[(L, SB, A)]],
-                                              F: Monad[F]): Eq[IndexedReaderWriterStateT[F, E, L, SA, SB, A]] =
+  implicit def IRWSTEq[F[_], E, L, SA, SB, A](implicit
+    SA: ExhaustiveCheck[SA],
+    SB: Arbitrary[SB],
+    E: ExhaustiveCheck[E],
+    FLSB: Eq[F[(L, SB, A)]],
+    F: Monad[F]
+  ): Eq[IndexedReaderWriterStateT[F, E, L, SA, SB, A]] =
     Eq.by[IndexedReaderWriterStateT[F, E, L, SA, SB, A], (E, SA) => F[(L, SB, A)]] { state => (e, s) =>
       state.run(e, s)
     }
diff --git a/tests/src/test/scala/cats/tests/IndexedStateTSuite.scala b/tests/src/test/scala/cats/tests/IndexedStateTSuite.scala
index 02138dd70..71c5e1ded 100644
--- a/tests/src/test/scala/cats/tests/IndexedStateTSuite.scala
+++ b/tests/src/test/scala/cats/tests/IndexedStateTSuite.scala
@@ -362,9 +362,11 @@ class IndexedStateTSuite extends CatsSuite {
     implicit val FS: Functor[IndexedStateT[ListWrapper, String, Int, *]] = IndexedStateT.catsDataFunctorForIndexedStateT
 
     checkAll("IndexedStateT[ListWrapper, MiniInt, Int, Int]",
-             FunctorTests[IndexedStateT[ListWrapper, MiniInt, Int, *]].functor[Int, Int, Int])
+             FunctorTests[IndexedStateT[ListWrapper, MiniInt, Int, *]].functor[Int, Int, Int]
+    )
     checkAll("Functor[IndexedStateT[ListWrapper, Int, *]]",
-             SerializableTests.serializable(Functor[IndexedStateT[ListWrapper, String, Int, *]]))
+             SerializableTests.serializable(Functor[IndexedStateT[ListWrapper, String, Int, *]])
+    )
 
     Functor[IndexedStateT[ListWrapper, String, Int, *]]
   }
@@ -374,9 +376,11 @@ class IndexedStateTSuite extends CatsSuite {
     implicit val FF: FunctorFilter[ListWrapper] = ListWrapper.functorFilter
 
     checkAll("IndexedStateT[ListWrapper, MiniInt, Int, *]",
-             FunctorFilterTests[IndexedStateT[ListWrapper, MiniInt, Int, *]].functorFilter[Int, Int, Int])
+             FunctorFilterTests[IndexedStateT[ListWrapper, MiniInt, Int, *]].functorFilter[Int, Int, Int]
+    )
     checkAll("FunctorFilter[IndexedStateT[ListWrapper, MiniInt, Int, *]]",
-             SerializableTests.serializable(FunctorFilter[IndexedStateT[ListWrapper, MiniInt, Int, *]]))
+             SerializableTests.serializable(FunctorFilter[IndexedStateT[ListWrapper, MiniInt, Int, *]])
+    )
 
     FunctorFilter[IndexedStateT[ListWrapper, String, Int, *]]
   }
@@ -387,9 +391,11 @@ class IndexedStateTSuite extends CatsSuite {
       IndexedStateT.catsDataContravariantForIndexedStateT
 
     checkAll("IndexedStateT[ListWrapper, *, Int, Boolean]",
-             ContravariantTests[IndexedStateT[ListWrapper, *, Int, Int]].contravariant[MiniInt, Int, Boolean])
+             ContravariantTests[IndexedStateT[ListWrapper, *, Int, Int]].contravariant[MiniInt, Int, Boolean]
+    )
     checkAll("Contravariant[IndexedStateT[ListWrapper, *, Int, Int]]",
-             SerializableTests.serializable(Contravariant[IndexedStateT[ListWrapper, *, Int, Int]]))
+             SerializableTests.serializable(Contravariant[IndexedStateT[ListWrapper, *, Int, Int]])
+    )
 
     Contravariant[IndexedStateT[ListWrapper, *, Int, Int]]
   }
@@ -399,9 +405,11 @@ class IndexedStateTSuite extends CatsSuite {
     implicit val FS: Bifunctor[IndexedStateT[ListWrapper, Int, *, *]] = IndexedStateT.catsDataBifunctorForIndexedStateT
 
     checkAll("IndexedStateT[ListWrapper, MiniInt, String, Int]",
-             BifunctorTests[IndexedStateT[ListWrapper, MiniInt, *, *]].bifunctor[String, String, String, Int, Int, Int])
+             BifunctorTests[IndexedStateT[ListWrapper, MiniInt, *, *]].bifunctor[String, String, String, Int, Int, Int]
+    )
     checkAll("Bifunctor[IndexedStateT[ListWrapper, Int, *, *]]",
-             SerializableTests.serializable(Bifunctor[IndexedStateT[ListWrapper, Int, *, *]]))
+             SerializableTests.serializable(Bifunctor[IndexedStateT[ListWrapper, Int, *, *]])
+    )
 
     Bifunctor[IndexedStateT[ListWrapper, Int, *, *]]
   }
@@ -412,9 +420,11 @@ class IndexedStateTSuite extends CatsSuite {
       IndexedStateT.catsDataProfunctorForIndexedStateT
 
     checkAll("IndexedStateT[ListWrapper, String, Int, Int]",
-             ProfunctorTests[IndexedStateT[ListWrapper, *, *, Int]].profunctor[MiniInt, String, String, Int, Int, Int])
+             ProfunctorTests[IndexedStateT[ListWrapper, *, *, Int]].profunctor[MiniInt, String, String, Int, Int, Int]
+    )
     checkAll("Profunctor[IndexedStateT[ListWrapper, *, *, Int]]",
-             SerializableTests.serializable(Profunctor[IndexedStateT[ListWrapper, *, *, Int]]))
+             SerializableTests.serializable(Profunctor[IndexedStateT[ListWrapper, *, *, Int]])
+    )
 
     Profunctor[IndexedStateT[ListWrapper, *, *, Int]]
   }
@@ -424,9 +434,11 @@ class IndexedStateTSuite extends CatsSuite {
     implicit val FS: Strong[IndexedStateT[ListWrapper, *, *, Int]] = IndexedStateT.catsDataStrongForIndexedStateT
 
     checkAll("IndexedStateT[ListWrapper, *, *, Int]",
-             StrongTests[IndexedStateT[ListWrapper, *, *, Int]].strong[MiniInt, Int, Boolean, Boolean, Boolean, String])
+             StrongTests[IndexedStateT[ListWrapper, *, *, Int]].strong[MiniInt, Int, Boolean, Boolean, Boolean, String]
+    )
     checkAll("Strong[IndexedStateT[ListWrapper, *, *, Int]]",
-             SerializableTests.serializable(Strong[IndexedStateT[ListWrapper, *, *, Int]]))
+             SerializableTests.serializable(Strong[IndexedStateT[ListWrapper, *, *, Int]])
+    )
 
     Strong[IndexedStateT[ListWrapper, *, *, Int]]
   }
@@ -436,9 +448,11 @@ class IndexedStateTSuite extends CatsSuite {
     implicit val F: Monad[ListWrapper] = ListWrapper.monad
 
     checkAll("IndexedStateT[ListWrapper, MiniInt, Int, *]",
-             MonadTests[IndexedStateT[ListWrapper, MiniInt, MiniInt, *]].monad[Int, Int, Int])
+             MonadTests[IndexedStateT[ListWrapper, MiniInt, MiniInt, *]].monad[Int, Int, Int]
+    )
     checkAll("Monad[IndexedStateT[ListWrapper, Int, Int, *]]",
-             SerializableTests.serializable(Monad[IndexedStateT[ListWrapper, Int, Int, *]]))
+             SerializableTests.serializable(Monad[IndexedStateT[ListWrapper, Int, Int, *]])
+    )
 
     Monad[IndexedStateT[ListWrapper, Int, Int, *]]
     FlatMap[IndexedStateT[ListWrapper, Int, Int, *]]
@@ -453,9 +467,11 @@ class IndexedStateTSuite extends CatsSuite {
     implicit val S: SemigroupK[ListWrapper] = ListWrapper.semigroupK
 
     checkAll("IndexedStateT[ListWrapper, MiniInt, Int, *]",
-             SemigroupKTests[IndexedStateT[ListWrapper, MiniInt, Int, *]].semigroupK[Int])
+             SemigroupKTests[IndexedStateT[ListWrapper, MiniInt, Int, *]].semigroupK[Int]
+    )
     checkAll("SemigroupK[IndexedStateT[ListWrapper, Int, *]]",
-             SerializableTests.serializable(SemigroupK[IndexedStateT[ListWrapper, String, Int, *]]))
+             SerializableTests.serializable(SemigroupK[IndexedStateT[ListWrapper, String, Int, *]])
+    )
   }
 
   {
@@ -467,7 +483,8 @@ class IndexedStateTSuite extends CatsSuite {
         .catsDataAlternativeForIndexedStateT[ListWrapper, MiniInt](ListWrapper.monad, ListWrapper.alternative)
 
     checkAll("IndexedStateT[ListWrapper, MiniInt, Int, Int]",
-             AlternativeTests[IndexedStateT[ListWrapper, MiniInt, MiniInt, *]](SA).alternative[Int, Int, Int])
+             AlternativeTests[IndexedStateT[ListWrapper, MiniInt, MiniInt, *]](SA).alternative[Int, Int, Int]
+    )
     checkAll("Alternative[IndexedStateT[ListWrapper, Int, Int, *]]", SerializableTests.serializable(SA))
 
     Monad[IndexedStateT[ListWrapper, Int, Int, *]]
@@ -494,9 +511,11 @@ class IndexedStateTSuite extends CatsSuite {
       EitherT.catsDataEqForEitherT[StateT[Option, MiniInt, *], Unit, Int]
 
     checkAll("StateT[Option, MiniInt, Int]",
-             MonadErrorTests[StateT[Option, MiniInt, *], Unit].monadError[Int, Int, Int])
+             MonadErrorTests[StateT[Option, MiniInt, *], Unit].monadError[Int, Int, Int]
+    )
     checkAll("MonadError[StateT[Option, Int, *], Unit]",
-             SerializableTests.serializable(MonadError[StateT[Option, Int, *], Unit]))
+             SerializableTests.serializable(MonadError[StateT[Option, Int, *], Unit])
+    )
   }
 
 }
@@ -510,8 +529,10 @@ object IndexedStateTSuite extends IndexedStateTSuiteInstances {
 
 sealed trait IndexedStateTSuiteInstances {
 
-  implicit def indexedStateTEq[F[_], SA, SB, A](implicit SA: ExhaustiveCheck[SA],
-                                                FSB: Eq[F[(SB, A)]],
-                                                F: FlatMap[F]): Eq[IndexedStateT[F, SA, SB, A]] =
+  implicit def indexedStateTEq[F[_], SA, SB, A](implicit
+    SA: ExhaustiveCheck[SA],
+    FSB: Eq[F[(SB, A)]],
+    F: FlatMap[F]
+  ): Eq[IndexedStateT[F, SA, SB, A]] =
     Eq.by[IndexedStateT[F, SA, SB, A], SA => F[(SB, A)]](state => s => state.run(s))
 }
diff --git a/tests/src/test/scala/cats/tests/InjectKSuite.scala b/tests/src/test/scala/cats/tests/InjectKSuite.scala
index e409a04d3..922965314 100644
--- a/tests/src/test/scala/cats/tests/InjectKSuite.scala
+++ b/tests/src/test/scala/cats/tests/InjectKSuite.scala
@@ -15,13 +15,16 @@ class InjectKSuite extends CatsSuite {
   object Test1Algebra {
     implicit def test1AlgebraAFunctor: Functor[Test1Algebra] =
       new Functor[Test1Algebra] {
-        def map[A, B](a: Test1Algebra[A])(f: A => B): Test1Algebra[B] = a match {
-          case Test1(k, h) => Test1(k, x => f(h(x)))
-        }
+        def map[A, B](a: Test1Algebra[A])(f: A => B): Test1Algebra[B] =
+          a match {
+            case Test1(k, h) => Test1(k, x => f(h(x)))
+          }
       }
 
-    implicit def test1AlgebraArbitrary[A](implicit seqArb: Arbitrary[Int],
-                                          intAArb: Arbitrary[Int => A]): Arbitrary[Test1Algebra[A]] =
+    implicit def test1AlgebraArbitrary[A](implicit
+      seqArb: Arbitrary[Int],
+      intAArb: Arbitrary[Int => A]
+    ): Arbitrary[Test1Algebra[A]] =
       Arbitrary(for { s <- seqArb.arbitrary; f <- intAArb.arbitrary } yield Test1(s, f))
 
     implicit def test1AlgebraEq[A](implicit ev: Eq[A]): Eq[Test1Algebra[A]] = Eq.fromUniversalEquals
@@ -34,13 +37,16 @@ class InjectKSuite extends CatsSuite {
   object Test2Algebra {
     implicit def test2AlgebraAFunctor: Functor[Test2Algebra] =
       new Functor[Test2Algebra] {
-        def map[A, B](a: Test2Algebra[A])(f: A => B): Test2Algebra[B] = a match {
-          case Test2(k, h) => Test2(k, x => f(h(x)))
-        }
+        def map[A, B](a: Test2Algebra[A])(f: A => B): Test2Algebra[B] =
+          a match {
+            case Test2(k, h) => Test2(k, x => f(h(x)))
+          }
       }
 
-    implicit def test2AlgebraArbitrary[A](implicit seqArb: Arbitrary[Int],
-                                          intAArb: Arbitrary[Int => A]): Arbitrary[Test2Algebra[A]] =
+    implicit def test2AlgebraArbitrary[A](implicit
+      seqArb: Arbitrary[Int],
+      intAArb: Arbitrary[Int => A]
+    ): Arbitrary[Test2Algebra[A]] =
       Arbitrary(for { s <- seqArb.arbitrary; f <- intAArb.arbitrary } yield Test2(s, f))
 
     implicit def test2AlgebraEq[A](implicit ev: Eq[A]): Eq[Test2Algebra[A]] = Eq.fromUniversalEquals
@@ -48,17 +54,16 @@ class InjectKSuite extends CatsSuite {
 
   type T[A] = EitherK[Test1Algebra, Test2Algebra, A]
 
-  implicit def tArbitrary[A](
-    implicit arb1: Arbitrary[Test1Algebra[A]],
+  implicit def tArbitrary[A](implicit
+    arb1: Arbitrary[Test1Algebra[A]],
     arb2: Arbitrary[Test2Algebra[A]]
   ): Arbitrary[T[A]] =
     Arbitrary(Gen.oneOf(arb1.arbitrary.map(EitherK.leftc(_): T[A]), arb2.arbitrary.map(EitherK.rightc(_): T[A])))
 
   test("inj & prj") {
-    def distr[F[_], A](f1: F[A], f2: F[A])(implicit
-                                           F: Functor[F],
-                                           I0: Test1Algebra :<: F,
-                                           I1: Test2Algebra :<: F): Option[Int] =
+    def distr[F[_], A](f1: F[A],
+                       f2: F[A]
+    )(implicit F: Functor[F], I0: Test1Algebra :<: F, I1: Test2Algebra :<: F): Option[Int] =
       for {
         Test1(x, _) <- I0.prj(f1)
         Test2(y, _) <- I1.prj(f2)
@@ -73,10 +78,9 @@ class InjectKSuite extends CatsSuite {
   }
 
   test("apply & unapply") {
-    def distr[F[_], A](f1: F[A], f2: F[A])(implicit
-                                           F: Functor[F],
-                                           I0: Test1Algebra :<: F,
-                                           I1: Test2Algebra :<: F): Option[Int] =
+    def distr[F[_], A](f1: F[A],
+                       f2: F[A]
+    )(implicit F: Functor[F], I0: Test1Algebra :<: F, I1: Test2Algebra :<: F): Option[Int] =
       for {
         Test1(x, _) <- I0.unapply(f1)
         Test2(y, _) <- I1.unapply(f2)
diff --git a/tests/src/test/scala/cats/tests/InjectSuite.scala b/tests/src/test/scala/cats/tests/InjectSuite.scala
index c28bc0906..af78d04a8 100644
--- a/tests/src/test/scala/cats/tests/InjectSuite.scala
+++ b/tests/src/test/scala/cats/tests/InjectSuite.scala
@@ -8,9 +8,7 @@ class InjectSuite extends CatsSuite {
   type StringOrInt = Either[String, Int]
 
   test("inj & prj") {
-    def distr[F](f1: F, f2: F)(implicit
-                               I0: Inject[String, F],
-                               I1: Inject[Int, F]): Option[String] =
+    def distr[F](f1: F, f2: F)(implicit I0: Inject[String, F], I1: Inject[Int, F]): Option[String] =
       for {
         x <- I0.prj(f1)
         y <- I1.prj(f2)
@@ -25,9 +23,7 @@ class InjectSuite extends CatsSuite {
   }
 
   test("apply & unapply") {
-    def distr[F](f1: F, f2: F)(implicit
-                               I0: Inject[String, F],
-                               I1: Inject[Int, F]): Option[String] =
+    def distr[F](f1: F, f2: F)(implicit I0: Inject[String, F], I1: Inject[Int, F]): Option[String] =
       for {
         x <- I0.unapply(f1)
         y <- I1.unapply(f2)
diff --git a/tests/src/test/scala/cats/tests/IorSuite.scala b/tests/src/test/scala/cats/tests/IorSuite.scala
index c0b07abb7..6f8ebecdc 100644
--- a/tests/src/test/scala/cats/tests/IorSuite.scala
+++ b/tests/src/test/scala/cats/tests/IorSuite.scala
@@ -37,7 +37,8 @@ class IorSuite extends CatsSuite {
 
   checkAll("Semigroup[Ior[A: Semigroup, B: Semigroup]]", SemigroupTests[Ior[List[Int], List[Int]]].semigroup)
   checkAll("SerializableTest Semigroup[Ior[A: Semigroup, B: Semigroup]]",
-           SerializableTests.serializable(Semigroup[Ior[List[Int], List[Int]]]))
+           SerializableTests.serializable(Semigroup[Ior[List[Int], List[Int]]])
+  )
 
   test("left Option is defined left and both") {
     forAll { (i: Int Ior String) =>
diff --git a/tests/src/test/scala/cats/tests/IorTSuite.scala b/tests/src/test/scala/cats/tests/IorTSuite.scala
index 1a99f3d9f..8bf7dc928 100644
--- a/tests/src/test/scala/cats/tests/IorTSuite.scala
+++ b/tests/src/test/scala/cats/tests/IorTSuite.scala
@@ -15,7 +15,8 @@ class IorTSuite extends CatsSuite {
     implicit val F: Functor[ListWrapper] = ListWrapper.functor
 
     checkAll("IorT[ListWrapper, *, *]",
-             BifunctorTests[IorT[ListWrapper, *, *]].bifunctor[Int, Int, Int, String, String, String])
+             BifunctorTests[IorT[ListWrapper, *, *]].bifunctor[Int, Int, Int, String, String, String]
+    )
     checkAll("Bifunctor[IorT[ListWrapper, *, *]]", SerializableTests.serializable(Bifunctor[IorT[ListWrapper, *, *]]))
 
     checkAll("IorT[ListWrapper, Int, *]", FunctorTests[IorT[ListWrapper, Int, *]].functor[Int, Int, Int])
@@ -26,7 +27,8 @@ class IorTSuite extends CatsSuite {
     implicit val F: Traverse[ListWrapper] = ListWrapper.traverse
 
     checkAll("IorT[ListWrapper, Int, *]",
-             TraverseTests[IorT[ListWrapper, Int, *]].traverse[Int, Int, Int, Int, Option, Option])
+             TraverseTests[IorT[ListWrapper, Int, *]].traverse[Int, Int, Int, Int, Option, Option]
+    )
     checkAll("Traverse[IorT[ListWrapper, Int, *]]", SerializableTests.serializable(Traverse[IorT[ListWrapper, Int, *]]))
   }
 
@@ -34,16 +36,20 @@ class IorTSuite extends CatsSuite {
     implicit val F: Monad[ListWrapper] = ListWrapper.monad
 
     checkAll("IorT[ListWrapper, String, Int]",
-             MonadErrorTests[IorT[ListWrapper, String, *], String].monadError[Int, Int, Int])
+             MonadErrorTests[IorT[ListWrapper, String, *], String].monadError[Int, Int, Int]
+    )
     checkAll("MonadError[IorT[List, *, *]]",
-             SerializableTests.serializable(MonadError[IorT[ListWrapper, String, *], String]))
+             SerializableTests.serializable(MonadError[IorT[ListWrapper, String, *], String])
+    )
   }
 
   {
     checkAll("IorT[Option, String, String]",
-             MonadErrorTests[IorT[Option, String, *], Unit].monadError[String, String, String])
+             MonadErrorTests[IorT[Option, String, *], Unit].monadError[String, String, String]
+    )
     checkAll("MonadError[IorT[Option, *, *]]",
-             SerializableTests.serializable(MonadError[IorT[Option, String, *], Unit]))
+             SerializableTests.serializable(MonadError[IorT[Option, String, *], Unit])
+    )
   }
 
   {
@@ -58,7 +64,8 @@ class IorTSuite extends CatsSuite {
 
     checkAll("IorT[ListWrapper, String, Int]", SemigroupTests[IorT[ListWrapper, String, Int]].semigroup)
     checkAll("Semigroup[IorT[ListWrapper, String, Int]]",
-             SerializableTests.serializable(Semigroup[IorT[ListWrapper, String, Int]]))
+             SerializableTests.serializable(Semigroup[IorT[ListWrapper, String, Int]])
+    )
   }
 
   {
@@ -66,7 +73,8 @@ class IorTSuite extends CatsSuite {
 
     checkAll("IorT[ListWrapper, String, Int]", MonoidTests[IorT[ListWrapper, String, Int]].monoid)
     checkAll("Monoid[IorT[ListWrapper, String, Int]]",
-             SerializableTests.serializable(Monoid[IorT[ListWrapper, String, Int]]))
+             SerializableTests.serializable(Monoid[IorT[ListWrapper, String, Int]])
+    )
   }
 
   {
diff --git a/tests/src/test/scala/cats/tests/KleisliSuite.scala b/tests/src/test/scala/cats/tests/KleisliSuite.scala
index 8c0882156..91c269c9e 100644
--- a/tests/src/test/scala/cats/tests/KleisliSuite.scala
+++ b/tests/src/test/scala/cats/tests/KleisliSuite.scala
@@ -34,46 +34,58 @@ class KleisliSuite extends CatsSuite {
     implicit val instance: ApplicativeError[Kleisli[Option, MiniInt, *], Unit] =
       Kleisli.catsDataApplicativeErrorForKleisli[Option, Unit, MiniInt](cats.instances.option.catsStdInstancesForOption)
     checkAll("Kleisli[Option, MinInt, *] with Unit",
-             ApplicativeErrorTests[Kleisli[Option, MiniInt, *], Unit](instance).applicativeError[Int, Int, Int])
+             ApplicativeErrorTests[Kleisli[Option, MiniInt, *], Unit](instance).applicativeError[Int, Int, Int]
+    )
     checkAll("ApplicativeError[Kleisli[Option, Int, Int], Unit]", SerializableTests.serializable(instance))
   }
 
   checkAll("Kleisli[Eval, MiniInt, *]", DeferTests[Kleisli[Eval, MiniInt, *]].defer[Int])
   checkAll("Kleisli[Option, MiniInt, *] with Unit",
-           MonadErrorTests[Kleisli[Option, MiniInt, *], Unit].monadError[Int, Int, Int])
+           MonadErrorTests[Kleisli[Option, MiniInt, *], Unit].monadError[Int, Int, Int]
+  )
   checkAll("MonadError[Kleisli[Option, Int, Int], Unit]",
-           SerializableTests.serializable(MonadError[Kleisli[Option, Int, *], Unit]))
+           SerializableTests.serializable(MonadError[Kleisli[Option, Int, *], Unit])
+  )
 
   checkAll("Kleisli[Option, MiniInt, *]", SemigroupalTests[Kleisli[Option, MiniInt, *]].semigroupal[Int, Int, Int])
   checkAll("Semigroupal[Kleisli[Option, Int, *]]", SerializableTests.serializable(Semigroupal[Kleisli[Option, Int, *]]))
 
   checkAll("Kleisli[(CSemi, *), MiniInt, *]",
-           CommutativeFlatMapTests[Kleisli[(CSemi, *), MiniInt, *]].commutativeFlatMap[Int, Int, Int])
+           CommutativeFlatMapTests[Kleisli[(CSemi, *), MiniInt, *]].commutativeFlatMap[Int, Int, Int]
+  )
   checkAll("CommutativeFlatMap[Kleisli[(CSemi, *), Int, *]]",
-           SerializableTests.serializable(CommutativeFlatMap[Kleisli[(CSemi, *), Int, *]]))
+           SerializableTests.serializable(CommutativeFlatMap[Kleisli[(CSemi, *), Int, *]])
+  )
 
   checkAll("Kleisli[Option, MiniInt, *]",
-           CommutativeMonadTests[Kleisli[Option, MiniInt, *]].commutativeMonad[Int, Int, Int])
+           CommutativeMonadTests[Kleisli[Option, MiniInt, *]].commutativeMonad[Int, Int, Int]
+  )
   checkAll("CommutativeMonad[Kleisli[Option, Int, *]]",
-           SerializableTests.serializable(CommutativeMonad[Kleisli[Option, Int, *]]))
+           SerializableTests.serializable(CommutativeMonad[Kleisli[Option, Int, *]])
+  )
 
   checkAll("Kleisli[Id, MiniInt, *]", CommutativeMonadTests[Kleisli[Id, MiniInt, *]].commutativeMonad[Int, Int, Int])
   checkAll("CommutativeMonad[Kleisli[Id, Int, *]]",
-           SerializableTests.serializable(CommutativeMonad[Kleisli[Id, Int, *]]))
+           SerializableTests.serializable(CommutativeMonad[Kleisli[Id, Int, *]])
+  )
 
   checkAll("Kleisli[List, *, *]",
-           ArrowTests[Kleisli[List, *, *]].arrow[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, Boolean])
+           ArrowTests[Kleisli[List, *, *]].arrow[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, Boolean]
+  )
   checkAll("Arrow[Kleisli[List, *, *]]", SerializableTests.serializable(Arrow[Kleisli[List, *, *]]))
 
   checkAll("Kleisli[List, *, *]",
-           ArrowChoiceTests[Kleisli[List, *, *]].arrowChoice[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, Boolean])
+           ArrowChoiceTests[Kleisli[List, *, *]].arrowChoice[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, Boolean]
+  )
   checkAll("ArrowChoice[Kleisli[List, *, *]]", SerializableTests.serializable(ArrowChoice[Kleisli[List, *, *]]))
 
   checkAll("Kleisli[Option, Int, Int]",
            CommutativeArrowTests[Kleisli[Option, *, *]]
-             .commutativeArrow[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, Boolean])
+             .commutativeArrow[MiniInt, MiniInt, MiniInt, MiniInt, MiniInt, Boolean]
+  )
   checkAll("CommutativeArrow[Kleisli[Option, *, *]]",
-           SerializableTests.serializable(CommutativeArrow[Kleisli[Option, *, *]]))
+           SerializableTests.serializable(CommutativeArrow[Kleisli[Option, *, *]])
+  )
 
   checkAll("Kleisli[Option, *, *]", ChoiceTests[Kleisli[Option, *, *]].choice[MiniInt, Boolean, Int, Int])
   checkAll("Choice[Kleisli[Option, *, *]]", SerializableTests.serializable(Choice[Kleisli[Option, *, *]]))
@@ -85,7 +97,8 @@ class KleisliSuite extends CatsSuite {
   checkAll("Monad[Reader[*, *], Int]", SerializableTests.serializable(Monad[Reader[Int, *]]))
 
   checkAll("Kleisli[Option, *, *]",
-           StrongTests[Kleisli[Option, *, *]].strong[MiniInt, Boolean, Boolean, Boolean, Boolean, Int])
+           StrongTests[Kleisli[Option, *, *]].strong[MiniInt, Boolean, Boolean, Boolean, Boolean, Int]
+  )
   checkAll("Strong[Kleisli[Option, *, *]]", SerializableTests.serializable(Strong[Kleisli[Option, *, *]]))
 
   checkAll("Kleisli[Option, MiniInt, Int]", FlatMapTests[Kleisli[Option, MiniInt, *]].flatMap[Int, Int, Int])
@@ -95,9 +108,11 @@ class KleisliSuite extends CatsSuite {
   checkAll("Alternative[Kleisli[Option, Int, *]]", SerializableTests.serializable(Alternative[Kleisli[Option, Int, *]]))
 
   checkAll("Kleisli[Const[String, *], MiniInt, *]",
-           ContravariantMonoidalTests[Kleisli[Const[String, *], MiniInt, *]].contravariantMonoidal[Int, Int, Int])
+           ContravariantMonoidalTests[Kleisli[Const[String, *], MiniInt, *]].contravariantMonoidal[Int, Int, Int]
+  )
   checkAll("ContravariantMonoidal[Kleisli[Option, Int, *]]",
-           SerializableTests.serializable(ContravariantMonoidal[Kleisli[Const[String, *], Int, *]]))
+           SerializableTests.serializable(ContravariantMonoidal[Kleisli[Const[String, *], Int, *]])
+  )
 
   checkAll("Kleisli[Option, MiniInt, Int]", ApplicativeTests[Kleisli[Option, MiniInt, *]].applicative[Int, Int, Int])
   checkAll("Applicative[Kleisli[Option, Int, *]]", SerializableTests.serializable(Applicative[Kleisli[Option, Int, *]]))
@@ -112,24 +127,29 @@ class KleisliSuite extends CatsSuite {
     implicit val FF: FunctorFilter[ListWrapper] = ListWrapper.functorFilter
 
     checkAll("Kleisli[ListWrapper, MiniInt, *]",
-             FunctorFilterTests[Kleisli[ListWrapper, MiniInt, *]].functorFilter[Int, Int, Int])
+             FunctorFilterTests[Kleisli[ListWrapper, MiniInt, *]].functorFilter[Int, Int, Int]
+    )
     checkAll("FunctorFilter[Kleisli[ListWrapper, MiniInt, *]]",
-             SerializableTests.serializable(FunctorFilter[Kleisli[ListWrapper, MiniInt, *]]))
+             SerializableTests.serializable(FunctorFilter[Kleisli[ListWrapper, MiniInt, *]])
+    )
 
     FunctorFilter[ReaderT[ListWrapper, Int, *]]
   }
 
   checkAll("Kleisli[Function0, MiniInt, *]",
-           DistributiveTests[Kleisli[Function0, MiniInt, *]].distributive[Int, Int, Int, Option, Id])
+           DistributiveTests[Kleisli[Function0, MiniInt, *]].distributive[Int, Int, Int, Option, Id]
+  )
   checkAll("Distributive[Kleisli[Function0, Int, *]]",
-           SerializableTests.serializable(Distributive[Kleisli[Function0, Int, *]]))
+           SerializableTests.serializable(Distributive[Kleisli[Function0, Int, *]])
+  )
 
   checkAll("Kleisli[Option, MiniInt, String]", MonoidTests[Kleisli[Option, MiniInt, String]].monoid)
   checkAll("Monoid[Kleisli[Option, Int, String]]", SerializableTests.serializable(Monoid[Kleisli[Option, Int, String]]))
 
   checkAll("Kleisli[Option, MiniInt, String]", SemigroupTests[Kleisli[Option, MiniInt, String]].semigroup)
   checkAll("Semigroup[Kleisli[Option, Int, String]]",
-           SerializableTests.serializable(Semigroup[Kleisli[Option, Int, String]]))
+           SerializableTests.serializable(Semigroup[Kleisli[Option, Int, String]])
+  )
 
   {
     implicit val catsDataMonoidKForKleisli: MonoidK[Î»[Î± => Kleisli[Option, Î±, Î±]]] = Kleisli.endoMonoidK[Option]
@@ -142,12 +162,14 @@ class KleisliSuite extends CatsSuite {
       Kleisli.endoSemigroupK[Option]
     checkAll("Kleisli[Option, MiniInt, MiniInt]", SemigroupKTests[Î»[Î± => Kleisli[Option, Î±, Î±]]].semigroupK[MiniInt])
     checkAll("SemigroupK[Î»[Î± => Kleisli[Option, Î±, Î±]]]",
-             SerializableTests.serializable(SemigroupK[Î»[Î± => Kleisli[Option, Î±, Î±]]]))
+             SerializableTests.serializable(SemigroupK[Î»[Î± => Kleisli[Option, Î±, Î±]]])
+    )
   }
 
   checkAll("Kleisli[Option, MiniInt, Int]", SemigroupKTests[Kleisli[Option, MiniInt, *]].semigroupK[Int])
   checkAll("SemigroupK[Kleisli[Option, String, *]]",
-           SerializableTests.serializable(SemigroupK[Kleisli[Option, String, *]]))
+           SerializableTests.serializable(SemigroupK[Kleisli[Option, String, *]])
+  )
 
   checkAll("Kleisli[Option, MiniInt, *]", MonoidKTests[Kleisli[Option, MiniInt, *]].monoidK[Int])
   checkAll("MonoidK[Kleisli[Option, String, *]]", SerializableTests.serializable(MonoidK[Kleisli[Option, String, *]]))
@@ -156,7 +178,8 @@ class KleisliSuite extends CatsSuite {
 
   checkAll("Kleisli[Option, *, Int]", ContravariantTests[Kleisli[Option, *, Int]].contravariant[MiniInt, Int, Boolean])
   checkAll("Contravariant[Kleisli[Option, *, Int]]",
-           SerializableTests.serializable(Contravariant[Kleisli[Option, *, Int]]))
+           SerializableTests.serializable(Contravariant[Kleisli[Option, *, Int]])
+  )
 
   test("Functor[Kleisli[F, Int, *]] is not ambiguous when an ApplicativeError and a FlatMap are in scope for F") {
     def shouldCompile1[F[_], E](implicit F: ApplicativeError[F, E], FM: FlatMap[F]): Functor[Kleisli[F, Int, *]] =
diff --git a/tests/src/test/scala/cats/tests/ListSuite.scala b/tests/src/test/scala/cats/tests/ListSuite.scala
index 5124f6880..b7672012c 100644
--- a/tests/src/test/scala/cats/tests/ListSuite.scala
+++ b/tests/src/test/scala/cats/tests/ListSuite.scala
@@ -43,6 +43,7 @@ class ListSuite extends CatsSuite {
   checkAll("Align[List]", SerializableTests.serializable(Align[List]))
 
   checkAll("List[Int]", ShortCircuitingTests[List].traverseFilter[Int])
+  checkAll("List[Int]", ShortCircuitingTests[List].foldable[Int])
 
   checkAll("ZipList[Int]", CommutativeApplyTests[ZipList].commutativeApply[Int, Int, Int])
 
diff --git a/tests/src/test/scala/cats/tests/MapSuite.scala b/tests/src/test/scala/cats/tests/MapSuite.scala
index b4a38da9b..b70836639 100644
--- a/tests/src/test/scala/cats/tests/MapSuite.scala
+++ b/tests/src/test/scala/cats/tests/MapSuite.scala
@@ -27,7 +27,8 @@ class MapSuite extends CatsSuite {
   checkAll("FlatMap[Map[Int, *]]", SerializableTests.serializable(FlatMap[Map[Int, *]]))
 
   checkAll("Map[Int, Int] with Option",
-           UnorderedTraverseTests[Map[Int, *]].unorderedTraverse[Int, Int, Int, Option, Option])
+           UnorderedTraverseTests[Map[Int, *]].unorderedTraverse[Int, Int, Int, Option, Option]
+  )
   checkAll("UnorderedTraverse[Map[Int, *]]", SerializableTests.serializable(UnorderedTraverse[Map[Int, *]]))
 
   checkAll("Map[Int, Int]", FunctorFilterTests[Map[Int, *]].functorFilter[Int, Int, Int])
diff --git a/tests/src/test/scala/cats/tests/NestedSuite.scala b/tests/src/test/scala/cats/tests/NestedSuite.scala
index d742e0f00..71426fad2 100644
--- a/tests/src/test/scala/cats/tests/NestedSuite.scala
+++ b/tests/src/test/scala/cats/tests/NestedSuite.scala
@@ -20,9 +20,11 @@ class NestedSuite extends CatsSuite {
     // Invariant composition
     implicit val instance: Invariant[ListWrapper] = ListWrapper.invariant
     checkAll("Nested[ListWrapper, ListWrapper]",
-             InvariantTests[Nested[ListWrapper, ListWrapper, *]].invariant[Int, Int, Int])
+             InvariantTests[Nested[ListWrapper, ListWrapper, *]].invariant[Int, Int, Int]
+    )
     checkAll("Invariant[Nested[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(Invariant[Nested[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(Invariant[Nested[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
@@ -30,9 +32,11 @@ class NestedSuite extends CatsSuite {
     implicit val instance: FunctorFilter[ListWrapper] = ListWrapper.functorFilter
     implicit val functorInstance: Functor[ListWrapper] = ListWrapper.functor
     checkAll("Nested[ListWrapper, ListWrapper]",
-             FunctorFilterTests[Nested[ListWrapper, ListWrapper, *]].functorFilter[Int, Int, Int])
+             FunctorFilterTests[Nested[ListWrapper, ListWrapper, *]].functorFilter[Int, Int, Int]
+    )
     checkAll("FunctorFilter[Nested[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(FunctorFilter[Nested[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(FunctorFilter[Nested[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
@@ -40,9 +44,11 @@ class NestedSuite extends CatsSuite {
     implicit val instance: TraverseFilter[ListWrapper] = ListWrapper.traverseFilter
     implicit val traverseInstance: Traverse[ListWrapper] = ListWrapper.traverse
     checkAll("Nested[ListWrapper, ListWrapper]",
-             TraverseFilterTests[Nested[ListWrapper, ListWrapper, *]].traverseFilter[Int, Int, Int])
+             TraverseFilterTests[Nested[ListWrapper, ListWrapper, *]].traverseFilter[Int, Int, Int]
+    )
     checkAll("TraverseFilter[Nested[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(TraverseFilter[Nested[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(TraverseFilter[Nested[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
@@ -50,16 +56,19 @@ class NestedSuite extends CatsSuite {
     val instance: Invariant[Nested[ListWrapper, ListWrapper, *]] =
       Nested.catsDataInvariantForCovariantNested(ListWrapper.invariant, ListWrapper.functor)
     checkAll("Nested[ListWrapper, ListWrapper] - Invariant + Covariant",
-             InvariantTests[Nested[ListWrapper, ListWrapper, *]](instance).invariant[Int, Int, Int])
+             InvariantTests[Nested[ListWrapper, ListWrapper, *]](instance).invariant[Int, Int, Int]
+    )
     checkAll("Invariant[Nested[ListWrapper, ListWrapper, *]] - Invariant + Covariant",
-             SerializableTests.serializable(instance))
+             SerializableTests.serializable(instance)
+    )
   }
 
   {
     // Invariant + Contravariant = Invariant
     val instance = Nested.catsDataInvariantForNestedContravariant(ListWrapper.invariant, Contravariant[Show])
     checkAll("Nested[ListWrapper, Show, *]",
-             InvariantTests[Nested[ListWrapper, Show, *]](instance).invariant[MiniInt, Int, Boolean])
+             InvariantTests[Nested[ListWrapper, Show, *]](instance).invariant[MiniInt, Int, Boolean]
+    )
     checkAll("Invariant[Nested[ListWrapper, Show, *]]", SerializableTests.serializable(instance))
   }
 
@@ -68,32 +77,39 @@ class NestedSuite extends CatsSuite {
     implicit val instance: Functor[ListWrapper] = ListWrapper.functor
     checkAll("Nested[Option, ListWrapper, *]", FunctorTests[Nested[Option, ListWrapper, *]].functor[Int, Int, Int])
     checkAll("Functor[Nested[Option, ListWrapper, *]]",
-             SerializableTests.serializable(Functor[Nested[Option, ListWrapper, *]]))
+             SerializableTests.serializable(Functor[Nested[Option, ListWrapper, *]])
+    )
   }
 
   {
     // Covariant + contravariant functor composition
     checkAll("Nested[Option, Show, *]",
-             ContravariantTests[Nested[Option, Show, *]].contravariant[MiniInt, Int, Boolean])
+             ContravariantTests[Nested[Option, Show, *]].contravariant[MiniInt, Int, Boolean]
+    )
     checkAll("Contravariant[Nested[Option, Show, *]]",
-             SerializableTests.serializable(Contravariant[Nested[Option, Show, *]]))
+             SerializableTests.serializable(Contravariant[Nested[Option, Show, *]])
+    )
   }
 
   {
     // InvariantSemigroupal + Apply functor composition
     implicit val instance: InvariantSemigroupal[ListWrapper] = ListWrapper.invariantSemigroupal
     checkAll("Nested[ListWrapper, Option, *]",
-             InvariantSemigroupalTests[Nested[ListWrapper, Option, *]].invariantSemigroupal[Int, Int, Int])
+             InvariantSemigroupalTests[Nested[ListWrapper, Option, *]].invariantSemigroupal[Int, Int, Int]
+    )
     checkAll("InvariantSemigroupal[Nested[ListWrapper, Const[String, *], *]",
-             SerializableTests.serializable(InvariantSemigroupal[Nested[ListWrapper, Option, *]]))
+             SerializableTests.serializable(InvariantSemigroupal[Nested[ListWrapper, Option, *]])
+    )
   }
 
   {
     // Applicative + ContravariantMonoidal functor composition
     checkAll("Nested[Option, Const[String, *], *]",
-             ContravariantMonoidalTests[Nested[Option, Const[String, *], *]].contravariantMonoidal[Int, Int, Int])
+             ContravariantMonoidalTests[Nested[Option, Const[String, *], *]].contravariantMonoidal[Int, Int, Int]
+    )
     checkAll("ContravariantMonoidal[Nested[Option, Const[String, *], *]",
-             SerializableTests.serializable(ContravariantMonoidal[Nested[Option, Const[String, *], *]]))
+             SerializableTests.serializable(ContravariantMonoidal[Nested[Option, Const[String, *], *]])
+    )
   }
 
   {
@@ -101,15 +117,18 @@ class NestedSuite extends CatsSuite {
     type ConstInt[A] = Const[Int, A]
     checkAll("Nested[Const[Int, *], Show, *]", FunctorTests[Nested[ConstInt, Show, *]].functor[Int, Int, Int])
     checkAll("Functor[Nested[Const[Int, *], Show, *]]",
-             SerializableTests.serializable(Functor[Nested[ConstInt, Show, *]]))
+             SerializableTests.serializable(Functor[Nested[ConstInt, Show, *]])
+    )
   }
 
   {
     // Contravariant + Functor = Contravariant
     checkAll("Nested[Show, Option, *]",
-             ContravariantTests[Nested[Show, Option, *]].contravariant[MiniInt, Int, Boolean])
+             ContravariantTests[Nested[Show, Option, *]].contravariant[MiniInt, Int, Boolean]
+    )
     checkAll("Contravariant[Nested[Show, Option, *]]",
-             SerializableTests.serializable(Contravariant[Nested[Show, Option, *]]))
+             SerializableTests.serializable(Contravariant[Nested[Show, Option, *]])
+    )
   }
 
   {
@@ -122,9 +141,11 @@ class NestedSuite extends CatsSuite {
   {
     // CommutativeApply composition
     checkAll("Nested[Option, Validated[Int, *], *]",
-             CommutativeApplyTests[Nested[Option, Validated[Int, *], *]].commutativeApply[Int, Int, Int])
+             CommutativeApplyTests[Nested[Option, Validated[Int, *], *]].commutativeApply[Int, Int, Int]
+    )
     checkAll("CommutativeApply[Nested[Option, Validated[Int, *], *], *]]",
-             SerializableTests.serializable(CommutativeApply[Nested[Option, Validated[Int, *], *]]))
+             SerializableTests.serializable(CommutativeApply[Nested[Option, Validated[Int, *], *]])
+    )
   }
 
   {
@@ -132,16 +153,19 @@ class NestedSuite extends CatsSuite {
     implicit val instance: Applicative[ListWrapper] = ListWrapper.applicative
     checkAll("Nested[List, ListWrapper, *]", ApplicativeTests[Nested[List, ListWrapper, *]].applicative[Int, Int, Int])
     checkAll("Applicative[Nested[List, ListWrapper, *]]",
-             SerializableTests.serializable(Applicative[Nested[List, ListWrapper, *]]))
+             SerializableTests.serializable(Applicative[Nested[List, ListWrapper, *]])
+    )
   }
 
   {
     // CommutativeApplicative composition
     implicit val instance: Applicative[ListWrapper] = ListWrapper.applicative
     checkAll("Nested[Option, Validated[Int, *], *]",
-             CommutativeApplicativeTests[Nested[Option, Validated[Int, *], *]].commutativeApplicative[Int, Int, Int])
+             CommutativeApplicativeTests[Nested[Option, Validated[Int, *], *]].commutativeApplicative[Int, Int, Int]
+    )
     checkAll("CommutativeApplicative[Nested[List, ListWrapper, *]]",
-             SerializableTests.serializable(CommutativeApplicative[Nested[Option, Validated[Int, *], *]]))
+             SerializableTests.serializable(CommutativeApplicative[Nested[Option, Validated[Int, *], *]])
+    )
   }
 
   {
@@ -163,7 +187,8 @@ class NestedSuite extends CatsSuite {
     implicit val instance: Alternative[ListWrapper] = ListWrapper.alternative
     checkAll("Nested[List, ListWrapper, *]", AlternativeTests[Nested[List, ListWrapper, *]].alternative[Int, Int, Int])
     checkAll("Alternative[Nested[List, ListWrapper, *]]",
-             SerializableTests.serializable(Alternative[Nested[List, ListWrapper, *]]))
+             SerializableTests.serializable(Alternative[Nested[List, ListWrapper, *]])
+    )
   }
 
   {
@@ -171,25 +196,30 @@ class NestedSuite extends CatsSuite {
     implicit val instance: Foldable[ListWrapper] = ListWrapper.foldable
     checkAll("Nested[List, ListWrapper, *]", FoldableTests[Nested[List, ListWrapper, *]].foldable[Int, Int])
     checkAll("Foldable[Nested[List, ListWrapper, *]]",
-             SerializableTests.serializable(Foldable[Nested[List, ListWrapper, *]]))
+             SerializableTests.serializable(Foldable[Nested[List, ListWrapper, *]])
+    )
   }
 
   {
     // Traverse composition
     implicit val instance: Traverse[ListWrapper] = ListWrapper.traverse
     checkAll("Nested[List, ListWrapper, *]",
-             TraverseTests[Nested[List, ListWrapper, *]].traverse[Int, Int, Int, Set[Int], Option, Option])
+             TraverseTests[Nested[List, ListWrapper, *]].traverse[Int, Int, Int, Set[Int], Option, Option]
+    )
     checkAll("Traverse[Nested[List, ListWrapper, *]]",
-             SerializableTests.serializable(Traverse[Nested[List, ListWrapper, *]]))
+             SerializableTests.serializable(Traverse[Nested[List, ListWrapper, *]])
+    )
   }
 
   {
     // Reducible composition
     implicit val instance: Foldable[ListWrapper] = ListWrapper.foldable
     checkAll("Nested[NonEmptyList, OneAnd[ListWrapper, *], *]",
-             ReducibleTests[Nested[NonEmptyList, OneAnd[ListWrapper, *], *]].reducible[Option, Int, Int])
+             ReducibleTests[Nested[NonEmptyList, OneAnd[ListWrapper, *], *]].reducible[Option, Int, Int]
+    )
     checkAll("Reducible[Nested[NonEmptyList, OneAnd[ListWrapper, *], *]]",
-             SerializableTests.serializable(Reducible[Nested[NonEmptyList, OneAnd[ListWrapper, *], *]]))
+             SerializableTests.serializable(Reducible[Nested[NonEmptyList, OneAnd[ListWrapper, *], *]])
+    )
   }
 
   {
@@ -200,7 +230,8 @@ class NestedSuite extends CatsSuite {
         .nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option]
     )
     checkAll("NonEmptyTraverse[Nested[NonEmptyList, NonEmptyVector, *]]",
-             SerializableTests.serializable(NonEmptyTraverse[Nested[NonEmptyList, NonEmptyVector, *]]))
+             SerializableTests.serializable(NonEmptyTraverse[Nested[NonEmptyList, NonEmptyVector, *]])
+    )
   }
 
   {
@@ -208,7 +239,8 @@ class NestedSuite extends CatsSuite {
     implicit val instance: SemigroupK[ListWrapper] = ListWrapper.semigroupK
     checkAll("Nested[ListWrapper, Option, *]", SemigroupKTests[Nested[ListWrapper, Option, *]].semigroupK[Int])
     checkAll("SemigroupK[Nested[ListWrapper, Option, *]]",
-             SerializableTests.serializable(SemigroupK[Nested[ListWrapper, Option, *]]))
+             SerializableTests.serializable(SemigroupK[Nested[ListWrapper, Option, *]])
+    )
   }
 
   {
@@ -216,7 +248,8 @@ class NestedSuite extends CatsSuite {
     implicit val instance: MonoidK[ListWrapper] = ListWrapper.monoidK
     checkAll("Nested[ListWrapper, Option, *]", MonoidKTests[Nested[ListWrapper, Option, *]].monoidK[Int])
     checkAll("MonoidK[Nested[ListWrapper, Option, *]]",
-             SerializableTests.serializable(MonoidK[Nested[ListWrapper, Option, *]]))
+             SerializableTests.serializable(MonoidK[Nested[ListWrapper, Option, *]])
+    )
   }
 
   {
@@ -227,6 +260,7 @@ class NestedSuite extends CatsSuite {
       DistributiveTests[Nested[Function1[MiniInt, *], Function0, *]].distributive[Int, Int, Int, Option, Function0]
     )
     checkAll("Distributive[Nested[Function1[Int,*], Function0, *]]",
-             SerializableTests.serializable(Distributive[Nested[Function1[Int, *], Function0, *]]))
+             SerializableTests.serializable(Distributive[Nested[Function1[Int, *], Function0, *]])
+    )
   }
 }
diff --git a/tests/src/test/scala/cats/tests/NonEmptyChainSuite.scala b/tests/src/test/scala/cats/tests/NonEmptyChainSuite.scala
index 55eacddf4..745f751cc 100644
--- a/tests/src/test/scala/cats/tests/NonEmptyChainSuite.scala
+++ b/tests/src/test/scala/cats/tests/NonEmptyChainSuite.scala
@@ -25,7 +25,8 @@ class NonEmptyChainSuite extends NonEmptyCollectionSuite[Chain, NonEmptyChain, N
   checkAll("SemigroupK[NonEmptyChain]", SerializableTests.serializable(SemigroupK[NonEmptyChain]))
 
   checkAll("NonEmptyChain[Int] with Option",
-           NonEmptyTraverseTests[NonEmptyChain].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option])
+           NonEmptyTraverseTests[NonEmptyChain].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option]
+  )
   checkAll("NonEmptyTraverse[NonEmptyChain]", SerializableTests.serializable(Traverse[NonEmptyChain]))
 
   checkAll("NonEmptyChain[Int]", BimonadTests[NonEmptyChain].bimonad[Int, Int, Int])
@@ -46,7 +47,8 @@ class NonEmptyChainSuite extends NonEmptyCollectionSuite[Chain, NonEmptyChain, N
     implicit val partialOrder: PartialOrder[ListWrapper[Int]] = ListWrapper.partialOrder[Int]
     checkAll("NonEmptyChain[ListWrapper[Int]]", PartialOrderTests[NonEmptyChain[ListWrapper[Int]]].partialOrder)
     checkAll("PartialOrder[NonEmptyChain[ListWrapper[Int]]",
-             SerializableTests.serializable(PartialOrder[NonEmptyChain[ListWrapper[Int]]]))
+             SerializableTests.serializable(PartialOrder[NonEmptyChain[ListWrapper[Int]]])
+    )
   }
 
   {
diff --git a/tests/src/test/scala/cats/tests/NonEmptyCollectionSuite.scala b/tests/src/test/scala/cats/tests/NonEmptyCollectionSuite.scala
index 6433a542c..2eb7ffd5b 100644
--- a/tests/src/test/scala/cats/tests/NonEmptyCollectionSuite.scala
+++ b/tests/src/test/scala/cats/tests/NonEmptyCollectionSuite.scala
@@ -3,8 +3,8 @@ package cats.tests
 import cats.data.NonEmptyCollection
 import org.scalacheck.Arbitrary
 
-abstract class NonEmptyCollectionSuite[U[+_], NE[+_], NEC[x] <: NonEmptyCollection[x, U, NE]](
-  implicit arbitraryU: Arbitrary[U[Int]],
+abstract class NonEmptyCollectionSuite[U[+_], NE[+_], NEC[x] <: NonEmptyCollection[x, U, NE]](implicit
+  arbitraryU: Arbitrary[U[Int]],
   arbitraryNE: Arbitrary[NE[Int]]
 ) extends CatsSuite {
   protected def toList[A](value: NE[A]): List[A]
diff --git a/tests/src/test/scala/cats/tests/NonEmptyListSuite.scala b/tests/src/test/scala/cats/tests/NonEmptyListSuite.scala
index 8843dc501..c53a400ca 100644
--- a/tests/src/test/scala/cats/tests/NonEmptyListSuite.scala
+++ b/tests/src/test/scala/cats/tests/NonEmptyListSuite.scala
@@ -33,7 +33,8 @@ class NonEmptyListSuite extends NonEmptyCollectionSuite[List, NonEmptyList, NonE
   checkAll("NonEmptyList[Int]", OrderTests[NonEmptyList[Int]].order)
 
   checkAll("NonEmptyList[Int] with Option",
-           NonEmptyTraverseTests[NonEmptyList].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option])
+           NonEmptyTraverseTests[NonEmptyList].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option]
+  )
   checkAll("NonEmptyTraverse[NonEmptyList[A]]", SerializableTests.serializable(NonEmptyTraverse[NonEmptyList]))
 
   checkAll("NonEmptyList[Int]", ReducibleTests[NonEmptyList].reducible[Option, Int, Int])
@@ -62,7 +63,8 @@ class NonEmptyListSuite extends NonEmptyCollectionSuite[List, NonEmptyList, NonE
     implicit val A: PartialOrder[ListWrapper[Int]] = ListWrapper.partialOrder[Int]
     checkAll("NonEmptyList[ListWrapper[Int]]", PartialOrderTests[NonEmptyList[ListWrapper[Int]]].partialOrder)
     checkAll("PartialOrder[NonEmptyList[ListWrapper[Int]]]",
-             SerializableTests.serializable(PartialOrder[NonEmptyList[ListWrapper[Int]]]))
+             SerializableTests.serializable(PartialOrder[NonEmptyList[ListWrapper[Int]]])
+    )
 
     Eq[NonEmptyList[ListWrapper[Int]]]
   }
@@ -71,7 +73,8 @@ class NonEmptyListSuite extends NonEmptyCollectionSuite[List, NonEmptyList, NonE
     implicit val A: Order[ListWrapper[Int]] = ListWrapper.order[Int]
     checkAll("NonEmptyList[ListWrapper[Int]]", OrderTests[NonEmptyList[ListWrapper[Int]]].order)
     checkAll("Order[NonEmptyList[ListWrapper[Int]]]",
-             SerializableTests.serializable(Order[NonEmptyList[ListWrapper[Int]]]))
+             SerializableTests.serializable(Order[NonEmptyList[ListWrapper[Int]]])
+    )
 
     Eq[NonEmptyList[ListWrapper[Int]]]
     PartialOrder[NonEmptyList[ListWrapper[Int]]]
@@ -382,7 +385,7 @@ class ReducibleNonEmptyListSuite extends ReducibleSuite[NonEmptyList]("NonEmptyL
     // if we inline this we get a bewildering implicit numeric widening
     // error message in Scala 2.10
     val tailStart: Long = start + 1L
-    NonEmptyList(start, (tailStart).to(endInclusive).toList)
+    NonEmptyList(start, tailStart.to(endInclusive).toList)
   }
 
   def fromValues[A](el: A, els: A*): NonEmptyList[A] = NonEmptyList(el, List(els: _*))
diff --git a/tests/src/test/scala/cats/tests/NonEmptySetSuite.scala b/tests/src/test/scala/cats/tests/NonEmptySetSuite.scala
index 82edb0f23..4331434d2 100644
--- a/tests/src/test/scala/cats/tests/NonEmptySetSuite.scala
+++ b/tests/src/test/scala/cats/tests/NonEmptySetSuite.scala
@@ -31,7 +31,8 @@ class NonEmptySetSuite extends CatsSuite {
 
     checkAll("NonEmptySet[ListWrapper[Int]]", OrderTests[NonEmptySet[ListWrapper[Int]]].order)
     checkAll("Order[NonEmptySet[ListWrapper[Int]]]",
-             SerializableTests.serializable(Order[NonEmptySet[ListWrapper[Int]]]))
+             SerializableTests.serializable(Order[NonEmptySet[ListWrapper[Int]]])
+    )
 
     Eq[NonEmptySet[ListWrapper[Int]]]
     PartialOrder[NonEmptySet[ListWrapper[Int]]]
diff --git a/tests/src/test/scala/cats/tests/NonEmptyVectorSuite.scala b/tests/src/test/scala/cats/tests/NonEmptyVectorSuite.scala
index 31e66a5c6..4f50ccf23 100644
--- a/tests/src/test/scala/cats/tests/NonEmptyVectorSuite.scala
+++ b/tests/src/test/scala/cats/tests/NonEmptyVectorSuite.scala
@@ -52,7 +52,8 @@ class NonEmptyVectorSuite extends NonEmptyCollectionSuite[Vector, NonEmptyVector
   checkAll("NonEmptyVector[Int]", EqTests[NonEmptyVector[Int]].eqv)
 
   checkAll("NonEmptyVector[Int] with Option",
-           NonEmptyTraverseTests[NonEmptyVector].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option])
+           NonEmptyTraverseTests[NonEmptyVector].nonEmptyTraverse[Option, Int, Int, Int, Int, Option, Option]
+  )
   checkAll("NonEmptyTraverse[NonEmptyVector[A]]", SerializableTests.serializable(NonEmptyTraverse[NonEmptyVector]))
 
   checkAll("NonEmptyVector[Int]", ReducibleTests[NonEmptyVector].reducible[Option, Int, Int])
@@ -393,7 +394,7 @@ class NonEmptyVectorSuite extends NonEmptyCollectionSuite[Vector, NonEmptyVector
 
   test("NonEmptyVector#collect is consistent with Vector#collect") {
     val pf: PartialFunction[Int, Double] = {
-      case i if (i % 2 == 0) => i.toDouble
+      case i if i % 2 == 0 => i.toDouble
     }
     forAll { (nonEmptyVector: NonEmptyVector[Int]) =>
       nonEmptyVector.collect(pf) should ===(nonEmptyVector.toVector.collect(pf))
@@ -438,7 +439,7 @@ class ReducibleNonEmptyVectorSuite extends ReducibleSuite[NonEmptyVector]("NonEm
     // if we inline this we get a bewildering implicit numeric widening
     // error message in Scala 2.10
     val tailStart: Long = start + 1L
-    NonEmptyVector(start, (tailStart).to(endInclusive).toVector)
+    NonEmptyVector(start, tailStart.to(endInclusive).toVector)
   }
 
   def fromValues[A](el: A, els: A*): NonEmptyVector[A] = NonEmptyVector(el, Vector(els: _*))
diff --git a/tests/src/test/scala/cats/tests/OneAndSuite.scala b/tests/src/test/scala/cats/tests/OneAndSuite.scala
index ed3cc1b12..fc35ffcd4 100644
--- a/tests/src/test/scala/cats/tests/OneAndSuite.scala
+++ b/tests/src/test/scala/cats/tests/OneAndSuite.scala
@@ -15,7 +15,8 @@ class OneAndSuite extends CatsSuite {
   {
     implicit val traverse: Traverse[OneAnd[ListWrapper, *]] = OneAnd.catsDataTraverseForOneAnd(ListWrapper.traverse)
     checkAll("OneAnd[ListWrapper, Int] with Option",
-             TraverseTests[OneAnd[ListWrapper, *]].traverse[Int, Int, Int, Int, Option, Option])
+             TraverseTests[OneAnd[ListWrapper, *]].traverse[Int, Int, Int, Int, Option, Option]
+    )
     checkAll("Traverse[OneAnd[ListWrapper, A]]", SerializableTests.serializable(Traverse[OneAnd[ListWrapper, *]]))
   }
 
diff --git a/tests/src/test/scala/cats/tests/OptionTSuite.scala b/tests/src/test/scala/cats/tests/OptionTSuite.scala
index bfaa3a04d..4cc2a79c3 100644
--- a/tests/src/test/scala/cats/tests/OptionTSuite.scala
+++ b/tests/src/test/scala/cats/tests/OptionTSuite.scala
@@ -26,7 +26,8 @@ class OptionTSuite extends CatsSuite {
 
     checkAll("OptionT[ListWrapper, *]", FunctorFilterTests[OptionT[ListWrapper, *]].functorFilter[Int, Int, Int])
     checkAll("FunctorFilter[OptionT[ListWrapper, *]]",
-             SerializableTests.serializable(FunctorFilter[OptionT[ListWrapper, *]]))
+             SerializableTests.serializable(FunctorFilter[OptionT[ListWrapper, *]])
+    )
 
   }
 
@@ -36,7 +37,8 @@ class OptionTSuite extends CatsSuite {
 
     checkAll("OptionT[ListWrapper, *]", TraverseFilterTests[OptionT[ListWrapper, *]].traverseFilter[Int, Int, Int])
     checkAll("TraverseFilter[OptionT[ListWrapper, *]]",
-             SerializableTests.serializable(TraverseFilter[OptionT[ListWrapper, *]]))
+             SerializableTests.serializable(TraverseFilter[OptionT[ListWrapper, *]])
+    )
 
   }
 
@@ -52,7 +54,8 @@ class OptionTSuite extends CatsSuite {
 
     checkAll("OptionT[ListWrapper, Int]", PartialOrderTests[OptionT[ListWrapper, Int]].partialOrder)
     checkAll("PartialOrder[OptionT[ListWrapper, Int]]",
-             SerializableTests.serializable(PartialOrder[OptionT[ListWrapper, Int]]))
+             SerializableTests.serializable(PartialOrder[OptionT[ListWrapper, Int]])
+    )
 
     Eq[OptionT[ListWrapper, Int]]
   }
@@ -97,9 +100,11 @@ class OptionTSuite extends CatsSuite {
   {
     // F has a ContravariantMonoidal
     checkAll("OptionT[Const[String, *], Int]",
-             ContravariantMonoidalTests[OptionT[Const[String, *], *]].contravariantMonoidal[Int, Int, Int])
+             ContravariantMonoidalTests[OptionT[Const[String, *], *]].contravariantMonoidal[Int, Int, Int]
+    )
     checkAll("ContravariantMonoidal[OptionT[Const[String, *], Int]]",
-             SerializableTests.serializable(ContravariantMonoidal[OptionT[Const[String, *], *]]))
+             SerializableTests.serializable(ContravariantMonoidal[OptionT[Const[String, *], *]])
+    )
   }
 
   {
@@ -157,7 +162,8 @@ class OptionTSuite extends CatsSuite {
     implicit val F: Traverse[ListWrapper] = ListWrapper.traverse
 
     checkAll("OptionT[ListWrapper, Int] with Option",
-             TraverseTests[OptionT[ListWrapper, *]].traverse[Int, Int, Int, Int, Option, Option])
+             TraverseTests[OptionT[ListWrapper, *]].traverse[Int, Int, Int, Int, Option, Option]
+    )
     checkAll("Traverse[OptionT[ListWrapper, *]]", SerializableTests.serializable(Traverse[OptionT[ListWrapper, *]]))
 
     Foldable[OptionT[ListWrapper, *]]
@@ -181,7 +187,8 @@ class OptionTSuite extends CatsSuite {
 
     checkAll("OptionT[ListWrapper, Int]", SemigroupTests[OptionT[ListWrapper, Int]].semigroup)
     checkAll("Semigroup[OptionT[ListWrapper, Int]]",
-             SerializableTests.serializable(Semigroup[OptionT[ListWrapper, Int]]))
+             SerializableTests.serializable(Semigroup[OptionT[ListWrapper, Int]])
+    )
   }
 
   {
diff --git a/tests/src/test/scala/cats/tests/OptionWrapper.scala b/tests/src/test/scala/cats/tests/OptionWrapper.scala
index 92549f738..2c842bdc2 100644
--- a/tests/src/test/scala/cats/tests/OptionWrapper.scala
+++ b/tests/src/test/scala/cats/tests/OptionWrapper.scala
@@ -22,8 +22,8 @@ object OptionWrapper {
   implicit def optionWrapperCogen[A: Cogen]: Cogen[OptionWrapper[A]] =
     Cogen[Option[A]].contramap(_.option)
 
-  implicit def catsLawsExhaustiveCheckForOptionWrapper[A](
-    implicit A: ExhaustiveCheck[A]
+  implicit def catsLawsExhaustiveCheckForOptionWrapper[A](implicit
+    A: ExhaustiveCheck[A]
   ): ExhaustiveCheck[OptionWrapper[A]] =
     ExhaustiveCheck.instance(ExhaustiveCheck[Option[A]].allValues.map(OptionWrapper(_)))
 }
diff --git a/tests/src/test/scala/cats/tests/OrderingSuite.scala b/tests/src/test/scala/cats/tests/OrderingSuite.scala
index a236fa06c..dc17ae31f 100644
--- a/tests/src/test/scala/cats/tests/OrderingSuite.scala
+++ b/tests/src/test/scala/cats/tests/OrderingSuite.scala
@@ -16,6 +16,7 @@ class OrderingSuite extends CatsSuite {
   checkAll("Contravariant[Ordering]", ContravariantTests[Ordering].contravariant[MiniInt, Int, Boolean])
   checkAll("Semigroupal[Ordering]", SemigroupalTests[Ordering].semigroupal[MiniInt, Boolean, Boolean])
   checkAll("ContravariantMonoidal[Ordering]",
-           ContravariantMonoidalTests[Ordering].contravariantMonoidal[MiniInt, Boolean, Boolean])
+           ContravariantMonoidalTests[Ordering].contravariantMonoidal[MiniInt, Boolean, Boolean]
+  )
   checkAll("ContravariantMonoidal[Ordering]", SerializableTests.serializable(ContravariantMonoidal[Ordering]))
 }
diff --git a/tests/src/test/scala/cats/tests/ParallelSuite.scala b/tests/src/test/scala/cats/tests/ParallelSuite.scala
index 560713974..2739dceec 100644
--- a/tests/src/test/scala/cats/tests/ParallelSuite.scala
+++ b/tests/src/test/scala/cats/tests/ParallelSuite.scala
@@ -93,8 +93,9 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
   implicit val catsBitraverseForListTuple2: Bitraverse[ListTuple2] = new Bitraverse[ListTuple2] {
     def bifoldLeft[A, B, C](fab: ListTuple2[A, B], c: C)(f: (C, A) => C, g: (C, B) => C): C =
       fab.foldLeft(c) { case (c, (a, b)) => g(f(c, a), b) }
-    def bifoldRight[A, B, C](fab: ListTuple2[A, B], lc: Eval[C])(f: (A, Eval[C]) => Eval[C],
-                                                                 g: (B, Eval[C]) => Eval[C]): Eval[C] = {
+    def bifoldRight[A, B, C](fab: ListTuple2[A, B],
+                             lc: Eval[C]
+    )(f: (A, Eval[C]) => Eval[C], g: (B, Eval[C]) => Eval[C]): Eval[C] = {
       def loop(abs: ListTuple2[A, B]): Eval[C] =
         abs match {
           case Nil         => lc
@@ -406,16 +407,18 @@ class ParallelSuite extends CatsSuite with ApplicativeErrorForEitherTest with Sc
       def parallel: Effect ~> Effect = arrow.FunctionK.id
       def sequential: Effect ~> Effect = arrow.FunctionK.id
 
-      def applicative: Applicative[Effect] = new Applicative[Effect] {
-        def pure[A](a: A): Effect[A] = Effect(a)
-        def ap[A, B](ff: Effect[A => B])(fa: Effect[A]): Effect[B] = throw Marker("parallel")
-      }
+      def applicative: Applicative[Effect] =
+        new Applicative[Effect] {
+          def pure[A](a: A): Effect[A] = Effect(a)
+          def ap[A, B](ff: Effect[A => B])(fa: Effect[A]): Effect[B] = throw Marker("parallel")
+        }
       def monad: Monad[Effect] = monadInstance
     }
 
     val iorts: List[IorT[Effect, String, Int]] = List(IorT.leftT("hello")(monadInstance),
                                                       IorT.bothT(" world", 404)(monadInstance),
-                                                      IorT.rightT(123)(monadInstance))
+                                                      IorT.rightT(123)(monadInstance)
+    )
 
     val resultSansInstance = {
       implicit val ev0: Monad[Effect] = monadInstance
@@ -514,6 +517,7 @@ trait ApplicativeErrorForEitherTest extends AnyFunSuiteLike with FunSuiteDiscipl
       Parallel.applicativeError[Either[String, *], String]
 
     checkAll("ApplicativeError[Validated[String, Int]]",
-             ApplicativeErrorTests[Validated[String, *], String].applicativeError[Int, Int, Int])
+             ApplicativeErrorTests[Validated[String, *], String].applicativeError[Int, Int, Int]
+    )
   }
 }
diff --git a/tests/src/test/scala/cats/tests/PartialOrderingSuite.scala b/tests/src/test/scala/cats/tests/PartialOrderingSuite.scala
index d9d786dbf..536206c21 100644
--- a/tests/src/test/scala/cats/tests/PartialOrderingSuite.scala
+++ b/tests/src/test/scala/cats/tests/PartialOrderingSuite.scala
@@ -17,7 +17,9 @@ class PartialOrderingSuite extends CatsSuite {
   checkAll("Contravariant[PartialOrdering]", SerializableTests.serializable(Contravariant[PartialOrdering]))
 
   checkAll("PartialOrdering[Int]",
-           ContravariantMonoidalTests[PartialOrdering].contravariantMonoidal[MiniInt, Boolean, Boolean])
+           ContravariantMonoidalTests[PartialOrdering].contravariantMonoidal[MiniInt, Boolean, Boolean]
+  )
   checkAll("ContravariantMonoidal[PartialOrdering]",
-           SerializableTests.serializable(ContravariantMonoidal[PartialOrdering]))
+           SerializableTests.serializable(ContravariantMonoidal[PartialOrdering])
+  )
 }
diff --git a/tests/src/test/scala/cats/tests/ReducibleSuite.scala b/tests/src/test/scala/cats/tests/ReducibleSuite.scala
index b8193f2b8..a3c3cc15d 100644
--- a/tests/src/test/scala/cats/tests/ReducibleSuite.scala
+++ b/tests/src/test/scala/cats/tests/ReducibleSuite.scala
@@ -121,9 +121,10 @@ class ReducibleSuiteAdditional extends CatsSuite {
   }
 }
 
-abstract class ReducibleSuite[F[_]: Reducible](name: String)(implicit ArbFInt: Arbitrary[F[Int]],
-                                                             ArbFString: Arbitrary[F[String]])
-    extends FoldableSuite[F](name) {
+abstract class ReducibleSuite[F[_]: Reducible](name: String)(implicit
+  ArbFInt: Arbitrary[F[Int]],
+  ArbFString: Arbitrary[F[String]]
+) extends FoldableSuite[F](name) {
 
   def range(start: Long, endInclusive: Long): F[Long]
   def fromValues[A](el: A, els: A*): F[A]
diff --git a/tests/src/test/scala/cats/tests/RegressionSuite.scala b/tests/src/test/scala/cats/tests/RegressionSuite.scala
index 7aa025006..550b7d6cc 100644
--- a/tests/src/test/scala/cats/tests/RegressionSuite.scala
+++ b/tests/src/test/scala/cats/tests/RegressionSuite.scala
@@ -29,10 +29,11 @@ class RegressionSuite extends CatsSuite with ScalaVersionSpecificRegressionSuite
   }
 
   object State {
-    implicit def instance[S]: Monad[State[S, *]] = new Monad[State[S, *]] with StackSafeMonad[State[S, *]] { // lies!
-      def pure[A](a: A): State[S, A] = State(s => (a, s))
-      def flatMap[A, B](sa: State[S, A])(f: A => State[S, B]): State[S, B] = sa.flatMap(f)
-    }
+    implicit def instance[S]: Monad[State[S, *]] =
+      new Monad[State[S, *]] with StackSafeMonad[State[S, *]] { // lies!
+        def pure[A](a: A): State[S, A] = State(s => (a, s))
+        def flatMap[A, B](sa: State[S, A])(f: A => State[S, B]): State[S, B] = sa.flatMap(f)
+      }
   }
 
   // used to test side-effects
diff --git a/tests/src/test/scala/cats/tests/RepresentableStoreSuite.scala b/tests/src/test/scala/cats/tests/RepresentableStoreSuite.scala
index 4c8adcb14..53bf628c0 100644
--- a/tests/src/test/scala/cats/tests/RepresentableStoreSuite.scala
+++ b/tests/src/test/scala/cats/tests/RepresentableStoreSuite.scala
@@ -28,16 +28,19 @@ class RepresentableStoreSuite extends CatsSuite {
     implicit val eqStoreStoreStore: Eq[
       RepresentableStore[Î»[P => (P, P)], Boolean, RepresentableStore[Î»[P => (P, P)],
                                                                      Boolean,
-                                                                     RepresentableStore[Î»[P => (P, P)], Boolean, Int]]]
+                                                                     RepresentableStore[Î»[P => (P, P)], Boolean, Int]
+      ]]
     ] =
       cats.laws.discipline.eq.catsLawsEqForRepresentableStore[Î»[P => (P, P)], Boolean, RepresentableStore[Î»[
         P => (P, P)
       ], Boolean, RepresentableStore[Î»[P => (P, P)], Boolean, Int]]]
     checkAll("Comonad[RepresentableStore[Î»[P => (P, P)], Boolean, *]]",
-             ComonadTests[RepresentableStore[Î»[P => (P, P)], Boolean, *]].comonad[Int, Int, Int])
+             ComonadTests[RepresentableStore[Î»[P => (P, P)], Boolean, *]].comonad[Int, Int, Int]
+    )
 
     checkAll("Comonad[RepresentableStore[Î»[P => (P, P)], Boolean, *]]",
-             SerializableTests.serializable(Comonad[RepresentableStore[Î»[P => (P, P)], Boolean, *]]))
+             SerializableTests.serializable(Comonad[RepresentableStore[Î»[P => (P, P)], Boolean, *]])
+    )
   }
 
   test("extract and peek are consistent") {
diff --git a/tests/src/test/scala/cats/tests/RepresentableSuite.scala b/tests/src/test/scala/cats/tests/RepresentableSuite.scala
index 3ecf7ffcf..d4440898c 100644
--- a/tests/src/test/scala/cats/tests/RepresentableSuite.scala
+++ b/tests/src/test/scala/cats/tests/RepresentableSuite.scala
@@ -54,7 +54,8 @@ class RepresentableSuite extends CatsSuite {
     )
 
     checkAll("Representable[Kleisli[Pair, MiniInt, *]]",
-             SerializableTests.serializable(Representable[Kleisli[Pair, MiniInt, *]]))
+             SerializableTests.serializable(Representable[Kleisli[Pair, MiniInt, *]])
+    )
   }
 
   val reprPair = Representable[Pair]
diff --git a/tests/src/test/scala/cats/tests/SortedMapSuite.scala b/tests/src/test/scala/cats/tests/SortedMapSuite.scala
index a5f05267c..6041f1794 100644
--- a/tests/src/test/scala/cats/tests/SortedMapSuite.scala
+++ b/tests/src/test/scala/cats/tests/SortedMapSuite.scala
@@ -29,7 +29,8 @@ class SortedMapSuite extends CatsSuite {
   checkAll("FlatMap[SortedMap[Int, *]]", SerializableTests.serializable(FlatMap[SortedMap[Int, *]]))
 
   checkAll("SortedMap[Int, Int] with Option",
-           TraverseTests[SortedMap[Int, *]].traverse[Int, Int, Int, Int, Option, Option])
+           TraverseTests[SortedMap[Int, *]].traverse[Int, Int, Int, Int, Option, Option]
+  )
   checkAll("Traverse[SortedMap[Int, *]]", SerializableTests.serializable(Traverse[SortedMap[Int, *]]))
 
   checkAll("SortedMap[Int, Int]", TraverseFilterTests[SortedMap[Int, *]].traverseFilter[Int, Int, Int])
@@ -50,9 +51,11 @@ class SortedMapSuite extends CatsSuite {
 
   checkAll("Hash[SortedMap[Int, String]]", HashTests[SortedMap[Int, String]].hash)
   checkAll("CommutativeMonoid[SortedMap[String, Int]]",
-           CommutativeMonoidTests[SortedMap[String, Int]].commutativeMonoid)
+           CommutativeMonoidTests[SortedMap[String, Int]].commutativeMonoid
+  )
   checkAll("CommutativeMonoid[SortedMap[String, Int]]",
-           SerializableTests.serializable(CommutativeMonoid[SortedMap[String, Int]]))
+           SerializableTests.serializable(CommutativeMonoid[SortedMap[String, Int]])
+  )
   checkAll("Monoid[SortedMap[String, String]]", MonoidTests[SortedMap[String, String]].monoid)
   checkAll("Monoid[SortedMap[String, String]]", SerializableTests.serializable(Monoid[SortedMap[String, String]]))
 
diff --git a/tests/src/test/scala/cats/tests/SortedSetSuite.scala b/tests/src/test/scala/cats/tests/SortedSetSuite.scala
index 03ef67995..be13e8434 100644
--- a/tests/src/test/scala/cats/tests/SortedSetSuite.scala
+++ b/tests/src/test/scala/cats/tests/SortedSetSuite.scala
@@ -7,7 +7,7 @@ import cats.kernel.{BoundedSemilattice, Semilattice}
 import cats.laws._
 import cats.laws.discipline.SemigroupalTests.Isomorphisms
 import cats.laws.discipline.arbitrary._
-import cats.laws.discipline.{FoldableTests, SemigroupKTests, SemigroupalTests, SerializableTests}
+import cats.laws.discipline.{FoldableTests, SemigroupKTests, SemigroupalTests, SerializableTests, ShortCircuitingTests}
 import cats.syntax.show._
 import scala.collection.immutable.SortedSet
 
@@ -24,7 +24,8 @@ class SortedSetSuite extends CatsSuite {
   checkAll("Order.reverse(Order[SortedSet[Int]])", OrderTests(Order.reverse(Order[SortedSet[Int]])).order)
   checkAll("PartialOrder[SortedSet[Int]]", PartialOrderTests[SortedSet[Int]].partialOrder)
   checkAll("PartialOrder.reverse(PartialOrder[SortedSet[Int]])",
-           PartialOrderTests(PartialOrder.reverse(PartialOrder[SortedSet[Int]])).partialOrder)
+           PartialOrderTests(PartialOrder.reverse(PartialOrder[SortedSet[Int]])).partialOrder
+  )
   checkAll(
     "PartialOrder.reverse(PartialOrder.reverse(PartialOrder[SortedSet[Int]]))",
     PartialOrderTests(PartialOrder.reverse(PartialOrder.reverse(PartialOrder[SortedSet[Int]]))).partialOrder
@@ -32,12 +33,15 @@ class SortedSetSuite extends CatsSuite {
 
   checkAll("BoundedSemilattice[SortedSet[String]]", BoundedSemilatticeTests[SortedSet[String]].boundedSemilattice)
   checkAll("BoundedSemilattice[SortedSet[String]]",
-           SerializableTests.serializable(BoundedSemilattice[SortedSet[String]]))
+           SerializableTests.serializable(BoundedSemilattice[SortedSet[String]])
+  )
 
   checkAll("Semilattice.asMeetPartialOrder[SortedSet[Int]]",
-           PartialOrderTests(Semilattice.asMeetPartialOrder[SortedSet[Int]]).partialOrder)
+           PartialOrderTests(Semilattice.asMeetPartialOrder[SortedSet[Int]]).partialOrder
+  )
   checkAll("Semilattice.asJoinPartialOrder[SortedSet[Int]]",
-           PartialOrderTests(Semilattice.asJoinPartialOrder[SortedSet[Int]]).partialOrder)
+           PartialOrderTests(Semilattice.asJoinPartialOrder[SortedSet[Int]]).partialOrder
+  )
   checkAll("Hash[SortedSet[Int]]", HashTests[SortedSet[Int]].hash)
 
   test("show keeps separate entries for items that map to identical strings") {
@@ -59,7 +63,7 @@ object SortedSetIsomorphism extends Isomorphisms[SortedSet] {
       fs._2.ordering
     )
 
-    fs._1.map { case (a, (b, c))   => (a, b, c) } <->
+    fs._1.map { case (a, (b, c)) => (a, b, c) } <->
       fs._2.map { case ((a, b), c) => (a, b, c) }
   }
 
diff --git a/tests/src/test/scala/cats/tests/SyntaxSerializationSuite.scala b/tests/src/test/scala/cats/tests/SyntaxSerializationSuite.scala
new file mode 100644
index 000000000..722fea0f1
--- /dev/null
+++ b/tests/src/test/scala/cats/tests/SyntaxSerializationSuite.scala
@@ -0,0 +1,26 @@
+package cats.tests
+
+import cats.laws.discipline.SerializableTests
+
+/**
+ * Test that our syntax implicits are serializable.
+ */
+class SyntaxSerializationSuite extends CatsSuite {
+  checkAll(
+    "Tuple3SemigroupalOps[Option, Boolean, Int, Long]",
+    SerializableTests.serializable(
+      cats.syntax.all.catsSyntaxTuple3Semigroupal[Option, Boolean, Int, Long]((None, None, None))
+    )
+  )
+
+  checkAll("SemigroupalOps[Option, Int]",
+           SerializableTests.serializable(cats.syntax.all.catsSyntaxSemigroupal[Option, Int](None))
+  )
+
+  checkAll(
+    "Tuple3ParallelOps[Either[String, ?], Boolean, Int, Long]",
+    SerializableTests.serializable(
+      cats.syntax.all.catsSyntaxTuple3Parallel[Either[String, ?], Boolean, Int, Long]((Left("a"), Left("b"), Left("c")))
+    )
+  )
+}
diff --git a/tests/src/test/scala/cats/tests/SyntaxSuite.scala b/tests/src/test/scala/cats/tests/SyntaxSuite.scala
index 8056a6a4b..830a456eb 100644
--- a/tests/src/test/scala/cats/tests/SyntaxSuite.scala
+++ b/tests/src/test/scala/cats/tests/SyntaxSuite.scala
@@ -280,7 +280,9 @@ object SyntaxSuite {
     val fb1: F[B] = fa.as(b)
   }
 
-  def testApply[F[_]: Apply: Semigroupal, G[_]: Contravariant: Semigroupal, H[_]: Invariant: Semigroupal, A, B, C, D, E, Z] = {
+  def testApply[F[_]: Apply: Semigroupal, G[_]: Contravariant: Semigroupal, H[
+    _
+  ]: Invariant: Semigroupal, A, B, C, D, E, Z] = {
     val tfabc = mock[(F[A], F[B], F[C])]
     val fa = mock[F[A]]
     val fb = mock[F[B]]
diff --git a/tests/src/test/scala/cats/tests/TailRecSuite.scala b/tests/src/test/scala/cats/tests/TailRecSuite.scala
index c2ee2f18e..65bb97eaf 100644
--- a/tests/src/test/scala/cats/tests/TailRecSuite.scala
+++ b/tests/src/test/scala/cats/tests/TailRecSuite.scala
@@ -13,7 +13,7 @@ class TailRecSuite extends CatsSuite {
     Arbitrary(
       Gen.frequency(
         (3, arbitrary[A].map(done(_))),
-        (1, Gen.lzy(arbitrary[(A, A => TailRec[A])].map { case (a, fn)          => tailcall(fn(a)) })),
+        (1, Gen.lzy(arbitrary[(A, A => TailRec[A])].map { case (a, fn) => tailcall(fn(a)) })),
         (1, Gen.lzy(arbitrary[(TailRec[A], A => TailRec[A])].map { case (a, fn) => a.flatMap(fn) }))
       )
     )
diff --git a/tests/src/test/scala/cats/tests/TraverseSuite.scala b/tests/src/test/scala/cats/tests/TraverseSuite.scala
index f3df02f00..5d34292a6 100644
--- a/tests/src/test/scala/cats/tests/TraverseSuite.scala
+++ b/tests/src/test/scala/cats/tests/TraverseSuite.scala
@@ -39,14 +39,15 @@ object TraverseSuite {
 
   // proxies a traverse instance so we can test default implementations
   // to achieve coverage using default datatype instances
-  private def proxyTraverse[F[_]: Traverse]: Traverse[F] = new Traverse[F] {
-    def foldLeft[A, B](fa: F[A], b: B)(f: (B, A) => B): B =
-      Traverse[F].foldLeft(fa, b)(f)
-    def foldRight[A, B](fa: F[A], lb: cats.Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
-      Traverse[F].foldRight(fa, lb)(f)
-    def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): G[F[B]] =
-      Traverse[F].traverse(fa)(f)
-  }
+  private def proxyTraverse[F[_]: Traverse]: Traverse[F] =
+    new Traverse[F] {
+      def foldLeft[A, B](fa: F[A], b: B)(f: (B, A) => B): B =
+        Traverse[F].foldLeft(fa, b)(f)
+      def foldRight[A, B](fa: F[A], lb: cats.Eval[B])(f: (A, Eval[B]) => Eval[B]): Eval[B] =
+        Traverse[F].foldRight(fa, lb)(f)
+      def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): G[F[B]] =
+        Traverse[F].traverse(fa)(f)
+    }
 }
 
 class TraverseListSuite extends TraverseSuite[List]("List")
diff --git a/tests/src/test/scala/cats/tests/Tuple2KSuite.scala b/tests/src/test/scala/cats/tests/Tuple2KSuite.scala
index 5ad7b2c36..45c6a03f5 100644
--- a/tests/src/test/scala/cats/tests/Tuple2KSuite.scala
+++ b/tests/src/test/scala/cats/tests/Tuple2KSuite.scala
@@ -13,16 +13,20 @@ class Tuple2KSuite extends CatsSuite {
   checkAll("Tuple2K[Eval, Eval, *]", DeferTests[Tuple2K[Eval, Eval, *]].defer[Int])
   checkAll("Tuple2K[Option, List, Int]", SemigroupalTests[Î»[Î± => Tuple2K[Option, List, Î±]]].semigroupal[Int, Int, Int])
   checkAll("Semigroupal[Tuple2K[Option, List, Int]]",
-           SerializableTests.serializable(Semigroupal[Î»[Î± => Tuple2K[Option, List, Î±]]]))
+           SerializableTests.serializable(Semigroupal[Î»[Î± => Tuple2K[Option, List, Î±]]])
+  )
 
   checkAll("Tuple2K[Option, List, Int]", AlternativeTests[Î»[Î± => Tuple2K[Option, List, Î±]]].alternative[Int, Int, Int])
   checkAll("Alternative[Tuple2K[Option, List, Int]]",
-           SerializableTests.serializable(Alternative[Î»[Î± => Tuple2K[Option, List, Î±]]]))
+           SerializableTests.serializable(Alternative[Î»[Î± => Tuple2K[Option, List, Î±]]])
+  )
 
   checkAll("Tuple2K[Show, Order, MiniInt]",
-           ContravariantTests[Î»[Î± => Tuple2K[Show, Order, Î±]]].contravariant[MiniInt, Int, Boolean])
+           ContravariantTests[Î»[Î± => Tuple2K[Show, Order, Î±]]].contravariant[MiniInt, Int, Boolean]
+  )
   checkAll("Contravariant[Tuple2K[Show, Order, Int]]",
-           SerializableTests.serializable(Contravariant[Î»[Î± => Tuple2K[Show, Order, Î±]]]))
+           SerializableTests.serializable(Contravariant[Î»[Î± => Tuple2K[Show, Order, Î±]]])
+  )
 
   checkAll(
     "Tuple2K[Const[String, *], Const[Int, *], Int]",
@@ -39,15 +43,18 @@ class Tuple2KSuite extends CatsSuite {
     implicit val monoidK: MonoidK[ListWrapper] = ListWrapper.monoidK
     checkAll("Tuple2K[ListWrapper, ListWrapper, *]", MonoidKTests[Tuple2K[ListWrapper, ListWrapper, *]].monoidK[Int])
     checkAll("MonoidK[Tuple2K[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(MonoidK[Tuple2K[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(MonoidK[Tuple2K[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
     implicit val semigroupK: SemigroupK[ListWrapper] = ListWrapper.semigroupK
     checkAll("Tuple2K[ListWrapper, ListWrapper, *]",
-             SemigroupKTests[Tuple2K[ListWrapper, ListWrapper, *]].semigroupK[Int])
+             SemigroupKTests[Tuple2K[ListWrapper, ListWrapper, *]].semigroupK[Int]
+    )
     checkAll("SemigroupK[Tuple2K[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(SemigroupK[Tuple2K[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(SemigroupK[Tuple2K[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
@@ -55,31 +62,39 @@ class Tuple2KSuite extends CatsSuite {
     implicit val iso: Isomorphisms[Tuple2K[ListWrapper, ListWrapper, *]] =
       Isomorphisms.invariant[Tuple2K[ListWrapper, ListWrapper, *]]
     checkAll("Tuple2K[ListWrapper, ListWrapper, *]",
-             ApplyTests[Tuple2K[ListWrapper, ListWrapper, *]].apply[Int, Int, Int])
+             ApplyTests[Tuple2K[ListWrapper, ListWrapper, *]].apply[Int, Int, Int]
+    )
     checkAll("Apply[Tuple2K[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(Apply[Tuple2K[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(Apply[Tuple2K[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
     checkAll("Tuple2K[Option, Validated[Int, *], *]",
-             CommutativeApplyTests[Tuple2K[Option, Validated[Int, *], *]].commutativeApply[Int, Int, Int])
+             CommutativeApplyTests[Tuple2K[Option, Validated[Int, *], *]].commutativeApply[Int, Int, Int]
+    )
     checkAll("Apply[Tuple2K[Option, Validated[Int, *], *]]",
-             SerializableTests.serializable(CommutativeApply[Tuple2K[Option, Validated[Int, *], *]]))
+             SerializableTests.serializable(CommutativeApply[Tuple2K[Option, Validated[Int, *], *]])
+    )
   }
 
   {
     checkAll("Tuple2K[Option, Validated[Int, *], *]",
-             CommutativeApplicativeTests[Tuple2K[Option, Validated[Int, *], *]].commutativeApplicative[Int, Int, Int])
+             CommutativeApplicativeTests[Tuple2K[Option, Validated[Int, *], *]].commutativeApplicative[Int, Int, Int]
+    )
     checkAll("Applicative[Tuple2K[Option, Validated[Int, *], *]]",
-             SerializableTests.serializable(CommutativeApplicative[Tuple2K[Option, Validated[Int, *], *]]))
+             SerializableTests.serializable(CommutativeApplicative[Tuple2K[Option, Validated[Int, *], *]])
+    )
   }
 
   {
     implicit val functor: Functor[ListWrapper] = ListWrapper.functor
     checkAll("Tuple2K[ListWrapper, ListWrapper, *]",
-             FunctorTests[Tuple2K[ListWrapper, ListWrapper, *]].functor[Int, Int, Int])
+             FunctorTests[Tuple2K[ListWrapper, ListWrapper, *]].functor[Int, Int, Int]
+    )
     checkAll("Functor[Tuple2K[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(Functor[Tuple2K[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(Functor[Tuple2K[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
@@ -87,25 +102,31 @@ class Tuple2KSuite extends CatsSuite {
     implicit val iso: Isomorphisms[Tuple2K[ListWrapper, ListWrapper, *]] =
       Isomorphisms.invariant[Tuple2K[ListWrapper, ListWrapper, *]]
     checkAll("Tuple2K[ListWrapper, ListWrapper, *]",
-             MonadTests[Tuple2K[ListWrapper, ListWrapper, *]].monad[Int, Int, Int])
+             MonadTests[Tuple2K[ListWrapper, ListWrapper, *]].monad[Int, Int, Int]
+    )
     checkAll("Monad[Tuple2K[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(Monad[Tuple2K[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(Monad[Tuple2K[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
     implicit val foldable: Foldable[ListWrapper] = ListWrapper.foldable
     checkAll("Tuple2K[ListWrapper, ListWrapper, *]",
-             FoldableTests[Tuple2K[ListWrapper, ListWrapper, *]].foldable[Int, Int])
+             FoldableTests[Tuple2K[ListWrapper, ListWrapper, *]].foldable[Int, Int]
+    )
     checkAll("Foldable[Tuple2K[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(Foldable[Tuple2K[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(Foldable[Tuple2K[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
     implicit val traverse: Traverse[ListWrapper] = ListWrapper.traverse
     checkAll("Tuple2K[ListWrapper, ListWrapper, *]",
-             TraverseTests[Tuple2K[ListWrapper, ListWrapper, *]].traverse[Int, Int, Int, Int, Option, Option])
+             TraverseTests[Tuple2K[ListWrapper, ListWrapper, *]].traverse[Int, Int, Int, Int, Option, Option]
+    )
     checkAll("Traverse[Tuple2K[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(Traverse[Tuple2K[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(Traverse[Tuple2K[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
@@ -113,9 +134,11 @@ class Tuple2KSuite extends CatsSuite {
     implicit val iso: Isomorphisms[Tuple2K[ListWrapper, ListWrapper, *]] =
       Isomorphisms.invariant[Tuple2K[ListWrapper, ListWrapper, *]]
     checkAll("Tuple2K[ListWrapper, ListWrapper, *]",
-             AlternativeTests[Tuple2K[ListWrapper, ListWrapper, *]].alternative[Int, Int, Int])
+             AlternativeTests[Tuple2K[ListWrapper, ListWrapper, *]].alternative[Int, Int, Int]
+    )
     checkAll("Alternative[Tuple2K[ListWrapper, ListWrapper, *]]",
-             SerializableTests.serializable(Alternative[Tuple2K[ListWrapper, ListWrapper, *]]))
+             SerializableTests.serializable(Alternative[Tuple2K[ListWrapper, ListWrapper, *]])
+    )
   }
 
   {
@@ -126,14 +149,17 @@ class Tuple2KSuite extends CatsSuite {
     checkAll("Tuple2K[ListWrapper, ListWrapper, Int]", EqTests[Tuple2K[ListWrapper, ListWrapper, Int]].eqv)
     checkAll("Tuple2K[ListWrapper, ListWrapper, Int]", OrderTests[Tuple2K[ListWrapper, ListWrapper, Int]].order)
     checkAll("Tuple2K[ListWrapper, ListWrapper, Int]",
-             PartialOrderTests[Tuple2K[ListWrapper, ListWrapper, Int]].partialOrder)
+             PartialOrderTests[Tuple2K[ListWrapper, ListWrapper, Int]].partialOrder
+    )
   }
 
   {
     checkAll("Tuple2K[Function0, Function0, *]",
-             DistributiveTests[Tuple2K[Function0, Function0, *]].distributive[Int, Int, Int, Option, Function0])
+             DistributiveTests[Tuple2K[Function0, Function0, *]].distributive[Int, Int, Int, Option, Function0]
+    )
     checkAll("Distributive[Tuple2K[Function0, Function0, *]]",
-             SerializableTests.serializable(Distributive[Tuple2K[Function0, Function0, *]]))
+             SerializableTests.serializable(Distributive[Tuple2K[Function0, Function0, *]])
+    )
   }
 
   test("show") {
diff --git a/tests/src/test/scala/cats/tests/TupleSuite.scala b/tests/src/test/scala/cats/tests/TupleSuite.scala
index e25c6d2cc..c03ad24b0 100644
--- a/tests/src/test/scala/cats/tests/TupleSuite.scala
+++ b/tests/src/test/scala/cats/tests/TupleSuite.scala
@@ -42,9 +42,11 @@ class TupleSuite extends CatsSuite {
   checkAll("Monad[(String, *)] serializable", SerializableTests.serializable(Monad[(String, *)]))
 
   checkAll("CommutativeFlatMap[(CSemi, *)]",
-           CommutativeFlatMapTests[(CSemi, *)].commutativeFlatMap[CSemi, CSemi, CSemi])
+           CommutativeFlatMapTests[(CSemi, *)].commutativeFlatMap[CSemi, CSemi, CSemi]
+  )
   checkAll("CommutativeFlatMap[(CSemi, *)] serializable",
-           SerializableTests.serializable(CommutativeFlatMap[(CSemi, *)]))
+           SerializableTests.serializable(CommutativeFlatMap[(CSemi, *)])
+  )
 
   checkAll("CommutativeMonad[(Int, *)]", CommutativeMonadTests[(Int, *)].commutativeMonad[Int, Int, Int])
   checkAll("CommutativeMonad[(Int, *)] serializable", SerializableTests.serializable(CommutativeMonad[(Int, *)]))
diff --git a/tests/src/test/scala/cats/tests/UnorderedFoldableSuite.scala b/tests/src/test/scala/cats/tests/UnorderedFoldableSuite.scala
index 500824328..9d28f8645 100644
--- a/tests/src/test/scala/cats/tests/UnorderedFoldableSuite.scala
+++ b/tests/src/test/scala/cats/tests/UnorderedFoldableSuite.scala
@@ -6,9 +6,10 @@ import cats.laws.discipline.UnorderedFoldableTests
 import cats.syntax.unorderedFoldable._
 import org.scalacheck.Arbitrary
 
-sealed abstract class UnorderedFoldableSuite[F[_]](name: String)(implicit ArbFString: Arbitrary[F[String]],
-                                                                 ArbFInt: Arbitrary[F[Int]])
-    extends CatsSuite {
+sealed abstract class UnorderedFoldableSuite[F[_]](name: String)(implicit
+  ArbFString: Arbitrary[F[String]],
+  ArbFInt: Arbitrary[F[Int]]
+) extends CatsSuite {
 
   def iterator[T](fa: F[T]): Iterator[T]
   def specializedUnorderedFoldMap[A, B: CommutativeMonoid](fa: F[A])(f: A => B): B
@@ -59,8 +60,8 @@ final class UnorderedFoldableMapSuite extends UnorderedFoldableSuite[Map[String,
     UnorderedFoldable[Map[String, *]].unorderedFoldMap(fa)(f)
 }
 
-sealed abstract class SpecializedUnorderedFoldableSuite[F[_]: UnorderedFoldable](name: String)(
-  implicit ArbFString: Arbitrary[F[String]]
+sealed abstract class SpecializedUnorderedFoldableSuite[F[_]: UnorderedFoldable](name: String)(implicit
+  ArbFString: Arbitrary[F[String]]
 ) extends CatsSuite {
 
   def iterator[T](fa: F[T]): Iterator[T]
diff --git a/tests/src/test/scala/cats/tests/ValidatedSuite.scala b/tests/src/test/scala/cats/tests/ValidatedSuite.scala
index 3ea5dcaf8..f147d052b 100644
--- a/tests/src/test/scala/cats/tests/ValidatedSuite.scala
+++ b/tests/src/test/scala/cats/tests/ValidatedSuite.scala
@@ -37,12 +37,15 @@ class ValidatedSuite extends CatsSuite {
     EitherT.catsDataEqForEitherT[Validated[String, *], String, Int]
 
   checkAll("Validated[String, Int]",
-           ApplicativeErrorTests[Validated[String, *], String].applicativeError[Int, Int, Int])
+           ApplicativeErrorTests[Validated[String, *], String].applicativeError[Int, Int, Int]
+  )
   checkAll("ApplicativeError[Validated, String]",
-           SerializableTests.serializable(ApplicativeError[Validated[String, *], String]))
+           SerializableTests.serializable(ApplicativeError[Validated[String, *], String])
+  )
 
   checkAll("Validated[String, Int] with Option",
-           TraverseTests[Validated[String, *]].traverse[Int, Int, Int, Int, Option, Option])
+           TraverseTests[Validated[String, *]].traverse[Int, Int, Int, Int, Option, Option]
+  )
   checkAll("Traverse[Validated[String, *]]", SerializableTests.serializable(Traverse[Validated[String, *]]))
 
   checkAll("Validated[String, Int]", OrderTests[Validated[String, Int]].order)
@@ -54,7 +57,8 @@ class ValidatedSuite extends CatsSuite {
 
   checkAll("Validated[Int, Int]", CommutativeApplicativeTests[Validated[Int, *]].commutativeApplicative[Int, Int, Int])
   checkAll("CommutativeApplicative[Validated[Int, *]]",
-           SerializableTests.serializable(CommutativeApplicative[Validated[Int, *]]))
+           SerializableTests.serializable(CommutativeApplicative[Validated[Int, *]])
+  )
 
   checkAll("Validated[Int, Int]", AlignTests[Validated[Int, *]].align[Int, Int, Int, Int])
   checkAll("Align[Validated[Int, *]]", SerializableTests.serializable(Align[Validated[Int, *]]))
@@ -63,14 +67,16 @@ class ValidatedSuite extends CatsSuite {
     implicit val L: Semigroup[ListWrapper[String]] = ListWrapper.semigroup[String]
     checkAll("Validated[ListWrapper[String], *]", SemigroupKTests[Validated[ListWrapper[String], *]].semigroupK[Int])
     checkAll("SemigroupK[Validated[ListWrapper[String], *]]",
-             SerializableTests.serializable(SemigroupK[Validated[ListWrapper[String], *]]))
+             SerializableTests.serializable(SemigroupK[Validated[ListWrapper[String], *]])
+    )
   }
 
   {
     implicit val S: PartialOrder[ListWrapper[String]] = ListWrapper.partialOrder[String]
     implicit val I: PartialOrder[ListWrapper[Int]] = ListWrapper.partialOrder[Int]
     checkAll("Validated[ListWrapper[String], ListWrapper[Int]]",
-             PartialOrderTests[Validated[ListWrapper[String], ListWrapper[Int]]].partialOrder)
+             PartialOrderTests[Validated[ListWrapper[String], ListWrapper[Int]]].partialOrder
+    )
     checkAll(
       "PartialOrder[Validated[ListWrapper[String], ListWrapper[Int]]]",
       SerializableTests.serializable(PartialOrder[Validated[ListWrapper[String], ListWrapper[Int]]])
@@ -81,9 +87,11 @@ class ValidatedSuite extends CatsSuite {
     implicit val S: Eq[ListWrapper[String]] = ListWrapper.eqv[String]
     implicit val I: Eq[ListWrapper[Int]] = ListWrapper.eqv[Int]
     checkAll("Validated[ListWrapper[String], ListWrapper[Int]]",
-             EqTests[Validated[ListWrapper[String], ListWrapper[Int]]].eqv)
+             EqTests[Validated[ListWrapper[String], ListWrapper[Int]]].eqv
+    )
     checkAll("Eq[Validated[ListWrapper[String], ListWrapper[Int]]]",
-             SerializableTests.serializable(Eq[Validated[ListWrapper[String], ListWrapper[Int]]]))
+             SerializableTests.serializable(Eq[Validated[ListWrapper[String], ListWrapper[Int]]])
+    )
   }
 
   test("ap2 combines failures in order") {
diff --git a/tests/src/test/scala/cats/tests/VarianceSuite.scala b/tests/src/test/scala/cats/tests/VarianceSuite.scala
deleted file mode 100644
index 33d029b8f..000000000
--- a/tests/src/test/scala/cats/tests/VarianceSuite.scala
+++ /dev/null
@@ -1,46 +0,0 @@
-package cats.tests
-
-import cats.{Bifunctor, Contravariant, Functor}
-import cats.implicits._
-import cats.conversions.all._
-
-class VarianceSuite extends CatsSuite {
-
-  sealed trait Foo
-  case class Bar(x: Int) extends Foo
-  case object Baz extends Foo
-
-  test("Auto-variance should infer subtypes correctly") {
-    def shouldInfer[F[_]: Functor](fi: F[Int]) =
-      fi.map(i => if (true) Left(Bar(i)) else Right(Baz))
-
-    def inferred[F[_]: Functor](fi: F[Int]): F[Either[Foo, Foo]] = shouldInfer[F](fi)
-  }
-
-  test("Auto-variance should infer supertypes correctly") {
-    def shouldCompile[F[_]: Contravariant](fi: F[Foo])(f: F[Bar] => Int) =
-      f(fi)
-  }
-
-  test("Auto-variance should widen a bifunctor automatically") {
-    def shouldInfer[F[_, _]: Bifunctor](fi: F[Int, Int]) =
-      fi.bimap(i => if (true) Left(Bar(i)) else Right(Baz), i => if (true) Left(Bar(i)) else Right(Baz))
-
-    def inferred[F[_, _]: Bifunctor](fi: F[Int, Int]): F[Either[Foo, Foo], Either[Foo, Foo]] = shouldInfer[F](fi)
-  }
-
-  test("Auto-variance should left widen a bifunctor automatically") {
-    def shouldInfer[F[_, _]: Bifunctor](fi: F[Int, Int]) =
-      fi.bimap(identity, i => if (true) Left(Bar(i)) else Right(Baz))
-
-    def inferred[F[_, _]: Bifunctor](fi: F[Int, Int]): F[Int, Either[Foo, Foo]] = shouldInfer[F](fi)
-  }
-
-  test("Auto-variance should right widen a bifunctor automatically") {
-    def shouldInfer[F[_, _]: Bifunctor](fi: F[Int, Int]) =
-      fi.bimap(i => if (true) Left(Bar(i)) else Right(Baz), identity)
-
-    def inferred[F[_, _]: Bifunctor](fi: F[Int, Int]): F[Either[Foo, Foo], Int] = shouldInfer[F](fi)
-  }
-
-}
diff --git a/tests/src/test/scala/cats/tests/VectorSuite.scala b/tests/src/test/scala/cats/tests/VectorSuite.scala
index 9155653df..4fdd04815 100644
--- a/tests/src/test/scala/cats/tests/VectorSuite.scala
+++ b/tests/src/test/scala/cats/tests/VectorSuite.scala
@@ -42,6 +42,7 @@ class VectorSuite extends CatsSuite {
   checkAll("Align[Vector]", SerializableTests.serializable(Align[Vector]))
 
   checkAll("Vector[Int]", ShortCircuitingTests[Vector].traverseFilter[Int])
+  checkAll("Vector[Int]", ShortCircuitingTests[Vector].foldable[Int])
 
   checkAll("ZipVector[Int]", CommutativeApplyTests[ZipVector].commutativeApply[Int, Int, Int])
 
diff --git a/tests/src/test/scala/cats/tests/WordCountSuite.scala b/tests/src/test/scala/cats/tests/WordCountSuite.scala
index ecd2394e1..e71b0ec5e 100644
--- a/tests/src/test/scala/cats/tests/WordCountSuite.scala
+++ b/tests/src/test/scala/cats/tests/WordCountSuite.scala
@@ -27,7 +27,7 @@ class WordCountSuite extends CatsSuite {
       appFunc { (c: Char) =>
         liftInt(testIf(c == '\n'))
       }
-    def isSpace(c: Char): Boolean = (c == ' ' || c == '\n')
+    def isSpace(c: Char): Boolean = c == ' ' || c == '\n'
 
     // To count words, we need to detect transitions from whitespace to non-whitespace.
     val countWord =
diff --git a/tests/src/test/scala/cats/tests/WriterTSuite.scala b/tests/src/test/scala/cats/tests/WriterTSuite.scala
index 8b43a4e46..6584872bf 100644
--- a/tests/src/test/scala/cats/tests/WriterTSuite.scala
+++ b/tests/src/test/scala/cats/tests/WriterTSuite.scala
@@ -23,9 +23,11 @@ class WriterTSuite extends CatsSuite {
   checkAll("Eq[WriterT[List, Int, Int]]", SerializableTests.serializable(Eq[WriterT[List, Int, Int]]))
 
   checkAll("WriterT[Show, MiniInt, *]",
-           ContravariantTests[WriterT[Show, MiniInt, *]].contravariant[MiniInt, Int, Boolean])
+           ContravariantTests[WriterT[Show, MiniInt, *]].contravariant[MiniInt, Int, Boolean]
+  )
   checkAll("Contravariant[WriterT[Show, Int, Int]]",
-           SerializableTests.serializable(Contravariant[WriterT[Show, Int, *]]))
+           SerializableTests.serializable(Contravariant[WriterT[Show, Int, *]])
+  )
 
   // check that this resolves
   Eq[Writer[Int, Int]]
@@ -121,9 +123,11 @@ class WriterTSuite extends CatsSuite {
     implicit val F: SemigroupK[ListWrapper] = ListWrapper.semigroupK
 
     checkAll("WriterT[ListWrapper, ListWrapper[Int], *]",
-             SemigroupKTests[WriterT[ListWrapper, ListWrapper[Int], *]].semigroupK[Int])
+             SemigroupKTests[WriterT[ListWrapper, ListWrapper[Int], *]].semigroupK[Int]
+    )
     checkAll("SemigroupK[WriterT[ListWrapper, ListWrapper[Int], *]]",
-             SerializableTests.serializable(SemigroupK[WriterT[ListWrapper, ListWrapper[Int], *]]))
+             SerializableTests.serializable(SemigroupK[WriterT[ListWrapper, ListWrapper[Int], *]])
+    )
   }
 
   {
@@ -133,9 +137,11 @@ class WriterTSuite extends CatsSuite {
     SemigroupK[WriterT[ListWrapper, ListWrapper[Int], *]]
 
     checkAll("WriterT[ListWrapper, ListWrapper[Int], *]",
-             MonoidKTests[WriterT[ListWrapper, ListWrapper[Int], *]].monoidK[Int])
+             MonoidKTests[WriterT[ListWrapper, ListWrapper[Int], *]].monoidK[Int]
+    )
     checkAll("MonoidK[WriterT[ListWrapper, ListWrapper[Int], *]]",
-             SerializableTests.serializable(MonoidK[WriterT[ListWrapper, ListWrapper[Int], *]]))
+             SerializableTests.serializable(MonoidK[WriterT[ListWrapper, ListWrapper[Int], *]])
+    )
   }
 
   {
@@ -143,9 +149,11 @@ class WriterTSuite extends CatsSuite {
     implicit val F: Functor[ListWrapper] = ListWrapper.functor
 
     checkAll("WriterT[ListWrapper, ListWrapper[Int], *]",
-             FunctorTests[WriterT[ListWrapper, ListWrapper[Int], *]].functor[Int, Int, Int])
+             FunctorTests[WriterT[ListWrapper, ListWrapper[Int], *]].functor[Int, Int, Int]
+    )
     checkAll("Functor[WriterT[ListWrapper, ListWrapper[Int], *]]",
-             SerializableTests.serializable(Functor[WriterT[ListWrapper, ListWrapper[Int], *]]))
+             SerializableTests.serializable(Functor[WriterT[ListWrapper, ListWrapper[Int], *]])
+    )
 
     checkAll("WriterT[Listwrapper, Int, *]", CoflatMapTests[WriterT[ListWrapper, Int, *]].coflatMap[Int, Int, Int])
     checkAll("WriterT[ListWrapper, Int, *]", SerializableTests.serializable(CoflatMap[WriterT[ListWrapper, Int, *]]))
@@ -158,9 +166,11 @@ class WriterTSuite extends CatsSuite {
     Functor[Logged]
 
     checkAll("WriterT[ListWrapper, *, *]",
-             BifunctorTests[WriterT[ListWrapper, *, *]].bifunctor[Int, Int, Int, Int, Int, Int])
+             BifunctorTests[WriterT[ListWrapper, *, *]].bifunctor[Int, Int, Int, Int, Int, Int]
+    )
     checkAll("Bifunctor[WriterT[ListWrapper, *, *]]",
-             SerializableTests.serializable(Bifunctor[WriterT[ListWrapper, *, *]]))
+             SerializableTests.serializable(Bifunctor[WriterT[ListWrapper, *, *]])
+    )
   }
 
   implicit val iso: Isomorphisms[WriterT[ListWrapper, ListWrapper[Int], *]] = Isomorphisms
@@ -177,9 +187,11 @@ class WriterTSuite extends CatsSuite {
 
     Functor[WriterT[ListWrapper, ListWrapper[Int], *]]
     checkAll("WriterT[ListWrapper, ListWrapper[Int], *]",
-             ApplyTests[WriterT[ListWrapper, ListWrapper[Int], *]].apply[Int, Int, Int])
+             ApplyTests[WriterT[ListWrapper, ListWrapper[Int], *]].apply[Int, Int, Int]
+    )
     checkAll("Apply[WriterT[ListWrapper, ListWrapper[Int], *]]",
-             SerializableTests.serializable(Apply[WriterT[ListWrapper, ListWrapper[Int], *]]))
+             SerializableTests.serializable(Apply[WriterT[ListWrapper, ListWrapper[Int], *]])
+    )
 
     Functor[WriterT[Id, ListWrapper[Int], *]]
     Apply[WriterT[Id, ListWrapper[Int], *]]
@@ -203,9 +215,11 @@ class WriterTSuite extends CatsSuite {
     Apply[WriterT[ListWrapper, ListWrapper[Int], *]]
     CoflatMap[WriterT[ListWrapper, ListWrapper[Int], *]]
     checkAll("WriterT[ListWrapper, ListWrapper[Int], *] 1",
-             FlatMapTests[WriterT[ListWrapper, ListWrapper[Int], *]].flatMap[Int, Int, Int])
+             FlatMapTests[WriterT[ListWrapper, ListWrapper[Int], *]].flatMap[Int, Int, Int]
+    )
     checkAll("FlatMap[WriterT[ListWrapper, ListWrapper[Int], *]] 1",
-             SerializableTests.serializable(FlatMap[WriterT[ListWrapper, ListWrapper[Int], *]]))
+             SerializableTests.serializable(FlatMap[WriterT[ListWrapper, ListWrapper[Int], *]])
+    )
 
     Functor[WriterT[Id, ListWrapper[Int], *]]
     Apply[WriterT[Id, ListWrapper[Int], *]]
@@ -231,9 +245,11 @@ class WriterTSuite extends CatsSuite {
     Apply[WriterT[ListWrapper, ListWrapper[Int], *]]
     CoflatMap[WriterT[ListWrapper, ListWrapper[Int], *]]
     checkAll("WriterT[ListWrapper, ListWrapper[Int], *] 2",
-             FlatMapTests[WriterT[ListWrapper, ListWrapper[Int], *]].flatMap[Int, Int, Int])
+             FlatMapTests[WriterT[ListWrapper, ListWrapper[Int], *]].flatMap[Int, Int, Int]
+    )
     checkAll("FlatMap[WriterT[ListWrapper, ListWrapper[Int], *]] 2",
-             SerializableTests.serializable(FlatMap[WriterT[ListWrapper, ListWrapper[Int], *]]))
+             SerializableTests.serializable(FlatMap[WriterT[ListWrapper, ListWrapper[Int], *]])
+    )
 
     Functor[WriterT[Id, ListWrapper[Int], *]]
     Apply[WriterT[Id, ListWrapper[Int], *]]
@@ -260,9 +276,11 @@ class WriterTSuite extends CatsSuite {
     Apply[WriterT[ListWrapper, ListWrapper[Int], *]]
     CoflatMap[WriterT[ListWrapper, ListWrapper[Int], *]]
     checkAll("WriterT[ListWrapper, ListWrapper[Int], *]",
-             ApplicativeTests[WriterT[ListWrapper, ListWrapper[Int], *]].applicative[Int, Int, Int])
+             ApplicativeTests[WriterT[ListWrapper, ListWrapper[Int], *]].applicative[Int, Int, Int]
+    )
     checkAll("Applicative[WriterT[ListWrapper, ListWrapper[Int], *]]",
-             SerializableTests.serializable(Applicative[WriterT[ListWrapper, ListWrapper[Int], *]]))
+             SerializableTests.serializable(Applicative[WriterT[ListWrapper, ListWrapper[Int], *]])
+    )
 
     Functor[WriterT[Id, ListWrapper[Int], *]]
     Apply[WriterT[Id, ListWrapper[Int], *]]
@@ -291,9 +309,11 @@ class WriterTSuite extends CatsSuite {
     FlatMap[WriterT[ListWrapper, ListWrapper[Int], *]]
     CoflatMap[WriterT[ListWrapper, ListWrapper[Int], *]]
     checkAll("WriterT[ListWrapper, ListWrapper[Int], *]",
-             MonadTests[WriterT[ListWrapper, ListWrapper[Int], *]].monad[Int, Int, Int])
+             MonadTests[WriterT[ListWrapper, ListWrapper[Int], *]].monad[Int, Int, Int]
+    )
     checkAll("Monad[WriterT[ListWrapper, ListWrapper[Int], *], List[String]]",
-             SerializableTests.serializable(Monad[WriterT[ListWrapper, ListWrapper[Int], *]]))
+             SerializableTests.serializable(Monad[WriterT[ListWrapper, ListWrapper[Int], *]])
+    )
 
     Functor[WriterT[Id, ListWrapper[Int], *]]
     Apply[WriterT[Id, ListWrapper[Int], *]]
@@ -328,9 +348,11 @@ class WriterTSuite extends CatsSuite {
     Alternative[WriterT[ListWrapper, ListWrapper[Int], *]]
     CoflatMap[WriterT[ListWrapper, ListWrapper[Int], *]]
     checkAll("WriterT[ListWrapper, ListWrapper[Int], *]",
-             AlternativeTests[WriterT[ListWrapper, ListWrapper[Int], *]].alternative[Int, Int, Int])
+             AlternativeTests[WriterT[ListWrapper, ListWrapper[Int], *]].alternative[Int, Int, Int]
+    )
     checkAll("Alternative[WriterT[ListWrapper, ListWrapper[Int], *]]",
-             SerializableTests.serializable(Alternative[WriterT[ListWrapper, ListWrapper[Int], *]]))
+             SerializableTests.serializable(Alternative[WriterT[ListWrapper, ListWrapper[Int], *]])
+    )
   }
 
   {
@@ -340,7 +362,8 @@ class WriterTSuite extends CatsSuite {
     Monoid[WriterT[ListWrapper, Int, Int]]
     checkAll("WriterT[ListWrapper, Int, Int]", MonoidTests[WriterT[ListWrapper, Int, Int]].monoid)
     checkAll("Monoid[WriterT[ListWrapper, Int, Int]]",
-             SerializableTests.serializable(Monoid[WriterT[ListWrapper, Int, Int]]))
+             SerializableTests.serializable(Monoid[WriterT[ListWrapper, Int, Int]])
+    )
 
     Monoid[Writer[Int, Int]]
     checkAll("Writer[Int, Int]", MonoidTests[Writer[Int, Int]].monoid)
@@ -353,7 +376,8 @@ class WriterTSuite extends CatsSuite {
     Semigroup[WriterT[ListWrapper, Int, Int]]
     checkAll("WriterT[ListWrapper, Int, Int]", SemigroupTests[WriterT[ListWrapper, Int, Int]].semigroup)
     checkAll("Semigroup[WriterT[ListWrapper, Int, Int]]",
-             SerializableTests.serializable(Semigroup[WriterT[ListWrapper, Int, Int]]))
+             SerializableTests.serializable(Semigroup[WriterT[ListWrapper, Int, Int]])
+    )
 
     Semigroup[Writer[Int, Int]]
     checkAll("Writer[Int, Int]", SemigroupTests[Writer[Int, Int]].semigroup)
@@ -376,7 +400,8 @@ class WriterTSuite extends CatsSuite {
     Applicative[WriterT[Validated[String, *], ListWrapper[Int], *]]
 
     checkAll("WriterT[Validated[String, *], ListWrapper[Int], *]",
-             ApplicativeTests[WriterT[Validated[String, *], ListWrapper[Int], *]].applicative[Int, Int, Int])
+             ApplicativeTests[WriterT[Validated[String, *], ListWrapper[Int], *]].applicative[Int, Int, Int]
+    )
     checkAll(
       "Applicative[WriterT[Validated[String, *], ListWrapper[Int], *]]",
       SerializableTests.serializable(Applicative[WriterT[Validated[String, *], ListWrapper[Int], *]])
@@ -417,9 +442,11 @@ class WriterTSuite extends CatsSuite {
     ApplicativeError[WriterT[Option, ListWrapper[Int], *], Unit]
 
     checkAll("WriterT[Option, ListWrapper[Int], *]",
-             MonadErrorTests[WriterT[Option, ListWrapper[Int], *], Unit].monadError[Int, Int, Int])
+             MonadErrorTests[WriterT[Option, ListWrapper[Int], *], Unit].monadError[Int, Int, Int]
+    )
     checkAll("MonadError[WriterT[Option, ListWrapper[Int], *], Unit]",
-             SerializableTests.serializable(MonadError[WriterT[Option, ListWrapper[Int], *], Unit]))
+             SerializableTests.serializable(MonadError[WriterT[Option, ListWrapper[Int], *], Unit])
+    )
   }
 
   {
@@ -427,9 +454,11 @@ class WriterTSuite extends CatsSuite {
     ContravariantMonoidal[WriterT[Const[String, *], Int, *]]
 
     checkAll("WriterT[Const[String, *], Int, *]",
-             ContravariantMonoidalTests[WriterT[Const[String, *], Int, *]].contravariantMonoidal[Int, Int, Int])
+             ContravariantMonoidalTests[WriterT[Const[String, *], Int, *]].contravariantMonoidal[Int, Int, Int]
+    )
     checkAll("ContravariantMonoidal[WriterT[Const[String, *], Int, *]]",
-             SerializableTests.serializable(ContravariantMonoidal[WriterT[Const[String, *], Int, *]]))
+             SerializableTests.serializable(ContravariantMonoidal[WriterT[Const[String, *], Int, *]])
+    )
   }
 
   {
@@ -440,7 +469,8 @@ class WriterTSuite extends CatsSuite {
 
     checkAll("WriterT[ListWrapper, Int, *]", InvariantTests[WriterT[ListWrapper, Int, *]].invariant[Int, Int, Int])
     checkAll("Invariant[WriterT[ListWrapper, Int, *]]",
-             SerializableTests.serializable(Invariant[WriterT[ListWrapper, Int, *]]))
+             SerializableTests.serializable(Invariant[WriterT[ListWrapper, Int, *]])
+    )
   }
 
   {
@@ -450,9 +480,11 @@ class WriterTSuite extends CatsSuite {
     Foldable[WriterT[Const[String, *], ListWrapper[Int], *]]
 
     checkAll("WriterT[Const[String, *], ListWrapper[Int], *]",
-             FoldableTests[WriterT[Const[String, *], ListWrapper[Int], *]].foldable[Int, Int])
+             FoldableTests[WriterT[Const[String, *], ListWrapper[Int], *]].foldable[Int, Int]
+    )
     checkAll("Foldable[WriterT[Const[String, *], ListWrapper[Int], *]]",
-             SerializableTests.serializable(Foldable[WriterT[Const[String, *], ListWrapper[Int], *]]))
+             SerializableTests.serializable(Foldable[WriterT[Const[String, *], ListWrapper[Int], *]])
+    )
 
     Foldable[Id]
     Foldable[WriterT[Id, ListWrapper[Int], *]]
@@ -468,16 +500,19 @@ class WriterTSuite extends CatsSuite {
     Traverse[WriterT[Const[String, *], ListWrapper[Int], *]]
 
     checkAll("WriterT[Const[String, *], ListWrapper[Int], *]",
-             TraverseTests[WriterT[Const[String, *], ListWrapper[Int], *]].traverse[Int, Int, Int, Int, Option, Option])
+             TraverseTests[WriterT[Const[String, *], ListWrapper[Int], *]].traverse[Int, Int, Int, Int, Option, Option]
+    )
     checkAll("Traverse[WriterT[Const[String, *], ListWrapper[Int], *]]",
-             SerializableTests.serializable(Traverse[WriterT[Const[String, *], ListWrapper[Int], *]]))
+             SerializableTests.serializable(Traverse[WriterT[Const[String, *], ListWrapper[Int], *]])
+    )
 
     Traverse[Id]
     Traverse[WriterT[Id, ListWrapper[Int], *]]
     Traverse[Writer[ListWrapper[Int], *]]
 
     checkAll("WriterT[Id, ListWrapper[Int], *]",
-             TraverseTests[WriterT[Id, ListWrapper[Int], *]].traverse[Int, Int, Int, Int, Option, Option])
+             TraverseTests[WriterT[Id, ListWrapper[Int], *]].traverse[Int, Int, Int, Int, Option, Option]
+    )
   }
 
   {
@@ -485,9 +520,11 @@ class WriterTSuite extends CatsSuite {
     Comonad[WriterT[(String, *), ListWrapper[Int], *]]
 
     checkAll("WriterT[(String, *), ListWrapper[Int], *]",
-             ComonadTests[WriterT[(String, *), ListWrapper[Int], *]].comonad[Int, Int, Int])
+             ComonadTests[WriterT[(String, *), ListWrapper[Int], *]].comonad[Int, Int, Int]
+    )
     checkAll("Comonad[WriterT[(String, *), ListWrapper[Int], *]]",
-             SerializableTests.serializable(Comonad[WriterT[(String, *), ListWrapper[Int], *]]))
+             SerializableTests.serializable(Comonad[WriterT[(String, *), ListWrapper[Int], *]])
+    )
 
     Comonad[Id]
     Comonad[WriterT[Id, ListWrapper[Int], *]]
@@ -498,5 +535,6 @@ class WriterTSuite extends CatsSuite {
 
   checkAll("WriterT[Option, Int, *]", CommutativeMonadTests[WriterT[Option, Int, *]].commutativeMonad[Int, Int, Int])
   checkAll("CommutativeMonad[WriterT[Option, Int, *]]",
-           SerializableTests.serializable(CommutativeMonad[WriterT[Option, Int, *]]))
+           SerializableTests.serializable(CommutativeMonad[WriterT[Option, Int, *]])
+  )
 }
