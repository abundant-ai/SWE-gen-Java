diff --git a/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorExecutorImpl.java b/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorExecutorImpl.java
index 9e6ab57174..5300a8b158 100644
--- a/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorExecutorImpl.java
+++ b/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorExecutorImpl.java
@@ -16,7 +16,6 @@
  */
 package org.apache.kafka.coordinator.common.runtime;
 
-import org.apache.kafka.common.TopicPartition;
 import org.apache.kafka.common.errors.CoordinatorLoadInProgressException;
 import org.apache.kafka.common.errors.NotCoordinatorException;
 import org.apache.kafka.common.utils.LogContext;
@@ -28,25 +27,22 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.RejectedExecutionException;
 
-public class CoordinatorExecutorImpl<S extends CoordinatorShard<U>, U> implements CoordinatorExecutor<U> {
+public class CoordinatorExecutorImpl<U> implements CoordinatorExecutor<U> {
     private record TaskResult<R>(R result, Throwable exception) { }
 
     private final Logger log;
-    private final TopicPartition shard;
-    private final CoordinatorRuntime<S, U> runtime;
     private final ExecutorService executor;
+    private final CoordinatorShardScheduler<U> scheduler;
     private final Map<String, TaskRunnable<?>> tasks = new ConcurrentHashMap<>();
 
     public CoordinatorExecutorImpl(
         LogContext logContext,
-        TopicPartition shard,
-        CoordinatorRuntime<S, U> runtime,
-        ExecutorService executor
+        ExecutorService executor,
+        CoordinatorShardScheduler<U> scheduler
     ) {
         this.log = logContext.logger(CoordinatorExecutorImpl.class);
-        this.shard = shard;
-        this.runtime = runtime;
         this.executor = executor;
+        this.scheduler = scheduler;
     }
 
     private <R> TaskResult<R> executeTask(TaskRunnable<R> task) {
@@ -73,13 +69,12 @@ public class CoordinatorExecutorImpl<S extends CoordinatorShard<U>, U> implement
             if (tasks.get(key) != task) return;
 
             // Execute the task.
-            final TaskResult<R> result = executeTask(task);
+            var result = executeTask(task);
 
             // Schedule the operation.
-            runtime.scheduleWriteOperation(
+            scheduler.scheduleWriteOperation(
                 key,
-                shard,
-                coordinator -> {
+                () -> {
                     // If the task associated with the key is not us, it means
                     // that the task was either replaced or cancelled. We stop.
                     if (!tasks.remove(key, task)) {
@@ -87,7 +82,7 @@ public class CoordinatorExecutorImpl<S extends CoordinatorShard<U>, U> implement
                     }
 
                     // Call the underlying write operation with the result of the task.
-                    return operation.onComplete(result.result, result.exception);
+                    return operation.onComplete(result.result(), result.exception());
                 }
             ).exceptionally(exception -> {
                 // Remove the task after a failure.
diff --git a/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorRuntime.java b/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorRuntime.java
index d5b676ba9a..9c8b6c319d 100644
--- a/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorRuntime.java
+++ b/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorRuntime.java
@@ -50,8 +50,6 @@ import org.slf4j.Logger;
 import java.nio.ByteBuffer;
 import java.time.Duration;
 import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -60,7 +58,6 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.RejectedExecutionException;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.ReentrantLock;
@@ -315,163 +312,6 @@ public class CoordinatorRuntime<S extends CoordinatorShard<U>, U> implements Aut
         abstract boolean canTransitionFrom(CoordinatorState state);
     }
 
-    /**
-     * The EventBasedCoordinatorTimer implements the CoordinatorTimer interface and provides an event based
-     * timer which turns timeouts of a regular {@link Timer} into {@link CoordinatorWriteEvent} events which
-     * are executed by the {@link CoordinatorEventProcessor} used by this coordinator runtime. This is done
-     * to ensure that the timer respects the threading model of the coordinator runtime.
-     *
-     * The {@link CoordinatorWriteEvent} events pushed by the coordinator timer wraps the
-     * {@link TimeoutOperation} operations scheduled by the coordinators.
-     *
-     * It also keeps track of all the scheduled {@link TimerTask}. This allows timeout operations to be
-     * cancelled or rescheduled. When a timer is cancelled or overridden, the previous timer is guaranteed to
-     * not be executed even if it already expired and got pushed to the event processor.
-     *
-     * When a timer fails with an unexpected exception, the timer is rescheduled with a backoff.
-     */
-    class EventBasedCoordinatorTimer implements CoordinatorTimer<Void, U> {
-        /**
-         * The logger.
-         */
-        final Logger log;
-
-        /**
-         * The topic partition.
-         */
-        final TopicPartition tp;
-
-        /**
-         * The scheduled timers keyed by their key.
-         */
-        final Map<String, TimerTask> tasks = new HashMap<>();
-
-        EventBasedCoordinatorTimer(TopicPartition tp, LogContext logContext) {
-            this.tp = tp;
-            this.log = logContext.logger(EventBasedCoordinatorTimer.class);
-        }
-
-        @Override
-        public void schedule(
-            String key,
-            long delay,
-            TimeUnit unit,
-            boolean retry,
-            TimeoutOperation<Void, U> operation
-        ) {
-            schedule(key, delay, unit, retry, 500, operation);
-        }
-
-        @Override
-        public void schedule(
-            String key,
-            long delay,
-            TimeUnit unit,
-            boolean retry,
-            long retryBackoff,
-            TimeoutOperation<Void, U> operation
-        ) {
-            // The TimerTask wraps the TimeoutOperation into a CoordinatorWriteEvent. When the TimerTask
-            // expires, the event is pushed to the queue of the coordinator runtime to be executed. This
-            // ensures that the threading model of the runtime is respected.
-            TimerTask task = new TimerTask(unit.toMillis(delay)) {
-                @Override
-                public void run() {
-                    String eventName = "Timeout(tp=" + tp + ", key=" + key + ")";
-                    CoordinatorWriteEvent<Void> event = new CoordinatorWriteEvent<>(eventName, tp, writeTimeout, coordinator -> {
-                        log.debug("Executing write event {} for timer {}.", eventName, key);
-
-                        // If the task is different, it means that the timer has been
-                        // cancelled while the event was waiting to be processed.
-                        if (!tasks.remove(key, this)) {
-                            throw new RejectedExecutionException("Timer " + key + " was overridden or cancelled");
-                        }
-
-                        // Execute the timeout operation.
-                        return operation.generateRecords();
-                    });
-
-                    // If the write event fails, it is rescheduled with a small backoff except if retry
-                    // is disabled or if the error is fatal.
-                    event.future.exceptionally(ex -> {
-                        if (ex instanceof RejectedExecutionException) {
-                            log.debug("The write event {} for the timer {} was not executed because it was " +
-                                "cancelled or overridden.", event.name, key);
-                            return null;
-                        }
-
-                        if (ex instanceof NotCoordinatorException || ex instanceof CoordinatorLoadInProgressException) {
-                            log.debug("The write event {} for the timer {} failed due to {}. Ignoring it because " +
-                                "the coordinator is not active.", event.name, key, ex.getMessage());
-                            return null;
-                        }
-
-                        if (retry) {
-                            log.info("The write event {} for the timer {} failed due to {}. Rescheduling it. ",
-                                event.name, key, ex.getMessage());
-                            schedule(key, retryBackoff, TimeUnit.MILLISECONDS, true, retryBackoff, operation);
-                        } else {
-                            log.error("The write event {} for the timer {} failed due to {}. Ignoring it. ",
-                                event.name, key, ex.getMessage(), ex);
-                        }
-
-                        return null;
-                    });
-
-                    log.debug("Scheduling write event {} for timer {}.", event.name, key);
-                    try {
-                        enqueueLast(event);
-                    } catch (NotCoordinatorException ex) {
-                        log.info("Failed to enqueue write event {} for timer {} because the runtime is closed. Ignoring it.",
-                            event.name, key);
-                    }
-                }
-            };
-
-            log.debug("Registering timer {} with delay of {}ms.", key, unit.toMillis(delay));
-            TimerTask prevTask = tasks.put(key, task);
-            if (prevTask != null) prevTask.cancel();
-
-            timer.add(task);
-        }
-
-        @Override
-        public void scheduleIfAbsent(
-            String key,
-            long delay,
-            TimeUnit unit,
-            boolean retry,
-            TimeoutOperation<Void, U> operation
-        ) {
-            if (!tasks.containsKey(key)) {
-                schedule(key, delay, unit, retry, 500, operation);
-            }
-        }
-
-        @Override
-        public void cancel(String key) {
-            TimerTask prevTask = tasks.remove(key);
-            if (prevTask != null) prevTask.cancel();
-        }
-
-        @Override
-        public boolean isScheduled(String key) {
-            return tasks.containsKey(key);
-        }
-
-        public void cancelAll() {
-            Iterator<Map.Entry<String, TimerTask>> iterator = tasks.entrySet().iterator();
-            while (iterator.hasNext()) {
-                iterator.next().getValue().cancel();
-                iterator.remove();
-            }
-        }
-
-        public int size() {
-            return tasks.size();
-        }
-    }
-
     /**
      * A simple container class to hold all the attributes
      * related to a pending batch.
@@ -570,12 +410,12 @@ public class CoordinatorRuntime<S extends CoordinatorShard<U>, U> implements Aut
         /**
          * The coordinator timer.
          */
-        final EventBasedCoordinatorTimer timer;
+        final CoordinatorTimerImpl<U> timer;
 
         /**
          * The coordinator executor.
          */
-        final CoordinatorExecutorImpl<S, U> executor;
+        final CoordinatorExecutorImpl<U> executor;
 
         /**
          * The current state.
@@ -639,12 +479,35 @@ public class CoordinatorRuntime<S extends CoordinatorShard<U>, U> implements Aut
             this.state = CoordinatorState.INITIAL;
             this.epoch = -1;
             this.deferredEventQueue = new DeferredEventQueue(logContext);
-            this.timer = new EventBasedCoordinatorTimer(tp, logContext);
+            this.timer = new CoordinatorTimerImpl<>(
+                logContext,
+                CoordinatorRuntime.this.timer,
+                (operationName, operation) -> {
+                    try {
+                        return scheduleWriteOperation(
+                            operationName,
+                            tp,
+                            coordinator -> operation.generate()
+                        );
+                    } catch (Throwable t) {
+                        return CompletableFuture.failedFuture(t);
+                    }
+                }
+            );
             this.executor = new CoordinatorExecutorImpl<>(
                 logContext,
-                tp,
-                CoordinatorRuntime.this,
-                executorService
+                executorService,
+                (operationName, operation) -> {
+                    try {
+                        return scheduleWriteOperation(
+                            operationName,
+                            tp,
+                            coordinator -> operation.generate()
+                        );
+                    } catch (Throwable t) {
+                        return CompletableFuture.failedFuture(t);
+                    }
+                }
             );
             this.bufferSupplier = new BufferSupplier.GrowableBufferSupplier();
             this.cachedBufferSize = new AtomicLong(0);
diff --git a/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorShardScheduler.java b/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorShardScheduler.java
new file mode 100644
index 0000000000..18fb1b8671
--- /dev/null
+++ b/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorShardScheduler.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.kafka.coordinator.common.runtime;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * Scheduler interface for shard-scoped components to schedule write operations
+ * through the coordinator runtime without depending on the full runtime API.
+ *
+ * @param <U> The record type used by the coordinator.
+ */
+@FunctionalInterface
+public interface CoordinatorShardScheduler<U> {
+
+    /**
+     * A write operation that produces records.
+     *
+     * @param <U> The record type used by the coordinator.
+     */
+    @FunctionalInterface
+    interface WriteOperation<U> {
+        CoordinatorResult<Void, U> generate();
+    }
+
+    /**
+     * Schedules a write operation to be executed by the runtime.
+     *
+     * @param operationName The name of the operation for logging/debugging.
+     * @param operation     The write operation to execute.
+     * @return A future that completes when the operation is done.
+     */
+    CompletableFuture<Void> scheduleWriteOperation(
+        String operationName,
+        WriteOperation<U> operation
+    );
+}
diff --git a/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorTimerImpl.java b/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorTimerImpl.java
new file mode 100644
index 0000000000..0c66c99c25
--- /dev/null
+++ b/coordinator-common/src/main/java/org/apache/kafka/coordinator/common/runtime/CoordinatorTimerImpl.java
@@ -0,0 +1,173 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements. See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.kafka.coordinator.common.runtime;
+
+import org.apache.kafka.common.errors.CoordinatorLoadInProgressException;
+import org.apache.kafka.common.errors.NotCoordinatorException;
+import org.apache.kafka.common.utils.LogContext;
+import org.apache.kafka.server.util.timer.Timer;
+import org.apache.kafka.server.util.timer.TimerTask;
+
+import org.slf4j.Logger;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * An event-based coordinator timer that bridges Kafka's utility Timer class with the
+ * coordinator runtime's event-driven architecture. It converts timeout expiries into
+ * write operations that are scheduled through the runtime, ensuring all timeout operations
+ * respect the coordinator's threading model.
+ *
+ * When a timer fails with an unexpected exception, the timer is rescheduled with a backoff.
+ */
+public class CoordinatorTimerImpl<U> implements CoordinatorTimer<Void, U> {
+    private final Logger log;
+    private final Timer timer;
+    private final CoordinatorShardScheduler<U> scheduler;
+    private final Map<String, TimerTask> tasks = new HashMap<>();
+
+    public CoordinatorTimerImpl(
+        LogContext logContext,
+        Timer timer,
+        CoordinatorShardScheduler<U> scheduler
+    ) {
+        this.log = logContext.logger(CoordinatorTimerImpl.class);
+        this.timer = timer;
+        this.scheduler = scheduler;
+    }
+
+    @Override
+    public void schedule(
+        String key,
+        long delay,
+        TimeUnit unit,
+        boolean retry,
+        TimeoutOperation<Void, U> operation
+    ) {
+        schedule(key, delay, unit, retry, 500, operation);
+    }
+
+    @Override
+    public void schedule(
+        String key,
+        long delay,
+        TimeUnit unit,
+        boolean retry,
+        long retryBackoff,
+        TimeoutOperation<Void, U> operation
+    ) {
+        // The TimerTask wraps the TimeoutOperation into a write operation. When the TimerTask
+        // expires, the operation is scheduled through the scheduler to be executed. This
+        // ensures that the threading model of the runtime is respected.
+        var task = new TimerTask(unit.toMillis(delay)) {
+            @Override
+            public void run() {
+                var operationName = "Timeout(key=" + key + ")";
+
+                scheduler.scheduleWriteOperation(
+                    operationName,
+                    () -> {
+                        log.debug("Executing write event {} for timer {}.", operationName, key);
+
+                        // If the task is different, it means that the timer has been
+                        // cancelled while the event was waiting to be processed.
+                        if (!tasks.remove(key, this)) {
+                            throw new RejectedExecutionException("Timer " + key + " was overridden or cancelled");
+                        }
+
+                        // Execute the timeout operation.
+                        return operation.generateRecords();
+                    }
+                ).exceptionally(ex -> {
+                    // Remove the task after a failure.
+                    tasks.remove(key, this);
+
+                    if (ex instanceof RejectedExecutionException) {
+                        log.debug("The write event {} for the timer {} was not executed because it was " +
+                            "cancelled or overridden.", operationName, key);
+                        return null;
+                    }
+
+                    if (ex instanceof NotCoordinatorException || ex instanceof CoordinatorLoadInProgressException) {
+                        log.debug("The write event {} for the timer {} failed due to {}. Ignoring it because " +
+                            "the coordinator is not active.", operationName, key, ex.getMessage());
+                        return null;
+                    }
+
+                    if (retry) {
+                        log.info("The write event {} for the timer {} failed due to {}. Rescheduling it. ",
+                            operationName, key, ex.getMessage());
+                        schedule(key, retryBackoff, TimeUnit.MILLISECONDS, true, retryBackoff, operation);
+                    } else {
+                        log.error("The write event {} for the timer {} failed due to {}. Ignoring it. ",
+                            operationName, key, ex.getMessage(), ex);
+                    }
+
+                    return null;
+                });
+
+                log.debug("Scheduling write event {} for timer {}.", operationName, key);
+            }
+        };
+
+        log.debug("Registering timer {} with delay of {}ms.", key, unit.toMillis(delay));
+        var prevTask = tasks.put(key, task);
+        if (prevTask != null) prevTask.cancel();
+
+        timer.add(task);
+    }
+
+    @Override
+    public void scheduleIfAbsent(
+        String key,
+        long delay,
+        TimeUnit unit,
+        boolean retry,
+        TimeoutOperation<Void, U> operation
+    ) {
+        if (!tasks.containsKey(key)) {
+            schedule(key, delay, unit, retry, 500, operation);
+        }
+    }
+
+    @Override
+    public void cancel(String key) {
+        var prevTask = tasks.remove(key);
+        if (prevTask != null) prevTask.cancel();
+    }
+
+    @Override
+    public boolean isScheduled(String key) {
+        return tasks.containsKey(key);
+    }
+
+    public void cancelAll() {
+        Iterator<Map.Entry<String, TimerTask>> iterator = tasks.entrySet().iterator();
+        while (iterator.hasNext()) {
+            iterator.next().getValue().cancel();
+            iterator.remove();
+        }
+    }
+
+    public int size() {
+        return tasks.size();
+    }
+}
