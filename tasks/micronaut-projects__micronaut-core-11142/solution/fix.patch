diff --git a/benchmarks/build.gradle b/benchmarks/build.gradle
index 2f41c6f90d..d2d34f5727 100644
--- a/benchmarks/build.gradle
+++ b/benchmarks/build.gradle
@@ -43,8 +43,8 @@ dependencies {
 
     typeCheckTestImplementation libs.junit.jupiter
     typeCheckTestImplementation libs.micronaut.test.type.pollution
-    typeCheckTestImplementation ("net.bytebuddy:byte-buddy-agent:1.14.19")
-    typeCheckTestImplementation ("net.bytebuddy:byte-buddy:1.14.19")
+    typeCheckTestImplementation ("net.bytebuddy:byte-buddy-agent:1.14.18")
+    typeCheckTestImplementation ("net.bytebuddy:byte-buddy:1.14.18")
     typeCheckTestRuntimeOnly libs.junit.platform.engine
 }
 
diff --git a/config/checkstyle/custom-suppressions.xml b/config/checkstyle/custom-suppressions.xml
index 9e4881f9ff..a726d69293 100644
--- a/config/checkstyle/custom-suppressions.xml
+++ b/config/checkstyle/custom-suppressions.xml
@@ -16,7 +16,7 @@
 
     <suppress checks=".*" files="FlowControlHandler.java" />
 
-    <suppress checks="ParameterNumber" files="DefaultHttpClient.java|DefaultJdkHttpClient.java|JdkBlockingHttpClient.java" />
+    <suppress checks="ParameterNumber" files="DefaultHttpClient.java" />
 
     <suppress checks="IllegalImport" files="JavaxProviderBeanDefinition.java" />
 
diff --git a/context/src/main/java/io/micronaut/runtime/converters/time/TimeConverterRegistrar.java b/context/src/main/java/io/micronaut/runtime/converters/time/TimeConverterRegistrar.java
index 25598f7319..18a949b0df 100644
--- a/context/src/main/java/io/micronaut/runtime/converters/time/TimeConverterRegistrar.java
+++ b/context/src/main/java/io/micronaut/runtime/converters/time/TimeConverterRegistrar.java
@@ -29,6 +29,7 @@ import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDate;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.time.MonthDay;
 import java.time.OffsetDateTime;
 import java.time.OffsetTime;
@@ -39,7 +40,9 @@ import java.time.ZoneId;
 import java.time.ZoneOffset;
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
+import java.time.format.DateTimeFormatterBuilder;
 import java.time.format.DateTimeParseException;
+import java.time.format.SignStyle;
 import java.time.temporal.TemporalAccessor;
 import java.time.temporal.TemporalAmount;
 import java.time.temporal.TemporalQuery;
@@ -53,6 +56,10 @@ import java.util.function.Function;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import static java.time.temporal.ChronoField.DAY_OF_MONTH;
+import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
+import static java.time.temporal.ChronoField.YEAR;
+
 /**
  * Registers data time converters.
  *
@@ -60,87 +67,65 @@ import java.util.regex.Pattern;
  * @since 1.0
  */
 @TypeHint(
-        value = {
-                Duration.class,
-                TemporalAmount.class,
-                Instant.class,
-                LocalDate.class,
-                LocalDateTime.class,
-                MonthDay.class,
-                OffsetDateTime.class,
-                OffsetTime.class,
-                Period.class,
-                Year.class,
-                YearMonth.class,
-                ZonedDateTime.class,
-                ZoneId.class,
-                ZoneOffset.class
-        },
-        accessType = TypeHint.AccessType.ALL_PUBLIC
+    value = {
+        Duration.class,
+        TemporalAmount.class,
+        Instant.class,
+        LocalTime.class,
+        LocalDate.class,
+        LocalDateTime.class,
+        MonthDay.class,
+        OffsetDateTime.class,
+        OffsetTime.class,
+        Period.class,
+        Year.class,
+        YearMonth.class,
+        ZonedDateTime.class,
+        ZoneId.class,
+        ZoneOffset.class
+    },
+    accessType = TypeHint.AccessType.ALL_PUBLIC
 )
 @Internal
 public class TimeConverterRegistrar implements TypeConverterRegistrar {
 
+    private static final Pattern PERIOD_MATCHER = Pattern.compile("^(-?\\d+)([unywmd])(s?)$");
     private static final Pattern DURATION_MATCHER = Pattern.compile("^(-?\\d+)([unsmhd])(s?)$");
     private static final int MILLIS = 3;
 
+    /**
+     * Copy of java.time.Year.PARSER DateTimeFormatter.
+     */
+    private static final DateTimeFormatter ISO_YEAR = new DateTimeFormatterBuilder()
+        .parseLenient()
+        .appendValue(YEAR, 1, 10, SignStyle.NORMAL)
+        .toFormatter();
+
+    /**
+     * Copy of java.time.YearMonth.PARSER DateTimeFormatter.
+     */
+    private static final DateTimeFormatter ISO_YEAR_MONTH = new DateTimeFormatterBuilder()
+        .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)
+        .appendLiteral('-')
+        .appendValue(MONTH_OF_YEAR, 2)
+        .toFormatter();
+
+    /**
+     * Copy of java.time.MonthDay.PARSER DateTimeFormatter.
+     */
+    private static final DateTimeFormatter ISO_MONTH_DAY = new DateTimeFormatterBuilder()
+        .appendLiteral("--")
+        .appendValue(MONTH_OF_YEAR, 2)
+        .appendLiteral('-')
+        .appendValue(DAY_OF_MONTH, 2)
+        .toFormatter();
+
     private final Map<String, DateTimeFormatter> formattersCache = new ConcurrentHashMap<>();
 
     @NextMajorVersion("Consider deletion of LocalDate and LocalDateTime converters")
     @Override
     public void register(MutableConversionService conversionService) {
-        final BiFunction<CharSequence, ConversionContext, Optional<Duration>> durationConverter = (object, context) -> {
-            String value = object.toString().trim();
-            if (value.startsWith("P")) {
-                try {
-                    return Optional.of(Duration.parse(value));
-                } catch (DateTimeParseException e) {
-                    context.reject(value, e);
-                    return Optional.empty();
-                }
-            } else {
-                Matcher matcher = DURATION_MATCHER.matcher(value);
-                if (matcher.find()) {
-                    String amount = matcher.group(1);
-                    final String g2 = matcher.group(2);
-                    char type = g2.charAt(0);
-                    try {
-                        switch (type) {
-                            case 's' -> {
-                                return Optional.of(Duration.ofSeconds(Integer.parseInt(amount)));
-                            }
-                            case 'm' -> {
-                                String ms = matcher.group(MILLIS);
-                                if (StringUtils.hasText(ms)) {
-                                    return Optional.of(Duration.ofMillis(Integer.parseInt(amount)));
-                                } else {
-                                    return Optional.of(Duration.ofMinutes(Integer.parseInt(amount)));
-                                }
-                            }
-                            case 'h' -> {
-                                return Optional.of(Duration.ofHours(Integer.parseInt(amount)));
-                            }
-                            case 'd' -> {
-                                return Optional.of(Duration.ofDays(Integer.parseInt(amount)));
-                            }
-                            default -> {
-                                final String seq = g2 + matcher.group(3);
-                                if (seq.equals("ns")) {
-                                    return Optional.of(Duration.ofNanos(Integer.parseInt(amount)));
-                                }
-                                context.reject(
-                                        value,
-                                        new DateTimeParseException("Unparseable date format (" + value + "). Should either be a ISO-8601 duration or a round number followed by the unit type", value, 0));
-                                return Optional.empty();
-                            }
-                        }
-                    } catch (NumberFormatException e) {
-                        context.reject(value, e);
-                    }
-                }
-            }
-            return Optional.empty();
-        };
+        final BiFunction<CharSequence, ConversionContext, Optional<Duration>> durationConverter = durationConverter();
 
         // CharSequence -> Duration
         conversionService.addConverter(
@@ -163,6 +148,29 @@ public class TimeConverterRegistrar implements TypeConverterRegistrar {
             (object, targetType, context) -> durationConverter.apply(object, context).map(TemporalAmount.class::cast)
         );
 
+        final BiFunction<CharSequence, ConversionContext, Optional<Period>> periodConverter = periodConverter();
+
+        // CharSequence -> Period
+        conversionService.addConverter(
+            CharSequence.class,
+            Period.class,
+            (object, targetType, context) -> periodConverter.apply(object, context)
+        );
+
+        // Integer -> Period
+        conversionService.addConverter(
+            Integer.class,
+            Period.class,
+            (integer, targetType, context) -> periodConverter.apply(integer.toString(), context)
+        );
+
+        // CharSequence -> TemporalAmount
+        conversionService.addConverter(
+            CharSequence.class,
+            TemporalAmount.class,
+            (object, targetType, context) -> periodConverter.apply(object, context).map(TemporalAmount.class::cast)
+        );
+
         addTemporalStringConverters(conversionService, Instant.class, DateTimeFormatter.ISO_INSTANT, Instant::from);
         addTemporalStringConverters(conversionService, LocalDate.class, DateTimeFormatter.ISO_LOCAL_DATE, LocalDate::from);
         addTemporalStringConverters(conversionService, LocalDateTime.class, DateTimeFormatter.ISO_LOCAL_DATE_TIME, LocalDateTime::from);
@@ -170,6 +178,31 @@ public class TimeConverterRegistrar implements TypeConverterRegistrar {
         addTemporalStringConverters(conversionService, OffsetDateTime.class, DateTimeFormatter.ISO_OFFSET_DATE_TIME, OffsetDateTime::from);
         addTemporalStringConverters(conversionService, ZonedDateTime.class, DateTimeFormatter.ISO_ZONED_DATE_TIME, ZonedDateTime::from);
 
+        addTemporalStringConverters(conversionService, YearMonth.class, ISO_YEAR_MONTH, YearMonth::from);
+        addTemporalStringConverters(conversionService, Year.class, ISO_YEAR, Year::from);
+        addTemporalIntegerConverters(conversionService, Year.class, ISO_YEAR, Year::from);
+        addTemporalStringConverters(conversionService, MonthDay.class, ISO_MONTH_DAY, MonthDay::from);
+        addTemporalStringConverters(conversionService, LocalTime.class, DateTimeFormatter.ISO_LOCAL_TIME, LocalTime::from);
+
+        conversionService.addConverter(CharSequence.class, ZoneId.class, (object, targetType, context) -> {
+            if (StringUtils.isEmpty(object)) {
+                return Optional.empty();
+            }
+            try {
+                ZoneId result = ZoneId.of(object.toString());
+                return Optional.of(result);
+            } catch (DateTimeParseException e) {
+                context.reject(object, e);
+                return Optional.empty();
+            }
+        });
+        conversionService.addConverter(ZoneId.class, CharSequence.class, (object, targetType, context) -> {
+            if (Objects.isNull(object)) {
+                return Optional.empty();
+            }
+            return Optional.of(object.toString());
+        });
+
         // java.time -> Date
         addTemporalToDateConverter(conversionService, Instant.class, Function.identity());
         addTemporalToDateConverter(conversionService, OffsetDateTime.class, OffsetDateTime::toInstant);
@@ -202,14 +235,14 @@ public class TimeConverterRegistrar implements TypeConverterRegistrar {
                     return Optional.of(converted);
                 } catch (DateTimeParseException ignored) {
                 }
-                // fall back to RFC 1123 date time for compatibility
-                try {
-                    T result = DateTimeFormatter.RFC_1123_DATE_TIME.parse(object, query);
-                    return Optional.of(result);
-                } catch (DateTimeParseException e) {
-                    context.reject(object, e);
-                    return Optional.empty();
-                }
+            }
+            // fall back to RFC 1123 date time for compatibility
+            try {
+                T result = DateTimeFormatter.RFC_1123_DATE_TIME.parse(object, query);
+                return Optional.of(result);
+            } catch (DateTimeParseException e) {
+                context.reject(object, e);
+                return Optional.empty();
             }
         });
 
@@ -234,23 +267,158 @@ public class TimeConverterRegistrar implements TypeConverterRegistrar {
                     return Optional.of(converted);
                 } catch (DateTimeException ignored) {
                 }
-                // fall back to RFC 1123 date time for compatibility
+            }
+            // fall back to RFC 1123 date time for compatibility
+            try {
+                CharSequence converted = DateTimeFormatter.RFC_1123_DATE_TIME.format(object);
+                return Optional.of(converted);
+            } catch (DateTimeException e) {
+                context.reject(object, e);
+                return Optional.empty();
+            }
+        });
+    }
+
+    private <T extends TemporalAccessor> void addTemporalIntegerConverters(MutableConversionService conversionService, Class<T> temporalType, DateTimeFormatter isoFormatter, TemporalQuery<T> query) {
+        conversionService.addConverter(Integer.class, temporalType, (Integer object, Class<T> targetType, ConversionContext context) -> {
+            if (Objects.isNull(object)) {
+                return Optional.empty();
+            }
+            // try explicit format first
+            Optional<String> format = context.getAnnotationMetadata().stringValue(Format.class);
+            if (format.isPresent()) {
+                DateTimeFormatter formatter = getFormatter(format.get(), context);
                 try {
-                    CharSequence converted = DateTimeFormatter.RFC_1123_DATE_TIME.format(object);
+                    T converted = formatter.parse(object.toString(), query);
                     return Optional.of(converted);
-                } catch (DateTimeException e) {
+                } catch (DateTimeParseException e) {
                     context.reject(object, e);
                     return Optional.empty();
                 }
+            } else {
+                try {
+                    T converted = isoFormatter.parse(object.toString(), query);
+                    return Optional.of(converted);
+                } catch (DateTimeParseException ignored) {
+                }
+            }
+            // fall back to RFC 1123 date time for compatibility
+            try {
+                T result = DateTimeFormatter.RFC_1123_DATE_TIME.parse(object.toString(), query);
+                return Optional.of(result);
+            } catch (DateTimeParseException e) {
+                context.reject(object, e);
+                return Optional.empty();
             }
         });
     }
 
+    private BiFunction<CharSequence, ConversionContext, Optional<Duration>> durationConverter() {
+        return (object, context) -> {
+            String value = object.toString().trim();
+            if (value.startsWith("P")) {
+                try {
+                    return Optional.of(Duration.parse(value));
+                } catch (DateTimeParseException e) {
+                    context.reject(value, e);
+                    return Optional.empty();
+                }
+            } else {
+                Matcher matcher = DURATION_MATCHER.matcher(value);
+                if (matcher.find()) {
+                    String amount = matcher.group(1);
+                    final String g2 = matcher.group(2);
+                    char type = g2.charAt(0);
+                    try {
+                        switch (type) {
+                            case 's' -> {
+                                return Optional.of(Duration.ofSeconds(Integer.parseInt(amount)));
+                            }
+                            case 'm' -> {
+                                String ms = matcher.group(MILLIS);
+                                if (StringUtils.hasText(ms)) {
+                                    return Optional.of(Duration.ofMillis(Integer.parseInt(amount)));
+                                } else {
+                                    return Optional.of(Duration.ofMinutes(Integer.parseInt(amount)));
+                                }
+                            }
+                            case 'h' -> {
+                                return Optional.of(Duration.ofHours(Integer.parseInt(amount)));
+                            }
+                            case 'd' -> {
+                                return Optional.of(Duration.ofDays(Integer.parseInt(amount)));
+                            }
+                            default -> {
+                                final String seq = g2 + matcher.group(3);
+                                if (seq.equals("ns")) {
+                                    return Optional.of(Duration.ofNanos(Integer.parseInt(amount)));
+                                }
+                                context.reject(
+                                    value,
+                                    new DateTimeParseException("Unparseable date format (" + value + "). Should either be a ISO-8601 duration or a round number followed by the unit type", value, 0));
+                                return Optional.empty();
+                            }
+                        }
+                    } catch (NumberFormatException e) {
+                        context.reject(value, e);
+                    }
+                }
+            }
+            return Optional.empty();
+        };
+    }
+
+    private BiFunction<CharSequence, ConversionContext, Optional<Period>> periodConverter() {
+        return (object, context) -> {
+            String value = object.toString().trim();
+            if (value.startsWith("P")) {
+                try {
+                    return Optional.of(Period.parse(value));
+                } catch (DateTimeParseException e) {
+                    context.reject(value, e);
+                    return Optional.empty();
+                }
+            } else {
+                Matcher matcher = PERIOD_MATCHER.matcher(value);
+                if (matcher.find()) {
+                    String amount = matcher.group(1);
+                    final String g2 = matcher.group(2);
+                    char type = g2.charAt(0);
+                    try {
+                        switch (type) {
+                            case 'y' -> {
+                                return Optional.of(Period.ofYears(Integer.parseInt(amount)));
+                            }
+                            case 'm' -> {
+                                return Optional.of(Period.ofMonths(Integer.parseInt(amount)));
+                            }
+                            case 'w' -> {
+                                return Optional.of(Period.ofWeeks(Integer.parseInt(amount)));
+                            }
+                            case 'd' -> {
+                                return Optional.of(Period.ofDays(Integer.parseInt(amount)));
+                            }
+                            default -> {
+                                context.reject(
+                                    value,
+                                    new DateTimeParseException("Unparseable date format (" + value + "). Should either be a ISO-8601 duration or a round number followed by the unit type", value, 0));
+                                return Optional.empty();
+                            }
+                        }
+                    } catch (NumberFormatException e) {
+                        context.reject(value, e);
+                    }
+                }
+            }
+            return Optional.empty();
+        };
+    }
+
     private DateTimeFormatter getFormatter(String pattern, ConversionContext context) {
         var key = pattern + context.getLocale();
-        var cachedFormatter = formattersCache.get(key);
-        if (cachedFormatter != null) {
-            return cachedFormatter;
+        var cachedFormater = formattersCache.get(key);
+        if (cachedFormater != null) {
+            return cachedFormater;
         }
         var formatter = DateTimeFormatter.ofPattern(pattern, context.getLocale());
         formattersCache.put(key, formatter);
diff --git a/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java b/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java
index adcc7348b9..a2a1cfae55 100644
--- a/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java
+++ b/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java
@@ -52,7 +52,6 @@ import io.micronaut.inject.ast.ElementQuery;
 import io.micronaut.inject.ast.FieldElement;
 import io.micronaut.inject.ast.MethodElement;
 import io.micronaut.inject.ast.ParameterElement;
-import io.micronaut.inject.ast.PrimitiveElement;
 import io.micronaut.inject.ast.TypedElement;
 import io.micronaut.inject.configuration.ConfigurationMetadataBuilder;
 import io.micronaut.inject.processing.JavaModelUtils;
@@ -63,7 +62,6 @@ import io.micronaut.inject.writer.ClassWriterOutputVisitor;
 import io.micronaut.inject.writer.ExecutableMethodsDefinitionWriter;
 import io.micronaut.inject.writer.OriginatingElements;
 import io.micronaut.inject.writer.ProxyingBeanDefinitionVisitor;
-import io.micronaut.inject.writer.WriterUtils;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.Label;
@@ -213,8 +211,6 @@ public class AopProxyWriter extends AbstractClassFileWriter implements ProxyingB
     private boolean constructorRequiresReflection;
     private MethodElement declaredConstructor;
     private MethodElement newConstructor;
-    private String newConstructorSignature;
-    private List<Map.Entry<ParameterElement, Integer>> superConstructorParametersBinding;
     private ParameterElement qualifierParameter;
     private ParameterElement interceptorsListParameter;
     private VisitorContext visitorContext;
@@ -495,38 +491,15 @@ public class AopProxyWriter extends AbstractClassFileWriter implements ProxyingB
         this.interceptorsListParameter = ParameterElement.of(interceptorList, INTERCEPTORS_PARAMETER);
         ParameterElement interceptorRegistryParameter = ParameterElement.of(ClassElement.of(InterceptorRegistry.class), "$interceptorRegistry");
         ClassElement proxyClass = ClassElement.of(proxyType.getClassName());
-        superConstructorParametersBinding = new ArrayList<>();
+
         ParameterElement[] constructorParameters = constructor.getParameters();
         List<ParameterElement> newConstructorParameters = new ArrayList<>(constructorParameters.length + 5);
         newConstructorParameters.addAll(Arrays.asList(constructorParameters));
-        int superConstructorParameterIndex = 0;
-        for (ParameterElement newConstructorParameter : newConstructorParameters) {
-            superConstructorParametersBinding.add(Map.entry(newConstructorParameter, superConstructorParameterIndex++));
-        }
-
-        ParameterElement beanResolutionContext = ParameterElement.of(BeanResolutionContext.class, "$beanResolutionContext");
-        newConstructorParameters.add(beanResolutionContext);
-        ParameterElement beanContext = ParameterElement.of(BeanContext.class, "$beanContext");
-        newConstructorParameters.add(beanContext);
+        newConstructorParameters.add(ParameterElement.of(BeanResolutionContext.class, "$beanResolutionContext"));
+        newConstructorParameters.add(ParameterElement.of(BeanContext.class, "$beanContext"));
         newConstructorParameters.add(qualifierParameter);
         newConstructorParameters.add(interceptorsListParameter);
         newConstructorParameters.add(interceptorRegistryParameter);
-        superConstructorParameterIndex += 5; // Skip internal parameters
-        if (WriterUtils.hasKotlinDefaultsParameters(List.of(constructorParameters))) {
-            List<ParameterElement> realNewConstructorParameters = new ArrayList<>(newConstructorParameters);
-            int count = WriterUtils.calculateNumberOfKotlinDefaultsMasks(List.of(constructorParameters));
-            for (int j = 0; j < count; j++) {
-                ParameterElement mask = ParameterElement.of(PrimitiveElement.INT, "mask" + j);
-                realNewConstructorParameters.add(mask);
-                superConstructorParametersBinding.add(Map.entry(mask, superConstructorParameterIndex++));
-            }
-            ParameterElement marker = ParameterElement.of(ClassElement.of("kotlin.jvm.internal.DefaultConstructorMarker"), "marker");
-            realNewConstructorParameters.add(marker);
-            superConstructorParametersBinding.add(Map.entry(marker, superConstructorParameterIndex));
-            this.newConstructorSignature = getConstructorDescriptor(realNewConstructorParameters);
-        } else {
-            this.newConstructorSignature = getConstructorDescriptor(newConstructorParameters);
-        }
         this.newConstructor = MethodElement.of(
                 proxyClass,
                 constructor.getAnnotationMetadata(),
@@ -535,11 +508,11 @@ public class AopProxyWriter extends AbstractClassFileWriter implements ProxyingB
                 "<init>",
                 newConstructorParameters.toArray(ZERO_PARAMETER_ELEMENTS)
         );
-        this.beanResolutionContextArgumentIndex = newConstructorParameters.indexOf(beanResolutionContext);
-        this.beanContextArgumentIndex = newConstructorParameters.indexOf(beanContext);
-        this.qualifierIndex = newConstructorParameters.indexOf(qualifierParameter);
-        this.interceptorsListArgumentIndex = newConstructorParameters.indexOf(interceptorsListParameter);
-        this.interceptorRegistryArgumentIndex = newConstructorParameters.indexOf(interceptorRegistryParameter);
+        this.beanResolutionContextArgumentIndex = constructorParameters.length;
+        this.beanContextArgumentIndex = constructorParameters.length + 1;
+        this.qualifierIndex = constructorParameters.length + 2;
+        this.interceptorsListArgumentIndex = constructorParameters.length + 3;
+        this.interceptorRegistryArgumentIndex = constructorParameters.length + 4;
     }
 
     @NonNull
@@ -772,30 +745,28 @@ public class AopProxyWriter extends AbstractClassFileWriter implements ProxyingB
         });
         qualifierParameter.annotate(AnnotationUtil.NULLABLE);
 
+        String constructorDescriptor = getConstructorDescriptor(Arrays.asList(newConstructor.getParameters()));
         ClassWriter proxyClassWriter = this.classWriter;
         this.constructorWriter = proxyClassWriter.visitMethod(
                 ACC_PUBLIC,
                 CONSTRUCTOR_NAME,
-                newConstructorSignature,
+                constructorDescriptor,
                 null,
                 null);
 
-        this.constructorGenerator = new GeneratorAdapter(constructorWriter, ACC_PUBLIC, CONSTRUCTOR_NAME, newConstructorSignature);
+        this.constructorGenerator = new GeneratorAdapter(constructorWriter, ACC_PUBLIC, CONSTRUCTOR_NAME, constructorDescriptor);
         GeneratorAdapter proxyConstructorGenerator = this.constructorGenerator;
 
         proxyConstructorGenerator.loadThis();
         if (isInterface) {
             proxyConstructorGenerator.invokeConstructor(TYPE_OBJECT, METHOD_DEFAULT_CONSTRUCTOR);
         } else {
-            List<ParameterElement> arguments = new ArrayList<>();
-            for (Map.Entry<ParameterElement, Integer> e : superConstructorParametersBinding) {
-                proxyConstructorGenerator.loadArg(e.getValue());
-                arguments.add(e.getKey());
+            ParameterElement[] existingArguments = declaredConstructor.getParameters();
+            for (int i = 0; i < existingArguments.length; i++) {
+                proxyConstructorGenerator.loadArg(i);
             }
-            proxyConstructorGenerator.invokeConstructor(
-                getTypeReferenceForName(targetClassFullName),
-                new Method(CONSTRUCTOR_NAME, getConstructorDescriptor(arguments))
-            );
+            String superConstructorDescriptor = getConstructorDescriptor(Arrays.asList(existingArguments));
+            proxyConstructorGenerator.invokeConstructor(getTypeReferenceForName(targetClassFullName), new Method(CONSTRUCTOR_NAME, superConstructorDescriptor));
         }
 
         proxyBeanDefinitionWriter.visitBeanDefinitionConstructor(
diff --git a/core-processor/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataWriter.java b/core-processor/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataWriter.java
index 1b985c2363..5db7acb98e 100644
--- a/core-processor/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataWriter.java
@@ -591,15 +591,11 @@ public class AnnotationMetadataWriter extends AbstractClassFileWriter {
                 invokeLoadClassValueMethod(declaringType, declaringClassWriter, methodVisitor, loadTypeMethods, acv);
             }
         } else if (value instanceof Enum<?> enumObject) {
-            methodVisitor.push(enumObject.name()); // Always store enum values as string
+            Class<?> declaringClass = enumObject.getDeclaringClass();
+            Type t = Type.getType(declaringClass);
+            methodVisitor.getStatic(t, enumObject.name(), t);
         } else if (value.getClass().isArray()) {
-            Class<?> jt;
-            Class<?> arrayComponentType = value.getClass().getComponentType();
-            if (arrayComponentType.isEnum() || arrayComponentType.equals(java.lang.Enum.class)) {
-                jt = String.class; // Always store enum values as string
-            } else {
-                jt = ReflectionUtils.getPrimitiveType(arrayComponentType);
-            }
+            Class<?> jt = ReflectionUtils.getPrimitiveType(value.getClass().getComponentType());
             final Type componentType = Type.getType(jt);
             int len = Array.getLength(value);
             if (Object.class == jt && len == 0) {
diff --git a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java
index 44407f9be0..2e5f2d77b9 100644
--- a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java
+++ b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java
@@ -33,7 +33,6 @@ import io.micronaut.inject.ast.ElementQuery;
 import io.micronaut.inject.ast.MethodElement;
 import io.micronaut.inject.ast.PropertyElement;
 import io.micronaut.inject.ast.PropertyElementQuery;
-import io.micronaut.inject.visitor.ElementPostponedToNextRoundException;
 import io.micronaut.inject.visitor.TypeElementVisitor;
 import io.micronaut.inject.visitor.VisitorContext;
 import io.micronaut.inject.writer.ClassGenerationException;
@@ -257,16 +256,13 @@ public class IntrospectedTypeElementVisitor implements TypeElementVisitor<Object
     public void finish(VisitorContext visitorContext) {
         try {
             if (!writers.isEmpty()) {
-                writers.forEach((className, writer) -> {
+                for (BeanIntrospectionWriter writer : writers.values()) {
                     try {
                         writer.accept(visitorContext);
-                    } catch (ElementPostponedToNextRoundException ignore) {
-                        // Ignore, next round will redo
                     } catch (IOException e) {
                         throw new ClassGenerationException("I/O error occurred during class generation: " + e.getMessage(), e);
                     }
-                });
-
+                }
             }
         } finally {
             writers.clear();
diff --git a/core-processor/src/main/java/io/micronaut/inject/visitor/ElementPostponedToNextRoundException.java b/core-processor/src/main/java/io/micronaut/inject/visitor/ElementPostponedToNextRoundException.java
deleted file mode 100644
index 74daed3dde..0000000000
--- a/core-processor/src/main/java/io/micronaut/inject/visitor/ElementPostponedToNextRoundException.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2017-2020 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.inject.visitor;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.inject.ast.Element;
-
-/**
- * Exception is thrown when the visitor is attempted to create a new file but the originated element is postponed to the next round.
- *
- * @author Denis Stepanov
- * @since 4.7
- */
-@Internal
-public final class ElementPostponedToNextRoundException extends RuntimeException {
-
-    private final Element originatingElement;
-
-    /**
-     * @param originatingElement The originating element
-     */
-    public ElementPostponedToNextRoundException(@NonNull Element originatingElement) {
-        super("Original element: " + originatingElement.getName() + " is postponed to the next round!");
-        this.originatingElement = originatingElement;
-    }
-
-    @NonNull
-    public Element getOriginatingElement() {
-        return originatingElement;
-    }
-
-}
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java b/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java
index ddc8e2c441..6fc23165e4 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java
@@ -3674,7 +3674,8 @@ public class BeanDefinitionWriter extends AbstractClassFileWriter implements Bea
                 final int parametersIndex = createConstructorParameterArray(parameters, buildMethodVisitor);
                 invokeConstructorChain(buildMethodVisitor, constructorIndex, parametersIndex, parameters);
             } else {
-                if (WriterUtils.hasKotlinDefaultsParameters(parameters)) {
+                boolean isKotlin = constructor.getClass().getSimpleName().startsWith("Kotlin");
+                if (isKotlin) {
                     Map<Integer, Integer> checksLocals = new HashMap<>();
                     Map<Integer, Integer> valuesLocals = new HashMap<>();
                     WriterUtils.invokeBeanConstructor(buildMethodVisitor, constructor, requiresReflection, true, (index, parameter) -> {
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java b/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java
index 865bcdbae7..1348f35b38 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java
@@ -55,26 +55,6 @@ import static org.objectweb.asm.commons.GeneratorAdapter.EQ;
 public final class WriterUtils {
     private static final String METHOD_NAME_INSTANTIATE = "instantiate";
 
-    /**
-     * The number of Kotlin defaults masks.
-     * @param parameters The parameters
-     * @return The number if masks
-     * @since 4.6.2
-     */
-    public static int calculateNumberOfKotlinDefaultsMasks(List<ParameterElement> parameters) {
-        return  (int) Math.ceil(parameters.size() / 32.0);
-    }
-
-    /**
-     * Checks if parameter include Kotlin defaults.
-     * @param arguments The arguments
-     * @return true if include
-     * @since 4.6.2
-     */
-    public static boolean hasKotlinDefaultsParameters(List<ParameterElement> arguments) {
-        return arguments.stream().anyMatch(p -> p instanceof KotlinParameterElement kp && kp.hasDefault());
-    }
-
     public static void invokeBeanConstructor(GeneratorAdapter writer,
                                              MethodElement constructor,
                                              boolean allowKotlinDefaults,
@@ -100,7 +80,7 @@ public final class WriterUtils {
         Collection<Type> argumentTypes = constructorArguments.stream().map(pe ->
             JavaModelUtils.getTypeReference(pe.getType())
         ).toList();
-        boolean isKotlinDefault = allowKotlinDefaults && hasKotlinDefaultsParameters(constructorArguments);
+        boolean isKotlinDefault = allowKotlinDefaults && constructorArguments.stream().anyMatch(p -> p instanceof KotlinParameterElement kp && kp.hasDefault());
 
         int[] masksLocal = null;
         if (isKotlinDefault) {
@@ -267,7 +247,7 @@ public final class WriterUtils {
                                                   @Nullable
                                                   BiFunction<Integer, ParameterElement, Boolean> argumentValueIsPresentPusher,
                                                   List<ParameterElement> parameters) {
-        int numberOfMasks = calculateNumberOfKotlinDefaultsMasks(parameters);
+        int numberOfMasks = (int) Math.ceil(parameters.size() / 32.0);
         int[] masksLocal = new int[numberOfMasks];
         for (int i = 0; i < numberOfMasks; i++) {
             int maskLocal = writer.newLocal(Type.INT_TYPE);
diff --git a/core/src/main/java/io/micronaut/core/execution/DelayedExecutionFlow.java b/core/src/main/java/io/micronaut/core/execution/DelayedExecutionFlow.java
index f07927c745..44490372de 100644
--- a/core/src/main/java/io/micronaut/core/execution/DelayedExecutionFlow.java
+++ b/core/src/main/java/io/micronaut/core/execution/DelayedExecutionFlow.java
@@ -15,7 +15,6 @@
  */
 package io.micronaut.core.execution;
 
-import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 
 /**
@@ -42,20 +41,4 @@ public sealed interface DelayedExecutionFlow<T> extends ExecutionFlow<T> permits
      * @param exc The exception
      */
     void completeExceptionally(Throwable exc);
-
-    /**
-     * Complete this flow from the given flow.
-     *
-     * @param flow The input flow
-     * @since 4.7.0
-     */
-    default void completeFrom(@NonNull ExecutionFlow<T> flow) {
-        flow.onComplete((o, t) -> {
-            if (t != null) {
-                completeExceptionally(t);
-            } else {
-                complete(o);
-            }
-        });
-    }
 }
diff --git a/core/src/main/java/io/micronaut/core/io/IOUtils.java b/core/src/main/java/io/micronaut/core/io/IOUtils.java
index d4b889285c..0a7c13420d 100644
--- a/core/src/main/java/io/micronaut/core/io/IOUtils.java
+++ b/core/src/main/java/io/micronaut/core/io/IOUtils.java
@@ -40,13 +40,9 @@ import java.nio.file.Paths;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Enumeration;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
 import java.util.function.Consumer;
-import java.util.stream.Stream;
 
 /**
  * Utility methods for I/O operations.
@@ -102,6 +98,7 @@ public class IOUtils {
         try {
             Path myPath = resolvePath(uri, path, toClose, IOUtils::loadNestedJarUri);
             if (myPath != null) {
+                Path finalMyPath = myPath;
                 // use this method instead of Files#walk to eliminate the Stream overhead
                 Files.walkFileTree(myPath, Collections.emptySet(), 1, new FileVisitor<>() {
                     @Override
@@ -111,7 +108,7 @@ public class IOUtils {
 
                     @Override
                     public FileVisitResult visitFile(Path currentPath, BasicFileAttributes attrs) throws IOException {
-                        if (currentPath.equals(myPath) || Files.isHidden(currentPath) || currentPath.getFileName().startsWith(".")) {
+                        if (currentPath.equals(finalMyPath) || Files.isHidden(currentPath) || currentPath.getFileName().startsWith(".")) {
                             return FileVisitResult.CONTINUE;
                         }
                         consumer.accept(currentPath);
@@ -141,23 +138,6 @@ public class IOUtils {
         }
     }
 
-    /**
-     * Resolve the path in the URI.
-     *
-     * @param uri     The URI
-     * @param path    The path
-     * @param toClose to close hooks
-     * @return The path resolved
-     * @throws IOException
-     * @since 4.7
-     */
-    @Nullable
-    public static Path resolvePath(@NonNull URI uri,
-                                   @NonNull String path,
-                                   @NonNull List<Closeable> toClose) throws IOException {
-        return resolvePath(uri, path, toClose, IOUtils::loadNestedJarUri);
-    }
-
     @Nullable
     static Path resolvePath(@NonNull URI uri,
                             String path,
@@ -255,96 +235,4 @@ public class IOUtils {
         }
         return answer.toString();
     }
-
-    /**
-     * Find all the resources starting with the path.
-     *
-     * @param classLoader The classloader
-     * @param path        The path
-     * @return the resources as URIs
-     * @throws IOException The IO exception
-     * @since 4.7
-     */
-    public static List<URI> getResources(ClassLoader classLoader, final String path) throws IOException {
-        final Enumeration<URL> micronautResources = classLoader.getResources(path);
-        Set<URI> uniqueURIs = new LinkedHashSet<>();
-        while (micronautResources.hasMoreElements()) {
-            URL url = micronautResources.nextElement();
-            try {
-                uniqueURIs.add(url.toURI());
-            } catch (URISyntaxException e) {
-                throw new RuntimeException(e);
-            }
-        }
-
-        FileSystem jrtProvider = null;
-        if (uniqueURIs.isEmpty()) {
-            jrtProvider = getJrtProvider(classLoader);
-            if (jrtProvider != null) {
-                Path modulesPath = jrtProvider.getPath("modules");
-                try (Stream<Path> stream = Files.list(modulesPath)) {
-                    stream
-                        .filter(p -> !p.getFileName().toString().startsWith("jdk.")) // filter out JDK internal modules
-                        .filter(p -> !p.getFileName().toString().startsWith("java.")) // filter out JDK public modules
-                        .map(p -> p.resolve(path))
-                        .filter(Files::exists)
-                        .map(modulesPath::resolve)
-                        .map(Path::toUri)
-                        .forEach(uniqueURIs::add);
-                }
-
-                // uri will be jrt:/modules/<module>/META-INF/micronaut/<service>, so we can walk through its files as if it was a directory
-            }
-        }
-        List<URI> uris = new ArrayList<>(uniqueURIs.size());
-        for (URI uri : uniqueURIs) {
-            String scheme = uri.getScheme();
-            if ("file".equals(scheme)) {
-                uri = normalizeFilePath(path, uri);
-            }
-            // on GraalVM there are spurious extra resources that end with # and then a number
-            // we ignore this extra ones
-            if (!("resource".equals(scheme) && uri.toString().contains("#"))) {
-                uris.add(uri);
-            }
-        }
-        if (jrtProvider != null && jrtProvider.isOpen()) {
-            try {
-                jrtProvider.close();
-            } catch (Throwable ignore) {
-                // Ignore
-            }
-        }
-        return uris;
-    }
-
-    @Nullable
-    private static FileSystem getJrtProvider(ClassLoader classLoader) {
-        try {
-            URI uri = URI.create("jrt:/");
-            FileSystem fs = FileSystems.getFileSystem(uri);
-            if (fs.isOpen()) {
-                return fs;
-            }
-            fs = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);
-            if (fs.isOpen()) {
-                return fs;
-            }
-        } catch (Throwable e) {
-            // not available, probably running in Native Image.
-        }
-        return null;
-    }
-
-    private static URI normalizeFilePath(String path, URI uri) {
-        Path p = Paths.get(uri);
-        if (p.endsWith(path)) {
-            Path subpath = Paths.get(path);
-            for (int i = 0; i < subpath.getNameCount(); i++) {
-                p = p.getParent();
-            }
-            uri = p.toUri();
-        }
-        return uri;
-    }
 }
diff --git a/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayBufferFactory.java b/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayBufferFactory.java
deleted file mode 100644
index a3072a790f..0000000000
--- a/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayBufferFactory.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.core.io.buffer;
-
-import io.micronaut.core.annotation.Internal;
-
-/**
- * {@link ByteBufferFactory} implementation based on simple byte arrays.
- *
- * @author Jonas Konrad
- * @since 4.7
- */
-@Internal
-public class ByteArrayBufferFactory implements ByteBufferFactory<Void, byte[]> {
-    public static final ByteArrayBufferFactory INSTANCE = new ByteArrayBufferFactory();
-
-    private ByteArrayBufferFactory() {
-    }
-
-    @Override
-    public Void getNativeAllocator() {
-        throw new UnsupportedOperationException("No native allocator");
-    }
-
-    @Override
-    public ByteArrayByteBuffer buffer() {
-        return buffer(0);
-    }
-
-    @Override
-    public ByteArrayByteBuffer buffer(int initialCapacity) {
-        return new ByteArrayByteBuffer(new byte[initialCapacity]);
-    }
-
-    @Override
-    public ByteArrayByteBuffer buffer(int initialCapacity, int maxCapacity) {
-        return buffer(initialCapacity);
-    }
-
-    @Override
-    public ByteArrayByteBuffer copiedBuffer(byte[] bytes) {
-        return wrap(bytes.clone());
-    }
-
-    @Override
-    public ByteArrayByteBuffer copiedBuffer(java.nio.ByteBuffer nioBuffer) {
-        int pos = nioBuffer.position();
-        int lim = nioBuffer.limit();
-        byte[] arr = new byte[lim - pos];
-        nioBuffer.get(pos, arr, 0, arr.length);
-        return wrap(arr);
-    }
-
-    @Override
-    public ByteArrayByteBuffer wrap(byte[] existing) {
-        return new ByteArrayByteBuffer(existing);
-    }
-}
diff --git a/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayByteBuffer.java b/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayByteBuffer.java
deleted file mode 100644
index c2350c3a84..0000000000
--- a/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayByteBuffer.java
+++ /dev/null
@@ -1,236 +0,0 @@
-/*
- * Copyright 2017-2023 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.core.io.buffer;
-
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.Internal;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.nio.charset.Charset;
-import java.util.Arrays;
-
-/**
- * A {@link ByteBuffer} implementation that is backed by a byte array.
- *
- * @since 4.7
- */
-@Internal
-@Experimental
-public final class ByteArrayByteBuffer implements ByteBuffer<byte[]> {
-
-    private final byte[] underlyingBytes;
-    private int readerIndex;
-    private int writerIndex;
-
-    /**
-     * Construct a new {@link ByteArrayByteBuffer} for the given bytes.
-     *
-     * @param underlyingBytes the bytes to wrap
-     */
-    ByteArrayByteBuffer(byte[] underlyingBytes) {
-        this(underlyingBytes, underlyingBytes.length);
-    }
-
-    /**
-     * Construct a new {@link ByteArrayByteBuffer} for the given bytes and capacity.
-     * If capacity is greater than the length of the underlyingBytes, extra bytes will be zeroed out.
-     * If capacity is less than the length of the underlyingBytes, the underlyingBytes will be truncated.
-     *
-     * @param underlyingBytes the bytes to wrap
-     * @param capacity        the capacity of the buffer
-     */
-    ByteArrayByteBuffer(byte[] underlyingBytes, int capacity) {
-        if (capacity < underlyingBytes.length) {
-            this.underlyingBytes = Arrays.copyOf(underlyingBytes, capacity);
-        } else if (capacity > underlyingBytes.length) {
-            this.underlyingBytes = new byte[capacity];
-            System.arraycopy(underlyingBytes, 0, this.underlyingBytes, 0, underlyingBytes.length);
-        } else {
-            this.underlyingBytes = underlyingBytes;
-        }
-    }
-
-    @Override
-    public byte[] asNativeBuffer() {
-        return underlyingBytes;
-    }
-
-    @Override
-    public int readableBytes() {
-        return underlyingBytes.length - readerIndex;
-    }
-
-    @Override
-    public int writableBytes() {
-        return underlyingBytes.length - writerIndex;
-    }
-
-    @Override
-    public int maxCapacity() {
-        return underlyingBytes.length;
-    }
-
-    @Override
-    public ByteArrayByteBuffer capacity(int capacity) {
-        return new ByteArrayByteBuffer(underlyingBytes, capacity);
-    }
-
-    @Override
-    public int readerIndex() {
-        return readerIndex;
-    }
-
-    @Override
-    public ByteArrayByteBuffer readerIndex(int readPosition) {
-        this.readerIndex = Math.min(readPosition, underlyingBytes.length);
-        return this;
-    }
-
-    @Override
-    public int writerIndex() {
-        return writerIndex;
-    }
-
-    @Override
-    public ByteArrayByteBuffer writerIndex(int position) {
-        this.writerIndex = Math.min(position, underlyingBytes.length);
-        return this;
-    }
-
-    @Override
-    public byte read() {
-        return underlyingBytes[readerIndex++];
-    }
-
-    @Override
-    public CharSequence readCharSequence(int length, Charset charset) {
-        String s = new String(underlyingBytes, readerIndex, length, charset);
-        readerIndex += length;
-        return s;
-    }
-
-    @Override
-    public ByteArrayByteBuffer read(byte[] destination) {
-        int count = Math.min(readableBytes(), destination.length);
-        System.arraycopy(underlyingBytes, readerIndex, destination, 0, count);
-        readerIndex += count;
-        return this;
-    }
-
-    @Override
-    public ByteArrayByteBuffer read(byte[] destination, int offset, int length) {
-        int count = Math.min(readableBytes(), Math.min(destination.length - offset, length));
-        System.arraycopy(underlyingBytes, readerIndex, destination, offset, count);
-        readerIndex += count;
-        return this;
-    }
-
-    @Override
-    public ByteArrayByteBuffer write(byte b) {
-        underlyingBytes[writerIndex++] = b;
-        return this;
-    }
-
-    @Override
-    public ByteArrayByteBuffer write(byte[] source) {
-        int count = Math.min(writableBytes(), source.length);
-        System.arraycopy(source, 0, underlyingBytes, writerIndex, count);
-        writerIndex += count;
-        return this;
-    }
-
-    @Override
-    public ByteArrayByteBuffer write(CharSequence source, Charset charset) {
-        write(source.toString().getBytes(charset));
-        return this;
-    }
-
-    @Override
-    public ByteArrayByteBuffer write(byte[] source, int offset, int length) {
-        int count = Math.min(writableBytes(), length);
-        System.arraycopy(source, offset, underlyingBytes, writerIndex, count);
-        writerIndex += count;
-        return this;
-    }
-
-    @Override
-    public ByteArrayByteBuffer write(ByteBuffer... buffers) {
-        for (ByteBuffer<?> buffer : buffers) {
-            write(buffer.toByteArray());
-        }
-        return this;
-    }
-
-    @Override
-    public ByteArrayByteBuffer write(java.nio.ByteBuffer... buffers) {
-        for (java.nio.ByteBuffer buffer : buffers) {
-            write(buffer.array());
-        }
-        return this;
-    }
-
-    @Override
-    public ByteArrayByteBuffer slice(int index, int length) {
-        return new ByteArrayByteBuffer(Arrays.copyOfRange(underlyingBytes, index, index + length), length);
-    }
-
-    @Override
-    public java.nio.ByteBuffer asNioBuffer() {
-        return java.nio.ByteBuffer.wrap(underlyingBytes, readerIndex, readableBytes());
-    }
-
-    @Override
-    public java.nio.ByteBuffer asNioBuffer(int index, int length) {
-        return java.nio.ByteBuffer.wrap(underlyingBytes, index, length);
-    }
-
-    @Override
-    public InputStream toInputStream() {
-        return new ByteArrayInputStream(underlyingBytes, readerIndex, readableBytes());
-    }
-
-    @Override
-    public OutputStream toOutputStream() {
-        throw new IllegalStateException("Not implemented");
-    }
-
-    @Override
-    public byte[] toByteArray() {
-        return Arrays.copyOfRange(underlyingBytes, readerIndex, readableBytes());
-    }
-
-    @Override
-    public String toString(Charset charset) {
-        return new String(underlyingBytes, readerIndex, readableBytes(), charset);
-    }
-
-    @Override
-    public int indexOf(byte b) {
-        for (int i = readerIndex; i < underlyingBytes.length; i++) {
-            if (underlyingBytes[i] == b) {
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    @Override
-    public byte getByte(int index) {
-        return underlyingBytes[index];
-    }
-}
diff --git a/core/src/main/java/io/micronaut/core/io/service/MicronautMetaServiceLoaderUtils.java b/core/src/main/java/io/micronaut/core/io/service/MicronautMetaServiceLoaderUtils.java
deleted file mode 100644
index 7c870a78fd..0000000000
--- a/core/src/main/java/io/micronaut/core/io/service/MicronautMetaServiceLoaderUtils.java
+++ /dev/null
@@ -1,337 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.core.io.service;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.io.IOUtils;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.lang.invoke.MethodHandles;
-import java.lang.invoke.MethodType;
-import java.net.URI;
-import java.nio.file.FileVisitResult;
-import java.nio.file.FileVisitor;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.attribute.BasicFileAttributes;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.ServiceConfigurationError;
-import java.util.Set;
-import java.util.concurrent.ForkJoinPool;
-import java.util.concurrent.RecursiveAction;
-import java.util.function.Predicate;
-
-/**
- * The loader of Micronaut services under META-INF/micronaut/.
- *
- * @author Denis Stepanov
- * @since 4.7
- */
-@Internal
-public final class MicronautMetaServiceLoaderUtils {
-
-    private static final String MICRONAUT_SERVICES_PATH = "META-INF/micronaut/";
-
-    private static final MethodHandles.Lookup LOOKUP = MethodHandles.publicLookup();
-    private static final MethodType VOID_TYPE = MethodType.methodType(void.class);
-
-    private static volatile CacheEntry cacheEntry;
-
-    /**
-     * Find all instantiated Micronaut service entries.
-     *
-     * @param classLoader  The classloader
-     * @param serviceClass The service class
-     * @param predicate    The predicate
-     * @param <S>          The service type
-     * @return the result
-     */
-    @NonNull
-    public static <S> List<S> findMetaMicronautServiceEntries(@NonNull ClassLoader classLoader,
-                                                              @NonNull Class<S> serviceClass,
-                                                              @Nullable Predicate<S> predicate) {
-        SoftServiceLoader.StaticServiceLoader<S> staticServiceLoader = (SoftServiceLoader.StaticServiceLoader<S>) SoftServiceLoader.STATIC_SERVICES.get(serviceClass.getName());
-        if (staticServiceLoader != null) {
-            return staticServiceLoader.load(predicate);
-        }
-        return new MicronautServiceCollector<>(classLoader, serviceClass.getName(), predicate)
-            .collect(true);
-    }
-
-    /**
-     * Find Micronaut service entries.
-     *
-     * @param classLoader The classloader
-     * @param serviceName The service name
-     * @return The entries
-     * @throws IOException
-     */
-    @NonNull
-    public static Set<String> findMicronautMetaServiceEntries(@NonNull ClassLoader classLoader,
-                                                              @NonNull String serviceName) throws IOException {
-        CacheEntry ce = cacheEntry;
-        if (ce == null || ce.classLoader != classLoader) {
-            ce = new CacheEntry(classLoader, findAllMicronautMetaServices(classLoader));
-            cacheEntry = ce;
-        }
-        return ce.services.getOrDefault(serviceName, Set.of());
-    }
-
-    /**
-     * Find all Micronaut services.
-     *
-     * @param classLoader The classloader
-     * @return the all entries
-     * @throws IOException
-     */
-    @NonNull
-    public static Map<String, Set<String>> findAllMicronautMetaServices(@NonNull ClassLoader classLoader) throws IOException {
-        final ServiceScanner.StaticServiceDefinitions ssd = ServiceScanner.findStaticServiceDefinitions();
-        if (ssd != null) {
-            return ssd.serviceTypeMap();
-        }
-        List<URI> resourceDefs = IOUtils.getResources(classLoader, MICRONAUT_SERVICES_PATH);
-        if (resourceDefs.isEmpty()) {
-            return Map.of();
-        }
-
-        Map<String, Set<String>> services = new LinkedHashMap<>();
-
-        FileVisitor<Path> visitor = new FileVisitor<>() {
-
-            private Set<String> definitions;
-
-            @Override
-            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
-                if (dir.endsWith(MICRONAUT_SERVICES_PATH)) {
-                    return FileVisitResult.CONTINUE;
-                }
-                String serviceName = dir.getFileName().toString();
-                definitions = services.get(serviceName);
-                if (definitions == null) {
-                    definitions = new LinkedHashSet<>();
-                    services.put(serviceName, definitions);
-                }
-                return FileVisitResult.CONTINUE;
-            }
-
-            @Override
-            public FileVisitResult visitFile(Path currentPath, BasicFileAttributes attrs) throws IOException {
-                if (Files.isHidden(currentPath)) {
-                    return FileVisitResult.CONTINUE;
-                }
-                Path fileName = currentPath.getFileName();
-                if (fileName.startsWith(".")) {
-                    return FileVisitResult.CONTINUE;
-                }
-                definitions.add(fileName.toString());
-                return FileVisitResult.SKIP_SUBTREE;
-            }
-
-            @Override
-            public FileVisitResult visitFileFailed(Path file, IOException exc) {
-                return FileVisitResult.CONTINUE;
-            }
-
-            @Override
-            public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
-                return FileVisitResult.CONTINUE;
-            }
-        };
-
-        List<Closeable> toClose = new ArrayList<>();
-        try {
-            for (URI uri : resourceDefs) {
-                Path myPath = IOUtils.resolvePath(uri, MICRONAUT_SERVICES_PATH, toClose);
-                if (myPath != null) {
-                    Files.walkFileTree(myPath, Collections.emptySet(), 2, visitor);
-                }
-            }
-        } catch (IOException e) {
-            // ignore, can't do anything here and can't log because class used in compiler
-        } finally {
-            for (Closeable closeable : toClose) {
-                try {
-                    closeable.close();
-                } catch (IOException ignored) {
-                }
-            }
-        }
-        return services;
-    }
-
-    private static <S> S instantiate(String className, ClassLoader classLoader) {
-        try {
-            @SuppressWarnings("unchecked") final Class<S> loadedClass =
-                (Class<S>) Class.forName(className, false, classLoader);
-            // MethodHandler should more performant than the basic reflection
-            return (S) LOOKUP.findConstructor(loadedClass, VOID_TYPE).invoke();
-        } catch (NoClassDefFoundError | ClassNotFoundException | NoSuchMethodException |
-                 IllegalAccessException e) {
-            // Ignore
-            return null;
-        } catch (Throwable e) {
-            return sneakyThrow(e);
-        }
-    }
-
-    private static <T extends Throwable, R> R sneakyThrow(Throwable t) throws T {
-        throw (T) t;
-    }
-
-    /**
-     * Fork-join recursive services loader.
-     *
-     * @param <S> The service type
-     */
-    @SuppressWarnings("java:S1948")
-    private static final class MicronautServiceCollector<S> extends RecursiveActionValuesCollector<S> {
-
-        private final ClassLoader classLoader;
-        private final String serviceName;
-        private final Predicate<S> predicate;
-        private final List<RecursiveActionValuesCollector<S>> tasks = new ArrayList<>();
-        private int size;
-
-        MicronautServiceCollector(ClassLoader classLoader, String serviceName, Predicate<S> predicate) {
-            this.classLoader = classLoader;
-            this.serviceName = serviceName;
-            this.predicate = predicate;
-        }
-
-        @Override
-        protected void compute() {
-            try {
-                Set<String> serviceEntries = MicronautMetaServiceLoaderUtils.findMicronautMetaServiceEntries(classLoader, serviceName);
-                size = serviceEntries.size();
-                for (String serviceEntry : serviceEntries) {
-                    final ServiceInstanceLoader<S> task = new ServiceInstanceLoader<>(classLoader, serviceEntry, predicate);
-                    tasks.add(task);
-                    task.fork();
-                }
-            } catch (IOException e) {
-                throw new ServiceConfigurationError("Failed to load resources for service: " + serviceName, e);
-            }
-        }
-
-        public List<S> collect(boolean allowFork) {
-            if (allowFork && ForkJoinPool.getCommonPoolParallelism() > 1) {
-                ForkJoinPool.commonPool().invoke(this);
-                List<S> collection = null;
-                for (RecursiveActionValuesCollector<S> task : tasks) {
-                    task.join();
-                    if (collection == null) {
-                        collection = new ArrayList<>(size);
-                    }
-                    task.collect(collection);
-                }
-                if (collection == null) {
-                    return List.of();
-                }
-                return collection;
-            }
-            try {
-                Set<String> serviceEntries = MicronautMetaServiceLoaderUtils.findMicronautMetaServiceEntries(classLoader, serviceName);
-                List<S> collection = new ArrayList<>(serviceEntries.size());
-                for (String serviceEntry : serviceEntries) {
-                    S val = instantiate(serviceEntry, classLoader);
-                    if (val != null && predicate.test(val)) {
-                        collection.add(val);
-                    }
-                }
-                return collection;
-            } catch (IOException e) {
-                throw new ServiceConfigurationError("Failed to load resources for service: " + serviceName, e);
-            }
-        }
-
-        @Override
-        public void collect(Collection<S> values) {
-            throw new IllegalStateException("Only constructor method is supported!");
-        }
-    }
-
-    /**
-     * Initializes and filters the entry.
-     *
-     * @param <S> The service type
-     */
-    private static final class ServiceInstanceLoader<S> extends RecursiveActionValuesCollector<S> {
-
-        private final ClassLoader classLoader;
-        private final String className;
-        private final Predicate<S> predicate;
-        private S result;
-        private Throwable throwable;
-
-        public ServiceInstanceLoader(ClassLoader classLoader, String className, Predicate<S> predicate) {
-            this.classLoader = classLoader;
-            this.className = className;
-            this.predicate = predicate;
-        }
-
-        @Override
-        protected void compute() {
-            try {
-                result = instantiate(className, classLoader);
-                if (result != null && predicate != null && !predicate.test(result)) {
-                    result = null;
-                }
-            } catch (Throwable e) {
-                throwable = e;
-            }
-        }
-
-        @Override
-        public void collect(Collection<S> values) {
-            if (throwable != null) {
-                throw new SoftServiceLoader.ServiceLoadingException("Failed to load a service: " + throwable.getMessage(), throwable);
-            }
-            if (result != null && !values.contains(result)) {
-                values.add(result);
-            }
-        }
-    }
-
-    /**
-     * Abstract recursive action class.
-     *
-     * @param <S> The type
-     */
-    private abstract static class RecursiveActionValuesCollector<S> extends RecursiveAction {
-
-        /**
-         * Collects loaded values.
-         *
-         * @param values The values
-         */
-        public abstract void collect(Collection<S> values);
-
-    }
-
-    private record CacheEntry(ClassLoader classLoader, Map<String, Set<String>> services) {
-    }
-
-}
diff --git a/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java b/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java
index 6a7f71a9c5..8f6a2ff98b 100644
--- a/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java
+++ b/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java
@@ -15,6 +15,8 @@
  */
 package io.micronaut.core.io.service;
 
+import static io.micronaut.core.util.StringUtils.EMPTY_STRING_ARRAY;
+
 import io.micronaut.core.annotation.AnnotationClassValue;
 import io.micronaut.core.annotation.AnnotationValue;
 import io.micronaut.core.annotation.BuildTimeInit;
@@ -22,27 +24,32 @@ import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.beans.BeanInfo;
 import io.micronaut.core.graal.GraalReflectionConfigurer;
+import io.micronaut.core.io.IOUtils;
 import io.micronaut.core.io.service.ServiceScanner.StaticServiceDefinitions;
 import io.micronaut.core.reflect.exception.InstantiationException;
 import io.micronaut.core.util.ArrayUtils;
-import org.graalvm.nativeimage.ImageSingletons;
-import org.graalvm.nativeimage.hosted.Feature;
-import org.graalvm.nativeimage.hosted.RuntimeClassInitialization;
-import org.graalvm.nativeimage.hosted.RuntimeReflection;
-
 import java.io.IOException;
-import java.io.UncheckedIOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Enumeration;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
-
-import static io.micronaut.core.util.StringUtils.EMPTY_STRING_ARRAY;
+import org.graalvm.nativeimage.ImageSingletons;
+import org.graalvm.nativeimage.hosted.Feature;
+import org.graalvm.nativeimage.hosted.RuntimeClassInitialization;
+import org.graalvm.nativeimage.hosted.RuntimeReflection;
 
 /**
  * Integrates {@link io.micronaut.core.io.service.SoftServiceLoader} with GraalVM Native Image.
@@ -188,13 +195,62 @@ class ServiceLoaderFeature implements Feature {
      */
     @NonNull
     protected StaticServiceDefinitions buildStaticServiceDefinitions(BeforeAnalysisAccess access) {
+        StaticServiceDefinitions staticServiceDefinitions = new StaticServiceDefinitions(null);
+        final String path = "META-INF/micronaut/";
         try {
-            return new StaticServiceDefinitions(
-                MicronautMetaServiceLoaderUtils.findAllMicronautMetaServices(getClass().getClassLoader())
-            );
-        } catch (IOException e) {
-            throw new UncheckedIOException(e);
+            final Enumeration<URL> micronautResources = access.getApplicationClassLoader().getResources(path);
+            while (micronautResources.hasMoreElements()) {
+                Set<String> servicePaths = new HashSet<>();
+                URL url = micronautResources.nextElement();
+                URI uri = url.toURI();
+                boolean isFileScheme = "file".equals(uri.getScheme());
+                if (isFileScheme) {
+                    Path p = Paths.get(uri);
+                    // strip the META-INF/micronaut part
+                    uri = p.getParent().getParent().toUri();
+                }
+                IOUtils.eachFile(
+                        uri,
+                        path,
+                        servicePath -> {
+                            if (Files.isDirectory(servicePath)) {
+                                String serviceName = servicePath.toString();
+                                if (isFileScheme) {
+                                    int i = serviceName.indexOf(path);
+                                    if (i > -1) {
+                                        serviceName = serviceName.substring(i);
+                                    }
+                                } else if (serviceName.startsWith("/")) {
+                                    serviceName = serviceName.substring(1);
+                                }
+                                if (serviceName.startsWith(path)) {
+                                    servicePaths.add(serviceName);
+                                }
+                            }
+                        }
+                );
+
+                for (String servicePath : servicePaths) {
+                    IOUtils.eachFile(
+                            uri,
+                            servicePath,
+                            serviceTypePath -> {
+                                if (Files.isRegularFile(serviceTypePath)) {
+                                    final Set<String> serviceTypeNames = staticServiceDefinitions.serviceTypeMap()
+                                            .computeIfAbsent(servicePath,
+                                                             key -> new HashSet<>());
+                                    final String serviceTypeName = serviceTypePath.getFileName().toString();
+                                    serviceTypeNames.add(serviceTypeName);
+                                }
+                            }
+                    );
+                }
+            }
+
+        } catch (IOException | URISyntaxException e) {
+            // ignore
         }
+        return staticServiceDefinitions;
     }
 
     private void configureForReflection(BeforeAnalysisAccess access) {
diff --git a/core/src/main/java/io/micronaut/core/io/service/ServiceScanner.java b/core/src/main/java/io/micronaut/core/io/service/ServiceScanner.java
index b74e29b199..93d5962800 100644
--- a/core/src/main/java/io/micronaut/core/io/service/ServiceScanner.java
+++ b/core/src/main/java/io/micronaut/core/io/service/ServiceScanner.java
@@ -17,24 +17,39 @@ package io.micronaut.core.io.service;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.io.IOUtils;
+import java.nio.file.FileSystemNotFoundException;
+import java.nio.file.ProviderNotFoundException;
+import java.util.stream.Stream;
 import org.graalvm.nativeimage.ImageSingletons;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.UncheckedIOException;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.net.URL;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.ServiceConfigurationError;
 import java.util.Set;
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.RecursiveAction;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
 
@@ -57,8 +72,49 @@ final class ServiceScanner<S> {
         this.transformer = transformer;
     }
 
+    private static URI normalizeFilePath(String path, URI uri) {
+        Path p = Paths.get(uri);
+        if (p.endsWith(path)) {
+            Path subpath = Paths.get(path);
+            for (int i = 0; i < subpath.getNameCount(); i++) {
+                p = p.getParent();
+            }
+            uri = p.toUri();
+        }
+        return uri;
+    }
+
+    /**
+     * Note: referenced by {@code io.micronaut.core.graal.ServiceLoaderInitialization}.
+     */
+    @SuppressWarnings("java:S3398")
+    private static Set<String> computeMicronautServiceTypeNames(URI uri, String path) {
+        final StaticServiceDefinitions ssd = findStaticServiceDefinitions();
+        if (ssd != null) {
+            return ssd.serviceTypeMap.getOrDefault(
+                path,
+                Collections.emptySet()
+            );
+        } else {
+            Set<String> typeNames = new HashSet<>();
+            // Keep the anonymous class instead of Lambda to reduce the Lambda invocation overhead during the startup
+            @SuppressWarnings({"Convert2Lambda", "java:S1604"}) Consumer<Path> consumer = new Consumer<>() {
+
+                @Override
+                public void accept(Path currentPath) {
+                    if (Files.isRegularFile(currentPath)) {
+                        final String typeName = currentPath.getFileName().toString();
+                        typeNames.add(typeName);
+                    }
+                }
+            };
+            IOUtils.eachFile(uri, path, consumer);
+            return typeNames;
+        }
+    }
+
     @Nullable
-    static StaticServiceDefinitions findStaticServiceDefinitions() {
+    private static StaticServiceDefinitions findStaticServiceDefinitions() {
         if (hasImageSingletons()) {
             return ImageSingletons.contains(StaticServiceDefinitions.class) ? ImageSingletons.lookup(StaticServiceDefinitions.class) : null;
         } else {
@@ -87,7 +143,7 @@ final class ServiceScanner<S> {
                     if (line == null) {
                         break;
                     }
-                    if (line.isEmpty() || line.charAt(0) == '#') {
+                    if (line.length() == 0 || line.charAt(0) == '#') {
                         continue;
                     }
                     if (!lineCondition.test(line)) {
@@ -106,10 +162,80 @@ final class ServiceScanner<S> {
         return typeNames;
     }
 
+    private boolean isWebSphereClassLoader() {
+        return classLoader.getClass().getName().startsWith("com.ibm.ws.classloader");
+    }
+
+    private String buildResourceSearchPath() {
+        String path = "META-INF/micronaut/" + serviceName;
+
+        if (isWebSphereClassLoader()) {
+            // Special case WebSphere classloader
+            // https://github.com/micronaut-projects/micronaut-core/issues/9905
+            return path + "/";
+        }
+
+        return path;
+    }
+
     private Enumeration<URL> findStandardServiceConfigs() throws IOException {
         return classLoader.getResources(SoftServiceLoader.META_INF_SERVICES + '/' + serviceName);
     }
 
+    private void findMicronautMetaServiceConfigs(BiConsumer<URI, String> consumer) throws IOException, URISyntaxException {
+        String path = buildResourceSearchPath();
+        final Enumeration<URL> micronautResources = classLoader.getResources(path);
+        Set<URI> uniqueURIs = new LinkedHashSet<>();
+        while (micronautResources.hasMoreElements()) {
+            URL url = micronautResources.nextElement();
+            final URI uri = url.toURI();
+            uniqueURIs.add(uri);
+        }
+
+        if (uniqueURIs.isEmpty()) {
+            FileSystem fs = null;
+            try {
+                fs = FileSystems.getFileSystem(URI.create("jrt:/"));
+            } catch (FileSystemNotFoundException | ProviderNotFoundException e) {
+                //no-op
+            }
+            if (fs == null || !fs.isOpen()) {
+                try {
+                    fs = FileSystems.newFileSystem(URI.create("jrt:/"), Collections.emptyMap(), classLoader);
+                } catch (IOException | ProviderNotFoundException e) {
+                    // not available, probably running in Native Image.
+                }
+            }
+            if (fs != null) {
+                Path modulesPath = fs.getPath("modules");
+                try (Stream<Path> stream = Files.list(modulesPath)) {
+                    stream
+                        .filter(p -> !p.getFileName().toString().startsWith("jdk.")) // filter out JDK internal modules
+                        .filter(p -> !p.getFileName().toString().startsWith("java.")) // filter out JDK public modules
+                        .map(p -> p.resolve(path))
+                        .filter(Files::exists)
+                        .map(modulesPath::resolve)
+                        .map(Path::toUri)
+                        .forEach(uniqueURIs::add);
+                }
+
+                // uri will be jrt:/modules/<module>/META-INF/micronaut/<service>, so we can walk through its files as if it was a directory
+            }
+        }
+
+        for (URI uri : uniqueURIs) {
+            String scheme = uri.getScheme();
+            if ("file".equals(scheme)) {
+                uri = normalizeFilePath(path, uri);
+            }
+            // on GraalVM there are spurious extra resources that end with # and then a number
+            // we ignore this extra ones
+            if (!("resource".equals(scheme) && uri.toString().contains("#"))) {
+                consumer.accept(uri, path);
+            }
+        }
+    }
+
     /**
      * Fork-join recursive services loader.
      */
@@ -128,13 +254,12 @@ final class ServiceScanner<S> {
                     tasks.add(task);
                     task.fork();
                 }
-                Set<String> serviceEntries = MicronautMetaServiceLoaderUtils.findMicronautMetaServiceEntries(classLoader, serviceName);
-                for (String serviceEntry : serviceEntries) {
-                    final ServiceInstanceLoader task = new ServiceInstanceLoader(serviceEntry);
+                findMicronautMetaServiceConfigs((uri, path) -> {
+                    final MicronautMetaServicesLoader task = new MicronautMetaServicesLoader(uri, path);
                     tasks.add(task);
                     task.fork();
-                }
-            } catch (IOException e) {
+                });
+            } catch (IOException | URISyntaxException e) {
                 throw new ServiceConfigurationError("Failed to load resources for service: " + serviceName, e);
             }
         }
@@ -168,20 +293,51 @@ final class ServiceScanner<S> {
                             }
                         }
                     }
-                    Set<String> serviceEntries = MicronautMetaServiceLoaderUtils.findMicronautMetaServiceEntries(classLoader, serviceName);
-                    for (String serviceEntry : serviceEntries) {
-                        S val = transformer.apply(serviceEntry);
-                        if (val != null) {
-                            values.add(val);
+                    findMicronautMetaServiceConfigs((uri, path) -> {
+                        for (String typeName : computeMicronautServiceTypeNames(uri, path)) {
+                            S val = transformer.apply(typeName);
+                            if (val != null) {
+                                values.add(val);
+                            }
                         }
-                    }
-                } catch (IOException e) {
+                    });
+                } catch (IOException | URISyntaxException e) {
                     throw new ServiceConfigurationError("Failed to load resources for service: " + serviceName, e);
                 }
             }
         }
     }
 
+    private final class MicronautMetaServicesLoader extends RecursiveActionValuesCollector<S> {
+        private final URI uri;
+        private final List<ServiceInstanceLoader> tasks = new ArrayList<>();
+        private final String path;
+
+        private MicronautMetaServicesLoader(URI uri, String path) {
+            this.uri = uri;
+            this.path = path;
+        }
+
+        @Override
+        public void collect(Collection<S> values) {
+            for (ServiceInstanceLoader task : tasks) {
+                task.join();
+                task.collect(values);
+            }
+        }
+
+        @Override
+        @SuppressWarnings("java:S2095")
+        protected void compute() {
+            Set<String> typeNames = computeMicronautServiceTypeNames(uri, path);
+            for (String typeName : typeNames) {
+                ServiceInstanceLoader task = new ServiceInstanceLoader(typeName);
+                tasks.add(task);
+                task.fork();
+            }
+        }
+    }
+
     /**
      * Reads URL, parses the file and produces sub-tasks to initialize the entry.
      */
diff --git a/core/src/main/java/io/micronaut/core/io/service/SoftServiceLoader.java b/core/src/main/java/io/micronaut/core/io/service/SoftServiceLoader.java
index 7d21beb11b..2a53038814 100644
--- a/core/src/main/java/io/micronaut/core/io/service/SoftServiceLoader.java
+++ b/core/src/main/java/io/micronaut/core/io/service/SoftServiceLoader.java
@@ -46,12 +46,14 @@ import java.util.stream.Stream;
  */
 public final class SoftServiceLoader<S> implements Iterable<ServiceDefinition<S>> {
     public static final String META_INF_SERVICES = "META-INF/services";
-    static final Map<String, SoftServiceLoader.StaticServiceLoader<?>> STATIC_SERVICES =
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.publicLookup();
+    private static final MethodType VOID_TYPE = MethodType.methodType(void.class);
+
+    private static final Map<String, SoftServiceLoader.StaticServiceLoader<?>> STATIC_SERVICES =
             StaticOptimizations.get(Optimizations.class)
                     .map(Optimizations::getServiceLoaders)
                     .orElse(Collections.emptyMap());
-    private static final MethodHandles.Lookup LOOKUP = MethodHandles.publicLookup();
-    private static final MethodType VOID_TYPE = MethodType.methodType(void.class);
+
     private final Class<S> serviceType;
     private final ClassLoader classLoader;
     private Collection<ServiceDefinition<S>> servicesForIterator;
diff --git a/core/src/main/java/io/micronaut/core/reflect/ClassUtils.java b/core/src/main/java/io/micronaut/core/reflect/ClassUtils.java
index ab6fc84b8e..61795f0454 100644
--- a/core/src/main/java/io/micronaut/core/reflect/ClassUtils.java
+++ b/core/src/main/java/io/micronaut/core/reflect/ClassUtils.java
@@ -33,6 +33,15 @@ import java.nio.charset.Charset;
 import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDate;
+import java.time.LocalTime;
+import java.time.MonthDay;
+import java.time.OffsetDateTime;
+import java.time.OffsetTime;
+import java.time.Period;
+import java.time.Year;
+import java.time.YearMonth;
+import java.time.ZoneId;
+import java.time.ZoneOffset;
 import java.time.ZonedDateTime;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -149,6 +158,15 @@ public class ClassUtils {
         BASIC_TYPE_MAP.put(LocalDate.class.getName(), LocalDate.class);
         BASIC_TYPE_MAP.put(Instant.class.getName(), Instant.class);
         BASIC_TYPE_MAP.put(ZonedDateTime.class.getName(), ZonedDateTime.class);
+        BASIC_TYPE_MAP.put(LocalTime.class.getName(), LocalTime.class);
+        BASIC_TYPE_MAP.put(OffsetTime.class.getName(), OffsetTime.class);
+        BASIC_TYPE_MAP.put(OffsetDateTime.class.getName(), OffsetDateTime.class);
+        BASIC_TYPE_MAP.put(Period.class.getName(), Period.class);
+        BASIC_TYPE_MAP.put(YearMonth.class.getName(), YearMonth.class);
+        BASIC_TYPE_MAP.put(Year.class.getName(), Year.class);
+        BASIC_TYPE_MAP.put(MonthDay.class.getName(), MonthDay.class);
+        BASIC_TYPE_MAP.put(ZoneId.class.getName(), ZoneId.class);
+        BASIC_TYPE_MAP.put(ZoneOffset.class.getName(), ZoneOffset.class);
     }
 
     /**
diff --git a/gradle.properties b/gradle.properties
index 43def3f710..05ec9cc2cf 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -3,7 +3,7 @@ projectGroupId=io.micronaut
 projectDesc=Core components supporting the Micronaut Framework
 title=Micronaut Core
 githubSlug=micronaut-projects/micronaut-core
-docsRepository=micronaut-projects/micronaut-docs
+docsRepository=micronaut-projects/micronaut-docs 
 testsdir=inject-groovy/src/test/groovy/io/micronaut/docs
 testssession=session/src/test/groovy/io/micronaut/session/docs
 testskafka=configurations/kafka/src/test/groovy/io/micronaut/configuration/kafka/docs
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 1eb6efee27..3fb363bbd4 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -33,20 +33,19 @@ jazzer = "0.22.1"
 jcache = "1.1.1"
 junit5 = "5.10.3"
 junit-platform="1.10.3"
-logback = "1.5.8"
+logback = "1.5.7"
 logbook-netty = "2.16.0"
 log4j = "2.23.1"
-micronaut-aws = "4.7.1"
-micronaut-build-plugins="7.2.1"
-micronaut-groovy = "4.4.0"
+micronaut-aws = "4.6.0"
+micronaut-build-plugins="7.2.0"
+micronaut-groovy = "4.3.0"
 micronaut-session = "4.3.0"
 micronaut-sql = "5.3.0"
 micronaut-test = "4.4.0"
 micronaut-validation = "4.6.1"
-micronaut-rxjava2 = "2.5.0"
+micronaut-rxjava2 = "2.4.0"
 micronaut-rxjava3 = "3.4.0"
-micronaut-reactor = "3.5.0"
-micronaut-kotlin = "4.4.0"
+micronaut-reactor = "3.4.1"
 native-gradle-plugin = "0.10.2"
 neo4j-java-driver = "5.17.0"
 selenium = "4.23.1"
@@ -57,7 +56,7 @@ spotbugs = "4.7.1"
 systemlambda = "1.2.1"
 testcontainers = "1.20.1"
 tomlj="1.1.1"
-vertx = "4.5.10"
+vertx = "4.5.9"
 wiremock = "2.33.2"
 mimepull = "1.10.0"
 
@@ -73,15 +72,15 @@ managed-jackson-databind = "2.17.0"
 managed-kotlin = "1.9.25"
 managed-kotlin-coroutines = "1.8.1"
 managed-methvin-directory-watcher = "0.18.0"
-managed-netty = "4.1.113.Final"
+managed-netty = "4.1.112.Final"
 managed-netty-iouring = "0.0.25.Final"
 managed-netty-http3 = "0.0.28.Final"
-managed-netty-tcnative = "2.0.66.Final"
+managed-netty-tcnative = "2.0.65.Final"
 managed-reactive-streams = "1.0.4"
 # This should be kept aligned with https://github.com/micronaut-projects/micronaut-reactor/blob/master/gradle.properties from the BOM
 managed-reactor = "3.6.9"
 managed-snakeyaml = "2.2"
-managed-java-parser-core = "3.26.2"
+managed-java-parser-core = "3.26.1"
 managed-ksp = "1.9.25-1.0.20"
 micronaut-docs = "2.0.0"
 
@@ -93,7 +92,6 @@ test-boms-micronaut-validation = { module = "io.micronaut.validation:micronaut-v
 test-boms-micronaut-rxjava2 = { module = "io.micronaut.rxjava2:micronaut-rxjava2-bom", version.ref = "micronaut-rxjava2" }
 test-boms-micronaut-rxjava3 = { module = "io.micronaut.rxjava3:micronaut-rxjava3-bom", version.ref = "micronaut-rxjava3" }
 test-boms-micronaut-reactor = { module = "io.micronaut.reactor:micronaut-reactor-bom", version.ref = "micronaut-reactor" }
-test-boms-micronaut-kotlin = { module = "io.micronaut.kotlin:micronaut-kotlin-bom", version.ref = "micronaut-kotlin" }
 
 boms-groovy = { module = "org.apache.groovy:groovy-bom", version.ref = "managed-groovy" }
 boms-kotlin = { module = "org.jetbrains.kotlin:kotlin-bom", version.ref = "managed-kotlin" }
@@ -277,8 +275,6 @@ micronaut-tracing-brave = { module = "io.micronaut.tracing:micronaut-tracing-bra
 micronaut-validation = { module = "io.micronaut.validation:micronaut-validation" }
 micronaut-validation-processor = { module = "io.micronaut.validation:micronaut-validation-processor" }
 
-micronaut-kotlin-runtime = { module = "io.micronaut.kotlin:micronaut-kotlin-runtime" }
-
 testcontainers-spock = { module = "org.testcontainers:spock", version.ref = "testcontainers" }
 
 vertx = { module = "io.vertx:vertx-core", version.ref = "vertx" }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index a4b76b9530..2c3521197d 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 9355b41557..09523c0e54 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.9-bin.zip
 networkTimeout=10000
 validateDistributionUrl=true
 zipStoreBase=GRADLE_USER_HOME
diff --git a/http-client-core/src/main/java/io/micronaut/http/client/AbstractHttpClientFactory.java b/http-client-core/src/main/java/io/micronaut/http/client/AbstractHttpClientFactory.java
index 4556dba099..107d109d58 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/AbstractHttpClientFactory.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/AbstractHttpClientFactory.java
@@ -19,7 +19,6 @@ import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.convert.ConversionService;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 
 import java.net.URI;
@@ -37,14 +36,13 @@ import java.net.URL;
 public abstract class AbstractHttpClientFactory<T extends HttpClient> implements HttpClientFactory {
 
     protected final MediaTypeCodecRegistry mediaTypeCodecRegistry;
-    protected final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
     protected final ConversionService conversionService;
 
-    protected AbstractHttpClientFactory(@Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
-                                        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
-                                        ConversionService conversionService) {
+    protected AbstractHttpClientFactory(
+        @Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
+        ConversionService conversionService
+    ) {
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
-        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
         this.conversionService = conversionService;
     }
 
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/AbstractJdkHttpClient.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/AbstractJdkHttpClient.java
index e28f6d44ae..627cc4e051 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/AbstractJdkHttpClient.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/AbstractJdkHttpClient.java
@@ -30,7 +30,6 @@ import io.micronaut.http.HttpResponse;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MutableHttpRequest;
 import io.micronaut.http.bind.RequestBinderRegistry;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.client.HttpVersionSelection;
 import io.micronaut.http.client.LoadBalancer;
@@ -107,20 +106,18 @@ abstract class AbstractJdkHttpClient {
     protected final List<HttpFilterResolver.FilterEntry> clientFilterEntries;
     protected final CookieDecoder cookieDecoder;
     protected MediaTypeCodecRegistry mediaTypeCodecRegistry;
-    protected MessageBodyHandlerRegistry messageBodyHandlerRegistry;
 
     /**
-     * @param log                        the logger to use
-     * @param loadBalancer               The {@link LoadBalancer} to use for selecting servers
-     * @param httpVersion                The {@link HttpVersionSelection} to prefer
-     * @param configuration              The {@link HttpClientConfiguration} to use
-     * @param contextPath                The base URI to prepend to request uris
-     * @param mediaTypeCodecRegistry     The {@link MediaTypeCodecRegistry} to use for encoding and decoding objects
-     * @param messageBodyHandlerRegistry The {@link MessageBodyHandlerRegistry} to use for encoding and decoding objects
-     * @param requestBinderRegistry      The request binder registry
-     * @param clientId                   The client id
-     * @param conversionService          The {@link ConversionService}
-     * @param sslBuilder                 The {@link JdkClientSslBuilder} for creating an {@link javax.net.ssl.SSLContext}
+     * @param log                    the logger to use
+     * @param loadBalancer           The {@link LoadBalancer} to use for selecting servers
+     * @param httpVersion            The {@link HttpVersionSelection} to prefer
+     * @param configuration          The {@link HttpClientConfiguration} to use
+     * @param contextPath            The base URI to prepend to request uris
+     * @param mediaTypeCodecRegistry The {@link MediaTypeCodecRegistry} to use for encoding and decoding objects
+     * @param requestBinderRegistry  The request binder registry
+     * @param clientId               The client id
+     * @param conversionService      The {@link ConversionService}
+     * @param sslBuilder             The {@link JdkClientSslBuilder} for creating an {@link javax.net.ssl.SSLContext}
      */
     @SuppressWarnings({"java:S107", "checkstyle:parameternumber"}) // too many parameters
     protected AbstractJdkHttpClient(
@@ -132,7 +129,6 @@ abstract class AbstractJdkHttpClient {
         @Nullable HttpClientFilterResolver<ClientFilterResolutionContext> filterResolver,
         @Nullable List<HttpFilterResolver.FilterEntry> clientFilterEntries,
         MediaTypeCodecRegistry mediaTypeCodecRegistry,
-        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         RequestBinderRegistry requestBinderRegistry,
         String clientId,
         ConversionService conversionService,
@@ -145,7 +141,6 @@ abstract class AbstractJdkHttpClient {
         this.httpVersion = httpVersion;
         this.configuration = configuration;
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
-        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
         this.requestBinderRegistry = requestBinderRegistry;
         this.clientId = clientId;
         this.conversionService = conversionService;
@@ -293,20 +288,6 @@ abstract class AbstractJdkHttpClient {
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
     }
 
-    /**
-     * @return The {@link MessageBodyHandlerRegistry}
-     */
-    public MessageBodyHandlerRegistry getMessageBodyHandlerRegistry() {
-        return messageBodyHandlerRegistry;
-    }
-
-    /**
-     * @param messageBodyHandlerRegistry The {@link MessageBodyHandlerRegistry}
-     */
-    public void setMessageBodyHandlerRegistry(MessageBodyHandlerRegistry messageBodyHandlerRegistry) {
-        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
-    }
-
     /**
      * Convert the Micronaut request to a JDK request.
      *
@@ -315,7 +296,7 @@ abstract class AbstractJdkHttpClient {
      * @param <I>      The body type
      * @return A JDK request object
      */
-    protected <I> Mono<HttpRequest> mapToHttpRequest(@NonNull io.micronaut.http.HttpRequest<I> request, @Nullable Argument<?> bodyType) {
+    protected <I> Mono<HttpRequest> mapToHttpRequest(io.micronaut.http.HttpRequest<I> request, Argument<?> bodyType) {
         return resolveRequestUri(request)
             .map(uri -> {
                 cookieDecoder.decode(request).ifPresent(cookies -> cookies.getAll().forEach(cookie -> {
@@ -323,7 +304,7 @@ abstract class AbstractJdkHttpClient {
                     cookieManager.getCookieStore().add(uri, newCookie);
                 }));
 
-                return HttpRequestFactory.builder(uri, request, configuration, bodyType, mediaTypeCodecRegistry, messageBodyHandlerRegistry).build();
+                return HttpRequestFactory.builder(uri, request, configuration, bodyType, mediaTypeCodecRegistry).build();
             });
     }
 
@@ -368,10 +349,10 @@ abstract class AbstractJdkHttpClient {
      */
     @NonNull
     protected <O> HttpResponse<O> response(@NonNull java.net.http.HttpResponse<byte[]> netResponse, @NonNull Argument<O> bodyType) {
-        return new HttpResponseAdapter<>(netResponse, bodyType, conversionService, mediaTypeCodecRegistry, messageBodyHandlerRegistry);
+        return new HttpResponseAdapter<>(netResponse, bodyType, conversionService, mediaTypeCodecRegistry);
     }
 
-    protected <I, O> Flux<HttpResponse<O>> exchangeImpl(@NonNull io.micronaut.http.HttpRequest<I> request, @Nullable Argument<O> bodyType) {
+    protected <I, O> Flux<HttpResponse<O>> exchangeImpl(@NonNull io.micronaut.http.HttpRequest<I> request, @NonNull Argument<O> bodyType) {
         var defaultPublisher = responsePublisher(request, bodyType);
         return resolveRequestUri(request)
             .flatMapMany(uri -> applyFilterToResponsePublisher(request, uri, defaultPublisher));
@@ -408,8 +389,8 @@ abstract class AbstractJdkHttpClient {
     }
 
     protected <O> Publisher<io.micronaut.http.HttpResponse<O>> responsePublisher(
-        @NonNull io.micronaut.http.HttpRequest<?> request,
-        @Nullable Argument<O> bodyType
+        io.micronaut.http.HttpRequest<?> request,
+        Argument<O> bodyType
     ) {
         return Flux.defer(() -> mapToHttpRequest(request, bodyType)) // defered so any client filter changes are used
             .map(httpRequest -> {
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClient.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClient.java
index 71a05cf794..ba93c8dd02 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClient.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClient.java
@@ -26,7 +26,6 @@ import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpResponse;
 import io.micronaut.http.bind.DefaultRequestBinderRegistry;
 import io.micronaut.http.bind.RequestBinderRegistry;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.client.BlockingHttpClient;
 import io.micronaut.http.client.DefaultHttpClientConfiguration;
 import io.micronaut.http.client.HttpClient;
@@ -67,7 +66,6 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
         @Nullable HttpClientFilterResolver<ClientFilterResolutionContext> filterResolver,
         @Nullable List<HttpFilterResolver.FilterEntry> clientFilterEntries,
         MediaTypeCodecRegistry mediaTypeCodecRegistry,
-        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         RequestBinderRegistry requestBinderRegistry,
         String clientId,
         ConversionService conversionService,
@@ -83,7 +81,6 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
             filterResolver,
             clientFilterEntries,
             mediaTypeCodecRegistry,
-            messageBodyHandlerRegistry,
             requestBinderRegistry,
             clientId,
             conversionService,
@@ -101,7 +98,6 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
             null,
             null,
             createDefaultMediaTypeRegistry(),
-            JdkHttpClientFactory.createDefaultMessageBodyHandlerRegistry(),
             new DefaultRequestBinderRegistry(conversionService),
             null,
             conversionService,
@@ -114,7 +110,6 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
         URI uri,
         HttpClientConfiguration configuration,
         MediaTypeCodecRegistry mediaTypeCodecRegistry,
-        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         ConversionService conversionService
     ) {
         this(
@@ -125,7 +120,6 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
             null,
             null,
             mediaTypeCodecRegistry,
-            messageBodyHandlerRegistry,
             new DefaultRequestBinderRegistry(conversionService),
             null,
             conversionService,
@@ -153,7 +147,6 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
             filterResolver,
             clientFilterEntries,
             mediaTypeCodecRegistry,
-            messageBodyHandlerRegistry,
             requestBinderRegistry,
             clientId,
             conversionService,
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClientRegistry.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClientRegistry.java
index 4039f60b76..739e9efb9b 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClientRegistry.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClientRegistry.java
@@ -29,15 +29,11 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.annotation.Order;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.io.ResourceResolver;
-import io.micronaut.core.type.Argument;
 import io.micronaut.core.util.StringUtils;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.annotation.FilterMatcher;
 import io.micronaut.http.bind.DefaultRequestBinderRegistry;
 import io.micronaut.http.bind.RequestBinderRegistry;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
-import io.micronaut.http.body.MessageBodyReader;
-import io.micronaut.http.body.MessageBodyWriter;
 import io.micronaut.http.client.HttpClient;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.client.HttpClientRegistry;
@@ -57,7 +53,6 @@ import io.micronaut.inject.InjectionPoint;
 import io.micronaut.inject.qualifiers.Qualifiers;
 import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
-import io.micronaut.json.body.CustomizableJsonHandler;
 import io.micronaut.json.codec.MapperMediaTypeCodec;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -66,7 +61,6 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
-import java.util.Optional;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
@@ -92,7 +86,6 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
     private final JsonMapper jsonMapper;
     @Nullable
     private final MediaTypeCodecRegistry mediaTypeCodecRegistry;
-    private final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
     private final BeanProvider<RequestBinderRegistry> requestBinderRegistryProvider;
     private final JdkClientSslBuilder jdkClientSslBuilder;
     private final CookieDecoder cookieDecoder;
@@ -105,7 +98,6 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
         HttpClientFilterResolver<ClientFilterResolutionContext> httpClientFilterResolver,
         JsonMapper jsonMapper,
         @Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
-        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         BeanProvider<RequestBinderRegistry> requestBinderRegistryProvider,
         BeanProvider<JdkClientSslBuilder> sslBuilderBeanProvider,
         BeanProvider<CookieDecoder> cookieDecoderBeanProvider
@@ -116,7 +108,6 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
         this.clientFilterResolver = httpClientFilterResolver;
         this.jsonMapper = jsonMapper;
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
-        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
         this.requestBinderRegistryProvider = requestBinderRegistryProvider;
         this.jdkClientSslBuilder = sslBuilderBeanProvider.orElse(new JdkClientSslBuilder(new ResourceResolver()));
         this.cookieDecoder = cookieDecoderBeanProvider.orElse(new CompositeCookieDecoder(List.of(new DefaultCookieDecoder())));
@@ -270,27 +261,6 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
                     codecs.add(createNewJsonCodec(this.beanContext, jsonFeatures));
                 }
                 client.setMediaTypeCodecRegistry(MediaTypeCodecRegistry.of(codecs));
-                client.setMessageBodyHandlerRegistry(new MessageBodyHandlerRegistry() {
-                    final MessageBodyHandlerRegistry delegate = client.getMessageBodyHandlerRegistry();
-
-                    @SuppressWarnings("unchecked")
-                    private <T> T customize(T handler) {
-                        if (handler instanceof CustomizableJsonHandler cnjh) {
-                            return (T) cnjh.customize(jsonFeatures);
-                        }
-                        return handler;
-                    }
-
-                    @Override
-                    public <T> Optional<MessageBodyReader<T>> findReader(Argument<T> type, List<MediaType> mediaType) {
-                        return delegate.findReader(type, mediaType).map(this::customize);
-                    }
-
-                    @Override
-                    public <T> Optional<MessageBodyWriter<T>> findWriter(Argument<T> type, List<MediaType> mediaType) {
-                        return delegate.findWriter(type, mediaType).map(this::customize);
-                    }
-                });
             }
             return client;
         });
@@ -317,7 +287,6 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
                 annotationMetadata
             )),
             mediaTypeCodecRegistry,
-            messageBodyHandlerRegistry,
             requestBinderRegistryProvider.orElse(new DefaultRequestBinderRegistry(conversionService)),
             clientId,
             conversionService,
@@ -347,9 +316,10 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
     @Override
     public void disposeClient(AnnotationMetadata annotationMetadata) {
         final ClientKey key = getClientKey(annotationMetadata);
-        HttpClient client = clients.remove(key);
+        HttpClient client = clients.get(key);
         if (client != null && client.isRunning()) {
             client.close();
+            clients.remove(key);
         }
     }
 
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpRequestFactory.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpRequestFactory.java
index 048fd54465..7a2299e194 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpRequestFactory.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpRequestFactory.java
@@ -18,20 +18,15 @@ package io.micronaut.http.client.jdk;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpMethod;
 import io.micronaut.http.MediaType;
-import io.micronaut.http.MutableHttpRequest;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
-import io.micronaut.http.body.MessageBodyWriter;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 
-import java.io.ByteArrayOutputStream;
 import java.net.URI;
 import java.net.URLEncoder;
 import java.net.http.HttpRequest;
@@ -57,21 +52,19 @@ public final class HttpRequestFactory {
     public static <I> HttpRequest.Builder builder(
         @NonNull URI uri, io.micronaut.http.HttpRequest<I> request,
         @NonNull HttpClientConfiguration configuration,
-        @Nullable Argument<?> bodyType,
-        @Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
-        @NonNull MessageBodyHandlerRegistry messageBodyHandlerRegistry
+        Argument<?> bodyType,
+        MediaTypeCodecRegistry mediaTypeCodecRegistry
     ) {
-        MutableHttpRequest<I> mutableHttpRequest = request.toMutableRequest();
         final HttpRequest.Builder builder = HttpRequest.newBuilder().uri(uri);
         configuration.getReadTimeout().ifPresent(builder::timeout);
-        if (mutableHttpRequest.getMethod() == HttpMethod.GET) {
+        if (request.getMethod() == HttpMethod.GET) {
             builder.GET();
         } else {
-            HttpRequest.BodyPublisher bodyPublisher = publisherForRequest(mutableHttpRequest, bodyType, mediaTypeCodecRegistry, messageBodyHandlerRegistry);
-            builder.method(mutableHttpRequest.getMethod().toString(), bodyPublisher);
+            HttpRequest.BodyPublisher bodyPublisher = publisherForRequest(request, bodyType, mediaTypeCodecRegistry);
+            builder.method(request.getMethod().toString(), bodyPublisher);
         }
-        mutableHttpRequest.getHeaders().forEach((name, values) -> values.forEach(value -> builder.header(name, value)));
-        if (mutableHttpRequest.getContentType().isEmpty()) {
+        request.getHeaders().forEach((name, values) -> values.forEach(value -> builder.header(name, value)));
+        if (request.getContentType().isEmpty()) {
             builder.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);
         }
         configuration.getReadTimeout().ifPresent(builder::timeout);
@@ -79,59 +72,51 @@ public final class HttpRequestFactory {
     }
 
     private static <I> HttpRequest.BodyPublisher publisherForRequest(
-        @NonNull MutableHttpRequest<I> request,
-        @Nullable Argument<?> bodyType,
-        @Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
-        @NonNull MessageBodyHandlerRegistry messageBodyHandlerRegistry
+        io.micronaut.http.HttpRequest<I> request,
+        Argument<?> bodyType,
+        MediaTypeCodecRegistry mediaTypeCodecRegistry
     ) {
-        if (!HttpMethod.permitsRequestBody(request.getMethod())) {
-            return HttpRequest.BodyPublishers.noBody();
-        }
-        Optional<?> body = request.getBody();
-        if (body.isPresent()) {
-            Object bodyValue = body.get();
-            MediaType requestContentType = request.getContentType().orElse(MediaType.APPLICATION_JSON_TYPE);
-            if (requestContentType.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE)) {
+        if (io.micronaut.http.HttpMethod.permitsRequestBody(request.getMethod())) {
+            Optional<?> body = request.getBody();
+            boolean hasBody = body.isPresent();
+            MediaType requestContentType = request.getContentType().orElseGet(() -> MediaType.APPLICATION_JSON_TYPE);
+            if (requestContentType.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE) && hasBody) {
+                Object bodyValue = body.get();
                 if (bodyValue instanceof CharSequence) {
                     return HttpRequest.BodyPublishers.ofString(bodyValue.toString());
-                }
-                if (bodyValue instanceof Map<?, ?> mapBody) {
+                } else if (bodyValue instanceof Map<?, ?> mapBody) {
                     return HttpRequest.BodyPublishers.ofString(encodeBody(mapBody, request.getCharacterEncoding()));
+                } else {
+                    throw unsupportedBodyType(bodyValue.getClass(), requestContentType.toString());
                 }
-            }
-            if (Publishers.isConvertibleToPublisher(bodyValue)) {
+            } else if (requestContentType.equals(MediaType.MULTIPART_FORM_DATA_TYPE) && hasBody) {
+                Object bodyValue = body.get();
                 throw unsupportedBodyType(bodyValue.getClass(), requestContentType.toString());
-            }
-            if (bodyValue instanceof CharSequence) {
-                return HttpRequest.BodyPublishers.ofString(bodyValue.toString());
-            }
-            if (mediaTypeCodecRegistry != null) {
-                Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(requestContentType);
-                var encoded = registeredCodec.map(codec -> {
-                        if (bodyType != null && bodyType.isInstance(bodyValue)) {
-                            return codec.encode((Argument<Object>) bodyType, bodyValue);
+            } else {
+                if (hasBody) {
+                    Object bodyValue = body.get();
+                    if (Publishers.isConvertibleToPublisher(bodyValue)) {
+                        throw unsupportedBodyType(bodyValue.getClass(), requestContentType.toString());
+                    } else if (bodyValue instanceof CharSequence) {
+                        return HttpRequest.BodyPublishers.ofString(bodyValue.toString());
+                    } else if (mediaTypeCodecRegistry != null) {
+                        Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(requestContentType);
+                        var encoded = registeredCodec.map(codec -> {
+                                if (bodyType != null && bodyType.isInstance(bodyValue)) {
+                                    return codec.encode((Argument<Object>) bodyType, bodyValue);
+                                } else {
+                                    return codec.encode(bodyValue);
+                                }
+                            })
+                            .orElse(null);
+                        if (encoded != null) {
+                            return HttpRequest.BodyPublishers.ofByteArray(encoded);
+                        } else {
+                            return HttpRequest.BodyPublishers.noBody();
                         }
-                        return codec.encode(bodyValue);
-                    })
-                    .orElse(null);
-                if (encoded != null) {
-                    return HttpRequest.BodyPublishers.ofByteArray(encoded);
+                    }
                 }
             }
-            Argument<Object> bodyArgument = bodyType != null && bodyType.isInstance(bodyValue) ? (Argument<Object>) bodyType : Argument.ofInstance(bodyValue);
-            MessageBodyWriter<Object> messageBodyWriter = messageBodyHandlerRegistry.findWriter(bodyArgument, requestContentType).orElse(null);
-            if (messageBodyWriter != null) {
-                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
-                messageBodyWriter.writeTo(
-                    bodyArgument,
-                    requestContentType,
-                    bodyValue,
-                    request.getHeaders(),
-                    byteArrayOutputStream
-                );
-                return HttpRequest.BodyPublishers.ofByteArray(byteArrayOutputStream.toByteArray());
-            }
-            throw unsupportedBodyType(bodyValue.getClass(), requestContentType.toString());
         }
         return HttpRequest.BodyPublishers.noBody();
     }
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpResponseAdapter.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpResponseAdapter.java
index 25b2b34e35..8bacac66ac 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpResponseAdapter.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpResponseAdapter.java
@@ -23,14 +23,11 @@ import io.micronaut.core.convert.ConversionContext;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.convert.value.MutableConvertibleValues;
 import io.micronaut.core.convert.value.MutableConvertibleValuesMap;
-import io.micronaut.core.io.buffer.ByteArrayBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpResponse;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
-import io.micronaut.http.body.MessageBodyReader;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
@@ -60,18 +57,15 @@ public class HttpResponseAdapter<O> implements HttpResponse<O> {
     private final MutableConvertibleValues<Object> attributes = new MutableConvertibleValuesMap<>();
 
     private final MediaTypeCodecRegistry mediaTypeCodecRegistry;
-    private final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
 
     public HttpResponseAdapter(java.net.http.HttpResponse<byte[]> httpResponse,
-                               @Nullable Argument<O> bodyType,
+                               @NonNull Argument<O> bodyType,
                                ConversionService conversionService,
-                               MediaTypeCodecRegistry mediaTypeCodecRegistry,
-                               MessageBodyHandlerRegistry messageBodyHandlerRegistry) {
+                               MediaTypeCodecRegistry mediaTypeCodecRegistry) {
         this.httpResponse = httpResponse;
         this.bodyType = bodyType;
         this.conversionService = conversionService;
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
-        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
     }
 
     @Override
@@ -101,69 +95,53 @@ public class HttpResponseAdapter<O> implements HttpResponse<O> {
 
     @Override
     public Optional<O> getBody() {
-        return getBody(bodyType);
+        return convertBytes(getContentType().orElse(null), httpResponse.body(), bodyType);
     }
 
     @Override
     public <T> Optional<T> getBody(Argument<T> type) {
-        final boolean isOptional = type.getType() == Optional.class;
-        final Argument<Object> theArgument = (Argument<Object>) (isOptional ? type.getFirstTypeVariable().orElse(type) : type);
-        Optional<?> optional = convertBytes(getContentType().orElse(null), httpResponse.body(), theArgument);
-        if (isOptional) {
-            // If the requested type is an Optional, then we need to wrap the result again
-            return Optional.of((T) optional);
-        }
-        return (Optional<T>) optional;
+        return convertBytes(getContentType().orElse(null), httpResponse.body(), type);
     }
 
-    private <T> Optional<T> convertBytes(@Nullable MediaType contentType, byte[] bytes, Argument<T> type) {
+    private <T> Optional convertBytes(@Nullable MediaType contentType, byte[] bytes, Argument<T> type) {
         if (bytes.length == 0) {
             return Optional.empty();
         }
-        if (type.getType().equals(byte[].class)) {
-            return Optional.of((T) bytes);
-        }
-        if (contentType != null) {
-            if (CharSequence.class.isAssignableFrom(type.getType())) {
+        final boolean isOptional = type.getType() == Optional.class;
+        final Argument finalArgument = isOptional ? type.getFirstTypeVariable().orElse(type) : type;
+
+        if (mediaTypeCodecRegistry != null && contentType != null) {
+            if (CharSequence.class.isAssignableFrom(finalArgument.getType())) {
                 Charset charset = contentType.getCharset().orElse(StandardCharsets.UTF_8);
-                return Optional.of((T) new String(bytes, charset));
-            }
-        }
-        if (mediaTypeCodecRegistry != null) {
-            Optional<MediaTypeCodec> foundCodec = mediaTypeCodecRegistry.findCodec(contentType);
-            if (foundCodec.isPresent()) {
-                try {
-                    return foundCodec.map(codec -> codec.decode(type, bytes));
-                } catch (CodecException e) {
-                    logCodecError(contentType, type, e);
-                }
-            }
-        }
-        if (messageBodyHandlerRegistry != null) {
-            MessageBodyReader<T> reader = messageBodyHandlerRegistry.findReader(type, contentType).orElse(null);
-            if (reader != null) {
-                try {
-                    T value = reader.read(
-                        type,
-                        contentType,
-                        getHeaders(),
-                        ByteArrayBufferFactory.INSTANCE.wrap(bytes)
-                    );
-                    return Optional.of(value);
-                } catch (CodecException e) {
-                    logCodecError(contentType, type, e);
+                var converted = Optional.of(new String(bytes, charset));
+                // If the requested type is an Optional, then we need to wrap the result again
+                return isOptional ? Optional.of(converted) : converted;
+            } else if (finalArgument.getType() == byte[].class) {
+                var converted = Optional.of(bytes);
+                // If the requested type is an Optional, then we need to wrap the result again
+                return isOptional ? Optional.of(converted) : converted;
+            } else {
+                Optional<MediaTypeCodec> foundCodec = mediaTypeCodecRegistry.findCodec(contentType);
+                if (foundCodec.isPresent()) {
+                    try {
+                        var converted = foundCodec.map(codec -> codec.decode(finalArgument, bytes));
+                        return isOptional ? Optional.of(converted) : converted;
+                    } catch (CodecException e) {
+                        if (LOG.isDebugEnabled()) {
+                            var message = e.getMessage();
+                            LOG.debug("Error decoding body for type [{}] from '{}'. Attempting fallback.", type, contentType);
+                            LOG.debug("CodecException Message was: {}", message == null ? "null" : message.replace("\n", ""));
+                        }
+                    }
                 }
             }
         }
         // last chance, try type conversion
-       return conversionService.convert(bytes, ConversionContext.of(type));
-    }
-
-    private <T> void logCodecError(MediaType contentType, Argument<T> type, CodecException e) {
-        if (LOG.isDebugEnabled()) {
-            var message = e.getMessage();
-            LOG.debug("Error decoding body for type [{}] from '{}'. Attempting fallback.", type, contentType);
-            LOG.debug("CodecException Message was: {}", message == null ? "null" : message.replace("\n", ""));
+        var converted = conversionService.convert(bytes, ConversionContext.of(finalArgument));
+        if (isOptional) {
+            return Optional.of(converted);
+        } else {
+            return converted;
         }
     }
 }
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkBlockingHttpClient.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkBlockingHttpClient.java
index 6b55acd701..2641c8948f 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkBlockingHttpClient.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkBlockingHttpClient.java
@@ -17,12 +17,10 @@ package io.micronaut.http.client.jdk;
 
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.bind.RequestBinderRegistry;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.client.BlockingHttpClient;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.client.HttpVersionSelection;
@@ -54,7 +52,6 @@ public class JdkBlockingHttpClient extends AbstractJdkHttpClient implements Bloc
         @Nullable HttpClientFilterResolver<ClientFilterResolutionContext> filterResolver,
         @Nullable List<HttpFilterResolver.FilterEntry> clientFilterEntries,
         MediaTypeCodecRegistry mediaTypeCodecRegistry,
-        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         RequestBinderRegistry requestBinderRegistry,
         String clientId,
         ConversionService conversionService,
@@ -70,7 +67,6 @@ public class JdkBlockingHttpClient extends AbstractJdkHttpClient implements Bloc
             filterResolver,
             clientFilterEntries,
             mediaTypeCodecRegistry,
-            messageBodyHandlerRegistry,
             requestBinderRegistry,
             clientId,
             conversionService,
@@ -80,10 +76,11 @@ public class JdkBlockingHttpClient extends AbstractJdkHttpClient implements Bloc
     }
 
     @Override
-    public <I, O, E> io.micronaut.http.HttpResponse<O> exchange(@NonNull io.micronaut.http.HttpRequest<I> request,
-                                                                @Nullable Argument<O> bodyType,
-                                                                @Nullable Argument<E> errorType) {
-        return exchangeImpl(request, bodyType).blockFirst();
+    public <I, O, E> io.micronaut.http.HttpResponse<O> exchange(io.micronaut.http.HttpRequest<I> request,
+                                              Argument<O> bodyType,
+                                              Argument<E> errorType) {
+        return exchangeImpl(request, bodyType)
+            .blockFirst();
     }
 
     @Override
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkHttpClientFactory.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkHttpClientFactory.java
index 22c51013db..3da749ca63 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkHttpClientFactory.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkHttpClientFactory.java
@@ -18,16 +18,8 @@ package io.micronaut.http.client.jdk;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.convert.ConversionService;
-import io.micronaut.core.io.buffer.ByteArrayBufferFactory;
-import io.micronaut.http.MediaType;
-import io.micronaut.http.body.ContextlessMessageBodyHandlerRegistry;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
-import io.micronaut.http.body.WritableBodyWriter;
 import io.micronaut.http.client.AbstractHttpClientFactory;
 import io.micronaut.http.client.HttpClientConfiguration;
-import io.micronaut.json.JsonMapper;
-import io.micronaut.json.body.JsonMessageHandler;
-import io.micronaut.runtime.ApplicationConfiguration;
 
 import java.net.URI;
 
@@ -41,7 +33,7 @@ import java.net.URI;
 public class JdkHttpClientFactory extends AbstractHttpClientFactory<DefaultJdkHttpClient> {
 
     public JdkHttpClientFactory() {
-        super(null, createDefaultMessageBodyHandlerRegistry(), ConversionService.SHARED);
+        super(null, ConversionService.SHARED);
     }
 
     @Override
@@ -51,19 +43,6 @@ public class JdkHttpClientFactory extends AbstractHttpClientFactory<DefaultJdkHt
 
     @Override
     protected DefaultJdkHttpClient createHttpClient(URI uri, HttpClientConfiguration configuration) {
-        return new DefaultJdkHttpClient(uri, configuration, mediaTypeCodecRegistry, messageBodyHandlerRegistry, conversionService);
-    }
-
-    public static MessageBodyHandlerRegistry createDefaultMessageBodyHandlerRegistry() {
-        ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
-        ContextlessMessageBodyHandlerRegistry registry = new ContextlessMessageBodyHandlerRegistry(
-            applicationConfiguration,
-            ByteArrayBufferFactory.INSTANCE,
-            new WritableBodyWriter(applicationConfiguration)
-        );
-        JsonMapper mapper = JsonMapper.createDefault();
-        registry.add(MediaType.APPLICATION_JSON_TYPE, new JsonMessageHandler<>(mapper));
-        registry.add(MediaType.APPLICATION_JSON_STREAM_TYPE, new JsonMessageHandler<>(mapper));
-        return registry;
+        return new DefaultJdkHttpClient(uri, configuration, mediaTypeCodecRegistry, conversionService);
     }
 }
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index fca9f0fc56..358d5f6a93 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -958,7 +958,6 @@ public class DefaultHttpClient implements
                 webSocketURL, protocolVersion, subprotocol, true, customHeaders, maxFramePayloadLength),
             requestBinderRegistry,
             mediaTypeCodecRegistry,
-            handlerRegistry,
             conversionService);
 
         return connectionManager.connectForWebsocket(requestKey, handler)
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java
index aa305d4c7c..5633a1587d 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java
@@ -55,6 +55,7 @@ import io.micronaut.http.client.sse.SseClientRegistry;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 import io.micronaut.http.filter.HttpClientFilterResolver;
+import io.micronaut.http.netty.body.CustomizableNettyJsonHandler;
 import io.micronaut.http.netty.channel.ChannelPipelineCustomizer;
 import io.micronaut.http.netty.channel.ChannelPipelineListener;
 import io.micronaut.http.netty.channel.DefaultEventLoopGroupConfiguration;
@@ -67,7 +68,6 @@ import io.micronaut.inject.InjectionPoint;
 import io.micronaut.inject.qualifiers.Qualifiers;
 import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
-import io.micronaut.json.body.CustomizableJsonHandler;
 import io.micronaut.json.codec.MapperMediaTypeCodec;
 import io.micronaut.runtime.context.scope.refresh.RefreshEvent;
 import io.micronaut.runtime.context.scope.refresh.RefreshEventListener;
@@ -404,7 +404,7 @@ class DefaultNettyHttpClientRegistry implements AutoCloseable,
 
                     @SuppressWarnings("unchecked")
                     private <T> T customize(T handler) {
-                        if (handler instanceof CustomizableJsonHandler cnjh) {
+                        if (handler instanceof CustomizableNettyJsonHandler cnjh) {
                             return (T) cnjh.customize(jsonFeatures);
                         }
                         return handler;
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/websocket/NettyWebSocketClientHandler.java b/http-client/src/main/java/io/micronaut/http/client/netty/websocket/NettyWebSocketClientHandler.java
index f993676b88..09d9b5d0fc 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/websocket/NettyWebSocketClientHandler.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/websocket/NettyWebSocketClientHandler.java
@@ -24,7 +24,6 @@ import io.micronaut.core.convert.value.ConvertibleValues;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.MutableHttpRequest;
 import io.micronaut.http.bind.RequestBinderRegistry;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 import io.micronaut.http.netty.websocket.AbstractNettyWebSocketHandler;
 import io.micronaut.http.netty.websocket.NettyWebSocketSession;
@@ -71,6 +70,7 @@ public class NettyWebSocketClientHandler<T> extends AbstractNettyWebSocketHandle
     private final WebSocketBean<T> genericWebSocketBean;
     private final Sinks.One<T> completion = Sinks.one();
     private final UriMatchInfo matchInfo;
+    private final MediaTypeCodecRegistry codecRegistry;
     private NettyWebSocketSession clientSession;
     private FullHttpResponse handshakeResponse;
     private Argument<?> clientBodyArgument;
@@ -79,13 +79,12 @@ public class NettyWebSocketClientHandler<T> extends AbstractNettyWebSocketHandle
     /**
      * Default constructor.
      *
-     * @param request                    The originating request that created the WebSocket.
-     * @param webSocketBean              The WebSocket client bean.
-     * @param handshaker                 The handshaker
-     * @param requestBinderRegistry      The request binder registry
-     * @param mediaTypeCodecRegistry     The media type codec registry
-     * @param messageBodyHandlerRegistry The handler registry
-     * @param conversionService          The conversionService
+     * @param request                The originating request that created the WebSocket.
+     * @param webSocketBean          The WebSocket client bean.
+     * @param handshaker             The handshaker
+     * @param requestBinderRegistry  The request binder registry
+     * @param mediaTypeCodecRegistry The media type codec registry
+     * @param conversionService      The conversionService
      */
     public NettyWebSocketClientHandler(
             MutableHttpRequest<?> request,
@@ -93,9 +92,9 @@ public class NettyWebSocketClientHandler<T> extends AbstractNettyWebSocketHandle
             final WebSocketClientHandshaker handshaker,
             RequestBinderRegistry requestBinderRegistry,
             MediaTypeCodecRegistry mediaTypeCodecRegistry,
-            MessageBodyHandlerRegistry messageBodyHandlerRegistry,
             ConversionService conversionService) {
-        super(requestBinderRegistry, mediaTypeCodecRegistry, messageBodyHandlerRegistry, webSocketBean, request, Collections.emptyMap(), handshaker.version(), handshaker.actualSubprotocol(), null, conversionService);
+        super(null, requestBinderRegistry, mediaTypeCodecRegistry, webSocketBean, request, Collections.emptyMap(), handshaker.version(), handshaker.actualSubprotocol(), null, conversionService);
+        this.codecRegistry = mediaTypeCodecRegistry;
         this.handshaker = handshaker;
         this.genericWebSocketBean = webSocketBean;
         String clientPath = webSocketBean.getBeanDefinition().stringValue(ClientWebSocket.class).orElse("");
@@ -231,8 +230,7 @@ public class NettyWebSocketClientHandler<T> extends AbstractNettyWebSocketHandle
                     handshakeResponse.headers().get(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT),
                     ctx.channel(),
                     originatingRequest,
-                    mediaTypeCodecRegistry,
-                    messageBodyHandlerRegistry,
+                    codecRegistry,
                     handshaker.version().toHttpHeaderValue(),
                     ctx.pipeline().get(SslHandler.class) != null
             ) {
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java b/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java
index d8219767cd..227b52902f 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java
@@ -120,9 +120,7 @@ public interface NettyHttpResponseBuilder {
      * @param byteBuf The byteBuf
      * @return The full response.
      * @since 4.3.0
-     * @deprecated Unused
      */
-    @Deprecated
     static @NonNull FullHttpResponse toFullHttpResponse(@NonNull io.micronaut.http.HttpResponse<?> response, @NonNull ByteBuf byteBuf) {
         while (response instanceof HttpResponseWrapper<?> wrapper) {
             response = wrapper.getDelegate();
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/NettyMutableHttpResponse.java b/http-netty/src/main/java/io/micronaut/http/netty/NettyMutableHttpResponse.java
index f55a7d91dd..06cb071f07 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/NettyMutableHttpResponse.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/NettyMutableHttpResponse.java
@@ -27,7 +27,6 @@ import io.micronaut.core.convert.value.MutableConvertibleValuesMap;
 import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.util.StringUtils;
-import io.micronaut.http.HttpResponseWrapper;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpHeaders;
@@ -45,7 +44,6 @@ import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
-import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.DefaultLastHttpContent;
 import io.netty.handler.codec.http.EmptyHttpHeaders;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -55,7 +53,6 @@ import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
 
-import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -170,38 +167,6 @@ public final class NettyMutableHttpResponse<B> implements MutableHttpResponse<B>
         }
     }
 
-    /**
-     * Create a non-body netty response from the given MN response.
-     *
-     * @param response The mn response
-     * @return The netty response
-     */
-    public static @NonNull HttpResponse toNoBodyResponse(@NonNull io.micronaut.http.HttpResponse<?> response) {
-        Objects.requireNonNull(response, "The response cannot be null");
-        while (response instanceof HttpResponseWrapper<?> wrapper) {
-            response = wrapper.getDelegate();
-        }
-        HttpVersion version;
-        HttpResponseStatus status;
-        if (response instanceof NettyMutableHttpResponse<?> nmhr) {
-            version = nmhr.getNettyHttpVersion();
-            status = nmhr.getNettyHttpStatus();
-        } else {
-            version = HttpVersion.HTTP_1_1;
-            status = new HttpResponseStatus(response.code(), response.reason());
-        }
-        io.micronaut.http.HttpHeaders mnHeaders = response.getHeaders();
-        HttpHeaders nettyHeaders;
-        if (mnHeaders instanceof NettyHttpHeaders nhh) {
-            nettyHeaders = nhh.getNettyHeaders();
-        } else {
-            nettyHeaders = new DefaultHttpHeaders();
-            response.getHeaders()
-                .forEach((s, strings) -> nettyHeaders.add(s, strings));
-        }
-        return new DefaultHttpResponse(version, status, nettyHeaders);
-    }
-
     @Override
     public Optional<MessageBodyWriter<B>> getBodyWriter() {
         return Optional.ofNullable(messageBodyWriter);
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/CustomizableNettyJsonHandler.java b/http-netty/src/main/java/io/micronaut/http/netty/body/CustomizableNettyJsonHandler.java
new file mode 100644
index 0000000000..6e104abc42
--- /dev/null
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/CustomizableNettyJsonHandler.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2017-2023 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.netty.body;
+
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.json.JsonFeatures;
+
+/**
+ * {@link io.micronaut.http.body.MessageBodyHandler} that is customizable with {@link JsonFeatures}.
+ *
+ * @since 4.0.0
+ * @author Jonas Konrad
+ */
+@Internal
+public interface CustomizableNettyJsonHandler {
+    @NonNull
+    CustomizableNettyJsonHandler customize(@NonNull JsonFeatures jsonFeatures);
+}
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyBodyWriter.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyBodyWriter.java
new file mode 100644
index 0000000000..6f4eadbee9
--- /dev/null
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyBodyWriter.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2017-2023 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.netty.body;
+
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.type.Argument;
+import io.micronaut.http.HttpRequest;
+import io.micronaut.http.MediaType;
+import io.micronaut.http.MutableHttpResponse;
+import io.micronaut.http.body.MessageBodyWriter;
+import io.micronaut.http.codec.CodecException;
+
+/**
+ * Netty-specific writer.
+ *
+ * @param <T> The type to write
+ */
+@Internal
+@Experimental
+public interface NettyBodyWriter<T> extends MessageBodyWriter<T> {
+
+    /**
+     * Write an object to the given context.
+     *
+     * @param request          The associated request
+     * @param outgoingResponse The outgoing response.
+     * @param type             The type
+     * @param mediaType        The media type
+     * @param object           The object to write
+     * @param nettyContext     The netty context
+     * @throws CodecException If an error occurs decoding
+     */
+    @NonNull
+    void writeTo(
+        @NonNull HttpRequest<?> request,
+        @NonNull MutableHttpResponse<T> outgoingResponse,
+        @NonNull Argument<T> type,
+        @NonNull MediaType mediaType,
+        @NonNull T object,
+        @NonNull NettyWriteContext nettyContext) throws CodecException;
+}
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyCharSequenceBodyWriter.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyCharSequenceBodyWriter.java
index 89d106b813..eca93cfff6 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyCharSequenceBodyWriter.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyCharSequenceBodyWriter.java
@@ -17,11 +17,8 @@ package io.micronaut.http.netty.body;
 
 import io.micronaut.context.annotation.Replaces;
 import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
@@ -29,17 +26,19 @@ import io.micronaut.http.MutableHttpHeaders;
 import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.body.CharSequenceBodyWriter;
 import io.micronaut.http.body.MessageBodyWriter;
-import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.netty.NettyHttpHeaders;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.buffer.ByteBufUtil;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.EmptyHttpHeaders;
+import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpVersion;
 import jakarta.inject.Singleton;
 
 import java.io.OutputStream;
-import java.nio.CharBuffer;
 import java.nio.charset.StandardCharsets;
 
 /**
@@ -51,18 +50,27 @@ import java.nio.charset.StandardCharsets;
 @Singleton
 @Replaces(CharSequenceBodyWriter.class)
 @Internal
-public final class NettyCharSequenceBodyWriter implements ResponseBodyWriter<CharSequence> {
+public final class NettyCharSequenceBodyWriter implements MessageBodyWriter<CharSequence>, NettyBodyWriter<CharSequence> {
     private final CharSequenceBodyWriter defaultHandler = new CharSequenceBodyWriter(StandardCharsets.UTF_8);
 
     @Override
-    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<CharSequence> outgoingResponse, Argument<CharSequence> type, MediaType mediaType, CharSequence object) throws CodecException {
+    public void writeTo(HttpRequest<?> request, MutableHttpResponse<CharSequence> outgoingResponse, Argument<CharSequence> type, MediaType mediaType, CharSequence object, NettyWriteContext nettyContext) throws CodecException {
         MutableHttpHeaders headers = outgoingResponse.getHeaders();
-        ByteBuf byteBuf = ByteBufUtil.encodeString(ByteBufAllocator.DEFAULT, CharBuffer.wrap(object), MessageBodyWriter.getCharset(mediaType, headers));
+        ByteBuf byteBuf = Unpooled.copiedBuffer(object.toString(), MessageBodyWriter.getCharset(mediaType, headers));
         NettyHttpHeaders nettyHttpHeaders = (NettyHttpHeaders) headers;
+        io.netty.handler.codec.http.HttpHeaders nettyHeaders = nettyHttpHeaders.getNettyHeaders();
         if (!nettyHttpHeaders.contains(HttpHeaders.CONTENT_TYPE)) {
             nettyHttpHeaders.set(HttpHeaderNames.CONTENT_TYPE, mediaType);
         }
-        return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, new AvailableNettyByteBody(byteBuf));
+        nettyHeaders.set(HttpHeaderNames.CONTENT_LENGTH, byteBuf.readableBytes());
+        FullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(
+            HttpVersion.HTTP_1_1,
+            HttpResponseStatus.valueOf(outgoingResponse.code(), outgoingResponse.reason()),
+            byteBuf,
+            nettyHeaders,
+            EmptyHttpHeaders.INSTANCE
+        );
+        nettyContext.writeFull(fullHttpResponse);
     }
 
     @Override
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonHandler.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonHandler.java
index b71c720fe3..019c94cb9e 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonHandler.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonHandler.java
@@ -20,31 +20,29 @@ import io.micronaut.context.annotation.Replaces;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Order;
 import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.Headers;
 import io.micronaut.core.type.MutableHeaders;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.body.ChunkedMessageBodyReader;
 import io.micronaut.http.body.MessageBodyHandler;
 import io.micronaut.http.body.MessageBodyWriter;
-import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.netty.NettyHttpHeaders;
 import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
-import io.micronaut.json.body.CustomizableJsonHandler;
 import io.micronaut.json.body.JsonMessageHandler;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufOutputStream;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.EmptyHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpVersion;
 import jakarta.inject.Singleton;
 import org.reactivestreams.Publisher;
 import reactor.core.publisher.Flux;
@@ -58,7 +56,6 @@ import java.io.OutputStream;
  *
  * @param <T> The type
  */
-@Order(JsonMessageHandler.ORDER)
 @Singleton
 @Internal
 @Replaces(JsonMessageHandler.class)
@@ -66,8 +63,7 @@ import java.io.OutputStream;
 @JsonMessageHandler.ConsumesJson
 @BootstrapContextCompatible
 @Requires(beans = JsonMapper.class)
-
-public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, ChunkedMessageBodyReader<T>, CustomizableJsonHandler, ResponseBodyWriter<T> {
+public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, ChunkedMessageBodyReader<T>, CustomizableNettyJsonHandler, NettyBodyWriter<T> {
     private final JsonMessageHandler<T> jsonMessageHandler;
 
     public NettyJsonHandler(JsonMapper jsonMapper) {
@@ -79,7 +75,7 @@ public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, Chunked
     }
 
     @Override
-    public CustomizableJsonHandler customize(JsonFeatures jsonFeatures) {
+    public CustomizableNettyJsonHandler customize(JsonFeatures jsonFeatures) {
         return new NettyJsonHandler<>(jsonMessageHandler.getJsonMapper().cloneWithFeatures(jsonFeatures));
     }
 
@@ -132,10 +128,10 @@ public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, Chunked
     }
 
     @Override
-    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, @NonNull HttpRequest<?> request, @NonNull MutableHttpResponse<T> outgoingResponse, @NonNull Argument<T> type, @NonNull MediaType mediaType, @NonNull T object) throws CodecException {
+    public void writeTo(@NonNull HttpRequest<?> request, @NonNull MutableHttpResponse<T> outgoingResponse, @NonNull Argument<T> type, @NonNull MediaType mediaType, @NonNull T object, @NonNull NettyWriteContext nettyContext) throws CodecException {
         NettyHttpHeaders nettyHttpHeaders = (NettyHttpHeaders) outgoingResponse.getHeaders();
         nettyHttpHeaders.setIfMissing(HttpHeaderNames.CONTENT_TYPE, mediaType);
-        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();
+        ByteBuf buffer = nettyContext.alloc().buffer();
         JsonMapper jsonMapper = jsonMessageHandler.getJsonMapper();
         try {
             jsonMapper.writeValue(new ByteBufOutputStream(buffer), object);
@@ -143,7 +139,7 @@ public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, Chunked
             buffer.release();
             throw new CodecException("Error encoding object [" + object + "] to JSON: " + e.getMessage(), e);
         }
-        return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, new AvailableNettyByteBody(buffer));
+        nettyContext.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(outgoingResponse.code(), outgoingResponse.reason()), buffer, nettyHttpHeaders.getNettyHeaders(), EmptyHttpHeaders.INSTANCE));
     }
 
     @Override
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonStreamHandler.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonStreamHandler.java
index 35e0eeff87..1ad9a5ef23 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonStreamHandler.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonStreamHandler.java
@@ -29,7 +29,6 @@ import io.micronaut.http.body.MessageBodyHandler;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
-import io.micronaut.json.body.CustomizableJsonHandler;
 import io.micronaut.json.body.JsonMessageHandler;
 import io.netty.buffer.ByteBuf;
 import jakarta.inject.Singleton;
@@ -51,7 +50,7 @@ import java.util.List;
 @Singleton
 @Produces(MediaType.APPLICATION_JSON_STREAM)
 @Consumes(MediaType.APPLICATION_JSON_STREAM)
-public final class NettyJsonStreamHandler<T> implements MessageBodyHandler<T>, ChunkedMessageBodyReader<T>, CustomizableJsonHandler {
+public final class NettyJsonStreamHandler<T> implements MessageBodyHandler<T>, ChunkedMessageBodyReader<T>, CustomizableNettyJsonHandler {
     private final JsonMessageHandler<T> jsonMessageHandler;
 
     public NettyJsonStreamHandler(JsonMapper jsonMapper) {
@@ -63,7 +62,7 @@ public final class NettyJsonStreamHandler<T> implements MessageBodyHandler<T>, C
     }
 
     @Override
-    public CustomizableJsonHandler customize(JsonFeatures jsonFeatures) {
+    public CustomizableNettyJsonHandler customize(JsonFeatures jsonFeatures) {
         return new NettyJsonStreamHandler<>(jsonMessageHandler.getJsonMapper().cloneWithFeatures(jsonFeatures));
     }
 
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWritableBodyWriter.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWritableBodyWriter.java
index 63ac58fd5e..d2508cadfa 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWritableBodyWriter.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWritableBodyWriter.java
@@ -20,12 +20,9 @@ import io.micronaut.context.annotation.Replaces;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.io.Writable;
 import io.micronaut.core.io.buffer.ByteBuffer;
-import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.Headers;
 import io.micronaut.core.type.MutableHeaders;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
@@ -33,14 +30,18 @@ import io.micronaut.http.MutableHttpHeaders;
 import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.body.ChunkedMessageBodyReader;
 import io.micronaut.http.body.MessageBodyWriter;
-import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.body.TypedMessageBodyHandler;
 import io.micronaut.http.body.WritableBodyWriter;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.exceptions.MessageBodyException;
+import io.micronaut.http.netty.NettyHttpHeaders;
 import io.micronaut.runtime.ApplicationConfiguration;
-import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.EmptyHttpHeaders;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpVersion;
 import jakarta.inject.Singleton;
 import org.reactivestreams.Publisher;
 
@@ -55,7 +56,7 @@ import java.io.OutputStream;
 @Singleton
 @Internal
 @BootstrapContextCompatible
-public final class NettyWritableBodyWriter implements TypedMessageBodyHandler<Writable>, ChunkedMessageBodyReader<Writable>, ResponseBodyWriter<Writable> {
+public final class NettyWritableBodyWriter implements NettyBodyWriter<Writable>, TypedMessageBodyHandler<Writable>, ChunkedMessageBodyReader<Writable> {
 
     private final WritableBodyWriter defaultWritable;
 
@@ -74,19 +75,25 @@ public final class NettyWritableBodyWriter implements TypedMessageBodyHandler<Wr
     }
 
     @Override
-    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<Writable> outgoingResponse, Argument<Writable> type, MediaType mediaType, Writable object) throws CodecException {
+    public void writeTo(HttpRequest<?> request, MutableHttpResponse<Writable> outgoingResponse, Argument<Writable> type, MediaType mediaType, Writable object, NettyWriteContext nettyContext) throws CodecException {
+        ByteBuf byteBuf = nettyContext.alloc().ioBuffer(128);
         MutableHttpHeaders outgoingHeaders = outgoingResponse.getHeaders();
         if (mediaType != null && !outgoingHeaders.contains(HttpHeaders.CONTENT_TYPE)) {
             outgoingHeaders.contentType(mediaType);
         }
-        ByteBufOutputStream outputStream = new ByteBufOutputStream(ByteBufAllocator.DEFAULT.buffer());
-        try {
+        try (ByteBufOutputStream outputStream = new ByteBufOutputStream(byteBuf)) {
+            DefaultFullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(
+                HttpVersion.HTTP_1_1,
+                HttpResponseStatus.valueOf(outgoingResponse.code(), outgoingResponse.reason()),
+                byteBuf,
+                ((NettyHttpHeaders) outgoingHeaders).getNettyHeaders(),
+                EmptyHttpHeaders.INSTANCE
+            );
             object.writeTo(outputStream, MessageBodyWriter.getCharset(mediaType, outgoingHeaders));
-            outputStream.close();
+            nettyContext.writeFull(fullHttpResponse);
         } catch (IOException e) {
             throw new MessageBodyException("Error writing body from writable", e);
         }
-        return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, new AvailableNettyByteBody(outputStream.buffer()));
     }
 
     @Override
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java
index 4f80af7fe7..5efa56d677 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java
@@ -19,7 +19,11 @@ import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.http.body.ByteBody;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpResponse;
+import org.reactivestreams.Publisher;
 
 /**
  * This interface is used to write the different kinds of netty responses.
@@ -29,6 +33,12 @@ import io.netty.handler.codec.http.HttpResponse;
 @Internal
 @Experimental
 public interface NettyWriteContext {
+    /**
+     * @return The bytebuf allocator.
+     */
+    @NonNull
+    ByteBufAllocator alloc();
+
     /**
      * Write a response.
      *
@@ -38,10 +48,28 @@ public interface NettyWriteContext {
     void write(@NonNull HttpResponse response, @NonNull ByteBody body);
 
     /**
-     * Write a response to a {@code HEAD} request. This is special because it never has a body but
-     * may still have a non-zero {@code Content-Length} header.
+     * Write a full response.
      *
-     * @param response The response status, headers etc
+     * @param response The response to write
+     */
+    default void writeFull(@NonNull FullHttpResponse response) {
+        writeFull(response, false);
+    }
+
+    /**
+     * Write a full response.
+     *
+     * @param response The response to write
+     * @param headResponse If {@code true}, this is a response to a {@code HEAD} request, so the
+     * {@code Content-Length} header should not be overwritten.
+     */
+    void writeFull(@NonNull FullHttpResponse response, boolean headResponse);
+
+    /**
+     * Write a streamed response.
+     *
+     * @param response The response to write
+     * @param content  The body
      */
-    void writeHeadResponse(@NonNull HttpResponse response);
+    void writeStreamed(@NonNull HttpResponse response, @NonNull Publisher<HttpContent> content);
 }
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/stream/JsonSubscriber.java b/http-netty/src/main/java/io/micronaut/http/netty/stream/JsonSubscriber.java
index baf1762651..5f389ad965 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/stream/JsonSubscriber.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/stream/JsonSubscriber.java
@@ -19,34 +19,76 @@ import io.micronaut.core.annotation.Internal;
 import io.micronaut.http.netty.content.HttpContentUtil;
 import io.netty.handler.codec.http.HttpContent;
 import org.reactivestreams.Publisher;
+import org.reactivestreams.Subscription;
+import reactor.core.CoreSubscriber;
 import reactor.core.publisher.Flux;
+import reactor.core.publisher.Operators;
+import reactor.util.context.Context;
 
-import java.util.function.Function;
+import java.util.concurrent.atomic.AtomicBoolean;
 
 /**
  * A Reactor subscriber used to handle JSON content. It delegates to an upstream subscriber, wrapping them with opening/closing brackets
  * where necessary.
  */
 @Internal
-public final class JsonSubscriber {
+public final class JsonSubscriber implements CoreSubscriber<HttpContent> {
+
+    private final AtomicBoolean empty = new AtomicBoolean(true);
+    private final CoreSubscriber<? super HttpContent> upstream;
+
+    public JsonSubscriber(CoreSubscriber<? super HttpContent> upstream) {
+        this.upstream = upstream;
+    }
+
+    @Override
+    public Context currentContext() {
+        return upstream.currentContext();
+    }
+
+    @Override
+    public void onSubscribe(Subscription s) {
+        upstream.onSubscribe(s);
+    }
+
+    /**
+     * The goal is to prevent the emission of the
+     * opening bracket if the underlying stream never emits
+     * an item and only produces an error.
+     *
+     * @param o The content
+     */
+    @Override
+    public void onNext(HttpContent o) {
+        if (empty.compareAndSet(true, false)) {
+            upstream.onNext(HttpContentUtil.prefixOpenBracket(o));
+        } else {
+            upstream.onNext(HttpContentUtil.prefixComma(o));
+        }
+    }
+
+    @Override
+    public void onError(Throwable t) {
+        upstream.onError(t);
+    }
+
+    /**
+     * On complete the opening bracket should be emitted
+     * if no items were ever produced, then the closing bracket.
+     */
+    @Override
+    public void onComplete() {
+        if (empty.get()) {
+            upstream.onNext(HttpContentUtil.prefixOpenBracket(HttpContentUtil.closeBracket()));
+        } else {
+            upstream.onNext(HttpContentUtil.closeBracket());
+        }
+        upstream.onComplete();
+    }
+
     public static Flux<HttpContent> lift(Publisher<HttpContent> publisher) {
-        HttpContent closeBracket = HttpContentUtil.closeBracket();
-        return Flux.from(publisher)
-            .concatWithValues(closeBracket)
-            .map(new Function<>() {
-                boolean empty = true;
-
-                @Override
-                public HttpContent apply(HttpContent httpContent) {
-                    if (empty) {
-                        empty = false;
-                        return HttpContentUtil.prefixOpenBracket(httpContent);
-                    } else if (httpContent != closeBracket) {
-                        return HttpContentUtil.prefixComma(httpContent);
-                    } else {
-                        return httpContent;
-                    }
-                }
-            });
+        return (Flux<HttpContent>) Operators.<HttpContent, HttpContent>lift(
+                (scannable, subscriber) -> new JsonSubscriber(subscriber)
+        ).apply(publisher);
     }
 }
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/websocket/AbstractNettyWebSocketHandler.java b/http-netty/src/main/java/io/micronaut/http/netty/websocket/AbstractNettyWebSocketHandler.java
index 8636b7bf45..542b373b9a 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/websocket/AbstractNettyWebSocketHandler.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/websocket/AbstractNettyWebSocketHandler.java
@@ -24,18 +24,14 @@ import io.micronaut.core.bind.DefaultExecutableBinder;
 import io.micronaut.core.bind.ExecutableBinder;
 import io.micronaut.core.bind.exceptions.UnsatisfiedArgumentException;
 import io.micronaut.core.convert.ConversionService;
-import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.annotation.Consumes;
 import io.micronaut.http.bind.RequestBinderRegistry;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
-import io.micronaut.http.body.MessageBodyReader;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
-import io.micronaut.http.simple.SimpleHttpHeaders;
 import io.micronaut.inject.ExecutableMethod;
 import io.micronaut.inject.MethodExecutionHandle;
 import io.micronaut.websocket.CloseReason;
@@ -96,7 +92,6 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
     protected final MethodExecutionHandle<?, ?> messageHandler;
     protected final MethodExecutionHandle<?, ?> pongHandler;
     protected final MediaTypeCodecRegistry mediaTypeCodecRegistry;
-    protected final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
     protected final WebSocketVersion webSocketVersion;
     protected final String subProtocol;
     protected final WebSocketSessionRepository webSocketSessionRepository;
@@ -107,9 +102,9 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
     /**
      * Default constructor.
      *
+     * @param ctx                        The channel handler context
      * @param binderRegistry             The request binder registry
      * @param mediaTypeCodecRegistry     The codec registry
-     * @param messageBodyHandlerRegistry The handler registry
      * @param webSocketBean              The websocket bean
      * @param request                    The originating request
      * @param uriVariables               The URI variables
@@ -119,9 +114,9 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
      * @param conversionService          The conversion service
      */
     protected AbstractNettyWebSocketHandler(
+            ChannelHandlerContext ctx,
             RequestBinderRegistry binderRegistry,
             MediaTypeCodecRegistry mediaTypeCodecRegistry,
-            MessageBodyHandlerRegistry messageBodyHandlerRegistry,
             WebSocketBean<?> webSocketBean,
             HttpRequest<?> request,
             Map<String, Object> uriVariables,
@@ -140,7 +135,6 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
         this.webSocketVersion = version;
         this.conversionService = conversionService;
-        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
     }
 
     /**
@@ -341,10 +335,10 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
                 }
 
                 Argument<?> bodyArgument = this.getBodyArgument();
-                Object data = conversionService.convert(content, ByteBuf.class, bodyArgument).orElse(null);
+                Optional<?> converted = conversionService.convert(content, ByteBuf.class, bodyArgument);
                 content.release();
 
-                if (data == null) {
+                if (converted.isEmpty()) {
                     MediaType mediaType;
                     try {
                         mediaType = messageHandler.stringValue(Consumes.class).map(MediaType::of).orElse(MediaType.APPLICATION_JSON_TYPE);
@@ -353,28 +347,19 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
                         return;
                     }
                     try {
-                        data = mediaTypeCodecRegistry.findCodec(mediaType)
-                            .map(codec -> codec.decode(bodyArgument, new NettyByteBufferFactory(ctx.alloc()).wrap(msg.content())))
-                            .orElse(null);
+                        converted = mediaTypeCodecRegistry.findCodec(mediaType).map(codec -> codec.decode(bodyArgument, new NettyByteBufferFactory(ctx.alloc()).wrap(msg.content())));
                     } catch (CodecException e) {
                         messageProcessingException(ctx, e);
                         return;
                     }
-                    if (data == null) {
-                        MessageBodyReader<?> reader = messageBodyHandlerRegistry.findReader(bodyArgument, mediaType)
-                            .orElse(null);
-                        if (reader != null) {
-                            ByteBuffer<ByteBuf> byteBuffer = new NettyByteBufferFactory(ctx.alloc()).wrap(msg.content().retain());
-                            data = reader.read((Argument) bodyArgument, mediaType, new SimpleHttpHeaders(), byteBuffer);
-                        }
-                    }
                 }
 
-                if (data != null) {
+                if (converted.isPresent()) {
+                    Object v = converted.get();
 
                     NettyWebSocketSession currentSession = getSession();
                     ExecutableBinder<WebSocketState> executableBinder = new DefaultExecutableBinder<>(
-                            Collections.singletonMap(bodyArgument, data)
+                            Collections.singletonMap(bodyArgument, v)
                     );
 
                     try {
@@ -387,15 +372,14 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
                         Object result = invokeExecutable(boundExecutable, messageHandler);
                         if (Publishers.isConvertibleToPublisher(result)) {
                             Flux<?> flowable = Flux.from(instrumentPublisher(ctx, result));
-                            Object finalData = data;
                             flowable.subscribe(
                                     o -> {
                                     },
                                     error -> messageProcessingException(ctx, error),
-                                    () -> messageHandled(ctx, finalData)
+                                    () -> messageHandled(ctx, v)
                             );
                         } else {
-                            messageHandled(ctx, data);
+                            messageHandled(ctx, v);
                         }
                     } catch (Throwable e) {
                         messageProcessingException(ctx, e);
@@ -405,7 +389,7 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
                     writeCloseFrameAndTerminate(
                             ctx,
                             CloseReason.UNSUPPORTED_DATA.getCode(),
-                            CloseReason.UNSUPPORTED_DATA.getReason() + ": " + "Received data cannot be data to target type: " + bodyArgument
+                            CloseReason.UNSUPPORTED_DATA.getReason() + ": " + "Received data cannot be converted to target type: " + bodyArgument
                     );
                 }
             }
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/websocket/NettyWebSocketSession.java b/http-netty/src/main/java/io/micronaut/http/netty/websocket/NettyWebSocketSession.java
index f20d00c67a..9d1b443643 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/websocket/NettyWebSocketSession.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/websocket/NettyWebSocketSession.java
@@ -24,7 +24,6 @@ import io.micronaut.core.convert.value.MutableConvertibleValues;
 import io.micronaut.core.convert.value.MutableConvertibleValuesMap;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 import io.micronaut.websocket.CloseReason;
 import io.micronaut.websocket.WebSocketSession;
@@ -65,6 +64,7 @@ public class NettyWebSocketSession implements WebSocketSession {
     private final HttpRequest<?> request;
     private final String protocolVersion;
     private final boolean isSecure;
+    private final MediaTypeCodecRegistry codecRegistry;
     private final MutableConvertibleValues<Object> attributes;
     private final WebSocketMessageEncoder messageEncoder;
 
@@ -74,7 +74,6 @@ public class NettyWebSocketSession implements WebSocketSession {
      * @param channel The channel
      * @param request The original request used to create the session
      * @param codecRegistry The codec registry
-     * @param handlerRegistry The handlers registry
      * @param protocolVersion The protocol version
      * @param isSecure Whether the session is secure
      */
@@ -83,7 +82,6 @@ public class NettyWebSocketSession implements WebSocketSession {
             Channel channel,
             HttpRequest<?> request,
             MediaTypeCodecRegistry codecRegistry,
-            MessageBodyHandlerRegistry handlerRegistry,
             String protocolVersion,
             boolean isSecure) {
         this.id = id;
@@ -92,7 +90,8 @@ public class NettyWebSocketSession implements WebSocketSession {
         this.protocolVersion = protocolVersion;
         this.isSecure = isSecure;
         this.channel.attr(WEB_SOCKET_SESSION_KEY).set(this);
-        this.messageEncoder = new WebSocketMessageEncoder(codecRegistry, handlerRegistry);
+        this.codecRegistry = codecRegistry;
+        this.messageEncoder = new WebSocketMessageEncoder(this.codecRegistry);
         this.attributes = request.getAttribute("micronaut.SESSION", MutableConvertibleValues.class).orElseGet(MutableConvertibleValuesMap::new);
     }
 
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/websocket/WebSocketMessageEncoder.java b/http-netty/src/main/java/io/micronaut/http/netty/websocket/WebSocketMessageEncoder.java
index cfe28bb3c0..90272d971b 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/websocket/WebSocketMessageEncoder.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/websocket/WebSocketMessageEncoder.java
@@ -17,22 +17,17 @@ package io.micronaut.http.netty.websocket;
 
 import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.context.annotation.Requires;
-import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.reflect.ClassUtils;
-import io.micronaut.core.type.Argument;
 import io.micronaut.http.MediaType;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
-import io.micronaut.http.body.MessageBodyWriter;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
-import io.micronaut.http.simple.SimpleHttpHeaders;
 import io.micronaut.websocket.exceptions.WebSocketSessionException;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
-import jakarta.inject.Inject;
 import jakarta.inject.Singleton;
 
 import java.nio.ByteBuffer;
@@ -49,28 +44,12 @@ import java.util.Optional;
 public class WebSocketMessageEncoder {
 
     private final MediaTypeCodecRegistry codecRegistry;
-    @Nullable
-    private final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
 
     /**
      * @param codecRegistry The codec registry
-     * @deprecated Not used anymore
      */
-    @Deprecated(forRemoval = true, since = "4.7")
     public WebSocketMessageEncoder(MediaTypeCodecRegistry codecRegistry) {
         this.codecRegistry = codecRegistry;
-        this.messageBodyHandlerRegistry = null;
-    }
-
-    /**
-     * @param codecRegistry The codec registry
-     * @param messageBodyHandlerRegistry The message body handler registry
-     */
-    @Inject
-    public WebSocketMessageEncoder(MediaTypeCodecRegistry codecRegistry,
-                                   MessageBodyHandlerRegistry messageBodyHandlerRegistry) {
-        this.codecRegistry = codecRegistry;
-        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
     }
 
     /**
@@ -90,26 +69,11 @@ public class WebSocketMessageEncoder {
         } else if (message instanceof ByteBuffer buffer) {
             return new BinaryWebSocketFrame(Unpooled.wrappedBuffer(buffer));
         } else {
-            MediaType theMediaType = mediaType != null ? mediaType : MediaType.APPLICATION_JSON_TYPE;
-            Optional<MediaTypeCodec> codec = codecRegistry.findCodec(theMediaType);
+            Optional<MediaTypeCodec> codec = codecRegistry.findCodec(mediaType != null ? mediaType : MediaType.APPLICATION_JSON_TYPE);
             if (codec.isPresent()) {
-                io.micronaut.core.io.buffer.ByteBuffer<?> encoded = codec.get().encode(message, NettyByteBufferFactory.DEFAULT);
+                io.micronaut.core.io.buffer.ByteBuffer encoded = codec.get().encode(message, new NettyByteBufferFactory(UnpooledByteBufAllocator.DEFAULT));
                 return new TextWebSocketFrame((ByteBuf) encoded.asNativeBuffer());
             }
-            if (messageBodyHandlerRegistry != null) {
-                Argument<Object> argument = Argument.ofInstance(message);
-                MessageBodyWriter<Object> messageBodyWriter = messageBodyHandlerRegistry.findWriter(argument, theMediaType).orElse(null);
-                if (messageBodyWriter != null) {
-                    io.micronaut.core.io.buffer.ByteBuffer<?> encoded = messageBodyWriter.writeTo(
-                        argument,
-                        theMediaType,
-                        message,
-                        new SimpleHttpHeaders(),
-                        NettyByteBufferFactory.DEFAULT
-                    );
-                    return new TextWebSocketFrame((ByteBuf) encoded.asNativeBuffer());
-                }
-            }
         }
         throw new WebSocketSessionException("Unable to encode WebSocket message: " + message);
     }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java
index 93c7037dc6..2caa735b95 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java
@@ -21,7 +21,7 @@ import io.micronaut.core.naming.Named;
 import io.micronaut.core.util.SupplierUtil;
 import io.micronaut.http.HttpVersion;
 import io.micronaut.http.netty.channel.ChannelPipelineCustomizer;
-import io.micronaut.http.netty.body.BodySizeLimits;
+import io.micronaut.http.server.netty.body.BodySizeLimits;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.netty.handler.Http2ServerHandler;
 import io.micronaut.http.server.netty.handler.PipeliningServerHandler;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpToHttpsRedirectHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpToHttpsRedirectHandler.java
index 3500956f15..63b6ccd512 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpToHttpsRedirectHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpToHttpsRedirectHandler.java
@@ -18,9 +18,9 @@ package io.micronaut.http.server.netty;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.http.HttpResponse;
+import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.netty.NettyHttpResponseBuilder;
-import io.micronaut.http.netty.body.AvailableNettyByteBody;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.netty.handler.OutboundAccess;
 import io.micronaut.http.server.netty.handler.RequestHandler;
@@ -28,6 +28,9 @@ import io.micronaut.http.server.util.HttpHostResolver;
 import io.micronaut.http.ssl.ServerSslConfiguration;
 import io.micronaut.http.uri.UriBuilder;
 import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpRequest;
 
 /**
@@ -63,11 +66,12 @@ record HttpToHttpsRedirectHandler(
         }
         uriBuilder.path(strippedRequest.getPath());
 
+        MutableHttpResponse<?> response = HttpResponse
+            .permanentRedirect(uriBuilder.build())
+            .header(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);
+        io.netty.handler.codec.http.HttpResponse nettyResponse = NettyHttpResponseBuilder.toHttpResponse(response);
         outboundAccess.closeAfterWrite();
-        outboundAccess.write(
-            NettyHttpResponseBuilder.toHttpResponse(HttpResponse.permanentRedirect(uriBuilder.build())),
-            AvailableNettyByteBody.empty()
-        );
+        outboundAccess.writeFull((FullHttpResponse) nettyResponse);
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
index 734411f717..9e58ab3e8d 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
@@ -59,8 +59,8 @@ import io.micronaut.http.netty.stream.DefaultStreamedHttpRequest;
 import io.micronaut.http.netty.stream.DelegateStreamedHttpRequest;
 import io.micronaut.http.netty.stream.StreamedHttpRequest;
 import io.micronaut.http.server.HttpServerConfiguration;
-import io.micronaut.http.netty.body.AvailableNettyByteBody;
-import io.micronaut.http.netty.body.NettyByteBody;
+import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.server.netty.body.NettyByteBody;
 import io.micronaut.http.server.netty.handler.Http2ServerHandler;
 import io.micronaut.http.server.netty.multipart.NettyCompletedFileUpload;
 import io.micronaut.web.router.DefaultUriRouteMatch;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyRequestLifecycle.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyRequestLifecycle.java
index 2ee6696860..f285a2c22d 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyRequestLifecycle.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyRequestLifecycle.java
@@ -27,7 +27,7 @@ import io.micronaut.http.annotation.Body;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.netty.NettyMutableHttpResponse;
 import io.micronaut.http.server.RequestLifecycle;
-import io.micronaut.http.netty.body.NettyByteBody;
+import io.micronaut.http.server.netty.body.NettyByteBody;
 import io.micronaut.http.server.netty.handler.OutboundAccess;
 import io.micronaut.http.server.types.files.FileCustomizableResponseType;
 import io.micronaut.http.server.types.files.StreamedFile;
@@ -74,37 +74,31 @@ final class NettyRequestLifecycle extends RequestLifecycle {
 
         ExecutionFlow<HttpResponse<?>> result;
 
-        // handle decoding failure
-        DecoderResult decoderResult = request.getNativeRequest().decoderResult();
-        if (decoderResult.isFailure()) {
-            Throwable cause = decoderResult.cause();
-            HttpStatus status = cause instanceof TooLongFrameException ? HttpStatus.REQUEST_ENTITY_TOO_LARGE : HttpStatus.BAD_REQUEST;
-            try {
+        try {
+            // handle decoding failure
+            DecoderResult decoderResult = request.getNativeRequest().decoderResult();
+            if (decoderResult.isFailure()) {
+                Throwable cause = decoderResult.cause();
+                HttpStatus status = cause instanceof TooLongFrameException ? HttpStatus.REQUEST_ENTITY_TOO_LARGE : HttpStatus.BAD_REQUEST;
                 result = onStatusError(
                     request,
                     HttpResponse.status(status),
                     status.getReason()
                 );
-            } catch (Exception e) {
-                result = ExecutionFlow.error(e);
-            }
-        } else {
-            try {
+            } else {
                 result = normalFlow(request);
-            } catch (Exception e) {
-                handleException(request, e);
-                return;
             }
-        }
-
-        ImperativeExecutionFlow<HttpResponse<?>> imperativeFlow = result.tryComplete();
-        if (imperativeFlow != null) {
-            Object value = ((ImperativeExecutionFlow<?>) imperativeFlow).getValue();
-            // usually this is a MutableHttpResponse, avoid scalability issues here
-            HttpResponse<?> response = value instanceof NettyMutableHttpResponse<?> mut ? mut : (HttpResponse<?>) value;
-            rib.writeResponse(outboundAccess, request, response, imperativeFlow.getError());
-        } else {
-            result.onComplete((response, throwable) -> rib.writeResponse(outboundAccess, request, response, throwable));
+            ImperativeExecutionFlow<HttpResponse<?>> imperativeFlow = result.tryComplete();
+            if (imperativeFlow != null) {
+                Object value = ((ImperativeExecutionFlow<?>) imperativeFlow).getValue();
+                // usually this is a MutableHttpResponse, avoid scalability issues here
+                HttpResponse<?> response = value instanceof NettyMutableHttpResponse<?> mut ? mut : (HttpResponse<?>) value;
+                rib.writeResponse(outboundAccess, request, response, imperativeFlow.getError());
+            } else {
+                result.onComplete((response, throwable) -> rib.writeResponse(outboundAccess, request, response, throwable));
+            }
+        } catch (Exception e) {
+            handleException(request, e);
         }
     }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
index b9dc9a37df..086caf41d1 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
@@ -23,15 +23,11 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.async.publisher.DelayedSubscriber;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.core.convert.ConversionService;
-import io.micronaut.core.execution.DelayedExecutionFlow;
-import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.propagation.PropagatedContext;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpAttributes;
 import io.micronaut.http.HttpMethod;
 import io.micronaut.http.HttpRequest;
@@ -42,8 +38,6 @@ import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.body.MediaTypeProvider;
 import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.body.MessageBodyWriter;
-import io.micronaut.http.body.ResponseBodyWriter;
-import io.micronaut.http.body.ResponseBodyWriterWrapper;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.context.ServerHttpRequestContext;
 import io.micronaut.http.context.ServerRequestContext;
@@ -52,14 +46,15 @@ import io.micronaut.http.exceptions.HttpStatusException;
 import io.micronaut.http.netty.EventLoopFlow;
 import io.micronaut.http.netty.NettyHttpResponseBuilder;
 import io.micronaut.http.netty.NettyMutableHttpResponse;
-import io.micronaut.http.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.netty.body.NettyBodyWriter;
 import io.micronaut.http.netty.body.NettyJsonHandler;
+import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.netty.channel.ChannelPipelineCustomizer;
 import io.micronaut.http.netty.stream.JsonSubscriber;
 import io.micronaut.http.netty.stream.StreamedHttpResponse;
 import io.micronaut.http.server.RouteExecutor;
 import io.micronaut.http.server.binding.RequestArgumentSatisfier;
-import io.micronaut.http.server.netty.body.NettyBodyAdapter;
+import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.netty.handler.OutboundAccess;
 import io.micronaut.http.server.netty.handler.RequestHandler;
@@ -67,18 +62,20 @@ import io.micronaut.web.router.DefaultUrlRouteInfo;
 import io.micronaut.web.router.RouteInfo;
 import io.micronaut.web.router.resource.StaticResourceResolver;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.compression.DecompressionException;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpContent;
+import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.DefaultHttpRequest;
-import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.util.AttributeKey;
+import org.reactivestreams.Processor;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -90,11 +87,13 @@ import reactor.core.scheduler.Schedulers;
 
 import javax.net.ssl.SSLException;
 import java.io.IOException;
+import java.io.OutputStream;
 import java.nio.channels.ClosedChannelException;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 import java.util.concurrent.ExecutorService;
+import java.util.function.BiConsumer;
 import java.util.function.Supplier;
 import java.util.regex.Pattern;
 
@@ -245,9 +244,9 @@ public final class RoutingInBoundHandler implements RequestHandler {
             response = routeExecutor.createDefaultErrorResponse(nettyHttpRequest, throwable);
         }
         if (response != null) {
-            ExecutionFlow<ByteBodyHttpResponse<?>> finalResponse;
             try {
-                finalResponse = encodeHttpResponse(
+                encodeHttpResponse(
+                    outboundAccess,
                     nettyHttpRequest,
                     response,
                     response.body()
@@ -255,59 +254,27 @@ public final class RoutingInBoundHandler implements RequestHandler {
             } catch (Throwable e) {
                 try {
                     response = routeExecutor.createDefaultErrorResponse(nettyHttpRequest, e);
-                    finalResponse = encodeHttpResponse(
+                    encodeHttpResponse(
+                        outboundAccess,
                         nettyHttpRequest,
                         response,
                         response.body()
                     );
                 } catch (Throwable f) {
                     f.addSuppressed(e);
-                    finalResponse = ExecutionFlow.error(f);
+                    outboundAccess.closeAfterWrite();
                     try {
-                        outboundAccess.closeAfterWrite();
-                        outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.INTERNAL_SERVER_ERROR), AvailableNettyByteBody.empty());
+                        outboundAccess.writeFull(new DefaultFullHttpResponse(
+                            HttpVersion.HTTP_1_1,
+                            HttpResponseStatus.INTERNAL_SERVER_ERROR,
+                            Unpooled.EMPTY_BUFFER
+                        ));
                     } catch (Throwable g) {
                         f.addSuppressed(g);
                     }
                     LOG.warn("Failed to encode error response", f);
                 }
             }
-            finalResponse.onComplete((r, t) -> {
-                ByteBodyHttpResponse<?> encodedResponse;
-                if (t != null) {
-                    // fallback of the fallback...
-                    encodedResponse = ByteBodyHttpResponseWrapper.wrap(HttpResponse.serverError(), AvailableNettyByteBody.empty());
-                } else {
-                    encodedResponse = r;
-                }
-                try (encodedResponse) {
-                    closeConnectionIfError(encodedResponse, nettyHttpRequest, outboundAccess);
-                    if (LOG.isDebugEnabled()) {
-                        LOG.debug("Response {} - {} {}",
-                            encodedResponse.code(),
-                            nettyHttpRequest.getMethodName(),
-                            nettyHttpRequest.getUri());
-                    }
-                    io.netty.handler.codec.http.HttpResponse noBodyResponse = NettyMutableHttpResponse.toNoBodyResponse(encodedResponse);
-                    if (nettyHttpRequest.getMethod() == HttpMethod.HEAD) {
-                        outboundAccess.writeHeadResponse(new DefaultHttpResponse(
-                            noBodyResponse.protocolVersion(),
-                            noBodyResponse.status(),
-                            noBodyResponse.headers()
-                        ));
-                    } else {
-                        outboundAccess.write(noBodyResponse, encodedResponse.byteBody());
-                    }
-                } catch (Throwable u) {
-                    if (t != null) {
-                        u.addSuppressed(t);
-                    }
-                    t = u;
-                }
-                if (t != null) {
-                    LOG.warn("Failed to build error response", t);
-                }
-            });
         }
     }
 
@@ -326,7 +293,8 @@ public final class RoutingInBoundHandler implements RequestHandler {
     }
 
     @SuppressWarnings("unchecked")
-    private ExecutionFlow<ByteBodyHttpResponse<?>> encodeHttpResponse(
+    private void encodeHttpResponse(
+        OutboundAccess outboundAccess,
         NettyHttpRequest<?> nettyRequest,
         HttpResponse<?> httpResponse,
         Object body) {
@@ -338,7 +306,12 @@ public final class RoutingInBoundHandler implements RequestHandler {
 
             if (Publishers.isConvertibleToPublisher(body)) {
                 response.body(null);
-                return writeStreamedWithErrorHandling(nettyRequest, response, mapToHttpContent(nettyRequest, response, body, routeInfo, nettyRequest.getChannelHandlerContext()));
+                DelegateStreamedHttpResponse streamedResponse = new DelegateStreamedHttpResponse(
+                    toNettyResponse(response),
+                    mapToHttpContent(nettyRequest, response, body, routeInfo, nettyRequest.getChannelHandlerContext())
+                );
+                writeStreamedWithErrorHandling(nettyRequest, outboundAccess, streamedResponse);
+                return;
             }
 
             // avoid checkcast for MessageBodyWriter interface here
@@ -372,46 +345,61 @@ public final class RoutingInBoundHandler implements RequestHandler {
             }
             if (messageBodyWriter == null || !responseBodyType.isInstance(body) || !messageBodyWriter.isWriteable(responseBodyType, responseMediaType)) {
                 responseBodyType = Argument.ofInstance(body);
-                messageBodyWriter = this.messageBodyHandlerRegistry.getWriter(responseBodyType, List.of(responseMediaType));
+                messageBodyWriter = this.messageBodyHandlerRegistry
+                    .findWriter(responseBodyType, List.of(responseMediaType))
+                    .orElse(null);
+            }
+            NettyBodyWriter<Object> closure = wrap(messageBodyWriter);
+            closeConnectionIfError(response, nettyRequest, outboundAccess);
+            if (closure.isBlocking()) {
+                MediaType finalResponseMediaType = responseMediaType;
+                Argument<Object> finalResponseBodyType = responseBodyType;
+                getIoExecutor().execute(() -> writeNettyMessageBody(nettyRequest, (MutableHttpResponse<Object>) response, finalResponseBodyType, finalResponseMediaType, body, closure, outboundAccess, true));
+            } else {
+                writeNettyMessageBody(nettyRequest, (MutableHttpResponse<Object>) response, responseBodyType, responseMediaType, body, closure, outboundAccess, false);
             }
-            return buildFinalResponse(nettyRequest, (MutableHttpResponse<Object>) response, responseBodyType, responseMediaType, body, messageBodyWriter, false);
         } else {
             response.body(null);
-            return writeFinalNettyResponse(
+            writeFinalNettyResponse(
                 response,
-                nettyRequest
+                nettyRequest,
+                outboundAccess
             );
         }
     }
 
-    private <T> ExecutionFlow<ByteBodyHttpResponse<?>> buildFinalResponse(NettyHttpRequest<?> nettyRequest,
-                                                                          MutableHttpResponse<T> response,
-                                                                          Argument<T> responseBodyType,
-                                                                          MediaType mediaType,
-                                                                          T body,
-                                                                          MessageBodyWriter<T> messageBodyWriter,
-                                                                          boolean onIoExecutor) {
-        if (!onIoExecutor && messageBodyWriter.isBlocking()) {
-            return ExecutionFlow.async(getIoExecutor(), () -> buildFinalResponse(nettyRequest, response, responseBodyType, mediaType, body, messageBodyWriter, true));
-        }
-
-        NettyByteBufferFactory bufferFactory = new NettyByteBufferFactory(nettyRequest.getChannelHandlerContext().alloc());
+    private void writeNettyMessageBody(
+        NettyHttpRequest<?> nettyRequest,
+        MutableHttpResponse<Object> response,
+        Argument<Object> responseBodyType,
+        MediaType mediaType,
+        Object body,
+        NettyBodyWriter<Object> nettyMessageBodyWriter,
+        OutboundAccess outboundAccess,
+        boolean onIoExecutor) {
         try {
-            return ExecutionFlow.just(NettyResponseBodyWriterWrapper.wrap(messageBodyWriter)
-                .write(bufferFactory, nettyRequest, response, responseBodyType, mediaType, body));
+            nettyMessageBodyWriter.writeTo(
+                nettyRequest,
+                response,
+                responseBodyType,
+                mediaType,
+                body, outboundAccess);
         } catch (CodecException e) {
             final MutableHttpResponse<Object> errorResponse = (MutableHttpResponse<Object>) routeExecutor.createDefaultErrorResponse(nettyRequest, e);
-            Object errorBody = errorResponse.body();
-            Argument<Object> type = Argument.ofInstance(errorBody);
-            MediaType errorContentType = errorResponse.getContentType().orElse(MediaType.APPLICATION_JSON_TYPE);
-            MessageBodyWriter<Object> errorBodyWriter = messageBodyHandlerRegistry.getWriter(type, List.of(errorContentType));
-            if (!onIoExecutor && errorBodyWriter.isBlocking()) {
-                return ExecutionFlow.async(getIoExecutor(), () -> ExecutionFlow.just(NettyResponseBodyWriterWrapper.wrap(errorBodyWriter)
-                    .write(bufferFactory, nettyRequest, errorResponse, type, errorContentType, errorBody)));
-            } else {
-                return ExecutionFlow.just(NettyResponseBodyWriterWrapper.wrap(errorBodyWriter)
-                    .write(bufferFactory, nettyRequest, errorResponse, type, errorContentType, errorBody));
-            }
+            writeError(nettyRequest, outboundAccess, onIoExecutor, errorResponse);
+        }
+    }
+
+    private void writeError(NettyHttpRequest<?> nettyRequest, OutboundAccess outboundAccess, boolean onIoExecutor, MutableHttpResponse<Object> errorResponse) {
+        Object errorBody = errorResponse.body();
+        Argument<Object> type = Argument.ofInstance(errorBody);
+        MediaType errorContentType = errorResponse.getContentType().orElse(MediaType.APPLICATION_JSON_TYPE);
+        MessageBodyWriter<Object> messageBodyWriter = messageBodyHandlerRegistry.getWriter(type, List.of(errorContentType));
+        NettyBodyWriter<Object> nettyWriter = wrap(messageBodyWriter);
+        if (onIoExecutor || !nettyWriter.isBlocking()) {
+            nettyWriter.writeTo(nettyRequest, errorResponse, type, errorContentType, errorBody, outboundAccess);
+        } else {
+            ioExecutor.execute(() -> nettyWriter.writeTo(nettyRequest, errorResponse, type, errorContentType, errorBody, outboundAccess));
         }
     }
 
@@ -439,7 +427,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
 
                 if (messageBodyWriter == null || !responseBodyType.isInstance(message) || !messageBodyWriter.isWriteable(responseBodyType, finalMediaType)) {
                     responseBodyType = Argument.ofInstance(message);
-                    messageBodyWriter = ResponseBodyWriter.wrap(messageBodyHandlerRegistry.getWriter(responseBodyType, List.of(finalMediaType)));
+                    messageBodyWriter = messageBodyHandlerRegistry.getWriter(responseBodyType, List.of(finalMediaType));
                 }
                 return writeAsync(
                     messageBodyWriter,
@@ -488,22 +476,46 @@ public final class RoutingInBoundHandler implements RequestHandler {
         }
     }
 
-    private ExecutionFlow<ByteBodyHttpResponse<?>> writeFinalNettyResponse(MutableHttpResponse<?> message, NettyHttpRequest<?> request) {
+    private void writeFinalNettyResponse(MutableHttpResponse<?> message, NettyHttpRequest<?> request, OutboundAccess outboundAccess) {
+        // default Connection header if not set explicitly
+        closeConnectionIfError(message, request, outboundAccess);
         io.netty.handler.codec.http.HttpResponse nettyResponse = NettyHttpResponseBuilder.toHttpResponse(message);
         if (nettyResponse instanceof StreamedHttpResponse streamed) {
-            return writeStreamedWithErrorHandling(request, message, streamed);
+            writeStreamedWithErrorHandling(request, outboundAccess, streamed);
         } else {
-            return ExecutionFlow.just(ByteBodyHttpResponseWrapper.wrap(message, new AvailableNettyByteBody(((FullHttpResponse) nettyResponse).content())));
+            FullHttpResponse fullResponse = (FullHttpResponse) nettyResponse;
+            outboundAccess.writeFull(fullResponse, request.getMethod() == HttpMethod.HEAD);
         }
+
+        log(request, nettyResponse);
+    }
+
+    private void writeFinalFullNettyResponse(MutableHttpResponse<?> message,
+                                             NettyHttpRequest<?> request,
+                                             OutboundAccess outboundAccess,
+                                             ByteBuf byteBuf) {
+        // default Connection header if not set explicitly
+        closeConnectionIfError(message, request, outboundAccess);
+        FullHttpResponse fullResponse = NettyHttpResponseBuilder.toFullHttpResponse(message, byteBuf);
+        outboundAccess.writeFull(fullResponse, request.getMethod() == HttpMethod.HEAD);
+        log(request, fullResponse);
     }
 
-    private ExecutionFlow<ByteBodyHttpResponse<?>> writeStreamedWithErrorHandling(NettyHttpRequest<?> request, HttpResponse<?> response, Publisher<HttpContent> streamed) {
-        LazySendingSubscriber sub = new LazySendingSubscriber(request, response);
+    private void log(HttpRequest<?> request, io.netty.handler.codec.http.HttpResponse nettyResponse) {
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Response {} - {} {}",
+                nettyResponse.status().code(),
+                request.getMethodName(),
+                request.getUri());
+        }
+    }
+
+    private void writeStreamedWithErrorHandling(NettyHttpRequest<?> request, OutboundAccess outboundAccess, StreamedHttpResponse streamed) {
+        LazySendingSubscriber sub = new LazySendingSubscriber(request, streamed, outboundAccess);
         streamed.subscribe(sub);
-        return sub.output;
     }
 
-    private void closeConnectionIfError(HttpResponse<?> message, HttpRequest<?> request, OutboundAccess outboundAccess) {
+    private void closeConnectionIfError(MutableHttpResponse<?> message, HttpRequest<?> request, OutboundAccess outboundAccess) {
         boolean decodeError = request instanceof NettyHttpRequest<?> nettyRequest &&
             nettyRequest.getNativeRequest().decoderResult().isFailure();
 
@@ -512,6 +524,28 @@ public final class RoutingInBoundHandler implements RequestHandler {
         }
     }
 
+    @NonNull
+    private io.netty.handler.codec.http.HttpResponse toNettyResponse(HttpResponse<?> message) {
+        if (message instanceof NettyHttpResponseBuilder builder) {
+            return builder.toHttpResponse();
+        } else {
+            return createNettyResponse(message).toHttpResponse();
+        }
+    }
+
+    @NonNull
+    private NettyMutableHttpResponse<?> createNettyResponse(HttpResponse<?> message) {
+        Object body = message.body();
+        io.netty.handler.codec.http.HttpHeaders nettyHeaders = new DefaultHttpHeaders(serverConfiguration.isValidateHeaders());
+        message.getHeaders().forEach((BiConsumer<String, List<String>>) nettyHeaders::set);
+        return new NettyMutableHttpResponse<>(
+            HttpVersion.HTTP_1_1,
+            HttpResponseStatus.valueOf(message.code(), message.reason()),
+            body instanceof ByteBuf ? body : null,
+            conversionService
+        );
+    }
+
     /**
      * Is the exception ignorable by Micronaut.
      *
@@ -526,33 +560,85 @@ public final class RoutingInBoundHandler implements RequestHandler {
         return cause instanceof IOException && message != null && IGNORABLE_ERROR_MESSAGE.matcher(message).matches();
     }
 
+    <T> NettyBodyWriter<T> wrap(MessageBodyWriter<T> closure) {
+        if (closure instanceof NettyJsonHandler<T> nettyClosure) {
+            // also covered by the next if, but this is slightly faster than an interface check
+            return nettyClosure;
+        } else if (closure instanceof NettyBodyWriter<T> nettyClosure) {
+            return nettyClosure;
+        } else {
+            return new CompatNettyWriteClosure<>(closure);
+        }
+    }
+
+    private final class CompatNettyWriteClosure<T> implements NettyBodyWriter<T> {
+        private final MessageBodyWriter<T> delegate;
+
+        CompatNettyWriteClosure(MessageBodyWriter<T> delegate) {
+            assert !(delegate instanceof NettyBodyWriter) : "please create using wrap()";
+            this.delegate = delegate;
+        }
+
+        @Override
+        public boolean isBlocking() {
+            return delegate.isBlocking();
+        }
+
+        @Override
+        public void writeTo(HttpRequest<?> request, MutableHttpResponse<T> outgoingResponse, Argument<T> type, MediaType mediaType, T object, NettyWriteContext nettyContext) throws CodecException {
+            NettyByteBufferFactory bufferFactory = new NettyByteBufferFactory(nettyContext.alloc());
+            ByteBuffer<?> byteBuffer = delegate.writeTo(
+                type,
+                mediaType,
+                object,
+                outgoingResponse.getHeaders(),
+                bufferFactory);
+            ByteBuf buffer = (ByteBuf) byteBuffer.asNativeBuffer();
+            writeFinalFullNettyResponse(outgoingResponse,
+                (NettyHttpRequest<?>) request,
+                (OutboundAccess) nettyContext,
+                buffer);
+        }
+
+        @Override
+        public void writeTo(Argument<T> type, MediaType mediaType, T object, MutableHeaders outgoingHeaders, OutputStream outputStream) throws CodecException {
+            delegate.writeTo(type, mediaType, object, outgoingHeaders, outputStream);
+        }
+
+        @Override
+        public ByteBuffer<?> writeTo(Argument<T> type, MediaType mediaType, T object, MutableHeaders outgoingHeaders, ByteBufferFactory<?, ?> bufferFactory) throws CodecException {
+            return delegate.writeTo(type, mediaType, object, outgoingHeaders, bufferFactory);
+        }
+    }
+
     /**
      * This processor waits for the first item before sending the response, and handles errors if they
      * appear as the first item.
      */
-    private final class LazySendingSubscriber implements Subscriber<HttpContent>, Publisher<ByteBuf> {
+    private final class LazySendingSubscriber implements Processor<HttpContent, HttpContent> {
         private static final Object COMPLETE = new Object();
 
         boolean headersSent = false;
         Subscription upstream;
-        final DelayedSubscriber<ByteBuf> downstream = new DelayedSubscriber<>();
+        final DelayedSubscriber<HttpContent> downstream = new DelayedSubscriber<>();
         @Nullable
         HttpContent first;
         Object completion = null; // in case first hasn't been consumed we need to delay completion
 
         private final EventLoopFlow flow;
         private final NettyHttpRequest<?> request;
-        private final HttpResponse<?> headers;
-        private final DelayedExecutionFlow<ByteBodyHttpResponse<?>> output = DelayedExecutionFlow.create();
+        private final io.netty.handler.codec.http.HttpResponse headers;
+        private final OutboundAccess outboundAccess;
 
-        private LazySendingSubscriber(NettyHttpRequest<?> request, HttpResponse<?> headers) {
+        private LazySendingSubscriber(NettyHttpRequest<?> request, io.netty.handler.codec.http.HttpResponse headers, OutboundAccess outboundAccess) {
             this.request = request;
             this.headers = headers;
+            this.outboundAccess = outboundAccess;
             this.flow = new EventLoopFlow(request.getChannelHandlerContext().channel().eventLoop());
         }
 
         @Override
-        public void subscribe(Subscriber<? super ByteBuf> s) {
+        public void subscribe(Subscriber<? super HttpContent> s) {
             downstream.onSubscribe(new Subscription() {
                 @Override
                 public void request(long n) {
@@ -560,7 +646,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
                     if (first != null) {
                         LazySendingSubscriber.this.first = null;
                         // onNext may trigger further request calls
-                        s.onNext(first.content());
+                        s.onNext(first);
                         if (completion != null) {
                             if (completion == COMPLETE) {
                                 s.onComplete();
@@ -606,11 +692,11 @@ public final class RoutingInBoundHandler implements RequestHandler {
 
         private void onNext0(HttpContent httpContent) {
             if (headersSent) {
-                downstream.onNext(httpContent.content());
+                downstream.onNext(httpContent);
             } else {
                 first = httpContent;
                 headersSent = true;
-                output.complete(ByteBodyHttpResponseWrapper.wrap(headers, NettyBodyAdapter.adapt(this, request.getChannelHandlerContext().channel().eventLoop())));
+                outboundAccess.writeStreamed(headers, this);
             }
         }
 
@@ -642,11 +728,12 @@ public final class RoutingInBoundHandler implements RequestHandler {
                 } else {
                     response = routeExecutor.createDefaultErrorResponse(request, t);
                 }
-                output.completeFrom(encodeHttpResponse(
+                encodeHttpResponse(
+                    outboundAccess,
                     request,
                     response,
                     response.body()
-                ));
+                );
             }
         }
 
@@ -666,43 +753,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
                 }
             } else {
                 headersSent = true;
-                output.complete(ByteBodyHttpResponseWrapper.wrap(headers, AvailableNettyByteBody.empty()));
-            }
-        }
-    }
-
-    /**
-     * Replacement for {@link ResponseBodyWriterWrapper} that uses a netty {@link ByteBuf} instead
-     * of a byte array as the backing store.
-     *
-     * @param <T> Body type
-     */
-    private static final class NettyResponseBodyWriterWrapper<T> extends ResponseBodyWriterWrapper<T> {
-        private NettyResponseBodyWriterWrapper(MessageBodyWriter<T> wrapped) {
-            super(wrapped);
-        }
-
-        static <T> ResponseBodyWriter<T> wrap(MessageBodyWriter<T> mbw) {
-            if (mbw instanceof ResponseBodyWriter<T> rbw) {
-                return rbw;
-            } else {
-                return new NettyResponseBodyWriterWrapper<>(mbw);
-            }
-        }
-
-        @Override
-        public @NonNull ByteBodyHttpResponse<?> write(@NonNull ByteBufferFactory<?, ?> bufferFactory, @NonNull HttpRequest<?> request, @NonNull MutableHttpResponse<T> httpResponse, @NonNull Argument<T> type, @NonNull MediaType mediaType, T object) throws CodecException {
-            ByteBuf buf = ((NettyByteBufferFactory) bufferFactory).buffer().asNativeBuffer();
-            ByteBufOutputStream bbos = new ByteBufOutputStream(buf);
-            boolean release = true;
-            try {
-                writeTo(type, mediaType, object, httpResponse.getHeaders(), bbos);
-                release = false;
-                return ByteBodyHttpResponseWrapper.wrap(httpResponse, new AvailableNettyByteBody(buf));
-            } finally {
-                if (release) {
-                    buf.release();
-                }
+                outboundAccess.writeStreamed(headers, Flux.empty());
             }
         }
     }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyBodyAnnotationBinder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyBodyAnnotationBinder.java
index a5b8220202..b54d7b7ca8 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyBodyAnnotationBinder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyBodyAnnotationBinder.java
@@ -43,7 +43,7 @@ import io.micronaut.http.server.netty.FormDataHttpContentProcessor;
 import io.micronaut.http.server.netty.FormRouteCompleter;
 import io.micronaut.http.server.netty.MicronautHttpData;
 import io.micronaut.http.server.netty.NettyHttpRequest;
-import io.micronaut.http.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.netty.converters.NettyConverters;
 import io.micronaut.web.router.RouteInfo;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AbstractFileBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AbstractFileBodyWriter.java
index 389e5d2398..cd7f3ccb82 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AbstractFileBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AbstractFileBodyWriter.java
@@ -17,16 +17,15 @@ package io.micronaut.http.server.netty.body;
 
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpResponse;
 import io.micronaut.http.MutableHttpHeaders;
 import io.micronaut.http.MutableHttpResponse;
-import io.micronaut.http.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.netty.NettyMutableHttpResponse;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.types.files.FileCustomizableResponseType;
+import io.netty.handler.codec.http.FullHttpResponse;
 
 import java.time.LocalDateTime;
 import java.time.ZonedDateTime;
@@ -54,7 +53,7 @@ abstract sealed class AbstractFileBodyWriter permits InputStreamBodyWriter, Stre
         });
     }
 
-    protected boolean handleIfModifiedAndHeaders(HttpRequest<?> request, MutableHttpResponse<?> response, FileCustomizableResponseType systemFile, MutableHttpResponse<?> nettyResponse) {
+    protected boolean handleIfModifiedAndHeaders(HttpRequest<?> request, MutableHttpResponse<?> response, FileCustomizableResponseType systemFile, NettyMutableHttpResponse<?> nettyResponse) {
         long lastModified = systemFile.getLastModified();
 
         // Cache Validation
@@ -118,10 +117,10 @@ abstract sealed class AbstractFileBodyWriter permits InputStreamBodyWriter, Stre
         headers.date(now);
     }
 
-    protected ByteBodyHttpResponse<?> notModified(MutableHttpResponse<?> originalResponse) {
-        MutableHttpResponse<Void> response = HttpResponse.notModified();
+    protected FullHttpResponse notModified(MutableHttpResponse<?> originalResponse) {
+        MutableHttpResponse response = HttpResponse.notModified();
         AbstractFileBodyWriter.copyNonEntityHeaders(originalResponse, response);
         setDateHeader(response);
-        return ByteBodyHttpResponseWrapper.wrap(response, AvailableNettyByteBody.empty());
+        return ((NettyMutableHttpResponse) response).toFullHttpResponse();
     }
 }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AvailableNettyByteBody.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AvailableNettyByteBody.java
new file mode 100644
index 0000000000..e003ca5519
--- /dev/null
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AvailableNettyByteBody.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.netty.body;
+
+import io.micronaut.buffer.netty.NettyByteBufferFactory;
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.execution.ExecutionFlow;
+import io.micronaut.core.io.buffer.ByteBuffer;
+import io.micronaut.http.body.AvailableByteBody;
+import io.micronaut.http.body.CloseableAvailableByteBody;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.buffer.Unpooled;
+import reactor.core.publisher.Flux;
+
+import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.util.Objects;
+
+/**
+ * Netty ByteBuf implementation of ImmediateByteBody.
+ *
+ * @since 4.5.0
+ * @author Jonas Konrad
+ */
+@Internal
+public final class AvailableNettyByteBody extends NettyByteBody implements CloseableAvailableByteBody {
+    private final long length;
+    @Nullable
+    private ByteBuf buffer;
+
+    public AvailableNettyByteBody(@NonNull ByteBuf buffer) {
+        this.buffer = Objects.requireNonNull(buffer, "buffer");
+        this.length = buffer.readableBytes();
+    }
+
+    public static CloseableAvailableByteBody empty() {
+        return new AvailableNettyByteBody(Unpooled.EMPTY_BUFFER);
+    }
+
+    public static ByteBuf toByteBuf(AvailableByteBody body) {
+        if (body instanceof AvailableNettyByteBody net) {
+            return net.claim();
+        } else {
+            return Unpooled.wrappedBuffer(body.toByteArray());
+        }
+    }
+
+    public ByteBuf peek() {
+        ByteBuf b = buffer;
+        if (b == null) {
+            throw new IllegalStateException("Body already claimed.");
+        }
+        return b;
+    }
+
+    @Override
+    public @NonNull InputStream toInputStream() {
+        return new ByteBufInputStream(claim(), true);
+    }
+
+    @Override
+    public long length() {
+        return length;
+    }
+
+    @NonNull
+    private ByteBuf claim() {
+        ByteBuf b = buffer;
+        if (b == null) {
+            failClaim();
+        }
+        this.buffer = null;
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Body claimed at this location. This is not an error, but may aid in debugging other errors", new Exception());
+        }
+        return b;
+    }
+
+    @Override
+    public @NonNull ExecutionFlow<? extends CloseableAvailableByteBody> bufferFlow() {
+        return ExecutionFlow.just(new AvailableNettyByteBody(claim()));
+    }
+
+    @Override
+    public void close() {
+        ByteBuf b = buffer;
+        this.buffer = null;
+        if (b != null) {
+            b.release();
+        }
+    }
+
+    @Override
+    protected Flux<ByteBuf> toByteBufPublisher() {
+        return Flux.just(claim());
+    }
+
+    @Override
+    public byte @NonNull [] toByteArray() {
+        ByteBuf b = claim();
+        try {
+            return ByteBufUtil.getBytes(b);
+        } finally {
+            b.release();
+        }
+    }
+
+    @Override
+    public @NonNull ByteBuffer<?> toByteBuffer() {
+        return NettyByteBufferFactory.DEFAULT.wrap(claim());
+    }
+
+    @Override
+    public @NonNull String toString(Charset charset) {
+        ByteBuf b = claim();
+        try {
+            return b.toString(charset);
+        } finally {
+            b.release();
+        }
+    }
+
+    @Override
+    public @NonNull CloseableAvailableByteBody split() {
+        ByteBuf b = buffer;
+        if (b == null) {
+            failClaim();
+        }
+        if (LOG.isTraceEnabled()) {
+            LOG.trace("Body split at this location. This is not an error, but may aid in debugging other errors", new Exception());
+        }
+        return new AvailableNettyByteBody(b.retainedSlice());
+    }
+}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BodySizeLimits.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BodySizeLimits.java
new file mode 100644
index 0000000000..8c47f52b8c
--- /dev/null
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BodySizeLimits.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.netty.body;
+
+import io.micronaut.core.annotation.Internal;
+
+@Internal
+public record BodySizeLimits(long maxBodySize, long maxBufferSize) {
+    public static final BodySizeLimits UNLIMITED = new BodySizeLimits(Long.MAX_VALUE, Integer.MAX_VALUE);
+}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BufferConsumer.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BufferConsumer.java
new file mode 100644
index 0000000000..06e98efbd6
--- /dev/null
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BufferConsumer.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.netty.body;
+
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.http.body.ByteBody;
+import io.netty.buffer.ByteBuf;
+
+/**
+ * This is a netty-specific reactor-like API for streaming bytes. It's a bit better than reactor
+ * because it's more explicit about reference counting semantics, has more fine-grained controls
+ * for cancelling, and has more relaxed concurrency semantics.
+ *
+ * @since 4.5.0
+ * @author Jonas Konrad
+ */
+@Internal
+public interface BufferConsumer {
+    /**
+     * Consume a buffer. Release ownership is transferred to this consumer.
+     *
+     * @param buf The buffer to consume
+     */
+    void add(ByteBuf buf);
+
+    /**
+     * Signal normal completion of the stream.
+     */
+    void complete();
+
+    /**
+     * Signal that the upstream has discarded the remaining data, as requested by {@link Upstream#allowDiscard()}.
+     */
+    default void discard() {
+        error(ByteBody.BodyDiscardedException.create());
+    }
+
+    /**
+     * Signal an upstream error.
+     *
+     * @param e The error
+     */
+    void error(Throwable e);
+
+    /**
+     * This interface manages the backpressure for data consumptions. It is highly concurrent:
+     * Calls to {@link #onBytesConsumed(long)} may happen at the same time on different threads.
+     */
+    interface Upstream {
+        /**
+         * Signal that we want to start consuming bytes. This is an optional hint to the upstream,
+         * the upstream may ignore it and send bytes immediately. This is used for CONTINUE
+         * support.
+         */
+        default void start() {
+        }
+
+        /**
+         * Called when a number of bytes has been consumed by the downstream.
+         *
+         * @param bytesConsumed The number of bytes that were consumed
+         */
+        void onBytesConsumed(long bytesConsumed);
+
+        /**
+         * Allow the upstream to discard any further messages. Note that this does not actually
+         * mean the messages must be discarded: If another consumer still needs the body data, it
+         * may continue to be read and continue to be forwarded to this consumer.
+         */
+        default void allowDiscard() {
+        }
+
+        /**
+         * Instruct the upstream to ignore backpressure from this consumer. This is slightly
+         * different from {@code onBytesConsumed(Long.MAX_VALUE)}: If there are two consumers
+         * in {@link ByteBody.SplitBackpressureMode#FASTEST} mode,
+         * a MAX_VALUE requests all data from the common upstream, while a disregardBackpressure
+         * removes this downstream from consideration.
+         */
+        default void disregardBackpressure() {
+        }
+    }
+}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/FileBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/FileBodyWriter.java
index fe2e7151dd..24f9ddfc16 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/FileBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/FileBodyWriter.java
@@ -17,15 +17,14 @@ package io.micronaut.http.server.netty.body;
 
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
-import io.micronaut.http.ByteBodyHttpResponse;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
-import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.codec.CodecException;
+import io.micronaut.http.netty.body.NettyBodyWriter;
+import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.server.types.files.SystemFile;
 import jakarta.inject.Singleton;
 
@@ -41,7 +40,7 @@ import java.io.OutputStream;
 @Internal
 @Experimental
 @Singleton
-public final class FileBodyWriter implements ResponseBodyWriter<File> {
+public final class FileBodyWriter implements NettyBodyWriter<File> {
     private final SystemFileBodyWriter systemFileBodyWriter;
 
     public FileBodyWriter(SystemFileBodyWriter systemFileBodyWriter) {
@@ -49,10 +48,15 @@ public final class FileBodyWriter implements ResponseBodyWriter<File> {
     }
 
     @Override
-    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<File> outgoingResponse, Argument<File> type, MediaType mediaType, File object) throws CodecException {
+    public void writeTo(HttpRequest<?> request, MutableHttpResponse<File> outgoingResponse, Argument<File> type, MediaType mediaType, File object, NettyWriteContext nettyContext) throws CodecException {
         SystemFile systemFile = new SystemFile(object);
         MutableHttpResponse<SystemFile> newResponse = outgoingResponse.body(systemFile);
-        return systemFileBodyWriter.write(request, newResponse, systemFile);
+        systemFileBodyWriter.writeTo(
+            request,
+            newResponse,
+            systemFile,
+            nettyContext
+        );
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/InputStreamBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/InputStreamBodyWriter.java
index 9caa5ce87e..04789a8456 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/InputStreamBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/InputStreamBodyWriter.java
@@ -18,20 +18,19 @@ package io.micronaut.http.server.netty.body;
 import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
-import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.body.stream.InputStreamByteBody;
 import io.micronaut.http.codec.CodecException;
+import io.micronaut.http.netty.NettyMutableHttpResponse;
+import io.micronaut.http.netty.body.NettyBodyWriter;
+import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.scheduling.TaskExecutors;
-import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http.DefaultHttpResponse;
 import jakarta.inject.Named;
 import jakarta.inject.Singleton;
 
@@ -49,7 +48,7 @@ import java.util.concurrent.ExecutorService;
 @Internal
 @Experimental
 @Singleton
-public final class InputStreamBodyWriter extends AbstractFileBodyWriter implements ResponseBodyWriter<InputStream> {
+public final class InputStreamBodyWriter extends AbstractFileBodyWriter implements NettyBodyWriter<InputStream> {
     private final ExecutorService executorService;
 
     InputStreamBodyWriter(NettyHttpServerConfiguration.FileTypeHandlerConfiguration configuration, @Named(TaskExecutors.BLOCKING) ExecutorService executorService) {
@@ -58,9 +57,18 @@ public final class InputStreamBodyWriter extends AbstractFileBodyWriter implemen
     }
 
     @Override
-    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<InputStream> outgoingResponse, Argument<InputStream> type, MediaType mediaType, InputStream object) throws CodecException {
-        outgoingResponse.getHeaders().setIfMissing(HttpHeaderNames.CONTENT_TYPE, mediaType);
-        return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, InputStreamByteBody.create(object, OptionalLong.empty(), executorService, NettyByteBufferFactory.DEFAULT));
+    public void writeTo(HttpRequest<?> request, MutableHttpResponse<InputStream> outgoingResponse, Argument<InputStream> type, MediaType mediaType, InputStream object, NettyWriteContext nettyContext) throws CodecException {
+        if (outgoingResponse instanceof NettyMutableHttpResponse<?> nettyResponse) {
+            final DefaultHttpResponse finalResponse = new DefaultHttpResponse(
+                nettyResponse.getNettyHttpVersion(),
+                nettyResponse.getNettyHttpStatus(),
+                nettyResponse.getNettyHeaders()
+            );
+            //  can be null if the stream was closed
+            nettyContext.write(finalResponse, InputStreamByteBody.create(object, OptionalLong.empty(), executorService, NettyByteBufferFactory.DEFAULT));
+        } else {
+            throw new IllegalArgumentException("Unsupported response type. Not a Netty response: " + outgoingResponse);
+        }
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyBodyAdapter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyBodyAdapter.java
index 377c760893..05a5d85ff2 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyBodyAdapter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyBodyAdapter.java
@@ -20,11 +20,6 @@ import io.micronaut.core.annotation.NonNull;
 import io.micronaut.http.body.AvailableByteBody;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.netty.EventLoopFlow;
-import io.micronaut.http.netty.body.AvailableNettyByteBody;
-import io.micronaut.http.netty.body.BodySizeLimits;
-import io.micronaut.http.netty.body.BufferConsumer;
-import io.micronaut.http.netty.body.NettyByteBody;
-import io.micronaut.http.netty.body.StreamingNettyByteBody;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.EventLoop;
@@ -120,10 +115,10 @@ public final class NettyBodyAdapter implements BufferConsumer.Upstream, Subscrib
     @Override
     public void onSubscribe(Subscription s) {
         this.subscription = s;
+        long demand = this.demand.get();
+        s.request(demand);
         if (cancelled) {
             s.cancel();
-        } else {
-            s.request(1);
         }
     }
 
@@ -135,11 +130,8 @@ public final class NettyBodyAdapter implements BufferConsumer.Upstream, Subscrib
     }
 
     private void onNext0(ByteBuf bytes) {
-        long newDemand = demand.addAndGet(-bytes.readableBytes());
+        demand.addAndGet(-bytes.readableBytes());
         sharedBuffer.add(bytes);
-        if (newDemand > 0) {
-            subscription.request(1);
-        }
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyByteBody.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyByteBody.java
new file mode 100644
index 0000000000..f826f25bdc
--- /dev/null
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyByteBody.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.netty.body;
+
+import io.micronaut.buffer.netty.NettyByteBufferFactory;
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.execution.ExecutionFlow;
+import io.micronaut.core.io.buffer.ByteBuffer;
+import io.micronaut.http.body.ByteBody;
+import io.micronaut.http.body.CloseableAvailableByteBody;
+import io.micronaut.http.body.InternalByteBody;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.buffer.Unpooled;
+import org.reactivestreams.Publisher;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import reactor.core.publisher.Flux;
+
+/**
+ * Common base class for streaming and immediate netty ByteBody implementations.
+ *
+ * @since 4.5.0
+ * @author Jonas Konrad
+ */
+@Internal
+public abstract sealed class NettyByteBody implements ByteBody, InternalByteBody permits AvailableNettyByteBody, StreamingNettyByteBody {
+    // don't change this, isolate body buffering to separate logging name space
+    protected static final Logger LOG = LoggerFactory.getLogger(NettyByteBufferFactory.class);
+
+    public static Flux<ByteBuf> toByteBufs(ByteBody body) {
+        if (body instanceof NettyByteBody net) {
+            return net.toByteBufPublisher();
+        } else {
+            return Flux.from(body.toByteArrayPublisher()).map(Unpooled::wrappedBuffer);
+        }
+    }
+
+    @Override
+    public @NonNull Publisher<byte[]> toByteArrayPublisher() {
+        return toByteBufPublisher().map(bb -> {
+            try {
+                return ByteBufUtil.getBytes(bb);
+            } finally {
+                bb.release();
+            }
+        });
+    }
+
+    @Override
+    public @NonNull Publisher<ByteBuffer<?>> toByteBufferPublisher() {
+        return toByteBufPublisher().map(NettyByteBufferFactory.DEFAULT::wrap);
+    }
+
+    public abstract @NonNull ExecutionFlow<? extends CloseableAvailableByteBody> bufferFlow();
+
+    abstract Flux<ByteBuf> toByteBufPublisher();
+
+    static void failClaim() {
+        throw new IllegalStateException("Request body has already been claimed: Two conflicting sites are trying to access the request body. If this is intentional, the first user must ByteBody#split the body. To find out where the body was claimed, turn on TRACE logging for io.micronaut.http.server.netty.body.NettyByteBody.");
+    }
+}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamFileBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamFileBodyWriter.java
index 417d9ed0b5..344d965ec2 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamFileBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamFileBodyWriter.java
@@ -18,20 +18,23 @@ package io.micronaut.http.server.netty.body;
 import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
-import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.body.stream.InputStreamByteBody;
 import io.micronaut.http.codec.CodecException;
+import io.micronaut.http.netty.NettyMutableHttpResponse;
+import io.micronaut.http.netty.body.NettyBodyWriter;
+import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.types.files.StreamedFile;
 import io.micronaut.scheduling.TaskExecutors;
+import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http.HttpHeaderValues;
+import io.netty.handler.codec.http.HttpHeaders;
 import jakarta.inject.Named;
 import jakarta.inject.Singleton;
 
@@ -49,7 +52,7 @@ import java.util.concurrent.ExecutorService;
 @Singleton
 @Experimental
 @Internal
-public final class StreamFileBodyWriter extends AbstractFileBodyWriter implements ResponseBodyWriter<StreamedFile> {
+public final class StreamFileBodyWriter extends AbstractFileBodyWriter implements NettyBodyWriter<StreamedFile> {
     private final ExecutorService ioExecutor;
 
     StreamFileBodyWriter(NettyHttpServerConfiguration.FileTypeHandlerConfiguration configuration, @Named(TaskExecutors.BLOCKING) ExecutorService ioExecutor) {
@@ -58,13 +61,29 @@ public final class StreamFileBodyWriter extends AbstractFileBodyWriter implement
     }
 
     @Override
-    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<StreamedFile> outgoingResponse, Argument<StreamedFile> type, MediaType mediaType, StreamedFile object) throws CodecException {
-        if (handleIfModifiedAndHeaders(request, outgoingResponse, object, outgoingResponse)) {
-            return notModified(outgoingResponse);
+    public void writeTo(HttpRequest<?> request, MutableHttpResponse<StreamedFile> outgoingResponse, Argument<StreamedFile> type, MediaType mediaType, StreamedFile object, NettyWriteContext nettyContext) throws CodecException {
+        if (outgoingResponse instanceof NettyMutableHttpResponse<?> nettyResponse) {
+            if (handleIfModifiedAndHeaders(request, outgoingResponse, object, nettyResponse)) {
+                nettyContext.writeFull(notModified(outgoingResponse));
+            } else {
+                HttpHeaders nettyHeaders = nettyResponse.getNettyHeaders();
+                long length = object.getLength();
+                if (length > -1) {
+                    nettyHeaders.set(HttpHeaderNames.CONTENT_LENGTH, length);
+                } else {
+                    nettyHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
+                }
+                final DefaultHttpResponse finalResponse = new DefaultHttpResponse(
+                    nettyResponse.getNettyHttpVersion(),
+                    nettyResponse.getNettyHttpStatus(),
+                    nettyHeaders
+                );
+                InputStream inputStream = object.getInputStream();
+                nettyContext.write(finalResponse, InputStreamByteBody.create(inputStream, OptionalLong.empty(), ioExecutor, NettyByteBufferFactory.DEFAULT));
+            }
+
         } else {
-            long length = object.getLength();
-            InputStream inputStream = object.getInputStream();
-            return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, InputStreamByteBody.create(inputStream, length > -1 ? OptionalLong.of(length) : OptionalLong.empty(), ioExecutor, NettyByteBufferFactory.DEFAULT));
+            throw new IllegalArgumentException("Unsupported response type. Not a Netty response: " + outgoingResponse);
         }
     }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamingNettyByteBody.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamingNettyByteBody.java
new file mode 100644
index 0000000000..8d1df408be
--- /dev/null
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamingNettyByteBody.java
@@ -0,0 +1,544 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.netty.body;
+
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.execution.DelayedExecutionFlow;
+import io.micronaut.core.execution.ExecutionFlow;
+import io.micronaut.core.util.SupplierUtil;
+import io.micronaut.http.body.CloseableAvailableByteBody;
+import io.micronaut.http.body.CloseableByteBody;
+import io.micronaut.http.exceptions.BufferLengthExceededException;
+import io.micronaut.http.exceptions.ContentLengthExceededException;
+import io.micronaut.http.netty.EventLoopFlow;
+import io.micronaut.http.netty.PublisherAsBlocking;
+import io.micronaut.http.netty.PublisherAsStream;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.CompositeByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.EventLoop;
+import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.util.ReferenceCounted;
+import io.netty.util.ResourceLeakDetector;
+import io.netty.util.ResourceLeakDetectorFactory;
+import io.netty.util.ResourceLeakTracker;
+import reactor.core.publisher.Flux;
+import reactor.core.publisher.Sinks;
+
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.OptionalLong;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.function.Supplier;
+
+/**
+ * Netty implementation for streaming ByteBody.
+ *
+ * @since 4.5.0
+ * @author Jonas Konrad
+ */
+@Internal
+public final class StreamingNettyByteBody extends NettyByteBody implements CloseableByteBody {
+    private final SharedBuffer sharedBuffer;
+    private BufferConsumer.Upstream upstream;
+
+    public StreamingNettyByteBody(SharedBuffer sharedBuffer) {
+        this(sharedBuffer, sharedBuffer.rootUpstream);
+    }
+
+    private StreamingNettyByteBody(SharedBuffer sharedBuffer, BufferConsumer.Upstream upstream) {
+        this.sharedBuffer = sharedBuffer;
+        this.upstream = upstream;
+    }
+
+    public BufferConsumer.Upstream primary(BufferConsumer primary) {
+        BufferConsumer.Upstream upstream = this.upstream;
+        if (upstream == null) {
+            failClaim();
+        }
+        this.upstream = null;
+        sharedBuffer.subscribe(primary, upstream);
+        return upstream;
+    }
+
+    @Override
+    public @NonNull CloseableByteBody split(@NonNull SplitBackpressureMode backpressureMode) {
+        BufferConsumer.Upstream upstream = this.upstream;
+        if (upstream == null) {
+            failClaim();
+        }
+        UpstreamBalancer.UpstreamPair pair = UpstreamBalancer.balancer(upstream, backpressureMode);
+        this.upstream = pair.left();
+        this.sharedBuffer.reserve();
+        return new StreamingNettyByteBody(sharedBuffer, pair.right());
+    }
+
+    @Override
+    public @NonNull StreamingNettyByteBody allowDiscard() {
+        BufferConsumer.Upstream upstream = this.upstream;
+        if (upstream == null) {
+            failClaim();
+        }
+        upstream.allowDiscard();
+        return this;
+    }
+
+    @Override
+    protected Flux<ByteBuf> toByteBufPublisher() {
+        AtomicLong unconsumed = new AtomicLong(0);
+        Sinks.Many<ByteBuf> sink = Sinks.many().unicast().onBackpressureBuffer();
+        BufferConsumer.Upstream upstream = primary(new BufferConsumer() {
+            @Override
+            public void add(ByteBuf buf) {
+                long newLength = unconsumed.addAndGet(buf.readableBytes());
+                if (newLength > sharedBuffer.limits.maxBufferSize()) {
+                    sink.tryEmitError(new BufferLengthExceededException(sharedBuffer.limits.maxBufferSize(), newLength));
+                    buf.release();
+                } else {
+                    if (sink.tryEmitNext(buf) != Sinks.EmitResult.OK) {
+                        buf.release();
+                    }
+                }
+            }
+
+            @Override
+            public void complete() {
+                sink.tryEmitComplete();
+            }
+
+            @Override
+            public void error(Throwable e) {
+                sink.tryEmitError(e);
+            }
+        });
+        return sink.asFlux()
+            .doOnSubscribe(s -> upstream.start())
+            .doOnNext(bb -> {
+                unconsumed.addAndGet(-bb.readableBytes());
+                upstream.onBytesConsumed(bb.readableBytes());
+            })
+            .doOnDiscard(ByteBuf.class, ReferenceCounted::release)
+            .doOnCancel(() -> {
+                upstream.allowDiscard();
+                upstream.disregardBackpressure();
+            });
+    }
+
+    @Override
+    public @NonNull OptionalLong expectedLength() {
+        long l = sharedBuffer.expectedLength;
+        return l < 0 ? OptionalLong.empty() : OptionalLong.of(l);
+    }
+
+    @Override
+    public @NonNull InputStream toInputStream() {
+        PublisherAsBlocking<ByteBuf> blocking = new PublisherAsBlocking<>();
+        toByteBufPublisher().subscribe(blocking);
+        return new PublisherAsStream(blocking);
+    }
+
+    @Override
+    public @NonNull ExecutionFlow<? extends CloseableAvailableByteBody> bufferFlow() {
+        BufferConsumer.Upstream upstream = this.upstream;
+        if (upstream == null) {
+            failClaim();
+        }
+        this.upstream = null;
+        upstream.start();
+        upstream.onBytesConsumed(Long.MAX_VALUE);
+        return sharedBuffer.subscribeFull(upstream).map(AvailableNettyByteBody::new);
+    }
+
+    @Override
+    public void close() {
+        BufferConsumer.Upstream upstream = this.upstream;
+        if (upstream == null) {
+            return;
+        }
+        this.upstream = null;
+        upstream.allowDiscard();
+        upstream.disregardBackpressure();
+        upstream.start();
+        sharedBuffer.subscribe(null, upstream);
+    }
+
+    /**
+     * This class buffers input data and distributes it to multiple {@link StreamingNettyByteBody}
+     * instances.
+     * <p>Thread safety: The {@link BufferConsumer} methods <i>must</i> only be called from one
+     * thread, the {@link #eventLoopFlow} thread. The other methods (subscribe, reserve) can be
+     * called from any thread.
+     */
+    public static final class SharedBuffer implements BufferConsumer {
+        private static final Supplier<ResourceLeakDetector<SharedBuffer>> LEAK_DETECTOR = SupplierUtil.memoized(() ->
+            ResourceLeakDetectorFactory.instance().newResourceLeakDetector(SharedBuffer.class));
+
+        @Nullable
+        private final ResourceLeakTracker<SharedBuffer> tracker = LEAK_DETECTOR.get().track(this);
+
+        private final EventLoopFlow eventLoopFlow;
+        private final BodySizeLimits limits;
+        /**
+         * Upstream of all subscribers. This is only used to cancel incoming data if the max
+         * request size is exceeded.
+         */
+        private final Upstream rootUpstream;
+        /**
+         * Buffered data. This is forwarded to new subscribers.
+         */
+        private CompositeByteBuf buffer;
+        /**
+         * Whether the input is complete.
+         */
+        private boolean complete;
+        /**
+         * Any stream error.
+         */
+        private Throwable error;
+        /**
+         * Number of reserved subscriber spots. A new subscription MUST be preceded by a
+         * reservation, and every reservation MUST have a subscription.
+         */
+        private int reserved = 1;
+        /**
+         * Active subscribers.
+         */
+        private List<@NonNull BufferConsumer> subscribers;
+        /**
+         * Active subscribers that need the fully buffered body.
+         */
+        private List<@NonNull DelayedExecutionFlow<ByteBuf>> fullSubscribers;
+        /**
+         * This flag is only used in tests, to verify that the BufferConsumer methods arent called
+         * in a reentrant fashion.
+         */
+        private boolean working = false;
+        /**
+         * Number of bytes received so far.
+         */
+        private long lengthSoFar = 0;
+        /**
+         * The expected length of the whole body. This is -1 if we're uncertain, otherwise it must
+         * be accurate. This can come from a content-length header, but it's also set once the full
+         * body has been received.
+         */
+        private volatile long expectedLength = -1;
+
+        public SharedBuffer(EventLoop loop, BodySizeLimits limits, Upstream rootUpstream) {
+            this.eventLoopFlow = new EventLoopFlow(loop);
+            this.limits = limits;
+            this.rootUpstream = rootUpstream;
+        }
+
+        public void setExpectedLengthFrom(HttpHeaders headers) {
+            String s = headers.get(HttpHeaderNames.CONTENT_LENGTH);
+            if (s == null) {
+                return;
+            }
+            long parsed;
+            try {
+                parsed = Long.parseLong(s);
+            } catch (NumberFormatException e) {
+                return;
+            }
+            if (parsed < 0) {
+                return;
+            }
+            if (parsed > limits.maxBodySize()) {
+                error(new ContentLengthExceededException(limits.maxBodySize(), parsed));
+            }
+            setExpectedLength(parsed);
+        }
+
+        public void setExpectedLength(long length) {
+            if (length < 0) {
+                throw new IllegalArgumentException("Should be > 0");
+            }
+            this.expectedLength = length;
+        }
+
+        void reserve() {
+            if (eventLoopFlow.executeNow(this::reserve0)) {
+                reserve0();
+            }
+        }
+
+        private void reserve0() {
+            if (reserved == 0) {
+                throw new IllegalStateException("Cannot go from streaming state back to buffering state");
+            }
+            reserved++;
+            if (tracker != null) {
+                tracker.record();
+            }
+        }
+
+        /**
+         * Add a subscriber. Must be preceded by a reservation.
+         *
+         * @param subscriber       The subscriber to add. Can be {@code null}, then the bytes will just be discarded
+         * @param specificUpstream The upstream for the subscriber. This is used to call allowDiscard if there was an error
+         */
+        void subscribe(@Nullable BufferConsumer subscriber, Upstream specificUpstream) {
+            if (eventLoopFlow.executeNow(() -> subscribe0(subscriber, specificUpstream))) {
+                subscribe0(subscriber, specificUpstream);
+            }
+        }
+
+        private void subscribe0(@Nullable BufferConsumer subscriber, Upstream specificUpstream) {
+            assert !working;
+
+            if (reserved == 0) {
+                throw new IllegalStateException("Need to reserve a spot first");
+            }
+
+            working = true;
+            boolean last = --reserved == 0;
+            if (subscriber != null) {
+                if (subscribers == null) {
+                    subscribers = new ArrayList<>(1);
+                }
+                subscribers.add(subscriber);
+                if (buffer != null) {
+                    if (last) {
+                        subscriber.add(buffer.slice());
+                        buffer = null;
+                    } else {
+                        subscriber.add(buffer.retainedSlice());
+                    }
+                }
+                if (error != null) {
+                    subscriber.error(error);
+                } else if (lengthSoFar > limits.maxBufferSize()) {
+                    subscriber.error(new BufferLengthExceededException(limits.maxBufferSize(), lengthSoFar));
+                    specificUpstream.allowDiscard();
+                }
+                if (complete) {
+                    subscriber.complete();
+                }
+            } else {
+                if (buffer != null && last) {
+                    buffer.release();
+                    buffer = null;
+                }
+            }
+            if (tracker != null) {
+                if (last) {
+                    tracker.close(this);
+                } else {
+                    tracker.record();
+                }
+            }
+            working = false;
+        }
+
+        /**
+         * Optimized version of {@link #subscribe} for subscribers that want to buffer the full
+         * body.
+         *
+         * @param specificUpstream The upstream for the subscriber. This is used to call allowDiscard if there was an error
+         * @return A flow that will complete when all data has arrived, with a buffer containing that data
+         */
+        ExecutionFlow<ByteBuf> subscribeFull(Upstream specificUpstream) {
+            DelayedExecutionFlow<ByteBuf> asyncFlow = DelayedExecutionFlow.create();
+            if (eventLoopFlow.executeNow(() -> {
+                ExecutionFlow<ByteBuf> res = subscribeFull0(asyncFlow, specificUpstream, false);
+                assert res == asyncFlow;
+            })) {
+                return subscribeFull0(asyncFlow, specificUpstream, true);
+            } else {
+                return asyncFlow;
+            }
+        }
+
+        /**
+         * On-loop version of {@link #subscribeFull}. The returned flow will complete when the
+         * input is buffered. The returned flow will always be identical to the {@code targetFlow}
+         * parameter IF {@code canReturnImmediate} is false. If {@code canReturnImmediate} is true,
+         * this method will SOMETIMES return an immediate ExecutionFlow instead as an optimization.
+         *
+         * @param targetFlow The delayed flow to use if {@code canReturnImmediate} is false and/or
+         *                   we have to wait for the result
+         * @param canReturnImmediate Whether we can return an immediate ExecutionFlow instead of
+         *                  {@code targetFlow}, when appropriate
+         */
+        private ExecutionFlow<ByteBuf> subscribeFull0(DelayedExecutionFlow<ByteBuf> targetFlow, Upstream specificUpstream, boolean canReturnImmediate) {
+            assert !working;
+
+            if (reserved <= 0) {
+                throw new IllegalStateException("Need to reserve a spot first. This should not happen, StreamingNettyByteBody should guard against it");
+            }
+
+            ExecutionFlow<ByteBuf> ret = targetFlow;
+
+            working = true;
+            boolean last = --reserved == 0;
+            Throwable error = this.error;
+            if (error == null && lengthSoFar > limits.maxBufferSize()) {
+                error = new BufferLengthExceededException(limits.maxBufferSize(), lengthSoFar);
+                specificUpstream.allowDiscard();
+            }
+            if (error != null) {
+                if (canReturnImmediate) {
+                    ret = ExecutionFlow.error(error);
+                } else {
+                    targetFlow.completeExceptionally(error);
+                }
+            } else if (complete) {
+                ByteBuf buf;
+                if (buffer == null) {
+                    buf = Unpooled.EMPTY_BUFFER;
+                } else if (last) {
+                    buf = buffer;
+                    buffer = null;
+                } else {
+                    buf = buffer.retainedSlice();
+                }
+                if (canReturnImmediate) {
+                    ret = ExecutionFlow.just(buf);
+                } else {
+                    targetFlow.complete(buf);
+                }
+            } else {
+                if (fullSubscribers == null) {
+                    fullSubscribers = new ArrayList<>(1);
+                }
+                fullSubscribers.add(targetFlow);
+            }
+            if (tracker != null) {
+                if (last) {
+                    tracker.close(this);
+                } else {
+                    tracker.record();
+                }
+            }
+            working = false;
+
+            return ret;
+        }
+
+        @Override
+        public void add(ByteBuf buf) {
+            assert !working;
+
+            buf.touch();
+
+            // drop messages if we're done with all subscribers
+            if (complete || error != null) {
+                buf.release();
+                return;
+            }
+            // calculate the new total length
+            long newLength = lengthSoFar + buf.readableBytes();
+            lengthSoFar = newLength;
+            if (newLength > limits.maxBodySize()) {
+                // for maxBodySize, all subscribers get the error
+                buf.release();
+                error(new ContentLengthExceededException(limits.maxBodySize(), newLength));
+                rootUpstream.allowDiscard();
+                return;
+            }
+
+            working = true;
+            if (subscribers != null) {
+                for (BufferConsumer subscriber : subscribers) {
+                    subscriber.add(buf.retainedSlice());
+                }
+            }
+            if (reserved > 0 || fullSubscribers != null) {
+                if (newLength > limits.maxBufferSize()) {
+                    // new subscribers will recognize that the limit has been exceeded. Streaming
+                    // subscribers can proceed normally. Need to notify buffering subscribers
+                    buf.release();
+                    if (buffer != null) {
+                        buffer.release();
+                        buffer = null;
+                    }
+                    if (fullSubscribers != null) {
+                        Exception e = new BufferLengthExceededException(limits.maxBufferSize(), lengthSoFar);
+                        for (DelayedExecutionFlow<ByteBuf> fullSubscriber : fullSubscribers) {
+                            fullSubscriber.completeExceptionally(e);
+                        }
+                    }
+                } else {
+                    if (buffer == null) {
+                        buffer = buf.alloc().compositeBuffer();
+                    }
+                    buffer.addComponent(true, buf);
+                }
+            } else {
+                buf.release();
+            }
+            working = false;
+        }
+
+        @Override
+        public void complete() {
+            complete = true;
+            expectedLength = lengthSoFar;
+            if (subscribers != null) {
+                for (BufferConsumer subscriber : subscribers) {
+                    subscriber.complete();
+                }
+            }
+            if (fullSubscribers != null) {
+                boolean release;
+                ByteBuf buf;
+                if (buffer == null) {
+                    buf = Unpooled.EMPTY_BUFFER;
+                    release = false;
+                } else {
+                    buf = buffer;
+                    if (reserved > 0) {
+                        release = false;
+                    } else {
+                        this.buffer = null;
+                        release = true;
+                    }
+                }
+                for (DelayedExecutionFlow<ByteBuf> fullSubscriber : fullSubscribers) {
+                    fullSubscriber.complete(buf.retainedSlice());
+                }
+                if (release) {
+                    buf.release();
+                }
+            }
+        }
+
+        @Override
+        public void error(Throwable e) {
+            error = e;
+            if (buffer != null) {
+                buffer.release();
+                buffer = null;
+            }
+            if (subscribers != null) {
+                for (BufferConsumer subscriber : subscribers) {
+                    subscriber.error(e);
+                }
+            }
+            if (fullSubscribers != null) {
+                for (DelayedExecutionFlow<ByteBuf> fullSubscriber : fullSubscribers) {
+                    fullSubscriber.completeExceptionally(e);
+                }
+            }
+        }
+    }
+}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/SystemFileBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/SystemFileBodyWriter.java
index 419201b096..e71a5c6649 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/SystemFileBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/SystemFileBodyWriter.java
@@ -20,24 +20,24 @@ import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpMethod;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
-import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.body.stream.InputStreamByteBody;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.exceptions.MessageBodyException;
+import io.micronaut.http.netty.NettyMutableHttpResponse;
+import io.micronaut.http.netty.body.NettyBodyWriter;
+import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.types.files.SystemFile;
 import io.micronaut.scheduling.TaskExecutors;
+import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import jakarta.inject.Named;
@@ -64,7 +64,7 @@ import static io.micronaut.http.HttpHeaders.CONTENT_RANGE;
 @Singleton
 @Experimental
 @Internal
-public final class SystemFileBodyWriter extends AbstractFileBodyWriter implements ResponseBodyWriter<SystemFile> {
+public final class SystemFileBodyWriter extends AbstractFileBodyWriter implements NettyBodyWriter<SystemFile> {
     private static final String UNIT_BYTES = "bytes";
 
     private final ExecutorService ioExecutor;
@@ -75,64 +75,71 @@ public final class SystemFileBodyWriter extends AbstractFileBodyWriter implement
     }
 
     @Override
-    public void writeTo(Argument<SystemFile> type, MediaType mediaType, SystemFile file, MutableHeaders outgoingHeaders, OutputStream outputStream) throws CodecException {
-        throw new UnsupportedOperationException("Can only be used in a Netty context");
+    public void writeTo(HttpRequest<?> request, MutableHttpResponse<SystemFile> outgoingResponse, Argument<SystemFile> type, MediaType mediaType, SystemFile object, NettyWriteContext nettyContext) throws CodecException {
+        writeTo(request, outgoingResponse, object, nettyContext);
     }
 
     @Override
-    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, @NonNull MutableHttpResponse<SystemFile> httpResponse, @NonNull Argument<SystemFile> type, @NonNull MediaType mediaType, SystemFile object) throws CodecException {
-        return write(request, httpResponse, object);
+    public void writeTo(Argument<SystemFile> type, MediaType mediaType, SystemFile file, MutableHeaders outgoingHeaders, OutputStream outputStream) throws CodecException {
+        throw new UnsupportedOperationException("Can only be used in a Netty context");
     }
 
-    public ByteBodyHttpResponse<?> write(HttpRequest<?> request, MutableHttpResponse<SystemFile> response, SystemFile systemFile) throws CodecException {
-        if (!systemFile.getFile().canRead()) {
-            throw new MessageBodyException("Could not find file");
-        }
-        if (handleIfModifiedAndHeaders(request, response, systemFile, response)) {
-            return notModified(response);
-        } else {
+    public void writeTo(HttpRequest<?> request, MutableHttpResponse<SystemFile> response, SystemFile systemFile, NettyWriteContext nettyContext) throws CodecException {
+        if (response instanceof NettyMutableHttpResponse<?> nettyResponse) {
+            if (!systemFile.getFile().canRead()) {
+                throw new MessageBodyException("Could not find file");
+            }
+            if (handleIfModifiedAndHeaders(request, response, systemFile, nettyResponse)) {
+                nettyContext.writeFull(notModified(response));
+            } else {
 
-            // Parse the range headers (if any), and determine the position and content length
-            // Only `bytes` ranges are supported. Only single ranges are supported. Invalid ranges fall back to returning the full response.
-            // See https://httpwg.org/specs/rfc9110.html#field.range
-            long fileLength = systemFile.getLength();
-            long position = 0;
-            long contentLength = fileLength;
-            if (fileLength > -1) {
-                String rangeHeader = request.getHeaders().get(HttpHeaders.RANGE);
-                if (rangeHeader != null
-                    && request.getMethod() == HttpMethod.GET // A server MUST ignore a Range header field received with a request method that is unrecognized or for which range handling is not defined.
-                    && rangeHeader.startsWith(UNIT_BYTES) // An origin server MUST ignore a Range header field that contains a range unit it does not understand.
-                    && response.status() == HttpStatus.OK // The Range header field is evaluated after evaluating the precondition header fields defined in Section 13.1, and only if the result in absence of the Range header field would be a 200 (OK) response.
-                ) {
-                    IntRange range = parseRangeHeader(rangeHeader, fileLength);
-                    if (range != null // A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1)
-                        && range.firstPos < range.lastPos // A server that supports range requests MAY ignore a Range header field when the selected representation has no content (i.e., the selected representation's data is of zero length).
-                        && range.firstPos < fileLength
-                        && range.lastPos < fileLength
+                // Parse the range headers (if any), and determine the position and content length
+                // Only `bytes` ranges are supported. Only single ranges are supported. Invalid ranges fall back to returning the full response.
+                // See https://httpwg.org/specs/rfc9110.html#field.range
+                long fileLength = systemFile.getLength();
+                long position = 0;
+                long contentLength = fileLength;
+                if (fileLength > -1) {
+                    String rangeHeader = request.getHeaders().get(HttpHeaders.RANGE);
+                    if (rangeHeader != null
+                        && request.getMethod() == HttpMethod.GET // A server MUST ignore a Range header field received with a request method that is unrecognized or for which range handling is not defined.
+                        && rangeHeader.startsWith(UNIT_BYTES) // An origin server MUST ignore a Range header field that contains a range unit it does not understand.
+                        && response.status() == HttpStatus.OK // The Range header field is evaluated after evaluating the precondition header fields defined in Section 13.1, and only if the result in absence of the Range header field would be a 200 (OK) response.
                     ) {
-                        position = range.firstPos;
-                        contentLength = range.lastPos + 1 - range.firstPos;
-                        response.status(HttpStatus.PARTIAL_CONTENT);
-                        response.header(CONTENT_RANGE, "%s %d-%d/%d".formatted(UNIT_BYTES, range.firstPos, range.lastPos, fileLength));
+                        IntRange range = parseRangeHeader(rangeHeader, fileLength);
+                        if (range != null // A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1)
+                            && range.firstPos < range.lastPos // A server that supports range requests MAY ignore a Range header field when the selected representation has no content (i.e., the selected representation's data is of zero length).
+                            && range.firstPos < fileLength
+                            && range.lastPos < fileLength
+                        ) {
+                            position = range.firstPos;
+                            contentLength = range.lastPos + 1 - range.firstPos;
+                            response.status(HttpStatus.PARTIAL_CONTENT);
+                            response.header(CONTENT_RANGE, "%s %d-%d/%d".formatted(UNIT_BYTES, range.firstPos, range.lastPos, fileLength));
+                        }
                     }
+                    response.header(HttpHeaders.ACCEPT_RANGES, UNIT_BYTES);
+                    response.header(HttpHeaders.CONTENT_LENGTH, Long.toString(contentLength));
+                } else {
+                    response.header(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
                 }
-                response.header(HttpHeaders.ACCEPT_RANGES, UNIT_BYTES);
-                response.header(HttpHeaders.CONTENT_LENGTH, Long.toString(contentLength));
-            } else {
-                response.header(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
-            }
 
-            File file = systemFile.getFile();
-            InputStream is;
-            try {
-                is = new FileInputStream(file);
-            } catch (FileNotFoundException e) {
-                throw new MessageBodyException("Could not find file", e);
-            }
+                // Write the request data
+                final DefaultHttpResponse finalResponse = new DefaultHttpResponse(nettyResponse.getNettyHttpVersion(), nettyResponse.getNettyHttpStatus(), nettyResponse.getNettyHeaders());
+
+                File file = systemFile.getFile();
+                InputStream is;
+                try {
+                    is = new FileInputStream(file);
+                } catch (FileNotFoundException e) {
+                    throw new MessageBodyException("Could not find file", e);
+                }
 
-            @NonNull InputStream stream = new RangeInputStream(is, position, contentLength);
-            return ByteBodyHttpResponseWrapper.wrap(response, InputStreamByteBody.create(stream, OptionalLong.of(contentLength), ioExecutor, NettyByteBufferFactory.DEFAULT));
+                @NonNull InputStream stream = new RangeInputStream(is, position, contentLength);
+                nettyContext.write(finalResponse, InputStreamByteBody.create(stream, OptionalLong.of(contentLength), ioExecutor, NettyByteBufferFactory.DEFAULT));
+            }
+        } else {
+            throw new IllegalArgumentException("Unsupported response type. Not a Netty response: " + response);
         }
     }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/UpstreamBalancer.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/UpstreamBalancer.java
new file mode 100644
index 0000000000..d364dab8bb
--- /dev/null
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/UpstreamBalancer.java
@@ -0,0 +1,308 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.netty.body;
+
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.http.body.ByteBody;
+
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongFieldUpdater;
+
+/**
+ * This class merges the backpressure of two data streams. The bytes signaled to the
+ * {@link #upstream} is always the <i>minimum</i> of the consumed bytes of the two downstreams.
+ * <p>
+ * Implementation notes: This is a bit tricky to implement without locking due to the concurrent nature of
+ * {@link BufferConsumer.Upstream}. Let {@code l} and {@code r} be the total bytes consumed by the left and
+ * right downstreams respectively. We have signalled already the consumption of
+ * {@code min(l, r)} bytes upstream. The {@link AtomicLong} stores the difference {@code l-r}.
+ * Now, assume the left downstream (wlog) signals consumption of {@code n} further bytes. There
+ * are three cases:
+ *
+ * <ul>
+ *     <li>{@code l>r}, thus {@code l-r>0}: right downstream is already lagging behind, don't
+ *     send any demand upstream</li>
+ *     <li>{@code l<r}, and {@code l+n<r}: left downstream stays lagging behind, send the full
+ *     {@code n} demand upstream</li>
+ *     <li>{@code l<r}, but {@code l+n>r}: left downstream was lagging behind but now right
+ *     downstream is. Just send {@code r-l=abs(l-r)} upstream</li>
+ * </ul>
+ * <p>
+ * The last two cases can be combined into sending {@code min(n, abs(l-r))} upstream. So we
+ * only need to test for the first case.
+ */
+@Internal
+final class UpstreamBalancer {
+    private static final AtomicLongFieldUpdater<UpstreamBalancer> DELTA = AtomicLongFieldUpdater.newUpdater(UpstreamBalancer.class, "delta");
+    private static final AtomicIntegerFieldUpdater<UpstreamBalancer> FLAGS = AtomicIntegerFieldUpdater.newUpdater(UpstreamBalancer.class, "flags");
+
+    private static final int FLAG_DISCARD_A = 1;
+    private static final int FLAG_DISCARD_B = 2;
+    private static final int MASK_DISCARD = FLAG_DISCARD_A | FLAG_DISCARD_B;
+
+    private static final int FLAG_START_A = 4;
+    private static final int FLAG_START_B = 8;
+    private static final int MASK_START = FLAG_START_A | FLAG_START_B;
+
+    private static final int FLAG_DISREGARD_A = 16;
+    private static final int FLAG_DISREGARD_B = 32;
+    private static final int MASK_DISREGARD = FLAG_DISREGARD_A | FLAG_DISREGARD_B;
+
+    private final BufferConsumer.Upstream upstream;
+    private volatile long delta;
+    private volatile int flags;
+
+    private UpstreamBalancer(BufferConsumer.Upstream upstream) {
+        this.upstream = upstream;
+    }
+
+    /**
+     * Implementation of {@link io.micronaut.http.body.ByteBody.SplitBackpressureMode#SLOWEST}.
+     */
+    static UpstreamPair slowest(BufferConsumer.Upstream upstream) {
+        UpstreamBalancer balancer = new UpstreamBalancer(upstream);
+        return new UpstreamPair(balancer.new SlowestUpstreamImpl(false), balancer.new SlowestUpstreamImpl(true));
+    }
+
+    /**
+     * Implementation of {@link io.micronaut.http.body.ByteBody.SplitBackpressureMode#FASTEST}.
+     */
+    static UpstreamPair fastest(BufferConsumer.Upstream upstream) {
+        UpstreamBalancer balancer = new UpstreamBalancer(upstream);
+        return new UpstreamPair(balancer.new FastestUpstreamImpl(false), balancer.new FastestUpstreamImpl(true));
+    }
+
+    /**
+     * Implementation of {@link io.micronaut.http.body.ByteBody.SplitBackpressureMode#ORIGINAL} and
+     * {@link io.micronaut.http.body.ByteBody.SplitBackpressureMode#NEW}.
+     */
+    static UpstreamPair first(BufferConsumer.Upstream upstream) {
+        UpstreamBalancer balancer = new UpstreamBalancer(upstream);
+        return new UpstreamPair(balancer.new PassthroughUpstreamImpl(), balancer.new IgnoringUpstreamImpl());
+    }
+
+    /**
+     * Create a pair of {@link io.micronaut.http.server.netty.body.BufferConsumer.Upstream}
+     * instances that delegates to the given {@code upstream} according to the semantics of the
+     * given {@code mode}.
+     */
+    static UpstreamPair balancer(BufferConsumer.Upstream upstream, ByteBody.SplitBackpressureMode mode) {
+        return switch (mode) {
+            case SLOWEST -> slowest(upstream);
+            case FASTEST -> fastest(upstream);
+            case ORIGINAL -> first(upstream);
+            case NEW -> first(upstream).flip();
+        };
+    }
+
+    private int getAndSetFlag(int flag) {
+        while (true) {
+            int current = this.flags;
+            if ((current & flag) != 0) {
+                // already set
+                return current;
+            }
+            int next = current | flag;
+            if (FLAGS.compareAndSet(UpstreamBalancer.this, current, next)) {
+                return current;
+            }
+        }
+    }
+
+    private boolean setFlagAndCheckMask(int flag, int mask) {
+        int old = getAndSetFlag(flag);
+        return (old & mask) != mask && ((old | flag) & mask) == mask;
+    }
+
+    private static long subtractSaturating(long dest, long n) {
+        assert n >= 0;
+        long sum = dest - n;
+        // also prevent MIN_VALUE to avoid some edge cases
+        if (sum > dest || sum == Long.MIN_VALUE) {
+            sum = -Long.MAX_VALUE;
+        }
+        return sum;
+    }
+
+    private static long addSaturating(long dest, long n) {
+        assert n >= 0;
+        long sum = dest + n;
+        if (sum < dest) {
+            sum = Long.MAX_VALUE;
+        }
+        return sum;
+    }
+
+    private void addSlowest(boolean inv, long n) {
+        if (n == 0) {
+            return;
+        }
+
+        assert n > 0;
+
+        long oldValue = DELTA.getAndUpdate(this, prev -> inv ? subtractSaturating(prev, n) : addSaturating(prev, n));
+        if (oldValue < 0 != inv) {
+            long actual = Math.min(n, Math.abs(oldValue));
+            if (actual > 0) {
+                this.upstream.onBytesConsumed(actual);
+            }
+        }
+    }
+
+    private void addFastest(boolean inv, long n) {
+        if (n == 0) {
+            return;
+        }
+
+        assert n > 0;
+
+        long newValue = DELTA.updateAndGet(this, prev -> inv ? subtractSaturating(prev, n) : addSaturating(prev, n));
+        if (newValue > 0 != inv) {
+            long actual = Math.min(n, Math.abs(newValue));
+            if (actual > 0) {
+                this.upstream.onBytesConsumed(actual);
+            }
+        }
+    }
+
+    private void pushSomeFromIgnored() {
+        // if delta > 0, push that demand upstream.
+        long n = DELTA.getAndUpdate(this, l -> l > 0 ? 0 : l);
+        if (n > 0) {
+            upstream.onBytesConsumed(n);
+        }
+    }
+
+    private abstract class UpstreamImpl implements BufferConsumer.Upstream {
+        final boolean inv;
+
+        UpstreamImpl(boolean inv) {
+            this.inv = inv;
+        }
+
+        @Override
+        public void allowDiscard() {
+            int flag = inv ? FLAG_DISCARD_B : FLAG_DISCARD_A;
+            if (setFlagAndCheckMask(flag, MASK_DISCARD)) {
+                // both streams discarded
+                upstream.allowDiscard();
+            }
+        }
+
+        @Override
+        public void disregardBackpressure() {
+            int flag = inv ? FLAG_DISREGARD_B : FLAG_DISREGARD_A;
+            int old = getAndSetFlag(flag);
+            if ((old & MASK_DISREGARD) != MASK_DISREGARD && ((old | flag) & MASK_DISREGARD) == MASK_DISREGARD) {
+                upstream.disregardBackpressure();
+            } else if ((old | flag) != old) {
+                disregardBackpressureThisSide();
+            }
+        }
+
+        protected void disregardBackpressureThisSide() {
+        }
+    }
+
+    private final class SlowestUpstreamImpl extends UpstreamImpl {
+        SlowestUpstreamImpl(boolean inv) {
+            super(inv);
+        }
+
+        @Override
+        public void start() {
+            int flag = inv ? FLAG_START_A : FLAG_START_B;
+            if (setFlagAndCheckMask(flag, MASK_START)) {
+                // both downstreams signalled start
+                upstream.start();
+            }
+        }
+
+        @Override
+        public void onBytesConsumed(long bytesConsumed) {
+            addSlowest(inv, bytesConsumed);
+        }
+
+        @Override
+        protected void disregardBackpressureThisSide() {
+            onBytesConsumed(Long.MAX_VALUE);
+        }
+    }
+
+    private final class FastestUpstreamImpl extends UpstreamImpl {
+        FastestUpstreamImpl(boolean inv) {
+            super(inv);
+        }
+
+        @Override
+        public void start() {
+            upstream.start();
+        }
+
+        @Override
+        public void onBytesConsumed(long bytesConsumed) {
+            addFastest(inv, bytesConsumed);
+        }
+    }
+
+    private final class IgnoringUpstreamImpl extends UpstreamImpl {
+        IgnoringUpstreamImpl() {
+            super(true);
+        }
+
+        // start() is ignored
+
+        @Override
+        public void onBytesConsumed(long bytesConsumed) {
+            // don't send the demand upstream, but save it for later in case the other side calls disregardBackpressure
+            DELTA.updateAndGet(UpstreamBalancer.this, old -> addSaturating(old, bytesConsumed));
+            if ((flags & FLAG_DISREGARD_A) != 0) {
+                pushSomeFromIgnored();
+            }
+        }
+    }
+
+    private final class PassthroughUpstreamImpl extends UpstreamImpl {
+        PassthroughUpstreamImpl() {
+            super(false);
+        }
+
+        @Override
+        public void start() {
+            upstream.start();
+        }
+
+        @Override
+        public void onBytesConsumed(long bytesConsumed) {
+            // save already-demanded bytes to delta to calculate demand for other side in case of disregardBackpressure
+            DELTA.updateAndGet(UpstreamBalancer.this, old -> subtractSaturating(old, bytesConsumed));
+            upstream.onBytesConsumed(bytesConsumed);
+        }
+
+        @Override
+        protected void disregardBackpressureThisSide() {
+            // when disregardBackpressure is called on this side, the previously "ignoring" side takes over backpressure.
+            pushSomeFromIgnored();
+        }
+    }
+
+    public record UpstreamPair(BufferConsumer.Upstream left, BufferConsumer.Upstream right) {
+        UpstreamPair flip() {
+            return new UpstreamPair(right, left);
+        }
+    }
+}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java
index 307c514c06..637dfc74b0 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java
@@ -15,7 +15,6 @@
  */
 package io.micronaut.http.server.netty.converters;
 
-import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.context.BeanProvider;
 import io.micronaut.context.annotation.Prototype;
 import io.micronaut.core.annotation.Internal;
@@ -24,16 +23,12 @@ import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.convert.MutableConversionService;
 import io.micronaut.core.convert.TypeConverterRegistrar;
 import io.micronaut.core.naming.NameUtils;
-import io.micronaut.core.type.Argument;
 import io.micronaut.core.util.StringUtils;
 import io.micronaut.http.MediaType;
-import io.micronaut.http.body.MessageBodyHandlerRegistry;
-import io.micronaut.http.body.MessageBodyReader;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 import io.micronaut.http.netty.channel.converters.ChannelOptionFactory;
 import io.micronaut.http.server.netty.multipart.NettyPartData;
-import io.micronaut.http.simple.SimpleHttpHeaders;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufInputStream;
 import io.netty.channel.ChannelOption;
@@ -59,25 +54,21 @@ public final class NettyConverters implements TypeConverterRegistrar {
 
     private final ConversionService conversionService;
     private final BeanProvider<MediaTypeCodecRegistry> decoderRegistryProvider;
-    private final BeanProvider<MessageBodyHandlerRegistry> messageBodyHandlerRegistries;
     private final BeanProvider<ChannelOptionFactory> channelOptionFactory;
 
     /**
      * Default constructor.
      *
-     * @param conversionService            The conversion service
-     * @param decoderRegistryProvider      The decoder registry provider
-     * @param messageBodyHandlerRegistries The message body handlers
-     * @param channelOptionFactory         The decoder channel option factory
+     * @param conversionService       The conversion service
+     * @param decoderRegistryProvider The decoder registry provider
+     * @param channelOptionFactory    The decoder channel option factory
      */
     public NettyConverters(ConversionService conversionService,
                            //Prevent early initialization of the codecs
                            BeanProvider<MediaTypeCodecRegistry> decoderRegistryProvider,
-                           BeanProvider<MessageBodyHandlerRegistry> messageBodyHandlerRegistries,
                            BeanProvider<ChannelOptionFactory> channelOptionFactory) {
         this.conversionService = conversionService;
         this.decoderRegistryProvider = decoderRegistryProvider;
-        this.messageBodyHandlerRegistries = messageBodyHandlerRegistries;
         this.channelOptionFactory = channelOptionFactory;
     }
 
@@ -107,23 +98,20 @@ public final class NettyConverters implements TypeConverterRegistrar {
                         if (!object.isCompleted()) {
                             return Optional.empty();
                         }
-                        Argument<Object> argument = context instanceof ArgumentConversionContext<?> argumentConversionContext ? (Argument<Object>) argumentConversionContext.getArgument() : Argument.of(targetType);
                         String contentType = object.getContentType();
                         ByteBuf byteBuf = object.getByteBuf();
-                        MediaType mediaType = StringUtils.isEmpty(contentType) ? null : MediaType.of(contentType);
-                        MediaTypeCodec codec = decoderRegistryProvider.get().findCodec(mediaType).orElse(null);
-                        if (codec != null) {
-                            return Optional.of(
-                                codec.decode(argument, new ByteBufInputStream(byteBuf))
-                            );
-                        }
-                        MessageBodyReader<Object> messageBodyReader = messageBodyHandlerRegistries.get().findReader(argument, mediaType).orElse(null);
-                        if (messageBodyReader != null) {
-                            return Optional.of(
-                                messageBodyReader.read(argument, mediaType, new SimpleHttpHeaders(), NettyByteBufferFactory.DEFAULT.wrap(byteBuf))
-                            );
+                        if (StringUtils.isNotEmpty(contentType)) {
+                            MediaType mediaType = MediaType.of(contentType);
+                            Optional<MediaTypeCodec> registered = decoderRegistryProvider.get().findCodec(mediaType);
+                            if (registered.isPresent()) {
+                                MediaTypeCodec decoder = registered.get();
+                                Object val = decoder.decode(targetType, new ByteBufInputStream(byteBuf));
+                                return Optional.of(val);
+                            } else {
+                                return this.conversionService.convert(byteBuf, targetType, context);
+                            }
                         }
-                        return conversionService.convert(byteBuf, targetType, context);
+                        return this.conversionService.convert(byteBuf, targetType, context);
                     } catch (Exception e) {
                         context.reject(e);
                         return Optional.empty();
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java
index dd5a88ca2a..aa46f95d16 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java
@@ -36,6 +36,7 @@ import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.handler.codec.compression.Zstd;
 import io.netty.handler.codec.compression.ZstdEncoder;
 import io.netty.handler.codec.compression.ZstdOptions;
+import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpMethod;
@@ -78,6 +79,10 @@ final class Compressor {
             response.protocolVersion() == HttpVersion.HTTP_1_0) {
             return null;
         }
+        // special case for FHR to keep behavior identical to HttpContentEncoder
+        if (response instanceof FullHttpResponse fhr && !fhr.content().isReadable()) {
+            return null;
+        }
         if (!strategy.shouldCompress(response)) {
             return null;
         }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
index 0407456e08..6e8bf0a49a 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
@@ -19,7 +19,7 @@ import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.server.netty.HttpCompressionStrategy;
-import io.micronaut.http.netty.body.BodySizeLimits;
+import io.micronaut.http.server.netty.body.BodySizeLimits;
 import io.micronaut.http.server.netty.handler.accesslog.Http2AccessLogConnectionEncoder;
 import io.micronaut.http.server.netty.handler.accesslog.Http2AccessLogFrameListener;
 import io.micronaut.http.server.netty.handler.accesslog.Http2AccessLogManager;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
index 9258be86a7..34adb5b5fb 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
@@ -20,31 +20,37 @@ import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.netty.EventLoopFlow;
-import io.micronaut.http.netty.body.AvailableNettyByteBody;
-import io.micronaut.http.netty.body.BodySizeLimits;
-import io.micronaut.http.netty.body.BufferConsumer;
-import io.micronaut.http.netty.body.NettyByteBody;
-import io.micronaut.http.netty.body.StreamingNettyByteBody;
 import io.micronaut.http.netty.reactive.HotObservable;
+import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.server.netty.body.BodySizeLimits;
+import io.micronaut.http.server.netty.body.BufferConsumer;
 import io.micronaut.http.server.netty.body.NettyBodyAdapter;
+import io.micronaut.http.server.netty.body.NettyByteBody;
+import io.micronaut.http.server.netty.body.StreamingNettyByteBody;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.CompositeByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoop;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.EmptyHttpHeaders;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http2.Http2Exception;
+import org.reactivestreams.Publisher;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import reactor.core.publisher.Flux;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.OptionalLong;
 
 /**
  * Common handler implementation for multiplexed HTTP versions (HTTP/2 and HTTP/3).
@@ -234,30 +240,30 @@ abstract class MultiplexedServerHandler {
             return true;
         }
 
+        @Override
+        public final @NonNull ByteBufAllocator alloc() {
+            return ctx.alloc();
+        }
+
         @Override
         public void write(@NonNull HttpResponse response, @NonNull ByteBody body) {
             if (responseDone) {
                 // early check
                 throw new IllegalStateException("Response already written");
             }
-
-            // we do some preparation immediately on the calling thread, so that the ByteBody
-            // primary operation happens here.
-
-            response.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);
-            if (PipeliningServerHandler.canHaveBody(response.status())) {
-                OptionalLong length = body.expectedLength();
-                if (length.isPresent()) {
-                    response.headers().set(HttpHeaderNames.CONTENT_LENGTH, length.getAsLong());
-                }
-            } else {
-                response.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
+            if (!ctx.executor().inEventLoop()) {
+                ctx.executor().execute(() -> write(response, body));
+                return;
             }
 
             NettyByteBody nbb = NettyBodyAdapter.adapt(body, ctx.channel().eventLoop());
             if (nbb instanceof AvailableNettyByteBody available) {
-                writeFull(response, AvailableNettyByteBody.toByteBuf(available));
+                writeFull(new DefaultFullHttpResponse(response.protocolVersion(), response.status(), AvailableNettyByteBody.toByteBuf(available), response.headers(), EmptyHttpHeaders.INSTANCE));
             } else {
+                prepareCompression(response, false);
+
+                writeHeaders(response, false, ctx.voidPromise());
+
                 StreamingNettyByteBody snbb = (StreamingNettyByteBody) nbb;
                 var consumer = new BufferConsumer() {
                     Upstream upstream;
@@ -292,11 +298,9 @@ abstract class MultiplexedServerHandler {
                     }
 
                     private void complete0() {
-                        if (!responseDone) {
+                        if (finish()) {
                             writeData(Unpooled.EMPTY_BUFFER, true, ctx.voidPromise());
-                            if (finish()) {
-                                flush();
-                            }
+                            flush();
                         }
                     }
 
@@ -315,54 +319,26 @@ abstract class MultiplexedServerHandler {
                         flush();
                     }
                 };
-                consumer.upstream = snbb.primary(consumer);
-                writeStreaming(response, consumer.upstream);
+                writerUpstream = consumer.upstream = snbb.primary(consumer);
+                consumer.upstream.start();
             }
         }
 
-        private void writeStreaming(HttpResponse response, BufferConsumer.Upstream upstream) {
-            if (!ctx.executor().inEventLoop()) {
-                ctx.executor().execute(() -> writeStreaming(response, upstream));
-                return;
-            }
-
-            if (responseDone) {
-                // connection closed?
-                writerUpstream.allowDiscard();
-                writerUpstream.disregardBackpressure();
-                return;
-            }
-
-            writerUpstream = upstream;
-
-            prepareCompression(response);
-
-            writeHeaders(response, false, ctx.voidPromise());
-            upstream.start();
-        }
-
         @Override
-        public void writeHeadResponse(@NonNull HttpResponse response) {
-            response.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);
-            writeFull(response, Unpooled.EMPTY_BUFFER);
-        }
-
-        private void writeFull(@NonNull HttpResponse response, @NonNull ByteBuf content) {
+        public final void writeFull(@NonNull FullHttpResponse response, boolean headResponse) {
             if (responseDone) {
                 // early check
                 throw new IllegalStateException("Response already written");
             }
             if (!ctx.executor().inEventLoop()) {
-                ByteBuf finalContent = content;
-                ctx.executor().execute(() -> writeFull(response, finalContent));
+                ctx.executor().execute(() -> writeFull(response, headResponse));
                 return;
             }
 
-            boolean empty = !content.isReadable();
+            prepareCompression(response, true);
 
-            if (!empty) {
-                prepareCompression(response);
-            }
+            ByteBuf content = response.content();
+            boolean empty = !content.isReadable();
 
             if (compressionSession != null) {
                 compressionSession.push(content);
@@ -376,8 +352,6 @@ abstract class MultiplexedServerHandler {
             if (!empty) {
                 // bypass writeDataCompressing
                 writeData0(content, true, ctx.voidPromise());
-            } else if (content != null) {
-                content.release();
             }
             if (!finish()) {
                 throw new IllegalStateException("Response already written");
@@ -385,6 +359,11 @@ abstract class MultiplexedServerHandler {
             flush();
         }
 
+        @Override
+        public final void writeStreamed(@NonNull HttpResponse response, @NonNull Publisher<HttpContent> content) {
+            write(response, NettyBodyAdapter.adapt(Flux.from(content).map(HttpContent::content), ctx.channel().eventLoop()));
+        }
+
         private void logStreamWriteFailure(Throwable cause) {
             if (cause instanceof Http2Exception h2e) {
                 if (LOG.isDebugEnabled()) {
@@ -404,11 +383,13 @@ abstract class MultiplexedServerHandler {
         public final void closeAfterWrite() {
         }
 
-        private void prepareCompression(HttpResponse headers) {
+        private void prepareCompression(HttpResponse headers, boolean full) {
             if (compressor != null) {
                 Compressor.Session session = compressor.prepare(ctx, request, headers);
                 if (session != null) {
-                    headers.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
+                    if (!full) {
+                        headers.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
+                    }
                     compressionSession = session;
                 }
             }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
index 7cc239281e..bda0d6d987 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
@@ -21,15 +21,16 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.netty.EventLoopFlow;
-import io.micronaut.http.netty.body.AvailableNettyByteBody;
-import io.micronaut.http.netty.body.BodySizeLimits;
-import io.micronaut.http.netty.body.BufferConsumer;
-import io.micronaut.http.netty.body.NettyByteBody;
-import io.micronaut.http.netty.body.StreamingNettyByteBody;
 import io.micronaut.http.netty.stream.StreamedHttpResponse;
 import io.micronaut.http.server.netty.HttpCompressionStrategy;
+import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.server.netty.body.BodySizeLimits;
+import io.micronaut.http.server.netty.body.BufferConsumer;
 import io.micronaut.http.server.netty.body.NettyBodyAdapter;
+import io.micronaut.http.server.netty.body.NettyByteBody;
+import io.micronaut.http.server.netty.body.StreamingNettyByteBody;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.CompositeByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
@@ -63,6 +64,7 @@ import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.timeout.IdleState;
 import io.netty.handler.timeout.IdleStateEvent;
+import org.reactivestreams.Publisher;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import reactor.core.publisher.Flux;
@@ -744,6 +746,11 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
             this.request = request;
         }
 
+        @Override
+        public ByteBufAllocator alloc() {
+            return ctx.alloc();
+        }
+
         /**
          * Set an attachment that is passed to {@link RequestHandler#responseWritten}. Defaults to
          * {@code null}.
@@ -838,17 +845,7 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
         }
 
         @Override
-        public void writeHeadResponse(@NonNull HttpResponse response) {
-            writeFull(new DefaultFullHttpResponse(
-                response.protocolVersion(),
-                response.status(),
-                Unpooled.EMPTY_BUFFER,
-                response.headers(),
-                EmptyHttpHeaders.INSTANCE
-            ), true);
-        }
-
-        private void writeFull(FullHttpResponse response, boolean headResponse) {
+        public void writeFull(FullHttpResponse response, boolean headResponse) {
             response.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);
             if (canHaveBody(response.status())) {
                 if (!headResponse) {
@@ -859,17 +856,20 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
             }
             preprocess(response);
             FullOutboundHandler oh = new FullOutboundHandler(this, response);
-            if (response.content().isReadable()) {
-                prepareCompression(response, oh);
-            }
+            prepareCompression(response, oh);
             write(oh);
         }
 
+        @Override
+        public void writeStreamed(HttpResponse response, Publisher<HttpContent> content) {
+            write(response, NettyBodyAdapter.adapt(Flux.from(content).map(HttpContent::content), ctx.channel().eventLoop()));
+        }
+
         @Override
         public void write(@NonNull HttpResponse response, @NonNull ByteBody body) {
             NettyByteBody nbb = NettyBodyAdapter.adapt(body, ctx.channel().eventLoop());
             if (nbb instanceof AvailableNettyByteBody available) {
-                writeFull(new DefaultFullHttpResponse(response.protocolVersion(), response.status(), AvailableNettyByteBody.toByteBuf(available), response.headers(), EmptyHttpHeaders.INSTANCE), false);
+                writeFull(new DefaultFullHttpResponse(response.protocolVersion(), response.status(), AvailableNettyByteBody.toByteBuf(available), response.headers(), EmptyHttpHeaders.INSTANCE));
             } else {
                 OptionalLong expectedLength = body.expectedLength();
                 if (expectedLength.isPresent()) {
@@ -1108,9 +1108,8 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
             }
 
             if (!removed) {
-                int n = buf.readableBytes();
                 writeCompressing(new DefaultHttpContent(buf), true, false);
-                incompleteWrittenBytes += n;
+                incompleteWrittenBytes += buf.readableBytes();
                 if (ctx.channel().isWritable()) {
                     writeSome();
                 }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/jackson/JsonViewServerFilter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/jackson/JsonViewServerFilter.java
index c220724cc3..a821cf7e1f 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/jackson/JsonViewServerFilter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/jackson/JsonViewServerFilter.java
@@ -91,9 +91,6 @@ public class JsonViewServerFilter implements Ordered {
                 final Optional<?> optionalBody = response.getBody();
                 if (optionalBody.isPresent()) {
                     Object body = optionalBody.get();
-                    if (routeInfo.getReturnType().isOptional()) {
-                        body = Optional.of(body);
-                    }
                     MediaTypeCodec codec = codecFactory.resolveJsonViewCodec(viewClass.get());
                     if (Publishers.isConvertibleToPublisher(body)) {
                         Publisher<?> pub = Publishers.convertToPublisher(conversionService, body);
@@ -101,9 +98,8 @@ public class JsonViewServerFilter implements Ordered {
                             .map(o -> codec.encode((Argument) routeInfo.getResponseBodyType(), o))
                             .subscribeOn(Schedulers.fromExecutorService(executorService)));
                     } else {
-                        Object finalBody = body;
                         return Mono.fromCallable(() -> {
-                            @SuppressWarnings({"unchecked", "rawtypes"}) final byte[] encoded = codec.encode((Argument) routeInfo.getResponseBodyType(), finalBody);
+                            @SuppressWarnings({"unchecked", "rawtypes"}) final byte[] encoded = codec.encode((Argument) routeInfo.getResponseBodyType(), body);
                             response.body(encoded);
                             return response;
                         }).subscribeOn(Schedulers.fromExecutorService(executorService));
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/multipart/MultipartBodyArgumentBinder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/multipart/MultipartBodyArgumentBinder.java
index fc4881c317..daa7e6a702 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/multipart/MultipartBodyArgumentBinder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/multipart/MultipartBodyArgumentBinder.java
@@ -27,7 +27,7 @@ import io.micronaut.http.server.multipart.MultipartBody;
 import io.micronaut.http.server.netty.FormDataHttpContentProcessor;
 import io.micronaut.http.server.netty.HttpContentProcessorAsReactiveProcessor;
 import io.micronaut.http.server.netty.NettyHttpRequest;
-import io.micronaut.http.netty.body.NettyByteBody;
+import io.micronaut.http.server.netty.body.NettyByteBody;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.netty.handler.codec.http.DefaultHttpContent;
 import io.netty.handler.codec.http.multipart.Attribute;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/websocket/NettyServerWebSocketHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/websocket/NettyServerWebSocketHandler.java
index 3175a36708..0ccaf1ecef 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/websocket/NettyServerWebSocketHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/websocket/NettyServerWebSocketHandler.java
@@ -123,9 +123,9 @@ public class NettyServerWebSocketHandler extends AbstractNettyWebSocketHandler {
         ExecutorSelector executorSelector,
         @Nullable CoroutineHelper coroutineHelper) {
         super(
+                ctx,
                 nettyEmbeddedServices.getRequestArgumentSatisfier().getBinderRegistry(),
                 nettyEmbeddedServices.getMediaTypeCodecRegistry(),
-                nettyEmbeddedServices.getMessageBodyHandlerRegistry(),
                 webSocketBean,
                 request,
                 routeMatch.getVariableValues(),
@@ -243,7 +243,6 @@ public class NettyServerWebSocketHandler extends AbstractNettyWebSocketHandler {
                 channel,
                 originatingRequest,
                 mediaTypeCodecRegistry,
-                messageBodyHandlerRegistry,
                 webSocketVersion.toHttpHeaderValue(),
                 ctx.pipeline().get(SslHandler.class) != null
         ) {
diff --git a/http-server/src/main/java/io/micronaut/http/server/codec/TextStreamCodec.java b/http-server/src/main/java/io/micronaut/http/server/codec/TextStreamCodec.java
index ffefbe5fce..185879bd3e 100644
--- a/http-server/src/main/java/io/micronaut/http/server/codec/TextStreamCodec.java
+++ b/http-server/src/main/java/io/micronaut/http/server/codec/TextStreamCodec.java
@@ -50,13 +50,11 @@ import java.util.List;
  *
  * @author Graeme Rocher
  * @since 1.0
- * @deprecated Replaced with message body writers / readers API
  */
 @Singleton
 @Internal
 @BootstrapContextCompatible
 @Requires(bean = ByteBufferFactory.class)
-@Deprecated(forRemoval = true, since = "4.7")
 public class TextStreamCodec implements MediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "text-stream";
diff --git a/http/src/main/java/io/micronaut/http/ByteBodyHttpResponse.java b/http/src/main/java/io/micronaut/http/ByteBodyHttpResponse.java
deleted file mode 100644
index 9d97c2abe3..0000000000
--- a/http/src/main/java/io/micronaut/http/ByteBodyHttpResponse.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http;
-
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.http.body.ByteBody;
-
-import java.io.Closeable;
-
-/**
- * Special response type that contains the encoded response bytes. Responses of this type must also
- * be closed if their {@link #byteBody()} is not used.
- *
- * @param <B> The original (non-encoded) body type
- * @since 4.7.0
- * @author Jonas Konrad
- */
-@Experimental
-public sealed interface ByteBodyHttpResponse<B> extends HttpResponse<B>, Closeable permits ByteBodyHttpResponseWrapper {
-    /**
-     * The body bytes.
-     *
-     * @return The bytes
-     */
-    @NonNull
-    ByteBody byteBody();
-
-    /**
-     * Close this response.
-     */
-    @Override
-    void close();
-}
diff --git a/http/src/main/java/io/micronaut/http/ByteBodyHttpResponseWrapper.java b/http/src/main/java/io/micronaut/http/ByteBodyHttpResponseWrapper.java
deleted file mode 100644
index 7ebcbe6a0c..0000000000
--- a/http/src/main/java/io/micronaut/http/ByteBodyHttpResponseWrapper.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http;
-
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.http.body.ByteBody;
-import io.micronaut.http.body.CloseableByteBody;
-
-/**
- * Simple response wrapper to implement {@link ByteBodyHttpResponse}.
- *
- * @param <B> The original body type
- * @since 4.7.0
- * @author Jonas Konrad
- */
-@Experimental
-public final class ByteBodyHttpResponseWrapper<B> extends HttpResponseWrapper<B> implements ByteBodyHttpResponse<B> {
-    private final CloseableByteBody byteBody;
-
-    private ByteBodyHttpResponseWrapper(HttpResponse<B> delegate, CloseableByteBody byteBody) {
-        super(delegate);
-        this.byteBody = byteBody;
-    }
-
-    /**
-     * Attach a body to the given response.
-     *
-     * @param delegate The original response to be used for e.g. headers and status
-     * @param byteBody The bytes to respond with
-     * @return A {@link ByteBodyHttpResponse} implementation with the given response and bytes
-     */
-    @NonNull
-    public static ByteBodyHttpResponse<?> wrap(@NonNull HttpResponse<?> delegate, @NonNull CloseableByteBody byteBody) {
-        return new ByteBodyHttpResponseWrapper<>(delegate, byteBody);
-    }
-
-    @Override
-    public @NonNull ByteBody byteBody() {
-        return byteBody;
-    }
-
-    @Override
-    public void close() {
-        byteBody.close();
-    }
-}
diff --git a/http/src/main/java/io/micronaut/http/HttpRequest.java b/http/src/main/java/io/micronaut/http/HttpRequest.java
index 9d458fa9a2..9393658aff 100644
--- a/http/src/main/java/io/micronaut/http/HttpRequest.java
+++ b/http/src/main/java/io/micronaut/http/HttpRequest.java
@@ -445,24 +445,4 @@ public interface HttpRequest<B> extends HttpMessage<B> {
         Objects.requireNonNull(httpMethodName, "Argument [httpMethodName] is required");
         return HttpRequestFactory.INSTANCE.create(httpMethod, uri, httpMethodName);
     }
-
-    /**
-     * Returns a mutable request based on this request.
-     * @return the mutable request
-     * @since 4.7
-     */
-    default MutableHttpRequest<B> toMutableRequest() {
-        if (this instanceof MutableHttpRequest<B> mutableHttpRequest) {
-            return mutableHttpRequest;
-        }
-        MutableHttpRequest<B> mutableHttpRequest = HttpRequest.create(getMethod(), getUri().toString());
-        getBody().ifPresent(mutableHttpRequest::body);
-        getHeaders().forEach((name, value) -> {
-            for (String val : value) {
-                mutableHttpRequest.header(name, val);
-            }
-        });
-        mutableHttpRequest.getAttributes().putAll(getAttributes());
-        return mutableHttpRequest;
-    }
 }
diff --git a/http/src/main/java/io/micronaut/http/HttpResponseWrapper.java b/http/src/main/java/io/micronaut/http/HttpResponseWrapper.java
index f814ffda00..51f2c67483 100644
--- a/http/src/main/java/io/micronaut/http/HttpResponseWrapper.java
+++ b/http/src/main/java/io/micronaut/http/HttpResponseWrapper.java
@@ -42,9 +42,7 @@ public class HttpResponseWrapper<B> extends HttpMessageWrapper<B> implements Htt
 
     @Override
     public HttpResponse<B> getDelegate() {
-        HttpMessage<B> delegate = super.getDelegate();
-        // this weird cast structure avoids type pollution
-        return delegate instanceof MutableHttpResponse<B> mhr ? mhr : (HttpResponse<B>) delegate;
+        return (HttpResponse<B>) super.getDelegate();
     }
 
 }
diff --git a/http/src/main/java/io/micronaut/http/MediaType.java b/http/src/main/java/io/micronaut/http/MediaType.java
index a6f398d5b1..97e7352934 100644
--- a/http/src/main/java/io/micronaut/http/MediaType.java
+++ b/http/src/main/java/io/micronaut/http/MediaType.java
@@ -886,38 +886,11 @@ public class MediaType implements CharSequence {
         if (expectedContentType == this) {
             return true;
         }
-        return matchesType(expectedContentType.getType()) && matchesSubtype(expectedContentType.getSubtype());
-    }
-
-    /**
-     * Check if the subtype matches.
-     *
-     * @param matchSubtype The subtype to match
-     * @return true if matches
-     * @since 4.6.3
-     */
-    public boolean matchesSubtype(String matchSubtype) {
-        return subtype.equals(WILDCARD) || subtype.equalsIgnoreCase(matchSubtype);
-    }
-
-    /**
-     * Check if the type matches.
-     * @param matchType The type to match
-     * @return true if matches
-     * @since 4.6.3
-     */
-    public boolean matchesType(String matchType) {
-        return type.equals(WILDCARD) || type.equalsIgnoreCase(matchType);
-    }
-
-    /**
-     * Check if the extension matches.
-     * @param matchExtension The extension to match
-     * @return true if matches
-     * @since 4.6.3
-     */
-    public boolean matchesExtension(String matchExtension) {
-        return extension.equalsIgnoreCase(ALL_TYPE.extension) || extension.equals(WILDCARD) || extension.equalsIgnoreCase(matchExtension);
+        String expectedType = expectedContentType.getType();
+        String expectedSubtype = expectedContentType.getSubtype();
+        boolean typeMatch = type.equals(WILDCARD) || type.equalsIgnoreCase(expectedType);
+        boolean subtypeMatch = subtype.equals(WILDCARD) || subtype.equalsIgnoreCase(expectedSubtype);
+        return typeMatch && subtypeMatch;
     }
 
     /**
diff --git a/http/src/main/java/io/micronaut/http/MutableHttpRequest.java b/http/src/main/java/io/micronaut/http/MutableHttpRequest.java
index a2d770e461..96e9ae0f55 100644
--- a/http/src/main/java/io/micronaut/http/MutableHttpRequest.java
+++ b/http/src/main/java/io/micronaut/http/MutableHttpRequest.java
@@ -160,9 +160,4 @@ public interface MutableHttpRequest<B> extends HttpRequest<B>, MutableHttpMessag
     default MutableHttpRequest<B> contentEncoding(CharSequence encoding) {
         return (MutableHttpRequest<B>) MutableHttpMessage.super.contentEncoding(encoding);
     }
-
-    @Override
-    default MutableHttpRequest<B> toMutableRequest() {
-        return this;
-    }
 }
diff --git a/http/src/main/java/io/micronaut/http/body/DefaultMessageBodyHandlerRegistry.java b/http/src/main/java/io/micronaut/http/body/DefaultMessageBodyHandlerRegistry.java
index 7e64572407..401d2ef531 100644
--- a/http/src/main/java/io/micronaut/http/body/DefaultMessageBodyHandlerRegistry.java
+++ b/http/src/main/java/io/micronaut/http/body/DefaultMessageBodyHandlerRegistry.java
@@ -67,20 +67,27 @@ public final class DefaultMessageBodyHandlerRegistry extends AbstractMessageBody
     @SuppressWarnings({"unchecked"})
     @Override
     protected <T> MessageBodyReader<T> findReaderImpl(Argument<T> type, List<MediaType> mediaTypes) {
-        List<MediaType> resolvedMediaTypes = resolveMediaTypes(mediaTypes);
         return beanLocator.getBeansOfType(
                 Argument.of(MessageBodyReader.class), // Select all readers and eliminate by the type later
                 Qualifiers.byQualifiers(
                     // Filter by media types first before filtering by the type hierarchy
-                    new MediaTypeQualifier<>(Argument.of(MessageBodyReader.class, type), resolvedMediaTypes, Consumes.class),
+                    newMediaTypeQualifier(Argument.of(MessageBodyReader.class, type), mediaTypes, Consumes.class),
                     MatchArgumentQualifier.covariant(MessageBodyReader.class, type)
                 )
             ).stream()
-            .filter(reader -> resolvedMediaTypes.stream().anyMatch(mediaType -> reader.isReadable(type, mediaType)))
+            .filter(reader -> mediaTypes.stream().anyMatch(mediaType -> reader.isReadable(type, mediaType)))
             .findFirst()
             .orElse(null);
     }
 
+    @NonNull
+    private <T, B> MediaTypeQualifier<B> newMediaTypeQualifier(Argument<T> type,
+                                                               List<MediaType> mediaTypes,
+                                                               Class<? extends Annotation> qualifierType) {
+        List<MediaType> resolvedMediaTypes = resolveMediaTypes(mediaTypes);
+        return new MediaTypeQualifier<>(type, resolvedMediaTypes, qualifierType);
+    }
+
     @NonNull
     private List<MediaType> resolveMediaTypes(List<MediaType> mediaTypes) {
         if (codecConfigurations.isEmpty()) {
@@ -105,16 +112,15 @@ public final class DefaultMessageBodyHandlerRegistry extends AbstractMessageBody
     @SuppressWarnings({"unchecked"})
     @Override
     protected <T> MessageBodyWriter<T> findWriterImpl(Argument<T> type, List<MediaType> mediaTypes) {
-        List<MediaType> resolvedMediaTypes = resolveMediaTypes(mediaTypes);
         return beanLocator.getBeansOfType(
                 Argument.of(MessageBodyWriter.class), // Select all writers and eliminate by the type later
                 Qualifiers.byQualifiers(
                     // Filter by media types first before filtering by the type hierarchy
-                    new MediaTypeQualifier<>(Argument.of(MessageBodyWriter.class, type), resolvedMediaTypes, Produces.class),
+                    newMediaTypeQualifier(Argument.of(MessageBodyWriter.class, type), mediaTypes, Produces.class),
                     MatchArgumentQualifier.contravariant(MessageBodyWriter.class, type)
                 )
             ).stream()
-            .filter(writer -> resolvedMediaTypes.stream().anyMatch(mediaType -> writer.isWriteable(type, mediaType)))
+            .filter(writer -> mediaTypes.stream().anyMatch(mediaType -> writer.isWriteable(type, mediaType)))
             .findFirst().orElse(null);
     }
 
@@ -134,7 +140,6 @@ public final class DefaultMessageBodyHandlerRegistry extends AbstractMessageBody
         @Override
         public <K extends BeanType<T>> Collection<K> filter(Class<T> beanType, Collection<K> candidates) {
             List<K> all = new ArrayList<>(candidates.size());
-            candidatesLoop:
             for (K candidate : candidates) {
                 String[] applicableTypes = candidate.getAnnotationMetadata().stringValues(annotationType);
                 if (applicableTypes.length == 0) {
@@ -142,12 +147,9 @@ public final class DefaultMessageBodyHandlerRegistry extends AbstractMessageBody
                     continue;
                 }
                 for (String mt : applicableTypes) {
-                    MediaType mediaType = new MediaType(mt);
-                    for (MediaType m : mediaTypes) {
-                        if (m.matches(mediaType)) {
-                            all.add(candidate);
-                            continue candidatesLoop;
-                        }
+                    if (mediaTypes.contains(new MediaType(mt))) {
+                        all.add(candidate);
+                        break;
                     }
                 }
             }
diff --git a/http/src/main/java/io/micronaut/http/body/MessageBodyHandlerRegistry.java b/http/src/main/java/io/micronaut/http/body/MessageBodyHandlerRegistry.java
index d76154eda1..c4283562b2 100644
--- a/http/src/main/java/io/micronaut/http/body/MessageBodyHandlerRegistry.java
+++ b/http/src/main/java/io/micronaut/http/body/MessageBodyHandlerRegistry.java
@@ -23,6 +23,7 @@ import io.micronaut.http.MediaType;
 import io.micronaut.http.codec.CodecException;
 
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
 
 /**
@@ -79,8 +80,9 @@ public interface MessageBodyHandlerRegistry {
      * @since 4.6
      */
     default <T> Optional<MessageBodyReader<T>> findReader(@NonNull Argument<T> type,
-                                                          @Nullable MediaType mediaType) {
-        return findReader(type, mediaType == null ? List.of() : List.of(mediaType));
+                                                          @NonNull MediaType mediaType) {
+        Objects.requireNonNull(mediaType);
+        return findReader(type, List.of(mediaType));
     }
 
     /**
@@ -113,8 +115,8 @@ public interface MessageBodyHandlerRegistry {
      * @since 4.6
      */
     default <T> Optional<MessageBodyWriter<T>> findWriter(@NonNull Argument<T> type,
-                                                          @Nullable MediaType mediaType) {
-        return findWriter(type, mediaType == null ? List.of() : List.of(mediaType));
+                                                          @NonNull MediaType mediaType) {
+        return findWriter(type, List.of(mediaType));
     }
 
     /**
diff --git a/http/src/main/java/io/micronaut/http/body/ResponseBodyWriter.java b/http/src/main/java/io/micronaut/http/body/ResponseBodyWriter.java
deleted file mode 100644
index 4a9f7ff4ea..0000000000
--- a/http/src/main/java/io/micronaut/http/body/ResponseBodyWriter.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.body;
-
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.Indexed;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.io.buffer.ByteBufferFactory;
-import io.micronaut.core.type.Argument;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.HttpRequest;
-import io.micronaut.http.MediaType;
-import io.micronaut.http.MutableHttpResponse;
-import io.micronaut.http.codec.CodecException;
-
-/**
- * Extension to {@link MessageBodyWriter} that is specific to writing the server response body. This
- * allows more fine-grained control over the response than the {@link MessageBodyWriter} API.
- *
- * @param <T> The body type
- * @since 4.7.0
- * @author Jonas Konrad
- */
-@Experimental
-@Indexed(MessageBodyWriter.class)
-public interface ResponseBodyWriter<T> extends MessageBodyWriter<T> {
-    /**
-     * Writes an object as a {@link ByteBodyHttpResponse}.
-     *
-     * @param bufferFactory The buffer factory
-     * @param request       The request
-     * @param httpResponse  The response
-     * @param type          The response body type
-     * @param mediaType     The media type
-     * @param object        The object to write
-     * @return A {@link ByteBodyHttpResponse} with the response bytes
-     * @throws CodecException If an error occurs encoding
-     */
-    @NonNull
-    ByteBodyHttpResponse<?> write(
-        @NonNull ByteBufferFactory<?, ?> bufferFactory,
-        @NonNull HttpRequest<?> request,
-        @NonNull MutableHttpResponse<T> httpResponse,
-        @NonNull Argument<T> type,
-        @NonNull MediaType mediaType,
-        T object) throws CodecException;
-
-    /**
-     * Wrap the given writer, if necessary, to get a {@link ResponseBodyWriter}.
-     *
-     * @param writer The generic message writer
-     * @return The response writer
-     * @param <T> The body type
-     */
-    @NonNull
-    static <T> ResponseBodyWriter<T> wrap(@NonNull MessageBodyWriter<T> writer) {
-        if (writer instanceof ResponseBodyWriter<T> rbw) {
-            return rbw;
-        } else {
-            return new ResponseBodyWriterWrapper<>(writer);
-        }
-    }
-}
diff --git a/http/src/main/java/io/micronaut/http/body/ResponseBodyWriterWrapper.java b/http/src/main/java/io/micronaut/http/body/ResponseBodyWriterWrapper.java
deleted file mode 100644
index 48ec5a962e..0000000000
--- a/http/src/main/java/io/micronaut/http/body/ResponseBodyWriterWrapper.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.body;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.io.buffer.ByteBuffer;
-import io.micronaut.core.io.buffer.ByteBufferFactory;
-import io.micronaut.core.type.Argument;
-import io.micronaut.core.type.MutableHeaders;
-import io.micronaut.http.ByteBodyHttpResponse;
-import io.micronaut.http.ByteBodyHttpResponseWrapper;
-import io.micronaut.http.HttpRequest;
-import io.micronaut.http.MediaType;
-import io.micronaut.http.MutableHttpResponse;
-import io.micronaut.http.body.stream.AvailableByteArrayBody;
-import io.micronaut.http.codec.CodecException;
-
-import java.io.ByteArrayOutputStream;
-import java.io.OutputStream;
-
-/**
- * {@link ResponseBodyWriter} implementation that delegates to a {@link MessageBodyWriter}.
- *
- * @param <T> The body type
- * @since 4.7.0
- * @author Jonas Konrad
- */
-@Internal
-public class ResponseBodyWriterWrapper<T> implements ResponseBodyWriter<T> {
-    private final MessageBodyWriter<T> wrapped;
-
-    protected ResponseBodyWriterWrapper(MessageBodyWriter<T> wrapped) {
-        this.wrapped = wrapped;
-    }
-
-    @Override
-    public boolean isWriteable(@NonNull Argument<T> type, @Nullable MediaType mediaType) {
-        return wrapped.isWriteable(type, mediaType);
-    }
-
-    @Override
-    public MessageBodyWriter<T> createSpecific(@NonNull Argument<T> type) {
-        return wrapped.createSpecific(type);
-    }
-
-    @Override
-    public boolean isBlocking() {
-        return wrapped.isBlocking();
-    }
-
-    @Override
-    public void writeTo(@NonNull Argument<T> type, @NonNull MediaType mediaType, T object, @NonNull MutableHeaders outgoingHeaders, @NonNull OutputStream outputStream) throws CodecException {
-        wrapped.writeTo(type, mediaType, object, outgoingHeaders, outputStream);
-    }
-
-    @Override
-    public @NonNull ByteBuffer<?> writeTo(@NonNull Argument<T> type, @NonNull MediaType mediaType, T object, @NonNull MutableHeaders outgoingHeaders, @NonNull ByteBufferFactory<?, ?> bufferFactory) throws CodecException {
-        return wrapped.writeTo(type, mediaType, object, outgoingHeaders, bufferFactory);
-    }
-
-    @Override
-    public @NonNull ByteBodyHttpResponse<?> write(@NonNull ByteBufferFactory<?, ?> bufferFactory, @NonNull HttpRequest<?> request, @NonNull MutableHttpResponse<T> httpResponse, @NonNull Argument<T> type, @NonNull MediaType mediaType, T object) throws CodecException {
-        ByteArrayOutputStream baos = new ByteArrayOutputStream();
-        writeTo(type, mediaType, object, httpResponse.getHeaders(), baos);
-        return ByteBodyHttpResponseWrapper.wrap(httpResponse, AvailableByteArrayBody.create(bufferFactory, baos.toByteArray()));
-    }
-}
diff --git a/http/src/main/java/io/micronaut/http/body/TextPlainObjectBodyReader.java b/http/src/main/java/io/micronaut/http/body/TextPlainObjectBodyReader.java
index 51bd22f8fe..75eebb3273 100644
--- a/http/src/main/java/io/micronaut/http/body/TextPlainObjectBodyReader.java
+++ b/http/src/main/java/io/micronaut/http/body/TextPlainObjectBodyReader.java
@@ -62,7 +62,7 @@ public final class TextPlainObjectBodyReader<T> implements TypedMessageBodyReade
 
     @Override
     public boolean isReadable(Argument<T> type, MediaType mediaType) {
-        return mediaType != null && mediaType.matches(MediaType.TEXT_PLAIN_TYPE);
+        return mediaType == MediaType.TEXT_PLAIN_TYPE;
     }
 
     @Override
diff --git a/http/src/main/java/io/micronaut/http/codec/DefaultMediaTypeCodecRegistry.java b/http/src/main/java/io/micronaut/http/codec/DefaultMediaTypeCodecRegistry.java
index 932143aeda..0a8b7a390d 100644
--- a/http/src/main/java/io/micronaut/http/codec/DefaultMediaTypeCodecRegistry.java
+++ b/http/src/main/java/io/micronaut/http/codec/DefaultMediaTypeCodecRegistry.java
@@ -30,9 +30,7 @@ import java.util.Optional;
  *
  * @author Graeme Rocher
  * @since 1.0
- * @deprecated Replaced with {@link io.micronaut.http.body.MessageBodyHandlerRegistry}.
  */
-@Deprecated(forRemoval = true, since = "4.7")
 public class DefaultMediaTypeCodecRegistry implements MediaTypeCodecRegistry {
 
     Map<String, Optional<MediaTypeCodec>> decodersByExtension = new LinkedHashMap<>(3);
diff --git a/http/src/main/java/io/micronaut/http/codec/MediaTypeCodec.java b/http/src/main/java/io/micronaut/http/codec/MediaTypeCodec.java
index 3624d249b9..adb9d71c4f 100644
--- a/http/src/main/java/io/micronaut/http/codec/MediaTypeCodec.java
+++ b/http/src/main/java/io/micronaut/http/codec/MediaTypeCodec.java
@@ -33,9 +33,7 @@ import java.util.Collection;
  *
  * @author Graeme Rocher
  * @since 1.0
- * @deprecated Replaced with {@link io.micronaut.http.body.MessageBodyHandler}
  */
-@Deprecated(since = "4.7")
 @Indexed(MediaTypeCodec.class)
 public interface MediaTypeCodec {
 
diff --git a/http/src/main/java/io/micronaut/http/codec/MediaTypeCodecRegistry.java b/http/src/main/java/io/micronaut/http/codec/MediaTypeCodecRegistry.java
index da28d41d57..daf1c5cbd2 100644
--- a/http/src/main/java/io/micronaut/http/codec/MediaTypeCodecRegistry.java
+++ b/http/src/main/java/io/micronaut/http/codec/MediaTypeCodecRegistry.java
@@ -26,9 +26,7 @@ import java.util.Optional;
  *
  * @author Graeme Rocher
  * @since 1.0
- * @deprecated Replaced with {@link io.micronaut.http.body.MessageBodyHandlerRegistry}.
  */
-@Deprecated(since = "4.7")
 public interface MediaTypeCodecRegistry {
 
     /**
diff --git a/http/src/main/java/io/micronaut/http/simple/SimpleHttpHeaders.java b/http/src/main/java/io/micronaut/http/simple/SimpleHttpHeaders.java
index 8189d2f6af..e06f9ba4f0 100644
--- a/http/src/main/java/io/micronaut/http/simple/SimpleHttpHeaders.java
+++ b/http/src/main/java/io/micronaut/http/simple/SimpleHttpHeaders.java
@@ -39,13 +39,6 @@ public class SimpleHttpHeaders implements MutableHttpHeaders {
     private final CaseInsensitiveMutableHttpHeaders headers;
     private ConversionService conversionService;
 
-    /**
-     * Map-based implementation of {@link MutableHttpHeaders}.
-     */
-    public SimpleHttpHeaders() {
-        this(ConversionService.SHARED);
-    }
-
     /**
      * Map-based implementation of {@link MutableHttpHeaders}.
      *
diff --git a/http/src/main/java/io/micronaut/http/uri/UriTemplateMatcher.java b/http/src/main/java/io/micronaut/http/uri/UriTemplateMatcher.java
index cb44ed2ffa..103d006456 100644
--- a/http/src/main/java/io/micronaut/http/uri/UriTemplateMatcher.java
+++ b/http/src/main/java/io/micronaut/http/uri/UriTemplateMatcher.java
@@ -68,7 +68,7 @@ public final class UriTemplateMatcher implements UriMatcher, Comparable<UriTempl
         this.parts = parts;
         List<UriMatchVariable> variables = new ArrayList<>();
         this.segments = provideMatchSegments(parts, variables);
-        this.isRoot = segments.length == 0 || segments.length == 1 && segments[0].type == SegmentType.LITERAL && isRoot(segments[0].value);
+        this.isRoot = segments.length == 0 || segments[0].type == SegmentType.LITERAL && isRoot(segments[0].value);
         this.variables = Collections.unmodifiableList(variables);
     }
 
@@ -269,10 +269,9 @@ public final class UriTemplateMatcher implements UriMatcher, Comparable<UriTempl
         int parameterIndex = uri.indexOf('?');
         if (parameterIndex > -1) {
             uri = uri.substring(0, parameterIndex);
-            length = uri.length();
-            if (length > 1 && uri.charAt(length - 1) == '/') {
-                uri = uri.substring(0, length - 1);
-            }
+        }
+        if (uri.endsWith("/")) {
+            uri = uri.substring(0, uri.length() - 1);
         }
         if (variables.isEmpty()) {
             if (uri.equals(templateString)) {
diff --git a/http/src/main/java/io/micronaut/runtime/http/codec/TextPlainCodec.java b/http/src/main/java/io/micronaut/runtime/http/codec/TextPlainCodec.java
index 819660cc7c..beab892b8a 100644
--- a/http/src/main/java/io/micronaut/runtime/http/codec/TextPlainCodec.java
+++ b/http/src/main/java/io/micronaut/runtime/http/codec/TextPlainCodec.java
@@ -50,11 +50,9 @@ import java.util.Optional;
  *
  * @author Graeme Rocher
  * @since 1.0
- * @deprecated Replaced with message body writers / readers API
  */
 @Singleton
 @BootstrapContextCompatible
-@Deprecated(forRemoval = true, since = "4.7")
 public class TextPlainCodec implements MediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "text";
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java b/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java
index fa937b43f0..4af276bb43 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java
@@ -36,7 +36,6 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
@@ -78,7 +77,6 @@ abstract class AbstractInjectAnnotationProcessor extends AbstractProcessor {
     private final Set<String> supportedAnnotationTypes = new HashSet<>(5);
     private final Map<String, Boolean> isProcessedCache = new HashMap<>(30);
     private Set<String> processedTypes;
-    protected Set<String> postponedTypes = new LinkedHashSet<>();
 
     @Override
     public SourceVersion getSupportedSourceVersion() {
@@ -218,8 +216,7 @@ abstract class AbstractInjectAnnotationProcessor extends AbstractProcessor {
             modelUtils,
             filer,
             visitorAttributes,
-            getVisitorKind(),
-            postponedTypes
+            getVisitorKind()
         );
     }
 
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/AnnotationUtils.java b/inject-java/src/main/java/io/micronaut/annotation/processing/AnnotationUtils.java
index 81685124ce..067c42e35b 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/AnnotationUtils.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/AnnotationUtils.java
@@ -29,7 +29,6 @@ import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import java.util.Set;
 
 /**
  * Utility methods for annotations.
@@ -144,8 +143,7 @@ public class AnnotationUtils {
             modelUtils,
             filer,
             visitorAttributes,
-            TypeElementVisitor.VisitorKind.ISOLATING,
-            Set.of()
+            TypeElementVisitor.VisitorKind.ISOLATING
         );
     }
 
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java b/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
index 3eacf20325..9822fdb1b7 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
@@ -107,6 +107,7 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
 
     private List<LoadedVisitor> loadedVisitors;
     private Collection<? extends TypeElementVisitor<?, ?>> typeElementVisitors;
+    private final Set<String> pendingTypes = new LinkedHashSet<>();
 
     /**
      * The visited annotation names.
@@ -240,8 +241,8 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
                 roundEnv.getRootElements()
             ).filter(notGroovyObject).forEach(elements::add);
 
-            postponedTypes.stream().map(elementUtils::getTypeElement).filter(Objects::nonNull).forEach(elements::add);
-            postponedTypes.clear();
+            pendingTypes.stream().map(elementUtils::getTypeElement).filter(Objects::nonNull).forEach(elements::add);
+            pendingTypes.clear();
 
             if (!elements.isEmpty()) {
 
@@ -271,7 +272,7 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
                             }
                             error(originatingElement.element(), e.getMessage());
                         } catch (PostponeToNextRoundException e) {
-                            postponedTypes.add(javaClassElement.getName());
+                            pendingTypes.add(javaClassElement.getName());
                         }
                     }
                 }
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
index d9059e1f78..4dbefa908f 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
@@ -52,7 +52,6 @@ import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import java.lang.annotation.Annotation;
@@ -266,15 +265,11 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
     @Override
     public Collection<ClassElement> getInterfaces() {
         if (resolvedInterfaces == null) {
-            resolvedInterfaces = classElement.getInterfaces().stream().filter(this::onlyAvailable).map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
+            resolvedInterfaces = classElement.getInterfaces().stream().map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
         }
         return resolvedInterfaces;
     }
 
-    private boolean onlyAvailable(TypeMirror mirror) {
-        return !(mirror instanceof DeclaredType declaredType) || declaredType.getKind() != TypeKind.ERROR;
-    }
-
     @Override
     public Optional<ClassElement> getSuperType() {
         if (resolvedSuperType == null) {
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java
index be7a7e5662..b9966d8988 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java
@@ -17,7 +17,6 @@ package io.micronaut.annotation.processing.visitor;
 
 import io.micronaut.annotation.processing.AnnotationProcessingOutputVisitor;
 import io.micronaut.annotation.processing.AnnotationUtils;
-import io.micronaut.inject.visitor.ElementPostponedToNextRoundException;
 import io.micronaut.annotation.processing.GenericUtils;
 import io.micronaut.annotation.processing.JavaAnnotationMetadataBuilder;
 import io.micronaut.annotation.processing.JavaElementAnnotationMetadataFactory;
@@ -67,7 +66,6 @@ import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Enumeration;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -102,7 +100,6 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
     private final JavaElementAnnotationMetadataFactory elementAnnotationMetadataFactory;
     private final JavaNativeElementsHelper nativeElementsHelper;
     private final Filer filer;
-    private final Set<String> postponedTypes;
 
     /**
      * The default constructor.
@@ -131,7 +128,7 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
         Filer filer,
         MutableConvertibleValues<Object> visitorAttributes,
         TypeElementVisitor.VisitorKind visitorKind) {
-        this(processingEnv, messager, elements, types, modelUtils, filer, visitorAttributes, visitorKind, new HashSet<>());
+        this(processingEnv, messager, elements, types, modelUtils, filer, visitorAttributes, visitorKind);
     }
 
     /**
@@ -145,9 +142,7 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
      * @param filer The filer
      * @param visitorAttributes The attributes
      * @param visitorKind The visitor kind
-     * @deprecated No longer needed
      */
-    @Deprecated(forRemoval = true, since = "4.7.0")
     public JavaVisitorContext(
         ProcessingEnvironment processingEnv,
         Messager messager,
@@ -157,32 +152,6 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
         Filer filer,
         MutableConvertibleValues<Object> visitorAttributes,
         TypeElementVisitor.VisitorKind visitorKind) {
-        this(processingEnv, messager, elements, types, modelUtils, filer, visitorAttributes, visitorKind, Set.of());
-    }
-
-    /**
-     * The default constructor.
-     *
-     * @param processingEnv The processing environment
-     * @param messager The messager
-     * @param elements The elements
-     * @param types Type types
-     * @param modelUtils The model utils
-     * @param filer The filer
-     * @param visitorAttributes The attributes
-     * @param visitorKind The visitor kind
-     * @param postponedTypes The postponed types
-     */
-    public JavaVisitorContext(
-        ProcessingEnvironment processingEnv,
-        Messager messager,
-        Elements elements,
-        Types types,
-        ModelUtils modelUtils,
-        Filer filer,
-        MutableConvertibleValues<Object> visitorAttributes,
-        TypeElementVisitor.VisitorKind visitorKind,
-        Set<String> postponedTypes) {
         this.messager = messager;
         this.elements = elements;
         this.types = types;
@@ -197,7 +166,6 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
         this.elementAnnotationMetadataFactory = new JavaElementAnnotationMetadataFactory(false, this.annotationMetadataBuilder);
         this.expressionCompilationContextFactory = new DefaultExpressionCompilationContextFactory(this);
         this.filer = filer;
-        this.postponedTypes = postponedTypes;
     }
 
     @Override
@@ -353,29 +321,13 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
         }
     }
 
-    private void checkForPostponedOriginalElement(io.micronaut.inject.ast.Element originatingElement) {
-        if (originatingElement != null && postponedTypes.contains(originatingElement.getName())) {
-            throw new ElementPostponedToNextRoundException(originatingElement);
-        }
-    }
-
-    private void checkForPostponedOriginalElements(io.micronaut.inject.ast.Element[] originatingElements) {
-        if (originatingElements != null) {
-            for (io.micronaut.inject.ast.Element originatingElement : originatingElements) {
-                checkForPostponedOriginalElement(originatingElement);
-            }
-        }
-    }
-
     @Override
     public OutputStream visitClass(String classname, @Nullable io.micronaut.inject.ast.Element originatingElement) throws IOException {
-        checkForPostponedOriginalElement(originatingElement);
         return outputVisitor.visitClass(classname, new io.micronaut.inject.ast.Element[] {originatingElement});
     }
 
     @Override
     public OutputStream visitClass(String classname, io.micronaut.inject.ast.Element... originatingElements) throws IOException {
-        checkForPostponedOriginalElements(originatingElements);
         return outputVisitor.visitClass(classname, originatingElements);
     }
 
@@ -386,13 +338,11 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
 
     @Override
     public void visitServiceDescriptor(String type, String classname, io.micronaut.inject.ast.Element originatingElement) {
-        checkForPostponedOriginalElement(originatingElement);
         outputVisitor.visitServiceDescriptor(type, classname, originatingElement);
     }
 
     @Override
     public Optional<GeneratedFile> visitMetaInfFile(String path, io.micronaut.inject.ast.Element... originatingElements) {
-        checkForPostponedOriginalElements(originatingElements);
         return outputVisitor.visitMetaInfFile(path, originatingElements);
     }
 
@@ -403,13 +353,11 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
 
     @Override
     public Optional<GeneratedFile> visitGeneratedFile(String path, io.micronaut.inject.ast.Element... originatingElements) {
-        checkForPostponedOriginalElements(originatingElements);
         return outputVisitor.visitGeneratedFile(path, originatingElements);
     }
 
     @Override
     public Optional<GeneratedFile> visitGeneratedSourceFile(String packageName, String fileNameWithoutExtension, io.micronaut.inject.ast.Element... originatingElements) {
-        checkForPostponedOriginalElements(originatingElements);
         return outputVisitor.visitGeneratedSourceFile(packageName, fileNameWithoutExtension, originatingElements);
     }
 
diff --git a/inject-kotlin-test/build.gradle b/inject-kotlin-test/build.gradle
index 2b3231dc95..4a4c5328e9 100644
--- a/inject-kotlin-test/build.gradle
+++ b/inject-kotlin-test/build.gradle
@@ -13,7 +13,7 @@ dependencies {
     api(libs.managed.ksp)
     implementation(libs.managed.kotlin.compiler.embeddable)
     implementation "com.squareup.okio:okio:3.9.0"
-    implementation "io.github.classgraph:classgraph:4.8.175"
+    implementation "io.github.classgraph:classgraph:4.8.174"
     testImplementation libs.javax.persistence
     testImplementation project(":runtime")
     api libs.blaze.persistence.core
diff --git a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
index 4eeded5f72..1d331c209f 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
@@ -459,15 +459,12 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
     }
 
     @Override
-    protected <T> void collectIterableBeans(@Nullable BeanResolutionContext resolutionContext,
-                                            @NonNull BeanDefinition<T> iterableBean,
-                                            @NonNull Set<BeanDefinition<T>> targetSet,
-                                            @NonNull Argument<T> beanType) {
+    protected <T> void collectIterableBeans(BeanResolutionContext resolutionContext, BeanDefinition<T> iterableBean, Set<BeanDefinition<T>> targetSet) {
         try (BeanResolutionContext rc = newResolutionContext(iterableBean, resolutionContext)) {
             if (iterableBean.hasDeclaredStereotype(EachProperty.class)) {
                 transformEachPropertyBeanDefinition(rc, iterableBean, targetSet);
             } else if (iterableBean.hasDeclaredStereotype(EachBean.class)) {
-                transformEachBeanBeanDefinition(rc, iterableBean, targetSet, beanType);
+                transformEachBeanBeanDefinition(rc, iterableBean, targetSet);
             } else {
                 transformConfigurationReaderBeanDefinition(rc, iterableBean, targetSet);
             }
@@ -547,8 +544,7 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
 
     private <T> void transformEachBeanBeanDefinition(@NonNull BeanResolutionContext resolutionContext,
                                                      BeanDefinition<T> originBeanDefinition,
-                                                     Set<BeanDefinition<T>> transformedCandidates,
-                                                     @NonNull Argument<T> beanType) {
+                                                     Set<BeanDefinition<T>> transformedCandidates) {
         AnnotationValue<EachBean> annotationValue = originBeanDefinition.getAnnotation(EachBean.class);
         if (annotationValue == null) {
             transformedCandidates.add(originBeanDefinition);
@@ -595,7 +591,7 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
                         delegateTypeArguments = typeArguments;
                     }
                     BeanDefinitionDelegate<?> delegate = BeanDefinitionDelegate.create(originBeanDefinition, (Qualifier<T>) qualifier, delegateTypeArguments);
-                    if (delegate.isEnabled(this, resolutionContext) && delegate.isCandidateBean(beanType)) {
+                    if (delegate.isEnabled(this, resolutionContext)) {
                         transformedCandidates.add((BeanDefinition<T>) delegate);
                     }
                 }
@@ -604,8 +600,8 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
     }
 
     private <T> void transformEachPropertyBeanDefinition(@NonNull BeanResolutionContext resolutionContext,
-                                                         @NonNull BeanDefinition<T> candidate,
-                                                         @NonNull Set<BeanDefinition<T>> transformedCandidates) {
+                                                         BeanDefinition<T> candidate,
+                                                         Set<BeanDefinition<T>> transformedCandidates) {
         try {
             final String prefix = candidate.stringValue(ConfigurationReader.class, ConfigurationReader.PREFIX).orElse(null);
             if (prefix != null) {
diff --git a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
index ae0471ea4c..ac69388e77 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
@@ -72,7 +72,7 @@ import io.micronaut.core.convert.TypeConverterRegistrar;
 import io.micronaut.core.convert.value.MutableConvertibleValues;
 import io.micronaut.core.io.ResourceLoader;
 import io.micronaut.core.io.scan.ClassPathResourceLoader;
-import io.micronaut.core.io.service.MicronautMetaServiceLoaderUtils;
+import io.micronaut.core.io.service.SoftServiceLoader;
 import io.micronaut.core.naming.NameResolver;
 import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.naming.Named;
@@ -1876,11 +1876,9 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     @NonNull
     protected List<BeanDefinitionReference> resolveBeanDefinitionReferences() {
         if (beanDefinitionReferences == null) {
-            beanDefinitionReferences = MicronautMetaServiceLoaderUtils.findMetaMicronautServiceEntries(
-                classLoader,
-                BeanDefinitionReference.class,
-                BeanDefinitionReference::isPresent
-            );
+            final SoftServiceLoader<BeanDefinitionReference> definitions = SoftServiceLoader.load(BeanDefinitionReference.class, classLoader);
+            beanDefinitionReferences = new ArrayList<>(300);
+            definitions.collectAll(beanDefinitionReferences, BeanDefinitionReference::isPresent);
         }
         return beanDefinitionReferences;
     }
@@ -1915,11 +1913,9 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     @NonNull
     protected Iterable<BeanConfiguration> resolveBeanConfigurations() {
         if (beanConfigurationsList == null) {
-            beanConfigurationsList = MicronautMetaServiceLoaderUtils.findMetaMicronautServiceEntries(
-                classLoader,
-                BeanConfiguration.class,
-                null
-            );
+            final SoftServiceLoader<BeanConfiguration> definitions = SoftServiceLoader.load(BeanConfiguration.class, classLoader);
+            beanConfigurationsList = new ArrayList<>(300);
+            definitions.collectAll(beanConfigurationsList, null);
         }
         return beanConfigurationsList;
     }
@@ -2169,7 +2165,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                 }
 
                 if (collectIterables && loadedBean.isConfigurationProperties()) {
-                    collectIterableBeans(resolutionContext, loadedBean, candidates, beanType);
+                    collectIterableBeans(resolutionContext, loadedBean, candidates);
                 } else {
                     candidates.add(loadedBean);
                 }
@@ -2199,13 +2195,9 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
      * @param resolutionContext The resolution context
      * @param iterableBean The iterable
      * @param targetSet The target set
-     * @param beanType The bean type
      * @param <T> The bean type
      */
-    protected <T> void collectIterableBeans(@Nullable BeanResolutionContext resolutionContext,
-                                            @NonNull BeanDefinition<T> iterableBean,
-                                            @NonNull Set<BeanDefinition<T>> targetSet,
-                                            @NonNull Argument<T> beanType) {
+    protected <T> void collectIterableBeans(@Nullable BeanResolutionContext resolutionContext, @NonNull BeanDefinition<T> iterableBean, Set<BeanDefinition<T>> targetSet) {
         // no-op
     }
 
@@ -2686,8 +2678,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
             collectIterableBeans(
                 null,
                 beanDefinition,
-                beanCandidates,
-                Argument.OBJECT_ARGUMENT
+                beanCandidates
             );
             for (BeanDefinition beanCandidate : beanCandidates) {
                 findOrCreateSingletonBeanRegistration(
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JacksonMediaTypeCodec.java b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JacksonMediaTypeCodec.java
index 41e3d97147..cf9bca1b80 100644
--- a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JacksonMediaTypeCodec.java
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JacksonMediaTypeCodec.java
@@ -41,9 +41,7 @@ import java.io.IOException;
  *
  * @author Graeme Rocher
  * @since 1.0.0
- * @deprecated Replaced with message body writers / readers API
  */
-@Deprecated(forRemoval = true, since = "4.7")
 public abstract class JacksonMediaTypeCodec extends MapperMediaTypeCodec {
 
     public static final String REGULAR_JSON_MEDIA_TYPE_CODEC_NAME = "json";
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonMediaTypeCodec.java b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonMediaTypeCodec.java
index 90942132d4..1de93fa5ed 100644
--- a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonMediaTypeCodec.java
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonMediaTypeCodec.java
@@ -36,14 +36,12 @@ import jakarta.inject.Singleton;
  *
  * @author Graeme Rocher
  * @since 1.0.0
- * @deprecated Replaced with message body writers / readers API
  */
 @Named("json")
 @Singleton
 @Secondary
 @BootstrapContextCompatible
 @Bean(typed = {JsonMediaTypeCodec.class, JacksonMediaTypeCodec.class}) // do not expose MapperMediaTypeCodec
-@Deprecated(forRemoval = true, since = "4.7")
 public class JsonMediaTypeCodec extends JacksonMediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "json";
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonStreamMediaTypeCodec.java b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonStreamMediaTypeCodec.java
index 021b9485ad..2244c6e37a 100644
--- a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonStreamMediaTypeCodec.java
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonStreamMediaTypeCodec.java
@@ -41,13 +41,11 @@ import java.util.List;
  *
  * @author Graeme Rocher
  * @since 1.0
- * @deprecated Replaced with message body writers / readers API
  */
 @Secondary
 @Singleton
 @BootstrapContextCompatible
 @Bean(typed = {JsonStreamMediaTypeCodec.class, JacksonMediaTypeCodec.class}) // do not expose MapperMediaTypeCodec
-@Deprecated(forRemoval = true, since = "4.7")
 public class JsonStreamMediaTypeCodec extends JsonMediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "json-stream";
diff --git a/json-core/src/main/java/io/micronaut/json/body/JsonMessageHandler.java b/json-core/src/main/java/io/micronaut/json/body/JsonMessageHandler.java
index 8111fe6e77..878b235d50 100644
--- a/json-core/src/main/java/io/micronaut/json/body/JsonMessageHandler.java
+++ b/json-core/src/main/java/io/micronaut/json/body/JsonMessageHandler.java
@@ -18,7 +18,6 @@ package io.micronaut.json.body;
 import io.micronaut.context.annotation.BootstrapContextCompatible;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Order;
 import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.io.buffer.ReferenceCounted;
 import io.micronaut.core.type.Argument;
@@ -31,7 +30,6 @@ import io.micronaut.http.annotation.Produces;
 import io.micronaut.http.body.MessageBodyHandler;
 import io.micronaut.http.body.MessageBodyWriter;
 import io.micronaut.http.codec.CodecException;
-import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
 import jakarta.inject.Singleton;
 
@@ -54,18 +52,12 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * @author Jonas Konrad
  * @since 4.0.0
  */
-@Order(JsonMessageHandler.ORDER)
 @Experimental
 @Singleton
 @JsonMessageHandler.ProducesJson
 @JsonMessageHandler.ConsumesJson
 @BootstrapContextCompatible
-public final class JsonMessageHandler<T> implements MessageBodyHandler<T>, CustomizableJsonHandler {
-
-    /**
-     * The JSON handler should be preferred if for any type.
-     */
-    public static final int ORDER = -10;
+public final class JsonMessageHandler<T> implements MessageBodyHandler<T> {
 
     private final JsonMapper jsonMapper;
 
@@ -85,7 +77,7 @@ public final class JsonMessageHandler<T> implements MessageBodyHandler<T>, Custo
 
     @Override
     public boolean isReadable(@NonNull Argument<T> type, MediaType mediaType) {
-        return mediaType != null && mediaType.matchesExtension(MediaType.EXTENSION_JSON);
+        return mediaType != null && mediaType.getExtension().equals(MediaType.EXTENSION_JSON);
     }
 
     private static CodecException decorateRead(Argument<?> type, IOException e) {
@@ -122,7 +114,7 @@ public final class JsonMessageHandler<T> implements MessageBodyHandler<T>, Custo
 
     @Override
     public boolean isWriteable(@NonNull Argument<T> type, MediaType mediaType) {
-        return mediaType != null && mediaType.matchesExtension(MediaType.EXTENSION_JSON);
+        return mediaType != null && mediaType.getExtension().equals(MediaType.EXTENSION_JSON);
     }
 
     private static CodecException decorateWrite(Object object, IOException e) {
@@ -143,11 +135,6 @@ public final class JsonMessageHandler<T> implements MessageBodyHandler<T>, Custo
         }
     }
 
-    @Override
-    public CustomizableJsonHandler customize(JsonFeatures jsonFeatures) {
-        return new JsonMessageHandler<>(jsonMapper.cloneWithFeatures(jsonFeatures));
-    }
-
     /**
      * A {@link Produces} with JSON supported types.
      */
diff --git a/json-core/src/main/java/io/micronaut/json/codec/JsonMediaTypeCodec.java b/json-core/src/main/java/io/micronaut/json/codec/JsonMediaTypeCodec.java
index 4b4da776ff..74cc1fd7fc 100644
--- a/json-core/src/main/java/io/micronaut/json/codec/JsonMediaTypeCodec.java
+++ b/json-core/src/main/java/io/micronaut/json/codec/JsonMediaTypeCodec.java
@@ -35,13 +35,11 @@ import java.util.List;
  *
  * @author Graeme Rocher
  * @since 1.0.0
- * @deprecated Replaced with message body writers / readers API
  */
 @Experimental
 @Named(MapperMediaTypeCodec.REGULAR_JSON_MEDIA_TYPE_CODEC_NAME)
 @Singleton
 @BootstrapContextCompatible
-@Deprecated(forRemoval = true, since = "4.7")
 public class JsonMediaTypeCodec extends MapperMediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "json";
diff --git a/json-core/src/main/java/io/micronaut/json/codec/JsonStreamMediaTypeCodec.java b/json-core/src/main/java/io/micronaut/json/codec/JsonStreamMediaTypeCodec.java
index 507f943a86..358aa19dbf 100644
--- a/json-core/src/main/java/io/micronaut/json/codec/JsonStreamMediaTypeCodec.java
+++ b/json-core/src/main/java/io/micronaut/json/codec/JsonStreamMediaTypeCodec.java
@@ -37,12 +37,10 @@ import java.util.List;
  *
  * @author Graeme Rocher
  * @since 1.0
- * @deprecated Replaced with message body writers / readers API
  */
 @Experimental
 @Singleton
 @BootstrapContextCompatible
-@Deprecated(forRemoval = true, since = "4.7")
 public class JsonStreamMediaTypeCodec extends JsonMediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "json-stream";
diff --git a/json-core/src/main/java/io/micronaut/json/codec/MapperMediaTypeCodec.java b/json-core/src/main/java/io/micronaut/json/codec/MapperMediaTypeCodec.java
index 38bcbe8056..79d80be54d 100644
--- a/json-core/src/main/java/io/micronaut/json/codec/MapperMediaTypeCodec.java
+++ b/json-core/src/main/java/io/micronaut/json/codec/MapperMediaTypeCodec.java
@@ -47,9 +47,7 @@ import java.util.List;
  * @author Graeme Rocher
  * @author svishnyakov
  * @since 1.3.0
- * @deprecated Replaced with message body writers / readers API
  */
-@Deprecated(since = "4.7")
 @Experimental
 public abstract class MapperMediaTypeCodec implements MediaTypeCodec {
     public static final String REGULAR_JSON_MEDIA_TYPE_CODEC_NAME = "json";
diff --git a/retry/src/main/java/io/micronaut/retry/intercept/SimpleRetry.java b/retry/src/main/java/io/micronaut/retry/intercept/SimpleRetry.java
index c4f06fe796..c4c43859f7 100644
--- a/retry/src/main/java/io/micronaut/retry/intercept/SimpleRetry.java
+++ b/retry/src/main/java/io/micronaut/retry/intercept/SimpleRetry.java
@@ -46,7 +46,7 @@ class SimpleRetry implements RetryState, MutableRetryState {
     private final Class<? extends Throwable> capturedException;
 
     /**
-     * @param maxAttempts The maximum number of attempts
+     * @param maxAttempts The maximum number of attemps
      * @param multiplier The multiplier to use between delays
      * @param delay The overall delay so far
      * @param maxDelay The maximum overall delay
@@ -70,7 +70,7 @@ class SimpleRetry implements RetryState, MutableRetryState {
     }
 
     /**
-     * @param maxAttempts The maximum number of attempts
+     * @param maxAttempts The maximum number of attemps
      * @param multiplier The multiplier to use between delays
      * @param delay The overall delay so far
      * @param maxDelay The maximum overall delay
@@ -81,7 +81,7 @@ class SimpleRetry implements RetryState, MutableRetryState {
     }
 
     /**
-     * @param maxAttempts The maximum number of attempts
+     * @param maxAttempts The maximum number of attemps
      * @param multiplier The multiplier to use between delays
      * @param delay The overall delay so far
      */
diff --git a/settings.gradle b/settings.gradle
index de7de3415e..740a14d754 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -6,7 +6,7 @@ pluginManagement {
 }
 
 plugins {
-    id 'io.micronaut.build.shared.settings' version '7.2.1'
+    id 'io.micronaut.build.shared.settings' version '7.2.0'
 }
 enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")
 
@@ -82,10 +82,7 @@ include "test-suite-logback"
 include "test-suite-logback-external-configuration"
 include "test-suite-logback-graalvm"
 include "test-suite-netty-ssl-graalvm"
-include "test-suite-kotlin-graalvm"
 include "test-utils"
-include "test-suite-annotation-remapper"
-include "test-suite-annotation-remapper-visitor"
 
 // benchmarks
 include "benchmarks"
diff --git a/src/main/docs/guide/quickStart/ideSetup/vsCodeSetup.adoc b/src/main/docs/guide/quickStart/ideSetup/vsCodeSetup.adoc
index dee1f9dfdb..26f3d5e8e8 100644
--- a/src/main/docs/guide/quickStart/ideSetup/vsCodeSetup.adoc
+++ b/src/main/docs/guide/quickStart/ideSetup/vsCodeSetup.adoc
@@ -1,27 +1,34 @@
-The Micronaut framework can easily be set up within Visual Studio Code by installing the following two extensions:
+The Micronaut framework can be set up within Visual Studio Code in one of two ways.
 
-* https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[The Microsoft Extension Pack for Java]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools[Tools for Micronaut framework]
+==== Option 1) GraalVM Extension Pack for Java
 
-These extensions can be installed by clicking on the *Install* button in the banner of the pages linked above, or, by searching for the extensions within VS Code.
+The prefered way is using the https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm-pack[GraalVM Extension Pack for Java] which ships with an https://netbeans.apache.org/[Apache NetBeans] Language server.
 
-image::installing-tools-for-micronaut-vs-code.gif[Installing Micronaut tools, 1024, 1024]
+NOTE: It is not possible to have both the official https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[Java Extension Pack] and the GraalVM Extension Pack for Java installed at the same time so if you prefer the former, skip this section and go to Option 2)
 
-Once they are installed they will give you access to a host of Micronaut specific features such as:
+The https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm[GraalVM Tools for Java] are preferred since they delegate to the build system for running applications and tests which means there is no additional setup or differences with regard to how javac is configured for annotation processing when compared to the https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[Java Extension Pack] which is based on the Eclipse compiler.
 
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut#create-a-new-micronaut-project[An application creation wizard]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#view-defined-beans-and-endpoints[Viewing beans and REST endpoints]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#compose-rest-queries[Composing REST queries and running them]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#editor-support-for-micronaut-expression-language[Support for the Micronaut Expression Language]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#monitor-and-manage-your-micronaut-application[A Micronaut Tools Activity view for running and monitoring your applications]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#observe-your-micronaut-application-using-the-micronaut-control-panel[Support for using the Micronaut Control Panel]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#debug-your-micronaut-application[Debugging your application]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#package-your-micronaut-application[Support for packaging your application as a container]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#connect-to-an-oracle-autonomous-database[Support for connecting to and working with an Oracle Database]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#deploy-your-micronaut-application-to-oracle-cloud-infrastructure[Advanced support for deploying your applications to Oracle Cloud Infrastructure]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#create-entity-classes-and-repository-interfaces-from-an-existing-database-schema[Advanced support for creating Micronaut Data entities, repositories and controllers from existing database schemas]
-* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#create-tests-for-micronaut-controller-endpoints[Test creation for Micronaut Data controllers endpoints]
+The GraalVM Extension Pack also includes the https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut[GraalVM Tools for Micronaut] extension which features:
 
-Once the extensions are installed just type `code .` in any Micronaut project directory and the project will be opened within VS Code.
+* An application creation wizard
+* Code completion for YAML configuration
+* Pallet commands to build, deploy, create Native Images etc.
+
+==== Option 2) Red Hat/Microsoft Java Extension Pack
+
+First install the https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[Java Extension Pack].
+
+TIP: You can also optionally install https://marketplace.visualstudio.com/items?itemName=Pivotal.vscode-spring-boot[STS] to enable code completion for `application.yml`.
+
+If you use Gradle, prior to opening the project in VSC run the following command from a terminal window:
+
+[source,bash]
+----
+./gradlew eclipse
+----
+
+NOTE: If you don't run the above command beforehand then annotation processing will not be configured correctly and the application will not work.
+
+Once the extension pack is installed just type `code .` in any project directory and the project will be automatically set up.
 
 NOTE: For macOS, you need to install the `code` command https://code.visualstudio.com/docs/setup/mac[by following these instructions].
diff --git a/src/main/docs/guide/toc.yml b/src/main/docs/guide/toc.yml
index 05a05ce20c..eb84e593f4 100644
--- a/src/main/docs/guide/toc.yml
+++ b/src/main/docs/guide/toc.yml
@@ -9,9 +9,9 @@ quickStart:
   ideSetup:
     title: Setting up an IDE
     ideaSetup: IntelliJ IDEA
-    vsCodeSetup: Visual Studio Code
     eclipseSetup: Eclipse
     netbeansSetup: Apache NetBeans
+    vsCodeSetup: Visual Studio Code
   creatingClient: Creating a Client
   deployingApp: Deploying the Application
 ioc:
diff --git a/src/main/docs/resources/img/installing-tools-for-micronaut-vs-code.gif b/src/main/docs/resources/img/installing-tools-for-micronaut-vs-code.gif
deleted file mode 100644
index 29941fe072..0000000000
Binary files a/src/main/docs/resources/img/installing-tools-for-micronaut-vs-code.gif and /dev/null differ
diff --git a/test-suite-annotation-remapper-visitor/build.gradle b/test-suite-annotation-remapper-visitor/build.gradle
deleted file mode 100644
index b5758ffb82..0000000000
--- a/test-suite-annotation-remapper-visitor/build.gradle
+++ /dev/null
@@ -1,11 +0,0 @@
-plugins {
-    id "java"
-}
-
-description = "A simple remapping visitor"
-
-dependencies {
-    implementation(projects.injectJava)
-    // Use an enum that shouldn't be present and the runtime to simulate added enum value that doesn't exist
-    implementation libs.blaze.persistence.core
-}
diff --git a/test-suite-annotation-remapper-visitor/src/main/java/example/micronaut/AddAnnotationWithEnumVisitor.java b/test-suite-annotation-remapper-visitor/src/main/java/example/micronaut/AddAnnotationWithEnumVisitor.java
deleted file mode 100644
index 2c5355d76c..0000000000
--- a/test-suite-annotation-remapper-visitor/src/main/java/example/micronaut/AddAnnotationWithEnumVisitor.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package example.micronaut;
-
-import com.blazebit.persistence.spi.JpqlFunctionKind;
-import io.micronaut.inject.ast.ClassElement;
-import io.micronaut.inject.visitor.TypeElementVisitor;
-import io.micronaut.inject.visitor.VisitorContext;
-
-public class AddAnnotationWithEnumVisitor implements TypeElementVisitor<Object, Object> {
-
-    @Override
-    public VisitorKind getVisitorKind() {
-        return VisitorKind.ISOLATING;
-    }
-
-    @Override
-    public void visitClass(ClassElement element, VisitorContext context) {
-            // Simulate annotating with enum value
-            // Micronaut should store the string value and not the enum value in the metadata
-        element.annotate("Something", builder -> builder.value(JpqlFunctionKind.DETERMINISTIC));
-    }
-}
diff --git a/test-suite-annotation-remapper-visitor/src/main/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor b/test-suite-annotation-remapper-visitor/src/main/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor
deleted file mode 100644
index d630212781..0000000000
--- a/test-suite-annotation-remapper-visitor/src/main/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor
+++ /dev/null
@@ -1 +0,0 @@
-example.micronaut.AddAnnotationWithEnumVisitor
diff --git a/test-suite-annotation-remapper/build.gradle b/test-suite-annotation-remapper/build.gradle
deleted file mode 100644
index cf05507e95..0000000000
--- a/test-suite-annotation-remapper/build.gradle
+++ /dev/null
@@ -1,34 +0,0 @@
-plugins {
-    id "java"
-    id "org.graalvm.buildtools.native"
-}
-
-description = "Test suite for definitions with added enum values"
-
-tasks.withType(Test).configureEach {
-    useJUnitPlatform()
-}
-
-dependencies {
-    testAnnotationProcessor(projects.testSuiteAnnotationRemapperVisitor)
-    testAnnotationProcessor(projects.injectJava)
-    testImplementation(projects.httpServerNetty)
-    implementation(projects.jacksonDatabind)
-    testImplementation(projects.httpClient)
-    testImplementation(libs.logback.classic)
-    testImplementation(libs.micronaut.test.junit5) {
-        exclude group: 'io.micronaut'
-    }
-}
-
-graalvmNative {
-    toolchainDetection = false
-    metadataRepository {
-        enabled = true
-    }
-    binaries {
-        configureEach {
-            resources.autodetect()
-        }
-    }
-}
diff --git a/test-suite-kotlin-graalvm/build.gradle b/test-suite-kotlin-graalvm/build.gradle
deleted file mode 100644
index 2c950d3bec..0000000000
--- a/test-suite-kotlin-graalvm/build.gradle
+++ /dev/null
@@ -1,51 +0,0 @@
-plugins {
-    id "org.graalvm.buildtools.native"
-    alias libs.plugins.managed.kotlin.jvm
-    alias libs.plugins.managed.ksp
-}
-
-description = "Test suite for Kotlin in native image"
-
-tasks.withType(Test).configureEach {
-    useJUnitPlatform()
-}
-
-dependencies {
-    kspTest(projects.injectKotlin)
-    testImplementation(projects.httpServerNetty)
-    testImplementation(projects.httpClient)
-    testImplementation(projects.jacksonDatabind)
-    testImplementation(libs.logback.classic)
-    testImplementation(libs.micronaut.test.junit5) {
-        exclude group: 'io.micronaut'
-    }
-    testImplementation libs.managed.kotlinx.coroutines.core
-    testImplementation libs.managed.kotlinx.coroutines.jdk8
-    testImplementation libs.managed.kotlinx.coroutines.reactive
-    testImplementation libs.managed.kotlinx.coroutines.reactor
-
-    testImplementation platform(libs.test.boms.micronaut.kotlin)
-    testImplementation (libs.micronaut.kotlin.runtime) {
-        exclude group: 'io.micronaut'
-    }
-}
-
-graalvmNative {
-    toolchainDetection = false
-    metadataRepository {
-        enabled = true
-    }
-    binaries {
-        configureEach {
-            resources.autodetect()
-        }
-    }
-}
-
-configurations.testRuntimeClasspath {
-    resolutionStrategy.eachDependency {
-        if (it.requested.group == 'org.jetbrains.kotlin') {
-            it.useVersion(libs.versions.managed.kotlin.asProvider().get())
-        }
-    }
-}
