diff --git a/.github/workflows/gradle.yml b/.github/workflows/gradle.yml
index be653308d2..909b5fd20d 100644
--- a/.github/workflows/gradle.yml
+++ b/.github/workflows/gradle.yml
@@ -78,7 +78,7 @@ jobs:
 
       - name: "ðŸ“œ Upload binary compatibility check results"
         if: matrix.java == '17'
-        uses: actions/upload-artifact@834a144ee995460fba8ed112a2fc961b36a5ec5a # v4.3.6
+        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
         with:
           name: binary-compatibility-reports
           path: "**/build/reports/binary-compatibility-*.html"
diff --git a/.github/workflows/release.yml b/.github/workflows/release.yml
index 9efeb20405..bae97dd915 100644
--- a/.github/workflows/release.yml
+++ b/.github/workflows/release.yml
@@ -66,13 +66,13 @@ jobs:
           # Store the hash in a file, which is uploaded as a workflow artifact.
           sha256sum $ARTIFACTS | base64 -w0 > artifacts-sha256
       - name: Upload build artifacts
-        uses: actions/upload-artifact@834a144ee995460fba8ed112a2fc961b36a5ec5a # v4.3.6
+        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
         with:
           name: gradle-build-outputs
           path: build/repo/${{ steps.publish.outputs.group }}/*/${{ steps.publish.outputs.version }}/*
           retention-days: 5
       - name: Upload artifacts-sha256
-        uses: actions/upload-artifact@834a144ee995460fba8ed112a2fc961b36a5ec5a # v4.3.6
+        uses: actions/upload-artifact@50769540e7f4bd5e21e526ee35c689e35e0d6874 # v4.4.0
         with:
           name: artifacts-sha256
           path: artifacts-sha256
@@ -160,6 +160,6 @@ jobs:
       - name: Upload assets
         # Upload the artifacts to the existing release. Note that the SLSA provenance will
         # attest to each artifact file and not the aggregated ZIP file.
-        uses: softprops/action-gh-release@de2c0eb89ae2a093876385947365aca7b0e5f844 # v0.1.15
+        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
         with:
           files: artifacts.zip
diff --git a/benchmarks/build.gradle b/benchmarks/build.gradle
index d2d34f5727..2f41c6f90d 100644
--- a/benchmarks/build.gradle
+++ b/benchmarks/build.gradle
@@ -43,8 +43,8 @@ dependencies {
 
     typeCheckTestImplementation libs.junit.jupiter
     typeCheckTestImplementation libs.micronaut.test.type.pollution
-    typeCheckTestImplementation ("net.bytebuddy:byte-buddy-agent:1.14.18")
-    typeCheckTestImplementation ("net.bytebuddy:byte-buddy:1.14.18")
+    typeCheckTestImplementation ("net.bytebuddy:byte-buddy-agent:1.14.19")
+    typeCheckTestImplementation ("net.bytebuddy:byte-buddy:1.14.19")
     typeCheckTestRuntimeOnly libs.junit.platform.engine
 }
 
diff --git a/config/checkstyle/custom-suppressions.xml b/config/checkstyle/custom-suppressions.xml
index a726d69293..9e4881f9ff 100644
--- a/config/checkstyle/custom-suppressions.xml
+++ b/config/checkstyle/custom-suppressions.xml
@@ -16,7 +16,7 @@
 
     <suppress checks=".*" files="FlowControlHandler.java" />
 
-    <suppress checks="ParameterNumber" files="DefaultHttpClient.java" />
+    <suppress checks="ParameterNumber" files="DefaultHttpClient.java|DefaultJdkHttpClient.java|JdkBlockingHttpClient.java" />
 
     <suppress checks="IllegalImport" files="JavaxProviderBeanDefinition.java" />
 
diff --git a/context/src/main/java/io/micronaut/runtime/converters/time/TimeConverterRegistrar.java b/context/src/main/java/io/micronaut/runtime/converters/time/TimeConverterRegistrar.java
index 18a949b0df..25598f7319 100644
--- a/context/src/main/java/io/micronaut/runtime/converters/time/TimeConverterRegistrar.java
+++ b/context/src/main/java/io/micronaut/runtime/converters/time/TimeConverterRegistrar.java
@@ -29,7 +29,6 @@ import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDate;
 import java.time.LocalDateTime;
-import java.time.LocalTime;
 import java.time.MonthDay;
 import java.time.OffsetDateTime;
 import java.time.OffsetTime;
@@ -40,9 +39,7 @@ import java.time.ZoneId;
 import java.time.ZoneOffset;
 import java.time.ZonedDateTime;
 import java.time.format.DateTimeFormatter;
-import java.time.format.DateTimeFormatterBuilder;
 import java.time.format.DateTimeParseException;
-import java.time.format.SignStyle;
 import java.time.temporal.TemporalAccessor;
 import java.time.temporal.TemporalAmount;
 import java.time.temporal.TemporalQuery;
@@ -56,10 +53,6 @@ import java.util.function.Function;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import static java.time.temporal.ChronoField.DAY_OF_MONTH;
-import static java.time.temporal.ChronoField.MONTH_OF_YEAR;
-import static java.time.temporal.ChronoField.YEAR;
-
 /**
  * Registers data time converters.
  *
@@ -67,65 +60,87 @@ import static java.time.temporal.ChronoField.YEAR;
  * @since 1.0
  */
 @TypeHint(
-    value = {
-        Duration.class,
-        TemporalAmount.class,
-        Instant.class,
-        LocalTime.class,
-        LocalDate.class,
-        LocalDateTime.class,
-        MonthDay.class,
-        OffsetDateTime.class,
-        OffsetTime.class,
-        Period.class,
-        Year.class,
-        YearMonth.class,
-        ZonedDateTime.class,
-        ZoneId.class,
-        ZoneOffset.class
-    },
-    accessType = TypeHint.AccessType.ALL_PUBLIC
+        value = {
+                Duration.class,
+                TemporalAmount.class,
+                Instant.class,
+                LocalDate.class,
+                LocalDateTime.class,
+                MonthDay.class,
+                OffsetDateTime.class,
+                OffsetTime.class,
+                Period.class,
+                Year.class,
+                YearMonth.class,
+                ZonedDateTime.class,
+                ZoneId.class,
+                ZoneOffset.class
+        },
+        accessType = TypeHint.AccessType.ALL_PUBLIC
 )
 @Internal
 public class TimeConverterRegistrar implements TypeConverterRegistrar {
 
-    private static final Pattern PERIOD_MATCHER = Pattern.compile("^(-?\\d+)([unywmd])(s?)$");
     private static final Pattern DURATION_MATCHER = Pattern.compile("^(-?\\d+)([unsmhd])(s?)$");
     private static final int MILLIS = 3;
 
-    /**
-     * Copy of java.time.Year.PARSER DateTimeFormatter.
-     */
-    private static final DateTimeFormatter ISO_YEAR = new DateTimeFormatterBuilder()
-        .parseLenient()
-        .appendValue(YEAR, 1, 10, SignStyle.NORMAL)
-        .toFormatter();
-
-    /**
-     * Copy of java.time.YearMonth.PARSER DateTimeFormatter.
-     */
-    private static final DateTimeFormatter ISO_YEAR_MONTH = new DateTimeFormatterBuilder()
-        .appendValue(YEAR, 4, 10, SignStyle.EXCEEDS_PAD)
-        .appendLiteral('-')
-        .appendValue(MONTH_OF_YEAR, 2)
-        .toFormatter();
-
-    /**
-     * Copy of java.time.MonthDay.PARSER DateTimeFormatter.
-     */
-    private static final DateTimeFormatter ISO_MONTH_DAY = new DateTimeFormatterBuilder()
-        .appendLiteral("--")
-        .appendValue(MONTH_OF_YEAR, 2)
-        .appendLiteral('-')
-        .appendValue(DAY_OF_MONTH, 2)
-        .toFormatter();
-
     private final Map<String, DateTimeFormatter> formattersCache = new ConcurrentHashMap<>();
 
     @NextMajorVersion("Consider deletion of LocalDate and LocalDateTime converters")
     @Override
     public void register(MutableConversionService conversionService) {
-        final BiFunction<CharSequence, ConversionContext, Optional<Duration>> durationConverter = durationConverter();
+        final BiFunction<CharSequence, ConversionContext, Optional<Duration>> durationConverter = (object, context) -> {
+            String value = object.toString().trim();
+            if (value.startsWith("P")) {
+                try {
+                    return Optional.of(Duration.parse(value));
+                } catch (DateTimeParseException e) {
+                    context.reject(value, e);
+                    return Optional.empty();
+                }
+            } else {
+                Matcher matcher = DURATION_MATCHER.matcher(value);
+                if (matcher.find()) {
+                    String amount = matcher.group(1);
+                    final String g2 = matcher.group(2);
+                    char type = g2.charAt(0);
+                    try {
+                        switch (type) {
+                            case 's' -> {
+                                return Optional.of(Duration.ofSeconds(Integer.parseInt(amount)));
+                            }
+                            case 'm' -> {
+                                String ms = matcher.group(MILLIS);
+                                if (StringUtils.hasText(ms)) {
+                                    return Optional.of(Duration.ofMillis(Integer.parseInt(amount)));
+                                } else {
+                                    return Optional.of(Duration.ofMinutes(Integer.parseInt(amount)));
+                                }
+                            }
+                            case 'h' -> {
+                                return Optional.of(Duration.ofHours(Integer.parseInt(amount)));
+                            }
+                            case 'd' -> {
+                                return Optional.of(Duration.ofDays(Integer.parseInt(amount)));
+                            }
+                            default -> {
+                                final String seq = g2 + matcher.group(3);
+                                if (seq.equals("ns")) {
+                                    return Optional.of(Duration.ofNanos(Integer.parseInt(amount)));
+                                }
+                                context.reject(
+                                        value,
+                                        new DateTimeParseException("Unparseable date format (" + value + "). Should either be a ISO-8601 duration or a round number followed by the unit type", value, 0));
+                                return Optional.empty();
+                            }
+                        }
+                    } catch (NumberFormatException e) {
+                        context.reject(value, e);
+                    }
+                }
+            }
+            return Optional.empty();
+        };
 
         // CharSequence -> Duration
         conversionService.addConverter(
@@ -148,29 +163,6 @@ public class TimeConverterRegistrar implements TypeConverterRegistrar {
             (object, targetType, context) -> durationConverter.apply(object, context).map(TemporalAmount.class::cast)
         );
 
-        final BiFunction<CharSequence, ConversionContext, Optional<Period>> periodConverter = periodConverter();
-
-        // CharSequence -> Period
-        conversionService.addConverter(
-            CharSequence.class,
-            Period.class,
-            (object, targetType, context) -> periodConverter.apply(object, context)
-        );
-
-        // Integer -> Period
-        conversionService.addConverter(
-            Integer.class,
-            Period.class,
-            (integer, targetType, context) -> periodConverter.apply(integer.toString(), context)
-        );
-
-        // CharSequence -> TemporalAmount
-        conversionService.addConverter(
-            CharSequence.class,
-            TemporalAmount.class,
-            (object, targetType, context) -> periodConverter.apply(object, context).map(TemporalAmount.class::cast)
-        );
-
         addTemporalStringConverters(conversionService, Instant.class, DateTimeFormatter.ISO_INSTANT, Instant::from);
         addTemporalStringConverters(conversionService, LocalDate.class, DateTimeFormatter.ISO_LOCAL_DATE, LocalDate::from);
         addTemporalStringConverters(conversionService, LocalDateTime.class, DateTimeFormatter.ISO_LOCAL_DATE_TIME, LocalDateTime::from);
@@ -178,31 +170,6 @@ public class TimeConverterRegistrar implements TypeConverterRegistrar {
         addTemporalStringConverters(conversionService, OffsetDateTime.class, DateTimeFormatter.ISO_OFFSET_DATE_TIME, OffsetDateTime::from);
         addTemporalStringConverters(conversionService, ZonedDateTime.class, DateTimeFormatter.ISO_ZONED_DATE_TIME, ZonedDateTime::from);
 
-        addTemporalStringConverters(conversionService, YearMonth.class, ISO_YEAR_MONTH, YearMonth::from);
-        addTemporalStringConverters(conversionService, Year.class, ISO_YEAR, Year::from);
-        addTemporalIntegerConverters(conversionService, Year.class, ISO_YEAR, Year::from);
-        addTemporalStringConverters(conversionService, MonthDay.class, ISO_MONTH_DAY, MonthDay::from);
-        addTemporalStringConverters(conversionService, LocalTime.class, DateTimeFormatter.ISO_LOCAL_TIME, LocalTime::from);
-
-        conversionService.addConverter(CharSequence.class, ZoneId.class, (object, targetType, context) -> {
-            if (StringUtils.isEmpty(object)) {
-                return Optional.empty();
-            }
-            try {
-                ZoneId result = ZoneId.of(object.toString());
-                return Optional.of(result);
-            } catch (DateTimeParseException e) {
-                context.reject(object, e);
-                return Optional.empty();
-            }
-        });
-        conversionService.addConverter(ZoneId.class, CharSequence.class, (object, targetType, context) -> {
-            if (Objects.isNull(object)) {
-                return Optional.empty();
-            }
-            return Optional.of(object.toString());
-        });
-
         // java.time -> Date
         addTemporalToDateConverter(conversionService, Instant.class, Function.identity());
         addTemporalToDateConverter(conversionService, OffsetDateTime.class, OffsetDateTime::toInstant);
@@ -235,14 +202,14 @@ public class TimeConverterRegistrar implements TypeConverterRegistrar {
                     return Optional.of(converted);
                 } catch (DateTimeParseException ignored) {
                 }
-            }
-            // fall back to RFC 1123 date time for compatibility
-            try {
-                T result = DateTimeFormatter.RFC_1123_DATE_TIME.parse(object, query);
-                return Optional.of(result);
-            } catch (DateTimeParseException e) {
-                context.reject(object, e);
-                return Optional.empty();
+                // fall back to RFC 1123 date time for compatibility
+                try {
+                    T result = DateTimeFormatter.RFC_1123_DATE_TIME.parse(object, query);
+                    return Optional.of(result);
+                } catch (DateTimeParseException e) {
+                    context.reject(object, e);
+                    return Optional.empty();
+                }
             }
         });
 
@@ -267,158 +234,23 @@ public class TimeConverterRegistrar implements TypeConverterRegistrar {
                     return Optional.of(converted);
                 } catch (DateTimeException ignored) {
                 }
-            }
-            // fall back to RFC 1123 date time for compatibility
-            try {
-                CharSequence converted = DateTimeFormatter.RFC_1123_DATE_TIME.format(object);
-                return Optional.of(converted);
-            } catch (DateTimeException e) {
-                context.reject(object, e);
-                return Optional.empty();
-            }
-        });
-    }
-
-    private <T extends TemporalAccessor> void addTemporalIntegerConverters(MutableConversionService conversionService, Class<T> temporalType, DateTimeFormatter isoFormatter, TemporalQuery<T> query) {
-        conversionService.addConverter(Integer.class, temporalType, (Integer object, Class<T> targetType, ConversionContext context) -> {
-            if (Objects.isNull(object)) {
-                return Optional.empty();
-            }
-            // try explicit format first
-            Optional<String> format = context.getAnnotationMetadata().stringValue(Format.class);
-            if (format.isPresent()) {
-                DateTimeFormatter formatter = getFormatter(format.get(), context);
+                // fall back to RFC 1123 date time for compatibility
                 try {
-                    T converted = formatter.parse(object.toString(), query);
+                    CharSequence converted = DateTimeFormatter.RFC_1123_DATE_TIME.format(object);
                     return Optional.of(converted);
-                } catch (DateTimeParseException e) {
+                } catch (DateTimeException e) {
                     context.reject(object, e);
                     return Optional.empty();
                 }
-            } else {
-                try {
-                    T converted = isoFormatter.parse(object.toString(), query);
-                    return Optional.of(converted);
-                } catch (DateTimeParseException ignored) {
-                }
-            }
-            // fall back to RFC 1123 date time for compatibility
-            try {
-                T result = DateTimeFormatter.RFC_1123_DATE_TIME.parse(object.toString(), query);
-                return Optional.of(result);
-            } catch (DateTimeParseException e) {
-                context.reject(object, e);
-                return Optional.empty();
             }
         });
     }
 
-    private BiFunction<CharSequence, ConversionContext, Optional<Duration>> durationConverter() {
-        return (object, context) -> {
-            String value = object.toString().trim();
-            if (value.startsWith("P")) {
-                try {
-                    return Optional.of(Duration.parse(value));
-                } catch (DateTimeParseException e) {
-                    context.reject(value, e);
-                    return Optional.empty();
-                }
-            } else {
-                Matcher matcher = DURATION_MATCHER.matcher(value);
-                if (matcher.find()) {
-                    String amount = matcher.group(1);
-                    final String g2 = matcher.group(2);
-                    char type = g2.charAt(0);
-                    try {
-                        switch (type) {
-                            case 's' -> {
-                                return Optional.of(Duration.ofSeconds(Integer.parseInt(amount)));
-                            }
-                            case 'm' -> {
-                                String ms = matcher.group(MILLIS);
-                                if (StringUtils.hasText(ms)) {
-                                    return Optional.of(Duration.ofMillis(Integer.parseInt(amount)));
-                                } else {
-                                    return Optional.of(Duration.ofMinutes(Integer.parseInt(amount)));
-                                }
-                            }
-                            case 'h' -> {
-                                return Optional.of(Duration.ofHours(Integer.parseInt(amount)));
-                            }
-                            case 'd' -> {
-                                return Optional.of(Duration.ofDays(Integer.parseInt(amount)));
-                            }
-                            default -> {
-                                final String seq = g2 + matcher.group(3);
-                                if (seq.equals("ns")) {
-                                    return Optional.of(Duration.ofNanos(Integer.parseInt(amount)));
-                                }
-                                context.reject(
-                                    value,
-                                    new DateTimeParseException("Unparseable date format (" + value + "). Should either be a ISO-8601 duration or a round number followed by the unit type", value, 0));
-                                return Optional.empty();
-                            }
-                        }
-                    } catch (NumberFormatException e) {
-                        context.reject(value, e);
-                    }
-                }
-            }
-            return Optional.empty();
-        };
-    }
-
-    private BiFunction<CharSequence, ConversionContext, Optional<Period>> periodConverter() {
-        return (object, context) -> {
-            String value = object.toString().trim();
-            if (value.startsWith("P")) {
-                try {
-                    return Optional.of(Period.parse(value));
-                } catch (DateTimeParseException e) {
-                    context.reject(value, e);
-                    return Optional.empty();
-                }
-            } else {
-                Matcher matcher = PERIOD_MATCHER.matcher(value);
-                if (matcher.find()) {
-                    String amount = matcher.group(1);
-                    final String g2 = matcher.group(2);
-                    char type = g2.charAt(0);
-                    try {
-                        switch (type) {
-                            case 'y' -> {
-                                return Optional.of(Period.ofYears(Integer.parseInt(amount)));
-                            }
-                            case 'm' -> {
-                                return Optional.of(Period.ofMonths(Integer.parseInt(amount)));
-                            }
-                            case 'w' -> {
-                                return Optional.of(Period.ofWeeks(Integer.parseInt(amount)));
-                            }
-                            case 'd' -> {
-                                return Optional.of(Period.ofDays(Integer.parseInt(amount)));
-                            }
-                            default -> {
-                                context.reject(
-                                    value,
-                                    new DateTimeParseException("Unparseable date format (" + value + "). Should either be a ISO-8601 duration or a round number followed by the unit type", value, 0));
-                                return Optional.empty();
-                            }
-                        }
-                    } catch (NumberFormatException e) {
-                        context.reject(value, e);
-                    }
-                }
-            }
-            return Optional.empty();
-        };
-    }
-
     private DateTimeFormatter getFormatter(String pattern, ConversionContext context) {
         var key = pattern + context.getLocale();
-        var cachedFormater = formattersCache.get(key);
-        if (cachedFormater != null) {
-            return cachedFormater;
+        var cachedFormatter = formattersCache.get(key);
+        if (cachedFormatter != null) {
+            return cachedFormatter;
         }
         var formatter = DateTimeFormatter.ofPattern(pattern, context.getLocale());
         formattersCache.put(key, formatter);
diff --git a/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java b/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java
index a2a1cfae55..adcc7348b9 100644
--- a/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java
+++ b/core-processor/src/main/java/io/micronaut/aop/writer/AopProxyWriter.java
@@ -52,6 +52,7 @@ import io.micronaut.inject.ast.ElementQuery;
 import io.micronaut.inject.ast.FieldElement;
 import io.micronaut.inject.ast.MethodElement;
 import io.micronaut.inject.ast.ParameterElement;
+import io.micronaut.inject.ast.PrimitiveElement;
 import io.micronaut.inject.ast.TypedElement;
 import io.micronaut.inject.configuration.ConfigurationMetadataBuilder;
 import io.micronaut.inject.processing.JavaModelUtils;
@@ -62,6 +63,7 @@ import io.micronaut.inject.writer.ClassWriterOutputVisitor;
 import io.micronaut.inject.writer.ExecutableMethodsDefinitionWriter;
 import io.micronaut.inject.writer.OriginatingElements;
 import io.micronaut.inject.writer.ProxyingBeanDefinitionVisitor;
+import io.micronaut.inject.writer.WriterUtils;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
 import org.objectweb.asm.Label;
@@ -211,6 +213,8 @@ public class AopProxyWriter extends AbstractClassFileWriter implements ProxyingB
     private boolean constructorRequiresReflection;
     private MethodElement declaredConstructor;
     private MethodElement newConstructor;
+    private String newConstructorSignature;
+    private List<Map.Entry<ParameterElement, Integer>> superConstructorParametersBinding;
     private ParameterElement qualifierParameter;
     private ParameterElement interceptorsListParameter;
     private VisitorContext visitorContext;
@@ -491,15 +495,38 @@ public class AopProxyWriter extends AbstractClassFileWriter implements ProxyingB
         this.interceptorsListParameter = ParameterElement.of(interceptorList, INTERCEPTORS_PARAMETER);
         ParameterElement interceptorRegistryParameter = ParameterElement.of(ClassElement.of(InterceptorRegistry.class), "$interceptorRegistry");
         ClassElement proxyClass = ClassElement.of(proxyType.getClassName());
-
+        superConstructorParametersBinding = new ArrayList<>();
         ParameterElement[] constructorParameters = constructor.getParameters();
         List<ParameterElement> newConstructorParameters = new ArrayList<>(constructorParameters.length + 5);
         newConstructorParameters.addAll(Arrays.asList(constructorParameters));
-        newConstructorParameters.add(ParameterElement.of(BeanResolutionContext.class, "$beanResolutionContext"));
-        newConstructorParameters.add(ParameterElement.of(BeanContext.class, "$beanContext"));
+        int superConstructorParameterIndex = 0;
+        for (ParameterElement newConstructorParameter : newConstructorParameters) {
+            superConstructorParametersBinding.add(Map.entry(newConstructorParameter, superConstructorParameterIndex++));
+        }
+
+        ParameterElement beanResolutionContext = ParameterElement.of(BeanResolutionContext.class, "$beanResolutionContext");
+        newConstructorParameters.add(beanResolutionContext);
+        ParameterElement beanContext = ParameterElement.of(BeanContext.class, "$beanContext");
+        newConstructorParameters.add(beanContext);
         newConstructorParameters.add(qualifierParameter);
         newConstructorParameters.add(interceptorsListParameter);
         newConstructorParameters.add(interceptorRegistryParameter);
+        superConstructorParameterIndex += 5; // Skip internal parameters
+        if (WriterUtils.hasKotlinDefaultsParameters(List.of(constructorParameters))) {
+            List<ParameterElement> realNewConstructorParameters = new ArrayList<>(newConstructorParameters);
+            int count = WriterUtils.calculateNumberOfKotlinDefaultsMasks(List.of(constructorParameters));
+            for (int j = 0; j < count; j++) {
+                ParameterElement mask = ParameterElement.of(PrimitiveElement.INT, "mask" + j);
+                realNewConstructorParameters.add(mask);
+                superConstructorParametersBinding.add(Map.entry(mask, superConstructorParameterIndex++));
+            }
+            ParameterElement marker = ParameterElement.of(ClassElement.of("kotlin.jvm.internal.DefaultConstructorMarker"), "marker");
+            realNewConstructorParameters.add(marker);
+            superConstructorParametersBinding.add(Map.entry(marker, superConstructorParameterIndex));
+            this.newConstructorSignature = getConstructorDescriptor(realNewConstructorParameters);
+        } else {
+            this.newConstructorSignature = getConstructorDescriptor(newConstructorParameters);
+        }
         this.newConstructor = MethodElement.of(
                 proxyClass,
                 constructor.getAnnotationMetadata(),
@@ -508,11 +535,11 @@ public class AopProxyWriter extends AbstractClassFileWriter implements ProxyingB
                 "<init>",
                 newConstructorParameters.toArray(ZERO_PARAMETER_ELEMENTS)
         );
-        this.beanResolutionContextArgumentIndex = constructorParameters.length;
-        this.beanContextArgumentIndex = constructorParameters.length + 1;
-        this.qualifierIndex = constructorParameters.length + 2;
-        this.interceptorsListArgumentIndex = constructorParameters.length + 3;
-        this.interceptorRegistryArgumentIndex = constructorParameters.length + 4;
+        this.beanResolutionContextArgumentIndex = newConstructorParameters.indexOf(beanResolutionContext);
+        this.beanContextArgumentIndex = newConstructorParameters.indexOf(beanContext);
+        this.qualifierIndex = newConstructorParameters.indexOf(qualifierParameter);
+        this.interceptorsListArgumentIndex = newConstructorParameters.indexOf(interceptorsListParameter);
+        this.interceptorRegistryArgumentIndex = newConstructorParameters.indexOf(interceptorRegistryParameter);
     }
 
     @NonNull
@@ -745,28 +772,30 @@ public class AopProxyWriter extends AbstractClassFileWriter implements ProxyingB
         });
         qualifierParameter.annotate(AnnotationUtil.NULLABLE);
 
-        String constructorDescriptor = getConstructorDescriptor(Arrays.asList(newConstructor.getParameters()));
         ClassWriter proxyClassWriter = this.classWriter;
         this.constructorWriter = proxyClassWriter.visitMethod(
                 ACC_PUBLIC,
                 CONSTRUCTOR_NAME,
-                constructorDescriptor,
+                newConstructorSignature,
                 null,
                 null);
 
-        this.constructorGenerator = new GeneratorAdapter(constructorWriter, ACC_PUBLIC, CONSTRUCTOR_NAME, constructorDescriptor);
+        this.constructorGenerator = new GeneratorAdapter(constructorWriter, ACC_PUBLIC, CONSTRUCTOR_NAME, newConstructorSignature);
         GeneratorAdapter proxyConstructorGenerator = this.constructorGenerator;
 
         proxyConstructorGenerator.loadThis();
         if (isInterface) {
             proxyConstructorGenerator.invokeConstructor(TYPE_OBJECT, METHOD_DEFAULT_CONSTRUCTOR);
         } else {
-            ParameterElement[] existingArguments = declaredConstructor.getParameters();
-            for (int i = 0; i < existingArguments.length; i++) {
-                proxyConstructorGenerator.loadArg(i);
+            List<ParameterElement> arguments = new ArrayList<>();
+            for (Map.Entry<ParameterElement, Integer> e : superConstructorParametersBinding) {
+                proxyConstructorGenerator.loadArg(e.getValue());
+                arguments.add(e.getKey());
             }
-            String superConstructorDescriptor = getConstructorDescriptor(Arrays.asList(existingArguments));
-            proxyConstructorGenerator.invokeConstructor(getTypeReferenceForName(targetClassFullName), new Method(CONSTRUCTOR_NAME, superConstructorDescriptor));
+            proxyConstructorGenerator.invokeConstructor(
+                getTypeReferenceForName(targetClassFullName),
+                new Method(CONSTRUCTOR_NAME, getConstructorDescriptor(arguments))
+            );
         }
 
         proxyBeanDefinitionWriter.visitBeanDefinitionConstructor(
diff --git a/core-processor/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataWriter.java b/core-processor/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataWriter.java
index 5db7acb98e..1b985c2363 100644
--- a/core-processor/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataWriter.java
@@ -591,11 +591,15 @@ public class AnnotationMetadataWriter extends AbstractClassFileWriter {
                 invokeLoadClassValueMethod(declaringType, declaringClassWriter, methodVisitor, loadTypeMethods, acv);
             }
         } else if (value instanceof Enum<?> enumObject) {
-            Class<?> declaringClass = enumObject.getDeclaringClass();
-            Type t = Type.getType(declaringClass);
-            methodVisitor.getStatic(t, enumObject.name(), t);
+            methodVisitor.push(enumObject.name()); // Always store enum values as string
         } else if (value.getClass().isArray()) {
-            Class<?> jt = ReflectionUtils.getPrimitiveType(value.getClass().getComponentType());
+            Class<?> jt;
+            Class<?> arrayComponentType = value.getClass().getComponentType();
+            if (arrayComponentType.isEnum() || arrayComponentType.equals(java.lang.Enum.class)) {
+                jt = String.class; // Always store enum values as string
+            } else {
+                jt = ReflectionUtils.getPrimitiveType(arrayComponentType);
+            }
             final Type componentType = Type.getType(jt);
             int len = Array.getLength(value);
             if (Object.class == jt && len == 0) {
diff --git a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java
index 2e5f2d77b9..44407f9be0 100644
--- a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java
+++ b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedTypeElementVisitor.java
@@ -33,6 +33,7 @@ import io.micronaut.inject.ast.ElementQuery;
 import io.micronaut.inject.ast.MethodElement;
 import io.micronaut.inject.ast.PropertyElement;
 import io.micronaut.inject.ast.PropertyElementQuery;
+import io.micronaut.inject.visitor.ElementPostponedToNextRoundException;
 import io.micronaut.inject.visitor.TypeElementVisitor;
 import io.micronaut.inject.visitor.VisitorContext;
 import io.micronaut.inject.writer.ClassGenerationException;
@@ -256,13 +257,16 @@ public class IntrospectedTypeElementVisitor implements TypeElementVisitor<Object
     public void finish(VisitorContext visitorContext) {
         try {
             if (!writers.isEmpty()) {
-                for (BeanIntrospectionWriter writer : writers.values()) {
+                writers.forEach((className, writer) -> {
                     try {
                         writer.accept(visitorContext);
+                    } catch (ElementPostponedToNextRoundException ignore) {
+                        // Ignore, next round will redo
                     } catch (IOException e) {
                         throw new ClassGenerationException("I/O error occurred during class generation: " + e.getMessage(), e);
                     }
-                }
+                });
+
             }
         } finally {
             writers.clear();
diff --git a/core-processor/src/main/java/io/micronaut/inject/visitor/ElementPostponedToNextRoundException.java b/core-processor/src/main/java/io/micronaut/inject/visitor/ElementPostponedToNextRoundException.java
new file mode 100644
index 0000000000..74daed3dde
--- /dev/null
+++ b/core-processor/src/main/java/io/micronaut/inject/visitor/ElementPostponedToNextRoundException.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2017-2020 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.inject.visitor;
+
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.inject.ast.Element;
+
+/**
+ * Exception is thrown when the visitor is attempted to create a new file but the originated element is postponed to the next round.
+ *
+ * @author Denis Stepanov
+ * @since 4.7
+ */
+@Internal
+public final class ElementPostponedToNextRoundException extends RuntimeException {
+
+    private final Element originatingElement;
+
+    /**
+     * @param originatingElement The originating element
+     */
+    public ElementPostponedToNextRoundException(@NonNull Element originatingElement) {
+        super("Original element: " + originatingElement.getName() + " is postponed to the next round!");
+        this.originatingElement = originatingElement;
+    }
+
+    @NonNull
+    public Element getOriginatingElement() {
+        return originatingElement;
+    }
+
+}
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java b/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java
index 6fc23165e4..ddc8e2c441 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/BeanDefinitionWriter.java
@@ -3674,8 +3674,7 @@ public class BeanDefinitionWriter extends AbstractClassFileWriter implements Bea
                 final int parametersIndex = createConstructorParameterArray(parameters, buildMethodVisitor);
                 invokeConstructorChain(buildMethodVisitor, constructorIndex, parametersIndex, parameters);
             } else {
-                boolean isKotlin = constructor.getClass().getSimpleName().startsWith("Kotlin");
-                if (isKotlin) {
+                if (WriterUtils.hasKotlinDefaultsParameters(parameters)) {
                     Map<Integer, Integer> checksLocals = new HashMap<>();
                     Map<Integer, Integer> valuesLocals = new HashMap<>();
                     WriterUtils.invokeBeanConstructor(buildMethodVisitor, constructor, requiresReflection, true, (index, parameter) -> {
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java b/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java
index 1348f35b38..865bcdbae7 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/WriterUtils.java
@@ -55,6 +55,26 @@ import static org.objectweb.asm.commons.GeneratorAdapter.EQ;
 public final class WriterUtils {
     private static final String METHOD_NAME_INSTANTIATE = "instantiate";
 
+    /**
+     * The number of Kotlin defaults masks.
+     * @param parameters The parameters
+     * @return The number if masks
+     * @since 4.6.2
+     */
+    public static int calculateNumberOfKotlinDefaultsMasks(List<ParameterElement> parameters) {
+        return  (int) Math.ceil(parameters.size() / 32.0);
+    }
+
+    /**
+     * Checks if parameter include Kotlin defaults.
+     * @param arguments The arguments
+     * @return true if include
+     * @since 4.6.2
+     */
+    public static boolean hasKotlinDefaultsParameters(List<ParameterElement> arguments) {
+        return arguments.stream().anyMatch(p -> p instanceof KotlinParameterElement kp && kp.hasDefault());
+    }
+
     public static void invokeBeanConstructor(GeneratorAdapter writer,
                                              MethodElement constructor,
                                              boolean allowKotlinDefaults,
@@ -80,7 +100,7 @@ public final class WriterUtils {
         Collection<Type> argumentTypes = constructorArguments.stream().map(pe ->
             JavaModelUtils.getTypeReference(pe.getType())
         ).toList();
-        boolean isKotlinDefault = allowKotlinDefaults && constructorArguments.stream().anyMatch(p -> p instanceof KotlinParameterElement kp && kp.hasDefault());
+        boolean isKotlinDefault = allowKotlinDefaults && hasKotlinDefaultsParameters(constructorArguments);
 
         int[] masksLocal = null;
         if (isKotlinDefault) {
@@ -247,7 +267,7 @@ public final class WriterUtils {
                                                   @Nullable
                                                   BiFunction<Integer, ParameterElement, Boolean> argumentValueIsPresentPusher,
                                                   List<ParameterElement> parameters) {
-        int numberOfMasks = (int) Math.ceil(parameters.size() / 32.0);
+        int numberOfMasks = calculateNumberOfKotlinDefaultsMasks(parameters);
         int[] masksLocal = new int[numberOfMasks];
         for (int i = 0; i < numberOfMasks; i++) {
             int maskLocal = writer.newLocal(Type.INT_TYPE);
diff --git a/core/src/main/java/io/micronaut/core/execution/DelayedExecutionFlow.java b/core/src/main/java/io/micronaut/core/execution/DelayedExecutionFlow.java
index 44490372de..f07927c745 100644
--- a/core/src/main/java/io/micronaut/core/execution/DelayedExecutionFlow.java
+++ b/core/src/main/java/io/micronaut/core/execution/DelayedExecutionFlow.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.core.execution;
 
+import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 
 /**
@@ -41,4 +42,20 @@ public sealed interface DelayedExecutionFlow<T> extends ExecutionFlow<T> permits
      * @param exc The exception
      */
     void completeExceptionally(Throwable exc);
+
+    /**
+     * Complete this flow from the given flow.
+     *
+     * @param flow The input flow
+     * @since 4.7.0
+     */
+    default void completeFrom(@NonNull ExecutionFlow<T> flow) {
+        flow.onComplete((o, t) -> {
+            if (t != null) {
+                completeExceptionally(t);
+            } else {
+                complete(o);
+            }
+        });
+    }
 }
diff --git a/core/src/main/java/io/micronaut/core/io/IOUtils.java b/core/src/main/java/io/micronaut/core/io/IOUtils.java
index 0a7c13420d..d4b889285c 100644
--- a/core/src/main/java/io/micronaut/core/io/IOUtils.java
+++ b/core/src/main/java/io/micronaut/core/io/IOUtils.java
@@ -40,9 +40,13 @@ import java.nio.file.Paths;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.Enumeration;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.function.Consumer;
+import java.util.stream.Stream;
 
 /**
  * Utility methods for I/O operations.
@@ -98,7 +102,6 @@ public class IOUtils {
         try {
             Path myPath = resolvePath(uri, path, toClose, IOUtils::loadNestedJarUri);
             if (myPath != null) {
-                Path finalMyPath = myPath;
                 // use this method instead of Files#walk to eliminate the Stream overhead
                 Files.walkFileTree(myPath, Collections.emptySet(), 1, new FileVisitor<>() {
                     @Override
@@ -108,7 +111,7 @@ public class IOUtils {
 
                     @Override
                     public FileVisitResult visitFile(Path currentPath, BasicFileAttributes attrs) throws IOException {
-                        if (currentPath.equals(finalMyPath) || Files.isHidden(currentPath) || currentPath.getFileName().startsWith(".")) {
+                        if (currentPath.equals(myPath) || Files.isHidden(currentPath) || currentPath.getFileName().startsWith(".")) {
                             return FileVisitResult.CONTINUE;
                         }
                         consumer.accept(currentPath);
@@ -138,6 +141,23 @@ public class IOUtils {
         }
     }
 
+    /**
+     * Resolve the path in the URI.
+     *
+     * @param uri     The URI
+     * @param path    The path
+     * @param toClose to close hooks
+     * @return The path resolved
+     * @throws IOException
+     * @since 4.7
+     */
+    @Nullable
+    public static Path resolvePath(@NonNull URI uri,
+                                   @NonNull String path,
+                                   @NonNull List<Closeable> toClose) throws IOException {
+        return resolvePath(uri, path, toClose, IOUtils::loadNestedJarUri);
+    }
+
     @Nullable
     static Path resolvePath(@NonNull URI uri,
                             String path,
@@ -235,4 +255,96 @@ public class IOUtils {
         }
         return answer.toString();
     }
+
+    /**
+     * Find all the resources starting with the path.
+     *
+     * @param classLoader The classloader
+     * @param path        The path
+     * @return the resources as URIs
+     * @throws IOException The IO exception
+     * @since 4.7
+     */
+    public static List<URI> getResources(ClassLoader classLoader, final String path) throws IOException {
+        final Enumeration<URL> micronautResources = classLoader.getResources(path);
+        Set<URI> uniqueURIs = new LinkedHashSet<>();
+        while (micronautResources.hasMoreElements()) {
+            URL url = micronautResources.nextElement();
+            try {
+                uniqueURIs.add(url.toURI());
+            } catch (URISyntaxException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        FileSystem jrtProvider = null;
+        if (uniqueURIs.isEmpty()) {
+            jrtProvider = getJrtProvider(classLoader);
+            if (jrtProvider != null) {
+                Path modulesPath = jrtProvider.getPath("modules");
+                try (Stream<Path> stream = Files.list(modulesPath)) {
+                    stream
+                        .filter(p -> !p.getFileName().toString().startsWith("jdk.")) // filter out JDK internal modules
+                        .filter(p -> !p.getFileName().toString().startsWith("java.")) // filter out JDK public modules
+                        .map(p -> p.resolve(path))
+                        .filter(Files::exists)
+                        .map(modulesPath::resolve)
+                        .map(Path::toUri)
+                        .forEach(uniqueURIs::add);
+                }
+
+                // uri will be jrt:/modules/<module>/META-INF/micronaut/<service>, so we can walk through its files as if it was a directory
+            }
+        }
+        List<URI> uris = new ArrayList<>(uniqueURIs.size());
+        for (URI uri : uniqueURIs) {
+            String scheme = uri.getScheme();
+            if ("file".equals(scheme)) {
+                uri = normalizeFilePath(path, uri);
+            }
+            // on GraalVM there are spurious extra resources that end with # and then a number
+            // we ignore this extra ones
+            if (!("resource".equals(scheme) && uri.toString().contains("#"))) {
+                uris.add(uri);
+            }
+        }
+        if (jrtProvider != null && jrtProvider.isOpen()) {
+            try {
+                jrtProvider.close();
+            } catch (Throwable ignore) {
+                // Ignore
+            }
+        }
+        return uris;
+    }
+
+    @Nullable
+    private static FileSystem getJrtProvider(ClassLoader classLoader) {
+        try {
+            URI uri = URI.create("jrt:/");
+            FileSystem fs = FileSystems.getFileSystem(uri);
+            if (fs.isOpen()) {
+                return fs;
+            }
+            fs = FileSystems.newFileSystem(uri, Collections.emptyMap(), classLoader);
+            if (fs.isOpen()) {
+                return fs;
+            }
+        } catch (Throwable e) {
+            // not available, probably running in Native Image.
+        }
+        return null;
+    }
+
+    private static URI normalizeFilePath(String path, URI uri) {
+        Path p = Paths.get(uri);
+        if (p.endsWith(path)) {
+            Path subpath = Paths.get(path);
+            for (int i = 0; i < subpath.getNameCount(); i++) {
+                p = p.getParent();
+            }
+            uri = p.toUri();
+        }
+        return uri;
+    }
 }
diff --git a/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayBufferFactory.java b/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayBufferFactory.java
new file mode 100644
index 0000000000..a3072a790f
--- /dev/null
+++ b/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayBufferFactory.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.core.io.buffer;
+
+import io.micronaut.core.annotation.Internal;
+
+/**
+ * {@link ByteBufferFactory} implementation based on simple byte arrays.
+ *
+ * @author Jonas Konrad
+ * @since 4.7
+ */
+@Internal
+public class ByteArrayBufferFactory implements ByteBufferFactory<Void, byte[]> {
+    public static final ByteArrayBufferFactory INSTANCE = new ByteArrayBufferFactory();
+
+    private ByteArrayBufferFactory() {
+    }
+
+    @Override
+    public Void getNativeAllocator() {
+        throw new UnsupportedOperationException("No native allocator");
+    }
+
+    @Override
+    public ByteArrayByteBuffer buffer() {
+        return buffer(0);
+    }
+
+    @Override
+    public ByteArrayByteBuffer buffer(int initialCapacity) {
+        return new ByteArrayByteBuffer(new byte[initialCapacity]);
+    }
+
+    @Override
+    public ByteArrayByteBuffer buffer(int initialCapacity, int maxCapacity) {
+        return buffer(initialCapacity);
+    }
+
+    @Override
+    public ByteArrayByteBuffer copiedBuffer(byte[] bytes) {
+        return wrap(bytes.clone());
+    }
+
+    @Override
+    public ByteArrayByteBuffer copiedBuffer(java.nio.ByteBuffer nioBuffer) {
+        int pos = nioBuffer.position();
+        int lim = nioBuffer.limit();
+        byte[] arr = new byte[lim - pos];
+        nioBuffer.get(pos, arr, 0, arr.length);
+        return wrap(arr);
+    }
+
+    @Override
+    public ByteArrayByteBuffer wrap(byte[] existing) {
+        return new ByteArrayByteBuffer(existing);
+    }
+}
diff --git a/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayByteBuffer.java b/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayByteBuffer.java
new file mode 100644
index 0000000000..c2350c3a84
--- /dev/null
+++ b/core/src/main/java/io/micronaut/core/io/buffer/ByteArrayByteBuffer.java
@@ -0,0 +1,236 @@
+/*
+ * Copyright 2017-2023 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.core.io.buffer;
+
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.Internal;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.charset.Charset;
+import java.util.Arrays;
+
+/**
+ * A {@link ByteBuffer} implementation that is backed by a byte array.
+ *
+ * @since 4.7
+ */
+@Internal
+@Experimental
+public final class ByteArrayByteBuffer implements ByteBuffer<byte[]> {
+
+    private final byte[] underlyingBytes;
+    private int readerIndex;
+    private int writerIndex;
+
+    /**
+     * Construct a new {@link ByteArrayByteBuffer} for the given bytes.
+     *
+     * @param underlyingBytes the bytes to wrap
+     */
+    ByteArrayByteBuffer(byte[] underlyingBytes) {
+        this(underlyingBytes, underlyingBytes.length);
+    }
+
+    /**
+     * Construct a new {@link ByteArrayByteBuffer} for the given bytes and capacity.
+     * If capacity is greater than the length of the underlyingBytes, extra bytes will be zeroed out.
+     * If capacity is less than the length of the underlyingBytes, the underlyingBytes will be truncated.
+     *
+     * @param underlyingBytes the bytes to wrap
+     * @param capacity        the capacity of the buffer
+     */
+    ByteArrayByteBuffer(byte[] underlyingBytes, int capacity) {
+        if (capacity < underlyingBytes.length) {
+            this.underlyingBytes = Arrays.copyOf(underlyingBytes, capacity);
+        } else if (capacity > underlyingBytes.length) {
+            this.underlyingBytes = new byte[capacity];
+            System.arraycopy(underlyingBytes, 0, this.underlyingBytes, 0, underlyingBytes.length);
+        } else {
+            this.underlyingBytes = underlyingBytes;
+        }
+    }
+
+    @Override
+    public byte[] asNativeBuffer() {
+        return underlyingBytes;
+    }
+
+    @Override
+    public int readableBytes() {
+        return underlyingBytes.length - readerIndex;
+    }
+
+    @Override
+    public int writableBytes() {
+        return underlyingBytes.length - writerIndex;
+    }
+
+    @Override
+    public int maxCapacity() {
+        return underlyingBytes.length;
+    }
+
+    @Override
+    public ByteArrayByteBuffer capacity(int capacity) {
+        return new ByteArrayByteBuffer(underlyingBytes, capacity);
+    }
+
+    @Override
+    public int readerIndex() {
+        return readerIndex;
+    }
+
+    @Override
+    public ByteArrayByteBuffer readerIndex(int readPosition) {
+        this.readerIndex = Math.min(readPosition, underlyingBytes.length);
+        return this;
+    }
+
+    @Override
+    public int writerIndex() {
+        return writerIndex;
+    }
+
+    @Override
+    public ByteArrayByteBuffer writerIndex(int position) {
+        this.writerIndex = Math.min(position, underlyingBytes.length);
+        return this;
+    }
+
+    @Override
+    public byte read() {
+        return underlyingBytes[readerIndex++];
+    }
+
+    @Override
+    public CharSequence readCharSequence(int length, Charset charset) {
+        String s = new String(underlyingBytes, readerIndex, length, charset);
+        readerIndex += length;
+        return s;
+    }
+
+    @Override
+    public ByteArrayByteBuffer read(byte[] destination) {
+        int count = Math.min(readableBytes(), destination.length);
+        System.arraycopy(underlyingBytes, readerIndex, destination, 0, count);
+        readerIndex += count;
+        return this;
+    }
+
+    @Override
+    public ByteArrayByteBuffer read(byte[] destination, int offset, int length) {
+        int count = Math.min(readableBytes(), Math.min(destination.length - offset, length));
+        System.arraycopy(underlyingBytes, readerIndex, destination, offset, count);
+        readerIndex += count;
+        return this;
+    }
+
+    @Override
+    public ByteArrayByteBuffer write(byte b) {
+        underlyingBytes[writerIndex++] = b;
+        return this;
+    }
+
+    @Override
+    public ByteArrayByteBuffer write(byte[] source) {
+        int count = Math.min(writableBytes(), source.length);
+        System.arraycopy(source, 0, underlyingBytes, writerIndex, count);
+        writerIndex += count;
+        return this;
+    }
+
+    @Override
+    public ByteArrayByteBuffer write(CharSequence source, Charset charset) {
+        write(source.toString().getBytes(charset));
+        return this;
+    }
+
+    @Override
+    public ByteArrayByteBuffer write(byte[] source, int offset, int length) {
+        int count = Math.min(writableBytes(), length);
+        System.arraycopy(source, offset, underlyingBytes, writerIndex, count);
+        writerIndex += count;
+        return this;
+    }
+
+    @Override
+    public ByteArrayByteBuffer write(ByteBuffer... buffers) {
+        for (ByteBuffer<?> buffer : buffers) {
+            write(buffer.toByteArray());
+        }
+        return this;
+    }
+
+    @Override
+    public ByteArrayByteBuffer write(java.nio.ByteBuffer... buffers) {
+        for (java.nio.ByteBuffer buffer : buffers) {
+            write(buffer.array());
+        }
+        return this;
+    }
+
+    @Override
+    public ByteArrayByteBuffer slice(int index, int length) {
+        return new ByteArrayByteBuffer(Arrays.copyOfRange(underlyingBytes, index, index + length), length);
+    }
+
+    @Override
+    public java.nio.ByteBuffer asNioBuffer() {
+        return java.nio.ByteBuffer.wrap(underlyingBytes, readerIndex, readableBytes());
+    }
+
+    @Override
+    public java.nio.ByteBuffer asNioBuffer(int index, int length) {
+        return java.nio.ByteBuffer.wrap(underlyingBytes, index, length);
+    }
+
+    @Override
+    public InputStream toInputStream() {
+        return new ByteArrayInputStream(underlyingBytes, readerIndex, readableBytes());
+    }
+
+    @Override
+    public OutputStream toOutputStream() {
+        throw new IllegalStateException("Not implemented");
+    }
+
+    @Override
+    public byte[] toByteArray() {
+        return Arrays.copyOfRange(underlyingBytes, readerIndex, readableBytes());
+    }
+
+    @Override
+    public String toString(Charset charset) {
+        return new String(underlyingBytes, readerIndex, readableBytes(), charset);
+    }
+
+    @Override
+    public int indexOf(byte b) {
+        for (int i = readerIndex; i < underlyingBytes.length; i++) {
+            if (underlyingBytes[i] == b) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    @Override
+    public byte getByte(int index) {
+        return underlyingBytes[index];
+    }
+}
diff --git a/core/src/main/java/io/micronaut/core/io/service/MicronautMetaServiceLoaderUtils.java b/core/src/main/java/io/micronaut/core/io/service/MicronautMetaServiceLoaderUtils.java
new file mode 100644
index 0000000000..7c870a78fd
--- /dev/null
+++ b/core/src/main/java/io/micronaut/core/io/service/MicronautMetaServiceLoaderUtils.java
@@ -0,0 +1,337 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.core.io.service;
+
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.io.IOUtils;
+
+import java.io.Closeable;
+import java.io.IOException;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.net.URI;
+import java.nio.file.FileVisitResult;
+import java.nio.file.FileVisitor;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.ServiceConfigurationError;
+import java.util.Set;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.RecursiveAction;
+import java.util.function.Predicate;
+
+/**
+ * The loader of Micronaut services under META-INF/micronaut/.
+ *
+ * @author Denis Stepanov
+ * @since 4.7
+ */
+@Internal
+public final class MicronautMetaServiceLoaderUtils {
+
+    private static final String MICRONAUT_SERVICES_PATH = "META-INF/micronaut/";
+
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.publicLookup();
+    private static final MethodType VOID_TYPE = MethodType.methodType(void.class);
+
+    private static volatile CacheEntry cacheEntry;
+
+    /**
+     * Find all instantiated Micronaut service entries.
+     *
+     * @param classLoader  The classloader
+     * @param serviceClass The service class
+     * @param predicate    The predicate
+     * @param <S>          The service type
+     * @return the result
+     */
+    @NonNull
+    public static <S> List<S> findMetaMicronautServiceEntries(@NonNull ClassLoader classLoader,
+                                                              @NonNull Class<S> serviceClass,
+                                                              @Nullable Predicate<S> predicate) {
+        SoftServiceLoader.StaticServiceLoader<S> staticServiceLoader = (SoftServiceLoader.StaticServiceLoader<S>) SoftServiceLoader.STATIC_SERVICES.get(serviceClass.getName());
+        if (staticServiceLoader != null) {
+            return staticServiceLoader.load(predicate);
+        }
+        return new MicronautServiceCollector<>(classLoader, serviceClass.getName(), predicate)
+            .collect(true);
+    }
+
+    /**
+     * Find Micronaut service entries.
+     *
+     * @param classLoader The classloader
+     * @param serviceName The service name
+     * @return The entries
+     * @throws IOException
+     */
+    @NonNull
+    public static Set<String> findMicronautMetaServiceEntries(@NonNull ClassLoader classLoader,
+                                                              @NonNull String serviceName) throws IOException {
+        CacheEntry ce = cacheEntry;
+        if (ce == null || ce.classLoader != classLoader) {
+            ce = new CacheEntry(classLoader, findAllMicronautMetaServices(classLoader));
+            cacheEntry = ce;
+        }
+        return ce.services.getOrDefault(serviceName, Set.of());
+    }
+
+    /**
+     * Find all Micronaut services.
+     *
+     * @param classLoader The classloader
+     * @return the all entries
+     * @throws IOException
+     */
+    @NonNull
+    public static Map<String, Set<String>> findAllMicronautMetaServices(@NonNull ClassLoader classLoader) throws IOException {
+        final ServiceScanner.StaticServiceDefinitions ssd = ServiceScanner.findStaticServiceDefinitions();
+        if (ssd != null) {
+            return ssd.serviceTypeMap();
+        }
+        List<URI> resourceDefs = IOUtils.getResources(classLoader, MICRONAUT_SERVICES_PATH);
+        if (resourceDefs.isEmpty()) {
+            return Map.of();
+        }
+
+        Map<String, Set<String>> services = new LinkedHashMap<>();
+
+        FileVisitor<Path> visitor = new FileVisitor<>() {
+
+            private Set<String> definitions;
+
+            @Override
+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
+                if (dir.endsWith(MICRONAUT_SERVICES_PATH)) {
+                    return FileVisitResult.CONTINUE;
+                }
+                String serviceName = dir.getFileName().toString();
+                definitions = services.get(serviceName);
+                if (definitions == null) {
+                    definitions = new LinkedHashSet<>();
+                    services.put(serviceName, definitions);
+                }
+                return FileVisitResult.CONTINUE;
+            }
+
+            @Override
+            public FileVisitResult visitFile(Path currentPath, BasicFileAttributes attrs) throws IOException {
+                if (Files.isHidden(currentPath)) {
+                    return FileVisitResult.CONTINUE;
+                }
+                Path fileName = currentPath.getFileName();
+                if (fileName.startsWith(".")) {
+                    return FileVisitResult.CONTINUE;
+                }
+                definitions.add(fileName.toString());
+                return FileVisitResult.SKIP_SUBTREE;
+            }
+
+            @Override
+            public FileVisitResult visitFileFailed(Path file, IOException exc) {
+                return FileVisitResult.CONTINUE;
+            }
+
+            @Override
+            public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
+                return FileVisitResult.CONTINUE;
+            }
+        };
+
+        List<Closeable> toClose = new ArrayList<>();
+        try {
+            for (URI uri : resourceDefs) {
+                Path myPath = IOUtils.resolvePath(uri, MICRONAUT_SERVICES_PATH, toClose);
+                if (myPath != null) {
+                    Files.walkFileTree(myPath, Collections.emptySet(), 2, visitor);
+                }
+            }
+        } catch (IOException e) {
+            // ignore, can't do anything here and can't log because class used in compiler
+        } finally {
+            for (Closeable closeable : toClose) {
+                try {
+                    closeable.close();
+                } catch (IOException ignored) {
+                }
+            }
+        }
+        return services;
+    }
+
+    private static <S> S instantiate(String className, ClassLoader classLoader) {
+        try {
+            @SuppressWarnings("unchecked") final Class<S> loadedClass =
+                (Class<S>) Class.forName(className, false, classLoader);
+            // MethodHandler should more performant than the basic reflection
+            return (S) LOOKUP.findConstructor(loadedClass, VOID_TYPE).invoke();
+        } catch (NoClassDefFoundError | ClassNotFoundException | NoSuchMethodException |
+                 IllegalAccessException e) {
+            // Ignore
+            return null;
+        } catch (Throwable e) {
+            return sneakyThrow(e);
+        }
+    }
+
+    private static <T extends Throwable, R> R sneakyThrow(Throwable t) throws T {
+        throw (T) t;
+    }
+
+    /**
+     * Fork-join recursive services loader.
+     *
+     * @param <S> The service type
+     */
+    @SuppressWarnings("java:S1948")
+    private static final class MicronautServiceCollector<S> extends RecursiveActionValuesCollector<S> {
+
+        private final ClassLoader classLoader;
+        private final String serviceName;
+        private final Predicate<S> predicate;
+        private final List<RecursiveActionValuesCollector<S>> tasks = new ArrayList<>();
+        private int size;
+
+        MicronautServiceCollector(ClassLoader classLoader, String serviceName, Predicate<S> predicate) {
+            this.classLoader = classLoader;
+            this.serviceName = serviceName;
+            this.predicate = predicate;
+        }
+
+        @Override
+        protected void compute() {
+            try {
+                Set<String> serviceEntries = MicronautMetaServiceLoaderUtils.findMicronautMetaServiceEntries(classLoader, serviceName);
+                size = serviceEntries.size();
+                for (String serviceEntry : serviceEntries) {
+                    final ServiceInstanceLoader<S> task = new ServiceInstanceLoader<>(classLoader, serviceEntry, predicate);
+                    tasks.add(task);
+                    task.fork();
+                }
+            } catch (IOException e) {
+                throw new ServiceConfigurationError("Failed to load resources for service: " + serviceName, e);
+            }
+        }
+
+        public List<S> collect(boolean allowFork) {
+            if (allowFork && ForkJoinPool.getCommonPoolParallelism() > 1) {
+                ForkJoinPool.commonPool().invoke(this);
+                List<S> collection = null;
+                for (RecursiveActionValuesCollector<S> task : tasks) {
+                    task.join();
+                    if (collection == null) {
+                        collection = new ArrayList<>(size);
+                    }
+                    task.collect(collection);
+                }
+                if (collection == null) {
+                    return List.of();
+                }
+                return collection;
+            }
+            try {
+                Set<String> serviceEntries = MicronautMetaServiceLoaderUtils.findMicronautMetaServiceEntries(classLoader, serviceName);
+                List<S> collection = new ArrayList<>(serviceEntries.size());
+                for (String serviceEntry : serviceEntries) {
+                    S val = instantiate(serviceEntry, classLoader);
+                    if (val != null && predicate.test(val)) {
+                        collection.add(val);
+                    }
+                }
+                return collection;
+            } catch (IOException e) {
+                throw new ServiceConfigurationError("Failed to load resources for service: " + serviceName, e);
+            }
+        }
+
+        @Override
+        public void collect(Collection<S> values) {
+            throw new IllegalStateException("Only constructor method is supported!");
+        }
+    }
+
+    /**
+     * Initializes and filters the entry.
+     *
+     * @param <S> The service type
+     */
+    private static final class ServiceInstanceLoader<S> extends RecursiveActionValuesCollector<S> {
+
+        private final ClassLoader classLoader;
+        private final String className;
+        private final Predicate<S> predicate;
+        private S result;
+        private Throwable throwable;
+
+        public ServiceInstanceLoader(ClassLoader classLoader, String className, Predicate<S> predicate) {
+            this.classLoader = classLoader;
+            this.className = className;
+            this.predicate = predicate;
+        }
+
+        @Override
+        protected void compute() {
+            try {
+                result = instantiate(className, classLoader);
+                if (result != null && predicate != null && !predicate.test(result)) {
+                    result = null;
+                }
+            } catch (Throwable e) {
+                throwable = e;
+            }
+        }
+
+        @Override
+        public void collect(Collection<S> values) {
+            if (throwable != null) {
+                throw new SoftServiceLoader.ServiceLoadingException("Failed to load a service: " + throwable.getMessage(), throwable);
+            }
+            if (result != null && !values.contains(result)) {
+                values.add(result);
+            }
+        }
+    }
+
+    /**
+     * Abstract recursive action class.
+     *
+     * @param <S> The type
+     */
+    private abstract static class RecursiveActionValuesCollector<S> extends RecursiveAction {
+
+        /**
+         * Collects loaded values.
+         *
+         * @param values The values
+         */
+        public abstract void collect(Collection<S> values);
+
+    }
+
+    private record CacheEntry(ClassLoader classLoader, Map<String, Set<String>> services) {
+    }
+
+}
diff --git a/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java b/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java
index 8f6a2ff98b..6a7f71a9c5 100644
--- a/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java
+++ b/core/src/main/java/io/micronaut/core/io/service/ServiceLoaderFeature.java
@@ -15,8 +15,6 @@
  */
 package io.micronaut.core.io.service;
 
-import static io.micronaut.core.util.StringUtils.EMPTY_STRING_ARRAY;
-
 import io.micronaut.core.annotation.AnnotationClassValue;
 import io.micronaut.core.annotation.AnnotationValue;
 import io.micronaut.core.annotation.BuildTimeInit;
@@ -24,32 +22,27 @@ import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.beans.BeanInfo;
 import io.micronaut.core.graal.GraalReflectionConfigurer;
-import io.micronaut.core.io.IOUtils;
 import io.micronaut.core.io.service.ServiceScanner.StaticServiceDefinitions;
 import io.micronaut.core.reflect.exception.InstantiationException;
 import io.micronaut.core.util.ArrayUtils;
+import org.graalvm.nativeimage.ImageSingletons;
+import org.graalvm.nativeimage.hosted.Feature;
+import org.graalvm.nativeimage.hosted.RuntimeClassInitialization;
+import org.graalvm.nativeimage.hosted.RuntimeReflection;
+
 import java.io.IOException;
+import java.io.UncheckedIOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Enumeration;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
-import org.graalvm.nativeimage.ImageSingletons;
-import org.graalvm.nativeimage.hosted.Feature;
-import org.graalvm.nativeimage.hosted.RuntimeClassInitialization;
-import org.graalvm.nativeimage.hosted.RuntimeReflection;
+
+import static io.micronaut.core.util.StringUtils.EMPTY_STRING_ARRAY;
 
 /**
  * Integrates {@link io.micronaut.core.io.service.SoftServiceLoader} with GraalVM Native Image.
@@ -195,62 +188,13 @@ class ServiceLoaderFeature implements Feature {
      */
     @NonNull
     protected StaticServiceDefinitions buildStaticServiceDefinitions(BeforeAnalysisAccess access) {
-        StaticServiceDefinitions staticServiceDefinitions = new StaticServiceDefinitions(null);
-        final String path = "META-INF/micronaut/";
         try {
-            final Enumeration<URL> micronautResources = access.getApplicationClassLoader().getResources(path);
-            while (micronautResources.hasMoreElements()) {
-                Set<String> servicePaths = new HashSet<>();
-                URL url = micronautResources.nextElement();
-                URI uri = url.toURI();
-                boolean isFileScheme = "file".equals(uri.getScheme());
-                if (isFileScheme) {
-                    Path p = Paths.get(uri);
-                    // strip the META-INF/micronaut part
-                    uri = p.getParent().getParent().toUri();
-                }
-                IOUtils.eachFile(
-                        uri,
-                        path,
-                        servicePath -> {
-                            if (Files.isDirectory(servicePath)) {
-                                String serviceName = servicePath.toString();
-                                if (isFileScheme) {
-                                    int i = serviceName.indexOf(path);
-                                    if (i > -1) {
-                                        serviceName = serviceName.substring(i);
-                                    }
-                                } else if (serviceName.startsWith("/")) {
-                                    serviceName = serviceName.substring(1);
-                                }
-                                if (serviceName.startsWith(path)) {
-                                    servicePaths.add(serviceName);
-                                }
-                            }
-                        }
-                );
-
-                for (String servicePath : servicePaths) {
-                    IOUtils.eachFile(
-                            uri,
-                            servicePath,
-                            serviceTypePath -> {
-                                if (Files.isRegularFile(serviceTypePath)) {
-                                    final Set<String> serviceTypeNames = staticServiceDefinitions.serviceTypeMap()
-                                            .computeIfAbsent(servicePath,
-                                                             key -> new HashSet<>());
-                                    final String serviceTypeName = serviceTypePath.getFileName().toString();
-                                    serviceTypeNames.add(serviceTypeName);
-                                }
-                            }
-                    );
-                }
-            }
-
-        } catch (IOException | URISyntaxException e) {
-            // ignore
+            return new StaticServiceDefinitions(
+                MicronautMetaServiceLoaderUtils.findAllMicronautMetaServices(getClass().getClassLoader())
+            );
+        } catch (IOException e) {
+            throw new UncheckedIOException(e);
         }
-        return staticServiceDefinitions;
     }
 
     private void configureForReflection(BeforeAnalysisAccess access) {
diff --git a/core/src/main/java/io/micronaut/core/io/service/ServiceScanner.java b/core/src/main/java/io/micronaut/core/io/service/ServiceScanner.java
index 93d5962800..b74e29b199 100644
--- a/core/src/main/java/io/micronaut/core/io/service/ServiceScanner.java
+++ b/core/src/main/java/io/micronaut/core/io/service/ServiceScanner.java
@@ -17,39 +17,24 @@ package io.micronaut.core.io.service;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.io.IOUtils;
-import java.nio.file.FileSystemNotFoundException;
-import java.nio.file.ProviderNotFoundException;
-import java.util.stream.Stream;
 import org.graalvm.nativeimage.ImageSingletons;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.UncheckedIOException;
-import java.net.URI;
-import java.net.URISyntaxException;
 import java.net.URL;
-import java.nio.file.FileSystem;
-import java.nio.file.FileSystems;
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.nio.file.Paths;
 import java.util.ArrayList;
 import java.util.Collection;
-import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.ServiceConfigurationError;
 import java.util.Set;
 import java.util.concurrent.ForkJoinPool;
 import java.util.concurrent.RecursiveAction;
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Predicate;
 
@@ -72,49 +57,8 @@ final class ServiceScanner<S> {
         this.transformer = transformer;
     }
 
-    private static URI normalizeFilePath(String path, URI uri) {
-        Path p = Paths.get(uri);
-        if (p.endsWith(path)) {
-            Path subpath = Paths.get(path);
-            for (int i = 0; i < subpath.getNameCount(); i++) {
-                p = p.getParent();
-            }
-            uri = p.toUri();
-        }
-        return uri;
-    }
-
-    /**
-     * Note: referenced by {@code io.micronaut.core.graal.ServiceLoaderInitialization}.
-     */
-    @SuppressWarnings("java:S3398")
-    private static Set<String> computeMicronautServiceTypeNames(URI uri, String path) {
-        final StaticServiceDefinitions ssd = findStaticServiceDefinitions();
-        if (ssd != null) {
-            return ssd.serviceTypeMap.getOrDefault(
-                path,
-                Collections.emptySet()
-            );
-        } else {
-            Set<String> typeNames = new HashSet<>();
-            // Keep the anonymous class instead of Lambda to reduce the Lambda invocation overhead during the startup
-            @SuppressWarnings({"Convert2Lambda", "java:S1604"}) Consumer<Path> consumer = new Consumer<>() {
-
-                @Override
-                public void accept(Path currentPath) {
-                    if (Files.isRegularFile(currentPath)) {
-                        final String typeName = currentPath.getFileName().toString();
-                        typeNames.add(typeName);
-                    }
-                }
-            };
-            IOUtils.eachFile(uri, path, consumer);
-            return typeNames;
-        }
-    }
-
     @Nullable
-    private static StaticServiceDefinitions findStaticServiceDefinitions() {
+    static StaticServiceDefinitions findStaticServiceDefinitions() {
         if (hasImageSingletons()) {
             return ImageSingletons.contains(StaticServiceDefinitions.class) ? ImageSingletons.lookup(StaticServiceDefinitions.class) : null;
         } else {
@@ -143,7 +87,7 @@ final class ServiceScanner<S> {
                     if (line == null) {
                         break;
                     }
-                    if (line.length() == 0 || line.charAt(0) == '#') {
+                    if (line.isEmpty() || line.charAt(0) == '#') {
                         continue;
                     }
                     if (!lineCondition.test(line)) {
@@ -162,80 +106,10 @@ final class ServiceScanner<S> {
         return typeNames;
     }
 
-    private boolean isWebSphereClassLoader() {
-        return classLoader.getClass().getName().startsWith("com.ibm.ws.classloader");
-    }
-
-    private String buildResourceSearchPath() {
-        String path = "META-INF/micronaut/" + serviceName;
-
-        if (isWebSphereClassLoader()) {
-            // Special case WebSphere classloader
-            // https://github.com/micronaut-projects/micronaut-core/issues/9905
-            return path + "/";
-        }
-
-        return path;
-    }
-
     private Enumeration<URL> findStandardServiceConfigs() throws IOException {
         return classLoader.getResources(SoftServiceLoader.META_INF_SERVICES + '/' + serviceName);
     }
 
-    private void findMicronautMetaServiceConfigs(BiConsumer<URI, String> consumer) throws IOException, URISyntaxException {
-        String path = buildResourceSearchPath();
-        final Enumeration<URL> micronautResources = classLoader.getResources(path);
-        Set<URI> uniqueURIs = new LinkedHashSet<>();
-        while (micronautResources.hasMoreElements()) {
-            URL url = micronautResources.nextElement();
-            final URI uri = url.toURI();
-            uniqueURIs.add(uri);
-        }
-
-        if (uniqueURIs.isEmpty()) {
-            FileSystem fs = null;
-            try {
-                fs = FileSystems.getFileSystem(URI.create("jrt:/"));
-            } catch (FileSystemNotFoundException | ProviderNotFoundException e) {
-                //no-op
-            }
-            if (fs == null || !fs.isOpen()) {
-                try {
-                    fs = FileSystems.newFileSystem(URI.create("jrt:/"), Collections.emptyMap(), classLoader);
-                } catch (IOException | ProviderNotFoundException e) {
-                    // not available, probably running in Native Image.
-                }
-            }
-            if (fs != null) {
-                Path modulesPath = fs.getPath("modules");
-                try (Stream<Path> stream = Files.list(modulesPath)) {
-                    stream
-                        .filter(p -> !p.getFileName().toString().startsWith("jdk.")) // filter out JDK internal modules
-                        .filter(p -> !p.getFileName().toString().startsWith("java.")) // filter out JDK public modules
-                        .map(p -> p.resolve(path))
-                        .filter(Files::exists)
-                        .map(modulesPath::resolve)
-                        .map(Path::toUri)
-                        .forEach(uniqueURIs::add);
-                }
-
-                // uri will be jrt:/modules/<module>/META-INF/micronaut/<service>, so we can walk through its files as if it was a directory
-            }
-        }
-
-        for (URI uri : uniqueURIs) {
-            String scheme = uri.getScheme();
-            if ("file".equals(scheme)) {
-                uri = normalizeFilePath(path, uri);
-            }
-            // on GraalVM there are spurious extra resources that end with # and then a number
-            // we ignore this extra ones
-            if (!("resource".equals(scheme) && uri.toString().contains("#"))) {
-                consumer.accept(uri, path);
-            }
-        }
-    }
-
     /**
      * Fork-join recursive services loader.
      */
@@ -254,12 +128,13 @@ final class ServiceScanner<S> {
                     tasks.add(task);
                     task.fork();
                 }
-                findMicronautMetaServiceConfigs((uri, path) -> {
-                    final MicronautMetaServicesLoader task = new MicronautMetaServicesLoader(uri, path);
+                Set<String> serviceEntries = MicronautMetaServiceLoaderUtils.findMicronautMetaServiceEntries(classLoader, serviceName);
+                for (String serviceEntry : serviceEntries) {
+                    final ServiceInstanceLoader task = new ServiceInstanceLoader(serviceEntry);
                     tasks.add(task);
                     task.fork();
-                });
-            } catch (IOException | URISyntaxException e) {
+                }
+            } catch (IOException e) {
                 throw new ServiceConfigurationError("Failed to load resources for service: " + serviceName, e);
             }
         }
@@ -293,51 +168,20 @@ final class ServiceScanner<S> {
                             }
                         }
                     }
-                    findMicronautMetaServiceConfigs((uri, path) -> {
-                        for (String typeName : computeMicronautServiceTypeNames(uri, path)) {
-                            S val = transformer.apply(typeName);
-                            if (val != null) {
-                                values.add(val);
-                            }
+                    Set<String> serviceEntries = MicronautMetaServiceLoaderUtils.findMicronautMetaServiceEntries(classLoader, serviceName);
+                    for (String serviceEntry : serviceEntries) {
+                        S val = transformer.apply(serviceEntry);
+                        if (val != null) {
+                            values.add(val);
                         }
-                    });
-                } catch (IOException | URISyntaxException e) {
+                    }
+                } catch (IOException e) {
                     throw new ServiceConfigurationError("Failed to load resources for service: " + serviceName, e);
                 }
             }
         }
     }
 
-    private final class MicronautMetaServicesLoader extends RecursiveActionValuesCollector<S> {
-        private final URI uri;
-        private final List<ServiceInstanceLoader> tasks = new ArrayList<>();
-        private final String path;
-
-        private MicronautMetaServicesLoader(URI uri, String path) {
-            this.uri = uri;
-            this.path = path;
-        }
-
-        @Override
-        public void collect(Collection<S> values) {
-            for (ServiceInstanceLoader task : tasks) {
-                task.join();
-                task.collect(values);
-            }
-        }
-
-        @Override
-        @SuppressWarnings("java:S2095")
-        protected void compute() {
-            Set<String> typeNames = computeMicronautServiceTypeNames(uri, path);
-            for (String typeName : typeNames) {
-                ServiceInstanceLoader task = new ServiceInstanceLoader(typeName);
-                tasks.add(task);
-                task.fork();
-            }
-        }
-    }
-
     /**
      * Reads URL, parses the file and produces sub-tasks to initialize the entry.
      */
diff --git a/core/src/main/java/io/micronaut/core/io/service/SoftServiceLoader.java b/core/src/main/java/io/micronaut/core/io/service/SoftServiceLoader.java
index 2a53038814..7d21beb11b 100644
--- a/core/src/main/java/io/micronaut/core/io/service/SoftServiceLoader.java
+++ b/core/src/main/java/io/micronaut/core/io/service/SoftServiceLoader.java
@@ -46,14 +46,12 @@ import java.util.stream.Stream;
  */
 public final class SoftServiceLoader<S> implements Iterable<ServiceDefinition<S>> {
     public static final String META_INF_SERVICES = "META-INF/services";
-    private static final MethodHandles.Lookup LOOKUP = MethodHandles.publicLookup();
-    private static final MethodType VOID_TYPE = MethodType.methodType(void.class);
-
-    private static final Map<String, SoftServiceLoader.StaticServiceLoader<?>> STATIC_SERVICES =
+    static final Map<String, SoftServiceLoader.StaticServiceLoader<?>> STATIC_SERVICES =
             StaticOptimizations.get(Optimizations.class)
                     .map(Optimizations::getServiceLoaders)
                     .orElse(Collections.emptyMap());
-
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.publicLookup();
+    private static final MethodType VOID_TYPE = MethodType.methodType(void.class);
     private final Class<S> serviceType;
     private final ClassLoader classLoader;
     private Collection<ServiceDefinition<S>> servicesForIterator;
diff --git a/core/src/main/java/io/micronaut/core/reflect/ClassUtils.java b/core/src/main/java/io/micronaut/core/reflect/ClassUtils.java
index 61795f0454..ab6fc84b8e 100644
--- a/core/src/main/java/io/micronaut/core/reflect/ClassUtils.java
+++ b/core/src/main/java/io/micronaut/core/reflect/ClassUtils.java
@@ -33,15 +33,6 @@ import java.nio.charset.Charset;
 import java.time.Duration;
 import java.time.Instant;
 import java.time.LocalDate;
-import java.time.LocalTime;
-import java.time.MonthDay;
-import java.time.OffsetDateTime;
-import java.time.OffsetTime;
-import java.time.Period;
-import java.time.Year;
-import java.time.YearMonth;
-import java.time.ZoneId;
-import java.time.ZoneOffset;
 import java.time.ZonedDateTime;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -158,15 +149,6 @@ public class ClassUtils {
         BASIC_TYPE_MAP.put(LocalDate.class.getName(), LocalDate.class);
         BASIC_TYPE_MAP.put(Instant.class.getName(), Instant.class);
         BASIC_TYPE_MAP.put(ZonedDateTime.class.getName(), ZonedDateTime.class);
-        BASIC_TYPE_MAP.put(LocalTime.class.getName(), LocalTime.class);
-        BASIC_TYPE_MAP.put(OffsetTime.class.getName(), OffsetTime.class);
-        BASIC_TYPE_MAP.put(OffsetDateTime.class.getName(), OffsetDateTime.class);
-        BASIC_TYPE_MAP.put(Period.class.getName(), Period.class);
-        BASIC_TYPE_MAP.put(YearMonth.class.getName(), YearMonth.class);
-        BASIC_TYPE_MAP.put(Year.class.getName(), Year.class);
-        BASIC_TYPE_MAP.put(MonthDay.class.getName(), MonthDay.class);
-        BASIC_TYPE_MAP.put(ZoneId.class.getName(), ZoneId.class);
-        BASIC_TYPE_MAP.put(ZoneOffset.class.getName(), ZoneOffset.class);
     }
 
     /**
diff --git a/core/src/test/groovy/io/micronaut/core/io/buffer/ByteArrayByteBufferSpec.groovy b/core/src/test/groovy/io/micronaut/core/io/buffer/ByteArrayByteBufferSpec.groovy
new file mode 100644
index 0000000000..37eb288aa2
--- /dev/null
+++ b/core/src/test/groovy/io/micronaut/core/io/buffer/ByteArrayByteBufferSpec.groovy
@@ -0,0 +1,126 @@
+package io.micronaut.core.io.buffer
+
+import spock.lang.Specification
+
+import java.nio.charset.StandardCharsets
+
+class ByteArrayByteBufferSpec extends Specification {
+
+    void 'test creating a buffer'() {
+        given:
+        def bytes = 'abcdefghij'.bytes
+        def buffer = new ByteArrayByteBuffer(bytes)
+
+        expect:
+        buffer.toByteArray() == bytes
+        buffer.maxCapacity() == 10
+
+        buffer.readableBytes() == 10
+        buffer.readerIndex() == 0
+
+        buffer.writableBytes() == 10
+        buffer.writerIndex() == 0
+    }
+
+    void 'test copying a buffer'() {
+        given:
+        def bytes = 'abcdefghij'.bytes
+        def buffer = new ByteArrayByteBuffer(bytes)
+
+        when:
+        def sliced = buffer.slice(1, 5)
+
+        then:
+        sliced.toByteArray() == 'bcdef'.bytes
+
+        when:
+        def expanded = new ByteArrayByteBuffer(buffer.toByteArray(), 20)
+
+        then:
+        expanded.readerIndex() == 0
+        expanded.readableBytes() == 20
+        expanded.toByteArray() == 'abcdefghij\0\0\0\0\0\0\0\0\0\0'.bytes
+
+        when:
+        def shrunk = new ByteArrayByteBuffer(buffer.toByteArray(), 5)
+
+        then:
+        shrunk.readerIndex() == 0
+        shrunk.readableBytes() == 5
+        shrunk.toByteArray() == 'abcde'.bytes
+    }
+
+    void 'test inputstream creation'() {
+        given:
+        def bytes = 'abcdefghij'.bytes
+        def buffer = new ByteArrayByteBuffer(bytes)
+
+        when:
+        def stream = buffer.toInputStream()
+
+        then:
+        stream.readAllBytes() == bytes
+    }
+
+    void 'test writing'() {
+        given:
+        def bytes = 'abcdefghij'.bytes
+        def buffer = new ByteArrayByteBuffer(bytes)
+
+        when:
+        buffer.write('12345'.bytes)
+
+        then:
+        buffer.toByteArray() == '12345fghij'.bytes
+        buffer.readerIndex() == 0
+        buffer.readableBytes() == 10
+
+        buffer.writerIndex() == 5
+        buffer.writableBytes() == 5
+
+        when:
+        buffer = new ByteArrayByteBuffer('abcdefghij'.bytes)
+        buffer.writerIndex(5)
+        buffer.write('T', StandardCharsets.UTF_8)
+
+        then:
+        buffer.toByteArray() == 'abcdeTghij'.bytes
+        buffer.readerIndex() == 0
+        buffer.readableBytes() == 10
+        buffer.writerIndex() == 6
+        buffer.writableBytes() == 4
+    }
+
+    void 'test reading'() {
+        given:
+        def bytes = 'abcdefghij'.bytes
+        def buffer = new ByteArrayByteBuffer(bytes)
+        def target = new byte[5]
+
+        when:
+        buffer.read(target)
+
+        then:
+        target == 'abcde'.bytes
+        buffer.readerIndex() == 5
+        buffer.readableBytes() == 5
+
+        buffer.writerIndex() == 0
+        buffer.writableBytes() == 10
+
+        when:
+        target = new byte[5]
+        buffer = new ByteArrayByteBuffer('abcdefghij'.bytes)
+        buffer.readerIndex(5)
+        buffer.read(target, 3, 5)
+
+        then:
+        target == '\0\0\0fg'.bytes
+        buffer.writerIndex() == 0
+        buffer.writableBytes() == 10
+
+        and: 'we only read 2 elements'
+        buffer.readerIndex() == 7
+        buffer.readableBytes() == 3
+    }
+}
diff --git a/gradle.properties b/gradle.properties
index 05ec9cc2cf..43def3f710 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -3,7 +3,7 @@ projectGroupId=io.micronaut
 projectDesc=Core components supporting the Micronaut Framework
 title=Micronaut Core
 githubSlug=micronaut-projects/micronaut-core
-docsRepository=micronaut-projects/micronaut-docs 
+docsRepository=micronaut-projects/micronaut-docs
 testsdir=inject-groovy/src/test/groovy/io/micronaut/docs
 testssession=session/src/test/groovy/io/micronaut/session/docs
 testskafka=configurations/kafka/src/test/groovy/io/micronaut/configuration/kafka/docs
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 3fb363bbd4..1eb6efee27 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -33,19 +33,20 @@ jazzer = "0.22.1"
 jcache = "1.1.1"
 junit5 = "5.10.3"
 junit-platform="1.10.3"
-logback = "1.5.7"
+logback = "1.5.8"
 logbook-netty = "2.16.0"
 log4j = "2.23.1"
-micronaut-aws = "4.6.0"
-micronaut-build-plugins="7.2.0"
-micronaut-groovy = "4.3.0"
+micronaut-aws = "4.7.1"
+micronaut-build-plugins="7.2.1"
+micronaut-groovy = "4.4.0"
 micronaut-session = "4.3.0"
 micronaut-sql = "5.3.0"
 micronaut-test = "4.4.0"
 micronaut-validation = "4.6.1"
-micronaut-rxjava2 = "2.4.0"
+micronaut-rxjava2 = "2.5.0"
 micronaut-rxjava3 = "3.4.0"
-micronaut-reactor = "3.4.1"
+micronaut-reactor = "3.5.0"
+micronaut-kotlin = "4.4.0"
 native-gradle-plugin = "0.10.2"
 neo4j-java-driver = "5.17.0"
 selenium = "4.23.1"
@@ -56,7 +57,7 @@ spotbugs = "4.7.1"
 systemlambda = "1.2.1"
 testcontainers = "1.20.1"
 tomlj="1.1.1"
-vertx = "4.5.9"
+vertx = "4.5.10"
 wiremock = "2.33.2"
 mimepull = "1.10.0"
 
@@ -72,15 +73,15 @@ managed-jackson-databind = "2.17.0"
 managed-kotlin = "1.9.25"
 managed-kotlin-coroutines = "1.8.1"
 managed-methvin-directory-watcher = "0.18.0"
-managed-netty = "4.1.112.Final"
+managed-netty = "4.1.113.Final"
 managed-netty-iouring = "0.0.25.Final"
 managed-netty-http3 = "0.0.28.Final"
-managed-netty-tcnative = "2.0.65.Final"
+managed-netty-tcnative = "2.0.66.Final"
 managed-reactive-streams = "1.0.4"
 # This should be kept aligned with https://github.com/micronaut-projects/micronaut-reactor/blob/master/gradle.properties from the BOM
 managed-reactor = "3.6.9"
 managed-snakeyaml = "2.2"
-managed-java-parser-core = "3.26.1"
+managed-java-parser-core = "3.26.2"
 managed-ksp = "1.9.25-1.0.20"
 micronaut-docs = "2.0.0"
 
@@ -92,6 +93,7 @@ test-boms-micronaut-validation = { module = "io.micronaut.validation:micronaut-v
 test-boms-micronaut-rxjava2 = { module = "io.micronaut.rxjava2:micronaut-rxjava2-bom", version.ref = "micronaut-rxjava2" }
 test-boms-micronaut-rxjava3 = { module = "io.micronaut.rxjava3:micronaut-rxjava3-bom", version.ref = "micronaut-rxjava3" }
 test-boms-micronaut-reactor = { module = "io.micronaut.reactor:micronaut-reactor-bom", version.ref = "micronaut-reactor" }
+test-boms-micronaut-kotlin = { module = "io.micronaut.kotlin:micronaut-kotlin-bom", version.ref = "micronaut-kotlin" }
 
 boms-groovy = { module = "org.apache.groovy:groovy-bom", version.ref = "managed-groovy" }
 boms-kotlin = { module = "org.jetbrains.kotlin:kotlin-bom", version.ref = "managed-kotlin" }
@@ -275,6 +277,8 @@ micronaut-tracing-brave = { module = "io.micronaut.tracing:micronaut-tracing-bra
 micronaut-validation = { module = "io.micronaut.validation:micronaut-validation" }
 micronaut-validation-processor = { module = "io.micronaut.validation:micronaut-validation-processor" }
 
+micronaut-kotlin-runtime = { module = "io.micronaut.kotlin:micronaut-kotlin-runtime" }
+
 testcontainers-spock = { module = "org.testcontainers:spock", version.ref = "testcontainers" }
 
 vertx = { module = "io.vertx:vertx-core", version.ref = "vertx" }
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
index 2c3521197d..a4b76b9530 100644
Binary files a/gradle/wrapper/gradle-wrapper.jar and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 09523c0e54..9355b41557 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,6 +1,6 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-8.9-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.10-bin.zip
 networkTimeout=10000
 validateDistributionUrl=true
 zipStoreBase=GRADLE_USER_HOME
diff --git a/http-client-core/src/main/java/io/micronaut/http/client/AbstractHttpClientFactory.java b/http-client-core/src/main/java/io/micronaut/http/client/AbstractHttpClientFactory.java
index 107d109d58..4556dba099 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/AbstractHttpClientFactory.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/AbstractHttpClientFactory.java
@@ -19,6 +19,7 @@ import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.convert.ConversionService;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 
 import java.net.URI;
@@ -36,13 +37,14 @@ import java.net.URL;
 public abstract class AbstractHttpClientFactory<T extends HttpClient> implements HttpClientFactory {
 
     protected final MediaTypeCodecRegistry mediaTypeCodecRegistry;
+    protected final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
     protected final ConversionService conversionService;
 
-    protected AbstractHttpClientFactory(
-        @Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
-        ConversionService conversionService
-    ) {
+    protected AbstractHttpClientFactory(@Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
+                                        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
+                                        ConversionService conversionService) {
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
+        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
         this.conversionService = conversionService;
     }
 
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/AbstractJdkHttpClient.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/AbstractJdkHttpClient.java
index 627cc4e051..e28f6d44ae 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/AbstractJdkHttpClient.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/AbstractJdkHttpClient.java
@@ -30,6 +30,7 @@ import io.micronaut.http.HttpResponse;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MutableHttpRequest;
 import io.micronaut.http.bind.RequestBinderRegistry;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.client.HttpVersionSelection;
 import io.micronaut.http.client.LoadBalancer;
@@ -106,18 +107,20 @@ abstract class AbstractJdkHttpClient {
     protected final List<HttpFilterResolver.FilterEntry> clientFilterEntries;
     protected final CookieDecoder cookieDecoder;
     protected MediaTypeCodecRegistry mediaTypeCodecRegistry;
+    protected MessageBodyHandlerRegistry messageBodyHandlerRegistry;
 
     /**
-     * @param log                    the logger to use
-     * @param loadBalancer           The {@link LoadBalancer} to use for selecting servers
-     * @param httpVersion            The {@link HttpVersionSelection} to prefer
-     * @param configuration          The {@link HttpClientConfiguration} to use
-     * @param contextPath            The base URI to prepend to request uris
-     * @param mediaTypeCodecRegistry The {@link MediaTypeCodecRegistry} to use for encoding and decoding objects
-     * @param requestBinderRegistry  The request binder registry
-     * @param clientId               The client id
-     * @param conversionService      The {@link ConversionService}
-     * @param sslBuilder             The {@link JdkClientSslBuilder} for creating an {@link javax.net.ssl.SSLContext}
+     * @param log                        the logger to use
+     * @param loadBalancer               The {@link LoadBalancer} to use for selecting servers
+     * @param httpVersion                The {@link HttpVersionSelection} to prefer
+     * @param configuration              The {@link HttpClientConfiguration} to use
+     * @param contextPath                The base URI to prepend to request uris
+     * @param mediaTypeCodecRegistry     The {@link MediaTypeCodecRegistry} to use for encoding and decoding objects
+     * @param messageBodyHandlerRegistry The {@link MessageBodyHandlerRegistry} to use for encoding and decoding objects
+     * @param requestBinderRegistry      The request binder registry
+     * @param clientId                   The client id
+     * @param conversionService          The {@link ConversionService}
+     * @param sslBuilder                 The {@link JdkClientSslBuilder} for creating an {@link javax.net.ssl.SSLContext}
      */
     @SuppressWarnings({"java:S107", "checkstyle:parameternumber"}) // too many parameters
     protected AbstractJdkHttpClient(
@@ -129,6 +132,7 @@ abstract class AbstractJdkHttpClient {
         @Nullable HttpClientFilterResolver<ClientFilterResolutionContext> filterResolver,
         @Nullable List<HttpFilterResolver.FilterEntry> clientFilterEntries,
         MediaTypeCodecRegistry mediaTypeCodecRegistry,
+        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         RequestBinderRegistry requestBinderRegistry,
         String clientId,
         ConversionService conversionService,
@@ -141,6 +145,7 @@ abstract class AbstractJdkHttpClient {
         this.httpVersion = httpVersion;
         this.configuration = configuration;
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
+        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
         this.requestBinderRegistry = requestBinderRegistry;
         this.clientId = clientId;
         this.conversionService = conversionService;
@@ -288,6 +293,20 @@ abstract class AbstractJdkHttpClient {
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
     }
 
+    /**
+     * @return The {@link MessageBodyHandlerRegistry}
+     */
+    public MessageBodyHandlerRegistry getMessageBodyHandlerRegistry() {
+        return messageBodyHandlerRegistry;
+    }
+
+    /**
+     * @param messageBodyHandlerRegistry The {@link MessageBodyHandlerRegistry}
+     */
+    public void setMessageBodyHandlerRegistry(MessageBodyHandlerRegistry messageBodyHandlerRegistry) {
+        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
+    }
+
     /**
      * Convert the Micronaut request to a JDK request.
      *
@@ -296,7 +315,7 @@ abstract class AbstractJdkHttpClient {
      * @param <I>      The body type
      * @return A JDK request object
      */
-    protected <I> Mono<HttpRequest> mapToHttpRequest(io.micronaut.http.HttpRequest<I> request, Argument<?> bodyType) {
+    protected <I> Mono<HttpRequest> mapToHttpRequest(@NonNull io.micronaut.http.HttpRequest<I> request, @Nullable Argument<?> bodyType) {
         return resolveRequestUri(request)
             .map(uri -> {
                 cookieDecoder.decode(request).ifPresent(cookies -> cookies.getAll().forEach(cookie -> {
@@ -304,7 +323,7 @@ abstract class AbstractJdkHttpClient {
                     cookieManager.getCookieStore().add(uri, newCookie);
                 }));
 
-                return HttpRequestFactory.builder(uri, request, configuration, bodyType, mediaTypeCodecRegistry).build();
+                return HttpRequestFactory.builder(uri, request, configuration, bodyType, mediaTypeCodecRegistry, messageBodyHandlerRegistry).build();
             });
     }
 
@@ -349,10 +368,10 @@ abstract class AbstractJdkHttpClient {
      */
     @NonNull
     protected <O> HttpResponse<O> response(@NonNull java.net.http.HttpResponse<byte[]> netResponse, @NonNull Argument<O> bodyType) {
-        return new HttpResponseAdapter<>(netResponse, bodyType, conversionService, mediaTypeCodecRegistry);
+        return new HttpResponseAdapter<>(netResponse, bodyType, conversionService, mediaTypeCodecRegistry, messageBodyHandlerRegistry);
     }
 
-    protected <I, O> Flux<HttpResponse<O>> exchangeImpl(@NonNull io.micronaut.http.HttpRequest<I> request, @NonNull Argument<O> bodyType) {
+    protected <I, O> Flux<HttpResponse<O>> exchangeImpl(@NonNull io.micronaut.http.HttpRequest<I> request, @Nullable Argument<O> bodyType) {
         var defaultPublisher = responsePublisher(request, bodyType);
         return resolveRequestUri(request)
             .flatMapMany(uri -> applyFilterToResponsePublisher(request, uri, defaultPublisher));
@@ -389,8 +408,8 @@ abstract class AbstractJdkHttpClient {
     }
 
     protected <O> Publisher<io.micronaut.http.HttpResponse<O>> responsePublisher(
-        io.micronaut.http.HttpRequest<?> request,
-        Argument<O> bodyType
+        @NonNull io.micronaut.http.HttpRequest<?> request,
+        @Nullable Argument<O> bodyType
     ) {
         return Flux.defer(() -> mapToHttpRequest(request, bodyType)) // defered so any client filter changes are used
             .map(httpRequest -> {
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClient.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClient.java
index ba93c8dd02..71a05cf794 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClient.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClient.java
@@ -26,6 +26,7 @@ import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpResponse;
 import io.micronaut.http.bind.DefaultRequestBinderRegistry;
 import io.micronaut.http.bind.RequestBinderRegistry;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.client.BlockingHttpClient;
 import io.micronaut.http.client.DefaultHttpClientConfiguration;
 import io.micronaut.http.client.HttpClient;
@@ -66,6 +67,7 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
         @Nullable HttpClientFilterResolver<ClientFilterResolutionContext> filterResolver,
         @Nullable List<HttpFilterResolver.FilterEntry> clientFilterEntries,
         MediaTypeCodecRegistry mediaTypeCodecRegistry,
+        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         RequestBinderRegistry requestBinderRegistry,
         String clientId,
         ConversionService conversionService,
@@ -81,6 +83,7 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
             filterResolver,
             clientFilterEntries,
             mediaTypeCodecRegistry,
+            messageBodyHandlerRegistry,
             requestBinderRegistry,
             clientId,
             conversionService,
@@ -98,6 +101,7 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
             null,
             null,
             createDefaultMediaTypeRegistry(),
+            JdkHttpClientFactory.createDefaultMessageBodyHandlerRegistry(),
             new DefaultRequestBinderRegistry(conversionService),
             null,
             conversionService,
@@ -110,6 +114,7 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
         URI uri,
         HttpClientConfiguration configuration,
         MediaTypeCodecRegistry mediaTypeCodecRegistry,
+        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         ConversionService conversionService
     ) {
         this(
@@ -120,6 +125,7 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
             null,
             null,
             mediaTypeCodecRegistry,
+            messageBodyHandlerRegistry,
             new DefaultRequestBinderRegistry(conversionService),
             null,
             conversionService,
@@ -147,6 +153,7 @@ public class DefaultJdkHttpClient extends AbstractJdkHttpClient implements JdkHt
             filterResolver,
             clientFilterEntries,
             mediaTypeCodecRegistry,
+            messageBodyHandlerRegistry,
             requestBinderRegistry,
             clientId,
             conversionService,
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClientRegistry.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClientRegistry.java
index 739e9efb9b..4039f60b76 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClientRegistry.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/DefaultJdkHttpClientRegistry.java
@@ -29,11 +29,15 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.annotation.Order;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.io.ResourceResolver;
+import io.micronaut.core.type.Argument;
 import io.micronaut.core.util.StringUtils;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.annotation.FilterMatcher;
 import io.micronaut.http.bind.DefaultRequestBinderRegistry;
 import io.micronaut.http.bind.RequestBinderRegistry;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
+import io.micronaut.http.body.MessageBodyReader;
+import io.micronaut.http.body.MessageBodyWriter;
 import io.micronaut.http.client.HttpClient;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.client.HttpClientRegistry;
@@ -53,6 +57,7 @@ import io.micronaut.inject.InjectionPoint;
 import io.micronaut.inject.qualifiers.Qualifiers;
 import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
+import io.micronaut.json.body.CustomizableJsonHandler;
 import io.micronaut.json.codec.MapperMediaTypeCodec;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -61,6 +66,7 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
@@ -86,6 +92,7 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
     private final JsonMapper jsonMapper;
     @Nullable
     private final MediaTypeCodecRegistry mediaTypeCodecRegistry;
+    private final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
     private final BeanProvider<RequestBinderRegistry> requestBinderRegistryProvider;
     private final JdkClientSslBuilder jdkClientSslBuilder;
     private final CookieDecoder cookieDecoder;
@@ -98,6 +105,7 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
         HttpClientFilterResolver<ClientFilterResolutionContext> httpClientFilterResolver,
         JsonMapper jsonMapper,
         @Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
+        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         BeanProvider<RequestBinderRegistry> requestBinderRegistryProvider,
         BeanProvider<JdkClientSslBuilder> sslBuilderBeanProvider,
         BeanProvider<CookieDecoder> cookieDecoderBeanProvider
@@ -108,6 +116,7 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
         this.clientFilterResolver = httpClientFilterResolver;
         this.jsonMapper = jsonMapper;
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
+        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
         this.requestBinderRegistryProvider = requestBinderRegistryProvider;
         this.jdkClientSslBuilder = sslBuilderBeanProvider.orElse(new JdkClientSslBuilder(new ResourceResolver()));
         this.cookieDecoder = cookieDecoderBeanProvider.orElse(new CompositeCookieDecoder(List.of(new DefaultCookieDecoder())));
@@ -261,6 +270,27 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
                     codecs.add(createNewJsonCodec(this.beanContext, jsonFeatures));
                 }
                 client.setMediaTypeCodecRegistry(MediaTypeCodecRegistry.of(codecs));
+                client.setMessageBodyHandlerRegistry(new MessageBodyHandlerRegistry() {
+                    final MessageBodyHandlerRegistry delegate = client.getMessageBodyHandlerRegistry();
+
+                    @SuppressWarnings("unchecked")
+                    private <T> T customize(T handler) {
+                        if (handler instanceof CustomizableJsonHandler cnjh) {
+                            return (T) cnjh.customize(jsonFeatures);
+                        }
+                        return handler;
+                    }
+
+                    @Override
+                    public <T> Optional<MessageBodyReader<T>> findReader(Argument<T> type, List<MediaType> mediaType) {
+                        return delegate.findReader(type, mediaType).map(this::customize);
+                    }
+
+                    @Override
+                    public <T> Optional<MessageBodyWriter<T>> findWriter(Argument<T> type, List<MediaType> mediaType) {
+                        return delegate.findWriter(type, mediaType).map(this::customize);
+                    }
+                });
             }
             return client;
         });
@@ -287,6 +317,7 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
                 annotationMetadata
             )),
             mediaTypeCodecRegistry,
+            messageBodyHandlerRegistry,
             requestBinderRegistryProvider.orElse(new DefaultRequestBinderRegistry(conversionService)),
             clientId,
             conversionService,
@@ -316,10 +347,9 @@ public final class DefaultJdkHttpClientRegistry implements AutoCloseable, HttpCl
     @Override
     public void disposeClient(AnnotationMetadata annotationMetadata) {
         final ClientKey key = getClientKey(annotationMetadata);
-        HttpClient client = clients.get(key);
+        HttpClient client = clients.remove(key);
         if (client != null && client.isRunning()) {
             client.close();
-            clients.remove(key);
         }
     }
 
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpRequestFactory.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpRequestFactory.java
index 7a2299e194..048fd54465 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpRequestFactory.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpRequestFactory.java
@@ -18,15 +18,20 @@ package io.micronaut.http.client.jdk;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpMethod;
 import io.micronaut.http.MediaType;
+import io.micronaut.http.MutableHttpRequest;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
+import io.micronaut.http.body.MessageBodyWriter;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 
+import java.io.ByteArrayOutputStream;
 import java.net.URI;
 import java.net.URLEncoder;
 import java.net.http.HttpRequest;
@@ -52,19 +57,21 @@ public final class HttpRequestFactory {
     public static <I> HttpRequest.Builder builder(
         @NonNull URI uri, io.micronaut.http.HttpRequest<I> request,
         @NonNull HttpClientConfiguration configuration,
-        Argument<?> bodyType,
-        MediaTypeCodecRegistry mediaTypeCodecRegistry
+        @Nullable Argument<?> bodyType,
+        @Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
+        @NonNull MessageBodyHandlerRegistry messageBodyHandlerRegistry
     ) {
+        MutableHttpRequest<I> mutableHttpRequest = request.toMutableRequest();
         final HttpRequest.Builder builder = HttpRequest.newBuilder().uri(uri);
         configuration.getReadTimeout().ifPresent(builder::timeout);
-        if (request.getMethod() == HttpMethod.GET) {
+        if (mutableHttpRequest.getMethod() == HttpMethod.GET) {
             builder.GET();
         } else {
-            HttpRequest.BodyPublisher bodyPublisher = publisherForRequest(request, bodyType, mediaTypeCodecRegistry);
-            builder.method(request.getMethod().toString(), bodyPublisher);
+            HttpRequest.BodyPublisher bodyPublisher = publisherForRequest(mutableHttpRequest, bodyType, mediaTypeCodecRegistry, messageBodyHandlerRegistry);
+            builder.method(mutableHttpRequest.getMethod().toString(), bodyPublisher);
         }
-        request.getHeaders().forEach((name, values) -> values.forEach(value -> builder.header(name, value)));
-        if (request.getContentType().isEmpty()) {
+        mutableHttpRequest.getHeaders().forEach((name, values) -> values.forEach(value -> builder.header(name, value)));
+        if (mutableHttpRequest.getContentType().isEmpty()) {
             builder.header(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON);
         }
         configuration.getReadTimeout().ifPresent(builder::timeout);
@@ -72,51 +79,59 @@ public final class HttpRequestFactory {
     }
 
     private static <I> HttpRequest.BodyPublisher publisherForRequest(
-        io.micronaut.http.HttpRequest<I> request,
-        Argument<?> bodyType,
-        MediaTypeCodecRegistry mediaTypeCodecRegistry
+        @NonNull MutableHttpRequest<I> request,
+        @Nullable Argument<?> bodyType,
+        @Nullable MediaTypeCodecRegistry mediaTypeCodecRegistry,
+        @NonNull MessageBodyHandlerRegistry messageBodyHandlerRegistry
     ) {
-        if (io.micronaut.http.HttpMethod.permitsRequestBody(request.getMethod())) {
-            Optional<?> body = request.getBody();
-            boolean hasBody = body.isPresent();
-            MediaType requestContentType = request.getContentType().orElseGet(() -> MediaType.APPLICATION_JSON_TYPE);
-            if (requestContentType.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE) && hasBody) {
-                Object bodyValue = body.get();
+        if (!HttpMethod.permitsRequestBody(request.getMethod())) {
+            return HttpRequest.BodyPublishers.noBody();
+        }
+        Optional<?> body = request.getBody();
+        if (body.isPresent()) {
+            Object bodyValue = body.get();
+            MediaType requestContentType = request.getContentType().orElse(MediaType.APPLICATION_JSON_TYPE);
+            if (requestContentType.equals(MediaType.APPLICATION_FORM_URLENCODED_TYPE)) {
                 if (bodyValue instanceof CharSequence) {
                     return HttpRequest.BodyPublishers.ofString(bodyValue.toString());
-                } else if (bodyValue instanceof Map<?, ?> mapBody) {
+                }
+                if (bodyValue instanceof Map<?, ?> mapBody) {
                     return HttpRequest.BodyPublishers.ofString(encodeBody(mapBody, request.getCharacterEncoding()));
-                } else {
-                    throw unsupportedBodyType(bodyValue.getClass(), requestContentType.toString());
                 }
-            } else if (requestContentType.equals(MediaType.MULTIPART_FORM_DATA_TYPE) && hasBody) {
-                Object bodyValue = body.get();
+            }
+            if (Publishers.isConvertibleToPublisher(bodyValue)) {
                 throw unsupportedBodyType(bodyValue.getClass(), requestContentType.toString());
-            } else {
-                if (hasBody) {
-                    Object bodyValue = body.get();
-                    if (Publishers.isConvertibleToPublisher(bodyValue)) {
-                        throw unsupportedBodyType(bodyValue.getClass(), requestContentType.toString());
-                    } else if (bodyValue instanceof CharSequence) {
-                        return HttpRequest.BodyPublishers.ofString(bodyValue.toString());
-                    } else if (mediaTypeCodecRegistry != null) {
-                        Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(requestContentType);
-                        var encoded = registeredCodec.map(codec -> {
-                                if (bodyType != null && bodyType.isInstance(bodyValue)) {
-                                    return codec.encode((Argument<Object>) bodyType, bodyValue);
-                                } else {
-                                    return codec.encode(bodyValue);
-                                }
-                            })
-                            .orElse(null);
-                        if (encoded != null) {
-                            return HttpRequest.BodyPublishers.ofByteArray(encoded);
-                        } else {
-                            return HttpRequest.BodyPublishers.noBody();
+            }
+            if (bodyValue instanceof CharSequence) {
+                return HttpRequest.BodyPublishers.ofString(bodyValue.toString());
+            }
+            if (mediaTypeCodecRegistry != null) {
+                Optional<MediaTypeCodec> registeredCodec = mediaTypeCodecRegistry.findCodec(requestContentType);
+                var encoded = registeredCodec.map(codec -> {
+                        if (bodyType != null && bodyType.isInstance(bodyValue)) {
+                            return codec.encode((Argument<Object>) bodyType, bodyValue);
                         }
-                    }
+                        return codec.encode(bodyValue);
+                    })
+                    .orElse(null);
+                if (encoded != null) {
+                    return HttpRequest.BodyPublishers.ofByteArray(encoded);
                 }
             }
+            Argument<Object> bodyArgument = bodyType != null && bodyType.isInstance(bodyValue) ? (Argument<Object>) bodyType : Argument.ofInstance(bodyValue);
+            MessageBodyWriter<Object> messageBodyWriter = messageBodyHandlerRegistry.findWriter(bodyArgument, requestContentType).orElse(null);
+            if (messageBodyWriter != null) {
+                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+                messageBodyWriter.writeTo(
+                    bodyArgument,
+                    requestContentType,
+                    bodyValue,
+                    request.getHeaders(),
+                    byteArrayOutputStream
+                );
+                return HttpRequest.BodyPublishers.ofByteArray(byteArrayOutputStream.toByteArray());
+            }
+            throw unsupportedBodyType(bodyValue.getClass(), requestContentType.toString());
         }
         return HttpRequest.BodyPublishers.noBody();
     }
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpResponseAdapter.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpResponseAdapter.java
index 8bacac66ac..25b2b34e35 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpResponseAdapter.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/HttpResponseAdapter.java
@@ -23,11 +23,14 @@ import io.micronaut.core.convert.ConversionContext;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.convert.value.MutableConvertibleValues;
 import io.micronaut.core.convert.value.MutableConvertibleValuesMap;
+import io.micronaut.core.io.buffer.ByteArrayBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpResponse;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
+import io.micronaut.http.body.MessageBodyReader;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
@@ -57,15 +60,18 @@ public class HttpResponseAdapter<O> implements HttpResponse<O> {
     private final MutableConvertibleValues<Object> attributes = new MutableConvertibleValuesMap<>();
 
     private final MediaTypeCodecRegistry mediaTypeCodecRegistry;
+    private final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
 
     public HttpResponseAdapter(java.net.http.HttpResponse<byte[]> httpResponse,
-                               @NonNull Argument<O> bodyType,
+                               @Nullable Argument<O> bodyType,
                                ConversionService conversionService,
-                               MediaTypeCodecRegistry mediaTypeCodecRegistry) {
+                               MediaTypeCodecRegistry mediaTypeCodecRegistry,
+                               MessageBodyHandlerRegistry messageBodyHandlerRegistry) {
         this.httpResponse = httpResponse;
         this.bodyType = bodyType;
         this.conversionService = conversionService;
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
+        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
     }
 
     @Override
@@ -95,53 +101,69 @@ public class HttpResponseAdapter<O> implements HttpResponse<O> {
 
     @Override
     public Optional<O> getBody() {
-        return convertBytes(getContentType().orElse(null), httpResponse.body(), bodyType);
+        return getBody(bodyType);
     }
 
     @Override
     public <T> Optional<T> getBody(Argument<T> type) {
-        return convertBytes(getContentType().orElse(null), httpResponse.body(), type);
+        final boolean isOptional = type.getType() == Optional.class;
+        final Argument<Object> theArgument = (Argument<Object>) (isOptional ? type.getFirstTypeVariable().orElse(type) : type);
+        Optional<?> optional = convertBytes(getContentType().orElse(null), httpResponse.body(), theArgument);
+        if (isOptional) {
+            // If the requested type is an Optional, then we need to wrap the result again
+            return Optional.of((T) optional);
+        }
+        return (Optional<T>) optional;
     }
 
-    private <T> Optional convertBytes(@Nullable MediaType contentType, byte[] bytes, Argument<T> type) {
+    private <T> Optional<T> convertBytes(@Nullable MediaType contentType, byte[] bytes, Argument<T> type) {
         if (bytes.length == 0) {
             return Optional.empty();
         }
-        final boolean isOptional = type.getType() == Optional.class;
-        final Argument finalArgument = isOptional ? type.getFirstTypeVariable().orElse(type) : type;
-
-        if (mediaTypeCodecRegistry != null && contentType != null) {
-            if (CharSequence.class.isAssignableFrom(finalArgument.getType())) {
+        if (type.getType().equals(byte[].class)) {
+            return Optional.of((T) bytes);
+        }
+        if (contentType != null) {
+            if (CharSequence.class.isAssignableFrom(type.getType())) {
                 Charset charset = contentType.getCharset().orElse(StandardCharsets.UTF_8);
-                var converted = Optional.of(new String(bytes, charset));
-                // If the requested type is an Optional, then we need to wrap the result again
-                return isOptional ? Optional.of(converted) : converted;
-            } else if (finalArgument.getType() == byte[].class) {
-                var converted = Optional.of(bytes);
-                // If the requested type is an Optional, then we need to wrap the result again
-                return isOptional ? Optional.of(converted) : converted;
-            } else {
-                Optional<MediaTypeCodec> foundCodec = mediaTypeCodecRegistry.findCodec(contentType);
-                if (foundCodec.isPresent()) {
-                    try {
-                        var converted = foundCodec.map(codec -> codec.decode(finalArgument, bytes));
-                        return isOptional ? Optional.of(converted) : converted;
-                    } catch (CodecException e) {
-                        if (LOG.isDebugEnabled()) {
-                            var message = e.getMessage();
-                            LOG.debug("Error decoding body for type [{}] from '{}'. Attempting fallback.", type, contentType);
-                            LOG.debug("CodecException Message was: {}", message == null ? "null" : message.replace("\n", ""));
-                        }
-                    }
+                return Optional.of((T) new String(bytes, charset));
+            }
+        }
+        if (mediaTypeCodecRegistry != null) {
+            Optional<MediaTypeCodec> foundCodec = mediaTypeCodecRegistry.findCodec(contentType);
+            if (foundCodec.isPresent()) {
+                try {
+                    return foundCodec.map(codec -> codec.decode(type, bytes));
+                } catch (CodecException e) {
+                    logCodecError(contentType, type, e);
+                }
+            }
+        }
+        if (messageBodyHandlerRegistry != null) {
+            MessageBodyReader<T> reader = messageBodyHandlerRegistry.findReader(type, contentType).orElse(null);
+            if (reader != null) {
+                try {
+                    T value = reader.read(
+                        type,
+                        contentType,
+                        getHeaders(),
+                        ByteArrayBufferFactory.INSTANCE.wrap(bytes)
+                    );
+                    return Optional.of(value);
+                } catch (CodecException e) {
+                    logCodecError(contentType, type, e);
                 }
             }
         }
         // last chance, try type conversion
-        var converted = conversionService.convert(bytes, ConversionContext.of(finalArgument));
-        if (isOptional) {
-            return Optional.of(converted);
-        } else {
-            return converted;
+       return conversionService.convert(bytes, ConversionContext.of(type));
+    }
+
+    private <T> void logCodecError(MediaType contentType, Argument<T> type, CodecException e) {
+        if (LOG.isDebugEnabled()) {
+            var message = e.getMessage();
+            LOG.debug("Error decoding body for type [{}] from '{}'. Attempting fallback.", type, contentType);
+            LOG.debug("CodecException Message was: {}", message == null ? "null" : message.replace("\n", ""));
         }
     }
 }
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkBlockingHttpClient.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkBlockingHttpClient.java
index 2641c8948f..6b55acd701 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkBlockingHttpClient.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkBlockingHttpClient.java
@@ -17,10 +17,12 @@ package io.micronaut.http.client.jdk;
 
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.bind.RequestBinderRegistry;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.client.BlockingHttpClient;
 import io.micronaut.http.client.HttpClientConfiguration;
 import io.micronaut.http.client.HttpVersionSelection;
@@ -52,6 +54,7 @@ public class JdkBlockingHttpClient extends AbstractJdkHttpClient implements Bloc
         @Nullable HttpClientFilterResolver<ClientFilterResolutionContext> filterResolver,
         @Nullable List<HttpFilterResolver.FilterEntry> clientFilterEntries,
         MediaTypeCodecRegistry mediaTypeCodecRegistry,
+        MessageBodyHandlerRegistry messageBodyHandlerRegistry,
         RequestBinderRegistry requestBinderRegistry,
         String clientId,
         ConversionService conversionService,
@@ -67,6 +70,7 @@ public class JdkBlockingHttpClient extends AbstractJdkHttpClient implements Bloc
             filterResolver,
             clientFilterEntries,
             mediaTypeCodecRegistry,
+            messageBodyHandlerRegistry,
             requestBinderRegistry,
             clientId,
             conversionService,
@@ -76,11 +80,10 @@ public class JdkBlockingHttpClient extends AbstractJdkHttpClient implements Bloc
     }
 
     @Override
-    public <I, O, E> io.micronaut.http.HttpResponse<O> exchange(io.micronaut.http.HttpRequest<I> request,
-                                              Argument<O> bodyType,
-                                              Argument<E> errorType) {
-        return exchangeImpl(request, bodyType)
-            .blockFirst();
+    public <I, O, E> io.micronaut.http.HttpResponse<O> exchange(@NonNull io.micronaut.http.HttpRequest<I> request,
+                                                                @Nullable Argument<O> bodyType,
+                                                                @Nullable Argument<E> errorType) {
+        return exchangeImpl(request, bodyType).blockFirst();
     }
 
     @Override
diff --git a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkHttpClientFactory.java b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkHttpClientFactory.java
index 3da749ca63..22c51013db 100644
--- a/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkHttpClientFactory.java
+++ b/http-client-jdk/src/main/java/io/micronaut/http/client/jdk/JdkHttpClientFactory.java
@@ -18,8 +18,16 @@ package io.micronaut.http.client.jdk;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.convert.ConversionService;
+import io.micronaut.core.io.buffer.ByteArrayBufferFactory;
+import io.micronaut.http.MediaType;
+import io.micronaut.http.body.ContextlessMessageBodyHandlerRegistry;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
+import io.micronaut.http.body.WritableBodyWriter;
 import io.micronaut.http.client.AbstractHttpClientFactory;
 import io.micronaut.http.client.HttpClientConfiguration;
+import io.micronaut.json.JsonMapper;
+import io.micronaut.json.body.JsonMessageHandler;
+import io.micronaut.runtime.ApplicationConfiguration;
 
 import java.net.URI;
 
@@ -33,7 +41,7 @@ import java.net.URI;
 public class JdkHttpClientFactory extends AbstractHttpClientFactory<DefaultJdkHttpClient> {
 
     public JdkHttpClientFactory() {
-        super(null, ConversionService.SHARED);
+        super(null, createDefaultMessageBodyHandlerRegistry(), ConversionService.SHARED);
     }
 
     @Override
@@ -43,6 +51,19 @@ public class JdkHttpClientFactory extends AbstractHttpClientFactory<DefaultJdkHt
 
     @Override
     protected DefaultJdkHttpClient createHttpClient(URI uri, HttpClientConfiguration configuration) {
-        return new DefaultJdkHttpClient(uri, configuration, mediaTypeCodecRegistry, conversionService);
+        return new DefaultJdkHttpClient(uri, configuration, mediaTypeCodecRegistry, messageBodyHandlerRegistry, conversionService);
+    }
+
+    public static MessageBodyHandlerRegistry createDefaultMessageBodyHandlerRegistry() {
+        ApplicationConfiguration applicationConfiguration = new ApplicationConfiguration();
+        ContextlessMessageBodyHandlerRegistry registry = new ContextlessMessageBodyHandlerRegistry(
+            applicationConfiguration,
+            ByteArrayBufferFactory.INSTANCE,
+            new WritableBodyWriter(applicationConfiguration)
+        );
+        JsonMapper mapper = JsonMapper.createDefault();
+        registry.add(MediaType.APPLICATION_JSON_TYPE, new JsonMessageHandler<>(mapper));
+        registry.add(MediaType.APPLICATION_JSON_STREAM_TYPE, new JsonMessageHandler<>(mapper));
+        return registry;
     }
 }
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index 358d5f6a93..fca9f0fc56 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -958,6 +958,7 @@ public class DefaultHttpClient implements
                 webSocketURL, protocolVersion, subprotocol, true, customHeaders, maxFramePayloadLength),
             requestBinderRegistry,
             mediaTypeCodecRegistry,
+            handlerRegistry,
             conversionService);
 
         return connectionManager.connectForWebsocket(requestKey, handler)
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java
index 5633a1587d..aa305d4c7c 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultNettyHttpClientRegistry.java
@@ -55,7 +55,6 @@ import io.micronaut.http.client.sse.SseClientRegistry;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 import io.micronaut.http.filter.HttpClientFilterResolver;
-import io.micronaut.http.netty.body.CustomizableNettyJsonHandler;
 import io.micronaut.http.netty.channel.ChannelPipelineCustomizer;
 import io.micronaut.http.netty.channel.ChannelPipelineListener;
 import io.micronaut.http.netty.channel.DefaultEventLoopGroupConfiguration;
@@ -68,6 +67,7 @@ import io.micronaut.inject.InjectionPoint;
 import io.micronaut.inject.qualifiers.Qualifiers;
 import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
+import io.micronaut.json.body.CustomizableJsonHandler;
 import io.micronaut.json.codec.MapperMediaTypeCodec;
 import io.micronaut.runtime.context.scope.refresh.RefreshEvent;
 import io.micronaut.runtime.context.scope.refresh.RefreshEventListener;
@@ -404,7 +404,7 @@ class DefaultNettyHttpClientRegistry implements AutoCloseable,
 
                     @SuppressWarnings("unchecked")
                     private <T> T customize(T handler) {
-                        if (handler instanceof CustomizableNettyJsonHandler cnjh) {
+                        if (handler instanceof CustomizableJsonHandler cnjh) {
                             return (T) cnjh.customize(jsonFeatures);
                         }
                         return handler;
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/websocket/NettyWebSocketClientHandler.java b/http-client/src/main/java/io/micronaut/http/client/netty/websocket/NettyWebSocketClientHandler.java
index 09d9b5d0fc..f993676b88 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/websocket/NettyWebSocketClientHandler.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/websocket/NettyWebSocketClientHandler.java
@@ -24,6 +24,7 @@ import io.micronaut.core.convert.value.ConvertibleValues;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.MutableHttpRequest;
 import io.micronaut.http.bind.RequestBinderRegistry;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 import io.micronaut.http.netty.websocket.AbstractNettyWebSocketHandler;
 import io.micronaut.http.netty.websocket.NettyWebSocketSession;
@@ -70,7 +71,6 @@ public class NettyWebSocketClientHandler<T> extends AbstractNettyWebSocketHandle
     private final WebSocketBean<T> genericWebSocketBean;
     private final Sinks.One<T> completion = Sinks.one();
     private final UriMatchInfo matchInfo;
-    private final MediaTypeCodecRegistry codecRegistry;
     private NettyWebSocketSession clientSession;
     private FullHttpResponse handshakeResponse;
     private Argument<?> clientBodyArgument;
@@ -79,12 +79,13 @@ public class NettyWebSocketClientHandler<T> extends AbstractNettyWebSocketHandle
     /**
      * Default constructor.
      *
-     * @param request                The originating request that created the WebSocket.
-     * @param webSocketBean          The WebSocket client bean.
-     * @param handshaker             The handshaker
-     * @param requestBinderRegistry  The request binder registry
-     * @param mediaTypeCodecRegistry The media type codec registry
-     * @param conversionService      The conversionService
+     * @param request                    The originating request that created the WebSocket.
+     * @param webSocketBean              The WebSocket client bean.
+     * @param handshaker                 The handshaker
+     * @param requestBinderRegistry      The request binder registry
+     * @param mediaTypeCodecRegistry     The media type codec registry
+     * @param messageBodyHandlerRegistry The handler registry
+     * @param conversionService          The conversionService
      */
     public NettyWebSocketClientHandler(
             MutableHttpRequest<?> request,
@@ -92,9 +93,9 @@ public class NettyWebSocketClientHandler<T> extends AbstractNettyWebSocketHandle
             final WebSocketClientHandshaker handshaker,
             RequestBinderRegistry requestBinderRegistry,
             MediaTypeCodecRegistry mediaTypeCodecRegistry,
+            MessageBodyHandlerRegistry messageBodyHandlerRegistry,
             ConversionService conversionService) {
-        super(null, requestBinderRegistry, mediaTypeCodecRegistry, webSocketBean, request, Collections.emptyMap(), handshaker.version(), handshaker.actualSubprotocol(), null, conversionService);
-        this.codecRegistry = mediaTypeCodecRegistry;
+        super(requestBinderRegistry, mediaTypeCodecRegistry, messageBodyHandlerRegistry, webSocketBean, request, Collections.emptyMap(), handshaker.version(), handshaker.actualSubprotocol(), null, conversionService);
         this.handshaker = handshaker;
         this.genericWebSocketBean = webSocketBean;
         String clientPath = webSocketBean.getBeanDefinition().stringValue(ClientWebSocket.class).orElse("");
@@ -230,7 +231,8 @@ public class NettyWebSocketClientHandler<T> extends AbstractNettyWebSocketHandle
                     handshakeResponse.headers().get(HttpHeaderNames.SEC_WEBSOCKET_ACCEPT),
                     ctx.channel(),
                     originatingRequest,
-                    codecRegistry,
+                    mediaTypeCodecRegistry,
+                    messageBodyHandlerRegistry,
                     handshaker.version().toHttpHeaderValue(),
                     ctx.pipeline().get(SslHandler.class) != null
             ) {
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java b/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java
index 227b52902f..d8219767cd 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/NettyHttpResponseBuilder.java
@@ -120,7 +120,9 @@ public interface NettyHttpResponseBuilder {
      * @param byteBuf The byteBuf
      * @return The full response.
      * @since 4.3.0
+     * @deprecated Unused
      */
+    @Deprecated
     static @NonNull FullHttpResponse toFullHttpResponse(@NonNull io.micronaut.http.HttpResponse<?> response, @NonNull ByteBuf byteBuf) {
         while (response instanceof HttpResponseWrapper<?> wrapper) {
             response = wrapper.getDelegate();
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/NettyMutableHttpResponse.java b/http-netty/src/main/java/io/micronaut/http/netty/NettyMutableHttpResponse.java
index 06cb071f07..f55a7d91dd 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/NettyMutableHttpResponse.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/NettyMutableHttpResponse.java
@@ -27,6 +27,7 @@ import io.micronaut.core.convert.value.MutableConvertibleValuesMap;
 import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.util.StringUtils;
+import io.micronaut.http.HttpResponseWrapper;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpHeaders;
@@ -44,6 +45,7 @@ import io.netty.buffer.Unpooled;
 import io.netty.handler.codec.DecoderResult;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpHeaders;
+import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.DefaultLastHttpContent;
 import io.netty.handler.codec.http.EmptyHttpHeaders;
 import io.netty.handler.codec.http.FullHttpResponse;
@@ -53,6 +55,7 @@ import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
 
+import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -167,6 +170,38 @@ public final class NettyMutableHttpResponse<B> implements MutableHttpResponse<B>
         }
     }
 
+    /**
+     * Create a non-body netty response from the given MN response.
+     *
+     * @param response The mn response
+     * @return The netty response
+     */
+    public static @NonNull HttpResponse toNoBodyResponse(@NonNull io.micronaut.http.HttpResponse<?> response) {
+        Objects.requireNonNull(response, "The response cannot be null");
+        while (response instanceof HttpResponseWrapper<?> wrapper) {
+            response = wrapper.getDelegate();
+        }
+        HttpVersion version;
+        HttpResponseStatus status;
+        if (response instanceof NettyMutableHttpResponse<?> nmhr) {
+            version = nmhr.getNettyHttpVersion();
+            status = nmhr.getNettyHttpStatus();
+        } else {
+            version = HttpVersion.HTTP_1_1;
+            status = new HttpResponseStatus(response.code(), response.reason());
+        }
+        io.micronaut.http.HttpHeaders mnHeaders = response.getHeaders();
+        HttpHeaders nettyHeaders;
+        if (mnHeaders instanceof NettyHttpHeaders nhh) {
+            nettyHeaders = nhh.getNettyHeaders();
+        } else {
+            nettyHeaders = new DefaultHttpHeaders();
+            response.getHeaders()
+                .forEach((s, strings) -> nettyHeaders.add(s, strings));
+        }
+        return new DefaultHttpResponse(version, status, nettyHeaders);
+    }
+
     @Override
     public Optional<MessageBodyWriter<B>> getBodyWriter() {
         return Optional.ofNullable(messageBodyWriter);
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AvailableNettyByteBody.java b/http-netty/src/main/java/io/micronaut/http/netty/body/AvailableNettyByteBody.java
similarity index 98%
rename from http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AvailableNettyByteBody.java
rename to http-netty/src/main/java/io/micronaut/http/netty/body/AvailableNettyByteBody.java
index e003ca5519..34a2c5cc04 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AvailableNettyByteBody.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/AvailableNettyByteBody.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.micronaut.http.server.netty.body;
+package io.micronaut.http.netty.body;
 
 import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.core.annotation.Internal;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BodySizeLimits.java b/http-netty/src/main/java/io/micronaut/http/netty/body/BodySizeLimits.java
similarity index 94%
rename from http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BodySizeLimits.java
rename to http-netty/src/main/java/io/micronaut/http/netty/body/BodySizeLimits.java
index 8c47f52b8c..132e42024c 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BodySizeLimits.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/BodySizeLimits.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.micronaut.http.server.netty.body;
+package io.micronaut.http.netty.body;
 
 import io.micronaut.core.annotation.Internal;
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BufferConsumer.java b/http-netty/src/main/java/io/micronaut/http/netty/body/BufferConsumer.java
similarity index 98%
rename from http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BufferConsumer.java
rename to http-netty/src/main/java/io/micronaut/http/netty/body/BufferConsumer.java
index 06e98efbd6..406ad853d3 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/BufferConsumer.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/BufferConsumer.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.micronaut.http.server.netty.body;
+package io.micronaut.http.netty.body;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.http.body.ByteBody;
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyBodyWriter.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyBodyWriter.java
deleted file mode 100644
index 6f4eadbee9..0000000000
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyBodyWriter.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright 2017-2023 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.netty.body;
-
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.type.Argument;
-import io.micronaut.http.HttpRequest;
-import io.micronaut.http.MediaType;
-import io.micronaut.http.MutableHttpResponse;
-import io.micronaut.http.body.MessageBodyWriter;
-import io.micronaut.http.codec.CodecException;
-
-/**
- * Netty-specific writer.
- *
- * @param <T> The type to write
- */
-@Internal
-@Experimental
-public interface NettyBodyWriter<T> extends MessageBodyWriter<T> {
-
-    /**
-     * Write an object to the given context.
-     *
-     * @param request          The associated request
-     * @param outgoingResponse The outgoing response.
-     * @param type             The type
-     * @param mediaType        The media type
-     * @param object           The object to write
-     * @param nettyContext     The netty context
-     * @throws CodecException If an error occurs decoding
-     */
-    @NonNull
-    void writeTo(
-        @NonNull HttpRequest<?> request,
-        @NonNull MutableHttpResponse<T> outgoingResponse,
-        @NonNull Argument<T> type,
-        @NonNull MediaType mediaType,
-        @NonNull T object,
-        @NonNull NettyWriteContext nettyContext) throws CodecException;
-}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyByteBody.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyByteBody.java
similarity index 95%
rename from http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyByteBody.java
rename to http-netty/src/main/java/io/micronaut/http/netty/body/NettyByteBody.java
index f826f25bdc..919006eff7 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyByteBody.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyByteBody.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.micronaut.http.server.netty.body;
+package io.micronaut.http.netty.body;
 
 import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.core.annotation.Internal;
@@ -71,6 +71,6 @@ public abstract sealed class NettyByteBody implements ByteBody, InternalByteBody
     abstract Flux<ByteBuf> toByteBufPublisher();
 
     static void failClaim() {
-        throw new IllegalStateException("Request body has already been claimed: Two conflicting sites are trying to access the request body. If this is intentional, the first user must ByteBody#split the body. To find out where the body was claimed, turn on TRACE logging for io.micronaut.http.server.netty.body.NettyByteBody.");
+        throw new IllegalStateException("Request body has already been claimed: Two conflicting sites are trying to access the request body. If this is intentional, the first user must ByteBody#split the body. To find out where the body was claimed, turn on TRACE logging for io.micronaut.http.netty.body.NettyByteBody.");
     }
 }
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyCharSequenceBodyWriter.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyCharSequenceBodyWriter.java
index eca93cfff6..89d106b813 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyCharSequenceBodyWriter.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyCharSequenceBodyWriter.java
@@ -17,8 +17,11 @@ package io.micronaut.http.netty.body;
 
 import io.micronaut.context.annotation.Replaces;
 import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
@@ -26,19 +29,17 @@ import io.micronaut.http.MutableHttpHeaders;
 import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.body.CharSequenceBodyWriter;
 import io.micronaut.http.body.MessageBodyWriter;
+import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.netty.NettyHttpHeaders;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
-import io.netty.handler.codec.http.DefaultFullHttpResponse;
-import io.netty.handler.codec.http.EmptyHttpHeaders;
-import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.ByteBufUtil;
 import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpResponseStatus;
-import io.netty.handler.codec.http.HttpVersion;
 import jakarta.inject.Singleton;
 
 import java.io.OutputStream;
+import java.nio.CharBuffer;
 import java.nio.charset.StandardCharsets;
 
 /**
@@ -50,27 +51,18 @@ import java.nio.charset.StandardCharsets;
 @Singleton
 @Replaces(CharSequenceBodyWriter.class)
 @Internal
-public final class NettyCharSequenceBodyWriter implements MessageBodyWriter<CharSequence>, NettyBodyWriter<CharSequence> {
+public final class NettyCharSequenceBodyWriter implements ResponseBodyWriter<CharSequence> {
     private final CharSequenceBodyWriter defaultHandler = new CharSequenceBodyWriter(StandardCharsets.UTF_8);
 
     @Override
-    public void writeTo(HttpRequest<?> request, MutableHttpResponse<CharSequence> outgoingResponse, Argument<CharSequence> type, MediaType mediaType, CharSequence object, NettyWriteContext nettyContext) throws CodecException {
+    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<CharSequence> outgoingResponse, Argument<CharSequence> type, MediaType mediaType, CharSequence object) throws CodecException {
         MutableHttpHeaders headers = outgoingResponse.getHeaders();
-        ByteBuf byteBuf = Unpooled.copiedBuffer(object.toString(), MessageBodyWriter.getCharset(mediaType, headers));
+        ByteBuf byteBuf = ByteBufUtil.encodeString(ByteBufAllocator.DEFAULT, CharBuffer.wrap(object), MessageBodyWriter.getCharset(mediaType, headers));
         NettyHttpHeaders nettyHttpHeaders = (NettyHttpHeaders) headers;
-        io.netty.handler.codec.http.HttpHeaders nettyHeaders = nettyHttpHeaders.getNettyHeaders();
         if (!nettyHttpHeaders.contains(HttpHeaders.CONTENT_TYPE)) {
             nettyHttpHeaders.set(HttpHeaderNames.CONTENT_TYPE, mediaType);
         }
-        nettyHeaders.set(HttpHeaderNames.CONTENT_LENGTH, byteBuf.readableBytes());
-        FullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(
-            HttpVersion.HTTP_1_1,
-            HttpResponseStatus.valueOf(outgoingResponse.code(), outgoingResponse.reason()),
-            byteBuf,
-            nettyHeaders,
-            EmptyHttpHeaders.INSTANCE
-        );
-        nettyContext.writeFull(fullHttpResponse);
+        return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, new AvailableNettyByteBody(byteBuf));
     }
 
     @Override
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonHandler.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonHandler.java
index 019c94cb9e..b71c720fe3 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonHandler.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonHandler.java
@@ -20,29 +20,31 @@ import io.micronaut.context.annotation.Replaces;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Order;
 import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.Headers;
 import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.body.ChunkedMessageBodyReader;
 import io.micronaut.http.body.MessageBodyHandler;
 import io.micronaut.http.body.MessageBodyWriter;
+import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.netty.NettyHttpHeaders;
 import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
+import io.micronaut.json.body.CustomizableJsonHandler;
 import io.micronaut.json.body.JsonMessageHandler;
 import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufOutputStream;
-import io.netty.handler.codec.http.DefaultFullHttpResponse;
-import io.netty.handler.codec.http.EmptyHttpHeaders;
 import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpResponseStatus;
-import io.netty.handler.codec.http.HttpVersion;
 import jakarta.inject.Singleton;
 import org.reactivestreams.Publisher;
 import reactor.core.publisher.Flux;
@@ -56,6 +58,7 @@ import java.io.OutputStream;
  *
  * @param <T> The type
  */
+@Order(JsonMessageHandler.ORDER)
 @Singleton
 @Internal
 @Replaces(JsonMessageHandler.class)
@@ -63,7 +66,8 @@ import java.io.OutputStream;
 @JsonMessageHandler.ConsumesJson
 @BootstrapContextCompatible
 @Requires(beans = JsonMapper.class)
-public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, ChunkedMessageBodyReader<T>, CustomizableNettyJsonHandler, NettyBodyWriter<T> {
+
+public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, ChunkedMessageBodyReader<T>, CustomizableJsonHandler, ResponseBodyWriter<T> {
     private final JsonMessageHandler<T> jsonMessageHandler;
 
     public NettyJsonHandler(JsonMapper jsonMapper) {
@@ -75,7 +79,7 @@ public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, Chunked
     }
 
     @Override
-    public CustomizableNettyJsonHandler customize(JsonFeatures jsonFeatures) {
+    public CustomizableJsonHandler customize(JsonFeatures jsonFeatures) {
         return new NettyJsonHandler<>(jsonMessageHandler.getJsonMapper().cloneWithFeatures(jsonFeatures));
     }
 
@@ -128,10 +132,10 @@ public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, Chunked
     }
 
     @Override
-    public void writeTo(@NonNull HttpRequest<?> request, @NonNull MutableHttpResponse<T> outgoingResponse, @NonNull Argument<T> type, @NonNull MediaType mediaType, @NonNull T object, @NonNull NettyWriteContext nettyContext) throws CodecException {
+    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, @NonNull HttpRequest<?> request, @NonNull MutableHttpResponse<T> outgoingResponse, @NonNull Argument<T> type, @NonNull MediaType mediaType, @NonNull T object) throws CodecException {
         NettyHttpHeaders nettyHttpHeaders = (NettyHttpHeaders) outgoingResponse.getHeaders();
         nettyHttpHeaders.setIfMissing(HttpHeaderNames.CONTENT_TYPE, mediaType);
-        ByteBuf buffer = nettyContext.alloc().buffer();
+        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();
         JsonMapper jsonMapper = jsonMessageHandler.getJsonMapper();
         try {
             jsonMapper.writeValue(new ByteBufOutputStream(buffer), object);
@@ -139,7 +143,7 @@ public final class NettyJsonHandler<T> implements MessageBodyHandler<T>, Chunked
             buffer.release();
             throw new CodecException("Error encoding object [" + object + "] to JSON: " + e.getMessage(), e);
         }
-        nettyContext.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(outgoingResponse.code(), outgoingResponse.reason()), buffer, nettyHttpHeaders.getNettyHeaders(), EmptyHttpHeaders.INSTANCE));
+        return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, new AvailableNettyByteBody(buffer));
     }
 
     @Override
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonStreamHandler.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonStreamHandler.java
index 1ad9a5ef23..35e0eeff87 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonStreamHandler.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyJsonStreamHandler.java
@@ -29,6 +29,7 @@ import io.micronaut.http.body.MessageBodyHandler;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
+import io.micronaut.json.body.CustomizableJsonHandler;
 import io.micronaut.json.body.JsonMessageHandler;
 import io.netty.buffer.ByteBuf;
 import jakarta.inject.Singleton;
@@ -50,7 +51,7 @@ import java.util.List;
 @Singleton
 @Produces(MediaType.APPLICATION_JSON_STREAM)
 @Consumes(MediaType.APPLICATION_JSON_STREAM)
-public final class NettyJsonStreamHandler<T> implements MessageBodyHandler<T>, ChunkedMessageBodyReader<T>, CustomizableNettyJsonHandler {
+public final class NettyJsonStreamHandler<T> implements MessageBodyHandler<T>, ChunkedMessageBodyReader<T>, CustomizableJsonHandler {
     private final JsonMessageHandler<T> jsonMessageHandler;
 
     public NettyJsonStreamHandler(JsonMapper jsonMapper) {
@@ -62,7 +63,7 @@ public final class NettyJsonStreamHandler<T> implements MessageBodyHandler<T>, C
     }
 
     @Override
-    public CustomizableNettyJsonHandler customize(JsonFeatures jsonFeatures) {
+    public CustomizableJsonHandler customize(JsonFeatures jsonFeatures) {
         return new NettyJsonStreamHandler<>(jsonMessageHandler.getJsonMapper().cloneWithFeatures(jsonFeatures));
     }
 
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWritableBodyWriter.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWritableBodyWriter.java
index d2508cadfa..63ac58fd5e 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWritableBodyWriter.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWritableBodyWriter.java
@@ -20,9 +20,12 @@ import io.micronaut.context.annotation.Replaces;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.io.Writable;
 import io.micronaut.core.io.buffer.ByteBuffer;
+import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.Headers;
 import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
@@ -30,18 +33,14 @@ import io.micronaut.http.MutableHttpHeaders;
 import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.body.ChunkedMessageBodyReader;
 import io.micronaut.http.body.MessageBodyWriter;
+import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.body.TypedMessageBodyHandler;
 import io.micronaut.http.body.WritableBodyWriter;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.exceptions.MessageBodyException;
-import io.micronaut.http.netty.NettyHttpHeaders;
 import io.micronaut.runtime.ApplicationConfiguration;
-import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.ByteBufOutputStream;
-import io.netty.handler.codec.http.DefaultFullHttpResponse;
-import io.netty.handler.codec.http.EmptyHttpHeaders;
-import io.netty.handler.codec.http.HttpResponseStatus;
-import io.netty.handler.codec.http.HttpVersion;
 import jakarta.inject.Singleton;
 import org.reactivestreams.Publisher;
 
@@ -56,7 +55,7 @@ import java.io.OutputStream;
 @Singleton
 @Internal
 @BootstrapContextCompatible
-public final class NettyWritableBodyWriter implements NettyBodyWriter<Writable>, TypedMessageBodyHandler<Writable>, ChunkedMessageBodyReader<Writable> {
+public final class NettyWritableBodyWriter implements TypedMessageBodyHandler<Writable>, ChunkedMessageBodyReader<Writable>, ResponseBodyWriter<Writable> {
 
     private final WritableBodyWriter defaultWritable;
 
@@ -75,25 +74,19 @@ public final class NettyWritableBodyWriter implements NettyBodyWriter<Writable>,
     }
 
     @Override
-    public void writeTo(HttpRequest<?> request, MutableHttpResponse<Writable> outgoingResponse, Argument<Writable> type, MediaType mediaType, Writable object, NettyWriteContext nettyContext) throws CodecException {
-        ByteBuf byteBuf = nettyContext.alloc().ioBuffer(128);
+    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<Writable> outgoingResponse, Argument<Writable> type, MediaType mediaType, Writable object) throws CodecException {
         MutableHttpHeaders outgoingHeaders = outgoingResponse.getHeaders();
         if (mediaType != null && !outgoingHeaders.contains(HttpHeaders.CONTENT_TYPE)) {
             outgoingHeaders.contentType(mediaType);
         }
-        try (ByteBufOutputStream outputStream = new ByteBufOutputStream(byteBuf)) {
-            DefaultFullHttpResponse fullHttpResponse = new DefaultFullHttpResponse(
-                HttpVersion.HTTP_1_1,
-                HttpResponseStatus.valueOf(outgoingResponse.code(), outgoingResponse.reason()),
-                byteBuf,
-                ((NettyHttpHeaders) outgoingHeaders).getNettyHeaders(),
-                EmptyHttpHeaders.INSTANCE
-            );
+        ByteBufOutputStream outputStream = new ByteBufOutputStream(ByteBufAllocator.DEFAULT.buffer());
+        try {
             object.writeTo(outputStream, MessageBodyWriter.getCharset(mediaType, outgoingHeaders));
-            nettyContext.writeFull(fullHttpResponse);
+            outputStream.close();
         } catch (IOException e) {
             throw new MessageBodyException("Error writing body from writable", e);
         }
+        return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, new AvailableNettyByteBody(outputStream.buffer()));
     }
 
     @Override
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java
index 5efa56d677..4f80af7fe7 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/NettyWriteContext.java
@@ -19,11 +19,7 @@ import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.http.body.ByteBody;
-import io.netty.buffer.ByteBufAllocator;
-import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpResponse;
-import org.reactivestreams.Publisher;
 
 /**
  * This interface is used to write the different kinds of netty responses.
@@ -33,12 +29,6 @@ import org.reactivestreams.Publisher;
 @Internal
 @Experimental
 public interface NettyWriteContext {
-    /**
-     * @return The bytebuf allocator.
-     */
-    @NonNull
-    ByteBufAllocator alloc();
-
     /**
      * Write a response.
      *
@@ -48,28 +38,10 @@ public interface NettyWriteContext {
     void write(@NonNull HttpResponse response, @NonNull ByteBody body);
 
     /**
-     * Write a full response.
-     *
-     * @param response The response to write
-     */
-    default void writeFull(@NonNull FullHttpResponse response) {
-        writeFull(response, false);
-    }
-
-    /**
-     * Write a full response.
-     *
-     * @param response The response to write
-     * @param headResponse If {@code true}, this is a response to a {@code HEAD} request, so the
-     * {@code Content-Length} header should not be overwritten.
-     */
-    void writeFull(@NonNull FullHttpResponse response, boolean headResponse);
-
-    /**
-     * Write a streamed response.
+     * Write a response to a {@code HEAD} request. This is special because it never has a body but
+     * may still have a non-zero {@code Content-Length} header.
      *
-     * @param response The response to write
-     * @param content  The body
+     * @param response The response status, headers etc
      */
-    void writeStreamed(@NonNull HttpResponse response, @NonNull Publisher<HttpContent> content);
+    void writeHeadResponse(@NonNull HttpResponse response);
 }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamingNettyByteBody.java b/http-netty/src/main/java/io/micronaut/http/netty/body/StreamingNettyByteBody.java
similarity index 85%
rename from http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamingNettyByteBody.java
rename to http-netty/src/main/java/io/micronaut/http/netty/body/StreamingNettyByteBody.java
index 8d1df408be..c39ad0e0f8 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamingNettyByteBody.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/StreamingNettyByteBody.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.micronaut.http.server.netty.body;
+package io.micronaut.http.netty.body;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
@@ -25,7 +25,6 @@ import io.micronaut.http.body.CloseableAvailableByteBody;
 import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.exceptions.BufferLengthExceededException;
 import io.micronaut.http.exceptions.ContentLengthExceededException;
-import io.micronaut.http.netty.EventLoopFlow;
 import io.micronaut.http.netty.PublisherAsBlocking;
 import io.micronaut.http.netty.PublisherAsStream;
 import io.netty.buffer.ByteBuf;
@@ -57,14 +56,30 @@ import java.util.function.Supplier;
 @Internal
 public final class StreamingNettyByteBody extends NettyByteBody implements CloseableByteBody {
     private final SharedBuffer sharedBuffer;
+    /**
+     * We have reserve, subscribe, and add calls in {@link SharedBuffer} that all modify the same
+     * data structures. They can all happen concurrently and must be moved to the event loop. We
+     * also need to ensure that a reserve and associated subscribe stay serialized
+     * ({@link io.micronaut.http.netty.EventLoopFlow} semantics). But because of the potential
+     * concurrency, we actually need stronger semantics than
+     * {@link io.micronaut.http.netty.EventLoopFlow}.
+     * <p>
+     * The solution is to use the old {@link EventLoop#inEventLoop()} + {@link EventLoop#execute}
+     * pattern. Serialization semantics for reserve to subscribe are guaranteed using this field:
+     * If the reserve call is delayed, this field is {@code true}, and the subscribe call will also
+     * be delayed. This approach is possible because we only need to serialize a single reserve
+     * with a single subscribe.
+     */
+    private final boolean forceDelaySubscribe;
     private BufferConsumer.Upstream upstream;
 
     public StreamingNettyByteBody(SharedBuffer sharedBuffer) {
-        this(sharedBuffer, sharedBuffer.rootUpstream);
+        this(sharedBuffer, false, sharedBuffer.rootUpstream);
     }
 
-    private StreamingNettyByteBody(SharedBuffer sharedBuffer, BufferConsumer.Upstream upstream) {
+    private StreamingNettyByteBody(SharedBuffer sharedBuffer, boolean forceDelaySubscribe, BufferConsumer.Upstream upstream) {
         this.sharedBuffer = sharedBuffer;
+        this.forceDelaySubscribe = forceDelaySubscribe;
         this.upstream = upstream;
     }
 
@@ -74,7 +89,7 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
             failClaim();
         }
         this.upstream = null;
-        sharedBuffer.subscribe(primary, upstream);
+        sharedBuffer.subscribe(primary, upstream, forceDelaySubscribe);
         return upstream;
     }
 
@@ -86,8 +101,8 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
         }
         UpstreamBalancer.UpstreamPair pair = UpstreamBalancer.balancer(upstream, backpressureMode);
         this.upstream = pair.left();
-        this.sharedBuffer.reserve();
-        return new StreamingNettyByteBody(sharedBuffer, pair.right());
+        boolean forceDelaySubscribe = this.sharedBuffer.reserve();
+        return new StreamingNettyByteBody(sharedBuffer, forceDelaySubscribe, pair.right());
     }
 
     @Override
@@ -163,7 +178,7 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
         this.upstream = null;
         upstream.start();
         upstream.onBytesConsumed(Long.MAX_VALUE);
-        return sharedBuffer.subscribeFull(upstream).map(AvailableNettyByteBody::new);
+        return sharedBuffer.subscribeFull(upstream, forceDelaySubscribe).map(AvailableNettyByteBody::new);
     }
 
     @Override
@@ -176,14 +191,14 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
         upstream.allowDiscard();
         upstream.disregardBackpressure();
         upstream.start();
-        sharedBuffer.subscribe(null, upstream);
+        sharedBuffer.subscribe(null, upstream, forceDelaySubscribe);
     }
 
     /**
      * This class buffers input data and distributes it to multiple {@link StreamingNettyByteBody}
      * instances.
      * <p>Thread safety: The {@link BufferConsumer} methods <i>must</i> only be called from one
-     * thread, the {@link #eventLoopFlow} thread. The other methods (subscribe, reserve) can be
+     * thread, the {@link #eventLoop} thread. The other methods (subscribe, reserve) can be
      * called from any thread.
      */
     public static final class SharedBuffer implements BufferConsumer {
@@ -193,7 +208,7 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
         @Nullable
         private final ResourceLeakTracker<SharedBuffer> tracker = LEAK_DETECTOR.get().track(this);
 
-        private final EventLoopFlow eventLoopFlow;
+        private final EventLoop eventLoop;
         private final BodySizeLimits limits;
         /**
          * Upstream of all subscribers. This is only used to cancel incoming data if the max
@@ -230,6 +245,11 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
          * in a reentrant fashion.
          */
         private boolean working = false;
+        /**
+         * {@code true} during {@link #add(ByteBuf)} to avoid reentrant subscribe or reserve calls.
+         * Field must only be accessed on the event loop.
+         */
+        private boolean adding = false;
         /**
          * Number of bytes received so far.
          */
@@ -242,7 +262,7 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
         private volatile long expectedLength = -1;
 
         public SharedBuffer(EventLoop loop, BodySizeLimits limits, Upstream rootUpstream) {
-            this.eventLoopFlow = new EventLoopFlow(loop);
+            this.eventLoop = loop;
             this.limits = limits;
             this.rootUpstream = rootUpstream;
         }
@@ -274,9 +294,13 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
             this.expectedLength = length;
         }
 
-        void reserve() {
-            if (eventLoopFlow.executeNow(this::reserve0)) {
+        boolean reserve() {
+            if (eventLoop.inEventLoop() && !adding) {
                 reserve0();
+                return false;
+            } else {
+                eventLoop.execute(this::reserve0);
+                return true;
             }
         }
 
@@ -295,10 +319,13 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
          *
          * @param subscriber       The subscriber to add. Can be {@code null}, then the bytes will just be discarded
          * @param specificUpstream The upstream for the subscriber. This is used to call allowDiscard if there was an error
+         * @param forceDelay       Whether to require an {@link EventLoop#execute} call to ensure serialization with previous {@link #reserve()} call
          */
-        void subscribe(@Nullable BufferConsumer subscriber, Upstream specificUpstream) {
-            if (eventLoopFlow.executeNow(() -> subscribe0(subscriber, specificUpstream))) {
+        void subscribe(@Nullable BufferConsumer subscriber, Upstream specificUpstream, boolean forceDelay) {
+            if (!forceDelay && eventLoop.inEventLoop() && !adding) {
                 subscribe0(subscriber, specificUpstream);
+            } else {
+                eventLoop.execute(() -> subscribe0(subscriber, specificUpstream));
             }
         }
 
@@ -354,16 +381,18 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
          * body.
          *
          * @param specificUpstream The upstream for the subscriber. This is used to call allowDiscard if there was an error
+         * @param forceDelay       Whether to require an {@link EventLoop#execute} call to ensure serialization with previous {@link #reserve()} call
          * @return A flow that will complete when all data has arrived, with a buffer containing that data
          */
-        ExecutionFlow<ByteBuf> subscribeFull(Upstream specificUpstream) {
+        ExecutionFlow<ByteBuf> subscribeFull(Upstream specificUpstream, boolean forceDelay) {
             DelayedExecutionFlow<ByteBuf> asyncFlow = DelayedExecutionFlow.create();
-            if (eventLoopFlow.executeNow(() -> {
-                ExecutionFlow<ByteBuf> res = subscribeFull0(asyncFlow, specificUpstream, false);
-                assert res == asyncFlow;
-            })) {
+            if (!forceDelay && eventLoop.inEventLoop() && !adding) {
                 return subscribeFull0(asyncFlow, specificUpstream, true);
             } else {
+                eventLoop.execute(() -> {
+                    ExecutionFlow<ByteBuf> res = subscribeFull0(asyncFlow, specificUpstream, false);
+                    assert res == asyncFlow;
+                });
                 return asyncFlow;
             }
         }
@@ -445,6 +474,7 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
                 buf.release();
                 return;
             }
+            adding = true;
             // calculate the new total length
             long newLength = lengthSoFar + buf.readableBytes();
             lengthSoFar = newLength;
@@ -453,6 +483,7 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
                 buf.release();
                 error(new ContentLengthExceededException(limits.maxBodySize(), newLength));
                 rootUpstream.allowDiscard();
+                adding = false;
                 return;
             }
 
@@ -486,6 +517,7 @@ public final class StreamingNettyByteBody extends NettyByteBody implements Close
             } else {
                 buf.release();
             }
+            adding = false;
             working = false;
         }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/UpstreamBalancer.java b/http-netty/src/main/java/io/micronaut/http/netty/body/UpstreamBalancer.java
similarity index 98%
rename from http-server-netty/src/main/java/io/micronaut/http/server/netty/body/UpstreamBalancer.java
rename to http-netty/src/main/java/io/micronaut/http/netty/body/UpstreamBalancer.java
index d364dab8bb..966711c8fb 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/UpstreamBalancer.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/body/UpstreamBalancer.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.micronaut.http.server.netty.body;
+package io.micronaut.http.netty.body;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.http.body.ByteBody;
@@ -96,7 +96,7 @@ final class UpstreamBalancer {
     }
 
     /**
-     * Create a pair of {@link io.micronaut.http.server.netty.body.BufferConsumer.Upstream}
+     * Create a pair of {@link BufferConsumer.Upstream}
      * instances that delegates to the given {@code upstream} according to the semantics of the
      * given {@code mode}.
      */
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/stream/JsonSubscriber.java b/http-netty/src/main/java/io/micronaut/http/netty/stream/JsonSubscriber.java
index 5f389ad965..baf1762651 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/stream/JsonSubscriber.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/stream/JsonSubscriber.java
@@ -19,76 +19,34 @@ import io.micronaut.core.annotation.Internal;
 import io.micronaut.http.netty.content.HttpContentUtil;
 import io.netty.handler.codec.http.HttpContent;
 import org.reactivestreams.Publisher;
-import org.reactivestreams.Subscription;
-import reactor.core.CoreSubscriber;
 import reactor.core.publisher.Flux;
-import reactor.core.publisher.Operators;
-import reactor.util.context.Context;
 
-import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Function;
 
 /**
  * A Reactor subscriber used to handle JSON content. It delegates to an upstream subscriber, wrapping them with opening/closing brackets
  * where necessary.
  */
 @Internal
-public final class JsonSubscriber implements CoreSubscriber<HttpContent> {
-
-    private final AtomicBoolean empty = new AtomicBoolean(true);
-    private final CoreSubscriber<? super HttpContent> upstream;
-
-    public JsonSubscriber(CoreSubscriber<? super HttpContent> upstream) {
-        this.upstream = upstream;
-    }
-
-    @Override
-    public Context currentContext() {
-        return upstream.currentContext();
-    }
-
-    @Override
-    public void onSubscribe(Subscription s) {
-        upstream.onSubscribe(s);
-    }
-
-    /**
-     * The goal is to prevent the emission of the
-     * opening bracket if the underlying stream never emits
-     * an item and only produces an error.
-     *
-     * @param o The content
-     */
-    @Override
-    public void onNext(HttpContent o) {
-        if (empty.compareAndSet(true, false)) {
-            upstream.onNext(HttpContentUtil.prefixOpenBracket(o));
-        } else {
-            upstream.onNext(HttpContentUtil.prefixComma(o));
-        }
-    }
-
-    @Override
-    public void onError(Throwable t) {
-        upstream.onError(t);
-    }
-
-    /**
-     * On complete the opening bracket should be emitted
-     * if no items were ever produced, then the closing bracket.
-     */
-    @Override
-    public void onComplete() {
-        if (empty.get()) {
-            upstream.onNext(HttpContentUtil.prefixOpenBracket(HttpContentUtil.closeBracket()));
-        } else {
-            upstream.onNext(HttpContentUtil.closeBracket());
-        }
-        upstream.onComplete();
-    }
-
+public final class JsonSubscriber {
     public static Flux<HttpContent> lift(Publisher<HttpContent> publisher) {
-        return (Flux<HttpContent>) Operators.<HttpContent, HttpContent>lift(
-                (scannable, subscriber) -> new JsonSubscriber(subscriber)
-        ).apply(publisher);
+        HttpContent closeBracket = HttpContentUtil.closeBracket();
+        return Flux.from(publisher)
+            .concatWithValues(closeBracket)
+            .map(new Function<>() {
+                boolean empty = true;
+
+                @Override
+                public HttpContent apply(HttpContent httpContent) {
+                    if (empty) {
+                        empty = false;
+                        return HttpContentUtil.prefixOpenBracket(httpContent);
+                    } else if (httpContent != closeBracket) {
+                        return HttpContentUtil.prefixComma(httpContent);
+                    } else {
+                        return httpContent;
+                    }
+                }
+            });
     }
 }
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/websocket/AbstractNettyWebSocketHandler.java b/http-netty/src/main/java/io/micronaut/http/netty/websocket/AbstractNettyWebSocketHandler.java
index 542b373b9a..8636b7bf45 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/websocket/AbstractNettyWebSocketHandler.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/websocket/AbstractNettyWebSocketHandler.java
@@ -24,14 +24,18 @@ import io.micronaut.core.bind.DefaultExecutableBinder;
 import io.micronaut.core.bind.ExecutableBinder;
 import io.micronaut.core.bind.exceptions.UnsatisfiedArgumentException;
 import io.micronaut.core.convert.ConversionService;
+import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.annotation.Consumes;
 import io.micronaut.http.bind.RequestBinderRegistry;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
+import io.micronaut.http.body.MessageBodyReader;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
+import io.micronaut.http.simple.SimpleHttpHeaders;
 import io.micronaut.inject.ExecutableMethod;
 import io.micronaut.inject.MethodExecutionHandle;
 import io.micronaut.websocket.CloseReason;
@@ -92,6 +96,7 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
     protected final MethodExecutionHandle<?, ?> messageHandler;
     protected final MethodExecutionHandle<?, ?> pongHandler;
     protected final MediaTypeCodecRegistry mediaTypeCodecRegistry;
+    protected final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
     protected final WebSocketVersion webSocketVersion;
     protected final String subProtocol;
     protected final WebSocketSessionRepository webSocketSessionRepository;
@@ -102,9 +107,9 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
     /**
      * Default constructor.
      *
-     * @param ctx                        The channel handler context
      * @param binderRegistry             The request binder registry
      * @param mediaTypeCodecRegistry     The codec registry
+     * @param messageBodyHandlerRegistry The handler registry
      * @param webSocketBean              The websocket bean
      * @param request                    The originating request
      * @param uriVariables               The URI variables
@@ -114,9 +119,9 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
      * @param conversionService          The conversion service
      */
     protected AbstractNettyWebSocketHandler(
-            ChannelHandlerContext ctx,
             RequestBinderRegistry binderRegistry,
             MediaTypeCodecRegistry mediaTypeCodecRegistry,
+            MessageBodyHandlerRegistry messageBodyHandlerRegistry,
             WebSocketBean<?> webSocketBean,
             HttpRequest<?> request,
             Map<String, Object> uriVariables,
@@ -135,6 +140,7 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
         this.mediaTypeCodecRegistry = mediaTypeCodecRegistry;
         this.webSocketVersion = version;
         this.conversionService = conversionService;
+        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
     }
 
     /**
@@ -335,10 +341,10 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
                 }
 
                 Argument<?> bodyArgument = this.getBodyArgument();
-                Optional<?> converted = conversionService.convert(content, ByteBuf.class, bodyArgument);
+                Object data = conversionService.convert(content, ByteBuf.class, bodyArgument).orElse(null);
                 content.release();
 
-                if (converted.isEmpty()) {
+                if (data == null) {
                     MediaType mediaType;
                     try {
                         mediaType = messageHandler.stringValue(Consumes.class).map(MediaType::of).orElse(MediaType.APPLICATION_JSON_TYPE);
@@ -347,19 +353,28 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
                         return;
                     }
                     try {
-                        converted = mediaTypeCodecRegistry.findCodec(mediaType).map(codec -> codec.decode(bodyArgument, new NettyByteBufferFactory(ctx.alloc()).wrap(msg.content())));
+                        data = mediaTypeCodecRegistry.findCodec(mediaType)
+                            .map(codec -> codec.decode(bodyArgument, new NettyByteBufferFactory(ctx.alloc()).wrap(msg.content())))
+                            .orElse(null);
                     } catch (CodecException e) {
                         messageProcessingException(ctx, e);
                         return;
                     }
+                    if (data == null) {
+                        MessageBodyReader<?> reader = messageBodyHandlerRegistry.findReader(bodyArgument, mediaType)
+                            .orElse(null);
+                        if (reader != null) {
+                            ByteBuffer<ByteBuf> byteBuffer = new NettyByteBufferFactory(ctx.alloc()).wrap(msg.content().retain());
+                            data = reader.read((Argument) bodyArgument, mediaType, new SimpleHttpHeaders(), byteBuffer);
+                        }
+                    }
                 }
 
-                if (converted.isPresent()) {
-                    Object v = converted.get();
+                if (data != null) {
 
                     NettyWebSocketSession currentSession = getSession();
                     ExecutableBinder<WebSocketState> executableBinder = new DefaultExecutableBinder<>(
-                            Collections.singletonMap(bodyArgument, v)
+                            Collections.singletonMap(bodyArgument, data)
                     );
 
                     try {
@@ -372,14 +387,15 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
                         Object result = invokeExecutable(boundExecutable, messageHandler);
                         if (Publishers.isConvertibleToPublisher(result)) {
                             Flux<?> flowable = Flux.from(instrumentPublisher(ctx, result));
+                            Object finalData = data;
                             flowable.subscribe(
                                     o -> {
                                     },
                                     error -> messageProcessingException(ctx, error),
-                                    () -> messageHandled(ctx, v)
+                                    () -> messageHandled(ctx, finalData)
                             );
                         } else {
-                            messageHandled(ctx, v);
+                            messageHandled(ctx, data);
                         }
                     } catch (Throwable e) {
                         messageProcessingException(ctx, e);
@@ -389,7 +405,7 @@ public abstract class AbstractNettyWebSocketHandler extends SimpleChannelInbound
                     writeCloseFrameAndTerminate(
                             ctx,
                             CloseReason.UNSUPPORTED_DATA.getCode(),
-                            CloseReason.UNSUPPORTED_DATA.getReason() + ": " + "Received data cannot be converted to target type: " + bodyArgument
+                            CloseReason.UNSUPPORTED_DATA.getReason() + ": " + "Received data cannot be data to target type: " + bodyArgument
                     );
                 }
             }
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/websocket/NettyWebSocketSession.java b/http-netty/src/main/java/io/micronaut/http/netty/websocket/NettyWebSocketSession.java
index 9d1b443643..f20d00c67a 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/websocket/NettyWebSocketSession.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/websocket/NettyWebSocketSession.java
@@ -24,6 +24,7 @@ import io.micronaut.core.convert.value.MutableConvertibleValues;
 import io.micronaut.core.convert.value.MutableConvertibleValuesMap;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 import io.micronaut.websocket.CloseReason;
 import io.micronaut.websocket.WebSocketSession;
@@ -64,7 +65,6 @@ public class NettyWebSocketSession implements WebSocketSession {
     private final HttpRequest<?> request;
     private final String protocolVersion;
     private final boolean isSecure;
-    private final MediaTypeCodecRegistry codecRegistry;
     private final MutableConvertibleValues<Object> attributes;
     private final WebSocketMessageEncoder messageEncoder;
 
@@ -74,6 +74,7 @@ public class NettyWebSocketSession implements WebSocketSession {
      * @param channel The channel
      * @param request The original request used to create the session
      * @param codecRegistry The codec registry
+     * @param handlerRegistry The handlers registry
      * @param protocolVersion The protocol version
      * @param isSecure Whether the session is secure
      */
@@ -82,6 +83,7 @@ public class NettyWebSocketSession implements WebSocketSession {
             Channel channel,
             HttpRequest<?> request,
             MediaTypeCodecRegistry codecRegistry,
+            MessageBodyHandlerRegistry handlerRegistry,
             String protocolVersion,
             boolean isSecure) {
         this.id = id;
@@ -90,8 +92,7 @@ public class NettyWebSocketSession implements WebSocketSession {
         this.protocolVersion = protocolVersion;
         this.isSecure = isSecure;
         this.channel.attr(WEB_SOCKET_SESSION_KEY).set(this);
-        this.codecRegistry = codecRegistry;
-        this.messageEncoder = new WebSocketMessageEncoder(this.codecRegistry);
+        this.messageEncoder = new WebSocketMessageEncoder(codecRegistry, handlerRegistry);
         this.attributes = request.getAttribute("micronaut.SESSION", MutableConvertibleValues.class).orElseGet(MutableConvertibleValuesMap::new);
     }
 
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/websocket/WebSocketMessageEncoder.java b/http-netty/src/main/java/io/micronaut/http/netty/websocket/WebSocketMessageEncoder.java
index 90272d971b..cfe28bb3c0 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/websocket/WebSocketMessageEncoder.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/websocket/WebSocketMessageEncoder.java
@@ -17,17 +17,22 @@ package io.micronaut.http.netty.websocket;
 
 import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.context.annotation.Requires;
+import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.reflect.ClassUtils;
+import io.micronaut.core.type.Argument;
 import io.micronaut.http.MediaType;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
+import io.micronaut.http.body.MessageBodyWriter;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
+import io.micronaut.http.simple.SimpleHttpHeaders;
 import io.micronaut.websocket.exceptions.WebSocketSessionException;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketFrame;
+import jakarta.inject.Inject;
 import jakarta.inject.Singleton;
 
 import java.nio.ByteBuffer;
@@ -44,12 +49,28 @@ import java.util.Optional;
 public class WebSocketMessageEncoder {
 
     private final MediaTypeCodecRegistry codecRegistry;
+    @Nullable
+    private final MessageBodyHandlerRegistry messageBodyHandlerRegistry;
 
     /**
      * @param codecRegistry The codec registry
+     * @deprecated Not used anymore
      */
+    @Deprecated(forRemoval = true, since = "4.7")
     public WebSocketMessageEncoder(MediaTypeCodecRegistry codecRegistry) {
         this.codecRegistry = codecRegistry;
+        this.messageBodyHandlerRegistry = null;
+    }
+
+    /**
+     * @param codecRegistry The codec registry
+     * @param messageBodyHandlerRegistry The message body handler registry
+     */
+    @Inject
+    public WebSocketMessageEncoder(MediaTypeCodecRegistry codecRegistry,
+                                   MessageBodyHandlerRegistry messageBodyHandlerRegistry) {
+        this.codecRegistry = codecRegistry;
+        this.messageBodyHandlerRegistry = messageBodyHandlerRegistry;
     }
 
     /**
@@ -69,11 +90,26 @@ public class WebSocketMessageEncoder {
         } else if (message instanceof ByteBuffer buffer) {
             return new BinaryWebSocketFrame(Unpooled.wrappedBuffer(buffer));
         } else {
-            Optional<MediaTypeCodec> codec = codecRegistry.findCodec(mediaType != null ? mediaType : MediaType.APPLICATION_JSON_TYPE);
+            MediaType theMediaType = mediaType != null ? mediaType : MediaType.APPLICATION_JSON_TYPE;
+            Optional<MediaTypeCodec> codec = codecRegistry.findCodec(theMediaType);
             if (codec.isPresent()) {
-                io.micronaut.core.io.buffer.ByteBuffer encoded = codec.get().encode(message, new NettyByteBufferFactory(UnpooledByteBufAllocator.DEFAULT));
+                io.micronaut.core.io.buffer.ByteBuffer<?> encoded = codec.get().encode(message, NettyByteBufferFactory.DEFAULT);
                 return new TextWebSocketFrame((ByteBuf) encoded.asNativeBuffer());
             }
+            if (messageBodyHandlerRegistry != null) {
+                Argument<Object> argument = Argument.ofInstance(message);
+                MessageBodyWriter<Object> messageBodyWriter = messageBodyHandlerRegistry.findWriter(argument, theMediaType).orElse(null);
+                if (messageBodyWriter != null) {
+                    io.micronaut.core.io.buffer.ByteBuffer<?> encoded = messageBodyWriter.writeTo(
+                        argument,
+                        theMediaType,
+                        message,
+                        new SimpleHttpHeaders(),
+                        NettyByteBufferFactory.DEFAULT
+                    );
+                    return new TextWebSocketFrame((ByteBuf) encoded.asNativeBuffer());
+                }
+            }
         }
         throw new WebSocketSessionException("Unable to encode WebSocket message: " + message);
     }
diff --git a/http-netty/src/test/groovy/io/micronaut/http/netty/body/DefaultStringHandlerSpec.groovy b/http-netty/src/test/groovy/io/micronaut/http/netty/body/DefaultHandlerSpec.groovy
similarity index 80%
rename from http-netty/src/test/groovy/io/micronaut/http/netty/body/DefaultStringHandlerSpec.groovy
rename to http-netty/src/test/groovy/io/micronaut/http/netty/body/DefaultHandlerSpec.groovy
index 4c88da10d1..7c9536a6c6 100644
--- a/http-netty/src/test/groovy/io/micronaut/http/netty/body/DefaultStringHandlerSpec.groovy
+++ b/http-netty/src/test/groovy/io/micronaut/http/netty/body/DefaultHandlerSpec.groovy
@@ -22,11 +22,41 @@ import spock.lang.Specification
 import spock.lang.Unroll
 
 @MicronautTest
-class DefaultStringHandlerSpec extends Specification {
+class DefaultHandlerSpec extends Specification {
 
     @Inject
     DefaultMessageBodyHandlerRegistry bodyHandlerRegistry
 
+    void "test default writer / reader for ALL type"() {
+        when:
+            def writer = bodyHandlerRegistry.findWriter(Argument.listOf(SomeBean), MediaType.ALL_TYPE)
+
+        then:
+            writer.isPresent()
+            writer.get() instanceof NettyJsonHandler
+
+        when:
+            def reader = bodyHandlerRegistry.findReader(Argument.listOf(SomeBean), MediaType.ALL_TYPE)
+
+        then:
+            reader.isPresent()
+            reader.get() instanceof NettyJsonHandler
+    }
+
+    void "test default writer / reader for missing type"() {
+        when:
+            def writer = bodyHandlerRegistry.findWriter(Argument.listOf(SomeBean))
+
+        then:
+            writer.isEmpty()
+
+        when:
+            def reader = bodyHandlerRegistry.findReader(Argument.listOf(SomeBean))
+
+        then:
+            reader.isEmpty()
+    }
+
     @Unroll
     void "test string body handlers"() {
         when:
@@ -113,4 +143,6 @@ class DefaultStringHandlerSpec extends Specification {
         }
     }
 
+    class SomeBean {}
+
 }
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/body/UpstreamBalancerSpec.groovy b/http-netty/src/test/groovy/io/micronaut/http/netty/body/UpstreamBalancerSpec.groovy
similarity index 99%
rename from http-server-netty/src/test/groovy/io/micronaut/http/server/netty/body/UpstreamBalancerSpec.groovy
rename to http-netty/src/test/groovy/io/micronaut/http/netty/body/UpstreamBalancerSpec.groovy
index 13288faffe..aa896fea6f 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/body/UpstreamBalancerSpec.groovy
+++ b/http-netty/src/test/groovy/io/micronaut/http/netty/body/UpstreamBalancerSpec.groovy
@@ -1,4 +1,4 @@
-package io.micronaut.http.server.netty.body
+package io.micronaut.http.netty.body
 
 import io.micronaut.http.body.ByteBody.SplitBackpressureMode
 import spock.lang.Specification
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java
index 2caa735b95..93c7037dc6 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpPipelineBuilder.java
@@ -21,7 +21,7 @@ import io.micronaut.core.naming.Named;
 import io.micronaut.core.util.SupplierUtil;
 import io.micronaut.http.HttpVersion;
 import io.micronaut.http.netty.channel.ChannelPipelineCustomizer;
-import io.micronaut.http.server.netty.body.BodySizeLimits;
+import io.micronaut.http.netty.body.BodySizeLimits;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.netty.handler.Http2ServerHandler;
 import io.micronaut.http.server.netty.handler.PipeliningServerHandler;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpToHttpsRedirectHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpToHttpsRedirectHandler.java
index 63b6ccd512..3500956f15 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpToHttpsRedirectHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/HttpToHttpsRedirectHandler.java
@@ -18,9 +18,9 @@ package io.micronaut.http.server.netty;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.convert.ConversionService;
 import io.micronaut.http.HttpResponse;
-import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.netty.NettyHttpResponseBuilder;
+import io.micronaut.http.netty.body.AvailableNettyByteBody;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.netty.handler.OutboundAccess;
 import io.micronaut.http.server.netty.handler.RequestHandler;
@@ -28,9 +28,6 @@ import io.micronaut.http.server.util.HttpHostResolver;
 import io.micronaut.http.ssl.ServerSslConfiguration;
 import io.micronaut.http.uri.UriBuilder;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpRequest;
 
 /**
@@ -66,12 +63,11 @@ record HttpToHttpsRedirectHandler(
         }
         uriBuilder.path(strippedRequest.getPath());
 
-        MutableHttpResponse<?> response = HttpResponse
-            .permanentRedirect(uriBuilder.build())
-            .header(HttpHeaderNames.CONNECTION, HttpHeaderValues.CLOSE);
-        io.netty.handler.codec.http.HttpResponse nettyResponse = NettyHttpResponseBuilder.toHttpResponse(response);
         outboundAccess.closeAfterWrite();
-        outboundAccess.writeFull((FullHttpResponse) nettyResponse);
+        outboundAccess.write(
+            NettyHttpResponseBuilder.toHttpResponse(HttpResponse.permanentRedirect(uriBuilder.build())),
+            AvailableNettyByteBody.empty()
+        );
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
index 9e58ab3e8d..734411f717 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyHttpRequest.java
@@ -59,8 +59,8 @@ import io.micronaut.http.netty.stream.DefaultStreamedHttpRequest;
 import io.micronaut.http.netty.stream.DelegateStreamedHttpRequest;
 import io.micronaut.http.netty.stream.StreamedHttpRequest;
 import io.micronaut.http.server.HttpServerConfiguration;
-import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
-import io.micronaut.http.server.netty.body.NettyByteBody;
+import io.micronaut.http.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.netty.body.NettyByteBody;
 import io.micronaut.http.server.netty.handler.Http2ServerHandler;
 import io.micronaut.http.server.netty.multipart.NettyCompletedFileUpload;
 import io.micronaut.web.router.DefaultUriRouteMatch;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyRequestLifecycle.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyRequestLifecycle.java
index f285a2c22d..2ee6696860 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyRequestLifecycle.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/NettyRequestLifecycle.java
@@ -27,7 +27,7 @@ import io.micronaut.http.annotation.Body;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.netty.NettyMutableHttpResponse;
 import io.micronaut.http.server.RequestLifecycle;
-import io.micronaut.http.server.netty.body.NettyByteBody;
+import io.micronaut.http.netty.body.NettyByteBody;
 import io.micronaut.http.server.netty.handler.OutboundAccess;
 import io.micronaut.http.server.types.files.FileCustomizableResponseType;
 import io.micronaut.http.server.types.files.StreamedFile;
@@ -74,31 +74,37 @@ final class NettyRequestLifecycle extends RequestLifecycle {
 
         ExecutionFlow<HttpResponse<?>> result;
 
-        try {
-            // handle decoding failure
-            DecoderResult decoderResult = request.getNativeRequest().decoderResult();
-            if (decoderResult.isFailure()) {
-                Throwable cause = decoderResult.cause();
-                HttpStatus status = cause instanceof TooLongFrameException ? HttpStatus.REQUEST_ENTITY_TOO_LARGE : HttpStatus.BAD_REQUEST;
+        // handle decoding failure
+        DecoderResult decoderResult = request.getNativeRequest().decoderResult();
+        if (decoderResult.isFailure()) {
+            Throwable cause = decoderResult.cause();
+            HttpStatus status = cause instanceof TooLongFrameException ? HttpStatus.REQUEST_ENTITY_TOO_LARGE : HttpStatus.BAD_REQUEST;
+            try {
                 result = onStatusError(
                     request,
                     HttpResponse.status(status),
                     status.getReason()
                 );
-            } else {
-                result = normalFlow(request);
+            } catch (Exception e) {
+                result = ExecutionFlow.error(e);
             }
-            ImperativeExecutionFlow<HttpResponse<?>> imperativeFlow = result.tryComplete();
-            if (imperativeFlow != null) {
-                Object value = ((ImperativeExecutionFlow<?>) imperativeFlow).getValue();
-                // usually this is a MutableHttpResponse, avoid scalability issues here
-                HttpResponse<?> response = value instanceof NettyMutableHttpResponse<?> mut ? mut : (HttpResponse<?>) value;
-                rib.writeResponse(outboundAccess, request, response, imperativeFlow.getError());
-            } else {
-                result.onComplete((response, throwable) -> rib.writeResponse(outboundAccess, request, response, throwable));
+        } else {
+            try {
+                result = normalFlow(request);
+            } catch (Exception e) {
+                handleException(request, e);
+                return;
             }
-        } catch (Exception e) {
-            handleException(request, e);
+        }
+
+        ImperativeExecutionFlow<HttpResponse<?>> imperativeFlow = result.tryComplete();
+        if (imperativeFlow != null) {
+            Object value = ((ImperativeExecutionFlow<?>) imperativeFlow).getValue();
+            // usually this is a MutableHttpResponse, avoid scalability issues here
+            HttpResponse<?> response = value instanceof NettyMutableHttpResponse<?> mut ? mut : (HttpResponse<?>) value;
+            rib.writeResponse(outboundAccess, request, response, imperativeFlow.getError());
+        } else {
+            result.onComplete((response, throwable) -> rib.writeResponse(outboundAccess, request, response, throwable));
         }
     }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
index 086caf41d1..b9dc9a37df 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/RoutingInBoundHandler.java
@@ -23,11 +23,15 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.async.publisher.DelayedSubscriber;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.core.convert.ConversionService;
+import io.micronaut.core.execution.DelayedExecutionFlow;
+import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.propagation.PropagatedContext;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpAttributes;
 import io.micronaut.http.HttpMethod;
 import io.micronaut.http.HttpRequest;
@@ -38,6 +42,8 @@ import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.body.MediaTypeProvider;
 import io.micronaut.http.body.MessageBodyHandlerRegistry;
 import io.micronaut.http.body.MessageBodyWriter;
+import io.micronaut.http.body.ResponseBodyWriter;
+import io.micronaut.http.body.ResponseBodyWriterWrapper;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.context.ServerHttpRequestContext;
 import io.micronaut.http.context.ServerRequestContext;
@@ -46,15 +52,14 @@ import io.micronaut.http.exceptions.HttpStatusException;
 import io.micronaut.http.netty.EventLoopFlow;
 import io.micronaut.http.netty.NettyHttpResponseBuilder;
 import io.micronaut.http.netty.NettyMutableHttpResponse;
-import io.micronaut.http.netty.body.NettyBodyWriter;
+import io.micronaut.http.netty.body.AvailableNettyByteBody;
 import io.micronaut.http.netty.body.NettyJsonHandler;
-import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.netty.channel.ChannelPipelineCustomizer;
 import io.micronaut.http.netty.stream.JsonSubscriber;
 import io.micronaut.http.netty.stream.StreamedHttpResponse;
 import io.micronaut.http.server.RouteExecutor;
 import io.micronaut.http.server.binding.RequestArgumentSatisfier;
-import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.server.netty.body.NettyBodyAdapter;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.netty.handler.OutboundAccess;
 import io.micronaut.http.server.netty.handler.RequestHandler;
@@ -62,20 +67,18 @@ import io.micronaut.web.router.DefaultUrlRouteInfo;
 import io.micronaut.web.router.RouteInfo;
 import io.micronaut.web.router.resource.StaticResourceResolver;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.Unpooled;
+import io.netty.buffer.ByteBufOutputStream;
 import io.netty.channel.ChannelHandler.Sharable;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.compression.DecompressionException;
-import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.DefaultHttpContent;
-import io.netty.handler.codec.http.DefaultHttpHeaders;
 import io.netty.handler.codec.http.DefaultHttpRequest;
+import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
 import io.netty.util.AttributeKey;
-import org.reactivestreams.Processor;
 import org.reactivestreams.Publisher;
 import org.reactivestreams.Subscriber;
 import org.reactivestreams.Subscription;
@@ -87,13 +90,11 @@ import reactor.core.scheduler.Schedulers;
 
 import javax.net.ssl.SSLException;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.nio.channels.ClosedChannelException;
 import java.util.Collections;
 import java.util.List;
 import java.util.Optional;
 import java.util.concurrent.ExecutorService;
-import java.util.function.BiConsumer;
 import java.util.function.Supplier;
 import java.util.regex.Pattern;
 
@@ -244,9 +245,9 @@ public final class RoutingInBoundHandler implements RequestHandler {
             response = routeExecutor.createDefaultErrorResponse(nettyHttpRequest, throwable);
         }
         if (response != null) {
+            ExecutionFlow<ByteBodyHttpResponse<?>> finalResponse;
             try {
-                encodeHttpResponse(
-                    outboundAccess,
+                finalResponse = encodeHttpResponse(
                     nettyHttpRequest,
                     response,
                     response.body()
@@ -254,27 +255,59 @@ public final class RoutingInBoundHandler implements RequestHandler {
             } catch (Throwable e) {
                 try {
                     response = routeExecutor.createDefaultErrorResponse(nettyHttpRequest, e);
-                    encodeHttpResponse(
-                        outboundAccess,
+                    finalResponse = encodeHttpResponse(
                         nettyHttpRequest,
                         response,
                         response.body()
                     );
                 } catch (Throwable f) {
                     f.addSuppressed(e);
-                    outboundAccess.closeAfterWrite();
+                    finalResponse = ExecutionFlow.error(f);
                     try {
-                        outboundAccess.writeFull(new DefaultFullHttpResponse(
-                            HttpVersion.HTTP_1_1,
-                            HttpResponseStatus.INTERNAL_SERVER_ERROR,
-                            Unpooled.EMPTY_BUFFER
-                        ));
+                        outboundAccess.closeAfterWrite();
+                        outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.INTERNAL_SERVER_ERROR), AvailableNettyByteBody.empty());
                     } catch (Throwable g) {
                         f.addSuppressed(g);
                     }
                     LOG.warn("Failed to encode error response", f);
                 }
             }
+            finalResponse.onComplete((r, t) -> {
+                ByteBodyHttpResponse<?> encodedResponse;
+                if (t != null) {
+                    // fallback of the fallback...
+                    encodedResponse = ByteBodyHttpResponseWrapper.wrap(HttpResponse.serverError(), AvailableNettyByteBody.empty());
+                } else {
+                    encodedResponse = r;
+                }
+                try (encodedResponse) {
+                    closeConnectionIfError(encodedResponse, nettyHttpRequest, outboundAccess);
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Response {} - {} {}",
+                            encodedResponse.code(),
+                            nettyHttpRequest.getMethodName(),
+                            nettyHttpRequest.getUri());
+                    }
+                    io.netty.handler.codec.http.HttpResponse noBodyResponse = NettyMutableHttpResponse.toNoBodyResponse(encodedResponse);
+                    if (nettyHttpRequest.getMethod() == HttpMethod.HEAD) {
+                        outboundAccess.writeHeadResponse(new DefaultHttpResponse(
+                            noBodyResponse.protocolVersion(),
+                            noBodyResponse.status(),
+                            noBodyResponse.headers()
+                        ));
+                    } else {
+                        outboundAccess.write(noBodyResponse, encodedResponse.byteBody());
+                    }
+                } catch (Throwable u) {
+                    if (t != null) {
+                        u.addSuppressed(t);
+                    }
+                    t = u;
+                }
+                if (t != null) {
+                    LOG.warn("Failed to build error response", t);
+                }
+            });
         }
     }
 
@@ -293,8 +326,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
     }
 
     @SuppressWarnings("unchecked")
-    private void encodeHttpResponse(
-        OutboundAccess outboundAccess,
+    private ExecutionFlow<ByteBodyHttpResponse<?>> encodeHttpResponse(
         NettyHttpRequest<?> nettyRequest,
         HttpResponse<?> httpResponse,
         Object body) {
@@ -306,12 +338,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
 
             if (Publishers.isConvertibleToPublisher(body)) {
                 response.body(null);
-                DelegateStreamedHttpResponse streamedResponse = new DelegateStreamedHttpResponse(
-                    toNettyResponse(response),
-                    mapToHttpContent(nettyRequest, response, body, routeInfo, nettyRequest.getChannelHandlerContext())
-                );
-                writeStreamedWithErrorHandling(nettyRequest, outboundAccess, streamedResponse);
-                return;
+                return writeStreamedWithErrorHandling(nettyRequest, response, mapToHttpContent(nettyRequest, response, body, routeInfo, nettyRequest.getChannelHandlerContext()));
             }
 
             // avoid checkcast for MessageBodyWriter interface here
@@ -345,61 +372,46 @@ public final class RoutingInBoundHandler implements RequestHandler {
             }
             if (messageBodyWriter == null || !responseBodyType.isInstance(body) || !messageBodyWriter.isWriteable(responseBodyType, responseMediaType)) {
                 responseBodyType = Argument.ofInstance(body);
-                messageBodyWriter = this.messageBodyHandlerRegistry
-                    .findWriter(responseBodyType, List.of(responseMediaType))
-                    .orElse(null);
-            }
-            NettyBodyWriter<Object> closure = wrap(messageBodyWriter);
-            closeConnectionIfError(response, nettyRequest, outboundAccess);
-            if (closure.isBlocking()) {
-                MediaType finalResponseMediaType = responseMediaType;
-                Argument<Object> finalResponseBodyType = responseBodyType;
-                getIoExecutor().execute(() -> writeNettyMessageBody(nettyRequest, (MutableHttpResponse<Object>) response, finalResponseBodyType, finalResponseMediaType, body, closure, outboundAccess, true));
-            } else {
-                writeNettyMessageBody(nettyRequest, (MutableHttpResponse<Object>) response, responseBodyType, responseMediaType, body, closure, outboundAccess, false);
+                messageBodyWriter = this.messageBodyHandlerRegistry.getWriter(responseBodyType, List.of(responseMediaType));
             }
+            return buildFinalResponse(nettyRequest, (MutableHttpResponse<Object>) response, responseBodyType, responseMediaType, body, messageBodyWriter, false);
         } else {
             response.body(null);
-            writeFinalNettyResponse(
+            return writeFinalNettyResponse(
                 response,
-                nettyRequest,
-                outboundAccess
+                nettyRequest
             );
         }
     }
 
-    private void writeNettyMessageBody(
-        NettyHttpRequest<?> nettyRequest,
-        MutableHttpResponse<Object> response,
-        Argument<Object> responseBodyType,
-        MediaType mediaType,
-        Object body,
-        NettyBodyWriter<Object> nettyMessageBodyWriter,
-        OutboundAccess outboundAccess,
-        boolean onIoExecutor) {
+    private <T> ExecutionFlow<ByteBodyHttpResponse<?>> buildFinalResponse(NettyHttpRequest<?> nettyRequest,
+                                                                          MutableHttpResponse<T> response,
+                                                                          Argument<T> responseBodyType,
+                                                                          MediaType mediaType,
+                                                                          T body,
+                                                                          MessageBodyWriter<T> messageBodyWriter,
+                                                                          boolean onIoExecutor) {
+        if (!onIoExecutor && messageBodyWriter.isBlocking()) {
+            return ExecutionFlow.async(getIoExecutor(), () -> buildFinalResponse(nettyRequest, response, responseBodyType, mediaType, body, messageBodyWriter, true));
+        }
+
+        NettyByteBufferFactory bufferFactory = new NettyByteBufferFactory(nettyRequest.getChannelHandlerContext().alloc());
         try {
-            nettyMessageBodyWriter.writeTo(
-                nettyRequest,
-                response,
-                responseBodyType,
-                mediaType,
-                body, outboundAccess);
+            return ExecutionFlow.just(NettyResponseBodyWriterWrapper.wrap(messageBodyWriter)
+                .write(bufferFactory, nettyRequest, response, responseBodyType, mediaType, body));
         } catch (CodecException e) {
             final MutableHttpResponse<Object> errorResponse = (MutableHttpResponse<Object>) routeExecutor.createDefaultErrorResponse(nettyRequest, e);
-            writeError(nettyRequest, outboundAccess, onIoExecutor, errorResponse);
-        }
-    }
-
-    private void writeError(NettyHttpRequest<?> nettyRequest, OutboundAccess outboundAccess, boolean onIoExecutor, MutableHttpResponse<Object> errorResponse) {
-        Object errorBody = errorResponse.body();
-        Argument<Object> type = Argument.ofInstance(errorBody);
-        MediaType errorContentType = errorResponse.getContentType().orElse(MediaType.APPLICATION_JSON_TYPE);
-        MessageBodyWriter<Object> messageBodyWriter = messageBodyHandlerRegistry.getWriter(type, List.of(errorContentType));
-        NettyBodyWriter<Object> nettyWriter = wrap(messageBodyWriter);
-        if (onIoExecutor || !nettyWriter.isBlocking()) {
-            nettyWriter.writeTo(nettyRequest, errorResponse, type, errorContentType, errorBody, outboundAccess);
-        } else {
-            ioExecutor.execute(() -> nettyWriter.writeTo(nettyRequest, errorResponse, type, errorContentType, errorBody, outboundAccess));
+            Object errorBody = errorResponse.body();
+            Argument<Object> type = Argument.ofInstance(errorBody);
+            MediaType errorContentType = errorResponse.getContentType().orElse(MediaType.APPLICATION_JSON_TYPE);
+            MessageBodyWriter<Object> errorBodyWriter = messageBodyHandlerRegistry.getWriter(type, List.of(errorContentType));
+            if (!onIoExecutor && errorBodyWriter.isBlocking()) {
+                return ExecutionFlow.async(getIoExecutor(), () -> ExecutionFlow.just(NettyResponseBodyWriterWrapper.wrap(errorBodyWriter)
+                    .write(bufferFactory, nettyRequest, errorResponse, type, errorContentType, errorBody)));
+            } else {
+                return ExecutionFlow.just(NettyResponseBodyWriterWrapper.wrap(errorBodyWriter)
+                    .write(bufferFactory, nettyRequest, errorResponse, type, errorContentType, errorBody));
+            }
         }
     }
 
@@ -427,7 +439,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
 
                 if (messageBodyWriter == null || !responseBodyType.isInstance(message) || !messageBodyWriter.isWriteable(responseBodyType, finalMediaType)) {
                     responseBodyType = Argument.ofInstance(message);
-                    messageBodyWriter = messageBodyHandlerRegistry.getWriter(responseBodyType, List.of(finalMediaType));
+                    messageBodyWriter = ResponseBodyWriter.wrap(messageBodyHandlerRegistry.getWriter(responseBodyType, List.of(finalMediaType)));
                 }
                 return writeAsync(
                     messageBodyWriter,
@@ -476,46 +488,22 @@ public final class RoutingInBoundHandler implements RequestHandler {
         }
     }
 
-    private void writeFinalNettyResponse(MutableHttpResponse<?> message, NettyHttpRequest<?> request, OutboundAccess outboundAccess) {
-        // default Connection header if not set explicitly
-        closeConnectionIfError(message, request, outboundAccess);
+    private ExecutionFlow<ByteBodyHttpResponse<?>> writeFinalNettyResponse(MutableHttpResponse<?> message, NettyHttpRequest<?> request) {
         io.netty.handler.codec.http.HttpResponse nettyResponse = NettyHttpResponseBuilder.toHttpResponse(message);
         if (nettyResponse instanceof StreamedHttpResponse streamed) {
-            writeStreamedWithErrorHandling(request, outboundAccess, streamed);
+            return writeStreamedWithErrorHandling(request, message, streamed);
         } else {
-            FullHttpResponse fullResponse = (FullHttpResponse) nettyResponse;
-            outboundAccess.writeFull(fullResponse, request.getMethod() == HttpMethod.HEAD);
+            return ExecutionFlow.just(ByteBodyHttpResponseWrapper.wrap(message, new AvailableNettyByteBody(((FullHttpResponse) nettyResponse).content())));
         }
-
-        log(request, nettyResponse);
-    }
-
-    private void writeFinalFullNettyResponse(MutableHttpResponse<?> message,
-                                             NettyHttpRequest<?> request,
-                                             OutboundAccess outboundAccess,
-                                             ByteBuf byteBuf) {
-        // default Connection header if not set explicitly
-        closeConnectionIfError(message, request, outboundAccess);
-        FullHttpResponse fullResponse = NettyHttpResponseBuilder.toFullHttpResponse(message, byteBuf);
-        outboundAccess.writeFull(fullResponse, request.getMethod() == HttpMethod.HEAD);
-        log(request, fullResponse);
     }
 
-    private void log(HttpRequest<?> request, io.netty.handler.codec.http.HttpResponse nettyResponse) {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Response {} - {} {}",
-                nettyResponse.status().code(),
-                request.getMethodName(),
-                request.getUri());
-        }
-    }
-
-    private void writeStreamedWithErrorHandling(NettyHttpRequest<?> request, OutboundAccess outboundAccess, StreamedHttpResponse streamed) {
-        LazySendingSubscriber sub = new LazySendingSubscriber(request, streamed, outboundAccess);
+    private ExecutionFlow<ByteBodyHttpResponse<?>> writeStreamedWithErrorHandling(NettyHttpRequest<?> request, HttpResponse<?> response, Publisher<HttpContent> streamed) {
+        LazySendingSubscriber sub = new LazySendingSubscriber(request, response);
         streamed.subscribe(sub);
+        return sub.output;
     }
 
-    private void closeConnectionIfError(MutableHttpResponse<?> message, HttpRequest<?> request, OutboundAccess outboundAccess) {
+    private void closeConnectionIfError(HttpResponse<?> message, HttpRequest<?> request, OutboundAccess outboundAccess) {
         boolean decodeError = request instanceof NettyHttpRequest<?> nettyRequest &&
             nettyRequest.getNativeRequest().decoderResult().isFailure();
 
@@ -524,28 +512,6 @@ public final class RoutingInBoundHandler implements RequestHandler {
         }
     }
 
-    @NonNull
-    private io.netty.handler.codec.http.HttpResponse toNettyResponse(HttpResponse<?> message) {
-        if (message instanceof NettyHttpResponseBuilder builder) {
-            return builder.toHttpResponse();
-        } else {
-            return createNettyResponse(message).toHttpResponse();
-        }
-    }
-
-    @NonNull
-    private NettyMutableHttpResponse<?> createNettyResponse(HttpResponse<?> message) {
-        Object body = message.body();
-        io.netty.handler.codec.http.HttpHeaders nettyHeaders = new DefaultHttpHeaders(serverConfiguration.isValidateHeaders());
-        message.getHeaders().forEach((BiConsumer<String, List<String>>) nettyHeaders::set);
-        return new NettyMutableHttpResponse<>(
-            HttpVersion.HTTP_1_1,
-            HttpResponseStatus.valueOf(message.code(), message.reason()),
-            body instanceof ByteBuf ? body : null,
-            conversionService
-        );
-    }
-
     /**
      * Is the exception ignorable by Micronaut.
      *
@@ -560,85 +526,33 @@ public final class RoutingInBoundHandler implements RequestHandler {
         return cause instanceof IOException && message != null && IGNORABLE_ERROR_MESSAGE.matcher(message).matches();
     }
 
-    <T> NettyBodyWriter<T> wrap(MessageBodyWriter<T> closure) {
-        if (closure instanceof NettyJsonHandler<T> nettyClosure) {
-            // also covered by the next if, but this is slightly faster than an interface check
-            return nettyClosure;
-        } else if (closure instanceof NettyBodyWriter<T> nettyClosure) {
-            return nettyClosure;
-        } else {
-            return new CompatNettyWriteClosure<>(closure);
-        }
-    }
-
-    private final class CompatNettyWriteClosure<T> implements NettyBodyWriter<T> {
-        private final MessageBodyWriter<T> delegate;
-
-        CompatNettyWriteClosure(MessageBodyWriter<T> delegate) {
-            assert !(delegate instanceof NettyBodyWriter) : "please create using wrap()";
-            this.delegate = delegate;
-        }
-
-        @Override
-        public boolean isBlocking() {
-            return delegate.isBlocking();
-        }
-
-        @Override
-        public void writeTo(HttpRequest<?> request, MutableHttpResponse<T> outgoingResponse, Argument<T> type, MediaType mediaType, T object, NettyWriteContext nettyContext) throws CodecException {
-            NettyByteBufferFactory bufferFactory = new NettyByteBufferFactory(nettyContext.alloc());
-            ByteBuffer<?> byteBuffer = delegate.writeTo(
-                type,
-                mediaType,
-                object,
-                outgoingResponse.getHeaders(),
-                bufferFactory);
-            ByteBuf buffer = (ByteBuf) byteBuffer.asNativeBuffer();
-            writeFinalFullNettyResponse(outgoingResponse,
-                (NettyHttpRequest<?>) request,
-                (OutboundAccess) nettyContext,
-                buffer);
-        }
-
-        @Override
-        public void writeTo(Argument<T> type, MediaType mediaType, T object, MutableHeaders outgoingHeaders, OutputStream outputStream) throws CodecException {
-            delegate.writeTo(type, mediaType, object, outgoingHeaders, outputStream);
-        }
-
-        @Override
-        public ByteBuffer<?> writeTo(Argument<T> type, MediaType mediaType, T object, MutableHeaders outgoingHeaders, ByteBufferFactory<?, ?> bufferFactory) throws CodecException {
-            return delegate.writeTo(type, mediaType, object, outgoingHeaders, bufferFactory);
-        }
-    }
-
     /**
      * This processor waits for the first item before sending the response, and handles errors if they
      * appear as the first item.
      */
-    private final class LazySendingSubscriber implements Processor<HttpContent, HttpContent> {
+    private final class LazySendingSubscriber implements Subscriber<HttpContent>, Publisher<ByteBuf> {
         private static final Object COMPLETE = new Object();
 
         boolean headersSent = false;
         Subscription upstream;
-        final DelayedSubscriber<HttpContent> downstream = new DelayedSubscriber<>();
+        final DelayedSubscriber<ByteBuf> downstream = new DelayedSubscriber<>();
         @Nullable
         HttpContent first;
         Object completion = null; // in case first hasn't been consumed we need to delay completion
 
         private final EventLoopFlow flow;
         private final NettyHttpRequest<?> request;
-        private final io.netty.handler.codec.http.HttpResponse headers;
-        private final OutboundAccess outboundAccess;
+        private final HttpResponse<?> headers;
+        private final DelayedExecutionFlow<ByteBodyHttpResponse<?>> output = DelayedExecutionFlow.create();
 
-        private LazySendingSubscriber(NettyHttpRequest<?> request, io.netty.handler.codec.http.HttpResponse headers, OutboundAccess outboundAccess) {
+        private LazySendingSubscriber(NettyHttpRequest<?> request, HttpResponse<?> headers) {
             this.request = request;
             this.headers = headers;
-            this.outboundAccess = outboundAccess;
             this.flow = new EventLoopFlow(request.getChannelHandlerContext().channel().eventLoop());
         }
 
         @Override
-        public void subscribe(Subscriber<? super HttpContent> s) {
+        public void subscribe(Subscriber<? super ByteBuf> s) {
             downstream.onSubscribe(new Subscription() {
                 @Override
                 public void request(long n) {
@@ -646,7 +560,7 @@ public final class RoutingInBoundHandler implements RequestHandler {
                     if (first != null) {
                         LazySendingSubscriber.this.first = null;
                         // onNext may trigger further request calls
-                        s.onNext(first);
+                        s.onNext(first.content());
                         if (completion != null) {
                             if (completion == COMPLETE) {
                                 s.onComplete();
@@ -692,11 +606,11 @@ public final class RoutingInBoundHandler implements RequestHandler {
 
         private void onNext0(HttpContent httpContent) {
             if (headersSent) {
-                downstream.onNext(httpContent);
+                downstream.onNext(httpContent.content());
             } else {
                 first = httpContent;
                 headersSent = true;
-                outboundAccess.writeStreamed(headers, this);
+                output.complete(ByteBodyHttpResponseWrapper.wrap(headers, NettyBodyAdapter.adapt(this, request.getChannelHandlerContext().channel().eventLoop())));
             }
         }
 
@@ -728,12 +642,11 @@ public final class RoutingInBoundHandler implements RequestHandler {
                 } else {
                     response = routeExecutor.createDefaultErrorResponse(request, t);
                 }
-                encodeHttpResponse(
-                    outboundAccess,
+                output.completeFrom(encodeHttpResponse(
                     request,
                     response,
                     response.body()
-                );
+                ));
             }
         }
 
@@ -753,7 +666,43 @@ public final class RoutingInBoundHandler implements RequestHandler {
                 }
             } else {
                 headersSent = true;
-                outboundAccess.writeStreamed(headers, Flux.empty());
+                output.complete(ByteBodyHttpResponseWrapper.wrap(headers, AvailableNettyByteBody.empty()));
+            }
+        }
+    }
+
+    /**
+     * Replacement for {@link ResponseBodyWriterWrapper} that uses a netty {@link ByteBuf} instead
+     * of a byte array as the backing store.
+     *
+     * @param <T> Body type
+     */
+    private static final class NettyResponseBodyWriterWrapper<T> extends ResponseBodyWriterWrapper<T> {
+        private NettyResponseBodyWriterWrapper(MessageBodyWriter<T> wrapped) {
+            super(wrapped);
+        }
+
+        static <T> ResponseBodyWriter<T> wrap(MessageBodyWriter<T> mbw) {
+            if (mbw instanceof ResponseBodyWriter<T> rbw) {
+                return rbw;
+            } else {
+                return new NettyResponseBodyWriterWrapper<>(mbw);
+            }
+        }
+
+        @Override
+        public @NonNull ByteBodyHttpResponse<?> write(@NonNull ByteBufferFactory<?, ?> bufferFactory, @NonNull HttpRequest<?> request, @NonNull MutableHttpResponse<T> httpResponse, @NonNull Argument<T> type, @NonNull MediaType mediaType, T object) throws CodecException {
+            ByteBuf buf = ((NettyByteBufferFactory) bufferFactory).buffer().asNativeBuffer();
+            ByteBufOutputStream bbos = new ByteBufOutputStream(buf);
+            boolean release = true;
+            try {
+                writeTo(type, mediaType, object, httpResponse.getHeaders(), bbos);
+                release = false;
+                return ByteBodyHttpResponseWrapper.wrap(httpResponse, new AvailableNettyByteBody(buf));
+            } finally {
+                if (release) {
+                    buf.release();
+                }
             }
         }
     }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyBodyAnnotationBinder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyBodyAnnotationBinder.java
index b54d7b7ca8..a5b8220202 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyBodyAnnotationBinder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/binders/NettyBodyAnnotationBinder.java
@@ -43,7 +43,7 @@ import io.micronaut.http.server.netty.FormDataHttpContentProcessor;
 import io.micronaut.http.server.netty.FormRouteCompleter;
 import io.micronaut.http.server.netty.MicronautHttpData;
 import io.micronaut.http.server.netty.NettyHttpRequest;
-import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.netty.body.AvailableNettyByteBody;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.netty.converters.NettyConverters;
 import io.micronaut.web.router.RouteInfo;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AbstractFileBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AbstractFileBodyWriter.java
index cd7f3ccb82..389e5d2398 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AbstractFileBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/AbstractFileBodyWriter.java
@@ -17,15 +17,16 @@ package io.micronaut.http.server.netty.body;
 
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpResponse;
 import io.micronaut.http.MutableHttpHeaders;
 import io.micronaut.http.MutableHttpResponse;
-import io.micronaut.http.netty.NettyMutableHttpResponse;
+import io.micronaut.http.netty.body.AvailableNettyByteBody;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.types.files.FileCustomizableResponseType;
-import io.netty.handler.codec.http.FullHttpResponse;
 
 import java.time.LocalDateTime;
 import java.time.ZonedDateTime;
@@ -53,7 +54,7 @@ abstract sealed class AbstractFileBodyWriter permits InputStreamBodyWriter, Stre
         });
     }
 
-    protected boolean handleIfModifiedAndHeaders(HttpRequest<?> request, MutableHttpResponse<?> response, FileCustomizableResponseType systemFile, NettyMutableHttpResponse<?> nettyResponse) {
+    protected boolean handleIfModifiedAndHeaders(HttpRequest<?> request, MutableHttpResponse<?> response, FileCustomizableResponseType systemFile, MutableHttpResponse<?> nettyResponse) {
         long lastModified = systemFile.getLastModified();
 
         // Cache Validation
@@ -117,10 +118,10 @@ abstract sealed class AbstractFileBodyWriter permits InputStreamBodyWriter, Stre
         headers.date(now);
     }
 
-    protected FullHttpResponse notModified(MutableHttpResponse<?> originalResponse) {
-        MutableHttpResponse response = HttpResponse.notModified();
+    protected ByteBodyHttpResponse<?> notModified(MutableHttpResponse<?> originalResponse) {
+        MutableHttpResponse<Void> response = HttpResponse.notModified();
         AbstractFileBodyWriter.copyNonEntityHeaders(originalResponse, response);
         setDateHeader(response);
-        return ((NettyMutableHttpResponse) response).toFullHttpResponse();
+        return ByteBodyHttpResponseWrapper.wrap(response, AvailableNettyByteBody.empty());
     }
 }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/FileBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/FileBodyWriter.java
index 24f9ddfc16..fe2e7151dd 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/FileBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/FileBodyWriter.java
@@ -17,14 +17,15 @@ package io.micronaut.http.server.netty.body;
 
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.ByteBodyHttpResponse;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
+import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.codec.CodecException;
-import io.micronaut.http.netty.body.NettyBodyWriter;
-import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.server.types.files.SystemFile;
 import jakarta.inject.Singleton;
 
@@ -40,7 +41,7 @@ import java.io.OutputStream;
 @Internal
 @Experimental
 @Singleton
-public final class FileBodyWriter implements NettyBodyWriter<File> {
+public final class FileBodyWriter implements ResponseBodyWriter<File> {
     private final SystemFileBodyWriter systemFileBodyWriter;
 
     public FileBodyWriter(SystemFileBodyWriter systemFileBodyWriter) {
@@ -48,15 +49,10 @@ public final class FileBodyWriter implements NettyBodyWriter<File> {
     }
 
     @Override
-    public void writeTo(HttpRequest<?> request, MutableHttpResponse<File> outgoingResponse, Argument<File> type, MediaType mediaType, File object, NettyWriteContext nettyContext) throws CodecException {
+    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<File> outgoingResponse, Argument<File> type, MediaType mediaType, File object) throws CodecException {
         SystemFile systemFile = new SystemFile(object);
         MutableHttpResponse<SystemFile> newResponse = outgoingResponse.body(systemFile);
-        systemFileBodyWriter.writeTo(
-            request,
-            newResponse,
-            systemFile,
-            nettyContext
-        );
+        return systemFileBodyWriter.write(request, newResponse, systemFile);
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/InputStreamBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/InputStreamBodyWriter.java
index 04789a8456..9caa5ce87e 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/InputStreamBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/InputStreamBodyWriter.java
@@ -18,19 +18,20 @@ package io.micronaut.http.server.netty.body;
 import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
+import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.body.stream.InputStreamByteBody;
 import io.micronaut.http.codec.CodecException;
-import io.micronaut.http.netty.NettyMutableHttpResponse;
-import io.micronaut.http.netty.body.NettyBodyWriter;
-import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.scheduling.TaskExecutors;
-import io.netty.handler.codec.http.DefaultHttpResponse;
+import io.netty.handler.codec.http.HttpHeaderNames;
 import jakarta.inject.Named;
 import jakarta.inject.Singleton;
 
@@ -48,7 +49,7 @@ import java.util.concurrent.ExecutorService;
 @Internal
 @Experimental
 @Singleton
-public final class InputStreamBodyWriter extends AbstractFileBodyWriter implements NettyBodyWriter<InputStream> {
+public final class InputStreamBodyWriter extends AbstractFileBodyWriter implements ResponseBodyWriter<InputStream> {
     private final ExecutorService executorService;
 
     InputStreamBodyWriter(NettyHttpServerConfiguration.FileTypeHandlerConfiguration configuration, @Named(TaskExecutors.BLOCKING) ExecutorService executorService) {
@@ -57,18 +58,9 @@ public final class InputStreamBodyWriter extends AbstractFileBodyWriter implemen
     }
 
     @Override
-    public void writeTo(HttpRequest<?> request, MutableHttpResponse<InputStream> outgoingResponse, Argument<InputStream> type, MediaType mediaType, InputStream object, NettyWriteContext nettyContext) throws CodecException {
-        if (outgoingResponse instanceof NettyMutableHttpResponse<?> nettyResponse) {
-            final DefaultHttpResponse finalResponse = new DefaultHttpResponse(
-                nettyResponse.getNettyHttpVersion(),
-                nettyResponse.getNettyHttpStatus(),
-                nettyResponse.getNettyHeaders()
-            );
-            //  can be null if the stream was closed
-            nettyContext.write(finalResponse, InputStreamByteBody.create(object, OptionalLong.empty(), executorService, NettyByteBufferFactory.DEFAULT));
-        } else {
-            throw new IllegalArgumentException("Unsupported response type. Not a Netty response: " + outgoingResponse);
-        }
+    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<InputStream> outgoingResponse, Argument<InputStream> type, MediaType mediaType, InputStream object) throws CodecException {
+        outgoingResponse.getHeaders().setIfMissing(HttpHeaderNames.CONTENT_TYPE, mediaType);
+        return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, InputStreamByteBody.create(object, OptionalLong.empty(), executorService, NettyByteBufferFactory.DEFAULT));
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyBodyAdapter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyBodyAdapter.java
index 05a5d85ff2..377c760893 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyBodyAdapter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/NettyBodyAdapter.java
@@ -20,6 +20,11 @@ import io.micronaut.core.annotation.NonNull;
 import io.micronaut.http.body.AvailableByteBody;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.netty.EventLoopFlow;
+import io.micronaut.http.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.netty.body.BodySizeLimits;
+import io.micronaut.http.netty.body.BufferConsumer;
+import io.micronaut.http.netty.body.NettyByteBody;
+import io.micronaut.http.netty.body.StreamingNettyByteBody;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.EventLoop;
@@ -115,10 +120,10 @@ public final class NettyBodyAdapter implements BufferConsumer.Upstream, Subscrib
     @Override
     public void onSubscribe(Subscription s) {
         this.subscription = s;
-        long demand = this.demand.get();
-        s.request(demand);
         if (cancelled) {
             s.cancel();
+        } else {
+            s.request(1);
         }
     }
 
@@ -130,8 +135,11 @@ public final class NettyBodyAdapter implements BufferConsumer.Upstream, Subscrib
     }
 
     private void onNext0(ByteBuf bytes) {
-        demand.addAndGet(-bytes.readableBytes());
+        long newDemand = demand.addAndGet(-bytes.readableBytes());
         sharedBuffer.add(bytes);
+        if (newDemand > 0) {
+            subscription.request(1);
+        }
     }
 
     @Override
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamFileBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamFileBodyWriter.java
index 344d965ec2..417d9ed0b5 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamFileBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/StreamFileBodyWriter.java
@@ -18,23 +18,20 @@ package io.micronaut.http.server.netty.body;
 import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
+import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.body.stream.InputStreamByteBody;
 import io.micronaut.http.codec.CodecException;
-import io.micronaut.http.netty.NettyMutableHttpResponse;
-import io.micronaut.http.netty.body.NettyBodyWriter;
-import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.types.files.StreamedFile;
 import io.micronaut.scheduling.TaskExecutors;
-import io.netty.handler.codec.http.DefaultHttpResponse;
-import io.netty.handler.codec.http.HttpHeaderNames;
-import io.netty.handler.codec.http.HttpHeaderValues;
-import io.netty.handler.codec.http.HttpHeaders;
 import jakarta.inject.Named;
 import jakarta.inject.Singleton;
 
@@ -52,7 +49,7 @@ import java.util.concurrent.ExecutorService;
 @Singleton
 @Experimental
 @Internal
-public final class StreamFileBodyWriter extends AbstractFileBodyWriter implements NettyBodyWriter<StreamedFile> {
+public final class StreamFileBodyWriter extends AbstractFileBodyWriter implements ResponseBodyWriter<StreamedFile> {
     private final ExecutorService ioExecutor;
 
     StreamFileBodyWriter(NettyHttpServerConfiguration.FileTypeHandlerConfiguration configuration, @Named(TaskExecutors.BLOCKING) ExecutorService ioExecutor) {
@@ -61,29 +58,13 @@ public final class StreamFileBodyWriter extends AbstractFileBodyWriter implement
     }
 
     @Override
-    public void writeTo(HttpRequest<?> request, MutableHttpResponse<StreamedFile> outgoingResponse, Argument<StreamedFile> type, MediaType mediaType, StreamedFile object, NettyWriteContext nettyContext) throws CodecException {
-        if (outgoingResponse instanceof NettyMutableHttpResponse<?> nettyResponse) {
-            if (handleIfModifiedAndHeaders(request, outgoingResponse, object, nettyResponse)) {
-                nettyContext.writeFull(notModified(outgoingResponse));
-            } else {
-                HttpHeaders nettyHeaders = nettyResponse.getNettyHeaders();
-                long length = object.getLength();
-                if (length > -1) {
-                    nettyHeaders.set(HttpHeaderNames.CONTENT_LENGTH, length);
-                } else {
-                    nettyHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
-                }
-                final DefaultHttpResponse finalResponse = new DefaultHttpResponse(
-                    nettyResponse.getNettyHttpVersion(),
-                    nettyResponse.getNettyHttpStatus(),
-                    nettyHeaders
-                );
-                InputStream inputStream = object.getInputStream();
-                nettyContext.write(finalResponse, InputStreamByteBody.create(inputStream, OptionalLong.empty(), ioExecutor, NettyByteBufferFactory.DEFAULT));
-            }
-
+    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, MutableHttpResponse<StreamedFile> outgoingResponse, Argument<StreamedFile> type, MediaType mediaType, StreamedFile object) throws CodecException {
+        if (handleIfModifiedAndHeaders(request, outgoingResponse, object, outgoingResponse)) {
+            return notModified(outgoingResponse);
         } else {
-            throw new IllegalArgumentException("Unsupported response type. Not a Netty response: " + outgoingResponse);
+            long length = object.getLength();
+            InputStream inputStream = object.getInputStream();
+            return ByteBodyHttpResponseWrapper.wrap(outgoingResponse, InputStreamByteBody.create(inputStream, length > -1 ? OptionalLong.of(length) : OptionalLong.empty(), ioExecutor, NettyByteBufferFactory.DEFAULT));
         }
     }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/SystemFileBodyWriter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/SystemFileBodyWriter.java
index e71a5c6649..419201b096 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/SystemFileBodyWriter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/body/SystemFileBodyWriter.java
@@ -20,24 +20,24 @@ import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.io.buffer.ByteBufferFactory;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.ByteBodyHttpResponseWrapper;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpMethod;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.MutableHttpResponse;
+import io.micronaut.http.body.ResponseBodyWriter;
 import io.micronaut.http.body.stream.InputStreamByteBody;
 import io.micronaut.http.codec.CodecException;
 import io.micronaut.http.exceptions.MessageBodyException;
-import io.micronaut.http.netty.NettyMutableHttpResponse;
-import io.micronaut.http.netty.body.NettyBodyWriter;
-import io.micronaut.http.netty.body.NettyWriteContext;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.http.server.types.files.SystemFile;
 import io.micronaut.scheduling.TaskExecutors;
-import io.netty.handler.codec.http.DefaultHttpResponse;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import jakarta.inject.Named;
@@ -64,7 +64,7 @@ import static io.micronaut.http.HttpHeaders.CONTENT_RANGE;
 @Singleton
 @Experimental
 @Internal
-public final class SystemFileBodyWriter extends AbstractFileBodyWriter implements NettyBodyWriter<SystemFile> {
+public final class SystemFileBodyWriter extends AbstractFileBodyWriter implements ResponseBodyWriter<SystemFile> {
     private static final String UNIT_BYTES = "bytes";
 
     private final ExecutorService ioExecutor;
@@ -75,71 +75,64 @@ public final class SystemFileBodyWriter extends AbstractFileBodyWriter implement
     }
 
     @Override
-    public void writeTo(HttpRequest<?> request, MutableHttpResponse<SystemFile> outgoingResponse, Argument<SystemFile> type, MediaType mediaType, SystemFile object, NettyWriteContext nettyContext) throws CodecException {
-        writeTo(request, outgoingResponse, object, nettyContext);
+    public void writeTo(Argument<SystemFile> type, MediaType mediaType, SystemFile file, MutableHeaders outgoingHeaders, OutputStream outputStream) throws CodecException {
+        throw new UnsupportedOperationException("Can only be used in a Netty context");
     }
 
     @Override
-    public void writeTo(Argument<SystemFile> type, MediaType mediaType, SystemFile file, MutableHeaders outgoingHeaders, OutputStream outputStream) throws CodecException {
-        throw new UnsupportedOperationException("Can only be used in a Netty context");
+    public ByteBodyHttpResponse<?> write(ByteBufferFactory<?, ?> bufferFactory, HttpRequest<?> request, @NonNull MutableHttpResponse<SystemFile> httpResponse, @NonNull Argument<SystemFile> type, @NonNull MediaType mediaType, SystemFile object) throws CodecException {
+        return write(request, httpResponse, object);
     }
 
-    public void writeTo(HttpRequest<?> request, MutableHttpResponse<SystemFile> response, SystemFile systemFile, NettyWriteContext nettyContext) throws CodecException {
-        if (response instanceof NettyMutableHttpResponse<?> nettyResponse) {
-            if (!systemFile.getFile().canRead()) {
-                throw new MessageBodyException("Could not find file");
-            }
-            if (handleIfModifiedAndHeaders(request, response, systemFile, nettyResponse)) {
-                nettyContext.writeFull(notModified(response));
-            } else {
+    public ByteBodyHttpResponse<?> write(HttpRequest<?> request, MutableHttpResponse<SystemFile> response, SystemFile systemFile) throws CodecException {
+        if (!systemFile.getFile().canRead()) {
+            throw new MessageBodyException("Could not find file");
+        }
+        if (handleIfModifiedAndHeaders(request, response, systemFile, response)) {
+            return notModified(response);
+        } else {
 
-                // Parse the range headers (if any), and determine the position and content length
-                // Only `bytes` ranges are supported. Only single ranges are supported. Invalid ranges fall back to returning the full response.
-                // See https://httpwg.org/specs/rfc9110.html#field.range
-                long fileLength = systemFile.getLength();
-                long position = 0;
-                long contentLength = fileLength;
-                if (fileLength > -1) {
-                    String rangeHeader = request.getHeaders().get(HttpHeaders.RANGE);
-                    if (rangeHeader != null
-                        && request.getMethod() == HttpMethod.GET // A server MUST ignore a Range header field received with a request method that is unrecognized or for which range handling is not defined.
-                        && rangeHeader.startsWith(UNIT_BYTES) // An origin server MUST ignore a Range header field that contains a range unit it does not understand.
-                        && response.status() == HttpStatus.OK // The Range header field is evaluated after evaluating the precondition header fields defined in Section 13.1, and only if the result in absence of the Range header field would be a 200 (OK) response.
+            // Parse the range headers (if any), and determine the position and content length
+            // Only `bytes` ranges are supported. Only single ranges are supported. Invalid ranges fall back to returning the full response.
+            // See https://httpwg.org/specs/rfc9110.html#field.range
+            long fileLength = systemFile.getLength();
+            long position = 0;
+            long contentLength = fileLength;
+            if (fileLength > -1) {
+                String rangeHeader = request.getHeaders().get(HttpHeaders.RANGE);
+                if (rangeHeader != null
+                    && request.getMethod() == HttpMethod.GET // A server MUST ignore a Range header field received with a request method that is unrecognized or for which range handling is not defined.
+                    && rangeHeader.startsWith(UNIT_BYTES) // An origin server MUST ignore a Range header field that contains a range unit it does not understand.
+                    && response.status() == HttpStatus.OK // The Range header field is evaluated after evaluating the precondition header fields defined in Section 13.1, and only if the result in absence of the Range header field would be a 200 (OK) response.
+                ) {
+                    IntRange range = parseRangeHeader(rangeHeader, fileLength);
+                    if (range != null // A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1)
+                        && range.firstPos < range.lastPos // A server that supports range requests MAY ignore a Range header field when the selected representation has no content (i.e., the selected representation's data is of zero length).
+                        && range.firstPos < fileLength
+                        && range.lastPos < fileLength
                     ) {
-                        IntRange range = parseRangeHeader(rangeHeader, fileLength);
-                        if (range != null // A server that supports range requests MAY ignore or reject a Range header field that contains an invalid ranges-specifier (Section 14.1.1)
-                            && range.firstPos < range.lastPos // A server that supports range requests MAY ignore a Range header field when the selected representation has no content (i.e., the selected representation's data is of zero length).
-                            && range.firstPos < fileLength
-                            && range.lastPos < fileLength
-                        ) {
-                            position = range.firstPos;
-                            contentLength = range.lastPos + 1 - range.firstPos;
-                            response.status(HttpStatus.PARTIAL_CONTENT);
-                            response.header(CONTENT_RANGE, "%s %d-%d/%d".formatted(UNIT_BYTES, range.firstPos, range.lastPos, fileLength));
-                        }
+                        position = range.firstPos;
+                        contentLength = range.lastPos + 1 - range.firstPos;
+                        response.status(HttpStatus.PARTIAL_CONTENT);
+                        response.header(CONTENT_RANGE, "%s %d-%d/%d".formatted(UNIT_BYTES, range.firstPos, range.lastPos, fileLength));
                     }
-                    response.header(HttpHeaders.ACCEPT_RANGES, UNIT_BYTES);
-                    response.header(HttpHeaders.CONTENT_LENGTH, Long.toString(contentLength));
-                } else {
-                    response.header(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
-                }
-
-                // Write the request data
-                final DefaultHttpResponse finalResponse = new DefaultHttpResponse(nettyResponse.getNettyHttpVersion(), nettyResponse.getNettyHttpStatus(), nettyResponse.getNettyHeaders());
-
-                File file = systemFile.getFile();
-                InputStream is;
-                try {
-                    is = new FileInputStream(file);
-                } catch (FileNotFoundException e) {
-                    throw new MessageBodyException("Could not find file", e);
                 }
+                response.header(HttpHeaders.ACCEPT_RANGES, UNIT_BYTES);
+                response.header(HttpHeaders.CONTENT_LENGTH, Long.toString(contentLength));
+            } else {
+                response.header(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);
+            }
 
-                @NonNull InputStream stream = new RangeInputStream(is, position, contentLength);
-                nettyContext.write(finalResponse, InputStreamByteBody.create(stream, OptionalLong.of(contentLength), ioExecutor, NettyByteBufferFactory.DEFAULT));
+            File file = systemFile.getFile();
+            InputStream is;
+            try {
+                is = new FileInputStream(file);
+            } catch (FileNotFoundException e) {
+                throw new MessageBodyException("Could not find file", e);
             }
-        } else {
-            throw new IllegalArgumentException("Unsupported response type. Not a Netty response: " + response);
+
+            @NonNull InputStream stream = new RangeInputStream(is, position, contentLength);
+            return ByteBodyHttpResponseWrapper.wrap(response, InputStreamByteBody.create(stream, OptionalLong.of(contentLength), ioExecutor, NettyByteBufferFactory.DEFAULT));
         }
     }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java
index 637dfc74b0..307c514c06 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/converters/NettyConverters.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.converters;
 
+import io.micronaut.buffer.netty.NettyByteBufferFactory;
 import io.micronaut.context.BeanProvider;
 import io.micronaut.context.annotation.Prototype;
 import io.micronaut.core.annotation.Internal;
@@ -23,12 +24,16 @@ import io.micronaut.core.convert.ConversionService;
 import io.micronaut.core.convert.MutableConversionService;
 import io.micronaut.core.convert.TypeConverterRegistrar;
 import io.micronaut.core.naming.NameUtils;
+import io.micronaut.core.type.Argument;
 import io.micronaut.core.util.StringUtils;
 import io.micronaut.http.MediaType;
+import io.micronaut.http.body.MessageBodyHandlerRegistry;
+import io.micronaut.http.body.MessageBodyReader;
 import io.micronaut.http.codec.MediaTypeCodec;
 import io.micronaut.http.codec.MediaTypeCodecRegistry;
 import io.micronaut.http.netty.channel.converters.ChannelOptionFactory;
 import io.micronaut.http.server.netty.multipart.NettyPartData;
+import io.micronaut.http.simple.SimpleHttpHeaders;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufInputStream;
 import io.netty.channel.ChannelOption;
@@ -54,21 +59,25 @@ public final class NettyConverters implements TypeConverterRegistrar {
 
     private final ConversionService conversionService;
     private final BeanProvider<MediaTypeCodecRegistry> decoderRegistryProvider;
+    private final BeanProvider<MessageBodyHandlerRegistry> messageBodyHandlerRegistries;
     private final BeanProvider<ChannelOptionFactory> channelOptionFactory;
 
     /**
      * Default constructor.
      *
-     * @param conversionService       The conversion service
-     * @param decoderRegistryProvider The decoder registry provider
-     * @param channelOptionFactory    The decoder channel option factory
+     * @param conversionService            The conversion service
+     * @param decoderRegistryProvider      The decoder registry provider
+     * @param messageBodyHandlerRegistries The message body handlers
+     * @param channelOptionFactory         The decoder channel option factory
      */
     public NettyConverters(ConversionService conversionService,
                            //Prevent early initialization of the codecs
                            BeanProvider<MediaTypeCodecRegistry> decoderRegistryProvider,
+                           BeanProvider<MessageBodyHandlerRegistry> messageBodyHandlerRegistries,
                            BeanProvider<ChannelOptionFactory> channelOptionFactory) {
         this.conversionService = conversionService;
         this.decoderRegistryProvider = decoderRegistryProvider;
+        this.messageBodyHandlerRegistries = messageBodyHandlerRegistries;
         this.channelOptionFactory = channelOptionFactory;
     }
 
@@ -98,20 +107,23 @@ public final class NettyConverters implements TypeConverterRegistrar {
                         if (!object.isCompleted()) {
                             return Optional.empty();
                         }
+                        Argument<Object> argument = context instanceof ArgumentConversionContext<?> argumentConversionContext ? (Argument<Object>) argumentConversionContext.getArgument() : Argument.of(targetType);
                         String contentType = object.getContentType();
                         ByteBuf byteBuf = object.getByteBuf();
-                        if (StringUtils.isNotEmpty(contentType)) {
-                            MediaType mediaType = MediaType.of(contentType);
-                            Optional<MediaTypeCodec> registered = decoderRegistryProvider.get().findCodec(mediaType);
-                            if (registered.isPresent()) {
-                                MediaTypeCodec decoder = registered.get();
-                                Object val = decoder.decode(targetType, new ByteBufInputStream(byteBuf));
-                                return Optional.of(val);
-                            } else {
-                                return this.conversionService.convert(byteBuf, targetType, context);
-                            }
+                        MediaType mediaType = StringUtils.isEmpty(contentType) ? null : MediaType.of(contentType);
+                        MediaTypeCodec codec = decoderRegistryProvider.get().findCodec(mediaType).orElse(null);
+                        if (codec != null) {
+                            return Optional.of(
+                                codec.decode(argument, new ByteBufInputStream(byteBuf))
+                            );
+                        }
+                        MessageBodyReader<Object> messageBodyReader = messageBodyHandlerRegistries.get().findReader(argument, mediaType).orElse(null);
+                        if (messageBodyReader != null) {
+                            return Optional.of(
+                                messageBodyReader.read(argument, mediaType, new SimpleHttpHeaders(), NettyByteBufferFactory.DEFAULT.wrap(byteBuf))
+                            );
                         }
-                        return this.conversionService.convert(byteBuf, targetType, context);
+                        return conversionService.convert(byteBuf, targetType, context);
                     } catch (Exception e) {
                         context.reject(e);
                         return Optional.empty();
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java
index aa46f95d16..dd5a88ca2a 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Compressor.java
@@ -36,7 +36,6 @@ import io.netty.handler.codec.compression.ZlibWrapper;
 import io.netty.handler.codec.compression.Zstd;
 import io.netty.handler.codec.compression.ZstdEncoder;
 import io.netty.handler.codec.compression.ZstdOptions;
-import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpHeaderValues;
 import io.netty.handler.codec.http.HttpMethod;
@@ -79,10 +78,6 @@ final class Compressor {
             response.protocolVersion() == HttpVersion.HTTP_1_0) {
             return null;
         }
-        // special case for FHR to keep behavior identical to HttpContentEncoder
-        if (response instanceof FullHttpResponse fhr && !fhr.content().isReadable()) {
-            return null;
-        }
         if (!strategy.shouldCompress(response)) {
             return null;
         }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
index 6e8bf0a49a..0407456e08 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
@@ -19,7 +19,7 @@ import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.server.netty.HttpCompressionStrategy;
-import io.micronaut.http.server.netty.body.BodySizeLimits;
+import io.micronaut.http.netty.body.BodySizeLimits;
 import io.micronaut.http.server.netty.handler.accesslog.Http2AccessLogConnectionEncoder;
 import io.micronaut.http.server.netty.handler.accesslog.Http2AccessLogFrameListener;
 import io.micronaut.http.server.netty.handler.accesslog.Http2AccessLogManager;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
index 34adb5b5fb..9258be86a7 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
@@ -20,37 +20,31 @@ import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.netty.EventLoopFlow;
+import io.micronaut.http.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.netty.body.BodySizeLimits;
+import io.micronaut.http.netty.body.BufferConsumer;
+import io.micronaut.http.netty.body.NettyByteBody;
+import io.micronaut.http.netty.body.StreamingNettyByteBody;
 import io.micronaut.http.netty.reactive.HotObservable;
-import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
-import io.micronaut.http.server.netty.body.BodySizeLimits;
-import io.micronaut.http.server.netty.body.BufferConsumer;
 import io.micronaut.http.server.netty.body.NettyBodyAdapter;
-import io.micronaut.http.server.netty.body.NettyByteBody;
-import io.micronaut.http.server.netty.body.StreamingNettyByteBody;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.CompositeByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoop;
-import io.netty.handler.codec.http.DefaultFullHttpResponse;
-import io.netty.handler.codec.http.EmptyHttpHeaders;
-import io.netty.handler.codec.http.FullHttpResponse;
-import io.netty.handler.codec.http.HttpContent;
 import io.netty.handler.codec.http.HttpHeaderNames;
 import io.netty.handler.codec.http.HttpRequest;
 import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpUtil;
 import io.netty.handler.codec.http2.Http2Exception;
-import org.reactivestreams.Publisher;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import reactor.core.publisher.Flux;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.OptionalLong;
 
 /**
  * Common handler implementation for multiplexed HTTP versions (HTTP/2 and HTTP/3).
@@ -240,30 +234,30 @@ abstract class MultiplexedServerHandler {
             return true;
         }
 
-        @Override
-        public final @NonNull ByteBufAllocator alloc() {
-            return ctx.alloc();
-        }
-
         @Override
         public void write(@NonNull HttpResponse response, @NonNull ByteBody body) {
             if (responseDone) {
                 // early check
                 throw new IllegalStateException("Response already written");
             }
-            if (!ctx.executor().inEventLoop()) {
-                ctx.executor().execute(() -> write(response, body));
-                return;
+
+            // we do some preparation immediately on the calling thread, so that the ByteBody
+            // primary operation happens here.
+
+            response.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);
+            if (PipeliningServerHandler.canHaveBody(response.status())) {
+                OptionalLong length = body.expectedLength();
+                if (length.isPresent()) {
+                    response.headers().set(HttpHeaderNames.CONTENT_LENGTH, length.getAsLong());
+                }
+            } else {
+                response.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
             }
 
             NettyByteBody nbb = NettyBodyAdapter.adapt(body, ctx.channel().eventLoop());
             if (nbb instanceof AvailableNettyByteBody available) {
-                writeFull(new DefaultFullHttpResponse(response.protocolVersion(), response.status(), AvailableNettyByteBody.toByteBuf(available), response.headers(), EmptyHttpHeaders.INSTANCE));
+                writeFull(response, AvailableNettyByteBody.toByteBuf(available));
             } else {
-                prepareCompression(response, false);
-
-                writeHeaders(response, false, ctx.voidPromise());
-
                 StreamingNettyByteBody snbb = (StreamingNettyByteBody) nbb;
                 var consumer = new BufferConsumer() {
                     Upstream upstream;
@@ -298,9 +292,11 @@ abstract class MultiplexedServerHandler {
                     }
 
                     private void complete0() {
-                        if (finish()) {
+                        if (!responseDone) {
                             writeData(Unpooled.EMPTY_BUFFER, true, ctx.voidPromise());
-                            flush();
+                            if (finish()) {
+                                flush();
+                            }
                         }
                     }
 
@@ -319,27 +315,55 @@ abstract class MultiplexedServerHandler {
                         flush();
                     }
                 };
-                writerUpstream = consumer.upstream = snbb.primary(consumer);
-                consumer.upstream.start();
+                consumer.upstream = snbb.primary(consumer);
+                writeStreaming(response, consumer.upstream);
             }
         }
 
+        private void writeStreaming(HttpResponse response, BufferConsumer.Upstream upstream) {
+            if (!ctx.executor().inEventLoop()) {
+                ctx.executor().execute(() -> writeStreaming(response, upstream));
+                return;
+            }
+
+            if (responseDone) {
+                // connection closed?
+                writerUpstream.allowDiscard();
+                writerUpstream.disregardBackpressure();
+                return;
+            }
+
+            writerUpstream = upstream;
+
+            prepareCompression(response);
+
+            writeHeaders(response, false, ctx.voidPromise());
+            upstream.start();
+        }
+
         @Override
-        public final void writeFull(@NonNull FullHttpResponse response, boolean headResponse) {
+        public void writeHeadResponse(@NonNull HttpResponse response) {
+            response.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);
+            writeFull(response, Unpooled.EMPTY_BUFFER);
+        }
+
+        private void writeFull(@NonNull HttpResponse response, @NonNull ByteBuf content) {
             if (responseDone) {
                 // early check
                 throw new IllegalStateException("Response already written");
             }
             if (!ctx.executor().inEventLoop()) {
-                ctx.executor().execute(() -> writeFull(response, headResponse));
+                ByteBuf finalContent = content;
+                ctx.executor().execute(() -> writeFull(response, finalContent));
                 return;
             }
 
-            prepareCompression(response, true);
-
-            ByteBuf content = response.content();
             boolean empty = !content.isReadable();
 
+            if (!empty) {
+                prepareCompression(response);
+            }
+
             if (compressionSession != null) {
                 compressionSession.push(content);
                 compressionSession.finish();
@@ -352,6 +376,8 @@ abstract class MultiplexedServerHandler {
             if (!empty) {
                 // bypass writeDataCompressing
                 writeData0(content, true, ctx.voidPromise());
+            } else if (content != null) {
+                content.release();
             }
             if (!finish()) {
                 throw new IllegalStateException("Response already written");
@@ -359,11 +385,6 @@ abstract class MultiplexedServerHandler {
             flush();
         }
 
-        @Override
-        public final void writeStreamed(@NonNull HttpResponse response, @NonNull Publisher<HttpContent> content) {
-            write(response, NettyBodyAdapter.adapt(Flux.from(content).map(HttpContent::content), ctx.channel().eventLoop()));
-        }
-
         private void logStreamWriteFailure(Throwable cause) {
             if (cause instanceof Http2Exception h2e) {
                 if (LOG.isDebugEnabled()) {
@@ -383,13 +404,11 @@ abstract class MultiplexedServerHandler {
         public final void closeAfterWrite() {
         }
 
-        private void prepareCompression(HttpResponse headers, boolean full) {
+        private void prepareCompression(HttpResponse headers) {
             if (compressor != null) {
                 Compressor.Session session = compressor.prepare(ctx, request, headers);
                 if (session != null) {
-                    if (!full) {
-                        headers.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
-                    }
+                    headers.headers().remove(HttpHeaderNames.CONTENT_LENGTH);
                     compressionSession = session;
                 }
             }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
index bda0d6d987..7cc239281e 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
@@ -21,16 +21,15 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.body.CloseableByteBody;
 import io.micronaut.http.netty.EventLoopFlow;
+import io.micronaut.http.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.netty.body.BodySizeLimits;
+import io.micronaut.http.netty.body.BufferConsumer;
+import io.micronaut.http.netty.body.NettyByteBody;
+import io.micronaut.http.netty.body.StreamingNettyByteBody;
 import io.micronaut.http.netty.stream.StreamedHttpResponse;
 import io.micronaut.http.server.netty.HttpCompressionStrategy;
-import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
-import io.micronaut.http.server.netty.body.BodySizeLimits;
-import io.micronaut.http.server.netty.body.BufferConsumer;
 import io.micronaut.http.server.netty.body.NettyBodyAdapter;
-import io.micronaut.http.server.netty.body.NettyByteBody;
-import io.micronaut.http.server.netty.body.StreamingNettyByteBody;
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
 import io.netty.buffer.CompositeByteBuf;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.ChannelFutureListener;
@@ -64,7 +63,6 @@ import io.netty.handler.codec.http.HttpVersion;
 import io.netty.handler.codec.http.LastHttpContent;
 import io.netty.handler.timeout.IdleState;
 import io.netty.handler.timeout.IdleStateEvent;
-import org.reactivestreams.Publisher;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import reactor.core.publisher.Flux;
@@ -746,11 +744,6 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
             this.request = request;
         }
 
-        @Override
-        public ByteBufAllocator alloc() {
-            return ctx.alloc();
-        }
-
         /**
          * Set an attachment that is passed to {@link RequestHandler#responseWritten}. Defaults to
          * {@code null}.
@@ -845,7 +838,17 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
         }
 
         @Override
-        public void writeFull(FullHttpResponse response, boolean headResponse) {
+        public void writeHeadResponse(@NonNull HttpResponse response) {
+            writeFull(new DefaultFullHttpResponse(
+                response.protocolVersion(),
+                response.status(),
+                Unpooled.EMPTY_BUFFER,
+                response.headers(),
+                EmptyHttpHeaders.INSTANCE
+            ), true);
+        }
+
+        private void writeFull(FullHttpResponse response, boolean headResponse) {
             response.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);
             if (canHaveBody(response.status())) {
                 if (!headResponse) {
@@ -856,20 +859,17 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
             }
             preprocess(response);
             FullOutboundHandler oh = new FullOutboundHandler(this, response);
-            prepareCompression(response, oh);
+            if (response.content().isReadable()) {
+                prepareCompression(response, oh);
+            }
             write(oh);
         }
 
-        @Override
-        public void writeStreamed(HttpResponse response, Publisher<HttpContent> content) {
-            write(response, NettyBodyAdapter.adapt(Flux.from(content).map(HttpContent::content), ctx.channel().eventLoop()));
-        }
-
         @Override
         public void write(@NonNull HttpResponse response, @NonNull ByteBody body) {
             NettyByteBody nbb = NettyBodyAdapter.adapt(body, ctx.channel().eventLoop());
             if (nbb instanceof AvailableNettyByteBody available) {
-                writeFull(new DefaultFullHttpResponse(response.protocolVersion(), response.status(), AvailableNettyByteBody.toByteBuf(available), response.headers(), EmptyHttpHeaders.INSTANCE));
+                writeFull(new DefaultFullHttpResponse(response.protocolVersion(), response.status(), AvailableNettyByteBody.toByteBuf(available), response.headers(), EmptyHttpHeaders.INSTANCE), false);
             } else {
                 OptionalLong expectedLength = body.expectedLength();
                 if (expectedLength.isPresent()) {
@@ -1108,8 +1108,9 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
             }
 
             if (!removed) {
+                int n = buf.readableBytes();
                 writeCompressing(new DefaultHttpContent(buf), true, false);
-                incompleteWrittenBytes += buf.readableBytes();
+                incompleteWrittenBytes += n;
                 if (ctx.channel().isWritable()) {
                     writeSome();
                 }
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/jackson/JsonViewServerFilter.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/jackson/JsonViewServerFilter.java
index a821cf7e1f..c220724cc3 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/jackson/JsonViewServerFilter.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/jackson/JsonViewServerFilter.java
@@ -91,6 +91,9 @@ public class JsonViewServerFilter implements Ordered {
                 final Optional<?> optionalBody = response.getBody();
                 if (optionalBody.isPresent()) {
                     Object body = optionalBody.get();
+                    if (routeInfo.getReturnType().isOptional()) {
+                        body = Optional.of(body);
+                    }
                     MediaTypeCodec codec = codecFactory.resolveJsonViewCodec(viewClass.get());
                     if (Publishers.isConvertibleToPublisher(body)) {
                         Publisher<?> pub = Publishers.convertToPublisher(conversionService, body);
@@ -98,8 +101,9 @@ public class JsonViewServerFilter implements Ordered {
                             .map(o -> codec.encode((Argument) routeInfo.getResponseBodyType(), o))
                             .subscribeOn(Schedulers.fromExecutorService(executorService)));
                     } else {
+                        Object finalBody = body;
                         return Mono.fromCallable(() -> {
-                            @SuppressWarnings({"unchecked", "rawtypes"}) final byte[] encoded = codec.encode((Argument) routeInfo.getResponseBodyType(), body);
+                            @SuppressWarnings({"unchecked", "rawtypes"}) final byte[] encoded = codec.encode((Argument) routeInfo.getResponseBodyType(), finalBody);
                             response.body(encoded);
                             return response;
                         }).subscribeOn(Schedulers.fromExecutorService(executorService));
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/multipart/MultipartBodyArgumentBinder.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/multipart/MultipartBodyArgumentBinder.java
index daa7e6a702..fc4881c317 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/multipart/MultipartBodyArgumentBinder.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/multipart/MultipartBodyArgumentBinder.java
@@ -27,7 +27,7 @@ import io.micronaut.http.server.multipart.MultipartBody;
 import io.micronaut.http.server.netty.FormDataHttpContentProcessor;
 import io.micronaut.http.server.netty.HttpContentProcessorAsReactiveProcessor;
 import io.micronaut.http.server.netty.NettyHttpRequest;
-import io.micronaut.http.server.netty.body.NettyByteBody;
+import io.micronaut.http.netty.body.NettyByteBody;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.netty.handler.codec.http.DefaultHttpContent;
 import io.netty.handler.codec.http.multipart.Attribute;
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/websocket/NettyServerWebSocketHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/websocket/NettyServerWebSocketHandler.java
index 0ccaf1ecef..3175a36708 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/websocket/NettyServerWebSocketHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/websocket/NettyServerWebSocketHandler.java
@@ -123,9 +123,9 @@ public class NettyServerWebSocketHandler extends AbstractNettyWebSocketHandler {
         ExecutorSelector executorSelector,
         @Nullable CoroutineHelper coroutineHelper) {
         super(
-                ctx,
                 nettyEmbeddedServices.getRequestArgumentSatisfier().getBinderRegistry(),
                 nettyEmbeddedServices.getMediaTypeCodecRegistry(),
+                nettyEmbeddedServices.getMessageBodyHandlerRegistry(),
                 webSocketBean,
                 request,
                 routeMatch.getVariableValues(),
@@ -243,6 +243,7 @@ public class NettyServerWebSocketHandler extends AbstractNettyWebSocketHandler {
                 channel,
                 originatingRequest,
                 mediaTypeCodecRegistry,
+                messageBodyHandlerRegistry,
                 webSocketVersion.toHttpHeaderValue(),
                 ctx.pipeline().get(SslHandler.class) != null
         ) {
diff --git a/http-server-netty/src/test/groovy/io/micronaut/PleaseEnableRoutesBySpecNameSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/PleaseEnableRoutesBySpecNameSpec.groovy
new file mode 100644
index 0000000000..418e3a026c
--- /dev/null
+++ b/http-server-netty/src/test/groovy/io/micronaut/PleaseEnableRoutesBySpecNameSpec.groovy
@@ -0,0 +1,18 @@
+package io.micronaut
+
+import io.micronaut.http.server.netty.AbstractMicronautSpec
+import io.micronaut.web.router.Router
+
+class PleaseEnableRoutesBySpecNameSpec extends AbstractMicronautSpec {
+
+    void "don't add more public routes in test"() {
+        // A lot of activate routes, filters etc. complicates debugging
+        // Please use @Requires(property="spec.name.. to enable your route and filters only for particular tests
+        given:
+            Router router = applicationContext.getBean(Router)
+        expect:
+            router.uriRoutes().toList().size() == 0
+    }
+
+
+}
diff --git a/http-server-netty/src/test/groovy/io/micronaut/docs/writable/TemplateController.java b/http-server-netty/src/test/groovy/io/micronaut/docs/writable/TemplateController.java
index 7236397280..8f9c894d45 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/docs/writable/TemplateController.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/docs/writable/TemplateController.java
@@ -19,6 +19,7 @@ package io.micronaut.docs.writable;
 
 import groovy.text.SimpleTemplateEngine;
 import groovy.text.Template;
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.io.Writable;
 import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.http.MediaType;
@@ -28,6 +29,7 @@ import io.micronaut.http.server.exceptions.HttpServerException;
 //end::imports[]
 
 //tag::clazz[]
+@Requires(property = "spec.name", value = "WritableSpec")
 @Controller("/template")
 public class TemplateController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/docs/writable/WritableSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/docs/writable/WritableSpec.groovy
index 0d7a675134..6b398789ea 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/docs/writable/WritableSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/docs/writable/WritableSpec.groovy
@@ -26,10 +26,9 @@ import spock.lang.Specification
 
 class WritableSpec extends Specification {
 
-    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer)
+    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'WritableSpec'])
     @Shared @AutoCleanup HttpClient client = embeddedServer.getApplicationContext().createBean(HttpClient, embeddedServer.getURL())
 
-
     void "test render template"() {
         expect:
         HttpResponse<String> resp = client.toBlocking().exchange('/template/welcome', String)
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/CompressionSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/CompressionSpec.groovy
index 3988309baa..b242ec85e1 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/CompressionSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/CompressionSpec.groovy
@@ -10,6 +10,7 @@ import io.micronaut.http.annotation.Body
 import io.micronaut.http.annotation.Controller
 import io.micronaut.http.annotation.Get
 import io.micronaut.http.annotation.Post
+import io.micronaut.http.annotation.Produces
 import io.micronaut.http.client.HttpClient
 import io.micronaut.http.client.netty.NettyClientCustomizer
 import io.micronaut.http.netty.channel.ChannelPipelineCustomizer
@@ -144,6 +145,44 @@ class CompressionSpec extends Specification {
         HttpHeaderValues.SNAPPY    | new SnappyFrameEncoder()
     }
 
+    def compressionStream(ChannelHandler decompressor, CharSequence contentEncoding) {
+        given:
+        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['spec.name': 'CompressionSpec'] + serverOptions())
+
+        byte[] uncompressed = new byte[100000]
+        ThreadLocalRandom.current().nextBytes(uncompressed)
+        server.applicationContext.getBean(Ctrl).data = uncompressed
+
+        def client = server.applicationContext.createBean(HttpClient, server.URI).toBlocking()
+
+        when:
+        byte[] compressed = client.retrieve(HttpRequest.GET("/compress-stream").header("Accept-Encoding", contentEncoding.toString()), byte[])
+        def compChannel = new EmbeddedChannel(decompressor)
+        compChannel.writeInbound(Unpooled.copiedBuffer(compressed))
+        compChannel.finish()
+        ByteBuf decompressed = Unpooled.buffer()
+        while (true) {
+            ByteBuf o = compChannel.readInbound()
+            if (o == null) {
+                break
+            }
+            decompressed.writeBytes(o)
+            o.release()
+        }
+        then:
+        ByteBufUtil.getBytes(decompressed) == uncompressed
+
+        cleanup:
+        client.close()
+        server.stop()
+
+        where:
+        contentEncoding            | decompressor
+        HttpHeaderValues.GZIP      | ZlibCodecFactory.newZlibDecoder(ZlibWrapper.GZIP)
+        HttpHeaderValues.DEFLATE   | ZlibCodecFactory.newZlibDecoder(ZlibWrapper.ZLIB)
+        HttpHeaderValues.SNAPPY    | new SnappyFrameDecoder()
+    }
+
     @Requires(property = "spec.name", value = "CompressionSpec")
     @Controller
     static class Ctrl {
@@ -158,6 +197,12 @@ class CompressionSpec extends Specification {
         void receive(@Body byte[] data) {
             this.data = data
         }
+
+        @Get("/compress-stream")
+        @Produces("text/plain")
+        InputStream sendStream() {
+            return new ByteArrayInputStream(data)
+        }
     }
 
     // the code below disables the automatic decompression in the http client so that we can see the compressed data in the test
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/ConnectionCloseSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/ConnectionCloseSpec.groovy
index 1fa75bdf3f..4201639f96 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/ConnectionCloseSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/ConnectionCloseSpec.groovy
@@ -1,6 +1,7 @@
 package io.micronaut.http.server.netty
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpHeaders
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.HttpResponse
@@ -86,6 +87,7 @@ class ConnectionCloseSpec extends Specification {
         server.close()
     }
 
+    @Requires(property = 'spec.name', value = 'ConnectionCloseSpec')
     @Controller("/connection")
     static class ConnectionCloseController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/NettyMultiServerSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/NettyMultiServerSpec.groovy
index db8b39b862..1ebb492ff0 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/NettyMultiServerSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/NettyMultiServerSpec.groovy
@@ -1,8 +1,7 @@
 package io.micronaut.http.server.netty
 
-
 import io.micronaut.context.annotation.Property
-import io.micronaut.core.util.StringUtils
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.annotation.Controller
 import io.micronaut.http.annotation.Get
@@ -17,7 +16,7 @@ import jakarta.inject.Named
 import spock.lang.Specification
 
 @MicronautTest
-@Property(name = "NettyMultiServerSpec", value = StringUtils.TRUE)
+@Property(name = "spec.name", value = "NettyMultiServerSpec")
 class NettyMultiServerSpec extends Specification {
 
     @Inject ApplicationConfiguration applicationConfiguration
@@ -46,6 +45,7 @@ class NettyMultiServerSpec extends Specification {
         secondaryClient.close()
     }
 
+    @Requires(property = "spec.name", value = "NettyMultiServerSpec")
     @Controller("/test/secondary/server")
     static class TestController {
         @Get("/")
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/RequestCertificateSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/RequestCertificateSpec.groovy
index 567df1e6c9..cb9f2ee7d7 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/RequestCertificateSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/RequestCertificateSpec.groovy
@@ -1,5 +1,6 @@
 package io.micronaut.http.server.netty
 
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.HttpStatus
 import io.micronaut.http.annotation.Controller
@@ -71,6 +72,7 @@ class RequestCertificateSpec extends AbstractMicronautSpec {
         ]
     }
 
+    @Requires(property = 'spec.name', value = 'RequestCertificateSpec')
     @Controller
     static class TestController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/TestNettySecondaryServer.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/TestNettySecondaryServer.java
index 77261ed522..cba7527f53 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/TestNettySecondaryServer.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/TestNettySecondaryServer.java
@@ -3,21 +3,20 @@ package io.micronaut.http.server.netty;
 import io.micronaut.context.annotation.Bean;
 import io.micronaut.context.annotation.Factory;
 import io.micronaut.context.annotation.Requires;
-import io.micronaut.core.util.StringUtils;
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration;
 import io.micronaut.runtime.ApplicationConfiguration;
 import jakarta.inject.Inject;
 import jakarta.inject.Named;
 
 @Factory
-@Requires(property = "NettyMultiServerSpec", value = StringUtils.TRUE)
+@Requires(property = "spec.name", value = "NettyMultiServerSpec")
 public class TestNettySecondaryServer {
     @Inject ApplicationConfiguration applicationConfiguration;
     @Inject NettyEmbeddedServerFactory embeddedServerFactory;
 
     @Named("secondary")
     @Bean(preDestroy = "stop")
-    @Requires(property = "NettyMultiServerSpec", value = StringUtils.TRUE)
+    @Requires(property = "spec.name", value = "NettyMultiServerSpec")
     NettyEmbeddedServer secondaryServer() {
         NettyEmbeddedServer embeddedServer = embeddedServerFactory
                 .build(new NettyHttpServerConfiguration(applicationConfiguration));
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CookieBindingSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CookieBindingSpec.groovy
index cff25946d3..cdb5722a32 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CookieBindingSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CookieBindingSpec.groovy
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.binding
 
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.annotation.Controller
 import io.micronaut.http.annotation.CookieValue
@@ -69,10 +70,12 @@ class CookieBindingSpec extends AbstractMicronautSpec {
         result == "Cookie Value: foo"
     }
 
+    @Requires(property = "spec.name", value = "CookieBindingSpec")
     @Client('/cookie')
     static interface CookieClient extends CookieApi {
     }
 
+    @Requires(property = "spec.name", value = "CookieBindingSpec")
     @Controller("/cookie")
     static class CookieController implements CookieApi {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CustomParameterBindingSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CustomParameterBindingSpec.groovy
index be2c25c58e..a444d3e135 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CustomParameterBindingSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CustomParameterBindingSpec.groovy
@@ -1,5 +1,6 @@
 package io.micronaut.http.server.netty.binding
 
+import io.micronaut.context.annotation.Requires
 import io.micronaut.core.annotation.Introspected
 import io.micronaut.core.convert.format.Format
 import io.micronaut.http.*
@@ -83,6 +84,7 @@ class CustomParameterBindingSpec extends AbstractMicronautSpec {
         response.getBody().get() == "Parameter Value: The Stand"
     }
 
+    @Requires(property = 'spec.name', value = 'CustomParameterBindingSpec')
     @Controller(value = "/parameter", produces = MediaType.TEXT_PLAIN)
     static class ParameterController {
         @CustomHttpMethod(method="REPORT")
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HeaderBindingSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HeaderBindingSpec.groovy
index 6c4ece0196..ed67cfa092 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HeaderBindingSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HeaderBindingSpec.groovy
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.binding
 
+import io.micronaut.context.annotation.Requires
 import io.micronaut.core.convert.format.Format
 import io.micronaut.http.HttpHeaders
 import io.micronaut.http.HttpRequest
@@ -67,6 +68,7 @@ class HeaderBindingSpec extends AbstractMicronautSpec {
         '/header/with-value'      | "Header: application/json"   | ['Content-Type': 'application/json']
     }
 
+    @Requires(property = 'spec.name', value = 'HeaderBindingSpec')
     @Controller("/header")
     static class HeaderController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HttpRequestTest.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HttpRequestTest.java
index 666b082b76..ed712cbbd6 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HttpRequestTest.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HttpRequestTest.java
@@ -21,7 +21,7 @@ import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.server.HttpServerConfiguration;
 import io.micronaut.http.server.netty.NettyHttpRequest;
-import io.micronaut.http.server.netty.body.AvailableNettyByteBody;
+import io.micronaut.http.netty.body.AvailableNettyByteBody;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.HttpVersion;
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HttpResponseSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HttpResponseSpec.groovy
index b340acdb87..e5f74b9099 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HttpResponseSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/HttpResponseSpec.groovy
@@ -18,9 +18,12 @@ package io.micronaut.http.server.netty.binding
 import io.micronaut.context.ApplicationContext
 import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpHeaders
+import io.micronaut.http.HttpMessage
+import io.micronaut.http.HttpMethod
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.HttpResponse
 import io.micronaut.http.HttpStatus
+import io.micronaut.http.MediaType
 import io.micronaut.http.annotation.Controller
 import io.micronaut.http.annotation.Get
 import io.micronaut.http.client.HttpClient
@@ -298,4 +301,81 @@ class HttpResponseSpec extends AbstractMicronautSpec {
     Map<String, Object> getConfiguration() {
         super.getConfiguration() << ['micronaut.server.date-header': false]
     }
+
+    @Requires(property = 'spec.name', value = 'HttpResponseSpec')
+    @Controller("/java/response")
+    static class ResponseController {
+
+        @Get("/disallow")
+        public HttpResponse disallow() {
+            return HttpResponse.notAllowed(HttpMethod.DELETE);
+        }
+
+        @Get("/accepted")
+        public HttpResponse accepted() {
+            return HttpResponse.accepted();
+        }
+
+        @Get("/accepted-uri")
+        public HttpResponse acceptedUri() {
+            return HttpResponse.accepted(HttpResponse.uri("http://example.com"));
+        }
+
+        @Get("/created-uri")
+        public HttpResponse createdUri() {
+            return HttpResponse.created(HttpResponse.uri("http://test.com"));
+        }
+
+        @Get("/created-body")
+        public HttpResponse createdBody() {
+            return HttpResponse.created(new io.micronaut.http.server.netty.java.Foo("blah", 10));
+        }
+
+        @Get("/created-body-uri")
+        public HttpResponse createdBodyUri() {
+            return HttpResponse.created(new io.micronaut.http.server.netty.java.Foo("blah", 10), HttpResponse.uri("http://test.com"));
+        }
+
+        @Get("/ok")
+        public HttpResponse ok() {
+            return HttpResponse.ok();
+        }
+
+        @Get(value = "/ok-with-body", produces = MediaType.TEXT_PLAIN)
+        public HttpResponse okWithBody() {
+            return HttpResponse.ok("some text");
+        }
+
+        @Get(value = "/error-with-body", produces = MediaType.TEXT_PLAIN)
+        public HttpResponse errorWithBody() {
+            return HttpResponse.serverError().body("some text");
+        }
+
+        @Get("/ok-with-body-object")
+        public HttpResponse<io.micronaut.http.server.netty.java.Foo> okWithBodyObject() {
+            return HttpResponse.ok(new io.micronaut.http.server.netty.java.Foo("blah", 10))
+                    .headers((headers)->
+                            headers.contentType(MediaType.APPLICATION_JSON_TYPE)
+                    );
+        }
+
+        @Get("/status")
+        public HttpMessage status() {
+            return HttpResponse.status(HttpStatus.MOVED_PERMANENTLY);
+        }
+
+        @Get("/custom-headers")
+        public HttpResponse customHeaders() {
+            return HttpResponse.ok("abc").contentType("text/plain").contentLength(7);
+        }
+
+        @Get("/optional-response/{empty}")
+        public Optional<HttpResponse> optionalResponse(Boolean empty) {
+            if (empty) {
+                return Optional.empty();
+            } else {
+                return Optional.of(HttpResponse.ok());
+            }
+        }
+    }
 }
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/NettyHttpRequestSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/NettyHttpRequestSpec.groovy
index abcbcdd051..4afbc9bca3 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/NettyHttpRequestSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/NettyHttpRequestSpec.groovy
@@ -21,7 +21,7 @@ import io.micronaut.http.HttpMethod
 import io.micronaut.http.MutableHttpRequest
 import io.micronaut.http.server.HttpServerConfiguration
 import io.micronaut.http.server.netty.NettyHttpRequest
-import io.micronaut.http.server.netty.body.AvailableNettyByteBody
+import io.micronaut.http.netty.body.AvailableNettyByteBody
 import io.netty.channel.ChannelHandlerContext
 import io.netty.handler.codec.http.DefaultFullHttpRequest
 import io.netty.handler.codec.http.HttpVersion
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/NettyHttpServerSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/NettyHttpServerSpec.groovy
index a6afb65253..51452336e3 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/NettyHttpServerSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/NettyHttpServerSpec.groovy
@@ -16,6 +16,7 @@
 package io.micronaut.http.server.netty.binding
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.context.env.Environment
 import io.micronaut.context.env.PropertySource
 import io.micronaut.context.event.StartupEvent
@@ -32,7 +33,6 @@ import io.micronaut.http.client.DefaultHttpClientConfiguration
 import io.micronaut.http.client.HttpClient
 import io.micronaut.http.client.exceptions.HttpClientResponseException
 import io.micronaut.http.server.exceptions.ServerStartupException
-import io.micronaut.runtime.Micronaut
 import io.micronaut.runtime.event.annotation.EventListener
 import io.micronaut.runtime.server.EmbeddedServer
 import jakarta.inject.Singleton
@@ -43,7 +43,6 @@ import spock.lang.Stepwise
 import java.time.Duration
 import java.time.temporal.ChronoUnit
 import java.util.concurrent.atomic.AtomicInteger
-
 /**
  * @author Graeme Rocher
  * @since 1.0
@@ -54,9 +53,8 @@ class NettyHttpServerSpec extends Specification {
 
     void "test Micronaut server running"() {
         when:
-        ApplicationContext applicationContext = Micronaut.run()
-        EmbeddedServer embeddedServer = applicationContext.getBean(EmbeddedServer)
-        HttpClient client = applicationContext.createBean(HttpClient, embeddedServer.getURL())
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'NettyHttpServerSpec'])
+        HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL())
 
         HttpResponse response = client.toBlocking().exchange('/person/Fred', String)
         then:
@@ -64,12 +62,12 @@ class NettyHttpServerSpec extends Specification {
 
         cleanup:
         client.stop()
-        applicationContext.stop()
+        embeddedServer.stop()
     }
 
     void "test run Micronaut server on same port as another server"() {
         when:
-        PropertySource propertySource = PropertySource.of('micronaut.server.port':-1)
+        PropertySource propertySource = PropertySource.of('micronaut.server.port':-1, 'spec.name': 'NettyHttpServerSpec')
         EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, propertySource, Environment.TEST)
 
         HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL())
@@ -80,7 +78,7 @@ class NettyHttpServerSpec extends Specification {
 
         when: "Run another server with same port"
         sleep(1_000) // wait for port to be not available
-        ApplicationContext.run(EmbeddedServer, PropertySource.of('micronaut.server.port':embeddedServer.getPort()), Environment.TEST)
+        ApplicationContext.run(EmbeddedServer, PropertySource.of('micronaut.server.port':embeddedServer.getPort(), 'spec.name': 'NettyHttpServerSpec'), Environment.TEST)
 
         then:"An error is thrown"
         def e = thrown(ServerStartupException)
@@ -93,9 +91,8 @@ class NettyHttpServerSpec extends Specification {
 
     void "test Micronaut server running again"() {
         when:
-        ApplicationContext applicationContext = Micronaut.run()
-        EmbeddedServer embeddedServer = applicationContext.getBean(EmbeddedServer)
-        HttpClient client = applicationContext.createBean(HttpClient, embeddedServer.getURL())
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'NettyHttpServerSpec'])
+        HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL())
 
         HttpResponse response = client.toBlocking().exchange('/person/Fred', String)
         then:
@@ -103,15 +100,14 @@ class NettyHttpServerSpec extends Specification {
 
         cleanup:
         client.stop()
-        applicationContext.stop()
+        embeddedServer.stop()
     }
 
     void "test Micronaut server on different port"() {
         when:
         int newPort = SocketUtils.findAvailableTcpPort()
-        ApplicationContext applicationContext = Micronaut.run('-port',newPort.toString())
-        EmbeddedServer embeddedServer = applicationContext.getBean(EmbeddedServer)
-        HttpClient client = applicationContext.createBean(HttpClient, embeddedServer.getURL())
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'NettyHttpServerSpec', 'micronaut.server.port':newPort.toString()])
+        HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL())
 
         HttpResponse response = client.toBlocking().exchange('/person/Fred', String)
 
@@ -120,15 +116,14 @@ class NettyHttpServerSpec extends Specification {
 
         cleanup:
         client.stop()
-        applicationContext.stop()
+        embeddedServer.stop()
     }
 
     void "test bind method argument from request parameter"() {
         when:
         int newPort = SocketUtils.findAvailableTcpPort()
-        ApplicationContext applicationContext = Micronaut.run('-port',newPort.toString())
-        EmbeddedServer embeddedServer = applicationContext.getBean(EmbeddedServer)
-        HttpClient client = applicationContext.createBean(HttpClient, embeddedServer.getURL())
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'NettyHttpServerSpec', 'micronaut.server.port':newPort.toString()])
+        HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL())
 
         HttpResponse response = client.toBlocking().exchange('/person/another/job?id=10', String)
 
@@ -137,15 +132,14 @@ class NettyHttpServerSpec extends Specification {
 
         cleanup:
         client.stop()
-        applicationContext.stop()
+        embeddedServer.stop()
     }
 
     void "test bind method argument from request parameter when parameter missing"() {
         when:"A required request parameter is missing"
         int newPort = SocketUtils.findAvailableTcpPort()
-        ApplicationContext applicationContext = Micronaut.run('-port',newPort.toString())
-        EmbeddedServer embeddedServer = applicationContext.getBean(EmbeddedServer)
-        HttpClient client = applicationContext.createBean(HttpClient, embeddedServer.getURL())
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'NettyHttpServerSpec', 'micronaut.server.port':newPort.toString()])
+        HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL())
 
         client.toBlocking().exchange('/person/another/job', String)
 
@@ -155,15 +149,14 @@ class NettyHttpServerSpec extends Specification {
 
         cleanup:
         client.stop()
-        applicationContext.stop()
+            embeddedServer.stop()
     }
 
     void "test allowed methods handling"() {
         when:"A request is sent to the server for the wrong HTTP method"
         int newPort = SocketUtils.findAvailableTcpPort()
-        ApplicationContext applicationContext = Micronaut.run('-port',newPort.toString())
-        EmbeddedServer embeddedServer = applicationContext.getBean(EmbeddedServer)
-        HttpClient client = applicationContext.createBean(HttpClient, embeddedServer.getURL())
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'NettyHttpServerSpec', 'micronaut.server.port':newPort.toString()])
+        HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL())
 
         client.toBlocking().exchange(HttpRequest.POST('/person/job/test', '{}'), String)
 
@@ -174,7 +167,7 @@ class NettyHttpServerSpec extends Specification {
 
         cleanup:
         client.stop()
-        applicationContext.stop()
+        embeddedServer.stop()
     }
 
     void "test expected connection persistence"() {
@@ -184,9 +177,8 @@ class NettyHttpServerSpec extends Specification {
         config.connectionPoolConfiguration.enabled = true
         config.connectionPoolConfiguration.acquireTimeout = Duration.of(3, ChronoUnit.SECONDS);
 
-        ApplicationContext applicationContext = Micronaut.run()
-        EmbeddedServer embeddedServer = applicationContext.getBean(EmbeddedServer)
-        HttpClient client = applicationContext.createBean(HttpClient, embeddedServer.getURL(), config)
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'NettyHttpServerSpec'])
+        HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL(), config)
 
         HttpRequest request = HttpRequest.create(HttpMethod.GET, '/person/Fred')
         HttpResponse response = client.toBlocking().exchange(request, String)
@@ -196,12 +188,13 @@ class NettyHttpServerSpec extends Specification {
 
         cleanup:
         client.stop()
-        applicationContext.stop()
+            embeddedServer.stop()
     }
 
     void "test run Micronaut server when enabling both http and https"() {
         when:
         PropertySource propertySource = PropertySource.of(
+                'spec.name': 'NettyHttpServerSpec',
                 'micronaut.server.port':httpPort,
                 'micronaut.server.ssl.enabled': true,
                 'micronaut.server.ssl.port': -1,
@@ -232,6 +225,7 @@ class NettyHttpServerSpec extends Specification {
         def unsecurePort = SocketUtils.findAvailableTcpPort()
         when:
         PropertySource propertySource = PropertySource.of(
+                'spec.name': 'NettyHttpServerSpec',
                 'micronaut.server.port': unsecurePort,
                 'micronaut.server.ssl.port': securePort,
                 'micronaut.server.ssl.enabled': true,
@@ -252,6 +246,7 @@ class NettyHttpServerSpec extends Specification {
     void "test non dual protocol Micronaut server only fires startup event once"() {
         when:
         PropertySource propertySource = PropertySource.of(
+                'spec.name': 'NettyHttpServerSpec',
                 'micronaut.server.port': SocketUtils.findAvailableTcpPort(),
                 'micronaut.server.dualProtocol':false
         )
@@ -268,6 +263,7 @@ class NettyHttpServerSpec extends Specification {
     void "test dual protocol only fires startup event once"() {
         when:
         PropertySource propertySource = PropertySource.of(
+                'spec.name': 'NettyHttpServerSpec',
                 'micronaut.server.port': SocketUtils.findAvailableTcpPort(),
                 'micronaut.server.ssl.port': SocketUtils.findAvailableTcpPort(),
                 'micronaut.server.ssl.enabled': true,
@@ -284,6 +280,7 @@ class NettyHttpServerSpec extends Specification {
         embeddedServer.applicationContext.stop()
     }
 
+    @Requires(property = "spec.name", value = "NettyHttpServerSpec")
     @Singleton
     static class EventCounter {
         AtomicInteger count = new AtomicInteger(0)
@@ -294,6 +291,7 @@ class NettyHttpServerSpec extends Specification {
         }
     }
 
+    @Requires(property = "spec.name", value = "NettyHttpServerSpec")
     @Controller("/person")
     static class PersonController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/ParameterBindingSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/ParameterBindingSpec.groovy
index d483f4ccb7..7c79c6f9c4 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/ParameterBindingSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/ParameterBindingSpec.groovy
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.binding
 
+import io.micronaut.context.annotation.Requires
 import io.micronaut.core.annotation.Introspected
 import io.micronaut.core.convert.format.Format
 import io.micronaut.http.*
@@ -107,6 +108,7 @@ class ParameterBindingSpec extends AbstractMicronautSpec {
         response.body().contains('Unexpected token (VALUE_STRING), expected END_ARRAY')
     }
 
+    @Requires(property = 'spec.name', value = 'ParameterBindingSpec')
     @Controller(value = "/parameter", produces = MediaType.TEXT_PLAIN)
     static class ParameterController {
         @Get
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/QueryParameterFormattingSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/QueryParameterFormattingSpec.groovy
index 5b1f170027..78706f1b67 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/QueryParameterFormattingSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/QueryParameterFormattingSpec.groovy
@@ -1,5 +1,6 @@
 package io.micronaut.http.server.netty.binding
 
+import io.micronaut.context.annotation.Requires
 import io.micronaut.core.annotation.Introspected
 import io.micronaut.core.convert.format.Format
 import io.micronaut.http.HttpMethod
@@ -66,7 +67,7 @@ public class QueryParameterFormattingSpec extends AbstractMicronautSpec {
         var e = thrown(HttpClientResponseException)
     }
 
-
+    @Requires(property = 'spec.name', value = 'QueryParameterFormattingSpec')
     @Controller(value = "/formatted", produces = MediaType.TEXT_PLAIN)
     static class FormattedController {
         @Get("csv")
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/body/NettyBodyAdapterSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/body/NettyBodyAdapterSpec.groovy
new file mode 100644
index 0000000000..1874494364
--- /dev/null
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/body/NettyBodyAdapterSpec.groovy
@@ -0,0 +1,42 @@
+package io.micronaut.http.server.netty.body
+
+import io.micronaut.http.netty.body.BufferConsumer
+import io.netty.buffer.ByteBuf
+import io.netty.buffer.Unpooled
+import io.netty.channel.embedded.EmbeddedChannel
+import reactor.core.publisher.Flux
+import spock.lang.Specification
+import io.micronaut.http.server.netty.body.NettyBodyAdapter
+
+class NettyBodyAdapterSpec extends Specification {
+    def 'empty buffers'() {
+        given:
+        def flux = Flux.just(Unpooled.EMPTY_BUFFER, Unpooled.wrappedBuffer(new byte[] {1, 2, 3}))
+        def adapter = NettyBodyAdapter.adapt(flux, new EmbeddedChannel().eventLoop())
+        def received = Unpooled.buffer()
+        def upstream = adapter.primary(new BufferConsumer() {
+            @Override
+            void add(ByteBuf buf) {
+                received.writeBytes(buf)
+                buf.release()
+            }
+
+            @Override
+            void complete() {
+            }
+
+            @Override
+            void error(Throwable e) {
+            }
+        })
+
+        expect:
+        !received.isReadable()
+
+        when:
+        upstream.start()
+        then:
+        received.isReadable()
+        received.readByte() == (byte) 1
+    }
+}
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/configuration/MaxHeaderSizeSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/configuration/MaxHeaderSizeSpec.groovy
index 033de6434c..b175c66bbc 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/configuration/MaxHeaderSizeSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/configuration/MaxHeaderSizeSpec.groovy
@@ -16,6 +16,7 @@
 package io.micronaut.http.server.netty.configuration
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.HttpStatus
 import io.micronaut.http.annotation.Controller
@@ -35,6 +36,7 @@ class MaxHeaderSizeSpec extends Specification {
     void "test that the max header size can be configured"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, [
+                'spec.name': 'MaxHeaderSizeSpec',
                 'micronaut.server.netty.maxHeaderSize':10
         ])
         HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL())
@@ -54,6 +56,7 @@ class MaxHeaderSizeSpec extends Specification {
         client.stop()
     }
 
+    @Requires(property = "spec.name", value = "MaxHeaderSizeSpec")
     @Controller('/max-header')
     static class TestController {
         @Get
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/consumes/ContentTypeHeaderSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/consumes/ContentTypeHeaderSpec.groovy
index 75aca5114a..ce1200fffc 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/consumes/ContentTypeHeaderSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/consumes/ContentTypeHeaderSpec.groovy
@@ -16,6 +16,7 @@
 package io.micronaut.http.server.netty.consumes
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.*
 import io.micronaut.http.annotation.Controller
 import io.micronaut.http.annotation.Get
@@ -27,7 +28,7 @@ import spock.lang.Specification
 
 class ContentTypeHeaderSpec extends Specification {
 
-    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer)
+    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'ContentTypeHeaderSpec'])
 
     @Shared HttpClient client = embeddedServer.applicationContext.createBean(
             HttpClient,
@@ -58,7 +59,7 @@ class ContentTypeHeaderSpec extends Specification {
         resp.body() == 'ok'
     }
 
-
+    @Requires(property = "spec.name", value = "ContentTypeHeaderSpec")
     @Controller("/test/content-type")
     static class ContentTypeController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/context/ServerRequestContextSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/context/ServerRequestContextSpec.groovy
index 32560932cf..64fc8ecfdb 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/context/ServerRequestContextSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/context/ServerRequestContextSpec.groovy
@@ -16,6 +16,7 @@
 package io.micronaut.http.server.netty.context
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.core.propagation.PropagatedContext
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.HttpResponse
@@ -53,7 +54,8 @@ class ServerRequestContextSpec extends Specification {
             EmbeddedServer,
             // limit number of threads to simulate thread sharing
             ['micronaut.executors.io.type': 'FIXED',
-             'micronaut.executors.io.nThreads':'2',]
+             'micronaut.executors.io.nThreads':'2',
+             'spec.name': 'ServerRequestContextSpec']
     )
 
     @Unroll
@@ -78,6 +80,7 @@ class ServerRequestContextSpec extends Specification {
         testClient.reactorContextStream() == '/test-context/reactor-context-stream'
     }
 
+    @Requires(property = 'spec.name', value = 'ServerRequestContextSpec')
     @Client('/test-context')
     @Consumes(MediaType.TEXT_PLAIN)
     static interface TestClient {
@@ -104,6 +107,7 @@ class ServerRequestContextSpec extends Specification {
         String handlerError()
     }
 
+    @Requires(property = 'spec.name', value = 'ServerRequestContextSpec')
     @Controller('/test-context')
     @Produces(MediaType.TEXT_PLAIN)
     static class TestContextController {
@@ -181,6 +185,7 @@ class ServerRequestContextSpec extends Specification {
         }
     }
 
+    @Requires(property = 'spec.name', value = 'ServerRequestContextSpec')
     @Singleton
     static class TestExceptionHandler implements ExceptionHandler<TestExceptionHandlerException, HttpResponse<String>> {
         @Inject
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/cors/CorsFilterSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/cors/CorsFilterSpec.groovy
index d610c401c1..a3e65433ee 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/cors/CorsFilterSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/cors/CorsFilterSpec.groovy
@@ -16,6 +16,7 @@
 package io.micronaut.http.server.netty.cors
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.core.annotation.Nullable
 import io.micronaut.core.util.StringUtils
 import io.micronaut.http.HttpAttributes
@@ -55,7 +56,7 @@ class CorsFilterSpec extends Specification {
 
     @Shared
     @AutoCleanup
-    EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer)
+    EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'CorsFilterSpec'])
 
     void "non CORS request is passed through"() {
         given:
@@ -537,6 +538,7 @@ class CorsFilterSpec extends Specification {
         HttpStatus.OK == response.status()
     }
 
+    @Requires(property = "spec.name", value = "CorsFilterSpec")
     @Controller
     static class TestController{
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/HeaderTooLongSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/HeaderTooLongSpec.groovy
new file mode 100644
index 0000000000..748cd43e78
--- /dev/null
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/HeaderTooLongSpec.groovy
@@ -0,0 +1,60 @@
+package io.micronaut.http.server.netty.errors
+
+import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
+import io.micronaut.core.annotation.NonNull
+import io.micronaut.http.HttpRequest
+import io.micronaut.http.MutableHttpResponse
+import io.micronaut.http.annotation.RequestFilter
+import io.micronaut.http.annotation.ServerFilter
+import io.micronaut.http.server.exceptions.response.ErrorContext
+import io.micronaut.http.server.exceptions.response.ErrorResponseProcessor
+import io.micronaut.runtime.server.EmbeddedServer
+import jakarta.inject.Singleton
+import spock.lang.AutoCleanup
+import spock.lang.Shared
+import spock.lang.Specification
+
+class HeaderTooLongSpec extends Specification {
+
+    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, [
+            'spec.name': 'HeaderTooLongSpec',
+            'micronaut.server.netty.log-level': 'info'
+    ])
+
+    def 'header too long'() {
+        given:
+        def connection = new URL("$embeddedServer.URL/malformed-proxy/xyz").openConnection()
+        connection.setRequestProperty("foo", "b".repeat(9000))
+
+        def myFilter = embeddedServer.applicationContext.getBean(MyFilter)
+
+        when:
+        connection.inputStream
+        then:
+        thrown IOException
+        ((HttpURLConnection) connection).errorStream == null
+        myFilter.filteredRequest == null
+    }
+
+    @Singleton
+    @Requires(property = "spec.name", value = "HeaderTooLongSpec")
+    static class BrokenProcessor implements ErrorResponseProcessor<String> {
+        @Override
+        MutableHttpResponse<String> processResponse(@NonNull ErrorContext errorContext, @NonNull MutableHttpResponse<?> baseResponse) {
+            throw new Exception("This processor is intentionally broken")
+        }
+    }
+
+    @Singleton
+    @Requires(property = "spec.name", value = "HeaderTooLongSpec")
+    @ServerFilter("/**")
+    static class MyFilter {
+        HttpRequest<?> filteredRequest
+
+        @RequestFilter
+        void requestFilter(HttpRequest<?> request) {
+            filteredRequest = request
+        }
+    }
+}
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/HttpStatusExceptionSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/HttpStatusExceptionSpec.groovy
index b6a02ec35b..93d805de04 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/HttpStatusExceptionSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/HttpStatusExceptionSpec.groovy
@@ -16,6 +16,7 @@
 package io.micronaut.http.server.netty.errors
 
 import groovy.json.JsonSlurper
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpHeaders
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.HttpResponse
@@ -73,6 +74,7 @@ class HttpStatusExceptionSpec extends AbstractMicronautSpec {
         json.title == 'The title'
     }
 
+    @Requires(property = "spec.name", value = "HttpStatusExceptionSpec")
     @Controller('/errors')
     static class BookController {
         @Get
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/MalformedUriSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/MalformedUriSpec.groovy
index d87d5d1df4..0fcf909108 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/MalformedUriSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/errors/MalformedUriSpec.groovy
@@ -15,6 +15,7 @@ import io.micronaut.http.annotation.ServerFilter
 import io.micronaut.http.client.HttpClient
 import io.micronaut.http.filter.HttpServerFilter
 import io.micronaut.http.filter.ServerFilterChain
+import io.micronaut.http.server.annotation.PreMatching
 import io.micronaut.runtime.server.EmbeddedServer
 import jakarta.inject.Singleton
 import org.reactivestreams.Publisher
@@ -64,6 +65,31 @@ class MalformedUriSpec extends Specification {
         result == 'Exception: Illegal character in path at index 17: /malformed-proxy/[]'
     }
 
+    void "header too long"() {
+        given:
+        OncePerFilter filter = embeddedServer.applicationContext.getBean(OncePerFilter)
+        filter.filterCalled = false
+
+        MalformedUriFilter newFilter = embeddedServer.applicationContext.getBean(MalformedUriFilter)
+        newFilter.preMatchingCalled = false
+
+        def connection = new URL("$embeddedServer.URL/malformed-proxy/xyz").openConnection()
+        connection.setRequestProperty("foo", "b".repeat(9000))
+
+        when:
+        connection.inputStream
+        then:
+        thrown IOException
+
+        when:
+        def result = ((HttpURLConnection) connection).errorStream.text
+
+        then:
+        result == '{"message":"Request Entity Too Large","_links":{"self":{"href":"/malformed-proxy/xyz","templated":false}},"_embedded":{"errors":[{"message":"Request Entity Too Large"}]}}'
+        !filter.filterCalled
+        !newFilter.preMatchingCalled
+    }
+
     @Requires(property = "spec.name", value = "MalformedUriSpec")
     @Controller('/malformed')
     static class SomeController {
@@ -97,10 +123,17 @@ class MalformedUriSpec extends Specification {
     @Singleton
     @ServerFilter("/malformed-proxy/**")
     static class MalformedUriFilter {
+        boolean preMatchingCalled
 
         @RequestFilter
         HttpResponse<?> filter(HttpRequest<?> request) {
             return HttpResponse.ok("ok: " + request.path)
         }
+
+        @RequestFilter
+        @PreMatching
+        void preMatching(HttpRequest<?> request) {
+            preMatchingCalled = false
+        }
     }
 }
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/filters/FilterBodySpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/filters/FilterBodySpec.groovy
index d8862ca935..b0b7c45f1f 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/filters/FilterBodySpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/filters/FilterBodySpec.groovy
@@ -73,6 +73,7 @@ class FilterBodySpec extends Specification {
         }
     }
 
+    @Requires(property = 'spec.name', value = 'FilterBodySpec')
     @Controller("/filter-body")
     static class MyController {
         @Post("/delayed-body-controller")
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/filters/FilterErrorSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/filters/FilterErrorSpec.groovy
index f1ddbe3625..f8bb4e573b 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/filters/FilterErrorSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/filters/FilterErrorSpec.groovy
@@ -31,7 +31,7 @@ import java.util.concurrent.atomic.AtomicReference
 class FilterErrorSpec extends Specification {
 
     void "test errors emitted from filters interacting with exception handlers"() {
-        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['spec.name': FilterErrorSpec.simpleName])
+        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['main.name': FilterErrorSpec.simpleName, 'spec.name': FilterErrorSpec.simpleName])
         def ctx = server.applicationContext
         HttpClient client = ctx.createBean(HttpClient, server.getURL())
         First first = ctx.getBean(First)
@@ -78,7 +78,7 @@ class FilterErrorSpec extends Specification {
     }
 
     void "test non once per request filter throwing error does not loop"() {
-        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['spec.name': FilterErrorSpec.simpleName + '2'])
+        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['main.name': FilterErrorSpec.simpleName, 'spec.name': FilterErrorSpec.simpleName + '2'])
         def ctx = server.applicationContext
         HttpClient client = ctx.createBean(HttpClient, server.getURL())
         FirstEvery filter = ctx.getBean(FirstEvery)
@@ -104,7 +104,7 @@ class FilterErrorSpec extends Specification {
     }
 
     void "test non once per request filter throwing error directly does not loop"() {
-        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['spec.name': FilterErrorSpec.simpleName + '2b'])
+        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['main.name': FilterErrorSpec.simpleName, 'spec.name': FilterErrorSpec.simpleName + '2b'])
         def ctx = server.applicationContext
         HttpClient client = ctx.createBean(HttpClient, server.getURL())
 
@@ -128,7 +128,7 @@ class FilterErrorSpec extends Specification {
     }
 
     void "test filter throwing exception handled by exception handler throwing exception"() {
-        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['spec.name': FilterErrorSpec.simpleName + '3'])
+        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['main.name': FilterErrorSpec.simpleName, 'spec.name': FilterErrorSpec.simpleName + '3'])
         def ctx = server.applicationContext
         HttpClient client = ctx.createBean(HttpClient, server.getURL())
         ExceptionException filter = ctx.getBean(ExceptionException)
@@ -156,7 +156,7 @@ class FilterErrorSpec extends Specification {
     }
 
     void "test the error route is the route match"() {
-        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['spec.name': FilterErrorSpec.simpleName + '4'])
+        EmbeddedServer server = ApplicationContext.run(EmbeddedServer, ['main.name': FilterErrorSpec.simpleName, 'spec.name': FilterErrorSpec.simpleName + '4'])
         def ctx = server.applicationContext
         HttpClient client = ctx.createBean(HttpClient, server.getURL())
         ExceptionRoute filter = ctx.getBean(ExceptionRoute)
@@ -301,6 +301,7 @@ class FilterErrorSpec extends Specification {
         }
     }
 
+    @Requires(property = 'main.name', value = 'FilterErrorSpec')
     @Controller("/filter-error-spec")
     static class NeverReachedController {
 
@@ -311,6 +312,7 @@ class FilterErrorSpec extends Specification {
 
     }
 
+    @Requires(property = 'main.name', value = 'FilterErrorSpec')
     @Controller("/filter-error-spec-3")
     static class HandledByHandlerController {
 
@@ -321,6 +323,7 @@ class FilterErrorSpec extends Specification {
 
     }
 
+    @Requires(property = 'main.name', value = 'FilterErrorSpec')
     @Controller("/filter-error-spec-4")
     static class HandledByErrorRouteController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/handler/Http2ServerHandlerSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/handler/Http2ServerHandlerSpec.groovy
index faa6659d5b..5e25baef3d 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/handler/Http2ServerHandlerSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/handler/Http2ServerHandlerSpec.groovy
@@ -5,9 +5,10 @@ import io.micronaut.core.annotation.NonNull
 import io.micronaut.http.body.CloseableByteBody
 import io.micronaut.http.body.InternalByteBody
 import io.micronaut.http.body.stream.InputStreamByteBody
+import io.micronaut.http.netty.body.AvailableNettyByteBody
+import io.micronaut.http.netty.body.NettyByteBody
 import io.micronaut.http.server.netty.EmbeddedTestUtil
-import io.micronaut.http.server.netty.body.AvailableNettyByteBody
-import io.micronaut.http.server.netty.body.NettyByteBody
+import io.micronaut.http.server.netty.body.NettyBodyAdapter
 import io.netty.buffer.ByteBuf
 import io.netty.buffer.ByteBufAllocator
 import io.netty.buffer.CompositeByteBuf
@@ -15,11 +16,7 @@ import io.netty.buffer.Unpooled
 import io.netty.channel.ChannelHandlerContext
 import io.netty.channel.embedded.EmbeddedChannel
 import io.netty.handler.codec.http.DefaultFullHttpResponse
-import io.netty.handler.codec.http.DefaultHttpContent
-import io.netty.handler.codec.http.DefaultHttpHeaders
 import io.netty.handler.codec.http.DefaultHttpResponse
-import io.netty.handler.codec.http.EmptyHttpHeaders
-import io.netty.handler.codec.http.HttpContent
 import io.netty.handler.codec.http.HttpHeaderNames
 import io.netty.handler.codec.http.HttpHeaderValues
 import io.netty.handler.codec.http.HttpMethod
@@ -118,7 +115,7 @@ class Http2ServerHandlerSpec extends Specification {
                 Assertions.assertEquals("/", request.uri())
                 Assertions.assertEquals("yawk.at", request.headers().getAsString(HttpHeaderNames.HOST))
 
-                outboundAccess.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.EMPTY_BUFFER, new DefaultHttpHeaders().add(HttpHeaderNames.CONTENT_LENGTH, 0), EmptyHttpHeaders.INSTANCE))
+                outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), AvailableNettyByteBody.empty())
             }
 
             @Override
@@ -248,15 +245,15 @@ class Http2ServerHandlerSpec extends Specification {
 
     def "download backpressure"() {
         given:
-        Subscriber<? super HttpContent> subscriber = null
+        Subscriber<? super ByteBuf> subscriber = null
         long demand = 0
         def (server, client, duplexHandler) = configure(new RequestHandler() {
             @Override
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 body.close()
-                outboundAccess.writeStreamed(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), new Publisher<HttpContent>() {
+                outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), NettyBodyAdapter.adapt(new Publisher<ByteBuf>() {
                     @Override
-                    void subscribe(Subscriber<? super HttpContent> s) {
+                    void subscribe(Subscriber<? super ByteBuf> s) {
                         subscriber = s
                         s.onSubscribe(new Subscription() {
                             @Override
@@ -270,7 +267,7 @@ class Http2ServerHandlerSpec extends Specification {
                             }
                         })
                     }
-                })
+                }, ctx.channel().eventLoop()))
             }
 
             @Override
@@ -297,7 +294,7 @@ class Http2ServerHandlerSpec extends Specification {
         when: "we satisfy the demand for body data"
         def windowSize = duplexHandler.frameCodec.connection().remote().flowController().windowSize(duplexHandler.frameCodec.connection().stream(stream1.id()))
         def data1 = randomData(windowSize)
-        subscriber.onNext(new DefaultHttpContent(data1.retainedSlice()))
+        subscriber.onNext(data1.retainedSlice())
         demand--
         EmbeddedTestUtil.advance(server, client)
         then: "first data is fully written & received, so there is new demand. window is now empty"
@@ -306,7 +303,7 @@ class Http2ServerHandlerSpec extends Specification {
 
         when: "we satisfy the demand for body data"
         def data2 = randomData(100)
-        subscriber.onNext(new DefaultHttpContent(data2.retainedSlice()))
+        subscriber.onNext(data2.retainedSlice())
         demand--
         EmbeddedTestUtil.advance(server, client)
         then: "because window is empty, data2 is not written -> no new demand"
@@ -322,7 +319,7 @@ class Http2ServerHandlerSpec extends Specification {
 
         when: "we satisfy the demand for more data"
         def data3 = randomData(50000)
-        subscriber.onNext(new DefaultHttpContent(data3.retainedSlice()))
+        subscriber.onNext(data3.retainedSlice())
         demand--
         EmbeddedTestUtil.advance(server, client)
         then: "we receive data3 fully, because it is smaller than window size"
@@ -492,14 +489,14 @@ class Http2ServerHandlerSpec extends Specification {
 
     def "download exception"(Exception exception, Http2Error expectedCode) {
         given:
-        Subscriber<? super HttpContent> subscriber = null
+        Subscriber<? super ByteBuf> subscriber = null
         def (server, client, duplexHandler) = configure(new RequestHandler() {
             @Override
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 body.close()
-                outboundAccess.writeStreamed(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), new Publisher<HttpContent>() {
+                outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), NettyBodyAdapter.adapt(new Publisher<ByteBuf>() {
                     @Override
-                    void subscribe(Subscriber<? super HttpContent> s) {
+                    void subscribe(Subscriber<? super ByteBuf> s) {
                         subscriber = s
                         s.onSubscribe(new Subscription() {
                             @Override
@@ -511,7 +508,7 @@ class Http2ServerHandlerSpec extends Specification {
                             }
                         })
                     }
-                })
+                }, ctx.channel().eventLoop()))
             }
 
             @Override
@@ -536,7 +533,7 @@ class Http2ServerHandlerSpec extends Specification {
 
         when: "send some data"
         def data1 = randomData(100)
-        subscriber.onNext(new DefaultHttpContent(data1.retainedSlice()))
+        subscriber.onNext(data1.retainedSlice())
         EmbeddedTestUtil.advance(server, client)
         then: "data is received"
         duplexHandler.received.readSlice(duplexHandler.received.readableBytes()) == data1
@@ -601,7 +598,7 @@ class Http2ServerHandlerSpec extends Specification {
         client.readInbound() == null
 
         when:"response can still be sent"
-        oa.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK))
+        oa.write(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), AvailableNettyByteBody.empty())
         EmbeddedTestUtil.advance(server, client)
         then:"we get the response but then a reset"
         Http2HeadersFrame response = client.readInbound()
@@ -621,16 +618,16 @@ class Http2ServerHandlerSpec extends Specification {
 
     def "download cancelled by client"() {
         given:
-        Subscriber<? super HttpContent> subscriber = null
+        Subscriber<? super ByteBuf> subscriber = null
         long demand = 0
         boolean cancelled = false
         def (server, client, duplexHandler) = configure(new RequestHandler() {
             @Override
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 body.close()
-                outboundAccess.writeStreamed(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), new Publisher<HttpContent>() {
+                outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), NettyBodyAdapter.adapt(new Publisher<ByteBuf>() {
                     @Override
-                    void subscribe(Subscriber<? super HttpContent> s) {
+                    void subscribe(Subscriber<? super ByteBuf> s) {
                         subscriber = s
                         s.onSubscribe(new Subscription() {
                             @Override
@@ -644,7 +641,7 @@ class Http2ServerHandlerSpec extends Specification {
                             }
                         })
                     }
-                })
+                }, ctx.channel().eventLoop()))
             }
 
             @Override
@@ -664,11 +661,11 @@ class Http2ServerHandlerSpec extends Specification {
         EmbeddedTestUtil.advance(server, client)
         def windowSize = duplexHandler.frameCodec.connection().remote().flowController().windowSize(duplexHandler.frameCodec.connection().stream(stream1.id()))
         def data1 = randomData(windowSize)
-        subscriber.onNext(new DefaultHttpContent(data1.retainedSlice()))
+        subscriber.onNext(data1.retainedSlice())
         demand--
         EmbeddedTestUtil.advance(server, client)
         def data2 = randomData(100)
-        subscriber.onNext(new DefaultHttpContent(data2.retainedSlice()))
+        subscriber.onNext(data2.retainedSlice())
         demand--
         EmbeddedTestUtil.advance(server, client)
         then: "we get the response headers, and a demand for body data"
@@ -736,7 +733,7 @@ class Http2ServerHandlerSpec extends Specification {
                 Assertions.assertEquals("/", request.uri())
                 Assertions.assertEquals("yawk.at", request.headers().getAsString(HttpHeaderNames.HOST))
 
-                outboundAccess.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, Unpooled.EMPTY_BUFFER, new DefaultHttpHeaders().add(HttpHeaderNames.CONTENT_LENGTH, 0), EmptyHttpHeaders.INSTANCE))
+                outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), AvailableNettyByteBody.empty())
             }
 
             @Override
@@ -781,7 +778,7 @@ class Http2ServerHandlerSpec extends Specification {
 
                 InternalByteBody.bufferFlow(body).onComplete((imm, t) -> {
                     def bb = AvailableNettyByteBody.toByteBuf(imm)
-                    outboundAccess.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, bb, new DefaultHttpHeaders().add(HttpHeaderNames.CONTENT_LENGTH, bb.readableBytes()), EmptyHttpHeaders.INSTANCE))
+                    outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK), new AvailableNettyByteBody(bb))
                 })
             }
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/handler/PipeliningServerHandlerSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/handler/PipeliningServerHandlerSpec.groovy
index 4a2e7b706c..3f7860ee17 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/handler/PipeliningServerHandlerSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/handler/PipeliningServerHandlerSpec.groovy
@@ -2,8 +2,11 @@ package io.micronaut.http.server.netty.handler
 
 import io.micronaut.core.io.buffer.ByteBuffer
 import io.micronaut.http.body.AvailableByteBody
+import io.micronaut.http.body.ByteBody
 import io.micronaut.http.body.CloseableAvailableByteBody
 import io.micronaut.http.body.CloseableByteBody
+import io.micronaut.http.netty.body.AvailableNettyByteBody
+import io.micronaut.http.server.netty.body.NettyBodyAdapter
 import io.netty.buffer.ByteBuf
 import io.netty.buffer.CompositeByteBuf
 import io.netty.buffer.Unpooled
@@ -21,8 +24,9 @@ import io.netty.handler.codec.http.DefaultHttpContent
 import io.netty.handler.codec.http.DefaultHttpRequest
 import io.netty.handler.codec.http.DefaultHttpResponse
 import io.netty.handler.codec.http.DefaultLastHttpContent
+import io.netty.handler.codec.http.EmptyHttpHeaders
 import io.netty.handler.codec.http.FullHttpRequest
-import io.netty.handler.codec.http.HttpContent
+import io.netty.handler.codec.http.FullHttpResponse
 import io.netty.handler.codec.http.HttpHeaderNames
 import io.netty.handler.codec.http.HttpHeaderValues
 import io.netty.handler.codec.http.HttpMethod
@@ -45,12 +49,12 @@ class PipeliningServerHandlerSpec extends Specification {
     def 'pipelined requests have their responses batched'() {
         given:
         def mon = new MonitorHandler()
-        def resp = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT)
+        def resp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT)
         def ch = new EmbeddedChannel(mon, new PipeliningServerHandler(new RequestHandler() {
             @Override
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 body.close()
-                outboundAccess.writeFull(resp)
+                outboundAccess.write(resp, AvailableNettyByteBody.empty())
             }
 
             @Override
@@ -80,8 +84,8 @@ class PipeliningServerHandlerSpec extends Specification {
         then:
         mon.read == 2
         mon.flush == 1
-        ch.readOutbound() == resp
-        ch.readOutbound() == resp
+        ch.readOutbound() == toFull(resp)
+        ch.readOutbound() == toFull(resp)
         ch.readOutbound() == null
         ch.checkException()
     }
@@ -91,12 +95,12 @@ class PipeliningServerHandlerSpec extends Specification {
         def mon = new MonitorHandler()
         def resp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK)
         resp.headers().add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED)
-        def sink = Sinks.many().unicast().<HttpContent>onBackpressureBuffer()
+        def sink = Sinks.many().unicast().<ByteBuf>onBackpressureBuffer()
         def ch = new EmbeddedChannel(mon, new PipeliningServerHandler(new RequestHandler() {
             @Override
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 body.close()
-                outboundAccess.writeStreamed(resp, sink.asFlux())
+                outboundAccess.write(resp, NettyBodyAdapter.adapt(sink.asFlux(), ctx.channel().eventLoop()))
             }
 
             @Override
@@ -117,22 +121,22 @@ class PipeliningServerHandlerSpec extends Specification {
         mon.flush == 0
 
         when:
-        def c1 = new DefaultHttpContent(Unpooled.wrappedBuffer("foo".getBytes(StandardCharsets.UTF_8)))
+        def c1 = Unpooled.wrappedBuffer("foo".getBytes(StandardCharsets.UTF_8))
         sink.tryEmitNext(c1)
         then:
         mon.read == 2
         mon.flush == 1
         ch.readOutbound() instanceof HttpResponse
-        ch.readOutbound() == c1
+        ch.readOutbound() == new DefaultHttpContent(c1)
         ch.readOutbound() == null
 
         when:
-        def c2 = new DefaultHttpContent(Unpooled.wrappedBuffer("foo".getBytes(StandardCharsets.UTF_8)))
+        def c2 = Unpooled.wrappedBuffer("foo".getBytes(StandardCharsets.UTF_8))
         sink.tryEmitNext(c2)
         then:
         mon.read == 2
         mon.flush == 2
-        ch.readOutbound() == c2
+        ch.readOutbound() == new DefaultHttpContent(c2)
         ch.readOutbound() == null
         ch.checkException()
     }
@@ -140,13 +144,13 @@ class PipeliningServerHandlerSpec extends Specification {
     def 'requests that come in a single packet are accumulated'() {
         given:
         def mon = new MonitorHandler()
-        def resp = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT)
+        def resp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT)
         def ch = new EmbeddedChannel(mon, new PipeliningServerHandler(new RequestHandler() {
             @Override
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 assert body instanceof AvailableByteBody
                 assert new String(body.toByteArray(), StandardCharsets.UTF_8) == "foobar"
-                outboundAccess.writeFull(resp)
+                outboundAccess.write(resp, AvailableNettyByteBody.empty())
             }
 
             @Override
@@ -171,18 +175,22 @@ class PipeliningServerHandlerSpec extends Specification {
         ch.checkException()
         mon.read == 2
         mon.flush == 1
-        ch.readOutbound() == resp
+        ch.readOutbound() == toFull(resp)
         ch.readOutbound() == null
     }
 
+    static FullHttpResponse toFull(HttpResponse response) {
+        return new DefaultFullHttpResponse(response.protocolVersion, response.status, Unpooled.EMPTY_BUFFER, response.headers(), EmptyHttpHeaders.INSTANCE)
+    }
+
     def 'continue support'() {
         given:
         def mon = new MonitorHandler()
-        def resp = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT)
+        def resp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT)
         def ch = new EmbeddedChannel(mon, new PipeliningServerHandler(new RequestHandler() {
             @Override
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
-                Flux.from(body.toByteArrayPublisher()).collectList().subscribe { outboundAccess.writeFull(resp) }
+                Flux.from(body.toByteArrayPublisher()).collectList().subscribe { outboundAccess.write(resp, AvailableNettyByteBody.empty()) }
             }
 
             @Override
@@ -208,7 +216,7 @@ class PipeliningServerHandlerSpec extends Specification {
         when:
         ch.writeInbound(new DefaultLastHttpContent(Unpooled.wrappedBuffer("foo".getBytes(StandardCharsets.UTF_8))))
         then:
-        ch.readOutbound() == resp
+        ch.readOutbound() == toFull(resp)
         ch.readOutbound() == null
     }
 
@@ -216,7 +224,7 @@ class PipeliningServerHandlerSpec extends Specification {
     def 'nested write'() {
         given:
         def mon = new MonitorHandler()
-        def resp = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT)
+        def resp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT)
         def ch = new EmbeddedChannel(mon, new ChannelOutboundHandlerAdapter() {
             @Override
             void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
@@ -227,7 +235,7 @@ class PipeliningServerHandlerSpec extends Specification {
             @Override
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 body.close()
-                outboundAccess.writeFull(resp)
+                outboundAccess.write(resp, AvailableNettyByteBody.empty())
             }
 
             @Override
@@ -247,7 +255,7 @@ class PipeliningServerHandlerSpec extends Specification {
         ch.checkException()
         mon.read == 2
         mon.flush == 1
-        ch.readOutbound() == resp
+        ch.readOutbound() == toFull(resp)
         ch.readOutbound() == null
     }
 
@@ -257,17 +265,17 @@ class PipeliningServerHandlerSpec extends Specification {
         def mon = new MonitorHandler()
         def resp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK)
         resp.headers().add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED)
-        def sink = Sinks.many().unicast().<HttpContent>onBackpressureBuffer()
+        def sink = Sinks.many().unicast().<ByteBuf>onBackpressureBuffer()
         def cleaned = 0
         def ch = new EmbeddedChannel(mon, new PipeliningServerHandler(new RequestHandler() {
             @Override
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 assert request instanceof FullHttpRequest
                 body.close()
-                outboundAccess.writeStreamed(resp, sink.asFlux().doOnCancel {
+                outboundAccess.write(resp, NettyBodyAdapter.adapt(sink.asFlux().doOnCancel {
                     // optional extra weirdness: onComplete *after* cancel. Could lead to double call to responseWritten, if I was an idiot.
                     if (completeOnCancel) sink.tryEmitComplete()
-                })
+                }, ctx.channel().eventLoop()))
             }
 
             @Override
@@ -285,12 +293,12 @@ class PipeliningServerHandlerSpec extends Specification {
         def req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/", Unpooled.EMPTY_BUFFER)
         ch.writeOneInbound(req)
         ch.flushInbound()
-        def c1 = new DefaultHttpContent(Unpooled.copiedBuffer("foo", StandardCharsets.UTF_8))
+        def c1 = Unpooled.copiedBuffer("foo", StandardCharsets.UTF_8)
         sink.emitNext(c1, Sinks.EmitFailureHandler.FAIL_FAST)
         then:
         ch.checkException()
         ch.readOutbound() == resp
-        ch.readOutbound() == c1
+        ch.readOutbound() == new DefaultHttpContent(c1)
 
         when:
         ch.close()
@@ -327,7 +335,7 @@ class PipeliningServerHandlerSpec extends Specification {
 
                     @Override
                     void onComplete() {
-                        outboundAccess.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT))
+                        outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT), AvailableNettyByteBody.empty())
                     }
                 })
             }
@@ -373,7 +381,7 @@ class PipeliningServerHandlerSpec extends Specification {
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 req = request
                 ibb = body
-                outboundAccess.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT))
+                outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT), AvailableNettyByteBody.empty())
             }
 
             @Override
@@ -425,7 +433,7 @@ class PipeliningServerHandlerSpec extends Specification {
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 req = request
                 ibb = body
-                outboundAccess.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT))
+                outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT), AvailableNettyByteBody.empty())
             }
 
             @Override
@@ -476,7 +484,7 @@ class PipeliningServerHandlerSpec extends Specification {
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 req = request
                 sbb = body
-                outboundAccess.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT))
+                outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT), AvailableNettyByteBody.empty())
             }
 
             @Override
@@ -529,7 +537,7 @@ class PipeliningServerHandlerSpec extends Specification {
         given:
         def resp = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK)
         resp.headers().add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED)
-        def sink = Sinks.many().unicast().<HttpContent>onBackpressureBuffer()
+        def sink = Sinks.many().unicast().<ByteBuf>onBackpressureBuffer()
         def ch = new EmbeddedChannel(new PipeliningServerHandler(new RequestHandler() {
             int i = 0
 
@@ -537,9 +545,9 @@ class PipeliningServerHandlerSpec extends Specification {
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 body.close()
                 if (i++ == 0) {
-                    outboundAccess.writeStreamed(resp, sink.asFlux())
+                    outboundAccess.write(resp, NettyBodyAdapter.adapt(sink.asFlux(), ctx.channel().eventLoop()))
                 } else {
-                    outboundAccess.writeStreamed(resp, Flux.empty())
+                    outboundAccess.write(resp, NettyBodyAdapter.adapt(Flux.empty(), ctx.channel().eventLoop()))
                 }
             }
 
@@ -573,7 +581,7 @@ class PipeliningServerHandlerSpec extends Specification {
             void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
                 unwritten++
                 body.close()
-                outboundAccess.writeFull(new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT))
+                outboundAccess.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.NO_CONTENT), AvailableNettyByteBody.empty())
             }
 
             @Override
@@ -604,6 +612,38 @@ class PipeliningServerHandlerSpec extends Specification {
         unwritten == 0
     }
 
+    def 'reentrant close'() {
+        given:
+        def resp = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK)
+        resp.headers().add(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED)
+        def ch = new EmbeddedChannel(new PipeliningServerHandler(new RequestHandler() {
+            @Override
+            void accept(ChannelHandlerContext ctx, HttpRequest request, CloseableByteBody body, OutboundAccess outboundAccess) {
+                def split = body.split(ByteBody.SplitBackpressureMode.FASTEST)
+                Flux.from(split.toByteArrayPublisher())
+                    .subscribe {
+                        body.close()
+                        outboundAccess.writeFull(resp)
+                    }
+            }
+
+            @Override
+            void handleUnboundError(Throwable cause) {
+                cause.printStackTrace()
+            }
+        }))
+
+
+        def request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, "/")
+        request.headers().add(HttpHeaderNames.CONTENT_LENGTH, 3)
+        when:
+        ch.writeInbound(request)
+        ch.writeInbound(new DefaultLastHttpContent(Unpooled.copiedBuffer("foo", StandardCharsets.UTF_8)))
+
+        then:
+        ch.checkException()
+    }
+
     static class MonitorHandler extends ChannelOutboundHandlerAdapter {
         int flush = 0
         int read = 0
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/http2/Http2Java11ClientSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/http2/Http2Java11ClientSpec.groovy
index 8bcc6aff68..6f7ebfd81e 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/http2/Http2Java11ClientSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/http2/Http2Java11ClientSpec.groovy
@@ -1,12 +1,16 @@
 package io.micronaut.http.server.netty.http2
 
 import io.micronaut.context.annotation.Property
-import io.micronaut.http.annotation.*
+import io.micronaut.context.annotation.Requires
+import io.micronaut.http.annotation.Body
+import io.micronaut.http.annotation.Consumes
+import io.micronaut.http.annotation.Controller
+import io.micronaut.http.annotation.Get
+import io.micronaut.http.annotation.Put
 import io.micronaut.runtime.server.EmbeddedServer
 import io.micronaut.test.extensions.spock.annotation.MicronautTest
 import jakarta.inject.Inject
 import spock.lang.Issue
-import spock.lang.Requires
 import spock.lang.Specification
 
 import javax.net.ssl.SSLContext
@@ -23,6 +27,7 @@ import static java.time.Duration.ofSeconds
 import static java.util.concurrent.CompletableFuture.supplyAsync
 
 @MicronautTest
+@Property(name = "spec.name", value = "Http2Java11ClientSpec")
 @Property(name = "micronaut.server.http-version", value = "2.0")
 @Property(name = "micronaut.server.ssl.enabled", value = "true")
 @Property(name = "micronaut.server.ssl.port", value = "-1")
@@ -122,6 +127,7 @@ class Http2Java11ClientSpec extends Specification {
         return context
     }
 
+    @Requires(property = "spec.name", value = "Http2Java11ClientSpec")
     @Controller('/http2/java11')
     static class ExampleController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/http2/Http2PostTest.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/http2/Http2PostTest.java
index 585af18118..e6875f4358 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/http2/Http2PostTest.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/http2/Http2PostTest.java
@@ -35,6 +35,7 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 
 @MicronautTest
+@Property(name = "spec.name", value = "Http2PostTest")
 @Property(name = "micronaut.server.http-version", value = "2.0")
 @Property(name = "micronaut.server.netty.log-level", value = "TRACE")
 @Property(name = "micronaut.http.client.log-level", value = "TRACE")
@@ -131,6 +132,7 @@ public class Http2PostTest implements TestPropertyProvider {
         );
     }
 
+    @Requires(property = "spec.name", value = "Http2PostTest")
     @Controller("/vertx/demo")
     public static class DemoController {
         @Get("/testGet")
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/ContextPathFilter.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/ContextPathFilter.java
index f84efeef9d..cb6da7238f 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/ContextPathFilter.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/ContextPathFilter.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.interceptor;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MutableHttpResponse;
@@ -26,6 +27,7 @@ import org.reactivestreams.Publisher;
 /**
  * Tests filters with the context path already prepended still work
  */
+@Requires(property = "tests", value = "io.micronaut.http.server.netty.interceptor")
 @Filter("/context/path/**")
 public class ContextPathFilter implements HttpServerFilter {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/FirstFilter.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/FirstFilter.java
index b4a65edd61..30081c7ed7 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/FirstFilter.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/FirstFilter.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.interceptor;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpResponse;
@@ -28,6 +29,7 @@ import org.spockframework.util.Assert;
  * @author Graeme Rocher
  * @since 1.0
  */
+@Requires(property = "tests", value = "io.micronaut.http.server.netty.interceptor")
 @Filter("/secure**")
 public class FirstFilter implements HttpFilter {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/HttpFilterContextPathSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/HttpFilterContextPathSpec.groovy
index 65d39a1866..e4beec5183 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/HttpFilterContextPathSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/HttpFilterContextPathSpec.groovy
@@ -11,7 +11,7 @@ class HttpFilterContextPathSpec extends AbstractMicronautSpec {
 
     @Override
     Map<String, Object> getConfiguration() {
-        super.getConfiguration() << ['micronaut.server.context-path': '/context/path']
+        super.getConfiguration() << ['micronaut.server.context-path': '/context/path', 'tests': "io.micronaut.http.server.netty.interceptor"]
     }
 
     void "test interceptor execution and order - proceed"() {
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/HttpFilterSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/HttpFilterSpec.groovy
index 20c03e3e4d..7fc9ac02fa 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/HttpFilterSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/HttpFilterSpec.groovy
@@ -43,6 +43,7 @@ import spock.lang.Specification
  */
 @MicronautTest
 @Property(name = 'spec.name', value = "HttpFilterSpec")
+@Property(name = 'tests', value = "io.micronaut.http.server.netty.interceptor")
 class HttpFilterSpec extends Specification {
 
     @Inject
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/SecondFilter.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/SecondFilter.java
index 76a12825f7..6a24202e88 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/SecondFilter.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/SecondFilter.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.interceptor;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.convert.value.MutableConvertibleValues;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpResponse;
@@ -28,6 +29,7 @@ import org.spockframework.util.Assert;
  * @author Graeme Rocher
  * @since 1.0
  */
+@Requires(property = "tests", value = "io.micronaut.http.server.netty.interceptor")
 @Filter("/secure**")
 public class SecondFilter implements HttpFilter {
     @Override
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/SecureController.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/SecureController.java
index 4c9116dc0d..399b340eb4 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/SecureController.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/SecureController.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.interceptor;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.http.HttpResponse;
 import io.micronaut.http.annotation.Controller;
 import io.micronaut.http.annotation.Get;
@@ -23,6 +24,7 @@ import io.micronaut.http.annotation.Get;
  * @author Graeme Rocher
  * @since 1.0
  */
+@Requires(property = "tests", value = "io.micronaut.http.server.netty.interceptor")
 @Controller("/secure")
 public class SecureController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/TestReactiveFilter.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/TestReactiveFilter.java
index 93ea6e6d88..f417e247dc 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/TestReactiveFilter.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/TestReactiveFilter.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.interceptor;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MutableHttpResponse;
 import io.micronaut.http.annotation.Filter;
@@ -27,6 +28,7 @@ import reactor.core.publisher.Flux;
  * @author Graeme Rocher
  * @since 1.0
  */
+@Requires(property = "tests", value = "io.micronaut.http.server.netty.interceptor")
 @Filter("/secure**")
 public class TestReactiveFilter implements HttpServerFilter{
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/TestSecurityFilter.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/TestSecurityFilter.java
index 46c4003739..200593d3c4 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/TestSecurityFilter.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/interceptor/TestSecurityFilter.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.interceptor;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpResponse;
@@ -30,6 +31,7 @@ import org.spockframework.util.Assert;
  * @author Graeme Rocher
  * @since 1.0
  */
+@Requires(property = "tests", value = "io.micronaut.http.server.netty.interceptor")
 @Filter("/secure**")
 public class TestSecurityFilter implements HttpServerFilter {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/java/ParameterController.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/java/ParameterController.java
index 274f780d44..3fafc8c035 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/java/ParameterController.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/java/ParameterController.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.java;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.http.HttpParameters;
 import io.micronaut.http.MediaType;
@@ -31,6 +32,7 @@ import java.util.Optional;
  * @author Graeme Rocher
  * @since 1.0
  */
+@Requires(property = "spec.name", value = "ParameterBindingSpec")
 @Controller("/java/parameter")
 public class ParameterController {
     @Get
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/java/ResponseController.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/java/ResponseController.java
index ad53bac361..ace30d9c65 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/java/ResponseController.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/java/ResponseController.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.java;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.http.HttpMessage;
 import io.micronaut.http.HttpMethod;
 import io.micronaut.http.HttpResponse;
@@ -29,6 +30,7 @@ import java.util.Optional;
  * @author Graeme Rocher
  * @since 1.0
  */
+@Requires(property = "spec.name", value = "ParameterBindingSpec")
 @Controller("/java/response")
 public class ResponseController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/LinuxNativeTransportSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/LinuxNativeTransportSpec.groovy
index 4e756a3ae2..e2aa6eea93 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/LinuxNativeTransportSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/LinuxNativeTransportSpec.groovy
@@ -25,6 +25,6 @@ class LinuxNativeTransportSpec extends AbstractMicronautSpec {
 
     @Override
     Map<String, Object> getConfiguration() {
-        super.getConfiguration() << ['micronaut.server.netty.use-native-transport': true]
+        super.getConfiguration() << ['micronaut.server.netty.use-native-transport': true, 'spec': 'TransportSpec']
     }
 }
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/MacNativeTransportSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/MacNativeTransportSpec.groovy
index 8884e6ac92..ff5152236a 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/MacNativeTransportSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/MacNativeTransportSpec.groovy
@@ -27,6 +27,6 @@ class MacNativeTransportSpec extends AbstractMicronautSpec {
 
     @Override
     Map<String, Object> getConfiguration() {
-        super.getConfiguration() << ['micronaut.server.netty.use-native-transport': true]
+        super.getConfiguration() << ['micronaut.server.netty.use-native-transport': true, 'spec': 'TransportSpec']
     }
 }
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/NativeTransportController.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/NativeTransportController.java
index 6aca3520d0..a24759f034 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/NativeTransportController.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/nativetransport/NativeTransportController.java
@@ -15,9 +15,11 @@
  */
 package io.micronaut.http.server.netty.nativetransport;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.http.annotation.Controller;
 import io.micronaut.http.annotation.Get;
 
+@Requires(property = "spec", value = "TransportSpec")
 @Controller("/native-transport")
 public class NativeTransportController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/redirect/RedirectSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/redirect/RedirectSpec.groovy
index b8ab8efa0b..442f211dc2 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/redirect/RedirectSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/redirect/RedirectSpec.groovy
@@ -16,6 +16,7 @@
 package io.micronaut.http.server.netty.redirect
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpHeaders
 import io.micronaut.http.HttpResponse
 import io.micronaut.http.HttpStatus
@@ -34,7 +35,7 @@ import spock.lang.Specification
  */
 class RedirectSpec extends Specification {
 
-    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer)
+    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'RedirectSpec'])
     @Shared @AutoCleanup HttpClient httpClient = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURL(), new DefaultHttpClientConfiguration(followRedirects: false))
 
     void 'test permanent redirect'() {
@@ -57,6 +58,7 @@ class RedirectSpec extends Specification {
         !response.header(HttpHeaders.CONTENT_TYPE)
     }
 
+    @Requires(property = 'spec.name', value = 'RedirectSpec')
     @Controller("/redirect")
     static class RedirectController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/KeyValue.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/KeyValue.java
new file mode 100644
index 0000000000..95636a5db7
--- /dev/null
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/KeyValue.java
@@ -0,0 +1,26 @@
+package io.micronaut.http.server.netty.routing;
+
+import io.micronaut.core.annotation.Creator;
+import io.micronaut.core.annotation.Introspected;
+
+@Introspected
+public class KeyValue {
+    private String key;
+    private String value;
+
+    @Creator
+    public static KeyValue of(String key, String value) {
+        final KeyValue keyValue = new KeyValue();
+        keyValue.key = key;
+        keyValue.value = value;
+        return keyValue;
+    }
+
+    public String getKey() {
+        return key;
+    }
+
+    public String getValue() {
+        return value;
+    }
+}
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/MyClient.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/MyClient.java
new file mode 100644
index 0000000000..50054668f1
--- /dev/null
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/MyClient.java
@@ -0,0 +1,23 @@
+package io.micronaut.http.server.netty.routing;
+
+import io.micronaut.http.annotation.Body;
+import io.micronaut.http.annotation.Get;
+import io.micronaut.http.annotation.Post;
+import io.micronaut.http.client.annotation.Client;
+
+import java.util.List;
+
+@Client("/")
+public interface MyClient {
+    @Post
+    KeyValue setRoot(@Body KeyValue body);
+
+    @Get
+    KeyValue getRoot();
+
+    @Get("/{id}")
+    KeyValue getId(String id);
+
+    @Get("/{id}/items")
+    List<KeyValue> getRelations(String id);
+}
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/MyController.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/MyController.java
new file mode 100644
index 0000000000..e9f918ec34
--- /dev/null
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/MyController.java
@@ -0,0 +1,37 @@
+package io.micronaut.http.server.netty.routing;
+
+import io.micronaut.context.annotation.Requires;
+import io.micronaut.http.annotation.Body;
+import io.micronaut.http.annotation.Controller;
+import io.micronaut.http.annotation.Get;
+import io.micronaut.http.annotation.Post;
+import io.micronaut.scheduling.TaskExecutors;
+import io.micronaut.scheduling.annotation.ExecuteOn;
+
+import java.util.List;
+
+@Requires(property = "spec.name", value = "RootRoutingTest")
+@Controller
+@ExecuteOn(TaskExecutors.BLOCKING)
+public class MyController {
+
+    @Post
+    public KeyValue createRoot(@Body KeyValue body) {
+        return body;
+    }
+
+    @Get
+    public KeyValue root() {
+        return KeyValue.of("hello", "world");
+    }
+
+    @Get("/{id}")
+    public KeyValue id(String id) {
+        return KeyValue.of("hello", id);
+    }
+
+    @Get("/{id}/items")
+    public List<KeyValue> items(String id) {
+        return List.of(KeyValue.of("hello", id), KeyValue.of("foo", "bar"));
+    }
+}
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/RootRoutingTest.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/RootRoutingTest.java
new file mode 100644
index 0000000000..79886d6e99
--- /dev/null
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/routing/RootRoutingTest.java
@@ -0,0 +1,23 @@
+package io.micronaut.http.server.netty.routing;
+
+import io.micronaut.context.annotation.Property;
+import io.micronaut.test.extensions.junit5.annotation.MicronautTest;
+import jakarta.inject.Inject;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+@Property(name = "spec.name", value = "RootRoutingTest")
+@MicronautTest
+class RootRoutingTest {
+
+    @Inject
+    MyClient client;
+
+    @Test
+    void testRootEndpoint() {
+        KeyValue kv = client.getRoot();
+        Assertions.assertEquals("hello", kv.getKey());
+        Assertions.assertEquals("world", kv.getValue());
+    }
+
+}
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/ssl/DeprecatedSslConfigurationSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/ssl/DeprecatedSslConfigurationSpec.groovy
index 5b1b22ce29..8638a039bb 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/ssl/DeprecatedSslConfigurationSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/ssl/DeprecatedSslConfigurationSpec.groovy
@@ -1,6 +1,7 @@
 package io.micronaut.http.server.netty.ssl
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.context.env.Environment
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.annotation.Controller
@@ -25,6 +26,7 @@ class DeprecatedSslConfigurationSpec extends Specification {
     def "self signed certificate is generated for #type configuration #property"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, [
+                'spec.name': 'DeprecatedSslConfigurationSpec',
                 'micronaut.server.ssl.port'                                : -1,
                 'micronaut.server.ssl.enabled'                             : true,
                 'micronaut.http.client.ssl.insecure-trust-all-certificates': true,
@@ -57,6 +59,7 @@ class DeprecatedSslConfigurationSpec extends Specification {
     def "ssl port can be set with #type property #property"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, [
+                'spec.name': 'DeprecatedSslConfigurationSpec',
                 (property)                                                 : -1,
                 'micronaut.server.ssl.enabled'                             : true,
                 'micronaut.http.client.ssl.insecure-trust-all-certificates': true,
@@ -88,6 +91,7 @@ class DeprecatedSslConfigurationSpec extends Specification {
         "micronaut.server.ssl.port" | false     | 'moved'
     }
 
+    @Requires(property = 'spec.name', value = 'DeprecatedSslConfigurationSpec')
     @Controller("/cert")
     static class TestController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/ErrorResponseSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/ErrorResponseSpec.groovy
index c7d68a87ee..40e3a18f8d 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/ErrorResponseSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/ErrorResponseSpec.groovy
@@ -1,5 +1,7 @@
 package io.micronaut.http.server.netty.stream
 
+import io.micronaut.context.annotation.Property
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpStatus
 import io.micronaut.http.MediaType
 import io.micronaut.http.annotation.Controller
@@ -16,6 +18,7 @@ import spock.lang.Issue
 import spock.lang.Specification
 
 @Issue('https://github.com/micronaut-projects/micronaut-core/issues/4862')
+@Property(name = "spec.name", value = "ErrorResponseSpec")
 @MicronautTest
 class ErrorResponseSpec extends Specification {
     @Inject
@@ -33,12 +36,14 @@ class ErrorResponseSpec extends Specification {
         }
     }
 
+    @Requires(property = 'spec.name', value = 'ErrorResponseSpec')
     @Client("/flowable")
     static interface FlowableClient {
         @Get(uri = "/error", consumes = MediaType.TEXT_PLAIN)
         Foo flowableError()
     }
 
+    @Requires(property = 'spec.name', value = 'ErrorResponseSpec')
     @Controller("/flowable")
     static class FlowableErrorController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/FluxBodySpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/FluxBodySpec.groovy
index f25970dc0a..843f77de3e 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/FluxBodySpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/FluxBodySpec.groovy
@@ -1,6 +1,7 @@
 package io.micronaut.http.server.netty.stream
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.HttpResponse
 import io.micronaut.http.HttpStatus
@@ -19,7 +20,7 @@ import spock.lang.Specification
 
 class FluxBodySpec extends Specification {
 
-    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer)
+    @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'FluxBodySpec'])
     @Shared @AutoCleanup HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURI())
 
     void "test empty and non-empty flux"() {
@@ -40,6 +41,7 @@ class FluxBodySpec extends Specification {
         e.response.status() == HttpStatus.BAD_REQUEST
     }
 
+    @Requires(property = 'spec.name', value = 'FluxBodySpec')
     @Controller("/body/flux/test")
     static class ReactiveController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/FluxFullBodySpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/FluxFullBodySpec.groovy
index 0519b6a3a6..a6ef905d2a 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/FluxFullBodySpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stream/FluxFullBodySpec.groovy
@@ -1,12 +1,20 @@
 package io.micronaut.http.server.netty.stream
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.HttpRequest
+import io.micronaut.http.HttpResponse
 import io.micronaut.http.HttpStatus
+import io.micronaut.http.annotation.Body
+import io.micronaut.http.annotation.Controller
+import io.micronaut.http.annotation.Post
 import io.micronaut.http.client.HttpClient
 import io.micronaut.http.client.exceptions.HttpClientResponseException
 import io.micronaut.http.server.netty.configuration.NettyHttpServerConfiguration
 import io.micronaut.runtime.server.EmbeddedServer
+import org.reactivestreams.Publisher
+import reactor.core.publisher.Flux
+import reactor.core.publisher.Mono
 import spock.lang.AutoCleanup
 import spock.lang.Shared
 import spock.lang.Specification
@@ -15,7 +23,7 @@ class FluxFullBodySpec extends Specification {
 
     @Shared @AutoCleanup EmbeddedServer embeddedServer = ApplicationContext.run(
             EmbeddedServer,
-            ["micronaut.server.netty.server-type": NettyHttpServerConfiguration.HttpServerType.FULL_CONTENT]
+            ["micronaut.server.netty.server-type": NettyHttpServerConfiguration.HttpServerType.FULL_CONTENT, 'spec.name': FluxFullBodySpec.simpleName]
     )
     @Shared @AutoCleanup HttpClient client = embeddedServer.applicationContext.createBean(HttpClient, embeddedServer.getURI())
 
@@ -37,4 +45,15 @@ class FluxFullBodySpec extends Specification {
         e.response.status() == HttpStatus.BAD_REQUEST
     }
 
+    @Requires(property = 'spec.name', value = 'FluxFullBodySpec')
+    @Controller("/body/flux/test")
+    static class ReactiveController {
+
+        @Post("/")
+        Mono<HttpResponse<?>> read(@Body Publisher<String> body) {
+            return Flux.from(body).collectList()
+                    .map(list -> HttpResponse.ok(list))
+        }
+    }
+
 }
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/threading/ThreadSelectionSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/threading/ThreadSelectionSpec.groovy
index 0a371fd155..2255238ba8 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/threading/ThreadSelectionSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/threading/ThreadSelectionSpec.groovy
@@ -1,6 +1,7 @@
 package io.micronaut.http.server.netty.threading
 
 import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Requires
 import io.micronaut.core.annotation.Blocking
 import io.micronaut.core.annotation.NonBlocking
 import io.micronaut.http.HttpRequest
@@ -45,7 +46,7 @@ class ThreadSelectionSpec extends Specification {
 
     void "test thread selection strategy #strategy"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.thread-selection': strategy])
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec': getClass().getSimpleName(), 'micronaut.server.thread-selection': strategy])
         ThreadSelectionClient client = embeddedServer.applicationContext.getBean(ThreadSelectionClient)
 
         expect:
@@ -67,7 +68,7 @@ class ThreadSelectionSpec extends Specification {
 
     void "test thread selection strategy for reactive types #strategy"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.thread-selection': strategy])
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec': getClass().getSimpleName(), 'micronaut.server.thread-selection': strategy])
         ThreadSelectionClient client = embeddedServer.applicationContext.getBean(ThreadSelectionClient)
 
 
@@ -90,7 +91,7 @@ class ThreadSelectionSpec extends Specification {
 
     void "test thread selection for exception handlers #strategy"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.thread-selection': strategy])
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec': getClass().getSimpleName(), 'micronaut.server.thread-selection': strategy])
         ThreadSelectionClient client = embeddedServer.applicationContext.getBean(ThreadSelectionClient)
 
         when:
@@ -117,7 +118,7 @@ class ThreadSelectionSpec extends Specification {
     @Ignore // pending feature, only works sometimes: https://github.com/micronaut-projects/micronaut-core/pull/10104
     void "test thread selection for error route #strategy"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.thread-selection': strategy])
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec': getClass().getSimpleName(), 'micronaut.server.thread-selection': strategy])
         ThreadSelectionClient client = embeddedServer.applicationContext.getBean(ThreadSelectionClient)
 
         when:
@@ -140,7 +141,7 @@ class ThreadSelectionSpec extends Specification {
 
     void "test injecting an executor service does not inject the Netty event loop"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec': getClass().getSimpleName()])
         ApplicationContext ctx = embeddedServer.applicationContext
 
         when:
@@ -150,6 +151,7 @@ class ThreadSelectionSpec extends Specification {
         !ctx.getBeansOfType(ExecutorService).contains(eventLoopGroup)
     }
 
+    @Requires(property = "spec", value = "ThreadSelectionSpec")
     @Client("/thread-selection")
     static interface ThreadSelectionClient {
         @Get("/blocking")
@@ -189,6 +191,7 @@ class ThreadSelectionSpec extends Specification {
         String scheduleException()
     }
 
+    @Requires(property = "spec", value = "ThreadSelectionSpec")
     @Controller("/thread-selection")
     static class ThreadSelectionController {
         @Get("/blocking")
@@ -267,6 +270,7 @@ class ThreadSelectionSpec extends Specification {
         }
     }
 
+    @Requires(property = "spec", value = "ThreadSelectionSpec")
     @Filter("/thread-selection/alter**")
     static class ThreadSelectionFilter implements HttpServerFilter {
 
@@ -304,6 +308,7 @@ class ThreadSelectionSpec extends Specification {
         }
     }
 
+    @Requires(property = "spec", value = "ThreadSelectionSpec")
     @Singleton
     static class MyExceptionHandler implements ExceptionHandler<MyException, HttpResponse> {
 
@@ -313,6 +318,7 @@ class ThreadSelectionSpec extends Specification {
         }
     }
 
+    @Requires(property = "spec", value = "ThreadSelectionSpec")
     @Singleton
     static class MyScheduledExceptionHandler implements ExceptionHandler<MyExceptionScheduled, HttpResponse> {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryChatClientWebSocket.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryChatClientWebSocket.java
index 4d2ecf914d..78448507e9 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryChatClientWebSocket.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryChatClientWebSocket.java
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 package io.micronaut.http.server.netty.websocket;
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.async.annotation.SingleResult;
 import io.micronaut.websocket.WebSocketPongMessage;
 import io.micronaut.websocket.WebSocketSession;
@@ -32,6 +33,7 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Future;
 
+@Requires(property = "spec.name", value = "BinaryWebSocketSpec")
 @ClientWebSocket("/binary/chat/{topic}/{username}")
 public abstract class BinaryChatClientWebSocket implements AutoCloseable{
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryChatServerWebSocket.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryChatServerWebSocket.java
index 141e417db3..8c11987596 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryChatServerWebSocket.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryChatServerWebSocket.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.websocket;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.http.context.ServerRequestContext;
 import io.micronaut.websocket.WebSocketSession;
 import io.micronaut.websocket.annotation.OnClose;
@@ -24,6 +25,7 @@ import io.micronaut.websocket.annotation.ServerWebSocket;
 
 import java.util.Set;
 
+@Requires(property = "spec.name", value = "BinaryWebSocketSpec")
 @ServerWebSocket("/binary/chat/{topic}/{username}")
 public class BinaryChatServerWebSocket {
     @OnOpen
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryWebSocketSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryWebSocketSpec.groovy
index d83c9c5be0..448b49bfad 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryWebSocketSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/BinaryWebSocketSpec.groovy
@@ -44,7 +44,7 @@ class BinaryWebSocketSpec extends Specification {
 
     void "test binary websocket exchange"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.builder('micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.builder('spec.name': 'BinaryWebSocketSpec', 'micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
         PollingConditions conditions = new PollingConditions(timeout: 15, delay: 0.5)
 
         when: "a websocket connection is established"
@@ -118,7 +118,7 @@ class BinaryWebSocketSpec extends Specification {
 
     void "test sending multiple frames for a single message"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.builder('micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.builder('spec.name': 'BinaryWebSocketSpec', 'micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
         PollingConditions conditions = new PollingConditions(timeout: 15, delay: 0.5)
 
         when: "a websocket connection is established"
@@ -152,7 +152,7 @@ class BinaryWebSocketSpec extends Specification {
 
     void "test sending many continuation frames"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.builder('micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.builder('spec.name': 'BinaryWebSocketSpec', 'micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
         PollingConditions conditions = new PollingConditions(timeout: 15, delay: 0.5)
 
         when: "a websocket connection is established"
@@ -186,7 +186,7 @@ class BinaryWebSocketSpec extends Specification {
 
     void "test sending ping messages"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.builder('micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.builder('spec.name': 'BinaryWebSocketSpec', 'micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
         PollingConditions conditions = new PollingConditions(timeout: 15, delay: 0.5)
 
         when:"a websocket connection is established"
@@ -210,7 +210,8 @@ class BinaryWebSocketSpec extends Specification {
     void "test per-message compression"() {
         given:
         def ctx = ApplicationContext.run([
-                'spec.name'            : 'test per-message compression',
+                'spec.name': 'BinaryWebSocketSpec',
+                'method.name'            : 'test per-message compression',
                 'micronaut.server.port': -1
         ])
         def cdcServer = ctx.getBean(CompressionDetectionCustomizerServer)
@@ -267,7 +268,8 @@ class BinaryWebSocketSpec extends Specification {
     void "test per-message compression disabled"() {
         given:
         def ctx = ApplicationContext.run([
-                'spec.name'            : 'test per-message compression',
+                'spec.name': 'BinaryWebSocketSpec',
+                'method.name'            : 'test per-message compression',
                 'micronaut.server.port': -1,
                 'micronaut.http.client.ws.compression.enabled': false
         ])
@@ -322,7 +324,7 @@ class BinaryWebSocketSpec extends Specification {
     }
 
     @Singleton
-    @Requires(property = 'spec.name', value = 'test per-message compression')
+    @Requires(property = 'method.name', value = 'test per-message compression')
     static class CompressionDetectionCustomizerServer implements BeanCreatedEventListener<NettyServerCustomizer.Registry> {
         List<ChannelPipeline> pipelines = Collections.synchronizedList(new ArrayList<>())
 
@@ -352,7 +354,7 @@ class BinaryWebSocketSpec extends Specification {
     }
 
     @Singleton
-    @Requires(property = 'spec.name', value = 'test per-message compression')
+    @Requires(property = 'method.name', value = 'test per-message compression')
     static class CompressionDetectionCustomizerClient implements BeanCreatedEventListener<NettyClientCustomizer.Registry> {
         List<ChannelPipeline> pipelines = Collections.synchronizedList(new ArrayList<>())
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ChatClientWebSocket.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ChatClientWebSocket.java
index a7479fa814..e0cc78ab48 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ChatClientWebSocket.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ChatClientWebSocket.java
@@ -17,6 +17,7 @@ package io.micronaut.http.server.netty.websocket;
 
 // tag::imports[]
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.async.annotation.SingleResult;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.websocket.WebSocketSession;
@@ -30,6 +31,7 @@ import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Future;
 
 // tag::class[]
+@Requires(property = "spec.name", value = "SimpleTextWebSocketSpec")
 @ClientWebSocket("/chat/{topic}/{username}") // <1>
 public abstract class ChatClientWebSocket implements AutoCloseable { // <2>
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ChatServerWebSocket.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ChatServerWebSocket.java
index bde9b21a4b..6f6ff72074 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ChatServerWebSocket.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ChatServerWebSocket.java
@@ -16,6 +16,7 @@
 package io.micronaut.http.server.netty.websocket;
 
 //tag::clazz[]
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.http.context.ServerRequestContext;
 import io.micronaut.websocket.WebSocketBroadcaster;
 import io.micronaut.websocket.WebSocketSession;
@@ -26,6 +27,7 @@ import io.micronaut.websocket.annotation.ServerWebSocket;
 
 import java.util.function.Predicate;
 
+@Requires(property = "spec.name", value = "SimpleTextWebSocketSpec")
 @ServerWebSocket("/chat/{topic}/{username}") // <1>
 public class ChatServerWebSocket {
     private WebSocketBroadcaster broadcaster;
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ColludingController.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ColludingController.java
index 232715415f..9beb628227 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ColludingController.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ColludingController.java
@@ -15,12 +15,14 @@
  */
 package io.micronaut.http.server.netty.websocket;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.annotation.Controller;
 import io.micronaut.http.annotation.Get;
 import io.micronaut.http.annotation.PathVariable;
 import io.micronaut.http.annotation.Produces;
 
+@Requires(property = "spec.name", value = "BinaryWebSocketSpec")
 @Controller("/binary/chat")
 public class ColludingController {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/PojoChatClientWebSocket.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/PojoChatClientWebSocket.java
index c1a46f7f8d..903e052e3f 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/PojoChatClientWebSocket.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/PojoChatClientWebSocket.java
@@ -15,15 +15,18 @@
  */
 package io.micronaut.http.server.netty.websocket;
 
+import io.micronaut.context.annotation.Requires;
+import io.micronaut.core.async.annotation.SingleResult;
 import io.micronaut.websocket.annotation.ClientWebSocket;
 import io.micronaut.websocket.annotation.OnMessage;
 import io.micronaut.websocket.annotation.OnOpen;
 import org.reactivestreams.Publisher;
+
 import java.util.Collection;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Future;
-import io.micronaut.core.async.annotation.SingleResult;
 
+@Requires(property = "spec.name", value = "PojoWebSocketSpec")
 @ClientWebSocket("/pojo/chat/{topic}/{username}")
 public abstract class PojoChatClientWebSocket implements AutoCloseable {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/PojoWebSocketSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/PojoWebSocketSpec.groovy
index 2831e9e1ba..eb7052f252 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/PojoWebSocketSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/PojoWebSocketSpec.groovy
@@ -27,7 +27,7 @@ class PojoWebSocketSpec extends Specification {
 
     void "test POJO websocket exchange"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.builder('micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.builder('spec.name': 'PojoWebSocketSpec', 'micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
         PollingConditions conditions = new PollingConditions(timeout: 15, delay: 0.5)
 
         when: "a websocket connection is established"
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/QueryParamServerWebSocket.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/QueryParamServerWebSocket.java
index 329f3027a8..fdfb89adf5 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/QueryParamServerWebSocket.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/QueryParamServerWebSocket.java
@@ -1,5 +1,6 @@
 package io.micronaut.http.server.netty.websocket;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.http.annotation.QueryValue;
 import io.micronaut.websocket.WebSocketBroadcaster;
 import io.micronaut.websocket.WebSocketSession;
@@ -8,6 +9,7 @@ import io.micronaut.websocket.annotation.OnMessage;
 import io.micronaut.websocket.annotation.OnOpen;
 import io.micronaut.websocket.annotation.ServerWebSocket;
 
+@Requires(property = "spec.name", value = "SimpleTextWebSocketSpec")
 @ServerWebSocket("/charity")
 public class QueryParamServerWebSocket {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ReactivePojoChatServerWebSocket.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ReactivePojoChatServerWebSocket.java
index e790805823..c157c53ac3 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ReactivePojoChatServerWebSocket.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/ReactivePojoChatServerWebSocket.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.websocket;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.http.context.ServerRequestContext;
 import io.micronaut.websocket.WebSocketBroadcaster;
 import io.micronaut.websocket.WebSocketSession;
@@ -26,6 +27,7 @@ import org.reactivestreams.Publisher;
 
 import java.util.function.Predicate;
 
+@Requires(property = "spec.name", value = "PojoWebSocketSpec")
 @ServerWebSocket("/pojo/chat/{topic}/{username}")
 public class ReactivePojoChatServerWebSocket {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/SimpleTextWebSocketSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/SimpleTextWebSocketSpec.groovy
index 8204402750..e1c33bcacd 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/SimpleTextWebSocketSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/SimpleTextWebSocketSpec.groovy
@@ -16,7 +16,6 @@
 package io.micronaut.http.server.netty.websocket
 
 import io.micronaut.context.ApplicationContext
-import io.micronaut.core.util.StreamUtils
 import io.micronaut.http.client.annotation.Client
 import io.micronaut.runtime.server.EmbeddedServer
 import io.micronaut.websocket.WebSocketClient
@@ -34,7 +33,7 @@ class SimpleTextWebSocketSpec extends Specification {
     @Retry
     void "test simple text websocket exchange"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.builder('micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.builder('spec.name': 'SimpleTextWebSocketSpec', 'micronaut.server.netty.log-level':'TRACE').run(EmbeddedServer)
         PollingConditions conditions = new PollingConditions(timeout: 15    , delay: 0.5)
         def uri = embeddedServer.getURI()
         uri = new URI(scheme, uri.schemeSpecificPart, uri.fragment) // apply wss scheme
@@ -113,6 +112,7 @@ class SimpleTextWebSocketSpec extends Specification {
     void "test simple text websocket connection over SSL"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.builder([
+                'spec.name': 'SimpleTextWebSocketSpec',
                 'micronaut.server.netty.log-level':'TRACE',
                 'micronaut.server.ssl.enabled':true,
                 'micronaut.server.ssl.port': -1,
@@ -198,7 +198,7 @@ class SimpleTextWebSocketSpec extends Specification {
 
     void "test simple text websocket connection with query"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.builder('micronaut.server.netty.log-level': 'TRACE').run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.builder('spec.name': 'SimpleTextWebSocketSpec', 'micronaut.server.netty.log-level': 'TRACE').run(EmbeddedServer)
         PollingConditions conditions = new PollingConditions(timeout: 2, delay: 0.5)
 
         when: "a websocket connection is established"
@@ -224,6 +224,7 @@ class SimpleTextWebSocketSpec extends Specification {
     void "test a filter responding to a websocket upgrade request"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.builder(
+                'spec.name': 'SimpleTextWebSocketSpec',
                 'websocket-filter-respond': true
         ).run(EmbeddedServer)
 
@@ -238,7 +239,7 @@ class SimpleTextWebSocketSpec extends Specification {
 
     void "test filters are invoked for web socket requests that don't match any routes"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.builder().run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'SimpleTextWebSocketSpec'])
 
         when:
         WebSocketClient wsClient = embeddedServer.applicationContext.createBean(WebSocketClient, embeddedServer.getURI())
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/WebSocketErrorsSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/WebSocketErrorsSpec.groovy
index 2987590896..271bf7f4dd 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/WebSocketErrorsSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/WebSocketErrorsSpec.groovy
@@ -31,7 +31,8 @@ class WebSocketErrorsSpec extends Specification {
     void "test idle timeout invokes onclose"() {
         given:
         EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, [
-                'micronaut.server.idle-timeout': '5s'
+                'micronaut.server.idle-timeout': '5s',
+                'spec.name': 'WebSocketErrorsSpec'
         ])
         WebSocketClient wsClient = embeddedServer.applicationContext.createBean(WebSocketClient, embeddedServer.getURI())
         PollingConditions conditions = new PollingConditions(timeout: 15, delay: 0.5)
@@ -62,7 +63,7 @@ class WebSocketErrorsSpec extends Specification {
 
     void "test error from on message handler without @OnMessage closes the connection"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'WebSocketErrorsSpec'])
         WebSocketClient wsClient = embeddedServer.applicationContext.createBean(WebSocketClient, embeddedServer.getURI())
         PollingConditions conditions = new PollingConditions(timeout: 15, delay: 0.5)
 
@@ -92,7 +93,7 @@ class WebSocketErrorsSpec extends Specification {
 
     void "test error from on message handler without @OnMessage invokes @OnError handler"() {
         given:
-        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer)
+        EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['spec.name': 'WebSocketErrorsSpec'])
         WebSocketClient wsClient = embeddedServer.applicationContext.createBean(WebSocketClient, embeddedServer.getURI())
         PollingConditions conditions = new PollingConditions(timeout: 15    , delay: 0.5)
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/ErrorsClient.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/ErrorsClient.java
index 3bed71cac3..4ef147cbe1 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/ErrorsClient.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/ErrorsClient.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.server.netty.websocket.errors;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.websocket.CloseReason;
 import io.micronaut.websocket.WebSocketSession;
 import io.micronaut.websocket.annotation.ClientWebSocket;
@@ -23,6 +24,7 @@ import io.micronaut.websocket.annotation.OnError;
 import io.micronaut.websocket.annotation.OnMessage;
 import io.micronaut.websocket.annotation.OnOpen;
 
+@Requires(property = "spec.name", value = "WebSocketErrorsSpec")
 @ClientWebSocket
 public abstract class ErrorsClient implements AutoCloseable {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/MessageErrorSocket.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/MessageErrorSocket.java
index f1f1ad174e..9a02e39915 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/MessageErrorSocket.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/MessageErrorSocket.java
@@ -15,10 +15,12 @@
  */
 package io.micronaut.http.server.netty.websocket.errors;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.websocket.annotation.OnClose;
 import io.micronaut.websocket.annotation.OnMessage;
 import io.micronaut.websocket.annotation.ServerWebSocket;
 
+@Requires(property = "spec.name", value = "WebSocketErrorsSpec")
 @ServerWebSocket("/ws/errors/message")
 public class MessageErrorSocket {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/MessageErrorSocketWithOnError.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/MessageErrorSocketWithOnError.java
index 2a49b191fa..7bbace3efa 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/MessageErrorSocketWithOnError.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/MessageErrorSocketWithOnError.java
@@ -15,12 +15,14 @@
  */
 package io.micronaut.http.server.netty.websocket.errors;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.websocket.CloseReason;
 import io.micronaut.websocket.WebSocketSession;
 import io.micronaut.websocket.annotation.OnError;
 import io.micronaut.websocket.annotation.OnMessage;
 import io.micronaut.websocket.annotation.ServerWebSocket;
 
+@Requires(property = "spec.name", value = "WebSocketErrorsSpec")
 @ServerWebSocket("/ws/errors/message-onerror")
 public class MessageErrorSocketWithOnError {
 
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/TimeoutErrorSocket.java b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/TimeoutErrorSocket.java
index a53a2ac911..19ed661e45 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/TimeoutErrorSocket.java
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/websocket/errors/TimeoutErrorSocket.java
@@ -15,16 +15,17 @@
  */
 package io.micronaut.http.server.netty.websocket.errors;
 
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.websocket.annotation.OnClose;
 import io.micronaut.websocket.annotation.OnMessage;
 import io.micronaut.websocket.annotation.ServerWebSocket;
 
+@Requires(property = "spec.name", value = "WebSocketErrorsSpec")
 @ServerWebSocket("/ws/timeout/message")
 public class TimeoutErrorSocket {
 
     boolean closed = false;
 
-
     @OnMessage
     public void onMessage(String blah) {
         System.out.println("blah = " + blah);
diff --git a/http-server-netty/src/test/groovy/io/micronaut/runtime/ExecutorServiceWithMultipleEventLoopsSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/runtime/ExecutorServiceWithMultipleEventLoopsSpec.groovy
index 12d4c4de24..6ad9280aa8 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/runtime/ExecutorServiceWithMultipleEventLoopsSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/runtime/ExecutorServiceWithMultipleEventLoopsSpec.groovy
@@ -17,6 +17,7 @@ package io.micronaut.runtime
 
 import io.micronaut.context.ApplicationContext
 import io.micronaut.context.annotation.Context
+import io.micronaut.context.annotation.Requires
 import io.micronaut.http.annotation.Controller
 import io.micronaut.http.annotation.Get
 import io.micronaut.scheduling.TaskExecutors
@@ -35,6 +36,7 @@ class ExecutorServiceWithMultipleEventLoopsSpec extends Specification {
                     'micronaut.netty.event-loops.clients.num-threads': 1,
                     'micronaut.netty.event-loops.abc.num-threads': 1,
                     'micronaut.netty.event-loops.xyz.num-threads': 1,
+                    'spec.name': 'ExecutorServiceWithMultipleEventLoopsSpec'
             ])
 
         then:
@@ -45,6 +47,7 @@ class ExecutorServiceWithMultipleEventLoopsSpec extends Specification {
             applicationContext.close()
     }
 
+    @Requires(property = 'spec.name', value = 'ExecutorServiceWithMultipleEventLoopsSpec')
     @Controller
     static class MyController1 {
 
@@ -62,6 +65,7 @@ class ExecutorServiceWithMultipleEventLoopsSpec extends Specification {
 
     }
 
+    @Requires(property = 'spec.name', value = 'ExecutorServiceWithMultipleEventLoopsSpec')
     @Context
     @Controller
     static class MyController2 {
diff --git a/http-server-netty/src/test/groovy/io/micronaut/runtime/http/scope/RequestScopeSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/runtime/http/scope/RequestScopeSpec.groovy
index 3ff9c0f591..d7784aa7be 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/runtime/http/scope/RequestScopeSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/runtime/http/scope/RequestScopeSpec.groovy
@@ -16,6 +16,7 @@
 package io.micronaut.runtime.http.scope
 
 import io.micronaut.context.annotation.Prototype
+import io.micronaut.context.annotation.Requires
 import io.micronaut.context.event.ApplicationEventListener
 import io.micronaut.http.HttpRequest
 import io.micronaut.http.annotation.Controller
@@ -149,6 +150,7 @@ class RequestScopeSpec extends AbstractMicronautSpec {
         result == "OK"
     }
 
+    @Requires(property = "spec.name", value = "RequestScopeSpec")
     @RequestScope
     static class RequestBean {
 
@@ -174,6 +176,7 @@ class RequestScopeSpec extends AbstractMicronautSpec {
         }
     }
 
+    @Requires(property = "spec.name", value = "RequestScopeSpec")
     @RequestScope
     static class SimpleRequestBean {
 
@@ -193,6 +196,7 @@ class RequestScopeSpec extends AbstractMicronautSpec {
 
     }
 
+    @Requires(property = "spec.name", value = "RequestScopeSpec")
     @Prototype
     static class SimpleBean {
 
@@ -205,6 +209,7 @@ class RequestScopeSpec extends AbstractMicronautSpec {
 
     }
 
+    @Requires(property = "spec.name", value = "RequestScopeSpec")
     @Controller
     static class SimpleTestController {
         final SimpleRequestBean simpleRequestBean
@@ -231,6 +236,7 @@ class RequestScopeSpec extends AbstractMicronautSpec {
         }
     }
 
+    @Requires(property = "spec.name", value = "RequestScopeSpec")
     @RequestScope
     static class RequestAwareBean implements RequestAware {
 
@@ -242,6 +248,7 @@ class RequestScopeSpec extends AbstractMicronautSpec {
         }
     }
 
+    @Requires(property = "spec.name", value = "RequestScopeSpec")
     @Singleton
     static class MessageService {
 
@@ -266,6 +273,7 @@ class RequestScopeSpec extends AbstractMicronautSpec {
         }
     }
 
+    @Requires(property = "spec.name", value = "RequestScopeSpec")
     @Controller
     static class TestController {
 
@@ -294,6 +302,7 @@ class RequestScopeSpec extends AbstractMicronautSpec {
         }
     }
 
+    @Requires(property = "spec.name", value = "RequestScopeSpec")
     @Singleton
     static class ReqTerminatedListener implements ApplicationEventListener<HttpRequestTerminatedEvent> {
         int callCount
diff --git a/http-server-netty/src/test/groovy/io/micronaut/web/router/version/VersioningNotMatchSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/web/router/version/VersioningNotMatchSpec.groovy
index 8d9f6882c1..3f35dd6739 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/web/router/version/VersioningNotMatchSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/web/router/version/VersioningNotMatchSpec.groovy
@@ -40,13 +40,13 @@ class VersioningNotMatchSpec extends VersioningSpec {
         e.status == status
 
         when:
-        Optional<Map> erroreBody = e.response.getBody(Map)
+        Optional<Map> errorBody = e.response.getBody(Map)
 
         then:
-        erroreBody.isPresent()
+        errorBody.isPresent()
 
         when:
-        Map body = erroreBody.get()
+        Map body = errorBody.get()
         then:
         body
         body._embedded.errors[0].message.contains(jsonErrorMessage)
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalType2Test.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalType2Test.java
new file mode 100644
index 0000000000..9c41bb21a4
--- /dev/null
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalType2Test.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2017-2023 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.tck.tests.codec;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import io.micronaut.context.annotation.Requires;
+import io.micronaut.core.annotation.Introspected;
+import io.micronaut.http.HttpHeaders;
+import io.micronaut.http.HttpRequest;
+import io.micronaut.http.HttpStatus;
+import io.micronaut.http.annotation.Controller;
+import io.micronaut.http.annotation.Get;
+import io.micronaut.http.annotation.Produces;
+import io.micronaut.http.tck.AssertionUtils;
+import io.micronaut.http.tck.BodyAssertion;
+import io.micronaut.http.tck.HttpResponseAssertion;
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Map;
+
+import static io.micronaut.http.tck.TestScenario.asserts;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+
+@SuppressWarnings({
+    "java:S5960", // We're allowed assertions, as these are used in tests only
+    "checkstyle:MissingJavadocType",
+    "checkstyle:DesignForExtension"
+})
+public class JsonCodecAdditionalType2Test {
+    public static final String SPEC_NAME = "JsonCodecAdditionalType2Test";
+    public static final String CUSTOM_MEDIA_TYPE = "application/json+feed";
+
+    @Test
+    void itIsPossibleToCanRegisterAdditionTypesForJsonCodec() throws IOException {
+        assertRequest("/json-additional-codec");
+        assertRequest("/json-additional-codec/pojo");
+    }
+
+    private void assertRequest(String uri) throws IOException {
+        HttpResponseAssertion assertion = HttpResponseAssertion.builder()
+            .body(BodyAssertion.builder().body("https://jsonfeed.org").contains())
+            .status(HttpStatus.OK)
+            .assertResponse(response -> assertTrue(response.header("Content-Type").contains(CUSTOM_MEDIA_TYPE)))
+            .build();
+        Map<String, Object> config = Collections.singletonMap("micronaut.codec.json.additional-types", Collections.singletonList(CUSTOM_MEDIA_TYPE));
+        asserts(SPEC_NAME,
+            config,
+            HttpRequest.GET(uri).header(HttpHeaders.ACCEPT, CUSTOM_MEDIA_TYPE),
+            (server, request) -> AssertionUtils.assertDoesNotThrow(server, request, assertion));
+    }
+
+    @Requires(property = "spec.name", value = SPEC_NAME)
+    @Controller
+    static class JsonFeedController {
+
+        @Produces(CUSTOM_MEDIA_TYPE)
+        @Get("/json-additional-codec")
+        String index() {
+            return """
+                {
+                    "version": "https://jsonfeed.org/version/1",
+                    "title": "My Example Feed",
+                    "home_page_url": "https://example.org/",
+                    "feed_url": "https://example.org/feed.json",
+                    ]
+                }\
+                """;
+        }
+
+        @Produces(CUSTOM_MEDIA_TYPE)
+        @Get("/json-additional-codec/pojo")
+        JsonFeed pojo() {
+            return new JsonFeed("https://jsonfeed.org/version/1", "My Example Feed", "https://example.org/", "https://example.org/feed.json");
+        }
+    }
+
+    @Introspected
+    static class JsonFeed {
+        private final String version;
+        private final String title;
+        @JsonProperty("home_page_url")
+        private final String homePageUrl;
+        @JsonProperty("feed_url")
+        private final String feedUrl;
+
+        public JsonFeed(String version, String title, String homePageUrl, String feedUrl) {
+            this.version = version;
+            this.title = title;
+            this.homePageUrl = homePageUrl;
+            this.feedUrl = feedUrl;
+        }
+
+        public String getVersion() {
+            return version;
+        }
+
+        public String getTitle() {
+            return title;
+        }
+
+        public String getHomePageUrl() {
+            return homePageUrl;
+        }
+
+        public String getFeedUrl() {
+            return feedUrl;
+        }
+    }
+}
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/routing/RootRoutingTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/routing/RootRoutingTest.java
new file mode 100644
index 0000000000..b065bea1d4
--- /dev/null
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/routing/RootRoutingTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.tck.tests.routing;
+
+import io.micronaut.context.annotation.Requires;
+import io.micronaut.core.annotation.Introspected;
+import io.micronaut.http.HttpRequest;
+import io.micronaut.http.HttpStatus;
+import io.micronaut.http.annotation.Body;
+import io.micronaut.http.annotation.Controller;
+import io.micronaut.http.annotation.Get;
+import io.micronaut.http.annotation.Post;
+import io.micronaut.http.tck.AssertionUtils;
+import io.micronaut.http.tck.BodyAssertion;
+import io.micronaut.http.tck.HttpResponseAssertion;
+import io.micronaut.http.tck.TestScenario;
+import io.micronaut.scheduling.TaskExecutors;
+import io.micronaut.scheduling.annotation.ExecuteOn;
+import org.junit.jupiter.api.Test;
+
+import java.io.IOException;
+import java.util.List;
+
+@SuppressWarnings({
+    "java:S5960", // We're allowed assertions, as these are used in tests only
+    "checkstyle:MissingJavadocType",
+    "checkstyle:DesignForExtension"
+})
+public class RootRoutingTest {
+    public static final String SPEC_NAME = "RootRoutingTest";
+
+    @Test
+    void testRouting() throws IOException {
+        TestScenario.asserts(SPEC_NAME,
+            HttpRequest.GET("/"),
+            (server, request) -> AssertionUtils.assertDoesNotThrow(server, request, HttpResponseAssertion.builder()
+                .status(HttpStatus.OK)
+                .body(BodyAssertion.builder().body("""
+                    {"key":"hello","value":"world"}""").equals())
+                .build()));
+    }
+
+    @Requires(property = "spec.name", value = SPEC_NAME)
+    @Controller
+    @ExecuteOn(TaskExecutors.BLOCKING)
+    static class MyController {
+
+        @Post
+        public KeyValue createRoot(@Body KeyValue body) {
+            return body;
+        }
+
+        @Get
+        public KeyValue root() {
+            return new KeyValue("hello", "world");
+        }
+
+        @Get("/{id}")
+        public KeyValue id(String id) {
+            return new KeyValue("hello", id);
+        }
+
+        @Get("/{id}/items")
+        public List<KeyValue> items(String id) {
+            return List.of(new KeyValue("hello", id), new KeyValue("foo", "bar"));
+        }
+    }
+
+    @Introspected
+    private record KeyValue(String key, String value) {
+    }
+
+}
diff --git a/http-server/src/main/java/io/micronaut/http/server/codec/TextStreamCodec.java b/http-server/src/main/java/io/micronaut/http/server/codec/TextStreamCodec.java
index 185879bd3e..ffefbe5fce 100644
--- a/http-server/src/main/java/io/micronaut/http/server/codec/TextStreamCodec.java
+++ b/http-server/src/main/java/io/micronaut/http/server/codec/TextStreamCodec.java
@@ -50,11 +50,13 @@ import java.util.List;
  *
  * @author Graeme Rocher
  * @since 1.0
+ * @deprecated Replaced with message body writers / readers API
  */
 @Singleton
 @Internal
 @BootstrapContextCompatible
 @Requires(bean = ByteBufferFactory.class)
+@Deprecated(forRemoval = true, since = "4.7")
 public class TextStreamCodec implements MediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "text-stream";
diff --git a/http/src/main/java/io/micronaut/http/ByteBodyHttpResponse.java b/http/src/main/java/io/micronaut/http/ByteBodyHttpResponse.java
new file mode 100644
index 0000000000..9d97c2abe3
--- /dev/null
+++ b/http/src/main/java/io/micronaut/http/ByteBodyHttpResponse.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http;
+
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.http.body.ByteBody;
+
+import java.io.Closeable;
+
+/**
+ * Special response type that contains the encoded response bytes. Responses of this type must also
+ * be closed if their {@link #byteBody()} is not used.
+ *
+ * @param <B> The original (non-encoded) body type
+ * @since 4.7.0
+ * @author Jonas Konrad
+ */
+@Experimental
+public sealed interface ByteBodyHttpResponse<B> extends HttpResponse<B>, Closeable permits ByteBodyHttpResponseWrapper {
+    /**
+     * The body bytes.
+     *
+     * @return The bytes
+     */
+    @NonNull
+    ByteBody byteBody();
+
+    /**
+     * Close this response.
+     */
+    @Override
+    void close();
+}
diff --git a/http/src/main/java/io/micronaut/http/ByteBodyHttpResponseWrapper.java b/http/src/main/java/io/micronaut/http/ByteBodyHttpResponseWrapper.java
new file mode 100644
index 0000000000..7ebcbe6a0c
--- /dev/null
+++ b/http/src/main/java/io/micronaut/http/ByteBodyHttpResponseWrapper.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http;
+
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.http.body.ByteBody;
+import io.micronaut.http.body.CloseableByteBody;
+
+/**
+ * Simple response wrapper to implement {@link ByteBodyHttpResponse}.
+ *
+ * @param <B> The original body type
+ * @since 4.7.0
+ * @author Jonas Konrad
+ */
+@Experimental
+public final class ByteBodyHttpResponseWrapper<B> extends HttpResponseWrapper<B> implements ByteBodyHttpResponse<B> {
+    private final CloseableByteBody byteBody;
+
+    private ByteBodyHttpResponseWrapper(HttpResponse<B> delegate, CloseableByteBody byteBody) {
+        super(delegate);
+        this.byteBody = byteBody;
+    }
+
+    /**
+     * Attach a body to the given response.
+     *
+     * @param delegate The original response to be used for e.g. headers and status
+     * @param byteBody The bytes to respond with
+     * @return A {@link ByteBodyHttpResponse} implementation with the given response and bytes
+     */
+    @NonNull
+    public static ByteBodyHttpResponse<?> wrap(@NonNull HttpResponse<?> delegate, @NonNull CloseableByteBody byteBody) {
+        return new ByteBodyHttpResponseWrapper<>(delegate, byteBody);
+    }
+
+    @Override
+    public @NonNull ByteBody byteBody() {
+        return byteBody;
+    }
+
+    @Override
+    public void close() {
+        byteBody.close();
+    }
+}
diff --git a/http/src/main/java/io/micronaut/http/HttpRequest.java b/http/src/main/java/io/micronaut/http/HttpRequest.java
index 9393658aff..9d458fa9a2 100644
--- a/http/src/main/java/io/micronaut/http/HttpRequest.java
+++ b/http/src/main/java/io/micronaut/http/HttpRequest.java
@@ -445,4 +445,24 @@ public interface HttpRequest<B> extends HttpMessage<B> {
         Objects.requireNonNull(httpMethodName, "Argument [httpMethodName] is required");
         return HttpRequestFactory.INSTANCE.create(httpMethod, uri, httpMethodName);
     }
+
+    /**
+     * Returns a mutable request based on this request.
+     * @return the mutable request
+     * @since 4.7
+     */
+    default MutableHttpRequest<B> toMutableRequest() {
+        if (this instanceof MutableHttpRequest<B> mutableHttpRequest) {
+            return mutableHttpRequest;
+        }
+        MutableHttpRequest<B> mutableHttpRequest = HttpRequest.create(getMethod(), getUri().toString());
+        getBody().ifPresent(mutableHttpRequest::body);
+        getHeaders().forEach((name, value) -> {
+            for (String val : value) {
+                mutableHttpRequest.header(name, val);
+            }
+        });
+        mutableHttpRequest.getAttributes().putAll(getAttributes());
+        return mutableHttpRequest;
+    }
 }
diff --git a/http/src/main/java/io/micronaut/http/HttpResponseWrapper.java b/http/src/main/java/io/micronaut/http/HttpResponseWrapper.java
index 51f2c67483..f814ffda00 100644
--- a/http/src/main/java/io/micronaut/http/HttpResponseWrapper.java
+++ b/http/src/main/java/io/micronaut/http/HttpResponseWrapper.java
@@ -42,7 +42,9 @@ public class HttpResponseWrapper<B> extends HttpMessageWrapper<B> implements Htt
 
     @Override
     public HttpResponse<B> getDelegate() {
-        return (HttpResponse<B>) super.getDelegate();
+        HttpMessage<B> delegate = super.getDelegate();
+        // this weird cast structure avoids type pollution
+        return delegate instanceof MutableHttpResponse<B> mhr ? mhr : (HttpResponse<B>) delegate;
     }
 
 }
diff --git a/http/src/main/java/io/micronaut/http/MediaType.java b/http/src/main/java/io/micronaut/http/MediaType.java
index 97e7352934..a6f398d5b1 100644
--- a/http/src/main/java/io/micronaut/http/MediaType.java
+++ b/http/src/main/java/io/micronaut/http/MediaType.java
@@ -886,11 +886,38 @@ public class MediaType implements CharSequence {
         if (expectedContentType == this) {
             return true;
         }
-        String expectedType = expectedContentType.getType();
-        String expectedSubtype = expectedContentType.getSubtype();
-        boolean typeMatch = type.equals(WILDCARD) || type.equalsIgnoreCase(expectedType);
-        boolean subtypeMatch = subtype.equals(WILDCARD) || subtype.equalsIgnoreCase(expectedSubtype);
-        return typeMatch && subtypeMatch;
+        return matchesType(expectedContentType.getType()) && matchesSubtype(expectedContentType.getSubtype());
+    }
+
+    /**
+     * Check if the subtype matches.
+     *
+     * @param matchSubtype The subtype to match
+     * @return true if matches
+     * @since 4.6.3
+     */
+    public boolean matchesSubtype(String matchSubtype) {
+        return subtype.equals(WILDCARD) || subtype.equalsIgnoreCase(matchSubtype);
+    }
+
+    /**
+     * Check if the type matches.
+     * @param matchType The type to match
+     * @return true if matches
+     * @since 4.6.3
+     */
+    public boolean matchesType(String matchType) {
+        return type.equals(WILDCARD) || type.equalsIgnoreCase(matchType);
+    }
+
+    /**
+     * Check if the extension matches.
+     * @param matchExtension The extension to match
+     * @return true if matches
+     * @since 4.6.3
+     */
+    public boolean matchesExtension(String matchExtension) {
+        return extension.equalsIgnoreCase(ALL_TYPE.extension) || extension.equals(WILDCARD) || extension.equalsIgnoreCase(matchExtension);
     }
 
     /**
diff --git a/http/src/main/java/io/micronaut/http/MutableHttpRequest.java b/http/src/main/java/io/micronaut/http/MutableHttpRequest.java
index 96e9ae0f55..a2d770e461 100644
--- a/http/src/main/java/io/micronaut/http/MutableHttpRequest.java
+++ b/http/src/main/java/io/micronaut/http/MutableHttpRequest.java
@@ -160,4 +160,9 @@ public interface MutableHttpRequest<B> extends HttpRequest<B>, MutableHttpMessag
     default MutableHttpRequest<B> contentEncoding(CharSequence encoding) {
         return (MutableHttpRequest<B>) MutableHttpMessage.super.contentEncoding(encoding);
     }
+
+    @Override
+    default MutableHttpRequest<B> toMutableRequest() {
+        return this;
+    }
 }
diff --git a/http/src/main/java/io/micronaut/http/body/DefaultMessageBodyHandlerRegistry.java b/http/src/main/java/io/micronaut/http/body/DefaultMessageBodyHandlerRegistry.java
index 401d2ef531..7e64572407 100644
--- a/http/src/main/java/io/micronaut/http/body/DefaultMessageBodyHandlerRegistry.java
+++ b/http/src/main/java/io/micronaut/http/body/DefaultMessageBodyHandlerRegistry.java
@@ -67,27 +67,20 @@ public final class DefaultMessageBodyHandlerRegistry extends AbstractMessageBody
     @SuppressWarnings({"unchecked"})
     @Override
     protected <T> MessageBodyReader<T> findReaderImpl(Argument<T> type, List<MediaType> mediaTypes) {
+        List<MediaType> resolvedMediaTypes = resolveMediaTypes(mediaTypes);
         return beanLocator.getBeansOfType(
                 Argument.of(MessageBodyReader.class), // Select all readers and eliminate by the type later
                 Qualifiers.byQualifiers(
                     // Filter by media types first before filtering by the type hierarchy
-                    newMediaTypeQualifier(Argument.of(MessageBodyReader.class, type), mediaTypes, Consumes.class),
+                    new MediaTypeQualifier<>(Argument.of(MessageBodyReader.class, type), resolvedMediaTypes, Consumes.class),
                     MatchArgumentQualifier.covariant(MessageBodyReader.class, type)
                 )
             ).stream()
-            .filter(reader -> mediaTypes.stream().anyMatch(mediaType -> reader.isReadable(type, mediaType)))
+            .filter(reader -> resolvedMediaTypes.stream().anyMatch(mediaType -> reader.isReadable(type, mediaType)))
             .findFirst()
             .orElse(null);
     }
 
-    @NonNull
-    private <T, B> MediaTypeQualifier<B> newMediaTypeQualifier(Argument<T> type,
-                                                               List<MediaType> mediaTypes,
-                                                               Class<? extends Annotation> qualifierType) {
-        List<MediaType> resolvedMediaTypes = resolveMediaTypes(mediaTypes);
-        return new MediaTypeQualifier<>(type, resolvedMediaTypes, qualifierType);
-    }
-
     @NonNull
     private List<MediaType> resolveMediaTypes(List<MediaType> mediaTypes) {
         if (codecConfigurations.isEmpty()) {
@@ -112,15 +105,16 @@ public final class DefaultMessageBodyHandlerRegistry extends AbstractMessageBody
     @SuppressWarnings({"unchecked"})
     @Override
     protected <T> MessageBodyWriter<T> findWriterImpl(Argument<T> type, List<MediaType> mediaTypes) {
+        List<MediaType> resolvedMediaTypes = resolveMediaTypes(mediaTypes);
         return beanLocator.getBeansOfType(
                 Argument.of(MessageBodyWriter.class), // Select all writers and eliminate by the type later
                 Qualifiers.byQualifiers(
                     // Filter by media types first before filtering by the type hierarchy
-                    newMediaTypeQualifier(Argument.of(MessageBodyWriter.class, type), mediaTypes, Produces.class),
+                    new MediaTypeQualifier<>(Argument.of(MessageBodyWriter.class, type), resolvedMediaTypes, Produces.class),
                     MatchArgumentQualifier.contravariant(MessageBodyWriter.class, type)
                 )
             ).stream()
-            .filter(writer -> mediaTypes.stream().anyMatch(mediaType -> writer.isWriteable(type, mediaType)))
+            .filter(writer -> resolvedMediaTypes.stream().anyMatch(mediaType -> writer.isWriteable(type, mediaType)))
             .findFirst().orElse(null);
     }
 
@@ -140,6 +134,7 @@ public final class DefaultMessageBodyHandlerRegistry extends AbstractMessageBody
         @Override
         public <K extends BeanType<T>> Collection<K> filter(Class<T> beanType, Collection<K> candidates) {
             List<K> all = new ArrayList<>(candidates.size());
+            candidatesLoop:
             for (K candidate : candidates) {
                 String[] applicableTypes = candidate.getAnnotationMetadata().stringValues(annotationType);
                 if (applicableTypes.length == 0) {
@@ -147,9 +142,12 @@ public final class DefaultMessageBodyHandlerRegistry extends AbstractMessageBody
                     continue;
                 }
                 for (String mt : applicableTypes) {
-                    if (mediaTypes.contains(new MediaType(mt))) {
-                        all.add(candidate);
-                        break;
+                    MediaType mediaType = new MediaType(mt);
+                    for (MediaType m : mediaTypes) {
+                        if (m.matches(mediaType)) {
+                            all.add(candidate);
+                            continue candidatesLoop;
+                        }
                     }
                 }
             }
diff --git a/http/src/main/java/io/micronaut/http/body/MessageBodyHandlerRegistry.java b/http/src/main/java/io/micronaut/http/body/MessageBodyHandlerRegistry.java
index c4283562b2..d76154eda1 100644
--- a/http/src/main/java/io/micronaut/http/body/MessageBodyHandlerRegistry.java
+++ b/http/src/main/java/io/micronaut/http/body/MessageBodyHandlerRegistry.java
@@ -23,7 +23,6 @@ import io.micronaut.http.MediaType;
 import io.micronaut.http.codec.CodecException;
 
 import java.util.List;
-import java.util.Objects;
 import java.util.Optional;
 
 /**
@@ -80,9 +79,8 @@ public interface MessageBodyHandlerRegistry {
      * @since 4.6
      */
     default <T> Optional<MessageBodyReader<T>> findReader(@NonNull Argument<T> type,
-                                                          @NonNull MediaType mediaType) {
-        Objects.requireNonNull(mediaType);
-        return findReader(type, List.of(mediaType));
+                                                          @Nullable MediaType mediaType) {
+        return findReader(type, mediaType == null ? List.of() : List.of(mediaType));
     }
 
     /**
@@ -115,8 +113,8 @@ public interface MessageBodyHandlerRegistry {
      * @since 4.6
      */
     default <T> Optional<MessageBodyWriter<T>> findWriter(@NonNull Argument<T> type,
-                                                          @NonNull MediaType mediaType) {
-        return findWriter(type, List.of(mediaType));
+                                                          @Nullable MediaType mediaType) {
+        return findWriter(type, mediaType == null ? List.of() : List.of(mediaType));
     }
 
     /**
diff --git a/http/src/main/java/io/micronaut/http/body/ResponseBodyWriter.java b/http/src/main/java/io/micronaut/http/body/ResponseBodyWriter.java
new file mode 100644
index 0000000000..4a9f7ff4ea
--- /dev/null
+++ b/http/src/main/java/io/micronaut/http/body/ResponseBodyWriter.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.body;
+
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.Indexed;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.io.buffer.ByteBufferFactory;
+import io.micronaut.core.type.Argument;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.HttpRequest;
+import io.micronaut.http.MediaType;
+import io.micronaut.http.MutableHttpResponse;
+import io.micronaut.http.codec.CodecException;
+
+/**
+ * Extension to {@link MessageBodyWriter} that is specific to writing the server response body. This
+ * allows more fine-grained control over the response than the {@link MessageBodyWriter} API.
+ *
+ * @param <T> The body type
+ * @since 4.7.0
+ * @author Jonas Konrad
+ */
+@Experimental
+@Indexed(MessageBodyWriter.class)
+public interface ResponseBodyWriter<T> extends MessageBodyWriter<T> {
+    /**
+     * Writes an object as a {@link ByteBodyHttpResponse}.
+     *
+     * @param bufferFactory The buffer factory
+     * @param request       The request
+     * @param httpResponse  The response
+     * @param type          The response body type
+     * @param mediaType     The media type
+     * @param object        The object to write
+     * @return A {@link ByteBodyHttpResponse} with the response bytes
+     * @throws CodecException If an error occurs encoding
+     */
+    @NonNull
+    ByteBodyHttpResponse<?> write(
+        @NonNull ByteBufferFactory<?, ?> bufferFactory,
+        @NonNull HttpRequest<?> request,
+        @NonNull MutableHttpResponse<T> httpResponse,
+        @NonNull Argument<T> type,
+        @NonNull MediaType mediaType,
+        T object) throws CodecException;
+
+    /**
+     * Wrap the given writer, if necessary, to get a {@link ResponseBodyWriter}.
+     *
+     * @param writer The generic message writer
+     * @return The response writer
+     * @param <T> The body type
+     */
+    @NonNull
+    static <T> ResponseBodyWriter<T> wrap(@NonNull MessageBodyWriter<T> writer) {
+        if (writer instanceof ResponseBodyWriter<T> rbw) {
+            return rbw;
+        } else {
+            return new ResponseBodyWriterWrapper<>(writer);
+        }
+    }
+}
diff --git a/http/src/main/java/io/micronaut/http/body/ResponseBodyWriterWrapper.java b/http/src/main/java/io/micronaut/http/body/ResponseBodyWriterWrapper.java
new file mode 100644
index 0000000000..48ec5a962e
--- /dev/null
+++ b/http/src/main/java/io/micronaut/http/body/ResponseBodyWriterWrapper.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.body;
+
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.io.buffer.ByteBuffer;
+import io.micronaut.core.io.buffer.ByteBufferFactory;
+import io.micronaut.core.type.Argument;
+import io.micronaut.core.type.MutableHeaders;
+import io.micronaut.http.ByteBodyHttpResponse;
+import io.micronaut.http.ByteBodyHttpResponseWrapper;
+import io.micronaut.http.HttpRequest;
+import io.micronaut.http.MediaType;
+import io.micronaut.http.MutableHttpResponse;
+import io.micronaut.http.body.stream.AvailableByteArrayBody;
+import io.micronaut.http.codec.CodecException;
+
+import java.io.ByteArrayOutputStream;
+import java.io.OutputStream;
+
+/**
+ * {@link ResponseBodyWriter} implementation that delegates to a {@link MessageBodyWriter}.
+ *
+ * @param <T> The body type
+ * @since 4.7.0
+ * @author Jonas Konrad
+ */
+@Internal
+public class ResponseBodyWriterWrapper<T> implements ResponseBodyWriter<T> {
+    private final MessageBodyWriter<T> wrapped;
+
+    protected ResponseBodyWriterWrapper(MessageBodyWriter<T> wrapped) {
+        this.wrapped = wrapped;
+    }
+
+    @Override
+    public boolean isWriteable(@NonNull Argument<T> type, @Nullable MediaType mediaType) {
+        return wrapped.isWriteable(type, mediaType);
+    }
+
+    @Override
+    public MessageBodyWriter<T> createSpecific(@NonNull Argument<T> type) {
+        return wrapped.createSpecific(type);
+    }
+
+    @Override
+    public boolean isBlocking() {
+        return wrapped.isBlocking();
+    }
+
+    @Override
+    public void writeTo(@NonNull Argument<T> type, @NonNull MediaType mediaType, T object, @NonNull MutableHeaders outgoingHeaders, @NonNull OutputStream outputStream) throws CodecException {
+        wrapped.writeTo(type, mediaType, object, outgoingHeaders, outputStream);
+    }
+
+    @Override
+    public @NonNull ByteBuffer<?> writeTo(@NonNull Argument<T> type, @NonNull MediaType mediaType, T object, @NonNull MutableHeaders outgoingHeaders, @NonNull ByteBufferFactory<?, ?> bufferFactory) throws CodecException {
+        return wrapped.writeTo(type, mediaType, object, outgoingHeaders, bufferFactory);
+    }
+
+    @Override
+    public @NonNull ByteBodyHttpResponse<?> write(@NonNull ByteBufferFactory<?, ?> bufferFactory, @NonNull HttpRequest<?> request, @NonNull MutableHttpResponse<T> httpResponse, @NonNull Argument<T> type, @NonNull MediaType mediaType, T object) throws CodecException {
+        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+        writeTo(type, mediaType, object, httpResponse.getHeaders(), baos);
+        return ByteBodyHttpResponseWrapper.wrap(httpResponse, AvailableByteArrayBody.create(bufferFactory, baos.toByteArray()));
+    }
+}
diff --git a/http/src/main/java/io/micronaut/http/body/TextPlainObjectBodyReader.java b/http/src/main/java/io/micronaut/http/body/TextPlainObjectBodyReader.java
index 75eebb3273..51bd22f8fe 100644
--- a/http/src/main/java/io/micronaut/http/body/TextPlainObjectBodyReader.java
+++ b/http/src/main/java/io/micronaut/http/body/TextPlainObjectBodyReader.java
@@ -62,7 +62,7 @@ public final class TextPlainObjectBodyReader<T> implements TypedMessageBodyReade
 
     @Override
     public boolean isReadable(Argument<T> type, MediaType mediaType) {
-        return mediaType == MediaType.TEXT_PLAIN_TYPE;
+        return mediaType != null && mediaType.matches(MediaType.TEXT_PLAIN_TYPE);
     }
 
     @Override
diff --git a/http/src/main/java/io/micronaut/http/codec/DefaultMediaTypeCodecRegistry.java b/http/src/main/java/io/micronaut/http/codec/DefaultMediaTypeCodecRegistry.java
index 0a8b7a390d..932143aeda 100644
--- a/http/src/main/java/io/micronaut/http/codec/DefaultMediaTypeCodecRegistry.java
+++ b/http/src/main/java/io/micronaut/http/codec/DefaultMediaTypeCodecRegistry.java
@@ -30,7 +30,9 @@ import java.util.Optional;
  *
  * @author Graeme Rocher
  * @since 1.0
+ * @deprecated Replaced with {@link io.micronaut.http.body.MessageBodyHandlerRegistry}.
  */
+@Deprecated(forRemoval = true, since = "4.7")
 public class DefaultMediaTypeCodecRegistry implements MediaTypeCodecRegistry {
 
     Map<String, Optional<MediaTypeCodec>> decodersByExtension = new LinkedHashMap<>(3);
diff --git a/http/src/main/java/io/micronaut/http/codec/MediaTypeCodec.java b/http/src/main/java/io/micronaut/http/codec/MediaTypeCodec.java
index adb9d71c4f..3624d249b9 100644
--- a/http/src/main/java/io/micronaut/http/codec/MediaTypeCodec.java
+++ b/http/src/main/java/io/micronaut/http/codec/MediaTypeCodec.java
@@ -33,7 +33,9 @@ import java.util.Collection;
  *
  * @author Graeme Rocher
  * @since 1.0
+ * @deprecated Replaced with {@link io.micronaut.http.body.MessageBodyHandler}
  */
+@Deprecated(since = "4.7")
 @Indexed(MediaTypeCodec.class)
 public interface MediaTypeCodec {
 
diff --git a/http/src/main/java/io/micronaut/http/codec/MediaTypeCodecRegistry.java b/http/src/main/java/io/micronaut/http/codec/MediaTypeCodecRegistry.java
index daf1c5cbd2..da28d41d57 100644
--- a/http/src/main/java/io/micronaut/http/codec/MediaTypeCodecRegistry.java
+++ b/http/src/main/java/io/micronaut/http/codec/MediaTypeCodecRegistry.java
@@ -26,7 +26,9 @@ import java.util.Optional;
  *
  * @author Graeme Rocher
  * @since 1.0
+ * @deprecated Replaced with {@link io.micronaut.http.body.MessageBodyHandlerRegistry}.
  */
+@Deprecated(since = "4.7")
 public interface MediaTypeCodecRegistry {
 
     /**
diff --git a/http/src/main/java/io/micronaut/http/simple/SimpleHttpHeaders.java b/http/src/main/java/io/micronaut/http/simple/SimpleHttpHeaders.java
index e06f9ba4f0..8189d2f6af 100644
--- a/http/src/main/java/io/micronaut/http/simple/SimpleHttpHeaders.java
+++ b/http/src/main/java/io/micronaut/http/simple/SimpleHttpHeaders.java
@@ -39,6 +39,13 @@ public class SimpleHttpHeaders implements MutableHttpHeaders {
     private final CaseInsensitiveMutableHttpHeaders headers;
     private ConversionService conversionService;
 
+    /**
+     * Map-based implementation of {@link MutableHttpHeaders}.
+     */
+    public SimpleHttpHeaders() {
+        this(ConversionService.SHARED);
+    }
+
     /**
      * Map-based implementation of {@link MutableHttpHeaders}.
      *
diff --git a/http/src/main/java/io/micronaut/http/uri/UriTemplateMatcher.java b/http/src/main/java/io/micronaut/http/uri/UriTemplateMatcher.java
index 103d006456..cb44ed2ffa 100644
--- a/http/src/main/java/io/micronaut/http/uri/UriTemplateMatcher.java
+++ b/http/src/main/java/io/micronaut/http/uri/UriTemplateMatcher.java
@@ -68,7 +68,7 @@ public final class UriTemplateMatcher implements UriMatcher, Comparable<UriTempl
         this.parts = parts;
         List<UriMatchVariable> variables = new ArrayList<>();
         this.segments = provideMatchSegments(parts, variables);
-        this.isRoot = segments.length == 0 || segments[0].type == SegmentType.LITERAL && isRoot(segments[0].value);
+        this.isRoot = segments.length == 0 || segments.length == 1 && segments[0].type == SegmentType.LITERAL && isRoot(segments[0].value);
         this.variables = Collections.unmodifiableList(variables);
     }
 
@@ -269,9 +269,10 @@ public final class UriTemplateMatcher implements UriMatcher, Comparable<UriTempl
         int parameterIndex = uri.indexOf('?');
         if (parameterIndex > -1) {
             uri = uri.substring(0, parameterIndex);
-        }
-        if (uri.endsWith("/")) {
-            uri = uri.substring(0, uri.length() - 1);
+            length = uri.length();
+            if (length > 1 && uri.charAt(length - 1) == '/') {
+                uri = uri.substring(0, length - 1);
+            }
         }
         if (variables.isEmpty()) {
             if (uri.equals(templateString)) {
diff --git a/http/src/main/java/io/micronaut/runtime/http/codec/TextPlainCodec.java b/http/src/main/java/io/micronaut/runtime/http/codec/TextPlainCodec.java
index beab892b8a..819660cc7c 100644
--- a/http/src/main/java/io/micronaut/runtime/http/codec/TextPlainCodec.java
+++ b/http/src/main/java/io/micronaut/runtime/http/codec/TextPlainCodec.java
@@ -50,9 +50,11 @@ import java.util.Optional;
  *
  * @author Graeme Rocher
  * @since 1.0
+ * @deprecated Replaced with message body writers / readers API
  */
 @Singleton
 @BootstrapContextCompatible
+@Deprecated(forRemoval = true, since = "4.7")
 public class TextPlainCodec implements MediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "text";
diff --git a/inject-java-test/src/main/groovy/io/micronaut/annotation/processing/test/AbstractTypeElementSpec.groovy b/inject-java-test/src/main/groovy/io/micronaut/annotation/processing/test/AbstractTypeElementSpec.groovy
index 227a0ba678..0d82597641 100644
--- a/inject-java-test/src/main/groovy/io/micronaut/annotation/processing/test/AbstractTypeElementSpec.groovy
+++ b/inject-java-test/src/main/groovy/io/micronaut/annotation/processing/test/AbstractTypeElementSpec.groovy
@@ -601,13 +601,13 @@ class Test {
                 @Override
                 protected List<AnnotationTransformer<Annotation>> getAnnotationTransformers(@NonNull String annotationName) {
                     def loadedTransformers = super.getAnnotationTransformers(annotationName)
-                    def localTransfomers = getLocalAnnotationTransformers(annotationName)
-                    if (localTransfomers) {
+                    def localTransformers = getLocalAnnotationTransformers(annotationName)
+                    if (localTransformers) {
                         def newList = []
                         if (loadedTransformers) {
                             newList.addAll(loadedTransformers)
                         }
-                        newList.addAll(localTransfomers)
+                        newList.addAll(localTransformers)
                         return newList
                     } else {
                         return loadedTransformers
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java b/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java
index 4af276bb43..fa937b43f0 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/AbstractInjectAnnotationProcessor.java
@@ -36,6 +36,7 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
@@ -77,6 +78,7 @@ abstract class AbstractInjectAnnotationProcessor extends AbstractProcessor {
     private final Set<String> supportedAnnotationTypes = new HashSet<>(5);
     private final Map<String, Boolean> isProcessedCache = new HashMap<>(30);
     private Set<String> processedTypes;
+    protected Set<String> postponedTypes = new LinkedHashSet<>();
 
     @Override
     public SourceVersion getSupportedSourceVersion() {
@@ -216,7 +218,8 @@ abstract class AbstractInjectAnnotationProcessor extends AbstractProcessor {
             modelUtils,
             filer,
             visitorAttributes,
-            getVisitorKind()
+            getVisitorKind(),
+            postponedTypes
         );
     }
 
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/AnnotationUtils.java b/inject-java/src/main/java/io/micronaut/annotation/processing/AnnotationUtils.java
index 067c42e35b..81685124ce 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/AnnotationUtils.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/AnnotationUtils.java
@@ -29,6 +29,7 @@ import javax.annotation.processing.Messager;
 import javax.annotation.processing.ProcessingEnvironment;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
+import java.util.Set;
 
 /**
  * Utility methods for annotations.
@@ -143,7 +144,8 @@ public class AnnotationUtils {
             modelUtils,
             filer,
             visitorAttributes,
-            TypeElementVisitor.VisitorKind.ISOLATING
+            TypeElementVisitor.VisitorKind.ISOLATING,
+            Set.of()
         );
     }
 
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java b/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
index 9822fdb1b7..3eacf20325 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/TypeElementVisitorProcessor.java
@@ -107,7 +107,6 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
 
     private List<LoadedVisitor> loadedVisitors;
     private Collection<? extends TypeElementVisitor<?, ?>> typeElementVisitors;
-    private final Set<String> pendingTypes = new LinkedHashSet<>();
 
     /**
      * The visited annotation names.
@@ -241,8 +240,8 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
                 roundEnv.getRootElements()
             ).filter(notGroovyObject).forEach(elements::add);
 
-            pendingTypes.stream().map(elementUtils::getTypeElement).filter(Objects::nonNull).forEach(elements::add);
-            pendingTypes.clear();
+            postponedTypes.stream().map(elementUtils::getTypeElement).filter(Objects::nonNull).forEach(elements::add);
+            postponedTypes.clear();
 
             if (!elements.isEmpty()) {
 
@@ -272,7 +271,7 @@ public class TypeElementVisitorProcessor extends AbstractInjectAnnotationProcess
                             }
                             error(originatingElement.element(), e.getMessage());
                         } catch (PostponeToNextRoundException e) {
-                            pendingTypes.add(javaClassElement.getName());
+                            postponedTypes.add(javaClassElement.getName());
                         }
                     }
                 }
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
index 4dbefa908f..d9059e1f78 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
@@ -52,6 +52,7 @@ import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.TypeParameterElement;
 import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
 import java.lang.annotation.Annotation;
@@ -265,11 +266,15 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
     @Override
     public Collection<ClassElement> getInterfaces() {
         if (resolvedInterfaces == null) {
-            resolvedInterfaces = classElement.getInterfaces().stream().map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
+            resolvedInterfaces = classElement.getInterfaces().stream().filter(this::onlyAvailable).map(mirror -> newClassElement(mirror, getTypeArguments())).toList();
         }
         return resolvedInterfaces;
     }
 
+    private boolean onlyAvailable(TypeMirror mirror) {
+        return !(mirror instanceof DeclaredType declaredType) || declaredType.getKind() != TypeKind.ERROR;
+    }
+
     @Override
     public Optional<ClassElement> getSuperType() {
         if (resolvedSuperType == null) {
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java
index b9966d8988..be7a7e5662 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaVisitorContext.java
@@ -17,6 +17,7 @@ package io.micronaut.annotation.processing.visitor;
 
 import io.micronaut.annotation.processing.AnnotationProcessingOutputVisitor;
 import io.micronaut.annotation.processing.AnnotationUtils;
+import io.micronaut.inject.visitor.ElementPostponedToNextRoundException;
 import io.micronaut.annotation.processing.GenericUtils;
 import io.micronaut.annotation.processing.JavaAnnotationMetadataBuilder;
 import io.micronaut.annotation.processing.JavaElementAnnotationMetadataFactory;
@@ -66,6 +67,7 @@ import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Enumeration;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -100,6 +102,7 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
     private final JavaElementAnnotationMetadataFactory elementAnnotationMetadataFactory;
     private final JavaNativeElementsHelper nativeElementsHelper;
     private final Filer filer;
+    private final Set<String> postponedTypes;
 
     /**
      * The default constructor.
@@ -128,7 +131,7 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
         Filer filer,
         MutableConvertibleValues<Object> visitorAttributes,
         TypeElementVisitor.VisitorKind visitorKind) {
-        this(processingEnv, messager, elements, types, modelUtils, filer, visitorAttributes, visitorKind);
+        this(processingEnv, messager, elements, types, modelUtils, filer, visitorAttributes, visitorKind, new HashSet<>());
     }
 
     /**
@@ -142,7 +145,9 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
      * @param filer The filer
      * @param visitorAttributes The attributes
      * @param visitorKind The visitor kind
+     * @deprecated No longer needed
      */
+    @Deprecated(forRemoval = true, since = "4.7.0")
     public JavaVisitorContext(
         ProcessingEnvironment processingEnv,
         Messager messager,
@@ -152,6 +157,32 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
         Filer filer,
         MutableConvertibleValues<Object> visitorAttributes,
         TypeElementVisitor.VisitorKind visitorKind) {
+        this(processingEnv, messager, elements, types, modelUtils, filer, visitorAttributes, visitorKind, Set.of());
+    }
+
+    /**
+     * The default constructor.
+     *
+     * @param processingEnv The processing environment
+     * @param messager The messager
+     * @param elements The elements
+     * @param types Type types
+     * @param modelUtils The model utils
+     * @param filer The filer
+     * @param visitorAttributes The attributes
+     * @param visitorKind The visitor kind
+     * @param postponedTypes The postponed types
+     */
+    public JavaVisitorContext(
+        ProcessingEnvironment processingEnv,
+        Messager messager,
+        Elements elements,
+        Types types,
+        ModelUtils modelUtils,
+        Filer filer,
+        MutableConvertibleValues<Object> visitorAttributes,
+        TypeElementVisitor.VisitorKind visitorKind,
+        Set<String> postponedTypes) {
         this.messager = messager;
         this.elements = elements;
         this.types = types;
@@ -166,6 +197,7 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
         this.elementAnnotationMetadataFactory = new JavaElementAnnotationMetadataFactory(false, this.annotationMetadataBuilder);
         this.expressionCompilationContextFactory = new DefaultExpressionCompilationContextFactory(this);
         this.filer = filer;
+        this.postponedTypes = postponedTypes;
     }
 
     @Override
@@ -321,13 +353,29 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
         }
     }
 
+    private void checkForPostponedOriginalElement(io.micronaut.inject.ast.Element originatingElement) {
+        if (originatingElement != null && postponedTypes.contains(originatingElement.getName())) {
+            throw new ElementPostponedToNextRoundException(originatingElement);
+        }
+    }
+
+    private void checkForPostponedOriginalElements(io.micronaut.inject.ast.Element[] originatingElements) {
+        if (originatingElements != null) {
+            for (io.micronaut.inject.ast.Element originatingElement : originatingElements) {
+                checkForPostponedOriginalElement(originatingElement);
+            }
+        }
+    }
+
     @Override
     public OutputStream visitClass(String classname, @Nullable io.micronaut.inject.ast.Element originatingElement) throws IOException {
+        checkForPostponedOriginalElement(originatingElement);
         return outputVisitor.visitClass(classname, new io.micronaut.inject.ast.Element[] {originatingElement});
     }
 
     @Override
     public OutputStream visitClass(String classname, io.micronaut.inject.ast.Element... originatingElements) throws IOException {
+        checkForPostponedOriginalElements(originatingElements);
         return outputVisitor.visitClass(classname, originatingElements);
     }
 
@@ -338,11 +386,13 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
 
     @Override
     public void visitServiceDescriptor(String type, String classname, io.micronaut.inject.ast.Element originatingElement) {
+        checkForPostponedOriginalElement(originatingElement);
         outputVisitor.visitServiceDescriptor(type, classname, originatingElement);
     }
 
     @Override
     public Optional<GeneratedFile> visitMetaInfFile(String path, io.micronaut.inject.ast.Element... originatingElements) {
+        checkForPostponedOriginalElements(originatingElements);
         return outputVisitor.visitMetaInfFile(path, originatingElements);
     }
 
@@ -353,11 +403,13 @@ public final class JavaVisitorContext implements VisitorContext, BeanElementVisi
 
     @Override
     public Optional<GeneratedFile> visitGeneratedFile(String path, io.micronaut.inject.ast.Element... originatingElements) {
+        checkForPostponedOriginalElements(originatingElements);
         return outputVisitor.visitGeneratedFile(path, originatingElements);
     }
 
     @Override
     public Optional<GeneratedFile> visitGeneratedSourceFile(String packageName, String fileNameWithoutExtension, io.micronaut.inject.ast.Element... originatingElements) {
+        checkForPostponedOriginalElements(originatingElements);
         return outputVisitor.visitGeneratedSourceFile(packageName, fileNameWithoutExtension, originatingElements);
     }
 
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/CoreReaders1.java b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/CoreReaders1.java
new file mode 100644
index 0000000000..6ab95e135a
--- /dev/null
+++ b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/CoreReaders1.java
@@ -0,0 +1,14 @@
+package io.micronaut.inject.foreach.generic;
+
+import jakarta.inject.Inject;
+import jakarta.inject.Singleton;
+
+@Singleton
+public class CoreReaders1 {
+
+    @Inject
+    public CoreReader1<String> stringReader;
+    @Inject
+    public CoreReader1<Integer> integerReader;
+
+}
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/CoreReaders2.java b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/CoreReaders2.java
new file mode 100644
index 0000000000..f1a11dae2e
--- /dev/null
+++ b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/CoreReaders2.java
@@ -0,0 +1,14 @@
+package io.micronaut.inject.foreach.generic;
+
+import jakarta.inject.Inject;
+import jakarta.inject.Singleton;
+
+@Singleton
+public class CoreReaders2 {
+
+    @Inject
+    public CoreReader2<String> stringReader;
+    @Inject
+    public CoreReader2<Integer> integerReader;
+
+}
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/EachBeanGenericSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/EachBeanGenericSpec.groovy
index 3c6e286841..f7fc6da585 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/EachBeanGenericSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/EachBeanGenericSpec.groovy
@@ -13,9 +13,11 @@ class EachBeanGenericSpec extends Specification {
         when:
             def registrations = context.getBeanRegistrations(CoreReader1)
         then:
-            registrations.size() == 1
-            registrations[0].definition().getTypeArguments(CoreReader1).size() == 1
-            registrations[0].definition().getTypeArguments(CoreReader1)[0].type == String
+            registrations.size() == 2
+            registrations.forEach {
+                assert it.definition().getTypeArguments(CoreReader1).size() == 1
+            }
+            registrations.collect { it.definition().getTypeArguments(CoreReader1)[0].type }.toSet() == [String, Integer].toSet()
         cleanup:
             context.close()
     }
@@ -28,9 +30,30 @@ class EachBeanGenericSpec extends Specification {
         when:
             def registrations = context.getBeanRegistrations(CoreReader2)
         then:
-            registrations.size() == 1
-            registrations[0].definition().getTypeArguments(CoreReader2).size() == 1
-            registrations[0].definition().getTypeArguments(CoreReader2)[0].type == String
+            registrations.size() == 2
+            registrations.forEach {
+                assert it.definition().getTypeArguments(CoreReader2).size() == 1
+            }
+            registrations.collect { it.definition().getTypeArguments(CoreReader2)[0].type }.toSet() == [String, Integer].toSet()
+        cleanup:
+            context.close()
+    }
+
+    void "test inject each bean also delegates generics"() {
+        given:
+            ApplicationContext context = ApplicationContext.run([
+                    'spec': 'EachBeanGenericSpec'
+            ])
+        when:
+            def coreReaders1 = context.getBean(CoreReaders1)
+        then:
+            coreReaders1.integerReader
+            coreReaders1.stringReader
+        when:
+            def coreReaders2 = context.getBean(CoreReaders2)
+        then:
+            coreReaders2.integerReader
+            coreReaders2.stringReader
         cleanup:
             context.close()
     }
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/IntegerMyReader1.java b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/IntegerMyReader1.java
new file mode 100644
index 0000000000..f2603d87ad
--- /dev/null
+++ b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/IntegerMyReader1.java
@@ -0,0 +1,11 @@
+package io.micronaut.inject.foreach.generic;
+
+import jakarta.inject.Singleton;
+
+@Singleton
+public class IntegerMyReader1 implements MyReader1<Integer> {
+    @Override
+    public Integer read() {
+        return 1;
+    }
+}
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/IntegerMyReader2.java b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/IntegerMyReader2.java
new file mode 100644
index 0000000000..9e3b3588e4
--- /dev/null
+++ b/inject-java/src/test/groovy/io/micronaut/inject/foreach/generic/IntegerMyReader2.java
@@ -0,0 +1,11 @@
+package io.micronaut.inject.foreach.generic;
+
+import jakarta.inject.Singleton;
+
+@Singleton
+public class IntegerMyReader2 implements MyReader2<Integer> {
+    @Override
+    public Integer read() {
+        return 1;
+    }
+}
diff --git a/inject-java/src/test/groovy/io/micronaut/visitors/PostponedVisitorsSpec.groovy b/inject-java/src/test/groovy/io/micronaut/visitors/PostponedVisitorsSpec.groovy
new file mode 100644
index 0000000000..e2a6d86f44
--- /dev/null
+++ b/inject-java/src/test/groovy/io/micronaut/visitors/PostponedVisitorsSpec.groovy
@@ -0,0 +1,31 @@
+package io.micronaut.visitors
+
+
+import io.micronaut.annotation.processing.test.AbstractTypeElementSpec
+
+class PostponedVisitorsSpec extends AbstractTypeElementSpec {
+
+    void 'test'() {
+        when:
+            def definition = buildBeanIntrospection('test.Walrus', '''
+package test;
+
+import io.micronaut.core.annotation.Introspected;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.visitors.Wither;
+
+@Introspected
+@Wither
+public record Walrus (
+    @NonNull
+    String name,
+    int age,
+    byte[] chipInfo
+) implements WalrusWither  {
+}
+
+''')
+        then:
+            definition
+    }
+}
diff --git a/inject-java/src/test/groovy/io/micronaut/visitors/Wither.java b/inject-java/src/test/groovy/io/micronaut/visitors/Wither.java
new file mode 100644
index 0000000000..c07c477900
--- /dev/null
+++ b/inject-java/src/test/groovy/io/micronaut/visitors/Wither.java
@@ -0,0 +1,8 @@
+package io.micronaut.visitors;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+
+@Retention(RetentionPolicy.RUNTIME)
+public @interface Wither {
+}
diff --git a/inject-java/src/test/groovy/io/micronaut/visitors/WitherVisitor.java b/inject-java/src/test/groovy/io/micronaut/visitors/WitherVisitor.java
new file mode 100644
index 0000000000..682385d143
--- /dev/null
+++ b/inject-java/src/test/groovy/io/micronaut/visitors/WitherVisitor.java
@@ -0,0 +1,47 @@
+package io.micronaut.visitors;
+
+import io.micronaut.inject.ast.ClassElement;
+import io.micronaut.inject.processing.ProcessingException;
+import io.micronaut.inject.visitor.TypeElementVisitor;
+import io.micronaut.inject.visitor.VisitorContext;
+
+public class WitherVisitor implements TypeElementVisitor<Wither, Object> {
+
+    @Override
+    public void visitClass(ClassElement element, VisitorContext context) {
+            context.visitGeneratedSourceFile(
+                "test",
+                "WalrusWither",
+                element
+            ).ifPresent(sourceFile -> {
+                try {
+                    sourceFile.write(writer -> writer.write("""
+                        package test;
+
+                        public interface WalrusWither {
+                            String name();
+
+                            int age();
+
+                            byte[] chipInfo();
+
+                            default Walrus withName(String name) {
+                                return new Walrus(name, this.age(), this.chipInfo());
+                            }
+
+                            default Walrus withAge(int age) {
+                                return new Walrus(this.name(), age, this.chipInfo());
+                            }
+
+                            default Walrus withChipInfo(byte[] chipInfo) {
+                                return new Walrus(this.name(), this.age(), chipInfo);
+                            }
+                        }
+                        """));
+                } catch (Exception e) {
+                    throw new ProcessingException(element, "Failed to generate a Wither: " + e.getMessage(), e);
+                }
+            });
+    }
+
+}
diff --git a/inject-java/src/test/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor b/inject-java/src/test/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor
index 71ade81eba..e8e846e183 100644
--- a/inject-java/src/test/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor
+++ b/inject-java/src/test/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor
@@ -19,3 +19,4 @@ io.micronaut.annotation.AnnotatePropertySpec$AnnotatePropertyVisitor
 io.micronaut.annotation.AnnotateClassSpec$AnnotateClassVisitor
 io.micronaut.annotation.AnnotateTypeArgSpec$AnnotateTypeArgVisitor
 io.micronaut.aop.introduction.beans.MyRepoVisitor2
+io.micronaut.visitors.WitherVisitor
diff --git a/inject-kotlin-test/build.gradle b/inject-kotlin-test/build.gradle
index 4a4c5328e9..2b3231dc95 100644
--- a/inject-kotlin-test/build.gradle
+++ b/inject-kotlin-test/build.gradle
@@ -13,7 +13,7 @@ dependencies {
     api(libs.managed.ksp)
     implementation(libs.managed.kotlin.compiler.embeddable)
     implementation "com.squareup.okio:okio:3.9.0"
-    implementation "io.github.classgraph:classgraph:4.8.174"
+    implementation "io.github.classgraph:classgraph:4.8.175"
     testImplementation libs.javax.persistence
     testImplementation project(":runtime")
     api libs.blaze.persistence.core
diff --git a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
index 1d331c209f..4eeded5f72 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
@@ -459,12 +459,15 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
     }
 
     @Override
-    protected <T> void collectIterableBeans(BeanResolutionContext resolutionContext, BeanDefinition<T> iterableBean, Set<BeanDefinition<T>> targetSet) {
+    protected <T> void collectIterableBeans(@Nullable BeanResolutionContext resolutionContext,
+                                            @NonNull BeanDefinition<T> iterableBean,
+                                            @NonNull Set<BeanDefinition<T>> targetSet,
+                                            @NonNull Argument<T> beanType) {
         try (BeanResolutionContext rc = newResolutionContext(iterableBean, resolutionContext)) {
             if (iterableBean.hasDeclaredStereotype(EachProperty.class)) {
                 transformEachPropertyBeanDefinition(rc, iterableBean, targetSet);
             } else if (iterableBean.hasDeclaredStereotype(EachBean.class)) {
-                transformEachBeanBeanDefinition(rc, iterableBean, targetSet);
+                transformEachBeanBeanDefinition(rc, iterableBean, targetSet, beanType);
             } else {
                 transformConfigurationReaderBeanDefinition(rc, iterableBean, targetSet);
             }
@@ -544,7 +547,8 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
 
     private <T> void transformEachBeanBeanDefinition(@NonNull BeanResolutionContext resolutionContext,
                                                      BeanDefinition<T> originBeanDefinition,
-                                                     Set<BeanDefinition<T>> transformedCandidates) {
+                                                     Set<BeanDefinition<T>> transformedCandidates,
+                                                     @NonNull Argument<T> beanType) {
         AnnotationValue<EachBean> annotationValue = originBeanDefinition.getAnnotation(EachBean.class);
         if (annotationValue == null) {
             transformedCandidates.add(originBeanDefinition);
@@ -591,7 +595,7 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
                         delegateTypeArguments = typeArguments;
                     }
                     BeanDefinitionDelegate<?> delegate = BeanDefinitionDelegate.create(originBeanDefinition, (Qualifier<T>) qualifier, delegateTypeArguments);
-                    if (delegate.isEnabled(this, resolutionContext)) {
+                    if (delegate.isEnabled(this, resolutionContext) && delegate.isCandidateBean(beanType)) {
                         transformedCandidates.add((BeanDefinition<T>) delegate);
                     }
                 }
@@ -600,8 +604,8 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
     }
 
     private <T> void transformEachPropertyBeanDefinition(@NonNull BeanResolutionContext resolutionContext,
-                                                         BeanDefinition<T> candidate,
-                                                         Set<BeanDefinition<T>> transformedCandidates) {
+                                                         @NonNull BeanDefinition<T> candidate,
+                                                         @NonNull Set<BeanDefinition<T>> transformedCandidates) {
         try {
             final String prefix = candidate.stringValue(ConfigurationReader.class, ConfigurationReader.PREFIX).orElse(null);
             if (prefix != null) {
diff --git a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
index ac69388e77..ae0471ea4c 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
@@ -72,7 +72,7 @@ import io.micronaut.core.convert.TypeConverterRegistrar;
 import io.micronaut.core.convert.value.MutableConvertibleValues;
 import io.micronaut.core.io.ResourceLoader;
 import io.micronaut.core.io.scan.ClassPathResourceLoader;
-import io.micronaut.core.io.service.SoftServiceLoader;
+import io.micronaut.core.io.service.MicronautMetaServiceLoaderUtils;
 import io.micronaut.core.naming.NameResolver;
 import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.naming.Named;
@@ -1876,9 +1876,11 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     @NonNull
     protected List<BeanDefinitionReference> resolveBeanDefinitionReferences() {
         if (beanDefinitionReferences == null) {
-            final SoftServiceLoader<BeanDefinitionReference> definitions = SoftServiceLoader.load(BeanDefinitionReference.class, classLoader);
-            beanDefinitionReferences = new ArrayList<>(300);
-            definitions.collectAll(beanDefinitionReferences, BeanDefinitionReference::isPresent);
+            beanDefinitionReferences = MicronautMetaServiceLoaderUtils.findMetaMicronautServiceEntries(
+                classLoader,
+                BeanDefinitionReference.class,
+                BeanDefinitionReference::isPresent
+            );
         }
         return beanDefinitionReferences;
     }
@@ -1913,9 +1915,11 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     @NonNull
     protected Iterable<BeanConfiguration> resolveBeanConfigurations() {
         if (beanConfigurationsList == null) {
-            final SoftServiceLoader<BeanConfiguration> definitions = SoftServiceLoader.load(BeanConfiguration.class, classLoader);
-            beanConfigurationsList = new ArrayList<>(300);
-            definitions.collectAll(beanConfigurationsList, null);
+            beanConfigurationsList = MicronautMetaServiceLoaderUtils.findMetaMicronautServiceEntries(
+                classLoader,
+                BeanConfiguration.class,
+                null
+            );
         }
         return beanConfigurationsList;
     }
@@ -2165,7 +2169,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                 }
 
                 if (collectIterables && loadedBean.isConfigurationProperties()) {
-                    collectIterableBeans(resolutionContext, loadedBean, candidates);
+                    collectIterableBeans(resolutionContext, loadedBean, candidates, beanType);
                 } else {
                     candidates.add(loadedBean);
                 }
@@ -2195,9 +2199,13 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
      * @param resolutionContext The resolution context
      * @param iterableBean The iterable
      * @param targetSet The target set
+     * @param beanType The bean type
      * @param <T> The bean type
      */
-    protected <T> void collectIterableBeans(@Nullable BeanResolutionContext resolutionContext, @NonNull BeanDefinition<T> iterableBean, Set<BeanDefinition<T>> targetSet) {
+    protected <T> void collectIterableBeans(@Nullable BeanResolutionContext resolutionContext,
+                                            @NonNull BeanDefinition<T> iterableBean,
+                                            @NonNull Set<BeanDefinition<T>> targetSet,
+                                            @NonNull Argument<T> beanType) {
         // no-op
     }
 
@@ -2678,7 +2686,8 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
             collectIterableBeans(
                 null,
                 beanDefinition,
-                beanCandidates
+                beanCandidates,
+                Argument.OBJECT_ARGUMENT
             );
             for (BeanDefinition beanCandidate : beanCandidates) {
                 findOrCreateSingletonBeanRegistration(
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JacksonMediaTypeCodec.java b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JacksonMediaTypeCodec.java
index cf9bca1b80..41e3d97147 100644
--- a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JacksonMediaTypeCodec.java
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JacksonMediaTypeCodec.java
@@ -41,7 +41,9 @@ import java.io.IOException;
  *
  * @author Graeme Rocher
  * @since 1.0.0
+ * @deprecated Replaced with message body writers / readers API
  */
+@Deprecated(forRemoval = true, since = "4.7")
 public abstract class JacksonMediaTypeCodec extends MapperMediaTypeCodec {
 
     public static final String REGULAR_JSON_MEDIA_TYPE_CODEC_NAME = "json";
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonMediaTypeCodec.java b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonMediaTypeCodec.java
index 1de93fa5ed..90942132d4 100644
--- a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonMediaTypeCodec.java
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonMediaTypeCodec.java
@@ -36,12 +36,14 @@ import jakarta.inject.Singleton;
  *
  * @author Graeme Rocher
  * @since 1.0.0
+ * @deprecated Replaced with message body writers / readers API
  */
 @Named("json")
 @Singleton
 @Secondary
 @BootstrapContextCompatible
 @Bean(typed = {JsonMediaTypeCodec.class, JacksonMediaTypeCodec.class}) // do not expose MapperMediaTypeCodec
+@Deprecated(forRemoval = true, since = "4.7")
 public class JsonMediaTypeCodec extends JacksonMediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "json";
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonStreamMediaTypeCodec.java b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonStreamMediaTypeCodec.java
index 2244c6e37a..021b9485ad 100644
--- a/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonStreamMediaTypeCodec.java
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/codec/JsonStreamMediaTypeCodec.java
@@ -41,11 +41,13 @@ import java.util.List;
  *
  * @author Graeme Rocher
  * @since 1.0
+ * @deprecated Replaced with message body writers / readers API
  */
 @Secondary
 @Singleton
 @BootstrapContextCompatible
 @Bean(typed = {JsonStreamMediaTypeCodec.class, JacksonMediaTypeCodec.class}) // do not expose MapperMediaTypeCodec
+@Deprecated(forRemoval = true, since = "4.7")
 public class JsonStreamMediaTypeCodec extends JsonMediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "json-stream";
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/body/CustomizableNettyJsonHandler.java b/json-core/src/main/java/io/micronaut/json/body/CustomizableJsonHandler.java
similarity index 80%
rename from http-netty/src/main/java/io/micronaut/http/netty/body/CustomizableNettyJsonHandler.java
rename to json-core/src/main/java/io/micronaut/json/body/CustomizableJsonHandler.java
index 6e104abc42..248e346cd5 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/body/CustomizableNettyJsonHandler.java
+++ b/json-core/src/main/java/io/micronaut/json/body/CustomizableJsonHandler.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package io.micronaut.http.netty.body;
+package io.micronaut.json.body;
 
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
@@ -22,11 +22,11 @@ import io.micronaut.json.JsonFeatures;
 /**
  * {@link io.micronaut.http.body.MessageBodyHandler} that is customizable with {@link JsonFeatures}.
  *
- * @since 4.0.0
- * @author Jonas Konrad
+ * @since 4.7.0
+ * @author Denis Stepanov
  */
 @Internal
-public interface CustomizableNettyJsonHandler {
+public interface CustomizableJsonHandler {
     @NonNull
-    CustomizableNettyJsonHandler customize(@NonNull JsonFeatures jsonFeatures);
+    CustomizableJsonHandler customize(@NonNull JsonFeatures jsonFeatures);
 }
diff --git a/json-core/src/main/java/io/micronaut/json/body/JsonMessageHandler.java b/json-core/src/main/java/io/micronaut/json/body/JsonMessageHandler.java
index 878b235d50..8111fe6e77 100644
--- a/json-core/src/main/java/io/micronaut/json/body/JsonMessageHandler.java
+++ b/json-core/src/main/java/io/micronaut/json/body/JsonMessageHandler.java
@@ -18,6 +18,7 @@ package io.micronaut.json.body;
 import io.micronaut.context.annotation.BootstrapContextCompatible;
 import io.micronaut.core.annotation.Experimental;
 import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Order;
 import io.micronaut.core.io.buffer.ByteBuffer;
 import io.micronaut.core.io.buffer.ReferenceCounted;
 import io.micronaut.core.type.Argument;
@@ -30,6 +31,7 @@ import io.micronaut.http.annotation.Produces;
 import io.micronaut.http.body.MessageBodyHandler;
 import io.micronaut.http.body.MessageBodyWriter;
 import io.micronaut.http.codec.CodecException;
+import io.micronaut.json.JsonFeatures;
 import io.micronaut.json.JsonMapper;
 import jakarta.inject.Singleton;
 
@@ -52,12 +54,18 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * @author Jonas Konrad
  * @since 4.0.0
  */
+@Order(JsonMessageHandler.ORDER)
 @Experimental
 @Singleton
 @JsonMessageHandler.ProducesJson
 @JsonMessageHandler.ConsumesJson
 @BootstrapContextCompatible
-public final class JsonMessageHandler<T> implements MessageBodyHandler<T> {
+public final class JsonMessageHandler<T> implements MessageBodyHandler<T>, CustomizableJsonHandler {
+
+    /**
+     * The JSON handler should be preferred if for any type.
+     */
+    public static final int ORDER = -10;
 
     private final JsonMapper jsonMapper;
 
@@ -77,7 +85,7 @@ public final class JsonMessageHandler<T> implements MessageBodyHandler<T> {
 
     @Override
     public boolean isReadable(@NonNull Argument<T> type, MediaType mediaType) {
-        return mediaType != null && mediaType.getExtension().equals(MediaType.EXTENSION_JSON);
+        return mediaType != null && mediaType.matchesExtension(MediaType.EXTENSION_JSON);
     }
 
     private static CodecException decorateRead(Argument<?> type, IOException e) {
@@ -114,7 +122,7 @@ public final class JsonMessageHandler<T> implements MessageBodyHandler<T> {
 
     @Override
     public boolean isWriteable(@NonNull Argument<T> type, MediaType mediaType) {
-        return mediaType != null && mediaType.getExtension().equals(MediaType.EXTENSION_JSON);
+        return mediaType != null && mediaType.matchesExtension(MediaType.EXTENSION_JSON);
     }
 
     private static CodecException decorateWrite(Object object, IOException e) {
@@ -135,6 +143,11 @@ public final class JsonMessageHandler<T> implements MessageBodyHandler<T> {
         }
     }
 
+    @Override
+    public CustomizableJsonHandler customize(JsonFeatures jsonFeatures) {
+        return new JsonMessageHandler<>(jsonMapper.cloneWithFeatures(jsonFeatures));
+    }
+
     /**
      * A {@link Produces} with JSON supported types.
      */
diff --git a/json-core/src/main/java/io/micronaut/json/codec/JsonMediaTypeCodec.java b/json-core/src/main/java/io/micronaut/json/codec/JsonMediaTypeCodec.java
index 74cc1fd7fc..4b4da776ff 100644
--- a/json-core/src/main/java/io/micronaut/json/codec/JsonMediaTypeCodec.java
+++ b/json-core/src/main/java/io/micronaut/json/codec/JsonMediaTypeCodec.java
@@ -35,11 +35,13 @@ import java.util.List;
  *
  * @author Graeme Rocher
  * @since 1.0.0
+ * @deprecated Replaced with message body writers / readers API
  */
 @Experimental
 @Named(MapperMediaTypeCodec.REGULAR_JSON_MEDIA_TYPE_CODEC_NAME)
 @Singleton
 @BootstrapContextCompatible
+@Deprecated(forRemoval = true, since = "4.7")
 public class JsonMediaTypeCodec extends MapperMediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "json";
diff --git a/json-core/src/main/java/io/micronaut/json/codec/JsonStreamMediaTypeCodec.java b/json-core/src/main/java/io/micronaut/json/codec/JsonStreamMediaTypeCodec.java
index 358aa19dbf..507f943a86 100644
--- a/json-core/src/main/java/io/micronaut/json/codec/JsonStreamMediaTypeCodec.java
+++ b/json-core/src/main/java/io/micronaut/json/codec/JsonStreamMediaTypeCodec.java
@@ -37,10 +37,12 @@ import java.util.List;
  *
  * @author Graeme Rocher
  * @since 1.0
+ * @deprecated Replaced with message body writers / readers API
  */
 @Experimental
 @Singleton
 @BootstrapContextCompatible
+@Deprecated(forRemoval = true, since = "4.7")
 public class JsonStreamMediaTypeCodec extends JsonMediaTypeCodec {
 
     public static final String CONFIGURATION_QUALIFIER = "json-stream";
diff --git a/json-core/src/main/java/io/micronaut/json/codec/MapperMediaTypeCodec.java b/json-core/src/main/java/io/micronaut/json/codec/MapperMediaTypeCodec.java
index 79d80be54d..38bcbe8056 100644
--- a/json-core/src/main/java/io/micronaut/json/codec/MapperMediaTypeCodec.java
+++ b/json-core/src/main/java/io/micronaut/json/codec/MapperMediaTypeCodec.java
@@ -47,7 +47,9 @@ import java.util.List;
  * @author Graeme Rocher
  * @author svishnyakov
  * @since 1.3.0
+ * @deprecated Replaced with message body writers / readers API
  */
+@Deprecated(since = "4.7")
 @Experimental
 public abstract class MapperMediaTypeCodec implements MediaTypeCodec {
     public static final String REGULAR_JSON_MEDIA_TYPE_CODEC_NAME = "json";
diff --git a/retry/src/main/java/io/micronaut/retry/intercept/SimpleRetry.java b/retry/src/main/java/io/micronaut/retry/intercept/SimpleRetry.java
index c4c43859f7..c4f06fe796 100644
--- a/retry/src/main/java/io/micronaut/retry/intercept/SimpleRetry.java
+++ b/retry/src/main/java/io/micronaut/retry/intercept/SimpleRetry.java
@@ -46,7 +46,7 @@ class SimpleRetry implements RetryState, MutableRetryState {
     private final Class<? extends Throwable> capturedException;
 
     /**
-     * @param maxAttempts The maximum number of attemps
+     * @param maxAttempts The maximum number of attempts
      * @param multiplier The multiplier to use between delays
      * @param delay The overall delay so far
      * @param maxDelay The maximum overall delay
@@ -70,7 +70,7 @@ class SimpleRetry implements RetryState, MutableRetryState {
     }
 
     /**
-     * @param maxAttempts The maximum number of attemps
+     * @param maxAttempts The maximum number of attempts
      * @param multiplier The multiplier to use between delays
      * @param delay The overall delay so far
      * @param maxDelay The maximum overall delay
@@ -81,7 +81,7 @@ class SimpleRetry implements RetryState, MutableRetryState {
     }
 
     /**
-     * @param maxAttempts The maximum number of attemps
+     * @param maxAttempts The maximum number of attempts
      * @param multiplier The multiplier to use between delays
      * @param delay The overall delay so far
      */
diff --git a/runtime/src/test/groovy/io/micronaut/runtime/converters/time/TimeConverterRegistrarSpec.groovy b/runtime/src/test/groovy/io/micronaut/runtime/converters/time/TimeConverterRegistrarSpec.groovy
index 9730049e5a..f2c5bb0a21 100644
--- a/runtime/src/test/groovy/io/micronaut/runtime/converters/time/TimeConverterRegistrarSpec.groovy
+++ b/runtime/src/test/groovy/io/micronaut/runtime/converters/time/TimeConverterRegistrarSpec.groovy
@@ -15,6 +15,7 @@
  */
 package io.micronaut.runtime.converters.time
 
+import io.micronaut.core.convert.ConversionService
 import io.micronaut.core.convert.DefaultMutableConversionService
 import spock.lang.Specification
 import spock.lang.Unroll
@@ -23,13 +24,8 @@ import java.time.Duration
 import java.time.Instant
 import java.time.LocalDate
 import java.time.LocalDateTime
-import java.time.LocalTime
-import java.time.MonthDay
 import java.time.OffsetDateTime
 import java.time.OffsetTime
-import java.time.Period
-import java.time.Year
-import java.time.YearMonth
 import java.time.ZoneId
 import java.time.ZoneOffset
 import java.time.ZonedDateTime
@@ -39,9 +35,10 @@ class TimeConverterRegistrarSpec extends Specification {
     @Unroll
     void "test convert duration #val"() {
         given:
-        def conversionService = new DefaultMutableConversionService()
+        ConversionService conversionService = new DefaultMutableConversionService()
         new TimeConverterRegistrar().register(conversionService)
 
+
         expect:
         conversionService.convert(val, Duration).get() == expected
 
@@ -53,67 +50,39 @@ class TimeConverterRegistrarSpec extends Specification {
         '10d'  | Duration.ofDays(10)
         '10h'  | Duration.ofHours(10)
         '10ns' | Duration.ofNanos(10)
-    }
-
-    @Unroll
-    void "test convert period #val"() {
-        given:
-        def conversionService = new DefaultMutableConversionService()
-        new TimeConverterRegistrar().register(conversionService)
-
-        expect:
-        conversionService.convert(val, Period).get() == expected
 
-        where:
-        val   | expected
-        '10y' | Period.ofYears(10)
-        '10m' | Period.ofMonths(10)
-        '10w' | Period.ofWeeks(10)
-        '10d' | Period.ofDays(10)
     }
-
     @Unroll
     void "test converts a #sourceObject.class.name to a #targetType.name"() {
         given:
-        def conversionService = new DefaultMutableConversionService()
+        ConversionService conversionService = new DefaultMutableConversionService()
         new TimeConverterRegistrar().register(conversionService)
 
         expect:
         conversionService.convert(sourceObject, targetType).get() == result
 
         where:
-        sourceObject                                                            | targetType     | result
-        Instant.ofEpochMilli(123)                                               | Date           | new Date(123)
-        Instant.ofEpochMilli(123).atOffset(ZoneOffset.ofHours(5))               | Date           | new Date(123)
-        Instant.ofEpochMilli(123).atZone(ZoneId.of("Europe/Berlin"))            | Date           | new Date(123)
-        Instant.ofEpochMilli(123).atOffset(ZoneOffset.UTC).toLocalDateTime()    | Date           | new Date(123)
-        Instant.ofEpochMilli(123).atOffset(ZoneOffset.UTC).toLocalDate()        | Date           | new Date(0)
+        sourceObject            | targetType  | result
+        Instant.ofEpochMilli(123)                                            | Date | new Date(123)
+        Instant.ofEpochMilli(123).atOffset(ZoneOffset.ofHours(5))            | Date | new Date(123)
+        Instant.ofEpochMilli(123).atZone(ZoneId.of("Europe/Berlin"))         | Date | new Date(123)
+        Instant.ofEpochMilli(123).atOffset(ZoneOffset.UTC).toLocalDateTime() | Date | new Date(123)
+        Instant.ofEpochMilli(123).atOffset(ZoneOffset.UTC).toLocalDate()     | Date | new Date(0)
 
-        "2022-08-12"                                                            | LocalDate      | LocalDate.of(2022, 8, 12)
-        "2022-08-12T12:19:00"                                                   | LocalDateTime  | LocalDateTime.of(2022, 8, 12, 12, 19)
-        "12:19:00+05:00"                                                        | OffsetTime     | OffsetTime.of(12, 19, 0, 0, ZoneOffset.ofHours(5))
-        "2022-08-12T12:19:00+05:00"                                             | OffsetDateTime | OffsetDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneOffset.ofHours(5))
-        "2022-08-12T12:19:00+05:00"                                             | ZonedDateTime  | ZonedDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneOffset.ofHours(5))
-        "2022-08-12T12:19:00+02:00[Europe/Berlin]"                              | ZonedDateTime  | ZonedDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneId.of("Europe/Berlin"))
-        "2022-08-12T12:19:00Z"                                                  | Instant        | LocalDateTime.of(2022, 8, 12, 12, 19).toInstant(ZoneOffset.UTC)
-        "12:19:00"                                                              | LocalTime      | LocalTime.of(12, 19)
-        "--12-19"                                                               | MonthDay       | MonthDay.of(12, 19)
-        "2022-08"                                                               | YearMonth      | YearMonth.of(2022, 8)
-        "2022"                                                                  | Year           | Year.of(2022)
-        2022                                                                    | Year           | Year.of(2022)
-        "+07:00"                                                                | ZoneId         | ZoneId.of("+07:00")
+        "2022-08-12"                               | LocalDate      | LocalDate.of(2022, 8, 12)
+        "2022-08-12T12:19:00"                      | LocalDateTime  | LocalDateTime.of(2022, 8, 12, 12, 19)
+        "12:19:00+05:00"                           | OffsetTime     | OffsetTime.of(12, 19, 0, 0, ZoneOffset.ofHours(5))
+        "2022-08-12T12:19:00+05:00"                | OffsetDateTime | OffsetDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneOffset.ofHours(5))
+        "2022-08-12T12:19:00+05:00"                | ZonedDateTime  | ZonedDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneOffset.ofHours(5))
+        "2022-08-12T12:19:00+02:00[Europe/Berlin]" | ZonedDateTime  | ZonedDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneId.of("Europe/Berlin"))
+        "2022-08-12T12:19:00Z"                     | Instant        | LocalDateTime.of(2022, 8, 12, 12, 19).toInstant(ZoneOffset.UTC)
 
-        LocalDate.of(2022, 8, 12)                                               | String         | "2022-08-12"
-        LocalDateTime.of(2022, 8, 12, 12, 19)                                   | String         | "2022-08-12T12:19:00"
-        OffsetTime.of(12, 19, 0, 0, ZoneOffset.ofHours(5))                      | String         | "12:19:00+05:00"
-        OffsetDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneOffset.ofHours(5))     | String         | "2022-08-12T12:19:00+05:00"
-        ZonedDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneOffset.ofHours(5))      | String         | "2022-08-12T12:19:00+05:00"
-        ZonedDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneId.of("Europe/Berlin")) | String         | "2022-08-12T12:19:00+02:00[Europe/Berlin]"
-        LocalDateTime.of(2022, 8, 12, 12, 19).toInstant(ZoneOffset.UTC)         | String         | "2022-08-12T12:19:00Z"
-        LocalTime.of(12, 19)                                                    | String         | "12:19:00"
-        MonthDay.of(12, 19)                                                     | String         | "--12-19"
-        YearMonth.of(2022, 8)                                                   | String         | "2022-08"
-        Year.of(2022)                                                           | String         | "2022"
-        ZoneId.of("+07:00")                                                     | String         | "+07:00"
+        LocalDate.of(2022, 8, 12)                                               | String | "2022-08-12"
+        LocalDateTime.of(2022, 8, 12, 12, 19)                                   | String | "2022-08-12T12:19:00"
+        OffsetTime.of(12, 19, 0, 0, ZoneOffset.ofHours(5))                      | String | "12:19:00+05:00"
+        OffsetDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneOffset.ofHours(5))     | String | "2022-08-12T12:19:00+05:00"
+        ZonedDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneOffset.ofHours(5))      | String | "2022-08-12T12:19:00+05:00"
+        ZonedDateTime.of(2022, 8, 12, 12, 19, 0, 0, ZoneId.of("Europe/Berlin")) | String | "2022-08-12T12:19:00+02:00[Europe/Berlin]"
+        LocalDateTime.of(2022, 8, 12, 12, 19).toInstant(ZoneOffset.UTC)         | String | "2022-08-12T12:19:00Z"
     }
 }
diff --git a/settings.gradle b/settings.gradle
index 740a14d754..de7de3415e 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -6,7 +6,7 @@ pluginManagement {
 }
 
 plugins {
-    id 'io.micronaut.build.shared.settings' version '7.2.0'
+    id 'io.micronaut.build.shared.settings' version '7.2.1'
 }
 enableFeaturePreview("TYPESAFE_PROJECT_ACCESSORS")
 
@@ -82,7 +82,10 @@ include "test-suite-logback"
 include "test-suite-logback-external-configuration"
 include "test-suite-logback-graalvm"
 include "test-suite-netty-ssl-graalvm"
+include "test-suite-kotlin-graalvm"
 include "test-utils"
+include "test-suite-annotation-remapper"
+include "test-suite-annotation-remapper-visitor"
 
 // benchmarks
 include "benchmarks"
diff --git a/src/main/docs/guide/quickStart/ideSetup/vsCodeSetup.adoc b/src/main/docs/guide/quickStart/ideSetup/vsCodeSetup.adoc
index 26f3d5e8e8..dee1f9dfdb 100644
--- a/src/main/docs/guide/quickStart/ideSetup/vsCodeSetup.adoc
+++ b/src/main/docs/guide/quickStart/ideSetup/vsCodeSetup.adoc
@@ -1,34 +1,27 @@
-The Micronaut framework can be set up within Visual Studio Code in one of two ways.
+The Micronaut framework can easily be set up within Visual Studio Code by installing the following two extensions:
 
-==== Option 1) GraalVM Extension Pack for Java
+* https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[The Microsoft Extension Pack for Java]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools[Tools for MicronautÂ® framework]
 
-The prefered way is using the https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm-pack[GraalVM Extension Pack for Java] which ships with an https://netbeans.apache.org/[Apache NetBeans] Language server.
+These extensions can be installed by clicking on the *Install* button in the banner of the pages linked above, or, by searching for the extensions within VS Code.
 
-NOTE: It is not possible to have both the official https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[Java Extension Pack] and the GraalVM Extension Pack for Java installed at the same time so if you prefer the former, skip this section and go to Option 2)
+image::installing-tools-for-micronaut-vs-code.gif[Installing Micronaut tools, 1024, 1024]
 
-The https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.graalvm[GraalVM Tools for Java] are preferred since they delegate to the build system for running applications and tests which means there is no additional setup or differences with regard to how javac is configured for annotation processing when compared to the https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[Java Extension Pack] which is based on the Eclipse compiler.
+Once they are installed they will give you access to a host of Micronaut specific features such as:
 
-The GraalVM Extension Pack also includes the https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut[GraalVM Tools for Micronaut] extension which features:
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut#create-a-new-micronaut-project[An application creation wizard]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#view-defined-beans-and-endpoints[Viewing beans and REST endpoints]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#compose-rest-queries[Composing REST queries and running them]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#editor-support-for-micronaut-expression-language[Support for the Micronaut Expression Language]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#monitor-and-manage-your-micronaut-application[A Micronaut Tools Activity view for running and monitoring your applications]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#observe-your-micronaut-application-using-the-micronaut-control-panel[Support for using the Micronaut Control Panel]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#debug-your-micronaut-application[Debugging your application]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#package-your-micronaut-application[Support for packaging your application as a container]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#connect-to-an-oracle-autonomous-database[Support for connecting to and working with an Oracle Database]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#deploy-your-micronaut-application-to-oracle-cloud-infrastructure[Advanced support for deploying your applications to Oracle Cloud Infrastructure]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#create-entity-classes-and-repository-interfaces-from-an-existing-database-schema[Advanced support for creating Micronaut Data entities, repositories and controllers from existing database schemas]
+* https://marketplace.visualstudio.com/items?itemName=oracle-labs-graalvm.micronaut-tools#create-tests-for-micronaut-controller-endpoints[Test creation for Micronaut Data controllers endpoints]
 
-* An application creation wizard
-* Code completion for YAML configuration
-* Pallet commands to build, deploy, create Native Images etc.
-
-==== Option 2) Red Hat/Microsoft Java Extension Pack
-
-First install the https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack[Java Extension Pack].
-
-TIP: You can also optionally install https://marketplace.visualstudio.com/items?itemName=Pivotal.vscode-spring-boot[STS] to enable code completion for `application.yml`.
-
-If you use Gradle, prior to opening the project in VSC run the following command from a terminal window:
-
-[source,bash]
-----
-./gradlew eclipse
-----
-
-NOTE: If you don't run the above command beforehand then annotation processing will not be configured correctly and the application will not work.
-
-Once the extension pack is installed just type `code .` in any project directory and the project will be automatically set up.
+Once the extensions are installed just type `code .` in any Micronaut project directory and the project will be opened within VS Code.
 
 NOTE: For macOS, you need to install the `code` command https://code.visualstudio.com/docs/setup/mac[by following these instructions].
diff --git a/src/main/docs/guide/toc.yml b/src/main/docs/guide/toc.yml
index eb84e593f4..05a05ce20c 100644
--- a/src/main/docs/guide/toc.yml
+++ b/src/main/docs/guide/toc.yml
@@ -9,9 +9,9 @@ quickStart:
   ideSetup:
     title: Setting up an IDE
     ideaSetup: IntelliJ IDEA
+    vsCodeSetup: Visual Studio Code
     eclipseSetup: Eclipse
     netbeansSetup: Apache NetBeans
-    vsCodeSetup: Visual Studio Code
   creatingClient: Creating a Client
   deployingApp: Deploying the Application
 ioc:
diff --git a/src/main/docs/resources/img/installing-tools-for-micronaut-vs-code.gif b/src/main/docs/resources/img/installing-tools-for-micronaut-vs-code.gif
new file mode 100644
index 0000000000..29941fe072
Binary files /dev/null and b/src/main/docs/resources/img/installing-tools-for-micronaut-vs-code.gif differ
diff --git a/test-suite-annotation-remapper-visitor/build.gradle b/test-suite-annotation-remapper-visitor/build.gradle
new file mode 100644
index 0000000000..b5758ffb82
--- /dev/null
+++ b/test-suite-annotation-remapper-visitor/build.gradle
@@ -0,0 +1,11 @@
+plugins {
+    id "java"
+}
+
+description = "A simple remapping visitor"
+
+dependencies {
+    implementation(projects.injectJava)
+    // Use an enum that shouldn't be present and the runtime to simulate added enum value that doesn't exist
+    implementation libs.blaze.persistence.core
+}
diff --git a/test-suite-annotation-remapper-visitor/src/main/java/example/micronaut/AddAnnotationWithEnumVisitor.java b/test-suite-annotation-remapper-visitor/src/main/java/example/micronaut/AddAnnotationWithEnumVisitor.java
new file mode 100644
index 0000000000..2c5355d76c
--- /dev/null
+++ b/test-suite-annotation-remapper-visitor/src/main/java/example/micronaut/AddAnnotationWithEnumVisitor.java
@@ -0,0 +1,21 @@
+package example.micronaut;
+
+import com.blazebit.persistence.spi.JpqlFunctionKind;
+import io.micronaut.inject.ast.ClassElement;
+import io.micronaut.inject.visitor.TypeElementVisitor;
+import io.micronaut.inject.visitor.VisitorContext;
+
+public class AddAnnotationWithEnumVisitor implements TypeElementVisitor<Object, Object> {
+
+    @Override
+    public VisitorKind getVisitorKind() {
+        return VisitorKind.ISOLATING;
+    }
+
+    @Override
+    public void visitClass(ClassElement element, VisitorContext context) {
+            // Simulate annotating with enum value
+            // Micronaut should store the string value and not the enum value in the metadata
+        element.annotate("Something", builder -> builder.value(JpqlFunctionKind.DETERMINISTIC));
+    }
+}
diff --git a/test-suite-annotation-remapper-visitor/src/main/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor b/test-suite-annotation-remapper-visitor/src/main/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor
new file mode 100644
index 0000000000..d630212781
--- /dev/null
+++ b/test-suite-annotation-remapper-visitor/src/main/resources/META-INF/services/io.micronaut.inject.visitor.TypeElementVisitor
@@ -0,0 +1 @@
+example.micronaut.AddAnnotationWithEnumVisitor
diff --git a/test-suite-annotation-remapper/build.gradle b/test-suite-annotation-remapper/build.gradle
new file mode 100644
index 0000000000..cf05507e95
--- /dev/null
+++ b/test-suite-annotation-remapper/build.gradle
@@ -0,0 +1,34 @@
+plugins {
+    id "java"
+    id "org.graalvm.buildtools.native"
+}
+
+description = "Test suite for definitions with added enum values"
+
+tasks.withType(Test).configureEach {
+    useJUnitPlatform()
+}
+
+dependencies {
+    testAnnotationProcessor(projects.testSuiteAnnotationRemapperVisitor)
+    testAnnotationProcessor(projects.injectJava)
+    testImplementation(projects.httpServerNetty)
+    implementation(projects.jacksonDatabind)
+    testImplementation(projects.httpClient)
+    testImplementation(libs.logback.classic)
+    testImplementation(libs.micronaut.test.junit5) {
+        exclude group: 'io.micronaut'
+    }
+}
+
+graalvmNative {
+    toolchainDetection = false
+    metadataRepository {
+        enabled = true
+    }
+    binaries {
+        configureEach {
+            resources.autodetect()
+        }
+    }
+}
diff --git a/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloController.java b/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloController.java
new file mode 100644
index 0000000000..eccfd9d5de
--- /dev/null
+++ b/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloController.java
@@ -0,0 +1,13 @@
+package example.micronaut;
+
+import io.micronaut.http.annotation.Controller;
+import io.micronaut.http.annotation.Get;
+
+@Controller("/hello")
+public class HelloController {
+
+    @Get
+    public MyRecord index() {
+        return new MyRecord("Denis", 123);
+    }
+}
diff --git a/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloControllerTest.java b/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloControllerTest.java
new file mode 100644
index 0000000000..60b3a99046
--- /dev/null
+++ b/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloControllerTest.java
@@ -0,0 +1,39 @@
+package example.micronaut;
+
+import io.micronaut.context.BeanContext;
+import io.micronaut.http.HttpRequest;
+import io.micronaut.http.client.HttpClient;
+import io.micronaut.http.client.annotation.Client;
+import io.micronaut.inject.BeanDefinition;
+import io.micronaut.test.extensions.junit5.annotation.MicronautTest;
+import jakarta.inject.Inject;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+@MicronautTest
+public class HelloControllerTest {
+
+    @Inject
+    @Client("/")
+    HttpClient client;
+
+    @Inject
+    BeanContext beanContext;
+
+    @Test
+    void testHelloWorldResponse() {
+        String response = client.toBlocking()
+            .retrieve(HttpRequest.GET("/hello"));
+        assertEquals("""
+            {"name":"Denis","age":123}""", response);
+    }
+
+    @Test
+    void testNewAnnotationIsAdded() {
+        BeanDefinition<HelloController> beanDefinition = beanContext.getBeanDefinition(HelloController.class);
+        assertTrue(beanDefinition.hasAnnotation("Something"));
+    }
+
+}
diff --git a/test-suite-annotation-remapper/src/test/java/example/micronaut/MyRecord.java b/test-suite-annotation-remapper/src/test/java/example/micronaut/MyRecord.java
new file mode 100644
index 0000000000..20f7cccd9f
--- /dev/null
+++ b/test-suite-annotation-remapper/src/test/java/example/micronaut/MyRecord.java
@@ -0,0 +1,7 @@
+package example.micronaut;
+
+import io.micronaut.core.annotation.Introspected;
+
+@Introspected
+public record MyRecord(String name, int age) {
+}
diff --git a/test-suite-annotation-remapper/src/test/resources/logback.xml b/test-suite-annotation-remapper/src/test/resources/logback.xml
new file mode 100644
index 0000000000..18fd1cc91f
--- /dev/null
+++ b/test-suite-annotation-remapper/src/test/resources/logback.xml
@@ -0,0 +1,16 @@
+<configuration>
+
+    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
+        <!-- encoders are assigned the type
+             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
+        <encoder>
+            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
+        </encoder>
+    </appender>
+
+    <root level="info">
+        <appender-ref ref="STDOUT" />
+    </root>
+
+</configuration>
+
diff --git a/test-suite-kotlin-graalvm/build.gradle b/test-suite-kotlin-graalvm/build.gradle
new file mode 100644
index 0000000000..2c950d3bec
--- /dev/null
+++ b/test-suite-kotlin-graalvm/build.gradle
@@ -0,0 +1,51 @@
+plugins {
+    id "org.graalvm.buildtools.native"
+    alias libs.plugins.managed.kotlin.jvm
+    alias libs.plugins.managed.ksp
+}
+
+description = "Test suite for Kotlin in native image"
+
+tasks.withType(Test).configureEach {
+    useJUnitPlatform()
+}
+
+dependencies {
+    kspTest(projects.injectKotlin)
+    testImplementation(projects.httpServerNetty)
+    testImplementation(projects.httpClient)
+    testImplementation(projects.jacksonDatabind)
+    testImplementation(libs.logback.classic)
+    testImplementation(libs.micronaut.test.junit5) {
+        exclude group: 'io.micronaut'
+    }
+    testImplementation libs.managed.kotlinx.coroutines.core
+    testImplementation libs.managed.kotlinx.coroutines.jdk8
+    testImplementation libs.managed.kotlinx.coroutines.reactive
+    testImplementation libs.managed.kotlinx.coroutines.reactor
+
+    testImplementation platform(libs.test.boms.micronaut.kotlin)
+    testImplementation (libs.micronaut.kotlin.runtime) {
+        exclude group: 'io.micronaut'
+    }
+}
+
+graalvmNative {
+    toolchainDetection = false
+    metadataRepository {
+        enabled = true
+    }
+    binaries {
+        configureEach {
+            resources.autodetect()
+        }
+    }
+}
+
+configurations.testRuntimeClasspath {
+    resolutionStrategy.eachDependency {
+        if (it.requested.group == 'org.jetbrains.kotlin') {
+            it.useVersion(libs.versions.managed.kotlin.asProvider().get())
+        }
+    }
+}
diff --git a/test-suite-kotlin-graalvm/src/test/kotlin/example/micronaut/HelloController.kt b/test-suite-kotlin-graalvm/src/test/kotlin/example/micronaut/HelloController.kt
new file mode 100644
index 0000000000..7bb4ed71bd
--- /dev/null
+++ b/test-suite-kotlin-graalvm/src/test/kotlin/example/micronaut/HelloController.kt
@@ -0,0 +1,25 @@
+package example.micronaut
+
+import io.micronaut.http.MediaType
+import io.micronaut.http.annotation.Controller
+import io.micronaut.http.annotation.Get
+import kotlinx.coroutines.delay
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.flow
+
+@Controller("/hello")
+class HelloController {
+
+    @Get(value = "/world1", produces = [MediaType.TEXT_PLAIN])
+    suspend fun world1(): String {
+        delay(1000)
+        return "Hello World"
+    }
+
+    @Get(value = "/world2", produces = [MediaType.TEXT_PLAIN])
+    suspend fun world2(): Flow<String> = flow {
+        delay(1000)
+        listOf("Hello World").forEach { emit(it) }
+    }
+
+}
diff --git a/test-suite-kotlin-graalvm/src/test/kotlin/example/micronaut/HelloControllerTest.kt b/test-suite-kotlin-graalvm/src/test/kotlin/example/micronaut/HelloControllerTest.kt
new file mode 100644
index 0000000000..99ee1d6d57
--- /dev/null
+++ b/test-suite-kotlin-graalvm/src/test/kotlin/example/micronaut/HelloControllerTest.kt
@@ -0,0 +1,30 @@
+package example.micronaut
+
+import io.micronaut.http.HttpRequest
+import io.micronaut.http.client.HttpClient
+import io.micronaut.http.client.annotation.Client
+import io.micronaut.test.extensions.junit5.annotation.MicronautTest
+import jakarta.inject.Inject
+import org.junit.jupiter.api.Assertions
+import org.junit.jupiter.api.Test
+
+@MicronautTest
+class HelloControllerTest {
+    @Inject
+    @Client("/")
+    var client: HttpClient? = null
+
+    @Test
+    fun testHelloWorld1() {
+        val response = client!!.toBlocking()
+            .retrieve(HttpRequest.GET<Any>("/hello/world1"))
+        Assertions.assertEquals("Hello World", response)
+    }
+
+    @Test
+    fun testHelloWorld2() {
+        val response = client!!.toBlocking()
+            .retrieve(HttpRequest.GET<Any>("/hello/world2"))
+        Assertions.assertEquals("Hello World", response)
+    }
+}
diff --git a/test-suite-kotlin-graalvm/src/test/resources/logback.xml b/test-suite-kotlin-graalvm/src/test/resources/logback.xml
new file mode 100644
index 0000000000..18fd1cc91f
--- /dev/null
+++ b/test-suite-kotlin-graalvm/src/test/resources/logback.xml
@@ -0,0 +1,16 @@
+<configuration>
+
+    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
+        <!-- encoders are assigned the type
+             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
+        <encoder>
+            <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
+        </encoder>
+    </appender>
+
+    <root level="info">
+        <appender-ref ref="STDOUT" />
+    </root>
+
+</configuration>
+
diff --git a/test-suite-kotlin-ksp/src/test/kotlin/io/micronaut/docs/server/defaults_intercepted/DefaultsInterceptedController.kt b/test-suite-kotlin-ksp/src/test/kotlin/io/micronaut/docs/server/defaults_intercepted/DefaultsInterceptedController.kt
new file mode 100644
index 0000000000..fccc7363bf
--- /dev/null
+++ b/test-suite-kotlin-ksp/src/test/kotlin/io/micronaut/docs/server/defaults_intercepted/DefaultsInterceptedController.kt
@@ -0,0 +1,45 @@
+package io.micronaut.docs.server.defaults_intercepted
+
+import io.micronaut.context.annotation.Requires
+import io.micronaut.core.async.annotation.SingleResult
+import io.micronaut.http.HttpResponse
+import io.micronaut.http.MediaType
+import io.micronaut.http.annotation.Body
+import io.micronaut.http.annotation.Controller
+import io.micronaut.http.annotation.Header
+import io.micronaut.http.annotation.Post
+import jakarta.validation.constraints.NotBlank
+import jakarta.validation.constraints.NotNull
+import jakarta.validation.constraints.Size
+import org.reactivestreams.Publisher
+import reactor.core.publisher.Flux
+import spock.lang.Specification
+import java.time.OffsetDateTime
+import java.time.ZoneId
+
+@Requires(property = "spec.name", value = "defaults-intercepted")
+// tag::class[]
+@Controller("/defaults-intercepted")
+open class DefaultsInterceptedController(private val timeProvider: (ZoneId) -> OffsetDateTime = OffsetDateTime::now) {
+// end::class[]
+
+    // tag::echo[]
+    @Post(value = "/echo", consumes = [MediaType.TEXT_PLAIN]) // <1>
+    @NotBlank
+    open fun echo(@Size(max = 1024) @NotNull @Body text: String, @Header("MYHEADER") someHeader : String = "THEDEFAULT"): String { // <2>
+        return someHeader // <3>
+    }
+    // end::echo[]
+
+    // tag::echoReactive[]
+    @Post(value = "/echo-publisher", consumes = [MediaType.TEXT_PLAIN]) // <1>
+    @SingleResult
+    open fun echoFlow(@Body text: Publisher<String>, @NotNull @Header("MYHEADER") someHeader : String = "THEDEFAULT"): Publisher<HttpResponse<String>> { //<2>
+        return Flux.from(text)
+            .collect({ StringBuffer() }, { obj, str -> obj.append(str) }) // <3>
+            .map { HttpResponse.ok(someHeader) }
+    }
+    // end::echoReactive[]
+
+// tag::endclass[]
+}
diff --git a/test-suite-kotlin-ksp/src/test/kotlin/io/micronaut/docs/server/defaults_intercepted/DefaultsInterceptedControllerSpec.kt b/test-suite-kotlin-ksp/src/test/kotlin/io/micronaut/docs/server/defaults_intercepted/DefaultsInterceptedControllerSpec.kt
new file mode 100644
index 0000000000..f2a631035c
--- /dev/null
+++ b/test-suite-kotlin-ksp/src/test/kotlin/io/micronaut/docs/server/defaults_intercepted/DefaultsInterceptedControllerSpec.kt
@@ -0,0 +1,56 @@
+package io.micronaut.docs.server.defaults_intercepted
+
+import io.kotest.core.spec.style.StringSpec
+import io.kotest.matchers.shouldBe
+import io.micronaut.context.ApplicationContext
+import io.micronaut.http.HttpRequest
+import io.micronaut.http.MediaType
+import io.micronaut.http.client.HttpClient
+import io.micronaut.runtime.server.EmbeddedServer
+
+class DefaultsInterceptedControllerSpec : StringSpec() {
+
+    val embeddedServer = autoClose(
+        ApplicationContext.run(EmbeddedServer::class.java, mapOf("spec.name" to "defaults-intercepted"))
+    )
+
+    val client = autoClose(
+        embeddedServer.applicationContext.createBean(HttpClient::class.java, embeddedServer.getURL())
+    )
+
+    init {
+        "test echo response"() {
+            val response1 = client.toBlocking().retrieve(
+                HttpRequest.POST("/defaults-intercepted/echo", "My Text")
+                    .header("MYHEADER", "abc123")
+                    .contentType(MediaType.TEXT_PLAIN_TYPE), String::class.java
+            )
+
+            response1 shouldBe "abc123"
+
+            val response2 = client.toBlocking().retrieve(
+                HttpRequest.POST("/defaults-intercepted/echo", "My Text")
+                    .contentType(MediaType.TEXT_PLAIN_TYPE), String::class.java
+            )
+
+            response2 shouldBe "THEDEFAULT"
+        }
+
+        "test echo reactive response"() {
+            val response1 = client.toBlocking().retrieve(
+                HttpRequest.POST("/defaults-intercepted/echo-publisher", "My Text")
+                    .header("MYHEADER", "abc123")
+                    .contentType(MediaType.TEXT_PLAIN_TYPE), String::class.java
+            )
+
+            response1 shouldBe "abc123"
+
+            val response2 = client.toBlocking().retrieve(
+                HttpRequest.POST("/defaults-intercepted/echo-publisher", "My Text")
+                    .contentType(MediaType.TEXT_PLAIN_TYPE), String::class.java
+            )
+
+            response2 shouldBe "THEDEFAULT"
+        }
+    }
+}
diff --git a/test-suite/src/test/groovy/io/micronaut/views/JsonViewsTest.java b/test-suite/src/test/groovy/io/micronaut/views/JsonViewsTest.java
new file mode 100644
index 0000000000..2e8cf9a69d
--- /dev/null
+++ b/test-suite/src/test/groovy/io/micronaut/views/JsonViewsTest.java
@@ -0,0 +1,57 @@
+package io.micronaut.views;
+
+import io.micronaut.context.annotation.Property;
+import io.micronaut.http.HttpResponse;
+import io.micronaut.http.HttpStatus;
+import io.micronaut.http.client.HttpClient;
+import io.micronaut.http.client.annotation.Client;
+import io.micronaut.test.extensions.junit5.annotation.MicronautTest;
+import jakarta.inject.Inject;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+
+@Property(name = "jackson.json-view.enabled", value = "true")
+@MicronautTest
+class JsonViewsTest {
+
+    @Inject
+    @Client("/")
+    HttpClient client;
+
+    @Test
+    void testJsonViewPojo() {
+        HttpResponse<String> response = client.toBlocking().exchange("/views/pojo", String.class);
+        assertEquals(HttpStatus.OK, response.getStatus());
+        assertFalse(response.body().contains("password"));
+    }
+
+    @Test
+    void testJsonViewList() {
+        HttpResponse<String> response = client.toBlocking().exchange("/views/list", String.class);
+        assertEquals(HttpStatus.OK, response.getStatus());
+        assertFalse(response.body().contains("password"));
+    }
+
+    @Test
+    void testJsonViewOptional() {
+        HttpResponse<String> response = client.toBlocking().exchange("/views/optional", String.class);
+        assertEquals(HttpStatus.OK, response.getStatus());
+        assertFalse(response.body().contains("password"));
+    }
+
+    @Test
+    void testJsonViewMono() {
+        HttpResponse<String> response = client.toBlocking().exchange("/views/mono", String.class);
+        assertEquals(HttpStatus.OK, response.getStatus());
+        assertFalse(response.body().contains("password"));
+    }
+
+    @Test
+    void testJsonViewFlux() {
+        HttpResponse<String> response = client.toBlocking().exchange("/views/flux", String.class);
+        assertEquals(HttpStatus.OK, response.getStatus());
+        assertFalse(response.body().contains("password"));
+    }
+}
diff --git a/test-suite/src/test/groovy/io/micronaut/views/User.java b/test-suite/src/test/groovy/io/micronaut/views/User.java
new file mode 100644
index 0000000000..074fc3a009
--- /dev/null
+++ b/test-suite/src/test/groovy/io/micronaut/views/User.java
@@ -0,0 +1,42 @@
+package io.micronaut.views;
+
+import com.fasterxml.jackson.annotation.JsonView;
+import io.micronaut.core.annotation.Introspected;
+
+@Introspected
+public class User {
+    private int id;
+    private String name;
+    private String password;
+
+    public User(int id, String name, String password) {
+        this.id = id;
+        this.name = name;
+        this.password = password;
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public void setId(int id) {
+        this.id = id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    @JsonView(Views.Secret.class)
+    public String getPassword() {
+        return password;
+    }
+
+    public void setPassword(String password) {
+        this.password = password;
+    }
+}
diff --git a/test-suite/src/test/groovy/io/micronaut/views/UserController.java b/test-suite/src/test/groovy/io/micronaut/views/UserController.java
new file mode 100644
index 0000000000..88dd7a15a4
--- /dev/null
+++ b/test-suite/src/test/groovy/io/micronaut/views/UserController.java
@@ -0,0 +1,46 @@
+package io.micronaut.views;
+
+import com.fasterxml.jackson.annotation.JsonView;
+import io.micronaut.http.annotation.Controller;
+import io.micronaut.http.annotation.Get;
+import reactor.core.publisher.Flux;
+import reactor.core.publisher.Mono;
+
+import java.util.List;
+import java.util.Optional;
+
+@Controller("/views")
+public class UserController {
+
+    private static final User USER = new User(1, "Joe", "secret");
+
+    @JsonView(Views.Public.class)
+    @Get("/pojo")
+    public User getUserPojo() {
+        return USER;
+    }
+
+    @JsonView(Views.Public.class)
+    @Get("/list")
+    public List<User> getUserList() {
+        return List.of(USER);
+    }
+
+    @JsonView(Views.Public.class)
+    @Get("/optional")
+    public Optional<User> getUserOptional() {
+        return Optional.of(USER);
+    }
+
+    @JsonView(Views.Public.class)
+    @Get("/mono")
+    public Mono<User> getUserMono() {
+        return Mono.just(USER);
+    }
+
+    @JsonView(Views.Public.class)
+    @Get("/flux")
+    public Flux<User> getUserFlux() {
+        return Flux.just(USER);
+    }
+}
diff --git a/test-suite/src/test/groovy/io/micronaut/views/Views.java b/test-suite/src/test/groovy/io/micronaut/views/Views.java
new file mode 100644
index 0000000000..78be712a6e
--- /dev/null
+++ b/test-suite/src/test/groovy/io/micronaut/views/Views.java
@@ -0,0 +1,10 @@
+package io.micronaut.views;
+
+public class Views {
+    public static class Public {
+    }
+
+    public static class Secret extends Public {
+    }
+
+}
