diff --git a/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java b/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java
index e2ac9153..e0603e40 100644
--- a/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/BufferedSinkJsonWriter.java
@@ -57,17 +57,14 @@ final class BufferedSinkJsonWriter extends JsonWriter {
   /** The output data, containing at most one top-level array or object. */
   private final BufferedSink sink;
 
-  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack permits
-  // up to 32 levels of nesting including the top-level document. Deeper nesting is prone to trigger
-  // StackOverflowErrors.
-  private final int[] stack = new int[32];
+  private int[] stack = new int[32];
   private int stackSize = 0;
   {
     push(EMPTY_DOCUMENT);
   }
 
-  private final String[] pathNames = new String[32];
-  private final int[] pathIndices = new int[32];
+  private String[] pathNames = new String[32];
+  private int[] pathIndices = new int[32];
 
   /**
    * A string containing a full set of spaces for a single level of
@@ -146,8 +143,8 @@ final class BufferedSinkJsonWriter extends JsonWriter {
    */
   private JsonWriter open(int empty, String openBracket) throws IOException {
     beforeValue();
+    pathIndices[stackSize] = 0;
     push(empty);
-    pathIndices[stackSize - 1] = 0;
     sink.writeUtf8(openBracket);
     return this;
   }
@@ -178,7 +175,9 @@ final class BufferedSinkJsonWriter extends JsonWriter {
 
   private void push(int newTop) {
     if (stackSize == stack.length) {
-      throw new JsonDataException("Nesting too deep at " + getPath() + ": circular reference?");
+      int[] newStack = new int[stackSize * 2];
+      System.arraycopy(stack, 0, newStack, 0, stackSize);
+      stack = newStack;
     }
     stack[stackSize++] = newTop;
   }
diff --git a/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java b/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
index 1e193830..087fd915 100644
--- a/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/BufferedSourceJsonReader.java
@@ -92,17 +92,17 @@ final class BufferedSourceJsonReader extends JsonReader {
    */
   private String peekedString;
 
-  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack permits
-  // up to 32 levels of nesting including the top-level document. Deeper nesting is prone to trigger
-  // StackOverflowErrors.
-  private final int[] stack = new int[32];
+  /*
+   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.
+   */
+  private int[] stack = new int[32];
   private int stackSize = 0;
   {
     stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;
   }
 
-  private final String[] pathNames = new String[32];
-  private final int[] pathIndices = new int[32];
+  private String[] pathNames = new String[32];
+  private int[] pathIndices = new int[32];
 
   BufferedSourceJsonReader(BufferedSource source) {
     if (source == null) {
@@ -901,7 +901,15 @@ final class BufferedSourceJsonReader extends JsonReader {
 
   private void push(int newTop) {
     if (stackSize == stack.length) {
-      throw new JsonDataException("Nesting too deep at " + getPath());
+      int[] newStack = new int[stackSize * 2];
+      int[] newPathIndices = new int[stackSize * 2];
+      String[] newPathNames = new String[stackSize * 2];
+      System.arraycopy(stack, 0, newStack, 0, stackSize);
+      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);
+      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);
+      stack = newStack;
+      pathIndices = newPathIndices;
+      pathNames = newPathNames;
     }
     stack[stackSize++] = newTop;
   }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonDataException.java b/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
index 06262637..a8463055 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
@@ -22,10 +22,6 @@ package com.squareup.moshi;
  *
  * <p>Exceptions of this type should be fixed by either changing the application code to accept
  * the unexpected JSON, or by changing the JSON to conform to the application's expectations.
- *
- * <p>This exception may also be triggered if a document's nesting exceeds 31 levels. This depth is
- * sufficient for all practical applications, but shallow enough to avoid uglier failures like
- * {@link StackOverflowError}.
  */
 public final class JsonDataException extends RuntimeException {
   public JsonDataException() {
diff --git a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
index 889d1f6d..b0bb34db 100644
--- a/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/MapJsonAdapter.java
@@ -50,7 +50,7 @@ final class MapJsonAdapter<K, V> extends JsonAdapter<Map<K, V>> {
     writer.beginObject();
     for (Map.Entry<K, V> entry : map.entrySet()) {
       if (entry.getKey() == null) {
-        throw new JsonDataException("Map key is null at " + writer.getPath());
+        throw new JsonDataException("Map key is null at path " + writer.getPath());
       }
       writer.promoteNameToValue();
       keyAdapter.toJson(writer, entry.getKey());
diff --git a/moshi/src/main/java/com/squareup/moshi/Types.java b/moshi/src/main/java/com/squareup/moshi/Types.java
index e383baab..67cac084 100644
--- a/moshi/src/main/java/com/squareup/moshi/Types.java
+++ b/moshi/src/main/java/com/squareup/moshi/Types.java
@@ -18,7 +18,6 @@ package com.squareup.moshi;
 import java.lang.reflect.Array;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.GenericDeclaration;
-import java.lang.reflect.Modifier;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
@@ -37,12 +36,22 @@ public final class Types {
   }
 
   /**
-   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType}.
+   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType}. Use this
+   * method if {@code rawType} is not enclosed in another type.
    */
   public static ParameterizedType newParameterizedType(Type rawType, Type... typeArguments) {
     return new ParameterizedTypeImpl(null, rawType, typeArguments);
   }
 
+  /**
+   * Returns a new parameterized type, applying {@code typeArguments} to {@code rawType}. Use this
+   * method if {@code rawType} is enclosed in {@code ownerType}.
+   */
+  public static ParameterizedType newParameterizedTypeWithOwner(
+      Type ownerType, Type rawType, Type... typeArguments) {
+    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);
+  }
+
   /** Returns an array type whose elements are all instances of {@code componentType}. */
   public static GenericArrayType arrayOf(Type componentType) {
     return new GenericArrayTypeImpl(componentType);
@@ -405,12 +414,11 @@ public final class Types {
     final Type[] typeArguments;
 
     ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {
-      // require an owner type if the raw type needs it
-      if (rawType instanceof Class<?>) {
-        Class<?> rawTypeAsClass = (Class<?>) rawType;
-        boolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())
-            || rawTypeAsClass.getEnclosingClass() == null;
-        if (ownerType == null && !isStaticOrTopLevelClass) throw new IllegalArgumentException();
+      // Require an owner type if the raw type needs it.
+      if (rawType instanceof Class<?>
+          && (ownerType == null) != (((Class<?>) rawType).getEnclosingClass() == null)) {
+        throw new IllegalArgumentException(
+            "unexpected owner type for " + rawType + ": " + ownerType);
       }
 
       this.ownerType = ownerType == null ? null : canonicalize(ownerType);
diff --git a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java b/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
index d3082ee8..ee378c48 100644
--- a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
@@ -22,6 +22,7 @@ import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -547,6 +548,44 @@ public final class AdapterMethodsTest {
     }
   }
 
+  @Test public void adaptedTypeIsEnclosedParameterizedType() throws Exception {
+    Moshi moshi = new Moshi.Builder()
+        .add(new EnclosedParameterizedTypeJsonAdapter())
+        .build();
+    JsonAdapter<Box<Point>> boxAdapter = moshi.adapter(Types.newParameterizedTypeWithOwner(
+        AdapterMethodsTest.class, Box.class, Point.class));
+    Box<Point> box = new Box<>(new Point(5, 8));
+    String json = "[{\"x\":5,\"y\":8}]";
+    assertThat(boxAdapter.toJson(box)).isEqualTo(json);
+    assertThat(boxAdapter.fromJson(json)).isEqualTo(box);
+  }
+
+  static class EnclosedParameterizedTypeJsonAdapter {
+    @FromJson Box<Point> boxFromJson(List<Point> points) {
+      return new Box<>(points.get(0));
+    }
+
+    @ToJson List<Point> boxToJson(Box<Point> box) throws Exception {
+      return Collections.singletonList(box.data);
+    }
+  }
+
+  static class Box<T> {
+    final T data;
+
+    public Box(T data) {
+      this.data = data;
+    }
+
+    @Override public boolean equals(Object o) {
+      return o instanceof Box && ((Box) o).data.equals(data);
+    }
+
+    @Override public int hashCode() {
+      return data.hashCode();
+    }
+  }
+
   static class Point {
     final int x;
     final int y;
diff --git a/moshi/src/test/java/com/squareup/moshi/BufferedSinkJsonWriterTest.java b/moshi/src/test/java/com/squareup/moshi/BufferedSinkJsonWriterTest.java
index 0cdfec11..d430b2f5 100644
--- a/moshi/src/test/java/com/squareup/moshi/BufferedSinkJsonWriterTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/BufferedSinkJsonWriterTest.java
@@ -419,62 +419,31 @@ public final class BufferedSinkJsonWriterTest {
   @Test public void deepNestingArrays() throws IOException {
     Buffer buffer = new Buffer();
     JsonWriter jsonWriter = JsonWriter.of(buffer);
-    for (int i = 0; i < 31; i++) {
+    for (int i = 0; i < 20; i++) {
       jsonWriter.beginArray();
     }
-    for (int i = 0; i < 31; i++) {
+    for (int i = 0; i < 20; i++) {
       jsonWriter.endArray();
     }
-    assertThat(buffer.readUtf8())
-        .isEqualTo("[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]");
-  }
-
-  @Test public void tooDeepNestingArrays() throws IOException {
-    Buffer buffer = new Buffer();
-    JsonWriter jsonWriter = JsonWriter.of(buffer);
-    for (int i = 0; i < 31; i++) {
-      jsonWriter.beginArray();
-    }
-    try {
-      jsonWriter.beginArray();
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected).hasMessage("Nesting too deep at $[0][0][0][0][0][0][0][0][0][0][0][0][0]"
-          + "[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]: circular reference?");
-    }
+    assertThat(buffer.readUtf8()).isEqualTo("[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]");
   }
 
   @Test public void deepNestingObjects() throws IOException {
     Buffer buffer = new Buffer();
     JsonWriter jsonWriter = JsonWriter.of(buffer);
-    for (int i = 0; i < 31; i++) {
-      jsonWriter.beginObject();
+    jsonWriter.beginObject();
+    for (int i = 0; i < 20; i++) {
       jsonWriter.name("a");
-    }
-    jsonWriter.value(true);
-    for (int i = 0; i < 31; i++) {
-      jsonWriter.endObject();
-    }
-    assertThat(buffer.readUtf8()).isEqualTo(""
-        + "{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":"
-        + "{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":"
-        + "{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":true}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}");
-  }
-
-  @Test public void tooDeepNestingObjects() throws IOException {
-    Buffer buffer = new Buffer();
-    JsonWriter jsonWriter = JsonWriter.of(buffer);
-    for (int i = 0; i < 31; i++) {
       jsonWriter.beginObject();
-      jsonWriter.name("a");
     }
-    try {
-      jsonWriter.beginObject();
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected).hasMessage("Nesting too deep at $.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a."
-          + "a.a.a.a.a.a.a.a.a.a.a.a: circular reference?");
+    for (int i = 0; i < 20; i++) {
+      jsonWriter.endObject();
     }
+    jsonWriter.endObject();
+    assertThat(buffer.readUtf8()).isEqualTo(
+        "{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":"
+        + "{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{"
+        + "}}}}}}}}}}}}}}}}}}}}}");
   }
 
   @Test public void repeatedName() throws IOException {
diff --git a/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java b/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java
index 11747957..69000871 100644
--- a/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/BufferedSourceJsonReaderTest.java
@@ -1498,77 +1498,43 @@ public final class BufferedSourceJsonReaderTest {
   }
 
   @Test public void deeplyNestedArrays() throws IOException {
-    JsonReader reader = newReader("[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]");
-    for (int i = 0; i < 31; i++) {
+    // this is nested 40 levels deep; Gson is tuned for nesting is 30 levels deep or fewer
+    JsonReader reader = newReader(
+        "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]");
+    for (int i = 0; i < 40; i++) {
       reader.beginArray();
     }
-    assertThat(reader.getPath()).isEqualTo("$[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]"
-        + "[0][0][0][0][0][0][0][0][0][0][0][0][0]");
-    for (int i = 0; i < 31; i++) {
+    assertThat(reader.getPath()).isEqualTo(
+        "$[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]"
+        + "[0][0][0][0][0][0][0][0][0][0][0][0][0][0]");
+    for (int i = 0; i < 40; i++) {
       reader.endArray();
     }
     assertThat(reader.peek()).isEqualTo(JsonReader.Token.END_DOCUMENT);
   }
 
-  @Test public void tooDeeplyNestedArrays() throws IOException {
-    JsonReader reader = newReader(
-        "[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]");
-    for (int i = 0; i < 31; i++) {
-      reader.beginArray();
-    }
-    try {
-      reader.beginArray();
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected).hasMessage("Nesting too deep at $[0][0][0][0][0][0][0][0][0][0][0][0][0]"
-          + "[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]");
-    }
-  }
-
   @Test public void deeplyNestedObjects() throws IOException {
-    // Build a JSON document structured like {"a":{"a":{"a":{"a":true}}}}, but 31 levels deep.
+    // Build a JSON document structured like {"a":{"a":{"a":{"a":true}}}}, but 40 levels deep
     String array = "{\"a\":%s}";
     String json = "true";
-    for (int i = 0; i < 31; i++) {
+    for (int i = 0; i < 40; i++) {
       json = String.format(array, json);
     }
 
     JsonReader reader = newReader(json);
-    for (int i = 0; i < 31; i++) {
+    for (int i = 0; i < 40; i++) {
       reader.beginObject();
       assertThat(reader.nextName()).isEqualTo("a");
     }
-    assertThat(reader.getPath())
-        .isEqualTo("$.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a");
+    assertThat(reader.getPath()).isEqualTo("$.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a"
+        + ".a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a");
     assertThat(reader.nextBoolean()).isTrue();
-    for (int i = 0; i < 31; i++) {
+    for (int i = 0; i < 40; i++) {
       reader.endObject();
     }
     assertThat(reader.peek()).isEqualTo(JsonReader.Token.END_DOCUMENT);
   }
 
-  @Test public void tooDeeplyNestedObjects() throws IOException {
-    // Build a JSON document structured like {"a":{"a":{"a":{"a":true}}}}, but 31 levels deep.
-    String array = "{\"a\":%s}";
-    String json = "true";
-    for (int i = 0; i < 32; i++) {
-      json = String.format(array, json);
-    }
-
-    JsonReader reader = newReader(json);
-    for (int i = 0; i < 31; i++) {
-      reader.beginObject();
-      assertThat(reader.nextName()).isEqualTo("a");
-    }
-    try {
-      reader.beginObject();
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected).hasMessage(
-          "Nesting too deep at $.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a");
-    }
-  }
-
   // http://code.google.com/p/google-gson/issues/detail?id=409
   @Test public void stringEndingInSlash() throws IOException {
     JsonReader reader = newReader("/");
diff --git a/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java b/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java
index 4c713f6a..2e382aae 100644
--- a/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java
@@ -23,6 +23,7 @@ import java.util.LinkedHashMap;
 import java.util.Map;
 import okio.Buffer;
 import org.assertj.core.data.MapEntry;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static com.squareup.moshi.TestUtil.newReader;
@@ -56,7 +57,7 @@ public final class MapJsonAdapterTest {
       toJson(String.class, Boolean.class, map);
       fail();
     } catch (JsonDataException expected) {
-      assertThat(expected).hasMessage("Map key is null at $.");
+      assertThat(expected).hasMessage("Map key is null at path $.");
     }
   }
 
diff --git a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
index 3e176ba7..0acff82b 100644
--- a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
@@ -23,17 +23,13 @@ import java.lang.annotation.Retention;
 import java.lang.reflect.Field;
 import java.lang.reflect.Type;
 import java.util.ArrayDeque;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
-import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 import java.util.Set;
 import javax.crypto.KeyGenerator;
-import org.junit.Assert;
 import org.junit.Test;
 
 import static com.squareup.moshi.TestUtil.newReader;
@@ -820,47 +816,6 @@ public final class MoshiTest {
     }
   }
 
-  @Test public void referenceCyclesOnArrays() throws Exception {
-    Moshi moshi = new Moshi.Builder().build();
-    Map<String, Object> map = new LinkedHashMap<>();
-    map.put("a", map);
-    try {
-      moshi.adapter(Object.class).toJson(map);
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected).hasMessage("Nesting too deep at $.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a."
-          + "a.a.a.a.a.a.a.a.a.a.a.a: circular reference?");
-    }
-  }
-
-  @Test public void referenceCyclesOnObjects() throws Exception {
-    Moshi moshi = new Moshi.Builder().build();
-    List<Object> list = new ArrayList<>();
-    list.add(list);
-    try {
-      moshi.adapter(Object.class).toJson(list);
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected).hasMessage("Nesting too deep at $[0][0][0][0][0][0][0][0][0][0][0][0][0]"
-          + "[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]: circular reference?");
-    }
-  }
-
-  @Test public void referenceCyclesOnMixedTypes() throws Exception {
-    Moshi moshi = new Moshi.Builder().build();
-    List<Object> list = new ArrayList<>();
-    Map<String, Object> map = new LinkedHashMap<>();
-    list.add(map);
-    map.put("a", list);
-    try {
-      moshi.adapter(Object.class).toJson(list);
-      fail();
-    } catch (JsonDataException expected) {
-      assertThat(expected).hasMessage("Nesting too deep at $[0].a[0].a[0].a[0].a[0].a[0].a[0].a[0]."
-          + "a[0].a[0].a[0].a[0].a[0].a[0].a[0].a[0]: circular reference?");
-    }
-  }
-
   static class Pizza {
     final int diameter;
     final boolean extraCheese;
diff --git a/moshi/src/test/java/com/squareup/moshi/TypesTest.java b/moshi/src/test/java/com/squareup/moshi/TypesTest.java
index fd77e270..a41070ea 100644
--- a/moshi/src/test/java/com/squareup/moshi/TypesTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/TypesTest.java
@@ -34,27 +34,32 @@ public final class TypesTest {
     assertThat(getFirstTypeArgument(type)).isEqualTo(A.class);
 
     // A<B>. A is a static inner class.
-    type = Types.newParameterizedType(A.class, B.class);
+    type = Types.newParameterizedTypeWithOwner(TypesTest.class, A.class, B.class);
     assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);
+  }
 
-    final class D {
-    }
+  @Test public void parameterizedTypeWithRequiredOwnerMissing() throws Exception {
     try {
-      // D<A> is not allowed since D is not a static inner class.
-      Types.newParameterizedType(D.class, A.class);
+      Types.newParameterizedType(A.class, B.class);
       fail();
     } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("unexpected owner type for " + A.class + ": null");
     }
+  }
 
-    // A<D> is allowed.
-    type = Types.newParameterizedType(A.class, D.class);
-    assertThat(getFirstTypeArgument(type)).isEqualTo(D.class);
+  @Test public void parameterizedTypeWithUnnecessaryOwnerProvided() throws Exception {
+    try {
+      Types.newParameterizedTypeWithOwner(A.class, List.class, B.class);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage("unexpected owner type for " + List.class + ": " + A.class);
+    }
   }
 
   @Test public void getFirstTypeArgument() throws Exception {
     assertThat(getFirstTypeArgument(A.class)).isNull();
 
-    Type type = Types.newParameterizedType(A.class, B.class, C.class);
+    Type type = Types.newParameterizedTypeWithOwner(TypesTest.class, A.class, B.class, C.class);
     assertThat(getFirstTypeArgument(type)).isEqualTo(B.class);
   }
 
