diff --git a/okhttp-testing-support/src/main/kotlin/okhttp3/CallEvent.kt b/okhttp-testing-support/src/main/kotlin/okhttp3/CallEvent.kt
index c14804eca..3bf1afe73 100644
--- a/okhttp-testing-support/src/main/kotlin/okhttp3/CallEvent.kt
+++ b/okhttp-testing-support/src/main/kotlin/okhttp3/CallEvent.kt
@@ -232,11 +232,4 @@ sealed class CallEvent {
     override val timestampNs: Long,
     override val call: Call,
   ) : CallEvent()
-
-  data class RetryDecision(
-    override val timestampNs: Long,
-    override val call: Call,
-    val shouldRetry: Boolean,
-    val reason: String,
-  ) : CallEvent()
 }
diff --git a/okhttp-testing-support/src/main/kotlin/okhttp3/ClientRuleEventListener.kt b/okhttp-testing-support/src/main/kotlin/okhttp3/ClientRuleEventListener.kt
index fbc37b59a..14b64abc0 100644
--- a/okhttp-testing-support/src/main/kotlin/okhttp3/ClientRuleEventListener.kt
+++ b/okhttp-testing-support/src/main/kotlin/okhttp3/ClientRuleEventListener.kt
@@ -274,16 +274,6 @@ class ClientRuleEventListener(
     delegate.cacheConditionalHit(call, cachedResponse)
   }
 
-  override fun retryDecision(
-    call: Call,
-    shouldRetry: Boolean,
-    reason: String,
-  ) {
-    logWithTime("retryDecision")
-
-    delegate.retryDecision(call, shouldRetry, reason)
-  }
-
   private fun logWithTime(message: String) {
     val startNs = startNs
     val timeMs =
diff --git a/okhttp-testing-support/src/main/kotlin/okhttp3/RecordingEventListener.kt b/okhttp-testing-support/src/main/kotlin/okhttp3/RecordingEventListener.kt
index 3b8694cb3..3223f4eed 100644
--- a/okhttp-testing-support/src/main/kotlin/okhttp3/RecordingEventListener.kt
+++ b/okhttp-testing-support/src/main/kotlin/okhttp3/RecordingEventListener.kt
@@ -97,10 +97,6 @@ open class RecordingEventListener(
 
   inline fun <reified T : CallEvent> removeUpToEvent(): T = removeUpToEvent(T::class.java)
 
-  inline fun <reified T : CallEvent> findEvent(): T {
-    return eventSequence.first { it is T } as T
-  }
-
   /**
    * Remove and return the next event from the recorded sequence.
    *
@@ -292,12 +288,4 @@ open class RecordingEventListener(
     call: Call,
     cachedResponse: Response,
   ) = logEvent(CacheConditionalHit(System.nanoTime(), call))
-
-  override fun retryDecision(
-    call: Call,
-    shouldRetry: Boolean,
-    reason: String,
-  ) = logEvent(
-    CallEvent.RetryDecision(System.nanoTime(), call, shouldRetry, reason),
-  )
 }
diff --git a/okhttp/api/android/okhttp.api b/okhttp/api/android/okhttp.api
index 363eddb1d..5dabeaa98 100644
--- a/okhttp/api/android/okhttp.api
+++ b/okhttp/api/android/okhttp.api
@@ -554,7 +554,6 @@ public abstract class okhttp3/EventListener {
 	public fun responseFailed (Lokhttp3/Call;Ljava/io/IOException;)V
 	public fun responseHeadersEnd (Lokhttp3/Call;Lokhttp3/Response;)V
 	public fun responseHeadersStart (Lokhttp3/Call;)V
-	public fun retryDecision (Lokhttp3/Call;ZLjava/lang/String;)V
 	public fun satisfactionFailure (Lokhttp3/Call;Lokhttp3/Response;)V
 	public fun secureConnectEnd (Lokhttp3/Call;Lokhttp3/Handshake;)V
 	public fun secureConnectStart (Lokhttp3/Call;)V
diff --git a/okhttp/api/jvm/okhttp.api b/okhttp/api/jvm/okhttp.api
index fbdd6e8c2..fcc070909 100644
--- a/okhttp/api/jvm/okhttp.api
+++ b/okhttp/api/jvm/okhttp.api
@@ -554,7 +554,6 @@ public abstract class okhttp3/EventListener {
 	public fun responseFailed (Lokhttp3/Call;Ljava/io/IOException;)V
 	public fun responseHeadersEnd (Lokhttp3/Call;Lokhttp3/Response;)V
 	public fun responseHeadersStart (Lokhttp3/Call;)V
-	public fun retryDecision (Lokhttp3/Call;ZLjava/lang/String;)V
 	public fun satisfactionFailure (Lokhttp3/Call;Lokhttp3/Response;)V
 	public fun secureConnectEnd (Lokhttp3/Call;Lokhttp3/Handshake;)V
 	public fun secureConnectStart (Lokhttp3/Call;)V
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/EventListener.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/EventListener.kt
index d424d60c3..42a08988a 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/EventListener.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/EventListener.kt
@@ -453,18 +453,6 @@ abstract class EventListener {
   ) {
   }
 
-  /**
-   * Invoked when a failed call is considered for retry.
-   *
-   * This event won't be emitted when a call isSuccessful.
-   */
-  open fun retryDecision(
-    call: Call,
-    shouldRetry: Boolean,
-    reason: String,
-  ) {
-  }
-
   fun interface Factory {
     /**
      * Creates an instance of the [EventListener] for a particular [Call]. The returned
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
index 602bd06dd..5dee0446f 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
@@ -90,7 +90,7 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
             .build()
 
         val exchange = call.interceptorScopedExchange
-        val followUp = followUpRequest(response, exchange, call)
+        val followUp = followUpRequest(response, exchange)
 
         if (followUp == null) {
           if (exchange != null && exchange.isDuplex) {
@@ -103,14 +103,12 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
         val followUpBody = followUp.body
         if (followUpBody != null && followUpBody.isOneShot()) {
           closeActiveExchange = false
-          call.eventListener.retryDecision(call, false, "request.body isOneShot is true")
           return response
         }
 
         response.body.closeQuietly()
 
         if (++followUpCount > MAX_FOLLOW_UPS) {
-          call.eventListener.retryDecision(call, false, "Too many follow-up requests: $followUpCount")
           throw ProtocolException("Too many follow-up requests: $followUpCount")
         }
 
@@ -135,19 +133,13 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
     requestSendStarted: Boolean,
   ): Boolean {
     // The application layer has forbidden retries.
-    if (!client.retryOnConnectionFailure) {
-      call.eventListener.retryDecision(call, false, "retryOnConnectionFailure is false")
-      return false
-    }
+    if (!client.retryOnConnectionFailure) return false
 
     // We can't send the request body again.
-    if (requestSendStarted && requestIsOneShot(e, userRequest)) {
-      call.eventListener.retryDecision(call, false, "request.body isOneShot is true")
-      return false
-    }
+    if (requestSendStarted && requestIsOneShot(e, userRequest)) return false
 
     // This exception is fatal.
-    if (!isRecoverable(e, requestSendStarted, call)) return false
+    if (!isRecoverable(e, requestSendStarted)) return false
 
     // No more routes to attempt.
     if (!call.retryAfterFailure()) return false
@@ -168,28 +160,16 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
   private fun isRecoverable(
     e: IOException,
     requestSendStarted: Boolean,
-    call: RealCall,
   ): Boolean {
     // If there was a protocol problem, don't recover.
     if (e is ProtocolException) {
-      call.eventListener.retryDecision(call, false, "failure was ProtocolException")
       return false
     }
 
     // If there was an interruption don't recover, but if there was a timeout connecting to a route
     // we should try the next route (if there is one).
     if (e is InterruptedIOException) {
-      if (e is SocketTimeoutException) {
-        if (requestSendStarted) {
-          call.eventListener.retryDecision(call, false, "request was at least partially sent")
-          return false
-        }
-      } else {
-        call.eventListener.retryDecision(call, false, "failure was InterruptedIOException")
-        return false
-      }
-
-      return true
+      return e is SocketTimeoutException && !requestSendStarted
     }
 
     // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
@@ -198,17 +178,13 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
       // If the problem was a CertificateException from the X509TrustManager,
       // do not retry.
       if (e.cause is CertificateException) {
-        call.eventListener.retryDecision(call, false, "failure was CertificateException")
         return false
       }
     }
-
     if (e is SSLPeerUnverifiedException) {
       // e.g. a certificate pinning error.
-      call.eventListener.retryDecision(call, false, "certificate pinning failure")
       return false
     }
-
     // An example of one we might want to retry with a different route is a problem connecting to a
     // proxy and would manifest as a standard IOException. Unless it is one we know we should not
     // retry, we return true and try a new route.
@@ -224,7 +200,6 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
   private fun followUpRequest(
     userResponse: Response,
     exchange: Exchange?,
-    call: RealCall,
   ): Request? {
     val route = exchange?.connection?.route()
     val responseCode = userResponse.code
@@ -234,23 +209,15 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
       HTTP_PROXY_AUTH -> {
         val selectedProxy = route!!.proxy
         if (selectedProxy.type() != Proxy.Type.HTTP) {
-          call.eventListener.retryDecision(call, false, "Received HTTP_PROXY_AUTH (407) code while not using proxy")
           throw ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy")
         }
-        call.eventListener.retryDecision(call, true, "Received HTTP_PROXY_AUTH (407) code")
         return client.proxyAuthenticator.authenticate(route, userResponse)
       }
 
-      HTTP_UNAUTHORIZED -> return client.authenticator.authenticate(route, userResponse).also {
-        if (it != null) {
-          call.eventListener.retryDecision(call, true, "Received HTTP_UNAUTHORIZED (401) and authenticate request")
-        } else {
-          call.eventListener.retryDecision(call, false, "Received HTTP_UNAUTHORIZED (401) without authenticate request")
-        }
-      }
+      HTTP_UNAUTHORIZED -> return client.authenticator.authenticate(route, userResponse)
 
       HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -> {
-        return buildRedirectRequest(userResponse, method, call)
+        return buildRedirectRequest(userResponse, method)
       }
 
       HTTP_CLIENT_TIMEOUT -> {
@@ -259,28 +226,23 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
         // repeat the request (even non-idempotent ones.)
         if (!client.retryOnConnectionFailure) {
           // The application layer has directed us not to retry the request.
-          call.eventListener.retryDecision(call, false, "HTTP_CLIENT_TIMEOUT (408) and retryOnConnectionFailure is false")
           return null
         }
 
         val requestBody = userResponse.request.body
         if (requestBody != null && requestBody.isOneShot()) {
-          call.eventListener.retryDecision(call, false, "HTTP_CLIENT_TIMEOUT (408) and request.body isOneShot is true")
           return null
         }
         val priorResponse = userResponse.priorResponse
         if (priorResponse != null && priorResponse.code == HTTP_CLIENT_TIMEOUT) {
-          call.eventListener.retryDecision(call, false, "HTTP_CLIENT_TIMEOUT (408) received on retry")
           // We attempted to retry and got another timeout. Give up.
           return null
         }
 
         if (retryAfter(userResponse, 0) > 0) {
-          call.eventListener.retryDecision(call, false, "HTTP_CLIENT_TIMEOUT (408) with Retry-After")
           return null
         }
 
-        call.eventListener.retryDecision(call, true, "HTTP_CLIENT_TIMEOUT (408)")
         return userResponse.request
       }
 
@@ -288,17 +250,14 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
         val priorResponse = userResponse.priorResponse
         if (priorResponse != null && priorResponse.code == HTTP_UNAVAILABLE) {
           // We attempted to retry and got another timeout. Give up.
-          call.eventListener.retryDecision(call, false, "HTTP_UNAVAILABLE (503) received on retry")
           return null
         }
 
         if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
           // specifically received an instruction to retry without delay
-          call.eventListener.retryDecision(call, true, "HTTP_UNAVAILABLE (503) with Retry-After = 0")
           return userResponse.request
         }
 
-        call.eventListener.retryDecision(call, false, "HTTP_UNAVAILABLE (503)")
         return null
       }
 
@@ -308,56 +267,35 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
         // we can retry on a different connection.
         val requestBody = userResponse.request.body
         if (requestBody != null && requestBody.isOneShot()) {
-          call.eventListener.retryDecision(call, false, "HTTP_MISDIRECTED_REQUEST (421) and request.body isOneShot is true")
           return null
         }
 
         if (exchange == null || !exchange.isCoalescedConnection) {
-          call.eventListener.retryDecision(call, false, "HTTP_MISDIRECTED_REQUEST (421) on non coalesced connection")
           return null
         }
 
         exchange.connection.noCoalescedConnections()
-        call.eventListener.retryDecision(call, true, "HTTP_MISDIRECTED_REQUEST (421), retrying without coalesced connection")
         return userResponse.request
       }
 
-      else -> return null.also {
-        if (!userResponse.isSuccessful) {
-          call.eventListener.retryDecision(call, false, "No rule to retry request ($responseCode)")
-        }
-      }
+      else -> return null
     }
   }
 
   private fun buildRedirectRequest(
     userResponse: Response,
     method: String,
-    call: RealCall,
   ): Request? {
     // Does the client allow redirects?
-    if (!client.followRedirects) {
-      call.eventListener.retryDecision(call, false, "followRedirects is false after redirect (${userResponse.code})")
-      return null
-    }
+    if (!client.followRedirects) return null
 
-    val location =
-      userResponse.header("Location") ?: return null.also {
-        call.eventListener.retryDecision(call, false, "redirect (${userResponse.code}) without Location")
-      }
+    val location = userResponse.header("Location") ?: return null
     // Don't follow redirects to unsupported protocols.
-    val url =
-      userResponse.request.url.resolve(location) ?: return null.also {
-        call.eventListener.retryDecision(call, false, "redirect (${userResponse.code}) to unsupported protocol")
-      }
+    val url = userResponse.request.url.resolve(location) ?: return null
 
     // If configured, don't follow redirects between SSL and non-SSL.
     val sameScheme = url.scheme == userResponse.request.url.scheme
-    if (!sameScheme && !client.followSslRedirects) {
-      return null.also {
-        call.eventListener.retryDecision(call, false, "redirect (${userResponse.code}) switching scheme and followSslRedirects is false")
-      }
-    }
+    if (!sameScheme && !client.followSslRedirects) return null
 
     // Most redirects don't include a request body.
     val requestBuilder = userResponse.request.newBuilder()
@@ -387,8 +325,6 @@ class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Intercepto
       requestBuilder.removeHeader("Authorization")
     }
 
-    call.eventListener.retryDecision(call, true, "redirect (${userResponse.code})")
-
     return requestBuilder.url(url).build()
   }
 
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/CallTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/CallTest.kt
index 350ade959..c483e5843 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/CallTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/CallTest.kt
@@ -34,7 +34,6 @@ import assertk.assertions.isNotSameAs
 import assertk.assertions.isNull
 import assertk.assertions.isTrue
 import assertk.assertions.matches
-import assertk.assertions.prop
 import assertk.assertions.startsWith
 import assertk.fail
 import java.io.FileNotFoundException
@@ -84,7 +83,6 @@ import okhttp3.CallEvent.ConnectStart
 import okhttp3.CallEvent.ConnectionAcquired
 import okhttp3.CallEvent.ConnectionReleased
 import okhttp3.CallEvent.ResponseFailed
-import okhttp3.CallEvent.RetryDecision
 import okhttp3.CertificatePinner.Companion.pin
 import okhttp3.Credentials.basic
 import okhttp3.Headers.Companion.headersOf
@@ -1665,12 +1663,8 @@ open class CallTest {
 
     assertThat(listener.recordedEventTypes()).containsExactly(
       "CallStart", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
-      "RequestBodyStart", "RequestBodyEnd", "ResponseFailed", "RetryDecision", "ConnectionReleased", "CallFailed",
+      "RequestBodyStart", "RequestBodyEnd", "ResponseFailed", "ConnectionReleased", "CallFailed",
     )
-    assertThat(listener.findEvent<RetryDecision>()).all {
-      prop(RetryDecision::reason).isEqualTo("retryOnConnectionFailure is false")
-      prop(RetryDecision::shouldRetry).isFalse()
-    }
     listener.clearAllEvents()
 
     val response3 = client.newCall(request1).execute()
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt
index 7e9d5752d..6f7f3384e 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/DuplexTest.kt
@@ -15,14 +15,12 @@
  */
 package okhttp3
 
-import assertk.all
 import assertk.assertThat
 import assertk.assertions.contains
 import assertk.assertions.containsExactly
 import assertk.assertions.isEqualTo
 import assertk.assertions.isNull
 import assertk.assertions.isTrue
-import assertk.assertions.prop
 import java.io.IOException
 import java.net.HttpURLConnection
 import java.net.ProtocolException
@@ -35,7 +33,6 @@ import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
 import mockwebserver3.internal.duplex.MockStreamHandler
-import okhttp3.CallEvent.RetryDecision
 import okhttp3.Credentials.basic
 import okhttp3.Headers.Companion.headersOf
 import okhttp3.RequestBody.Companion.toRequestBody
@@ -403,14 +400,10 @@ class DuplexTest {
       "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
       "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
       "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
-      "ResponseHeadersEnd", "RetryDecision", "ResponseBodyStart", "ResponseBodyEnd", "RequestHeadersStart",
+      "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestHeadersStart",
       "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
       "ResponseBodyEnd", "ConnectionReleased", "CallEnd", "RequestFailed",
     )
-    assertThat(listener.findEvent<RetryDecision>()).all {
-      prop(RetryDecision::reason).isEqualTo("redirect (301)")
-      prop(RetryDecision::shouldRetry).isTrue()
-    }
   }
 
   /**
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/EventListenerTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/EventListenerTest.kt
index 060a791f3..d8d49aee3 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/EventListenerTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/EventListenerTest.kt
@@ -15,20 +15,16 @@
  */
 package okhttp3
 
-import assertk.all
 import assertk.assertThat
 import assertk.assertions.contains
 import assertk.assertions.containsExactly
 import assertk.assertions.doesNotContain
 import assertk.assertions.isEqualTo
-import assertk.assertions.isFalse
 import assertk.assertions.isIn
 import assertk.assertions.isInstanceOf
 import assertk.assertions.isNotNull
 import assertk.assertions.isNull
 import assertk.assertions.isSameAs
-import assertk.assertions.isTrue
-import assertk.assertions.prop
 import java.io.File
 import java.io.IOException
 import java.io.InterruptedIOException
@@ -63,7 +59,6 @@ import okhttp3.CallEvent.ResponseBodyStart
 import okhttp3.CallEvent.ResponseFailed
 import okhttp3.CallEvent.ResponseHeadersEnd
 import okhttp3.CallEvent.ResponseHeadersStart
-import okhttp3.CallEvent.RetryDecision
 import okhttp3.CallEvent.SecureConnectEnd
 import okhttp3.CallEvent.SecureConnectStart
 import okhttp3.MediaType.Companion.toMediaType
@@ -248,12 +243,8 @@ class EventListenerTest {
       "CallStart",
       "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
       "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-      "RequestHeadersEnd", "ResponseFailed", "RetryDecision", "ConnectionReleased", "CallFailed",
+      "RequestHeadersEnd", "ResponseFailed", "ConnectionReleased", "CallFailed",
     )
-    assertThat(listener.findEvent<RetryDecision>()).all {
-      prop(RetryDecision::reason).isEqualTo("request was at least partially sent")
-      prop(RetryDecision::shouldRetry).isFalse()
-    }
   }
 
   @Test
@@ -1654,14 +1645,10 @@ class EventListenerTest {
       "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
       "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
       "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-      "ResponseBodyEnd", "RetryDecision", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
+      "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
       "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
       "CallEnd",
     )
-    assertThat(listener.findEvent<RetryDecision>()).all {
-      prop(RetryDecision::reason).isEqualTo("redirect (302)")
-      prop(RetryDecision::shouldRetry).isTrue()
-    }
   }
 
   @Test
@@ -1691,7 +1678,6 @@ class EventListenerTest {
       "ResponseHeadersEnd",
       "ResponseBodyStart",
       "ResponseBodyEnd",
-      "RetryDecision",
       "ConnectionReleased",
       "ProxySelectStart",
       "ProxySelectEnd",
@@ -1709,10 +1695,6 @@ class EventListenerTest {
       "ConnectionReleased",
       "CallEnd",
     )
-    assertThat(listener.findEvent<RetryDecision>()).all {
-      prop(RetryDecision::reason).isEqualTo("redirect (302)")
-      prop(RetryDecision::shouldRetry).isTrue()
-    }
   }
 
   @Test
@@ -1933,11 +1915,7 @@ class EventListenerTest {
     assertThat(response.code).isEqualTo(504)
     response.close()
     assertThat(listener.recordedEventTypes())
-      .containsExactly("CallStart", "SatisfactionFailure", "RetryDecision", "CallEnd")
-    assertThat(listener.findEvent<RetryDecision>()).all {
-      prop(RetryDecision::reason).isEqualTo("No rule to retry request (504)")
-      prop(RetryDecision::shouldRetry).isFalse()
-    }
+      .containsExactly("CallStart", "SatisfactionFailure", "CallEnd")
   }
 
   @Test
