diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/TypeResolver.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/TypeResolver.kt
index 89ed9b64..99cc29bf 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/TypeResolver.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/TypeResolver.kt
@@ -35,18 +35,15 @@ open class TypeResolver {
       is ParameterizedTypeName -> {
         ParameterizedTypeName.get(
             typeName.rawType, *(typeName.typeArguments.map { resolve(it) }.toTypedArray()))
-            .asNullableIf(typeName.nullable)
       }
 
       is WildcardTypeName -> {
         when {
           typeName.lowerBounds.size == 1 -> {
             WildcardTypeName.supertypeOf(resolve(typeName.lowerBounds[0]))
-                .asNullableIf(typeName.nullable)
           }
           typeName.upperBounds.size == 1 -> {
             WildcardTypeName.subtypeOf(resolve(typeName.upperBounds[0]))
-                .asNullableIf(typeName.nullable)
           }
           else -> {
             throw IllegalArgumentException(
@@ -60,4 +57,4 @@ open class TypeResolver {
       else -> throw IllegalArgumentException("Unrepresentable type: $typeName")
     }
   }
-}
+}
\ No newline at end of file
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/kotlintypes.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/kotlintypes.kt
index fd4c6d1e..f5d95804 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/kotlintypes.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/kotlintypes.kt
@@ -26,7 +26,3 @@ internal fun TypeName.rawType(): ClassName {
     else -> throw IllegalArgumentException("Cannot get raw type from $this")
   }
 }
-
-internal fun TypeName.asNullableIf(condition: Boolean): TypeName {
-  return if (condition) asNullable() else this
-}
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/metadata.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/metadata.kt
index d26170b1..1109cfbb 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/metadata.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/metadata.kt
@@ -72,17 +72,15 @@ internal fun Type.asTypeName(
   if (hasFlexibleUpperBound()) {
     return WildcardTypeName.subtypeOf(
         flexibleUpperBound.asTypeName(nameResolver, getTypeParameter, resolveAliases))
-        .asNullableIf(nullable)
   } else if (hasOuterType()) {
     return WildcardTypeName.supertypeOf(
         outerType.asTypeName(nameResolver, getTypeParameter, resolveAliases))
-        .asNullableIf(nullable)
   }
 
   val realType = when {
     hasTypeParameter() -> return getTypeParameter(typeParameter)
         .asTypeName(nameResolver, getTypeParameter, resolveAliases)
-        .asNullableIf(nullable)
+        .let { if (nullable) it.asNullable() else it }
     hasTypeParameterName() -> typeParameterName
     hasAbbreviatedType() && !resolveAliases -> abbreviatedType.typeAliasName
     else -> className
@@ -93,36 +91,43 @@ internal fun Type.asTypeName(
           .replace("/", "."))
 
   if (argumentList.isNotEmpty()) {
-    val remappedArgs: Array<TypeName> = argumentList.map { argumentType ->
-      val nullableProjection = if (argumentType.hasProjection()) {
-        argumentType.projection
+    val remappedArgs: Array<TypeName> = argumentList.map {
+      val projection = if (it.hasProjection()) {
+        it.projection
       } else null
-      if (argumentType.hasType()) {
-        argumentType.type.asTypeName(nameResolver, getTypeParameter, resolveAliases)
-            .let { argumentTypeName ->
-              nullableProjection?.let { projection ->
-                when (projection) {
-                  Type.Argument.Projection.IN -> WildcardTypeName.supertypeOf(argumentTypeName)
+      if (it.hasType()) {
+        it.type.asTypeName(nameResolver, getTypeParameter, resolveAliases)
+            .let { typeName ->
+              projection?.let {
+                when (it) {
+                  Type.Argument.Projection.IN -> WildcardTypeName.supertypeOf(
+                      typeName)
                   Type.Argument.Projection.OUT -> {
-                    if (argumentTypeName == ANY) {
+                    if (typeName == ANY) {
                       // This becomes a *, which we actually don't want here.
                       // List<Any> works with List<*>, but List<*> doesn't work with List<Any>
-                      argumentTypeName
+                      typeName
                     } else {
-                      WildcardTypeName.subtypeOf(argumentTypeName)
+                      WildcardTypeName.subtypeOf(typeName)
                     }
                   }
-                  Type.Argument.Projection.STAR -> WildcardTypeName.subtypeOf(ANY)
+                  Type.Argument.Projection.STAR -> WildcardTypeName.subtypeOf(
+                      ANY)
                   Type.Argument.Projection.INV -> TODO("INV projection is unsupported")
                 }
-              } ?: argumentTypeName
+              } ?: typeName
             }
       } else {
         WildcardTypeName.subtypeOf(ANY)
       }
     }.toTypedArray()
-    typeName = ParameterizedTypeName.get(typeName as ClassName, *remappedArgs)
+    typeName = ParameterizedTypeName.get(
+        typeName as ClassName, *remappedArgs)
   }
 
-  return typeName.asNullableIf(nullable)
+  if (nullable) {
+    typeName = typeName.asNullable()
+  }
+
+  return typeName
 }
diff --git a/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/TypeResolverTest.kt b/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/TypeResolverTest.kt
deleted file mode 100644
index f81f27bc..00000000
--- a/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/TypeResolverTest.kt
+++ /dev/null
@@ -1,36 +0,0 @@
-package com.squareup.moshi
-
-import com.google.common.truth.Truth.assertThat
-import com.squareup.kotlinpoet.ParameterizedTypeName
-import com.squareup.kotlinpoet.WildcardTypeName
-import com.squareup.kotlinpoet.asClassName
-import org.junit.Test
-
-class TypeResolverTest {
-
-  private val resolver = TypeResolver()
-
-  @Test
-  fun ensureClassNameNullabilityIsPreserved() {
-    assertThat(resolver.resolve(Int::class.asClassName().asNullable()).nullable).isTrue()
-  }
-
-  @Test
-  fun ensureParameterizedNullabilityIsPreserved() {
-    val nullableTypeName = ParameterizedTypeName.get(
-        List::class.asClassName(),
-        String::class.asClassName())
-        .asNullable()
-
-    assertThat(resolver.resolve(nullableTypeName).nullable).isTrue()
-  }
-
-  @Test
-  fun ensureWildcardNullabilityIsPreserved() {
-    val nullableTypeName = WildcardTypeName.subtypeOf(List::class.asClassName())
-        .asNullable()
-
-    assertThat(resolver.resolve(nullableTypeName).nullable).isTrue()
-  }
-
-}
