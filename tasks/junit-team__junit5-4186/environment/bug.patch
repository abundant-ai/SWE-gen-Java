diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.4.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.4.adoc
index 1e2d0eab3..ee08a53ee 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.4.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.11.4.adoc
@@ -16,10 +16,7 @@ JUnit repository on GitHub.
 [[release-notes-5.11.4-junit-platform-bug-fixes]]
 ==== Bug Fixes
 
-* Escape whitespace characters (such as line breaks) in XML attribute values (such as
-  exception messages) in the legacy XML report generated by the Console Launcher. This
-  change ensures the resulting XML files can be processed by downstream tools while
-  preserving whitespace characters.
+* ❓
 
 [[release-notes-5.11.4-junit-platform-deprecations-and-breaking-changes]]
 ==== Deprecations and Breaking Changes
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 5b5c6b20f..da1b55fd7 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -68,7 +68,6 @@ univocity-parsers = { module = "com.sonofab1rd:univocity-parsers", version = "2.
 xmlunit-assertj = { module = "org.xmlunit:xmlunit-assertj3", version.ref = "xmlunit" }
 xmlunit-placeholders = { module = "org.xmlunit:xmlunit-placeholders", version.ref = "xmlunit" }
 testingAnnotations = { module = "com.gradle:develocity-testing-annotations", version = "2.0.1" }
-woodstox = { module = "com.fasterxml.woodstox:woodstox-core", version = "7.0.0" }
 
 # Only declared here so Dependabot knows when to update the referenced versions
 asciidoctorj-pdf = { module = "org.asciidoctor:asciidoctorj-pdf", version.ref = "asciidoctorj-pdf" }
diff --git a/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportWriter.java b/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportWriter.java
index b9d7ea13a..e81d3abbd 100644
--- a/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportWriter.java
+++ b/junit-platform-reporting/src/main/java/org/junit/platform/reporting/legacy/xml/XmlReportWriter.java
@@ -13,7 +13,6 @@ package org.junit.platform.reporting.legacy.xml;
 import static java.text.MessageFormat.format;
 import static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE_TIME;
 import static java.util.Collections.emptyList;
-import static java.util.Collections.unmodifiableMap;
 import static java.util.Comparator.naturalOrder;
 import static java.util.function.Function.identity;
 import static java.util.stream.Collectors.counting;
@@ -31,7 +30,6 @@ import static org.junit.platform.reporting.legacy.xml.XmlReportWriter.Aggregated
 import static org.junit.platform.reporting.legacy.xml.XmlReportWriter.AggregatedTestResult.Type.SKIPPED;
 import static org.junit.platform.reporting.legacy.xml.XmlReportWriter.AggregatedTestResult.Type.SUCCESS;
 
-import java.io.IOException;
 import java.io.Writer;
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -40,7 +38,6 @@ import java.time.LocalDateTime;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.EnumSet;
-import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
@@ -71,17 +68,6 @@ import org.junit.platform.reporting.legacy.xml.XmlReportWriter.AggregatedTestRes
  */
 class XmlReportWriter {
 
-	static final char ILLEGAL_CHARACTER_REPLACEMENT = '\uFFFD';
-
-	private static final Map<Character, String> REPLACEMENTS_IN_ATTRIBUTE_VALUES;
-	static {
-		Map<Character, String> tmp = new HashMap<>(3);
-		tmp.put('\n', "&#10;");
-		tmp.put('\r', "&#13;");
-		tmp.put('\t', "&#9;");
-		REPLACEMENTS_IN_ATTRIBUTE_VALUES = unmodifiableMap(tmp);
-	}
-
 	// Using zero-width assertions in the split pattern simplifies the splitting process: All split parts
 	// (including the first and last one) can be used directly, without having to re-add separator characters.
 	private static final Pattern CDATA_SPLIT_PATTERN = Pattern.compile("(?<=]])(?=>)");
@@ -115,269 +101,243 @@ class XmlReportWriter {
 	private void writeXmlReport(TestIdentifier testIdentifier, Map<TestIdentifier, AggregatedTestResult> tests,
 			Writer out) throws XMLStreamException {
 
-		new XmlReport(out).write(testIdentifier, tests);
+		XMLOutputFactory factory = XMLOutputFactory.newInstance();
+		XMLStreamWriter xmlWriter = factory.createXMLStreamWriter(out);
+		xmlWriter.writeStartDocument("UTF-8", "1.0");
+		newLine(xmlWriter);
+		writeTestsuite(testIdentifier, tests, xmlWriter);
+		xmlWriter.writeEndDocument();
+		xmlWriter.flush();
+		xmlWriter.close();
 	}
 
-	class XmlReport implements AutoCloseable {
-
-		private final XMLStreamWriter xml;
-		private final ReplacingWriter out;
+	private void writeTestsuite(TestIdentifier testIdentifier, Map<TestIdentifier, AggregatedTestResult> tests,
+			XMLStreamWriter writer) throws XMLStreamException {
 
-		XmlReport(Writer out) throws XMLStreamException {
-			this.out = new ReplacingWriter(out);
-			XMLOutputFactory factory = XMLOutputFactory.newInstance();
-			this.xml = factory.createXMLStreamWriter(this.out);
-		}
-
-		void write(TestIdentifier testIdentifier, Map<TestIdentifier, AggregatedTestResult> tests)
-				throws XMLStreamException {
-			xml.writeStartDocument("UTF-8", "1.0");
-			newLine();
-			writeTestsuite(testIdentifier, tests);
-			xml.writeEndDocument();
-		}
+		// NumberFormat is not thread-safe. Thus, we instantiate it here and pass it to
+		// writeTestcase instead of using a constant
+		NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
 
-		private void writeTestsuite(TestIdentifier testIdentifier, Map<TestIdentifier, AggregatedTestResult> tests)
-				throws XMLStreamException {
+		writer.writeStartElement("testsuite");
 
-			// NumberFormat is not thread-safe. Thus, we instantiate it here and pass it to
-			// writeTestcase instead of using a constant
-			NumberFormat numberFormat = NumberFormat.getInstance(Locale.US);
+		writeSuiteAttributes(testIdentifier, tests.values(), numberFormat, writer);
 
-			xml.writeStartElement("testsuite");
+		newLine(writer);
+		writeSystemProperties(writer);
 
-			writeSuiteAttributes(testIdentifier, tests.values(), numberFormat);
+		for (Entry<TestIdentifier, AggregatedTestResult> entry : tests.entrySet()) {
+			writeTestcase(entry.getKey(), entry.getValue(), numberFormat, writer);
+		}
 
-			newLine();
-			writeSystemProperties();
+		writeOutputElement("system-out", formatNonStandardAttributesAsString(testIdentifier), writer);
 
-			for (Entry<TestIdentifier, AggregatedTestResult> entry : tests.entrySet()) {
-				writeTestcase(entry.getKey(), entry.getValue(), numberFormat);
-			}
+		writer.writeEndElement();
+		newLine(writer);
+	}
 
-			writeOutputElement("system-out", formatNonStandardAttributesAsString(testIdentifier));
+	private void writeSuiteAttributes(TestIdentifier testIdentifier, Collection<AggregatedTestResult> testResults,
+			NumberFormat numberFormat, XMLStreamWriter writer) throws XMLStreamException {
 
-			xml.writeEndElement();
-			newLine();
-		}
+		writeAttributeSafely(writer, "name", testIdentifier.getDisplayName());
+		writeTestCounts(testResults, writer);
+		writeAttributeSafely(writer, "time", getTime(testIdentifier, numberFormat));
+		writeAttributeSafely(writer, "hostname", getHostname().orElse("<unknown host>"));
+		writeAttributeSafely(writer, "timestamp", ISO_LOCAL_DATE_TIME.format(getCurrentDateTime()));
+	}
 
-		private void writeSuiteAttributes(TestIdentifier testIdentifier, Collection<AggregatedTestResult> testResults,
-				NumberFormat numberFormat) throws XMLStreamException {
+	private void writeTestCounts(Collection<AggregatedTestResult> testResults, XMLStreamWriter writer)
+			throws XMLStreamException {
+		Map<Type, Long> counts = testResults.stream().map(it -> it.type).collect(groupingBy(identity(), counting()));
+		long total = counts.values().stream().mapToLong(Long::longValue).sum();
+		writeAttributeSafely(writer, "tests", String.valueOf(total));
+		writeAttributeSafely(writer, "skipped", counts.getOrDefault(SKIPPED, 0L).toString());
+		writeAttributeSafely(writer, "failures", counts.getOrDefault(FAILURE, 0L).toString());
+		writeAttributeSafely(writer, "errors", counts.getOrDefault(ERROR, 0L).toString());
+	}
 
-			writeAttributeSafely("name", testIdentifier.getDisplayName());
-			writeTestCounts(testResults);
-			writeAttributeSafely("time", getTime(testIdentifier, numberFormat));
-			writeAttributeSafely("hostname", getHostname().orElse("<unknown host>"));
-			writeAttributeSafely("timestamp", ISO_LOCAL_DATE_TIME.format(getCurrentDateTime()));
-		}
+	private void writeSystemProperties(XMLStreamWriter writer) throws XMLStreamException {
+		writer.writeStartElement("properties");
+		newLine(writer);
+		Properties systemProperties = System.getProperties();
+		for (String propertyName : new TreeSet<>(systemProperties.stringPropertyNames())) {
+			writer.writeEmptyElement("property");
+			writeAttributeSafely(writer, "name", propertyName);
+			writeAttributeSafely(writer, "value", systemProperties.getProperty(propertyName));
+			newLine(writer);
+		}
+		writer.writeEndElement();
+		newLine(writer);
+	}
 
-		private void writeTestCounts(Collection<AggregatedTestResult> testResults) throws XMLStreamException {
-			Map<Type, Long> counts = testResults.stream().map(it -> it.type).collect(
-				groupingBy(identity(), counting()));
-			long total = counts.values().stream().mapToLong(Long::longValue).sum();
-			writeAttributeSafely("tests", String.valueOf(total));
-			writeAttributeSafely("skipped", counts.getOrDefault(SKIPPED, 0L).toString());
-			writeAttributeSafely("failures", counts.getOrDefault(FAILURE, 0L).toString());
-			writeAttributeSafely("errors", counts.getOrDefault(ERROR, 0L).toString());
-		}
+	private void writeTestcase(TestIdentifier testIdentifier, AggregatedTestResult testResult,
+			NumberFormat numberFormat, XMLStreamWriter writer) throws XMLStreamException {
 
-		private void writeSystemProperties() throws XMLStreamException {
-			xml.writeStartElement("properties");
-			newLine();
-			Properties systemProperties = System.getProperties();
-			for (String propertyName : new TreeSet<>(systemProperties.stringPropertyNames())) {
-				xml.writeEmptyElement("property");
-				writeAttributeSafely("name", propertyName);
-				writeAttributeSafely("value", systemProperties.getProperty(propertyName));
-				newLine();
-			}
-			xml.writeEndElement();
-			newLine();
-		}
+		writer.writeStartElement("testcase");
 
-		private void writeTestcase(TestIdentifier testIdentifier, AggregatedTestResult testResult,
-				NumberFormat numberFormat) throws XMLStreamException {
+		writeAttributeSafely(writer, "name", getName(testIdentifier));
+		writeAttributeSafely(writer, "classname", getClassName(testIdentifier));
+		writeAttributeSafely(writer, "time", getTime(testIdentifier, numberFormat));
+		newLine(writer);
 
-			xml.writeStartElement("testcase");
+		writeSkippedOrErrorOrFailureElement(testIdentifier, testResult, writer);
 
-			writeAttributeSafely("name", getName(testIdentifier));
-			writeAttributeSafely("classname", getClassName(testIdentifier));
-			writeAttributeSafely("time", getTime(testIdentifier, numberFormat));
-			newLine();
+		List<String> systemOutElements = new ArrayList<>();
+		List<String> systemErrElements = new ArrayList<>();
+		systemOutElements.add(formatNonStandardAttributesAsString(testIdentifier));
+		collectReportEntries(testIdentifier, systemOutElements, systemErrElements);
+		writeOutputElements("system-out", systemOutElements, writer);
+		writeOutputElements("system-err", systemErrElements, writer);
 
-			writeSkippedOrErrorOrFailureElement(testIdentifier, testResult);
+		writer.writeEndElement();
+		newLine(writer);
+	}
 
-			List<String> systemOutElements = new ArrayList<>();
-			List<String> systemErrElements = new ArrayList<>();
-			systemOutElements.add(formatNonStandardAttributesAsString(testIdentifier));
-			collectReportEntries(testIdentifier, systemOutElements, systemErrElements);
-			writeOutputElements("system-out", systemOutElements);
-			writeOutputElements("system-err", systemErrElements);
+	private String getName(TestIdentifier testIdentifier) {
+		return testIdentifier.getLegacyReportingName();
+	}
 
-			xml.writeEndElement();
-			newLine();
-		}
+	private String getClassName(TestIdentifier testIdentifier) {
+		return LegacyReportingUtils.getClassName(this.reportData.getTestPlan(), testIdentifier);
+	}
 
-		private String getName(TestIdentifier testIdentifier) {
-			return testIdentifier.getLegacyReportingName();
-		}
+	private void writeSkippedOrErrorOrFailureElement(TestIdentifier testIdentifier, AggregatedTestResult testResult,
+			XMLStreamWriter writer) throws XMLStreamException {
 
-		private String getClassName(TestIdentifier testIdentifier) {
-			return LegacyReportingUtils.getClassName(reportData.getTestPlan(), testIdentifier);
+		if (testResult.type == SKIPPED) {
+			writeSkippedElement(this.reportData.getSkipReason(testIdentifier), writer);
 		}
-
-		private void writeSkippedOrErrorOrFailureElement(TestIdentifier testIdentifier, AggregatedTestResult testResult)
-				throws XMLStreamException {
-
-			if (testResult.type == SKIPPED) {
-				writeSkippedElement(reportData.getSkipReason(testIdentifier), xml);
-			}
-			else {
-				Map<Type, List<Optional<Throwable>>> throwablesByType = testResult.getThrowablesByType();
-				for (Type type : EnumSet.of(FAILURE, ERROR)) {
-					for (Optional<Throwable> throwable : throwablesByType.getOrDefault(type, emptyList())) {
-						writeErrorOrFailureElement(type, throwable.orElse(null), xml);
-					}
+		else {
+			Map<Type, List<Optional<Throwable>>> throwablesByType = testResult.getThrowablesByType();
+			for (Type type : EnumSet.of(FAILURE, ERROR)) {
+				for (Optional<Throwable> throwable : throwablesByType.getOrDefault(type, emptyList())) {
+					writeErrorOrFailureElement(type, throwable.orElse(null), writer);
 				}
 			}
 		}
+	}
 
-		private void writeSkippedElement(String reason, XMLStreamWriter writer) throws XMLStreamException {
-			if (isNotBlank(reason)) {
-				writer.writeStartElement("skipped");
-				writeCDataSafely(reason);
-				writer.writeEndElement();
-			}
-			else {
-				writer.writeEmptyElement("skipped");
-			}
-			newLine();
+	private void writeSkippedElement(String reason, XMLStreamWriter writer) throws XMLStreamException {
+		if (isNotBlank(reason)) {
+			writer.writeStartElement("skipped");
+			writeCDataSafely(writer, reason);
+			writer.writeEndElement();
+		}
+		else {
+			writer.writeEmptyElement("skipped");
 		}
+		newLine(writer);
+	}
 
-		private void writeErrorOrFailureElement(Type type, Throwable throwable, XMLStreamWriter writer)
-				throws XMLStreamException {
+	private void writeErrorOrFailureElement(Type type, Throwable throwable, XMLStreamWriter writer)
+			throws XMLStreamException {
 
-			String elementName = type == FAILURE ? "failure" : "error";
-			if (throwable != null) {
-				writer.writeStartElement(elementName);
-				writeFailureAttributesAndContent(throwable);
-				writer.writeEndElement();
-			}
-			else {
-				writer.writeEmptyElement(elementName);
-			}
-			newLine();
+		String elementName = type == FAILURE ? "failure" : "error";
+		if (throwable != null) {
+			writer.writeStartElement(elementName);
+			writeFailureAttributesAndContent(throwable, writer);
+			writer.writeEndElement();
+		}
+		else {
+			writer.writeEmptyElement(elementName);
 		}
+		newLine(writer);
+	}
 
-		private void writeFailureAttributesAndContent(Throwable throwable) throws XMLStreamException {
+	private void writeFailureAttributesAndContent(Throwable throwable, XMLStreamWriter writer)
+			throws XMLStreamException {
 
-			if (throwable.getMessage() != null) {
-				writeAttributeSafely("message", throwable.getMessage());
-			}
-			writeAttributeSafely("type", throwable.getClass().getName());
-			writeCDataSafely(readStackTrace(throwable));
+		if (throwable.getMessage() != null) {
+			writeAttributeSafely(writer, "message", throwable.getMessage());
 		}
+		writeAttributeSafely(writer, "type", throwable.getClass().getName());
+		writeCDataSafely(writer, readStackTrace(throwable));
+	}
 
-		private void collectReportEntries(TestIdentifier testIdentifier, List<String> systemOutElements,
-				List<String> systemErrElements) {
-			List<ReportEntry> entries = reportData.getReportEntries(testIdentifier);
-			if (!entries.isEmpty()) {
-				List<String> systemOutElementsForCapturedOutput = new ArrayList<>();
-				StringBuilder formattedReportEntries = new StringBuilder();
-				for (int i = 0; i < entries.size(); i++) {
-					ReportEntry reportEntry = entries.get(i);
-					Map<String, String> keyValuePairs = new LinkedHashMap<>(reportEntry.getKeyValuePairs());
-					removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDOUT_REPORT_ENTRY_KEY,
-						systemOutElementsForCapturedOutput);
-					removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDERR_REPORT_ENTRY_KEY, systemErrElements);
-					if (!keyValuePairs.isEmpty()) {
-						buildReportEntryDescription(reportEntry.getTimestamp(), keyValuePairs, i + 1,
-							formattedReportEntries);
-					}
+	private void collectReportEntries(TestIdentifier testIdentifier, List<String> systemOutElements,
+			List<String> systemErrElements) {
+		List<ReportEntry> entries = this.reportData.getReportEntries(testIdentifier);
+		if (!entries.isEmpty()) {
+			List<String> systemOutElementsForCapturedOutput = new ArrayList<>();
+			StringBuilder formattedReportEntries = new StringBuilder();
+			for (int i = 0; i < entries.size(); i++) {
+				ReportEntry reportEntry = entries.get(i);
+				Map<String, String> keyValuePairs = new LinkedHashMap<>(reportEntry.getKeyValuePairs());
+				removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDOUT_REPORT_ENTRY_KEY,
+					systemOutElementsForCapturedOutput);
+				removeIfPresentAndAddAsSeparateElement(keyValuePairs, STDERR_REPORT_ENTRY_KEY, systemErrElements);
+				if (!keyValuePairs.isEmpty()) {
+					buildReportEntryDescription(reportEntry.getTimestamp(), keyValuePairs, i + 1,
+						formattedReportEntries);
 				}
-				systemOutElements.add(formattedReportEntries.toString().trim());
-				systemOutElements.addAll(systemOutElementsForCapturedOutput);
-			}
-		}
-
-		private void removeIfPresentAndAddAsSeparateElement(Map<String, String> keyValuePairs, String key,
-				List<String> elements) {
-			String value = keyValuePairs.remove(key);
-			if (value != null) {
-				elements.add(value);
 			}
+			systemOutElements.add(formattedReportEntries.toString().trim());
+			systemOutElements.addAll(systemOutElementsForCapturedOutput);
 		}
+	}
 
-		private void buildReportEntryDescription(LocalDateTime timestamp, Map<String, String> keyValuePairs,
-				int entryNumber, StringBuilder result) {
-			result.append(
-				format("Report Entry #{0} (timestamp: {1})\n", entryNumber, ISO_LOCAL_DATE_TIME.format(timestamp)));
-			keyValuePairs.forEach((key, value) -> result.append(format("\t- {0}: {1}\n", key, value)));
+	private void removeIfPresentAndAddAsSeparateElement(Map<String, String> keyValuePairs, String key,
+			List<String> elements) {
+		String value = keyValuePairs.remove(key);
+		if (value != null) {
+			elements.add(value);
 		}
+	}
 
-		private String getTime(TestIdentifier testIdentifier, NumberFormat numberFormat) {
-			return numberFormat.format(reportData.getDurationInSeconds(testIdentifier));
-		}
+	private void buildReportEntryDescription(LocalDateTime timestamp, Map<String, String> keyValuePairs,
+			int entryNumber, StringBuilder result) {
+		result.append(
+			format("Report Entry #{0} (timestamp: {1})\n", entryNumber, ISO_LOCAL_DATE_TIME.format(timestamp)));
+		keyValuePairs.forEach((key, value) -> result.append(format("\t- {0}: {1}\n", key, value)));
+	}
 
-		private Optional<String> getHostname() {
-			try {
-				return Optional.ofNullable(InetAddress.getLocalHost().getHostName());
-			}
-			catch (UnknownHostException e) {
-				return Optional.empty();
-			}
-		}
+	private String getTime(TestIdentifier testIdentifier, NumberFormat numberFormat) {
+		return numberFormat.format(this.reportData.getDurationInSeconds(testIdentifier));
+	}
 
-		private LocalDateTime getCurrentDateTime() {
-			return LocalDateTime.now(reportData.getClock()).withNano(0);
+	private Optional<String> getHostname() {
+		try {
+			return Optional.ofNullable(InetAddress.getLocalHost().getHostName());
 		}
-
-		private String formatNonStandardAttributesAsString(TestIdentifier testIdentifier) {
-			return "unique-id: " + testIdentifier.getUniqueId() //
-					+ "\ndisplay-name: " + testIdentifier.getDisplayName();
+		catch (UnknownHostException e) {
+			return Optional.empty();
 		}
+	}
 
-		private void writeOutputElements(String elementName, List<String> elements) throws XMLStreamException {
-			for (String content : elements) {
-				writeOutputElement(elementName, content);
-			}
-		}
+	private LocalDateTime getCurrentDateTime() {
+		return LocalDateTime.now(this.reportData.getClock()).withNano(0);
+	}
 
-		private void writeOutputElement(String elementName, String content) throws XMLStreamException {
-			xml.writeStartElement(elementName);
-			writeCDataSafely("\n" + content + "\n");
-			xml.writeEndElement();
-			newLine();
-		}
+	private String formatNonStandardAttributesAsString(TestIdentifier testIdentifier) {
+		return "unique-id: " + testIdentifier.getUniqueId() //
+				+ "\ndisplay-name: " + testIdentifier.getDisplayName();
+	}
 
-		private void writeAttributeSafely(String name, String value) throws XMLStreamException {
-			// Workaround for XMLStreamWriter implementations that don't escape
-			// '\n', '\r', and '\t' characters in attribute values
-			xml.flush();
-			out.setWhitespaceReplacingEnabled(true);
-			xml.writeAttribute(name, replaceIllegalCharacters(value));
-			xml.flush();
-			out.setWhitespaceReplacingEnabled(false);
+	private void writeOutputElements(String elementName, List<String> elements, XMLStreamWriter writer)
+			throws XMLStreamException {
+		for (String content : elements) {
+			writeOutputElement(elementName, content, writer);
 		}
+	}
 
-		private void writeCDataSafely(String data) throws XMLStreamException {
-			for (String safeDataPart : CDATA_SPLIT_PATTERN.split(replaceIllegalCharacters(data))) {
-				xml.writeCData(safeDataPart);
-			}
-		}
+	private void writeOutputElement(String elementName, String content, XMLStreamWriter writer)
+			throws XMLStreamException {
+		writer.writeStartElement(elementName);
+		writeCDataSafely(writer, "\n" + content + "\n");
+		writer.writeEndElement();
+		newLine(writer);
+	}
 
-		private void newLine() throws XMLStreamException {
-			xml.writeCharacters("\n");
-		}
+	private void writeAttributeSafely(XMLStreamWriter writer, String name, String value) throws XMLStreamException {
+		writer.writeAttribute(name, escapeIllegalChars(value));
+	}
 
-		@Override
-		public void close() throws XMLStreamException {
-			xml.flush();
-			xml.close();
+	private void writeCDataSafely(XMLStreamWriter writer, String data) throws XMLStreamException {
+		for (String safeDataPart : CDATA_SPLIT_PATTERN.split(escapeIllegalChars(data))) {
+			writer.writeCData(safeDataPart);
 		}
 	}
 
-	static String replaceIllegalCharacters(String text) {
+	static String escapeIllegalChars(String text) {
 		if (text.codePoints().allMatch(XmlReportWriter::isAllowedXmlCharacter)) {
 			return text;
 		}
@@ -386,14 +346,14 @@ class XmlReportWriter {
 			if (isAllowedXmlCharacter(codePoint)) {
 				result.appendCodePoint(codePoint);
 			}
-			else {
-				result.append(ILLEGAL_CHARACTER_REPLACEMENT);
+			else { // use a Character Reference (cf. https://www.w3.org/TR/xml/#NT-CharRef)
+				result.append("&#").append(codePoint).append(';');
 			}
 		});
 		return result.toString();
 	}
 
-	static boolean isAllowedXmlCharacter(int codePoint) {
+	private static boolean isAllowedXmlCharacter(int codePoint) {
 		// source: https://www.w3.org/TR/xml/#charsets
 		return codePoint == 0x9 //
 				|| codePoint == 0xA //
@@ -403,6 +363,15 @@ class XmlReportWriter {
 				|| (codePoint >= 0x10000 && codePoint <= 0x10FFFF);
 	}
 
+	private void newLine(XMLStreamWriter xmlWriter) throws XMLStreamException {
+		xmlWriter.writeCharacters("\n");
+	}
+
+	private static boolean isFailure(TestExecutionResult result) {
+		Optional<Throwable> throwable = result.getThrowable();
+		return throwable.isPresent() && throwable.get() instanceof AssertionError;
+	}
+
 	static class AggregatedTestResult {
 
 		private static final AggregatedTestResult SKIPPED_RESULT = new AggregatedTestResult(SKIPPED, emptyList());
@@ -442,125 +411,6 @@ class XmlReportWriter {
 				}
 				return SUCCESS;
 			}
-
-			private static boolean isFailure(TestExecutionResult result) {
-				Optional<Throwable> throwable = result.getThrowable();
-				return throwable.isPresent() && throwable.get() instanceof AssertionError;
-			}
-		}
-	}
-
-	private static class ReplacingWriter extends Writer {
-
-		private final Writer delegate;
-		private boolean whitespaceReplacingEnabled;
-
-		ReplacingWriter(Writer delegate) {
-			this.delegate = delegate;
-		}
-
-		void setWhitespaceReplacingEnabled(boolean whitespaceReplacingEnabled) {
-			this.whitespaceReplacingEnabled = whitespaceReplacingEnabled;
-		}
-
-		@Override
-		public void write(char[] cbuf, int off, int len) throws IOException {
-			if (!whitespaceReplacingEnabled) {
-				delegate.write(cbuf, off, len);
-				return;
-			}
-			StringBuilder stringBuilder = new StringBuilder(len * 2);
-			for (int i = off; i < off + len; i++) {
-				char c = cbuf[i];
-				String replacement = REPLACEMENTS_IN_ATTRIBUTE_VALUES.get(c);
-				if (replacement != null) {
-					stringBuilder.append(replacement);
-				}
-				else {
-					stringBuilder.append(c);
-				}
-			}
-			delegate.write(stringBuilder.toString());
-		}
-
-		@Override
-		public void write(int c) throws IOException {
-			if (whitespaceReplacingEnabled) {
-				super.write(c);
-			}
-			else {
-				delegate.write(c);
-			}
-		}
-
-		@Override
-		public void write(char[] cbuf) throws IOException {
-			if (whitespaceReplacingEnabled) {
-				super.write(cbuf);
-			}
-			else {
-				delegate.write(cbuf);
-			}
-		}
-
-		@Override
-		public void write(String str) throws IOException {
-			if (whitespaceReplacingEnabled) {
-				super.write(str);
-			}
-			else {
-				delegate.write(str);
-			}
-		}
-
-		@Override
-		public void write(String str, int off, int len) throws IOException {
-			if (whitespaceReplacingEnabled) {
-				super.write(str, off, len);
-			}
-			else {
-				delegate.write(str, off, len);
-			}
-		}
-
-		@Override
-		public Writer append(CharSequence csq) throws IOException {
-			if (whitespaceReplacingEnabled) {
-				return super.append(csq);
-			}
-			else {
-				return delegate.append(csq);
-			}
-		}
-
-		@Override
-		public Writer append(CharSequence csq, int start, int end) throws IOException {
-			if (whitespaceReplacingEnabled) {
-				return super.append(csq, start, end);
-			}
-			else {
-				return delegate.append(csq, start, end);
-			}
-		}
-
-		@Override
-		public Writer append(char c) throws IOException {
-			if (whitespaceReplacingEnabled) {
-				return super.append(c);
-			}
-			else {
-				return delegate.append(c);
-			}
-		}
-
-		@Override
-		public void flush() throws IOException {
-			delegate.flush();
-		}
-
-		@Override
-		public void close() throws IOException {
-			delegate.close();
 		}
 	}
 
diff --git a/platform-tests/platform-tests.gradle.kts b/platform-tests/platform-tests.gradle.kts
index 2da1a0dbb..4c1c69608 100644
--- a/platform-tests/platform-tests.gradle.kts
+++ b/platform-tests/platform-tests.gradle.kts
@@ -22,12 +22,6 @@ java {
 	}
 }
 
-val woodstox = configurations.dependencyScope("woodstox")
-val woodstoxRuntimeClasspath = configurations.resolvable("woodstoxRuntimeClasspath") {
-	extendsFrom(configurations.testRuntimeClasspath.get())
-	extendsFrom(woodstox.get())
-}
-
 dependencies {
 	// --- Things we are testing --------------------------------------------------
 	testImplementation(projects.junitPlatformCommons)
@@ -67,7 +61,6 @@ dependencies {
 	testRuntimeOnly(libs.groovy4) {
 		because("`ReflectionUtilsTests.findNestedClassesWithInvalidNestedClassFile` needs it")
 	}
-	woodstox(libs.woodstox)
 
 	// --- https://openjdk.java.net/projects/code-tools/jmh/ ----------------------
 	jmh(projects.junitJupiterApi)
@@ -115,16 +108,6 @@ tasks {
 			includeTags("junit4")
 		}
 	}
-	val testWoodstox by registering(Test::class) {
-		val test by testing.suites.existing(JvmTestSuite::class)
-		testClassesDirs = files(test.map { it.sources.output.classesDirs })
-		classpath = files(sourceSets.main.map { it.output }) + files(test.map { it.sources.output }) + woodstoxRuntimeClasspath.get()
-		group = JavaBasePlugin.VERIFICATION_GROUP
-		setIncludes(listOf("**/org/junit/platform/reporting/**"))
-	}
-	check {
-		dependsOn(testWoodstox)
-	}
 	named<JavaCompile>(processStarter.compileJavaTaskName).configure {
 		options.release = javaLibrary.testJavaVersion.majorVersion.toInt()
 	}
diff --git a/platform-tests/src/test/java/org/junit/platform/reporting/legacy/xml/XmlReportWriterTests.java b/platform-tests/src/test/java/org/junit/platform/reporting/legacy/xml/XmlReportWriterTests.java
index 3f4332632..7f8a324c5 100644
--- a/platform-tests/src/test/java/org/junit/platform/reporting/legacy/xml/XmlReportWriterTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/reporting/legacy/xml/XmlReportWriterTests.java
@@ -10,7 +10,6 @@
 
 package org.junit.platform.reporting.legacy.xml;
 
-import static java.util.stream.Collectors.joining;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.joox.JOOX.$;
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -22,7 +21,6 @@ import static org.junit.platform.launcher.LauncherConstants.STDERR_REPORT_ENTRY_
 import static org.junit.platform.launcher.LauncherConstants.STDOUT_REPORT_ENTRY_KEY;
 import static org.junit.platform.launcher.core.OutputDirectoryProviders.dummyOutputDirectoryProvider;
 import static org.junit.platform.reporting.legacy.xml.XmlReportAssertions.assertValidAccordingToJenkinsSchema;
-import static org.junit.platform.reporting.legacy.xml.XmlReportWriter.ILLEGAL_CHARACTER_REPLACEMENT;
 import static org.mockito.Mockito.mock;
 
 import java.io.StringReader;
@@ -31,7 +29,6 @@ import java.io.Writer;
 import java.time.Clock;
 import java.util.Map;
 import java.util.Set;
-import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
 import org.joox.Match;
@@ -223,55 +220,50 @@ class XmlReportWriterTests {
 
 		assertValidAccordingToJenkinsSchema(testsuite.document());
 		assertThat(testsuite.find("property").matchAttr("name", "foo\\.bar").attr("value")) //
-				.isEqualTo(String.valueOf(ILLEGAL_CHARACTER_REPLACEMENT));
+				.isEqualTo("&#1;");
 		var failure = testsuite.find("failure");
 		assertThat(failure.attr("message")) //
-				.isEqualTo("expected: <A> but was: <B" + ILLEGAL_CHARACTER_REPLACEMENT + ">");
+				.isEqualTo("expected: <A> but was: <B&#0;>");
 		assertThat(failure.text()) //
-				.contains("AssertionError: expected: <A> but was: <B" + ILLEGAL_CHARACTER_REPLACEMENT + ">");
-	}
-
-	@ParameterizedTest(name = "[{index}]")
-	@MethodSource("stringPairs")
-	void replacesIllegalCharacters(String input, String output) {
-		assertEquals(output, XmlReportWriter.replaceIllegalCharacters(input));
+				.contains("AssertionError: expected: <A> but was: <B&#0;>");
 	}
 
 	@Test
-	void writesValidXmlForExceptionMessagesContainingLineBreaks() throws Exception {
+	void doesNotReopenCDataWithinCDataContent() throws Exception {
 		var uniqueId = engineDescriptor.getUniqueId().append("test", "test");
 		engineDescriptor.addChild(new TestDescriptorStub(uniqueId, "test"));
 		var testPlan = TestPlan.from(Set.of(engineDescriptor), configParams, dummyOutputDirectoryProvider());
 
-		var allWhitespaceCharacters = IntStream.range(0, 0x10000) //
-				.filter(Character::isWhitespace) //
-				.filter(XmlReportWriter::isAllowedXmlCharacter) //
-				.mapToObj(Character::toString) //
-				.collect(joining());
-
-		var message = "a" + allWhitespaceCharacters + " b<&>";
 		var reportData = new XmlReportData(testPlan, Clock.systemDefaultZone());
-		var assertionError = new AssertionError(message);
+		var assertionError = new AssertionError("<foo><![CDATA[bar]]></foo>");
 		reportData.markFinished(testPlan.getTestIdentifier(uniqueId), failed(assertionError));
+		Writer assertingWriter = new StringWriter() {
 
-		var testsuite = writeXmlReport(testPlan, reportData);
+			@SuppressWarnings("NullableProblems")
+			@Override
+			public void write(char[] buffer, int off, int len) {
+				assertThat(new String(buffer, off, len)).doesNotContain("]]><![CDATA[");
+			}
+		};
 
-		assertValidAccordingToJenkinsSchema(testsuite.document());
+		writeXmlReport(testPlan, reportData, assertingWriter);
+	}
 
-		var attributeValue = testsuite.find("failure").attr("message");
-		assertThat(attributeValue).isEqualTo(message);
+	@ParameterizedTest(name = "{index}")
+	@MethodSource("stringPairs")
+	void escapesIllegalChars(String input, String output) {
+		assertEquals(output, XmlReportWriter.escapeIllegalChars(input));
 	}
 
 	static Stream<Arguments> stringPairs() {
 		return Stream.of( //
-			arguments("\0", String.valueOf(ILLEGAL_CHARACTER_REPLACEMENT)), //
-			arguments("\1", String.valueOf(ILLEGAL_CHARACTER_REPLACEMENT)), //
+			arguments("\0", "&#0;"), //
+			arguments("\1", "&#1;"), //
 			arguments("\t", "\t"), //
 			arguments("\r", "\r"), //
 			arguments("\n", "\n"), //
-			arguments("\u001f", String.valueOf(ILLEGAL_CHARACTER_REPLACEMENT)), //
-			arguments("✅", "✅"), //
-			arguments(" ", " "), //
+			arguments("\u001f", "&#31;"), //
+			arguments("\u0020", "\u0020"), //
 			arguments("foo!", "foo!"), //
 			arguments("\uD801\uDC00", "\uD801\uDC00") //
 		);
