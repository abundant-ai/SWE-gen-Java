diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index 1b64b2b3..1ecd8781 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -18,6 +18,7 @@ package com.squareup.moshi;
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import javax.annotation.CheckReturnValue;
@@ -176,13 +177,13 @@ import okio.ByteString;
  * of this class are not thread safe.
  */
 public abstract class JsonReader implements Closeable {
-  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack permits
-  // up to 32 levels of nesting including the top-level document. Deeper nesting is prone to trigger
-  // StackOverflowErrors.
+  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack will
+  // grow itself up to 256 levels of nesting including the top-level document. Deeper nesting is
+  // prone to trigger StackOverflowErrors.
   int stackSize = 0;
-  final int[] scopes = new int[32];
-  final String[] pathNames = new String[32];
-  final int[] pathIndices = new int[32];
+  int[] scopes = new int[32];
+  String[] pathNames = new String[32];
+  int[] pathIndices = new int[32];
 
   /** True to accept non-spec compliant JSON. */
   boolean lenient;
@@ -201,7 +202,12 @@ public abstract class JsonReader implements Closeable {
 
   final void pushScope(int newTop) {
     if (stackSize == scopes.length) {
-      throw new JsonDataException("Nesting too deep at " + getPath());
+      if (stackSize == 256) {
+        throw new JsonDataException("Nesting too deep at " + getPath());
+      }
+      scopes = Arrays.copyOf(scopes, scopes.length * 2);
+      pathNames = Arrays.copyOf(pathNames, pathNames.length * 2);
+      pathIndices = Arrays.copyOf(pathIndices, pathIndices.length * 2);
     }
     scopes[stackSize++] = newTop;
   }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
index 97838bcc..221f2591 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
@@ -101,6 +101,7 @@ final class JsonUtf8Writer extends JsonWriter {
    */
   private JsonWriter open(int empty, String openBracket) throws IOException {
     beforeValue();
+    checkStack();
     pushScope(empty);
     pathIndices[stackSize - 1] = 0;
     sink.writeUtf8(openBracket);
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
index 79fc9b83..cc532f25 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
@@ -31,7 +31,7 @@ import static java.lang.Double.POSITIVE_INFINITY;
 
 /** Writes JSON by building a Java object comprising maps, lists, and JSON primitives. */
 final class JsonValueWriter extends JsonWriter {
-  private final Object[] stack = new Object[32];
+  Object[] stack = new Object[32];
   private @Nullable String deferredName;
 
   JsonValueWriter() {
@@ -47,9 +47,7 @@ final class JsonValueWriter extends JsonWriter {
   }
 
   @Override public JsonWriter beginArray() throws IOException {
-    if (stackSize == stack.length) {
-      throw new JsonDataException("Nesting too deep at " + getPath() + ": circular reference?");
-    }
+    checkStack();
     List<Object> list = new ArrayList<>();
     add(list);
     stack[stackSize] = list;
@@ -69,9 +67,7 @@ final class JsonValueWriter extends JsonWriter {
   }
 
   @Override public JsonWriter beginObject() throws IOException {
-    if (stackSize == stack.length) {
-      throw new JsonDataException("Nesting too deep at " + getPath() + ": circular reference?");
-    }
+    checkStack();
     Map<String, Object> map = new LinkedHashTreeMap<>();
     add(map);
     stack[stackSize] = map;
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index 067eae09..70e9513c 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -18,6 +18,7 @@ package com.squareup.moshi;
 import java.io.Closeable;
 import java.io.Flushable;
 import java.io.IOException;
+import java.util.Arrays;
 import javax.annotation.CheckReturnValue;
 import javax.annotation.Nullable;
 import okio.BufferedSink;
@@ -121,13 +122,13 @@ import static com.squareup.moshi.JsonScope.NONEMPTY_OBJECT;
  * malformed JSON string will fail with an {@link IllegalStateException}.
  */
 public abstract class JsonWriter implements Closeable, Flushable {
-  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack permits
-  // up to 32 levels of nesting including the top-level document. Deeper nesting is prone to trigger
-  // StackOverflowErrors.
+  // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack will
+  // grow itself up to 256 levels of nesting including the top-level document. Deeper nesting is
+  // prone to trigger StackOverflowErrors.
   int stackSize = 0;
-  final int[] scopes = new int[32];
-  final String[] pathNames = new String[32];
-  final int[] pathIndices = new int[32];
+  int[] scopes = new int[32];
+  String[] pathNames = new String[32];
+  int[] pathIndices = new int[32];
 
   /**
    * A string containing a full set of spaces for a single level of indentation, or null for no
@@ -155,10 +156,26 @@ public abstract class JsonWriter implements Closeable, Flushable {
     return scopes[stackSize - 1];
   }
 
-  final void pushScope(int newTop) {
-    if (stackSize == scopes.length) {
+  /** Before pushing a value on the stack this confirms that the stack has capacity. */
+  final boolean checkStack() {
+    if (stackSize != scopes.length) return false;
+
+    if (stackSize == 256) {
       throw new JsonDataException("Nesting too deep at " + getPath() + ": circular reference?");
     }
+
+    scopes = Arrays.copyOf(scopes, scopes.length * 2);
+    pathNames = Arrays.copyOf(pathNames, pathNames.length * 2);
+    pathIndices = Arrays.copyOf(pathIndices, pathIndices.length * 2);
+    if (this instanceof JsonValueWriter) {
+      ((JsonValueWriter) this).stack =
+          Arrays.copyOf(((JsonValueWriter) this).stack, ((JsonValueWriter) this).stack.length * 2);
+    }
+
+    return true;
+  }
+
+  final void pushScope(int newTop) {
     scopes[stackSize++] = newTop;
   }
 
