diff --git a/CHANGELOG.md b/CHANGELOG.md
index 74b7bda23..11963d8df 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -11,6 +11,7 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 - Widen main method recognition according to [JEP 445](https://openjdk.org/jeps/445). ([#3371](https://github.com/spotbugs/spotbugs/pull/3371))
 - Do not report `US_USELESS_SUPPRESSION_ON_METHOD` on generated methods ([#3350](https://github.com/spotbugs/spotbugs/issues/3350))
 - Rewrite some member in `ResourceValueFrame.java` to Enum ([#2061](https://github.com/spotbugs/spotbugs/issues/2061))
+- Ignore non-interpreted text when looking for `FS_BAD_DATE_FORMAT_FLAG_COMBO` ([#3387](https://github.com/spotbugs/spotbugs/issues/3387))
 
 ## 4.9.3 - 2025-03-14
 ### Added
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/DateFormatStringChecker.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/DateFormatStringChecker.java
index aeceeed0f..b8a3fd42a 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/DateFormatStringChecker.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/DateFormatStringChecker.java
@@ -139,6 +139,8 @@ public class DateFormatStringChecker extends OpcodeStackDetector {
      * @return {@code true} if given string matches any bad combination.
      */
     private boolean runDateFormatRuleVerify(String dateFormat) {
+        String interpretedDateFormat = removeNonInterpretedText(dateFormat);
+
         return Stream.of(
                 // when "h" or "K" flags found, make sure that it ALSO CONTAINS "a" or "B"
                 new Rule(Arrays.asList("a", "B"), null, true, Arrays.asList("h", "K")),
@@ -168,6 +170,25 @@ public class DateFormatStringChecker extends OpcodeStackDetector {
 
                 // year and year-of-era cannot be used together
                 new Rule(Collections.singletonList("u"), null, false, Collections.singletonList("y")),
-                new Rule(Collections.singletonList("y"), null, false, Collections.singletonList("u"))).anyMatch(rule -> rule.verify(dateFormat));
+                new Rule(Collections.singletonList("y"), null, false, Collections.singletonList("u"))).anyMatch(rule -> rule.verify(
+                        interpretedDateFormat));
+    }
+
+    protected String removeNonInterpretedText(String dateFormat) {
+        int length = dateFormat.length();
+        boolean inQuote = false;
+        StringBuilder builder = new StringBuilder();
+
+        for (int i = 0; i < length; i++) {
+            char c = dateFormat.charAt(i);
+
+            if (c == '\'') {
+                inQuote = !inQuote;
+            } else if (!inQuote) {
+                builder.append(c);
+            }
+        }
+
+        return builder.toString();
     }
 }
diff --git a/spotbugsTestCases/src/java/ghIssues/Issue3387.java b/spotbugsTestCases/src/java/ghIssues/Issue3387.java
new file mode 100644
index 000000000..cda2449a7
--- /dev/null
+++ b/spotbugsTestCases/src/java/ghIssues/Issue3387.java
@@ -0,0 +1,14 @@
+package ghIssues;
+
+import java.time.ZoneId;
+import java.time.ZonedDateTime;
+import java.time.format.DateTimeFormatter;
+import java.util.Locale;
+
+public class Issue3387 {
+
+    public String testDateFormat() {
+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("d MMMM yyyy Ã  HH'h'mm", Locale.FRENCH);
+        return ZonedDateTime.now(ZoneId.systemDefault()).format(formatter);
+    }
+}
\ No newline at end of file
