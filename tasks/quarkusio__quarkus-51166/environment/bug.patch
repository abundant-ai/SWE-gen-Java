diff --git a/extensions/arc/deployment/pom.xml b/extensions/arc/deployment/pom.xml
index 55c07286bfc..e4760e55666 100644
--- a/extensions/arc/deployment/pom.xml
+++ b/extensions/arc/deployment/pom.xml
@@ -38,28 +38,24 @@
             <artifactId>arc-processor</artifactId>
         </dependency>
 
-        <!--
-          - The following 2 dependencies must NOT be test-scoped, because test-scoped dependencies
-          - are always loaded by the Runtime CL (not by Base Runtime CL) and so are considered
-          - application archives. All tests using them require a NON-application archive.
-          -->
         <dependency>
             <groupId>io.quarkus</groupId>
-            <artifactId>quarkus-arc-test-supplement</artifactId>
+            <artifactId>quarkus-junit5-internal</artifactId>
+            <scope>test</scope>
         </dependency>
         <dependency>
-            <groupId>io.quarkus</groupId>
-            <artifactId>quarkus-arc-test-supplement-decorator</artifactId>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
         </dependency>
-
         <dependency>
             <groupId>io.quarkus</groupId>
-            <artifactId>quarkus-junit5-internal</artifactId>
+            <artifactId>quarkus-arc-test-supplement</artifactId>
             <scope>test</scope>
         </dependency>
         <dependency>
-            <groupId>org.assertj</groupId>
-            <artifactId>assertj-core</artifactId>
+            <groupId>io.quarkus</groupId>
+            <artifactId>quarkus-arc-test-supplement-decorator</artifactId>
             <scope>test</scope>
         </dependency>
         <!-- Used to test wrong @Singleton detection -->
diff --git a/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/cdi/bcextensions/SynthBeanForExternalClassTest.java b/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/cdi/bcextensions/SynthBeanForExternalClassTest.java
index 8733187e85f..8818280382e 100644
--- a/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/cdi/bcextensions/SynthBeanForExternalClassTest.java
+++ b/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/cdi/bcextensions/SynthBeanForExternalClassTest.java
@@ -51,11 +51,6 @@ public void test() {
         assertTrue(MySyntheticBeanDisposer.disposed);
     }
 
-    @Test
-    public void testNonAppArchive() {
-        assertTrue(SomeClassInExternalLibrary.class.getClassLoader().getName().contains("Quarkus Base Runtime ClassLoader"));
-    }
-
     @ApplicationScoped
     public static class MyBean {
         @Inject
diff --git a/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/cdi/bcextensions/SynthObserverAsIfInExternalClassTest.java b/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/cdi/bcextensions/SynthObserverAsIfInExternalClassTest.java
index 84418521a3a..289dc891252 100644
--- a/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/cdi/bcextensions/SynthObserverAsIfInExternalClassTest.java
+++ b/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/cdi/bcextensions/SynthObserverAsIfInExternalClassTest.java
@@ -48,11 +48,6 @@ public void test() {
         assertTrue(MySyntheticObserver.notified);
     }
 
-    @Test
-    public void testNonAppArchive() {
-        assertTrue(SomeClassInExternalLibrary.class.getClassLoader().getName().contains("Quarkus Base Runtime ClassLoader"));
-    }
-
     @ApplicationScoped
     public static class MyBean {
         @Inject
diff --git a/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/decorator/DecoratorAsBeanDefiningAnnotationTest.java b/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/decorator/DecoratorAsBeanDefiningAnnotationTest.java
index 9d210bb4b15..feb864ba353 100644
--- a/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/decorator/DecoratorAsBeanDefiningAnnotationTest.java
+++ b/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/decorator/DecoratorAsBeanDefiningAnnotationTest.java
@@ -1,7 +1,6 @@
 package io.quarkus.arc.test.decorator;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.util.List;
 
@@ -11,7 +10,6 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
-import io.quarkus.arc.test.supplement.decorator.SomeDecorator;
 import io.quarkus.arc.test.supplement.decorator.SomeInterface;
 import io.quarkus.builder.Version;
 import io.quarkus.maven.dependency.Dependency;
@@ -37,11 +35,6 @@ public void test() {
         assertEquals("Delegated: SomeBean", bean.ping());
     }
 
-    @Test
-    public void testNonAppArchive() {
-        assertTrue(SomeDecorator.class.getClassLoader().getName().contains("Quarkus Base Runtime ClassLoader"));
-    }
-
     @Dependent
     public static class SomeBean implements SomeInterface {
 
diff --git a/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/decorator/DecoratorOfExternalBeanTest.java b/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/decorator/DecoratorOfExternalBeanTest.java
index abd8fe72fdc..8a166fb63c2 100644
--- a/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/decorator/DecoratorOfExternalBeanTest.java
+++ b/extensions/arc/deployment/src/test/java/io/quarkus/arc/test/decorator/DecoratorOfExternalBeanTest.java
@@ -1,28 +1,18 @@
 package io.quarkus.arc.test.decorator;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.util.List;
 
 import jakarta.decorator.Decorator;
 import jakarta.decorator.Delegate;
-import jakarta.enterprise.event.Event;
-import jakarta.enterprise.inject.Instance;
 import jakarta.inject.Inject;
 
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
-import io.quarkus.arc.ClientProxy;
-import io.quarkus.arc.test.supplement.ConsumerOfSomeBeanInExternalLibrary;
-import io.quarkus.arc.test.supplement.ConsumerOfSomeDepBeanInExternalLibrary;
 import io.quarkus.arc.test.supplement.SomeBeanInExternalLibrary;
-import io.quarkus.arc.test.supplement.SomeDepBeanInExternalLibrary;
-import io.quarkus.arc.test.supplement.SomeEventInExternalLibrary;
 import io.quarkus.arc.test.supplement.SomeInterfaceInExternalLibrary;
-import io.quarkus.arc.test.supplement.SomeProducedDependencyInExternalLibrary;
 import io.quarkus.builder.Version;
 import io.quarkus.maven.dependency.Dependency;
 import io.quarkus.test.QuarkusUnitTest;
@@ -40,111 +30,9 @@ public class DecoratorOfExternalBeanTest {
     @Inject
     SomeBeanInExternalLibrary bean;
 
-    @Inject
-    ConsumerOfSomeBeanInExternalLibrary consumer;
-
-    @Inject
-    SomeDepBeanInExternalLibrary depBean;
-
-    @Inject
-    ConsumerOfSomeDepBeanInExternalLibrary depConsumer;
-
-    @Inject
-    Event<SomeEventInExternalLibrary> event;
-
-    @Inject
-    Instance<SomeProducedDependencyInExternalLibrary> instance;
-
     @Test
-    public void testNormalScope() {
+    public void test() {
         assertEquals("Delegated: Hello", bean.hello());
-
-        assertFalse(SomeBeanInExternalLibrary.pinged);
-        assertFalse(SomeBeanInExternalLibrary.observed);
-        assertFalse(SomeBeanInExternalLibrary.produced);
-        assertFalse(SomeBeanInExternalLibrary.disposed);
-
-        assertEquals("pong", consumer.ping());
-
-        assertTrue(SomeBeanInExternalLibrary.pinged);
-        assertFalse(SomeBeanInExternalLibrary.observed);
-        assertFalse(SomeBeanInExternalLibrary.produced);
-        assertFalse(SomeBeanInExternalLibrary.disposed);
-
-        event.fire(new SomeEventInExternalLibrary());
-
-        assertTrue(SomeBeanInExternalLibrary.pinged);
-        assertTrue(SomeBeanInExternalLibrary.observed);
-        assertFalse(SomeBeanInExternalLibrary.produced);
-        assertFalse(SomeBeanInExternalLibrary.disposed);
-
-        SomeProducedDependencyInExternalLibrary dependency = instance.get();
-
-        assertTrue(SomeBeanInExternalLibrary.pinged);
-        assertTrue(SomeBeanInExternalLibrary.observed);
-        assertTrue(SomeBeanInExternalLibrary.produced);
-        assertFalse(SomeBeanInExternalLibrary.disposed);
-
-        assertEquals("Produced: Hello", dependency.hello());
-
-        assertTrue(SomeBeanInExternalLibrary.pinged);
-        assertTrue(SomeBeanInExternalLibrary.observed);
-        assertTrue(SomeBeanInExternalLibrary.produced);
-        assertFalse(SomeBeanInExternalLibrary.disposed);
-
-        instance.destroy(dependency);
-
-        assertTrue(SomeBeanInExternalLibrary.pinged);
-        assertTrue(SomeBeanInExternalLibrary.observed);
-        assertTrue(SomeBeanInExternalLibrary.produced);
-        assertTrue(SomeBeanInExternalLibrary.disposed);
-    }
-
-    @Test
-    public void testPseudoScope() {
-        assertEquals("Delegated: DepHello", depBean.hello());
-
-        assertFalse(SomeDepBeanInExternalLibrary.pinged);
-
-        assertEquals("pong", depConsumer.ping());
-
-        assertTrue(SomeDepBeanInExternalLibrary.pinged);
-    }
-
-    @Test
-    public void testNonAppArchive() {
-        assertTrue(SomeInterfaceInExternalLibrary.class.getClassLoader().getName()
-                .contains("Quarkus Base Runtime ClassLoader"));
-        assertTrue(SomeBeanInExternalLibrary.class.getClassLoader().getName()
-                .contains("Quarkus Base Runtime ClassLoader"));
-        assertTrue(ConsumerOfSomeBeanInExternalLibrary.class.getClassLoader().getName()
-                .contains("Quarkus Base Runtime ClassLoader"));
-        assertTrue(SomeDepBeanInExternalLibrary.class.getClassLoader().getName()
-                .contains("Quarkus Base Runtime ClassLoader"));
-        assertTrue(ConsumerOfSomeDepBeanInExternalLibrary.class.getClassLoader().getName()
-                .contains("Quarkus Base Runtime ClassLoader"));
-        assertTrue(SomeEventInExternalLibrary.class.getClassLoader().getName()
-                .contains("Quarkus Base Runtime ClassLoader"));
-        assertTrue(SomeProducedDependencyInExternalLibrary.class.getClassLoader().getName()
-                .contains("Quarkus Base Runtime ClassLoader"));
-
-        // client proxies are non-app
-        assertTrue(bean.getClass().getSimpleName().endsWith("_ClientProxy"));
-        assertTrue(bean.getClass().getClassLoader().getName().contains("Quarkus Base Runtime ClassLoader"));
-        assertTrue(consumer.getClass().getSimpleName().endsWith("_ClientProxy"));
-        assertTrue(consumer.getClass().getClassLoader().getName().contains("Quarkus Base Runtime ClassLoader"));
-    }
-
-    @Test
-    public void testAppArchive() {
-        assertTrue(MyDecorator.class.getClassLoader().getName().contains("Quarkus Runtime ClassLoader"));
-
-        // decoration subclasses are app
-        SomeBeanInExternalLibrary unwrappedBean = ClientProxy.unwrap(bean);
-        assertTrue(unwrappedBean.getClass().getSimpleName().endsWith("_Subclass"));
-        assertTrue(unwrappedBean.getClass().getClassLoader().getName().contains("Quarkus Runtime ClassLoader"));
-        assertTrue(depBean.getClass().getSimpleName().endsWith("_Subclass"));
-        assertTrue(depBean.getClass().getClassLoader().getName().contains("Quarkus Runtime ClassLoader"));
     }
 
     @Decorator
diff --git a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/ConsumerOfSomeBeanInExternalLibrary.java b/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/ConsumerOfSomeBeanInExternalLibrary.java
deleted file mode 100644
index 921a8979803..00000000000
--- a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/ConsumerOfSomeBeanInExternalLibrary.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package io.quarkus.arc.test.supplement;
-
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.inject.Inject;
-
-@ApplicationScoped
-public class ConsumerOfSomeBeanInExternalLibrary {
-    @Inject
-    SomeBeanInExternalLibrary bean;
-
-    public String ping() {
-        return bean.ping();
-    }
-}
diff --git a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/ConsumerOfSomeDepBeanInExternalLibrary.java b/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/ConsumerOfSomeDepBeanInExternalLibrary.java
deleted file mode 100644
index f6f059695af..00000000000
--- a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/ConsumerOfSomeDepBeanInExternalLibrary.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package io.quarkus.arc.test.supplement;
-
-import jakarta.enterprise.context.Dependent;
-import jakarta.inject.Inject;
-
-@Dependent
-public class ConsumerOfSomeDepBeanInExternalLibrary {
-    @Inject
-    SomeDepBeanInExternalLibrary bean;
-
-    public String ping() {
-        return bean.ping();
-    }
-}
diff --git a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeBeanInExternalLibrary.java b/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeBeanInExternalLibrary.java
index 924ba17b4bd..1e722755fa7 100644
--- a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeBeanInExternalLibrary.java
+++ b/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeBeanInExternalLibrary.java
@@ -1,47 +1,11 @@
 package io.quarkus.arc.test.supplement;
 
-import jakarta.enterprise.context.ApplicationScoped;
 import jakarta.enterprise.context.Dependent;
-import jakarta.enterprise.event.Observes;
-import jakarta.enterprise.inject.Disposes;
-import jakarta.enterprise.inject.Produces;
-import jakarta.inject.Inject;
 
-@ApplicationScoped
+@Dependent
 public class SomeBeanInExternalLibrary implements SomeInterfaceInExternalLibrary {
-    public static boolean pinged;
-    public static boolean observed;
-    public static boolean produced;
-    public static boolean disposed;
-
-    @Inject
-    SomeDependencyInExternalLibrary dependency;
-
     @Override
     public String hello() {
-        return dependency.hello();
-    }
-
-    // methods below are intentionally package-private to verify
-    // behavior in Quarkus dev mode (multiple classloaders)
-
-    String ping() {
-        pinged = true;
-        return "pong";
-    }
-
-    void init(@Observes SomeEventInExternalLibrary event) {
-        observed = true;
-    }
-
-    @Produces
-    @Dependent
-    SomeProducedDependencyInExternalLibrary produce(SomeDependencyInExternalLibrary dependency) {
-        produced = true;
-        return new SomeProducedDependencyInExternalLibrary(dependency);
-    }
-
-    void dispose(@Disposes SomeProducedDependencyInExternalLibrary dependency) {
-        disposed = true;
+        return "Hello";
     }
 }
diff --git a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeDepBeanInExternalLibrary.java b/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeDepBeanInExternalLibrary.java
deleted file mode 100644
index aacd6d50b2e..00000000000
--- a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeDepBeanInExternalLibrary.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package io.quarkus.arc.test.supplement;
-
-import jakarta.enterprise.context.Dependent;
-
-@Dependent
-public class SomeDepBeanInExternalLibrary implements SomeInterfaceInExternalLibrary {
-    public static boolean pinged;
-
-    @Override
-    public String hello() {
-        return "DepHello";
-    }
-
-    // methods below are intentionally package-private to verify
-    // behavior in Quarkus dev mode (multiple classloaders)
-
-    String ping() {
-        pinged = true;
-        return "pong";
-    }
-}
diff --git a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeDependencyInExternalLibrary.java b/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeDependencyInExternalLibrary.java
deleted file mode 100644
index af5b5abe119..00000000000
--- a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeDependencyInExternalLibrary.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package io.quarkus.arc.test.supplement;
-
-import jakarta.enterprise.context.Dependent;
-
-@Dependent
-public class SomeDependencyInExternalLibrary {
-    public String hello() {
-        return "Hello";
-    }
-}
diff --git a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeEventInExternalLibrary.java b/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeEventInExternalLibrary.java
deleted file mode 100644
index 5ac933a3813..00000000000
--- a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeEventInExternalLibrary.java
+++ /dev/null
@@ -1,4 +0,0 @@
-package io.quarkus.arc.test.supplement;
-
-public class SomeEventInExternalLibrary {
-}
diff --git a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeProducedDependencyInExternalLibrary.java b/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeProducedDependencyInExternalLibrary.java
deleted file mode 100644
index a431add59b9..00000000000
--- a/extensions/arc/test-supplement/src/main/java/io/quarkus/arc/test/supplement/SomeProducedDependencyInExternalLibrary.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package io.quarkus.arc.test.supplement;
-
-public class SomeProducedDependencyInExternalLibrary {
-    private final SomeDependencyInExternalLibrary dependency;
-
-    public SomeProducedDependencyInExternalLibrary(SomeDependencyInExternalLibrary dependency) {
-        this.dependency = dependency;
-    }
-
-    public String hello() {
-        return "Produced: " + dependency.hello();
-    }
-}
diff --git a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java
index f6aee2c5683..60ffbd8c88d 100644
--- a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java
+++ b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java
@@ -63,6 +63,8 @@
 import org.jboss.logging.Logger;
 import org.jboss.logmanager.Level;
 
+import com.fasterxml.jackson.databind.Module;
+
 import io.quarkus.agroal.spi.JdbcDataSourceBuildItem;
 import io.quarkus.agroal.spi.JdbcDataSourceSchemaReadyBuildItem;
 import io.quarkus.arc.deployment.BeanContainerBuildItem;
@@ -320,6 +322,19 @@ public ImpliedBlockingPersistenceUnitTypeBuildItem defineTypeOfImpliedPU(
         }
     }
 
+    @BuildStep
+    public void allowJacksonModuleDiscovery(Capabilities capabilities,
+            List<PersistenceUnitDescriptorBuildItem> persistenceUnits,
+            BuildProducer<ServiceProviderBuildItem> serviceProviders) {
+        if (capabilities.isMissing(Capability.JACKSON) || persistenceUnits.isEmpty()) {
+            // We won't be using Hibernate's default FormatMapper relying on Jackson for sure
+            return;
+        }
+        // Hibernate's default FormatMapper relying on Jackson requires
+        // service loading to discover modules in the classpath.
+        serviceProviders.produce(ServiceProviderBuildItem.allProvidersFromClassPath(Module.class.getName()));
+    }
+
     @BuildStep
     @Record(RUNTIME_INIT)
     public void configurationDescriptorBuilding(
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanDeployment.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanDeployment.java
index ca30c30a30b..9e4e58fa266 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanDeployment.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanDeployment.java
@@ -52,9 +52,6 @@
 import io.quarkus.arc.processor.BuildExtension.Key;
 import io.quarkus.arc.processor.Types.TypeClosure;
 import io.quarkus.arc.processor.bcextensions.ExtensionsEntryPoint;
-import io.quarkus.gizmo.ClassTransformer;
-import io.quarkus.gizmo.FieldDescriptor;
-import io.quarkus.gizmo.MethodDescriptor;
 import io.quarkus.gizmo2.Expr;
 
 public class BeanDeployment {
@@ -522,7 +519,6 @@ ValidationContext validate(List<BeanDeploymentValidator> validators,
         // First, validate all beans internally
         validateBeans(errors, bytecodeTransformerConsumer);
         validateInterceptorsAndDecorators(errors, bytecodeTransformerConsumer);
-        validateNonAppBeansWithAppDecorators(errors, bytecodeTransformerConsumer);
         ValidationContextImpl validationContext = new ValidationContextImpl(buildContext);
         for (Throwable error : errors) {
             validationContext.addDeploymentProblem(error);
@@ -1794,97 +1790,6 @@ private void validateBeans(List<Throwable> errors, Consumer<BytecodeTransformer>
         }
     }
 
-    private void validateNonAppBeansWithAppDecorators(List<Throwable> errors,
-            Consumer<BytecodeTransformer> bytecodeTransformer) {
-        for (BeanInfo bean : beans) {
-            boolean isNonAppBeanWithAppDecorators = bean.isClassBean() // only class-based beans can be decorated
-                    && !applicationClassPredicate.test(bean.getBeanClass())
-                    && bean.hasBoundDecoratorMatching(applicationClassPredicate);
-
-            if (!isNonAppBeanWithAppDecorators) {
-                continue;
-            }
-
-            // in case of a non-app bean with app decorators, we only turn the generated `_Bean` and `_Subclass`
-            // classes into app classes, so the only thing we need to transform here are injection points
-            //
-            // we specifically do _not_ turn the generated `_ClientProxy` class into app class,
-            // so method invocations on normal scoped beans work even if the methods are not `public`
-            //
-            // producers, disposers and observers in non-app beans have their own generated classes
-            // which are _non-app_, so there's no cross-classloader access
-
-            Set<AnnotationTarget> nonPublicInjectionPoints = new HashSet<>();
-            for (InjectionPointInfo ip : bean.getAllInjectionPoints()) {
-                AnnotationTarget target = ip.getAnnotationTarget();
-                if (target == null) {
-                    continue;
-                }
-
-                if (target.kind() == AnnotationTarget.Kind.FIELD
-                        && !Modifier.isPublic(target.asField().flags())) {
-                    nonPublicInjectionPoints.add(target);
-                } else if (target.kind() == AnnotationTarget.Kind.METHOD_PARAMETER
-                        && !Modifier.isPublic(target.asMethodParameter().method().flags())) {
-                    nonPublicInjectionPoints.add(target.asMethodParameter().method());
-                }
-            }
-
-            if (nonPublicInjectionPoints.isEmpty()) {
-                continue;
-            }
-
-            Collection<ClassInfo> beanSubclasses = getBeanArchiveIndex().getAllKnownSubclasses(bean.getBeanClass());
-            if (!beanSubclasses.isEmpty()) {
-                StringBuilder error = new StringBuilder();
-                error.append("Non-application bean ")
-                        .append(bean.getBeanClass())
-                        .append(" has bound application decorator(s):");
-                for (DecoratorInfo decorator : bean.getBoundDecorators()) {
-                    DotName decoratorName = decorator.getImplClazz().name();
-                    if (applicationClassPredicate.test(decoratorName)) {
-                        error.append("\n\t- ").append(decoratorName);
-                    }
-                }
-                error.append("\nThis bean has non-public injection point(s):");
-                for (AnnotationTarget ip : nonPublicInjectionPoints) {
-                    if (ip.kind() == AnnotationTarget.Kind.FIELD) {
-                        error.append("\n\t- field `").append(ip.asField().name()).append("`");
-                    } else if (ip.kind() == AnnotationTarget.Kind.METHOD) {
-                        error.append("\n\t- method `").append(ip.asMethod().name()).append("()`");
-                    }
-                }
-                error.append("\nBytecode transformation would be required to make these injection points public,")
-                        .append(" but the bean also has subclasses that could be broken:");
-                for (ClassInfo beanSubclass : beanSubclasses) {
-                    error.append("\n\t- ").append(beanSubclass.name());
-                }
-                error.append("\nThe only possible fix on the application side is removing the decorator(s).");
-                errors.add(new DeploymentException(error.toString()));
-            } else {
-                bytecodeTransformer.accept(new BytecodeTransformer(bean.getBeanClass().toString(), (name, visitor) -> {
-                    ClassTransformer transformer = new ClassTransformer(name);
-
-                    // turn non-`public` injection points into `public`
-                    for (AnnotationTarget ip : nonPublicInjectionPoints) {
-                        if (ip.kind() == AnnotationTarget.Kind.FIELD) {
-                            transformer.modifyField(FieldDescriptor.of(ip.asField()))
-                                    .removeModifiers(Modifier.PRIVATE | Modifier.PROTECTED)
-                                    .addModifiers(Modifier.PUBLIC);
-                        } else if (ip.kind() == AnnotationTarget.Kind.METHOD) {
-                            MethodDescriptor desc = MethodDescriptor.of(ip.asMethod());
-                            transformer.modifyMethod(desc)
-                                    .removeModifiers(Modifier.PRIVATE | Modifier.PROTECTED)
-                                    .addModifiers(Modifier.PUBLIC);
-                        }
-                    }
-
-                    return transformer.applyTo(visitor);
-                }));
-            }
-        }
-    }
-
     private void findNamespaces(BeanInfo bean, Set<String> namespaces) {
         if (!strictCompatibility) {
             return;
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanGenerator.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanGenerator.java
index 61a1c3351ba..18c4999c9f3 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanGenerator.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanGenerator.java
@@ -222,7 +222,7 @@ Collection<Resource> generate(BeanInfo bean) {
 
         boolean isApplicationClass = applicationClassPredicate.test(clazz.name())
                 || bean.isForceApplicationClass()
-                || bean.hasBoundDecoratorMatching(applicationClassPredicate);
+                || bean.hasBoundDecoratorWhichIsApplicationClass(applicationClassPredicate);
         ResourceClassOutput classOutput = new ResourceClassOutput(isApplicationClass,
                 name -> name.equals(generatedName) ? SpecialType.BEAN : null, generateSources);
 
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanInfo.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanInfo.java
index b46b7c396cd..81e900bb2cd 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanInfo.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/BeanInfo.java
@@ -415,8 +415,10 @@ Map<MethodDesc, DecoratorMethod> getNextDecorators(DecoratorInfo decorator) {
                     break;
                 }
             }
-            if (index != -1 && index != (decoratorMethods.size() - 1)) {
-                next.put(methodDescOf(entry.getKey()), decoratorMethods.get(index + 1));
+            if (index != -1) {
+                if (index != (decoratorMethods.size() - 1)) {
+                    next.put(methodDescOf(entry.getKey()), decoratorMethods.get(index + 1));
+                }
             }
         }
         return next;
@@ -523,9 +525,9 @@ public List<DecoratorInfo> getBoundDecorators() {
         return bound;
     }
 
-    boolean hasBoundDecoratorMatching(Predicate<DotName> predicate) {
+    boolean hasBoundDecoratorWhichIsApplicationClass(Predicate<DotName> isApplicationClass) {
         for (DecoratorInfo decorator : getBoundDecorators()) {
-            if (predicate.test(decorator.getImplClazz().name())) {
+            if (isApplicationClass.test(decorator.getImplClazz().name())) {
                 return true;
             }
         }
@@ -839,33 +841,36 @@ private void addDecoratedMethods(Map<MethodKey, DecorationInfo> decoratedMethods
     }
 
     private List<DecoratorMethod> findMatchingDecorators(MethodInfo method, List<DecoratorInfo> decorators) {
+        List<Type> methodParams = method.parameterTypes();
         List<DecoratorMethod> matching = new ArrayList<>(decorators.size());
-        IndexView index = beanDeployment.getBeanArchiveIndex();
-        outermost: for (DecoratorInfo decorator : decorators) {
+        for (DecoratorInfo decorator : decorators) {
             for (Type decoratedType : decorator.getDecoratedTypes()) {
-                ClassInfo decoratedInterface = index.getClassByName(decoratedType.name());
-                if (decoratedInterface == null) {
-                    throw new DefinitionException("Decorated interface " + decoratedType.name() + " not found in the index");
+                ClassInfo decoratedTypeClass = decorator.getDeployment().getBeanArchiveIndex()
+                        .getClassByName(decoratedType.name());
+                if (decoratedTypeClass == null) {
+                    throw new DefinitionException(
+                            "The class of the decorated type " + decoratedType + " was not found in the index");
                 }
 
-                Map<String, Type> resolvedTypeParameters = Types.resolveDecoratedTypeParams(decoratedInterface, decorator);
+                Map<String, Type> resolvedTypeParameters = Types.resolveDecoratedTypeParams(decoratedTypeClass,
+                        decorator);
 
-                // it's enough to look at methods declared directly on the decorated interface,
-                // because its superinterfaces are present in the set of decorated types
-                for (MethodInfo decoratedMethod : decoratedInterface.methods()) {
+                for (MethodInfo decoratedMethod : decoratedTypeClass.methods()) {
                     if (!method.name().equals(decoratedMethod.name())) {
                         continue;
                     }
-                    if (method.parametersCount() != decoratedMethod.parametersCount()) {
+                    List<Type> decoratedMethodParams = decoratedMethod.parameterTypes();
+                    if (methodParams.size() != decoratedMethodParams.size()) {
                         continue;
                     }
-
                     // Match the resolved parameter types
                     boolean matches = true;
-                    List<Type> decoratedMethodParams = Types.getResolvedParameters(decoratedInterface, resolvedTypeParameters,
-                            decoratedMethod, index);
-                    List<Type> methodParams = Types.getResolvedParameters(decoratedInterface, resolvedTypeParameters,
-                            method, index);
+                    decoratedMethodParams = Types.getResolvedParameters(decoratedTypeClass, resolvedTypeParameters,
+                            decoratedMethod,
+                            beanDeployment.getBeanArchiveIndex());
+                    methodParams = Types.getResolvedParameters(decoratedTypeClass, resolvedTypeParameters,
+                            method,
+                            beanDeployment.getBeanArchiveIndex());
                     for (int i = 0; i < methodParams.size(); i++) {
                         BeanResolver resolver = beanDeployment.getDelegateInjectionPointResolver();
                         Type decoratedParam = decoratedMethodParams.get(i);
@@ -881,12 +886,6 @@ private List<DecoratorMethod> findMatchingDecorators(MethodInfo method, List<Dec
                     }
                     if (matches) {
                         matching.add(new DecoratorMethod(decorator, decoratedMethod));
-                        // It is possible that multiple methods from one decorator match, in case multiple decorated
-                        // types of the decorator declare the same method. It doesn't matter which one we remember,
-                        // because all decorated methods (public methods on decorated types, which are all interfaces)
-                        // are virtual and are invoked as such and virtual invocation has consistent semantics
-                        // regardless of which exact method declaration is named by the invoked method descriptor.
-                        continue outermost;
                     }
                 }
             }
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/ClientProxyGenerator.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/ClientProxyGenerator.java
index 96e7fec1ce2..40a8a7fdfcc 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/ClientProxyGenerator.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/ClientProxyGenerator.java
@@ -105,7 +105,8 @@ Collection<Resource> generate(BeanInfo bean, String beanClassName,
             return Collections.emptyList();
         }
 
-        boolean isApplicationClass = applicationClassPredicate.test(getApplicationClassTestName(bean));
+        boolean isApplicationClass = applicationClassPredicate.test(getApplicationClassTestName(bean))
+                || bean.hasBoundDecoratorWhichIsApplicationClass(applicationClassPredicate);
         ResourceClassOutput classOutput = new ResourceClassOutput(isApplicationClass,
                 name -> name.equals(generatedName) ? SpecialType.CLIENT_PROXY : null, generateSources);
 
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/DecoratorGenerator.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/DecoratorGenerator.java
index 1ce93a794dd..057419e1d4e 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/DecoratorGenerator.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/DecoratorGenerator.java
@@ -6,12 +6,9 @@
 
 import java.lang.constant.ClassDesc;
 import java.lang.constant.MethodTypeDesc;
-import java.lang.reflect.Modifier;
-import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
@@ -30,6 +27,7 @@
 import org.jboss.jandex.MethodInfo;
 import org.jboss.jandex.MethodParameterInfo;
 import org.jboss.jandex.Type;
+import org.jboss.jandex.TypeVariable;
 
 import io.quarkus.arc.InjectableDecorator;
 import io.quarkus.arc.processor.BeanProcessor.PrivateMembersCollector;
@@ -257,51 +255,21 @@ private String generateAbstractDecoratorImplementation(Gizmo gizmo, String baseN
                 });
             });
 
-            // remember all implemented (not `abstract`) methods that are either declared on the decorator class
-            // or inherited from superclasses and superinterfaces
-            // since decorated types are interfaces, the implemented methods must be `public`, otherwise
-            // they wouldn't be inherited
-            // we later use it to figure out if a decorated method is implemented by the decorator,
-            // so order does not matter
-            List<MethodInfo> decoratorMethods = new ArrayList<>();
-            Deque<ClassInfo> worklist = new ArrayDeque<>();
-            Set<DotName> seen = new HashSet<>();
-            worklist.add(decoratorClass);
-            while (!worklist.isEmpty()) {
-                ClassInfo clazz = worklist.poll();
-                if (!seen.add(clazz.name())) {
-                    continue;
-                }
-
-                for (MethodInfo decoratorMethod : clazz.methods()) {
-                    if (!decoratorMethod.isAbstract() && Modifier.isPublic(decoratorMethod.flags())) {
-                        decoratorMethods.add(decoratorMethod);
-                    }
-                }
-
-                if (!clazz.isInterface() && clazz.superName() != null) {
-                    worklist.add(index.getClassByName(clazz.superName()));
-                }
-                for (DotName iface : clazz.interfaceNames()) {
-                    worklist.add(index.getClassByName(iface));
-                }
-            }
-
             // Find non-decorated methods from all decorated types
             Set<MethodDesc> abstractMethods = new HashSet<>();
             Map<MethodDesc, MethodDesc> bridgeMethods = new HashMap<>();
             for (Type decoratedType : decorator.getDecoratedTypes()) {
-                ClassInfo decoratedInterface = index.getClassByName(decoratedType.name());
-                if (decoratedInterface == null) {
+                ClassInfo decoratedTypeClass = index.getClassByName(decoratedType.name());
+                if (decoratedTypeClass == null) {
                     throw new IllegalStateException("Decorated type not found in the bean archive index: " + decoratedType);
                 }
 
                 // A decorated type can declare type parameters
                 // For example Converter<String> should result in a T -> String mapping
-                boolean isDecoratedInterfaceGeneric = !decoratedInterface.typeParameters().isEmpty();
-                Map<String, Type> resolvedTypeParameters = Types.resolveDecoratedTypeParams(decoratedInterface, decorator);
+                List<TypeVariable> typeParameters = decoratedTypeClass.typeParameters();
+                Map<String, Type> resolvedTypeParameters = Types.resolveDecoratedTypeParams(decoratedTypeClass, decorator);
 
-                for (MethodInfo method : decoratedInterface.methods()) {
+                for (MethodInfo method : decoratedTypeClass.methods()) {
                     if (Methods.skipForDelegateSubclass(method)) {
                         continue;
                     }
@@ -310,9 +278,9 @@ private String generateAbstractDecoratorImplementation(Gizmo gizmo, String baseN
                     // Create a resolved descriptor variant if a param contains a type variable
                     // E.g. ping(T) -> ping(String)
                     MethodDesc resolvedMethodDesc;
-                    if (isDecoratedInterfaceGeneric && (Methods.containsTypeVariableParameter(method)
+                    if (!typeParameters.isEmpty() && (Methods.containsTypeVariableParameter(method)
                             || Types.containsTypeVariable(method.returnType()))) {
-                        List<Type> paramTypes = Types.getResolvedParameters(decoratedInterface, resolvedTypeParameters,
+                        List<Type> paramTypes = Types.getResolvedParameters(decoratedTypeClass, resolvedTypeParameters,
                                 method, index);
                         Type returnType = Types.resolveTypeParam(method.returnType(), resolvedTypeParameters, index);
                         ClassDesc[] paramTypesArray = new ClassDesc[paramTypes.size()];
@@ -326,7 +294,7 @@ private String generateAbstractDecoratorImplementation(Gizmo gizmo, String baseN
                     }
 
                     boolean include = true;
-                    for (MethodInfo decoratorMethod : decoratorMethods) {
+                    for (MethodInfo decoratorMethod : decoratorClass.methods()) {
                         if (decoratorMethod.isConstructor() || decoratorMethod.isStaticInitializer()) {
                             // we cannot build a `MethodDesc` for constructors and static initializers
                             // (`methodDescOf()` below would throw) and they cannot be decorated anyway
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Decorators.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Decorators.java
index 5dd691f766a..5571482a0c8 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Decorators.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Decorators.java
@@ -5,6 +5,7 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashSet;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
 
@@ -38,7 +39,7 @@ static DecoratorInfo createDecorator(ClassInfo decoratorClass, BeanDeployment be
             InjectionPointModifier transformer) {
 
         // Find the delegate injection point
-        List<InjectionPointInfo> delegateInjectionPoints = new ArrayList<>();
+        List<InjectionPointInfo> delegateInjectionPoints = new LinkedList<>();
         List<Injection> injections = Injection.forBean(decoratorClass, null, beanDeployment, transformer,
                 Injection.BeanType.DECORATOR);
         for (Injection injection : injections) {
@@ -117,10 +118,6 @@ static DecoratorInfo createDecorator(ClassInfo decoratorClass, BeanDeployment be
         }
 
         if (Modifier.isAbstract(decoratorClass.flags())) {
-            // TODO this check is not precise: we check that decorators do not declare _any_ abstract methods,
-            //  but the spec says that decorators may not declare abstract methods that do not belong
-            //  to a decorated type
-            //  also, we only check methods declared on the decorator class itself, not inherited methods
             List<MethodInfo> abstractMethods = new ArrayList<>();
             for (MethodInfo method : decoratorClass.methods()) {
                 if (Modifier.isAbstract(method.flags())) {
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/SubclassGenerator.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/SubclassGenerator.java
index c733e79f1df..5fde9a710d2 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/SubclassGenerator.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/SubclassGenerator.java
@@ -110,7 +110,7 @@ Collection<Resource> generate(BeanInfo bean, String beanClassName) {
         }
 
         boolean isApplicationClass = applicationClassPredicate.test(bean.getBeanClass())
-                || bean.hasBoundDecoratorMatching(applicationClassPredicate);
+                || bean.hasBoundDecoratorWhichIsApplicationClass(applicationClassPredicate);
         ResourceClassOutput classOutput = new ResourceClassOutput(isApplicationClass,
                 name -> name.equals(generatedName) ? SpecialType.SUBCLASS : null,
                 generateSources);
@@ -592,9 +592,16 @@ private void processDecorator(Gizmo gizmo, ClassCreator subclass,
         // First generate the delegate subclass
         // An instance of this subclass is injected in the delegate injection point of a decorator instance
         ClassInfo decoratorClass = decorator.getTarget().get().asClass();
+        String baseName;
+        if (decoratorClass.enclosingClass() != null) {
+            baseName = decoratorClass.enclosingClass().withoutPackagePrefix() + UNDERSCORE
+                    + decoratorClass.name().withoutPackagePrefix();
+        } else {
+            baseName = decoratorClass.name().withoutPackagePrefix();
+        }
         // Name: AlphaDecorator_FooBeanId_Delegate_Subclass
         String generatedName = generatedName(providerType.name(),
-                decoratorClass.name().withoutPackagePrefix() + UNDERSCORE + bean.getIdentifier() + UNDERSCORE + "Delegate");
+                baseName + UNDERSCORE + bean.getIdentifier() + UNDERSCORE + "Delegate");
 
         Set<MethodInfo> decoratedMethods = bean.getDecoratedMethods(decorator);
         Set<MethodDesc> decoratedMethodDescriptors = new HashSet<>(decoratedMethods.size());
@@ -806,7 +813,7 @@ && isDecorated(decoratedMethodDescriptors, methodDescriptor, resolvedMethodDesc,
         for (DecoratorInfo decoratorParameter : decoratorParameters) {
             LocalVar decoratorVar = decoratorToLocalVar.get(decoratorParameter.getIdentifier());
             if (decoratorVar == null) {
-                throw new IllegalStateException("Unknown next " + decoratorParameter + " when generating " + generatedName);
+                throw new IllegalStateException("Decorator var must not be null");
             }
             params[paramIdx] = decoratorVar;
             paramIdx++;
diff --git a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Types.java b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Types.java
index ba20a943058..52831583030 100644
--- a/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Types.java
+++ b/independent-projects/arc/processor/src/main/java/io/quarkus/arc/processor/Types.java
@@ -493,10 +493,10 @@ static Set<Type> getClassUnrestrictedTypeClosure(ClassInfo classInfo, BeanDeploy
         return types;
     }
 
-    static Map<String, Type> resolveDecoratedTypeParams(ClassInfo decoratedInterface, DecoratorInfo decorator) {
+    static Map<String, Type> resolveDecoratedTypeParams(ClassInfo decoratedTypeClass, DecoratorInfo decorator) {
         // A decorated type can declare type parameters
         // For example Converter<String> should result in a T -> String mapping
-        List<TypeVariable> typeParameters = decoratedInterface.typeParameters();
+        List<TypeVariable> typeParameters = decoratedTypeClass.typeParameters();
         Map<String, org.jboss.jandex.Type> resolvedTypeParameters = Collections.emptyMap();
         if (!typeParameters.isEmpty()) {
             resolvedTypeParameters = new HashMap<>();
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/defaultmethod/DecoratorDefaultMethodDirectlyImplementedTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/DecoratorDefaultMethodTest.java
similarity index 68%
rename from independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/defaultmethod/DecoratorDefaultMethodDirectlyImplementedTest.java
rename to independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/DecoratorDefaultMethodTest.java
index 5ab11d61b2c..d92844ef90d 100644
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/defaultmethod/DecoratorDefaultMethodDirectlyImplementedTest.java
+++ b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/DecoratorDefaultMethodTest.java
@@ -1,4 +1,4 @@
-package io.quarkus.arc.test.decorators.defaultmethod;
+package io.quarkus.arc.test.decorators;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
@@ -17,37 +17,38 @@
 import io.quarkus.arc.Arc;
 import io.quarkus.arc.test.ArcTestContainer;
 
-public class DecoratorDefaultMethodDirectlyImplementedTest {
+public class DecoratorDefaultMethodTest {
+
     @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Converter.class, ConverterImpl.class,
+    public ArcTestContainer container = new ArcTestContainer(Converter.class, ToLengthConverter.class,
             ConverterDecorator.class);
 
+    @SuppressWarnings("serial")
     @Test
     public void testDecoration() {
         Converter<String> converter = Arc.container().instance(new TypeLiteral<Converter<String>>() {
         }).get();
-        assertEquals(6, converter.convertToInt("HoLa!"));
+        assertEquals(5, converter.convert("Hola!"));
         assertTrue(converter.convertToBoolean("echo"));
-        assertFalse(converter.convertToBoolean("ECHO"));
+        assertFalse(converter.convertToBoolean("echos"));
     }
 
     interface Converter<T> {
-        // overridden by both `ConverterImpl` and `ConverterDecorator`
-        default int convertToInt(T value) {
+
+        default int convert(T value) {
             return Integer.MAX_VALUE;
         }
 
-        // overridden by `ConverterDecorator`,
-        // not overridden by `ConverterImpl`, so inherited
+        // this method is intentionally not overriden by ToLengthConverter
         default boolean convertToBoolean(T value) {
             return false;
         }
     }
 
     @ApplicationScoped
-    static class ConverterImpl implements Converter<String> {
+    static class ToLengthConverter implements Converter<String> {
         @Override
-        public int convertToInt(String value) {
+        public int convert(String value) {
             return value.length();
         }
     }
@@ -55,18 +56,21 @@ public int convertToInt(String value) {
     @Priority(1)
     @Decorator
     static class ConverterDecorator implements Converter<String> {
+
         @Inject
         @Delegate
         Converter<String> delegate;
 
         @Override
-        public int convertToInt(String value) {
-            return 1 + delegate.convertToInt(value);
+        public int convert(String value) {
+            return delegate.convert(value);
         }
 
         @Override
         public boolean convertToBoolean(String value) {
             return value.equals("echo");
         }
+
     }
+
 }
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsIndependentAndDefaultTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsIndependentAndDefaultTest.java
deleted file mode 100644
index 6fd5fa1596e..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsIndependentAndDefaultTest.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package io.quarkus.arc.test.decorators;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.Arc;
-import io.quarkus.arc.test.ArcTestContainer;
-
-public class MultipleSameDecoratedMethodsIndependentAndDefaultTest {
-    @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Foo.class, Bar.class, Alpha.class, Bravo.class,
-            AlphaDecorator.class);
-
-    @Test
-    public void testDecoration() {
-        Alpha alpha = Arc.container().instance(Alpha.class).get();
-        Bravo bravo = Arc.container().instance(Bravo.class).get();
-
-        assertEquals(2, alpha.quux()); // decorated
-        assertEquals(2, bravo.quux()); // not decorated
-    }
-
-    interface Foo {
-        default int quux() {
-            return 3;
-        }
-    }
-
-    interface Bar {
-        default int quux() {
-            return 4;
-        }
-    }
-
-    @ApplicationScoped
-    static class Alpha implements Foo, Bar {
-        @Override
-        public int quux() {
-            return 1;
-        }
-    }
-
-    @ApplicationScoped
-    static class Bravo implements Foo, Bar {
-        @Override
-        public int quux() {
-            return 2;
-        }
-    }
-
-    @Priority(1)
-    @Decorator
-    static class AlphaDecorator implements Foo, Bar {
-        @Inject
-        @Delegate
-        Alpha delegate;
-
-        @Override
-        public int quux() {
-            return 1 + delegate.quux();
-        }
-    }
-}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsIndependentTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsIndependentTest.java
deleted file mode 100644
index 2fe514a2ce9..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsIndependentTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package io.quarkus.arc.test.decorators;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.Arc;
-import io.quarkus.arc.test.ArcTestContainer;
-
-public class MultipleSameDecoratedMethodsIndependentTest {
-    @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Foo.class, Bar.class, Alpha.class, Bravo.class,
-            AlphaDecorator.class);
-
-    @Test
-    public void testDecoration() {
-        Alpha alpha = Arc.container().instance(Alpha.class).get();
-        Bravo bravo = Arc.container().instance(Bravo.class).get();
-
-        assertEquals(2, alpha.quux()); // decorated
-        assertEquals(2, bravo.quux()); // not decorated
-    }
-
-    interface Foo {
-        int quux();
-    }
-
-    interface Bar {
-        int quux();
-    }
-
-    @ApplicationScoped
-    static class Alpha implements Foo, Bar {
-        @Override
-        public int quux() {
-            return 1;
-        }
-    }
-
-    @ApplicationScoped
-    static class Bravo implements Foo, Bar {
-        @Override
-        public int quux() {
-            return 2;
-        }
-    }
-
-    @Priority(1)
-    @Decorator
-    static class AlphaDecorator implements Foo, Bar {
-        @Inject
-        @Delegate
-        Alpha delegate;
-
-        @Override
-        public int quux() {
-            return 1 + delegate.quux();
-        }
-    }
-}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsOverridenAndBridgeTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsOverridenAndBridgeTest.java
deleted file mode 100644
index 1760c896af1..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsOverridenAndBridgeTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package io.quarkus.arc.test.decorators;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.Arc;
-import io.quarkus.arc.test.ArcTestContainer;
-
-public class MultipleSameDecoratedMethodsOverridenAndBridgeTest {
-    @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Alpha.class, Bravo.class, Sorted.class, SortedDecorator.class);
-
-    @Test
-    public void testDecoration() {
-        Alpha alpha = Arc.container().instance(Alpha.class).get();
-        Bravo bravo = Arc.container().instance(Bravo.class).get();
-
-        // The decorator reverses priorities
-        assertEquals(1, alpha.compareTo(bravo));
-    }
-
-    interface Sorted extends Comparable<Sorted> {
-        int priority();
-
-        @Override
-        default int compareTo(Sorted other) {
-            return Integer.compare(priority(), other.priority());
-        }
-    }
-
-    @ApplicationScoped
-    static class Alpha implements Sorted {
-        @Override
-        public int priority() {
-            return 1;
-        }
-    }
-
-    @ApplicationScoped
-    static class Bravo implements Sorted {
-        @Override
-        public int priority() {
-            return 2;
-        }
-    }
-
-    @Priority(1)
-    @Decorator
-    static class SortedDecorator implements Sorted {
-        @Inject
-        @Delegate
-        Sorted delegate;
-
-        @Override
-        public int compareTo(Sorted other) {
-            return Integer.compare(other.priority(), delegate.priority());
-        }
-
-        @Override
-        public int priority() {
-            return delegate.priority();
-        }
-    }
-}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsOverridenAndDefaultTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsOverridenAndDefaultTest.java
deleted file mode 100644
index e83dd364382..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsOverridenAndDefaultTest.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package io.quarkus.arc.test.decorators;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.Arc;
-import io.quarkus.arc.test.ArcTestContainer;
-
-public class MultipleSameDecoratedMethodsOverridenAndDefaultTest {
-    @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Foo.class, Bar.class, Alpha.class, Bravo.class,
-            BarDecorator.class);
-
-    @Test
-    public void testDecoration() {
-        Alpha alpha = Arc.container().instance(Alpha.class).get();
-        Bravo bravo = Arc.container().instance(Bravo.class).get();
-
-        assertEquals(2, alpha.quux());
-        assertEquals(3, bravo.quux());
-    }
-
-    interface Foo {
-        int quux();
-    }
-
-    interface Bar extends Foo {
-        default int quux() {
-            return 3;
-        }
-    }
-
-    @ApplicationScoped
-    static class Alpha implements Bar {
-        @Override
-        public int quux() {
-            return 1;
-        }
-    }
-
-    @ApplicationScoped
-    static class Bravo implements Bar {
-        @Override
-        public int quux() {
-            return 2;
-        }
-    }
-
-    @Priority(1)
-    @Decorator
-    static class BarDecorator implements Bar {
-        @Inject
-        @Delegate
-        Bar delegate;
-
-        @Override
-        public int quux() {
-            return 1 + delegate.quux();
-        }
-    }
-}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsOverridenTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsOverridenTest.java
deleted file mode 100644
index db96fc278b0..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/MultipleSameDecoratedMethodsOverridenTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package io.quarkus.arc.test.decorators;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.Arc;
-import io.quarkus.arc.test.ArcTestContainer;
-
-public class MultipleSameDecoratedMethodsOverridenTest {
-    @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Foo.class, Bar.class, Alpha.class, Bravo.class,
-            BarDecorator.class);
-
-    @Test
-    public void testDecoration() {
-        Alpha alpha = Arc.container().instance(Alpha.class).get();
-        Bravo bravo = Arc.container().instance(Bravo.class).get();
-
-        assertEquals(2, alpha.quux());
-        assertEquals(3, bravo.quux());
-    }
-
-    interface Foo {
-        int quux();
-    }
-
-    interface Bar extends Foo {
-        int quux();
-    }
-
-    @ApplicationScoped
-    static class Alpha implements Bar {
-        @Override
-        public int quux() {
-            return 1;
-        }
-    }
-
-    @ApplicationScoped
-    static class Bravo implements Bar {
-        @Override
-        public int quux() {
-            return 2;
-        }
-    }
-
-    @Priority(1)
-    @Decorator
-    static class BarDecorator implements Bar {
-        @Inject
-        @Delegate
-        Bar delegate;
-
-        @Override
-        public int quux() {
-            return 1 + delegate.quux();
-        }
-    }
-}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/abstractimpl/AbstractDecoratorDefaultMethodTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/abstractimpl/AbstractDecoratorDefaultMethodTest.java
deleted file mode 100644
index cb23084e70c..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/abstractimpl/AbstractDecoratorDefaultMethodTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package io.quarkus.arc.test.decorators.abstractimpl;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.enterprise.util.TypeLiteral;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.Arc;
-import io.quarkus.arc.test.ArcTestContainer;
-
-public class AbstractDecoratorDefaultMethodTest {
-    @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Converter.class, ConverterImpl.class,
-            ConverterDecorator.class);
-
-    @Test
-    public void testDecoration() {
-        Converter<String> converter = Arc.container().instance(new TypeLiteral<Converter<String>>() {
-        }).get();
-        assertEquals(0, converter.convertToInt("HoLa!"));
-        assertEquals("hola!", converter.convertToString("HoLa!"));
-    }
-
-    interface Converter<T> {
-        // not overridden by `ConverterDecorator`, so inherited
-        default int convertToInt(T value) {
-            return 0;
-        }
-
-        // not implemented by abstract `ConverterDecorator`, so forwarded to the contextual instance
-        String convertToString(T value);
-    }
-
-    @ApplicationScoped
-    static class ConverterImpl implements Converter<String> {
-        @Override
-        public int convertToInt(String value) {
-            return value.length();
-        }
-
-        @Override
-        public String convertToString(String value) {
-            return value.toLowerCase();
-        }
-    }
-
-    @Decorator
-    @Priority(1)
-    static abstract class ConverterDecorator implements Converter<String> {
-        @Inject
-        @Delegate
-        Converter<String> delegate;
-    }
-}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/abstractimpl/AbstractDecoratorNotInheritingNonPublicMethodTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/abstractimpl/AbstractDecoratorNotInheritingNonPublicMethodTest.java
deleted file mode 100644
index a54fbb0a639..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/abstractimpl/AbstractDecoratorNotInheritingNonPublicMethodTest.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package io.quarkus.arc.test.decorators.abstractimpl;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.Arc;
-import io.quarkus.arc.test.ArcTestContainer;
-
-/**
- * Decorated types are interfaces, and interfaces may only have {@code public} and {@code private} methods.
- * Since {@code private} methods are never inherited, all decorated methods that decorators may inherit
- * from superclasses and superinterfaces must be {@code public}, otherwise the code wouldn't compile.
- * This test verifies that the decorator doesn't inherit a {@code private} method from its superclass.
- * Similar test with package-private in the same package and {@code protected} method wouldn't compile.
- * We could add a test with package-private method in a different package, but there's no point.
- */
-public class AbstractDecoratorNotInheritingNonPublicMethodTest {
-    @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Converter.class, ConverterImpl.class,
-            AbstractConverterDecorator.class, ConverterDecorator.class);
-
-    @Test
-    public void testDecoration() {
-        Converter converter = Arc.container().instance(Converter.class).get();
-        assertEquals(0, converter.convertToInt("HoLa!"));
-        assertEquals("hola!", converter.convertToString("HoLa!"));
-    }
-
-    interface Converter {
-        // not overridden by `ConverterDecorator`, so inherited
-        default int convertToInt(String value) {
-            return 0;
-        }
-
-        // not implemented by abstract `ConverterDecorator`, so forwarded to the contextual instance
-        String convertToString(String value);
-    }
-
-    @ApplicationScoped
-    static class ConverterImpl implements Converter {
-        @Override
-        public int convertToInt(String value) {
-            return value.length();
-        }
-
-        @Override
-        public String convertToString(String value) {
-            return value.toLowerCase();
-        }
-    }
-
-    static class AbstractConverterDecorator {
-        private String convertToString(String value) {
-            return "PRIVATE";
-        }
-    }
-
-    @Decorator
-    @Priority(1)
-    static abstract class ConverterDecorator extends AbstractConverterDecorator implements Converter {
-        @Inject
-        @Delegate
-        Converter delegate;
-    }
-}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/defaultmethod/DecoratorDefaultMethodInheritedFromSuperclassTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/defaultmethod/DecoratorDefaultMethodInheritedFromSuperclassTest.java
deleted file mode 100644
index f92f259703a..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/defaultmethod/DecoratorDefaultMethodInheritedFromSuperclassTest.java
+++ /dev/null
@@ -1,87 +0,0 @@
-package io.quarkus.arc.test.decorators.defaultmethod;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.enterprise.util.TypeLiteral;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.Arc;
-import io.quarkus.arc.test.ArcTestContainer;
-
-public class DecoratorDefaultMethodInheritedFromSuperclassTest {
-    @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Converter.class, ConverterImpl.class,
-            AbstractConverterDecorator.class, ConverterDecorator.class);
-
-    @Test
-    public void testDecoration() {
-        Converter<String> converter = Arc.container().instance(new TypeLiteral<Converter<String>>() {
-        }).get();
-        assertEquals(6, converter.convertToInt("HoLa!"));
-        assertTrue(converter.convertToBoolean("echo"));
-        assertFalse(converter.convertToBoolean("ECHO"));
-        assertEquals("HOLA!", converter.convertToString("HoLa!"));
-    }
-
-    interface Converter<T> {
-        // overridden by both `ConverterImpl` and `ConverterDecorator`
-        default int convertToInt(T value) {
-            return Integer.MAX_VALUE;
-        }
-
-        // not overridden by `ConverterImpl`, so it's inherited
-        default boolean convertToBoolean(T value) {
-            return false;
-        }
-
-        // not implemented by `ConverterDecorator`, but implemented by `AbstractConverterDecorator`, so inherited
-        String convertToString(T value);
-    }
-
-    @ApplicationScoped
-    static class ConverterImpl implements Converter<String> {
-        @Override
-        public int convertToInt(String value) {
-            return value.length();
-        }
-
-        @Override
-        public String convertToString(String value) {
-            return value.toLowerCase();
-        }
-    }
-
-    static abstract class AbstractConverterDecorator implements Converter<String> {
-        @Override
-        public String convertToString(String value) {
-            return value.toUpperCase();
-        }
-    }
-
-    @Priority(1)
-    @Decorator
-    static class ConverterDecorator extends AbstractConverterDecorator {
-        @Inject
-        @Delegate
-        Converter<String> delegate;
-
-        @Override
-        public int convertToInt(String value) {
-            return 1 + delegate.convertToInt(value);
-        }
-
-        @Override
-        public boolean convertToBoolean(String value) {
-            return value.equals("echo");
-        }
-    }
-}
diff --git a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/defaultmethod/DecoratorDefaultMethodInheritedFromSuperinterfaceTest.java b/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/defaultmethod/DecoratorDefaultMethodInheritedFromSuperinterfaceTest.java
deleted file mode 100644
index a81ea06dacc..00000000000
--- a/independent-projects/arc/tests/src/test/java/io/quarkus/arc/test/decorators/defaultmethod/DecoratorDefaultMethodInheritedFromSuperinterfaceTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-package io.quarkus.arc.test.decorators.defaultmethod;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-
-import jakarta.annotation.Priority;
-import jakarta.decorator.Decorator;
-import jakarta.decorator.Delegate;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.enterprise.util.TypeLiteral;
-import jakarta.inject.Inject;
-
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.RegisterExtension;
-
-import io.quarkus.arc.Arc;
-import io.quarkus.arc.test.ArcTestContainer;
-
-public class DecoratorDefaultMethodInheritedFromSuperinterfaceTest {
-    @RegisterExtension
-    public ArcTestContainer container = new ArcTestContainer(Converter.class, ConverterImpl.class,
-            ConverterDecorator.class);
-
-    @Test
-    public void testDecoration() {
-        Converter<String> converter = Arc.container().instance(new TypeLiteral<Converter<String>>() {
-        }).get();
-        assertEquals(6, converter.convertToInt("HoLa!"));
-        assertTrue(converter.convertToBoolean("echo"));
-        assertFalse(converter.convertToBoolean("ECHO"));
-        assertEquals("HOLA!", converter.convertToString("HoLa!"));
-    }
-
-    interface Converter<T> {
-        // overridden by both `ConverterImpl` and `ConverterDecorator`
-        default int convertToInt(T value) {
-            return Integer.MAX_VALUE;
-        }
-
-        // not overridden by `ConverterImpl`, so inherited
-        default boolean convertToBoolean(T value) {
-            return false;
-        }
-
-        // not overridden by `ConverterDecorator`, so inherited
-        default String convertToString(T value) {
-            return value.toString().toUpperCase();
-        }
-    }
-
-    @ApplicationScoped
-    static class ConverterImpl implements Converter<String> {
-        @Override
-        public int convertToInt(String value) {
-            return value.length();
-        }
-
-        @Override
-        public String convertToString(String value) {
-            return value.toLowerCase();
-        }
-    }
-
-    @Priority(1)
-    @Decorator
-    static class ConverterDecorator implements Converter<String> {
-        @Inject
-        @Delegate
-        Converter<String> delegate;
-
-        @Override
-        public int convertToInt(String value) {
-            return 1 + delegate.convertToInt(value);
-        }
-
-        @Override
-        public boolean convertToBoolean(String value) {
-            return value.equals("echo");
-        }
-    }
-}
diff --git a/pom.xml b/pom.xml
index a7ef4b3e336..f262545f2f3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -71,12 +71,12 @@
         <jacoco.version>0.8.14</jacoco.version>
         <kubernetes-client.version>7.4.0</kubernetes-client.version> <!-- Please check with Java Operator SDK team before updating -->
         <rest-assured.version>5.5.6</rest-assured.version>
-        <hibernate-orm.version>7.1.6.Final</hibernate-orm.version> <!-- WARNING when updating, also align the versions below -->
+        <hibernate-orm.version>7.1.10.Final</hibernate-orm.version> <!-- WARNING when updating, also align the versions below -->
         <jakarta.persistence-api.version>3.2.0</jakarta.persistence-api.version> <!-- version controlled by Hibernate ORM's needs -->
         <antlr.version>4.13.2</antlr.version> <!-- version controlled by Hibernate ORM's needs -->
         <bytebuddy.version>1.17.6</bytebuddy.version> <!-- version controlled by Hibernate ORM's needs -->
         <hibernate-models.version>1.0.1</hibernate-models.version> <!-- version controlled by Hibernate ORM's needs -->
-        <hibernate-reactive.version>3.1.8.Final</hibernate-reactive.version> <!-- highly sensitive to Hibernate ORM upgrades -->
+        <hibernate-reactive.version>3.1.9.Final</hibernate-reactive.version> <!-- highly sensitive to Hibernate ORM upgrades -->
         <hibernate-validator.version>9.1.0.Final</hibernate-validator.version>
         <hibernate-search.version>8.1.2.Final</hibernate-search.version>
         <hibernate-tools.version>7.1.6.Final</hibernate-tools.version>
