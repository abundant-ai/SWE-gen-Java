diff --git a/retrofit-adapters/guava/pom.xml b/retrofit-adapters/guava/pom.xml
deleted file mode 100644
index 214c7ba8..00000000
--- a/retrofit-adapters/guava/pom.xml
+++ /dev/null
@@ -1,43 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.retrofit2</groupId>
-    <artifactId>retrofit-adapters</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
-    <relativePath>../pom.xml</relativePath>
-  </parent>
-
-  <artifactId>adapter-guava</artifactId>
-  <name>Adapter: Guava</name>
-
-  <dependencies>
-    <dependency>
-      <groupId>${project.groupId}</groupId>
-      <artifactId>retrofit</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>com.google.guava</groupId>
-      <artifactId>guava</artifactId>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp3</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <scope>test</scope>
-    </dependency>
-  </dependencies>
-</project>
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
deleted file mode 100644
index 497616ff..00000000
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/GuavaCallAdapterFactory.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.guava;
-
-import com.google.common.reflect.TypeToken;
-import com.google.common.util.concurrent.AbstractFuture;
-import com.google.common.util.concurrent.ListenableFuture;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.WildcardType;
-import retrofit2.Call;
-import retrofit2.CallAdapter;
-import retrofit2.Callback;
-import retrofit2.Response;
-import retrofit2.Retrofit;
-
-public final class GuavaCallAdapterFactory implements CallAdapter.Factory {
-  public static GuavaCallAdapterFactory create() {
-    return new GuavaCallAdapterFactory();
-  }
-
-  private GuavaCallAdapterFactory() {
-  }
-
-  @Override
-  public CallAdapter<?> get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
-    if (TypeToken.of(returnType).getRawType() != ListenableFuture.class) {
-      return null;
-    }
-    if (!(returnType instanceof ParameterizedType)) {
-      throw new IllegalStateException("ListenableFuture return type must be parameterized"
-          + " as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
-    }
-    Type innerType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
-    if (innerType instanceof WildcardType) {
-      innerType = ((WildcardType) innerType).getUpperBounds()[0];
-    }
-
-    if (TypeToken.of(innerType).getRawType() != Response.class) {
-      // Generic type is not Response<T>. Use it for body-only adapter.
-      return new BodyCallAdapter(innerType);
-    }
-
-    // Generic type is Response<T>. Extract T and create the Response version of the adapter.
-    if (!(innerType instanceof ParameterizedType)) {
-      throw new IllegalStateException("Response must be parameterized"
-          + " as Response<Foo> or Response<? extends Foo>");
-    }
-    Type responseType = ((ParameterizedType) innerType).getActualTypeArguments()[0];
-    if (responseType instanceof WildcardType) {
-      responseType = ((WildcardType) responseType).getUpperBounds()[0];
-    }
-    return new ResponseCallAdapter(responseType);
-  }
-
-  private static class BodyCallAdapter implements CallAdapter<ListenableFuture<?>> {
-    private final Type responseType;
-
-    BodyCallAdapter(Type responseType) {
-      this.responseType = responseType;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> ListenableFuture<?> adapt(final Call<R> call) {
-      return new AbstractFuture<R>() {
-        {
-          call.enqueue(new Callback<R>() {
-            @Override public void onResponse(Call<R> call, Response<R> response) {
-              if (response.isSuccess()) {
-                set(response.body());
-              } else {
-                setException(new HttpException(response));
-              }
-            }
-
-            @Override public void onFailure(Call<R> call, Throwable t) {
-              setException(t);
-            }
-          });
-        }
-
-        @Override protected void interruptTask() {
-          call.cancel();
-        }
-      };
-    }
-  }
-
-  private static class ResponseCallAdapter implements CallAdapter<ListenableFuture<?>> {
-    private final Type responseType;
-
-    ResponseCallAdapter(Type responseType) {
-      this.responseType = responseType;
-    }
-
-    @Override public Type responseType() {
-      return responseType;
-    }
-
-    @Override public <R> ListenableFuture<Response<R>> adapt(final Call<R> call) {
-      return new AbstractFuture<Response<R>>() {
-        {
-          call.enqueue(new Callback<R>() {
-            @Override public void onResponse(Call<R> call, Response<R> response) {
-              set(response);
-            }
-
-            @Override public void onFailure(Call<R> call, Throwable t) {
-              setException(t);
-            }
-          });
-        }
-
-        @Override protected void interruptTask() {
-          call.cancel();
-        }
-      };
-    }
-  }
-}
diff --git a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java b/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
deleted file mode 100644
index f18a8195..00000000
--- a/retrofit-adapters/guava/src/main/java/retrofit2/adapter/guava/HttpException.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.guava;
-
-import retrofit2.Response;
-
-/** Exception for an unexpected, non-2xx HTTP response. */
-public final class HttpException extends Exception {
-  private final int code;
-  private final String message;
-  private final transient Response<?> response;
-
-  public HttpException(Response<?> response) {
-    super("HTTP " + response.code() + " " + response.message());
-    this.code = response.code();
-    this.message = response.message();
-    this.response = response;
-  }
-
-  /** HTTP status code. */
-  public int code() {
-    return code;
-  }
-
-  /** HTTP status message. */
-  public String message() {
-    return message;
-  }
-
-  /**
-   * The full HTTP response. This may be null if the exception was serialized.
-   */
-  public Response<?> response() {
-    return response;
-  }
-}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
deleted file mode 100644
index 62d449eb..00000000
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/GuavaCallAdapterFactoryTest.java
+++ /dev/null
@@ -1,100 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.guava;
-
-import com.google.common.reflect.TypeToken;
-import com.google.common.util.concurrent.ListenableFuture;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import java.util.List;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.CallAdapter;
-import retrofit2.Response;
-import retrofit2.Retrofit;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class GuavaCallAdapterFactoryTest {
-  private static final Annotation[] NO_ANNOTATIONS = new Annotation[0];
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final CallAdapter.Factory factory = GuavaCallAdapterFactory.create();
-  private Retrofit retrofit;
-
-  @Before public void setUp() {
-    retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(factory)
-        .build();
-  }
-
-  @Test public void responseType() {
-    Type bodyClass = new TypeToken<ListenableFuture<String>>() {}.getType();
-    assertThat(factory.get(bodyClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyWildcard = new TypeToken<ListenableFuture<? extends String>>() {}.getType();
-    assertThat(factory.get(bodyWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type bodyGeneric = new TypeToken<ListenableFuture<List<String>>>() {}.getType();
-    assertThat(factory.get(bodyGeneric, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(new TypeToken<List<String>>() {}.getType());
-    Type responseClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(responseClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type responseWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(responseWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultClass = new TypeToken<ListenableFuture<Response<String>>>() {}.getType();
-    assertThat(factory.get(resultClass, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-    Type resultWildcard = new TypeToken<ListenableFuture<Response<? extends String>>>() {}.getType();
-    assertThat(factory.get(resultWildcard, NO_ANNOTATIONS, retrofit).responseType())
-        .isEqualTo(String.class);
-  }
-
-  @Test public void nonListenableFutureReturnsNull() {
-    CallAdapter<?> adapter = factory.get(String.class, NO_ANNOTATIONS, retrofit);
-    assertThat(adapter).isNull();
-  }
-
-  @Test public void rawTypeThrows() {
-    Type observableType = new TypeToken<ListenableFuture>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "ListenableFuture return type must be parameterized as ListenableFuture<Foo> or ListenableFuture<? extends Foo>");
-    }
-  }
-
-  @Test public void rawResponseTypeThrows() {
-    Type observableType = new TypeToken<ListenableFuture<Response>>() {}.getType();
-    try {
-      factory.get(observableType, NO_ANNOTATIONS, retrofit);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e).hasMessage(
-          "Response must be parameterized as Response<Foo> or Response<? extends Foo>");
-    }
-  }
-}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
deleted file mode 100644
index b87b9f24..00000000
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/ListenableFutureTest.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.guava;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import java.io.IOException;
-import java.util.concurrent.ExecutionException;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import retrofit2.Response;
-import retrofit2.Retrofit;
-import retrofit2.http.GET;
-
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ListenableFutureTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  interface Service {
-    @GET("/") ListenableFuture<String> body();
-    @GET("/") ListenableFuture<Response<String>> response();
-  }
-
-  private Service service;
-
-  @Before public void setUp() {
-    Retrofit retrofit = new Retrofit.Builder()
-        .baseUrl(server.url("/"))
-        .addConverterFactory(new StringConverterFactory())
-        .addCallAdapterFactory(GuavaCallAdapterFactory.create())
-        .build();
-    service = retrofit.create(Service.class);
-  }
-
-  @Test public void bodySuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    ListenableFuture<String> future = service.body();
-    assertThat(future.get()).isEqualTo("Hi");
-  }
-
-  @Test public void bodySuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404));
-
-    ListenableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(HttpException.class)
-          .hasMessage("HTTP 404 Client Error");
-    }
-  }
-
-  @Test public void bodyFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    ListenableFuture<String> future = service.body();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-
-  @Test public void responseSuccess200() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hi"));
-
-    ListenableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccess()).isTrue();
-    assertThat(response.body()).isEqualTo("Hi");
-  }
-
-  @Test public void responseSuccess404() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(404).setBody("Hi"));
-
-    ListenableFuture<Response<String>> future = service.response();
-    Response<String> response = future.get();
-    assertThat(response.isSuccess()).isFalse();
-    assertThat(response.errorBody().string()).isEqualTo("Hi");
-  }
-
-  @Test public void responseFailure() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-
-    ListenableFuture<Response<String>> future = service.response();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(IOException.class);
-    }
-  }
-}
diff --git a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java b/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
deleted file mode 100644
index c7f6a77f..00000000
--- a/retrofit-adapters/guava/src/test/java/retrofit2/adapter/guava/StringConverterFactory.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.adapter.guava;
-
-import java.io.IOException;
-import java.lang.annotation.Annotation;
-import java.lang.reflect.Type;
-import okhttp3.MediaType;
-import okhttp3.RequestBody;
-import okhttp3.ResponseBody;
-import retrofit2.Converter;
-import retrofit2.Retrofit;
-
-final class StringConverterFactory extends Converter.Factory {
-  @Override
-  public Converter<ResponseBody, ?> responseBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    return new Converter<ResponseBody, String>() {
-      @Override public String convert(ResponseBody value) throws IOException {
-        return value.string();
-      }
-    };
-  }
-
-  @Override
-  public Converter<?, RequestBody> requestBodyConverter(Type type, Annotation[] annotations,
-      Retrofit retrofit) {
-    return new Converter<String, RequestBody>() {
-      @Override public RequestBody convert(String value) throws IOException {
-        return RequestBody.create(MediaType.parse("text/plain"), value);
-      }
-    };
-  }
-}
diff --git a/retrofit-adapters/pom.xml b/retrofit-adapters/pom.xml
index b81a583c..8a677d35 100644
--- a/retrofit-adapters/pom.xml
+++ b/retrofit-adapters/pom.xml
@@ -15,7 +15,6 @@
   <packaging>pom</packaging>
 
   <modules>
-    <module>guava</module>
     <module>rxjava</module>
   </modules>
 </project>
diff --git a/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
new file mode 100644
index 00000000..167d5cfe
--- /dev/null
+++ b/samples/src/main/java/com/example/retrofit/CustomCallAdapter.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.example.retrofit;
+
+import com.google.common.reflect.TypeToken;
+import com.google.common.util.concurrent.AbstractFuture;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executors;
+import retrofit2.Call;
+import retrofit2.CallAdapter;
+import retrofit2.Callback;
+import retrofit2.GsonConverterFactory;
+import retrofit2.Response;
+import retrofit2.Retrofit;
+import retrofit2.http.GET;
+
+/**
+ * A sample showing a custom {@link CallAdapter} which adapts Guava's {@link ListenableFuture} as
+ * a service method return type.
+ */
+public final class CustomCallAdapter {
+  public static class ListenableFutureCallAdapterFactory implements CallAdapter.Factory {
+    @Override public CallAdapter<ListenableFuture<?>> get(Type returnType, Annotation[] annotations,
+        Retrofit retrofit) {
+      TypeToken<?> token = TypeToken.of(returnType);
+      if (token.getRawType() != ListenableFuture.class) {
+        return null;
+      }
+      if (!(returnType instanceof ParameterizedType)) {
+        throw new IllegalStateException(
+            "ListenableFuture must have generic type (e.g., ListenableFuture<ResponseBody>)");
+      }
+      final Type responseType = ((ParameterizedType) returnType).getActualTypeArguments()[0];
+      return new CallAdapter<ListenableFuture<?>>() {
+        @Override public Type responseType() {
+          return responseType;
+        }
+
+        @Override public <R> ListenableFuture<R> adapt(Call<R> call) {
+          CallFuture<R> future = new CallFuture<>(call);
+          call.enqueue(future);
+          return future;
+        }
+      };
+    }
+
+    private static final class CallFuture<T> extends AbstractFuture<T> implements Callback<T> {
+      private final Call<T> call;
+
+      private CallFuture(Call<T> call) {
+        this.call = call;
+      }
+
+      @Override protected void interruptTask() {
+        call.cancel();
+      }
+
+      @Override public void onResponse(Call<T> call, Response<T> response) {
+        if (response.isSuccess()) {
+          set(response.body());
+        } else {
+          setException(new IOException()); // TODO something more useful.
+        }
+      }
+
+      @Override public void onFailure(Call<T> call, Throwable t) {
+        setException(t);
+      }
+    }
+  }
+
+  interface HttpBinService {
+    @GET("/ip")
+    ListenableFuture<Ip> getIp();
+  }
+
+  static class Ip {
+    String origin;
+  }
+
+  public static void main(String... args) {
+    Retrofit retrofit = new Retrofit.Builder()
+        .baseUrl("http://httpbin.org")
+        .addCallAdapterFactory(new ListenableFutureCallAdapterFactory())
+        .addConverterFactory(GsonConverterFactory.create())
+        .build();
+
+    HttpBinService service = retrofit.create(HttpBinService.class);
+    final ListenableFuture<Ip> ip = service.getIp();
+    ip.addListener(new Runnable() {
+      @Override public void run() {
+        try {
+          System.out.println("IP: " + ip.get().origin);
+        } catch (InterruptedException | ExecutionException e) {
+          e.printStackTrace();
+        }
+      }
+    }, Executors.newSingleThreadExecutor());
+  }
+}
