Async controller methods that return Java async types are currently executed through Reactor even when Reactor is not required, which introduces Reactor stack frames into the request execution path. This is problematic for environments that want to avoid Reactor overhead and stack usage for simple async endpoints.

When an HTTP controller method returns an async type like `CompletableFuture` or `CompletionStage`, the server should be able to execute and complete the response without routing the execution through Reactor APIs. In particular, the call stack during request processing should not include `reactor.*` classes for these async return types unless Reactor is explicitly needed (e.g., when a controller/filter is returning a Reactive Streams `Publisher`).

Reproduction scenario: start an embedded server and call endpoints that return `CompletableFuture`/`CompletionStage` responses. During request handling, capture the stack trace (e.g., by walking `new RuntimeException().getStackTrace()` inside the request path) and verify it only contains expected framework/Netty/Java stack frames (e.g., `io.netty.*`, `io.micronaut.*`, `java.*`, `jdk.internal.*`) and does not contain `reactor.*`. Currently, these async endpoints end up with Reactor stack members present, indicating the framework is adapting the async return type into Reactor unnecessarily.

Expected behavior: controller methods returning `CompletableFuture`/`CompletionStage` (and similar non-reactive async types) should complete the HTTP response using Micronautâ€™s own async handling (and/or Netty futures) without Reactor being part of the execution chain. Reactor should still be allowed/used for reactive controller methods that return a Reactive Streams `Publisher` and for cases where reactive filters are involved.

Actual behavior: async endpoints are executed via a Reactor-based path, causing Reactor to appear in the invocation stack even for simple `CompletableFuture`/`CompletionStage` controller methods. This can also affect stack size characteristics and runtime dependencies.

Implement the server-side invocation/return-value handling so that non-reactive async controller methods (e.g., `CompletableFuture`, `CompletionStage`) are executed and adapted to an HTTP response without requiring Reactor, while preserving correct behavior for blocking/non-blocking annotations (`@NonBlocking`, `@ExecuteOn`) and for reactive (`Publisher`) endpoints and reactive filters.