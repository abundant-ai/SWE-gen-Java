diff --git a/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlow.java b/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlow.java
index b946ed2a7f..0274572e7e 100644
--- a/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlow.java
+++ b/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlow.java
@@ -18,7 +18,7 @@ package io.micronaut.core.execution;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 
-import java.util.concurrent.CompletionStage;
+import java.util.concurrent.CompletableFuture;
 
 /**
  * The completable future execution flow.
@@ -38,8 +38,8 @@ public interface CompletableFutureExecutionFlow<T> extends ExecutionFlow<T> {
      * @return a new flow
      */
     @NonNull
-    static <K> ExecutionFlow<K> just(@NonNull CompletionStage<K> value) {
-        return (ExecutionFlow<K>) new CompletableFutureExecutionFlowImpl((CompletionStage<Object>) value);
+    static <K> ExecutionFlow<K> just(@NonNull CompletableFuture<K> value) {
+        return (ExecutionFlow<K>) new CompletableFutureExecutionFlowImpl((CompletableFuture<Object>) value);
     }
 
 }
diff --git a/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlowImpl.java b/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlowImpl.java
index 26dbaeb795..c78cf5483c 100644
--- a/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlowImpl.java
+++ b/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlowImpl.java
@@ -34,9 +34,9 @@ import java.util.function.Supplier;
 @Internal
 final class CompletableFutureExecutionFlowImpl implements CompletableFutureExecutionFlow<Object> {
 
-    private CompletionStage<Object> stage;
+    private CompletableFuture<Object> stage;
 
-    CompletableFutureExecutionFlowImpl(CompletionStage<Object> stage) {
+    CompletableFutureExecutionFlowImpl(CompletableFuture<Object> stage) {
         this.stage = stage;
     }
 
@@ -106,10 +106,9 @@ final class CompletableFutureExecutionFlowImpl implements CompletableFutureExecu
     @Nullable
     @Override
     public ImperativeExecutionFlow<Object> tryComplete() {
-        CompletableFuture<Object> completableFuture = stage.toCompletableFuture();
-        if (completableFuture.isDone()) {
+        if (stage.isDone()) {
             try {
-                return new ImperativeExecutionFlowImpl(completableFuture.getNow(null), null);
+                return new ImperativeExecutionFlowImpl(stage.getNow(null), null);
             } catch (Throwable throwable) {
                 if (throwable instanceof CompletionException completionException) {
                     throwable = completionException.getCause();
@@ -123,7 +122,7 @@ final class CompletableFutureExecutionFlowImpl implements CompletableFutureExecu
 
     @Override
     public CompletableFuture<Object> toCompletableFuture() {
-        return stage.toCompletableFuture();
+        return stage;
     }
 
 }
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stack/InvocationStackSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stack/InvocationStackSpec.groovy
index 891b190e8b..2d1939b1cb 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stack/InvocationStackSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/stack/InvocationStackSpec.groovy
@@ -10,8 +10,6 @@ import io.micronaut.http.annotation.Controller
 import io.micronaut.http.annotation.Error
 import io.micronaut.http.annotation.Filter
 import io.micronaut.http.annotation.Get
-import io.micronaut.http.annotation.ResponseFilter
-import io.micronaut.http.annotation.ServerFilter
 import io.micronaut.http.client.annotation.Client
 import io.micronaut.http.filter.HttpServerFilter
 import io.micronaut.http.filter.ServerFilterChain
@@ -23,8 +21,6 @@ import org.reactivestreams.Publisher
 import spock.lang.Specification
 import spock.lang.Unroll
 
-import java.util.concurrent.CompletableFuture
-import java.util.concurrent.CompletionStage
 import java.util.concurrent.atomic.AtomicBoolean
 
 class InvocationStackSpec extends Specification {
@@ -42,56 +38,15 @@ class InvocationStackSpec extends Specification {
         embeddedServer.close()
 
         where:
-        method << ["async", "asyncIO", "blocking", "nonblocking", "executeOn",
+        method << ["blocking", "nonblocking", "executeOn",
                    "withOneReactiveFilter", "withOneReactiveFilterExecuteOn",
                    "withTwoReactiveFilters", "withTwoReactiveFiltersExecuteOn",
                    "exception", "throwsExecuteOnEx"]
     }
 
-    static void checkInvocationStack(boolean allowExecutor = false, boolean allowReactor = false) {
-        for (StackTraceElement s in new RuntimeException().getStackTrace()) {
-            if (!isKnownStack(s.className, allowExecutor, allowExecutor)) {
-                throw new RuntimeException("Unknown stack member: " + s.className);
-            }
-        }
-    }
-
-    static boolean isKnownStack(String className, boolean allowExecutor, boolean allowReactor) {
-        if (allowExecutor) {
-            if (className.startsWith("java.util.concurrent")) {
-                return true
-            }
-        }
-        if (className.startsWith("io.netty")) {
-            return true
-        }
-        if (className.startsWith("io.micronaut")) {
-            return true
-        }
-        if (className.startsWith("jdk.internal") || className.startsWith("java.lang")) {
-            return true // Java
-        }
-        if (className.startsWith("org.codehaus.groovy") || className.startsWith("org.apache.groovy") || className.startsWith("groovy.lang")) {
-            return true // Groovy
-        }
-        if (allowReactor) {
-            if (className == "reactor.core.publisher.Mono" || className == "reactor.core.publisher.MonoFromPublisher") {
-                return false
-            }
-        }
-        return false
-    }
-
     @Requires(property = "spec", value = "InvocationStackSpec")
     @Client("/stack-check")
     static interface StackCheckClient {
-
-        @Get("/async")
-        String async()
-
-        @Get("/async-io")
-        String asyncIO()
-
         @Get("/blocking")
         String blocking()
 
@@ -132,29 +87,16 @@ class InvocationStackSpec extends Specification {
         @Inject
         MyTwoFilter2 twoFilters2
 
-        @Get("/async")
-        CompletionStage<String> async() {
-            checkInvocationStack()
-            return CompletableFuture.completedFuture("OK")
-        }
-
-        @ExecuteOn(TaskExecutors.IO)
-        @Get("/async-io")
-        CompletionStage<String> asyncIO() {
-            checkInvocationStack(true)
-            return CompletableFuture.completedFuture("OK")
-        }
-
         @Get("/blocking")
         String blocking() {
-            checkInvocationStack()
+            checkInvocationStack(false)
             return "OK"
         }
 
         @Get("/nonblocking")
         @NonBlocking
         String nonblocking() {
-            checkInvocationStack()
+            checkInvocationStack(false)
             return "OK"
         }
 
@@ -163,7 +105,7 @@ class InvocationStackSpec extends Specification {
             if (!oneFilter.getExecuted().get()) {
                 throw new IllegalStateException()
             }
-            checkInvocationStack()
+            checkInvocationStack(false)
             return "OK"
         }
 
@@ -182,7 +124,7 @@ class InvocationStackSpec extends Specification {
             if (!twoFilters1.getExecuted().get() || !twoFilters2.getExecuted().get()) {
                 throw new IllegalStateException()
             }
-            checkInvocationStack()
+            checkInvocationStack(false)
             return "OK"
         }
 
@@ -191,7 +133,7 @@ class InvocationStackSpec extends Specification {
             if (!twoFilters1.getExecuted().get() || !twoFilters2.getExecuted().get()) {
                 throw new IllegalStateException()
             }
-            checkInvocationStack()
+            checkInvocationStack(true)
             return "OK"
         }
 
@@ -204,19 +146,19 @@ class InvocationStackSpec extends Specification {
 
         @Get("/exception")
         String throwsEx() {
-            checkInvocationStack()
+            checkInvocationStack(false)
             throw new MyException()
         }
 
         @Error(MyException)
         HttpResponse<?> onException(MyException e) {
-            checkInvocationStack()
+            checkInvocationStack(false)
             return HttpResponse.ok("OK")
         }
 
         @Get("/exception-execute-on")
         String throwsExecuteOnEx() {
-            checkInvocationStack()
+            checkInvocationStack(false)
             throw new MyException2()
         }
 
@@ -227,6 +169,36 @@ class InvocationStackSpec extends Specification {
             return HttpResponse.ok("OK")
         }
 
+        void checkInvocationStack(boolean allowExecutor) {
+            for (StackTraceElement s in new RuntimeException().getStackTrace()) {
+                if (!isKnownStack(s.className, allowExecutor)) {
+                    throw new RuntimeException("Unknown stack member: " + s.className);
+                }
+            }
+        }
+
+        boolean isKnownStack(String className, boolean allowExecutor) {
+            if (className.startsWith("java.util.concurrent")) {
+                return true
+            }
+            if (className.startsWith("io.netty")) {
+                return true
+            }
+            if (className.startsWith("io.micronaut")) {
+                return true
+            }
+            if (className.startsWith("jdk.internal") || className.startsWith("java.lang")) {
+                return true // Java
+            }
+            if (className.startsWith("org.codehaus.groovy") || className.startsWith("org.apache.groovy")) {
+                return true // Spock
+            }
+            if (className == "reactor.core.publisher.Mono" || className == "reactor.core.publisher.MonoFromPublisher") {
+                return true // added for kotlin context filters
+            }
+            return false
+        }
+
     }
 
     static class MyException extends RuntimeException {
@@ -245,32 +217,6 @@ class InvocationStackSpec extends Specification {
 
     }
 
-    @Requires(property = "spec", value = "InvocationStackSpec")
-    @ServerFilter("/stack-check/async")
-    static class AsyncFilter {
-
-        @ResponseFilter
-        HttpResponse<?> filterResponse(HttpResponse<?> httpResponse) {
-            checkInvocationStack()
-            return httpResponse
-        }
-    }
-
-    @Requires(property = "spec", value = "InvocationStackSpec")
-    @ServerFilter("/stack-check/async-io")
-    static class AsyncIoFilter {
-
-        @ResponseFilter
-        HttpResponse<?> filterResponse(HttpResponse<?> httpResponse) {
-            if (!Thread.currentThread().name.startsWith("io-executor")) {
-                throw new IllegalAccessException()
-            }
-            checkInvocationStack(true)
-            return httpResponse
-        }
-    }
-
-    @Requires(property = "spec", value = "InvocationStackSpec")
     @Filter("/stack-check/with-one-reactive-filter*")
     static class MyOneFilter implements HttpServerFilter {
 
@@ -278,13 +224,11 @@ class InvocationStackSpec extends Specification {
 
         @Override
         Publisher<MutableHttpResponse<?>> doFilter(HttpRequest<?> request, ServerFilterChain chain) {
-            checkInvocationStack(false, true)
             executed.set(true)
             return chain.proceed(request)
         }
     }
 
-    @Requires(property = "spec", value = "InvocationStackSpec")
     @Filter("/stack-check/with-two-reactive-filters*")
     static class MyTwoFilter1 implements HttpServerFilter {
 
@@ -292,13 +236,11 @@ class InvocationStackSpec extends Specification {
 
         @Override
         Publisher<MutableHttpResponse<?>> doFilter(HttpRequest<?> request, ServerFilterChain chain) {
-            checkInvocationStack(false, true)
             executed.set(true)
             return chain.proceed(request)
         }
     }
 
-    @Requires(property = "spec", value = "InvocationStackSpec")
     @Filter("/stack-check/with-two-reactive-filters*")
     static class MyTwoFilter2 implements HttpServerFilter {
 
@@ -306,7 +248,6 @@ class InvocationStackSpec extends Specification {
 
         @Override
         Publisher<MutableHttpResponse<?>> doFilter(HttpRequest<?> request, ServerFilterChain chain) {
-            checkInvocationStack(false, true)
             executed.set(true)
             return chain.proceed(request)
         }
diff --git a/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java b/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java
index b2492f675e..6f8870bf59 100644
--- a/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java
+++ b/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java
@@ -24,7 +24,6 @@ import io.micronaut.core.async.propagation.ReactivePropagation;
 import io.micronaut.core.async.propagation.ReactorPropagation;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.core.convert.ConversionService;
-import io.micronaut.core.execution.CompletableFutureExecutionFlow;
 import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.core.io.buffer.ReferenceCounted;
 import io.micronaut.core.propagation.PropagatedContext;
@@ -80,7 +79,6 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.function.Supplier;
@@ -518,30 +516,23 @@ public final class RouteExecutor {
         if (response != null) {
             return ExecutionFlow.just(finaliseResponse(request, routeInfo, routeMatch, response));
         }
-        Objects.requireNonNull(body);
         if (routeInfo.isImperative()) {
             outgoingResponse = fromImperativeExecute(propagatedContext, request, routeInfo, body);
         } else {
-            if (routeInfo.isAsync()) {
-                outgoingResponse = CompletableFutureExecutionFlow.just(
-                    fromCompletionStage(request, body, routeInfo)
+            // special case HttpResponse because FullNettyClientHttpResponse implements Completable...
+            boolean isReactive = routeInfo.isAsyncOrReactive() || (Publishers.isConvertibleToPublisher(body) && !(body instanceof HttpResponse<?>));
+            if (isReactive) {
+                outgoingResponse = ReactiveExecutionFlow.fromPublisher(
+                    ReactivePropagation.propagate(
+                        propagatedContext,
+                        fromReactiveExecute(propagatedContext, request, Objects.requireNonNull(body), routeInfo)
+                    )
                 );
             } else {
-                // special case HttpResponse because FullNettyClientHttpResponse implements Completable...
-                boolean isReactive = routeInfo.isReactive() || (Publishers.isConvertibleToPublisher(body) && !(body instanceof HttpResponse<?>));
-                if (isReactive) {
-                    outgoingResponse = ReactiveExecutionFlow.fromPublisher(
-                        ReactivePropagation.propagate(
-                            propagatedContext,
-                            fromReactiveExecute(propagatedContext, request, body, routeInfo)
-                        )
-                    );
+                if (routeInfo.isSuspended()) {
+                    outgoingResponse = fromKotlinCoroutineExecute(propagatedContext, request, body, routeInfo);
                 } else {
-                    if (routeInfo.isSuspended()) {
-                        outgoingResponse = fromKotlinCoroutineExecute(propagatedContext, request, body, routeInfo);
-                    } else {
-                        outgoingResponse = fromImperativeExecute(propagatedContext, request, routeInfo, body);
-                    }
+                    outgoingResponse = fromImperativeExecute(propagatedContext, request, routeInfo, body);
                 }
             }
         }
@@ -670,47 +661,6 @@ public final class RouteExecutor {
         return processPublisherBody(propagatedContext, request, response, routeInfo);
     }
 
-    @NonNull
-    private CompletionStage<MutableHttpResponse<?>> fromCompletionStage(@NonNull HttpRequest<?> request,
-                                                                        @NonNull Object body,
-                                                                        @NonNull RouteInfo<?> routeInfo) {
-        CompletionStage<Object> completionStage = (CompletionStage<Object>) body;
-        return completionStage.thenCompose(asyncBody -> {
-            MutableHttpResponse<?> mutableResponse;
-            if (asyncBody instanceof Optional<?> optional) {
-                if (optional.isPresent()) {
-                    asyncBody = optional.get();
-                } else {
-                    return CompletableFuture.completedStage(newNotFoundError(request));
-                }
-            }
-            if (asyncBody instanceof HttpResponse<?> httpResponse) {
-                mutableResponse = httpResponse.toMutableResponse();
-                final Argument<?> bodyArgument = routeInfo.getReturnType() // CompletionStage
-                    .getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT) // HttpResponse
-                    .getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT); // CompletionStage
-                if (bodyArgument.isAsync()) {
-                    CompletionStage<Object> inner = (CompletionStage<Object>) mutableResponse.body();
-                    return inner.thenApply(innerBody -> {
-                        if (innerBody == null) {
-                            return newNotFoundError(request);
-                        }
-                        return mutableResponse.body(innerBody);
-                    });
-                }
-            } else if (asyncBody instanceof HttpStatus status) {
-                mutableResponse = forStatus(routeInfo, status);
-            } else {
-                mutableResponse = forStatus(routeInfo, null)
-                    .body(asyncBody);
-            }
-            if (mutableResponse.body() == null) {
-                return CompletableFuture.completedStage(newNotFoundError(request));
-            }
-            return CompletableFuture.completedStage(mutableResponse);
-        });
-    }
-
     private Mono<MutableHttpResponse<?>> processPublisherBody(PropagatedContext propagatedContext,
                                                               HttpRequest<?> request,
                                                               MutableHttpResponse<?> response,
diff --git a/router/src/main/java/io/micronaut/web/router/Router.java b/router/src/main/java/io/micronaut/web/router/Router.java
index 1dfbe74d81..0b2a23d851 100644
--- a/router/src/main/java/io/micronaut/web/router/Router.java
+++ b/router/src/main/java/io/micronaut/web/router/Router.java
@@ -150,7 +150,7 @@ public interface Router {
      * @return A match or null, throws {@link DuplicateRouteException} on multiple routes.
      * @since 4.0.0
      */
-    @NonNull
+    @Nullable
     default <T, R> UriRouteMatch<T, R> findClosest(@NonNull HttpRequest<?> request) throws DuplicateRouteException {
         List<UriRouteMatch<T, R>> uriRoutes = findAllClosest(request);
         if (uriRoutes.size() > 1) {
