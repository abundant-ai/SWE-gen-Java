diff --git a/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlow.java b/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlow.java
index 0274572e7e..b946ed2a7f 100644
--- a/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlow.java
+++ b/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlow.java
@@ -18,7 +18,7 @@ package io.micronaut.core.execution;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 
-import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
 
 /**
  * The completable future execution flow.
@@ -38,8 +38,8 @@ public interface CompletableFutureExecutionFlow<T> extends ExecutionFlow<T> {
      * @return a new flow
      */
     @NonNull
-    static <K> ExecutionFlow<K> just(@NonNull CompletableFuture<K> value) {
-        return (ExecutionFlow<K>) new CompletableFutureExecutionFlowImpl((CompletableFuture<Object>) value);
+    static <K> ExecutionFlow<K> just(@NonNull CompletionStage<K> value) {
+        return (ExecutionFlow<K>) new CompletableFutureExecutionFlowImpl((CompletionStage<Object>) value);
     }
 
 }
diff --git a/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlowImpl.java b/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlowImpl.java
index c78cf5483c..26dbaeb795 100644
--- a/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlowImpl.java
+++ b/core/src/main/java/io/micronaut/core/execution/CompletableFutureExecutionFlowImpl.java
@@ -34,9 +34,9 @@ import java.util.function.Supplier;
 @Internal
 final class CompletableFutureExecutionFlowImpl implements CompletableFutureExecutionFlow<Object> {
 
-    private CompletableFuture<Object> stage;
+    private CompletionStage<Object> stage;
 
-    CompletableFutureExecutionFlowImpl(CompletableFuture<Object> stage) {
+    CompletableFutureExecutionFlowImpl(CompletionStage<Object> stage) {
         this.stage = stage;
     }
 
@@ -106,9 +106,10 @@ final class CompletableFutureExecutionFlowImpl implements CompletableFutureExecu
     @Nullable
     @Override
     public ImperativeExecutionFlow<Object> tryComplete() {
-        if (stage.isDone()) {
+        CompletableFuture<Object> completableFuture = stage.toCompletableFuture();
+        if (completableFuture.isDone()) {
             try {
-                return new ImperativeExecutionFlowImpl(stage.getNow(null), null);
+                return new ImperativeExecutionFlowImpl(completableFuture.getNow(null), null);
             } catch (Throwable throwable) {
                 if (throwable instanceof CompletionException completionException) {
                     throwable = completionException.getCause();
@@ -122,7 +123,7 @@ final class CompletableFutureExecutionFlowImpl implements CompletableFutureExecu
 
     @Override
     public CompletableFuture<Object> toCompletableFuture() {
-        return stage;
+        return stage.toCompletableFuture();
     }
 
 }
diff --git a/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java b/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java
index 6f8870bf59..b2492f675e 100644
--- a/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java
+++ b/http-server/src/main/java/io/micronaut/http/server/RouteExecutor.java
@@ -24,6 +24,7 @@ import io.micronaut.core.async.propagation.ReactivePropagation;
 import io.micronaut.core.async.propagation.ReactorPropagation;
 import io.micronaut.core.async.publisher.Publishers;
 import io.micronaut.core.convert.ConversionService;
+import io.micronaut.core.execution.CompletableFutureExecutionFlow;
 import io.micronaut.core.execution.ExecutionFlow;
 import io.micronaut.core.io.buffer.ReferenceCounted;
 import io.micronaut.core.propagation.PropagatedContext;
@@ -79,6 +80,7 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.function.Supplier;
@@ -516,23 +518,30 @@ public final class RouteExecutor {
         if (response != null) {
             return ExecutionFlow.just(finaliseResponse(request, routeInfo, routeMatch, response));
         }
+        Objects.requireNonNull(body);
         if (routeInfo.isImperative()) {
             outgoingResponse = fromImperativeExecute(propagatedContext, request, routeInfo, body);
         } else {
-            // special case HttpResponse because FullNettyClientHttpResponse implements Completable...
-            boolean isReactive = routeInfo.isAsyncOrReactive() || (Publishers.isConvertibleToPublisher(body) && !(body instanceof HttpResponse<?>));
-            if (isReactive) {
-                outgoingResponse = ReactiveExecutionFlow.fromPublisher(
-                    ReactivePropagation.propagate(
-                        propagatedContext,
-                        fromReactiveExecute(propagatedContext, request, Objects.requireNonNull(body), routeInfo)
-                    )
+            if (routeInfo.isAsync()) {
+                outgoingResponse = CompletableFutureExecutionFlow.just(
+                    fromCompletionStage(request, body, routeInfo)
                 );
             } else {
-                if (routeInfo.isSuspended()) {
-                    outgoingResponse = fromKotlinCoroutineExecute(propagatedContext, request, body, routeInfo);
+                // special case HttpResponse because FullNettyClientHttpResponse implements Completable...
+                boolean isReactive = routeInfo.isReactive() || (Publishers.isConvertibleToPublisher(body) && !(body instanceof HttpResponse<?>));
+                if (isReactive) {
+                    outgoingResponse = ReactiveExecutionFlow.fromPublisher(
+                        ReactivePropagation.propagate(
+                            propagatedContext,
+                            fromReactiveExecute(propagatedContext, request, body, routeInfo)
+                        )
+                    );
                 } else {
-                    outgoingResponse = fromImperativeExecute(propagatedContext, request, routeInfo, body);
+                    if (routeInfo.isSuspended()) {
+                        outgoingResponse = fromKotlinCoroutineExecute(propagatedContext, request, body, routeInfo);
+                    } else {
+                        outgoingResponse = fromImperativeExecute(propagatedContext, request, routeInfo, body);
+                    }
                 }
             }
         }
@@ -661,6 +670,47 @@ public final class RouteExecutor {
         return processPublisherBody(propagatedContext, request, response, routeInfo);
     }
 
+    @NonNull
+    private CompletionStage<MutableHttpResponse<?>> fromCompletionStage(@NonNull HttpRequest<?> request,
+                                                                        @NonNull Object body,
+                                                                        @NonNull RouteInfo<?> routeInfo) {
+        CompletionStage<Object> completionStage = (CompletionStage<Object>) body;
+        return completionStage.thenCompose(asyncBody -> {
+            MutableHttpResponse<?> mutableResponse;
+            if (asyncBody instanceof Optional<?> optional) {
+                if (optional.isPresent()) {
+                    asyncBody = optional.get();
+                } else {
+                    return CompletableFuture.completedStage(newNotFoundError(request));
+                }
+            }
+            if (asyncBody instanceof HttpResponse<?> httpResponse) {
+                mutableResponse = httpResponse.toMutableResponse();
+                final Argument<?> bodyArgument = routeInfo.getReturnType() // CompletionStage
+                    .getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT) // HttpResponse
+                    .getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT); // CompletionStage
+                if (bodyArgument.isAsync()) {
+                    CompletionStage<Object> inner = (CompletionStage<Object>) mutableResponse.body();
+                    return inner.thenApply(innerBody -> {
+                        if (innerBody == null) {
+                            return newNotFoundError(request);
+                        }
+                        return mutableResponse.body(innerBody);
+                    });
+                }
+            } else if (asyncBody instanceof HttpStatus status) {
+                mutableResponse = forStatus(routeInfo, status);
+            } else {
+                mutableResponse = forStatus(routeInfo, null)
+                    .body(asyncBody);
+            }
+            if (mutableResponse.body() == null) {
+                return CompletableFuture.completedStage(newNotFoundError(request));
+            }
+            return CompletableFuture.completedStage(mutableResponse);
+        });
+    }
+
     private Mono<MutableHttpResponse<?>> processPublisherBody(PropagatedContext propagatedContext,
                                                               HttpRequest<?> request,
                                                               MutableHttpResponse<?> response,
diff --git a/router/src/main/java/io/micronaut/web/router/Router.java b/router/src/main/java/io/micronaut/web/router/Router.java
index 0b2a23d851..1dfbe74d81 100644
--- a/router/src/main/java/io/micronaut/web/router/Router.java
+++ b/router/src/main/java/io/micronaut/web/router/Router.java
@@ -150,7 +150,7 @@ public interface Router {
      * @return A match or null, throws {@link DuplicateRouteException} on multiple routes.
      * @since 4.0.0
      */
-    @Nullable
+    @NonNull
     default <T, R> UriRouteMatch<T, R> findClosest(@NonNull HttpRequest<?> request) throws DuplicateRouteException {
         List<UriRouteMatch<T, R>> uriRoutes = findAllClosest(request);
         if (uriRoutes.size() > 1) {
