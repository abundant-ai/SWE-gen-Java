diff --git a/release-notes/VERSION-2.x b/release-notes/VERSION-2.x
index 196b734cb..f2b492e05 100644
--- a/release-notes/VERSION-2.x
+++ b/release-notes/VERSION-2.x
@@ -4,11 +4,6 @@ Project: jackson-databind
 === Releases === 
 ------------------------------------------------------------------------
 
-Not yet released
-
-#5242: Support "binary vectors": `@JsonFormat(shape = Shape.BINARY)` for
-  `float[]`, `double[]`
-
 2.20.0-rc1 (04-Aug-2025)
 
 #3072: Allow specifying `@JacksonInject` does not fail when there's no
diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java
index 08a62c777..d058c5d38 100644
--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java
@@ -213,6 +213,7 @@ public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T>
     @SuppressWarnings("unchecked")
     protected T handleNonArray(JsonParser p, DeserializationContext ctxt) throws IOException
     {
+
         final boolean canWrap = (_unwrapSingle == Boolean.TRUE) ||
                 ((_unwrapSingle == null) &&
                         ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY));
@@ -268,8 +269,10 @@ public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T>
         @Override
         public char[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
         {
-            // Won't take arrays, must get a String (could also convert other tokens to Strings...
-            // but let's not bother yet, doesn't seem to make sense)
+            /* Won't take arrays, must get a String (could also
+             * convert other tokens to Strings... but let's not bother
+             * yet, doesn't seem to make sense)
+             */
             if (p.hasToken(JsonToken.VALUE_STRING)) {
                 // note: can NOT return shared internal buffer, must copy:
                 char[] buffer = p.getTextCharacters();
@@ -480,7 +483,6 @@ public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T>
                         return (byte[]) ctxt.handleWeirdStringValue(byte[].class,
                                 p.getText(), msg);
                     }
-                    throw e;
                 }
             }
             // 31-Dec-2009, tatu: Also may be hidden as embedded Object
@@ -819,10 +821,6 @@ public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T>
         public float[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
         {
             if (!p.isExpectedStartArrayToken()) {
-                float[] decoded = _deserializeBinaryVector(p, ctxt);
-                if (decoded != null) {
-                    return decoded;
-                }
                 return handleNonArray(p, ctxt);
             }
             ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder();
@@ -866,61 +864,6 @@ public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T>
             System.arraycopy(newValue, 0, result, len1, len2);
             return result;
         }
-
-        private float[] _deserializeBinaryVector(JsonParser p, DeserializationContext ctxt)
-            throws IOException
-        {
-            JsonToken t = p.currentToken();
-            byte[] packed = null;
-
-            // Typical textual format case: base64 encoded String (for Packed Binary Vector)
-            if (t == JsonToken.VALUE_STRING) {
-                try {
-                    packed = p.getBinaryValue(ctxt.getBase64Variant());
-                } catch (StreamReadException | DatabindException e) {
-                    // [databind#1425], try to convert to a more usable one, as it's not really
-                    // a JSON-level parse exception, but rather binding from JSON String into
-                    // base64 decoded  binary data
-                    String msg = e.getOriginalMessage();
-                    if (msg.contains("base64")) {
-                        return (float[]) ctxt.handleWeirdStringValue(float[].class,
-                                p.getText(), msg);
-                    }
-                    throw e;
-                }
-            } else if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {
-                // Typical for binary formats
-                Object ob = p.getEmbeddedObject();
-                if (ob instanceof byte[]) {
-                    packed = (byte[]) ob;
-                } else if (ob == null || (ob instanceof float[])) {
-                    return (float[]) ob;
-                }
-            }
-            // Packed Binary Vector case
-            if (packed != null) {
-                return _unpack(ctxt, packed);
-            }
-            return null;
-        }
-
-        private float[] _unpack(DeserializationContext ctxt, byte[] bytes) throws IOException {
-            final int bytesLen = bytes.length;
-            if ((bytesLen & 3) != 0) {
-                return (float[]) ctxt.reportInputMismatch(handledType(),
-                        "Vector length for Packed Binary Float Vector (%d) not a multiple of 4 bytes", bytesLen);
-            }
-            final int vectorLen = bytesLen >> 2;
-            final float[] floats = new float[vectorLen];
-            for (int in = 0, out = 0; in < bytesLen; ) {
-                int packed = (bytes[in++] << 24)
-                        | ((bytes[in++] & 0xFF) << 16)
-                        | ((bytes[in++] & 0xFF) << 8)
-                        | (bytes[in++] & 0xFF);
-                floats[out++] = Float.intBitsToFloat(packed);
-            }
-            return floats;
-        }
     }
 
     @JacksonStdImpl
@@ -949,10 +892,6 @@ public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T>
         public double[] deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
         {
             if (!p.isExpectedStartArrayToken()) {
-                double[] decoded = _deserializeBinaryVector(p, ctxt);
-                if (decoded != null) {
-                    return decoded;
-                }
                 return handleNonArray(p, ctxt);
             }
             ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder();
@@ -995,65 +934,5 @@ public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T>
             System.arraycopy(newValue, 0, result, len1, len2);
             return result;
         }
-
-        private double[] _deserializeBinaryVector(JsonParser p, DeserializationContext ctxt)
-            throws IOException
-        {
-            JsonToken t = p.currentToken();
-            byte[] packed = null;
-
-            // Typical textual format case: base64 encoded String (for Packed Binary Vector)
-            if (t == JsonToken.VALUE_STRING) {
-                try {
-                    packed = p.getBinaryValue(ctxt.getBase64Variant());
-                } catch (StreamReadException | DatabindException e) {
-                    // [databind#1425], try to convert to a more usable one, as it's not really
-                    // a JSON-level parse exception, but rather binding from JSON String into
-                    // base64 decoded  binary data
-                    String msg = e.getOriginalMessage();
-                    if (msg.contains("base64")) {
-                        return (double[]) ctxt.handleWeirdStringValue(double[].class,
-                                p.getText(), msg);
-                    }
-                    throw e;
-                }
-            } else if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {
-                // Typical for binary formats
-                Object ob = p.getEmbeddedObject();
-                if (ob instanceof byte[]) {
-                    packed = (byte[]) ob;
-                } else if (ob == null || (ob instanceof double[])) {
-                    return (double[]) ob;
-                }
-            }
-            // Packed Binary Vector case
-            if (packed != null) {
-                return _unpack(ctxt, packed);
-            }
-            return null;
-        }
-
-        private double[] _unpack(DeserializationContext ctxt, byte[] bytes) throws IOException {
-            final int bytesLen = bytes.length;
-            if ((bytesLen & 7) != 0) {
-                return (double[]) ctxt.reportInputMismatch(handledType(),
-                        "Vector length for Packed Binary Double Vector (%d) not a multiple of 8 bytes", bytesLen);
-            }
-            final int vectorLen = bytesLen >> 3;
-            final double[] doubles = new double[vectorLen];
-            for (int in = 0, out = 0; in < bytesLen; ) {
-                int packed1 = (bytes[in++] << 24)
-                        | ((bytes[in++] & 0xFF) << 16)
-                        | ((bytes[in++] & 0xFF) << 8)
-                        | (bytes[in++] & 0xFF);
-                int packed2 = (bytes[in++] << 24)
-                        | ((bytes[in++] & 0xFF) << 16)
-                        | ((bytes[in++] & 0xFF) << 8)
-                        | (bytes[in++] & 0xFF);
-                long packed = ((long) packed1 << 32) | (packed2 & 0xFFFFFFFFL);
-                doubles[out++] = Double.longBitsToDouble(packed);
-            }
-            return doubles;
-        }
     }
 }
diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java
index fbf05de4c..9d2231cf3 100644
--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java
+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java
@@ -4,7 +4,6 @@ import java.io.IOException;
 import java.lang.reflect.Type;
 import java.util.HashMap;
 
-import com.fasterxml.jackson.annotation.JsonFormat;
 import com.fasterxml.jackson.core.*;
 import com.fasterxml.jackson.core.type.WritableTypeId;
 import com.fasterxml.jackson.databind.*;
@@ -14,7 +13,6 @@ import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrappe
 import com.fasterxml.jackson.databind.jsontype.TypeSerializer;
 import com.fasterxml.jackson.databind.node.ObjectNode;
 import com.fasterxml.jackson.databind.ser.ContainerSerializer;
-import com.fasterxml.jackson.databind.ser.ContextualSerializer;
 import com.fasterxml.jackson.databind.type.TypeFactory;
 
 /**
@@ -514,20 +512,16 @@ public class StdArraySerializers
         // as above, assuming no one re-defines primitive/wrapper types
         private final static JavaType VALUE_TYPE = simpleElementType(Float.TYPE);
 
-        // @since 2.20
-        final static FloatArraySerializer instance = new FloatArraySerializer();
-
         public FloatArraySerializer() {
             super(float[].class);
         }
-
         public FloatArraySerializer(FloatArraySerializer src, BeanProperty prop,
                 Boolean unwrapSingle) {
             super(src, prop, unwrapSingle);
         }
 
         @Override
-        public JsonSerializer<?> _withResolved(BeanProperty prop, Boolean unwrapSingle) {
+        public JsonSerializer<?> _withResolved(BeanProperty prop,Boolean unwrapSingle) {
             return new FloatArraySerializer(this, prop, unwrapSingle);
         }
 
@@ -552,20 +546,6 @@ public class StdArraySerializers
             return (value.length == 1);
         }
 
-        @Override
-        public JsonSerializer<?> createContextual(SerializerProvider ctxt, BeanProperty property)
-            throws JsonMappingException
-        {
-            JsonFormat.Value format = findFormatOverrides(ctxt, property,
-                    handledType());
-            if (format != null) {
-                if (format.getShape() == JsonFormat.Shape.BINARY) {
-                    return BinaryFloatArraySerializer.instance;
-                }
-            }
-            return super.createContextual(ctxt, property);
-        }
-
         @Override
         public final void serialize(float[] value, JsonGenerator g, SerializerProvider provider) throws IOException
         {
@@ -610,9 +590,6 @@ public class StdArraySerializers
         // as above, assuming no one re-defines primitive/wrapper types
         private final static JavaType VALUE_TYPE = simpleElementType(Double.TYPE);
 
-        // @since 2.20
-        final static DoubleArraySerializer instance = new DoubleArraySerializer();
-        
         public DoubleArraySerializer() { super(double[].class); }
 
         /**
@@ -658,20 +635,6 @@ public class StdArraySerializers
             return (value.length == 1);
         }
 
-        @Override
-        public JsonSerializer<?> createContextual(SerializerProvider ctxt, BeanProperty property)
-            throws JsonMappingException
-        {
-            JsonFormat.Value format = findFormatOverrides(ctxt, property,
-                    handledType());
-            if (format != null) {
-                if (format.getShape() == JsonFormat.Shape.BINARY) {
-                    return BinaryDoubleArraySerializer.instance;
-                }
-            }
-            return super.createContextual(ctxt, property);
-        }
-        
         @Override
         public final void serialize(double[] value, JsonGenerator g, SerializerProvider provider) throws IOException
         {
@@ -708,193 +671,4 @@ public class StdArraySerializers
             visitArrayFormat(visitor, typeHint, JsonFormatTypes.NUMBER);
         }
     }
-
-    /*
-    /**********************************************************************
-    /* Concrete serializers, alternative "binary Vector" representations
-    /**********************************************************************
-     */
-
-    /**
-     * Alternative serializer for arrays of primitive floats, using "packed binary"
-     * representation ("binary vector") instead of JSON array.
-     *
-     * @since 2.20
-     */
-    @JacksonStdImpl
-    public static class BinaryFloatArraySerializer extends StdSerializer<float[]>
-        implements ContextualSerializer
-    {
-        private static final long serialVersionUID = 1L;
-
-        final static BinaryFloatArraySerializer instance = new BinaryFloatArraySerializer();
-        
-        public BinaryFloatArraySerializer() {
-            super(float[].class);
-        }
-
-        @Override
-        public boolean isEmpty(SerializerProvider prov, float[] value) {
-            return value.length == 0;
-        }
-
-        @Override
-        public JsonSerializer<?> createContextual(SerializerProvider ctxt, BeanProperty property)
-                throws JsonMappingException
-        {
-            JsonFormat.Value format = findFormatOverrides(ctxt, property,
-                    handledType());
-            if (format != null) {
-                switch (format.getShape()) {
-                case ARRAY:
-                case NATURAL:
-                    return FloatArraySerializer.instance;
-                default:
-                }
-            }
-            return this;
-        }
-
-        @Override
-        public void serialize(float[] value, JsonGenerator g, SerializerProvider ctxt)
-            throws IOException
-        {
-            // First: "pack" the floats into bytes
-            final int vectorLen = value.length;
-            final byte[] b = new byte[vectorLen << 2];
-            for (int i = 0, out = 0; i < vectorLen; i++) {
-                final int floatBits = Float.floatToIntBits(value[i]);
-                b[out++] = (byte) (floatBits >> 24);
-                b[out++] = (byte) (floatBits >> 16);
-                b[out++] = (byte) (floatBits >> 8);
-                b[out++] = (byte) (floatBits);
-            }
-            // Second: write packed bytes (for JSON, Base64 encoded)
-            g.writeBinary(ctxt.getConfig().getBase64Variant(),
-                    b, 0, b.length);
-        }
-
-        @Override
-        public void serializeWithType(float[] value, JsonGenerator g, SerializerProvider ctxt,
-                TypeSerializer typeSer)
-            throws IOException
-        {
-            // most likely scalar
-            WritableTypeId typeIdDef = typeSer.writeTypePrefix(g,
-                    typeSer.typeId(value, JsonToken.VALUE_EMBEDDED_OBJECT));
-            serialize(value, g, ctxt);
-            typeSer.writeTypeSuffix(g, typeIdDef);
-        }
-
-        @Deprecated
-        @Override
-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {
-            return createSchemaNode("array", true).set("items", createSchemaNode("number"));
-        }
-
-        @Override
-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
-            throws JsonMappingException
-        {
-            // 06-Aug-2025, tatu: while logically (and within JVM) binary, gets encoded as Base64 String,
-            // let's try to indicate it is array of Float... difficult, thanks to JSON Schema's
-            // lackluster listing of types
-            visitArrayFormat(visitor, typeHint, JsonFormatTypes.NUMBER);
-        }
-    }
-
-    /**
-     * Alternative serializer for arrays of primitive doubles, using "packed binary"
-     * representation ("binary vector") instead of JSON array.
-     *
-     * @since 2.20
-     */
-    @JacksonStdImpl
-    public static class BinaryDoubleArraySerializer extends StdSerializer<double[]>
-        implements ContextualSerializer
-    {
-        private static final long serialVersionUID = 1L;
-
-        final static BinaryDoubleArraySerializer instance = new BinaryDoubleArraySerializer();
-        
-        public BinaryDoubleArraySerializer() {
-            super(double[].class);
-        }
-
-        @Override
-        public boolean isEmpty(SerializerProvider prov, double[] value) {
-            return value.length == 0;
-        }
-
-        @Override
-        public JsonSerializer<?> createContextual(SerializerProvider ctxt, BeanProperty property)
-                throws JsonMappingException
-        {
-            JsonFormat.Value format = findFormatOverrides(ctxt, property,
-                    handledType());
-            if (format != null) {
-                switch (format.getShape()) {
-                case ARRAY:
-                case NATURAL:
-                    return DoubleArraySerializer.instance;
-                default:
-                }
-            }
-            return this;
-        }
-
-        @Override
-        public void serialize(double[] value, JsonGenerator g, SerializerProvider ctxt)
-            throws IOException
-        {
-            // First: "pack" the floats into bytes
-            final int vectorLen = value.length;
-            final byte[] b = new byte[vectorLen << 3];
-            for (int i = 0, out = 0; i < vectorLen; i++) {
-                long bits = Double.doubleToLongBits(value[i]);
-                final int hi = (int) (bits >> 32);
-                b[out] = (byte) (hi >> 24);
-                b[out+1] = (byte) (hi >> 16);
-                b[out+2] = (byte) (hi >> 8);
-                b[out+3] = (byte) (hi);
-                final int lo = (int) bits;
-                b[out+4] = (byte) (lo >> 24);
-                b[out+5] = (byte) (lo >> 16);
-                b[out+6] = (byte) (lo >> 8);
-                b[out+7] = (byte) (lo);
-                out += 8;
-            }
-            // Second: write packed bytes (for JSON, Base64 encoded)
-            g.writeBinary(ctxt.getConfig().getBase64Variant(),
-                    b, 0, b.length);
-        }
-
-        @Override
-        public void serializeWithType(double[] value, JsonGenerator g, SerializerProvider ctxt,
-                TypeSerializer typeSer)
-            throws IOException
-        {
-            // most likely scalar
-            WritableTypeId typeIdDef = typeSer.writeTypePrefix(g,
-                    typeSer.typeId(value, JsonToken.VALUE_EMBEDDED_OBJECT));
-            serialize(value, g, ctxt);
-            typeSer.writeTypeSuffix(g, typeIdDef);
-        }
-
-        @Deprecated
-        @Override
-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {
-            return createSchemaNode("array", true).set("items", createSchemaNode("number"));
-        }
-
-        @Override
-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
-            throws JsonMappingException
-        {
-            // 14-Mar-2016, tatu: while logically (and within JVM) binary, gets encoded as Base64 String,
-            // let's try to indicate it is array of Float... difficult, thanks to JSON Schema's
-            // lackluster listing of types
-            visitArrayFormat(visitor, typeHint, JsonFormatTypes.NUMBER);
-        }
-    }
 }
diff --git a/src/test/java/com/fasterxml/jackson/databind/convert/CoerceContainersTest.java b/src/test/java/com/fasterxml/jackson/databind/convert/CoerceContainersTest.java
index 4a5ea0fdd..3b4b2288f 100644
--- a/src/test/java/com/fasterxml/jackson/databind/convert/CoerceContainersTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/convert/CoerceContainersTest.java
@@ -155,9 +155,7 @@ public class CoerceContainersTest
     @Test
     public void testFloatArray() throws Exception
     {
-        // 06-Aug-2025, tatu: with [databind#5242] will coerce empty String
-        //    as empty Base64 array, so no exception here
-        //_verifyNoCoercion(float[].class);
+        _verifyNoCoercion(float[].class);
         float[] result = _readWithCoercion(float[].class);
         assertNotNull(result);
         assertEquals(0, result.length);
@@ -166,9 +164,7 @@ public class CoerceContainersTest
     @Test
     public void testDoubleArray() throws Exception
     {
-        // 06-Aug-2025, tatu: with [databind#5242] will coerce empty String
-        //    as empty Base64 array, so no exception here
-        //_verifyNoCoercion(double[].class);
+        _verifyNoCoercion(double[].class);
         double[] result = _readWithCoercion(double[].class);
         assertNotNull(result);
         assertEquals(0, result.length);
diff --git a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/ArrayDeserializationTest.java b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/ArrayDeserializationTest.java
index fcdd9f05a..f12dbef55 100644
--- a/src/test/java/com/fasterxml/jackson/databind/deser/jdk/ArrayDeserializationTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/deser/jdk/ArrayDeserializationTest.java
@@ -551,12 +551,8 @@ public class ArrayDeserializationTest
         assertLengthValue(MAPPER.readValue("\"1\"", short[].class), (short) 1);
         assertLengthValue(MAPPER.readValue("\"1\"", int[].class), 1);
         assertLengthValue(MAPPER.readValue("\"1\"", long[].class), 1L);
-
-        // 06-Aug-2025, tatu: with [databind#5242] will try to access String
-        //   as Base64-encoded bytes. Need to think of whether to try to 
-        //   support Float/Double-as-single-String case or not; for now, not
-        //assertLengthValue(MAPPER.readValue("\"7.038531e-26\"", float[].class), 7.038531e-26f);
-        //assertLengthValue(MAPPER.readValue("\"1.5555\"", double[].class), 1.5555d);
+        assertLengthValue(MAPPER.readValue("\"7.038531e-26\"", float[].class), 7.038531e-26f);
+        assertLengthValue(MAPPER.readValue("\"1.5555\"", double[].class), 1.5555d);
     }
 
     private void assertLengthValue(boolean[] arr, boolean expt) {
@@ -584,12 +580,12 @@ public class ArrayDeserializationTest
         assertEquals(expt, arr[0]);
     }
 
-    void assertLengthValue(float[] arr, float expt) {
+    private void assertLengthValue(float[] arr, float expt) {
         assertEquals(1, arr.length);
         assertEquals(expt, arr[0]);
     }
 
-    void assertLengthValue(double[] arr, double expt) {
+    private void assertLengthValue(double[] arr, double expt) {
         assertEquals(1, arr.length);
         assertEquals(expt, arr[0]);
     }
diff --git a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/VectorsAsBinarySerTest.java b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/VectorsAsBinarySerTest.java
index 6bc0979b8..345e0e9c5 100644
--- a/src/test/java/com/fasterxml/jackson/databind/ser/jdk/VectorsAsBinarySerTest.java
+++ b/src/test/java/com/fasterxml/jackson/databind/ser/jdk/VectorsAsBinarySerTest.java
@@ -2,8 +2,6 @@ package com.fasterxml.jackson.databind.ser.jdk;
 
 import org.junit.jupiter.api.Test;
 
-import com.fasterxml.jackson.annotation.JsonFormat;
-import com.fasterxml.jackson.core.Base64Variants;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.testutil.DatabindTestUtil;
 
@@ -22,174 +20,27 @@ public class VectorsAsBinarySerTest extends DatabindTestUtil
     private final static double[] DOUBLE_VECTOR = new double[] { -1.0, 1.5, 0.0125 };
     private final static String DOUBLE_VECTOR_STR = "[-1.0,1.5,0.0125]";
 
-    static class BeanWithArrayFloatVector {
-        @JsonFormat(shape = JsonFormat.Shape.NATURAL) // or ARRAY
-        public float[] vector;
-
-        protected BeanWithArrayFloatVector() { }
-        public BeanWithArrayFloatVector(float[] v) {
-            vector = v;
-        }
-    }
-
-    static class BeanWithBinaryFloatVector {
-        @JsonFormat(shape = JsonFormat.Shape.BINARY)
-        public float[] vector;
-
-        protected BeanWithBinaryFloatVector() { }
-        public BeanWithBinaryFloatVector(float[] v) {
-            vector = v;
-        }
-    }
-
-    static class BeanWithArrayDoubleVector {
-        @JsonFormat(shape = JsonFormat.Shape.NATURAL) // or ARRAY
-        public double[] vector;
-
-        protected BeanWithArrayDoubleVector() { }
-        public BeanWithArrayDoubleVector(double[] v) {
-            vector = v;
-        }
-    }
-
-    static class BeanWithBinaryDoubleVector {
-        @JsonFormat(shape = JsonFormat.Shape.BINARY)
-        public double[] vector;
-
-        protected BeanWithBinaryDoubleVector() { }
-        public BeanWithBinaryDoubleVector(double[] v) {
-            vector = v;
-        }
-    }
-
-    private final ObjectMapper VANILLA_MAPPER = sharedMapper();
-
-    private final ObjectMapper BINARY_VECTOR_MAPPER = jsonMapperBuilder()
-            .withConfigOverride(float[].class,
-                    c -> c.setFormat(JsonFormat.Value.forShape(JsonFormat.Shape.BINARY)))
-            .withConfigOverride(double[].class,
-                    c -> c.setFormat(JsonFormat.Value.forShape(JsonFormat.Shape.BINARY)))
-            .build();
-
-    // // // Float Vector tests, as-Array
+    private final ObjectMapper MAPPER = sharedMapper();
 
+    // // // Float Vector tests
+    
     @Test
     public void defaultFloatVectorSerialization() throws Exception {
-        String json = VANILLA_MAPPER.writeValueAsString(FLOAT_VECTOR);
+        String json = MAPPER.writeValueAsString(FLOAT_VECTOR);
         assertEquals(FLOAT_VECTOR_STR, json);
 
-        float[] result = VANILLA_MAPPER.readValue(json, float[].class);
-        assertArrayEquals(FLOAT_VECTOR, result);
-    }
-
-    @Test
-    public void asArrayFloatVectorSerialization() throws Exception {
-        final String exp = a2q("{'vector':"+FLOAT_VECTOR_STR+"}");
-        String json = VANILLA_MAPPER.writeValueAsString(new BeanWithArrayFloatVector(FLOAT_VECTOR));
-        assertEquals(exp, json);
-        // And annotation overrides default shape override
-        assertEquals(exp,
-                BINARY_VECTOR_MAPPER.writeValueAsString(new BeanWithArrayFloatVector(FLOAT_VECTOR)));
-
-        BeanWithArrayFloatVector result = VANILLA_MAPPER.readValue(json, BeanWithArrayFloatVector.class);
-        assertArrayEquals(FLOAT_VECTOR, result.vector);
-    }
-
-    // // // Float Vector tests, as-Binary
-
-    @Test
-    public void asBinaryFloatVectorSerializationRoot() throws Exception {
-        String json = BINARY_VECTOR_MAPPER.writeValueAsString(FLOAT_VECTOR);
-        assertEquals(q(base64Encode(asBinary(FLOAT_VECTOR))), json);
-
-        float[] result = BINARY_VECTOR_MAPPER.readValue(json, float[].class);
+        float[] result = MAPPER.readValue(json, float[].class);
         assertArrayEquals(FLOAT_VECTOR, result);
     }
 
-    @Test
-    public void asBinaryFloatVectorSerializationPOJO() throws Exception {
-        String json = VANILLA_MAPPER.writeValueAsString(new BeanWithBinaryFloatVector(FLOAT_VECTOR));
-        assertEquals(a2q("{'vector':'"+base64Encode(asBinary(FLOAT_VECTOR))+"'}"), json);
-
-        BeanWithArrayFloatVector result = VANILLA_MAPPER.readValue(json, BeanWithArrayFloatVector.class);
-        assertArrayEquals(FLOAT_VECTOR, result.vector);
-    }
+    // // // Double Vector tests
     
-    // // // Double Vector tests, as-Array
-
     @Test
     public void defaultDoubleVectorSerialization() throws Exception {
-        String json = VANILLA_MAPPER.writeValueAsString(DOUBLE_VECTOR);
+        String json = MAPPER.writeValueAsString(DOUBLE_VECTOR);
         assertEquals(DOUBLE_VECTOR_STR, json);
 
-        double[] result = VANILLA_MAPPER.readValue(json, double[].class);
+        double[] result = MAPPER.readValue(json, double[].class);
         assertArrayEquals(DOUBLE_VECTOR, result);
     }
-
-    @Test
-    public void asArrayDoubleVectorSerialization() throws Exception {
-        String exp = a2q("{'vector':"+DOUBLE_VECTOR_STR+"}");
-        String json = VANILLA_MAPPER.writeValueAsString(new BeanWithArrayDoubleVector(DOUBLE_VECTOR));
-        assertEquals(exp, json);
-        // And annotation overrides default shape override
-        assertEquals(exp,
-                BINARY_VECTOR_MAPPER.writeValueAsString(new BeanWithArrayDoubleVector(DOUBLE_VECTOR)));
-
-        BeanWithArrayDoubleVector result = VANILLA_MAPPER.readValue(json, BeanWithArrayDoubleVector.class);
-        assertArrayEquals(DOUBLE_VECTOR, result.vector);
-    }
-
-    // // // Double Vector tests, as-Binary
-
-    @Test
-    public void asBinaryDoubleVectorSerializationRoot() throws Exception {
-        String json = BINARY_VECTOR_MAPPER.writeValueAsString(DOUBLE_VECTOR);
-        assertEquals(q(base64Encode(asBinary(DOUBLE_VECTOR))), json);
-
-        double[] result = BINARY_VECTOR_MAPPER.readValue(json, double[].class);
-        assertArrayEquals(DOUBLE_VECTOR, result);
-    }
-    
-    @Test
-    public void asBinaryDoubleVectorSerializationPOJO() throws Exception {
-        String json = VANILLA_MAPPER.writeValueAsString(new BeanWithBinaryDoubleVector(DOUBLE_VECTOR));
-        assertEquals(a2q("{'vector':'"+base64Encode(asBinary(DOUBLE_VECTOR))+"'}"), json);
-
-        BeanWithBinaryDoubleVector result = VANILLA_MAPPER.readValue(json, BeanWithBinaryDoubleVector.class);
-        assertArrayEquals(DOUBLE_VECTOR, result.vector);
-    }
-
-    // // // Helper methods
-
-    private static byte[] asBinary(float[] vector) {
-        byte[] result = new byte[vector.length * 4];
-        for (int i = 0; i < vector.length; i++) {
-            int bits = Float.floatToIntBits(vector[i]);
-            result[i * 4] = (byte) (bits >> 24);
-            result[i * 4 + 1] = (byte) (bits >> 16);
-            result[i * 4 + 2] = (byte) (bits >> 8);
-            result[i * 4 + 3] = (byte) bits;
-        }
-        return result;
-    }
-
-    private static byte[] asBinary(double[] vector) {
-        byte[] result = new byte[vector.length * 8];
-        for (int i = 0; i < vector.length; i++) {
-            long bits = Double.doubleToLongBits(vector[i]);
-            result[i * 8] = (byte) (bits >> 56);
-            result[i * 8 + 1] = (byte) (bits >> 48);
-            result[i * 8 + 2] = (byte) (bits >> 40);
-            result[i * 8 + 3] = (byte) (bits >> 32);
-            result[i * 8 + 4] = (byte) (bits >> 24);
-            result[i * 8 + 5] = (byte) (bits >> 16);
-            result[i * 8 + 6] = (byte) (bits >> 8);
-            result[i * 8 + 7] = (byte) bits;
-        }
-        return result;
-    }
-
-    private String base64Encode(byte[] data) {
-        return Base64Variants.getDefaultVariant().encode(data, false);
-    }
 }
