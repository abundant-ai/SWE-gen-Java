diff --git a/.scalafmt.conf b/.scalafmt.conf
index 4fe86abb5..795c9a4a7 100644
--- a/.scalafmt.conf
+++ b/.scalafmt.conf
@@ -1,4 +1,4 @@
-version=2.0.0
+version=2.0.0-RC8
 align.openParenCallSite = true
 align.openParenDefnSite = true
 maxColumn = 120
diff --git a/core/src/main/scala/cats/Parallel.scala b/core/src/main/scala/cats/Parallel.scala
index 2f905da39..466b172f8 100644
--- a/core/src/main/scala/cats/Parallel.scala
+++ b/core/src/main/scala/cats/Parallel.scala
@@ -169,6 +169,26 @@ object Parallel extends ParallelArityFunctions2 {
     P.sequential(gtb)
   }
 
+  def parUnorderedTraverse[T[_]: UnorderedTraverse, M[_], F[_]: CommutativeApplicative, A, B](
+    ta: T[A]
+  )(f: A => M[B])(implicit P: Parallel[M, F]): M[T[B]] =
+    P.sequential(UnorderedTraverse[T].unorderedTraverse(ta)(a => P.parallel(f(a))))
+
+  def parUnorderedSequence[T[_]: UnorderedTraverse, M[_], F[_]: CommutativeApplicative, A](
+    ta: T[M[A]]
+  )(implicit P: Parallel[M, F]): M[T[A]] =
+    parUnorderedTraverse[T, M, F, M[A], A](ta)(Predef.identity)
+
+  def parUnorderedFlatTraverse[T[_]: UnorderedTraverse: FlatMap, M[_], F[_]: CommutativeApplicative, A, B](
+    ta: T[A]
+  )(f: A => M[T[B]])(implicit P: Parallel[M, F]): M[T[B]] =
+    P.monad.map(parUnorderedTraverse[T, M, F, A, T[B]](ta)(f))(FlatMap[T].flatten)
+
+  def parUnorderedFlatSequence[T[_]: UnorderedTraverse: FlatMap, M[_], F[_]: CommutativeApplicative, A](
+    ta: T[M[T[A]]]
+  )(implicit P: Parallel[M, F]): M[T[A]] =
+    parUnorderedFlatTraverse[T, M, F, M[T[A]], A](ta)(Predef.identity)
+
   /**
    * Like `NonEmptyTraverse[A].nonEmptySequence`, but uses the apply instance
    * corresponding to the Parallel instance instead.
diff --git a/core/src/main/scala/cats/syntax/all.scala b/core/src/main/scala/cats/syntax/all.scala
index a12639f1b..2b19d210e 100644
--- a/core/src/main/scala/cats/syntax/all.scala
+++ b/core/src/main/scala/cats/syntax/all.scala
@@ -9,6 +9,7 @@ abstract class AllSyntaxBinCompat
     with AllSyntaxBinCompat3
     with AllSyntaxBinCompat4
     with AllSyntaxBinCompat5
+    with AllSyntaxBinCompat6
 
 trait AllSyntax
     extends AlternativeSyntax
@@ -90,3 +91,5 @@ trait AllSyntaxBinCompat4
     with BitraverseSyntaxBinCompat0
 
 trait AllSyntaxBinCompat5 extends ParallelBitraverseSyntax
+
+trait AllSyntaxBinCompat6 extends ParallelUnorderedTraverseSyntax
diff --git a/core/src/main/scala/cats/syntax/package.scala b/core/src/main/scala/cats/syntax/package.scala
index f7f4170aa..a6aa644a6 100644
--- a/core/src/main/scala/cats/syntax/package.scala
+++ b/core/src/main/scala/cats/syntax/package.scala
@@ -45,6 +45,7 @@ package object syntax {
       with ParallelFlatSyntax
       with ParallelApplySyntax
       with ParallelBitraverseSyntax
+      with ParallelUnorderedTraverseSyntax
   object partialOrder extends PartialOrderSyntax
   object profunctor extends ProfunctorSyntax
   object reducible extends ReducibleSyntax with ReducibleSyntaxBinCompat0
diff --git a/core/src/main/scala/cats/syntax/parallel.scala b/core/src/main/scala/cats/syntax/parallel.scala
index 79bd2ed69..b56f5844d 100644
--- a/core/src/main/scala/cats/syntax/parallel.scala
+++ b/core/src/main/scala/cats/syntax/parallel.scala
@@ -1,6 +1,6 @@
 package cats.syntax
 
-import cats.{Bitraverse, FlatMap, Foldable, Monad, Parallel, Traverse}
+import cats.{Bitraverse, CommutativeApplicative, FlatMap, Foldable, Monad, Parallel, Traverse, UnorderedTraverse}
 
 trait ParallelSyntax extends TupleParallelSyntax {
 
@@ -61,6 +61,24 @@ trait ParallelBitraverseSyntax {
     new ParallelLeftSequenceOps[T, M, A, B](tmab)
 }
 
+trait ParallelUnorderedTraverseSyntax {
+  implicit final def catsSyntaxParallelUnorderedTraverse[T[_], A](
+    ta: T[A]
+  ): ParallelUnorderedTraverseOps[T, A] =
+    new ParallelUnorderedTraverseOps[T, A](ta)
+
+  implicit final def catsSyntaxParallelUnorderedSequence[T[_], M[_], A](
+    tma: T[M[A]]
+  ): ParallelUnorderedSequenceOps[T, M, A] =
+    new ParallelUnorderedSequenceOps[T, M, A](tma)
+
+  implicit final def catsSyntaxParallelUnorderedFlatSequence[T[_], M[_], A](
+    tmta: T[M[T[A]]]
+  ): ParallelUnorderedFlatSequenceOps[T, M, A] =
+    new ParallelUnorderedFlatSequenceOps[T, M, A](tmta)
+
+}
+
 final class ParallelTraversableOps[T[_], A](private val ta: T[A]) extends AnyVal {
   def parTraverse[M[_]: Monad, F[_], B](f: A => M[B])(implicit T: Traverse[T], P: Parallel[M, F]): M[T[B]] =
     Parallel.parTraverse(ta)(f)
@@ -94,6 +112,36 @@ final class ParallelFlatSequenceOps[T[_], M[_], A](private val tmta: T[M[T[A]]])
     Parallel.parFlatSequence(tmta)
 }
 
+final class ParallelUnorderedSequenceOps[T[_], M[_], A](private val tmta: T[M[A]]) extends AnyVal {
+  def parUnorderedSequence[F[_]](implicit P: Parallel[M, F],
+                                 F: CommutativeApplicative[F],
+                                 Tutraverse: UnorderedTraverse[T]): M[T[A]] =
+    Parallel.parUnorderedSequence(tmta)
+}
+
+final class ParallelUnorderedTraverseOps[T[_], A](private val ta: T[A]) extends AnyVal {
+  def parUnorderedTraverse[M[_], F[_], B](
+    f: A => M[B]
+  )(implicit P: Parallel[M, F], F: CommutativeApplicative[F], Tutraverse: UnorderedTraverse[T]): M[T[B]] =
+    Parallel.parUnorderedTraverse(ta)(f)
+
+  def parUnorderedFlatTraverse[M[_], F[_], B](
+    f: A => M[T[B]]
+  )(implicit P: Parallel[M, F],
+    F: CommutativeApplicative[F],
+    Tflatmap: FlatMap[T],
+    Tutraverse: UnorderedTraverse[T]): M[T[B]] =
+    Parallel.parUnorderedFlatTraverse(ta)(f)
+}
+
+final class ParallelUnorderedFlatSequenceOps[T[_], M[_], A](private val tmta: T[M[T[A]]]) extends AnyVal {
+  def parUnorderedFlatSequence[F[_]](implicit P: Parallel[M, F],
+                                     Tflatmap: FlatMap[T],
+                                     F: CommutativeApplicative[F],
+                                     Tutraverse: UnorderedTraverse[T]): M[T[A]] =
+    Parallel.parUnorderedFlatSequence(tmta)
+}
+
 final class ParallelApOps[M[_], A](private val ma: M[A]) extends AnyVal {
 
   def &>[F[_], B](mb: M[B])(implicit P: Parallel[M, F]): M[B] =
