diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index bcf1194f..d65429ef 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -514,8 +514,19 @@ public abstract class JsonReader implements Closeable {
   /**
    * Changes the reader to treat the next name as a string value. This is useful for map adapters so
    * that arbitrary type adapters can use {@link #nextString} to read a name value.
+   *
+   * <p>In this example, calling this method allows two sequential calls to {@link #nextString()}:
+   * <pre> {@code
+   *
+   *     JsonReader reader = JsonReader.of(new Buffer().writeUtf8("{\"a\":\"b\"}"));
+   *     reader.beginObject();
+   *     reader.promoteNameToValue();
+   *     assertEquals("a", reader.nextString());
+   *     assertEquals("b", reader.nextString());
+   *     reader.endObject();
+   * }</pre>
    */
-  abstract void promoteNameToValue() throws IOException;
+  public abstract void promoteNameToValue() throws IOException;
 
   /**
    * A set of strings to be chosen with {@link #selectName} or {@link #selectString}. This prepares
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
index 70e48a88..dfcc10e1 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
@@ -1158,7 +1158,7 @@ final class JsonUtf8Reader extends JsonReader {
     }
   }
 
-  @Override void promoteNameToValue() throws IOException {
+  @Override public void promoteNameToValue() throws IOException {
     if (hasNext()) {
       peekedString = nextName();
       peeked = PEEKED_BUFFERED;
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
index e8d88be0..19610394 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Writer.java
@@ -162,12 +162,13 @@ final class JsonUtf8Writer extends JsonWriter {
       throw new IllegalStateException("JsonWriter is closed.");
     }
     int context = peekScope();
-    if ((context != EMPTY_OBJECT && context != NONEMPTY_OBJECT) || deferredName != null) {
+    if ((context != EMPTY_OBJECT && context != NONEMPTY_OBJECT)
+        || deferredName != null
+        || promoteValueToName) {
       throw new IllegalStateException("Nesting problem.");
     }
     deferredName = name;
     pathNames[stackSize - 1] = name;
-    promoteValueToName = false;
     return this;
   }
 
@@ -184,6 +185,7 @@ final class JsonUtf8Writer extends JsonWriter {
       return nullValue();
     }
     if (promoteValueToName) {
+      promoteValueToName = false;
       return name(value);
     }
     writeDeferredName();
@@ -236,6 +238,7 @@ final class JsonUtf8Writer extends JsonWriter {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
     if (promoteValueToName) {
+      promoteValueToName = false;
       return name(Double.toString(value));
     }
     writeDeferredName();
@@ -247,6 +250,7 @@ final class JsonUtf8Writer extends JsonWriter {
 
   @Override public JsonWriter value(long value) throws IOException {
     if (promoteValueToName) {
+      promoteValueToName = false;
       return name(Long.toString(value));
     }
     writeDeferredName();
@@ -267,6 +271,7 @@ final class JsonUtf8Writer extends JsonWriter {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
     if (promoteValueToName) {
+      promoteValueToName = false;
       return name(string);
     }
     writeDeferredName();
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java b/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
index df1d66b7..85ba5074 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
@@ -330,7 +330,7 @@ final class JsonValueReader extends JsonReader {
     return new JsonValueReader(this);
   }
 
-  @Override void promoteNameToValue() throws IOException {
+  @Override public void promoteNameToValue() throws IOException {
     if (hasNext()) {
       String name = nextName();
       push(name);
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
index 21fa06b9..2aab8949 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
@@ -130,17 +130,17 @@ final class JsonValueWriter extends JsonWriter {
     if (stackSize == 0) {
       throw new IllegalStateException("JsonWriter is closed.");
     }
-    if (peekScope() != EMPTY_OBJECT || deferredName != null) {
+    if (peekScope() != EMPTY_OBJECT || deferredName != null || promoteValueToName) {
       throw new IllegalStateException("Nesting problem.");
     }
     deferredName = name;
     pathNames[stackSize - 1] = name;
-    promoteValueToName = false;
     return this;
   }
 
   @Override public JsonWriter value(@Nullable String value) throws IOException {
     if (promoteValueToName) {
+      promoteValueToName = false;
       return name(value);
     }
     add(value);
@@ -184,6 +184,7 @@ final class JsonValueWriter extends JsonWriter {
       throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
     }
     if (promoteValueToName) {
+      promoteValueToName = false;
       return name(Double.toString(value));
     }
     add(value);
@@ -193,6 +194,7 @@ final class JsonValueWriter extends JsonWriter {
 
   @Override public JsonWriter value(long value) throws IOException {
     if (promoteValueToName) {
+      promoteValueToName = false;
       return name(Long.toString(value));
     }
     add(value);
@@ -223,6 +225,7 @@ final class JsonValueWriter extends JsonWriter {
         ? ((BigDecimal) value)
         : new BigDecimal(value.toString());
     if (promoteValueToName) {
+      promoteValueToName = false;
       return name(bigDecimalValue.toString());
     }
     add(bigDecimalValue);
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index af390204..1ff16105 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -443,8 +443,20 @@ public abstract class JsonWriter implements Closeable, Flushable {
   /**
    * Changes the writer to treat the next value as a string name. This is useful for map adapters so
    * that arbitrary type adapters can use {@link #value} to write a name value.
+   *
+   * <p>In this example, calling this method allows two sequential calls to {@link #value(String)}
+   * to produce the object, {@code {"a": "b"}}.
+   * <pre> {@code
+   *
+   *     JsonWriter writer = JsonWriter.of(...);
+   *     writer.beginObject();
+   *     writer.promoteValueToName();
+   *     writer.value("a");
+   *     writer.value("b");
+   *     writer.endObject();
+   * }</pre>
    */
-  final void promoteValueToName() throws IOException {
+  public final void promoteValueToName() throws IOException {
     int context = peekScope();
     if (context != NONEMPTY_OBJECT && context != EMPTY_OBJECT) {
       throw new IllegalStateException("Nesting problem.");
