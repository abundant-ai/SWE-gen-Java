diff --git a/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt b/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt
index f3dfa512d..9fea41599 100644
--- a/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt
+++ b/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt
@@ -16,10 +16,20 @@
 package okhttp3.mockwebserver
 
 import java.util.concurrent.TimeUnit.MILLISECONDS
-import mockwebserver3.SocketEffect
-import mockwebserver3.SocketEffect.CloseSocket
-import mockwebserver3.SocketEffect.CloseStream
-import mockwebserver3.SocketEffect.ShutdownConnection
+import mockwebserver3.SocketPolicy.DisconnectAfterRequest
+import mockwebserver3.SocketPolicy.DisconnectAtEnd
+import mockwebserver3.SocketPolicy.DisconnectAtStart
+import mockwebserver3.SocketPolicy.DisconnectDuringRequestBody
+import mockwebserver3.SocketPolicy.DisconnectDuringResponseBody
+import mockwebserver3.SocketPolicy.DoNotReadRequestBody
+import mockwebserver3.SocketPolicy.FailHandshake
+import mockwebserver3.SocketPolicy.KeepOpen
+import mockwebserver3.SocketPolicy.NoResponse
+import mockwebserver3.SocketPolicy.ResetStreamAtStart
+import mockwebserver3.SocketPolicy.ShutdownInputAtEnd
+import mockwebserver3.SocketPolicy.ShutdownOutputAtEnd
+import mockwebserver3.SocketPolicy.ShutdownServerAfterResponse
+import mockwebserver3.SocketPolicy.StallSocketAtStart
 import okio.Buffer
 import okio.ByteString
 
@@ -56,38 +66,19 @@ internal fun MockResponse.wrap(): mockwebserver3.MockResponse {
   result.status(status)
   result.headers(headers)
   result.trailers(trailers)
-
-  when (socketPolicy) {
-    SocketPolicy.EXPECT_CONTINUE, SocketPolicy.CONTINUE_ALWAYS -> result.add100Continue()
-    SocketPolicy.UPGRADE_TO_SSL_AT_END -> result.inTunnel()
-    SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE -> result.shutdownServer(true)
-    SocketPolicy.KEEP_OPEN -> Unit
-    SocketPolicy.DISCONNECT_AT_END -> result.onResponseEnd(ShutdownConnection)
-    SocketPolicy.DISCONNECT_AT_START -> result.onRequestStart(CloseSocket())
-    SocketPolicy.DISCONNECT_AFTER_REQUEST -> result.onResponseStart(CloseSocket())
-    SocketPolicy.DISCONNECT_DURING_REQUEST_BODY -> result.onRequestBody(CloseSocket())
-    SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY -> result.onResponseBody(CloseSocket())
-    SocketPolicy.DO_NOT_READ_REQUEST_BODY -> result.doNotReadRequestBody()
-    SocketPolicy.FAIL_HANDSHAKE -> result.failHandshake()
-    SocketPolicy.SHUTDOWN_INPUT_AT_END ->
-      result.onResponseEnd(
-        CloseSocket(
-          closeSocket = false,
-          shutdownInput = true,
-        ),
-      )
-    SocketPolicy.SHUTDOWN_OUTPUT_AT_END ->
-      result.onResponseEnd(
-        CloseSocket(
-          closeSocket = false,
-          shutdownOutput = true,
-        ),
-      )
-    SocketPolicy.STALL_SOCKET_AT_START -> result.onRequestStart(SocketEffect.Stall)
-    SocketPolicy.NO_RESPONSE -> result.onResponseStart(SocketEffect.Stall)
-    SocketPolicy.RESET_STREAM_AT_START -> result.onRequestStart(CloseStream(http2ErrorCode))
-  }
-
+  result.socketPolicy(
+    when (socketPolicy) {
+      SocketPolicy.EXPECT_CONTINUE, SocketPolicy.CONTINUE_ALWAYS -> {
+        result.add100Continue()
+        KeepOpen
+      }
+      SocketPolicy.UPGRADE_TO_SSL_AT_END -> {
+        result.inTunnel()
+        KeepOpen
+      }
+      else -> wrapSocketPolicy()
+    },
+  )
   result.throttleBody(throttleBytesPerPeriod, getThrottlePeriod(MILLISECONDS), MILLISECONDS)
   result.bodyDelay(getBodyDelay(MILLISECONDS), MILLISECONDS)
   result.headersDelay(getHeadersDelay(MILLISECONDS), MILLISECONDS)
@@ -116,3 +107,22 @@ internal fun mockwebserver3.RecordedRequest.unwrap(): RecordedRequest =
     handshake = handshake,
     requestUrl = url,
   )
+
+private fun MockResponse.wrapSocketPolicy(): mockwebserver3.SocketPolicy =
+  when (val socketPolicy = socketPolicy) {
+    SocketPolicy.SHUTDOWN_SERVER_AFTER_RESPONSE -> ShutdownServerAfterResponse
+    SocketPolicy.KEEP_OPEN -> KeepOpen
+    SocketPolicy.DISCONNECT_AT_END -> DisconnectAtEnd
+    SocketPolicy.DISCONNECT_AT_START -> DisconnectAtStart
+    SocketPolicy.DISCONNECT_AFTER_REQUEST -> DisconnectAfterRequest
+    SocketPolicy.DISCONNECT_DURING_REQUEST_BODY -> DisconnectDuringRequestBody
+    SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY -> DisconnectDuringResponseBody
+    SocketPolicy.DO_NOT_READ_REQUEST_BODY -> DoNotReadRequestBody(http2ErrorCode)
+    SocketPolicy.FAIL_HANDSHAKE -> FailHandshake
+    SocketPolicy.SHUTDOWN_INPUT_AT_END -> ShutdownInputAtEnd
+    SocketPolicy.SHUTDOWN_OUTPUT_AT_END -> ShutdownOutputAtEnd
+    SocketPolicy.STALL_SOCKET_AT_START -> StallSocketAtStart
+    SocketPolicy.NO_RESPONSE -> NoResponse
+    SocketPolicy.RESET_STREAM_AT_START -> ResetStreamAtStart(http2ErrorCode)
+    else -> error("Unexpected SocketPolicy: $socketPolicy")
+  }
diff --git a/mockwebserver/api/mockwebserver3.api b/mockwebserver/api/mockwebserver3.api
index 980b7b03c..24d8a0d64 100644
--- a/mockwebserver/api/mockwebserver3.api
+++ b/mockwebserver/api/mockwebserver3.api
@@ -6,28 +6,21 @@ public abstract class mockwebserver3/Dispatcher : java/io/Closeable {
 }
 
 public final class mockwebserver3/MockResponse {
-	public fun <init> (ILokhttp3/Headers;Ljava/lang/String;)V
-	public synthetic fun <init> (ILokhttp3/Headers;Ljava/lang/String;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public fun <init> (ILokhttp3/Headers;Ljava/lang/String;Lmockwebserver3/SocketPolicy;)V
+	public synthetic fun <init> (ILokhttp3/Headers;Ljava/lang/String;Lmockwebserver3/SocketPolicy;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
 	public synthetic fun <init> (Lmockwebserver3/MockResponse$Builder;Lkotlin/jvm/internal/DefaultConstructorMarker;)V
 	public final fun getBody ()Lmockwebserver3/MockResponseBody;
 	public final fun getBodyDelayNanos ()J
 	public final fun getCode ()I
-	public final fun getDoNotReadRequestBody ()Z
-	public final fun getFailHandshake ()Z
 	public final fun getHeaders ()Lokhttp3/Headers;
 	public final fun getHeadersDelayNanos ()J
 	public final fun getInTunnel ()Z
 	public final fun getInformationalResponses ()Ljava/util/List;
 	public final fun getMessage ()Ljava/lang/String;
-	public final fun getOnRequestBody ()Lmockwebserver3/SocketEffect;
-	public final fun getOnRequestStart ()Lmockwebserver3/SocketEffect;
-	public final fun getOnResponseBody ()Lmockwebserver3/SocketEffect;
-	public final fun getOnResponseEnd ()Lmockwebserver3/SocketEffect;
-	public final fun getOnResponseStart ()Lmockwebserver3/SocketEffect;
 	public final fun getPushPromises ()Ljava/util/List;
 	public final fun getSettings ()Lokhttp3/internal/http2/Settings;
-	public final fun getShutdownServer ()Z
 	public final fun getSocketHandler ()Lmockwebserver3/SocketHandler;
+	public final fun getSocketPolicy ()Lmockwebserver3/SocketPolicy;
 	public final fun getStatus ()Ljava/lang/String;
 	public final fun getThrottleBytesPerPeriod ()J
 	public final fun getThrottlePeriodNanos ()J
@@ -59,26 +52,17 @@ public final class mockwebserver3/MockResponse$Builder : java/lang/Cloneable {
 	public synthetic fun clone ()Ljava/lang/Object;
 	public fun clone ()Lmockwebserver3/MockResponse$Builder;
 	public final fun code (I)Lmockwebserver3/MockResponse$Builder;
-	public final fun doNotReadRequestBody ()Lmockwebserver3/MockResponse$Builder;
-	public final fun failHandshake ()Lmockwebserver3/MockResponse$Builder;
 	public final fun getBody ()Lmockwebserver3/MockResponseBody;
 	public final fun getBodyDelayNanos ()J
 	public final fun getCode ()I
-	public final fun getDoNotReadRequestBody ()Z
-	public final fun getFailHandshake ()Z
 	public final fun getHeaders ()Lokhttp3/Headers;
 	public final fun getHeadersDelayNanos ()J
 	public final fun getInTunnel ()Z
 	public final fun getInformationalResponses ()Ljava/util/List;
-	public final fun getOnRequestBody ()Lmockwebserver3/SocketEffect;
-	public final fun getOnRequestStart ()Lmockwebserver3/SocketEffect;
-	public final fun getOnResponseBody ()Lmockwebserver3/SocketEffect;
-	public final fun getOnResponseEnd ()Lmockwebserver3/SocketEffect;
-	public final fun getOnResponseStart ()Lmockwebserver3/SocketEffect;
 	public final fun getPushPromises ()Ljava/util/List;
 	public final fun getSettings ()Lokhttp3/internal/http2/Settings;
-	public final fun getShutdownServer ()Z
 	public final fun getSocketHandler ()Lmockwebserver3/SocketHandler;
+	public final fun getSocketPolicy ()Lmockwebserver3/SocketPolicy;
 	public final fun getStatus ()Ljava/lang/String;
 	public final fun getThrottleBytesPerPeriod ()J
 	public final fun getThrottlePeriodNanos ()J
@@ -88,16 +72,11 @@ public final class mockwebserver3/MockResponse$Builder : java/lang/Cloneable {
 	public final fun headers (Lokhttp3/Headers;)Lmockwebserver3/MockResponse$Builder;
 	public final fun headersDelay (JLjava/util/concurrent/TimeUnit;)Lmockwebserver3/MockResponse$Builder;
 	public final fun inTunnel ()Lmockwebserver3/MockResponse$Builder;
-	public final fun onRequestBody (Lmockwebserver3/SocketEffect;)Lmockwebserver3/MockResponse$Builder;
-	public final fun onRequestStart (Lmockwebserver3/SocketEffect;)Lmockwebserver3/MockResponse$Builder;
-	public final fun onResponseBody (Lmockwebserver3/SocketEffect;)Lmockwebserver3/MockResponse$Builder;
-	public final fun onResponseEnd (Lmockwebserver3/SocketEffect;)Lmockwebserver3/MockResponse$Builder;
-	public final fun onResponseStart (Lmockwebserver3/SocketEffect;)Lmockwebserver3/MockResponse$Builder;
 	public final fun removeHeader (Ljava/lang/String;)Lmockwebserver3/MockResponse$Builder;
 	public final fun setHeader (Ljava/lang/String;Ljava/lang/Object;)Lmockwebserver3/MockResponse$Builder;
 	public final fun settings (Lokhttp3/internal/http2/Settings;)Lmockwebserver3/MockResponse$Builder;
-	public final fun shutdownServer (Z)Lmockwebserver3/MockResponse$Builder;
 	public final fun socketHandler (Lmockwebserver3/SocketHandler;)Lmockwebserver3/MockResponse$Builder;
+	public final fun socketPolicy (Lmockwebserver3/SocketPolicy;)Lmockwebserver3/MockResponse$Builder;
 	public final fun status (Ljava/lang/String;)Lmockwebserver3/MockResponse$Builder;
 	public final fun throttleBody (JJLjava/util/concurrent/TimeUnit;)Lmockwebserver3/MockResponse$Builder;
 	public final fun trailers (Lokhttp3/Headers;)Lmockwebserver3/MockResponse$Builder;
@@ -184,34 +163,76 @@ public final class mockwebserver3/RecordedRequest {
 	public fun toString ()Ljava/lang/String;
 }
 
-public abstract interface class mockwebserver3/SocketEffect {
+public abstract interface class mockwebserver3/SocketHandler {
+	public abstract fun handle (Lokio/Socket;)V
+}
+
+public abstract interface class mockwebserver3/SocketPolicy {
+}
+
+public final class mockwebserver3/SocketPolicy$DisconnectAfterRequest : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$DisconnectAfterRequest;
+}
+
+public final class mockwebserver3/SocketPolicy$DisconnectAtEnd : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$DisconnectAtEnd;
 }
 
-public final class mockwebserver3/SocketEffect$CloseSocket : mockwebserver3/SocketEffect {
+public final class mockwebserver3/SocketPolicy$DisconnectAtStart : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$DisconnectAtStart;
+}
+
+public final class mockwebserver3/SocketPolicy$DisconnectDuringRequestBody : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$DisconnectDuringRequestBody;
+}
+
+public final class mockwebserver3/SocketPolicy$DisconnectDuringResponseBody : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$DisconnectDuringResponseBody;
+}
+
+public final class mockwebserver3/SocketPolicy$DoNotReadRequestBody : mockwebserver3/SocketPolicy {
 	public fun <init> ()V
-	public fun <init> (ZZZ)V
-	public synthetic fun <init> (ZZZILkotlin/jvm/internal/DefaultConstructorMarker;)V
-	public final fun getCloseSocket ()Z
-	public final fun getShutdownInput ()Z
-	public final fun getShutdownOutput ()Z
+	public fun <init> (I)V
+	public synthetic fun <init> (IILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun getHttp2ErrorCode ()I
+}
+
+public final class mockwebserver3/SocketPolicy$FailHandshake : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$FailHandshake;
+}
+
+public final class mockwebserver3/SocketPolicy$HalfCloseAfterRequest : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$HalfCloseAfterRequest;
+}
+
+public final class mockwebserver3/SocketPolicy$KeepOpen : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$KeepOpen;
+}
+
+public final class mockwebserver3/SocketPolicy$NoResponse : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$NoResponse;
 }
 
-public final class mockwebserver3/SocketEffect$CloseStream : mockwebserver3/SocketEffect {
+public final class mockwebserver3/SocketPolicy$ResetStreamAtStart : mockwebserver3/SocketPolicy {
 	public fun <init> ()V
 	public fun <init> (I)V
 	public synthetic fun <init> (IILkotlin/jvm/internal/DefaultConstructorMarker;)V
 	public final fun getHttp2ErrorCode ()I
 }
 
-public final class mockwebserver3/SocketEffect$ShutdownConnection : mockwebserver3/SocketEffect {
-	public static final field INSTANCE Lmockwebserver3/SocketEffect$ShutdownConnection;
+public final class mockwebserver3/SocketPolicy$ShutdownInputAtEnd : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$ShutdownInputAtEnd;
 }
 
-public final class mockwebserver3/SocketEffect$Stall : mockwebserver3/SocketEffect {
-	public static final field INSTANCE Lmockwebserver3/SocketEffect$Stall;
+public final class mockwebserver3/SocketPolicy$ShutdownOutputAtEnd : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$ShutdownOutputAtEnd;
 }
 
-public abstract interface class mockwebserver3/SocketHandler {
-	public abstract fun handle (Lokio/Socket;)V
+public final class mockwebserver3/SocketPolicy$ShutdownServerAfterResponse : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$ShutdownServerAfterResponse;
+}
+
+public final class mockwebserver3/SocketPolicy$StallSocketAtStart : mockwebserver3/SocketPolicy {
+	public static final field INSTANCE Lmockwebserver3/SocketPolicy$StallSocketAtStart;
 }
 
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/Dispatcher.kt b/mockwebserver/src/main/kotlin/mockwebserver3/Dispatcher.kt
index e8de08e27..c92ccb1fd 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/Dispatcher.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/Dispatcher.kt
@@ -16,6 +16,7 @@
 package mockwebserver3
 
 import java.io.Closeable
+import mockwebserver3.SocketPolicy.KeepOpen
 
 /** Handler for mock server requests. */
 public abstract class Dispatcher : Closeable {
@@ -32,7 +33,7 @@ public abstract class Dispatcher : Closeable {
    * can return other values to test HTTP edge cases, such as unhappy socket policies or throttled
    * request bodies.
    */
-  public open fun peek(): MockResponse = MockResponse()
+  public open fun peek(): MockResponse = MockResponse(socketPolicy = KeepOpen)
 
   /**
    * Release any resources held by this dispatcher. Any requests that are currently being dispatched
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/MockResponse.kt b/mockwebserver/src/main/kotlin/mockwebserver3/MockResponse.kt
index 7056271ce..f6e863d6e 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/MockResponse.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/MockResponse.kt
@@ -23,13 +23,12 @@
 package mockwebserver3
 
 import java.util.concurrent.TimeUnit
-import mockwebserver3.SocketEffect.CloseStream
+import mockwebserver3.SocketPolicy.KeepOpen
 import mockwebserver3.internal.toMockResponseBody
 import okhttp3.Headers
 import okhttp3.Headers.Companion.headersOf
 import okhttp3.WebSocketListener
 import okhttp3.internal.addHeaderLenient
-import okhttp3.internal.http2.ErrorCode
 import okhttp3.internal.http2.Settings
 import okio.Buffer
 
@@ -66,14 +65,7 @@ public class MockResponse {
   public val throttleBytesPerPeriod: Long
   public val throttlePeriodNanos: Long
 
-  public val failHandshake: Boolean
-  public val onRequestStart: SocketEffect?
-  public val doNotReadRequestBody: Boolean
-  public val onRequestBody: SocketEffect?
-  public val onResponseStart: SocketEffect?
-  public val onResponseBody: SocketEffect?
-  public val onResponseEnd: SocketEffect?
-  public val shutdownServer: Boolean
+  public val socketPolicy: SocketPolicy
 
   public val headersDelayNanos: Long
   public val bodyDelayNanos: Long
@@ -88,11 +80,13 @@ public class MockResponse {
     code: Int = 200,
     headers: Headers = headersOf(),
     body: String = "",
+    socketPolicy: SocketPolicy = KeepOpen,
   ) : this(
     Builder()
       .code(code)
       .headers(headers)
-      .body(body),
+      .body(body)
+      .socketPolicy(socketPolicy),
   )
 
   private constructor(builder: Builder) {
@@ -106,14 +100,7 @@ public class MockResponse {
     this.informationalResponses = builder.informationalResponses
     this.throttleBytesPerPeriod = builder.throttleBytesPerPeriod
     this.throttlePeriodNanos = builder.throttlePeriodNanos
-    this.failHandshake = builder.failHandshake
-    this.onRequestStart = builder.onRequestStart
-    this.doNotReadRequestBody = builder.doNotReadRequestBody
-    this.onRequestBody = builder.onRequestBody
-    this.onResponseStart = builder.onResponseStart
-    this.onResponseBody = builder.onResponseBody
-    this.onResponseEnd = builder.onResponseEnd
-    this.shutdownServer = builder.shutdownServer
+    this.socketPolicy = builder.socketPolicy
     this.headersDelayNanos = builder.headersDelayNanos
     this.bodyDelayNanos = builder.bodyDelayNanos
     this.trailersDelayNanos = builder.trailersDelayNanos
@@ -195,21 +182,7 @@ public class MockResponse {
     public var throttlePeriodNanos: Long
       private set
 
-    public var failHandshake: Boolean
-      private set
-    public var onRequestStart: SocketEffect?
-      private set
-    public var doNotReadRequestBody: Boolean
-      private set
-    public var onRequestBody: SocketEffect?
-      private set
-    public var onResponseStart: SocketEffect?
-      private set
-    public var onResponseBody: SocketEffect?
-      private set
-    public var onResponseEnd: SocketEffect?
-      private set
-    public var shutdownServer: Boolean
+    public var socketPolicy: SocketPolicy
       private set
 
     public var headersDelayNanos: Long
@@ -241,14 +214,7 @@ public class MockResponse {
       this.trailers_ = Headers.Builder()
       this.throttleBytesPerPeriod = Long.MAX_VALUE
       this.throttlePeriodNanos = 0L
-      this.failHandshake = false
-      this.onRequestStart = null
-      this.doNotReadRequestBody = false
-      this.onRequestBody = null
-      this.onResponseStart = null
-      this.onResponseBody = null
-      this.onResponseEnd = null
-      this.shutdownServer = false
+      this.socketPolicy = KeepOpen
       this.headersDelayNanos = 0L
       this.bodyDelayNanos = 0L
       this.trailersDelayNanos = 0L
@@ -267,14 +233,7 @@ public class MockResponse {
       this.webSocketListenerVar = mockResponse.webSocketListener
       this.throttleBytesPerPeriod = mockResponse.throttleBytesPerPeriod
       this.throttlePeriodNanos = mockResponse.throttlePeriodNanos
-      this.failHandshake = mockResponse.failHandshake
-      this.onRequestStart = mockResponse.onRequestStart
-      this.doNotReadRequestBody = mockResponse.doNotReadRequestBody
-      this.onRequestBody = mockResponse.onRequestBody
-      this.onResponseStart = mockResponse.onResponseStart
-      this.onResponseBody = mockResponse.onResponseBody
-      this.onResponseEnd = mockResponse.onResponseEnd
-      this.shutdownServer = mockResponse.shutdownServer
+      this.socketPolicy = mockResponse.socketPolicy
       this.headersDelayNanos = mockResponse.headersDelayNanos
       this.bodyDelayNanos = mockResponse.bodyDelayNanos
       this.trailersDelayNanos = mockResponse.trailersDelayNanos
@@ -415,56 +374,10 @@ public class MockResponse {
         this.trailers_ = trailers.newBuilder()
       }
 
-    /** Don't trust the client during the SSL handshake. */
-    public fun failHandshake(): Builder =
-      apply {
-        failHandshake = true
-      }
-
-    /** Trigger [socketEffect] before the request headers are read. */
-    public fun onRequestStart(socketEffect: SocketEffect?): Builder =
-      apply {
-        this.onRequestStart = socketEffect
-      }
-
-    /**
-     * Process the response without even attempting to reading the request body. For HTTP/2 this
-     * will close the response stream after the response body or trailers. For HTTP/1 this will
-     * close the socket after the response body or trailers.
-     */
-    public fun doNotReadRequestBody(): Builder =
-      apply {
-        doNotReadRequestBody = true
-        onResponseEnd = CloseStream(ErrorCode.NO_ERROR.httpCode)
-      }
-
-    /** Trigger [socketEffect] while reading the request body. */
-    public fun onRequestBody(socketEffect: SocketEffect?): Builder =
-      apply {
-        this.onRequestBody = socketEffect
-      }
-
-    /** Trigger [socketEffect] before the response headers are sent. */
-    public fun onResponseStart(socketEffect: SocketEffect?): Builder =
-      apply {
-        this.onResponseStart = socketEffect
-      }
-
-    /** Trigger [socketEffect] while writing the response body. */
-    public fun onResponseBody(socketEffect: SocketEffect?): Builder =
-      apply {
-        this.onResponseBody = socketEffect
-      }
-
-    /** Trigger [socketEffect] after writing the response body. */
-    public fun onResponseEnd(socketEffect: SocketEffect?): Builder =
-      apply {
-        this.onResponseEnd = socketEffect
-      }
-
-    public fun shutdownServer(shutdownServer: Boolean): Builder =
+    /** Sets the socket policy and returns this. */
+    public fun socketPolicy(socketPolicy: SocketPolicy): Builder =
       apply {
-        this.shutdownServer = shutdownServer
+        this.socketPolicy = socketPolicy
       }
 
     /**
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
index bf6b9295b..a77001e9c 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
@@ -50,10 +50,20 @@ import javax.net.ssl.SSLSocket
 import javax.net.ssl.SSLSocketFactory
 import javax.net.ssl.TrustManager
 import javax.net.ssl.X509TrustManager
-import mockwebserver3.SocketEffect.CloseSocket
-import mockwebserver3.SocketEffect.CloseStream
-import mockwebserver3.SocketEffect.ShutdownConnection
-import mockwebserver3.SocketEffect.Stall
+import mockwebserver3.SocketPolicy.DisconnectAfterRequest
+import mockwebserver3.SocketPolicy.DisconnectAtEnd
+import mockwebserver3.SocketPolicy.DisconnectAtStart
+import mockwebserver3.SocketPolicy.DisconnectDuringRequestBody
+import mockwebserver3.SocketPolicy.DisconnectDuringResponseBody
+import mockwebserver3.SocketPolicy.DoNotReadRequestBody
+import mockwebserver3.SocketPolicy.FailHandshake
+import mockwebserver3.SocketPolicy.HalfCloseAfterRequest
+import mockwebserver3.SocketPolicy.NoResponse
+import mockwebserver3.SocketPolicy.ResetStreamAtStart
+import mockwebserver3.SocketPolicy.ShutdownInputAtEnd
+import mockwebserver3.SocketPolicy.ShutdownOutputAtEnd
+import mockwebserver3.SocketPolicy.ShutdownServerAfterResponse
+import mockwebserver3.SocketPolicy.StallSocketAtStart
 import mockwebserver3.internal.DEFAULT_REQUEST_LINE_HTTP_1
 import mockwebserver3.internal.DEFAULT_REQUEST_LINE_HTTP_2
 import mockwebserver3.internal.RecordedRequest
@@ -386,8 +396,8 @@ public class MockWebServer : Closeable {
         return
       }
 
-      val peek = dispatcher.peek()
-      if (peek.onRequestStart is CloseSocket) {
+      val socketPolicy = dispatcher.peek().socketPolicy
+      if (socketPolicy === DisconnectAtStart) {
         dispatchBookkeepingRequest(
           connectionIndex = nextConnectionIndex++,
           exchangeIndex = 0,
@@ -396,7 +406,7 @@ public class MockWebServer : Closeable {
         socket.close()
       } else {
         openClientSockets.add(socket)
-        serveConnection(nextConnectionIndex++, socket, peek)
+        serveConnection(nextConnectionIndex++, socket)
       }
     }
   }
@@ -423,11 +433,10 @@ public class MockWebServer : Closeable {
   private fun serveConnection(
     connectionIndex: Int,
     raw: Socket,
-    firstExchangePeek: MockResponse,
   ) {
     taskRunner.newQueue().execute("MockWebServer ${raw.remoteSocketAddress}", cancelable = false) {
       try {
-        SocketHandler(connectionIndex, raw, firstExchangePeek).handle()
+        SocketHandler(connectionIndex, raw).handle()
       } catch (e: IOException) {
         logger.fine("$this connection from ${raw.inetAddress} failed: $e")
       } catch (e: Exception) {
@@ -439,7 +448,6 @@ public class MockWebServer : Closeable {
   internal inner class SocketHandler(
     private val connectionIndex: Int,
     private val raw: Socket,
-    private val firstExchangePeek: MockResponse,
   ) {
     private var nextExchangeIndex = 0
 
@@ -447,11 +455,12 @@ public class MockWebServer : Closeable {
     fun handle() {
       if (!processTunnelRequests()) return
 
+      val socketPolicy = dispatcher.peek().socketPolicy
       val protocol: Protocol
       val socket: Socket
       when {
         sslSocketFactory != null -> {
-          if (firstExchangePeek.failHandshake) {
+          if (socketPolicy === FailHandshake) {
             dispatchBookkeepingRequest(
               connectionIndex = connectionIndex,
               exchangeIndex = nextExchangeIndex++,
@@ -505,7 +514,7 @@ public class MockWebServer : Closeable {
         }
       }
 
-      if (firstExchangePeek.onRequestStart == Stall) {
+      if (socketPolicy === StallSocketAtStart) {
         dispatchBookkeepingRequest(
           connectionIndex = connectionIndex,
           exchangeIndex = nextExchangeIndex++,
@@ -584,7 +593,7 @@ public class MockWebServer : Closeable {
         return false // No more requests on this socket.
       }
 
-      val request = readRequest(socket, source, sink, connectionIndex, nextExchangeIndex++)
+      val request = readRequest(socket, source, sink, connectionIndex, nextExchangeIndex)
       atomicRequestCount.incrementAndGet()
       requestQueue.add(request)
 
@@ -593,41 +602,52 @@ public class MockWebServer : Closeable {
       }
 
       val response = dispatcher.dispatch(request)
+      if (response.socketPolicy === DisconnectAfterRequest) {
+        socket.close()
+        return false
+      }
+      if (response.socketPolicy === HalfCloseAfterRequest) {
+        socket.shutdownOutput()
+        return false
+      }
+      if (response.socketPolicy === NoResponse) {
+        // This read should block until the socket is closed. (Because nobody is writing.)
+        if (source.exhausted()) return false
+        throw ProtocolException("unexpected data")
+      }
 
-      try {
-        if (handleSocketEffect(response.onResponseStart, socket)) {
-          return false
-        }
-
-        var reuseSocket = true
-        val requestWantsWebSockets =
-          "Upgrade".equals(request.headers["Connection"], ignoreCase = true) &&
-            "websocket".equals(request.headers["Upgrade"], ignoreCase = true)
-        val responseWantsWebSockets = response.webSocketListener != null
-        if (requestWantsWebSockets && responseWantsWebSockets) {
-          handleWebSocketUpgrade(socket, source, sink, request, response)
-          reuseSocket = false
-        } else {
-          writeHttpResponse(socket, sink, response)
-        }
+      var reuseSocket = true
+      val requestWantsWebSockets =
+        "Upgrade".equals(request.headers["Connection"], ignoreCase = true) &&
+          "websocket".equals(request.headers["Upgrade"], ignoreCase = true)
+      val responseWantsWebSockets = response.webSocketListener != null
+      if (requestWantsWebSockets && responseWantsWebSockets) {
+        handleWebSocketUpgrade(socket, source, sink, request, response)
+        reuseSocket = false
+      } else {
+        writeHttpResponse(socket, sink, response)
+      }
 
-        if (logger.isLoggable(Level.FINE)) {
-          logger.fine(
-            "${this@MockWebServer} received request: $request and responded: $response",
-          )
-        }
+      if (logger.isLoggable(Level.FINE)) {
+        logger.fine(
+          "${this@MockWebServer} received request: $request and responded: $response",
+        )
+      }
 
-        // See warnings associated with these socket policies in SocketPolicy.
-        if (handleSocketEffect(response.onResponseEnd, socket)) {
+      // See warnings associated with these socket policies in SocketPolicy.
+      when (response.socketPolicy) {
+        DisconnectAtEnd, is DoNotReadRequestBody -> {
+          socket.close()
           return false
         }
-
-        return reuseSocket
-      } finally {
-        if (response.shutdownServer) {
-          close()
+        ShutdownInputAtEnd -> socket.shutdownInput()
+        ShutdownOutputAtEnd -> socket.shutdownOutput()
+        ShutdownServerAfterResponse -> close()
+        else -> {
         }
       }
+      nextExchangeIndex++
+      return reuseSocket
     }
   }
 
@@ -646,7 +666,7 @@ public class MockWebServer : Closeable {
     try {
       socket.startHandshake() // we're testing a handshake failure
       throw AssertionError()
-    } catch (_: IOException) {
+    } catch (expected: IOException) {
     }
     socket.close()
   }
@@ -721,17 +741,18 @@ public class MockWebServer : Closeable {
         writeHttpResponse(socket, sink, response)
       }
 
+      val policy = dispatcher.peek()
       val requestBodySink =
         requestBody
-          .withThrottlingAndSocketEffect(
-            policy = peek,
-            socketEffect = peek.onRequestBody,
+          .withThrottlingAndSocketPolicy(
+            policy = policy,
+            disconnectHalfway = policy.socketPolicy == DisconnectDuringRequestBody,
             expectedByteCount = contentLength,
             socket = socket,
           ).buffer()
       requestBodySink.use {
         when {
-          peek.doNotReadRequestBody -> {
+          policy.socketPolicy is DoNotReadRequestBody -> {
             hasBody = false // Ignore the body completely.
           }
 
@@ -868,9 +889,9 @@ public class MockWebServer : Closeable {
     socket.sleepWhileOpen(response.bodyDelayNanos)
     val responseBodySink =
       sink
-        .withThrottlingAndSocketEffect(
+        .withThrottlingAndSocketPolicy(
           policy = response,
-          socketEffect = response.onResponseBody,
+          disconnectHalfway = response.socketPolicy == DisconnectDuringResponseBody,
           expectedByteCount = body.contentLength,
           socket = socket,
         ).buffer()
@@ -899,12 +920,11 @@ public class MockWebServer : Closeable {
   }
 
   /** Returns a sink that applies throttling and disconnecting. */
-  private fun Sink.withThrottlingAndSocketEffect(
+  private fun Sink.withThrottlingAndSocketPolicy(
     policy: MockResponse,
-    socketEffect: SocketEffect?,
+    disconnectHalfway: Boolean,
     expectedByteCount: Long,
     socket: Socket,
-    stream: Http2Stream? = null,
   ): Sink {
     var result: Sink = this
 
@@ -918,7 +938,7 @@ public class MockWebServer : Closeable {
         )
     }
 
-    if (socketEffect != null) {
+    if (disconnectHalfway) {
       val halfwayByteCount =
         when {
           expectedByteCount != -1L -> expectedByteCount / 2
@@ -930,52 +950,11 @@ public class MockWebServer : Closeable {
           triggerByteCount = halfwayByteCount,
         ) {
           result.flush()
-          handleSocketEffect(socketEffect, socket, stream)
-        }
-    }
-
-    return result
-  }
-
-  /** Returns true if processing this exchange is complete. */
-  private fun handleSocketEffect(
-    effect: SocketEffect?,
-    socket: Socket,
-    stream: Http2Stream? = null,
-  ): Boolean {
-    if (effect == null) return false
-
-    when (effect) {
-      is CloseStream -> {
-        if (stream != null) {
-          stream.close(ErrorCode.fromHttp2(effect.http2ErrorCode)!!, null)
-        } else {
           socket.close()
         }
-      }
-
-      ShutdownConnection -> {
-        if (stream != null) {
-          stream.connection.shutdown(ErrorCode.NO_ERROR)
-        } else {
-          socket.close()
-        }
-      }
-
-      is CloseSocket -> {
-        if (effect.shutdownInput) socket.shutdownInput()
-        if (effect.shutdownOutput) socket.shutdownOutput()
-        if (effect.closeSocket) socket.close()
-      }
-
-      Stall -> {
-        // Sleep until the socket is closed.
-        socket.sleepWhileOpen(TimeUnit.MINUTES.toNanos(60))
-        error("expected timeout")
-      }
     }
 
-    return true
+    return result
   }
 
   @Throws(IOException::class)
@@ -1038,14 +1017,15 @@ public class MockWebServer : Closeable {
 
     @Throws(IOException::class)
     override fun onStream(stream: Http2Stream) {
-      val peek = dispatcher.peek()
-      if (handleSocketEffect(peek.onRequestStart, socket, stream)) {
+      val peekedResponse = dispatcher.peek()
+      if (peekedResponse.socketPolicy is ResetStreamAtStart) {
         dispatchBookkeepingRequest(
           connectionIndex = connectionIndex,
           exchangeIndex = nextExchangeIndex.getAndIncrement(),
           socket = socket,
           requestLine = DEFAULT_REQUEST_LINE_HTTP_2,
         )
+        stream.close(ErrorCode.fromHttp2(peekedResponse.socketPolicy.http2ErrorCode)!!, null)
         return
       }
 
@@ -1056,25 +1036,29 @@ public class MockWebServer : Closeable {
         return // Nothing to respond to.
       }
 
-      val response = dispatcher.dispatch(request)
+      val response: MockResponse = dispatcher.dispatch(request)
 
-      try {
-        if (handleSocketEffect(peek.onResponseStart, socket, stream)) {
-          return
-        }
+      val socketPolicy = response.socketPolicy
+      if (socketPolicy === DisconnectAfterRequest) {
+        socket.close()
+        return
+      }
+      writeResponse(stream, request, response)
+      if (logger.isLoggable(Level.FINE)) {
+        logger.fine(
+          "${this@MockWebServer} received request: $request " +
+            "and responded: $response protocol is $protocol",
+        )
+      }
 
-        writeResponse(stream, request, response)
-        if (logger.isLoggable(Level.FINE)) {
-          logger.fine(
-            "${this@MockWebServer} received request: $request " +
-              "and responded: $response protocol is $protocol",
-          )
+      when (socketPolicy) {
+        DisconnectAtEnd -> {
+          stream.connection.shutdown(ErrorCode.NO_ERROR)
         }
-
-        handleSocketEffect(peek.onResponseEnd, socket, stream)
-      } finally {
-        if (response.shutdownServer) {
-          close()
+        is DoNotReadRequestBody -> {
+          stream.close(ErrorCode.fromHttp2(socketPolicy.http2ErrorCode)!!, null)
+        }
+        else -> {
         }
       }
     }
@@ -1120,18 +1104,17 @@ public class MockWebServer : Closeable {
         )
       var exception: IOException? = null
       var bodyByteString: ByteString? = null
-      if (readBody && peek.socketHandler == null && !peek.doNotReadRequestBody) {
+      if (readBody && peek.socketHandler == null && peek.socketPolicy !is DoNotReadRequestBody) {
         val body = Buffer()
         try {
           val contentLengthString = headers["content-length"]
           val requestBodySink =
             body
-              .withThrottlingAndSocketEffect(
+              .withThrottlingAndSocketPolicy(
                 policy = peek,
-                socketEffect = peek.onRequestBody,
+                disconnectHalfway = peek.socketPolicy == DisconnectDuringRequestBody,
                 expectedByteCount = contentLengthString?.toLong() ?: Long.MAX_VALUE,
                 socket = socket,
-                stream = stream,
               ).buffer()
           requestBodySink.use {
             it.writeAll(stream.source)
@@ -1178,6 +1161,10 @@ public class MockWebServer : Closeable {
       val settings = response.settings
       stream.connection.setSettings(settings)
 
+      if (response.socketPolicy === NoResponse) {
+        return
+      }
+
       val bodyDelayNanos = response.bodyDelayNanos
       val trailers = response.trailers
       val body = response.body
@@ -1204,12 +1191,11 @@ public class MockWebServer : Closeable {
         val responseBodySink =
           stream
             .sink
-            .withThrottlingAndSocketEffect(
+            .withThrottlingAndSocketPolicy(
               policy = response,
-              socketEffect = response.onResponseBody,
+              disconnectHalfway = response.socketPolicy == DisconnectDuringResponseBody,
               expectedByteCount = body.contentLength,
               socket = socket,
-              stream = stream,
             ).buffer()
         responseBodySink.use {
           body.writeTo(it)
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/SocketEffect.kt b/mockwebserver/src/main/kotlin/mockwebserver3/SocketEffect.kt
deleted file mode 100644
index c04cf3a0c..000000000
--- a/mockwebserver/src/main/kotlin/mockwebserver3/SocketEffect.kt
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2025 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package mockwebserver3
-
-/**
- * An adverse action to take on a socket, intended to exercise failure modes in the calling code.
- */
-public sealed interface SocketEffect {
-  /**
-   * Close the TCP socket that carries this request.
-   *
-   * Using this as [MockResponse.onResponseEnd] is the default for HTTP/1.0.
-   */
-  public class CloseSocket(
-    public val closeSocket: Boolean = true,
-    public val shutdownInput: Boolean = false,
-    public val shutdownOutput: Boolean = false,
-  ) : SocketEffect
-
-  /**
-   * On HTTP/2, send a [GOAWAY frame](https://tools.ietf.org/html/rfc7540#section-6.8) immediately
-   * after the response and will close the connection when the client's socket is exhausted.
-   *
-   * On HTTP/1 this closes the socket.
-   */
-  public object ShutdownConnection : SocketEffect
-
-  /**
-   * On HTTP/2 this will send the error code on the stream.
-   *
-   * On HTTP/1 this closes the socket.
-   */
-  public class CloseStream(
-    public val http2ErrorCode: Int = 0,
-  ) : SocketEffect
-
-  /** Stop processing this. */
-  public object Stall : SocketEffect
-}
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/SocketPolicy.kt b/mockwebserver/src/main/kotlin/mockwebserver3/SocketPolicy.kt
new file mode 100644
index 000000000..5449c7df3
--- /dev/null
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/SocketPolicy.kt
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2011 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package mockwebserver3
+
+import okhttp3.ExperimentalOkHttpApi
+
+/**
+ * What should be done with the incoming socket.
+ *
+ * Be careful when using values like [DisconnectAtEnd], [ShutdownInputAtEnd]
+ * and [ShutdownOutputAtEnd] that close a socket after a response, and where there are
+ * follow-up requests. The client is unblocked and free to continue as soon as it has received the
+ * entire response body. If and when the client makes a subsequent request using a pooled socket the
+ * server may not have had time to close the socket. The socket will be closed at an indeterminate
+ * point before or during the second request. It may be closed after client has started sending the
+ * request body. If a request body is not retryable then the client may fail the request, making
+ * client behavior non-deterministic. Add delays in the client to improve the chances that the
+ * server has closed the socket before follow up requests are made.
+ */
+@ExperimentalOkHttpApi
+public sealed interface SocketPolicy {
+  /**
+   * Shutdown [MockWebServer] after writing response.
+   */
+  public object ShutdownServerAfterResponse : SocketPolicy
+
+  /**
+   * Keep the socket open after the response. This is the default HTTP/1.1 behavior.
+   */
+  public object KeepOpen : SocketPolicy
+
+  /**
+   * Close the socket after the response. This is the default HTTP/1.0 behavior. For HTTP/2
+   * connections, this sends a [GOAWAYframe](https://tools.ietf.org/html/rfc7540#section-6.8)
+   * immediately after the response and will close the connection when the client's socket
+   * is exhausted.
+   *
+   * See [SocketPolicy] for reasons why this can cause test flakiness and how to avoid it.
+   */
+  public object DisconnectAtEnd : SocketPolicy
+
+  /**
+   * Request immediate close of connection without even reading the request. Use to simulate buggy
+   * SSL servers closing connections in response to unrecognized TLS extensions.
+   */
+  public object DisconnectAtStart : SocketPolicy
+
+  /**
+   * Close connection after reading the request but before writing the response. Use this to
+   * simulate late connection pool failures.
+   */
+  public object DisconnectAfterRequest : SocketPolicy
+
+  /**
+   * Half close connection (InputStream for client) after reading the request but before
+   * writing the response. Use this to simulate late connection pool failures.
+   */
+  public object HalfCloseAfterRequest : SocketPolicy
+
+  /** Close connection after reading half of the request body (if present). */
+  public object DisconnectDuringRequestBody : SocketPolicy
+
+  /** Close connection after writing half of the response body (if present). */
+  public object DisconnectDuringResponseBody : SocketPolicy
+
+  /**
+   * Process the response without even attempting to reading the request body. For HTTP/2 this will
+   * send [http2ErrorCode] after the response body or trailers. For HTTP/1 this will close the
+   * socket after the response body or trailers.
+   */
+  public class DoNotReadRequestBody(
+    public val http2ErrorCode: Int = 0,
+  ) : SocketPolicy
+
+  /** Don't trust the client during the SSL handshake. */
+  public object FailHandshake : SocketPolicy
+
+  /**
+   * Shutdown the socket input after sending the response. For testing bad behavior.
+   *
+   * See [SocketPolicy] for reasons why this can cause test flakiness and how to avoid it.
+   */
+  public object ShutdownInputAtEnd : SocketPolicy
+
+  /**
+   * Shutdown the socket output after sending the response. For testing bad behavior.
+   *
+   * See [SocketPolicy] for reasons why this can cause test flakiness and how to avoid it.
+   */
+  public object ShutdownOutputAtEnd : SocketPolicy
+
+  /**
+   * After accepting the connection and doing TLS (if configured) don't do HTTP/1.1 or HTTP/2
+   * framing. Ignore the socket completely until the server is shut down.
+   */
+  public object StallSocketAtStart : SocketPolicy
+
+  /**
+   * Read the request but don't respond to it. Just keep the socket open. For testing read response
+   * header timeout issue.
+   */
+  public object NoResponse : SocketPolicy
+
+  /**
+   * Fail HTTP/2 requests without processing them by sending [http2ErrorCode].
+   */
+  @ExperimentalOkHttpApi
+  public class ResetStreamAtStart(
+    public val http2ErrorCode: Int = 0,
+  ) : SocketPolicy
+}
diff --git a/mockwebserver/src/test/java/mockwebserver3/MockWebServerTest.kt b/mockwebserver/src/test/java/mockwebserver3/MockWebServerTest.kt
index cc97a6825..851afd20a 100644
--- a/mockwebserver/src/test/java/mockwebserver3/MockWebServerTest.kt
+++ b/mockwebserver/src/test/java/mockwebserver3/MockWebServerTest.kt
@@ -40,7 +40,10 @@ import java.time.Duration
 import java.util.concurrent.TimeUnit
 import javax.net.ssl.HttpsURLConnection
 import kotlin.test.assertFailsWith
-import mockwebserver3.SocketEffect.CloseSocket
+import mockwebserver3.SocketPolicy.DisconnectAtStart
+import mockwebserver3.SocketPolicy.DisconnectDuringRequestBody
+import mockwebserver3.SocketPolicy.DisconnectDuringResponseBody
+import mockwebserver3.SocketPolicy.ShutdownServerAfterResponse
 import okhttp3.Headers
 import okhttp3.HttpUrl.Companion.toHttpUrl
 import okhttp3.OkHttpClient
@@ -295,7 +298,7 @@ class MockWebServerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .onRequestStart(CloseSocket())
+        .socketPolicy(DisconnectAtStart)
         .build(),
     )
     server.enqueue(MockResponse()) // The jdk's HttpUrlConnection is a bastard.
@@ -410,7 +413,7 @@ class MockWebServerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .onRequestBody(CloseSocket())
+        .socketPolicy(DisconnectDuringRequestBody)
         .build(),
     )
     // Limit the size of the request body that the server holds in memory to an arbitrary
@@ -447,7 +450,7 @@ class MockWebServerTest {
       MockResponse
         .Builder()
         .body("ab")
-        .onResponseBody(CloseSocket())
+        .socketPolicy(DisconnectDuringResponseBody)
         .build(),
     )
     val connection = server.url("/").toUrl().openConnection()
@@ -620,7 +623,7 @@ class MockWebServerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .shutdownServer(true)
+        .socketPolicy(ShutdownServerAfterResponse)
         .build(),
     )
     val url = server.url("/").toUrl()
@@ -862,7 +865,7 @@ class MockWebServerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .doNotReadRequestBody()
+        .socketPolicy(SocketPolicy.DoNotReadRequestBody())
         .build(),
     )
     val client = OkHttpClient()
diff --git a/okhttp-coroutines/src/test/kotlin/okhttp3/coroutines/ExecuteAsyncTest.kt b/okhttp-coroutines/src/test/kotlin/okhttp3/coroutines/ExecuteAsyncTest.kt
index 60d7bc48f..bf7c9e75e 100644
--- a/okhttp-coroutines/src/test/kotlin/okhttp3/coroutines/ExecuteAsyncTest.kt
+++ b/okhttp-coroutines/src/test/kotlin/okhttp3/coroutines/ExecuteAsyncTest.kt
@@ -34,7 +34,7 @@ import kotlinx.coroutines.withContext
 import kotlinx.coroutines.withTimeout
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect
+import mockwebserver3.SocketPolicy.DisconnectAfterRequest
 import mockwebserver3.junit5.StartStop
 import okhttp3.Callback
 import okhttp3.FailingCall
@@ -135,11 +135,10 @@ class ExecuteAsyncTest {
   fun failedCall() {
     runTest {
       server.enqueue(
-        MockResponse
-          .Builder()
-          .body("abc")
-          .onResponseStart(SocketEffect.ShutdownConnection)
-          .build(),
+        MockResponse(
+          body = "abc",
+          socketPolicy = DisconnectAfterRequest,
+        ),
       )
 
       val call = client.newCall(request)
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.kt b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.kt
index da0a5495e..0ef0f8c6d 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.kt
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.kt
@@ -22,6 +22,7 @@ import java.net.UnknownHostException
 import java.util.Arrays
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
+import mockwebserver3.SocketPolicy.FailHandshake
 import mockwebserver3.junit5.StartStop
 import okhttp3.HttpUrl
 import okhttp3.MediaType.Companion.toMediaType
@@ -204,7 +205,7 @@ class LoggingEventListenerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .failHandshake()
+        .socketPolicy(FailHandshake)
         .build(),
     )
     url = server.url("/")
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/CacheTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/CacheTest.kt
index 25a842777..5b6caec05 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/CacheTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/CacheTest.kt
@@ -40,7 +40,7 @@ import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
 import mockwebserver3.RecordedRequest
-import mockwebserver3.SocketEffect.ShutdownConnection
+import mockwebserver3.SocketPolicy.DisconnectAtEnd
 import mockwebserver3.junit5.StartStop
 import okhttp3.Cache.Companion.key
 import okhttp3.Headers.Companion.headersOf
@@ -3842,7 +3842,7 @@ CLEAN $urlKey ${entryMetadata.length} ${entryBody.length}
     numBytesToKeep: Int,
   ): MockResponse.Builder {
     val response = builder.build()
-    builder.onResponseEnd(ShutdownConnection)
+    builder.socketPolicy(DisconnectAtEnd)
     val headers = response.headers
     val fullBody = Buffer()
     response.body!!.writeTo(fullBody)
@@ -3879,7 +3879,7 @@ CLEAN $urlKey ${entryMetadata.length} ${entryBody.length}
         chunkSize: Int,
       ) {
         response.body(content)
-        response.onResponseEnd(ShutdownConnection)
+        response.socketPolicy(DisconnectAtEnd)
         response.removeHeader("Content-Length")
       }
     }, ;
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/CallKotlinTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/CallKotlinTest.kt
index 887a209f8..ccacf3e46 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/CallKotlinTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/CallKotlinTest.kt
@@ -26,7 +26,8 @@ import java.time.Duration
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect.CloseSocket
+import mockwebserver3.SocketPolicy.DisconnectAtStart
+import mockwebserver3.SocketPolicy.ShutdownOutputAtEnd
 import mockwebserver3.junit5.StartStop
 import okhttp3.Headers.Companion.headersOf
 import okhttp3.MediaType.Companion.toMediaType
@@ -198,15 +199,10 @@ class CallKotlinTest {
         ).build()
 
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("a")
-        .onResponseEnd(
-          CloseSocket(
-            closeSocket = false,
-            shutdownOutput = true,
-          ),
-        ).build(),
+      MockResponse(
+        body = "a",
+        socketPolicy = ShutdownOutputAtEnd,
+      ),
     )
     server.enqueue(MockResponse(body = "b"))
 
@@ -259,8 +255,8 @@ class CallKotlinTest {
 
   /** Confirm suppressed exceptions that occur after connecting are returned. */
   @Test fun httpExceptionsAreReturnedAsSuppressed() {
-    server.enqueue(MockResponse.Builder().onRequestStart(CloseSocket()).build())
-    server.enqueue(MockResponse.Builder().onRequestStart(CloseSocket()).build())
+    server.enqueue(MockResponse(socketPolicy = DisconnectAtStart))
+    server.enqueue(MockResponse(socketPolicy = DisconnectAtStart))
 
     client =
       client
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/CallTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/CallTest.kt
index 99f250bae..aa135ebff 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/CallTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/CallTest.kt
@@ -72,9 +72,13 @@ import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
 import mockwebserver3.QueueDispatcher
 import mockwebserver3.RecordedRequest
-import mockwebserver3.SocketEffect.CloseSocket
-import mockwebserver3.SocketEffect.ShutdownConnection
-import mockwebserver3.SocketEffect.Stall
+import mockwebserver3.SocketPolicy.DisconnectAfterRequest
+import mockwebserver3.SocketPolicy.DisconnectAtEnd
+import mockwebserver3.SocketPolicy.DisconnectAtStart
+import mockwebserver3.SocketPolicy.FailHandshake
+import mockwebserver3.SocketPolicy.HalfCloseAfterRequest
+import mockwebserver3.SocketPolicy.NoResponse
+import mockwebserver3.SocketPolicy.StallSocketAtStart
 import mockwebserver3.junit5.StartStop
 import okhttp3.CallEvent.CallEnd
 import okhttp3.CallEvent.ConnectStart
@@ -542,12 +546,11 @@ open class CallTest {
   @Test
   fun authenticateWithNoConnection() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(401)
-        .addHeader("Connection", "close")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 401,
+        headers = headersOf("Connection", "close"),
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     val authenticator = RecordingOkAuthenticator(null, null)
     client =
@@ -1013,7 +1016,7 @@ open class CallTest {
   @Test
   fun tlsTimeoutsNotRetried() {
     enableTls()
-    server.enqueue(MockResponse.Builder().onResponseStart(Stall).build())
+    server.enqueue(MockResponse(socketPolicy = NoResponse))
     server.enqueue(MockResponse(body = "unreachable!"))
     client =
       client
@@ -1059,7 +1062,7 @@ open class CallTest {
   /** https://github.com/square/okhttp/issues/4875  */
   @Test
   fun interceptorRecoversWhenRoutesExhausted() {
-    server.enqueue(MockResponse.Builder().onRequestStart(CloseSocket()).build())
+    server.enqueue(MockResponse(socketPolicy = DisconnectAtStart))
     server.enqueue(MockResponse())
     client =
       client
@@ -1112,7 +1115,7 @@ open class CallTest {
    */
   @Test
   fun readTimeoutFails() {
-    server.enqueue(MockResponse.Builder().onRequestStart(Stall).build())
+    server.enqueue(MockResponse(socketPolicy = StallSocketAtStart))
     server2.enqueue(
       MockResponse(body = "success!"),
     )
@@ -1252,14 +1255,14 @@ open class CallTest {
     val dispatcher: QueueDispatcher =
       object : QueueDispatcher() {
         override fun dispatch(request: RecordedRequest): MockResponse {
-          if (peek().onResponseStart is CloseSocket) {
+          if (peek().socketPolicy === DisconnectAfterRequest) {
             requestFinished.await()
           }
           return super.dispatch(request)
         }
       }
     dispatcher.enqueue(MockResponse(body = "seed connection pool"))
-    dispatcher.enqueue(MockResponse.Builder().onResponseStart(CloseSocket()).build())
+    dispatcher.enqueue(MockResponse(socketPolicy = DisconnectAfterRequest))
     dispatcher.enqueue(MockResponse(body = "retry success"))
     server.dispatcher = dispatcher
     listener =
@@ -1303,7 +1306,7 @@ open class CallTest {
   @Test
   fun noRecoverWhenRetryOnConnectionFailureIsFalse() {
     server.enqueue(MockResponse(body = "seed connection pool"))
-    server.enqueue(MockResponse.Builder().onResponseStart(CloseSocket()).build())
+    server.enqueue(MockResponse(socketPolicy = DisconnectAfterRequest))
     server.enqueue(MockResponse(body = "unreachable!"))
     client =
       client
@@ -1334,7 +1337,7 @@ open class CallTest {
     platform.assumeNotBouncyCastle()
 
     server.useHttps(handshakeCertificates.sslSocketFactory())
-    server.enqueue(MockResponse.Builder().failHandshake().build())
+    server.enqueue(MockResponse(socketPolicy = FailHandshake))
     server.enqueue(MockResponse(body = "response that will never be received"))
     val response = executeSynchronously("/")
     response.assertFailure(
@@ -1353,7 +1356,7 @@ open class CallTest {
     platform.assumeNotBouncyCastle()
 
     server.useHttps(handshakeCertificates.sslSocketFactory())
-    server.enqueue(MockResponse.Builder().failHandshake().build())
+    server.enqueue(MockResponse(socketPolicy = FailHandshake))
     server.enqueue(MockResponse(body = "abc"))
     client =
       client
@@ -1382,7 +1385,7 @@ open class CallTest {
       return
     }
     server.useHttps(handshakeCertificates.sslSocketFactory())
-    server.enqueue(MockResponse.Builder().failHandshake().build())
+    server.enqueue(MockResponse(socketPolicy = FailHandshake))
     val clientSocketFactory =
       RecordingSSLSocketFactory(
         handshakeCertificates.sslSocketFactory(),
@@ -1414,7 +1417,7 @@ open class CallTest {
     platform.assumeNotBouncyCastle()
 
     server.useHttps(handshakeCertificates.sslSocketFactory())
-    server.enqueue(MockResponse.Builder().failHandshake().build())
+    server.enqueue(MockResponse(socketPolicy = FailHandshake))
     server.enqueue(MockResponse(body = "abc"))
     client =
       client
@@ -1446,7 +1449,7 @@ open class CallTest {
           handshakeCertificates.trustManager,
         ).build()
     server.useHttps(handshakeCertificates.sslSocketFactory())
-    server.enqueue(MockResponse.Builder().failHandshake().build())
+    server.enqueue(MockResponse(socketPolicy = FailHandshake))
     val request = Request.Builder().url(server.url("/")).build()
     assertFailsWith<IOException> {
       client.newCall(request).execute()
@@ -1680,16 +1683,7 @@ open class CallTest {
   @Test
   fun serverHalfClosingBeforeResponse() {
     server.enqueue(MockResponse(body = "abc"))
-    server.enqueue(
-      MockResponse
-        .Builder()
-        .onResponseStart(
-          CloseSocket(
-            closeSocket = false,
-            shutdownOutput = true,
-          ),
-        ).build(),
-    )
+    server.enqueue(MockResponse(socketPolicy = HalfCloseAfterRequest))
     server.enqueue(MockResponse(body = "abc"))
 
     val client =
@@ -1770,7 +1764,7 @@ open class CallTest {
   @Test
   fun postBodyRetransmittedOnFailureRecovery() {
     server.enqueue(MockResponse(body = "abc"))
-    server.enqueue(MockResponse.Builder().onResponseStart(CloseSocket()).build())
+    server.enqueue(MockResponse(socketPolicy = DisconnectAfterRequest))
     server.enqueue(MockResponse(body = "def"))
 
     // Seed the connection pool so we have something that can fail.
@@ -2216,13 +2210,12 @@ open class CallTest {
   @Test
   fun getClientRequestTimeout() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(408)
-        .addHeader("Connection", "Close")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 408,
+        headers = headersOf("Connection", "Close"),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(MockResponse(body = "Body"))
     val request = Request(server.url("/"))
@@ -2233,14 +2226,18 @@ open class CallTest {
   @Test
   fun getClientRequestTimeoutWithBackPressure() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(408)
-        .addHeader("Connection", "Close")
-        .addHeader("Retry-After", "1")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 408,
+        headers =
+          headersOf(
+            "Connection",
+            "Close",
+            "Retry-After",
+            "1",
+          ),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     val request = Request(server.url("/"))
     val response = client.newCall(request).execute()
@@ -2250,13 +2247,12 @@ open class CallTest {
   @Test
   fun requestBodyRetransmittedOnClientRequestTimeout() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(408)
-        .addHeader("Connection", "Close")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 408,
+        headers = headersOf("Connection", "Close"),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(MockResponse(body = "Body"))
     val request =
@@ -2275,13 +2271,12 @@ open class CallTest {
   @Test
   fun disableClientRequestTimeoutRetry() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(408)
-        .addHeader("Connection", "Close")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 408,
+        headers = headersOf("Connection", "Close"),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     client =
       client
@@ -2297,22 +2292,20 @@ open class CallTest {
   @Test
   fun maxClientRequestTimeoutRetries() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(408)
-        .addHeader("Connection", "Close")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 408,
+        headers = headersOf("Connection", "Close"),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(408)
-        .addHeader("Connection", "Close")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 408,
+        headers = headersOf("Connection", "Close"),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     val request = Request(server.url("/"))
     val response = client.newCall(request).execute()
@@ -2324,24 +2317,32 @@ open class CallTest {
   @Test
   fun maxUnavailableTimeoutRetries() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(503)
-        .addHeader("Connection", "Close")
-        .addHeader("Retry-After", "0")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 503,
+        headers =
+          headersOf(
+            "Connection",
+            "Close",
+            "Retry-After",
+            "0",
+          ),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(503)
-        .addHeader("Connection", "Close")
-        .addHeader("Retry-After", "0")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 503,
+        headers =
+          headersOf(
+            "Connection",
+            "Close",
+            "Retry-After",
+            "0",
+          ),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     val request = Request(server.url("/"))
     val response = client.newCall(request).execute()
@@ -2353,14 +2354,18 @@ open class CallTest {
   @Test
   fun retryOnUnavailableWith0RetryAfter() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(503)
-        .addHeader("Connection", "Close")
-        .addHeader("Retry-After", "0")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 503,
+        headers =
+          headersOf(
+            "Connection",
+            "Close",
+            "Retry-After",
+            "0",
+          ),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(MockResponse(body = "Body"))
     val request = Request(server.url("/"))
@@ -2781,7 +2786,7 @@ open class CallTest {
 
   /** Cancel a call that's waiting for connect to complete.  */
   private fun cancelDuringConnect(scheme: String?) {
-    server.enqueue(MockResponse.Builder().onRequestStart(Stall).build())
+    server.enqueue(MockResponse(socketPolicy = StallSocketAtStart))
     val cancelDelayMillis = 300L
     val call =
       client.newCall(
@@ -3268,7 +3273,7 @@ open class CallTest {
   @Tag("Slowish")
   @Test
   fun expect100ContinueTimesOutWithoutContinue() {
-    server.enqueue(MockResponse.Builder().onResponseStart(Stall).build())
+    server.enqueue(MockResponse(socketPolicy = NoResponse))
     client =
       client
         .newBuilder()
@@ -3690,7 +3695,7 @@ open class CallTest {
         .Builder()
         .body("abc")
         .setHeader("Content-Length", "5")
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(DisconnectAtEnd)
         .build(),
     )
     val hostnameVerifier = RecordingHostnameVerifier()
@@ -4014,7 +4019,7 @@ open class CallTest {
       MockResponse
         .Builder()
         .inTunnel()
-        .onResponseStart(CloseSocket())
+        .socketPolicy(DisconnectAfterRequest)
         .build(),
     )
     client =
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/ConnectionListenerTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/ConnectionListenerTest.kt
index a21950b83..031c904e1 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/ConnectionListenerTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/ConnectionListenerTest.kt
@@ -35,6 +35,7 @@ import java.util.concurrent.TimeUnit
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
+import mockwebserver3.SocketPolicy.FailHandshake
 import mockwebserver3.junit5.StartStop
 import okhttp3.Headers.Companion.headersOf
 import okhttp3.internal.DoubleInetAddressDns
@@ -257,7 +258,7 @@ open class ConnectionListenerTest {
   @Throws(UnknownHostException::class)
   fun failedConnect() {
     enableTls()
-    server!!.enqueue(MockResponse.Builder().failHandshake().build())
+    server!!.enqueue(MockResponse(socketPolicy = FailHandshake))
     val call =
       client.newCall(
         Request
@@ -283,7 +284,7 @@ open class ConnectionListenerTest {
   @Throws(IOException::class)
   fun multipleConnectsForSingleCall() {
     enableTls()
-    server!!.enqueue(MockResponse.Builder().failHandshake().build())
+    server!!.enqueue(MockResponse(socketPolicy = FailHandshake))
     server!!.enqueue(MockResponse())
     client =
       client
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/ConnectionReuseTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/ConnectionReuseTest.kt
index 7162f1d05..a4d903b4c 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/ConnectionReuseTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/ConnectionReuseTest.kt
@@ -23,8 +23,8 @@ import javax.net.ssl.SSLException
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect.CloseSocket
-import mockwebserver3.SocketEffect.ShutdownConnection
+import mockwebserver3.SocketPolicy.DisconnectAfterRequest
+import mockwebserver3.SocketPolicy.DisconnectAtEnd
 import mockwebserver3.junit5.StartStop
 import okhttp3.Headers.Companion.headersOf
 import okhttp3.MediaType.Companion.toMediaType
@@ -118,7 +118,7 @@ class ConnectionReuseTest {
         .Builder()
         .body("a")
         .clearHeaders()
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(DisconnectAtEnd)
         .build(),
     )
     server.enqueue(MockResponse(body = "b"))
@@ -188,7 +188,7 @@ class ConnectionReuseTest {
   @Test
   fun silentRetryWhenIdempotentRequestFailsOnReusedConnection() {
     server.enqueue(MockResponse(body = "a"))
-    server.enqueue(MockResponse.Builder().onResponseStart(CloseSocket()).build())
+    server.enqueue(MockResponse(socketPolicy = DisconnectAfterRequest))
     server.enqueue(MockResponse(body = "b"))
     val request = Request(server.url("/"))
     val responseA = client.newCall(request).execute()
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/EventListenerTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/EventListenerTest.kt
index 5ad9aba78..26467918a 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/EventListenerTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/EventListenerTest.kt
@@ -43,7 +43,9 @@ import java.util.concurrent.TimeUnit
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect.CloseSocket
+import mockwebserver3.SocketPolicy.DisconnectDuringRequestBody
+import mockwebserver3.SocketPolicy.DisconnectDuringResponseBody
+import mockwebserver3.SocketPolicy.FailHandshake
 import mockwebserver3.junit5.StartStop
 import okhttp3.CallEvent.CallEnd
 import okhttp3.CallEvent.CallFailed
@@ -322,7 +324,7 @@ class EventListenerTest {
         .Builder()
         .body("0123456789")
         .throttleBody(2, 100, TimeUnit.MILLISECONDS)
-        .onResponseBody(CloseSocket())
+        .socketPolicy(DisconnectDuringResponseBody)
         .build(),
     )
     client =
@@ -854,7 +856,7 @@ class EventListenerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .failHandshake()
+        .socketPolicy(FailHandshake)
         .build(),
     )
     val call =
@@ -886,7 +888,7 @@ class EventListenerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .failHandshake()
+        .socketPolicy(FailHandshake)
         .build(),
     )
     server.enqueue(MockResponse())
@@ -1049,7 +1051,7 @@ class EventListenerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .failHandshake()
+        .socketPolicy(FailHandshake)
         .build(),
     )
     val call =
@@ -1107,7 +1109,7 @@ class EventListenerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .failHandshake()
+        .socketPolicy(FailHandshake)
         .build(),
     )
     server.enqueue(MockResponse())
@@ -1307,7 +1309,7 @@ class EventListenerTest {
       MockResponse
         .Builder()
         .body(Buffer().write(ByteArray(responseBodySize)))
-        .onResponseBody(CloseSocket())
+        .socketPolicy(DisconnectDuringResponseBody)
         .build(),
     )
     val call =
@@ -1337,7 +1339,7 @@ class EventListenerTest {
         .Builder()
         .body("")
         .bodyDelay(1, TimeUnit.SECONDS)
-        .onResponseBody(CloseSocket())
+        .socketPolicy(DisconnectDuringResponseBody)
         .build(),
     )
     val call =
@@ -1416,7 +1418,7 @@ class EventListenerTest {
         .Builder()
         .body("abc")
         .bodyDelay(1, TimeUnit.SECONDS)
-        .onResponseBody(CloseSocket())
+        .socketPolicy(DisconnectDuringResponseBody)
         .build(),
     )
     val call =
@@ -1473,7 +1475,7 @@ class EventListenerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .onRequestBody(CloseSocket())
+        .socketPolicy(DisconnectDuringRequestBody)
         .build(),
     )
     val request = NonCompletingRequestBody()
@@ -1547,7 +1549,7 @@ class EventListenerTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .onRequestBody(CloseSocket())
+        .socketPolicy(DisconnectDuringRequestBody)
         .build(),
     )
     val call =
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/FastFallbackTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/FastFallbackTest.kt
index 92e6171c2..d8d5886a8 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/FastFallbackTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/FastFallbackTest.kt
@@ -30,7 +30,7 @@ import javax.net.SocketFactory
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect.CloseStream
+import mockwebserver3.SocketPolicy.ResetStreamAtStart
 import okhttp3.internal.http2.ErrorCode
 import okhttp3.testing.Flaky
 import org.junit.jupiter.api.AfterEach
@@ -309,10 +309,7 @@ class FastFallbackTest {
 
     // Set up a same-connection retry.
     serverIpv4.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     serverIpv4.enqueue(
       MockResponse(body = "this was the 2nd request on IPv4"),
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/InterceptorTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/InterceptorTest.kt
index 22f1ceaf5..0cd0e823d 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/InterceptorTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/InterceptorTest.kt
@@ -36,7 +36,7 @@ import java.util.concurrent.atomic.AtomicReference
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect.ShutdownConnection
+import mockwebserver3.SocketPolicy.DisconnectAtEnd
 import mockwebserver3.junit5.StartStop
 import okhttp3.MediaType.Companion.toMediaType
 import okhttp3.RequestBody.Companion.toRequestBody
@@ -653,7 +653,7 @@ class InterceptorTest {
     server.enqueue(
       MockResponse
         .Builder()
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(DisconnectAtEnd)
         .addHeader("Connection", "Close")
         .build(),
     )
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/RouteFailureTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/RouteFailureTest.kt
index ece701a30..81aaadbe2 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/RouteFailureTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/RouteFailureTest.kt
@@ -26,7 +26,7 @@ import java.net.Proxy
 import java.net.SocketTimeoutException
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect.CloseStream
+import mockwebserver3.SocketPolicy.ResetStreamAtStart
 import mockwebserver3.junit5.StartStop
 import okhttp3.internal.http.RecordingProxySelector
 import okhttp3.internal.http2.ErrorCode
@@ -63,10 +63,9 @@ class RouteFailureTest {
   val ipv6 = InetAddress.getByName("2001:db8:ffff:ffff:ffff:ffff:ffff:1")
 
   val refusedStream =
-    MockResponse
-      .Builder()
-      .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-      .build()
+    MockResponse(
+      socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode),
+    )
   val bodyResponse = MockResponse(body = "body")
 
   @BeforeEach
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/ServerTruncatesRequestTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/ServerTruncatesRequestTest.kt
index 723a30293..76f228d7d 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/ServerTruncatesRequestTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/ServerTruncatesRequestTest.kt
@@ -24,9 +24,11 @@ import javax.net.ssl.SSLSocket
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
+import mockwebserver3.SocketPolicy.DoNotReadRequestBody
 import mockwebserver3.junit5.StartStop
 import okhttp3.Headers.Companion.headersOf
 import okhttp3.internal.duplex.AsyncRequestBody
+import okhttp3.internal.http2.ErrorCode
 import okhttp3.testing.PlatformRule
 import okio.BufferedSink
 import okio.IOException
@@ -80,11 +82,10 @@ class ServerTruncatesRequestTest {
 
   private fun serverTruncatesRequestOnLongPost(https: Boolean) {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("abc")
-        .doNotReadRequestBody()
-        .build(),
+      MockResponse(
+        body = "abc",
+        socketPolicy = DoNotReadRequestBody(ErrorCode.NO_ERROR.httpCode),
+      ),
     )
 
     val call =
@@ -140,11 +141,10 @@ class ServerTruncatesRequestTest {
     enableProtocol(Protocol.HTTP_2)
 
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("abc")
-        .doNotReadRequestBody()
-        .build(),
+      MockResponse(
+        body = "abc",
+        socketPolicy = DoNotReadRequestBody(ErrorCode.NO_ERROR.httpCode),
+      ),
     )
 
     val requestBody = AsyncRequestBody()
@@ -187,7 +187,7 @@ class ServerTruncatesRequestTest {
     val mockResponse =
       MockResponse
         .Builder()
-        .doNotReadRequestBody()
+        .socketPolicy(DoNotReadRequestBody(ErrorCode.NO_ERROR.httpCode))
         .trailers(headersOf("caboose", "xyz"))
 
     // Trailers always work for HTTP/2, but only for chunked bodies in HTTP/1.
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/TrailersTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/TrailersTest.kt
index 76140182e..aec5adfbb 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/TrailersTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/TrailersTest.kt
@@ -31,8 +31,7 @@ import kotlin.time.Duration.Companion.milliseconds
 import kotlin.time.measureTime
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect.CloseSocket
-import mockwebserver3.SocketEffect.ShutdownConnection
+import mockwebserver3.SocketPolicy
 import mockwebserver3.junit5.StartStop
 import okhttp3.Headers.Companion.headersOf
 import okhttp3.testing.PlatformRule
@@ -251,7 +250,7 @@ open class TrailersTest {
         .Builder()
         .trailers(headersOf("t1", "v2"))
         .body(protocol, "Hello")
-        .onResponseBody(CloseSocket())
+        .socketPolicy(SocketPolicy.DisconnectDuringResponseBody)
         .build(),
     )
 
@@ -362,7 +361,7 @@ open class TrailersTest {
         .Builder()
         .body("Hello")
         .removeHeader("Content-Length")
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(SocketPolicy.DisconnectAtEnd)
         .build(),
     )
 
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/URLConnectionTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/URLConnectionTest.kt
index b737c9440..8ec83e90f 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/URLConnectionTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/URLConnectionTest.kt
@@ -70,8 +70,11 @@ import javax.net.ssl.X509TrustManager
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect.CloseSocket
-import mockwebserver3.SocketEffect.ShutdownConnection
+import mockwebserver3.SocketPolicy
+import mockwebserver3.SocketPolicy.DisconnectAtEnd
+import mockwebserver3.SocketPolicy.FailHandshake
+import mockwebserver3.SocketPolicy.ShutdownInputAtEnd
+import mockwebserver3.SocketPolicy.ShutdownOutputAtEnd
 import mockwebserver3.junit5.StartStop
 import okhttp3.Credentials.basic
 import okhttp3.Headers.Companion.headersOf
@@ -366,43 +369,17 @@ class URLConnectionTest {
 
   @Test
   fun serverClosesSocket() {
-    testServerClosesOutput(
-      MockResponse
-        .Builder()
-        .body("This connection won't pool properly")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
-    )
+    testServerClosesOutput(DisconnectAtEnd)
   }
 
   @Test
   fun serverShutdownInput() {
-    testServerClosesOutput(
-      MockResponse
-        .Builder()
-        .body("This connection won't pool properly")
-        .onResponseEnd(
-          CloseSocket(
-            closeSocket = false,
-            shutdownInput = true,
-          ),
-        ).build(),
-    )
+    testServerClosesOutput(ShutdownInputAtEnd)
   }
 
   @Test
   fun serverShutdownOutput() {
-    testServerClosesOutput(
-      MockResponse
-        .Builder()
-        .body("This connection won't pool properly")
-        .onResponseEnd(
-          CloseSocket(
-            closeSocket = false,
-            shutdownOutput = true,
-          ),
-        ).build(),
-    )
+    testServerClosesOutput(ShutdownOutputAtEnd)
   }
 
   @Test
@@ -423,8 +400,13 @@ class URLConnectionTest {
     }
   }
 
-  private fun testServerClosesOutput(mockResponse: MockResponse) {
-    server.enqueue(mockResponse)
+  private fun testServerClosesOutput(socketPolicy: SocketPolicy) {
+    server.enqueue(
+      MockResponse(
+        body = "This connection won't pool properly",
+        socketPolicy = socketPolicy,
+      ),
+    )
     val responseAfter = MockResponse(body = "This comes after a busted connection")
     server.enqueue(responseAfter)
     server.enqueue(responseAfter) // Enqueue 2x because the broken connection may be reused.
@@ -654,7 +636,7 @@ class URLConnectionTest {
     platform.assumeNotBouncyCastle()
 
     server.useHttps(handshakeCertificates.sslSocketFactory())
-    server.enqueue(MockResponse.Builder().failHandshake().build())
+    server.enqueue(MockResponse(socketPolicy = FailHandshake))
     server.enqueue(MockResponse(body = "this response comes via SSL"))
     client =
       client
@@ -681,8 +663,8 @@ class URLConnectionTest {
     platform.assumeNotBouncyCastle()
 
     server.useHttps(handshakeCertificates.sslSocketFactory())
-    server.enqueue(MockResponse.Builder().failHandshake().build())
-    server.enqueue(MockResponse.Builder().failHandshake().build())
+    server.enqueue(MockResponse(socketPolicy = FailHandshake))
+    server.enqueue(MockResponse(socketPolicy = FailHandshake))
     client =
       client
         .newBuilder()
@@ -711,11 +693,10 @@ class URLConnectionTest {
   fun sslFallbackNotUsedWhenRecycledConnectionFails() {
     server.useHttps(handshakeCertificates.sslSocketFactory())
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("abc")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        body = "abc",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(MockResponse(body = "def"))
     client =
@@ -820,7 +801,7 @@ class URLConnectionTest {
         .Builder()
         .body("abc")
         .setHeader("Content-Length", "5")
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(DisconnectAtEnd)
         .build(),
     )
     assertFailsWith<ProtocolException> {
@@ -926,7 +907,7 @@ class URLConnectionTest {
     builder.body(truncatedBody)
     builder.clearHeaders()
     builder.addHeader("Transfer-encoding: chunked")
-    builder.onResponseEnd(ShutdownConnection)
+    builder.socketPolicy(DisconnectAtEnd)
     server.enqueue(builder.build())
     assertFailsWith<IOException> {
       val response = getResponse(newRequest("/"))
@@ -1452,7 +1433,7 @@ class URLConnectionTest {
         .body("5")
         .clearHeaders()
         .addHeader("Transfer-encoding: chunked")
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(DisconnectAtEnd)
         .build(),
     )
     assertFailsWith<IOException> {
@@ -1605,15 +1586,10 @@ class URLConnectionTest {
   @Test
   fun transparentGzipWorksAfterExceptionRecovery() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("a")
-        .onResponseEnd(
-          CloseSocket(
-            closeSocket = false,
-            shutdownInput = true,
-          ),
-        ).build(),
+      MockResponse(
+        body = "a",
+        socketPolicy = ShutdownInputAtEnd,
+      ),
     )
     server.enqueue(
       MockResponse
@@ -1644,7 +1620,7 @@ class URLConnectionTest {
         .Builder()
         .body("{}")
         .clearHeaders()
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(DisconnectAtEnd)
         .build(),
     )
     val response = getResponse(newRequest("/"))
@@ -2975,13 +2951,12 @@ class URLConnectionTest {
 
   private fun enqueueClientRequestTimeoutResponses() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
-        .addHeader("Connection", "Close")
-        .body("You took too long!")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = HttpURLConnection.HTTP_CLIENT_TIMEOUT,
+        headers = headersOf("Connection", "Close"),
+        body = "You took too long!",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(
       MockResponse(body = "Body"),
@@ -3190,16 +3165,11 @@ class URLConnectionTest {
   @Test
   fun sameConnectionRedirectAndReuse() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location", "/foo")
-        .onResponseEnd(
-          CloseSocket(
-            closeSocket = false,
-            shutdownInput = true,
-          ),
-        ).build(),
+      MockResponse(
+        code = HttpURLConnection.HTTP_MOVED_TEMP,
+        headers = headersOf("Location", "/foo"),
+        socketPolicy = ShutdownInputAtEnd,
+      ),
     )
     server.enqueue(MockResponse(body = "This is the new page!"))
     assertContent("This is the new page!", getResponse(newRequest("/")))
@@ -3291,7 +3261,7 @@ class URLConnectionTest {
 
   @Test
   fun getHeadersThrows() {
-    server.enqueue(MockResponse.Builder().onRequestStart(CloseSocket()).build())
+    server.enqueue(MockResponse(socketPolicy = SocketPolicy.DisconnectAtStart))
     assertFailsWith<IOException> {
       getResponse(newRequest("/"))
     }
@@ -3341,7 +3311,7 @@ class URLConnectionTest {
         .body("ABC")
         .clearHeaders()
         .addHeader("Connection: close")
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(DisconnectAtEnd)
         .build(),
     )
     val response = getResponse(newRequest("/"))
@@ -3508,11 +3478,10 @@ class URLConnectionTest {
     requestSize: Int,
   ) {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("A")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        body = "A",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(MockResponse(body = "B"))
     server.enqueue(MockResponse(body = "C"))
@@ -3552,7 +3521,7 @@ class URLConnectionTest {
   @Test
   fun postBodyRetransmittedOnFailureRecovery() {
     server.enqueue(MockResponse(body = "abc"))
-    server.enqueue(MockResponse.Builder().onResponseStart(CloseSocket()).build())
+    server.enqueue(MockResponse(socketPolicy = SocketPolicy.DisconnectAfterRequest))
     server.enqueue(MockResponse(body = "def"))
 
     // Seed the connection pool so we have something that can fail.
@@ -4068,7 +4037,7 @@ class URLConnectionTest {
     platform.assumeNotBouncyCastle()
 
     server.useHttps(handshakeCertificates.sslSocketFactory())
-    server.enqueue(MockResponse.Builder().failHandshake().build())
+    server.enqueue(MockResponse(socketPolicy = FailHandshake))
     server.enqueue(MockResponse(body = "Response that would have needed fallbacks"))
     client =
       client
@@ -4261,11 +4230,10 @@ class URLConnectionTest {
     platform.assumeHttp2Support()
     enableProtocol(Protocol.HTTP_2)
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("abc")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        body = "abc",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(
       MockResponse(body = "def"),
@@ -4296,12 +4264,11 @@ class URLConnectionTest {
   @Test
   fun authenticateNoConnection() {
     server.enqueue(
-      MockResponse
-        .Builder()
-        .code(401)
-        .addHeader("Connection", "close")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        code = 401,
+        headers = headersOf("Connection", "close"),
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     java.net.Authenticator.setDefault(RecordingAuthenticator(null))
     client =
@@ -4386,7 +4353,7 @@ class URLConnectionTest {
         chunkSize: Int,
       ) {
         response.body(content!!)
-        response.onResponseEnd(ShutdownConnection)
+        response.socketPolicy(DisconnectAtEnd)
         response.removeHeader("Content-Length")
       }
 
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/internal/http2/HttpOverHttp2Test.kt b/okhttp/src/jvmTest/kotlin/okhttp3/internal/http2/HttpOverHttp2Test.kt
index b6de0ac91..eb4c8e25d 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/internal/http2/HttpOverHttp2Test.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/internal/http2/HttpOverHttp2Test.kt
@@ -45,9 +45,10 @@ import mockwebserver3.MockWebServer
 import mockwebserver3.PushPromise
 import mockwebserver3.QueueDispatcher
 import mockwebserver3.RecordedRequest
-import mockwebserver3.SocketEffect.CloseStream
-import mockwebserver3.SocketEffect.ShutdownConnection
-import mockwebserver3.SocketEffect.Stall
+import mockwebserver3.SocketPolicy.DisconnectAtEnd
+import mockwebserver3.SocketPolicy.NoResponse
+import mockwebserver3.SocketPolicy.ResetStreamAtStart
+import mockwebserver3.SocketPolicy.StallSocketAtStart
 import mockwebserver3.junit5.StartStop
 import okhttp3.Cache
 import okhttp3.Call
@@ -578,7 +579,7 @@ class HttpOverHttp2Test {
   @ArgumentsSource(ProtocolParamProvider::class)
   fun readResponseHeaderTimeout(protocol: Protocol) {
     setUp(protocol)
-    server.enqueue(MockResponse.Builder().onResponseStart(Stall).build())
+    server.enqueue(MockResponse(socketPolicy = NoResponse))
     server.enqueue(MockResponse(body = "A"))
     client =
       client
@@ -894,10 +895,7 @@ class HttpOverHttp2Test {
   fun noRecoveryFromOneRefusedStream(protocol: Protocol) {
     setUp(protocol)
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(MockResponse(body = "abc"))
     val call = client.newCall(Request(server.url("/")))
@@ -918,10 +916,7 @@ class HttpOverHttp2Test {
         .dns(DoubleInetAddressDns()) // Two routes!
         .build()
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(MockResponse(body = "abc"))
 
@@ -946,22 +941,13 @@ class HttpOverHttp2Test {
         .dns(DoubleInetAddressDns()) // Two routes!
         .build()
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
 
     val request = Request(server.url("/"))
@@ -980,10 +966,7 @@ class HttpOverHttp2Test {
   fun connectionWithOneRefusedStreamIsPooled(protocol: Protocol) {
     setUp(protocol)
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(MockResponse(body = "abc"))
     val request = Request(server.url("/"))
@@ -1007,16 +990,10 @@ class HttpOverHttp2Test {
   fun connectionWithTwoRefusedStreamsIsNotPooled(protocol: Protocol) {
     setUp(protocol)
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(MockResponse(body = "abc"))
     server.enqueue(MockResponse(body = "def"))
@@ -1053,16 +1030,10 @@ class HttpOverHttp2Test {
   fun noRecoveryFromTwoRefusedStreams(protocol: Protocol) {
     setUp(protocol)
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(
       MockResponse(body = "abc"),
@@ -1091,7 +1062,7 @@ class HttpOverHttp2Test {
 
   private fun recoverFromOneHttp2ErrorRequiresNewConnection(errorCode: ErrorCode?) {
     server.enqueue(
-      MockResponse.Builder().onRequestStart(CloseStream(errorCode!!.httpCode)).build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(errorCode!!.httpCode)),
     )
     server.enqueue(MockResponse(body = "abc"))
     client =
@@ -1118,16 +1089,10 @@ class HttpOverHttp2Test {
   fun recoverFromMultipleRefusedStreamsRequiresNewConnection(protocol: Protocol) {
     setUp(protocol)
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.REFUSED_STREAM.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.REFUSED_STREAM.httpCode)),
     )
     server.enqueue(MockResponse(body = "abc"))
     client =
@@ -1317,7 +1282,7 @@ class HttpOverHttp2Test {
 
   private fun noRecoveryFromErrorWithRetryDisabled(errorCode: ErrorCode?) {
     server.enqueue(
-      MockResponse.Builder().onRequestStart(CloseStream(errorCode!!.httpCode)).build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(errorCode!!.httpCode)),
     )
     server.enqueue(MockResponse(body = "abc"))
     client =
@@ -1339,10 +1304,7 @@ class HttpOverHttp2Test {
     setUp(protocol)
     server.enqueue(MockResponse(code = 401))
     server.enqueue(
-      MockResponse
-        .Builder()
-        .onRequestStart(CloseStream(ErrorCode.INTERNAL_ERROR.httpCode))
-        .build(),
+      MockResponse(socketPolicy = ResetStreamAtStart(ErrorCode.INTERNAL_ERROR.httpCode)),
     )
     server.enqueue(MockResponse(body = "DEF"))
     server.enqueue(
@@ -1599,7 +1561,7 @@ class HttpOverHttp2Test {
         .build()
 
     // Set up the server to ignore the socket. It won't respond to pings!
-    server.enqueue(MockResponse.Builder().onRequestStart(Stall).build())
+    server.enqueue(MockResponse(socketPolicy = StallSocketAtStart))
 
     // Make a call. It'll fail as soon as our pings detect a problem.
     val call = client.newCall(Request(server.url("/")))
@@ -1635,7 +1597,7 @@ class HttpOverHttp2Test {
         .build()
 
     // Stalling the socket will cause TWO requests to time out!
-    server.enqueue(MockResponse.Builder().onRequestStart(Stall).build())
+    server.enqueue(MockResponse(socketPolicy = StallSocketAtStart))
 
     // The 3rd request should be sent to a fresh connection.
     server.enqueue(
@@ -1798,11 +1760,10 @@ class HttpOverHttp2Test {
   fun connectionNotReusedAfterShutdown(protocol: Protocol) {
     setUp(protocol)
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("ABC")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        body = "ABC",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(MockResponse(body = "DEF"))
     // Enqueue an additional response that show if we burnt a good prior response.
@@ -1858,11 +1819,10 @@ class HttpOverHttp2Test {
   fun connectionShutdownAfterHealthCheck(protocol: Protocol) {
     setUp(protocol)
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("ABC")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        body = "ABC",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     server.enqueue(MockResponse(body = "DEF"))
     val client2 =
@@ -1913,11 +1873,10 @@ class HttpOverHttp2Test {
         .build(),
     )
     server.enqueue(
-      MockResponse
-        .Builder()
-        .body("DEF")
-        .onResponseEnd(ShutdownConnection)
-        .build(),
+      MockResponse(
+        body = "DEF",
+        socketPolicy = DisconnectAtEnd,
+      ),
     )
     val latch = CountDownLatch(2)
     val errors = ArrayList<IOException?>()
@@ -1953,7 +1912,7 @@ class HttpOverHttp2Test {
       assertThat(server.requestCount).isEqualTo(2)
     } else {
       // https://github.com/square/okhttp/issues/4836
-      // As documented in SocketEffect, this is known to be flaky.
+      // As documented in SocketPolicy, this is known to be flaky.
       val error = errors[0]
       if (error !is StreamResetException) {
         throw error!!
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/internal/tls/CertificatePinnerChainValidationTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/internal/tls/CertificatePinnerChainValidationTest.kt
index f9b01cec8..09d66228e 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/internal/tls/CertificatePinnerChainValidationTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/internal/tls/CertificatePinnerChainValidationTest.kt
@@ -30,7 +30,7 @@ import javax.net.ssl.TrustManager
 import kotlin.test.assertFailsWith
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
-import mockwebserver3.SocketEffect.ShutdownConnection
+import mockwebserver3.SocketPolicy.DisconnectAtEnd
 import mockwebserver3.junit5.StartStop
 import okhttp3.CertificatePinner
 import okhttp3.CertificatePinner.Companion.pin
@@ -193,7 +193,7 @@ class CertificatePinnerChainValidationTest {
       MockResponse
         .Builder()
         .body("abc")
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(DisconnectAtEnd)
         .build(),
     )
     val call1 =
@@ -215,7 +215,7 @@ class CertificatePinnerChainValidationTest {
       MockResponse
         .Builder()
         .body("def")
-        .onResponseEnd(ShutdownConnection)
+        .socketPolicy(DisconnectAtEnd)
         .build(),
     )
     val call2 =
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/internal/ws/WebSocketHttpTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/internal/ws/WebSocketHttpTest.kt
index a94503758..240941961 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/internal/ws/WebSocketHttpTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/internal/ws/WebSocketHttpTest.kt
@@ -43,8 +43,9 @@ import mockwebserver3.Dispatcher
 import mockwebserver3.MockResponse
 import mockwebserver3.MockWebServer
 import mockwebserver3.RecordedRequest
-import mockwebserver3.SocketEffect.CloseSocket
-import mockwebserver3.SocketEffect.Stall
+import mockwebserver3.SocketPolicy
+import mockwebserver3.SocketPolicy.KeepOpen
+import mockwebserver3.SocketPolicy.NoResponse
 import mockwebserver3.junit5.StartStop
 import okhttp3.Interceptor
 import okhttp3.OkHttpClient
@@ -398,7 +399,7 @@ class WebSocketHttpTest {
     webServer.enqueue(
       MockResponse
         .Builder()
-        .onRequestStart(CloseSocket())
+        .socketPolicy(SocketPolicy.DisconnectAtStart)
         .build(),
     )
     val webSocket = newWebSocket()
@@ -426,7 +427,7 @@ class WebSocketHttpTest {
     webServer.enqueue(
       MockResponse
         .Builder()
-        .onRequestStart(CloseSocket())
+        .socketPolicy(SocketPolicy.DisconnectAtStart)
         .build(),
     )
     val webSocket = newWebSocket()
@@ -453,7 +454,7 @@ class WebSocketHttpTest {
     webServer.enqueue(
       MockResponse
         .Builder()
-        .onRequestStart(CloseSocket())
+        .socketPolicy(SocketPolicy.DisconnectAtStart)
         .build(),
     )
     val webSocket = newWebSocket()
@@ -481,7 +482,7 @@ class WebSocketHttpTest {
     webServer.enqueue(
       MockResponse
         .Builder()
-        .onRequestStart(CloseSocket())
+        .socketPolicy(SocketPolicy.DisconnectAtStart)
         .build(),
     )
     val webSocket = newWebSocket()
@@ -508,7 +509,7 @@ class WebSocketHttpTest {
     webServer.enqueue(
       MockResponse
         .Builder()
-        .onRequestStart(CloseSocket())
+        .socketPolicy(SocketPolicy.DisconnectAtStart)
         .build(),
     )
     val webSocket = newWebSocket()
@@ -536,7 +537,7 @@ class WebSocketHttpTest {
     webServer.enqueue(
       MockResponse
         .Builder()
-        .onRequestStart(CloseSocket())
+        .socketPolicy(SocketPolicy.DisconnectAtStart)
         .build(),
     )
     val webSocket = newWebSocket()
@@ -743,7 +744,7 @@ class WebSocketHttpTest {
     webServer.enqueue(
       MockResponse
         .Builder()
-        .onResponseStart(Stall)
+        .socketPolicy(NoResponse)
         .build(),
     )
     val webSocket: WebSocket = newWebSocket()
@@ -768,6 +769,7 @@ class WebSocketHttpTest {
           upgradeResponse(request)
             .body(Buffer().write("81".decodeHex())) // Truncated frame.
             .removeHeader("Content-Length")
+            .socketPolicy(KeepOpen)
             .build()
       }
     val webSocket: WebSocket = newWebSocket()
