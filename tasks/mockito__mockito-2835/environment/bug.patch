diff --git a/src/main/java/org/mockito/ArgumentMatcher.java b/src/main/java/org/mockito/ArgumentMatcher.java
index 5d68132d8..ad52e1eca 100644
--- a/src/main/java/org/mockito/ArgumentMatcher.java
+++ b/src/main/java/org/mockito/ArgumentMatcher.java
@@ -161,7 +161,7 @@ public interface ArgumentMatcher<T> {
      * <p>Only matcher implementations that can conceptually match a raw vararg parameter should override this method.
      *
      * @return the type this matcher handles. The default value of {@link Void} means the type is not known.
-     * @since 4.11.0
+     * @since 5.0.0
      */
     default Class<?> type() {
         return Void.class;
diff --git a/src/main/java/org/mockito/ArgumentMatchers.java b/src/main/java/org/mockito/ArgumentMatchers.java
index 1d3f11136..28986e164 100644
--- a/src/main/java/org/mockito/ArgumentMatchers.java
+++ b/src/main/java/org/mockito/ArgumentMatchers.java
@@ -174,7 +174,7 @@ public class ArgumentMatchers {
      * @see #isNull()
      */
     public static <T> T any(Class<T> type) {
-        reportMatcher(new InstanceOf(type, "<any " + type.getCanonicalName() + ">"));
+        reportMatcher(new InstanceOf.VarArgAware(type, "<any " + type.getCanonicalName() + ">"));
         return defaultValue(type);
     }
 
@@ -709,7 +709,7 @@ public class ArgumentMatchers {
      * @param type the type of the argument being matched.
      * @return <code>null</code>.
      * @see #isNotNull(Class)
-     * @since 4.11.0
+     * @since 5.0.0
      */
     public static <T> T isNull(Class<T> type) {
         reportMatcher(new Null<>(type));
@@ -747,7 +747,7 @@ public class ArgumentMatchers {
      *
      * @param type the type of the argument being matched.
      * @return <code>null</code>.
-     * @since 4.11.0
+     * @since 5.0.0
      */
     public static <T> T notNull(Class<T> type) {
         reportMatcher(new NotNull<>(type));
@@ -786,7 +786,7 @@ public class ArgumentMatchers {
      * @param type the type of the argument being matched.
      * @return <code>null</code>.
      * @see #isNull()
-     * @since 4.11.0
+     * @since 5.0.0
      */
     public static <T> T isNotNull(Class<T> type) {
         return notNull(type);
diff --git a/src/main/java/org/mockito/hamcrest/MockitoHamcrest.java b/src/main/java/org/mockito/hamcrest/MockitoHamcrest.java
index 3624ba20c..b8ebf8f97 100644
--- a/src/main/java/org/mockito/hamcrest/MockitoHamcrest.java
+++ b/src/main/java/org/mockito/hamcrest/MockitoHamcrest.java
@@ -42,24 +42,6 @@ import org.mockito.internal.hamcrest.HamcrestArgumentMatcher;
  * Due to how java works we don't really have a clean way of detecting this scenario and protecting the user from this problem.
  * Hopefully, the javadoc describes the problem and solution well.
  * If you have an idea how to fix the problem, let us know via the mailing list or the issue tracker.
- * <p/>
- * By default, a matcher passed to a varargs parameter will match against the first element in the varargs array.
- * To match against the raw varargs array pass the type of the varargs parameter to {@link MockitoHamcrest#argThat(Matcher, Class)}
- * <p/>
- * For example, to match any number of {@code String} values:
- * <pre>
- *     import static org.hamcrest.CoreMatchers.isA;
- *     import static org.mockito.hamcrest.MockitoHamcrest.argThat;
- *
- *     // Given:
- *     void varargMethod(String... args);
- *
- *     //stubbing
- *     when(mock.varargMethod(argThat(isA(String[].class), String[].class));
- *
- *     //verification
- *     verify(mock).giveMe(argThat(isA(String[].class), String[].class));
- * </pre>
  *
  * @since 2.1.0
  */
@@ -80,26 +62,6 @@ public final class MockitoHamcrest {
         return (T) defaultValue(genericTypeOfMatcher(matcher.getClass()));
     }
 
-    /**
-     * Allows matching arguments with hamcrest matchers.
-     * <p/>
-     * This variant can be used to pass an explicit {@code type},
-     * which can be useful to provide a matcher that matches against all
-     * elements in a varargs parameter.
-     * <p/>
-     * See examples in javadoc for {@link MockitoHamcrest} class
-     *
-     * @param matcher decides whether argument matches
-     * @param type the type the matcher matches.
-     * @return <code>null</code> or default value for primitive (0, false, etc.)
-     * @since 5.0.0
-     */
-    @SuppressWarnings("unchecked")
-    public static <T> T argThat(Matcher<T> matcher, Class<T> type) {
-        reportMatcher(matcher, type);
-        return (T) defaultValue(genericTypeOfMatcher(matcher.getClass()));
-    }
-
     /**
      * Enables integrating hamcrest matchers that match primitive <code>char</code> arguments.
      * Note that {@link #argThat} will not work with primitive <code>char</code> matchers due to <code>NullPointerException</code> auto-unboxing caveat.
@@ -213,15 +175,9 @@ public final class MockitoHamcrest {
     }
 
     private static <T> void reportMatcher(Matcher<T> matcher) {
-        reportMatcher(new HamcrestArgumentMatcher<T>(matcher));
-    }
-
-    private static <T> void reportMatcher(Matcher<T> matcher, Class<T> type) {
-        reportMatcher(new HamcrestArgumentMatcher<T>(matcher, type));
-    }
-
-    private static <T> void reportMatcher(final HamcrestArgumentMatcher<T> matcher) {
-        mockingProgress().getArgumentMatcherStorage().reportMatcher(matcher);
+        mockingProgress()
+                .getArgumentMatcherStorage()
+                .reportMatcher(new HamcrestArgumentMatcher<T>(matcher));
     }
 
     private MockitoHamcrest() {}
diff --git a/src/main/java/org/mockito/internal/hamcrest/HamcrestArgumentMatcher.java b/src/main/java/org/mockito/internal/hamcrest/HamcrestArgumentMatcher.java
index f9ef55d52..db526546e 100644
--- a/src/main/java/org/mockito/internal/hamcrest/HamcrestArgumentMatcher.java
+++ b/src/main/java/org/mockito/internal/hamcrest/HamcrestArgumentMatcher.java
@@ -7,25 +7,14 @@ package org.mockito.internal.hamcrest;
 import org.hamcrest.Matcher;
 import org.hamcrest.StringDescription;
 import org.mockito.ArgumentMatcher;
-
-import static java.util.Objects.requireNonNull;
+import org.mockito.internal.matchers.VarargMatcher;
 
 public class HamcrestArgumentMatcher<T> implements ArgumentMatcher<T> {
 
-    private final Matcher<T> matcher;
-    private final Class<?> type;
+    private final Matcher matcher;
 
     public HamcrestArgumentMatcher(Matcher<T> matcher) {
-        this(Void.class, matcher);
-    }
-
-    public HamcrestArgumentMatcher(Matcher<T> matcher, Class<T> type) {
-        this(type, matcher);
-    }
-
-    private HamcrestArgumentMatcher(Class<?> type, Matcher<T> matcher) {
-        this.type = requireNonNull(type, "type");
-        this.matcher = requireNonNull(matcher, "matcher");
+        this.matcher = matcher;
     }
 
     @Override
@@ -33,14 +22,14 @@ public class HamcrestArgumentMatcher<T> implements ArgumentMatcher<T> {
         return this.matcher.matches(argument);
     }
 
+    @SuppressWarnings("deprecation")
+    public boolean isVarargMatcher() {
+        return matcher instanceof VarargMatcher;
+    }
+
     @Override
     public String toString() {
         // TODO SF add unit tests and integ test coverage for toString()
         return StringDescription.toString(matcher);
     }
-
-    @Override
-    public Class<?> type() {
-        return type;
-    }
 }
diff --git a/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java b/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java
index 8b50da635..f3c0111c6 100644
--- a/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java
+++ b/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java
@@ -4,10 +4,13 @@
  */
 package org.mockito.internal.invocation;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import org.mockito.ArgumentMatcher;
+import org.mockito.internal.hamcrest.HamcrestArgumentMatcher;
 import org.mockito.internal.matchers.CapturingMatcher;
+import org.mockito.internal.matchers.VarargMatcher;
 import org.mockito.invocation.Invocation;
 
 public class MatcherApplicationStrategy {
@@ -60,7 +63,7 @@ public class MatcherApplicationStrategy {
                         && invocation.getRawArguments().length == matchers.size();
 
         if (maybeVararg) {
-            final Class<?> matcherType = lastMatcherType();
+            final Class<?> matcherType = lastMatcher().type();
             final Class<?> paramType = lastParameterType();
             if (paramType.isAssignableFrom(matcherType)) {
                 return argsMatch(invocation.getRawArguments(), matchers, action);
@@ -71,6 +74,12 @@ public class MatcherApplicationStrategy {
             return argsMatch(invocation.getArguments(), matchers, action);
         }
 
+        if (maybeVararg && isLastMatcherVarargMatcher()) {
+            int times = varargLength();
+            final List<? extends ArgumentMatcher<?>> matchers = appendLastMatcherNTimes(times);
+            return argsMatch(invocation.getArguments(), matchers, action);
+        }
+
         return false;
     }
 
@@ -89,8 +98,33 @@ public class MatcherApplicationStrategy {
         return true;
     }
 
-    private Class<?> lastMatcherType() {
-        return matchers.get(matchers.size() - 1).type();
+    private boolean isLastMatcherVarargMatcher() {
+        ArgumentMatcher<?> argumentMatcher = lastMatcher();
+        if (argumentMatcher instanceof HamcrestArgumentMatcher<?>) {
+            return ((HamcrestArgumentMatcher<?>) argumentMatcher).isVarargMatcher();
+        }
+        return argumentMatcher instanceof VarargMatcher;
+    }
+
+    private List<? extends ArgumentMatcher<?>> appendLastMatcherNTimes(
+            int timesToAppendLastMatcher) {
+        ArgumentMatcher<?> lastMatcher = lastMatcher();
+
+        List<ArgumentMatcher<?>> expandedMatchers = new ArrayList<ArgumentMatcher<?>>(matchers);
+        for (int i = 0; i < timesToAppendLastMatcher; i++) {
+            expandedMatchers.add(lastMatcher);
+        }
+        return expandedMatchers;
+    }
+
+    private int varargLength() {
+        int rawArgumentCount = invocation.getRawArguments().length;
+        int expandedArgumentCount = invocation.getArguments().length;
+        return expandedArgumentCount - rawArgumentCount;
+    }
+
+    private ArgumentMatcher<?> lastMatcher() {
+        return matchers.get(matchers.size() - 1);
     }
 
     private Class<?> lastParameterType() {
diff --git a/src/main/java/org/mockito/internal/matchers/Any.java b/src/main/java/org/mockito/internal/matchers/Any.java
index 2074f81ab..1a71a7e2b 100644
--- a/src/main/java/org/mockito/internal/matchers/Any.java
+++ b/src/main/java/org/mockito/internal/matchers/Any.java
@@ -8,7 +8,7 @@ import java.io.Serializable;
 
 import org.mockito.ArgumentMatcher;
 
-public class Any implements ArgumentMatcher<Object>, Serializable {
+public class Any implements ArgumentMatcher<Object>, VarargMatcher, Serializable {
 
     public static final Any ANY = new Any();
 
diff --git a/src/main/java/org/mockito/internal/matchers/CapturingMatcher.java b/src/main/java/org/mockito/internal/matchers/CapturingMatcher.java
index 7ce913365..2be6d9f56 100644
--- a/src/main/java/org/mockito/internal/matchers/CapturingMatcher.java
+++ b/src/main/java/org/mockito/internal/matchers/CapturingMatcher.java
@@ -17,7 +17,8 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.util.Primitives;
 
-public class CapturingMatcher<T> implements ArgumentMatcher<T>, CapturesArguments, Serializable {
+public class CapturingMatcher<T>
+        implements ArgumentMatcher<T>, CapturesArguments, VarargMatcher, Serializable {
 
     private final Class<? extends T> clazz;
     private final List<T> arguments = new ArrayList<>();
diff --git a/src/main/java/org/mockito/internal/matchers/InstanceOf.java b/src/main/java/org/mockito/internal/matchers/InstanceOf.java
index a53b1bda0..9ea762bb9 100644
--- a/src/main/java/org/mockito/internal/matchers/InstanceOf.java
+++ b/src/main/java/org/mockito/internal/matchers/InstanceOf.java
@@ -39,4 +39,20 @@ public class InstanceOf implements ArgumentMatcher<Object>, Serializable {
     public String toString() {
         return description;
     }
+
+    public static class VarArgAware extends InstanceOf implements VarargMatcher {
+
+        public VarArgAware(Class<?> clazz) {
+            super(clazz);
+        }
+
+        public VarArgAware(Class<?> clazz, String describedAs) {
+            super(clazz, describedAs);
+        }
+
+        @Override
+        public Class<?> type() {
+            return clazz;
+        }
+    }
 }
diff --git a/src/main/java/org/mockito/internal/matchers/VarargMatcher.java b/src/main/java/org/mockito/internal/matchers/VarargMatcher.java
new file mode 100644
index 000000000..2dfd9b754
--- /dev/null
+++ b/src/main/java/org/mockito/internal/matchers/VarargMatcher.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.matchers;
+
+import java.io.Serializable;
+
+/**
+ * Internal interface that informs Mockito that the matcher is intended to capture varargs.
+ * This information is needed when mockito collects the arguments.
+ *
+ * @deprecated use of this interface is deprecated as the behaviour it promotes has limitations.
+ * It is not recommended for new implementations to implement this method.
+ *
+ * <p>Instead, matchers should implement the {@link org.mockito.ArgumentMatcher#type()} method.
+ * If this method returns the same raw type as a vararg parameter, then Mockito will treat the
+ * matcher as matching the entire vararg array parameter, otherwise it will be treated as matching a single element.
+ * For an example, see {@link org.mockito.ArgumentMatchers#isNull(Class)}.
+ */
+@Deprecated
+public interface VarargMatcher extends Serializable {}
diff --git a/src/test/java/org/mockito/internal/invocation/InvocationMatcherTest.java b/src/test/java/org/mockito/internal/invocation/InvocationMatcherTest.java
index a217d4d8d..ab53be545 100644
--- a/src/test/java/org/mockito/internal/invocation/InvocationMatcherTest.java
+++ b/src/test/java/org/mockito/internal/invocation/InvocationMatcherTest.java
@@ -149,11 +149,11 @@ public class InvocationMatcherTest extends TestBase {
     }
 
     @Test
-    public void should_match_varargs_using_any_varargs() {
+    public void should_match_varargs_using_any_varargs() throws Exception {
         // given
         mock.varargs("1", "2");
         Invocation invocation = getLastInvocation();
-        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, asList(ANY, ANY));
+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(ANY));
 
         // when
         boolean match = invocationMatcher.matches(invocation);
@@ -163,11 +163,11 @@ public class InvocationMatcherTest extends TestBase {
     }
 
     @Test
-    public void should_capture_varargs_as_vararg() {
+    public void should_capture_varargs_as_vararg() throws Exception {
         // given
         mock.mixedVarargs(1, "a", "b");
         Invocation invocation = getLastInvocation();
-        CapturingMatcher<String[]> m = new CapturingMatcher(String[].class);
+        CapturingMatcher m = new CapturingMatcher(List.class);
         InvocationMatcher invocationMatcher =
                 new InvocationMatcher(invocation, Arrays.<ArgumentMatcher>asList(new Equals(1), m));
 
@@ -175,11 +175,11 @@ public class InvocationMatcherTest extends TestBase {
         invocationMatcher.captureArgumentsFrom(invocation);
 
         // then
-        Assertions.assertThat(m.getAllValues()).containsExactly(new String[] {"a", "b"});
+        Assertions.assertThat(m.getAllValues()).containsExactly("a", "b");
     }
 
     @Test // like using several time the captor in the vararg
-    public void should_capture_arguments_when_args_count_does_NOT_match() {
+    public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {
         // given
         mock.varargs();
         Invocation invocation = getLastInvocation();
diff --git a/src/test/java/org/mockito/internal/invocation/MatcherApplicationStrategyTest.java b/src/test/java/org/mockito/internal/invocation/MatcherApplicationStrategyTest.java
index 21c94b152..ddd433390 100644
--- a/src/test/java/org/mockito/internal/invocation/MatcherApplicationStrategyTest.java
+++ b/src/test/java/org/mockito/internal/invocation/MatcherApplicationStrategyTest.java
@@ -9,6 +9,7 @@ import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.internal.invocation.MatcherApplicationStrategy.getMatcherApplicationStrategyFor;
 import static org.mockito.internal.matchers.Any.ANY;
 
@@ -25,6 +26,7 @@ import org.mockito.internal.hamcrest.HamcrestArgumentMatcher;
 import org.mockito.internal.matchers.Any;
 import org.mockito.internal.matchers.Equals;
 import org.mockito.internal.matchers.InstanceOf;
+import org.mockito.internal.matchers.VarargMatcher;
 import org.mockito.invocation.Invocation;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
@@ -122,7 +124,7 @@ public class MatcherApplicationStrategyTest extends TestBase {
     public void shouldAllowAnyMatchEntireVararg() {
         // given
         invocation = varargs("1", "2");
-        matchers = asList(ANY, ANY);
+        matchers = asList(ANY);
 
         // when
         boolean match =
@@ -149,10 +151,10 @@ public class MatcherApplicationStrategyTest extends TestBase {
     }
 
     @Test
-    public void shouldAllowAnyWithMixedVarargs() {
+    public void shouldAllowanyWithMixedVarargs() {
         // given
         invocation = mixedVarargs(1, "1", "2");
-        matchers = asList(new Equals(1), ANY, ANY);
+        matchers = asList(new Equals(1), ANY);
 
         // when
         boolean match =
@@ -184,7 +186,7 @@ public class MatcherApplicationStrategyTest extends TestBase {
     public void shouldMatchAnyEvenIfOneOfTheArgsIsNull() {
         // given
         invocation = mixedVarargs(null, null, "2");
-        matchers = asList(new Equals(null), ANY, ANY);
+        matchers = asList(new Equals(null), ANY);
 
         // when
         getMatcherApplicationStrategyFor(invocation, matchers)
@@ -198,7 +200,7 @@ public class MatcherApplicationStrategyTest extends TestBase {
     public void shouldMatchAnyEvenIfMatcherIsDecorated() {
         // given
         invocation = varargs("1", "2");
-        matchers = asList(ANY, ANY);
+        matchers = asList(ANY);
 
         // when
         getMatcherApplicationStrategyFor(invocation, matchers)
@@ -214,7 +216,7 @@ public class MatcherApplicationStrategyTest extends TestBase {
         invocation = varargs("1", "2");
         HamcrestArgumentMatcher<Integer> argumentMatcher =
                 new HamcrestArgumentMatcher<>(new IntMatcher());
-        matchers = asList(argumentMatcher, argumentMatcher);
+        matchers = asList(argumentMatcher);
 
         // when
         getMatcherApplicationStrategyFor(invocation, matchers)
@@ -228,7 +230,7 @@ public class MatcherApplicationStrategyTest extends TestBase {
     public void shouldMatchAnyThatMatchesRawVarArgType() {
         // given
         invocation = varargs("1", "2");
-        InstanceOf any = new InstanceOf(String[].class, "<any String[]>");
+        InstanceOf.VarArgAware any = new InstanceOf.VarArgAware(String[].class, "<any String[]>");
         matchers = asList(any);
 
         // when
@@ -239,15 +241,7 @@ public class MatcherApplicationStrategyTest extends TestBase {
         recordAction.assertContainsExactly(any);
     }
 
-    private static class IntMatcher extends BaseMatcher<Integer> {
-        public boolean matches(Object o) {
-            return true;
-        }
-
-        public void describeTo(Description description) {}
-    }
-
-    private static class IntArrayMatcher extends BaseMatcher<Integer[]> {
+    private static class IntMatcher extends BaseMatcher<Integer> implements VarargMatcher {
         public boolean matches(Object o) {
             return true;
         }
diff --git a/src/test/java/org/mockito/internal/matchers/InstanceOfTest.java b/src/test/java/org/mockito/internal/matchers/InstanceOfTest.java
index 7740d0b77..8addef8ca 100644
--- a/src/test/java/org/mockito/internal/matchers/InstanceOfTest.java
+++ b/src/test/java/org/mockito/internal/matchers/InstanceOfTest.java
@@ -59,8 +59,9 @@ public class InstanceOfTest {
 
     @Test
     public void can_be_vararg_aware() {
-        assertThat(new InstanceOf(Number[].class).matches(new Integer[0])).isTrue();
-        assertThat(new InstanceOf(Number[].class).matches(new Number[0])).isTrue();
-        assertThat(new InstanceOf(Number[].class).matches(new Object[0])).isFalse();
+        assertThat(new InstanceOf.VarArgAware(Number[].class)).isInstanceOf(VarargMatcher.class);
+        assertThat(new InstanceOf.VarArgAware(Number[].class).matches(new Integer[0])).isTrue();
+        assertThat(new InstanceOf.VarArgAware(Number[].class).matches(new Number[0])).isTrue();
+        assertThat(new InstanceOf.VarArgAware(Number[].class).matches(new Object[0])).isFalse();
     }
 }
diff --git a/src/test/java/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java b/src/test/java/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java
index 45ff5ea86..9e63e8df6 100644
--- a/src/test/java/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java
+++ b/src/test/java/org/mockito/internal/util/reflection/ParameterizedConstructorInstantiatorTest.java
@@ -73,7 +73,7 @@ public class ParameterizedConstructorInstantiatorTest {
     public void should_instantiate_type_if_resolver_provide_matching_types() throws Exception {
         Observer observer = mock(Observer.class);
         Map map = mock(Map.class);
-        given(resolver.resolveTypeInstances(ArgumentMatchers.any(Class[].class)))
+        given(resolver.resolveTypeInstances(ArgumentMatchers.<Class<?>[]>any()))
                 .willReturn(new Object[] {observer, map});
 
         new ParameterizedConstructorInstantiator(this, field("withMultipleConstructor"), resolver)
@@ -120,7 +120,7 @@ public class ParameterizedConstructorInstantiatorTest {
     @Test
     public void should_instantiate_type_with_vararg_constructor() throws Exception {
         Observer[] vararg = new Observer[] {};
-        given(resolver.resolveTypeInstances(ArgumentMatchers.any(Class[].class)))
+        given(resolver.resolveTypeInstances(ArgumentMatchers.<Class<?>[]>any()))
                 .willReturn(new Object[] {"", vararg});
 
         new ParameterizedConstructorInstantiator(this, field("withVarargConstructor"), resolver)
diff --git a/src/test/java/org/mockitousage/basicapi/UsingVarargsTest.java b/src/test/java/org/mockitousage/basicapi/UsingVarargsTest.java
index 8d69a2a52..551c63790 100644
--- a/src/test/java/org/mockitousage/basicapi/UsingVarargsTest.java
+++ b/src/test/java/org/mockitousage/basicapi/UsingVarargsTest.java
@@ -173,9 +173,9 @@ public class UsingVarargsTest extends TestBase {
 
     @Test
     // See bug #157
-    public void shouldMatchEasilyEmptyVararg() {
+    public void shouldMatchEasilyEmptyVararg() throws Exception {
         // when
-        when(mock.foo(any(Object[].class))).thenReturn(-1);
+        when(mock.foo(any())).thenReturn(-1);
 
         // then
         assertEquals(-1, mock.foo());
diff --git a/src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyPicksUpExtraInvocationsTest.java b/src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyPicksUpExtraInvocationsTest.java
index c08bdf064..f6f4417c4 100644
--- a/src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyPicksUpExtraInvocationsTest.java
+++ b/src/test/java/org/mockitousage/bugs/varargs/VarargsAndAnyPicksUpExtraInvocationsTest.java
@@ -26,7 +26,7 @@ public class VarargsAndAnyPicksUpExtraInvocationsTest extends TestBase {
         table.newRow("abc", "def");
 
         // then
-        verify(table, times(2)).newRow(anyString(), any(String[].class));
+        verify(table, times(2)).newRow(anyString(), (String[]) any());
     }
 
     @Test
@@ -36,7 +36,7 @@ public class VarargsAndAnyPicksUpExtraInvocationsTest extends TestBase {
         table.newRow("x", "def");
 
         // then
-        verify(table, times(2)).newRow(eq("x"), any(String[].class));
+        verify(table, times(2)).newRow(eq("x"), (String[]) any());
     }
 
     @Test
diff --git a/src/test/java/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyTest.java b/src/test/java/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyTest.java
new file mode 100644
index 000000000..6e11a6a7f
--- /dev/null
+++ b/src/test/java/org/mockitousage/bugs/varargs/VarargsNotPlayingWithAnyTest.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage.bugs.varargs;
+
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyString;
+import static org.mockito.Mockito.eq;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+import org.mockito.Mock;
+import org.mockitoutil.TestBase;
+
+// see issue 62
+public class VarargsNotPlayingWithAnyTest extends TestBase {
+
+    interface VarargMethod {
+        Object run(String... args);
+    }
+
+    @Mock VarargMethod mock;
+
+    @Test
+    public void shouldMatchAny() {
+        mock.run("a", "b");
+
+        verify(mock).run(anyString(), anyString());
+        verify(mock).run((String) any(), (String) any());
+
+        verify(mock).run((String[]) any());
+
+        verify(mock, never()).run();
+        verify(mock, never()).run(anyString(), eq("f"));
+    }
+
+    @Test
+    public void shouldAllowUsinganyForVarArgs() {
+        mock.run("a", "b");
+        verify(mock).run((String[]) any());
+    }
+
+    @Test
+    public void shouldStubUsingAny() {
+        when(mock.run((String[]) any())).thenReturn("foo");
+
+        assertEquals("foo", mock.run("a", "b"));
+    }
+}
diff --git a/src/test/java/org/mockitousage/matchers/CapturingArgumentsTest.java b/src/test/java/org/mockitousage/matchers/CapturingArgumentsTest.java
index e0146de78..34b868488 100644
--- a/src/test/java/org/mockitousage/matchers/CapturingArgumentsTest.java
+++ b/src/test/java/org/mockitousage/matchers/CapturingArgumentsTest.java
@@ -4,7 +4,6 @@
  */
 package org.mockitousage.matchers;
 
-import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.*;
 import static org.mockito.Mockito.*;
@@ -14,6 +13,7 @@ import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 
+import org.assertj.core.api.Assertions;
 import org.junit.Test;
 import org.mockito.ArgumentCaptor;
 import org.mockito.Captor;
@@ -24,7 +24,7 @@ import org.mockitoutil.TestBase;
 
 public class CapturingArgumentsTest extends TestBase {
 
-    private static class Person {
+    class Person {
 
         private final Integer age;
 
@@ -37,9 +37,9 @@ public class CapturingArgumentsTest extends TestBase {
         }
     }
 
-    private static class BulkEmailService {
+    class BulkEmailService {
 
-        private final EmailService service;
+        private EmailService service;
 
         public BulkEmailService(EmailService service) {
             this.service = service;
@@ -62,6 +62,7 @@ public class CapturingArgumentsTest extends TestBase {
     private final IMethods mock = mock(IMethods.class);
     @Captor private ArgumentCaptor<List<?>> listCaptor;
 
+    @SuppressWarnings("deprecation")
     @Test
     public void should_allow_assertions_on_captured_argument() {
         // given
@@ -170,7 +171,7 @@ public class CapturingArgumentsTest extends TestBase {
         mock.simpleMethod("bar", 2);
 
         // then
-        assertThat(argument.getAllValues()).containsOnly("bar");
+        Assertions.assertThat(argument.getAllValues()).containsOnly("bar");
     }
 
     @Test
@@ -241,42 +242,13 @@ public class CapturingArgumentsTest extends TestBase {
         // given
         ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(byte.class);
 
-        // when
-        mock.varargsbyte((byte) 1);
-
-        // then
-        verify(mock).varargsbyte(argumentCaptor.capture());
-        assertEquals((byte) 1, (byte) argumentCaptor.getValue());
-        assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1);
-    }
-
-    @Test
-    public void should_capture_byte_vararg_by_creating_captor_with_primitive_2_args() {
-        // given
-        ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(byte.class);
-
         // when
         mock.varargsbyte((byte) 1, (byte) 2);
 
         // then
-        verify(mock).varargsbyte(argumentCaptor.capture(), argumentCaptor.capture());
+        verify(mock).varargsbyte(argumentCaptor.capture());
         assertEquals((byte) 2, (byte) argumentCaptor.getValue());
-        assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1, (byte) 2);
-    }
-
-    @Test
-    public void should_capture_byte_vararg_by_creating_captor_with_primitive_array() {
-        // given
-        ArgumentCaptor<byte[]> argumentCaptor = ArgumentCaptor.forClass(byte[].class);
-
-        // when
-        mock.varargsbyte();
-        mock.varargsbyte((byte) 1, (byte) 2);
-
-        // then
-        verify(mock, times(2)).varargsbyte(argumentCaptor.capture());
-        assertThat(argumentCaptor.getValue()).containsExactly(new byte[] {1, 2});
-        assertThat(argumentCaptor.getAllValues()).containsExactly(new byte[] {}, new byte[] {1, 2});
+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1, (byte) 2);
     }
 
     @Test
@@ -285,163 +257,41 @@ public class CapturingArgumentsTest extends TestBase {
         ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(Byte.class);
 
         // when
-        mock.varargsbyte((byte) 1);
+        mock.varargsbyte((byte) 1, (byte) 2);
 
         // then
         verify(mock).varargsbyte(argumentCaptor.capture());
-        assertEquals((byte) 1, (byte) argumentCaptor.getValue());
-        assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1);
-    }
-
-    @Test
-    public void should_not_capture_empty_vararg_with_single_captor() {
-        // given
-        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);
-
-        // when
-        mock.mixedVarargs(42);
-
-        // then
-        verify(mock, never()).mixedVarargs(any(), argumentCaptor.capture());
-    }
-
-    @Test
-    public void should_capture_single_vararg_with_single_captor() {
-        // given
-        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);
-
-        // when
-        mock.mixedVarargs(42, "a");
-
-        // then
-        verify(mock).mixedVarargs(any(), argumentCaptor.capture());
-        assertThat(argumentCaptor.getValue()).isEqualTo("a");
-    }
-
-    @Test
-    public void should_not_capture_multiple_vararg_with_single_captor() {
-        // given
-        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);
-
-        // when
-        mock.mixedVarargs(42, "a", "b");
-
-        // then
-        verify(mock, never()).mixedVarargs(any(), argumentCaptor.capture());
-    }
-
-    @Test
-    public void should_capture_multiple_vararg_with_multiple_captor() {
-        // given
-        ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);
-
-        // when
-        mock.mixedVarargs(42, "a", "b");
-
-        // then
-        verify(mock).mixedVarargs(any(), argumentCaptor.capture(), argumentCaptor.capture());
-        assertThat(argumentCaptor.getValue()).isEqualTo("b");
-        assertThat(argumentCaptor.getAllValues()).isEqualTo(asList("a", "b"));
+        assertEquals((byte) 2, (byte) argumentCaptor.getValue());
+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1, (byte) 2);
     }
 
     @Test
-    public void should_not_capture_multiple_vararg_some_null_with_single_captor() {
+    public void should_capture_vararg() {
         // given
         ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);
 
-        // when
-        mock.mixedVarargs(42, "a", null);
-
-        // then
-        verify(mock, never()).mixedVarargs(any(), argumentCaptor.capture());
-    }
-
-    @Test
-    public void should_capture_empty_vararg_with_array_captor() {
-        // given
-        ArgumentCaptor<String[]> argumentCaptor = ArgumentCaptor.forClass(String[].class);
-
-        // when
-        mock.mixedVarargs(42);
-
-        // then
-        verify(mock).mixedVarargs(any(), argumentCaptor.capture());
-        assertThat(argumentCaptor.getValue()).isEqualTo(new String[] {});
-        assertThat(argumentCaptor.getAllValues()).containsExactly(new String[] {});
-    }
-
-    @Test
-    public void should_capture_single_vararg_with_array_captor() {
-        // given
-        ArgumentCaptor<String[]> argumentCaptor = ArgumentCaptor.forClass(String[].class);
-
-        // when
-        mock.mixedVarargs(42, "a");
-
-        // then
-        verify(mock).mixedVarargs(any(), argumentCaptor.capture());
-        assertThat(argumentCaptor.getValue()).isEqualTo(new String[] {"a"});
-        assertThat(argumentCaptor.getAllValues()).containsExactly(new String[] {"a"});
-    }
-
-    @Test
-    public void should_capture_multiple_vararg_with_array_captor() {
-        // given
-        ArgumentCaptor<String[]> argumentCaptor = ArgumentCaptor.forClass(String[].class);
-
         // when
         mock.mixedVarargs(42, "a", "b", "c");
 
         // then
         verify(mock).mixedVarargs(any(), argumentCaptor.capture());
-        assertThat(argumentCaptor.getAllValues()).containsExactly(new String[] {"a", "b", "c"});
-    }
-
-    @Test
-    public void should_capture_multiple_vararg_some_null_with_array_captor() {
-        // given
-        ArgumentCaptor<String[]> argumentCaptor = ArgumentCaptor.forClass(String[].class);
-
-        // when
-        mock.mixedVarargs(42, "a", null, "c");
-
-        // then
-        verify(mock).mixedVarargs(any(), argumentCaptor.capture());
-        assertThat(argumentCaptor.getAllValues()).containsExactly(new String[] {"a", null, "c"});
+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a", "b", "c");
     }
 
     @Test
-    public void should_capture_multiple_invocations_with_captor() {
+    public void should_capture_all_vararg() {
         // given
         ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);
 
         // when
-        mock.mixedVarargs(42, "a", "b");
-        mock.mixedVarargs(42, "c", "d");
-
-        // then
-        verify(mock, times(2))
-                .mixedVarargs(any(), argumentCaptor.capture(), argumentCaptor.capture());
-
-        assertThat(argumentCaptor.getValue()).isEqualTo("d");
-        assertThat(argumentCaptor.getAllValues()).containsExactly("a", "b", "c", "d");
-    }
-
-    @Test
-    public void should_capture_multiple_invocations_with_array_captor() {
-        // given
-        ArgumentCaptor<String[]> argumentCaptor = ArgumentCaptor.forClass(String[].class);
-
-        // when
-        mock.mixedVarargs(42, "a", "b");
-        mock.mixedVarargs(42, "c", "d");
+        mock.mixedVarargs(42, "a", "b", "c");
+        mock.mixedVarargs(42, "again ?!");
 
         // then
         verify(mock, times(2)).mixedVarargs(any(), argumentCaptor.capture());
 
-        assertThat(argumentCaptor.getValue()).isEqualTo(new String[] {"c", "d"});
-        assertThat(argumentCaptor.getAllValues())
-                .containsExactly(new String[] {"a", "b"}, new String[] {"c", "d"});
+        Assertions.assertThat(argumentCaptor.getAllValues())
+                .containsExactly("a", "b", "c", "again ?!");
     }
 
     @Test
@@ -454,7 +304,7 @@ public class CapturingArgumentsTest extends TestBase {
 
         // then
         verify(mock).simpleMethod(argumentCaptor.capture(), eq(2));
-        assertThat(argumentCaptor.getAllValues()).containsExactly("a");
+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a");
     }
 
     @Test
@@ -473,7 +323,7 @@ public class CapturingArgumentsTest extends TestBase {
                         argumentCaptor.capture(),
                         argumentCaptor.capture(),
                         argumentCaptor.capture());
-        assertThat(argumentCaptor.getAllValues()).containsExactly("a", "b", "c");
+        Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a", "b", "c");
     }
 
     @Test
@@ -486,7 +336,7 @@ public class CapturingArgumentsTest extends TestBase {
 
         // then
         verify(mock).varargs(eq(42), argumentCaptor.capture());
-        assertThat(argumentCaptor.getValue()).contains("capturedValue");
+        Assertions.assertThat(argumentCaptor.getValue()).contains("capturedValue");
     }
 
     @SuppressWarnings("unchecked")
diff --git a/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java b/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java
index 261a3c3c9..3f16618c2 100644
--- a/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java
+++ b/src/test/java/org/mockitousage/matchers/HamcrestMatchersTest.java
@@ -6,10 +6,7 @@ package org.mockitousage.matchers;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.hamcrest.CoreMatchers.is;
-import static org.hamcrest.CoreMatchers.isA;
 import static org.junit.Assert.*;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 import static org.mockito.hamcrest.MockitoHamcrest.*;
@@ -57,44 +54,7 @@ public class HamcrestMatchersTest extends TestBase {
         }
     }
 
-    @Test
-    public void does_not_verify_vararg_with_no_items() {
-        mock.varargs();
-
-        verify(mock, never()).varargs(argThat(isA(String.class)));
-    }
-
-    @Test
-    public void verifies_vararg_with_single_item() {
-        mock.varargs("a");
-
-        verify(mock).varargs(argThat(isA(String.class)));
-    }
-
-    @Test
-    public void does_not_verify_vararg_with_multiple_items() {
-        mock.varargs("a", "b");
-
-        verify(mock, never()).varargs(argThat(isA(String.class)));
-    }
-
-    @Test
-    public void verify_vararg_with_multiple_item() {
-        mock.varargs("a", "b");
-
-        verify(mock).varargs(argThat(isA(String.class)), argThat(isA(String.class)));
-    }
-
-    @Test
-    public void verifies_vararg_with_any_num_items() {
-        mock.varargs();
-        mock.varargs("a");
-        mock.varargs("a", "b");
-
-        verify(mock, times(3)).varargs(argThat(isA(String[].class), String[].class));
-    }
-
-    private final class IntMatcher extends BaseMatcher<Integer> {
+    private class IntMatcher extends BaseMatcher<Integer> {
         public boolean matches(Object o) {
             return true;
         }
diff --git a/src/test/java/org/mockitousage/matchers/VarargsTest.java b/src/test/java/org/mockitousage/matchers/VarargsTest.java
index 5daba370e..0e5456fd2 100644
--- a/src/test/java/org/mockitousage/matchers/VarargsTest.java
+++ b/src/test/java/org/mockitousage/matchers/VarargsTest.java
@@ -40,7 +40,6 @@ public class VarargsTest {
 
     @Rule public MockitoRule mockitoRule = MockitoJUnit.rule();
     @Captor private ArgumentCaptor<String> captor;
-    @Captor private ArgumentCaptor<String[]> arrayCaptor;
     @Mock private IMethods mock;
 
     private static final Condition<Object> NULL =
@@ -83,18 +82,18 @@ public class VarargsTest {
 
     @Test
     public void shouldMatchVarArgs_oneNullArg_isNull() {
-        mock.varargs((Object) null);
+        Object arg = null;
+        mock.varargs(arg);
 
-        verify(mock).varargs(ArgumentMatchers.<Object>isNull());
-        verify(mock, never()).varargs(isNull(Object[].class));
+        verify(mock).varargs(ArgumentMatchers.<Object[]>isNull());
     }
 
     @Test
     public void shouldMatchVarArgs_nullArrayArg() {
-        mock.varargs((Object[]) null);
+        Object[] argArray = null;
+        mock.varargs(argArray);
 
-        verify(mock).varargs(isNull(Object[].class));
-        verify(mock).varargs(ArgumentMatchers.<Object>isNull());
+        verify(mock).varargs(ArgumentMatchers.<Object[]>isNull());
     }
 
     @Test
@@ -112,28 +111,28 @@ public class VarargsTest {
     public void shouldMatchVarArgs_emptyVarArgsOneAnyMatcher() {
         mock.varargs();
 
-        verify(mock).varargs(any(String[].class));
+        verify(mock).varargs((String[]) any()); // any() -> VarargMatcher
     }
 
     @Test
     public void shouldMatchVarArgs_oneArgsOneAnyMatcher() {
         mock.varargs(1);
 
-        verify(mock).varargs(any(Object[].class));
+        verify(mock).varargs(ArgumentMatchers.<Object[]>any()); // any() -> VarargMatcher
     }
 
     @Test
     public void shouldMatchVarArgs_twoArgsOneAnyMatcher() {
         mock.varargs(1, 2);
 
-        verify(mock).varargs(any(Object[].class));
+        verify(mock).varargs(ArgumentMatchers.<Object[]>any()); // any() -> VarargMatcher
     }
 
     @Test
     public void shouldMatchVarArgs_twoArgsTwoAnyMatcher() {
         mock.varargs(1, 2);
 
-        verify(mock).varargs(any(), ArgumentMatchers.<Object>any());
+        verify(mock).varargs(any(), ArgumentMatchers.<Object>any()); // any() -> VarargMatcher
     }
 
     @Test
@@ -142,7 +141,7 @@ public class VarargsTest {
 
         assertThatThrownBy(
                         () -> {
-                            verify(mock).varargs(any(), any(), any());
+                            verify(mock).varargs(any(), any(), any()); // any() -> VarargMatcher
                         })
                 .hasMessageContaining("Argument(s) are different");
     }
@@ -193,9 +192,9 @@ public class VarargsTest {
     public void shouldCaptureVarArgs_noArgs() {
         mock.varargs();
 
-        verify(mock).varargs(arrayCaptor.capture());
+        verify(mock).varargs(captor.capture());
 
-        assertThatCaptor(arrayCaptor).contains(new String[] {});
+        assertThatCaptor(captor).isEmpty();
     }
 
     @Test
@@ -225,9 +224,9 @@ public class VarargsTest {
     public void shouldCaptureVarArgs_twoArgsOneCapture() {
         mock.varargs("1", "2");
 
-        verify(mock).varargs(arrayCaptor.capture());
+        verify(mock).varargs(captor.capture());
 
-        assertThatCaptor(arrayCaptor).contains(new String[] {"1", "2"});
+        assertThatCaptor(captor).contains("1", "2");
     }
 
     @Test
@@ -239,6 +238,15 @@ public class VarargsTest {
         assertThatCaptor(captor).contains("1", "2");
     }
 
+    @Test
+    public void shouldCaptureVarArgs_oneNullArgument() {
+        mock.varargs("1", null);
+
+        verify(mock).varargs(captor.capture());
+
+        assertThatCaptor(captor).contains("1", (String) null);
+    }
+
     @Test
     public void shouldCaptureVarArgs_oneNullArgument2() {
         mock.varargs("1", null);
@@ -355,6 +363,20 @@ public class VarargsTest {
         assertThat(mock.methodWithVarargAndNonVarargVariants("a", "b", "c")).isNull();
     }
 
+    @Test
+    public void shouldMockVarargsInvocationUsingCasts() {
+        given(mock.methodWithVarargAndNonVarargVariants((String) any()))
+                .willReturn("single arg method");
+        given(mock.methodWithVarargAndNonVarargVariants((String[]) any()))
+                .willReturn("var arg method");
+
+        assertThat(mock.methodWithVarargAndNonVarargVariants("a")).isEqualTo("single arg method");
+        assertThat(mock.methodWithVarargAndNonVarargVariants()).isEqualTo("var arg method");
+        assertThat(mock.methodWithVarargAndNonVarargVariants(new String[] {"a"}))
+                .isEqualTo("var arg method");
+        assertThat(mock.methodWithVarargAndNonVarargVariants("a", "b")).isEqualTo("var arg method");
+    }
+
     @Test
     public void shouldMockVarargsInvocationForSuperType() {
         given(mock.varargsReturningString(any(Object[].class))).willReturn("a");
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
index 2b96bdf0a..d037cfc0a 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithAdditionalAnswersTest.java
@@ -56,8 +56,7 @@ public class StubbingWithAdditionalAnswersTest {
         given(iMethods.objectArgMethod(any())).will(returnsFirstArg());
         given(iMethods.threeArgumentMethod(eq(0), any(), anyString())).will(returnsSecondArg());
         given(iMethods.threeArgumentMethod(eq(1), any(), anyString())).will(returnsLastArg());
-        given(iMethods.mixedVarargsReturningString(eq(1), any(String[].class)))
-                .will(returnsArgAt(2));
+        given(iMethods.mixedVarargsReturningString(eq(1), any())).will(returnsArgAt(2));
 
         assertThat(iMethods.objectArgMethod("first")).isEqualTo("first");
         assertThat(iMethods.threeArgumentMethod(0, "second", "whatever")).isEqualTo("second");
@@ -67,10 +66,8 @@ public class StubbingWithAdditionalAnswersTest {
 
     @Test
     public void can_return_var_arguments_of_invocation() throws Exception {
-        given(iMethods.mixedVarargsReturningStringArray(eq(1), any(String[].class)))
-                .will(returnsLastArg());
-        given(iMethods.mixedVarargsReturningObjectArray(eq(1), any(String[].class)))
-                .will(returnsArgAt(1));
+        given(iMethods.mixedVarargsReturningStringArray(eq(1), any())).will(returnsLastArg());
+        given(iMethods.mixedVarargsReturningObjectArray(eq(1), any())).will(returnsArgAt(1));
 
         assertThat(iMethods.mixedVarargsReturningStringArray(1, "the", "var", "args"))
                 .containsExactlyInAnyOrder("the", "var", "args");
@@ -80,8 +77,7 @@ public class StubbingWithAdditionalAnswersTest {
 
     @Test
     public void returns_arg_at_throws_on_out_of_range_var_args() throws Exception {
-        given(iMethods.mixedVarargsReturningString(eq(1), any(String[].class)))
-                .will(returnsArgAt(3));
+        given(iMethods.mixedVarargsReturningString(eq(1), any())).will(returnsArgAt(3));
 
         assertThatThrownBy(() -> iMethods.mixedVarargsReturningString(1, "a", "b"))
                 .isInstanceOf(MockitoException.class)
@@ -115,7 +111,7 @@ public class StubbingWithAdditionalAnswersTest {
 
     @Test
     public void can_return_expanded_arguments_of_invocation() throws Exception {
-        given(iMethods.varargsObject(eq(1), any(Object[].class))).will(returnsArgAt(3));
+        given(iMethods.varargsObject(eq(1), any())).will(returnsArgAt(3));
 
         assertThat(iMethods.varargsObject(1, "bob", "alexander", "alice", "carl"))
                 .isEqualTo("alice");
@@ -393,7 +389,7 @@ public class StubbingWithAdditionalAnswersTest {
     @Test
     public void can_return_based_on_strongly_types_one_parameter_var_args_function()
             throws Exception {
-        given(iMethods.varargs(any(String[].class)))
+        given(iMethods.varargs(any()))
                 .will(
                         answer(
                                 new Answer1<Integer, String[]>() {
@@ -410,7 +406,7 @@ public class StubbingWithAdditionalAnswersTest {
             throws Exception {
         final IMethods target = mock(IMethods.class);
 
-        given(iMethods.varargs(any(String[].class)))
+        given(iMethods.varargs(any()))
                 .will(
                         answerVoid(
                                 new VoidAnswer1<String[]>() {
@@ -429,7 +425,7 @@ public class StubbingWithAdditionalAnswersTest {
     @Test
     public void can_return_based_on_strongly_typed_two_parameter_var_args_function()
             throws Exception {
-        given(iMethods.mixedVarargsReturningString(any(), any(String[].class)))
+        given(iMethods.mixedVarargsReturningString(any(), any()))
                 .will(
                         answer(
                                 new Answer2<String, Object, String[]>() {
@@ -446,7 +442,7 @@ public class StubbingWithAdditionalAnswersTest {
             throws Exception {
         final IMethods target = mock(IMethods.class);
 
-        given(iMethods.mixedVarargsReturningString(any(), any(String[].class)))
+        given(iMethods.mixedVarargsReturningString(any(), any()))
                 .will(
                         answerVoid(
                                 new VoidAnswer2<Object, String[]>() {
@@ -467,7 +463,7 @@ public class StubbingWithAdditionalAnswersTest {
             throws Exception {
         final IMethods target = mock(IMethods.class);
 
-        given(iMethods.threeArgumentVarArgsMethod(anyInt(), any(), any(String[].class)))
+        given(iMethods.threeArgumentVarArgsMethod(anyInt(), any(), any()))
                 .will(
                         answer(
                                 new Answer3<String, Integer, String, String[]>() {
@@ -490,7 +486,7 @@ public class StubbingWithAdditionalAnswersTest {
             throws Exception {
         final IMethods target = mock(IMethods.class);
 
-        given(iMethods.threeArgumentVarArgsMethod(anyInt(), any(), any(String[].class)))
+        given(iMethods.threeArgumentVarArgsMethod(anyInt(), any(), any()))
                 .will(
                         answerVoid(
                                 new VoidAnswer3<Integer, String, String[]>() {
@@ -510,7 +506,7 @@ public class StubbingWithAdditionalAnswersTest {
     public void can_return_based_on_strongly_typed_four_parameter_var_args_function()
             throws Exception {
         final IMethods target = mock(IMethods.class);
-        given(iMethods.fourArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(String[].class)))
+        given(iMethods.fourArgumentVarArgsMethod(anyInt(), any(), anyInt(), any()))
                 .will(
                         answer(
                                 new Answer4<String, Integer, String, Integer, String[]>() {
@@ -535,7 +531,7 @@ public class StubbingWithAdditionalAnswersTest {
             throws Exception {
         final IMethods target = mock(IMethods.class);
 
-        given(iMethods.fourArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(String[].class)))
+        given(iMethods.fourArgumentVarArgsMethod(anyInt(), any(), anyInt(), any()))
                 .will(
                         answerVoid(
                                 new VoidAnswer4<Integer, String, Integer, String[]>() {
@@ -556,9 +552,7 @@ public class StubbingWithAdditionalAnswersTest {
     public void can_return_based_on_strongly_typed_five_parameter_var_args_function()
             throws Exception {
         final IMethods target = mock(IMethods.class);
-        given(
-                        iMethods.fiveArgumentVarArgsMethod(
-                                anyInt(), any(), anyInt(), any(), any(String[].class)))
+        given(iMethods.fiveArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(), any()))
                 .will(
                         answer(
                                 new Answer5<String, Integer, String, Integer, String, String[]>() {
@@ -586,9 +580,7 @@ public class StubbingWithAdditionalAnswersTest {
             throws Exception {
         final IMethods target = mock(IMethods.class);
 
-        given(
-                        iMethods.fiveArgumentVarArgsMethod(
-                                anyInt(), any(), anyInt(), any(), any(String[].class)))
+        given(iMethods.fiveArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(), any()))
                 .will(
                         answerVoid(
                                 new VoidAnswer5<Integer, String, Integer, String, String[]>() {
@@ -613,9 +605,7 @@ public class StubbingWithAdditionalAnswersTest {
     public void can_return_based_on_strongly_typed_six_parameter_var_args_function()
             throws Exception {
         final IMethods target = mock(IMethods.class);
-        given(
-                        iMethods.sixArgumentVarArgsMethod(
-                                anyInt(), any(), anyInt(), any(), any(), any(String[].class)))
+        given(iMethods.sixArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(), any(), any()))
                 .will(
                         answer(
                                 new Answer6<
@@ -651,9 +641,7 @@ public class StubbingWithAdditionalAnswersTest {
     public void will_execute_a_void_returning_strongly_typed_six_parameter_var_args_function()
             throws Exception {
         final IMethods target = mock(IMethods.class);
-        given(
-                        iMethods.sixArgumentVarArgsMethod(
-                                anyInt(), any(), anyInt(), any(), any(), any(String[].class)))
+        given(iMethods.sixArgumentVarArgsMethod(anyInt(), any(), anyInt(), any(), any(), any()))
                 .will(
                         answerVoid(
                                 new VoidAnswer6<
@@ -679,7 +667,7 @@ public class StubbingWithAdditionalAnswersTest {
 
     @Test
     public void can_accept_array_supertype_for_strongly_typed_var_args_function() throws Exception {
-        given(iMethods.varargs(any(String[].class)))
+        given(iMethods.varargs(any()))
                 .will(
                         answer(
                                 new Answer1<Integer, Object[]>() {
@@ -693,7 +681,7 @@ public class StubbingWithAdditionalAnswersTest {
 
     @Test
     public void can_accept_non_vararg_answer_on_var_args_function() throws Exception {
-        given(iMethods.varargs(any(String[].class)))
+        given(iMethods.varargs(any()))
                 .will(
                         answer(
                                 new Answer2<Integer, String, String>() {
@@ -707,7 +695,7 @@ public class StubbingWithAdditionalAnswersTest {
 
     @Test
     public void should_work_with_var_args_with_no_elements() throws Exception {
-        given(iMethods.varargs(any(String[].class)))
+        given(iMethods.varargs(any()))
                 .will(
                         answer(
                                 new Answer1<Integer, String[]>() {
@@ -721,7 +709,7 @@ public class StubbingWithAdditionalAnswersTest {
 
     @Test
     public void should_work_with_array_var_args() throws Exception {
-        given(iMethods.arrayVarargsMethod(any(String[][].class)))
+        given(iMethods.arrayVarargsMethod(any()))
                 .will(
                         answer(
                                 new Answer1<Integer, String[][]>() {
