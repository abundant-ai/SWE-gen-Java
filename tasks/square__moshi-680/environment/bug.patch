diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4287d413..f7e745f9 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,46 @@
 Change Log
 ==========
 
+## Version 1.7.0
+
+_2018-09-24_
+
+ * New: `EnumJsonAdapter` makes it easy to specify a fallback value for unknown enum constants.
+   By default Moshi throws an `JsonDataException` if it reads an unknown enum constant. With this
+   you can specify a fallback value or null.
+
+   ```java
+   new Moshi.Builder()
+       .add(EnumJsonAdapter.create(IsoCurrency.class)
+           .withUnknownFallback(IsoCurrency.USD))
+       .build();
+   ```
+
+   Note that this adapter is in the optional `moshi-adapters` module.
+
+   ```groovy
+   implementation 'com.squareup.moshi:moshi-adapters:1.7.0'
+   ```
+
+ * New: Embed R8/ProGuard rules in the `.jar` file.
+ * New: Use `@CheckReturnValue` in more places. We hope this will encourage you to use `skipName()`
+   instead of `nextName()` for better performance!
+ * New: Forbid automatic encoding of platform classes in `androidx`. As with `java.*`, `android.*`,
+   and `kotlin.*` Moshi wants you to specify how to encode platform types.
+ * New: Improve error reporting when creating an adapter fails.
+ * New: Upgrade to Okio 1.15.0. We don't yet require Kotlin-friendly Okio 2.x but Moshi works fine
+   with that release.
+
+   ```groovy
+   implementation 'com.squareup.okio:okio:1.15.0'
+   ```
+
+ * Fix: Return false from `JsonReader.hasNext()` at document's end.
+ * Fix: Improve code gen to handle several broken cases. Our generated adapters had problems with
+   nulls, nested parameterized types, private transient properties, generic type aliases, fields
+   with dollar signs in their names, and named companion objects.
+
+
 ## Version 1.6.0
 
 _2018-05-14_
diff --git a/README.md b/README.md
index 7314f1a5..91d7c800 100644
--- a/README.md
+++ b/README.md
@@ -500,12 +500,12 @@ The reflection adapter requires the following additional dependency:
 <dependency>
   <groupId>com.squareup.moshi</groupId>
   <artifactId>moshi-kotlin</artifactId>
-  <version>1.6.0</version>
+  <version>1.7.0</version>
 </dependency>
 ```
 
 ```groovy
-implementation 'com.squareup.moshi:moshi-kotlin:1.6.0'
+implementation 'com.squareup.moshi:moshi-kotlin:1.7.0'
 ```
 
 Note that the reflection adapter transitively depends on the `kotlin-reflect` library which is a
@@ -535,13 +535,13 @@ add the following to your build to enable the annotation processor:
 <dependency>
   <groupId>com.squareup.moshi</groupId>
   <artifactId>moshi-kotlin-codegen</artifactId>
-  <version>1.6.0</version>
+  <version>1.7.0</version>
   <scope>provided</scope>
 </dependency>
 ```
 
 ```groovy
-kapt 'com.squareup.moshi:moshi-kotlin-codegen:1.6.0'
+kapt 'com.squareup.moshi:moshi-kotlin-codegen:1.7.0'
 ```
 
 You must also have the `kotlin-stdlib` dependency on the classpath during compilation in order for
@@ -567,12 +567,12 @@ Download [the latest JAR][dl] or depend via Maven:
 <dependency>
   <groupId>com.squareup.moshi</groupId>
   <artifactId>moshi</artifactId>
-  <version>1.6.0</version>
+  <version>1.7.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-implementation 'com.squareup.moshi:moshi:1.6.0'
+implementation 'com.squareup.moshi:moshi:1.7.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/adapters/pom.xml b/adapters/pom.xml
index 81264c91..bde57f56 100644
--- a/adapters/pom.xml
+++ b/adapters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.7.0-SNAPSHOT</version>
+    <version>1.8.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>moshi-adapters</artifactId>
diff --git a/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java b/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java
index 1e805c10..1bc91f7e 100644
--- a/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java
+++ b/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java
@@ -21,7 +21,6 @@ import com.squareup.moshi.JsonReader;
 import com.squareup.moshi.JsonWriter;
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.Types;
-import com.squareup.moshi.internal.Util;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -35,13 +34,14 @@ import javax.annotation.CheckReturnValue;
  * decoding the JSON. This factory's adapters expect JSON in the format of a JSON object with a
  * key whose value is a label that determines the type to which to map the JSON object.
  */
-public final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
+// TODO(jwilson): make this class public in Moshi 1.8.
+final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
   final Class<T> baseType;
   final String labelKey;
   final Map<String, Type> labelToType = new LinkedHashMap<>();
 
   /**
-   * @param baseType The base type for which this factory will create adapters.
+   * @param baseType The base type for which this factory will create adapters. Cannot be Object.
    * @param labelKey The key in the JSON object whose value determines the type to which to map the
    *     JSON object.
    */
@@ -49,6 +49,10 @@ public final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
   public static <T> RuntimeJsonAdapterFactory<T> of(Class<T> baseType, String labelKey) {
     if (baseType == null) throw new NullPointerException("baseType == null");
     if (labelKey == null) throw new NullPointerException("labelKey == null");
+    if (baseType == Object.class) {
+      throw new IllegalArgumentException(
+          "The base type must not be Object. Consider using a marker interface.");
+    }
     return new RuntimeJsonAdapterFactory<>(baseType, labelKey);
   }
 
@@ -86,10 +90,9 @@ public final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
       typeToLabel.put(typeValue, label);
       labelToAdapter.put(label, moshi.adapter(typeValue));
     }
-    JsonAdapter<Object> objectJsonAdapter = moshi.nextAdapter(
-        this, Object.class, Util.NO_ANNOTATIONS);
-    return new RuntimeJsonAdapter(labelKey, labelToAdapter, typeToLabel, objectJsonAdapter)
-        .nullSafe();
+    JsonAdapter<Object> objectJsonAdapter = moshi.adapter(Object.class);
+    return new RuntimeJsonAdapter(labelKey, labelToAdapter, typeToLabel,
+        objectJsonAdapter).nullSafe();
   }
 
   static final class RuntimeJsonAdapter extends JsonAdapter<Object> {
diff --git a/adapters/src/test/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactoryTest.java b/adapters/src/test/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactoryTest.java
index 6e04f53a..2998aaac 100644
--- a/adapters/src/test/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactoryTest.java
+++ b/adapters/src/test/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactoryTest.java
@@ -171,6 +171,16 @@ public final class RuntimeJsonAdapterFactoryTest {
     assertThat(reader.peek()).isEqualTo(JsonReader.Token.END_DOCUMENT);
   }
 
+  @Test public void disallowObjectBaseType() {
+    try {
+      RuntimeJsonAdapterFactory.of(Object.class, "type");
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertThat(expected).hasMessage(
+          "The base type must not be Object. Consider using a marker interface.");
+    }
+  }
+
   interface Message {
   }
 
diff --git a/examples/pom.xml b/examples/pom.xml
index aeff13dc..4dd8a72e 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.7.0-SNAPSHOT</version>
+    <version>1.8.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>moshi-examples</artifactId>
diff --git a/kotlin/codegen/pom.xml b/kotlin/codegen/pom.xml
index 37d28739..1bd061b7 100644
--- a/kotlin/codegen/pom.xml
+++ b/kotlin/codegen/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.7.0-SNAPSHOT</version>
+    <version>1.8.0-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
index 5156e3d9..f2769211 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
@@ -135,7 +135,7 @@ internal class AdapterGenerator(
     result.addProperty(optionsProperty)
     for (uniqueAdapter in propertyList.distinctBy { it.delegateKey }) {
       result.addProperty(uniqueAdapter.delegateKey.generateProperty(
-          nameAllocator, typeRenderer, moshiParam))
+          nameAllocator, typeRenderer, moshiParam, uniqueAdapter.name))
     }
 
     result.addFunction(generateToStringFun())
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
index 3165feda..45e35a6d 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
@@ -43,7 +43,8 @@ internal data class DelegateKey(
   fun generateProperty(
     nameAllocator: NameAllocator,
     typeRenderer: TypeRenderer,
-    moshiParameter: ParameterSpec
+    moshiParameter: ParameterSpec,
+    propertyName: String
   ): PropertySpec {
     val qualifierNames = jsonQualifiers.joinToString("") {
       "At${(it.type as ClassName).simpleName}"
@@ -53,27 +54,23 @@ internal data class DelegateKey(
 
     val adapterTypeName = JsonAdapter::class.asClassName().parameterizedBy(type)
     val standardArgs = arrayOf(moshiParameter,
-        if (type is ClassName && jsonQualifiers.isEmpty()) {
-          ""
-        } else {
-          CodeBlock.of("<%T>", type)
-        },
+        CodeBlock.of("<%T>", type),
         typeRenderer.render(type))
-    val standardArgsSize = standardArgs.size + 1
+    var standardArgsSize = standardArgs.size
     val (initializerString, args) = when {
-      jsonQualifiers.isEmpty() -> "" to emptyArray()
+      // TODO: Reference top-level function emptySet().
+      // TODO: https://github.com/square/kotlinpoet/issues/433/
+      jsonQualifiers.isEmpty() -> ", kotlin.collections.emptySet()" to emptyArray()
       else -> {
-        ", %${standardArgsSize}T.getFieldJsonQualifierAnnotations(javaClass, " +
-            "%${standardArgsSize + 1}S)" to arrayOf(Types::class.asTypeName(), adapterName)
+        ", %${++standardArgsSize}T.getFieldJsonQualifierAnnotations(javaClass, " +
+            "%${++standardArgsSize}S)" to arrayOf(Types::class.asTypeName(), adapterName)
       }
     }
-    val finalArgs = arrayOf(*standardArgs, *args)
-
-    val nullModifier = if (nullable) ".nullSafe()" else ".nonNull()"
+    val finalArgs = arrayOf(*standardArgs, *args, propertyName)
 
     return PropertySpec.builder(adapterName, adapterTypeName, KModifier.PRIVATE)
         .addAnnotations(jsonQualifiers)
-        .initializer("%1N.adapter%2L(%3L$initializerString)$nullModifier", *finalArgs)
+        .initializer("%1N.adapter%2L(%3L$initializerString, %${++standardArgsSize}S)", *finalArgs)
         .build()
   }
 }
diff --git a/kotlin/reflect/pom.xml b/kotlin/reflect/pom.xml
index fa924cb7..97a062b0 100644
--- a/kotlin/reflect/pom.xml
+++ b/kotlin/reflect/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.7.0-SNAPSHOT</version>
+    <version>1.8.0-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/kotlin/reflect/src/main/java/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapter.kt b/kotlin/reflect/src/main/java/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapter.kt
index d32ae5c3..8e4d16b1 100644
--- a/kotlin/reflect/src/main/java/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapter.kt
+++ b/kotlin/reflect/src/main/java/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapter.kt
@@ -229,7 +229,7 @@ class KotlinJsonAdapterFactory : JsonAdapter.Factory {
       val name = jsonAnnotation?.name ?: property.name
       val resolvedPropertyType = resolve(type, rawType, property.returnType.javaType)
       val adapter = moshi.adapter<Any>(
-          resolvedPropertyType, Util.jsonAnnotations(allAnnotations.toTypedArray()))
+          resolvedPropertyType, Util.jsonAnnotations(allAnnotations.toTypedArray()), property.name)
 
       bindingsByName[property.name] = KotlinJsonAdapter.Binding(name, adapter,
           property as KProperty1<Any, Any?>, parameter)
diff --git a/kotlin/tests/pom.xml b/kotlin/tests/pom.xml
index 4c9c541e..8996cd6f 100644
--- a/kotlin/tests/pom.xml
+++ b/kotlin/tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.7.0-SNAPSHOT</version>
+    <version>1.8.0-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
@@ -108,7 +108,7 @@
               <sourceDirs>
                 <sourceDir>src/test/kotlin</sourceDir>
                 <sourceDir>src/test/java</sourceDir>
-                <sourceDir>target/generated-sources/kapt/test</sourceDir>
+                <sourceDir>target/generated-sources/kaptKotlin/test</sourceDir>
               </sourceDirs>
             </configuration>
           </execution>
@@ -144,7 +144,9 @@
           <execution>
             <id>java-test-compile</id>
             <phase>test-compile</phase>
-            <goals> <goal>testCompile</goal> </goals>
+            <goals>
+              <goal>testCompile</goal>
+            </goals>
           </execution>
         </executions>
       </plugin>
diff --git a/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/codgen/GeneratedAdaptersTest.kt b/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/codgen/GeneratedAdaptersTest.kt
index be90a498..793cdb92 100644
--- a/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/codgen/GeneratedAdaptersTest.kt
+++ b/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/codgen/GeneratedAdaptersTest.kt
@@ -413,7 +413,7 @@ class GeneratedAdaptersTest {
       jsonAdapter.fromJson("{\"a\":null}")
       fail()
     } catch (expected: JsonDataException) {
-      assertThat(expected).hasMessage("Unexpected null at \$.a")
+      assertThat(expected).hasMessage("Non-null value 'a' was null at \$.a")
     }
   }
 
@@ -432,7 +432,10 @@ class GeneratedAdaptersTest {
   }
 
   @JsonClass(generateAdapter = true)
-  class HasNonNullConstructorParameter(val a: String)
+  data class HasNonNullConstructorParameter(val a: String)
+
+  @JsonClass(generateAdapter = true)
+  data class HasNullableConstructorParameter(val a: String?)
 
   @Test fun explicitNull() {
     val moshi = Moshi.Builder().build()
@@ -592,7 +595,7 @@ class GeneratedAdaptersTest {
       jsonAdapter.fromJson("{\"a\":null}")
       fail()
     } catch (expected: JsonDataException) {
-      assertThat(expected).hasMessage("Unexpected null at \$.a")
+      assertThat(expected).hasMessage("Non-null value 'a' was null at \$.a")
     }
   }
 
@@ -1083,6 +1086,50 @@ class GeneratedAdaptersTest {
     assertThat(adapter.fromJson("null")).isNull()
     assertThat(adapter.toJson(null)).isEqualTo("null")
   }
+
+  @Retention(AnnotationRetention.RUNTIME)
+  annotation class Nullable
+
+  @Test fun delegatesToInstalledAdaptersBeforeNullChecking() {
+    val moshi = Moshi.Builder()
+        .add(object {
+          @FromJson fun fromJson(@Nullable string: String?): String {
+            return string ?: "fallback"
+          }
+
+          @ToJson fun toJson(@Nullable value: String?): String {
+            return value ?: "fallback"
+          }
+        })
+        .build()
+
+    val hasNonNullConstructorParameterAdapter =
+        moshi.adapter(HasNonNullConstructorParameter::class.java)
+    assertThat(hasNonNullConstructorParameterAdapter
+        .fromJson("{\"a\":null}")).isEqualTo(HasNonNullConstructorParameter("fallback"))
+
+    val hasNullableConstructorParameterAdapter =
+        moshi.adapter(HasNullableConstructorParameter::class.java)
+    assertThat(hasNullableConstructorParameterAdapter
+        .fromJson("{\"a\":null}")).isEqualTo(HasNullableConstructorParameter("fallback"))
+    assertThat(hasNullableConstructorParameterAdapter
+        .toJson(HasNullableConstructorParameter(null))).isEqualTo("{\"a\":\"fallback\"}")
+  }
+
+  @JsonClass(generateAdapter = true)
+  data class HasNullableTypeWithGeneratedAdapter(val a: HasNonNullConstructorParameter?)
+
+  @Test fun delegatesToInstalledAdaptersBeforeNullCheckingWithGeneratedAdapter() {
+    val moshi = Moshi.Builder().build()
+    val adapter = moshi.adapter(HasNullableTypeWithGeneratedAdapter::class.java)
+
+    val encoded = HasNullableTypeWithGeneratedAdapter(null)
+    assertThat(adapter.toJson(encoded)).isEqualTo("""{}""")
+    assertThat(adapter.serializeNulls().toJson(encoded)).isEqualTo("""{"a":null}""")
+
+    val decoded = adapter.fromJson("""{"a":null}""")!!
+    assertThat(decoded.a).isEqualTo(null)
+  }
 }
 
 // Has to be outside to avoid Types seeing an owning class
diff --git a/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapterTest.kt b/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapterTest.kt
index 89b21dec..89938374 100644
--- a/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapterTest.kt
+++ b/kotlin/tests/src/test/kotlin/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapterTest.kt
@@ -170,7 +170,9 @@ class KotlinJsonAdapterTest {
     }
   }
 
-  class HasNonNullConstructorParameter(val a: String)
+  data class HasNonNullConstructorParameter(val a: String)
+
+  data class HasNullableConstructorParameter(val a: String?)
 
   @Test fun nonNullPropertySetToNullFailsWithJsonDataException() {
     val moshi = Moshi.Builder().add(KotlinJsonAdapterFactory()).build()
@@ -853,6 +855,31 @@ class KotlinJsonAdapterTest {
     assertThat(adapter.toJson(value)).isEqualTo(json)
   }
 
+  @Retention(RUNTIME)
+  annotation class Nullable
+
+  @Test fun delegatesToInstalledAdaptersBeforeNullChecking() {
+    val moshi = Moshi.Builder()
+        .add(object {
+          @FromJson fun fromJson(@Nullable string: String?): String {
+            return string ?: "fallback"
+          }
+
+          @ToJson fun toJson(@Nullable value: String?): String {
+            return value ?: "fallback"
+          }
+        })
+        .build()
+
+    assertThat(moshi.adapter(HasNonNullConstructorParameter::class.java)
+        .fromJson("{\"a\":null}")).isEqualTo(HasNonNullConstructorParameter("fallback"))
+
+    assertThat(moshi.adapter(HasNullableConstructorParameter::class.java)
+        .fromJson("{\"a\":null}")).isEqualTo(HasNullableConstructorParameter("fallback"))
+    assertThat(moshi.adapter(HasNullableConstructorParameter::class.java)
+        .toJson(HasNullableConstructorParameter(null))).isEqualTo("{\"a\":\"fallback\"}")
+  }
+
   @Test fun mixingReflectionAndCodegen() {
     val moshi = Moshi.Builder()
         .add(KotlinJsonAdapterFactory())
diff --git a/moshi/pom.xml b/moshi/pom.xml
index f091bdd0..6b885d00 100644
--- a/moshi/pom.xml
+++ b/moshi/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.7.0-SNAPSHOT</version>
+    <version>1.8.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>moshi</artifactId>
@@ -47,6 +47,17 @@
           </archive>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <excludePackageNames>com.squareup.moshi.internal:com.squareup.moshi.internal.*</excludePackageNames>
+          <links>
+            <link>https://square.github.io/okio/</link>
+          </links>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
index 8a03096f..f26230a7 100644
--- a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
@@ -53,7 +53,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
       } catch (IllegalArgumentException e) {
         String missingAnnotation = toAdapter == null ? "@ToJson" : "@FromJson";
         throw new IllegalArgumentException("No " + missingAnnotation + " adapter for "
-            + typeAnnotatedWithAnnotations(type, annotations));
+            + typeAnnotatedWithAnnotations(type, annotations), e);
       }
     } else {
       delegate = null;
diff --git a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
index aee6d55b..71d45349 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
@@ -95,14 +95,15 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
         // Look up a type adapter for this type.
         Type fieldType = resolve(type, rawType, field.getGenericType());
         Set<? extends Annotation> annotations = Util.jsonAnnotations(field);
-        JsonAdapter<Object> adapter = moshi.adapter(fieldType, annotations);
+        String fieldName = field.getName();
+        JsonAdapter<Object> adapter = moshi.adapter(fieldType, annotations, fieldName);
 
         // Create the binding between field and JSON.
         field.setAccessible(true);
 
         // Store it using the field's name. If there was already a field with this name, fail!
         Json jsonAnnotation = field.getAnnotation(Json.class);
-        String name = jsonAnnotation != null ? jsonAnnotation.name() : field.getName();
+        String name = jsonAnnotation != null ? jsonAnnotation.name() : fieldName;
         FieldBinding<Object> fieldBinding = new FieldBinding<>(name, field, adapter);
         FieldBinding<?> replaced = fieldBindings.put(name, fieldBinding);
         if (replaced != null) {
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index e04acf96..eabc01a0 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -180,10 +180,10 @@ public abstract class JsonReader implements Closeable {
   // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack will
   // grow itself up to 256 levels of nesting including the top-level document. Deeper nesting is
   // prone to trigger StackOverflowErrors.
-  int stackSize;
-  int[] scopes;
-  String[] pathNames;
-  int[] pathIndices;
+  int stackSize = 0;
+  int[] scopes = new int[32];
+  String[] pathNames = new String[32];
+  int[] pathIndices = new int[32];
 
   /** True to accept non-spec compliant JSON. */
   boolean lenient;
@@ -196,21 +196,8 @@ public abstract class JsonReader implements Closeable {
     return new JsonUtf8Reader(source);
   }
 
-  // Package-private to control subclasses.
   JsonReader() {
-    scopes = new int[32];
-    pathNames = new String[32];
-    pathIndices = new int[32];
-  }
-
-  // Package-private to control subclasses.
-  JsonReader(JsonReader copyFrom) {
-    this.stackSize = copyFrom.stackSize;
-    this.scopes = copyFrom.scopes.clone();
-    this.pathNames = copyFrom.pathNames.clone();
-    this.pathIndices = copyFrom.pathIndices.clone();
-    this.lenient = copyFrom.lenient;
-    this.failOnUnknown = copyFrom.failOnUnknown;
+    // Package-private to control subclasses.
   }
 
   final void pushScope(int newTop) {
@@ -474,32 +461,6 @@ public abstract class JsonReader implements Closeable {
     }
   }
 
-  /**
-   * Returns a new {@code JsonReader} that can read data from this {@code JsonReader} without
-   * consuming it. The returned reader becomes invalid once this one is next read or closed.
-   *
-   * For example, we can use `peek()` to lookahead and read the same data multiple times.
-   *
-   * <pre> {@code
-   *
-   *   Buffer buffer = new Buffer();
-   *   buffer.writeUtf8("[123, 456, 789]")
-   *
-   *   JsonReader jsonReader = JsonReader.of(buffer);
-   *   jsonReader.beginArray();
-   *   jsonReader.nextInt(); // Returns 123, reader contains 456, 789 and ].
-   *
-   *   JsonReader peek = reader.peekReader();
-   *   peek.nextInt() // Returns 456.
-   *   peek.nextInt() // Returns 789.
-   *   peek.endArray()
-   *
-   *   jsonReader.nextInt() // Returns 456, reader contains 789 and ].
-   * }</pre>
-   */
-  // TODO(jwilson): make this public once it's supported in JsonUtf8Reader.
-  abstract JsonReader peekJson();
-
   /**
    * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
    * the current location in the JSON value.
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
index 16c478ae..71d8ddcd 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
@@ -31,6 +31,7 @@ final class JsonUtf8Reader extends JsonReader {
   private static final ByteString UNQUOTED_STRING_TERMINALS
       = ByteString.encodeUtf8("{}[]:, \n\t\r\f/\\;#=");
   private static final ByteString LINEFEED_OR_CARRIAGE_RETURN = ByteString.encodeUtf8("\n\r");
+  private static final ByteString CLOSING_BLOCK_COMMENT = ByteString.encodeUtf8("*/");
 
   private static final int PEEKED_NONE = 0;
   private static final int PEEKED_BEGIN_OBJECT = 1;
@@ -990,11 +991,9 @@ final class JsonUtf8Reader extends JsonReader {
             // skip a /* c-style comment */
             buffer.readByte(); // '/'
             buffer.readByte(); // '*'
-            if (!skipTo("*/")) {
+            if (!skipToEndOfBlockComment()) {
               throw syntaxError("Unterminated comment");
             }
-            buffer.readByte(); // '*'
-            buffer.readByte(); // '/'
             p = 0;
             continue;
 
@@ -1043,24 +1042,13 @@ final class JsonUtf8Reader extends JsonReader {
   }
 
   /**
-   * @param toFind a string to search for. Must not contain a newline.
+   * Skips through the next closing block comment.
    */
-  private boolean skipTo(String toFind) throws IOException {
-    outer:
-    for (; source.request(toFind.length()); ) {
-      for (int c = 0; c < toFind.length(); c++) {
-        if (buffer.getByte(c) != toFind.charAt(c)) {
-          buffer.readByte();
-          continue outer;
-        }
-      }
-      return true;
-    }
-    return false;
-  }
-
-  @Override JsonReader peekJson() {
-    throw new UnsupportedOperationException("TODO");
+  private boolean skipToEndOfBlockComment() throws IOException {
+    long index = source.indexOf(CLOSING_BLOCK_COMMENT);
+    boolean found = index != -1;
+    buffer.skip(found ? index + CLOSING_BLOCK_COMMENT.size() : buffer.size());
+    return found;
   }
 
   @Override public String toString() {
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java b/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
index 4246d3d8..fb3991b9 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
@@ -20,11 +20,10 @@ import java.math.BigDecimal;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.ListIterator;
 import java.util.Map;
 import javax.annotation.Nullable;
 
-import static com.squareup.moshi.JsonScope.CLOSED;
-
 /**
  * This class reads a JSON document by traversing a Java object comprising maps, lists, and JSON
  * primitives. It does depth-first traversal keeping a stack starting with the root object. During
@@ -33,11 +32,11 @@ import static com.squareup.moshi.JsonScope.CLOSED;
  * <ul>
  *   <li>The next element to act upon is on the top of the stack.
  *   <li>When the top of the stack is a {@link List}, calling {@link #beginArray()} replaces the
- *       list with a {@link JsonIterator}. The first element of the iterator is pushed on top of the
+ *       list with a {@link ListIterator}. The first element of the iterator is pushed on top of the
  *       iterator.
  *   <li>Similarly, when the top of the stack is a {@link Map}, calling {@link #beginObject()}
- *       replaces the map with an {@link JsonIterator} of its entries. The first element of the
- *       iterator is pushed on top of the iterator.
+ *       replaces the map with an {@link Iterator} of its entries. The first element of the iterator
+ *       is pushed on top of the iterator.
  *   <li>When the top of the stack is a {@link Map.Entry}, calling {@link #nextName()} returns the
  *       entry's key and replaces the entry with its value on the stack.
  *   <li>When an element is consumed it is popped. If the new top of the stack has a non-exhausted
@@ -50,31 +49,17 @@ final class JsonValueReader extends JsonReader {
   /** Sentinel object pushed on {@link #stack} when the reader is closed. */
   private static final Object JSON_READER_CLOSED = new Object();
 
-  private Object[] stack;
+  private Object[] stack = new Object[32];
 
   JsonValueReader(Object root) {
     scopes[stackSize] = JsonScope.NONEMPTY_DOCUMENT;
-    stack = new Object[32];
     stack[stackSize++] = root;
   }
 
-  /** Copy-constructor makes a deep copy for peeking. */
-  JsonValueReader(JsonValueReader copyFrom) {
-    super(copyFrom);
-
-    stack = copyFrom.stack.clone();
-    for (int i = 0; i < stackSize; i++) {
-      if (stack[i] instanceof JsonIterator) {
-        stack[i] = ((JsonIterator) stack[i]).clone();
-      }
-    }
-  }
-
   @Override public void beginArray() throws IOException {
     List<?> peeked = require(List.class, Token.BEGIN_ARRAY);
 
-    JsonIterator iterator = new JsonIterator(
-        Token.END_ARRAY, peeked.toArray(new Object[peeked.size()]), 0);
+    ListIterator<?> iterator = peeked.listIterator();
     stack[stackSize - 1] = iterator;
     scopes[stackSize - 1] = JsonScope.EMPTY_ARRAY;
     pathIndices[stackSize - 1] = 0;
@@ -86,8 +71,8 @@ final class JsonValueReader extends JsonReader {
   }
 
   @Override public void endArray() throws IOException {
-    JsonIterator peeked = require(JsonIterator.class, Token.END_ARRAY);
-    if (peeked.endToken != Token.END_ARRAY || peeked.hasNext()) {
+    ListIterator<?> peeked = require(ListIterator.class, Token.END_ARRAY);
+    if (peeked.hasNext()) {
       throw typeMismatch(peeked, Token.END_ARRAY);
     }
     remove();
@@ -96,8 +81,7 @@ final class JsonValueReader extends JsonReader {
   @Override public void beginObject() throws IOException {
     Map<?, ?> peeked = require(Map.class, Token.BEGIN_OBJECT);
 
-    JsonIterator iterator = new JsonIterator(
-        Token.END_OBJECT, peeked.entrySet().toArray(new Object[peeked.size()]), 0);
+    Iterator<?> iterator = peeked.entrySet().iterator();
     stack[stackSize - 1] = iterator;
     scopes[stackSize - 1] = JsonScope.EMPTY_OBJECT;
 
@@ -108,8 +92,8 @@ final class JsonValueReader extends JsonReader {
   }
 
   @Override public void endObject() throws IOException {
-    JsonIterator peeked = require(JsonIterator.class, Token.END_OBJECT);
-    if (peeked.endToken != Token.END_OBJECT || peeked.hasNext()) {
+    Iterator<?> peeked = require(Iterator.class, Token.END_OBJECT);
+    if (peeked instanceof ListIterator || peeked.hasNext()) {
       throw typeMismatch(peeked, Token.END_OBJECT);
     }
     pathNames[stackSize - 1] = null;
@@ -128,7 +112,8 @@ final class JsonValueReader extends JsonReader {
 
     // If the top of the stack is an iterator, take its first element and push it on the stack.
     Object peeked = stack[stackSize - 1];
-    if (peeked instanceof JsonIterator) return ((JsonIterator) peeked).endToken;
+    if (peeked instanceof ListIterator) return Token.END_ARRAY;
+    if (peeked instanceof Iterator) return Token.END_OBJECT;
     if (peeked instanceof List) return Token.BEGIN_ARRAY;
     if (peeked instanceof Map) return Token.BEGIN_OBJECT;
     if (peeked instanceof Map.Entry) return Token.NAME;
@@ -318,10 +303,6 @@ final class JsonValueReader extends JsonReader {
     }
   }
 
-  @Override JsonReader peekJson() {
-    return new JsonValueReader(this);
-  }
-
   @Override void promoteNameToValue() throws IOException {
     if (hasNext()) {
       String name = nextName();
@@ -332,7 +313,7 @@ final class JsonValueReader extends JsonReader {
   @Override public void close() throws IOException {
     Arrays.fill(stack, 0, stackSize, null);
     stack[0] = JSON_READER_CLOSED;
-    scopes[0] = CLOSED;
+    scopes[0] = JsonScope.CLOSED;
     stackSize = 1;
   }
 
@@ -393,33 +374,4 @@ final class JsonValueReader extends JsonReader {
       }
     }
   }
-
-  static final class JsonIterator implements Iterator<Object>, Cloneable {
-    final Token endToken;
-    final Object[] array;
-    int next;
-
-    JsonIterator(Token endToken, Object[] array, int next) {
-      this.endToken = endToken;
-      this.array = array;
-      this.next = next;
-    }
-
-    @Override public boolean hasNext() {
-      return next < array.length;
-    }
-
-    @Override public Object next() {
-      return array[next++];
-    }
-
-    @Override public void remove() {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override protected JsonIterator clone() {
-      // No need to copy the array; it's read-only.
-      return new JsonIterator(endToken, array, next);
-    }
-  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 8d39c474..26db3162 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -90,8 +90,18 @@ public final class Moshi {
   }
 
   @CheckReturnValue
-  @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
   public <T> JsonAdapter<T> adapter(Type type, Set<? extends Annotation> annotations) {
+    return adapter(type, annotations, null);
+  }
+
+  /**
+   * @param fieldName An optional field name associated with this type. The field name is used as a
+   * hint for better adapter lookup error messages for nested structures.
+   */
+  @CheckReturnValue
+  @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
+  public <T> JsonAdapter<T> adapter(Type type, Set<? extends Annotation> annotations,
+      @Nullable String fieldName) {
     if (type == null) {
       throw new NullPointerException("type == null");
     }
@@ -123,8 +133,10 @@ public final class Moshi {
     }
 
     // Prepare for re-entrant calls, then ask each factory to create a type adapter.
-    DeferredAdapter<T> deferredAdapter = new DeferredAdapter<>(cacheKey);
+    DeferredAdapter<T> deferredAdapter = new DeferredAdapter<>(type, fieldName, cacheKey);
+
     deferredAdapters.add(deferredAdapter);
+    int lastIndex = deferredAdapters.size() - 1;
     try {
       for (int i = 0, size = factories.size(); i < size; i++) {
         JsonAdapter<T> result = (JsonAdapter<T>) factories.get(i).create(type, annotations, this);
@@ -133,12 +145,19 @@ public final class Moshi {
           synchronized (adapterCache) {
             adapterCache.put(cacheKey, result);
           }
+          // Remove the type or field name only when we succeed in creating the adapter,
+          // so we have the full stack  at the top level.
+          deferredAdapters.remove(lastIndex);
           return result;
         }
       }
+    } catch (IllegalArgumentException e) {
+      if (lastIndex == 0) { // Rewrite the exception at the top level.
+        e = errorWithFields(deferredAdapters, e);
+      }
+      throw e;
     } finally {
-      deferredAdapters.remove(deferredAdapters.size() - 1);
-      if (deferredAdapters.isEmpty()) {
+      if (lastIndex == 0) {
         reentrantCalls.remove();
       }
     }
@@ -181,6 +200,27 @@ public final class Moshi {
     return Arrays.asList(type, annotations);
   }
 
+  static IllegalArgumentException errorWithFields(List<DeferredAdapter<?>> typesAndFieldNames,
+      IllegalArgumentException e) {
+    int size = typesAndFieldNames.size();
+    if (size == 1 && typesAndFieldNames.get(0).fieldName == null) {
+      return e;
+    }
+    StringBuilder errorMessageBuilder = new StringBuilder(e.getMessage());
+    for (int i = size - 1; i >= 0; i--) {
+      DeferredAdapter<?> deferredAdapter = typesAndFieldNames.get(i);
+      errorMessageBuilder
+          .append("\nfor ")
+          .append(deferredAdapter.type);
+      if (deferredAdapter.fieldName != null) {
+        errorMessageBuilder
+            .append(' ')
+            .append(deferredAdapter.fieldName);
+      }
+    }
+    return new IllegalArgumentException(errorMessageBuilder.toString(), e);
+  }
+
   public static final class Builder {
     final List<JsonAdapter.Factory> factories = new ArrayList<>();
 
@@ -250,11 +290,15 @@ public final class Moshi {
    * <p>Typically this is necessary in self-referential object models, such as an {@code Employee}
    * class that has a {@code List<Employee>} field for an organization's management hierarchy.
    */
-  private static class DeferredAdapter<T> extends JsonAdapter<T> {
+  private static final class DeferredAdapter<T> extends JsonAdapter<T> {
+    final Type type;
+    final @Nullable String fieldName;
     @Nullable Object cacheKey;
     private @Nullable JsonAdapter<T> delegate;
 
-    DeferredAdapter(Object cacheKey) {
+    DeferredAdapter(Type type, @Nullable String fieldName, Object cacheKey) {
+      this.type = type;
+      this.fieldName = fieldName;
       this.cacheKey = cacheKey;
     }
 
diff --git a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java b/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
index 8bdc5234..afd24690 100644
--- a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
@@ -463,6 +463,9 @@ public final class AdapterMethodsTest {
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("No @FromJson adapter for interface "
           + "com.squareup.moshi.AdapterMethodsTest$Shape (with no annotations)");
+      assertThat(e).hasCauseExactlyInstanceOf(IllegalArgumentException.class);
+      assertThat(e.getCause()).hasMessage("No next JsonAdapter for interface "
+          + "com.squareup.moshi.AdapterMethodsTest$Shape (with no annotations)");
     }
   }
 
@@ -482,6 +485,9 @@ public final class AdapterMethodsTest {
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("No @ToJson adapter for interface "
           + "com.squareup.moshi.AdapterMethodsTest$Shape (with no annotations)");
+      assertThat(e).hasCauseExactlyInstanceOf(IllegalArgumentException.class);
+      assertThat(e.getCause()).hasMessage("No next JsonAdapter for interface "
+          + "com.squareup.moshi.AdapterMethodsTest$Shape (with no annotations)");
     }
   }
 
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonCodecFactory.java b/moshi/src/test/java/com/squareup/moshi/JsonCodecFactory.java
index a9997497..1bab51a6 100644
--- a/moshi/src/test/java/com/squareup/moshi/JsonCodecFactory.java
+++ b/moshi/src/test/java/com/squareup/moshi/JsonCodecFactory.java
@@ -96,38 +96,9 @@ abstract class JsonCodecFactory {
       }
     };
 
-    final JsonCodecFactory valuePeek = new JsonCodecFactory() {
-      @Override public JsonReader newReader(String json) throws IOException {
-        return value.newReader(json).peekJson();
-      }
-
-      // TODO(jwilson): fix precision checks and delete his method.
-      @Override boolean implementsStrictPrecision() {
-        return false;
-      }
-
-      @Override JsonWriter newWriter() {
-        return value.newWriter();
-      }
-
-      @Override String json() {
-        return value.json();
-      }
-
-      // TODO(jwilson): support BigDecimal and BigInteger and delete his method.
-      @Override boolean supportsBigNumbers() {
-        return false;
-      }
-
-      @Override public String toString() {
-        return "ValuePeek";
-      }
-    };
-
     return Arrays.asList(
         new Object[] { utf8 },
-        new Object[] { value },
-        new Object[] { valuePeek });
+        new Object[] { value });
   }
 
   abstract JsonReader newReader(String json) throws IOException;
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonQualifiersTest.java b/moshi/src/test/java/com/squareup/moshi/JsonQualifiersTest.java
index 0dfe77ef..2493328b 100644
--- a/moshi/src/test/java/com/squareup/moshi/JsonQualifiersTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/JsonQualifiersTest.java
@@ -332,8 +332,16 @@ public final class JsonQualifiersTest {
       moshi.adapter(StringAndFooString.class);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("No @FromJson adapter for class java.lang.String "
+      assertThat(expected).hasMessage("No @FromJson adapter for class java.lang.String annotated "
+          + "[@com.squareup.moshi.JsonQualifiersTest$FooPrefix()]"
+          + "\nfor class java.lang.String b"
+          + "\nfor class com.squareup.moshi.JsonQualifiersTest$StringAndFooString");
+      assertThat(expected).hasCauseExactlyInstanceOf(IllegalArgumentException.class);
+      assertThat(expected.getCause()).hasMessage("No @FromJson adapter for class java.lang.String "
           + "annotated [@com.squareup.moshi.JsonQualifiersTest$FooPrefix()]");
+      assertThat(expected.getCause()).hasCauseExactlyInstanceOf(IllegalArgumentException.class);
+      assertThat(expected.getCause().getCause()).hasMessage("No next JsonAdapter for class "
+          + "java.lang.String annotated [@com.squareup.moshi.JsonQualifiersTest$FooPrefix()]");
     }
   }
 
@@ -353,8 +361,16 @@ public final class JsonQualifiersTest {
       moshi.adapter(StringAndFooString.class);
       fail();
     } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("No @ToJson adapter for class java.lang.String "
+      assertThat(expected).hasMessage("No @ToJson adapter for class java.lang.String annotated "
+          + "[@com.squareup.moshi.JsonQualifiersTest$FooPrefix()]"
+          + "\nfor class java.lang.String b"
+          + "\nfor class com.squareup.moshi.JsonQualifiersTest$StringAndFooString");
+      assertThat(expected).hasCauseExactlyInstanceOf(IllegalArgumentException.class);
+      assertThat(expected.getCause()).hasMessage("No @ToJson adapter for class java.lang.String "
           + "annotated [@com.squareup.moshi.JsonQualifiersTest$FooPrefix()]");
+      assertThat(expected.getCause()).hasCauseExactlyInstanceOf(IllegalArgumentException.class);
+      assertThat(expected.getCause().getCause()).hasMessage("No next JsonAdapter for class "
+          + "java.lang.String annotated [@com.squareup.moshi.JsonQualifiersTest$FooPrefix()]");
     }
   }
 
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java b/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java
index 8f5c0450..ea1d9524 100644
--- a/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/JsonReaderTest.java
@@ -985,103 +985,4 @@ public final class JsonReaderTest {
     reader.readJsonValue();
     assertThat(reader.hasNext()).isFalse();
   }
-
-  @Test public void basicPeekJson() throws IOException {
-    JsonReader reader = newReader("{\"a\":12,\"b\":[34,56],\"c\":78}");
-    assumeTrue(reader instanceof JsonValueReader); // Not implemented for JsonUtf8Reader yet!
-    reader.beginObject();
-    assertThat(reader.nextName()).isEqualTo("a");
-    assertThat(reader.nextInt()).isEqualTo(12);
-    assertThat(reader.nextName()).isEqualTo("b");
-    reader.beginArray();
-    assertThat(reader.nextInt()).isEqualTo(34);
-
-    // Peek.
-    JsonReader peekReader = reader.peekJson();
-    assertThat(peekReader.nextInt()).isEqualTo(56);
-    peekReader.endArray();
-    assertThat(peekReader.nextName()).isEqualTo("c");
-    assertThat(peekReader.nextInt()).isEqualTo(78);
-    peekReader.endObject();
-    assertThat(peekReader.peek()).isEqualTo(JsonReader.Token.END_DOCUMENT);
-
-    // Read again.
-    assertThat(reader.nextInt()).isEqualTo(56);
-    reader.endArray();
-    assertThat(reader.nextName()).isEqualTo("c");
-    assertThat(reader.nextInt()).isEqualTo(78);
-    reader.endObject();
-    assertThat(reader.peek()).isEqualTo(JsonReader.Token.END_DOCUMENT);
-  }
-
-  /**
-   * We have a document that requires 12 operations to read. We read it step-by-step with one real
-   * reader. Before each of the real readerâ€™s operations we create a peeking reader and let it read
-   * the rest of the document.
-   */
-  @Test public void peekJsonReader() throws IOException {
-    JsonReader reader = newReader("[12,34,{\"a\":56,\"b\":78},90]");
-    assumeTrue(reader instanceof JsonValueReader); // Not implemented for JsonUtf8Reader yet!
-    for (int i = 0; i < 12; i++) {
-      readPeek12Steps(reader.peekJson(), i, 12);
-      readPeek12Steps(reader, i, i + 1);
-    }
-  }
-
-  /**
-   * Read a fragment of {@code reader}. This assumes the fixed document defined in {@link
-   * #peekJsonReader} and reads a range of it on each call.
-   */
-  private void readPeek12Steps(JsonReader reader, int from, int until) throws IOException {
-    switch (from) {
-      case 0:
-        if (until == 0) break;
-        reader.beginArray();
-        assertThat(reader.getPath()).isEqualTo("$[0]");
-      case 1:
-        if (until == 1) break;
-        assertThat(reader.nextInt()).isEqualTo(12);
-        assertThat(reader.getPath()).isEqualTo("$[1]");
-      case 2:
-        if (until == 2) break;
-        assertThat(reader.nextInt()).isEqualTo(34);
-        assertThat(reader.getPath()).isEqualTo("$[2]");
-      case 3:
-        if (until == 3) break;
-        reader.beginObject();
-        assertThat(reader.getPath()).isEqualTo("$[2].");
-      case 4:
-        if (until == 4) break;
-        assertThat(reader.nextName()).isEqualTo("a");
-        assertThat(reader.getPath()).isEqualTo("$[2].a");
-      case 5:
-        if (until == 5) break;
-        assertThat(reader.nextInt()).isEqualTo(56);
-        assertThat(reader.getPath()).isEqualTo("$[2].a");
-      case 6:
-        if (until == 6) break;
-        assertThat(reader.nextName()).isEqualTo("b");
-        assertThat(reader.getPath()).isEqualTo("$[2].b");
-      case 7:
-        if (until == 7) break;
-        assertThat(reader.nextInt()).isEqualTo(78);
-        assertThat(reader.getPath()).isEqualTo("$[2].b");
-      case 8:
-        if (until == 8) break;
-        reader.endObject();
-        assertThat(reader.getPath()).isEqualTo("$[3]");
-      case 9:
-        if (until == 9) break;
-        assertThat(reader.nextInt()).isEqualTo(90);
-        assertThat(reader.getPath()).isEqualTo("$[4]");
-      case 10:
-        if (until == 10) break;
-        reader.endArray();
-        assertThat(reader.getPath()).isEqualTo("$");
-      case 11:
-        if (until == 11) break;
-        assertThat(reader.peek()).isEqualTo(JsonReader.Token.END_DOCUMENT);
-        assertThat(reader.getPath()).isEqualTo("$");
-    }
-  }
 }
diff --git a/moshi/src/test/java/com/squareup/moshi/JsonValueWriterTest.java b/moshi/src/test/java/com/squareup/moshi/JsonValueWriterTest.java
index a3211047..7faae6ff 100644
--- a/moshi/src/test/java/com/squareup/moshi/JsonValueWriterTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/JsonValueWriterTest.java
@@ -18,6 +18,7 @@ package com.squareup.moshi;
 import java.io.IOException;
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.util.AbstractMap.SimpleEntry;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
@@ -28,7 +29,6 @@ import org.junit.Test;
 
 import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.entry;
 import static org.junit.Assert.fail;
 
 public final class JsonValueWriterTest {
@@ -57,8 +57,11 @@ public final class JsonValueWriterTest {
     writer.name("d").nullValue();
     writer.endObject();
 
-    assertThat((Map<?, ?>) writer.root()).containsExactly(
-        entry("a", "s"), entry("b", 1.5d), entry("c", true), entry("d", null));
+    assertThat((Map<String, Object>) writer.root()).containsExactly(
+        new SimpleEntry<String, Object>("a", "s"),
+        new SimpleEntry<String, Object>("b", 1.5d),
+        new SimpleEntry<String, Object>("c", true),
+        new SimpleEntry<String, Object>("d", null));
   }
 
   @Test public void repeatedNameThrows() throws IOException {
@@ -253,8 +256,11 @@ public final class JsonValueWriterTest {
     writer.name("d");
     writer.value(new Buffer().writeUtf8("null"));
     writer.endObject();
-    assertThat((Map<?, ?>) writer.root()).containsExactly(
-      entry("a", singletonList("value")), entry("b", 2.0d), entry("c", 3L), entry("d", null));
+    assertThat((Map<String, Object>) writer.root()).containsExactly(
+        new SimpleEntry<String, Object>("a", singletonList("value")),
+        new SimpleEntry<String, Object>("b", 2.0d),
+        new SimpleEntry<String, Object>("c", 3L),
+        new SimpleEntry<String, Object>("d", null));
   }
 
   /**
diff --git a/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java b/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java
index c9670476..d368ce6d 100644
--- a/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MapJsonAdapterTest.java
@@ -17,12 +17,12 @@ package com.squareup.moshi;
 
 import java.io.IOException;
 import java.lang.reflect.Type;
+import java.util.AbstractMap.SimpleEntry;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import okio.Buffer;
-import org.assertj.core.data.MapEntry;
 import org.junit.Test;
 
 import static com.squareup.moshi.TestUtil.newReader;
@@ -45,7 +45,9 @@ public final class MapJsonAdapterTest {
     Map<String, Boolean> fromJson = fromJson(
         String.class, Boolean.class, "{\"a\":true,\"b\":false,\"c\":null}");
     assertThat(fromJson).containsExactly(
-        MapEntry.entry("a", true), MapEntry.entry("b", false), MapEntry.entry("c", null));
+        new SimpleEntry<String, Boolean>("a", true),
+        new SimpleEntry<String, Boolean>("b", false),
+        new SimpleEntry<String, Boolean>("c", null));
   }
 
   @Test public void mapWithNullKeyFailsToEmit() throws Exception {
@@ -119,13 +121,15 @@ public final class MapJsonAdapterTest {
     String toJson = toJson(Integer.class, Boolean.class, map);
     assertThat(toJson).isEqualTo("{\"5\":true,\"6\":false,\"7\":null}");
 
-    Map<String, Boolean> fromJson = fromJson(
+    Map<Integer, Boolean> fromJson = fromJson(
         Integer.class, Boolean.class, "{\"5\":true,\"6\":false,\"7\":null}");
     assertThat(fromJson).containsExactly(
-        MapEntry.entry(5, true), MapEntry.entry(6, false), MapEntry.entry(7, null));
+        new SimpleEntry<Integer, Boolean>(5, true),
+        new SimpleEntry<Integer, Boolean>(6, false),
+        new SimpleEntry<Integer, Boolean>(7, null));
   }
 
-  @Test public void mapWithNonStringKeysToJsonObject() throws Exception {
+  @Test public void mapWithNonStringKeysToJsonObject() {
     Map<Integer, Boolean> map = new LinkedHashMap<>();
     map.put(5, true);
     map.put(6, false);
diff --git a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
index cefd67af..1303b630 100644
--- a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
@@ -45,6 +45,7 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
 
+@SuppressWarnings("CheckReturnValue")
 public final class MoshiTest {
   @Test public void booleanAdapter() throws Exception {
     Moshi moshi = new Moshi.Builder().build();
@@ -955,6 +956,74 @@ public final class MoshiTest {
     }
   }
 
+  static final class HasPlatformType {
+    ArrayList<String> strings;
+
+    static final class Wrapper {
+      HasPlatformType hasPlatformType;
+    }
+
+    static final class ListWrapper {
+      List<HasPlatformType> platformTypes;
+    }
+  }
+
+  @Test public void reentrantFieldErrorMessagesTopLevelMap() {
+    Moshi moshi = new Moshi.Builder().build();
+    try {
+      moshi.adapter(Types.newParameterizedType(Map.class, String.class, HasPlatformType.class));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Platform java.util.ArrayList<java.lang.String> (with no annotations) requires explicit "
+              + "JsonAdapter to be registered"
+              + "\nfor java.util.ArrayList<java.lang.String> strings"
+              + "\nfor class com.squareup.moshi.MoshiTest$HasPlatformType"
+              + "\nfor java.util.Map<java.lang.String, "
+              + "com.squareup.moshi.MoshiTest$HasPlatformType>");
+      assertThat(e).hasCauseExactlyInstanceOf(IllegalArgumentException.class);
+      assertThat(e.getCause()).hasMessage("Platform java.util.ArrayList<java.lang.String> "
+          + "(with no annotations) requires explicit JsonAdapter to be registered");
+    }
+  }
+
+  @Test public void reentrantFieldErrorMessagesWrapper() {
+    Moshi moshi = new Moshi.Builder().build();
+    try {
+      moshi.adapter(HasPlatformType.Wrapper.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Platform java.util.ArrayList<java.lang.String> (with no annotations) requires explicit "
+              + "JsonAdapter to be registered"
+              + "\nfor java.util.ArrayList<java.lang.String> strings"
+              + "\nfor class com.squareup.moshi.MoshiTest$HasPlatformType hasPlatformType"
+              + "\nfor class com.squareup.moshi.MoshiTest$HasPlatformType$Wrapper");
+      assertThat(e).hasCauseExactlyInstanceOf(IllegalArgumentException.class);
+      assertThat(e.getCause()).hasMessage("Platform java.util.ArrayList<java.lang.String> "
+          + "(with no annotations) requires explicit JsonAdapter to be registered");
+    }
+  }
+
+  @Test public void reentrantFieldErrorMessagesListWrapper() {
+    Moshi moshi = new Moshi.Builder().build();
+    try {
+      moshi.adapter(HasPlatformType.ListWrapper.class);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(
+          "Platform java.util.ArrayList<java.lang.String> (with no annotations) requires explicit "
+              + "JsonAdapter to be registered"
+              + "\nfor java.util.ArrayList<java.lang.String> strings"
+              + "\nfor class com.squareup.moshi.MoshiTest$HasPlatformType"
+              + "\nfor java.util.List<com.squareup.moshi.MoshiTest$HasPlatformType> platformTypes"
+              + "\nfor class com.squareup.moshi.MoshiTest$HasPlatformType$ListWrapper");
+      assertThat(e).hasCauseExactlyInstanceOf(IllegalArgumentException.class);
+      assertThat(e.getCause()).hasMessage("Platform java.util.ArrayList<java.lang.String> "
+          + "(with no annotations) requires explicit JsonAdapter to be registered");
+    }
+  }
+
   @Test public void qualifierWithElementsMayNotBeDirectlyRegistered() throws IOException {
     try {
       new Moshi.Builder()
diff --git a/moshi/src/test/java/com/squareup/moshi/ObjectAdapterTest.java b/moshi/src/test/java/com/squareup/moshi/ObjectAdapterTest.java
index a844d944..72d2347a 100644
--- a/moshi/src/test/java/com/squareup/moshi/ObjectAdapterTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/ObjectAdapterTest.java
@@ -22,6 +22,7 @@ import java.math.BigDecimal;
 import java.util.AbstractCollection;
 import java.util.AbstractList;
 import java.util.AbstractMap;
+import java.util.AbstractMap.SimpleEntry;
 import java.util.AbstractSet;
 import java.util.Arrays;
 import java.util.Collection;
@@ -40,10 +41,9 @@ import org.junit.Test;
 import static java.util.Collections.singletonList;
 import static java.util.Collections.singletonMap;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.entry;
 
 public final class ObjectAdapterTest {
-  @Test public void toJsonUsesRuntimeType() throws Exception {
+  @Test public void toJsonUsesRuntimeType() {
     Delivery delivery = new Delivery();
     delivery.address = "1455 Market St.";
     Pizza pizza = new Pizza();
@@ -62,7 +62,7 @@ public final class ObjectAdapterTest {
         + "}");
   }
 
-  @Test public void toJsonJavaLangObject() throws Exception {
+  @Test public void toJsonJavaLangObject() {
     Moshi moshi = new Moshi.Builder().build();
     JsonAdapter<Object> adapter = moshi.adapter(Object.class);
     assertThat(adapter.toJson(new Object())).isEqualTo("{}");
@@ -104,7 +104,7 @@ public final class ObjectAdapterTest {
         .isEqualTo(emptyDelivery);
   }
 
-  @Test public void toJsonCoercesRuntimeTypeForCollections() throws Exception {
+  @Test public void toJsonCoercesRuntimeTypeForCollections() {
     Collection<String> collection = new AbstractCollection<String>() {
       @Override public Iterator<String> iterator() {
         return Collections.singleton("A").iterator();
@@ -119,7 +119,7 @@ public final class ObjectAdapterTest {
     assertThat(adapter.toJson(collection)).isEqualTo("[\"A\"]");
   }
 
-  @Test public void toJsonCoercesRuntimeTypeForLists() throws Exception {
+  @Test public void toJsonCoercesRuntimeTypeForLists() {
     List<String> list = new AbstractList<String>() {
       @Override public String get(int i) {
         return "A";
@@ -135,7 +135,7 @@ public final class ObjectAdapterTest {
     assertThat(adapter.toJson(list)).isEqualTo("[\"A\"]");
   }
 
-  @Test public void toJsonCoercesRuntimeTypeForSets() throws Exception {
+  @Test public void toJsonCoercesRuntimeTypeForSets() {
     Set<String> set = new AbstractSet<String>() {
       @Override public Iterator<String> iterator() {
         return Collections.singleton("A").iterator();
@@ -151,7 +151,7 @@ public final class ObjectAdapterTest {
   }
 
   @Ignore // We don't support raw maps, like Map<Object, Object>. (Even if the keys are strings!)
-  @Test public void toJsonCoercesRuntimeTypeForMaps() throws Exception {
+  @Test public void toJsonCoercesRuntimeTypeForMaps() {
     Map<String, Boolean> map = new AbstractMap<String, Boolean>() {
       @Override public Set<Entry<String, Boolean>> entrySet() {
         return Collections.singletonMap("A", true).entrySet();
@@ -163,7 +163,7 @@ public final class ObjectAdapterTest {
     assertThat(adapter.toJson(map)).isEqualTo("{\"A\":true}");
   }
 
-  @Test public void toJsonUsesTypeAdapters() throws Exception {
+  @Test public void toJsonUsesTypeAdapters() {
     Object dateAdapter = new Object() {
       @ToJson Long dateToJson(Date d) {
         return d.getTime();
@@ -185,7 +185,7 @@ public final class ObjectAdapterTest {
    */
   @Test public void objectAdapterDelegatesStringNamesAndValues() throws Exception {
     JsonAdapter<String> stringAdapter = new JsonAdapter<String>() {
-      @Nullable @Override public String fromJson(JsonReader reader) throws IOException {
+      @Override public String fromJson(JsonReader reader) throws IOException {
         return reader.nextString().toUpperCase(Locale.US);
       }
 
@@ -198,8 +198,9 @@ public final class ObjectAdapterTest {
         .add(String.class, stringAdapter)
         .build();
     JsonAdapter<Object> objectAdapter = moshi.adapter(Object.class);
-    Map<?, ?> value = (Map<?, ?>) objectAdapter.fromJson("{\"a\":\"b\", \"c\":\"d\"}");
-    assertThat(value).containsExactly(entry("A", "B"), entry("C", "D"));
+    Map<String, String> value
+        = (Map<String, String>) objectAdapter.fromJson("{\"a\":\"b\", \"c\":\"d\"}");
+    assertThat(value).containsExactly(new SimpleEntry<>("A", "B"), new SimpleEntry<>("C", "D"));
   }
 
   /**
@@ -241,7 +242,7 @@ public final class ObjectAdapterTest {
   /** Confirm that the built-in adapter for Object delegates to user-supplied adapters for lists. */
   @Test public void objectAdapterDelegatesLists() throws Exception {
     JsonAdapter<List<?>> listAdapter = new JsonAdapter<List<?>>() {
-      @Override public @Nullable List<?> fromJson(JsonReader reader) throws IOException {
+      @Override public List<?> fromJson(JsonReader reader) throws IOException {
         reader.skipValue();
         return singletonList("z");
       }
@@ -262,7 +263,7 @@ public final class ObjectAdapterTest {
   /** Confirm that the built-in adapter for Object delegates to user-supplied adapters for maps. */
   @Test public void objectAdapterDelegatesMaps() throws Exception {
     JsonAdapter<Map<?, ?>> mapAdapter = new JsonAdapter<Map<?, ?>>() {
-      @Override public @Nullable Map<?, ?> fromJson(JsonReader reader) throws IOException {
+      @Override public Map<?, ?> fromJson(JsonReader reader) throws IOException {
         reader.skipValue();
         return singletonMap("x", "y");
       }
diff --git a/pom.xml b/pom.xml
index 67408d53..c6d1cc15 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.moshi</groupId>
   <artifactId>moshi-parent</artifactId>
-  <version>1.7.0-SNAPSHOT</version>
+  <version>1.8.0-SNAPSHOT</version>
   <packaging>pom</packaging>
   <name>Moshi (Parent)</name>
   <description>A modern JSON API for Android and Java</description>
@@ -29,18 +29,18 @@
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <java.version>1.7</java.version>
-    <kotlin.version>1.2.21</kotlin.version>
-    <kotlin-metadata.version>1.3.0</kotlin-metadata.version>
+    <kotlin.version>1.2.71</kotlin.version>
+    <kotlin-metadata.version>1.4.0</kotlin-metadata.version>
     <dokka.version>0.9.17</dokka.version>
     <maven-assembly.version>3.1.0</maven-assembly.version>
 
     <!-- Dependencies -->
-    <okio.version>1.14.0</okio.version>
+    <okio.version>1.15.0</okio.version>
 
     <!-- Test Dependencies -->
-    <compile-testing.version>0.8</compile-testing.version>
+    <compile-testing.version>0.15</compile-testing.version>
     <junit.version>4.12</junit.version>
-    <assertj.version>1.7.0</assertj.version>
+    <assertj.version>3.11.1</assertj.version>
   </properties>
 
   <scm>
@@ -138,7 +138,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.3</version>
+          <version>3.8.0</version>
           <configuration>
             <compilerId>javac-with-errorprone</compilerId>
             <forceJavacCompilerUse>true</forceJavacCompilerUse>
