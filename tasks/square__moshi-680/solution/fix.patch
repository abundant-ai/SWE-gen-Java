diff --git a/CHANGELOG.md b/CHANGELOG.md
index f7e745f9..4287d413 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,46 +1,6 @@
 Change Log
 ==========
 
-## Version 1.7.0
-
-_2018-09-24_
-
- * New: `EnumJsonAdapter` makes it easy to specify a fallback value for unknown enum constants.
-   By default Moshi throws an `JsonDataException` if it reads an unknown enum constant. With this
-   you can specify a fallback value or null.
-
-   ```java
-   new Moshi.Builder()
-       .add(EnumJsonAdapter.create(IsoCurrency.class)
-           .withUnknownFallback(IsoCurrency.USD))
-       .build();
-   ```
-
-   Note that this adapter is in the optional `moshi-adapters` module.
-
-   ```groovy
-   implementation 'com.squareup.moshi:moshi-adapters:1.7.0'
-   ```
-
- * New: Embed R8/ProGuard rules in the `.jar` file.
- * New: Use `@CheckReturnValue` in more places. We hope this will encourage you to use `skipName()`
-   instead of `nextName()` for better performance!
- * New: Forbid automatic encoding of platform classes in `androidx`. As with `java.*`, `android.*`,
-   and `kotlin.*` Moshi wants you to specify how to encode platform types.
- * New: Improve error reporting when creating an adapter fails.
- * New: Upgrade to Okio 1.15.0. We don't yet require Kotlin-friendly Okio 2.x but Moshi works fine
-   with that release.
-
-   ```groovy
-   implementation 'com.squareup.okio:okio:1.15.0'
-   ```
-
- * Fix: Return false from `JsonReader.hasNext()` at document's end.
- * Fix: Improve code gen to handle several broken cases. Our generated adapters had problems with
-   nulls, nested parameterized types, private transient properties, generic type aliases, fields
-   with dollar signs in their names, and named companion objects.
-
-
 ## Version 1.6.0
 
 _2018-05-14_
diff --git a/README.md b/README.md
index 91d7c800..7314f1a5 100644
--- a/README.md
+++ b/README.md
@@ -500,12 +500,12 @@ The reflection adapter requires the following additional dependency:
 <dependency>
   <groupId>com.squareup.moshi</groupId>
   <artifactId>moshi-kotlin</artifactId>
-  <version>1.7.0</version>
+  <version>1.6.0</version>
 </dependency>
 ```
 
 ```groovy
-implementation 'com.squareup.moshi:moshi-kotlin:1.7.0'
+implementation 'com.squareup.moshi:moshi-kotlin:1.6.0'
 ```
 
 Note that the reflection adapter transitively depends on the `kotlin-reflect` library which is a
@@ -535,13 +535,13 @@ add the following to your build to enable the annotation processor:
 <dependency>
   <groupId>com.squareup.moshi</groupId>
   <artifactId>moshi-kotlin-codegen</artifactId>
-  <version>1.7.0</version>
+  <version>1.6.0</version>
   <scope>provided</scope>
 </dependency>
 ```
 
 ```groovy
-kapt 'com.squareup.moshi:moshi-kotlin-codegen:1.7.0'
+kapt 'com.squareup.moshi:moshi-kotlin-codegen:1.6.0'
 ```
 
 You must also have the `kotlin-stdlib` dependency on the classpath during compilation in order for
@@ -567,12 +567,12 @@ Download [the latest JAR][dl] or depend via Maven:
 <dependency>
   <groupId>com.squareup.moshi</groupId>
   <artifactId>moshi</artifactId>
-  <version>1.7.0</version>
+  <version>1.6.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-implementation 'com.squareup.moshi:moshi:1.7.0'
+implementation 'com.squareup.moshi:moshi:1.6.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/adapters/pom.xml b/adapters/pom.xml
index bde57f56..81264c91 100644
--- a/adapters/pom.xml
+++ b/adapters/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.8.0-SNAPSHOT</version>
+    <version>1.7.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>moshi-adapters</artifactId>
diff --git a/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java b/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java
index 1bc91f7e..1e805c10 100644
--- a/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java
+++ b/adapters/src/main/java/com/squareup/moshi/adapters/RuntimeJsonAdapterFactory.java
@@ -21,6 +21,7 @@ import com.squareup.moshi.JsonReader;
 import com.squareup.moshi.JsonWriter;
 import com.squareup.moshi.Moshi;
 import com.squareup.moshi.Types;
+import com.squareup.moshi.internal.Util;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Type;
@@ -34,14 +35,13 @@ import javax.annotation.CheckReturnValue;
  * decoding the JSON. This factory's adapters expect JSON in the format of a JSON object with a
  * key whose value is a label that determines the type to which to map the JSON object.
  */
-// TODO(jwilson): make this class public in Moshi 1.8.
-final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
+public final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
   final Class<T> baseType;
   final String labelKey;
   final Map<String, Type> labelToType = new LinkedHashMap<>();
 
   /**
-   * @param baseType The base type for which this factory will create adapters. Cannot be Object.
+   * @param baseType The base type for which this factory will create adapters.
    * @param labelKey The key in the JSON object whose value determines the type to which to map the
    *     JSON object.
    */
@@ -49,10 +49,6 @@ final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
   public static <T> RuntimeJsonAdapterFactory<T> of(Class<T> baseType, String labelKey) {
     if (baseType == null) throw new NullPointerException("baseType == null");
     if (labelKey == null) throw new NullPointerException("labelKey == null");
-    if (baseType == Object.class) {
-      throw new IllegalArgumentException(
-          "The base type must not be Object. Consider using a marker interface.");
-    }
     return new RuntimeJsonAdapterFactory<>(baseType, labelKey);
   }
 
@@ -90,9 +86,10 @@ final class RuntimeJsonAdapterFactory<T> implements JsonAdapter.Factory {
       typeToLabel.put(typeValue, label);
       labelToAdapter.put(label, moshi.adapter(typeValue));
     }
-    JsonAdapter<Object> objectJsonAdapter = moshi.adapter(Object.class);
-    return new RuntimeJsonAdapter(labelKey, labelToAdapter, typeToLabel,
-        objectJsonAdapter).nullSafe();
+    JsonAdapter<Object> objectJsonAdapter = moshi.nextAdapter(
+        this, Object.class, Util.NO_ANNOTATIONS);
+    return new RuntimeJsonAdapter(labelKey, labelToAdapter, typeToLabel, objectJsonAdapter)
+        .nullSafe();
   }
 
   static final class RuntimeJsonAdapter extends JsonAdapter<Object> {
diff --git a/examples/pom.xml b/examples/pom.xml
index 4dd8a72e..aeff13dc 100644
--- a/examples/pom.xml
+++ b/examples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.8.0-SNAPSHOT</version>
+    <version>1.7.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>moshi-examples</artifactId>
diff --git a/kotlin/codegen/pom.xml b/kotlin/codegen/pom.xml
index 1bd061b7..37d28739 100644
--- a/kotlin/codegen/pom.xml
+++ b/kotlin/codegen/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.8.0-SNAPSHOT</version>
+    <version>1.7.0-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
index f2769211..5156e3d9 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
@@ -135,7 +135,7 @@ internal class AdapterGenerator(
     result.addProperty(optionsProperty)
     for (uniqueAdapter in propertyList.distinctBy { it.delegateKey }) {
       result.addProperty(uniqueAdapter.delegateKey.generateProperty(
-          nameAllocator, typeRenderer, moshiParam, uniqueAdapter.name))
+          nameAllocator, typeRenderer, moshiParam))
     }
 
     result.addFunction(generateToStringFun())
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
index 45e35a6d..3165feda 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
@@ -43,8 +43,7 @@ internal data class DelegateKey(
   fun generateProperty(
     nameAllocator: NameAllocator,
     typeRenderer: TypeRenderer,
-    moshiParameter: ParameterSpec,
-    propertyName: String
+    moshiParameter: ParameterSpec
   ): PropertySpec {
     val qualifierNames = jsonQualifiers.joinToString("") {
       "At${(it.type as ClassName).simpleName}"
@@ -54,23 +53,27 @@ internal data class DelegateKey(
 
     val adapterTypeName = JsonAdapter::class.asClassName().parameterizedBy(type)
     val standardArgs = arrayOf(moshiParameter,
-        CodeBlock.of("<%T>", type),
+        if (type is ClassName && jsonQualifiers.isEmpty()) {
+          ""
+        } else {
+          CodeBlock.of("<%T>", type)
+        },
         typeRenderer.render(type))
-    var standardArgsSize = standardArgs.size
+    val standardArgsSize = standardArgs.size + 1
     val (initializerString, args) = when {
-      // TODO: Reference top-level function emptySet().
-      // TODO: https://github.com/square/kotlinpoet/issues/433/
-      jsonQualifiers.isEmpty() -> ", kotlin.collections.emptySet()" to emptyArray()
+      jsonQualifiers.isEmpty() -> "" to emptyArray()
       else -> {
-        ", %${++standardArgsSize}T.getFieldJsonQualifierAnnotations(javaClass, " +
-            "%${++standardArgsSize}S)" to arrayOf(Types::class.asTypeName(), adapterName)
+        ", %${standardArgsSize}T.getFieldJsonQualifierAnnotations(javaClass, " +
+            "%${standardArgsSize + 1}S)" to arrayOf(Types::class.asTypeName(), adapterName)
       }
     }
-    val finalArgs = arrayOf(*standardArgs, *args, propertyName)
+    val finalArgs = arrayOf(*standardArgs, *args)
+
+    val nullModifier = if (nullable) ".nullSafe()" else ".nonNull()"
 
     return PropertySpec.builder(adapterName, adapterTypeName, KModifier.PRIVATE)
         .addAnnotations(jsonQualifiers)
-        .initializer("%1N.adapter%2L(%3L$initializerString, %${++standardArgsSize}S)", *finalArgs)
+        .initializer("%1N.adapter%2L(%3L$initializerString)$nullModifier", *finalArgs)
         .build()
   }
 }
diff --git a/kotlin/reflect/pom.xml b/kotlin/reflect/pom.xml
index 97a062b0..fa924cb7 100644
--- a/kotlin/reflect/pom.xml
+++ b/kotlin/reflect/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.8.0-SNAPSHOT</version>
+    <version>1.7.0-SNAPSHOT</version>
     <relativePath>../../pom.xml</relativePath>
   </parent>
 
diff --git a/kotlin/reflect/src/main/java/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapter.kt b/kotlin/reflect/src/main/java/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapter.kt
index 8e4d16b1..d32ae5c3 100644
--- a/kotlin/reflect/src/main/java/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapter.kt
+++ b/kotlin/reflect/src/main/java/com/squareup/moshi/kotlin/reflect/KotlinJsonAdapter.kt
@@ -229,7 +229,7 @@ class KotlinJsonAdapterFactory : JsonAdapter.Factory {
       val name = jsonAnnotation?.name ?: property.name
       val resolvedPropertyType = resolve(type, rawType, property.returnType.javaType)
       val adapter = moshi.adapter<Any>(
-          resolvedPropertyType, Util.jsonAnnotations(allAnnotations.toTypedArray()), property.name)
+          resolvedPropertyType, Util.jsonAnnotations(allAnnotations.toTypedArray()))
 
       bindingsByName[property.name] = KotlinJsonAdapter.Binding(name, adapter,
           property as KProperty1<Any, Any?>, parameter)
diff --git a/moshi/pom.xml b/moshi/pom.xml
index 6b885d00..f091bdd0 100644
--- a/moshi/pom.xml
+++ b/moshi/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.moshi</groupId>
     <artifactId>moshi-parent</artifactId>
-    <version>1.8.0-SNAPSHOT</version>
+    <version>1.7.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>moshi</artifactId>
@@ -47,17 +47,6 @@
           </archive>
         </configuration>
       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-javadoc-plugin</artifactId>
-        <version>2.10.4</version>
-        <configuration>
-          <excludePackageNames>com.squareup.moshi.internal:com.squareup.moshi.internal.*</excludePackageNames>
-          <links>
-            <link>https://square.github.io/okio/</link>
-          </links>
-        </configuration>
-      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
index f26230a7..8a03096f 100644
--- a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
+++ b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
@@ -53,7 +53,7 @@ final class AdapterMethodsFactory implements JsonAdapter.Factory {
       } catch (IllegalArgumentException e) {
         String missingAnnotation = toAdapter == null ? "@ToJson" : "@FromJson";
         throw new IllegalArgumentException("No " + missingAnnotation + " adapter for "
-            + typeAnnotatedWithAnnotations(type, annotations), e);
+            + typeAnnotatedWithAnnotations(type, annotations));
       }
     } else {
       delegate = null;
diff --git a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
index 71d45349..aee6d55b 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
@@ -95,15 +95,14 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
         // Look up a type adapter for this type.
         Type fieldType = resolve(type, rawType, field.getGenericType());
         Set<? extends Annotation> annotations = Util.jsonAnnotations(field);
-        String fieldName = field.getName();
-        JsonAdapter<Object> adapter = moshi.adapter(fieldType, annotations, fieldName);
+        JsonAdapter<Object> adapter = moshi.adapter(fieldType, annotations);
 
         // Create the binding between field and JSON.
         field.setAccessible(true);
 
         // Store it using the field's name. If there was already a field with this name, fail!
         Json jsonAnnotation = field.getAnnotation(Json.class);
-        String name = jsonAnnotation != null ? jsonAnnotation.name() : fieldName;
+        String name = jsonAnnotation != null ? jsonAnnotation.name() : field.getName();
         FieldBinding<Object> fieldBinding = new FieldBinding<>(name, field, adapter);
         FieldBinding<?> replaced = fieldBindings.put(name, fieldBinding);
         if (replaced != null) {
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index eabc01a0..e04acf96 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -180,10 +180,10 @@ public abstract class JsonReader implements Closeable {
   // The nesting stack. Using a manual array rather than an ArrayList saves 20%. This stack will
   // grow itself up to 256 levels of nesting including the top-level document. Deeper nesting is
   // prone to trigger StackOverflowErrors.
-  int stackSize = 0;
-  int[] scopes = new int[32];
-  String[] pathNames = new String[32];
-  int[] pathIndices = new int[32];
+  int stackSize;
+  int[] scopes;
+  String[] pathNames;
+  int[] pathIndices;
 
   /** True to accept non-spec compliant JSON. */
   boolean lenient;
@@ -196,8 +196,21 @@ public abstract class JsonReader implements Closeable {
     return new JsonUtf8Reader(source);
   }
 
+  // Package-private to control subclasses.
   JsonReader() {
-    // Package-private to control subclasses.
+    scopes = new int[32];
+    pathNames = new String[32];
+    pathIndices = new int[32];
+  }
+
+  // Package-private to control subclasses.
+  JsonReader(JsonReader copyFrom) {
+    this.stackSize = copyFrom.stackSize;
+    this.scopes = copyFrom.scopes.clone();
+    this.pathNames = copyFrom.pathNames.clone();
+    this.pathIndices = copyFrom.pathIndices.clone();
+    this.lenient = copyFrom.lenient;
+    this.failOnUnknown = copyFrom.failOnUnknown;
   }
 
   final void pushScope(int newTop) {
@@ -461,6 +474,32 @@ public abstract class JsonReader implements Closeable {
     }
   }
 
+  /**
+   * Returns a new {@code JsonReader} that can read data from this {@code JsonReader} without
+   * consuming it. The returned reader becomes invalid once this one is next read or closed.
+   *
+   * For example, we can use `peek()` to lookahead and read the same data multiple times.
+   *
+   * <pre> {@code
+   *
+   *   Buffer buffer = new Buffer();
+   *   buffer.writeUtf8("[123, 456, 789]")
+   *
+   *   JsonReader jsonReader = JsonReader.of(buffer);
+   *   jsonReader.beginArray();
+   *   jsonReader.nextInt(); // Returns 123, reader contains 456, 789 and ].
+   *
+   *   JsonReader peek = reader.peekReader();
+   *   peek.nextInt() // Returns 456.
+   *   peek.nextInt() // Returns 789.
+   *   peek.endArray()
+   *
+   *   jsonReader.nextInt() // Returns 456, reader contains 789 and ].
+   * }</pre>
+   */
+  // TODO(jwilson): make this public once it's supported in JsonUtf8Reader.
+  abstract JsonReader peekJson();
+
   /**
    * Returns a <a href="http://goessner.net/articles/JsonPath/">JsonPath</a> to
    * the current location in the JSON value.
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
index 71d8ddcd..16c478ae 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
@@ -31,7 +31,6 @@ final class JsonUtf8Reader extends JsonReader {
   private static final ByteString UNQUOTED_STRING_TERMINALS
       = ByteString.encodeUtf8("{}[]:, \n\t\r\f/\\;#=");
   private static final ByteString LINEFEED_OR_CARRIAGE_RETURN = ByteString.encodeUtf8("\n\r");
-  private static final ByteString CLOSING_BLOCK_COMMENT = ByteString.encodeUtf8("*/");
 
   private static final int PEEKED_NONE = 0;
   private static final int PEEKED_BEGIN_OBJECT = 1;
@@ -991,9 +990,11 @@ final class JsonUtf8Reader extends JsonReader {
             // skip a /* c-style comment */
             buffer.readByte(); // '/'
             buffer.readByte(); // '*'
-            if (!skipToEndOfBlockComment()) {
+            if (!skipTo("*/")) {
               throw syntaxError("Unterminated comment");
             }
+            buffer.readByte(); // '*'
+            buffer.readByte(); // '/'
             p = 0;
             continue;
 
@@ -1042,13 +1043,24 @@ final class JsonUtf8Reader extends JsonReader {
   }
 
   /**
-   * Skips through the next closing block comment.
+   * @param toFind a string to search for. Must not contain a newline.
    */
-  private boolean skipToEndOfBlockComment() throws IOException {
-    long index = source.indexOf(CLOSING_BLOCK_COMMENT);
-    boolean found = index != -1;
-    buffer.skip(found ? index + CLOSING_BLOCK_COMMENT.size() : buffer.size());
-    return found;
+  private boolean skipTo(String toFind) throws IOException {
+    outer:
+    for (; source.request(toFind.length()); ) {
+      for (int c = 0; c < toFind.length(); c++) {
+        if (buffer.getByte(c) != toFind.charAt(c)) {
+          buffer.readByte();
+          continue outer;
+        }
+      }
+      return true;
+    }
+    return false;
+  }
+
+  @Override JsonReader peekJson() {
+    throw new UnsupportedOperationException("TODO");
   }
 
   @Override public String toString() {
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java b/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
index fb3991b9..4246d3d8 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
@@ -20,10 +20,11 @@ import java.math.BigDecimal;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
-import java.util.ListIterator;
 import java.util.Map;
 import javax.annotation.Nullable;
 
+import static com.squareup.moshi.JsonScope.CLOSED;
+
 /**
  * This class reads a JSON document by traversing a Java object comprising maps, lists, and JSON
  * primitives. It does depth-first traversal keeping a stack starting with the root object. During
@@ -32,11 +33,11 @@ import javax.annotation.Nullable;
  * <ul>
  *   <li>The next element to act upon is on the top of the stack.
  *   <li>When the top of the stack is a {@link List}, calling {@link #beginArray()} replaces the
- *       list with a {@link ListIterator}. The first element of the iterator is pushed on top of the
+ *       list with a {@link JsonIterator}. The first element of the iterator is pushed on top of the
  *       iterator.
  *   <li>Similarly, when the top of the stack is a {@link Map}, calling {@link #beginObject()}
- *       replaces the map with an {@link Iterator} of its entries. The first element of the iterator
- *       is pushed on top of the iterator.
+ *       replaces the map with an {@link JsonIterator} of its entries. The first element of the
+ *       iterator is pushed on top of the iterator.
  *   <li>When the top of the stack is a {@link Map.Entry}, calling {@link #nextName()} returns the
  *       entry's key and replaces the entry with its value on the stack.
  *   <li>When an element is consumed it is popped. If the new top of the stack has a non-exhausted
@@ -49,17 +50,31 @@ final class JsonValueReader extends JsonReader {
   /** Sentinel object pushed on {@link #stack} when the reader is closed. */
   private static final Object JSON_READER_CLOSED = new Object();
 
-  private Object[] stack = new Object[32];
+  private Object[] stack;
 
   JsonValueReader(Object root) {
     scopes[stackSize] = JsonScope.NONEMPTY_DOCUMENT;
+    stack = new Object[32];
     stack[stackSize++] = root;
   }
 
+  /** Copy-constructor makes a deep copy for peeking. */
+  JsonValueReader(JsonValueReader copyFrom) {
+    super(copyFrom);
+
+    stack = copyFrom.stack.clone();
+    for (int i = 0; i < stackSize; i++) {
+      if (stack[i] instanceof JsonIterator) {
+        stack[i] = ((JsonIterator) stack[i]).clone();
+      }
+    }
+  }
+
   @Override public void beginArray() throws IOException {
     List<?> peeked = require(List.class, Token.BEGIN_ARRAY);
 
-    ListIterator<?> iterator = peeked.listIterator();
+    JsonIterator iterator = new JsonIterator(
+        Token.END_ARRAY, peeked.toArray(new Object[peeked.size()]), 0);
     stack[stackSize - 1] = iterator;
     scopes[stackSize - 1] = JsonScope.EMPTY_ARRAY;
     pathIndices[stackSize - 1] = 0;
@@ -71,8 +86,8 @@ final class JsonValueReader extends JsonReader {
   }
 
   @Override public void endArray() throws IOException {
-    ListIterator<?> peeked = require(ListIterator.class, Token.END_ARRAY);
-    if (peeked.hasNext()) {
+    JsonIterator peeked = require(JsonIterator.class, Token.END_ARRAY);
+    if (peeked.endToken != Token.END_ARRAY || peeked.hasNext()) {
       throw typeMismatch(peeked, Token.END_ARRAY);
     }
     remove();
@@ -81,7 +96,8 @@ final class JsonValueReader extends JsonReader {
   @Override public void beginObject() throws IOException {
     Map<?, ?> peeked = require(Map.class, Token.BEGIN_OBJECT);
 
-    Iterator<?> iterator = peeked.entrySet().iterator();
+    JsonIterator iterator = new JsonIterator(
+        Token.END_OBJECT, peeked.entrySet().toArray(new Object[peeked.size()]), 0);
     stack[stackSize - 1] = iterator;
     scopes[stackSize - 1] = JsonScope.EMPTY_OBJECT;
 
@@ -92,8 +108,8 @@ final class JsonValueReader extends JsonReader {
   }
 
   @Override public void endObject() throws IOException {
-    Iterator<?> peeked = require(Iterator.class, Token.END_OBJECT);
-    if (peeked instanceof ListIterator || peeked.hasNext()) {
+    JsonIterator peeked = require(JsonIterator.class, Token.END_OBJECT);
+    if (peeked.endToken != Token.END_OBJECT || peeked.hasNext()) {
       throw typeMismatch(peeked, Token.END_OBJECT);
     }
     pathNames[stackSize - 1] = null;
@@ -112,8 +128,7 @@ final class JsonValueReader extends JsonReader {
 
     // If the top of the stack is an iterator, take its first element and push it on the stack.
     Object peeked = stack[stackSize - 1];
-    if (peeked instanceof ListIterator) return Token.END_ARRAY;
-    if (peeked instanceof Iterator) return Token.END_OBJECT;
+    if (peeked instanceof JsonIterator) return ((JsonIterator) peeked).endToken;
     if (peeked instanceof List) return Token.BEGIN_ARRAY;
     if (peeked instanceof Map) return Token.BEGIN_OBJECT;
     if (peeked instanceof Map.Entry) return Token.NAME;
@@ -303,6 +318,10 @@ final class JsonValueReader extends JsonReader {
     }
   }
 
+  @Override JsonReader peekJson() {
+    return new JsonValueReader(this);
+  }
+
   @Override void promoteNameToValue() throws IOException {
     if (hasNext()) {
       String name = nextName();
@@ -313,7 +332,7 @@ final class JsonValueReader extends JsonReader {
   @Override public void close() throws IOException {
     Arrays.fill(stack, 0, stackSize, null);
     stack[0] = JSON_READER_CLOSED;
-    scopes[0] = JsonScope.CLOSED;
+    scopes[0] = CLOSED;
     stackSize = 1;
   }
 
@@ -374,4 +393,33 @@ final class JsonValueReader extends JsonReader {
       }
     }
   }
+
+  static final class JsonIterator implements Iterator<Object>, Cloneable {
+    final Token endToken;
+    final Object[] array;
+    int next;
+
+    JsonIterator(Token endToken, Object[] array, int next) {
+      this.endToken = endToken;
+      this.array = array;
+      this.next = next;
+    }
+
+    @Override public boolean hasNext() {
+      return next < array.length;
+    }
+
+    @Override public Object next() {
+      return array[next++];
+    }
+
+    @Override public void remove() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override protected JsonIterator clone() {
+      // No need to copy the array; it's read-only.
+      return new JsonIterator(endToken, array, next);
+    }
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 26db3162..8d39c474 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -89,19 +89,9 @@ public final class Moshi {
     return adapter(type, Collections.unmodifiableSet(annotations));
   }
 
-  @CheckReturnValue
-  public <T> JsonAdapter<T> adapter(Type type, Set<? extends Annotation> annotations) {
-    return adapter(type, annotations, null);
-  }
-
-  /**
-   * @param fieldName An optional field name associated with this type. The field name is used as a
-   * hint for better adapter lookup error messages for nested structures.
-   */
   @CheckReturnValue
   @SuppressWarnings("unchecked") // Factories are required to return only matching JsonAdapters.
-  public <T> JsonAdapter<T> adapter(Type type, Set<? extends Annotation> annotations,
-      @Nullable String fieldName) {
+  public <T> JsonAdapter<T> adapter(Type type, Set<? extends Annotation> annotations) {
     if (type == null) {
       throw new NullPointerException("type == null");
     }
@@ -133,10 +123,8 @@ public final class Moshi {
     }
 
     // Prepare for re-entrant calls, then ask each factory to create a type adapter.
-    DeferredAdapter<T> deferredAdapter = new DeferredAdapter<>(type, fieldName, cacheKey);
-
+    DeferredAdapter<T> deferredAdapter = new DeferredAdapter<>(cacheKey);
     deferredAdapters.add(deferredAdapter);
-    int lastIndex = deferredAdapters.size() - 1;
     try {
       for (int i = 0, size = factories.size(); i < size; i++) {
         JsonAdapter<T> result = (JsonAdapter<T>) factories.get(i).create(type, annotations, this);
@@ -145,19 +133,12 @@ public final class Moshi {
           synchronized (adapterCache) {
             adapterCache.put(cacheKey, result);
           }
-          // Remove the type or field name only when we succeed in creating the adapter,
-          // so we have the full stack  at the top level.
-          deferredAdapters.remove(lastIndex);
           return result;
         }
       }
-    } catch (IllegalArgumentException e) {
-      if (lastIndex == 0) { // Rewrite the exception at the top level.
-        e = errorWithFields(deferredAdapters, e);
-      }
-      throw e;
     } finally {
-      if (lastIndex == 0) {
+      deferredAdapters.remove(deferredAdapters.size() - 1);
+      if (deferredAdapters.isEmpty()) {
         reentrantCalls.remove();
       }
     }
@@ -200,27 +181,6 @@ public final class Moshi {
     return Arrays.asList(type, annotations);
   }
 
-  static IllegalArgumentException errorWithFields(List<DeferredAdapter<?>> typesAndFieldNames,
-      IllegalArgumentException e) {
-    int size = typesAndFieldNames.size();
-    if (size == 1 && typesAndFieldNames.get(0).fieldName == null) {
-      return e;
-    }
-    StringBuilder errorMessageBuilder = new StringBuilder(e.getMessage());
-    for (int i = size - 1; i >= 0; i--) {
-      DeferredAdapter<?> deferredAdapter = typesAndFieldNames.get(i);
-      errorMessageBuilder
-          .append("\nfor ")
-          .append(deferredAdapter.type);
-      if (deferredAdapter.fieldName != null) {
-        errorMessageBuilder
-            .append(' ')
-            .append(deferredAdapter.fieldName);
-      }
-    }
-    return new IllegalArgumentException(errorMessageBuilder.toString(), e);
-  }
-
   public static final class Builder {
     final List<JsonAdapter.Factory> factories = new ArrayList<>();
 
@@ -290,15 +250,11 @@ public final class Moshi {
    * <p>Typically this is necessary in self-referential object models, such as an {@code Employee}
    * class that has a {@code List<Employee>} field for an organization's management hierarchy.
    */
-  private static final class DeferredAdapter<T> extends JsonAdapter<T> {
-    final Type type;
-    final @Nullable String fieldName;
+  private static class DeferredAdapter<T> extends JsonAdapter<T> {
     @Nullable Object cacheKey;
     private @Nullable JsonAdapter<T> delegate;
 
-    DeferredAdapter(Type type, @Nullable String fieldName, Object cacheKey) {
-      this.type = type;
-      this.fieldName = fieldName;
+    DeferredAdapter(Object cacheKey) {
       this.cacheKey = cacheKey;
     }
 
diff --git a/pom.xml b/pom.xml
index c6d1cc15..67408d53 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.moshi</groupId>
   <artifactId>moshi-parent</artifactId>
-  <version>1.8.0-SNAPSHOT</version>
+  <version>1.7.0-SNAPSHOT</version>
   <packaging>pom</packaging>
   <name>Moshi (Parent)</name>
   <description>A modern JSON API for Android and Java</description>
@@ -29,18 +29,18 @@
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <java.version>1.7</java.version>
-    <kotlin.version>1.2.71</kotlin.version>
-    <kotlin-metadata.version>1.4.0</kotlin-metadata.version>
+    <kotlin.version>1.2.21</kotlin.version>
+    <kotlin-metadata.version>1.3.0</kotlin-metadata.version>
     <dokka.version>0.9.17</dokka.version>
     <maven-assembly.version>3.1.0</maven-assembly.version>
 
     <!-- Dependencies -->
-    <okio.version>1.15.0</okio.version>
+    <okio.version>1.14.0</okio.version>
 
     <!-- Test Dependencies -->
-    <compile-testing.version>0.15</compile-testing.version>
+    <compile-testing.version>0.8</compile-testing.version>
     <junit.version>4.12</junit.version>
-    <assertj.version>3.11.1</assertj.version>
+    <assertj.version>1.7.0</assertj.version>
   </properties>
 
   <scm>
@@ -138,7 +138,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.8.0</version>
+          <version>3.3</version>
           <configuration>
             <compilerId>javac-with-errorprone</compilerId>
             <forceJavacCompilerUse>true</forceJavacCompilerUse>
