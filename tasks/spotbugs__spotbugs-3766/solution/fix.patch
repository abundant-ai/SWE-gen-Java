diff --git a/CHANGELOG.md b/CHANGELOG.md
index 884fe342d..65076bfb0 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -8,6 +8,8 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 ## Unreleased - 2025-??-??
 ### Added
 - Recognize `jakarta.annotation.Nonnull` and `jakarta.annotation.Nullable` ([#3780](https://github.com/spotbugs/spotbugs/pull/3780))
+- New bug type is introduced: `NCR_NOT_PROPERLY_CHECKED_READ`. Improper validation of the return value from the read() method in InputStream and Reader classes may result in an array not being fully filled. ([#3766](https://github.com/spotbugs/spotbugs/pull/3766))
+
 ### Fixed
 - Fix incorrect bug counts and sizes when unioning reports ([#3721](https://github.com/spotbugs/spotbugs/issues/3721))
 
diff --git a/spotbugs/etc/findbugs.xml b/spotbugs/etc/findbugs.xml
index 8006edaca..399149210 100644
--- a/spotbugs/etc/findbugs.xml
+++ b/spotbugs/etc/findbugs.xml
@@ -482,7 +482,7 @@
           <Detector class="edu.umd.cs.findbugs.detect.Naming" speed="fast"
                     reports="NM_WRONG_PACKAGE,NM_WRONG_PACKAGE_INTENTIONAL,NM_VERY_CONFUSING,NM_VERY_CONFUSING_INTENTIONAL,NM_CONFUSING,NM_METHOD_CONSTRUCTOR_CONFUSION,NM_LCASE_HASHCODE,NM_LCASE_TOSTRING,NM_BAD_EQUAL,NM_CLASS_NAMING_CONVENTION,NM_FIELD_NAMING_CONVENTION,NM_METHOD_NAMING_CONVENTION,NM_CLASS_NOT_EXCEPTION,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,NM_SAME_SIMPLE_NAME_AS_INTERFACE"/>
           <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked" speed="fast"
-                    reports="RR_NOT_CHECKED,SR_NOT_CHECKED"/>
+                    reports="RR_NOT_CHECKED,SR_NOT_CHECKED,NCR_NOT_PROPERLY_CHECKED_READ"/>
           <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom" speed="fast"
                     reports="SE_NO_SERIALVERSIONID,SE_METHOD_MUST_BE_PRIVATE,WS_WRITEOBJECT_SYNC,RS_READOBJECT_SYNC,SE_INNER_CLASS,SE_BAD_FIELD,SE_BAD_FIELD_STORE,SE_NONLONG_SERIALVERSIONID,SE_NONSTATIC_SERIALVERSIONID,SE_NONFINAL_SERIALVERSIONID,SE_NO_SUITABLE_CONSTRUCTOR,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,SE_READ_RESOLVE_MUST_RETURN_OBJECT,SE_TRANSIENT_FIELD_NOT_RESTORED,SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS,SE_BAD_FIELD_INNER_CLASS,SE_READ_RESOLVE_IS_STATIC,SE_PRIVATE_READ_RESOLVE_NOT_INHERITED,SE_PREVENT_EXT_OBJ_OVERWRITE"/>
           <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor" speed="fast"
@@ -739,6 +739,7 @@
           <BugCode abbrev="VSC"/>
           <BugCode abbrev="DA"/>
           <BugCode abbrev="HSM"/>
+          <BugCode abbrev="NCR"/>
           <!-- Bug patterns -->
           <BugPattern abbrev="JUA" type="JUA_DONT_ASSERT_INSTANCEOF_IN_TESTS" category="BAD_PRACTICE" experimental="true" />
           <BugPattern abbrev="AA" type="AA_ASSERTION_OF_ARGUMENTS" category="BAD_PRACTICE" cweid="617"/>
@@ -1343,4 +1344,5 @@
           <BugPattern abbrev="US" type="US_USELESS_SUPPRESSION_ON_METHOD" category="STYLE"/>
           <BugPattern abbrev="US" type="US_USELESS_SUPPRESSION_ON_METHOD_PARAMETER" category="STYLE"/>
           <BugPattern abbrev="US" type="US_USELESS_SUPPRESSION_ON_PACKAGE" category="STYLE"/>
+          <BugPattern abbrev="NCR" type="NCR_NOT_PROPERLY_CHECKED_READ" category="BAD_PRACTICE" cweid="135"/>
 </FindbugsPlugin>
diff --git a/spotbugs/etc/messages.xml b/spotbugs/etc/messages.xml
index c7015569f..c4e519151 100644
--- a/spotbugs/etc/messages.xml
+++ b/spotbugs/etc/messages.xml
@@ -974,7 +974,7 @@ malicious code.  </p>
     <Details>
 <![CDATA[
 <p> This detector looks for calls to InputStream.read() or InputStream.skip() where the
-return value is ignored.  </p>
+return value is ignored or improperly checked.</p>
 ]]>
     </Details>
   </Detector>
@@ -4755,6 +4755,11 @@ be confusing to users of this class.</p>
   causing the program to fail only sporadically.</p>
   <p>See <a href="https://cwe.mitre.org/data/definitions/252.html">CWE-252: Unchecked Return Value</a>.
 </p>
+
+  <p>Additionally, it is not sufficient to simply check for the end of the file (EOF)
+  as an indicator that the entire array has been filled. The return value of
+  <code>read()</code> must be verified to ensure that the correct number of bytes
+  have been read.</p>
 ]]>
     </Details>
   </BugPattern>
@@ -9822,6 +9827,26 @@ Using floating-point variables should not be used as loop counters, as they are
       </p>]]>
     </Details>
   </BugPattern>
+  <BugPattern type="NCR_NOT_PROPERLY_CHECKED_READ">
+    <ShortDescription>Return value of read() is not properly checked, array may be partially filled</ShortDescription>
+    <LongDescription>The return value of method {2.nameAndSignature} is not properly checked in {1.name}, which may result in using a partially filled array.</LongDescription>
+    <Details>
+      <![CDATA[
+        <p>
+          When using the read() method to fill an array, the method may not always fill the entire array. This can occur when the input stream does not have enough bytes available to completely fill the array, leading to a partial read. This issue can result in unexpected behavior if the partially filled array is assumed to be fully populated.
+        </p>
+        <p>
+          It is crucial to verify the return value of the read() method, which indicates the number of bytes actually read, and to ensure that the array is fully filled if necessary. Failing to do so can result in incomplete data processing and potential vulnerabilities.
+        </p>
+        <p>
+          To fix this issue, check the return value of read() and handle cases where fewer bytes are read than expected. Consider looping over the read() call or using methods like readFully() to ensure that the array is filled completely.
+        </p>
+        <p>
+          See SEI CERT rule <a href="https://wiki.sei.cmu.edu/confluence/display/java/FIO10-J.+Ensure+the+array+is+filled+when+using+read%28%29+to+fill+an+array">FIO10-J. Ensure the array is filled when using read() to fill an array</a> for more information.
+        </p>
+      ]]>
+    </Details>
+  </BugPattern>
   <!--
   **********************************************************************
    BugCodes
@@ -9986,5 +10011,6 @@ Using floating-point variables should not be used as loop counters, as they are
   <BugCode abbrev="CWO">Lock closed without being opened in the first place</BugCode>
   <BugCode abbrev="HSM">Avoid method hiding</BugCode>
   <BugCode abbrev="US">Useless suppression</BugCode>
+  <BugCode abbrev="NCR">Not checked read while filling array</BugCode>
 </MessageCollection>
 
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeChecked.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeChecked.java
index 44dd6007b..286145607 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeChecked.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeChecked.java
@@ -19,19 +19,21 @@
 
 package edu.umd.cs.findbugs.detect;
 
-import org.apache.bcel.Const;
-import org.apache.bcel.Repository;
-import org.apache.bcel.classfile.Code;
-
 import edu.umd.cs.findbugs.BugAccumulator;
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
-import edu.umd.cs.findbugs.BytecodeScanningDetector;
+import edu.umd.cs.findbugs.OpcodeStack;
 import edu.umd.cs.findbugs.SourceLineAnnotation;
 import edu.umd.cs.findbugs.StatelessDetector;
 import edu.umd.cs.findbugs.ba.ch.Subtypes2;
+import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
+import org.apache.bcel.Const;
+import org.apache.bcel.Repository;
+import org.apache.bcel.classfile.Code;
+
+import java.util.Set;
 
-public class ReadReturnShouldBeChecked extends BytecodeScanningDetector implements StatelessDetector {
+public class ReadReturnShouldBeChecked extends OpcodeStackDetector implements StatelessDetector {
 
     boolean sawRead = false;
 
@@ -49,6 +51,18 @@ public class ReadReturnShouldBeChecked extends BytecodeScanningDetector implemen
 
     private String lastCallClass = null, lastCallMethod = null, lastCallSig = null;
 
+    private boolean readProcessed = false;
+
+    private OpcodeStack.Item itemToBeCompared;
+
+    private static final Set<Short> comparisonOpcodes = Set.of(
+            Const.IF_ICMPEQ, Const.IF_ICMPNE,
+            Const.IF_ICMPLT, Const.IF_ICMPGE,
+            Const.IF_ICMPGT, Const.IF_ICMPLE,
+            Const.FCMPL, Const.FCMPG,
+            Const.DCMPL, Const.DCMPG,
+            Const.LCMP);
+
     public ReadReturnShouldBeChecked(BugReporter bugReporter) {
         this.accumulator = new BugAccumulator(bugReporter);
     }
@@ -58,6 +72,8 @@ public class ReadReturnShouldBeChecked extends BytecodeScanningDetector implemen
         sawAvailable = 0;
         sawRead = false;
         sawSkip = false;
+        readProcessed = false;
+        itemToBeCompared = null;
         super.visit(obj);
         accumulator.reportAccumulatedBugs();
     }
@@ -97,6 +113,7 @@ public class ReadReturnShouldBeChecked extends BytecodeScanningDetector implemen
 
     @Override
     public void sawOpcode(int seen) {
+        readProcessed = false;
 
         if (seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE) {
             lastCallClass = getDottedClassConstantOperand();
@@ -123,6 +140,7 @@ public class ReadReturnShouldBeChecked extends BytecodeScanningDetector implemen
             sawRead = true;
             recentCallToAvailable = sawAvailable > 0;
             locationOfCall = getPC();
+            readProcessed = true;
             return;
         }
         if ((seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE)
@@ -158,7 +176,61 @@ public class ReadReturnShouldBeChecked extends BytecodeScanningDetector implemen
                                         .fromVisitedInstruction(getClassContext(), this, locationOfCall));
             }
         }
+
+        if (sawRead && (seen == Const.I2F || seen == Const.I2D || seen == Const.I2L)) {
+            readProcessed = true;
+        }
+
+        if (comparisonOpcodes.contains((short) seen) && stack.getStackDepth() > 1) {
+            OpcodeStack.Item rightItem = stack.getStackItem(0);
+            OpcodeStack.Item leftItem = stack.getStackItem(1);
+            Object value = null;
+            if (leftItem.equals(itemToBeCompared)) {
+                value = rightItem.getConstant();
+            } else if (rightItem.equals(itemToBeCompared)) {
+                value = leftItem.getConstant();
+            }
+
+            reportIfMinusOneValue(value);
+        }
+
+        //The return value of the read() is copied into a variable
+        if (seen == Const.DUP && itemToBeCompared != null) {
+            itemToBeCompared = null;
+        }
+
         sawRead = false;
         sawSkip = false;
     }
+
+    @Override
+    public void afterOpcode(int seen) {
+        super.afterOpcode(seen);
+
+        if (readProcessed) {
+            itemToBeCompared = stack.getStackDepth() > 0 ? stack.getStackItem(0) : null;
+        }
+    }
+
+    private void reportIfMinusOneValue(Object value) {
+        boolean isMinusOne = false;
+
+        if (value instanceof Integer) {
+            isMinusOne = (Integer) value == -1;
+        } else if (value instanceof Float) {
+            isMinusOne = (Float) value == -1.0f;
+        } else if (value instanceof Double) {
+            isMinusOne = (Double) value == -1.0d;
+        } else if (value instanceof Long) {
+            isMinusOne = (Long) value == -1L;
+        }
+
+        if (isMinusOne) {
+            accumulator.accumulateBug(
+                    new BugInstance(this, "NCR_NOT_PROPERLY_CHECKED_READ", recentCallToAvailable ? LOW_PRIORITY : NORMAL_PRIORITY)
+                            .addClassAndMethod(this)
+                            .addCalledMethod(lastCallClass, lastCallMethod, lastCallSig, false),
+                    SourceLineAnnotation.fromVisitedInstruction(getClassContext(), this, locationOfCall));
+        }
+    }
 }
