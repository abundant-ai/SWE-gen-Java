diff --git a/CHANGELOG.md b/CHANGELOG.md
index 65076bfb0..884fe342d 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -8,8 +8,6 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 ## Unreleased - 2025-??-??
 ### Added
 - Recognize `jakarta.annotation.Nonnull` and `jakarta.annotation.Nullable` ([#3780](https://github.com/spotbugs/spotbugs/pull/3780))
-- New bug type is introduced: `NCR_NOT_PROPERLY_CHECKED_READ`. Improper validation of the return value from the read() method in InputStream and Reader classes may result in an array not being fully filled. ([#3766](https://github.com/spotbugs/spotbugs/pull/3766))
-
 ### Fixed
 - Fix incorrect bug counts and sizes when unioning reports ([#3721](https://github.com/spotbugs/spotbugs/issues/3721))
 
diff --git a/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeCheckedTest.java b/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeCheckedTest.java
deleted file mode 100644
index 43e311756..000000000
--- a/spotbugs-tests/src/test/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeCheckedTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package edu.umd.cs.findbugs.detect;
-
-import edu.umd.cs.findbugs.AbstractIntegrationTest;
-import org.junit.jupiter.api.Test;
-
-class ReadReturnShouldBeCheckedTest extends AbstractIntegrationTest {
-
-    private static final String NCR_BUG_TYPE = "NCR_NOT_PROPERLY_CHECKED_READ";
-    private static final String RR_BUG_TYPE = "RR_NOT_CHECKED";
-    private static final String SR_BUG_TYPE = "SR_NOT_CHECKED";
-
-    @Test
-    void testNotCheckedRead() {
-        performAnalysis("partialFilledArrayWithRead/BadReadReturnShouldBeCheckedTest.class");
-
-        assertBugTypeCount(NCR_BUG_TYPE, 6);
-        assertBugTypeCount(RR_BUG_TYPE, 0);
-        assertBugTypeCount(SR_BUG_TYPE, 0);
-
-        final String className = "BadReadReturnShouldBeCheckedTest";
-        assertBugInMethodAtLine(NCR_BUG_TYPE, className, "readBytes", 14);
-        assertBugInMethodAtLine(NCR_BUG_TYPE, className, "readBytesWithOffset", 23);
-        assertBugInMethodAtLine(NCR_BUG_TYPE, className, "readFromBufferedReader", 32);
-        assertBugInMethodAtLine(NCR_BUG_TYPE, className, "readBytesComparedToFloat", 40);
-        assertBugInMethodAtLine(NCR_BUG_TYPE, className, "changeOrderOfComparing", 48);
-        assertBugInMethodAtLine(NCR_BUG_TYPE, className, "changeOrderOfComparingLong", 56);
-    }
-
-    @Test
-    void testCheckedRead() {
-        performAnalysis("partialFilledArrayWithRead/GoodReadReturnShouldBeCheckedTest.class");
-
-        assertNoBugType(NCR_BUG_TYPE);
-        assertNoBugType(RR_BUG_TYPE);
-        assertNoBugType(SR_BUG_TYPE);
-    }
-}
diff --git a/spotbugs/etc/findbugs.xml b/spotbugs/etc/findbugs.xml
index 399149210..8006edaca 100644
--- a/spotbugs/etc/findbugs.xml
+++ b/spotbugs/etc/findbugs.xml
@@ -482,7 +482,7 @@
           <Detector class="edu.umd.cs.findbugs.detect.Naming" speed="fast"
                     reports="NM_WRONG_PACKAGE,NM_WRONG_PACKAGE_INTENTIONAL,NM_VERY_CONFUSING,NM_VERY_CONFUSING_INTENTIONAL,NM_CONFUSING,NM_METHOD_CONSTRUCTOR_CONFUSION,NM_LCASE_HASHCODE,NM_LCASE_TOSTRING,NM_BAD_EQUAL,NM_CLASS_NAMING_CONVENTION,NM_FIELD_NAMING_CONVENTION,NM_METHOD_NAMING_CONVENTION,NM_CLASS_NOT_EXCEPTION,NM_SAME_SIMPLE_NAME_AS_SUPERCLASS,NM_SAME_SIMPLE_NAME_AS_INTERFACE"/>
           <Detector class="edu.umd.cs.findbugs.detect.ReadReturnShouldBeChecked" speed="fast"
-                    reports="RR_NOT_CHECKED,SR_NOT_CHECKED,NCR_NOT_PROPERLY_CHECKED_READ"/>
+                    reports="RR_NOT_CHECKED,SR_NOT_CHECKED"/>
           <Detector class="edu.umd.cs.findbugs.detect.SerializableIdiom" speed="fast"
                     reports="SE_NO_SERIALVERSIONID,SE_METHOD_MUST_BE_PRIVATE,WS_WRITEOBJECT_SYNC,RS_READOBJECT_SYNC,SE_INNER_CLASS,SE_BAD_FIELD,SE_BAD_FIELD_STORE,SE_NONLONG_SERIALVERSIONID,SE_NONSTATIC_SERIALVERSIONID,SE_NONFINAL_SERIALVERSIONID,SE_NO_SUITABLE_CONSTRUCTOR,SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION,SE_READ_RESOLVE_MUST_RETURN_OBJECT,SE_TRANSIENT_FIELD_NOT_RESTORED,SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS,SE_BAD_FIELD_INNER_CLASS,SE_READ_RESOLVE_IS_STATIC,SE_PRIVATE_READ_RESOLVE_NOT_INHERITED,SE_PREVENT_EXT_OBJ_OVERWRITE"/>
           <Detector class="edu.umd.cs.findbugs.detect.StartInConstructor" speed="fast"
@@ -739,7 +739,6 @@
           <BugCode abbrev="VSC"/>
           <BugCode abbrev="DA"/>
           <BugCode abbrev="HSM"/>
-          <BugCode abbrev="NCR"/>
           <!-- Bug patterns -->
           <BugPattern abbrev="JUA" type="JUA_DONT_ASSERT_INSTANCEOF_IN_TESTS" category="BAD_PRACTICE" experimental="true" />
           <BugPattern abbrev="AA" type="AA_ASSERTION_OF_ARGUMENTS" category="BAD_PRACTICE" cweid="617"/>
@@ -1344,5 +1343,4 @@
           <BugPattern abbrev="US" type="US_USELESS_SUPPRESSION_ON_METHOD" category="STYLE"/>
           <BugPattern abbrev="US" type="US_USELESS_SUPPRESSION_ON_METHOD_PARAMETER" category="STYLE"/>
           <BugPattern abbrev="US" type="US_USELESS_SUPPRESSION_ON_PACKAGE" category="STYLE"/>
-          <BugPattern abbrev="NCR" type="NCR_NOT_PROPERLY_CHECKED_READ" category="BAD_PRACTICE" cweid="135"/>
 </FindbugsPlugin>
diff --git a/spotbugs/etc/messages.xml b/spotbugs/etc/messages.xml
index c4e519151..c7015569f 100644
--- a/spotbugs/etc/messages.xml
+++ b/spotbugs/etc/messages.xml
@@ -974,7 +974,7 @@ malicious code.  </p>
     <Details>
 <![CDATA[
 <p> This detector looks for calls to InputStream.read() or InputStream.skip() where the
-return value is ignored or improperly checked.</p>
+return value is ignored.  </p>
 ]]>
     </Details>
   </Detector>
@@ -4755,11 +4755,6 @@ be confusing to users of this class.</p>
   causing the program to fail only sporadically.</p>
   <p>See <a href="https://cwe.mitre.org/data/definitions/252.html">CWE-252: Unchecked Return Value</a>.
 </p>
-
-  <p>Additionally, it is not sufficient to simply check for the end of the file (EOF)
-  as an indicator that the entire array has been filled. The return value of
-  <code>read()</code> must be verified to ensure that the correct number of bytes
-  have been read.</p>
 ]]>
     </Details>
   </BugPattern>
@@ -9827,26 +9822,6 @@ Using floating-point variables should not be used as loop counters, as they are
       </p>]]>
     </Details>
   </BugPattern>
-  <BugPattern type="NCR_NOT_PROPERLY_CHECKED_READ">
-    <ShortDescription>Return value of read() is not properly checked, array may be partially filled</ShortDescription>
-    <LongDescription>The return value of method {2.nameAndSignature} is not properly checked in {1.name}, which may result in using a partially filled array.</LongDescription>
-    <Details>
-      <![CDATA[
-        <p>
-          When using the read() method to fill an array, the method may not always fill the entire array. This can occur when the input stream does not have enough bytes available to completely fill the array, leading to a partial read. This issue can result in unexpected behavior if the partially filled array is assumed to be fully populated.
-        </p>
-        <p>
-          It is crucial to verify the return value of the read() method, which indicates the number of bytes actually read, and to ensure that the array is fully filled if necessary. Failing to do so can result in incomplete data processing and potential vulnerabilities.
-        </p>
-        <p>
-          To fix this issue, check the return value of read() and handle cases where fewer bytes are read than expected. Consider looping over the read() call or using methods like readFully() to ensure that the array is filled completely.
-        </p>
-        <p>
-          See SEI CERT rule <a href="https://wiki.sei.cmu.edu/confluence/display/java/FIO10-J.+Ensure+the+array+is+filled+when+using+read%28%29+to+fill+an+array">FIO10-J. Ensure the array is filled when using read() to fill an array</a> for more information.
-        </p>
-      ]]>
-    </Details>
-  </BugPattern>
   <!--
   **********************************************************************
    BugCodes
@@ -10011,6 +9986,5 @@ Using floating-point variables should not be used as loop counters, as they are
   <BugCode abbrev="CWO">Lock closed without being opened in the first place</BugCode>
   <BugCode abbrev="HSM">Avoid method hiding</BugCode>
   <BugCode abbrev="US">Useless suppression</BugCode>
-  <BugCode abbrev="NCR">Not checked read while filling array</BugCode>
 </MessageCollection>
 
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeChecked.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeChecked.java
index 286145607..44dd6007b 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeChecked.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/ReadReturnShouldBeChecked.java
@@ -19,21 +19,19 @@
 
 package edu.umd.cs.findbugs.detect;
 
+import org.apache.bcel.Const;
+import org.apache.bcel.Repository;
+import org.apache.bcel.classfile.Code;
+
 import edu.umd.cs.findbugs.BugAccumulator;
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
-import edu.umd.cs.findbugs.OpcodeStack;
+import edu.umd.cs.findbugs.BytecodeScanningDetector;
 import edu.umd.cs.findbugs.SourceLineAnnotation;
 import edu.umd.cs.findbugs.StatelessDetector;
 import edu.umd.cs.findbugs.ba.ch.Subtypes2;
-import edu.umd.cs.findbugs.bcel.OpcodeStackDetector;
-import org.apache.bcel.Const;
-import org.apache.bcel.Repository;
-import org.apache.bcel.classfile.Code;
-
-import java.util.Set;
 
-public class ReadReturnShouldBeChecked extends OpcodeStackDetector implements StatelessDetector {
+public class ReadReturnShouldBeChecked extends BytecodeScanningDetector implements StatelessDetector {
 
     boolean sawRead = false;
 
@@ -51,18 +49,6 @@ public class ReadReturnShouldBeChecked extends OpcodeStackDetector implements St
 
     private String lastCallClass = null, lastCallMethod = null, lastCallSig = null;
 
-    private boolean readProcessed = false;
-
-    private OpcodeStack.Item itemToBeCompared;
-
-    private static final Set<Short> comparisonOpcodes = Set.of(
-            Const.IF_ICMPEQ, Const.IF_ICMPNE,
-            Const.IF_ICMPLT, Const.IF_ICMPGE,
-            Const.IF_ICMPGT, Const.IF_ICMPLE,
-            Const.FCMPL, Const.FCMPG,
-            Const.DCMPL, Const.DCMPG,
-            Const.LCMP);
-
     public ReadReturnShouldBeChecked(BugReporter bugReporter) {
         this.accumulator = new BugAccumulator(bugReporter);
     }
@@ -72,8 +58,6 @@ public class ReadReturnShouldBeChecked extends OpcodeStackDetector implements St
         sawAvailable = 0;
         sawRead = false;
         sawSkip = false;
-        readProcessed = false;
-        itemToBeCompared = null;
         super.visit(obj);
         accumulator.reportAccumulatedBugs();
     }
@@ -113,7 +97,6 @@ public class ReadReturnShouldBeChecked extends OpcodeStackDetector implements St
 
     @Override
     public void sawOpcode(int seen) {
-        readProcessed = false;
 
         if (seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE) {
             lastCallClass = getDottedClassConstantOperand();
@@ -140,7 +123,6 @@ public class ReadReturnShouldBeChecked extends OpcodeStackDetector implements St
             sawRead = true;
             recentCallToAvailable = sawAvailable > 0;
             locationOfCall = getPC();
-            readProcessed = true;
             return;
         }
         if ((seen == Const.INVOKEVIRTUAL || seen == Const.INVOKEINTERFACE)
@@ -176,61 +158,7 @@ public class ReadReturnShouldBeChecked extends OpcodeStackDetector implements St
                                         .fromVisitedInstruction(getClassContext(), this, locationOfCall));
             }
         }
-
-        if (sawRead && (seen == Const.I2F || seen == Const.I2D || seen == Const.I2L)) {
-            readProcessed = true;
-        }
-
-        if (comparisonOpcodes.contains((short) seen) && stack.getStackDepth() > 1) {
-            OpcodeStack.Item rightItem = stack.getStackItem(0);
-            OpcodeStack.Item leftItem = stack.getStackItem(1);
-            Object value = null;
-            if (leftItem.equals(itemToBeCompared)) {
-                value = rightItem.getConstant();
-            } else if (rightItem.equals(itemToBeCompared)) {
-                value = leftItem.getConstant();
-            }
-
-            reportIfMinusOneValue(value);
-        }
-
-        //The return value of the read() is copied into a variable
-        if (seen == Const.DUP && itemToBeCompared != null) {
-            itemToBeCompared = null;
-        }
-
         sawRead = false;
         sawSkip = false;
     }
-
-    @Override
-    public void afterOpcode(int seen) {
-        super.afterOpcode(seen);
-
-        if (readProcessed) {
-            itemToBeCompared = stack.getStackDepth() > 0 ? stack.getStackItem(0) : null;
-        }
-    }
-
-    private void reportIfMinusOneValue(Object value) {
-        boolean isMinusOne = false;
-
-        if (value instanceof Integer) {
-            isMinusOne = (Integer) value == -1;
-        } else if (value instanceof Float) {
-            isMinusOne = (Float) value == -1.0f;
-        } else if (value instanceof Double) {
-            isMinusOne = (Double) value == -1.0d;
-        } else if (value instanceof Long) {
-            isMinusOne = (Long) value == -1L;
-        }
-
-        if (isMinusOne) {
-            accumulator.accumulateBug(
-                    new BugInstance(this, "NCR_NOT_PROPERLY_CHECKED_READ", recentCallToAvailable ? LOW_PRIORITY : NORMAL_PRIORITY)
-                            .addClassAndMethod(this)
-                            .addCalledMethod(lastCallClass, lastCallMethod, lastCallSig, false),
-                    SourceLineAnnotation.fromVisitedInstruction(getClassContext(), this, locationOfCall));
-        }
-    }
 }
diff --git a/spotbugsTestCases/src/java/partialFilledArrayWithRead/BadReadReturnShouldBeCheckedTest.java b/spotbugsTestCases/src/java/partialFilledArrayWithRead/BadReadReturnShouldBeCheckedTest.java
deleted file mode 100644
index ccfedd957..000000000
--- a/spotbugsTestCases/src/java/partialFilledArrayWithRead/BadReadReturnShouldBeCheckedTest.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package partialFilledArrayWithRead;
-
-
-import java.io.BufferedReader;
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.charset.StandardCharsets;
-
-public class BadReadReturnShouldBeCheckedTest {
-
-    String readBytes(InputStream in) throws IOException {
-        byte[] data = new byte[1024];
-        if (in.read(data) == -1) {
-            throw new EOFException();
-        }
-        return new String(data, StandardCharsets.UTF_8);
-    }
-
-    public static String readBytesWithOffset(InputStream in) throws IOException {
-        byte[] data = new byte[1024];
-        int offset = 0;
-        if (in.read(data, offset, data.length - offset) != -1) {
-            throw new EOFException();
-        }
-        return new String(data, StandardCharsets.UTF_8);
-    }
-
-    public String readFromBufferedReader(BufferedReader bufferedReader) throws IOException {
-        char[] data = new char[1024];
-
-        if (bufferedReader.read(data) == -1) {
-            throw new EOFException();
-        }
-        return new String(data);
-    }
-
-    String readBytesComparedToFloat(InputStream in) throws IOException {
-        byte[] data = new byte[1024];
-        if (in.read(data) == -1F) {
-            throw new EOFException();
-        }
-        return new String(data, StandardCharsets.UTF_8);
-    }
-
-    String changeOrderOfComparing(InputStream in) throws IOException {
-        byte[] data = new byte[1024];
-        if (-1 == in.read(data)) {
-            throw new EOFException();
-        }
-        return new String(data, StandardCharsets.UTF_8);
-    }
-
-    String changeOrderOfComparingLong(InputStream in) throws IOException {
-        byte[] data = new byte[1024];
-        if (-1L == in.read(data)) {
-            throw new EOFException();
-        }
-        return new String(data, StandardCharsets.UTF_8);
-    }
-}
diff --git a/spotbugsTestCases/src/java/partialFilledArrayWithRead/GoodReadReturnShouldBeCheckedTest.java b/spotbugsTestCases/src/java/partialFilledArrayWithRead/GoodReadReturnShouldBeCheckedTest.java
deleted file mode 100644
index 4b893c7a7..000000000
--- a/spotbugsTestCases/src/java/partialFilledArrayWithRead/GoodReadReturnShouldBeCheckedTest.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package partialFilledArrayWithRead;
-
-import java.io.DataInputStream;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.BufferedReader;
-import java.nio.charset.StandardCharsets;
-
-public class GoodReadReturnShouldBeCheckedTest {
-    public static String readBytes(InputStream in) throws IOException {
-        int offset = 0;
-        int bytesRead = 0;
-        byte[] data = new byte[1024];
-        while ((bytesRead = in.read(data, offset, data.length - offset)) != -1) {
-            offset += bytesRead;
-            if (offset >= data.length) {
-                break;
-            }
-        }
-        return new String(data, 0, offset, StandardCharsets.UTF_8);
-    }
-
-    public static String singleReadWithProperReturnCheck(FileInputStream fis) throws IOException {
-        int size = 1024;
-        byte[] data = new byte[size];
-        DataInputStream dis = new DataInputStream(fis);
-        if (dis.read(data) < size) {
-            throw new IOException(String.format("Failed to read %s bytes", size));
-        }
-        return new String(data, StandardCharsets.UTF_8);
-    }
-
-    public static String readFullyBytes(FileInputStream fis) throws IOException {
-        byte[] data = new byte[1024];
-        DataInputStream dis = new DataInputStream(fis);
-        dis.readFully(data);
-        return new String(data, StandardCharsets.UTF_8);
-    }
-
-    public static String readBytesWithDoWhile(InputStream in) throws IOException {
-        int offset = 0;
-        int bytesRead;
-        byte[] data = new byte[1024];
-        do {
-            bytesRead = in.read(data, offset, data.length - offset);
-            if (bytesRead == -1) {
-                break;
-            }
-            offset += bytesRead;
-        } while (offset < data.length);
-        return new String(data, 0, offset, StandardCharsets.UTF_8);
-    }
-
-    public static String readBytesWithFor(InputStream in) throws IOException {
-        byte[] data = new byte[1024];
-        int offset = 0;
-
-        for (int bytesRead; offset < data.length; offset += bytesRead) {
-            bytesRead = in.read(data, offset, data.length - offset);
-            if (bytesRead == -1) {
-                break;
-            }
-        }
-        return new String(data, 0, offset, StandardCharsets.UTF_8);
-    }
-
-    public static String properReadCheckUsingReaderClass(BufferedReader reader) throws IOException {
-        char[] buffer = new char[1024];
-        int offset = 0;
-        int charsRead;
-
-        while (offset < buffer.length
-                && (charsRead = reader.read(buffer, offset, buffer.length - offset)) != -1) {
-            offset += charsRead;
-        }
-
-        return new String(buffer, 0, offset);
-    }
-
-    public static String checkReadWithNonInt(FileInputStream in) throws IOException {
-        long size = 1024L;
-        byte[] data = new byte[(int) size];
-        DataInputStream dis = new DataInputStream(in);
-        if (dis.read(data) < size) {
-            throw new IOException(String.format("Failed to read %s bytes", size));
-        }
-        return new String(data, StandardCharsets.UTF_8);
-    }
-}
