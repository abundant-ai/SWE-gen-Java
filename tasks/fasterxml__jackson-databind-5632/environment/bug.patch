diff --git a/release-notes/VERSION b/release-notes/VERSION
index 6bf9d2b38..8047716c3 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -5,7 +5,7 @@ Versions: 3.x (for earlier see VERSION-2.x)
 === Releases ===
 ------------------------------------------------------------------------
 
-3.1.0 (not yet released)
+3.1.0-rc1 (27-Jan-2026)
 
 #221: Support alternate radixes when writing numeric values as strings
  (requested by Christopher C)
@@ -163,7 +163,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
  (implemented by @cowtowncoder, w/ Claude code)
 #5621: Fix typo: MissingInjectableValueExcepion â†’ MissingInjectableValueException
  (implemented by Lee Jiwon)
-#5631: Rename `StdDelegatingSerializer` to `StdConvertingSerializer` (3.0->3.1)
 
 3.0.4 (not yet released)
 
diff --git a/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java b/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java
index 85cff6881..31c2df9fb 100644
--- a/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java
+++ b/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java
@@ -438,7 +438,7 @@ public abstract class BasicSerializerFactory
             return ser;
         }
         JavaType delegateType = conv.getOutputType(ctxt.getTypeFactory());
-        return new StdConvertingSerializer(conv, delegateType, ser, null);
+        return new StdDelegatingSerializer(conv, delegateType, ser, null);
     }
 
     protected Converter<Object,Object> findConverter(SerializationContext ctxt,
diff --git a/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java b/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java
index 3e3d6fd36..cd7f7c9e3 100644
--- a/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java
+++ b/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java
@@ -24,7 +24,7 @@ import tools.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;
 import tools.jackson.databind.ser.impl.UnsupportedTypeSerializer;
 import tools.jackson.databind.ser.jdk.MapEntryAsPOJOSerializer;
 import tools.jackson.databind.ser.jdk.MapSerializer;
-import tools.jackson.databind.ser.std.StdConvertingSerializer;
+import tools.jackson.databind.ser.std.StdDelegatingSerializer;
 import tools.jackson.databind.ser.std.ToEmptyObjectSerializer;
 import tools.jackson.databind.type.ReferenceType;
 import tools.jackson.databind.util.BeanUtil;
@@ -176,7 +176,7 @@ public class BeanSerializerFactory
             if ((ser == null) && !delegateType.isJavaLangObject()) {
                 ser = _createSerializer2(ctxt, beanDescRef, delegateType, formatOverrides, true);
             }
-            return new StdConvertingSerializer(conv, delegateType, ser, null);
+            return new StdDelegatingSerializer(conv, delegateType, ser, null);
         }
         // No, regular serializer
         return (ValueSerializer<Object>) _createSerializer2(ctxt, beanDescRef, type, formatOverrides, staticTyping);
diff --git a/src/main/java/tools/jackson/databind/ser/bean/BeanSerializerBase.java b/src/main/java/tools/jackson/databind/ser/bean/BeanSerializerBase.java
index 305aae5cc..5ac78df85 100644
--- a/src/main/java/tools/jackson/databind/ser/bean/BeanSerializerBase.java
+++ b/src/main/java/tools/jackson/databind/ser/bean/BeanSerializerBase.java
@@ -18,7 +18,7 @@ import tools.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;
 import tools.jackson.databind.ser.jdk.EnumSerializer;
 import tools.jackson.databind.ser.jdk.MapEntrySerializer;
 import tools.jackson.databind.ser.std.StdContainerSerializer;
-import tools.jackson.databind.ser.std.StdConvertingSerializer;
+import tools.jackson.databind.ser.std.StdDelegatingSerializer;
 import tools.jackson.databind.ser.std.StdSerializer;
 import tools.jackson.databind.util.ClassUtil;
 import tools.jackson.databind.util.Converter;
@@ -366,7 +366,7 @@ public abstract class BeanSerializerBase
                     // [databind#731]: Should skip if nominally java.lang.Object
                     ValueSerializer<?> ser = delegateType.isJavaLangObject() ? null
                             : ctxt.findPrimaryPropertySerializer(delegateType, prop);
-                    return new StdConvertingSerializer(conv, delegateType, ser, prop);
+                    return new StdDelegatingSerializer(conv, delegateType, ser, prop);
                 }
             }
         }
diff --git a/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java b/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java
index 91bcc23f4..6fcb81979 100644
--- a/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java
@@ -239,7 +239,7 @@ public abstract class ReferenceTypeSerializer<T>
         return refSer;
     }
 
-    protected boolean _useStatic(SerializationContext ctxt, BeanProperty property,
+    protected boolean _useStatic(SerializationContext serializers, BeanProperty property,
             JavaType referredType)
     {
         // First: no serializer for `Object.class`, must be dynamic
@@ -255,11 +255,11 @@ public abstract class ReferenceTypeSerializer<T>
             return true;
         }
         // if neither, maybe explicit annotation?
-        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
+        AnnotationIntrospector intr = serializers.getAnnotationIntrospector();
         if ((intr != null) && (property != null)) {
             Annotated ann = property.getMember();
             if (ann != null) {
-                JsonSerialize.Typing t = intr.findSerializationTyping(ctxt.getConfig(),
+                JsonSerialize.Typing t = intr.findSerializationTyping(serializers.getConfig(),
                         property.getMember());
                 if (t == JsonSerialize.Typing.STATIC) {
                     return true;
@@ -270,7 +270,7 @@ public abstract class ReferenceTypeSerializer<T>
             }
         }
         // and finally, may be forced by global static typing (unlikely...)
-        return ctxt.isEnabled(MapperFeature.USE_STATIC_TYPING);
+        return serializers.isEnabled(MapperFeature.USE_STATIC_TYPING);
     }
 
     /*
diff --git a/src/main/java/tools/jackson/databind/ser/std/StdConvertingSerializer.java b/src/main/java/tools/jackson/databind/ser/std/StdConvertingSerializer.java
deleted file mode 100644
index 892dac1e7..000000000
--- a/src/main/java/tools/jackson/databind/ser/std/StdConvertingSerializer.java
+++ /dev/null
@@ -1,273 +0,0 @@
-package tools.jackson.databind.ser.std;
-
-import tools.jackson.core.JacksonException;
-import tools.jackson.core.JsonGenerator;
-import tools.jackson.databind.*;
-import tools.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
-import tools.jackson.databind.jsontype.TypeSerializer;
-import tools.jackson.databind.ser.impl.PropertySerializerMap;
-import tools.jackson.databind.util.ClassUtil;
-import tools.jackson.databind.util.Converter;
-
-/**
- * Serializer implementation where given Java type is first converted
- * to an intermediate "delegate type" (using a configured
- * {@link Converter}, and then this delegate value is serialized by Jackson.
- *<p>
- * Note that although types may be related, they must not be same; trying
- * to do this will result in an exception.
- *
- * @see Converter
- *
- * @since 3.1 (in 3.0 was incorrectly named {@link StdDelegatingSerializer})
- */
-@SuppressWarnings("javadoc")
-public class StdConvertingSerializer
-    extends StdSerializer<Object>
-{
-    // @since 3.0
-    protected final BeanProperty _property;
-
-    protected final Converter<Object,?> _converter;
-
-    /**
-     * Fully resolved delegate type, with generic information if any available.
-     */
-    protected final JavaType _delegateType;
-
-    /**
-     * Underlying serializer for the intermediate type.
-     */
-    protected final ValueSerializer<Object> _delegateSerializer;
-
-    /**
-     * If delegate serializer needs to be accessed dynamically (non-final
-     * type, static type not forced), this data structure helps with efficient
-     * lookups.
-     *
-     * @since 3.0
-     */
-    protected PropertySerializerMap _dynamicValueSerializers = PropertySerializerMap.emptyForProperties();
-
-    /*
-    /**********************************************************************
-    /* Life-cycle
-    /**********************************************************************
-     */
-
-    @SuppressWarnings("unchecked")
-    public StdConvertingSerializer(Converter<?,?> converter)
-    {
-        super(Object.class);
-        _converter = (Converter<Object,?>)converter;
-        _delegateType = null;
-        _delegateSerializer = null;
-        _property = null;
-    }
-
-    @SuppressWarnings("unchecked")
-    public <T> StdConvertingSerializer(Class<T> cls, Converter<T,?> converter)
-    {
-        super(cls);
-        _converter = (Converter<Object,?>)converter;
-        _delegateType = null;
-        _delegateSerializer = null;
-        _property = null;
-    }
-
-    @SuppressWarnings("unchecked")
-    public StdConvertingSerializer(Converter<Object,?> converter,
-            JavaType delegateType, ValueSerializer<?> delegateSerializer,
-            BeanProperty prop)
-    {
-        super(delegateType);
-        _converter = converter;
-        _delegateType = delegateType;
-        _delegateSerializer = (ValueSerializer<Object>) delegateSerializer;
-        _property = prop;
-    }
-
-    /**
-     * Method used for creating resolved contextual instances. Must be
-     * overridden when sub-classing.
-     */
-    protected StdConvertingSerializer withDelegate(Converter<Object,?> converter,
-            JavaType delegateType, ValueSerializer<?> delegateSerializer,
-            BeanProperty prop)
-    {
-        ClassUtil.verifyMustOverride(StdConvertingSerializer.class, this, "withDelegate");
-        return new StdConvertingSerializer(converter, delegateType, delegateSerializer, prop);
-    }
-
-    /*
-    /**********************************************************************
-    /* Contextualization
-    /**********************************************************************
-     */
-
-    @Override
-    public void resolve(SerializationContext ctxt)
-    {
-        if (_delegateSerializer != null) {
-            _delegateSerializer.resolve(ctxt);
-        }
-    }
-
-    @Override
-    public ValueSerializer<?> createContextual(SerializationContext ctxt, BeanProperty property)
-    {
-        ValueSerializer<?> delSer = _delegateSerializer;
-        JavaType delegateType = _delegateType;
-
-        if (delSer == null) {
-            // Otherwise, need to locate serializer to delegate to. For that we need type information...
-            if (delegateType == null) {
-                delegateType = _converter.getOutputType(ctxt.getTypeFactory());
-            }
-            // 02-Apr-2015, tatu: For "dynamic case", where type is only specified as
-            //    java.lang.Object (or missing generic), [databind#731]
-            if (!delegateType.isJavaLangObject()) {
-                delSer = ctxt.findValueSerializer(delegateType);
-            }
-        }
-        if (delSer != null) {
-            delSer = ctxt.handleSecondaryContextualization(delSer, property);
-        }
-        if ((delSer == _delegateSerializer)
-                && (delegateType == _delegateType) && (property == _property)) {
-            return this;
-        }
-        return withDelegate(_converter, delegateType, delSer, property);
-    }
-
-    /*
-    /**********************************************************************
-    /* Accessors
-    /**********************************************************************
-     */
-
-    public Converter<Object, ?> getConverter() {
-        return _converter;
-    }
-
-    @Override
-    public ValueSerializer<?> getDelegatee() {
-        return _delegateSerializer;
-    }
-
-    /*
-    /**********************************************************************
-    /* Serialization
-    /**********************************************************************
-     */
-
-    @Override
-    public void serialize(Object value, JsonGenerator gen, SerializationContext ctxt)
-        throws JacksonException
-    {
-        Object delegateValue = convertValue(ctxt, value);
-        // should we accept nulls?
-        if (delegateValue == null) {
-            ctxt.defaultSerializeNullValue(gen);
-            return;
-        }
-        // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup
-        ValueSerializer<Object> ser = _delegateSerializer;
-        if (ser == null) {
-            ser = _findSerializer(delegateValue, ctxt);
-        }
-        ser.serialize(delegateValue, gen, ctxt);
-    }
-
-    @Override
-    public void serializeWithType(Object value, JsonGenerator gen, SerializationContext ctxt,
-            TypeSerializer typeSer)
-        throws JacksonException
-    {
-        // 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,
-        //    let's give it a chance?
-        Object delegateValue = convertValue(ctxt, value);
-        // consider null (to be consistent with serialize method above)
-        if (delegateValue == null) {
-            ctxt.defaultSerializeNullValue(gen);
-            return;
-        }
-        ValueSerializer<Object> ser = _delegateSerializer;
-        if (ser == null) {
-            ser = _findSerializer(delegateValue, ctxt);
-        }
-        ser.serializeWithType(delegateValue, gen, ctxt, typeSer);
-    }
-
-    @Override
-    public boolean isEmpty(SerializationContext ctxt, Object value)
-    {
-        Object delegateValue = convertValue(ctxt, value);
-        if (delegateValue == null) {
-            return true;
-        }
-        ValueSerializer<Object> ser = _delegateSerializer;
-        if (ser == null) {
-            ser = _findSerializer(value, ctxt);
-        }
-        return ser.isEmpty(ctxt, delegateValue);
-    }
-
-    /*
-    /**********************************************************************
-    /* Schema functionality
-    /**********************************************************************
-     */
-
-    @Override
-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
-    {
-        // 03-Sep-2012, tatu: Not sure if this can be made to really work
-        //    properly... but for now, try this:
-
-        // 02-Apr-2015, tatu: For dynamic case, very little we can do
-        if (_delegateSerializer != null) {
-            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);
-        }
-    }
-
-    /*
-    /**********************************************************************
-    /* Overridable methods
-    /**********************************************************************
-     */
-
-    /**
-     * Method called to convert from source Java value into delegate
-     * value (which will be serialized using standard Jackson serializer for delegate type)
-     *<P>
-     * The default implementation uses configured {@link Converter} to do
-     * conversion.
-     *
-     * @param value Value to convert
-     *
-     * @return Result of conversion
-     */
-    protected Object convertValue(SerializationContext ctxt,Object value) {
-        return _converter.convert(ctxt, value);
-    }
-
-    /**
-     * Helper method used for locating serializer to use in dynamic use case, where
-     * actual type value gets converted to is not specified beyond basic
-     * {@link java.lang.Object}, and where serializer needs to be located dynamically
-     * based on actual value type.
-     */
-    protected ValueSerializer<Object> _findSerializer(Object value, SerializationContext ctxt)
-    {
-        // 17-Apr-2018, tatu: Basically inline `_findAndAddDynamic(...)`
-        // 17-Apr-2018, tatu: difficult to know if these are primary or secondary serializers...
-        Class<?> cc = value.getClass();
-        PropertySerializerMap.SerializerAndMapResult result = _dynamicValueSerializers.findAndAddSecondarySerializer(cc,
-                ctxt, _property);
-        if (_dynamicValueSerializers != result.map) {
-            _dynamicValueSerializers = result.map;
-        }
-        return result.serializer;
-    }
-}
diff --git a/src/main/java/tools/jackson/databind/ser/std/StdDelegatingSerializer.java b/src/main/java/tools/jackson/databind/ser/std/StdDelegatingSerializer.java
index f47dbaf19..86e8538f6 100644
--- a/src/main/java/tools/jackson/databind/ser/std/StdDelegatingSerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/std/StdDelegatingSerializer.java
@@ -1,44 +1,94 @@
 package tools.jackson.databind.ser.std;
 
+import tools.jackson.core.JacksonException;
+import tools.jackson.core.JsonGenerator;
 import tools.jackson.databind.*;
+import tools.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
+import tools.jackson.databind.jsontype.TypeSerializer;
+import tools.jackson.databind.ser.impl.PropertySerializerMap;
 import tools.jackson.databind.util.ClassUtil;
 import tools.jackson.databind.util.Converter;
 
 /**
- * Older incorrectly named (in 3.0) variant of {@link StdConvertingSerializer}.
- *
- * @deprecated Since 3.1 should use correctly named {@link StdConvertingSerializer} instead.
+ * Serializer implementation where given Java type is first converted
+ * to an intermediate "delegate type" (using a configured
+ * {@link Converter}, and then this delegate value is serialized by Jackson.
+ *<p>
+ * Note that although types may be related, they must not be same; trying
+ * to do this will result in an exception.
  */
-@Deprecated
 public class StdDelegatingSerializer
-    extends StdConvertingSerializer
+    extends StdSerializer<Object>
 {
+    // @since 3.0
+    protected final BeanProperty _property;
+
+    protected final Converter<Object,?> _converter;
+
+    /**
+     * Fully resolved delegate type, with generic information if any available.
+     */
+    protected final JavaType _delegateType;
+
+    /**
+     * Underlying serializer for type <code>T</code>.
+     */
+    protected final ValueSerializer<Object> _delegateSerializer;
+
+    /**
+     * If delegate serializer needs to be accessed dynamically (non-final
+     * type, static type not forced), this data structure helps with efficient
+     * lookups.
+     *
+     * @since 3.0
+     */
+    protected PropertySerializerMap _dynamicValueSerializers = PropertySerializerMap.emptyForProperties();
+
     /*
     /**********************************************************************
     /* Life-cycle
     /**********************************************************************
      */
 
-    @Deprecated
-    public StdDelegatingSerializer(Converter<?,?> converter) {
-        super(converter);
+    @SuppressWarnings("unchecked")
+    public StdDelegatingSerializer(Converter<?,?> converter)
+    {
+        super(Object.class);
+        _converter = (Converter<Object,?>)converter;
+        _delegateType = null;
+        _delegateSerializer = null;
+        _property = null;
     }
 
-    @Deprecated
-    public <T> StdDelegatingSerializer(Class<T> cls, Converter<T,?> converter) {
-        super(cls, converter);
+    @SuppressWarnings("unchecked")
+    public <T> StdDelegatingSerializer(Class<T> cls, Converter<T,?> converter)
+    {
+        super(cls);
+        _converter = (Converter<Object,?>)converter;
+        _delegateType = null;
+        _delegateSerializer = null;
+        _property = null;
     }
 
-    @Deprecated
+    /**
+     * @since 3.0
+     */
+    @SuppressWarnings("unchecked")
     public StdDelegatingSerializer(Converter<Object,?> converter,
             JavaType delegateType, ValueSerializer<?> delegateSerializer,
             BeanProperty prop)
     {
-        super(converter, delegateType, delegateSerializer, prop);
+        super(delegateType);
+        _converter = converter;
+        _delegateType = delegateType;
+        _delegateSerializer = (ValueSerializer<Object>) delegateSerializer;
+        _property = prop;
     }
 
-    @Deprecated
-    @Override
+    /**
+     * Method used for creating resolved contextual instances. Must be
+     * overridden when sub-classing.
+     */
     protected StdDelegatingSerializer withDelegate(Converter<Object,?> converter,
             JavaType delegateType, ValueSerializer<?> delegateSerializer,
             BeanProperty prop)
@@ -46,4 +96,176 @@ public class StdDelegatingSerializer
         ClassUtil.verifyMustOverride(StdDelegatingSerializer.class, this, "withDelegate");
         return new StdDelegatingSerializer(converter, delegateType, delegateSerializer, prop);
     }
+
+    /*
+    /**********************************************************************
+    /* Contextualization
+    /**********************************************************************
+     */
+
+    @Override
+    public void resolve(SerializationContext ctxt)
+    {
+        if (_delegateSerializer != null) {
+            _delegateSerializer.resolve(ctxt);
+        }
+    }
+
+    @Override
+    public ValueSerializer<?> createContextual(SerializationContext ctxt, BeanProperty property)
+    {
+        ValueSerializer<?> delSer = _delegateSerializer;
+        JavaType delegateType = _delegateType;
+
+        if (delSer == null) {
+            // Otherwise, need to locate serializer to delegate to. For that we need type information...
+            if (delegateType == null) {
+                delegateType = _converter.getOutputType(ctxt.getTypeFactory());
+            }
+            // 02-Apr-2015, tatu: For "dynamic case", where type is only specified as
+            //    java.lang.Object (or missing generic), [databind#731]
+            if (!delegateType.isJavaLangObject()) {
+                delSer = ctxt.findValueSerializer(delegateType);
+            }
+        }
+        if (delSer != null) {
+            delSer = ctxt.handleSecondaryContextualization(delSer, property);
+        }
+        if ((delSer == _delegateSerializer)
+                && (delegateType == _delegateType) && (property == _property)) {
+            return this;
+        }
+        return withDelegate(_converter, delegateType, delSer, property);
+    }
+
+    /*
+    /**********************************************************************
+    /* Accessors
+    /**********************************************************************
+     */
+
+    public Converter<Object, ?> getConverter() {
+        return _converter;
+    }
+
+    @Override
+    public ValueSerializer<?> getDelegatee() {
+        return _delegateSerializer;
+    }
+
+    /*
+    /**********************************************************************
+    /* Serialization
+    /**********************************************************************
+     */
+
+    @Override
+    public void serialize(Object value, JsonGenerator gen, SerializationContext ctxt)
+        throws JacksonException
+    {
+        Object delegateValue = convertValue(ctxt, value);
+        // should we accept nulls?
+        if (delegateValue == null) {
+            ctxt.defaultSerializeNullValue(gen);
+            return;
+        }
+        // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup
+        ValueSerializer<Object> ser = _delegateSerializer;
+        if (ser == null) {
+            ser = _findSerializer(delegateValue, ctxt);
+        }
+        ser.serialize(delegateValue, gen, ctxt);
+    }
+
+    @Override
+    public void serializeWithType(Object value, JsonGenerator gen, SerializationContext ctxt,
+            TypeSerializer typeSer)
+        throws JacksonException
+    {
+        // 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,
+        //    let's give it a chance?
+        Object delegateValue = convertValue(ctxt, value);
+        // consider null (to be consistent with serialize method above)
+        if (delegateValue == null) {
+            ctxt.defaultSerializeNullValue(gen);
+            return;
+        }
+        ValueSerializer<Object> ser = _delegateSerializer;
+        if (ser == null) {
+            ser = _findSerializer(delegateValue, ctxt);
+        }
+        ser.serializeWithType(delegateValue, gen, ctxt, typeSer);
+    }
+
+    @Override
+    public boolean isEmpty(SerializationContext ctxt, Object value)
+    {
+        Object delegateValue = convertValue(ctxt, value);
+        if (delegateValue == null) {
+            return true;
+        }
+        ValueSerializer<Object> ser = _delegateSerializer;
+        if (ser == null) {
+            ser = _findSerializer(value, ctxt);
+        }
+        return ser.isEmpty(ctxt, delegateValue);
+    }
+
+    /*
+    /**********************************************************************
+    /* Schema functionality
+    /**********************************************************************
+     */
+
+    @Override
+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
+    {
+        // 03-Sep-2012, tatu: Not sure if this can be made to really work
+        //    properly... but for now, try this:
+
+        // 02-Apr-2015, tatu: For dynamic case, very little we can do
+        if (_delegateSerializer != null) {
+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);
+        }
+    }
+
+    /*
+    /**********************************************************************
+    /* Overridable methods
+    /**********************************************************************
+     */
+
+    /**
+     * Method called to convert from source Java value into delegate
+     * value (which will be serialized using standard Jackson serializer for delegate type)
+     *<P>
+     * The default implementation uses configured {@link Converter} to do
+     * conversion.
+     *
+     * @param value Value to convert
+     *
+     * @return Result of conversion
+     */
+    protected Object convertValue(SerializationContext ctxt,Object value) {
+        return _converter.convert(ctxt, value);
+    }
+
+    /**
+     * Helper method used for locating serializer to use in dynamic use case, where
+     * actual type value gets converted to is not specified beyond basic
+     * {@link java.lang.Object}, and where serializer needs to be located dynamically
+     * based on actual value type.
+     */
+    protected ValueSerializer<Object> _findSerializer(Object value, SerializationContext ctxt)
+    {
+        // 17-Apr-2018, tatu: Basically inline `_findAndAddDynamic(...)`
+        // 17-Apr-2018, tatu: difficult to know if these are primary or secondary serializers...
+        Class<?> cc = value.getClass();
+        PropertySerializerMap.SerializerAndMapResult result = _dynamicValueSerializers.findAndAddSecondarySerializer(cc,
+                ctxt, _property);
+        if (_dynamicValueSerializers != result.map) {
+            _dynamicValueSerializers = result.map;
+        }
+        return result.serializer;
+    }
 }
diff --git a/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java b/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java
index 8f8812e9b..93d4a9e55 100644
--- a/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java
@@ -358,7 +358,7 @@ public abstract class StdSerializer<T>
                 if ((existingSerializer == null) && !delegateType.isJavaLangObject()) {
                     existingSerializer = ctxt.findValueSerializer(delegateType);
                 }
-                return new StdConvertingSerializer(conv, delegateType, existingSerializer, prop);
+                return new StdDelegatingSerializer(conv, delegateType, existingSerializer, prop);
             }
         }
         return existingSerializer;
diff --git a/src/main/java/tools/jackson/databind/util/Converter.java b/src/main/java/tools/jackson/databind/util/Converter.java
index 5e03951ec..c87dc999f 100644
--- a/src/main/java/tools/jackson/databind/util/Converter.java
+++ b/src/main/java/tools/jackson/databind/util/Converter.java
@@ -14,7 +14,7 @@ import tools.jackson.databind.type.TypeFactory;
  * @param <IN> Type of values converter takes
  * @param <OUT> Result type from conversion
  *
- * @see tools.jackson.databind.ser.std.StdConvertingSerializer
+ * @see tools.jackson.databind.ser.std.StdDelegatingSerializer
  * @see tools.jackson.databind.deser.std.StdConvertingDeserializer
  */
 public interface Converter<IN,OUT>
diff --git a/src/test/java/tools/jackson/databind/convert/MapConversion4878Test.java b/src/test/java/tools/jackson/databind/convert/MapConversion4878Test.java
index dba388fcb..576e32805 100644
--- a/src/test/java/tools/jackson/databind/convert/MapConversion4878Test.java
+++ b/src/test/java/tools/jackson/databind/convert/MapConversion4878Test.java
@@ -10,7 +10,7 @@ import com.fasterxml.jackson.annotation.JsonFormat;
 import tools.jackson.databind.*;
 import tools.jackson.databind.module.SimpleModule;
 import tools.jackson.databind.module.SimpleSerializers;
-import tools.jackson.databind.ser.std.StdConvertingSerializer;
+import tools.jackson.databind.ser.std.StdDelegatingSerializer;
 import tools.jackson.databind.testutil.DatabindTestUtil;
 import tools.jackson.databind.util.StdConverter;
 
@@ -41,7 +41,7 @@ public class MapConversion4878Test extends DatabindTestUtil
                 JavaType type, BeanDescription.Supplier beanDescRef, JsonFormat.Value formatOverrides) {
             Class<?> rawClass = type.getRawClass();
             if (MapWrapper4878.class.isAssignableFrom(rawClass)) {
-                return new StdConvertingSerializer(new WrapperConverter4878());
+                return new StdDelegatingSerializer(new WrapperConverter4878());
             }
             return super.findSerializer(config, type, beanDescRef, formatOverrides);
         }
diff --git a/src/test/java/tools/jackson/databind/convert/StringConversionsTest.java b/src/test/java/tools/jackson/databind/convert/StringConversionsTest.java
index 2f8026b40..2c20c94ba 100644
--- a/src/test/java/tools/jackson/databind/convert/StringConversionsTest.java
+++ b/src/test/java/tools/jackson/databind/convert/StringConversionsTest.java
@@ -8,7 +8,6 @@ import tools.jackson.core.Base64Variants;
 import tools.jackson.databind.*;
 import tools.jackson.databind.annotation.JsonDeserialize;
 import tools.jackson.databind.annotation.JsonSerialize;
-import tools.jackson.databind.json.JsonMapper;
 import tools.jackson.databind.util.StdConverter;
 
 import static org.junit.jupiter.api.Assertions.*;
@@ -32,7 +31,7 @@ public class StringConversionsTest
         public StringWrapperWithConvert(String v) { value = v; }
     }
 
-    private final ObjectMapper MAPPER = new JsonMapper();
+    private final ObjectMapper MAPPER = new ObjectMapper();
 
     @Test
     public void testSimple()
@@ -55,7 +54,7 @@ public class StringConversionsTest
     {
         // let's verify our "neat trick" actually works...
         assertArrayEquals(new int[] { 1, 2, 3, 4, -1, 0 },
-                MAPPER.convertValue("1  2 3    4  -1 0".split("\\s+"), int[].class));
+                          MAPPER.convertValue("1  2 3    4  -1 0".split("\\s+"), int[].class));
     }
 
     @Test
@@ -88,15 +87,14 @@ public class StringConversionsTest
     @Test
     public void testLowerCasingSerializer() throws Exception
     {
-        assertEquals("{\"value\":\"abc\"}",
-                MAPPER.writeValueAsString(new StringWrapperWithConvert("ABC")));
+        assertEquals("{\"value\":\"abc\"}", MAPPER.writeValueAsString(new StringWrapperWithConvert("ABC")));
     }
 
     @Test
     public void testLowerCasingDeserializer() throws Exception
     {
-        StringWrapperWithConvert value = MAPPER.readValue("{\"value\":\"XyZ\"}",
-                StringWrapperWithConvert.class);
+        StringWrapperWithConvert value = MAPPER.readValue("{\"value\":\"XyZ\"}", StringWrapperWithConvert.class);
+        assertNotNull(value);
         assertEquals("xyz", value.value);
     }
 }
diff --git a/src/test/java/tools/jackson/databind/ext/xml/DOMElementWithCustomSerializerTest.java b/src/test/java/tools/jackson/databind/ext/xml/DOMElementWithCustomSerializerTest.java
deleted file mode 100644
index 5fb6b9f7c..000000000
--- a/src/test/java/tools/jackson/databind/ext/xml/DOMElementWithCustomSerializerTest.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package tools.jackson.databind.ext.xml;
-
-import javax.xml.parsers.DocumentBuilderFactory;
-import org.junit.jupiter.api.Test;
-import org.w3c.dom.Element;
-
-import tools.jackson.core.*;
-import tools.jackson.databind.*;
-import tools.jackson.databind.annotation.JsonSerialize;
-import tools.jackson.databind.ser.std.StdSerializer;
-import tools.jackson.databind.testutil.DatabindTestUtil;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-/**
- * Tests for verifying various issues with custom serializers.
- */
-public class DOMElementWithCustomSerializerTest extends DatabindTestUtil
-{
-    static class ElementSerializer extends StdSerializer<Element>
-    {
-        public ElementSerializer() { super(Element.class); }
-        @Override
-        public void serialize(Element value, JsonGenerator g, SerializationContext ctxt) {
-            g.writeString("element");
-        }
-    }
-
-    @JsonSerialize(using = ElementSerializer.class)
-    public static class ElementMixin {}
-
-    public static class Immutable {
-        protected int x() { return 3; }
-        protected int y() { return 7; }
-    }
-
-    /*
-    /**********************************************************************
-    /* Test methods
-    /**********************************************************************
-     */
-
-    @Test
-    public void testCustomElementSerializer() throws Exception
-    {
-        ObjectMapper mapper = jsonMapperBuilder()
-                .addMixIn(Element.class, ElementMixin.class)
-                .build();
-        Element element = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement("el");
-        assertEquals("\"element\"", mapper.writeValueAsString(element));
-    }
-}
diff --git a/src/test/java/tools/jackson/databind/ser/CustomSerializersTest.java b/src/test/java/tools/jackson/databind/ser/CustomSerializersTest.java
index c2da64764..69205a808 100644
--- a/src/test/java/tools/jackson/databind/ser/CustomSerializersTest.java
+++ b/src/test/java/tools/jackson/databind/ser/CustomSerializersTest.java
@@ -1,8 +1,11 @@
 package tools.jackson.databind.ser;
 
+import java.io.StringWriter;
 import java.util.*;
 
+import javax.xml.parsers.DocumentBuilderFactory;
 import org.junit.jupiter.api.Test;
+import org.w3c.dom.Element;
 
 import com.fasterxml.jackson.annotation.*;
 
@@ -26,6 +29,18 @@ import static org.junit.jupiter.api.Assertions.*;
  */
 public class CustomSerializersTest extends DatabindTestUtil
 {
+    static class ElementSerializer extends StdSerializer<Element>
+    {
+        public ElementSerializer() { super(Element.class); }
+        @Override
+        public void serialize(Element value, JsonGenerator gen, SerializationContext provider) {
+            gen.writeString("element");
+        }
+    }
+
+    @JsonSerialize(using = ElementSerializer.class)
+    public static class ElementMixin {}
+
     public static class Immutable {
         protected int x() { return 3; }
         protected int y() { return 7; }
@@ -137,30 +152,6 @@ public class CustomSerializersTest extends DatabindTestUtil
         }
     }
 
-    // Test for isEmpty() of StdConvertingSerializer
-    @JsonPropertyOrder({ "text", "other" })
-    static class ConvertingIsEmptyBean {
-        @JsonInclude(JsonInclude.Include.NON_EMPTY)
-        @JsonSerialize(converter = MaybeEmptyConverter.class)
-        public String text;
-
-        public String other;
-
-        public ConvertingIsEmptyBean(String t, String o) {
-            text = t;
-            other = o;
-        }
-    }
-
-    static class MaybeEmptyConverter extends StdConverter<String, String> {
-        @Override
-        public String convert(String value) {
-            if ("NULL".equals(value)) return null;
-            if ("EMPTY".equals(value)) return "";
-            return value;
-        }
-    }
-
     // [databind#2475]
     static class MyFilter2475 extends SimpleBeanPropertyFilter {
         @Override
@@ -198,7 +189,11 @@ public class CustomSerializersTest extends DatabindTestUtil
 
     // [databind#4575]
     @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "@type")
-    @JsonSubTypes({ @JsonSubTypes.Type(Sub4575.class) })
+    @JsonSubTypes(
+        {
+            @JsonSubTypes.Type(Sub4575.class)
+        }
+    )
     @JsonTypeName("Super")
     static class Super4575 {
         public static final Super4575 NULL = new Super4575();
@@ -207,8 +202,7 @@ public class CustomSerializersTest extends DatabindTestUtil
     @JsonTypeName("Sub")
     static class Sub4575 extends Super4575 { }
 
-    static class NullSerializer4575 extends StdConvertingSerializer
-    {
+    static class NullSerializer4575 extends StdDelegatingSerializer {
         public NullSerializer4575(Converter<Object, ?> converter, JavaType delegateType,
                 ValueSerializer<?> delegateSerializer,
                 BeanProperty prop) {
@@ -241,7 +235,7 @@ public class CustomSerializersTest extends DatabindTestUtil
         }
 
         @Override
-        protected StdConvertingSerializer withDelegate(Converter<Object, ?> converter,
+        protected StdDelegatingSerializer withDelegate(Converter<Object, ?> converter,
                 JavaType delegateType, ValueSerializer<?> delegateSerializer,
                 BeanProperty prop) {
             return new NullSerializer4575(converter, delegateType, delegateSerializer, prop);
@@ -249,13 +243,25 @@ public class CustomSerializersTest extends DatabindTestUtil
     }
 
     /*
-    /**********************************************************************
-    /* Test methods
-    /**********************************************************************
+    /**********************************************************
+    /* Unit tests
+    /**********************************************************
      */
 
     private final ObjectMapper MAPPER = newJsonMapper();
 
+    @Test
+    public void testCustomization() throws Exception
+    {
+        ObjectMapper mapper = jsonMapperBuilder()
+                .addMixIn(Element.class, ElementMixin.class)
+                .build();
+        Element element = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement("el");
+        StringWriter sw = new StringWriter();
+        mapper.writeValue(sw, element);
+        assertEquals(sw.toString(), "\"element\"");
+    }
+
     @SuppressWarnings({ "unchecked", "rawtypes" })
     @Test
     public void testCustomLists() throws Exception
@@ -288,29 +294,6 @@ public class CustomSerializersTest extends DatabindTestUtil
     // [databind#87]: delegating serializer
     @Test
     public void testDelegating() throws Exception
-    {
-        SimpleModule module = new SimpleModule("test", Version.unknownVersion());
-        module.addSerializer(new StdConvertingSerializer(Immutable.class,
-                new StdConverter<Immutable, Map<String,Integer>>() {
-                    @Override
-                    public Map<String, Integer> convert(Immutable value)
-                    {
-                        HashMap<String,Integer> map = new LinkedHashMap<String,Integer>();
-                        map.put("x", value.x());
-                        map.put("y", value.y());
-                        return map;
-                    }
-        }));
-        ObjectMapper mapper = jsonMapperBuilder()
-                .addModule(module)
-                .build();
-        assertEquals("{\"x\":3,\"y\":7}", mapper.writeValueAsString(new Immutable()));
-    }
-
-    // [databind#5631]
-    @SuppressWarnings("deprecation")
-    @Test
-    public void testDelegatingWithDeprecated() throws Exception
     {
         SimpleModule module = new SimpleModule("test", Version.unknownVersion());
         module.addSerializer(new StdDelegatingSerializer(Immutable.class,
@@ -329,7 +312,7 @@ public class CustomSerializersTest extends DatabindTestUtil
                 .build();
         assertEquals("{\"x\":3,\"y\":7}", mapper.writeValueAsString(new Immutable()));
     }
-    
+
     // [databind#215]: Allow registering CharacterEscapes via ObjectWriter
     @Test
     public void testCustomEscapes() throws Exception
@@ -381,24 +364,6 @@ public class CustomSerializersTest extends DatabindTestUtil
         assertEquals(a2q("['FOO',null]"), mapper.writeValueAsString(set));
     }
 
-    // Test that StdConvertingSerializer.isEmpty() works with NON_EMPTY inclusion:
-    // converter returning null means empty, converter returning "" means empty,
-    // converter returning non-empty string means not empty.
-    @Test
-    public void testConvertingSerializerIsEmpty() throws Exception {
-        // Converted to null -> isEmpty() returns true -> property excluded
-        assertEquals(a2q("{'other':'a'}"),
-                MAPPER.writeValueAsString(new ConvertingIsEmptyBean("NULL", "a")));
-
-        // Converted to "" -> delegate isEmpty() returns true -> property excluded
-        assertEquals(a2q("{'other':'b'}"),
-                MAPPER.writeValueAsString(new ConvertingIsEmptyBean("EMPTY", "b")));
-
-        // Converted to non-empty -> isEmpty() returns false -> property included
-        assertEquals(a2q("{'text':'hello','other':'c'}"),
-                MAPPER.writeValueAsString(new ConvertingIsEmptyBean("hello", "c")));
-    }
-
     // [databind#2475]
     @Test
     public void testIssue2475() throws Exception {
