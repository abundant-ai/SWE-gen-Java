diff --git a/release-notes/VERSION b/release-notes/VERSION
index 8047716c3..6bf9d2b38 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -5,7 +5,7 @@ Versions: 3.x (for earlier see VERSION-2.x)
 === Releases ===
 ------------------------------------------------------------------------
 
-3.1.0-rc1 (27-Jan-2026)
+3.1.0 (not yet released)
 
 #221: Support alternate radixes when writing numeric values as strings
  (requested by Christopher C)
@@ -163,6 +163,7 @@ Versions: 3.x (for earlier see VERSION-2.x)
  (implemented by @cowtowncoder, w/ Claude code)
 #5621: Fix typo: MissingInjectableValueExcepion â†’ MissingInjectableValueException
  (implemented by Lee Jiwon)
+#5631: Rename `StdDelegatingSerializer` to `StdConvertingSerializer` (3.0->3.1)
 
 3.0.4 (not yet released)
 
diff --git a/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java b/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java
index 31c2df9fb..85cff6881 100644
--- a/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java
+++ b/src/main/java/tools/jackson/databind/ser/BasicSerializerFactory.java
@@ -438,7 +438,7 @@ public abstract class BasicSerializerFactory
             return ser;
         }
         JavaType delegateType = conv.getOutputType(ctxt.getTypeFactory());
-        return new StdDelegatingSerializer(conv, delegateType, ser, null);
+        return new StdConvertingSerializer(conv, delegateType, ser, null);
     }
 
     protected Converter<Object,Object> findConverter(SerializationContext ctxt,
diff --git a/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java b/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java
index cd7f7c9e3..3e3d6fd36 100644
--- a/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java
+++ b/src/main/java/tools/jackson/databind/ser/BeanSerializerFactory.java
@@ -24,7 +24,7 @@ import tools.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;
 import tools.jackson.databind.ser.impl.UnsupportedTypeSerializer;
 import tools.jackson.databind.ser.jdk.MapEntryAsPOJOSerializer;
 import tools.jackson.databind.ser.jdk.MapSerializer;
-import tools.jackson.databind.ser.std.StdDelegatingSerializer;
+import tools.jackson.databind.ser.std.StdConvertingSerializer;
 import tools.jackson.databind.ser.std.ToEmptyObjectSerializer;
 import tools.jackson.databind.type.ReferenceType;
 import tools.jackson.databind.util.BeanUtil;
@@ -176,7 +176,7 @@ public class BeanSerializerFactory
             if ((ser == null) && !delegateType.isJavaLangObject()) {
                 ser = _createSerializer2(ctxt, beanDescRef, delegateType, formatOverrides, true);
             }
-            return new StdDelegatingSerializer(conv, delegateType, ser, null);
+            return new StdConvertingSerializer(conv, delegateType, ser, null);
         }
         // No, regular serializer
         return (ValueSerializer<Object>) _createSerializer2(ctxt, beanDescRef, type, formatOverrides, staticTyping);
diff --git a/src/main/java/tools/jackson/databind/ser/bean/BeanSerializerBase.java b/src/main/java/tools/jackson/databind/ser/bean/BeanSerializerBase.java
index 5ac78df85..305aae5cc 100644
--- a/src/main/java/tools/jackson/databind/ser/bean/BeanSerializerBase.java
+++ b/src/main/java/tools/jackson/databind/ser/bean/BeanSerializerBase.java
@@ -18,7 +18,7 @@ import tools.jackson.databind.ser.impl.PropertyBasedObjectIdGenerator;
 import tools.jackson.databind.ser.jdk.EnumSerializer;
 import tools.jackson.databind.ser.jdk.MapEntrySerializer;
 import tools.jackson.databind.ser.std.StdContainerSerializer;
-import tools.jackson.databind.ser.std.StdDelegatingSerializer;
+import tools.jackson.databind.ser.std.StdConvertingSerializer;
 import tools.jackson.databind.ser.std.StdSerializer;
 import tools.jackson.databind.util.ClassUtil;
 import tools.jackson.databind.util.Converter;
@@ -366,7 +366,7 @@ public abstract class BeanSerializerBase
                     // [databind#731]: Should skip if nominally java.lang.Object
                     ValueSerializer<?> ser = delegateType.isJavaLangObject() ? null
                             : ctxt.findPrimaryPropertySerializer(delegateType, prop);
-                    return new StdDelegatingSerializer(conv, delegateType, ser, prop);
+                    return new StdConvertingSerializer(conv, delegateType, ser, prop);
                 }
             }
         }
diff --git a/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java b/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java
index 6fcb81979..91bcc23f4 100644
--- a/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java
@@ -239,7 +239,7 @@ public abstract class ReferenceTypeSerializer<T>
         return refSer;
     }
 
-    protected boolean _useStatic(SerializationContext serializers, BeanProperty property,
+    protected boolean _useStatic(SerializationContext ctxt, BeanProperty property,
             JavaType referredType)
     {
         // First: no serializer for `Object.class`, must be dynamic
@@ -255,11 +255,11 @@ public abstract class ReferenceTypeSerializer<T>
             return true;
         }
         // if neither, maybe explicit annotation?
-        AnnotationIntrospector intr = serializers.getAnnotationIntrospector();
+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();
         if ((intr != null) && (property != null)) {
             Annotated ann = property.getMember();
             if (ann != null) {
-                JsonSerialize.Typing t = intr.findSerializationTyping(serializers.getConfig(),
+                JsonSerialize.Typing t = intr.findSerializationTyping(ctxt.getConfig(),
                         property.getMember());
                 if (t == JsonSerialize.Typing.STATIC) {
                     return true;
@@ -270,7 +270,7 @@ public abstract class ReferenceTypeSerializer<T>
             }
         }
         // and finally, may be forced by global static typing (unlikely...)
-        return serializers.isEnabled(MapperFeature.USE_STATIC_TYPING);
+        return ctxt.isEnabled(MapperFeature.USE_STATIC_TYPING);
     }
 
     /*
diff --git a/src/main/java/tools/jackson/databind/ser/std/StdConvertingSerializer.java b/src/main/java/tools/jackson/databind/ser/std/StdConvertingSerializer.java
new file mode 100644
index 000000000..892dac1e7
--- /dev/null
+++ b/src/main/java/tools/jackson/databind/ser/std/StdConvertingSerializer.java
@@ -0,0 +1,273 @@
+package tools.jackson.databind.ser.std;
+
+import tools.jackson.core.JacksonException;
+import tools.jackson.core.JsonGenerator;
+import tools.jackson.databind.*;
+import tools.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
+import tools.jackson.databind.jsontype.TypeSerializer;
+import tools.jackson.databind.ser.impl.PropertySerializerMap;
+import tools.jackson.databind.util.ClassUtil;
+import tools.jackson.databind.util.Converter;
+
+/**
+ * Serializer implementation where given Java type is first converted
+ * to an intermediate "delegate type" (using a configured
+ * {@link Converter}, and then this delegate value is serialized by Jackson.
+ *<p>
+ * Note that although types may be related, they must not be same; trying
+ * to do this will result in an exception.
+ *
+ * @see Converter
+ *
+ * @since 3.1 (in 3.0 was incorrectly named {@link StdDelegatingSerializer})
+ */
+@SuppressWarnings("javadoc")
+public class StdConvertingSerializer
+    extends StdSerializer<Object>
+{
+    // @since 3.0
+    protected final BeanProperty _property;
+
+    protected final Converter<Object,?> _converter;
+
+    /**
+     * Fully resolved delegate type, with generic information if any available.
+     */
+    protected final JavaType _delegateType;
+
+    /**
+     * Underlying serializer for the intermediate type.
+     */
+    protected final ValueSerializer<Object> _delegateSerializer;
+
+    /**
+     * If delegate serializer needs to be accessed dynamically (non-final
+     * type, static type not forced), this data structure helps with efficient
+     * lookups.
+     *
+     * @since 3.0
+     */
+    protected PropertySerializerMap _dynamicValueSerializers = PropertySerializerMap.emptyForProperties();
+
+    /*
+    /**********************************************************************
+    /* Life-cycle
+    /**********************************************************************
+     */
+
+    @SuppressWarnings("unchecked")
+    public StdConvertingSerializer(Converter<?,?> converter)
+    {
+        super(Object.class);
+        _converter = (Converter<Object,?>)converter;
+        _delegateType = null;
+        _delegateSerializer = null;
+        _property = null;
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T> StdConvertingSerializer(Class<T> cls, Converter<T,?> converter)
+    {
+        super(cls);
+        _converter = (Converter<Object,?>)converter;
+        _delegateType = null;
+        _delegateSerializer = null;
+        _property = null;
+    }
+
+    @SuppressWarnings("unchecked")
+    public StdConvertingSerializer(Converter<Object,?> converter,
+            JavaType delegateType, ValueSerializer<?> delegateSerializer,
+            BeanProperty prop)
+    {
+        super(delegateType);
+        _converter = converter;
+        _delegateType = delegateType;
+        _delegateSerializer = (ValueSerializer<Object>) delegateSerializer;
+        _property = prop;
+    }
+
+    /**
+     * Method used for creating resolved contextual instances. Must be
+     * overridden when sub-classing.
+     */
+    protected StdConvertingSerializer withDelegate(Converter<Object,?> converter,
+            JavaType delegateType, ValueSerializer<?> delegateSerializer,
+            BeanProperty prop)
+    {
+        ClassUtil.verifyMustOverride(StdConvertingSerializer.class, this, "withDelegate");
+        return new StdConvertingSerializer(converter, delegateType, delegateSerializer, prop);
+    }
+
+    /*
+    /**********************************************************************
+    /* Contextualization
+    /**********************************************************************
+     */
+
+    @Override
+    public void resolve(SerializationContext ctxt)
+    {
+        if (_delegateSerializer != null) {
+            _delegateSerializer.resolve(ctxt);
+        }
+    }
+
+    @Override
+    public ValueSerializer<?> createContextual(SerializationContext ctxt, BeanProperty property)
+    {
+        ValueSerializer<?> delSer = _delegateSerializer;
+        JavaType delegateType = _delegateType;
+
+        if (delSer == null) {
+            // Otherwise, need to locate serializer to delegate to. For that we need type information...
+            if (delegateType == null) {
+                delegateType = _converter.getOutputType(ctxt.getTypeFactory());
+            }
+            // 02-Apr-2015, tatu: For "dynamic case", where type is only specified as
+            //    java.lang.Object (or missing generic), [databind#731]
+            if (!delegateType.isJavaLangObject()) {
+                delSer = ctxt.findValueSerializer(delegateType);
+            }
+        }
+        if (delSer != null) {
+            delSer = ctxt.handleSecondaryContextualization(delSer, property);
+        }
+        if ((delSer == _delegateSerializer)
+                && (delegateType == _delegateType) && (property == _property)) {
+            return this;
+        }
+        return withDelegate(_converter, delegateType, delSer, property);
+    }
+
+    /*
+    /**********************************************************************
+    /* Accessors
+    /**********************************************************************
+     */
+
+    public Converter<Object, ?> getConverter() {
+        return _converter;
+    }
+
+    @Override
+    public ValueSerializer<?> getDelegatee() {
+        return _delegateSerializer;
+    }
+
+    /*
+    /**********************************************************************
+    /* Serialization
+    /**********************************************************************
+     */
+
+    @Override
+    public void serialize(Object value, JsonGenerator gen, SerializationContext ctxt)
+        throws JacksonException
+    {
+        Object delegateValue = convertValue(ctxt, value);
+        // should we accept nulls?
+        if (delegateValue == null) {
+            ctxt.defaultSerializeNullValue(gen);
+            return;
+        }
+        // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup
+        ValueSerializer<Object> ser = _delegateSerializer;
+        if (ser == null) {
+            ser = _findSerializer(delegateValue, ctxt);
+        }
+        ser.serialize(delegateValue, gen, ctxt);
+    }
+
+    @Override
+    public void serializeWithType(Object value, JsonGenerator gen, SerializationContext ctxt,
+            TypeSerializer typeSer)
+        throws JacksonException
+    {
+        // 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,
+        //    let's give it a chance?
+        Object delegateValue = convertValue(ctxt, value);
+        // consider null (to be consistent with serialize method above)
+        if (delegateValue == null) {
+            ctxt.defaultSerializeNullValue(gen);
+            return;
+        }
+        ValueSerializer<Object> ser = _delegateSerializer;
+        if (ser == null) {
+            ser = _findSerializer(delegateValue, ctxt);
+        }
+        ser.serializeWithType(delegateValue, gen, ctxt, typeSer);
+    }
+
+    @Override
+    public boolean isEmpty(SerializationContext ctxt, Object value)
+    {
+        Object delegateValue = convertValue(ctxt, value);
+        if (delegateValue == null) {
+            return true;
+        }
+        ValueSerializer<Object> ser = _delegateSerializer;
+        if (ser == null) {
+            ser = _findSerializer(value, ctxt);
+        }
+        return ser.isEmpty(ctxt, delegateValue);
+    }
+
+    /*
+    /**********************************************************************
+    /* Schema functionality
+    /**********************************************************************
+     */
+
+    @Override
+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
+    {
+        // 03-Sep-2012, tatu: Not sure if this can be made to really work
+        //    properly... but for now, try this:
+
+        // 02-Apr-2015, tatu: For dynamic case, very little we can do
+        if (_delegateSerializer != null) {
+            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);
+        }
+    }
+
+    /*
+    /**********************************************************************
+    /* Overridable methods
+    /**********************************************************************
+     */
+
+    /**
+     * Method called to convert from source Java value into delegate
+     * value (which will be serialized using standard Jackson serializer for delegate type)
+     *<P>
+     * The default implementation uses configured {@link Converter} to do
+     * conversion.
+     *
+     * @param value Value to convert
+     *
+     * @return Result of conversion
+     */
+    protected Object convertValue(SerializationContext ctxt,Object value) {
+        return _converter.convert(ctxt, value);
+    }
+
+    /**
+     * Helper method used for locating serializer to use in dynamic use case, where
+     * actual type value gets converted to is not specified beyond basic
+     * {@link java.lang.Object}, and where serializer needs to be located dynamically
+     * based on actual value type.
+     */
+    protected ValueSerializer<Object> _findSerializer(Object value, SerializationContext ctxt)
+    {
+        // 17-Apr-2018, tatu: Basically inline `_findAndAddDynamic(...)`
+        // 17-Apr-2018, tatu: difficult to know if these are primary or secondary serializers...
+        Class<?> cc = value.getClass();
+        PropertySerializerMap.SerializerAndMapResult result = _dynamicValueSerializers.findAndAddSecondarySerializer(cc,
+                ctxt, _property);
+        if (_dynamicValueSerializers != result.map) {
+            _dynamicValueSerializers = result.map;
+        }
+        return result.serializer;
+    }
+}
diff --git a/src/main/java/tools/jackson/databind/ser/std/StdDelegatingSerializer.java b/src/main/java/tools/jackson/databind/ser/std/StdDelegatingSerializer.java
index 86e8538f6..f47dbaf19 100644
--- a/src/main/java/tools/jackson/databind/ser/std/StdDelegatingSerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/std/StdDelegatingSerializer.java
@@ -1,94 +1,44 @@
 package tools.jackson.databind.ser.std;
 
-import tools.jackson.core.JacksonException;
-import tools.jackson.core.JsonGenerator;
 import tools.jackson.databind.*;
-import tools.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
-import tools.jackson.databind.jsontype.TypeSerializer;
-import tools.jackson.databind.ser.impl.PropertySerializerMap;
 import tools.jackson.databind.util.ClassUtil;
 import tools.jackson.databind.util.Converter;
 
 /**
- * Serializer implementation where given Java type is first converted
- * to an intermediate "delegate type" (using a configured
- * {@link Converter}, and then this delegate value is serialized by Jackson.
- *<p>
- * Note that although types may be related, they must not be same; trying
- * to do this will result in an exception.
+ * Older incorrectly named (in 3.0) variant of {@link StdConvertingSerializer}.
+ *
+ * @deprecated Since 3.1 should use correctly named {@link StdConvertingSerializer} instead.
  */
+@Deprecated
 public class StdDelegatingSerializer
-    extends StdSerializer<Object>
+    extends StdConvertingSerializer
 {
-    // @since 3.0
-    protected final BeanProperty _property;
-
-    protected final Converter<Object,?> _converter;
-
-    /**
-     * Fully resolved delegate type, with generic information if any available.
-     */
-    protected final JavaType _delegateType;
-
-    /**
-     * Underlying serializer for type <code>T</code>.
-     */
-    protected final ValueSerializer<Object> _delegateSerializer;
-
-    /**
-     * If delegate serializer needs to be accessed dynamically (non-final
-     * type, static type not forced), this data structure helps with efficient
-     * lookups.
-     *
-     * @since 3.0
-     */
-    protected PropertySerializerMap _dynamicValueSerializers = PropertySerializerMap.emptyForProperties();
-
     /*
     /**********************************************************************
     /* Life-cycle
     /**********************************************************************
      */
 
-    @SuppressWarnings("unchecked")
-    public StdDelegatingSerializer(Converter<?,?> converter)
-    {
-        super(Object.class);
-        _converter = (Converter<Object,?>)converter;
-        _delegateType = null;
-        _delegateSerializer = null;
-        _property = null;
+    @Deprecated
+    public StdDelegatingSerializer(Converter<?,?> converter) {
+        super(converter);
     }
 
-    @SuppressWarnings("unchecked")
-    public <T> StdDelegatingSerializer(Class<T> cls, Converter<T,?> converter)
-    {
-        super(cls);
-        _converter = (Converter<Object,?>)converter;
-        _delegateType = null;
-        _delegateSerializer = null;
-        _property = null;
+    @Deprecated
+    public <T> StdDelegatingSerializer(Class<T> cls, Converter<T,?> converter) {
+        super(cls, converter);
     }
 
-    /**
-     * @since 3.0
-     */
-    @SuppressWarnings("unchecked")
+    @Deprecated
     public StdDelegatingSerializer(Converter<Object,?> converter,
             JavaType delegateType, ValueSerializer<?> delegateSerializer,
             BeanProperty prop)
     {
-        super(delegateType);
-        _converter = converter;
-        _delegateType = delegateType;
-        _delegateSerializer = (ValueSerializer<Object>) delegateSerializer;
-        _property = prop;
+        super(converter, delegateType, delegateSerializer, prop);
     }
 
-    /**
-     * Method used for creating resolved contextual instances. Must be
-     * overridden when sub-classing.
-     */
+    @Deprecated
+    @Override
     protected StdDelegatingSerializer withDelegate(Converter<Object,?> converter,
             JavaType delegateType, ValueSerializer<?> delegateSerializer,
             BeanProperty prop)
@@ -96,176 +46,4 @@ public class StdDelegatingSerializer
         ClassUtil.verifyMustOverride(StdDelegatingSerializer.class, this, "withDelegate");
         return new StdDelegatingSerializer(converter, delegateType, delegateSerializer, prop);
     }
-
-    /*
-    /**********************************************************************
-    /* Contextualization
-    /**********************************************************************
-     */
-
-    @Override
-    public void resolve(SerializationContext ctxt)
-    {
-        if (_delegateSerializer != null) {
-            _delegateSerializer.resolve(ctxt);
-        }
-    }
-
-    @Override
-    public ValueSerializer<?> createContextual(SerializationContext ctxt, BeanProperty property)
-    {
-        ValueSerializer<?> delSer = _delegateSerializer;
-        JavaType delegateType = _delegateType;
-
-        if (delSer == null) {
-            // Otherwise, need to locate serializer to delegate to. For that we need type information...
-            if (delegateType == null) {
-                delegateType = _converter.getOutputType(ctxt.getTypeFactory());
-            }
-            // 02-Apr-2015, tatu: For "dynamic case", where type is only specified as
-            //    java.lang.Object (or missing generic), [databind#731]
-            if (!delegateType.isJavaLangObject()) {
-                delSer = ctxt.findValueSerializer(delegateType);
-            }
-        }
-        if (delSer != null) {
-            delSer = ctxt.handleSecondaryContextualization(delSer, property);
-        }
-        if ((delSer == _delegateSerializer)
-                && (delegateType == _delegateType) && (property == _property)) {
-            return this;
-        }
-        return withDelegate(_converter, delegateType, delSer, property);
-    }
-
-    /*
-    /**********************************************************************
-    /* Accessors
-    /**********************************************************************
-     */
-
-    public Converter<Object, ?> getConverter() {
-        return _converter;
-    }
-
-    @Override
-    public ValueSerializer<?> getDelegatee() {
-        return _delegateSerializer;
-    }
-
-    /*
-    /**********************************************************************
-    /* Serialization
-    /**********************************************************************
-     */
-
-    @Override
-    public void serialize(Object value, JsonGenerator gen, SerializationContext ctxt)
-        throws JacksonException
-    {
-        Object delegateValue = convertValue(ctxt, value);
-        // should we accept nulls?
-        if (delegateValue == null) {
-            ctxt.defaultSerializeNullValue(gen);
-            return;
-        }
-        // 02-Apr-2015, tatu: As per [databind#731] may need to do dynamic lookup
-        ValueSerializer<Object> ser = _delegateSerializer;
-        if (ser == null) {
-            ser = _findSerializer(delegateValue, ctxt);
-        }
-        ser.serialize(delegateValue, gen, ctxt);
-    }
-
-    @Override
-    public void serializeWithType(Object value, JsonGenerator gen, SerializationContext ctxt,
-            TypeSerializer typeSer)
-        throws JacksonException
-    {
-        // 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,
-        //    let's give it a chance?
-        Object delegateValue = convertValue(ctxt, value);
-        // consider null (to be consistent with serialize method above)
-        if (delegateValue == null) {
-            ctxt.defaultSerializeNullValue(gen);
-            return;
-        }
-        ValueSerializer<Object> ser = _delegateSerializer;
-        if (ser == null) {
-            ser = _findSerializer(delegateValue, ctxt);
-        }
-        ser.serializeWithType(delegateValue, gen, ctxt, typeSer);
-    }
-
-    @Override
-    public boolean isEmpty(SerializationContext ctxt, Object value)
-    {
-        Object delegateValue = convertValue(ctxt, value);
-        if (delegateValue == null) {
-            return true;
-        }
-        ValueSerializer<Object> ser = _delegateSerializer;
-        if (ser == null) {
-            ser = _findSerializer(value, ctxt);
-        }
-        return ser.isEmpty(ctxt, delegateValue);
-    }
-
-    /*
-    /**********************************************************************
-    /* Schema functionality
-    /**********************************************************************
-     */
-
-    @Override
-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
-    {
-        // 03-Sep-2012, tatu: Not sure if this can be made to really work
-        //    properly... but for now, try this:
-
-        // 02-Apr-2015, tatu: For dynamic case, very little we can do
-        if (_delegateSerializer != null) {
-            _delegateSerializer.acceptJsonFormatVisitor(visitor, typeHint);
-        }
-    }
-
-    /*
-    /**********************************************************************
-    /* Overridable methods
-    /**********************************************************************
-     */
-
-    /**
-     * Method called to convert from source Java value into delegate
-     * value (which will be serialized using standard Jackson serializer for delegate type)
-     *<P>
-     * The default implementation uses configured {@link Converter} to do
-     * conversion.
-     *
-     * @param value Value to convert
-     *
-     * @return Result of conversion
-     */
-    protected Object convertValue(SerializationContext ctxt,Object value) {
-        return _converter.convert(ctxt, value);
-    }
-
-    /**
-     * Helper method used for locating serializer to use in dynamic use case, where
-     * actual type value gets converted to is not specified beyond basic
-     * {@link java.lang.Object}, and where serializer needs to be located dynamically
-     * based on actual value type.
-     */
-    protected ValueSerializer<Object> _findSerializer(Object value, SerializationContext ctxt)
-    {
-        // 17-Apr-2018, tatu: Basically inline `_findAndAddDynamic(...)`
-        // 17-Apr-2018, tatu: difficult to know if these are primary or secondary serializers...
-        Class<?> cc = value.getClass();
-        PropertySerializerMap.SerializerAndMapResult result = _dynamicValueSerializers.findAndAddSecondarySerializer(cc,
-                ctxt, _property);
-        if (_dynamicValueSerializers != result.map) {
-            _dynamicValueSerializers = result.map;
-        }
-        return result.serializer;
-    }
 }
diff --git a/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java b/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java
index 93d4a9e55..8f8812e9b 100644
--- a/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/std/StdSerializer.java
@@ -358,7 +358,7 @@ public abstract class StdSerializer<T>
                 if ((existingSerializer == null) && !delegateType.isJavaLangObject()) {
                     existingSerializer = ctxt.findValueSerializer(delegateType);
                 }
-                return new StdDelegatingSerializer(conv, delegateType, existingSerializer, prop);
+                return new StdConvertingSerializer(conv, delegateType, existingSerializer, prop);
             }
         }
         return existingSerializer;
diff --git a/src/main/java/tools/jackson/databind/util/Converter.java b/src/main/java/tools/jackson/databind/util/Converter.java
index c87dc999f..5e03951ec 100644
--- a/src/main/java/tools/jackson/databind/util/Converter.java
+++ b/src/main/java/tools/jackson/databind/util/Converter.java
@@ -14,7 +14,7 @@ import tools.jackson.databind.type.TypeFactory;
  * @param <IN> Type of values converter takes
  * @param <OUT> Result type from conversion
  *
- * @see tools.jackson.databind.ser.std.StdDelegatingSerializer
+ * @see tools.jackson.databind.ser.std.StdConvertingSerializer
  * @see tools.jackson.databind.deser.std.StdConvertingDeserializer
  */
 public interface Converter<IN,OUT>
