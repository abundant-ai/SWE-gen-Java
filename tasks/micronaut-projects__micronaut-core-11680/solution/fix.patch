diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java b/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java
index ff73103afe..c227edf640 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java
@@ -16,6 +16,7 @@
 package io.micronaut.inject.ast;
 
 import io.micronaut.core.annotation.AnnotationMetadata;
+import io.micronaut.core.annotation.NextMajorVersion;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.ReflectiveAccess;
 
@@ -107,6 +108,7 @@ public interface MemberElement extends Element {
      * @return Will return {@code true} if is accessible.
      * @since 4.3.0
      */
+    @NextMajorVersion("The ReflectiveAccess should not be checked here and accessibility should fail if ReflectiveAccess is not present")
     default boolean isAccessible(@NonNull ClassElement callingType, boolean allowReflection) {
         if (isPublic()) {
             return true;
diff --git a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
index c0e8d139e8..5b5e6476dd 100644
--- a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
@@ -222,7 +222,7 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
         this.beanType = ClassTypeDef.of(beanClassElement);
         this.introspectionName = computeShortIntrospectionName(targetPackage, name);
         this.introspectionTypeDef = ClassTypeDef.of(introspectionName);
-        this.dispatchWriter = new DispatchWriter();
+        this.dispatchWriter = new DispatchWriter(introspectionName);
         this.annotationMetadata = annotationMetadata.getTargetAnnotationMetadata();
         this.originatingElements = OriginatingElements.of(beanClassElement);
         evaluatedExpressionProcessor = new EvaluatedExpressionProcessor(visitorContext, beanClassElement);
@@ -253,7 +253,7 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
         this.beanType = ClassTypeDef.of(beanClassElement);
         this.introspectionName = computeIntrospectionName(targetPackage, className);
         this.introspectionTypeDef = ClassTypeDef.of(introspectionName);
-        this.dispatchWriter = new DispatchWriter();
+        this.dispatchWriter = new DispatchWriter(introspectionName);
         this.annotationMetadata = annotationMetadata.getTargetAnnotationMetadata();
         this.originatingElements = OriginatingElements.of(originatingElement);
         evaluatedExpressionProcessor = new EvaluatedExpressionProcessor(visitorContext, beanClassElement);
@@ -1120,6 +1120,10 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
                         FieldElement field = fieldGetDispatchTarget.getField();
                         propertyType = field.getGenericType();
                         member = field;
+                    } else if (dispatchTarget instanceof DispatchWriter.FieldGetReflectionDispatchTarget fieldGetDispatchTarget) {
+                        FieldElement field = fieldGetDispatchTarget.getField();
+                        propertyType = field.getGenericType();
+                        member = field;
                     } else {
                         throw new IllegalStateException();
                     }
@@ -1205,6 +1209,9 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
                             } else if (readDispatch instanceof DispatchWriter.FieldGetDispatchTarget fieldGetDispatchTarget) {
                                 FieldElement fieldElement = fieldGetDispatchTarget.getField();
                                 oldValueExp = prevBeanVar.field(fieldElement);
+                            } else if (readDispatch instanceof DispatchWriter.FieldGetReflectionDispatchTarget fieldGetDispatchTarget) {
+                                FieldElement fieldElement = fieldGetDispatchTarget.getField();
+                                oldValueExp = prevBeanVar.field(fieldElement);
                             } else {
                                 throw new IllegalStateException();
                             }
@@ -1223,6 +1230,11 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
                                 statements.add(
                                         newBeanVar.field(fieldElement).assign(oldValueExp)
                                 );
+                            } else if (writeDispatch instanceof DispatchWriter.FieldSetReflectionDispatchTarget fieldSetDispatchTarget) {
+                                FieldElement fieldElement = fieldSetDispatchTarget.getField();
+                                statements.add(
+                                        newBeanVar.field(fieldElement).assign(oldValueExp)
+                                );
                             } else {
                                 throw new IllegalStateException();
                             }
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/DispatchWriter.java b/core-processor/src/main/java/io/micronaut/inject/writer/DispatchWriter.java
index be230639f0..98d4245126 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/DispatchWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/DispatchWriter.java
@@ -96,6 +96,12 @@ public final class DispatchWriter implements ClassOutputWriter {
 
     private boolean hasInterceptedMethod;
 
+    private final String thisType;
+
+    public DispatchWriter(String thisType) {
+        this.thisType = thisType;
+    }
+
     /**
      * Adds new set field dispatch target.
      *
@@ -103,6 +109,9 @@ public final class DispatchWriter implements ClassOutputWriter {
      * @return the target index
      */
     public int addSetField(FieldElement beanField) {
+        if (beanField.isReflectionRequired(ClassElement.of(thisType))) {
+            return addDispatchTarget(new FieldSetReflectionDispatchTarget(beanField));
+        }
         return addDispatchTarget(new FieldSetDispatchTarget(beanField));
     }
 
@@ -113,6 +122,9 @@ public final class DispatchWriter implements ClassOutputWriter {
      * @return the target index
      */
     public int addGetField(FieldElement beanField) {
+        if (beanField.isReflectionRequired(ClassElement.of(thisType))) {
+            return addDispatchTarget(new FieldGetReflectionDispatchTarget(beanField));
+        }
         return addDispatchTarget(new FieldGetDispatchTarget(beanField));
     }
 
@@ -144,7 +156,7 @@ public final class DispatchWriter implements ClassOutputWriter {
         List<ParameterElement> argumentTypes = Arrays.asList(methodElement.getSuspendParameters());
         boolean isKotlinDefault = argumentTypes.stream().anyMatch(p -> p instanceof KotlinParameterElement kp && kp.hasDefault());
         ClassElement declaringClassType = (ClassElement) declaringType;
-        if (methodElement.isReflectionRequired()) {
+        if (methodElement.isReflectionRequired(ClassElement.of(thisType))) {
             if (isKotlinDefault) {
                 throw new ProcessingException(methodElement, "Kotlin default methods are not supported for reflection invocation");
             }
@@ -514,19 +526,57 @@ public final class DispatchWriter implements ClassOutputWriter {
 
         @Override
         public ExpressionDef dispatchExpression(ExpressionDef bean) {
-            final TypeDef propertyType = TypeDef.of(beanField.getType());
-            final ClassTypeDef targetType = ClassTypeDef.of(beanField.getOwningType());
-
-            if (beanField.isReflectionRequired()) {
-                return TYPE_REFLECTION_UTILS.invokeStatic(
-                    METHOD_GET_FIELD_VALUE,
-                    ExpressionDef.constant(targetType), // Target class
-                    ExpressionDef.constant(beanField.getName()), // Field name,
-                    bean // Target instance
-                ).cast(propertyType);
-            } else {
-                return bean.cast(targetType).field(beanField).cast(propertyType);
-            }
+            return bean.cast(ClassTypeDef.of(beanField.getOwningType()))
+                .field(beanField)
+                .cast(TypeDef.of(beanField.getType()));
+        }
+
+        @NonNull
+        public FieldElement getField() {
+            return beanField;
+        }
+    }
+
+    /**
+     * Field get dispatch target.
+     */
+    @Internal
+    public static final class FieldGetReflectionDispatchTarget extends AbstractDispatchTarget {
+        @NonNull
+        final FieldElement beanField;
+
+        public FieldGetReflectionDispatchTarget(FieldElement beanField) {
+            this.beanField = beanField;
+        }
+
+        @Override
+        public boolean supportsDispatchOne() {
+            return true;
+        }
+
+        @Override
+        public boolean supportsDispatchMulti() {
+            return false;
+        }
+
+        @Override
+        public MethodElement getMethodElement() {
+            return null;
+        }
+
+        @Override
+        public TypedElement getDeclaringType() {
+            return null;
+        }
+
+        @Override
+        public ExpressionDef dispatchExpression(ExpressionDef bean) {
+            return TYPE_REFLECTION_UTILS.invokeStatic(
+                METHOD_GET_FIELD_VALUE,
+                ExpressionDef.constant(ClassTypeDef.of(beanField.getOwningType())), // Target class
+                ExpressionDef.constant(beanField.getName()), // Field name,
+                bean // Target instance
+            ).cast(TypeDef.of(beanField.getType()));
         }
 
         @NonNull
@@ -569,21 +619,58 @@ public final class DispatchWriter implements ClassOutputWriter {
 
         @Override
         public StatementDef dispatchOne(int caseValue, ExpressionDef caseExpression, ExpressionDef target, ExpressionDef value) {
-            final TypeDef propertyType = TypeDef.of(beanField.getType());
-            final ClassTypeDef targetType = ClassTypeDef.of(beanField.getOwningType());
-            if (beanField.isReflectionRequired()) {
-                return TYPE_REFLECTION_UTILS.invokeStatic(METHOD_SET_FIELD_VALUE,
-                    ExpressionDef.constant(targetType), // Target class
-                    ExpressionDef.constant(beanField.getName()), // Field name
-                    target, // Target instance
-                    value // Field value
-                ).after(ExpressionDef.nullValue().returning());
-            } else {
-                return target.cast(targetType)
-                    .field(beanField)
-                    .put(value.cast(propertyType))
-                    .after(ExpressionDef.nullValue().returning());
-            }
+            return target.cast(ClassTypeDef.of(beanField.getOwningType()))
+                .field(beanField)
+                .put(value.cast(TypeDef.of(beanField.getType())))
+                .after(ExpressionDef.nullValue().returning());
+        }
+
+        @NonNull
+        public FieldElement getField() {
+            return beanField;
+        }
+    }
+
+    /**
+     * Field set dispatch target.
+     */
+    @Internal
+    public static final class FieldSetReflectionDispatchTarget extends AbstractDispatchTarget {
+        @NonNull
+        final FieldElement beanField;
+
+        public FieldSetReflectionDispatchTarget(FieldElement beanField) {
+            this.beanField = beanField;
+        }
+
+        @Override
+        public boolean supportsDispatchOne() {
+            return true;
+        }
+
+        @Override
+        public boolean supportsDispatchMulti() {
+            return false;
+        }
+
+        @Override
+        public MethodElement getMethodElement() {
+            return null;
+        }
+
+        @Override
+        public TypedElement getDeclaringType() {
+            return null;
+        }
+
+        @Override
+        public StatementDef dispatchOne(int caseValue, ExpressionDef caseExpression, ExpressionDef target, ExpressionDef value) {
+            return TYPE_REFLECTION_UTILS.invokeStatic(METHOD_SET_FIELD_VALUE,
+                ExpressionDef.constant(ClassTypeDef.of(beanField.getOwningType())), // Target class
+                ExpressionDef.constant(beanField.getName()), // Field name
+                target, // Target instance
+                value // Field value
+            ).after(ExpressionDef.nullValue().returning());
         }
 
         @NonNull
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/ExecutableMethodsDefinitionWriter.java b/core-processor/src/main/java/io/micronaut/inject/writer/ExecutableMethodsDefinitionWriter.java
index df6f42f2df..d2bdc83f94 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/ExecutableMethodsDefinitionWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/ExecutableMethodsDefinitionWriter.java
@@ -120,7 +120,7 @@ public class ExecutableMethodsDefinitionWriter implements ClassOutputWriter {
         this.visitorContext = visitorContext;
         this.thisType = ClassTypeDef.of(className);
         this.beanDefinitionReferenceClassName = beanDefinitionReferenceClassName;
-        this.methodDispatchWriter = new DispatchWriter();
+        this.methodDispatchWriter = new DispatchWriter(className);
     }
 
     /**
