diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java b/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java
index c227edf640..ff73103afe 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/MemberElement.java
@@ -16,7 +16,6 @@
 package io.micronaut.inject.ast;
 
 import io.micronaut.core.annotation.AnnotationMetadata;
-import io.micronaut.core.annotation.NextMajorVersion;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.ReflectiveAccess;
 
@@ -108,7 +107,6 @@ public interface MemberElement extends Element {
      * @return Will return {@code true} if is accessible.
      * @since 4.3.0
      */
-    @NextMajorVersion("The ReflectiveAccess should not be checked here and accessibility should fail if ReflectiveAccess is not present")
     default boolean isAccessible(@NonNull ClassElement callingType, boolean allowReflection) {
         if (isPublic()) {
             return true;
diff --git a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
index 5b5e6476dd..c0e8d139e8 100644
--- a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/BeanIntrospectionWriter.java
@@ -222,7 +222,7 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
         this.beanType = ClassTypeDef.of(beanClassElement);
         this.introspectionName = computeShortIntrospectionName(targetPackage, name);
         this.introspectionTypeDef = ClassTypeDef.of(introspectionName);
-        this.dispatchWriter = new DispatchWriter(introspectionName);
+        this.dispatchWriter = new DispatchWriter();
         this.annotationMetadata = annotationMetadata.getTargetAnnotationMetadata();
         this.originatingElements = OriginatingElements.of(beanClassElement);
         evaluatedExpressionProcessor = new EvaluatedExpressionProcessor(visitorContext, beanClassElement);
@@ -253,7 +253,7 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
         this.beanType = ClassTypeDef.of(beanClassElement);
         this.introspectionName = computeIntrospectionName(targetPackage, className);
         this.introspectionTypeDef = ClassTypeDef.of(introspectionName);
-        this.dispatchWriter = new DispatchWriter(introspectionName);
+        this.dispatchWriter = new DispatchWriter();
         this.annotationMetadata = annotationMetadata.getTargetAnnotationMetadata();
         this.originatingElements = OriginatingElements.of(originatingElement);
         evaluatedExpressionProcessor = new EvaluatedExpressionProcessor(visitorContext, beanClassElement);
@@ -1120,10 +1120,6 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
                         FieldElement field = fieldGetDispatchTarget.getField();
                         propertyType = field.getGenericType();
                         member = field;
-                    } else if (dispatchTarget instanceof DispatchWriter.FieldGetReflectionDispatchTarget fieldGetDispatchTarget) {
-                        FieldElement field = fieldGetDispatchTarget.getField();
-                        propertyType = field.getGenericType();
-                        member = field;
                     } else {
                         throw new IllegalStateException();
                     }
@@ -1209,9 +1205,6 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
                             } else if (readDispatch instanceof DispatchWriter.FieldGetDispatchTarget fieldGetDispatchTarget) {
                                 FieldElement fieldElement = fieldGetDispatchTarget.getField();
                                 oldValueExp = prevBeanVar.field(fieldElement);
-                            } else if (readDispatch instanceof DispatchWriter.FieldGetReflectionDispatchTarget fieldGetDispatchTarget) {
-                                FieldElement fieldElement = fieldGetDispatchTarget.getField();
-                                oldValueExp = prevBeanVar.field(fieldElement);
                             } else {
                                 throw new IllegalStateException();
                             }
@@ -1230,11 +1223,6 @@ final class BeanIntrospectionWriter implements OriginatingElements, ClassOutputW
                                 statements.add(
                                         newBeanVar.field(fieldElement).assign(oldValueExp)
                                 );
-                            } else if (writeDispatch instanceof DispatchWriter.FieldSetReflectionDispatchTarget fieldSetDispatchTarget) {
-                                FieldElement fieldElement = fieldSetDispatchTarget.getField();
-                                statements.add(
-                                        newBeanVar.field(fieldElement).assign(oldValueExp)
-                                );
                             } else {
                                 throw new IllegalStateException();
                             }
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/DispatchWriter.java b/core-processor/src/main/java/io/micronaut/inject/writer/DispatchWriter.java
index 98d4245126..be230639f0 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/DispatchWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/DispatchWriter.java
@@ -96,12 +96,6 @@ public final class DispatchWriter implements ClassOutputWriter {
 
     private boolean hasInterceptedMethod;
 
-    private final String thisType;
-
-    public DispatchWriter(String thisType) {
-        this.thisType = thisType;
-    }
-
     /**
      * Adds new set field dispatch target.
      *
@@ -109,9 +103,6 @@ public final class DispatchWriter implements ClassOutputWriter {
      * @return the target index
      */
     public int addSetField(FieldElement beanField) {
-        if (beanField.isReflectionRequired(ClassElement.of(thisType))) {
-            return addDispatchTarget(new FieldSetReflectionDispatchTarget(beanField));
-        }
         return addDispatchTarget(new FieldSetDispatchTarget(beanField));
     }
 
@@ -122,9 +113,6 @@ public final class DispatchWriter implements ClassOutputWriter {
      * @return the target index
      */
     public int addGetField(FieldElement beanField) {
-        if (beanField.isReflectionRequired(ClassElement.of(thisType))) {
-            return addDispatchTarget(new FieldGetReflectionDispatchTarget(beanField));
-        }
         return addDispatchTarget(new FieldGetDispatchTarget(beanField));
     }
 
@@ -156,7 +144,7 @@ public final class DispatchWriter implements ClassOutputWriter {
         List<ParameterElement> argumentTypes = Arrays.asList(methodElement.getSuspendParameters());
         boolean isKotlinDefault = argumentTypes.stream().anyMatch(p -> p instanceof KotlinParameterElement kp && kp.hasDefault());
         ClassElement declaringClassType = (ClassElement) declaringType;
-        if (methodElement.isReflectionRequired(ClassElement.of(thisType))) {
+        if (methodElement.isReflectionRequired()) {
             if (isKotlinDefault) {
                 throw new ProcessingException(methodElement, "Kotlin default methods are not supported for reflection invocation");
             }
@@ -526,57 +514,19 @@ public final class DispatchWriter implements ClassOutputWriter {
 
         @Override
         public ExpressionDef dispatchExpression(ExpressionDef bean) {
-            return bean.cast(ClassTypeDef.of(beanField.getOwningType()))
-                .field(beanField)
-                .cast(TypeDef.of(beanField.getType()));
-        }
-
-        @NonNull
-        public FieldElement getField() {
-            return beanField;
-        }
-    }
-
-    /**
-     * Field get dispatch target.
-     */
-    @Internal
-    public static final class FieldGetReflectionDispatchTarget extends AbstractDispatchTarget {
-        @NonNull
-        final FieldElement beanField;
-
-        public FieldGetReflectionDispatchTarget(FieldElement beanField) {
-            this.beanField = beanField;
-        }
-
-        @Override
-        public boolean supportsDispatchOne() {
-            return true;
-        }
-
-        @Override
-        public boolean supportsDispatchMulti() {
-            return false;
-        }
-
-        @Override
-        public MethodElement getMethodElement() {
-            return null;
-        }
-
-        @Override
-        public TypedElement getDeclaringType() {
-            return null;
-        }
-
-        @Override
-        public ExpressionDef dispatchExpression(ExpressionDef bean) {
-            return TYPE_REFLECTION_UTILS.invokeStatic(
-                METHOD_GET_FIELD_VALUE,
-                ExpressionDef.constant(ClassTypeDef.of(beanField.getOwningType())), // Target class
-                ExpressionDef.constant(beanField.getName()), // Field name,
-                bean // Target instance
-            ).cast(TypeDef.of(beanField.getType()));
+            final TypeDef propertyType = TypeDef.of(beanField.getType());
+            final ClassTypeDef targetType = ClassTypeDef.of(beanField.getOwningType());
+
+            if (beanField.isReflectionRequired()) {
+                return TYPE_REFLECTION_UTILS.invokeStatic(
+                    METHOD_GET_FIELD_VALUE,
+                    ExpressionDef.constant(targetType), // Target class
+                    ExpressionDef.constant(beanField.getName()), // Field name,
+                    bean // Target instance
+                ).cast(propertyType);
+            } else {
+                return bean.cast(targetType).field(beanField).cast(propertyType);
+            }
         }
 
         @NonNull
@@ -619,58 +569,21 @@ public final class DispatchWriter implements ClassOutputWriter {
 
         @Override
         public StatementDef dispatchOne(int caseValue, ExpressionDef caseExpression, ExpressionDef target, ExpressionDef value) {
-            return target.cast(ClassTypeDef.of(beanField.getOwningType()))
-                .field(beanField)
-                .put(value.cast(TypeDef.of(beanField.getType())))
-                .after(ExpressionDef.nullValue().returning());
-        }
-
-        @NonNull
-        public FieldElement getField() {
-            return beanField;
-        }
-    }
-
-    /**
-     * Field set dispatch target.
-     */
-    @Internal
-    public static final class FieldSetReflectionDispatchTarget extends AbstractDispatchTarget {
-        @NonNull
-        final FieldElement beanField;
-
-        public FieldSetReflectionDispatchTarget(FieldElement beanField) {
-            this.beanField = beanField;
-        }
-
-        @Override
-        public boolean supportsDispatchOne() {
-            return true;
-        }
-
-        @Override
-        public boolean supportsDispatchMulti() {
-            return false;
-        }
-
-        @Override
-        public MethodElement getMethodElement() {
-            return null;
-        }
-
-        @Override
-        public TypedElement getDeclaringType() {
-            return null;
-        }
-
-        @Override
-        public StatementDef dispatchOne(int caseValue, ExpressionDef caseExpression, ExpressionDef target, ExpressionDef value) {
-            return TYPE_REFLECTION_UTILS.invokeStatic(METHOD_SET_FIELD_VALUE,
-                ExpressionDef.constant(ClassTypeDef.of(beanField.getOwningType())), // Target class
-                ExpressionDef.constant(beanField.getName()), // Field name
-                target, // Target instance
-                value // Field value
-            ).after(ExpressionDef.nullValue().returning());
+            final TypeDef propertyType = TypeDef.of(beanField.getType());
+            final ClassTypeDef targetType = ClassTypeDef.of(beanField.getOwningType());
+            if (beanField.isReflectionRequired()) {
+                return TYPE_REFLECTION_UTILS.invokeStatic(METHOD_SET_FIELD_VALUE,
+                    ExpressionDef.constant(targetType), // Target class
+                    ExpressionDef.constant(beanField.getName()), // Field name
+                    target, // Target instance
+                    value // Field value
+                ).after(ExpressionDef.nullValue().returning());
+            } else {
+                return target.cast(targetType)
+                    .field(beanField)
+                    .put(value.cast(propertyType))
+                    .after(ExpressionDef.nullValue().returning());
+            }
         }
 
         @NonNull
diff --git a/core-processor/src/main/java/io/micronaut/inject/writer/ExecutableMethodsDefinitionWriter.java b/core-processor/src/main/java/io/micronaut/inject/writer/ExecutableMethodsDefinitionWriter.java
index d2bdc83f94..df6f42f2df 100644
--- a/core-processor/src/main/java/io/micronaut/inject/writer/ExecutableMethodsDefinitionWriter.java
+++ b/core-processor/src/main/java/io/micronaut/inject/writer/ExecutableMethodsDefinitionWriter.java
@@ -120,7 +120,7 @@ public class ExecutableMethodsDefinitionWriter implements ClassOutputWriter {
         this.visitorContext = visitorContext;
         this.thisType = ClassTypeDef.of(className);
         this.beanDefinitionReferenceClassName = beanDefinitionReferenceClassName;
-        this.methodDispatchWriter = new DispatchWriter(className);
+        this.methodDispatchWriter = new DispatchWriter();
     }
 
     /**
diff --git a/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/BeanIntrospectionSpec.groovy b/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/BeanIntrospectionSpec.groovy
index 4eb7c72663..5041ac0717 100644
--- a/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/BeanIntrospectionSpec.groovy
+++ b/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/BeanIntrospectionSpec.groovy
@@ -12,7 +12,6 @@ import io.micronaut.context.annotation.Executable
 import io.micronaut.context.annotation.Replaces
 import io.micronaut.context.visitor.ConfigurationReaderVisitor
 import io.micronaut.core.annotation.Introspected
-import io.micronaut.core.annotation.NextMajorVersion
 import io.micronaut.core.annotation.NonNull
 import io.micronaut.core.beans.BeanIntrospection
 import io.micronaut.core.beans.BeanIntrospectionReference
@@ -31,7 +30,6 @@ import io.micronaut.inject.ExecutableMethod
 import io.micronaut.inject.annotation.EvaluatedAnnotationMetadata
 import io.micronaut.inject.beans.visitor.IntrospectedTypeElementVisitor
 import io.micronaut.inject.visitor.TypeElementVisitor
-import io.micronaut.inject.visitor.beans.outer.MuxedEvent2
 import io.micronaut.jackson.modules.BeanIntrospectionModule
 import io.micronaut.json.JsonMapper
 import io.micronaut.validation.visitor.ValidationVisitor
@@ -55,47 +53,6 @@ import java.util.stream.IntStream
 
 class BeanIntrospectionSpec extends AbstractTypeElementSpec {
 
-    void "test import field introspection"() {
-        when:
-        def introspection = buildBeanIntrospection('test.$io_micronaut_inject_visitor_beans_MuxedEvent1', '''
-package test;
-
-import io.micronaut.core.annotation.Introspected;
-
-@Introspected(classes = io.micronaut.inject.visitor.beans.MuxedEvent1.class, accessKind = Introspected.AccessKind.FIELD, visibility = Introspected.Visibility.ANY)
-class Test {
-}
-
-
-    ''' )
-
-        then:
-        introspection != null
-        introspection.getBeanProperties().size() == 2
-        introspection.getProperty("content").get().get(new MuxedEvent1("abc", "xyz")) == "xyz"
-    }
-
-    @NextMajorVersion("This test should fail and require ReflectiveAccess on fields/class or there should be an option on the introspected to use reflective access by default by annotating the introspected type")
-    void "test import field introspection reflection"() {
-        when:
-        def introspection = buildBeanIntrospection('test.$io_micronaut_inject_visitor_beans_outer_MuxedEvent2', '''
-package test;
-
-import io.micronaut.core.annotation.Introspected;
-
-@Introspected(classes = io.micronaut.inject.visitor.beans.outer.MuxedEvent2.class, accessKind = Introspected.AccessKind.FIELD, visibility = Introspected.Visibility.ANY)
-class Test {
-}
-
-
-    ''' )
-
-        then:
-        introspection != null
-        introspection.getBeanProperties().size() == 2
-        introspection.getProperty("content").get().get(new MuxedEvent2("abc", "xyz")) == "xyz"
-    }
-
     void "test inner introspection"() {
         when:
         def introspection = buildBeanIntrospection('test.Test$Foo', '''
diff --git a/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/MuxedEvent1.java b/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/MuxedEvent1.java
deleted file mode 100644
index f7b62615a9..0000000000
--- a/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/MuxedEvent1.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package io.micronaut.inject.visitor.beans;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
-
-public class MuxedEvent1 {
-    @JsonProperty
-    String compartment;
-    @JsonProperty
-    String content;
-
-    public MuxedEvent1(String compartment, String content) {
-        this.compartment = compartment;
-        this.content = content;
-    }
-
-    public MuxedEvent1() {
-    }
-}
diff --git a/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/outer/MuxedEvent2.java b/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/outer/MuxedEvent2.java
deleted file mode 100644
index f53e295356..0000000000
--- a/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/outer/MuxedEvent2.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package io.micronaut.inject.visitor.beans.outer;
-
-public class MuxedEvent2 {
-    String compartment;
-    String content;
-
-    public MuxedEvent2(String compartment, String content) {
-        this.compartment = compartment;
-        this.content = content;
-    }
-
-    public MuxedEvent2() {
-    }
-}
