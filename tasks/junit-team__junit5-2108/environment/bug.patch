diff --git a/buildSrc/build.gradle.kts b/buildSrc/build.gradle.kts
index d498b5176..f2b41e765 100644
--- a/buildSrc/build.gradle.kts
+++ b/buildSrc/build.gradle.kts
@@ -10,4 +10,5 @@ repositories {
 dependencies {
 	implementation(kotlin("gradle-plugin"))
 	implementation("de.marcphilipp.gradle:nexus-publish-plugin:0.4.0")
+	implementation("biz.aQute.bnd:biz.aQute.bnd.gradle:4.3.1")
 }
diff --git a/buildSrc/src/main/kotlin/APIGuardianAnnotations.kt b/buildSrc/src/main/kotlin/APIGuardianAnnotations.kt
new file mode 100644
index 000000000..24b08fb22
--- /dev/null
+++ b/buildSrc/src/main/kotlin/APIGuardianAnnotations.kt
@@ -0,0 +1,91 @@
+import aQute.bnd.header.Attrs
+import aQute.bnd.header.OSGiHeader
+import aQute.bnd.header.Parameters
+import aQute.bnd.osgi.Analyzer
+import aQute.bnd.osgi.Clazz
+import aQute.bnd.osgi.Descriptors.TypeRef
+import aQute.bnd.osgi.Instruction
+import aQute.bnd.osgi.Instructions
+import aQute.bnd.service.AnalyzerPlugin
+
+/*
+This is a plugin for bnd which helps analyze the usages of
+org.apiguardian.api.API found in the project bytecode. You can read more
+about this here: https://bnd.bndtools.org/instructions/export-apiguardian.html
+
+Once the next version of bnd releases (likely 5.0.0) this plugin will be
+included in bnd and this class can be removed.
+
+Please ping @rotty3000 to cleanup when that happens.
+*/
+open class APIGuardianAnnotations : AnalyzerPlugin {
+
+	companion object {
+		const val API_ANNOTATION: String = "org/apiguardian/api/API"
+		const val INTERNAL_STATUS: String	= "INTERNAL"
+		const val STATUS_PROPERTY: String	= "status"
+		const val EXPORT_APIGUARDIAN: String = "-export-apiguardian"
+		const val MANDATORY_DIRECTIVE: String = "mandatory:"
+		const val NO_IMPORT_DIRECTIVE: String = "-noimport:"
+	}
+
+	internal enum class Status {
+		INTERNAL,
+		DEPRECATED,
+		EXPERIMENTAL,
+		MAINTAINED,
+		STABLE
+	}
+
+	@Throws(Exception::class)
+	override fun analyzeJar(analyzer:Analyzer):Boolean {
+		// Opt-in is required.
+		val header = OSGiHeader.parseHeader(analyzer.getProperty(EXPORT_APIGUARDIAN))
+		if (header.isEmpty()) return false
+		val exportPackages = analyzer.getExportPackage()
+		val instructions = Instructions(header)
+		val apiGuardianPackages = Parameters(false)
+		for ((_, c:Clazz) in analyzer.getClassspace()) {
+			if (c.isModule() || c.isInnerClass() || c.isSynthetic()) continue
+			for ((k:Instruction, v:Attrs) in instructions) {
+				if (k.matches(c.getFQN())) {
+					if (k.isNegated()) break
+
+					c.annotations(API_ANNOTATION)
+						.map({ ann-> Status.valueOf(ann.get(STATUS_PROPERTY)) })
+						.max(Status::compareTo)
+						.ifPresent({ status->
+							val attrs = apiGuardianPackages.computeIfAbsent(
+								c.getClassName().getPackageRef().getFQN(), { _->
+									Attrs(v)
+								}
+							)
+
+							attrs.compute(
+								STATUS_PROPERTY, { _, v->
+									if ((v == null))
+										status.name
+									else
+										if ((Status.valueOf(v).compareTo(status) > 0))
+											v
+										else
+											status.name
+								}
+							)
+						}
+					)
+				}
+			}
+		}
+
+		apiGuardianPackages.values.stream()
+			.filter({ a-> Status.valueOf(a.get(STATUS_PROPERTY)) === Status.INTERNAL })
+			.forEach({ a->
+				a.put(MANDATORY_DIRECTIVE, STATUS_PROPERTY)
+				a.put(NO_IMPORT_DIRECTIVE, "true")
+			})
+		exportPackages.mergeWith(apiGuardianPackages, false)
+		analyzer.setExportPackage(exportPackages.toString())
+		return false
+	}
+}
diff --git a/buildSrc/src/main/kotlin/Versions.kt b/buildSrc/src/main/kotlin/Versions.kt
index bca76deb0..5ef6f6f98 100644
--- a/buildSrc/src/main/kotlin/Versions.kt
+++ b/buildSrc/src/main/kotlin/Versions.kt
@@ -34,5 +34,6 @@ object Versions {
     val jmh = "1.21"
     val ktlint = "0.35.0"
     val surefire = "2.22.2"
+    var bnd = "4.3.1"
 
 }
diff --git a/buildSrc/src/main/kotlin/java-library-conventions.gradle.kts b/buildSrc/src/main/kotlin/java-library-conventions.gradle.kts
index bc74d47e1..b5f41ad98 100644
--- a/buildSrc/src/main/kotlin/java-library-conventions.gradle.kts
+++ b/buildSrc/src/main/kotlin/java-library-conventions.gradle.kts
@@ -1,3 +1,7 @@
+import aQute.bnd.gradle.BundleTaskConvention
+import aQute.bnd.gradle.FileSetRepositoryConvention
+import aQute.bnd.gradle.Resolve
+
 plugins {
 	`java-library`
 	eclipse
@@ -139,6 +143,105 @@ if (project in mavenizedProjects) {
 		}
 	}
 
+	// This task enances `jar` and `shadowJar` tasks with the bnd
+	// `BundleTaskConvention` convention which allows for generating OSGi
+	// metadata into the jar
+	tasks.withType<Jar>().matching {
+		task: Jar -> task.name == "jar" || task.name == "shadowJar"
+	}.configureEach {
+		val btc = BundleTaskConvention(this)
+
+		// These are bnd instructions necessary for generating OSGi metadata.
+		// We've generalized these so that they are widely applicable limiting
+		// module configurations to special cases.
+		btc.setBnd("""
+			# These are the general rules for package imports.
+			Import-Package: \
+				!org.apiguardian.api,\
+				org.junit.platform.commons.logging;status=INTERNAL,\
+				kotlin.*;resolution:="optional",\
+				*
+
+			# This tells bnd not to complain if a module doesn't actually import
+			# the kotlin packages, but enough modules do to make it a default.
+			-fixupmessages.kotlin.import: "Unused Import-Package instructions: \\[kotlin.*\\]";is:=ignore
+
+			# This tells bnd to ignore classes it files in `META-INF/versions/`
+			# because bnd doesn't yet support multi-release jars.
+			-fixupmessages.wrong.dir: "Classes found in the wrong directory: \\{META-INF/versions/...";is:=ignore
+
+			# Don't scan for Class.forName package imports.
+			# See https://bnd.bndtools.org/instructions/noclassforname.html
+			-noclassforname: true
+
+			# Don't add all the extra headers bnd normally adds.
+			# See https://bnd.bndtools.org/instructions/noextraheaders.html
+			-noextraheaders: true
+
+			# Don't add the Private-Package header.
+			# See https://bnd.bndtools.org/instructions/removeheaders.html
+			-removeheaders: Private-Package
+
+			# Add the custom buildSrc/src/main/kotlin/APIGuardianAnnotations.kt
+			# plugin to bnd
+			-plugin.apiguardian.annotations: ${APIGuardianAnnotations::class.qualifiedName}
+
+			# Instruct the APIGuardianAnnotations how to operate.
+			# See https://bnd.bndtools.org/instructions/export-apiguardian.html
+			-export-apiguardian: *;version=${project.version}
+		""")
+
+		// Add the convention to the jar task
+		convention.plugins.put("bundle", btc)
+
+		doLast {
+			// Do the actual work putting OSGi stuff in the jar.
+			btc.buildBundle()
+		}
+
+		finalizedBy("verifyOSGi")
+	}
+
+	// Bnd's Resolve task uses a properties file for it's configuration. This
+	// task writes out the properties necessary for it to verify the OSGi
+	// metadata.
+	tasks.register<WriteProperties>("verifyOSGiProperties") {
+		setOutputFile("${buildDir}/verifyOSGiProperties.bndrun")
+		property("-standalone", "true")
+		property("-runee", "JavaSE-${Versions.jvmTarget}")
+		property("-runrequires", "osgi.identity;filter:='(osgi.identity=${project.name})'")
+		property("-runsystempackages", "jdk.internal.misc,sun.misc")
+	}
+
+	// Bnd's Resolve task is what verifies that a jar can be used in OSGi and
+	// that it's metadata is valid. If the metadata is invalid this task will
+	// fail.
+	tasks.register<Resolve>("verifyOSGi") {
+		dependsOn("verifyOSGiProperties")
+		setBndrun("${buildDir}/verifyOSGiProperties.bndrun")
+		setReportOptional(false)
+		withConvention(FileSetRepositoryConvention::class) {
+
+			// By default bnd will use jars found in:
+			// 1. project.sourceSets.main.runtimeClasspath
+			// 2. project.configurations.archives.artifacts.files
+			// to validate the metadata.
+			// This adds jars defined in `testRuntimeClasses` also so that bnd
+			// can use them to validate the metadata without causing those to
+			// end up in the dependencies of those projects.
+			bundles(sourceSets["test"].runtimeClasspath)
+		}
+	}
+
+	// The ${project.description}, for some odd reason, is only available
+	// afterEvaluate.
+	afterEvaluate {
+		tasks.withType<Jar>().configureEach {
+			convention.findPlugin(BundleTaskConvention::class.java)
+				?.bnd("Bundle-Name: ${project.description}")
+		}
+	}
+
 } else {
 	tasks {
 		jar {
diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index f5185bbba..cd4857eac 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -89,6 +89,7 @@ endif::[]
 :TestExecutionExceptionHandler:              {javadoc-root}/org/junit/jupiter/api/extension/TestExecutionExceptionHandler.html[TestExecutionExceptionHandler]
 :TestInstanceFactory:                        {javadoc-root}/org/junit/jupiter/api/extension/TestInstanceFactory.html[TestInstanceFactory]
 :TestInstancePostProcessor:                  {javadoc-root}/org/junit/jupiter/api/extension/TestInstancePostProcessor.html[TestInstancePostProcessor]
+:TestInstancePreDestroyCallback:             {javadoc-root}/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.html[TestInstancePreDestroyCallback]
 :TestTemplateInvocationContext:              {javadoc-root}/org/junit/jupiter/api/extension/TestTemplateInvocationContext.html[TestTemplateInvocationContext]
 :TestTemplateInvocationContextProvider:      {javadoc-root}/org/junit/jupiter/api/extension/TestTemplateInvocationContextProvider.html[TestTemplateInvocationContextProvider]
 :TestWatcher:                                {javadoc-root}/org/junit/jupiter/api/extension/TestWatcher.html[TestWatcher]
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
index ac99c1845..df4bc0da9 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
@@ -24,6 +24,7 @@ on GitHub.
 
 ==== New Features and Improvements
 
+* Provide JARs with OSGi metadata.
 * `TestExecutionSummary.Failure` is now serializable.
 
 
@@ -40,15 +41,17 @@ on GitHub.
 
 ==== New Features and Improvements
 
+* Provide JARs with OSGi metadata.
 * `@EnabledIfEnvironmentVariable`, `@DisabledIfEnvironmentVariable`,
   `@EnabledIfSystemProperty`, and `@DisabledIfSystemProperty` may now be used as
   _repeatable_ annotations. In other words, it is now possible to declare each of those
   annotations multiple times on a test interface, test class, or test method.
+* New `TestInstancePreDestroyCallback` interface that defines the API for `Extension`
+  that wish to process test instances *after* they have been used in tests and *before*
+  they are destroyed.
 * `InvocationInterceptor` extensions may now explicitly `skip()` an intercepted
   invocation. This allows executing it by other means, e.g. in a forked JVM.
-* Parameter names are now included in the default display name of a `@ParameterizedTest`
-  invocation (if they are present in the bytecode). The `{argumentsWithNames}` pattern
-  can also be used in custom names.
+
 
 [[release-notes-5.6.0-M2️-junit-vintage]]
 === JUnit Vintage
@@ -63,4 +66,4 @@ on GitHub.
 
 ==== New Features and Improvements
 
-* ❓
+* Provide JARs with OSGi metadata.
diff --git a/documentation/src/docs/asciidoc/user-guide/extensions.adoc b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
index b0e00a11d..2df5c2cee 100644
--- a/documentation/src/docs/asciidoc/user-guide/extensions.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
@@ -122,9 +122,9 @@ If a `@RegisterExtension` field is `static`, the extension will be registered af
 extensions that are registered at the class level via `@ExtendWith`. Such _static
 extensions_ are not limited in which extension APIs they can implement. Extensions
 registered via static fields may therefore implement class-level and instance-level
-extension APIs such as `BeforeAllCallback`, `AfterAllCallback`, and
-`TestInstancePostProcessor` as well as method-level extension APIs such as
-`BeforeEachCallback`, etc.
+extension APIs such as `BeforeAllCallback`, `AfterAllCallback`,
+`TestInstancePostProcessor`, and `TestInstancePreDestroyCallback` as well as method-level
+extension APIs such as `BeforeEachCallback`, etc.
 
 In the following example, the `server` field in the test class is initialized
 programmatically by using a builder pattern supported by the `WebServerExtension`. The
@@ -324,6 +324,15 @@ initialization methods on the test instance, etc.
 For a concrete example, consult the source code for the `{MockitoExtension}` and the
 `{SpringExtension}`.
 
+[[extensions-test-instance-pre-destroy-callback]]
+=== Test Instance Pre-destroy Callback
+
+`{TestInstancePreDestroyCallback}` defines the API for `Extensions` that wish to process
+test instances _after_ they have been used in tests and _before_ they are destroyed.
+
+Common use cases include cleaning dependencies that have been injected into the
+test instance, invoking custom de-initialization methods on the test instance, etc.
+
 [[extensions-parameter-resolution]]
 === Parameter Resolution
 
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 34b98e83e..5b1294f9e 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -924,9 +924,9 @@ following.
 
 ....
 palindromes(String) ✔
-├─ [1] candidate=racecar ✔
-├─ [2] candidate=radar ✔
-└─ [3] candidate=able was I ere I saw elba ✔
+├─ [1] racecar ✔
+├─ [2] radar ✔
+└─ [3] able was I ere I saw elba ✔
 ....
 
 WARNING: Parameterized tests are currently an _experimental_ feature. Consult the table
@@ -1452,10 +1452,6 @@ include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_w
 
 By default, the display name of a parameterized test invocation contains the invocation
 index and the `String` representation of all arguments for that specific invocation.
-Each of them is preceded by the parameter name (unless the argument is only available via
-an `ArgumentsAccessor` or `ArgumentAggregator`), if present in the bytecode (for Java,
-test code must be compiled with the `-parameters` compiler flag).
-
 However, you can customize invocation display names via the `name` attribute of the
 `@ParameterizedTest` annotation like in the following example.
 
@@ -1469,22 +1465,20 @@ the following.
 
 ....
 Display name of container ✔
-├─ 1 ==> the rank of 'apple' is 1 ✔
-├─ 2 ==> the rank of 'banana' is 2 ✔
-└─ 3 ==> the rank of 'lemon, lime' is 3 ✔
+├─ 1 ==> fruit='apple', rank=1 ✔
+├─ 2 ==> fruit='banana', rank=2 ✔
+└─ 3 ==> fruit='lemon, lime', rank=3 ✔
 ....
 
 The following placeholders are supported within custom display names.
 
 [cols="20,80"]
 |===
-| Placeholder              | Description
+| Placeholder       | Description
 
-| `{displayName}`          | the display name of the method
-| `{index}`                | the current invocation index (1-based)
-| `{arguments}`            | the complete, comma-separated arguments list
-| `{argumentsWithNames}`   | the complete, comma-separated arguments list with parameter names
-| `{0}`, `{1}`, ...        | an individual argument
+| `{index}`         | the current invocation index (1-based)
+| `{arguments}`     | the complete, comma-separated arguments list
+| `{0}`, `{1}`, ... | an individual argument
 |===
 
 
diff --git a/documentation/src/test/java/example/ParameterizedTestDemo.java b/documentation/src/test/java/example/ParameterizedTestDemo.java
index ca73fd043..71abceb5a 100644
--- a/documentation/src/test/java/example/ParameterizedTestDemo.java
+++ b/documentation/src/test/java/example/ParameterizedTestDemo.java
@@ -411,7 +411,7 @@ class ParameterizedTestDemo {
 
 	// tag::custom_display_names[]
 	@DisplayName("Display name of container")
-	@ParameterizedTest(name = "{index} ==> the rank of ''{0}'' is {1}")
+	@ParameterizedTest(name = "{index} ==> fruit=''{0}'', rank={1}")
 	@CsvSource({ "apple, 1", "banana, 2", "'lemon, lime', 3" })
 	void testWithCustomDisplayNames(String fruit, int rank) {
 	}
diff --git a/gradle.properties b/gradle.properties
index 46cb107e5..eff74e582 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -17,3 +17,8 @@ org.gradle.jvmargs=-Xmx1g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryEr
 org.gradle.caching=true
 org.gradle.parallel=true
 
+# Use this flag so that when compiling against project dependencies
+# the jar is created and used instead of using src/main/classes.
+#
+# See https://docs.gradle.org/current/userguide/java_library_plugin.html#sub:java_library_known_issues_windows_performance
+systemProp.org.gradle.java.compile-classpath-packaging=true
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index 6ce793f21..94920145f 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-6.0-bin.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-6.0.1-bin.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtendWith.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtendWith.java
index bfa0f289e..6799db47d 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtendWith.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtendWith.java
@@ -39,6 +39,7 @@ import org.apiguardian.api.API;
  * <li>{@link AfterTestExecutionCallback}</li>
  * <li>{@link TestInstanceFactory}</li>
  * <li>{@link TestInstancePostProcessor}</li>
+ * <li>{@link TestInstancePreDestroyCallback}</li>
  * <li>{@link ParameterResolver}</li>
  * <li>{@link TestExecutionExceptionHandler}</li>
  * <li>{@link TestTemplateInvocationContextProvider}</li>
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/InvocationInterceptor.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/InvocationInterceptor.java
index 7bde15e5c..b2bbbc80b 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/InvocationInterceptor.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/InvocationInterceptor.java
@@ -54,6 +54,9 @@ public interface InvocationInterceptor extends Extension {
 	/**
 	 * Intercept the invocation of a test class constructor.
 	 *
+	 * <p>Note that the test class may <em>not</em> have been initialized
+	 * (static initialization) when this method is invoked.
+	 *
 	 * @param invocation the invocation that is being intercepted; never
 	 * {@code null}
 	 * @param invocationContext the context of the invocation that is being
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterResolver.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterResolver.java
index b006d2bac..109dfcdf0 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterResolver.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterResolver.java
@@ -41,6 +41,7 @@ import org.apiguardian.api.API;
  * @see ParameterContext
  * @see TestInstanceFactory
  * @see TestInstancePostProcessor
+ * @see TestInstancePreDestroyCallback
  */
 @API(status = STABLE, since = "5.0")
 public interface ParameterResolver extends Extension {
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/RegisterExtension.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/RegisterExtension.java
index 80ff02c45..f9ade6a23 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/RegisterExtension.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/RegisterExtension.java
@@ -41,8 +41,9 @@ import org.apiguardian.api.API;
  * which extension APIs they can implement. Extensions registered via static
  * fields may therefore implement class-level and instance-level extension APIs
  * such as {@link BeforeAllCallback}, {@link AfterAllCallback},
- * {@link TestInstanceFactory}, and {@link TestInstancePostProcessor} as well as
- * method-level extension APIs such as {@link BeforeEachCallback}, etc.
+ * {@link TestInstanceFactory}, {@link TestInstancePostProcessor} and
+ * {@link TestInstancePreDestroyCallback} as well as method-level extension APIs
+ * such as {@link BeforeEachCallback}, etc.
  *
  * <h3>Instance Fields</h3>
  *
@@ -121,6 +122,7 @@ import org.apiguardian.api.API;
  * <li>{@link AfterTestExecutionCallback}</li>
  * <li>{@link TestInstanceFactory}</li>
  * <li>{@link TestInstancePostProcessor}</li>
+ * <li>{@link TestInstancePreDestroyCallback}</li>
  * <li>{@link ParameterResolver}</li>
  * <li>{@link TestExecutionExceptionHandler}</li>
  * <li>{@link TestTemplateInvocationContextProvider}</li>
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstanceFactory.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstanceFactory.java
index c9d1c3612..038344c7e 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstanceFactory.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstanceFactory.java
@@ -46,6 +46,7 @@ import org.apiguardian.api.API;
  * @see #createTestInstance(TestInstanceFactoryContext, ExtensionContext)
  * @see TestInstanceFactoryContext
  * @see TestInstancePostProcessor
+ * @see TestInstancePreDestroyCallback
  * @see ParameterResolver
  */
 @FunctionalInterface
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java
new file mode 100644
index 000000000..c3b987751
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import org.apiguardian.api.API;
+
+/**
+ * {@code TestInstancePreDestroyCallback} defines the API for {@link Extension
+ * Extensions} that wish to process test instances <em>after</em> they have been
+ * used in tests and <em>before</em> they are destroyed.
+ *
+ * <p>Common use cases include cleaning dependencies that have been injected
+ * into the test instance, invoking custom de-initialization methods on the test
+ * instance, etc.
+ *
+ * <p>Extensions that implement {@code TestInstancePreDestroyCallback} must be
+ * registered at the class level.
+ *
+ * <h3>Constructor Requirements</h3>
+ *
+ * <p>Consult the documentation in {@link Extension} for details on constructor
+ * requirements.
+ *
+ * @since 5.6
+ * @see #preDestroyTestInstance(ExtensionContext)
+ * @see TestInstanceFactory
+ * @see ParameterResolver
+ */
+@FunctionalInterface
+@API(status = EXPERIMENTAL, since = "5.6")
+public interface TestInstancePreDestroyCallback extends Extension {
+
+	/**
+	 * Callback for processing a test instance before it is destroyed.
+	 *
+	 * @param context the current extension context; never {@code null}
+	 * @see ExtensionContext#getTestInstance()
+	 * @see ExtensionContext#getRequiredTestInstance()
+	 */
+	void preDestroyTestInstance(ExtensionContext context) throws Exception;
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
index b123ca262..e61a9f586 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
@@ -42,6 +42,7 @@ import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler;
 import org.junit.jupiter.api.extension.TestInstanceFactory;
 import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestInstantiationException;
 import org.junit.jupiter.api.function.Executable;
@@ -175,8 +176,7 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 	public JupiterEngineExecutionContext before(JupiterEngineExecutionContext context) {
 		ThrowableCollector throwableCollector = context.getThrowableCollector();
 
-		Lifecycle lifecycle = context.getExtensionContext().getTestInstanceLifecycle().orElse(Lifecycle.PER_METHOD);
-		if (lifecycle == Lifecycle.PER_CLASS) {
+		if (isPerClassLifecycle(context)) {
 			// Eagerly load test instance for BeforeAllCallbacks, if necessary,
 			// and store the instance in the ExtensionContext.
 			ClassExtensionContext extensionContext = (ClassExtensionContext) context.getExtensionContext();
@@ -213,6 +213,10 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 			invokeAfterAllCallbacks(context);
 		}
 
+		if (isPerClassLifecycle(context)) {
+			invokeTestInstancePreDestroyCallback(context);
+		}
+
 		// If the previous Throwable was not null when this method was called,
 		// that means an exception was already thrown either before or during
 		// the execution of this Node. If an exception was already thrown, any
@@ -421,6 +425,19 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 				.forEach(extension -> throwableCollector.execute(() -> extension.afterAll(extensionContext)));
 	}
 
+	private void invokeTestInstancePreDestroyCallback(JupiterEngineExecutionContext context) {
+		ExtensionContext extensionContext = context.getExtensionContext();
+		ThrowableCollector throwableCollector = context.getThrowableCollector();
+
+		context.getExtensionRegistry().stream(TestInstancePreDestroyCallback.class).forEach(
+			extension -> throwableCollector.execute(() -> extension.preDestroyTestInstance(extensionContext)));
+	}
+
+	private boolean isPerClassLifecycle(JupiterEngineExecutionContext context) {
+		return context.getExtensionContext().getTestInstanceLifecycle().orElse(
+			Lifecycle.PER_METHOD) == Lifecycle.PER_CLASS;
+	}
+
 	private void registerBeforeEachMethodAdapters(ExtensionRegistrar registrar) {
 		List<Method> beforeEachMethods = findBeforeEachMethods(this.testClass);
 		registerMethodsAsExtensions(beforeEachMethods, registrar, this::synthesizeBeforeEachMethodAdapter);
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
index 3a0dacc2f..54f68e282 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
@@ -20,6 +20,7 @@ import java.util.Optional;
 import java.util.function.Consumer;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.TestInstance;
 import org.junit.jupiter.api.extension.AfterEachCallback;
 import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
 import org.junit.jupiter.api.extension.BeforeEachCallback;
@@ -29,6 +30,7 @@ import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler;
 import org.junit.jupiter.api.extension.TestExecutionExceptionHandler;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestWatcher;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
@@ -139,6 +141,7 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 				invokeAfterEachMethods(context);
 			}
 		invokeAfterEachCallbacks(context);
+		invokeTestInstancePreDestroyCallback(context);
 		// @formatter:on
 
 		throwableCollector.assertEmpty();
@@ -245,6 +248,15 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 			(callback, extensionContext) -> callback.afterEach(extensionContext));
 	}
 
+	private void invokeTestInstancePreDestroyCallback(JupiterEngineExecutionContext context) {
+		context.getExtensionContext().getTestInstanceLifecycle().ifPresent(lifecycle -> {
+			if (TestInstance.Lifecycle.PER_METHOD == lifecycle) {
+				invokeAllAfterMethodsOrCallbacks(TestInstancePreDestroyCallback.class, context,
+					TestInstancePreDestroyCallback::preDestroyTestInstance);
+			}
+		});
+	}
+
 	private <T extends Extension> void invokeAllAfterMethodsOrCallbacks(Class<T> type,
 			JupiterEngineExecutionContext context, CallbackInvoker<T> callbackInvoker) {
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
index 8e9592aea..52db4a55f 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
@@ -46,6 +46,7 @@ public class KitchenSinkExtension implements
 	// Dependency Injection
 	TestInstanceFactory,
 	TestInstancePostProcessor,
+	TestInstancePreDestroyCallback,
 	ParameterResolver,
 
 	// Conditional Test Execution
@@ -120,6 +121,10 @@ public class KitchenSinkExtension implements
 	public void postProcessTestInstance(Object testInstance, ExtensionContext context) {
 	}
 
+	@Override
+	public void preDestroyTestInstance(ExtensionContext context) {
+	}
+
 	@Override
 	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
 		return false;
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java
index ffb3f8df7..da03cca3d 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java
@@ -51,6 +51,7 @@ import org.junit.jupiter.api.extension.ExecutionCondition;
 import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;
@@ -101,6 +102,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 
 		String containerExecutionConditionKey = executionConditionKey(testClass, null);
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String testTemplateKey = testTemplateKey(testClass, "singletonTest");
@@ -119,6 +121,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				containerExecutionConditionKey,
 				beforeAllCallbackKey,
 				postProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
 				testTemplateKey,
 				testExecutionConditionKey1,
 				beforeEachCallbackKey1,
@@ -153,6 +156,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(testInstances, instanceMap.get(testExecutionConditionKey3));
 		assertSame(testInstances.getInnermostInstance(),
 			instanceMap.get(postProcessTestInstanceKey).getInnermostInstance());
+		assertSame(testInstances.getInnermostInstance(),
+			instanceMap.get(preDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		assertThat(lifecyclesMap.keySet()).containsExactly(testClass);
 		assertThat(lifecyclesMap.get(testClass).stream()).allMatch(Lifecycle.PER_METHOD::equals);
@@ -180,6 +185,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		String containerExecutionConditionKey = executionConditionKey(testClass, null);
 		String testTemplateKey = testTemplateKey(testClass, "singletonTest");
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String testExecutionConditionKey1 = executionConditionKey(testClass, testsInvoked.get(0));
@@ -195,6 +201,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		// @formatter:off
 		assertThat(instanceMap.keySet()).containsExactlyInAnyOrder(
 				postProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
 				containerExecutionConditionKey,
 				beforeAllCallbackKey,
 				testTemplateKey,
@@ -225,6 +232,9 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(testInstances, instanceMap.get(afterEachCallbackKey3));
 		assertSame(testInstances.getInnermostInstance(),
 			instanceMap.get(postProcessTestInstanceKey).getInnermostInstance());
+		assertSame(testInstances.getInnermostInstance(),
+			instanceMap.get(preDestroyCallbackTestInstanceKey).getInnermostInstance());
+
 		assertNull(instanceMap.get(containerExecutionConditionKey));
 
 		assertThat(lifecyclesMap.keySet()).containsExactly(testClass);
@@ -248,6 +258,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		String nestedTestTemplateKey = testTemplateKey(nestedTestClass, "singletonTest");
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
 		String nestedPostProcessTestInstanceKey = postProcessTestInstanceKey(nestedTestClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
+		String nestedPreDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(nestedTestClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String outerTestExecutionConditionKey = executionConditionKey(testClass, "outerTest");
@@ -272,6 +284,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				nestedContainerExecutionConditionKey,
 				postProcessTestInstanceKey,
 				nestedPostProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
+				nestedPreDestroyCallbackTestInstanceKey,
 				beforeAllCallbackKey,
 				afterAllCallbackKey,
 				outerTestExecutionConditionKey,
@@ -324,6 +338,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 			instanceMap.get(nestedAfterEachCallbackKey3).getInnermostInstance());
 		assertSame(nestedInstances3.getInnermostInstance(),
 			instanceMap.get(nestedExecutionConditionKey3).getInnermostInstance());
+		assertSame(nestedInstances3.getInnermostInstance(),
+			instanceMap.get(nestedPreDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		Object outerInstance1 = instanceMap.get(nestedExecutionConditionKey1).findInstance(testClass).get();
 		Object outerInstance2 = instanceMap.get(nestedExecutionConditionKey2).findInstance(testClass).get();
@@ -364,6 +380,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		String nestedTestTemplateKey = testTemplateKey(nestedTestClass, "singletonTest");
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
 		String nestedPostProcessTestInstanceKey = postProcessTestInstanceKey(nestedTestClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
+		String nestedPreDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(nestedTestClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String outerTestExecutionConditionKey = executionConditionKey(testClass, "outerTest");
@@ -388,6 +406,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				nestedContainerExecutionConditionKey,
 				postProcessTestInstanceKey,
 				nestedPostProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
+				nestedPreDestroyCallbackTestInstanceKey,
 				beforeAllCallbackKey,
 				afterAllCallbackKey,
 				outerTestExecutionConditionKey,
@@ -415,6 +435,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(instance, instanceMap.get(outerTestExecutionConditionKey).getInnermostInstance());
 		assertSame(instance, instanceMap.get(beforeEachCallbackKey).getInnermostInstance());
 		assertSame(instance, instanceMap.get(afterEachCallbackKey).getInnermostInstance());
+		assertSame(instance, instanceMap.get(preDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		Object nestedInstance = instanceMap.get(nestedPostProcessTestInstanceKey).getInnermostInstance();
 		assertNotNull(nestedInstance);
@@ -431,9 +452,12 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(nestedInstance, instanceMap.get(nestedExecutionConditionKey3).getInnermostInstance());
 		assertSame(nestedInstance, instanceMap.get(nestedBeforeEachCallbackKey3).getInnermostInstance());
 		assertSame(nestedInstance, instanceMap.get(nestedAfterEachCallbackKey3).getInnermostInstance());
+		assertSame(nestedInstance, instanceMap.get(nestedPreDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		Object outerInstance = instanceMap.get(nestedExecutionConditionKey1).findInstance(testClass).get();
 		assertSame(outerInstance, instanceMap.get(postProcessTestInstanceKey).getInnermostInstance());
+		assertSame(outerInstance, instanceMap.get(preDestroyCallbackTestInstanceKey).getInnermostInstance());
+
 		assertThat(instanceMap.get(nestedExecutionConditionKey1).getAllInstances()).containsExactly(outerInstance,
 			nestedInstance);
 		assertThat(instanceMap.get(nestedBeforeEachCallbackKey1).getAllInstances()).containsExactly(outerInstance,
@@ -475,6 +499,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		String nestedTestTemplateKey = testTemplateKey(nestedTestClass, "singletonTest");
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
 		String nestedPostProcessTestInstanceKey = postProcessTestInstanceKey(nestedTestClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
+		String nestedPreDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(nestedTestClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String outerTestExecutionConditionKey = executionConditionKey(testClass, "outerTest");
@@ -499,6 +525,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				nestedContainerExecutionConditionKey,
 				postProcessTestInstanceKey,
 				nestedPostProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
+				nestedPreDestroyCallbackTestInstanceKey,
 				beforeAllCallbackKey,
 				afterAllCallbackKey,
 				outerTestExecutionConditionKey,
@@ -541,6 +569,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(nestedInstance, instanceMap.get(nestedExecutionConditionKey3).getInnermostInstance());
 		assertSame(nestedInstance, instanceMap.get(nestedBeforeEachCallbackKey3).getInnermostInstance());
 		assertSame(nestedInstance, instanceMap.get(nestedAfterEachCallbackKey3).getInnermostInstance());
+		assertSame(nestedInstance, instanceMap.get(nestedPreDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		// The last tracked instance stored under postProcessTestInstanceKey
 		// is only created in order to instantiate the nested test class.
@@ -609,6 +638,10 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		return concat(TestInstancePostProcessor.class, testClass);
 	}
 
+	private static String preDestroyCallbackTestInstanceKey(Class<?> testClass) {
+		return concat(TestInstancePreDestroyCallback.class, testClass);
+	}
+
 	private static String beforeAllCallbackKey(Class<?> testClass) {
 		return concat(BeforeAllCallback.class, testClass);
 	}
@@ -935,7 +968,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 	// Intentionally not implementing BeforeTestExecutionCallback, AfterTestExecutionCallback,
 	// and TestExecutionExceptionHandler, since they are analogous to BeforeEachCallback and
 	// AfterEachCallback with regard to instance scope and Lifecycle.
-	static class InstanceTrackingExtension implements ExecutionCondition, TestInstancePostProcessor, BeforeAllCallback,
+	static class InstanceTrackingExtension
+			implements ExecutionCondition, TestInstancePostProcessor, TestInstancePreDestroyCallback, BeforeAllCallback,
 			AfterAllCallback, BeforeEachCallback, AfterEachCallback, TestTemplateInvocationContextProvider {
 
 		@Override
@@ -961,6 +995,14 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				DefaultTestInstances.of(testInstance));
 		}
 
+		@Override
+		public void preDestroyTestInstance(ExtensionContext context) {
+			trackLifecycle(context);
+			assertThat(context.getTestInstance()).isPresent();
+			instanceMap.put(preDestroyCallbackTestInstanceKey(context.getRequiredTestClass()),
+				DefaultTestInstances.of(context.getTestInstance().get()));
+		}
+
 		@Override
 		public void beforeAll(ExtensionContext context) {
 			trackLifecycle(context);
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePostProcessorAndPreDestroyCallbackTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePostProcessorAndPreDestroyCallbackTests.java
new file mode 100644
index 000000000..ad34f9221
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePostProcessorAndPreDestroyCallbackTests.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static java.util.Arrays.asList;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+import org.junit.jupiter.engine.JupiterTestEngine;
+
+/**
+ * Integration tests that verify support for {@link TestInstancePostProcessor}
+ * and {@link TestInstancePreDestroyCallback} in the {@link JupiterTestEngine}.
+ *
+ * @since 5.6
+ */
+class TestInstancePostProcessorAndPreDestroyCallbackTests extends AbstractJupiterTestEngineTests {
+
+	private static final List<String> callSequence = new ArrayList<>();
+
+	@Test
+	void postProcessorAndPreDestroyCallbacks() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(TopLevelTestCase.class,
+			"fooPostProcessTestInstance",
+			"barPostProcessTestInstance",
+				"test-1",
+			"barPreDestroyTestInstance",
+			"fooPreDestroyTestInstance"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void postProcessorAndPreDestroyCallbacksInSubclass() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(SecondLevelTestCase.class,
+			"fooPostProcessTestInstance",
+			"barPostProcessTestInstance",
+				"bazPostProcessTestInstance",
+					"test-2",
+				"bazPreDestroyTestInstance",
+			"barPreDestroyTestInstance",
+			"fooPreDestroyTestInstance"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void postProcessorAndPreDestroyCallbacksInSubSubclass() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(ThirdLevelTestCase.class,
+			"fooPostProcessTestInstance",
+			"barPostProcessTestInstance",
+				"bazPostProcessTestInstance",
+					"quuxPostProcessTestInstance",
+						"test-3",
+					"quuxPreDestroyTestInstance",
+				"bazPreDestroyTestInstance",
+			"barPreDestroyTestInstance",
+			"fooPreDestroyTestInstance"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void preDestroyTestInstanceMethodThrowsAnException() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(ExceptionInTestInstancePreDestroyCallbackTestCase.class, 0,
+			"fooPostProcessTestInstance",
+				"test",
+			"exceptionThrowingTestInstancePreDestroyCallback"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void postProcessTestInstanceMethodThrowsAnException() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(ExceptionInTestInstancePostProcessorTestCase.class, 0,
+			"exceptionThrowingTestInstancePostProcessor"
+		);
+		// @formatter:on
+	}
+
+	private void assertPostProcessorAndPreDestroyCallbacks(Class<?> testClass, String... expectedCalls) {
+		assertPostProcessorAndPreDestroyCallbacks(testClass, 1, expectedCalls);
+	}
+
+	private void assertPostProcessorAndPreDestroyCallbacks(Class<?> testClass, int testsSuccessful,
+			String... expectedCalls) {
+
+		callSequence.clear();
+
+		executeTestsForClass(testClass).testEvents()//
+				.assertStatistics(stats -> stats.started(1).succeeded(testsSuccessful));
+
+		assertEquals(asList(expectedCalls), callSequence, () -> "wrong call sequence for " + testClass.getName());
+	}
+
+	// -------------------------------------------------------------------------
+
+	// Must NOT be private; otherwise, the @Test method gets discovered but never executed.
+	@ExtendWith({ FooTestInstanceCallbacks.class, BarTestInstanceCallbacks.class })
+	static class TopLevelTestCase {
+
+		@Test
+		void test() {
+			callSequence.add("test-1");
+		}
+	}
+
+	// Must NOT be private; otherwise, the @Test method gets discovered but never executed.
+	@ExtendWith(BazTestInstanceCallbacks.class)
+	static class SecondLevelTestCase extends TopLevelTestCase {
+
+		@Test
+		@Override
+		void test() {
+			callSequence.add("test-2");
+		}
+	}
+
+	@ExtendWith(QuuxTestInstanceCallbacks.class)
+	static class ThirdLevelTestCase extends SecondLevelTestCase {
+
+		@Test
+		@Override
+		void test() {
+			callSequence.add("test-3");
+		}
+	}
+
+	@ExtendWith(ExceptionThrowingTestInstancePreDestroyCallback.class)
+	static class ExceptionInTestInstancePreDestroyCallbackTestCase {
+		@Test
+		void test() {
+			callSequence.add("test");
+		}
+	}
+
+	@ExtendWith(ExceptionThrowingTestInstancePostProcessor.class)
+	static class ExceptionInTestInstancePostProcessorTestCase {
+		@Test
+		void test() {
+			callSequence.add("test");
+		}
+	}
+
+	// -------------------------------------------------------------------------
+
+	static class FooTestInstanceCallbacks extends AbstractTestInstanceCallbacks {
+
+		protected FooTestInstanceCallbacks() {
+			super("foo");
+		}
+	}
+
+	static class BarTestInstanceCallbacks extends AbstractTestInstanceCallbacks {
+
+		protected BarTestInstanceCallbacks() {
+			super("bar");
+		}
+	}
+
+	static class BazTestInstanceCallbacks extends AbstractTestInstanceCallbacks {
+
+		protected BazTestInstanceCallbacks() {
+			super("baz");
+		}
+	}
+
+	static class QuuxTestInstanceCallbacks extends AbstractTestInstanceCallbacks {
+
+		protected QuuxTestInstanceCallbacks() {
+			super("quux");
+		}
+	}
+
+	static class ExceptionThrowingTestInstancePreDestroyCallback extends AbstractTestInstanceCallbacks {
+
+		protected ExceptionThrowingTestInstancePreDestroyCallback() {
+			super("foo");
+		}
+
+		@Override
+		public void preDestroyTestInstance(ExtensionContext context) {
+			callSequence.add("exceptionThrowingTestInstancePreDestroyCallback");
+			throw new EnigmaException("preDestroyTestInstance");
+		}
+	}
+
+	static class ExceptionThrowingTestInstancePostProcessor extends AbstractTestInstanceCallbacks {
+
+		protected ExceptionThrowingTestInstancePostProcessor() {
+			super("exception");
+		}
+
+		@Override
+		public void postProcessTestInstance(Object testInstance, ExtensionContext context) {
+			callSequence.add("exceptionThrowingTestInstancePostProcessor");
+			throw new EnigmaException("postProcessTestInstance");
+		}
+	}
+
+	private static abstract class AbstractTestInstanceCallbacks
+			implements TestInstancePostProcessor, TestInstancePreDestroyCallback {
+
+		private final String name;
+
+		AbstractTestInstanceCallbacks(String name) {
+			this.name = name;
+		}
+
+		@Override
+		public void postProcessTestInstance(Object testInstance, ExtensionContext context) {
+			callSequence.add(name + "PostProcessTestInstance");
+		}
+
+		@Override
+		public void preDestroyTestInstance(ExtensionContext context) {
+			callSequence.add(name + "PreDestroyTestInstance");
+		}
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePreDestroyCallbackTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePreDestroyCallbackTests.java
new file mode 100644
index 000000000..0a6aa83ac
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePreDestroyCallbackTests.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+
+/**
+ * Integration tests that verify support for {@link TestInstancePreDestroyCallback}.
+ *
+ * @since 5.6
+ */
+class TestInstancePreDestroyCallbackTests extends AbstractJupiterTestEngineTests {
+
+	private static final List<String> callSequence = new ArrayList<>();
+
+	@BeforeEach
+	void resetCallSequence() {
+		callSequence.clear();
+	}
+
+	@Test
+	void instancePreDestroyCallbacksInNestedClasses() {
+		executeTestsForClass(OuterTestCase.class).testEvents().assertStatistics(stats -> stats.started(2).succeeded(2));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+
+			// OuterTestCase
+			"beforeOuterMethod",
+				"testOuter",
+			"fooPreDestroyCallbackTestInstance:OuterTestCase",
+
+			// InnerTestCase
+			"beforeOuterMethod",
+				"beforeInnerMethod",
+					"testInner",
+				"barPreDestroyCallbackTestInstance:InnerTestCase",
+
+			"fooPreDestroyCallbackTestInstance:InnerTestCase"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void testSpecificTestInstancePreDestroyCallbackIsCalled() {
+		executeTestsForClass(
+			TestCaseWithTestSpecificTestInstancePreDestroyCallback.class).testEvents().assertStatistics(
+				stats -> stats.started(1).succeeded(1));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+			"beforeEachMethod",
+				"test",
+			"fooPreDestroyCallbackTestInstance:TestCaseWithTestSpecificTestInstancePreDestroyCallback"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void classLifecyclePreDestroyCallbacks() {
+		executeTestsForClass(PerClassLifecyclePreDestroyCallbackWithTwoTestMethods.class).testEvents().assertStatistics(
+			stats -> stats.started(2).succeeded(2));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+			"beforeEachMethod",
+				"test1",
+			"beforeEachMethod",
+				"test2",
+			"fooPreDestroyCallbackTestInstance:PerClassLifecyclePreDestroyCallbackWithTwoTestMethods"
+		);
+		// @formatter:on
+	}
+
+	// -------------------------------------------------------------------
+
+	@ExtendWith(FooInstancePreDestroyCallback.class)
+	static class OuterTestCase extends Destroyable {
+
+		@BeforeEach
+		void beforeOuterMethod() {
+			callSequence.add("beforeOuterMethod");
+		}
+
+		@Test
+		void testOuter() {
+			assertFalse(isDestroyed);
+			callSequence.add("testOuter");
+		}
+
+		@Nested
+		@ExtendWith(BarInstancePreDestroyCallback.class)
+		class InnerTestCase extends Destroyable {
+
+			@BeforeEach
+			void beforeInnerMethod() {
+				assertFalse(isDestroyed);
+				callSequence.add("beforeInnerMethod");
+			}
+
+			@Test
+			void testInner() {
+				callSequence.add("testInner");
+			}
+		}
+	}
+
+	static class TestCaseWithTestSpecificTestInstancePreDestroyCallback extends Destroyable {
+
+		@BeforeEach
+		void beforeEachMethod() {
+			assertFalse(isDestroyed);
+			callSequence.add("beforeEachMethod");
+		}
+
+		@ExtendWith(FooInstancePreDestroyCallback.class)
+		@Test
+		void test() {
+			callSequence.add("test");
+		}
+	}
+
+	@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+	@ExtendWith(FooInstancePreDestroyCallback.class)
+	static class PerClassLifecyclePreDestroyCallbackWithTwoTestMethods extends Destroyable {
+
+		@BeforeEach
+		void beforeEachMethod() {
+			callSequence.add("beforeEachMethod");
+		}
+
+		@Test
+		void test1() {
+			callSequence.add("test1");
+		}
+
+		@Test
+		void test2() {
+			callSequence.add("test2");
+		}
+	}
+
+	static class FooInstancePreDestroyCallback extends AbstractInstancePreDestroyCallback {
+
+		protected FooInstancePreDestroyCallback() {
+			super("foo");
+		}
+	}
+
+	static class BarInstancePreDestroyCallback extends AbstractInstancePreDestroyCallback {
+
+		protected BarInstancePreDestroyCallback() {
+			super("bar");
+		}
+	}
+
+	static abstract class AbstractInstancePreDestroyCallback implements TestInstancePreDestroyCallback {
+
+		private final String name;
+
+		AbstractInstancePreDestroyCallback(String name) {
+			this.name = name;
+		}
+
+		@Override
+		public void preDestroyTestInstance(ExtensionContext context) {
+			assertTrue(context.getTestInstance().isPresent());
+			Object testInstance = context.getTestInstance().get();
+			if (testInstance instanceof Destroyable) {
+				((Destroyable) testInstance).setDestroyed();
+			}
+			callSequence.add(name + "PreDestroyCallbackTestInstance:" + testInstance.getClass().getSimpleName());
+		}
+	}
+
+	private abstract static class Destroyable {
+
+		boolean isDestroyed;
+
+		void setDestroyed() {
+			isDestroyed = true;
+		}
+	}
+}
diff --git a/junit-jupiter-migrationsupport/junit-jupiter-migrationsupport.gradle.kts b/junit-jupiter-migrationsupport/junit-jupiter-migrationsupport.gradle.kts
index 1f7a21e7c..fe8f29c35 100644
--- a/junit-jupiter-migrationsupport/junit-jupiter-migrationsupport.gradle.kts
+++ b/junit-jupiter-migrationsupport/junit-jupiter-migrationsupport.gradle.kts
@@ -1,3 +1,5 @@
+import aQute.bnd.gradle.BundleTaskConvention;
+
 plugins {
 	`java-library-conventions`
 }
@@ -18,4 +20,20 @@ dependencies {
 	testImplementation(project(":junit-platform-launcher"))
 	testImplementation(project(":junit-platform-runner"))
 	testImplementation(project(":junit-platform-testkit"))
+
+	testRuntimeOnly("org.apache.servicemix.bundles:org.apache.servicemix.bundles.junit:4.12_1")
+}
+
+tasks.jar {
+	withConvention(BundleTaskConvention::class) {
+		bnd("""
+			# Import JUnit4 packages with a version
+			Import-Package: \
+				!org.apiguardian.api,\
+				org.junit;version="${Versions.junit4}",\
+				org.junit.platform.commons.logging;status=INTERNAL,\
+				org.junit.rules;version="${Versions.junit4}",\
+				*
+		""")
+	}
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java
index e00f3671b..2915ee157 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java
@@ -155,17 +155,6 @@ public @interface ParameterizedTest {
 	@API(status = EXPERIMENTAL, since = "5.3")
 	String ARGUMENTS_PLACEHOLDER = "{arguments}";
 
-	/**
-	 * Placeholder for the complete, comma-separated named arguments list
-	 * of the current invocation of a {@code @ParameterizedTest} method:
-	 * <code>{argumentsWithNames}</code>
-	 *
-	 * @see #name
-	 * @since 5.6
-	 */
-	@API(status = EXPERIMENTAL, since = "5.6")
-	String ARGUMENTS_WITH_NAMES_PLACEHOLDER = "{argumentsWithNames}";
-
 	/**
 	 * Default display name pattern for the current invocation of a
 	 * {@code @ParameterizedTest} method: {@value}
@@ -177,11 +166,11 @@ public @interface ParameterizedTest {
 	 * @see #name
 	 * @see #DISPLAY_NAME_PLACEHOLDER
 	 * @see #INDEX_PLACEHOLDER
-	 * @see #ARGUMENTS_WITH_NAMES_PLACEHOLDER
+	 * @see #ARGUMENTS_PLACEHOLDER
 	 * @since 5.3
 	 */
 	@API(status = EXPERIMENTAL, since = "5.3")
-	String DEFAULT_DISPLAY_NAME = "[" + INDEX_PLACEHOLDER + "] " + ARGUMENTS_WITH_NAMES_PLACEHOLDER;
+	String DEFAULT_DISPLAY_NAME = "[" + INDEX_PLACEHOLDER + "] " + ARGUMENTS_PLACEHOLDER;
 
 	/**
 	 * The display name to be used for individual invocations of the
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
index 6cf507ac8..fa171ca2e 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
@@ -72,7 +72,7 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 		String displayName = extensionContext.getDisplayName();
 		ParameterizedTestMethodContext methodContext = getStore(extensionContext)//
 				.get(METHOD_CONTEXT_KEY, ParameterizedTestMethodContext.class);
-		ParameterizedTestNameFormatter formatter = createNameFormatter(templateMethod, methodContext, displayName);
+		ParameterizedTestNameFormatter formatter = createNameFormatter(templateMethod, displayName);
 		AtomicLong invocationCount = new AtomicLong(0);
 
 		// @formatter:off
@@ -118,14 +118,13 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 		return new ParameterizedTestInvocationContext(formatter, methodContext, arguments);
 	}
 
-	private ParameterizedTestNameFormatter createNameFormatter(Method templateMethod,
-			ParameterizedTestMethodContext methodContext, String displayName) {
+	private ParameterizedTestNameFormatter createNameFormatter(Method templateMethod, String displayName) {
 		ParameterizedTest parameterizedTest = findAnnotation(templateMethod, ParameterizedTest.class).get();
 		String pattern = Preconditions.notBlank(parameterizedTest.name().trim(),
 			() -> String.format(
 				"Configuration error: @ParameterizedTest on method [%s] must be declared with a non-empty name.",
 				templateMethod));
-		return new ParameterizedTestNameFormatter(pattern, displayName, methodContext);
+		return new ParameterizedTestNameFormatter(pattern, displayName);
 	}
 
 	protected static Stream<? extends Arguments> arguments(ArgumentsProvider provider, ExtensionContext context) {
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
index f2615b3f9..7e7f9e3db 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
@@ -18,7 +18,6 @@ import java.lang.reflect.Method;
 import java.lang.reflect.Parameter;
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Optional;
 
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
@@ -43,15 +42,14 @@ import org.junit.platform.commons.util.StringUtils;
  */
 class ParameterizedTestMethodContext {
 
-	private final Parameter[] parameters;
-	private final Resolver[] resolvers;
 	private final List<ResolverType> resolverTypes;
+	private final Resolver[] resolvers;
 
 	ParameterizedTestMethodContext(Method testMethod) {
-		this.parameters = testMethod.getParameters();
-		this.resolvers = new Resolver[this.parameters.length];
-		this.resolverTypes = new ArrayList<>(this.parameters.length);
-		for (Parameter parameter : this.parameters) {
+		Parameter[] parameters = testMethod.getParameters();
+		this.resolverTypes = new ArrayList<>(parameters.length);
+		this.resolvers = new Resolver[parameters.length];
+		for (Parameter parameter : parameters) {
 			this.resolverTypes.add(isAggregator(parameter) ? AGGREGATOR : CONVERTER);
 		}
 	}
@@ -102,27 +100,7 @@ class ParameterizedTestMethodContext {
 	 * context.
 	 */
 	int getParameterCount() {
-		return parameters.length;
-	}
-
-	/**
-	 * Get the name of the {@link Parameter} with the supplied index, if
-	 * it is present and declared before the aggregators.
-	 *
-	 * @return an {@code Optional} containing the name of the parameter
-	 */
-	Optional<String> getParameterName(int parameterIndex) {
-		if (parameterIndex >= getParameterCount()) {
-			return Optional.empty();
-		}
-		Parameter parameter = this.parameters[parameterIndex];
-		if (!parameter.isNamePresent()) {
-			return Optional.empty();
-		}
-		if (hasAggregator() && parameterIndex >= indexOfFirstAggregator()) {
-			return Optional.empty();
-		}
-		return Optional.of(parameter.getName());
+		return resolvers.length;
 	}
 
 	/**
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
index 6e6653a26..e94300ad6 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
@@ -12,7 +12,6 @@ package org.junit.jupiter.params;
 
 import static java.util.stream.Collectors.joining;
 import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_PLACEHOLDER;
-import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_WITH_NAMES_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;
 
@@ -31,12 +30,10 @@ class ParameterizedTestNameFormatter {
 
 	private final String pattern;
 	private final String displayName;
-	private final ParameterizedTestMethodContext methodContext;
 
-	ParameterizedTestNameFormatter(String pattern, String displayName, ParameterizedTestMethodContext methodContext) {
+	ParameterizedTestNameFormatter(String pattern, String displayName) {
 		this.pattern = pattern;
 		this.displayName = displayName;
-		this.methodContext = methodContext;
 	}
 
 	String format(int invocationIndex, Object... arguments) {
@@ -62,30 +59,18 @@ class ParameterizedTestNameFormatter {
 				.replace(DISPLAY_NAME_PLACEHOLDER, this.displayName)//
 				.replace(INDEX_PLACEHOLDER, String.valueOf(invocationIndex));
 
-		if (result.contains(ARGUMENTS_WITH_NAMES_PLACEHOLDER)) {
-			result = result.replace(ARGUMENTS_WITH_NAMES_PLACEHOLDER, argumentsWithNamesPattern(arguments));
-		}
-
 		if (result.contains(ARGUMENTS_PLACEHOLDER)) {
-			result = result.replace(ARGUMENTS_PLACEHOLDER, argumentsPattern(arguments));
+			// @formatter:off
+			String replacement = IntStream.range(0, arguments.length)
+					.mapToObj(index -> "{" + index + "}")
+					.collect(joining(", "));
+			// @formatter:on
+			result = result.replace(ARGUMENTS_PLACEHOLDER, replacement);
 		}
 
 		return result;
 	}
 
-	private String argumentsWithNamesPattern(Object[] arguments) {
-		return IntStream.range(0, arguments.length) //
-				.mapToObj(index -> methodContext.getParameterName(index).map(name -> name + "=").orElse("") + "{"
-						+ index + "}") //
-				.collect(joining(", "));
-	}
-
-	private String argumentsPattern(Object[] arguments) {
-		return IntStream.range(0, arguments.length) //
-				.mapToObj(index -> "{" + index + "}") //
-				.collect(joining(", "));
-	}
-
 	private Object[] makeReadable(MessageFormat format, Object[] arguments) {
 		Format[] formats = format.getFormatsByArgumentIndex();
 		Object[] result = Arrays.copyOf(arguments, Math.min(arguments.length, formats.length), Object[].class);
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java
index 6315c18ac..2626198ee 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java
@@ -35,7 +35,6 @@ class ParameterizedTestParameterResolver implements ParameterResolver {
 	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
 		Executable declaringExecutable = parameterContext.getDeclaringExecutable();
 		Method testMethod = extensionContext.getTestMethod().orElse(null);
-		int parameterIndex = parameterContext.getIndex();
 
 		// Not a @ParameterizedTest method?
 		if (!declaringExecutable.equals(testMethod)) {
@@ -43,18 +42,18 @@ class ParameterizedTestParameterResolver implements ParameterResolver {
 		}
 
 		// Current parameter is an aggregator?
-		if (this.methodContext.isAggregator(parameterIndex)) {
+		if (this.methodContext.isAggregator(parameterContext.getIndex())) {
 			return true;
 		}
 
 		// Ensure that the current parameter is declared before aggregators.
 		// Otherwise, a different ParameterResolver should handle it.
-		if (this.methodContext.hasAggregator()) {
-			return parameterIndex < this.methodContext.indexOfFirstAggregator();
+		if (this.methodContext.indexOfFirstAggregator() != -1) {
+			return parameterContext.getIndex() < this.methodContext.indexOfFirstAggregator();
 		}
 
 		// Else fallback to behavior for parameterized test methods without aggregators.
-		return parameterIndex < this.arguments.length;
+		return parameterContext.getIndex() < this.arguments.length;
 	}
 
 	@Override
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
index ee9ce3040..7a527e4d4 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
@@ -54,10 +54,6 @@ import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.engine.JupiterTestEngine;
-import org.junit.jupiter.params.aggregator.AggregateWith;
-import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
-import org.junit.jupiter.params.aggregator.ArgumentsAggregationException;
-import org.junit.jupiter.params.aggregator.ArgumentsAggregator;
 import org.junit.jupiter.params.converter.ArgumentConversionException;
 import org.junit.jupiter.params.converter.ArgumentConverter;
 import org.junit.jupiter.params.converter.ConvertWith;
@@ -89,16 +85,16 @@ class ParameterizedTestIntegrationTests {
 	void executesWithSingleArgumentsProviderWithMultipleInvocations() {
 		var results = execute("testWithTwoSingleStringArgumentsProvider", String.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
-				.haveExactly(1, event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
+				.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
+				.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
 	}
 
 	@Test
 	void executesWithCsvSource() {
 		var results = execute("testWithCsvSource", String.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
-				.haveExactly(1, event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
+				.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
+				.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
 	}
 
 	@Test
@@ -116,8 +112,8 @@ class ParameterizedTestIntegrationTests {
 	void executesWithPrimitiveWideningConversion() {
 		var results = execute("testWithPrimitiveWideningConversion", double.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] num=1"), finishedWithFailure(message("num: 1.0")))) //
-				.haveExactly(1, event(test(), displayName("[2] num=2"), finishedWithFailure(message("num: 2.0"))));
+				.haveExactly(1, event(test(), displayName("[1] 1"), finishedWithFailure(message("num: 1.0")))) //
+				.haveExactly(1, event(test(), displayName("[2] 2"), finishedWithFailure(message("num: 2.0"))));
 	}
 
 	/**
@@ -127,8 +123,8 @@ class ParameterizedTestIntegrationTests {
 	void executesWithImplicitGenericConverter() {
 		var results = execute("testWithImplicitGenericConverter", Book.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] book=book 1"), finishedWithFailure(message("book 1")))) //
-				.haveExactly(1, event(test(), displayName("[2] book=book 2"), finishedWithFailure(message("book 2"))));
+				.haveExactly(1, event(test(), displayName("[1] book 1"), finishedWithFailure(message("book 1")))) //
+				.haveExactly(1, event(test(), displayName("[2] book 2"), finishedWithFailure(message("book 2"))));
 	}
 
 	@Test
@@ -148,19 +144,8 @@ class ParameterizedTestIntegrationTests {
 	void executesWithExplicitConverter() {
 		var results = execute("testWithExplicitConverter", int.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] length=O"), finishedWithFailure(message("length: 1")))) //
-				.haveExactly(1,
-					event(test(), displayName("[2] length=XXX"), finishedWithFailure(message("length: 3"))));
-	}
-
-	@Test
-	void executesWithAggregator() {
-		var results = execute("testWithAggregator", String.class);
-		results.allEvents().assertThatEvents() //
-				.haveExactly(1,
-					event(test(), displayName("[1] ab, cd"), finishedWithFailure(message("concatenation: abcd")))) //
-				.haveExactly(1,
-					event(test(), displayName("[2] ef, gh"), finishedWithFailure(message("concatenation: efgh"))));
+				.haveExactly(1, event(test(), displayName("[1] O"), finishedWithFailure(message("length: 1")))) //
+				.haveExactly(1, event(test(), displayName("[2] XXX"), finishedWithFailure(message("length: 3"))));
 	}
 
 	@Test
@@ -187,10 +172,8 @@ class ParameterizedTestIntegrationTests {
 
 		var results = execute(selectClass(LifecycleTestCase.class));
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1,
-					event(test("test1"), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
-				.haveExactly(1,
-					event(test("test1"), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
+				.haveExactly(1, event(test("test1"), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
+				.haveExactly(1, event(test("test1"), displayName("[2] bar"), finishedWithFailure(message("bar"))));
 
 		List<String> testMethods = new ArrayList<>(LifecycleTestCase.testMethods);
 
@@ -199,22 +182,22 @@ class ParameterizedTestIntegrationTests {
 			"beforeAll:ParameterizedTestIntegrationTests$LifecycleTestCase",
 				"providerMethod",
 					"constructor:ParameterizedTestIntegrationTests$LifecycleTestCase",
-					"beforeEach:[1] argument=foo",
-						testMethods.get(0) + ":[1] argument=foo",
-					"afterEach:[1] argument=foo",
+					"beforeEach:[1] foo",
+						testMethods.get(0) + ":[1] foo",
+					"afterEach:[1] foo",
 					"constructor:ParameterizedTestIntegrationTests$LifecycleTestCase",
-					"beforeEach:[2] argument=bar",
-						testMethods.get(0) + ":[2] argument=bar",
-					"afterEach:[2] argument=bar",
+					"beforeEach:[2] bar",
+						testMethods.get(0) + ":[2] bar",
+					"afterEach:[2] bar",
 				"providerMethod",
 					"constructor:ParameterizedTestIntegrationTests$LifecycleTestCase",
-					"beforeEach:[1] argument=foo",
-						testMethods.get(1) + ":[1] argument=foo",
-					"afterEach:[1] argument=foo",
+					"beforeEach:[1] foo",
+						testMethods.get(1) + ":[1] foo",
+					"afterEach:[1] foo",
 					"constructor:ParameterizedTestIntegrationTests$LifecycleTestCase",
-					"beforeEach:[2] argument=bar",
-						testMethods.get(1) + ":[2] argument=bar",
-					"afterEach:[2] argument=bar",
+					"beforeEach:[2] bar",
+						testMethods.get(1) + ":[2] bar",
+					"afterEach:[2] bar",
 			"afterAll:ParameterizedTestIntegrationTests$LifecycleTestCase");
 		// @formatter:on
 	}
@@ -241,21 +224,21 @@ class ParameterizedTestIntegrationTests {
 		void executesWithNullSourceForString() {
 			var results = execute("testWithNullSourceForString", String.class);
 			results.testEvents().failed().assertEventsMatchExactly(
-				event(test(), displayName("[1] argument=null"), finishedWithFailure(message("null"))));
+				event(test(), displayName("[1] null"), finishedWithFailure(message("null"))));
 		}
 
 		@Test
 		void executesWithNullSourceForStringAndTestInfo() {
 			var results = execute("testWithNullSourceForStringAndTestInfo", String.class, TestInfo.class);
 			results.testEvents().failed().assertEventsMatchExactly(
-				event(test(), displayName("[1] argument=null"), finishedWithFailure(message("null"))));
+				event(test(), displayName("[1] null"), finishedWithFailure(message("null"))));
 		}
 
 		@Test
 		void executesWithNullSourceForNumber() {
 			var results = execute("testWithNullSourceForNumber", Number.class);
 			results.testEvents().failed().assertEventsMatchExactly(
-				event(test(), displayName("[1] argument=null"), finishedWithFailure(message("null"))));
+				event(test(), displayName("[1] null"), finishedWithFailure(message("null"))));
 		}
 
 		@Test
@@ -272,7 +255,7 @@ class ParameterizedTestIntegrationTests {
 		@Test
 		void failsWithNullSourceForPrimitive() {
 			var results = execute("testWithNullSourceForPrimitive", int.class);
-			results.testEvents().failed().assertEventsMatchExactly(event(test(), displayName("[1] argument=null"),
+			results.testEvents().failed().assertEventsMatchExactly(event(test(), displayName("[1] null"),
 				finishedWithFailure(instanceOf(ParameterResolutionException.class), message(
 					"Error converting parameter at index 0: Cannot convert null to primitive value of type int"))));
 		}
@@ -293,55 +276,55 @@ class ParameterizedTestIntegrationTests {
 		@Test
 		void executesWithEmptySourceForString() {
 			var results = execute("testWithEmptySourceForString", String.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] ")));
 		}
 
 		@Test
 		void executesWithEmptySourceForStringAndTestInfo() {
 			var results = execute("testWithEmptySourceForStringAndTestInfo", String.class, TestInfo.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] ")));
 		}
 
 		@Test
 		void executesWithEmptySourceForList() {
 			var results = execute("testWithEmptySourceForList", List.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
 		}
 
 		@Test
 		void executesWithEmptySourceForSet() {
 			var results = execute("testWithEmptySourceForSet", Set.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
 		}
 
 		@Test
 		void executesWithEmptySourceForMap() {
 			var results = execute("testWithEmptySourceForMap", Map.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument={}")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] {}")));
 		}
 
 		@Test
 		void executesWithEmptySourceForOneDimensionalPrimitiveArray() {
 			var results = execute("testWithEmptySourceForOneDimensionalPrimitiveArray", int[].class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
 		}
 
 		@Test
 		void executesWithEmptySourceForOneDimensionalStringArray() {
 			var results = execute("testWithEmptySourceForOneDimensionalStringArray", String[].class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
 		}
 
 		@Test
 		void executesWithEmptySourceForTwoDimensionalPrimitiveArray() {
 			var results = execute("testWithEmptySourceForTwoDimensionalPrimitiveArray", int[][].class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
 		}
 
 		@Test
 		void executesWithEmptySourceForTwoDimensionalStringArray() {
 			var results = execute("testWithEmptySourceForTwoDimensionalStringArray", String[][].class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
 		}
 
 		@Test
@@ -423,15 +406,15 @@ class ParameterizedTestIntegrationTests {
 
 		private void assertNullAndEmptyString(EngineExecutionResults results) {
 			results.testEvents().succeeded().assertEventsMatchExactly(//
-				event(test(), displayName("[1] argument=null")), //
-				event(test(), displayName("[2] argument="))//
+				event(test(), displayName("[1] null")), //
+				event(test(), displayName("[2] "))//
 			);
 		}
 
 		private void assertNullAndEmpty(EngineExecutionResults results) {
 			results.testEvents().succeeded().assertEventsMatchExactly(//
-				event(test(), displayName("[1] argument=null")), //
-				event(test(), displayName("[2] argument=[]"))//
+				event(test(), displayName("[1] null")), //
+				event(test(), displayName("[2] []"))//
 			);
 		}
 
@@ -586,36 +569,32 @@ class ParameterizedTestIntegrationTests {
 		void executesWithArgumentsSourceProvidingUnusedArguments() {
 			var results = execute("testWithTwoUnusedStringArgumentsProvider", String.class);
 			results.allEvents().assertThatEvents() //
-					.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
-					.haveExactly(1,
-						event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
+					.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
+					.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
 		}
 
 		@Test
 		void executesWithCsvSourceContainingUnusedArguments() {
 			var results = execute("testWithCsvSourceContainingUnusedArguments", String.class);
 			results.allEvents().assertThatEvents() //
-					.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
-					.haveExactly(1,
-						event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
+					.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
+					.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
 		}
 
 		@Test
 		void executesWithCsvFileSourceContainingUnusedArguments() {
 			var results = execute("testWithCsvFileSourceContainingUnusedArguments", String.class);
 			results.allEvents().assertThatEvents() //
-					.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
-					.haveExactly(1,
-						event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
+					.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
+					.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
 		}
 
 		@Test
 		void executesWithMethodSourceProvidingUnusedArguments() {
 			var results = execute("testWithMethodSourceProvidingUnusedArguments", String.class);
 			results.allEvents().assertThatEvents() //
-					.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
-					.haveExactly(1,
-						event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
+					.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
+					.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
 		}
 
 		private EngineExecutionResults execute(String methodName, Class<?>... methodParameterTypes) {
@@ -677,12 +656,6 @@ class ParameterizedTestIntegrationTests {
 			fail("this should never be called");
 		}
 
-		@ParameterizedTest
-		@CsvSource({ "ab, cd", "ef, gh" })
-		void testWithAggregator(@AggregateWith(StringAggregator.class) String concatenation) {
-			fail("concatenation: " + concatenation);
-		}
-
 	}
 
 	static class NullSourceTestCase {
@@ -1118,15 +1091,6 @@ class ParameterizedTestIntegrationTests {
 		}
 	}
 
-	private static class StringAggregator implements ArgumentsAggregator {
-
-		@Override
-		public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context)
-				throws ArgumentsAggregationException {
-			return accessor.getString(0) + accessor.getString(1);
-		}
-	}
-
 	private static class ErroneousConverter implements ArgumentConverter {
 
 		@Override
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
index 3e5f8f2b5..a97c7aeef 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
@@ -16,12 +16,10 @@ import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_PLACEHOLDER;
-import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_WITH_NAMES_PLACEHOLDER;
+import static org.junit.jupiter.params.ParameterizedTest.DEFAULT_DISPLAY_NAME;
 import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;
-import static org.mockito.Mockito.mock;
 
-import java.lang.reflect.Method;
 import java.math.BigDecimal;
 import java.sql.Date;
 import java.time.LocalDate;
@@ -32,14 +30,8 @@ import java.util.Locale;
 
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.extension.ParameterContext;
-import org.junit.jupiter.params.aggregator.AggregateWith;
-import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
-import org.junit.jupiter.params.aggregator.ArgumentsAggregationException;
-import org.junit.jupiter.params.aggregator.ArgumentsAggregator;
 import org.junit.jupiter.params.provider.CsvSource;
 import org.junit.platform.commons.JUnitException;
-import org.junit.platform.commons.util.ReflectionUtils;
 
 /**
  * @since 5.0
@@ -55,7 +47,8 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formatsDisplayName() {
-		ParameterizedTestNameFormatter formatter = formatter(DISPLAY_NAME_PLACEHOLDER, "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(DISPLAY_NAME_PLACEHOLDER,
+			"enigma");
 
 		assertEquals("enigma", formatter.format(1));
 		assertEquals("enigma", formatter.format(2));
@@ -63,7 +56,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formatsInvocationIndex() {
-		ParameterizedTestNameFormatter formatter = formatter(INDEX_PLACEHOLDER, "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(INDEX_PLACEHOLDER, "enigma");
 
 		assertEquals("1", formatter.format(1));
 		assertEquals("2", formatter.format(2));
@@ -71,14 +64,14 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formatsIndividualArguments() {
-		ParameterizedTestNameFormatter formatter = formatter("{0} -> {1}", "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0} -> {1}", "enigma");
 
 		assertEquals("foo -> 42", formatter.format(1, "foo", 42));
 	}
 
 	@Test
 	void formatsCompleteArgumentsList() {
-		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(ARGUMENTS_PLACEHOLDER, "enigma");
 
 		// @formatter:off
 		assertEquals("42, 99, enigma, null, [1, 2, 3], [foo, bar], [[2, 4], [3, 9]]",
@@ -95,48 +88,27 @@ class ParameterizedTestNameFormatterTests {
 	}
 
 	@Test
-	void formatsCompleteArgumentsListWithNames() {
-		Method testMethod = ParameterizedTestCases.getMethod("parameterizedTest", int.class, String.class,
-			Object[].class);
-		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_WITH_NAMES_PLACEHOLDER, "enigma", testMethod);
-
-		String formattedName = formatter.format(1, 42, "enigma", new Object[] { "foo", 1 });
-		assertEquals("someNumber=42, someString=enigma, someArray=[foo, 1]", formattedName);
-	}
-
-	@Test
-	void formatsCompleteArgumentsListWithoutNamesForAggregators() {
-		Method testMethod = ParameterizedTestCases.getMethod("parameterizedTestWithAggregator", int.class,
-			String.class);
-		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_WITH_NAMES_PLACEHOLDER, "enigma", testMethod);
-
-		String formattedName = formatter.format(1, 42, "foo", "bar");
-		assertEquals("someNumber=42, foo, bar", formattedName);
-	}
-
-	@Test
-	void formatsCompleteArgumentsListWithArrays() {
-		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
+	void formatsInvocationIndexAndCompleteArgumentsListUsingDefaultPattern() {
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(DEFAULT_DISPLAY_NAME, "enigma");
 
 		// Explicit test for https://github.com/junit-team/junit5/issues/814
-		assertEquals("[foo, bar]", formatter.format(1, (Object) new String[] { "foo", "bar" }));
+		assertEquals("[1] [foo, bar]", formatter.format(1, (Object) new String[] { "foo", "bar" }));
 
-		assertEquals("[foo, bar], 42, true", formatter.format(1, new String[] { "foo", "bar" }, 42, true));
+		assertEquals("[1] [foo, bar], 42, true", formatter.format(1, new String[] { "foo", "bar" }, 42, true));
 	}
 
 	@Test
 	void formatsEverythingUsingCustomPattern() {
-		String pattern = DISPLAY_NAME_PLACEHOLDER + " " + INDEX_PLACEHOLDER + " :: " + ARGUMENTS_PLACEHOLDER
-				+ " :: {1}";
-		ParameterizedTestNameFormatter formatter = formatter(pattern, "enigma");
+		String pattern = DISPLAY_NAME_PLACEHOLDER + " :: " + DEFAULT_DISPLAY_NAME + " :: {1}";
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(pattern, "enigma");
 
-		assertEquals("enigma 1 :: foo, bar :: bar", formatter.format(1, "foo", "bar"));
-		assertEquals("enigma 2 :: foo, 42 :: 42", formatter.format(2, "foo", 42));
+		assertEquals("enigma :: [1] foo, bar :: bar", formatter.format(1, "foo", "bar"));
+		assertEquals("enigma :: [2] foo, 42 :: 42", formatter.format(2, "foo", 42));
 	}
 
 	@Test
 	void formatDoesNotAlterArgumentsArray() {
-		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(ARGUMENTS_PLACEHOLDER, "enigma");
 		Object[] actual = { 1, "two", Byte.valueOf("-128"), new Integer[][] { { 2, 4 }, { 3, 9 } } };
 		Object[] expected = Arrays.copyOf(actual, actual.length);
 		assertEquals("1, two, -128, [[2, 4], [3, 9]]", formatter.format(1, actual));
@@ -145,7 +117,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formatDoesNotRaiseAnArrayStoreException() {
-		ParameterizedTestNameFormatter formatter = formatter("{0} -> {1}", "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0} -> {1}", "enigma");
 
 		Object[] arguments = new Number[] { 1, 2 };
 		assertEquals("1 -> 2", formatter.format(1, arguments));
@@ -153,7 +125,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void throwsReadableExceptionForInvalidPattern() {
-		ParameterizedTestNameFormatter formatter = formatter("{index", "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{index", "enigma");
 
 		JUnitException exception = assertThrows(JUnitException.class, () -> formatter.format(1));
 		assertNotNull(exception.getCause());
@@ -162,11 +134,11 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formattingDoesNotFailIfArgumentToStringImplementationThrowsAnException() {
-		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(DEFAULT_DISPLAY_NAME, "enigma");
 
 		String formattedName = formatter.format(1, new Object[] { new ToStringThrowsException(), "foo" });
 
-		assertThat(formattedName).startsWith(ToStringThrowsException.class.getName() + "@");
+		assertThat(formattedName).startsWith("[1] " + ToStringThrowsException.class.getName() + "@");
 		assertThat(formattedName).endsWith("foo");
 	}
 
@@ -175,7 +147,7 @@ class ParameterizedTestNameFormatterTests {
 			"DE | 42,23 is positive on 13.01.2019 at 12:34:56" })
 	void customFormattingExpressionsAreSupported(Locale locale, String expectedValue) {
 		var pattern = "[{index}] {1,number,#.##} is {1,choice,0<positive} on {0,date} at {0,time} even though {2}";
-		ParameterizedTestNameFormatter formatter = formatter(pattern, "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(pattern, "enigma");
 		Locale.setDefault(Locale.US);
 
 		var date = Date.from(
@@ -189,7 +161,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void ignoresExcessPlaceholders() {
-		ParameterizedTestNameFormatter formatter = formatter("{0}, {1}", "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0}, {1}", "enigma");
 
 		String formattedName = formatter.format(1, "foo");
 
@@ -198,7 +170,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void placeholdersCanBeOmitted() {
-		ParameterizedTestNameFormatter formatter = formatter("{0}", "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0}", "enigma");
 
 		String formattedName = formatter.format(1, "foo", "bar");
 
@@ -207,23 +179,13 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void placeholdersCanBeSkipped() {
-		ParameterizedTestNameFormatter formatter = formatter("{0}, {2}", "enigma");
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0}, {2}", "enigma");
 
 		String formattedName = formatter.format(1, "foo", "bar", "baz");
 
 		assertThat(formattedName).isEqualTo("foo, baz");
 	}
 
-	private static ParameterizedTestNameFormatter formatter(String pattern, String displayName) {
-		return new ParameterizedTestNameFormatter(pattern, displayName, mock(ParameterizedTestMethodContext.class));
-	}
-
-	private static ParameterizedTestNameFormatter formatter(String pattern, String displayName, Method method) {
-		return new ParameterizedTestNameFormatter(pattern, displayName, new ParameterizedTestMethodContext(method));
-	}
-
-	// -------------------------------------------------------------------
-
 	private static class ToStringThrowsException {
 
 		@Override
@@ -232,28 +194,4 @@ class ParameterizedTestNameFormatterTests {
 		}
 	}
 
-	private static class ParameterizedTestCases {
-
-		static Method getMethod(String methodName, Class<?>... parameterTypes) {
-			return ReflectionUtils.findMethod(ParameterizedTestCases.class, methodName, parameterTypes).get();
-		}
-
-		void parameterizedTest(int someNumber, String someString, Object[] someArray) {
-
-		}
-
-		void parameterizedTestWithAggregator(int someNumber,
-				@AggregateWith(CustomAggregator.class) String someAggregatedString) {
-
-		}
-
-		private static class CustomAggregator implements ArgumentsAggregator {
-			@Override
-			public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context)
-					throws ArgumentsAggregationException {
-				return accessor.get(0);
-			}
-		}
-	}
-
 }
diff --git a/junit-platform-console-standalone/junit-platform-console-standalone.gradle.kts b/junit-platform-console-standalone/junit-platform-console-standalone.gradle.kts
index c86cec8bf..d86c8ed90 100644
--- a/junit-platform-console-standalone/junit-platform-console-standalone.gradle.kts
+++ b/junit-platform-console-standalone/junit-platform-console-standalone.gradle.kts
@@ -1,3 +1,5 @@
+import aQute.bnd.gradle.BundleTaskConvention;
+
 plugins {
 	`java-library-conventions`
 	id("com.github.johnrengelman.shadow")
@@ -41,6 +43,19 @@ tasks {
 			into("META-INF")
 		}
 
+		withConvention(BundleTaskConvention::class) {
+			bnd("""
+				# Customize the imports because this is an aggregate jar
+				Import-Package: \
+					!org.apiguardian.api,\
+					kotlin.*;resolution:="optional",\
+					*
+				# Disable the APIGuardian plugin since everything was already
+				# processed, again because this is an aggregate jar
+				-export-apiguardian:
+			""")
+		}
+
 		mergeServiceFiles()
 		manifest.apply {
 			inheritFrom(jar.get().manifest)
@@ -59,4 +74,12 @@ tasks {
 			))
 		}
 	}
+
+	// This jar contains some Java 9 code
+	// (org.junit.platform.console.ConsoleLauncherToolProvider which implements
+	// java.util.spi.ToolProvider which is @since 9).
+	// So in order to resolve this, it can only run on Java 9
+	verifyOSGiProperties {
+		property("-runee", "JavaSE-9")
+	}
 }
diff --git a/junit-platform-console/junit-platform-console.gradle.kts b/junit-platform-console/junit-platform-console.gradle.kts
index 3ebab4d38..c29ff00cd 100644
--- a/junit-platform-console/junit-platform-console.gradle.kts
+++ b/junit-platform-console/junit-platform-console.gradle.kts
@@ -42,4 +42,12 @@ tasks {
 			attributes("Main-Class" to "org.junit.platform.console.ConsoleLauncher")
 		}
 	}
+
+	// This jar contains some Java 9 code
+	// (org.junit.platform.console.ConsoleLauncherToolProvider which implements
+	// java.util.spi.ToolProvider which is @since 9).
+	// So in order to resolve this, it can only run on Java 9
+	verifyOSGiProperties {
+		property("-runee", "JavaSE-9")
+	}
 }
diff --git a/junit-platform-runner/junit-platform-runner.gradle.kts b/junit-platform-runner/junit-platform-runner.gradle.kts
index 31df1f7b1..9b672f5d6 100644
--- a/junit-platform-runner/junit-platform-runner.gradle.kts
+++ b/junit-platform-runner/junit-platform-runner.gradle.kts
@@ -1,3 +1,5 @@
+import aQute.bnd.gradle.BundleTaskConvention;
+
 plugins {
 	`java-library-conventions`
 }
@@ -12,4 +14,19 @@ dependencies {
 
 	api(project(":junit-platform-launcher"))
 	api(project(":junit-platform-suite-api"))
+
+	testRuntimeOnly("org.apache.servicemix.bundles:org.apache.servicemix.bundles.junit:4.12_1")
+}
+
+tasks.jar {
+	withConvention(BundleTaskConvention::class) {
+		bnd("""
+			# Import JUnit4 packages with a version
+			Import-Package: \
+				!org.apiguardian.api,\
+				org.junit.platform.commons.logging;status=INTERNAL,\
+				org.junit.runner.*;version="${Versions.junit4}",\
+				*
+		""")
+	}
 }
diff --git a/junit-platform-suite-api/junit-platform-suite-api.gradle.kts b/junit-platform-suite-api/junit-platform-suite-api.gradle.kts
index 829e3fe0b..09f369bff 100644
--- a/junit-platform-suite-api/junit-platform-suite-api.gradle.kts
+++ b/junit-platform-suite-api/junit-platform-suite-api.gradle.kts
@@ -8,4 +8,6 @@ dependencies {
 	api(platform(project(":junit-bom")))
 
 	api("org.apiguardian:apiguardian-api:${Versions.apiGuardian}")
+
+	testRuntimeOnly(project(":junit-platform-commons"))
 }
diff --git a/junit-vintage-engine/junit-vintage-engine.gradle.kts b/junit-vintage-engine/junit-vintage-engine.gradle.kts
index f22f2fcd8..2765f7af8 100644
--- a/junit-vintage-engine/junit-vintage-engine.gradle.kts
+++ b/junit-vintage-engine/junit-vintage-engine.gradle.kts
@@ -1,3 +1,5 @@
+import aQute.bnd.gradle.BundleTaskConvention;
+
 plugins {
 	`java-library-conventions`
 }
@@ -21,6 +23,8 @@ dependencies {
 	testImplementation(project(":junit-platform-runner"))
 	testImplementation(project(":junit-platform-testkit"))
 	junit_4_13("junit:junit:4.13-rc-1")
+
+	testRuntimeOnly("org.apache.servicemix.bundles:org.apache.servicemix.bundles.junit:4.12_1")
 }
 
 tasks {
@@ -32,3 +36,21 @@ tasks {
 		dependsOn(test_4_13)
 	}
 }
+
+tasks.jar {
+	withConvention(BundleTaskConvention::class) {
+		bnd("""
+			# Import JUnit4 packages with a version
+			Import-Package: \
+				!org.apiguardian.api,\
+				junit.runner;version="${Versions.junit4}",\
+				org.junit;version="${Versions.junit4}",\
+				org.junit.experimental.categories;version="${Versions.junit4}",\
+				org.junit.internal.builders;version="${Versions.junit4}",\
+				org.junit.platform.commons.logging;status=INTERNAL,\
+				org.junit.runner.*;version="${Versions.junit4}",\
+				org.junit.runners.model;version="${Versions.junit4}",\
+				*
+		""")
+	}
+}
diff --git a/platform-tooling-support-tests/platform-tooling-support-tests.gradle.kts b/platform-tooling-support-tests/platform-tooling-support-tests.gradle.kts
index c51f14974..c23047498 100644
--- a/platform-tooling-support-tests/platform-tooling-support-tests.gradle.kts
+++ b/platform-tooling-support-tests/platform-tooling-support-tests.gradle.kts
@@ -26,6 +26,9 @@ dependencies {
 		because("it provides convenience methods to handle process output")
 		exclude(group = "org.junit.platform", module = "junit-platform-launcher")
 	}
+	testImplementation("biz.aQute.bnd:biz.aQute.bndlib:${Versions.bnd}") {
+		because("parsing OSGi metadata")
+	}
 	testRuntimeOnly("com.tngtech.archunit:archunit-junit5-engine:${Versions.archunit}") {
 		because("contains the ArchUnit TestEngine implementation")
 	}
diff --git a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/ManifestTests.java b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/ManifestTests.java
index 8e6b73129..47decdaad 100644
--- a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/ManifestTests.java
+++ b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/ManifestTests.java
@@ -44,6 +44,10 @@ class ManifestTests {
 			assertValue(attributes, "Implementation-Version", version);
 			assertValue(attributes, "Implementation-Vendor", "junit.org");
 			assertValue(attributes, "Automatic-Module-Name", null);
+			assertValue(attributes, "Bundle-ManifestVersion", "2");
+			assertValue(attributes, "Bundle-SymbolicName", module);
+			assertValue(attributes, "Bundle-Version",
+				aQute.bnd.version.MavenVersion.parseMavenString(version).getOSGiVersion().toString());
 			switch (module) {
 				case "junit-platform-commons":
 					assertValue(attributes, "Multi-Release", "true");
