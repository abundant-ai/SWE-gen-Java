diff --git a/kotlin/codegen/pom.xml b/kotlin/codegen/pom.xml
index 64a4a07d..f2c5af0a 100644
--- a/kotlin/codegen/pom.xml
+++ b/kotlin/codegen/pom.xml
@@ -25,7 +25,7 @@
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>kotlinpoet</artifactId>
-      <version>1.0.0-RC1</version>
+      <version>0.7.0</version>
     </dependency>
     <dependency>
       <groupId>com.google.auto</groupId>
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
index 7008b9bc..e58ccc48 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
@@ -25,7 +25,6 @@ import com.squareup.kotlinpoet.KModifier
 import com.squareup.kotlinpoet.NameAllocator
 import com.squareup.kotlinpoet.ParameterSpec
 import com.squareup.kotlinpoet.ParameterizedTypeName
-import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
 import com.squareup.kotlinpoet.PropertySpec
 import com.squareup.kotlinpoet.TypeSpec
 import com.squareup.kotlinpoet.TypeVariableName
@@ -55,7 +54,7 @@ internal class AdapterGenerator(
   private val typeVariables = target.typeVariables
 
   private val nameAllocator = NameAllocator()
-  private val adapterName = "${className.simpleNames.joinToString(separator = "_")}JsonAdapter"
+  private val adapterName = "${className.simpleNames().joinToString(separator = "_")}JsonAdapter"
   private val originalTypeName = target.element.asType().asTypeName()
 
   private val moshiParam = ParameterSpec.builder(
@@ -63,7 +62,7 @@ internal class AdapterGenerator(
       Moshi::class).build()
   private val typesParam = ParameterSpec.builder(
       nameAllocator.newName("types"),
-      ARRAY.parameterizedBy(Type::class.asTypeName()))
+      ParameterizedTypeName.get(ARRAY, Type::class.asTypeName()))
       .build()
   private val readerParam = ParameterSpec.builder(
       nameAllocator.newName("reader"),
@@ -77,7 +76,8 @@ internal class AdapterGenerator(
       nameAllocator.newName("value"),
       originalTypeName.asNullable())
       .build()
-  private val jsonAdapterTypeName = JsonAdapter::class.asClassName().parameterizedBy(originalTypeName)
+  private val jsonAdapterTypeName = ParameterizedTypeName.get(
+      JsonAdapter::class.asClassName(), originalTypeName)
 
   // selectName() API setup
   private val optionsProperty = PropertySpec.builder(
@@ -92,7 +92,7 @@ internal class AdapterGenerator(
       property.allocateNames(nameAllocator)
     }
 
-    val result = FileSpec.builder(className.packageName, adapterName)
+    val result = FileSpec.builder(className.packageName(), adapterName)
     result.addComment("Code generated by moshi-kotlin-codegen. Do not edit.")
     companionObjectName?.let {
       result.addFunction(generateJsonAdapterFun(it))
@@ -161,7 +161,7 @@ internal class AdapterGenerator(
         .addModifiers(KModifier.OVERRIDE)
         .returns(String::class)
         .addStatement("return %S",
-            "GeneratedJsonAdapter(${originalTypeName.rawType().simpleNames.joinToString(".")})")
+            "GeneratedJsonAdapter(${originalTypeName.rawType().simpleNames().joinToString(".")})")
         .build()
   }
 
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
index c28353bb..4343b8e7 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
@@ -24,12 +24,10 @@ import com.squareup.kotlinpoet.KModifier
 import com.squareup.kotlinpoet.NameAllocator
 import com.squareup.kotlinpoet.ParameterSpec
 import com.squareup.kotlinpoet.ParameterizedTypeName
-import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
 import com.squareup.kotlinpoet.PropertySpec
 import com.squareup.kotlinpoet.TypeName
 import com.squareup.kotlinpoet.TypeVariableName
 import com.squareup.kotlinpoet.WildcardTypeName
-import com.squareup.kotlinpoet.asClassName
 import com.squareup.kotlinpoet.asTypeName
 import com.squareup.moshi.JsonAdapter
 import com.squareup.moshi.Types
@@ -76,7 +74,8 @@ internal data class DelegateKey(
     val adapterName = nameAllocator.newName(
         "${type.toVariableName().decapitalize()}${qualifierNames}Adapter", this)
 
-    val adapterTypeName = JsonAdapter::class.asClassName().parameterizedBy(type)
+    val adapterTypeName = ParameterizedTypeName.get(
+        JsonAdapter::class.asTypeName(), type)
     val qualifiers = jsonQualifiers
     val standardArgs = arrayOf(moshiParameter,
         if (type is ClassName && qualifiers.isEmpty()) {
@@ -115,8 +114,8 @@ private fun List<TypeName>.toVariableNames() = joinToString("") { it.toVariableN
 /** Returns a suggested variable name derived from a type name, like nullableListOfString. */
 private fun TypeName.toVariableName(): String {
   val base = when (this) {
-    is ClassName -> simpleName
-    is ParameterizedTypeName -> rawType.simpleName + "Of" + typeArguments.toVariableNames()
+    is ClassName -> simpleName()
+    is ParameterizedTypeName -> rawType.simpleName() + "Of" + typeArguments.toVariableNames()
     is WildcardTypeName -> (lowerBounds + upperBounds).toVariableNames()
     is TypeVariableName -> name + bounds.toVariableNames()
     else -> throw IllegalArgumentException("Unrecognized type! $this")
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt
index cd521b48..eedd2f88 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt
@@ -204,19 +204,13 @@ internal data class TargetType(
 
     private fun genericTypeNames(proto: Class, nameResolver: NameResolver): List<TypeVariableName> {
       return proto.typeParameterList.map {
-        val possibleBounds = it.upperBoundList
-            .map { it.asTypeName(nameResolver, proto::getTypeParameter, false) }
-        val typeVar = if (possibleBounds.isEmpty()) {
-          TypeVariableName(
-              name = nameResolver.getString(it.name),
-              variance = it.varianceModifier)
-        } else {
         TypeVariableName(
             name = nameResolver.getString(it.name),
-            bounds = *possibleBounds.toTypedArray(),
+            bounds = *(it.upperBoundList
+                .map { it.asTypeName(nameResolver, proto::getTypeParameter, false) }
+                .toTypedArray()),
             variance = it.varianceModifier)
-        }
-        return@map typeVar.reified(it.reified)
+            .reified(it.reified)
       }
     }
 
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TypeResolver.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TypeResolver.kt
index 579d7b52..1d580ccc 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TypeResolver.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TypeResolver.kt
@@ -20,7 +20,6 @@ import com.squareup.kotlinpoet.ParameterizedTypeName
 import com.squareup.kotlinpoet.TypeName
 import com.squareup.kotlinpoet.TypeVariableName
 import com.squareup.kotlinpoet.WildcardTypeName
-import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
 
 /**
  * Resolves type parameters against a type declaration. Use this to fill in type variables with
@@ -34,7 +33,8 @@ open class TypeResolver {
       is ClassName -> typeName
 
       is ParameterizedTypeName -> {
-            typeName.rawType.parameterizedBy(*(typeName.typeArguments.map { resolve(it) }.toTypedArray()))
+        ParameterizedTypeName.get(
+            typeName.rawType, *(typeName.typeArguments.map { resolve(it) }.toTypedArray()))
             .asNullableIf(typeName.nullable)
       }
 
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
index 8b20a032..f224e323 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
@@ -18,7 +18,7 @@ package com.squareup.moshi.kotlin.codegen
 import com.squareup.kotlinpoet.ANY
 import com.squareup.kotlinpoet.ClassName
 import com.squareup.kotlinpoet.KModifier
-import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
+import com.squareup.kotlinpoet.ParameterizedTypeName
 import com.squareup.kotlinpoet.TypeName
 import com.squareup.kotlinpoet.TypeVariableName
 import com.squareup.kotlinpoet.WildcardTypeName
@@ -31,20 +31,15 @@ internal fun TypeParameter.asTypeName(
   nameResolver: NameResolver,
   getTypeParameter: (index: Int) -> TypeParameter,
   resolveAliases: Boolean = false
-): TypeVariableName {
-  val possibleBounds = upperBoundList.map {
-    it.asTypeName(nameResolver, getTypeParameter, resolveAliases)
-  }
-  return if (possibleBounds.isEmpty()) {
-    TypeVariableName(
-        name = nameResolver.getString(name),
-        variance = variance.asKModifier())
-  } else {
-    TypeVariableName(
-        name = nameResolver.getString(name),
-        bounds = *possibleBounds.toTypedArray(),
-        variance = variance.asKModifier())
-  }
+): TypeName {
+  return TypeVariableName(
+      name = nameResolver.getString(name),
+      bounds = *(upperBoundList.map {
+        it.asTypeName(nameResolver, getTypeParameter, resolveAliases)
+      }
+          .toTypedArray()),
+      variance = variance.asKModifier()
+  )
 }
 
 internal fun TypeParameter.Variance.asKModifier(): KModifier? {
@@ -117,16 +112,16 @@ internal fun Type.asTypeName(
                       WildcardTypeName.subtypeOf(argumentTypeName)
                     }
                   }
-                  Type.Argument.Projection.STAR -> WildcardTypeName.STAR
+                  Type.Argument.Projection.STAR -> WildcardTypeName.subtypeOf(ANY)
                   Type.Argument.Projection.INV -> TODO("INV projection is unsupported")
                 }
               } ?: argumentTypeName
             }
       } else {
-        WildcardTypeName.STAR
+        WildcardTypeName.subtypeOf(ANY)
       }
     }.toTypedArray()
-    typeName = (typeName as ClassName).parameterizedBy(*remappedArgs)
+    typeName = ParameterizedTypeName.get(typeName as ClassName, *remappedArgs)
   }
 
   return typeName.asNullableIf(nullable)
diff --git a/kotlin/codegen/src/test/java/com/squareup/moshi/kotlin/codegen/TypeResolverTest.kt b/kotlin/codegen/src/test/java/com/squareup/moshi/kotlin/codegen/TypeResolverTest.kt
index e6290b0b..b4985a17 100644
--- a/kotlin/codegen/src/test/java/com/squareup/moshi/kotlin/codegen/TypeResolverTest.kt
+++ b/kotlin/codegen/src/test/java/com/squareup/moshi/kotlin/codegen/TypeResolverTest.kt
@@ -16,9 +16,10 @@
 package com.squareup.moshi.kotlin.codegen
 
 import com.google.common.truth.Truth.assertThat
-import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.plusParameter
+import com.squareup.kotlinpoet.ParameterizedTypeName
 import com.squareup.kotlinpoet.WildcardTypeName
 import com.squareup.kotlinpoet.asClassName
+import com.squareup.moshi.kotlin.codegen.TypeResolver
 import org.junit.Test
 
 class TypeResolverTest {
@@ -31,7 +32,9 @@ class TypeResolverTest {
 
   @Test
   fun ensureParameterizedNullabilityIsPreserved() {
-    val nullableTypeName = List::class.plusParameter(String::class)
+    val nullableTypeName = ParameterizedTypeName.get(
+        List::class.asClassName(),
+        String::class.asClassName())
         .asNullable()
 
     assertThat(resolver.resolve(nullableTypeName).nullable).isTrue()
