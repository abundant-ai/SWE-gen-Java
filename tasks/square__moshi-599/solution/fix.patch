diff --git a/kotlin/codegen/pom.xml b/kotlin/codegen/pom.xml
index f2c5af0a..64a4a07d 100644
--- a/kotlin/codegen/pom.xml
+++ b/kotlin/codegen/pom.xml
@@ -25,7 +25,7 @@
     <dependency>
       <groupId>com.squareup</groupId>
       <artifactId>kotlinpoet</artifactId>
-      <version>0.7.0</version>
+      <version>1.0.0-RC1</version>
     </dependency>
     <dependency>
       <groupId>com.google.auto</groupId>
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
index e58ccc48..7008b9bc 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/AdapterGenerator.kt
@@ -25,6 +25,7 @@ import com.squareup.kotlinpoet.KModifier
 import com.squareup.kotlinpoet.NameAllocator
 import com.squareup.kotlinpoet.ParameterSpec
 import com.squareup.kotlinpoet.ParameterizedTypeName
+import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
 import com.squareup.kotlinpoet.PropertySpec
 import com.squareup.kotlinpoet.TypeSpec
 import com.squareup.kotlinpoet.TypeVariableName
@@ -54,7 +55,7 @@ internal class AdapterGenerator(
   private val typeVariables = target.typeVariables
 
   private val nameAllocator = NameAllocator()
-  private val adapterName = "${className.simpleNames().joinToString(separator = "_")}JsonAdapter"
+  private val adapterName = "${className.simpleNames.joinToString(separator = "_")}JsonAdapter"
   private val originalTypeName = target.element.asType().asTypeName()
 
   private val moshiParam = ParameterSpec.builder(
@@ -62,7 +63,7 @@ internal class AdapterGenerator(
       Moshi::class).build()
   private val typesParam = ParameterSpec.builder(
       nameAllocator.newName("types"),
-      ParameterizedTypeName.get(ARRAY, Type::class.asTypeName()))
+      ARRAY.parameterizedBy(Type::class.asTypeName()))
       .build()
   private val readerParam = ParameterSpec.builder(
       nameAllocator.newName("reader"),
@@ -76,8 +77,7 @@ internal class AdapterGenerator(
       nameAllocator.newName("value"),
       originalTypeName.asNullable())
       .build()
-  private val jsonAdapterTypeName = ParameterizedTypeName.get(
-      JsonAdapter::class.asClassName(), originalTypeName)
+  private val jsonAdapterTypeName = JsonAdapter::class.asClassName().parameterizedBy(originalTypeName)
 
   // selectName() API setup
   private val optionsProperty = PropertySpec.builder(
@@ -92,7 +92,7 @@ internal class AdapterGenerator(
       property.allocateNames(nameAllocator)
     }
 
-    val result = FileSpec.builder(className.packageName(), adapterName)
+    val result = FileSpec.builder(className.packageName, adapterName)
     result.addComment("Code generated by moshi-kotlin-codegen. Do not edit.")
     companionObjectName?.let {
       result.addFunction(generateJsonAdapterFun(it))
@@ -161,7 +161,7 @@ internal class AdapterGenerator(
         .addModifiers(KModifier.OVERRIDE)
         .returns(String::class)
         .addStatement("return %S",
-            "GeneratedJsonAdapter(${originalTypeName.rawType().simpleNames().joinToString(".")})")
+            "GeneratedJsonAdapter(${originalTypeName.rawType().simpleNames.joinToString(".")})")
         .build()
   }
 
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
index 4343b8e7..c28353bb 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/DelegateKey.kt
@@ -24,10 +24,12 @@ import com.squareup.kotlinpoet.KModifier
 import com.squareup.kotlinpoet.NameAllocator
 import com.squareup.kotlinpoet.ParameterSpec
 import com.squareup.kotlinpoet.ParameterizedTypeName
+import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
 import com.squareup.kotlinpoet.PropertySpec
 import com.squareup.kotlinpoet.TypeName
 import com.squareup.kotlinpoet.TypeVariableName
 import com.squareup.kotlinpoet.WildcardTypeName
+import com.squareup.kotlinpoet.asClassName
 import com.squareup.kotlinpoet.asTypeName
 import com.squareup.moshi.JsonAdapter
 import com.squareup.moshi.Types
@@ -74,8 +76,7 @@ internal data class DelegateKey(
     val adapterName = nameAllocator.newName(
         "${type.toVariableName().decapitalize()}${qualifierNames}Adapter", this)
 
-    val adapterTypeName = ParameterizedTypeName.get(
-        JsonAdapter::class.asTypeName(), type)
+    val adapterTypeName = JsonAdapter::class.asClassName().parameterizedBy(type)
     val qualifiers = jsonQualifiers
     val standardArgs = arrayOf(moshiParameter,
         if (type is ClassName && qualifiers.isEmpty()) {
@@ -114,8 +115,8 @@ private fun List<TypeName>.toVariableNames() = joinToString("") { it.toVariableN
 /** Returns a suggested variable name derived from a type name, like nullableListOfString. */
 private fun TypeName.toVariableName(): String {
   val base = when (this) {
-    is ClassName -> simpleName()
-    is ParameterizedTypeName -> rawType.simpleName() + "Of" + typeArguments.toVariableNames()
+    is ClassName -> simpleName
+    is ParameterizedTypeName -> rawType.simpleName + "Of" + typeArguments.toVariableNames()
     is WildcardTypeName -> (lowerBounds + upperBounds).toVariableNames()
     is TypeVariableName -> name + bounds.toVariableNames()
     else -> throw IllegalArgumentException("Unrecognized type! $this")
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt
index eedd2f88..cd521b48 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt
@@ -204,13 +204,19 @@ internal data class TargetType(
 
     private fun genericTypeNames(proto: Class, nameResolver: NameResolver): List<TypeVariableName> {
       return proto.typeParameterList.map {
+        val possibleBounds = it.upperBoundList
+            .map { it.asTypeName(nameResolver, proto::getTypeParameter, false) }
+        val typeVar = if (possibleBounds.isEmpty()) {
+          TypeVariableName(
+              name = nameResolver.getString(it.name),
+              variance = it.varianceModifier)
+        } else {
         TypeVariableName(
             name = nameResolver.getString(it.name),
-            bounds = *(it.upperBoundList
-                .map { it.asTypeName(nameResolver, proto::getTypeParameter, false) }
-                .toTypedArray()),
+            bounds = *possibleBounds.toTypedArray(),
             variance = it.varianceModifier)
-            .reified(it.reified)
+        }
+        return@map typeVar.reified(it.reified)
       }
     }
 
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TypeResolver.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TypeResolver.kt
index 1d580ccc..579d7b52 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TypeResolver.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TypeResolver.kt
@@ -20,6 +20,7 @@ import com.squareup.kotlinpoet.ParameterizedTypeName
 import com.squareup.kotlinpoet.TypeName
 import com.squareup.kotlinpoet.TypeVariableName
 import com.squareup.kotlinpoet.WildcardTypeName
+import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
 
 /**
  * Resolves type parameters against a type declaration. Use this to fill in type variables with
@@ -33,8 +34,7 @@ open class TypeResolver {
       is ClassName -> typeName
 
       is ParameterizedTypeName -> {
-        ParameterizedTypeName.get(
-            typeName.rawType, *(typeName.typeArguments.map { resolve(it) }.toTypedArray()))
+            typeName.rawType.parameterizedBy(*(typeName.typeArguments.map { resolve(it) }.toTypedArray()))
             .asNullableIf(typeName.nullable)
       }
 
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
index f224e323..8b20a032 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
@@ -18,7 +18,7 @@ package com.squareup.moshi.kotlin.codegen
 import com.squareup.kotlinpoet.ANY
 import com.squareup.kotlinpoet.ClassName
 import com.squareup.kotlinpoet.KModifier
-import com.squareup.kotlinpoet.ParameterizedTypeName
+import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
 import com.squareup.kotlinpoet.TypeName
 import com.squareup.kotlinpoet.TypeVariableName
 import com.squareup.kotlinpoet.WildcardTypeName
@@ -31,15 +31,20 @@ internal fun TypeParameter.asTypeName(
   nameResolver: NameResolver,
   getTypeParameter: (index: Int) -> TypeParameter,
   resolveAliases: Boolean = false
-): TypeName {
-  return TypeVariableName(
-      name = nameResolver.getString(name),
-      bounds = *(upperBoundList.map {
-        it.asTypeName(nameResolver, getTypeParameter, resolveAliases)
-      }
-          .toTypedArray()),
-      variance = variance.asKModifier()
-  )
+): TypeVariableName {
+  val possibleBounds = upperBoundList.map {
+    it.asTypeName(nameResolver, getTypeParameter, resolveAliases)
+  }
+  return if (possibleBounds.isEmpty()) {
+    TypeVariableName(
+        name = nameResolver.getString(name),
+        variance = variance.asKModifier())
+  } else {
+    TypeVariableName(
+        name = nameResolver.getString(name),
+        bounds = *possibleBounds.toTypedArray(),
+        variance = variance.asKModifier())
+  }
 }
 
 internal fun TypeParameter.Variance.asKModifier(): KModifier? {
@@ -112,16 +117,16 @@ internal fun Type.asTypeName(
                       WildcardTypeName.subtypeOf(argumentTypeName)
                     }
                   }
-                  Type.Argument.Projection.STAR -> WildcardTypeName.subtypeOf(ANY)
+                  Type.Argument.Projection.STAR -> WildcardTypeName.STAR
                   Type.Argument.Projection.INV -> TODO("INV projection is unsupported")
                 }
               } ?: argumentTypeName
             }
       } else {
-        WildcardTypeName.subtypeOf(ANY)
+        WildcardTypeName.STAR
       }
     }.toTypedArray()
-    typeName = ParameterizedTypeName.get(typeName as ClassName, *remappedArgs)
+    typeName = (typeName as ClassName).parameterizedBy(*remappedArgs)
   }
 
   return typeName.asNullableIf(nullable)
