diff --git a/core/src/main/scala/cats/Foldable.scala b/core/src/main/scala/cats/Foldable.scala
index 190ac117a..0d81c48eb 100644
--- a/core/src/main/scala/cats/Foldable.scala
+++ b/core/src/main/scala/cats/Foldable.scala
@@ -1,10 +1,11 @@
 package cats
 
-import scala.collection.mutable
+import cats.Foldable.sentinel
 import cats.instances.either._
 import cats.kernel.CommutativeMonoid
 import simulacrum.typeclass
-import Foldable.sentinel
+
+import scala.collection.mutable
 
 /**
  * Data structures that can be folded to a summary value.
@@ -594,6 +595,13 @@ object Foldable {
     Eval.always(iterable.iterator).flatMap(loop)
   }
 
+  def iterateRightDefer[G[_]: Defer, A, B](iterable: Iterable[A], lb: G[B])(f: (A, G[B]) => G[B]): G[B] = {
+    def loop(it: Iterator[A]): G[B] =
+      Defer[G].defer(if (it.hasNext) f(it.next(), Defer[G].defer(loop(it))) else Defer[G].defer(lb))
+
+    Defer[G].defer(loop(iterable.iterator))
+  }
+
   /**
    * Isomorphic to
    *
diff --git a/core/src/main/scala/cats/syntax/foldable.scala b/core/src/main/scala/cats/syntax/foldable.scala
index 4929b8ac0..4fdf6f86e 100644
--- a/core/src/main/scala/cats/syntax/foldable.scala
+++ b/core/src/main/scala/cats/syntax/foldable.scala
@@ -331,6 +331,16 @@ final class FoldableOps0[F[_], A](private val fa: F[A]) extends AnyVal {
    */
   def maximumByOption[B: Order](f: A => B)(implicit F: Foldable[F]): Option[A] =
     F.maximumOption(fa)(Order.by(f))
+
+  /**
+   * Implementers are responsible for ensuring they maintain consistency with foldRight; this is not checked by laws on Scala 2.11
+   */
+  def foldRightDefer[G[_]: Defer, B](gb: G[B])(fn: (A, G[B]) => G[B])(implicit F: Foldable[F]): G[B] =
+    Defer[G].defer(
+      F.foldLeft(fa, (z: G[B]) => z)(
+        (acc, elem) => z => Defer[G].defer(acc(fn(elem, z)))
+      )(gb)
+    )
 }
 
 final private[syntax] class FoldableOps1[F[_]](private val F: Foldable[F]) extends AnyVal {
