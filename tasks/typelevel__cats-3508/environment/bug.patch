diff --git a/core/src/main/scala-2.12/cats/evidence/AsSupport.scala b/core/src/main/scala-2.12/cats/evidence/AsSupport.scala
deleted file mode 100644
index cfc719d4e..000000000
--- a/core/src/main/scala-2.12/cats/evidence/AsSupport.scala
+++ /dev/null
@@ -1,12 +0,0 @@
-package cats.evidence
-
-private[evidence] trait AsSupport {
-
-  /**
-   * In 2.13 there is a method on ev that makes this safe.
-   * But lack of this method does not make the cast unsafe
-   * it just makes it not provable without the cast.
-   */
-  @inline implicit def asFromPredef[A, B](implicit ev: A <:< B): A As B =
-    As.refl[A].asInstanceOf[A As B]
-}
diff --git a/core/src/main/scala-2.12/cats/evidence/IsSupport.scala b/core/src/main/scala-2.12/cats/evidence/IsSupport.scala
deleted file mode 100644
index caecd859b..000000000
--- a/core/src/main/scala-2.12/cats/evidence/IsSupport.scala
+++ /dev/null
@@ -1,12 +0,0 @@
-package cats.evidence
-
-private[evidence] trait IsSupport {
-
-  /**
-   * In 2.13 there is a method on ev that makes this safe.
-   * But lack of this method does not make the cast unsafe
-   * it just makes it not provable without the cast.
-   */
-  @inline implicit def isFromPredef[A, B](implicit ev: A =:= B): A Is B =
-    Is.refl[A].asInstanceOf[A Is B]
-}
diff --git a/core/src/main/scala-2.13+/cats/evidence/AsSupport.scala b/core/src/main/scala-2.13+/cats/evidence/AsSupport.scala
deleted file mode 100644
index c2cf58a37..000000000
--- a/core/src/main/scala-2.13+/cats/evidence/AsSupport.scala
+++ /dev/null
@@ -1,10 +0,0 @@
-package cats.evidence
-
-private[evidence] trait AsSupport {
-  @inline implicit def asFromPredef[A, B](implicit ev: A <:< B): A As B = {
-    // we need F to be covariant, and the type lambda loses that
-    // if we write As[A, ?]
-    type F[+Z] = As[A, Z]
-    ev.substituteCo[F](As.refl[A])
-  }
-}
diff --git a/core/src/main/scala-2.13+/cats/evidence/IsSupport.scala b/core/src/main/scala-2.13+/cats/evidence/IsSupport.scala
deleted file mode 100644
index a4d1ce74f..000000000
--- a/core/src/main/scala-2.13+/cats/evidence/IsSupport.scala
+++ /dev/null
@@ -1,6 +0,0 @@
-package cats.evidence
-
-private[evidence] trait IsSupport {
-  @inline implicit def isFromPredef[A, B](implicit ev: A =:= B): A Is B =
-    ev.substituteCo[Is[A, *]](Is.refl[A])
-}
diff --git a/core/src/main/scala/cats/evidence/As.scala b/core/src/main/scala/cats/evidence/As.scala
index ece14025f..b7e9af389 100644
--- a/core/src/main/scala/cats/evidence/As.scala
+++ b/core/src/main/scala/cats/evidence/As.scala
@@ -34,15 +34,6 @@ sealed abstract class As[-A, +B] extends Serializable {
   @inline final def compose[C](that: (C As A)): (C As B) = As.compose(this, that)
 
   @inline final def coerce(a: A): B = As.witness(this)(a)
-
-  /**
-   * A value `A As B` is always sufficient to produce a similar `Predef.<:<`
-   * value.
-   */
-  @inline final def toPredef: A <:< B = {
-    type F[-Z] = <:<[Z, B]
-    substitute[F](implicitly[B <:< B])
-  }
 }
 
 sealed abstract class AsInstances {
@@ -58,7 +49,7 @@ sealed abstract class AsInstances {
   }
 }
 
-object As extends AsInstances with AsSupport {
+object As extends AsInstances {
 
   /**
    * In truth, "all values of `A Is B` are `refl`". `reflAny` is that
@@ -97,11 +88,12 @@ object As extends AsInstances with AsSupport {
 
   /**
    * It can be convenient to convert a <:< value into a `<~<` value.
-   * This is not actually unsafe, but was previously labeled as such out
-   * of an abundance of caution
+   * This is not strictly valid as while it is almost certainly true that
+   * `A <:< B` implies `A <~< B` it is not the case that you can create
+   * evidence of `A <~< B` except via a coercion. Use responsibly.
    */
   def fromPredef[A, B](eq: A <:< B): A As B =
-    asFromPredef(eq)
+    reflAny.asInstanceOf[A As B]
 
   /**
    * We can lift subtyping into any covariant type constructor
diff --git a/core/src/main/scala/cats/evidence/Is.scala b/core/src/main/scala/cats/evidence/Is.scala
index 4bff2ac6d..7446a5e82 100644
--- a/core/src/main/scala/cats/evidence/Is.scala
+++ b/core/src/main/scala/cats/evidence/Is.scala
@@ -62,16 +62,8 @@ abstract class Is[A, B] extends Serializable {
    * A value `A Is B` is always sufficient to produce a similar `Predef.=:=`
    * value.
    */
-  @deprecated("Use toPredef for consistency with As", "2.2.0")
   @inline final def predefEq: A =:= B =
     substitute[=:=[A, *]](implicitly[A =:= A])
-
-  /**
-   * A value `A Is B` is always sufficient to produce a similar `Predef.=:=`
-   * value.
-   */
-  @inline final def toPredef: A =:= B =
-    substitute[=:=[A, *]](implicitly[A =:= A])
 }
 
 sealed abstract class IsInstances {
@@ -86,7 +78,7 @@ sealed abstract class IsInstances {
   }
 }
 
-object Is extends IsInstances with IsSupport {
+object Is extends IsInstances {
 
   /**
    * In truth, "all values of `A Is B` are `refl`". `reflAny` is that
@@ -110,10 +102,11 @@ object Is extends IsInstances with IsSupport {
 
   /**
    * It can be convenient to convert a `Predef.=:=` value into an `Is` value.
-   * This is not actually unsafe, but was previously labeled as such out
-   * of an abundance of caution
+   * This is not strictly valid as while it is almost certainly true that
+   * `A =:= B` implies `A Is B` it is not the case that you can create
+   * evidence of `A Is B` except via a coercion. Use responsibly.
    */
-  @deprecated("use Is.isFromPredef", "2.2.0")
   @inline def unsafeFromPredef[A, B](eq: A =:= B): A Is B =
-    Is.isFromPredef(eq)
+    reflAny.asInstanceOf[A Is B]
+
 }
diff --git a/tests/src/test/scala/cats/tests/AsSuite.scala b/tests/src/test/scala/cats/tests/AsSuite.scala
index a2820cbfb..82cfef919 100644
--- a/tests/src/test/scala/cats/tests/AsSuite.scala
+++ b/tests/src/test/scala/cats/tests/AsSuite.scala
@@ -41,15 +41,6 @@ class AsSuite extends CatsSuite {
     implicitly[String <~< AnyRef]
     implicitly[(String, Int) <~< (AnyRef, Any)]
     implicitly[scala.collection.immutable.List[String] <~< scala.collection.Seq[Any]]
-
-    {
-      trait Foo
-      trait Bar
-      implicit def subFooBar: Foo <:< Bar = implicitly[Foo <:< Foo].asInstanceOf[Foo <:< Bar]
-      // make sure the above is found
-      implicitly[As[Foo, Bar]]
-      val res: Foo <:< Bar = implicitly[As[Foo, Bar]].toPredef
-    }
   }
 
   trait Top {
diff --git a/tests/src/test/scala/cats/tests/IsSuite.scala b/tests/src/test/scala/cats/tests/IsSuite.scala
index 4c18d7575..a17398cfd 100644
--- a/tests/src/test/scala/cats/tests/IsSuite.scala
+++ b/tests/src/test/scala/cats/tests/IsSuite.scala
@@ -28,16 +28,7 @@ class IsSuite extends CatsSuite {
     val flip: Leibniz[Bar, Bar] = lifted.flip
     val lift: Leibniz[List[Bar], List[Bar]] = lifted.lift[List]
     val coerce: Bar = lifted.coerce(new Bar {})
-    val predefEq: =:=[Bar, Bar] = lifted.toPredef
-
-    {
-      trait Foo
-      implicit def eqFooBar: Foo =:= Bar = implicitly[Foo =:= Foo].asInstanceOf[Foo =:= Bar]
-      // make sure the above is found
-      implicitly[Is[Foo, Bar]]
-
-      val res: Foo =:= Bar = implicitly[Is[Foo, Bar]].toPredef
-    }
+    val predefEq: =:=[Bar, Bar] = lifted.predefEq
   }
 
 }
