diff --git a/core/src/main/scala-2.12/cats/evidence/AsSupport.scala b/core/src/main/scala-2.12/cats/evidence/AsSupport.scala
new file mode 100644
index 000000000..cfc719d4e
--- /dev/null
+++ b/core/src/main/scala-2.12/cats/evidence/AsSupport.scala
@@ -0,0 +1,12 @@
+package cats.evidence
+
+private[evidence] trait AsSupport {
+
+  /**
+   * In 2.13 there is a method on ev that makes this safe.
+   * But lack of this method does not make the cast unsafe
+   * it just makes it not provable without the cast.
+   */
+  @inline implicit def asFromPredef[A, B](implicit ev: A <:< B): A As B =
+    As.refl[A].asInstanceOf[A As B]
+}
diff --git a/core/src/main/scala-2.12/cats/evidence/IsSupport.scala b/core/src/main/scala-2.12/cats/evidence/IsSupport.scala
new file mode 100644
index 000000000..caecd859b
--- /dev/null
+++ b/core/src/main/scala-2.12/cats/evidence/IsSupport.scala
@@ -0,0 +1,12 @@
+package cats.evidence
+
+private[evidence] trait IsSupport {
+
+  /**
+   * In 2.13 there is a method on ev that makes this safe.
+   * But lack of this method does not make the cast unsafe
+   * it just makes it not provable without the cast.
+   */
+  @inline implicit def isFromPredef[A, B](implicit ev: A =:= B): A Is B =
+    Is.refl[A].asInstanceOf[A Is B]
+}
diff --git a/core/src/main/scala-2.13+/cats/evidence/AsSupport.scala b/core/src/main/scala-2.13+/cats/evidence/AsSupport.scala
new file mode 100644
index 000000000..c2cf58a37
--- /dev/null
+++ b/core/src/main/scala-2.13+/cats/evidence/AsSupport.scala
@@ -0,0 +1,10 @@
+package cats.evidence
+
+private[evidence] trait AsSupport {
+  @inline implicit def asFromPredef[A, B](implicit ev: A <:< B): A As B = {
+    // we need F to be covariant, and the type lambda loses that
+    // if we write As[A, ?]
+    type F[+Z] = As[A, Z]
+    ev.substituteCo[F](As.refl[A])
+  }
+}
diff --git a/core/src/main/scala-2.13+/cats/evidence/IsSupport.scala b/core/src/main/scala-2.13+/cats/evidence/IsSupport.scala
new file mode 100644
index 000000000..a4d1ce74f
--- /dev/null
+++ b/core/src/main/scala-2.13+/cats/evidence/IsSupport.scala
@@ -0,0 +1,6 @@
+package cats.evidence
+
+private[evidence] trait IsSupport {
+  @inline implicit def isFromPredef[A, B](implicit ev: A =:= B): A Is B =
+    ev.substituteCo[Is[A, *]](Is.refl[A])
+}
diff --git a/core/src/main/scala/cats/evidence/As.scala b/core/src/main/scala/cats/evidence/As.scala
index b7e9af389..ece14025f 100644
--- a/core/src/main/scala/cats/evidence/As.scala
+++ b/core/src/main/scala/cats/evidence/As.scala
@@ -34,6 +34,15 @@ sealed abstract class As[-A, +B] extends Serializable {
   @inline final def compose[C](that: (C As A)): (C As B) = As.compose(this, that)
 
   @inline final def coerce(a: A): B = As.witness(this)(a)
+
+  /**
+   * A value `A As B` is always sufficient to produce a similar `Predef.<:<`
+   * value.
+   */
+  @inline final def toPredef: A <:< B = {
+    type F[-Z] = <:<[Z, B]
+    substitute[F](implicitly[B <:< B])
+  }
 }
 
 sealed abstract class AsInstances {
@@ -49,7 +58,7 @@ sealed abstract class AsInstances {
   }
 }
 
-object As extends AsInstances {
+object As extends AsInstances with AsSupport {
 
   /**
    * In truth, "all values of `A Is B` are `refl`". `reflAny` is that
@@ -88,12 +97,11 @@ object As extends AsInstances {
 
   /**
    * It can be convenient to convert a <:< value into a `<~<` value.
-   * This is not strictly valid as while it is almost certainly true that
-   * `A <:< B` implies `A <~< B` it is not the case that you can create
-   * evidence of `A <~< B` except via a coercion. Use responsibly.
+   * This is not actually unsafe, but was previously labeled as such out
+   * of an abundance of caution
    */
   def fromPredef[A, B](eq: A <:< B): A As B =
-    reflAny.asInstanceOf[A As B]
+    asFromPredef(eq)
 
   /**
    * We can lift subtyping into any covariant type constructor
diff --git a/core/src/main/scala/cats/evidence/Is.scala b/core/src/main/scala/cats/evidence/Is.scala
index 7446a5e82..4bff2ac6d 100644
--- a/core/src/main/scala/cats/evidence/Is.scala
+++ b/core/src/main/scala/cats/evidence/Is.scala
@@ -62,8 +62,16 @@ abstract class Is[A, B] extends Serializable {
    * A value `A Is B` is always sufficient to produce a similar `Predef.=:=`
    * value.
    */
+  @deprecated("Use toPredef for consistency with As", "2.2.0")
   @inline final def predefEq: A =:= B =
     substitute[=:=[A, *]](implicitly[A =:= A])
+
+  /**
+   * A value `A Is B` is always sufficient to produce a similar `Predef.=:=`
+   * value.
+   */
+  @inline final def toPredef: A =:= B =
+    substitute[=:=[A, *]](implicitly[A =:= A])
 }
 
 sealed abstract class IsInstances {
@@ -78,7 +86,7 @@ sealed abstract class IsInstances {
   }
 }
 
-object Is extends IsInstances {
+object Is extends IsInstances with IsSupport {
 
   /**
    * In truth, "all values of `A Is B` are `refl`". `reflAny` is that
@@ -102,11 +110,10 @@ object Is extends IsInstances {
 
   /**
    * It can be convenient to convert a `Predef.=:=` value into an `Is` value.
-   * This is not strictly valid as while it is almost certainly true that
-   * `A =:= B` implies `A Is B` it is not the case that you can create
-   * evidence of `A Is B` except via a coercion. Use responsibly.
+   * This is not actually unsafe, but was previously labeled as such out
+   * of an abundance of caution
    */
+  @deprecated("use Is.isFromPredef", "2.2.0")
   @inline def unsafeFromPredef[A, B](eq: A =:= B): A Is B =
-    reflAny.asInstanceOf[A Is B]
-
+    Is.isFromPredef(eq)
 }
