diff --git a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
index 2b519d3c..4a2621b9 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
@@ -56,20 +56,17 @@ public abstract class JsonAdapter<T> {
   }
 
   /**
-   * Encodes {@code value} as a Java model comprised of maps, lists, strings, numbers, booleans
-   * and nulls.
+   * Encodes {@code value} as a Java value object comprised of maps, lists, strings, numbers,
+   * booleans, and nulls.
    * 
    * <p>Values encoded using {@code value(double)} or {@code value(long)} are modeled with the
    * corresponding boxed type. Values encoded using {@code value(Number)} are modeled as a
    * {@link Long} for boxed integer types ({@link Byte}, {@link Short}, {@link Integer}, and {@link
    * Long}), as a {@link Double} for boxed floating point types ({@link Float} and {@link Double}),
    * and as a {@link BigDecimal} for all other types.
-   *
-   * <p>The returned model is equivalent to calling {@link #toJson} to encode {@code value}
-   * as a JSON string, and then parsing that string without any particular type.
    */
-  public final Object toJsonObject(T value) {
-    ObjectJsonWriter writer = new ObjectJsonWriter();
+  public final Object toJsonValue(T value) {
+    JsonValueWriter writer = new JsonValueWriter();
     try {
       toJson(writer, value);
       return writer.root();
@@ -79,12 +76,11 @@ public abstract class JsonAdapter<T> {
   }
 
   /**
-   * Decodes a Java value from {@code object}, which must be a Java model comprised of maps, lists,
-   * strings, numbers, booleans and nulls. This is equivalent to encoding {@code object} to a JSON
-   * string, and then calling {@link #fromJson} to decode that string.
+   * Decodes a Java value object from {@code value}, which must be comprised of maps, lists,
+   * strings, numbers, booleans and nulls.
    */
-  public final T fromJsonObject(Object object) {
-    ObjectJsonReader reader = new ObjectJsonReader(object);
+  public final T fromJsonValue(Object value) {
+    JsonValueReader reader = new JsonValueReader(value);
     try {
       return fromJson(reader);
     } catch (IOException e) {
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonReader.java b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
index 0ff01a70..e4b1142a 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonReader.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonReader.java
@@ -185,9 +185,9 @@ public abstract class JsonReader implements Closeable {
   /** True to throw a {@link JsonDataException} on any attempt to call {@link #skipValue()}. */
   boolean failOnUnknown;
 
-  /** Returns a new instance that reads a JSON-encoded stream from {@code source}. */
+  /** Returns a new instance that reads UTF-8 encoded JSON from {@code source}. */
   public static JsonReader of(BufferedSource source) {
-    return new BufferedSourceJsonReader(source);
+    return new JsonUtf8Reader(source);
   }
 
   JsonReader() {
@@ -422,7 +422,7 @@ public abstract class JsonReader implements Closeable {
         ByteString[] result = new ByteString[strings.length];
         Buffer buffer = new Buffer();
         for (int i = 0; i < strings.length; i++) {
-          BufferedSinkJsonWriter.string(buffer, strings[i]);
+          JsonUt8Writer.string(buffer, strings[i]);
           buffer.readByte(); // Skip the leading double quote (but leave the trailing one).
           result[i] = buffer.readByteString();
         }
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonUt8Writer.java b/moshi/src/main/java/com/squareup/moshi/JsonUt8Writer.java
new file mode 100644
index 00000000..7dd59ab9
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/JsonUt8Writer.java
@@ -0,0 +1,370 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.io.IOException;
+import okio.BufferedSink;
+import okio.Sink;
+
+import static com.squareup.moshi.JsonScope.DANGLING_NAME;
+import static com.squareup.moshi.JsonScope.EMPTY_ARRAY;
+import static com.squareup.moshi.JsonScope.EMPTY_DOCUMENT;
+import static com.squareup.moshi.JsonScope.EMPTY_OBJECT;
+import static com.squareup.moshi.JsonScope.NONEMPTY_ARRAY;
+import static com.squareup.moshi.JsonScope.NONEMPTY_DOCUMENT;
+import static com.squareup.moshi.JsonScope.NONEMPTY_OBJECT;
+
+final class JsonUt8Writer extends JsonWriter {
+
+  /*
+   * From RFC 7159, "All Unicode characters may be placed within the
+   * quotation marks except for the characters that must be escaped:
+   * quotation mark, reverse solidus, and the control characters
+   * (U+0000 through U+001F)."
+   *
+   * We also escape '\u2028' and '\u2029', which JavaScript interprets as
+   * newline characters. This prevents eval() from failing with a syntax
+   * error. http://code.google.com/p/google-gson/issues/detail?id=341
+   */
+  private static final String[] REPLACEMENT_CHARS;
+  static {
+    REPLACEMENT_CHARS = new String[128];
+    for (int i = 0; i <= 0x1f; i++) {
+      REPLACEMENT_CHARS[i] = String.format("\\u%04x", (int) i);
+    }
+    REPLACEMENT_CHARS['"'] = "\\\"";
+    REPLACEMENT_CHARS['\\'] = "\\\\";
+    REPLACEMENT_CHARS['\t'] = "\\t";
+    REPLACEMENT_CHARS['\b'] = "\\b";
+    REPLACEMENT_CHARS['\n'] = "\\n";
+    REPLACEMENT_CHARS['\r'] = "\\r";
+    REPLACEMENT_CHARS['\f'] = "\\f";
+  }
+
+  /** The output data, containing at most one top-level array or object. */
+  private final BufferedSink sink;
+
+  /** The name/value separator; either ":" or ": ". */
+  private String separator = ":";
+
+  private String deferredName;
+
+  JsonUt8Writer(BufferedSink sink) {
+    if (sink == null) {
+      throw new NullPointerException("sink == null");
+    }
+    this.sink = sink;
+    pushScope(EMPTY_DOCUMENT);
+  }
+
+  @Override public void setIndent(String indent) {
+    super.setIndent(indent);
+    this.separator = !indent.isEmpty() ? ": " : ":";
+  }
+
+  @Override public JsonWriter beginArray() throws IOException {
+    writeDeferredName();
+    return open(EMPTY_ARRAY, "[");
+  }
+
+  @Override public JsonWriter endArray() throws IOException {
+    return close(EMPTY_ARRAY, NONEMPTY_ARRAY, "]");
+  }
+
+  @Override public JsonWriter beginObject() throws IOException {
+    writeDeferredName();
+    return open(EMPTY_OBJECT, "{");
+  }
+
+  @Override public JsonWriter endObject() throws IOException {
+    promoteValueToName = false;
+    return close(EMPTY_OBJECT, NONEMPTY_OBJECT, "}");
+  }
+
+  /**
+   * Enters a new scope by appending any necessary whitespace and the given
+   * bracket.
+   */
+  private JsonWriter open(int empty, String openBracket) throws IOException {
+    beforeValue();
+    pushScope(empty);
+    pathIndices[stackSize - 1] = 0;
+    sink.writeUtf8(openBracket);
+    return this;
+  }
+
+  /**
+   * Closes the current scope by appending any necessary whitespace and the
+   * given bracket.
+   */
+  private JsonWriter close(int empty, int nonempty, String closeBracket) throws IOException {
+    int context = peekScope();
+    if (context != nonempty && context != empty) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    if (deferredName != null) {
+      throw new IllegalStateException("Dangling name: " + deferredName);
+    }
+
+    stackSize--;
+    pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
+    pathIndices[stackSize - 1]++;
+    if (context == nonempty) {
+      newline();
+    }
+    sink.writeUtf8(closeBracket);
+    return this;
+  }
+
+  @Override public JsonWriter name(String name) throws IOException {
+    if (name == null) {
+      throw new NullPointerException("name == null");
+    }
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    if (deferredName != null) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    deferredName = name;
+    pathNames[stackSize - 1] = name;
+    promoteValueToName = false;
+    return this;
+  }
+
+  private void writeDeferredName() throws IOException {
+    if (deferredName != null) {
+      beforeName();
+      string(sink, deferredName);
+      deferredName = null;
+    }
+  }
+
+  @Override public JsonWriter value(String value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+    if (promoteValueToName) {
+      return name(value);
+    }
+    writeDeferredName();
+    beforeValue();
+    string(sink, value);
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter nullValue() throws IOException {
+    if (deferredName != null) {
+      if (serializeNulls) {
+        writeDeferredName();
+      } else {
+        deferredName = null;
+        return this; // skip the name and the value
+      }
+    }
+    beforeValue();
+    sink.writeUtf8("null");
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter value(boolean value) throws IOException {
+    writeDeferredName();
+    beforeValue();
+    sink.writeUtf8(value ? "true" : "false");
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter value(Boolean value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+    return value(value.booleanValue());
+  }
+
+  @Override public JsonWriter value(double value) throws IOException {
+    if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+    if (promoteValueToName) {
+      return name(Double.toString(value));
+    }
+    writeDeferredName();
+    beforeValue();
+    sink.writeUtf8(Double.toString(value));
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter value(long value) throws IOException {
+    if (promoteValueToName) {
+      return name(Long.toString(value));
+    }
+    writeDeferredName();
+    beforeValue();
+    sink.writeUtf8(Long.toString(value));
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter value(Number value) throws IOException {
+    if (value == null) {
+      return nullValue();
+    }
+
+    String string = value.toString();
+    if (!lenient
+        && (string.equals("-Infinity") || string.equals("Infinity") || string.equals("NaN"))) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+    if (promoteValueToName) {
+      return name(string);
+    }
+    writeDeferredName();
+    beforeValue();
+    sink.writeUtf8(string);
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  /**
+   * Ensures all buffered data is written to the underlying {@link Sink}
+   * and flushes that writer.
+   */
+  @Override public void flush() throws IOException {
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    sink.flush();
+  }
+
+  /**
+   * Flushes and closes this writer and the underlying {@link Sink}.
+   *
+   * @throws JsonDataException if the JSON document is incomplete.
+   */
+  @Override public void close() throws IOException {
+    sink.close();
+
+    int size = stackSize;
+    if (size > 1 || size == 1 && scopes[size - 1] != NONEMPTY_DOCUMENT) {
+      throw new IOException("Incomplete document");
+    }
+    stackSize = 0;
+  }
+
+  /**
+   * Writes {@code value} as a string literal to {@code sink}. This wraps the value in double quotes
+   * and escapes those characters that require it.
+   */
+  static void string(BufferedSink sink, String value) throws IOException {
+    String[] replacements = REPLACEMENT_CHARS;
+    sink.writeByte('"');
+    int last = 0;
+    int length = value.length();
+    for (int i = 0; i < length; i++) {
+      char c = value.charAt(i);
+      String replacement;
+      if (c < 128) {
+        replacement = replacements[c];
+        if (replacement == null) {
+          continue;
+        }
+      } else if (c == '\u2028') {
+        replacement = "\\u2028";
+      } else if (c == '\u2029') {
+        replacement = "\\u2029";
+      } else {
+        continue;
+      }
+      if (last < i) {
+        sink.writeUtf8(value, last, i);
+      }
+      sink.writeUtf8(replacement);
+      last = i + 1;
+    }
+    if (last < length) {
+      sink.writeUtf8(value, last, length);
+    }
+    sink.writeByte('"');
+  }
+
+  private void newline() throws IOException {
+    if (indent == null) {
+      return;
+    }
+
+    sink.writeByte('\n');
+    for (int i = 1, size = stackSize; i < size; i++) {
+      sink.writeUtf8(indent);
+    }
+  }
+
+  /**
+   * Inserts any necessary separators and whitespace before a name. Also
+   * adjusts the stack to expect the name's value.
+   */
+  private void beforeName() throws IOException {
+    int context = peekScope();
+    if (context == NONEMPTY_OBJECT) { // first in object
+      sink.writeByte(',');
+    } else if (context != EMPTY_OBJECT) { // not in an object!
+      throw new IllegalStateException("Nesting problem.");
+    }
+    newline();
+    replaceTop(DANGLING_NAME);
+  }
+
+  /**
+   * Inserts any necessary separators and whitespace before a literal value,
+   * inline array, or inline object. Also adjusts the stack to expect either a
+   * closing bracket or another element.
+   */
+  @SuppressWarnings("fallthrough")
+  private void beforeValue() throws IOException {
+    switch (peekScope()) {
+      case NONEMPTY_DOCUMENT:
+        if (!lenient) {
+          throw new IllegalStateException(
+              "JSON must have only one top-level value.");
+        }
+        // fall-through
+      case EMPTY_DOCUMENT: // first in document
+        replaceTop(NONEMPTY_DOCUMENT);
+        break;
+
+      case EMPTY_ARRAY: // first in array
+        replaceTop(NONEMPTY_ARRAY);
+        newline();
+        break;
+
+      case NONEMPTY_ARRAY: // another in array
+        sink.writeByte(',');
+        newline();
+        break;
+
+      case DANGLING_NAME: // value for name
+        sink.writeUtf8(separator);
+        replaceTop(NONEMPTY_OBJECT);
+        break;
+
+      default:
+        throw new IllegalStateException("Nesting problem.");
+    }
+  }
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
new file mode 100644
index 00000000..abe56434
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/JsonUtf8Reader.java
@@ -0,0 +1,1115 @@
+/*
+ * Copyright (C) 2010 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.math.BigDecimal;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+
+final class JsonUtf8Reader extends JsonReader {
+  private static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;
+
+  private static final ByteString SINGLE_QUOTE_OR_SLASH = ByteString.encodeUtf8("'\\");
+  private static final ByteString DOUBLE_QUOTE_OR_SLASH = ByteString.encodeUtf8("\"\\");
+  private static final ByteString UNQUOTED_STRING_TERMINALS
+      = ByteString.encodeUtf8("{}[]:, \n\t\r\f/\\;#=");
+  private static final ByteString LINEFEED_OR_CARRIAGE_RETURN = ByteString.encodeUtf8("\n\r");
+
+  private static final int PEEKED_NONE = 0;
+  private static final int PEEKED_BEGIN_OBJECT = 1;
+  private static final int PEEKED_END_OBJECT = 2;
+  private static final int PEEKED_BEGIN_ARRAY = 3;
+  private static final int PEEKED_END_ARRAY = 4;
+  private static final int PEEKED_TRUE = 5;
+  private static final int PEEKED_FALSE = 6;
+  private static final int PEEKED_NULL = 7;
+  private static final int PEEKED_SINGLE_QUOTED = 8;
+  private static final int PEEKED_DOUBLE_QUOTED = 9;
+  private static final int PEEKED_UNQUOTED = 10;
+  /** When this is returned, the string value is stored in peekedString. */
+  private static final int PEEKED_BUFFERED = 11;
+  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;
+  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;
+  private static final int PEEKED_UNQUOTED_NAME = 14;
+  private static final int PEEKED_BUFFERED_NAME = 15;
+  /** When this is returned, the integer value is stored in peekedLong. */
+  private static final int PEEKED_LONG = 16;
+  private static final int PEEKED_NUMBER = 17;
+  private static final int PEEKED_EOF = 18;
+
+  /* State machine when parsing numbers */
+  private static final int NUMBER_CHAR_NONE = 0;
+  private static final int NUMBER_CHAR_SIGN = 1;
+  private static final int NUMBER_CHAR_DIGIT = 2;
+  private static final int NUMBER_CHAR_DECIMAL = 3;
+  private static final int NUMBER_CHAR_FRACTION_DIGIT = 4;
+  private static final int NUMBER_CHAR_EXP_E = 5;
+  private static final int NUMBER_CHAR_EXP_SIGN = 6;
+  private static final int NUMBER_CHAR_EXP_DIGIT = 7;
+
+  /** The input JSON. */
+  private final BufferedSource source;
+  private final Buffer buffer;
+
+  private int peeked = PEEKED_NONE;
+
+  /**
+   * A peeked value that was composed entirely of digits with an optional
+   * leading dash. Positive values may not have a leading 0.
+   */
+  private long peekedLong;
+
+  /**
+   * The number of characters in a peeked number literal. Increment 'pos' by
+   * this after reading a number.
+   */
+  private int peekedNumberLength;
+
+  /**
+   * A peeked string that should be parsed on the next double, long or string.
+   * This is populated before a numeric value is parsed and used if that parsing
+   * fails.
+   */
+  private String peekedString;
+
+  JsonUtf8Reader(BufferedSource source) {
+    if (source == null) {
+      throw new NullPointerException("source == null");
+    }
+    this.source = source;
+    this.buffer = source.buffer();
+    pushScope(JsonScope.EMPTY_DOCUMENT);
+  }
+
+  @Override public void beginArray() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_BEGIN_ARRAY) {
+      pushScope(JsonScope.EMPTY_ARRAY);
+      pathIndices[stackSize - 1] = 0;
+      peeked = PEEKED_NONE;
+    } else {
+      throw new JsonDataException("Expected BEGIN_ARRAY but was " + peek()
+          + " at path " + getPath());
+    }
+  }
+
+  @Override public void endArray() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_END_ARRAY) {
+      stackSize--;
+      pathIndices[stackSize - 1]++;
+      peeked = PEEKED_NONE;
+    } else {
+      throw new JsonDataException("Expected END_ARRAY but was " + peek()
+          + " at path " + getPath());
+    }
+  }
+
+  @Override public void beginObject() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_BEGIN_OBJECT) {
+      pushScope(JsonScope.EMPTY_OBJECT);
+      peeked = PEEKED_NONE;
+    } else {
+      throw new JsonDataException("Expected BEGIN_OBJECT but was " + peek()
+          + " at path " + getPath());
+    }
+  }
+
+  @Override public void endObject() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_END_OBJECT) {
+      stackSize--;
+      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
+      pathIndices[stackSize - 1]++;
+      peeked = PEEKED_NONE;
+    } else {
+      throw new JsonDataException("Expected END_OBJECT but was " + peek()
+          + " at path " + getPath());
+    }
+  }
+
+  @Override public boolean hasNext() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;
+  }
+
+  @Override public Token peek() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+
+    switch (p) {
+      case PEEKED_BEGIN_OBJECT:
+        return Token.BEGIN_OBJECT;
+      case PEEKED_END_OBJECT:
+        return Token.END_OBJECT;
+      case PEEKED_BEGIN_ARRAY:
+        return Token.BEGIN_ARRAY;
+      case PEEKED_END_ARRAY:
+        return Token.END_ARRAY;
+      case PEEKED_SINGLE_QUOTED_NAME:
+      case PEEKED_DOUBLE_QUOTED_NAME:
+      case PEEKED_UNQUOTED_NAME:
+      case PEEKED_BUFFERED_NAME:
+        return Token.NAME;
+      case PEEKED_TRUE:
+      case PEEKED_FALSE:
+        return Token.BOOLEAN;
+      case PEEKED_NULL:
+        return Token.NULL;
+      case PEEKED_SINGLE_QUOTED:
+      case PEEKED_DOUBLE_QUOTED:
+      case PEEKED_UNQUOTED:
+      case PEEKED_BUFFERED:
+        return Token.STRING;
+      case PEEKED_LONG:
+      case PEEKED_NUMBER:
+        return Token.NUMBER;
+      case PEEKED_EOF:
+        return Token.END_DOCUMENT;
+      default:
+        throw new AssertionError();
+    }
+  }
+
+  private int doPeek() throws IOException {
+    int peekStack = scopes[stackSize - 1];
+    if (peekStack == JsonScope.EMPTY_ARRAY) {
+      scopes[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;
+    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {
+      // Look for a comma before the next element.
+      int c = nextNonWhitespace(true);
+      buffer.readByte(); // consume ']' or ','.
+      switch (c) {
+        case ']':
+          return peeked = PEEKED_END_ARRAY;
+        case ';':
+          checkLenient(); // fall-through
+        case ',':
+          break;
+        default:
+          throw syntaxError("Unterminated array");
+      }
+    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {
+      scopes[stackSize - 1] = JsonScope.DANGLING_NAME;
+      // Look for a comma before the next element.
+      if (peekStack == JsonScope.NONEMPTY_OBJECT) {
+        int c = nextNonWhitespace(true);
+        buffer.readByte(); // Consume '}' or ','.
+        switch (c) {
+          case '}':
+            return peeked = PEEKED_END_OBJECT;
+          case ';':
+            checkLenient(); // fall-through
+          case ',':
+            break;
+          default:
+            throw syntaxError("Unterminated object");
+        }
+      }
+      int c = nextNonWhitespace(true);
+      switch (c) {
+        case '"':
+          buffer.readByte(); // consume the '\"'.
+          return peeked = PEEKED_DOUBLE_QUOTED_NAME;
+        case '\'':
+          buffer.readByte(); // consume the '\''.
+          checkLenient();
+          return peeked = PEEKED_SINGLE_QUOTED_NAME;
+        case '}':
+          if (peekStack != JsonScope.NONEMPTY_OBJECT) {
+            buffer.readByte(); // consume the '}'.
+            return peeked = PEEKED_END_OBJECT;
+          } else {
+            throw syntaxError("Expected name");
+          }
+        default:
+          checkLenient();
+          if (isLiteral((char) c)) {
+            return peeked = PEEKED_UNQUOTED_NAME;
+          } else {
+            throw syntaxError("Expected name");
+          }
+      }
+    } else if (peekStack == JsonScope.DANGLING_NAME) {
+      scopes[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;
+      // Look for a colon before the value.
+      int c = nextNonWhitespace(true);
+      buffer.readByte(); // Consume ':'.
+      switch (c) {
+        case ':':
+          break;
+        case '=':
+          checkLenient();
+          if (source.request(1) && buffer.getByte(0) == '>') {
+            buffer.readByte(); // Consume '>'.
+          }
+          break;
+        default:
+          throw syntaxError("Expected ':'");
+      }
+    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {
+      scopes[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;
+    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {
+      int c = nextNonWhitespace(false);
+      if (c == -1) {
+        return peeked = PEEKED_EOF;
+      } else {
+        checkLenient();
+      }
+    } else if (peekStack == JsonScope.CLOSED) {
+      throw new IllegalStateException("JsonReader is closed");
+    }
+
+    int c = nextNonWhitespace(true);
+    switch (c) {
+      case ']':
+        if (peekStack == JsonScope.EMPTY_ARRAY) {
+          buffer.readByte(); // Consume ']'.
+          return peeked = PEEKED_END_ARRAY;
+        }
+        // fall-through to handle ",]"
+      case ';':
+      case ',':
+        // In lenient mode, a 0-length literal in an array means 'null'.
+        if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {
+          checkLenient();
+          return peeked = PEEKED_NULL;
+        } else {
+          throw syntaxError("Unexpected value");
+        }
+      case '\'':
+        checkLenient();
+        buffer.readByte(); // Consume '\''.
+        return peeked = PEEKED_SINGLE_QUOTED;
+      case '"':
+        buffer.readByte(); // Consume '\"'.
+        return peeked = PEEKED_DOUBLE_QUOTED;
+      case '[':
+        buffer.readByte(); // Consume '['.
+        return peeked = PEEKED_BEGIN_ARRAY;
+      case '{':
+        buffer.readByte(); // Consume '{'.
+        return peeked = PEEKED_BEGIN_OBJECT;
+      default:
+    }
+
+    int result = peekKeyword();
+    if (result != PEEKED_NONE) {
+      return result;
+    }
+
+    result = peekNumber();
+    if (result != PEEKED_NONE) {
+      return result;
+    }
+
+    if (!isLiteral(buffer.getByte(0))) {
+      throw syntaxError("Expected value");
+    }
+
+    checkLenient();
+    return peeked = PEEKED_UNQUOTED;
+  }
+
+  private int peekKeyword() throws IOException {
+    // Figure out which keyword we're matching against by its first character.
+    byte c = buffer.getByte(0);
+    String keyword;
+    String keywordUpper;
+    int peeking;
+    if (c == 't' || c == 'T') {
+      keyword = "true";
+      keywordUpper = "TRUE";
+      peeking = PEEKED_TRUE;
+    } else if (c == 'f' || c == 'F') {
+      keyword = "false";
+      keywordUpper = "FALSE";
+      peeking = PEEKED_FALSE;
+    } else if (c == 'n' || c == 'N') {
+      keyword = "null";
+      keywordUpper = "NULL";
+      peeking = PEEKED_NULL;
+    } else {
+      return PEEKED_NONE;
+    }
+
+    // Confirm that chars [1..length) match the keyword.
+    int length = keyword.length();
+    for (int i = 1; i < length; i++) {
+      if (!source.request(i + 1)) {
+        return PEEKED_NONE;
+      }
+      c = buffer.getByte(i);
+      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {
+        return PEEKED_NONE;
+      }
+    }
+
+    if (source.request(length + 1) && isLiteral(buffer.getByte(length))) {
+      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!
+    }
+
+    // We've found the keyword followed either by EOF or by a non-literal character.
+    buffer.skip(length);
+    return peeked = peeking;
+  }
+
+  private int peekNumber() throws IOException {
+    long value = 0; // Negative to accommodate Long.MIN_VALUE more easily.
+    boolean negative = false;
+    boolean fitsInLong = true;
+    int last = NUMBER_CHAR_NONE;
+
+    int i = 0;
+
+    charactersOfNumber:
+    for (; true; i++) {
+      if (!source.request(i + 1)) {
+        break;
+      }
+
+      byte c = buffer.getByte(i);
+      switch (c) {
+        case '-':
+          if (last == NUMBER_CHAR_NONE) {
+            negative = true;
+            last = NUMBER_CHAR_SIGN;
+            continue;
+          } else if (last == NUMBER_CHAR_EXP_E) {
+            last = NUMBER_CHAR_EXP_SIGN;
+            continue;
+          }
+          return PEEKED_NONE;
+
+        case '+':
+          if (last == NUMBER_CHAR_EXP_E) {
+            last = NUMBER_CHAR_EXP_SIGN;
+            continue;
+          }
+          return PEEKED_NONE;
+
+        case 'e':
+        case 'E':
+          if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {
+            last = NUMBER_CHAR_EXP_E;
+            continue;
+          }
+          return PEEKED_NONE;
+
+        case '.':
+          if (last == NUMBER_CHAR_DIGIT) {
+            last = NUMBER_CHAR_DECIMAL;
+            continue;
+          }
+          return PEEKED_NONE;
+
+        default:
+          if (c < '0' || c > '9') {
+            if (!isLiteral(c)) {
+              break charactersOfNumber;
+            }
+            return PEEKED_NONE;
+          }
+          if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {
+            value = -(c - '0');
+            last = NUMBER_CHAR_DIGIT;
+          } else if (last == NUMBER_CHAR_DIGIT) {
+            if (value == 0) {
+              return PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).
+            }
+            long newValue = value * 10 - (c - '0');
+            fitsInLong &= value > MIN_INCOMPLETE_INTEGER
+                || (value == MIN_INCOMPLETE_INTEGER && newValue < value);
+            value = newValue;
+          } else if (last == NUMBER_CHAR_DECIMAL) {
+            last = NUMBER_CHAR_FRACTION_DIGIT;
+          } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {
+            last = NUMBER_CHAR_EXP_DIGIT;
+          }
+      }
+    }
+
+    // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.
+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {
+      peekedLong = negative ? value : -value;
+      buffer.skip(i);
+      return peeked = PEEKED_LONG;
+    } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT
+        || last == NUMBER_CHAR_EXP_DIGIT) {
+      peekedNumberLength = i;
+      return peeked = PEEKED_NUMBER;
+    } else {
+      return PEEKED_NONE;
+    }
+  }
+
+  private boolean isLiteral(int c) throws IOException {
+    switch (c) {
+      case '/':
+      case '\\':
+      case ';':
+      case '#':
+      case '=':
+        checkLenient(); // fall-through
+      case '{':
+      case '}':
+      case '[':
+      case ']':
+      case ':':
+      case ',':
+      case ' ':
+      case '\t':
+      case '\f':
+      case '\r':
+      case '\n':
+        return false;
+      default:
+        return true;
+    }
+  }
+
+  @Override public String nextName() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    String result;
+    if (p == PEEKED_UNQUOTED_NAME) {
+      result = nextUnquotedValue();
+    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {
+      result = nextQuotedValue(DOUBLE_QUOTE_OR_SLASH);
+    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {
+      result = nextQuotedValue(SINGLE_QUOTE_OR_SLASH);
+    } else if (p == PEEKED_BUFFERED_NAME) {
+      result = peekedString;
+    } else {
+      throw new JsonDataException("Expected a name but was " + peek() + " at path " + getPath());
+    }
+    peeked = PEEKED_NONE;
+    pathNames[stackSize - 1] = result;
+    return result;
+  }
+
+  @Override public int selectName(Options options) throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p < PEEKED_SINGLE_QUOTED_NAME || p > PEEKED_BUFFERED_NAME) {
+      return -1;
+    }
+    if (p == PEEKED_BUFFERED_NAME) {
+      return findName(peekedString, options);
+    }
+
+    int result = source.select(options.doubleQuoteSuffix);
+    if (result != -1) {
+      peeked = PEEKED_NONE;
+      pathNames[stackSize - 1] = options.strings[result];
+
+      return result;
+    }
+
+    // The next name may be unnecessary escaped. Save the last recorded path name, so that we
+    // can restore the peek state in case we fail to find a match.
+    String lastPathName = pathNames[stackSize - 1];
+
+    String nextName = nextName();
+    result = findName(nextName, options);
+
+    if (result == -1) {
+      peeked = PEEKED_BUFFERED_NAME;
+      peekedString = nextName;
+      // We can't push the path further, make it seem like nothing happened.
+      pathNames[stackSize - 1] = lastPathName;
+    }
+
+    return result;
+  }
+
+  /**
+   * If {@code name} is in {@code options} this consumes it and returns it's index.
+   * Otherwise this returns -1 and no name is consumed.
+   */
+  private int findName(String name, Options options) {
+    for (int i = 0, size = options.strings.length; i < size; i++) {
+      if (name.equals(options.strings[i])) {
+        peeked = PEEKED_NONE;
+        pathNames[stackSize - 1] = name;
+
+        return i;
+      }
+    }
+    return -1;
+  }
+
+  @Override public String nextString() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    String result;
+    if (p == PEEKED_UNQUOTED) {
+      result = nextUnquotedValue();
+    } else if (p == PEEKED_DOUBLE_QUOTED) {
+      result = nextQuotedValue(DOUBLE_QUOTE_OR_SLASH);
+    } else if (p == PEEKED_SINGLE_QUOTED) {
+      result = nextQuotedValue(SINGLE_QUOTE_OR_SLASH);
+    } else if (p == PEEKED_BUFFERED) {
+      result = peekedString;
+      peekedString = null;
+    } else if (p == PEEKED_LONG) {
+      result = Long.toString(peekedLong);
+    } else if (p == PEEKED_NUMBER) {
+      result = buffer.readUtf8(peekedNumberLength);
+    } else {
+      throw new JsonDataException("Expected a string but was " + peek() + " at path " + getPath());
+    }
+    peeked = PEEKED_NONE;
+    pathIndices[stackSize - 1]++;
+    return result;
+  }
+
+  @Override public int selectString(Options options) throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p < PEEKED_SINGLE_QUOTED || p > PEEKED_BUFFERED) {
+      return -1;
+    }
+    if (p == PEEKED_BUFFERED) {
+      return findString(peekedString, options);
+    }
+
+    int result = source.select(options.doubleQuoteSuffix);
+    if (result != -1) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+
+      return result;
+    }
+
+    String nextString = nextString();
+    result = findString(nextString, options);
+
+    if (result == -1) {
+      peeked = PEEKED_BUFFERED;
+      peekedString = nextString;
+      pathIndices[stackSize - 1]--;
+    }
+
+    return result;
+  }
+
+  /**
+   * If {@code string} is in {@code options} this consumes it and returns it's index.
+   * Otherwise this returns -1 and no string is consumed.
+   */
+  private int findString(String string, Options options) {
+    for (int i = 0, size = options.strings.length; i < size; i++) {
+      if (string.equals(options.strings[i])) {
+        peeked = PEEKED_NONE;
+        pathIndices[stackSize - 1]++;
+
+        return i;
+      }
+    }
+    return -1;
+  }
+
+  @Override public boolean nextBoolean() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_TRUE) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return true;
+    } else if (p == PEEKED_FALSE) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return false;
+    }
+    throw new JsonDataException("Expected a boolean but was " + peek() + " at path " + getPath());
+  }
+
+  @Override public <T> T nextNull() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+    if (p == PEEKED_NULL) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return null;
+    } else {
+      throw new JsonDataException("Expected null but was " + peek() + " at path " + getPath());
+    }
+  }
+
+  @Override public double nextDouble() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+
+    if (p == PEEKED_LONG) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return (double) peekedLong;
+    }
+
+    if (p == PEEKED_NUMBER) {
+      peekedString = buffer.readUtf8(peekedNumberLength);
+    } else if (p == PEEKED_DOUBLE_QUOTED) {
+      peekedString = nextQuotedValue(DOUBLE_QUOTE_OR_SLASH);
+    } else if (p == PEEKED_SINGLE_QUOTED) {
+      peekedString = nextQuotedValue(SINGLE_QUOTE_OR_SLASH);
+    } else if (p == PEEKED_UNQUOTED) {
+      peekedString = nextUnquotedValue();
+    } else if (p != PEEKED_BUFFERED) {
+      throw new JsonDataException("Expected a double but was " + peek() + " at path " + getPath());
+    }
+
+    peeked = PEEKED_BUFFERED;
+    double result;
+    try {
+      result = Double.parseDouble(peekedString);
+    } catch (NumberFormatException e) {
+      throw new JsonDataException("Expected a double but was " + peekedString
+          + " at path " + getPath());
+    }
+    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
+      throw new JsonEncodingException("JSON forbids NaN and infinities: " + result
+          + " at path " + getPath());
+    }
+    peekedString = null;
+    peeked = PEEKED_NONE;
+    pathIndices[stackSize - 1]++;
+    return result;
+  }
+
+  @Override public long nextLong() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+
+    if (p == PEEKED_LONG) {
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return peekedLong;
+    }
+
+    if (p == PEEKED_NUMBER) {
+      peekedString = buffer.readUtf8(peekedNumberLength);
+    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {
+      peekedString = p == PEEKED_DOUBLE_QUOTED
+          ? nextQuotedValue(DOUBLE_QUOTE_OR_SLASH)
+          : nextQuotedValue(SINGLE_QUOTE_OR_SLASH);
+      try {
+        long result = Long.parseLong(peekedString);
+        peeked = PEEKED_NONE;
+        pathIndices[stackSize - 1]++;
+        return result;
+      } catch (NumberFormatException ignored) {
+        // Fall back to parse as a double below.
+      }
+    } else if (p != PEEKED_BUFFERED) {
+      throw new JsonDataException("Expected a long but was " + peek()
+          + " at path " + getPath());
+    }
+
+    peeked = PEEKED_BUFFERED;
+    long result;
+    try {
+      BigDecimal asDecimal = new BigDecimal(peekedString);
+      result = asDecimal.longValueExact();
+    } catch (NumberFormatException | ArithmeticException e) {
+      throw new JsonDataException("Expected a long but was " + peekedString
+          + " at path " + getPath());
+    }
+    peekedString = null;
+    peeked = PEEKED_NONE;
+    pathIndices[stackSize - 1]++;
+    return result;
+  }
+
+  /**
+   * Returns the string up to but not including {@code quote}, unescaping any character escape
+   * sequences encountered along the way. The opening quote should have already been read. This
+   * consumes the closing quote, but does not include it in the returned string.
+   *
+   * @throws IOException if any unicode escape sequences are malformed.
+   */
+  private String nextQuotedValue(ByteString runTerminator) throws IOException {
+    StringBuilder builder = null;
+    while (true) {
+      long index = source.indexOfElement(runTerminator);
+      if (index == -1L) throw syntaxError("Unterminated string");
+
+      // If we've got an escape character, we're going to need a string builder.
+      if (buffer.getByte(index) == '\\') {
+        if (builder == null) builder = new StringBuilder();
+        builder.append(buffer.readUtf8(index));
+        buffer.readByte(); // '\'
+        builder.append(readEscapeCharacter());
+        continue;
+      }
+
+      // If it isn't the escape character, it's the quote. Return the string.
+      if (builder == null) {
+        String result = buffer.readUtf8(index);
+        buffer.readByte(); // Consume the quote character.
+        return result;
+      } else {
+        builder.append(buffer.readUtf8(index));
+        buffer.readByte(); // Consume the quote character.
+        return builder.toString();
+      }
+    }
+  }
+
+  /** Returns an unquoted value as a string. */
+  private String nextUnquotedValue() throws IOException {
+    long i = source.indexOfElement(UNQUOTED_STRING_TERMINALS);
+    return i != -1 ? buffer.readUtf8(i) : buffer.readUtf8();
+  }
+
+  private void skipQuotedValue(ByteString runTerminator) throws IOException {
+    while (true) {
+      long index = source.indexOfElement(runTerminator);
+      if (index == -1L) throw syntaxError("Unterminated string");
+
+      if (buffer.getByte(index) == '\\') {
+        buffer.skip(index + 1);
+        readEscapeCharacter();
+      } else {
+        buffer.skip(index + 1);
+        return;
+      }
+    }
+  }
+
+  private void skipUnquotedValue() throws IOException {
+    long i = source.indexOfElement(UNQUOTED_STRING_TERMINALS);
+    buffer.skip(i != -1L ? i : buffer.size());
+  }
+
+  @Override public int nextInt() throws IOException {
+    int p = peeked;
+    if (p == PEEKED_NONE) {
+      p = doPeek();
+    }
+
+    int result;
+    if (p == PEEKED_LONG) {
+      result = (int) peekedLong;
+      if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.
+        throw new JsonDataException("Expected an int but was " + peekedLong
+            + " at path " + getPath());
+      }
+      peeked = PEEKED_NONE;
+      pathIndices[stackSize - 1]++;
+      return result;
+    }
+
+    if (p == PEEKED_NUMBER) {
+      peekedString = buffer.readUtf8(peekedNumberLength);
+    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {
+      peekedString = p == PEEKED_DOUBLE_QUOTED
+          ? nextQuotedValue(DOUBLE_QUOTE_OR_SLASH)
+          : nextQuotedValue(SINGLE_QUOTE_OR_SLASH);
+      try {
+        result = Integer.parseInt(peekedString);
+        peeked = PEEKED_NONE;
+        pathIndices[stackSize - 1]++;
+        return result;
+      } catch (NumberFormatException ignored) {
+        // Fall back to parse as a double below.
+      }
+    } else if (p != PEEKED_BUFFERED) {
+      throw new JsonDataException("Expected an int but was " + peek() + " at path " + getPath());
+    }
+
+    peeked = PEEKED_BUFFERED;
+    double asDouble;
+    try {
+      asDouble = Double.parseDouble(peekedString);
+    } catch (NumberFormatException e) {
+      throw new JsonDataException("Expected an int but was " + peekedString
+          + " at path " + getPath());
+    }
+    result = (int) asDouble;
+    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.
+      throw new JsonDataException("Expected an int but was " + peekedString
+          + " at path " + getPath());
+    }
+    peekedString = null;
+    peeked = PEEKED_NONE;
+    pathIndices[stackSize - 1]++;
+    return result;
+  }
+
+  @Override public void close() throws IOException {
+    peeked = PEEKED_NONE;
+    scopes[0] = JsonScope.CLOSED;
+    stackSize = 1;
+    buffer.clear();
+    source.close();
+  }
+
+  @Override public void skipValue() throws IOException {
+    if (failOnUnknown) {
+      throw new JsonDataException("Cannot skip unexpected " + peek() + " at " + getPath());
+    }
+    int count = 0;
+    do {
+      int p = peeked;
+      if (p == PEEKED_NONE) {
+        p = doPeek();
+      }
+
+      if (p == PEEKED_BEGIN_ARRAY) {
+        pushScope(JsonScope.EMPTY_ARRAY);
+        count++;
+      } else if (p == PEEKED_BEGIN_OBJECT) {
+        pushScope(JsonScope.EMPTY_OBJECT);
+        count++;
+      } else if (p == PEEKED_END_ARRAY) {
+        stackSize--;
+        count--;
+      } else if (p == PEEKED_END_OBJECT) {
+        stackSize--;
+        count--;
+      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {
+        skipUnquotedValue();
+      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {
+        skipQuotedValue(DOUBLE_QUOTE_OR_SLASH);
+      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {
+        skipQuotedValue(SINGLE_QUOTE_OR_SLASH);
+      } else if (p == PEEKED_NUMBER) {
+        buffer.skip(peekedNumberLength);
+      }
+      peeked = PEEKED_NONE;
+    } while (count != 0);
+
+    pathIndices[stackSize - 1]++;
+    pathNames[stackSize - 1] = "null";
+  }
+
+  /**
+   * Returns the next character in the stream that is neither whitespace nor a
+   * part of a comment. When this returns, the returned character is always at
+   * {@code buffer[pos-1]}; this means the caller can always push back the
+   * returned character by decrementing {@code pos}.
+   */
+  private int nextNonWhitespace(boolean throwOnEof) throws IOException {
+    /*
+     * This code uses ugly local variables 'p' and 'l' representing the 'pos'
+     * and 'limit' fields respectively. Using locals rather than fields saves
+     * a few field reads for each whitespace character in a pretty-printed
+     * document, resulting in a 5% speedup. We need to flush 'p' to its field
+     * before any (potentially indirect) call to fillBuffer() and reread both
+     * 'p' and 'l' after any (potentially indirect) call to the same method.
+     */
+    int p = 0;
+    while (source.request(p + 1)) {
+      int c = buffer.getByte(p++);
+      if (c == '\n' || c == ' ' || c == '\r' || c == '\t') {
+        continue;
+      }
+
+      buffer.skip(p - 1);
+      if (c == '/') {
+        if (!source.request(2)) {
+          return c;
+        }
+
+        checkLenient();
+        byte peek = buffer.getByte(1);
+        switch (peek) {
+          case '*':
+            // skip a /* c-style comment */
+            buffer.readByte(); // '/'
+            buffer.readByte(); // '*'
+            if (!skipTo("*/")) {
+              throw syntaxError("Unterminated comment");
+            }
+            buffer.readByte(); // '*'
+            buffer.readByte(); // '/'
+            p = 0;
+            continue;
+
+          case '/':
+            // skip a // end-of-line comment
+            buffer.readByte(); // '/'
+            buffer.readByte(); // '/'
+            skipToEndOfLine();
+            p = 0;
+            continue;
+
+          default:
+            return c;
+        }
+      } else if (c == '#') {
+        // Skip a # hash end-of-line comment. The JSON RFC doesn't specify this behaviour, but it's
+        // required to parse existing documents.
+        checkLenient();
+        skipToEndOfLine();
+        p = 0;
+      } else {
+        return c;
+      }
+    }
+    if (throwOnEof) {
+      throw new EOFException("End of input");
+    } else {
+      return -1;
+    }
+  }
+
+  private void checkLenient() throws IOException {
+    if (!lenient) {
+      throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON");
+    }
+  }
+
+  /**
+   * Advances the position until after the next newline character. If the line
+   * is terminated by "\r\n", the '\n' must be consumed as whitespace by the
+   * caller.
+   */
+  private void skipToEndOfLine() throws IOException {
+    long index = source.indexOfElement(LINEFEED_OR_CARRIAGE_RETURN);
+    buffer.skip(index != -1 ? index + 1 : buffer.size());
+  }
+
+  /**
+   * @param toFind a string to search for. Must not contain a newline.
+   */
+  private boolean skipTo(String toFind) throws IOException {
+    outer:
+    for (; source.request(toFind.length()); ) {
+      for (int c = 0; c < toFind.length(); c++) {
+        if (buffer.getByte(c) != toFind.charAt(c)) {
+          buffer.readByte();
+          continue outer;
+        }
+      }
+      return true;
+    }
+    return false;
+  }
+
+  @Override public String toString() {
+    return "JsonReader(" + source + ")";
+  }
+
+  /**
+   * Unescapes the character identified by the character or characters that immediately follow a
+   * backslash. The backslash '\' should have already been read. This supports both unicode escapes
+   * "u000A" and two-character escapes "\n".
+   *
+   * @throws IOException if any unicode escape sequences are malformed.
+   */
+  private char readEscapeCharacter() throws IOException {
+    if (!source.request(1)) {
+      throw syntaxError("Unterminated escape sequence");
+    }
+
+    byte escaped = buffer.readByte();
+    switch (escaped) {
+      case 'u':
+        if (!source.request(4)) {
+          throw new EOFException("Unterminated escape sequence at path " + getPath());
+        }
+        // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);
+        char result = 0;
+        for (int i = 0, end = i + 4; i < end; i++) {
+          byte c = buffer.getByte(i);
+          result <<= 4;
+          if (c >= '0' && c <= '9') {
+            result += (c - '0');
+          } else if (c >= 'a' && c <= 'f') {
+            result += (c - 'a' + 10);
+          } else if (c >= 'A' && c <= 'F') {
+            result += (c - 'A' + 10);
+          } else {
+            throw syntaxError("\\u" + buffer.readUtf8(4));
+          }
+        }
+        buffer.skip(4);
+        return result;
+
+      case 't':
+        return '\t';
+
+      case 'b':
+        return '\b';
+
+      case 'n':
+        return '\n';
+
+      case 'r':
+        return '\r';
+
+      case 'f':
+        return '\f';
+
+      case '\n':
+      case '\'':
+      case '"':
+      case '\\':
+      case '/':
+        return (char) escaped;
+
+      default:
+        if (!lenient) throw syntaxError("Invalid escape sequence: \\" + (char) escaped);
+        return (char) escaped;
+    }
+  }
+
+  @Override void promoteNameToValue() throws IOException {
+    if (hasNext()) {
+      peekedString = nextName();
+      peeked = PEEKED_BUFFERED;
+    }
+  }
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java b/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
new file mode 100644
index 00000000..e78bfe7f
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/JsonValueReader.java
@@ -0,0 +1,340 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.Map;
+
+/**
+ * This class reads a JSON document by traversing a Java object comprising maps, lists, and JSON
+ * primitives. It does depth-first traversal keeping a stack starting with the root object. During
+ * traversal a stack tracks the current position in the document:
+ *
+ * <ul>
+ *   <li>The next element to act upon is on the top of the stack.
+ *   <li>When the top of the stack is a {@link List}, calling {@link #beginArray()} replaces the
+ *       list with a {@link ListIterator}. The first element of the iterator is pushed on top of the
+ *       iterator.
+ *   <li>Similarly, when the top of the stack is a {@link Map}, calling {@link #beginObject()}
+ *       replaces the map with an {@link Iterator} of its entries. The first element of the iterator
+ *       is pushed on top of the iterator.
+ *   <li>When the top of the stack is a {@link Map.Entry}, calling {@link #nextName()} returns the
+ *       entry's key and replaces the entry with its value on the stack.
+ *   <li>When an element is consumed it is popped. If the new top of the stack has a non-exhausted
+ *       iterator, the next element of that iterator is pushed.
+ *   <li>If the top of the stack is an exhausted iterator, calling {@link #endArray} or {@link
+ *       #endObject} will pop it.
+ * </ul>
+ */
+final class JsonValueReader extends JsonReader {
+  /** Sentinel object pushed on {@link #stack} when the reader is closed. */
+  private static final Object JSON_READER_CLOSED = new Object();
+
+  private final Object[] stack = new Object[32];
+
+  public JsonValueReader(Object root) {
+    scopes[stackSize] = JsonScope.NONEMPTY_DOCUMENT;
+    stack[stackSize++] = root;
+  }
+
+  @Override public void beginArray() throws IOException {
+    List<?> peeked = require(List.class, Token.BEGIN_ARRAY);
+
+    ListIterator<?> iterator = peeked.listIterator();
+    stack[stackSize - 1] = iterator;
+    scopes[stackSize - 1] = JsonScope.EMPTY_ARRAY;
+    pathIndices[stackSize - 1] = 0;
+
+    // If the iterator isn't empty push its first value onto the stack.
+    if (iterator.hasNext()) {
+      push(iterator.next());
+    }
+  }
+
+  @Override public void endArray() throws IOException {
+    ListIterator<?> peeked = require(ListIterator.class, Token.END_ARRAY);
+    if (peeked.hasNext()) {
+      throw typeMismatch(peeked, Token.END_ARRAY);
+    }
+    remove();
+  }
+
+  @Override public void beginObject() throws IOException {
+    Map<?, ?> peeked = require(Map.class, Token.BEGIN_OBJECT);
+
+    Iterator<?> iterator = peeked.entrySet().iterator();
+    stack[stackSize - 1] = iterator;
+    scopes[stackSize - 1] = JsonScope.EMPTY_OBJECT;
+
+    // If the iterator isn't empty push its first value onto the stack.
+    if (iterator.hasNext()) {
+      push(iterator.next());
+    }
+  }
+
+  @Override public void endObject() throws IOException {
+    Iterator<?> peeked = require(Iterator.class, Token.END_OBJECT);
+    if (peeked instanceof ListIterator || peeked.hasNext()) {
+      throw typeMismatch(peeked, Token.END_OBJECT);
+    }
+    pathNames[stackSize - 1] = null;
+    remove();
+  }
+
+  @Override public boolean hasNext() throws IOException {
+    // TODO(jwilson): this is consistent with BufferedSourceJsonReader but it doesn't make sense.
+    if (stackSize == 0) return true;
+
+    Object peeked = stack[stackSize - 1];
+    return !(peeked instanceof Iterator) || ((Iterator) peeked).hasNext();
+  }
+
+  @Override public Token peek() throws IOException {
+    if (stackSize == 0) return Token.END_DOCUMENT;
+
+    // If the top of the stack is an iterator, take its first element and push it on the stack.
+    Object peeked = stack[stackSize - 1];
+    if (peeked instanceof ListIterator) return Token.END_ARRAY;
+    if (peeked instanceof Iterator) return Token.END_OBJECT;
+    if (peeked instanceof List) return Token.BEGIN_ARRAY;
+    if (peeked instanceof Map) return Token.BEGIN_OBJECT;
+    if (peeked instanceof Map.Entry) return Token.NAME;
+    if (peeked instanceof String) return Token.STRING;
+    if (peeked instanceof Boolean) return Token.BOOLEAN;
+    if (peeked instanceof Number) return Token.NUMBER;
+    if (peeked == null) return Token.NULL;
+    if (peeked == JSON_READER_CLOSED) throw new IllegalStateException("JsonReader is closed");
+
+    throw typeMismatch(peeked, "a JSON value");
+  }
+
+  @Override public String nextName() throws IOException {
+    Map.Entry<?, ?> peeked = require(Map.Entry.class, Token.NAME);
+
+    // Swap the Map.Entry for its value on the stack and return its key.
+    String result = stringKey(peeked);
+    stack[stackSize - 1] = peeked.getValue();
+    pathNames[stackSize - 2] = result;
+    return result;
+  }
+
+  @Override public int selectName(Options options) throws IOException {
+    Map.Entry<?, ?> peeked = require(Map.Entry.class, Token.NAME);
+    String name = stringKey(peeked);
+    for (int i = 0, length = options.strings.length; i < length; i++) {
+      // Swap the Map.Entry for its value on the stack and return its key.
+      if (options.strings[i].equals(name)) {
+        stack[stackSize - 1] = peeked.getValue();
+        pathNames[stackSize - 2] = name;
+        return i;
+      }
+    }
+    return -1;
+  }
+
+  @Override public String nextString() throws IOException {
+    String peeked = require(String.class, Token.STRING);
+    remove();
+    return peeked;
+  }
+
+  @Override public int selectString(Options options) throws IOException {
+    String peeked = require(String.class, Token.STRING);
+    for (int i = 0, length = options.strings.length; i < length; i++) {
+      if (options.strings[i].equals(peeked)) {
+        remove();
+        return i;
+      }
+    }
+    return -1;
+  }
+
+  @Override public boolean nextBoolean() throws IOException {
+    Boolean peeked = require(Boolean.class, Token.BOOLEAN);
+    remove();
+    return peeked;
+  }
+
+  @Override public <T> T nextNull() throws IOException {
+    require(Void.class, Token.NULL);
+    remove();
+    return null;
+  }
+
+  @Override public double nextDouble() throws IOException {
+    Object peeked = require(Object.class, Token.NUMBER);
+
+    double result;
+    if (peeked instanceof Number) {
+      result = ((Number) peeked).doubleValue();
+    } else if (peeked instanceof String) {
+      try {
+        result = Double.parseDouble((String) peeked);
+      } catch (NumberFormatException e) {
+        throw typeMismatch(peeked, Token.NUMBER);
+      }
+    } else {
+      throw typeMismatch(peeked, Token.NUMBER);
+    }
+    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {
+      throw new JsonEncodingException("JSON forbids NaN and infinities: " + result
+          + " at path " + getPath());
+    }
+    remove();
+    return result;
+  }
+
+  @Override public long nextLong() throws IOException {
+    Object peeked = require(Object.class, Token.NUMBER);
+
+    long result;
+    if (peeked instanceof Number) {
+      result = ((Number) peeked).longValue();
+    } else if (peeked instanceof String) {
+      try {
+        result = Long.parseLong((String) peeked);
+      } catch (NumberFormatException e) {
+        try {
+          BigDecimal asDecimal = new BigDecimal((String) peeked);
+          result = asDecimal.longValueExact();
+        } catch (NumberFormatException e2) {
+          throw typeMismatch(peeked, Token.NUMBER);
+        }
+      }
+    } else {
+      throw typeMismatch(peeked, Token.NUMBER);
+    }
+    remove();
+    return result;
+  }
+
+  @Override public int nextInt() throws IOException {
+    Object peeked = require(Object.class, Token.NUMBER);
+
+    int result;
+    if (peeked instanceof Number) {
+      result = ((Number) peeked).intValue();
+    } else if (peeked instanceof String) {
+      try {
+        result = Integer.parseInt((String) peeked);
+      } catch (NumberFormatException e) {
+        try {
+          BigDecimal asDecimal = new BigDecimal((String) peeked);
+          result = asDecimal.intValueExact();
+        } catch (NumberFormatException e2) {
+          throw typeMismatch(peeked, Token.NUMBER);
+        }
+      }
+    } else {
+      throw typeMismatch(peeked, Token.NUMBER);
+    }
+    remove();
+    return result;
+  }
+
+  @Override public void skipValue() throws IOException {
+    if (failOnUnknown) {
+      throw new JsonDataException("Cannot skip unexpected " + peek() + " at " + getPath());
+    }
+
+    // If this element is in an object clear out the key.
+    if (stackSize > 1) {
+      pathNames[stackSize - 2] = "null";
+    }
+
+    Object skipped = stackSize != 0 ? stack[stackSize - 1] : null;
+
+    if (skipped instanceof Map.Entry) {
+      // We're skipping a name. Promote the map entry's value.
+      Map.Entry<?, ?> entry = (Map.Entry<?, ?>) stack[stackSize - 1];
+      stack[stackSize - 1] = entry.getValue();
+    } else if (stackSize > 0) {
+      // We're skipping a value.
+      remove();
+    }
+  }
+
+  @Override void promoteNameToValue() throws IOException {
+    if (hasNext()) {
+      String name = nextName();
+      push(name);
+    }
+  }
+
+  @Override public void close() throws IOException {
+    Arrays.fill(stack, 0, stackSize, null);
+    stack[0] = JSON_READER_CLOSED;
+    scopes[0] = JsonScope.CLOSED;
+    stackSize = 1;
+  }
+
+  private void push(Object newTop) {
+    if (stackSize == stack.length) {
+      throw new JsonDataException("Nesting too deep at " + getPath());
+    }
+    stack[stackSize++] = newTop;
+  }
+
+  /**
+   * Returns the top of the stack which is required to be a {@code type}. Throws if this reader is
+   * closed, or if the type isn't what was expected.
+   */
+  private <T> T require(Class<T> type, Token expected) throws IOException {
+    Object peeked = (stackSize != 0 ? stack[stackSize - 1] : null);
+
+    if (type.isInstance(peeked)) {
+      return type.cast(peeked);
+    }
+    if (peeked == null && expected == Token.NULL) {
+      return null;
+    }
+    if (peeked == JSON_READER_CLOSED) {
+      throw new IllegalStateException("JsonReader is closed");
+    }
+    throw typeMismatch(peeked, expected);
+  }
+
+  private String stringKey(Map.Entry<?, ?> entry) {
+    Object name = entry.getKey();
+    if (name instanceof String) return (String) name;
+    throw typeMismatch(name, Token.NAME);
+  }
+
+  /**
+   * Removes a value and prepares for the next. If we're iterating a map or list this advances the
+   * iterator.
+   */
+  private void remove() {
+    stackSize--;
+    stack[stackSize] = null;
+    scopes[stackSize] = 0;
+
+    // If we're iterating an array or an object push its next element on to the stack.
+    if (stackSize > 0) {
+      pathIndices[stackSize - 1]++;
+
+      Object parent = stack[stackSize - 1];
+      if (parent instanceof Iterator && ((Iterator<?>) parent).hasNext()) {
+        push(((Iterator<?>) parent).next());
+      }
+    }
+  }
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
new file mode 100644
index 00000000..01038e06
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/JsonValueWriter.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.io.IOException;
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+import static com.squareup.moshi.JsonScope.EMPTY_ARRAY;
+import static com.squareup.moshi.JsonScope.EMPTY_DOCUMENT;
+import static com.squareup.moshi.JsonScope.EMPTY_OBJECT;
+import static com.squareup.moshi.JsonScope.NONEMPTY_DOCUMENT;
+import static java.lang.Double.NEGATIVE_INFINITY;
+import static java.lang.Double.POSITIVE_INFINITY;
+
+/** Writes JSON by building a Java object comprising maps, lists, and JSON primitives. */
+final class JsonValueWriter extends JsonWriter {
+  private final Object[] stack = new Object[32];
+  private String deferredName;
+
+  JsonValueWriter() {
+    pushScope(EMPTY_DOCUMENT);
+  }
+
+  public Object root() {
+    int size = stackSize;
+    if (size > 1 || size == 1 && scopes[size - 1] != NONEMPTY_DOCUMENT) {
+      throw new IllegalStateException("Incomplete document");
+    }
+    return stack[0];
+  }
+
+  @Override public JsonWriter beginArray() throws IOException {
+    if (stackSize == stack.length) {
+      throw new JsonDataException("Nesting too deep at " + getPath() + ": circular reference?");
+    }
+    List<Object> list = new ArrayList<>();
+    add(list);
+    stack[stackSize] = list;
+    pathIndices[stackSize] = 0;
+    pushScope(EMPTY_ARRAY);
+    return this;
+  }
+
+  @Override public JsonWriter endArray() throws IOException {
+    if (peekScope() != EMPTY_ARRAY) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    stackSize--;
+    stack[stackSize] = null;
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter beginObject() throws IOException {
+    if (stackSize == stack.length) {
+      throw new JsonDataException("Nesting too deep at " + getPath() + ": circular reference?");
+    }
+    Map<String, Object> map = new LinkedHashTreeMap<>();
+    add(map);
+    stack[stackSize] = map;
+    pushScope(EMPTY_OBJECT);
+    return this;
+  }
+
+  @Override public JsonWriter endObject() throws IOException {
+    if (peekScope() != EMPTY_OBJECT || deferredName != null) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    promoteValueToName = false;
+    stackSize--;
+    stack[stackSize] = null;
+    pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter name(String name) throws IOException {
+    if (name == null) {
+      throw new NullPointerException("name == null");
+    }
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+    if (peekScope() != EMPTY_OBJECT || deferredName != null) {
+      throw new IllegalStateException("Nesting problem.");
+    }
+    deferredName = name;
+    pathNames[stackSize - 1] = name;
+    promoteValueToName = false;
+    return this;
+  }
+
+  @Override public JsonWriter value(String value) throws IOException {
+    if (promoteValueToName) {
+      return name(value);
+    }
+    add(value);
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter nullValue() throws IOException {
+    add(null);
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter value(boolean value) throws IOException {
+    add(value);
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter value(Boolean value) throws IOException {
+    add(value);
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter value(double value) throws IOException {
+    if (!lenient
+        && (Double.isNaN(value) || value == NEGATIVE_INFINITY || value == POSITIVE_INFINITY)) {
+      throw new IllegalArgumentException("Numeric values must be finite, but was " + value);
+    }
+    if (promoteValueToName) {
+      return name(Double.toString(value));
+    }
+    add(value);
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter value(long value) throws IOException {
+    if (promoteValueToName) {
+      return name(Long.toString(value));
+    }
+    add(value);
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public JsonWriter value(Number value) throws IOException {
+    // If it's trivially converted to a long, do that.
+    if (value instanceof Byte
+        || value instanceof Short
+        || value instanceof Integer
+        || value instanceof Long) {
+      return value(value.longValue());
+    }
+
+    // If it's trivially converted to a double, do that.
+    if (value instanceof Float || value instanceof Double) {
+      return value(value.doubleValue());
+    }
+
+    // Everything else gets converted to a BigDecimal.
+    BigDecimal bigDecimalValue = value instanceof BigDecimal
+        ? ((BigDecimal) value)
+        : new BigDecimal(value.toString());
+    if (promoteValueToName) {
+      return name(bigDecimalValue.toString());
+    }
+    add(bigDecimalValue);
+    pathIndices[stackSize - 1]++;
+    return this;
+  }
+
+  @Override public void close() throws IOException {
+    int size = stackSize;
+    if (size > 1 || size == 1 && scopes[size - 1] != NONEMPTY_DOCUMENT) {
+      throw new IOException("Incomplete document");
+    }
+    stackSize = 0;
+  }
+
+  @Override public void flush() throws IOException {
+    if (stackSize == 0) {
+      throw new IllegalStateException("JsonWriter is closed.");
+    }
+  }
+
+  private JsonValueWriter add(Object newTop) {
+    int scope = peekScope();
+
+    if (stackSize == 1) {
+      if (scope != EMPTY_DOCUMENT) {
+        throw new IllegalStateException("JSON must have only one top-level value.");
+      }
+      scopes[stackSize - 1] = NONEMPTY_DOCUMENT;
+      stack[stackSize - 1] = newTop;
+
+    } else if (scope == EMPTY_OBJECT && deferredName != null) {
+      if (newTop != null || serializeNulls) {
+        @SuppressWarnings("unchecked") // Our maps always have string keys and object values.
+        Map<String, Object> map = (Map<String, Object>) stack[stackSize - 1];
+        Object replaced = map.put(deferredName, newTop);
+        if (replaced != null) {
+          throw new IllegalArgumentException("Map key '" + deferredName
+              + "' has multiple values at path " + getPath() + ": " + replaced + " and " + newTop);
+        }
+      }
+      deferredName = null;
+
+    } else if (scope == EMPTY_ARRAY) {
+      @SuppressWarnings("unchecked") // Our lists always have object values.
+      List<Object> list = (List<Object>) stack[stackSize - 1];
+      list.add(newTop);
+
+    } else {
+      throw new IllegalStateException("Nesting problem.");
+    }
+
+    return this;
+  }
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index c0179951..7e74f6c8 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -136,9 +136,9 @@ public abstract class JsonWriter implements Closeable, Flushable {
   boolean serializeNulls;
   boolean promoteValueToName;
 
-  /** Returns a new instance that writes a JSON-encoded stream to {@code sink}. */
+  /** Returns a new instance that writes UTF-8 encoded JSON to {@code sink}. */
   public static JsonWriter of(BufferedSink sink) {
-    return new BufferedSinkJsonWriter(sink);
+    return new JsonUt8Writer(sink);
   }
 
   JsonWriter() {
