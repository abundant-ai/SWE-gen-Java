diff --git a/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt b/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt
index 0ae1e9807..3335e6943 100644
--- a/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt
+++ b/mockwebserver-deprecated/src/main/kotlin/okhttp3/mockwebserver/DeprecationBridge.kt
@@ -30,6 +30,7 @@ import mockwebserver3.SocketPolicy.ShutdownInputAtEnd
 import mockwebserver3.SocketPolicy.ShutdownOutputAtEnd
 import mockwebserver3.SocketPolicy.ShutdownServerAfterResponse
 import mockwebserver3.SocketPolicy.StallSocketAtStart
+import okio.Buffer
 
 internal fun Dispatcher.wrap(): mockwebserver3.Dispatcher {
   if (this is QueueDispatcher) return this.delegate
@@ -97,7 +98,7 @@ internal fun mockwebserver3.RecordedRequest.unwrap(): RecordedRequest =
     headers = headers,
     chunkSizes = chunkSizes,
     bodySize = bodySize,
-    body = body,
+    body = Buffer().write(body),
     sequenceNumber = sequenceNumber,
     failure = failure,
     method = method,
diff --git a/mockwebserver/api/mockwebserver3.api b/mockwebserver/api/mockwebserver3.api
index a5729cc86..9423c2c0a 100644
--- a/mockwebserver/api/mockwebserver3.api
+++ b/mockwebserver/api/mockwebserver3.api
@@ -145,9 +145,9 @@ public class mockwebserver3/QueueDispatcher : mockwebserver3/Dispatcher {
 }
 
 public final class mockwebserver3/RecordedRequest {
-	public fun <init> (Ljava/lang/String;Lokhttp3/Headers;Ljava/util/List;JLokio/Buffer;ILjava/net/Socket;Ljava/io/IOException;)V
-	public synthetic fun <init> (Ljava/lang/String;Lokhttp3/Headers;Ljava/util/List;JLokio/Buffer;ILjava/net/Socket;Ljava/io/IOException;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
-	public final fun getBody ()Lokio/Buffer;
+	public fun <init> (ILokhttp3/Handshake;Ljava/util/List;Lokhttp3/HttpUrl;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lokhttp3/Headers;Lokio/ByteString;JLjava/util/List;Ljava/io/IOException;)V
+	public synthetic fun <init> (ILokhttp3/Handshake;Ljava/util/List;Lokhttp3/HttpUrl;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Lokhttp3/Headers;Lokio/ByteString;JLjava/util/List;Ljava/io/IOException;ILkotlin/jvm/internal/DefaultConstructorMarker;)V
+	public final fun getBody ()Lokio/ByteString;
 	public final fun getBodySize ()J
 	public final fun getChunkSizes ()Ljava/util/List;
 	public final fun getFailure ()Ljava/io/IOException;
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
index cdce3d6eb..26ef45146 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
@@ -63,6 +63,7 @@ import mockwebserver3.SocketPolicy.ShutdownInputAtEnd
 import mockwebserver3.SocketPolicy.ShutdownOutputAtEnd
 import mockwebserver3.SocketPolicy.ShutdownServerAfterResponse
 import mockwebserver3.SocketPolicy.StallSocketAtStart
+import mockwebserver3.internal.RecordedRequest
 import mockwebserver3.internal.ThrottledSink
 import mockwebserver3.internal.TriggerSink
 import mockwebserver3.internal.sleepNanos
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/RecordedRequest.kt b/mockwebserver/src/main/kotlin/mockwebserver3/RecordedRequest.kt
index e853be936..0271d6e3e 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/RecordedRequest.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/RecordedRequest.kt
@@ -17,103 +17,51 @@
 package mockwebserver3
 
 import java.io.IOException
-import java.net.Inet6Address
-import java.net.Socket
-import javax.net.ssl.SSLSocket
 import okhttp3.ExperimentalOkHttpApi
 import okhttp3.Handshake
-import okhttp3.Handshake.Companion.handshake
 import okhttp3.Headers
 import okhttp3.HttpUrl
-import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
-import okhttp3.internal.platform.Platform
-import okio.Buffer
+import okio.ByteString
 
 /** An HTTP request that came into the mock web server. */
 @ExperimentalOkHttpApi
 public class RecordedRequest(
-  public val requestLine: String,
-  /** All headers. */
-  public val headers: Headers,
-  /**
-   * The sizes of the chunks of this request's body, or an empty list if the request's body
-   * was empty or unchunked.
-   */
-  public val chunkSizes: List<Int>,
-  /** The total size of the body of this POST request (before truncation).*/
-  public val bodySize: Long,
-  /** The body of this POST request. This may be truncated. */
-  public val body: Buffer,
   /**
    * The index of this request on its HTTP connection. Since a single HTTP connection may serve
    * multiple requests, each request is assigned its own sequence number.
    */
   public val sequenceNumber: Int,
-  socket: Socket,
-  /**
-   * The failure MockWebServer recorded when attempting to decode this request. If, for example,
-   * the inbound request was truncated, this exception will be non-null.
-   */
-  public val failure: IOException? = null,
-) {
-  public val method: String?
-  public val path: String?
-
   /**
    * The TLS handshake of the connection that carried this request, or null if the request was
    * received without TLS.
    */
-  public val handshake: Handshake?
-  public val requestUrl: HttpUrl?
-
+  public val handshake: Handshake?,
   /**
    * Returns the name of the server the client requested via the SNI (Server Name Indication)
    * attribute in the TLS handshake. Unlike the rest of the HTTP exchange, this name is sent in
    * cleartext and may be monitored or blocked by a proxy or other middlebox.
    */
-  public val handshakeServerNames: List<String>
-
-  init {
-    if (socket is SSLSocket) {
-      try {
-        this.handshake = socket.session.handshake()
-        this.handshakeServerNames = Platform.get().getHandshakeServerNames(socket)
-      } catch (e: IOException) {
-        throw IllegalArgumentException(e)
-      }
-    } else {
-      this.handshake = null
-      this.handshakeServerNames = listOf()
-    }
-
-    if (requestLine.isNotEmpty()) {
-      val methodEnd = requestLine.indexOf(' ')
-      val pathEnd = requestLine.indexOf(' ', methodEnd + 1)
-      this.method = requestLine.substring(0, methodEnd)
-      var path = requestLine.substring(methodEnd + 1, pathEnd)
-      if (!path.startsWith("/")) {
-        path = "/"
-      }
-      this.path = path
-
-      val scheme = if (socket is SSLSocket) "https" else "http"
-      val localPort = socket.localPort
-      val hostAndPort =
-        headers[":authority"]
-          ?: headers["Host"]
-          ?: when (val inetAddress = socket.localAddress) {
-            is Inet6Address -> "[${inetAddress.hostAddress}]:$localPort"
-            else -> "${inetAddress.hostAddress}:$localPort"
-          }
-
-      // Allow null in failure case to allow for testing bad requests
-      this.requestUrl = "$scheme://$hostAndPort$path".toHttpUrlOrNull()
-    } else {
-      this.requestUrl = null
-      this.method = null
-      this.path = null
-    }
-  }
-
+  public val handshakeServerNames: List<String>,
+  public val requestUrl: HttpUrl?,
+  public val requestLine: String,
+  public val method: String?,
+  public val path: String?,
+  /** All headers. */
+  public val headers: Headers,
+  /** The body of this request, or [ByteString.EMPTY] if it has none. This may be truncated. */
+  public val body: ByteString,
+  /** The total size of the body of this request (before truncation).*/
+  public val bodySize: Long,
+  /**
+   * The sizes of the chunks of this request's body, or an empty list if the request's body
+   * was empty or unchunked.
+   */
+  public val chunkSizes: List<Int>,
+  /**
+   * The failure MockWebServer recorded when attempting to decode this request. If, for example,
+   * the inbound request was truncated, this exception will be non-null.
+   */
+  public val failure: IOException? = null,
+) {
   public override fun toString(): String = requestLine
 }
diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/internal/RecordedRequestFactory.kt b/mockwebserver/src/main/kotlin/mockwebserver3/internal/RecordedRequestFactory.kt
new file mode 100644
index 000000000..d832a525a
--- /dev/null
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/internal/RecordedRequestFactory.kt
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2025 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package mockwebserver3.internal
+
+import java.io.IOException
+import java.net.Inet6Address
+import java.net.Socket
+import javax.net.ssl.SSLSocket
+import mockwebserver3.RecordedRequest
+import okhttp3.Handshake
+import okhttp3.Handshake.Companion.handshake
+import okhttp3.Headers
+import okhttp3.HttpUrl
+import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
+import okhttp3.internal.platform.Platform
+import okio.Buffer
+
+internal fun RecordedRequest(
+  requestLine: String,
+  headers: Headers,
+  chunkSizes: List<Int>,
+  bodySize: Long,
+  body: Buffer,
+  sequenceNumber: Int,
+  socket: Socket,
+  failure: IOException? = null,
+): RecordedRequest {
+  val handshake: Handshake?
+  val handshakeServerNames: List<String>
+  if (socket is SSLSocket) {
+    try {
+      handshake = socket.session.handshake()
+      handshakeServerNames = Platform.get().getHandshakeServerNames(socket)
+    } catch (e: IOException) {
+      throw IllegalArgumentException(e)
+    }
+  } else {
+    handshake = null
+    handshakeServerNames = listOf()
+  }
+
+  val requestUrl: HttpUrl?
+  val method: String?
+  val path: String?
+  if (requestLine.isNotEmpty()) {
+    val methodEnd = requestLine.indexOf(' ')
+    val urlEnd = requestLine.indexOf(' ', methodEnd + 1)
+    method = requestLine.substring(0, methodEnd)
+    var urlPart = requestLine.substring(methodEnd + 1, urlEnd)
+    if (!urlPart.startsWith("/")) {
+      urlPart = "/"
+    }
+    path = urlPart
+
+    val scheme = if (socket is SSLSocket) "https" else "http"
+    val localPort = socket.localPort
+    val hostAndPort =
+      headers[":authority"]
+        ?: headers["Host"]
+        ?: when (val inetAddress = socket.localAddress) {
+          is Inet6Address -> "[${inetAddress.hostAddress}]:$localPort"
+          else -> "${inetAddress.hostAddress}:$localPort"
+        }
+
+    // Allow null in failure case to allow for testing bad requests
+    requestUrl = "$scheme://$hostAndPort$path".toHttpUrlOrNull()
+  } else {
+    requestUrl = null
+    method = null
+    path = null
+  }
+
+  return RecordedRequest(
+    sequenceNumber = sequenceNumber,
+    handshake = handshake,
+    handshakeServerNames = handshakeServerNames,
+    requestUrl = requestUrl,
+    requestLine = requestLine,
+    method = method,
+    path = path,
+    headers = headers,
+    body = body.readByteString(),
+    bodySize = bodySize,
+    chunkSizes = chunkSizes,
+    failure = failure,
+  )
+}
