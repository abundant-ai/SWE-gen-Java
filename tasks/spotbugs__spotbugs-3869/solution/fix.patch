diff --git a/CHANGELOG.md b/CHANGELOG.md
index 753c96a8a..2dacd8e63 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -8,6 +8,7 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 ### Refactor
 - Move internal usage of 'javax.annotation.Nonnull' to 'jakarta.annotation.NonNull'. ([#3858](https://github.com/spotbugs/spotbugs/pull/3858))
 - Move internal usage of 'javax.annotation.Nullable' to 'jakarta.annotation.Nullable'. ([#3861](https://github.com/spotbugs/spotbugs/pull/3861))
+- Renamed methods from `edu.umd.cs.findbugs.SwitchHandler` to reflect that they return a PC, not an offset ([#3869](https://github.com/spotbugs/spotbugs/pull/3869))
 
 ### Added
 - Recognize `jakarta.annotation.Nonnull` and `jakarta.annotation.Nullable` ([#3780](https://github.com/spotbugs/spotbugs/pull/3780))
@@ -36,6 +37,7 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 - Fix IllegalArgumentException initializing spotbugs when inside a fat jar on Java 25 ([#3875](https://github.com/spotbugs/spotbugs/pull/3875))
 - Do not report `DM_DEFAULT_ENCODING` for classes compiled with target >= 18 ([#3866](https://github.com/spotbugs/spotbugs/pull/3866))
 - Fix `FS_BAD_DATE_FORMAT_FLAG_COMBO` not suppressed by field-level annotation ([#3838](https://github.com/spotbugs/spotbugs/issues/3838))
+- Fix `SF_SWITCH_FALLTHROUGH` false positives ([#3767](https://github.com/spotbugs/spotbugs/issues/3767))
 
 ### Removed
 - Removed old deprecated methods: 
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/SwitchHandler.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/SwitchHandler.java
index 19be594ff..948c76fad 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/SwitchHandler.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/SwitchHandler.java
@@ -23,6 +23,7 @@ import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.function.Function;
 
 import javax.annotation.CheckForNull;
 
@@ -87,7 +88,7 @@ public class SwitchHandler {
         int size = switchOffsetStack.size();
         while (--size >= 0) {
             SwitchDetails existingDetail = switchOffsetStack.get(size);
-            if (details.switchPC > (existingDetail.switchPC + existingDetail.getLastOffset())) {
+            if (details.switchPC > existingDetail.getLastCasePC()) {
                 switchOffsetStack.remove(size);
             }
         }
@@ -96,24 +97,24 @@ public class SwitchHandler {
 
     public boolean isOnSwitchOffset(DismantleBytecode dbc) {
         int pc = dbc.getPC();
-        if (pc == getDefaultOffset()) {
+        if (pc == getDefaultCasePC()) {
             return false;
         }
 
-        return (pc == getNextSwitchOffset(dbc));
+        return (pc == getNextSwitchCasePC(dbc));
     }
 
-    public int getNextSwitchOffset(DismantleBytecode dbc) {
+    public int getNextSwitchCasePC(DismantleBytecode dbc) {
         int size = switchOffsetStack.size();
         while (size > 0) {
             SwitchDetails details = switchOffsetStack.get(size - 1);
 
-            int nextSwitchOffset = details.getNextSwitchOffset(dbc.getPC());
+            int nextSwitchOffset = details.getNextSwitchCasePC(dbc.getPC());
             if (nextSwitchOffset >= 0) {
                 return nextSwitchOffset;
             }
 
-            if (dbc.getPC() <= details.getDefaultOffset()) {
+            if (dbc.getPC() <= details.getDefaultCasePC()) {
                 return -1;
             }
             switchOffsetStack.remove(size - 1);
@@ -129,12 +130,12 @@ public class SwitchHandler {
         while (size > 0) {
             SwitchDetails details = switchOffsetStack.get(size - 1);
 
-            int nextSwitchOffset = details.getNextSwitchOffset(dbc.getPC());
+            int nextSwitchOffset = details.getNextSwitchCasePC(dbc.getPC());
             if (nextSwitchOffset >= 0) {
                 return details;
             }
 
-            if (dbc.getPC() <= details.getDefaultOffset()) {
+            if (dbc.getPC() <= details.getDefaultCasePC()) {
                 return null;
             }
             switchOffsetStack.remove(size - 1);
@@ -144,14 +145,28 @@ public class SwitchHandler {
         return null;
     }
 
-    public int getDefaultOffset() {
+    /**
+     * @return The PC of the default case
+     */
+    public int getDefaultCasePC() {
+        return getSwitchDetailsValue(SwitchDetails::getDefaultCasePC);
+    }
+
+    /**
+     * @return The PC of the last switch branch
+     */
+    public int getLastCasePC() {
+        return getSwitchDetailsValue(SwitchDetails::getLastCasePC);
+    }
+
+    private int getSwitchDetailsValue(Function<SwitchDetails, Integer> f) {
         int size = switchOffsetStack.size();
         if (size == 0) {
             return -1;
         }
 
         SwitchDetails details = switchOffsetStack.get(size - 1);
-        return details.getDefaultOffset();
+        return f.apply(details);
     }
 
     public SourceLineAnnotation getCurrentSwitchStatement(BytecodeScanningDetector detector) {
@@ -293,7 +308,7 @@ public class SwitchHandler {
             this.exhaustive = exhaustive;
         }
 
-        public int getNextSwitchOffset(int currentPC) {
+        public int getNextSwitchCasePC(int currentPC) {
             while ((nextOffset < swOffsets.length) && (currentPC > (switchPC + swOffsets[nextOffset]))) {
                 nextOffset++;
             }
@@ -305,15 +320,22 @@ public class SwitchHandler {
             return switchPC + swOffsets[nextOffset];
         }
 
-        public int getDefaultOffset() {
+        /**
+         * @return The PC of the default case
+         */
+        public int getDefaultCasePC() {
             if (exhaustive) {
                 return Short.MIN_VALUE;
             }
             return switchPC + defaultOffset;
         }
 
-        private int getLastOffset() {
-            return swOffsets.length > 0 ? swOffsets[swOffsets.length - 1] : 0;
+        /**
+         * @return The PC of the last switch branch
+         */
+        private int getLastCasePC() {
+            int lastOffset = swOffsets.length > 0 ? swOffsets[swOffsets.length - 1] : 0;
+            return switchPC + lastOffset;
         }
 
         /**
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java
index c6f878f75..8431c8620 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/SwitchFallthrough.java
@@ -25,7 +25,9 @@ import java.util.BitSet;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.LinkedList;
+import java.util.Map.Entry;
 import java.util.Set;
+import java.util.TreeMap;
 
 import org.apache.bcel.Const;
 import org.apache.bcel.classfile.Code;
@@ -78,6 +80,8 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
 
     private int priority;
 
+    private final TreeMap<Integer, Integer> branchTargetsByPc = new TreeMap<>();
+
     public SwitchFallthrough(BugReporter bugReporter) {
         this.bugAccumulator = new BugAccumulator(bugReporter);
     }
@@ -103,7 +107,10 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
         deadStore = null;
         priority = NORMAL_PRIORITY;
         enumType = null;
+        branchTargetsByPc.clear();
+
         super.visit(obj);
+
         enumType = null;
         if (!found.isEmpty()) {
             if (found.size() >= 4 && priority == NORMAL_PRIORITY) {
@@ -144,9 +151,13 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
 
     @Override
     public void sawOpcode(int seen) {
-        boolean isDefaultOffset = switchHdlr.getDefaultOffset() == getPC();
+        boolean isDefaultOffset = switchHdlr.getDefaultCasePC() == getPC();
         boolean isCaseOffset = switchHdlr.isOnSwitchOffset(this);
 
+        if (isBranch(seen)) {
+            branchTargetsByPc.put(getPC(), getBranchTarget());
+        }
+
         if (DEBUG) {
             if (seen == Const.GOTO) {
                 System.out.printf("%4d: goto %-7d %s %s %s %d%n", getPC(), getBranchTarget(), reachable, isCaseOffset,
@@ -268,13 +279,13 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
             biggestJumpTarget = -1;
             switchHdlr.enterSwitch(this, enumType);
             if (DEBUG) {
-                System.out.printf("  entered switch, default is %d%n", switchHdlr.getDefaultOffset());
+                System.out.printf("  entered switch, default is %d%n", switchHdlr.getDefaultCasePC());
             }
             break;
 
         case Const.GOTO_W:
         case Const.GOTO:
-            if (isBranchTargetOutsideOfNextCase() || switchHdlr.getDefaultOffset() == getBranchTarget()) {
+            if (isBranchTargetOutsideOfNextCase() || switchHdlr.getLastCasePC() == getBranchTarget()) {
                 if (biggestJumpTarget < getBranchTarget()) {
                     biggestJumpTarget = getBranchTarget();
                     if (DEBUG) {
@@ -313,26 +324,46 @@ public class SwitchFallthrough extends OpcodeStackDetector implements StatelessD
      * A GOTO might correspond to a <code>break</code> or to a do/while/for loop.
      * For loops the branch target will be before the offset of the next case, for breaks we're exiting the switch so the target is actually even after the end of the last case.
      * The branch target might be before the switch when we're inside another structure such as a loop.
-     *
-     * @return <code>true</code> if:
-     * <ul>
-     * <li> the branch target is a GOTO instruction as it is the case for a no-op (empty block) in an arrow-syntax switch
-     * <li> the branch target is after the next switch offset as it is the case for a switch break</li>
-     * <li> or the branch target is before the PC corresponding to the switch instruction</li>
-     * <li> or there's no next switch case (as it is the case for the default case)</li>
-     * </ul>
      */
     public boolean isBranchTargetOutsideOfNextCase() {
         int branchTarget = getBranchTarget();
+
+        // the branch target is a GOTO instruction as it is the case for a no-op (empty block) in an arrow-syntax switch
         if (getCodeByte(branchTarget) == Const.GOTO) {
             return true;
         }
 
         SwitchDetails nextSwitchDetails = switchHdlr.getNextSwitchDetails(this);
 
+        if (nextSwitchDetails != null
+                // The GOTO brings us back to an earlier PC
+                && branchTarget < getPC()
+                // This is the last instruction of the case
+                && getNextPC() == switchHdlr.getNextSwitchCasePC(this)) {
+            // get the entry for <PC of the branch instruction we're getting back to, branch target of that branch instruction>
+            Entry<Integer, Integer> nextBranchTargetAfterBranchTarget = branchTargetsByPc.higherEntry(branchTarget);
+
+            if (nextBranchTargetAfterBranchTarget != null) {
+                // the branch target of the GOTO is followed by an IF (it's a while GOTO)
+                if (isIf(getCodeByte(nextBranchTargetAfterBranchTarget.getKey()))
+                        // And its target is after the next case so there's no fallthrough
+                        && nextBranchTargetAfterBranchTarget.getValue() > nextSwitchDetails.getNextSwitchCasePC(getPC())) {
+                    return true;
+                }
+
+                // there's no IF so it's an unconditional while(true) loop
+                if (!isIf(getCodeByte(nextBranchTargetAfterBranchTarget.getKey()))) {
+                    return true;
+                }
+            }
+        }
+
         if (nextSwitchDetails != null) {
-            return branchTarget > nextSwitchDetails.getNextSwitchOffset(getPC()) || branchTarget < nextSwitchDetails.getSwitchPC();
+            // the branch target is after the next switch offset as it is the case for a switch break
+            // or the branch target is before the PC corresponding to the switch instruction
+            return branchTarget > nextSwitchDetails.getNextSwitchCasePC(getPC()) || branchTarget < nextSwitchDetails.getSwitchPC();
         } else {
+            // or there's no next switch case (as it is the case for the default case)
             return true;
         }
     }
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/visitclass/DismantleBytecode.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/visitclass/DismantleBytecode.java
index f6a0aa8e1..31858aa01 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/visitclass/DismantleBytecode.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/visitclass/DismantleBytecode.java
@@ -429,6 +429,19 @@ public abstract class DismantleBytecode extends AnnotationVisitor {
         return opcode == Const.LOOKUPSWITCH || opcode == Const.TABLESWITCH;
     }
 
+    /**
+     * Return whether or not given opcode is an IF instruction.
+     *
+     * @param opcode
+     *            the opcode
+     * @return true if instruction is an IF, false if not
+     */
+    public static boolean isIf(int opcode) {
+        return (opcode >= Const.IFEQ && opcode <= Const.IF_ACMPNE)
+                || opcode == Const.IFNULL
+                || opcode == Const.IFNONNULL;
+    }
+
     @SuppressFBWarnings("EI")
     public int[] getSwitchOffsets() {
         if (switchOffsets == null) {
diff --git a/spotbugsTestCases/src/java/ghIssues/Issue3767.java b/spotbugsTestCases/src/java/ghIssues/Issue3767.java
new file mode 100644
index 000000000..6d9a8721b
--- /dev/null
+++ b/spotbugsTestCases/src/java/ghIssues/Issue3767.java
@@ -0,0 +1,81 @@
+package ghIssues;
+
+import java.io.IOException;
+
+public class Issue3767 {
+    private int m;
+
+    public void check(int state) {
+
+        switch (state) {
+            default:
+                return;
+            case 1:
+                m = m + 1;
+                break;
+            case 2:
+                break;
+        }
+    }
+    
+    public void printNumbers(int size, int type) {
+        switch (type) {
+            case 1:
+                int  k = 1;
+                while (k < size - 1) {
+                    k++;
+                }
+                break;
+            case 2:
+                k = 1;
+                while (k < size - 1) {
+                    k++;
+                }
+                break;
+            default:
+                // should not happen
+                break;
+        }
+    }
+
+    final public String term(int state) throws IOException {
+
+        switch (state) {
+            case 1:{
+                label_5: while (true) {
+                    switch (2 * state) {
+                        case 8:{
+                            ;
+                            break;
+                        }
+                        default:
+                            m = 2;
+                            break label_5;
+                    }
+                    m = 1;
+                }
+                break;
+            }
+            case 2:{
+                label_6:
+                while (true) {
+                    switch (2 * state) {
+                        case 8:{
+                            ;
+                            break;
+                        }
+                        default:
+                            m = 2;
+                            break label_6;
+                    }
+                    m = 1;
+                }
+                break;
+            }
+            default:
+                m = 7;
+                throw new IOException();
+        }
+        return "";
+    }
+}
