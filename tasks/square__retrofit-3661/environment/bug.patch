diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index 6846f763..6084fc66 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -75,12 +75,10 @@ abstract class ParameterHandler<T> {
   static final class Header<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
-    private final boolean allowUnsafeNonAsciiValues;
 
-    Header(String name, Converter<T, String> valueConverter, boolean allowUnsafeNonAsciiValues) {
+    Header(String name, Converter<T, String> valueConverter) {
       this.name = Objects.requireNonNull(name, "name == null");
       this.valueConverter = valueConverter;
-      this.allowUnsafeNonAsciiValues = allowUnsafeNonAsciiValues;
     }
 
     @Override
@@ -90,7 +88,7 @@ abstract class ParameterHandler<T> {
       String headerValue = valueConverter.convert(value);
       if (headerValue == null) return; // Skip converted but null values.
 
-      builder.addHeader(name, headerValue, allowUnsafeNonAsciiValues);
+      builder.addHeader(name, headerValue);
     }
   }
 
@@ -210,17 +208,11 @@ abstract class ParameterHandler<T> {
     private final Method method;
     private final int p;
     private final Converter<T, String> valueConverter;
-    private final boolean allowUnsafeNonAsciiValues;
 
-    HeaderMap(
-        Method method,
-        int p,
-        Converter<T, String> valueConverter,
-        boolean allowUnsafeNonAsciiValues) {
+    HeaderMap(Method method, int p, Converter<T, String> valueConverter) {
       this.method = method;
       this.p = p;
       this.valueConverter = valueConverter;
-      this.allowUnsafeNonAsciiValues = allowUnsafeNonAsciiValues;
     }
 
     @Override
@@ -239,8 +231,7 @@ abstract class ParameterHandler<T> {
           throw Utils.parameterError(
               method, p, "Header map contained null value for key '" + headerName + "'.");
         }
-        builder.addHeader(
-            headerName, valueConverter.convert(headerValue), allowUnsafeNonAsciiValues);
+        builder.addHeader(headerName, valueConverter.convert(headerValue));
       }
     }
   }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index 2fa224f1..d47f61fe 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -100,15 +100,13 @@ final class RequestBuilder {
     this.relativeUrl = relativeUrl.toString();
   }
 
-  void addHeader(String name, String value, boolean allowUnsafeNonAsciiValues) {
+  void addHeader(String name, String value) {
     if ("Content-Type".equalsIgnoreCase(name)) {
       try {
         contentType = MediaType.get(value);
       } catch (IllegalArgumentException e) {
         throw new IllegalArgumentException("Malformed content type: " + value, e);
       }
-    } else if (allowUnsafeNonAsciiValues) {
-      headersBuilder.addUnsafeNonAscii(name, value);
     } else {
       headersBuilder.add(name, value);
     }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index 04f27bba..36b9d0eb 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -241,12 +241,11 @@ final class RequestFactory {
         HTTP http = (HTTP) annotation;
         parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
       } else if (annotation instanceof retrofit2.http.Headers) {
-        retrofit2.http.Headers headers = (retrofit2.http.Headers) annotation;
-        String[] headersToParse = headers.value();
+        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
         if (headersToParse.length == 0) {
           throw methodError(method, "@Headers annotation is empty.");
         }
-        this.headers = parseHeaders(headersToParse, headers.allowUnsafeNonAsciiValues());
+        headers = parseHeaders(headersToParse);
       } else if (annotation instanceof Multipart) {
         if (isFormEncoded) {
           throw methodError(method, "Only one encoding annotation is allowed.");
@@ -294,7 +293,7 @@ final class RequestFactory {
       this.relativeUrlParamNames = parsePathParameters(value);
     }
 
-    private Headers parseHeaders(String[] headers, boolean allowUnsafeNonAsciiValues) {
+    private Headers parseHeaders(String[] headers) {
       Headers.Builder builder = new Headers.Builder();
       for (String header : headers) {
         int colon = header.indexOf(':');
@@ -310,8 +309,6 @@ final class RequestFactory {
           } catch (IllegalArgumentException e) {
             throw methodError(method, e, "Malformed content type: %s", headerValue);
           }
-        } else if (allowUnsafeNonAsciiValues) {
-          builder.addUnsafeNonAscii(headerName, headerValue);
         } else {
           builder.add(headerName, headerValue);
         }
@@ -527,17 +524,15 @@ final class RequestFactory {
           ParameterizedType parameterizedType = (ParameterizedType) type;
           Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
           Converter<?, String> converter = retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Header<>(name, converter, header.allowUnsafeNonAsciiValues())
-              .iterable();
+          return new ParameterHandler.Header<>(name, converter).iterable();
         } else if (rawParameterType.isArray()) {
           Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
           Converter<?, String> converter =
               retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Header<>(name, converter, header.allowUnsafeNonAsciiValues())
-              .array();
+          return new ParameterHandler.Header<>(name, converter).array();
         } else {
           Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Header<>(name, converter, header.allowUnsafeNonAsciiValues());
+          return new ParameterHandler.Header<>(name, converter);
         }
 
       } else if (annotation instanceof HeaderMap) {
@@ -563,8 +558,7 @@ final class RequestFactory {
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         Converter<?, String> valueConverter = retrofit.stringConverter(valueType, annotations);
 
-        return new ParameterHandler.HeaderMap<>(
-            method, p, valueConverter, ((HeaderMap) annotation).allowUnsafeNonAsciiValues());
+        return new ParameterHandler.HeaderMap<>(method, p, valueConverter);
 
       } else if (annotation instanceof Field) {
         validateResolvableType(p, type);
diff --git a/retrofit/src/main/java/retrofit2/http/Header.java b/retrofit/src/main/java/retrofit2/http/Header.java
index 5c383215..95b08cb1 100644
--- a/retrofit/src/main/java/retrofit2/http/Header.java
+++ b/retrofit/src/main/java/retrofit2/http/Header.java
@@ -33,14 +33,6 @@ import java.lang.annotation.Target;
  * Header parameters may be {@code null} which will omit them from the request. Passing a {@link
  * java.util.List List} or array will result in a header for each non-{@code null} item.
  *
- * <p>Parameter keys and values only allows ascii values by default. Specify {@link
- * #allowUnsafeNonAsciiValues() allowUnsafeNonAsciiValues=true} to change this behavior.
- *
- * <pre><code>
- * &#64;GET("/")
- * Call&lt;ResponseBody&gt; foo(@Header("Accept-Language", allowUnsafeNonAsciiValues=true) String lang);
- * </code></pre>
- *
  * <p><strong>Note:</strong> Headers do not overwrite each other. All headers with the same name
  * will be included in the request.
  *
@@ -51,12 +43,5 @@ import java.lang.annotation.Target;
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface Header {
-
-  /** The query parameter name. */
   String value();
-
-  /**
-   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
-   */
-  boolean allowUnsafeNonAsciiValues() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
index c1aa98f4..e0fdccc7 100644
--- a/retrofit/src/main/java/retrofit2/http/HeaderMap.java
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -45,20 +45,10 @@ import retrofit2.Retrofit;
  * foo.list(ImmutableMap.of("Accept", "text/plain", "Accept-Charset", "utf-8"));
  * </pre>
  *
- * <p>Map keys and values representing parameter values allow only ascii values by default.
- * Specify {@link #allowUnsafeNonAsciiValues() allowUnsafeNonAsciiValues=true} to change this behavior.
- *
- * <pre>
- * &#64;GET("/search")
- * void list(@HeaderMap(allowUnsafeNonAsciiValues=true) Map&lt;String, String&gt; headers);
- *
  * @see Header
  * @see Headers
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
-public @interface HeaderMap {
-  /** Specifies whether the parameter values are allowed with unsafe non ascii values. */
-  boolean allowUnsafeNonAsciiValues() default false;
-}
+public @interface HeaderMap {}
diff --git a/retrofit/src/main/java/retrofit2/http/Headers.java b/retrofit/src/main/java/retrofit2/http/Headers.java
index ceb4b53d..7bc48b89 100644
--- a/retrofit/src/main/java/retrofit2/http/Headers.java
+++ b/retrofit/src/main/java/retrofit2/http/Headers.java
@@ -38,13 +38,8 @@ import java.lang.annotation.Target;
  * ...
  * </code></pre>
  *
- * <p>Parameter keys and values only allows ascii values by default. Specify {@link
- * #allowUnsafeNonAsciiValues() allowUnsafeNonAsciiValues=true} to change this behavior.
- *
- * <p>&#64;Headers({ "X-Foo: Bar", "X-Ping: Pong" }, allowUnsafeNonAsciiValues=true) &#64;GET("/")
- *
- * <p><strong>Note:</strong> Headers do not overwrite each other. All headers with the same name
- * will be included in the request.
+ * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
+ * be included in the request.
  *
  * @see Header
  * @see HeaderMap
@@ -53,12 +48,5 @@ import java.lang.annotation.Target;
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface Headers {
-
-  /** The query parameter name. */
   String[] value();
-
-  /**
-   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
-   */
-  boolean allowUnsafeNonAsciiValues() default false;
 }
diff --git a/retrofit/src/test/java/retrofit2/RequestFactoryTest.java b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
index 79e33a25..7add6e5f 100644
--- a/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestFactoryTest.java
@@ -782,29 +782,6 @@ public final class RequestFactoryTest {
     }
   }
 
-  @Test
-  public void getWithHeaderMapAllowingUnsafeNonAsciiValues() {
-    class Example {
-      @GET("/search")
-      Call<ResponseBody> method(
-          @HeaderMap(allowUnsafeNonAsciiValues = true) Map<String, Object> headers) {
-        return null;
-      }
-    }
-
-    Map<String, Object> headers = new LinkedHashMap<>();
-    headers.put("Accept", "text/plain");
-    headers.put("Title", "Kein plötzliches");
-
-    Request request = buildRequest(Example.class, headers);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/search");
-    assertThat(request.body()).isNull();
-    assertThat(request.headers().size()).isEqualTo(2);
-    assertThat(request.header("Accept")).isEqualTo("text/plain");
-    assertThat(request.header("Title")).isEqualTo("Kein plötzliches");
-  }
-
   @Test
   public void twoBodies() {
     class Example {
@@ -2855,27 +2832,6 @@ public final class RequestFactoryTest {
     assertThat(request.body()).isNull();
   }
 
-  @Test
-  public void simpleHeadersAllowingUnsafeNonAsciiValues() {
-    class Example {
-      @GET("/foo/bar/")
-      @Headers(
-          value = {"ping: pong", "title: Kein plötzliches"},
-          allowUnsafeNonAsciiValues = true)
-      Call<ResponseBody> method() {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class);
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("title")).isEqualTo("Kein plötzliches");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
   @Test
   public void headersDoNotOverwriteEachOther() {
     class Example {
@@ -2935,26 +2891,6 @@ public final class RequestFactoryTest {
     assertThat(request.body()).isNull();
   }
 
-  @Test
-  public void headerParamAllowingUnsafeNonAsciiValues() {
-    class Example {
-      @GET("/foo/bar/") //
-      @Headers("ping: pong") //
-      Call<ResponseBody> method(
-          @Header(value = "title", allowUnsafeNonAsciiValues = true) String kit) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "Kein plötzliches");
-    assertThat(request.method()).isEqualTo("GET");
-    okhttp3.Headers headers = request.headers();
-    assertThat(headers.size()).isEqualTo(2);
-    assertThat(headers.get("ping")).isEqualTo("pong");
-    assertThat(headers.get("title")).isEqualTo("Kein plötzliches");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-    assertThat(request.body()).isNull();
-  }
-
   @Test
   public void headerParamList() {
     class Example {
