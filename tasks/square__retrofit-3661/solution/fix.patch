diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index 6084fc66..6846f763 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -75,10 +75,12 @@ abstract class ParameterHandler<T> {
   static final class Header<T> extends ParameterHandler<T> {
     private final String name;
     private final Converter<T, String> valueConverter;
+    private final boolean allowUnsafeNonAsciiValues;
 
-    Header(String name, Converter<T, String> valueConverter) {
+    Header(String name, Converter<T, String> valueConverter, boolean allowUnsafeNonAsciiValues) {
       this.name = Objects.requireNonNull(name, "name == null");
       this.valueConverter = valueConverter;
+      this.allowUnsafeNonAsciiValues = allowUnsafeNonAsciiValues;
     }
 
     @Override
@@ -88,7 +90,7 @@ abstract class ParameterHandler<T> {
       String headerValue = valueConverter.convert(value);
       if (headerValue == null) return; // Skip converted but null values.
 
-      builder.addHeader(name, headerValue);
+      builder.addHeader(name, headerValue, allowUnsafeNonAsciiValues);
     }
   }
 
@@ -208,11 +210,17 @@ abstract class ParameterHandler<T> {
     private final Method method;
     private final int p;
     private final Converter<T, String> valueConverter;
+    private final boolean allowUnsafeNonAsciiValues;
 
-    HeaderMap(Method method, int p, Converter<T, String> valueConverter) {
+    HeaderMap(
+        Method method,
+        int p,
+        Converter<T, String> valueConverter,
+        boolean allowUnsafeNonAsciiValues) {
       this.method = method;
       this.p = p;
       this.valueConverter = valueConverter;
+      this.allowUnsafeNonAsciiValues = allowUnsafeNonAsciiValues;
     }
 
     @Override
@@ -231,7 +239,8 @@ abstract class ParameterHandler<T> {
           throw Utils.parameterError(
               method, p, "Header map contained null value for key '" + headerName + "'.");
         }
-        builder.addHeader(headerName, valueConverter.convert(headerValue));
+        builder.addHeader(
+            headerName, valueConverter.convert(headerValue), allowUnsafeNonAsciiValues);
       }
     }
   }
diff --git a/retrofit/src/main/java/retrofit2/RequestBuilder.java b/retrofit/src/main/java/retrofit2/RequestBuilder.java
index d47f61fe..2fa224f1 100644
--- a/retrofit/src/main/java/retrofit2/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit2/RequestBuilder.java
@@ -100,13 +100,15 @@ final class RequestBuilder {
     this.relativeUrl = relativeUrl.toString();
   }
 
-  void addHeader(String name, String value) {
+  void addHeader(String name, String value, boolean allowUnsafeNonAsciiValues) {
     if ("Content-Type".equalsIgnoreCase(name)) {
       try {
         contentType = MediaType.get(value);
       } catch (IllegalArgumentException e) {
         throw new IllegalArgumentException("Malformed content type: " + value, e);
       }
+    } else if (allowUnsafeNonAsciiValues) {
+      headersBuilder.addUnsafeNonAscii(name, value);
     } else {
       headersBuilder.add(name, value);
     }
diff --git a/retrofit/src/main/java/retrofit2/RequestFactory.java b/retrofit/src/main/java/retrofit2/RequestFactory.java
index 36b9d0eb..04f27bba 100644
--- a/retrofit/src/main/java/retrofit2/RequestFactory.java
+++ b/retrofit/src/main/java/retrofit2/RequestFactory.java
@@ -241,11 +241,12 @@ final class RequestFactory {
         HTTP http = (HTTP) annotation;
         parseHttpMethodAndPath(http.method(), http.path(), http.hasBody());
       } else if (annotation instanceof retrofit2.http.Headers) {
-        String[] headersToParse = ((retrofit2.http.Headers) annotation).value();
+        retrofit2.http.Headers headers = (retrofit2.http.Headers) annotation;
+        String[] headersToParse = headers.value();
         if (headersToParse.length == 0) {
           throw methodError(method, "@Headers annotation is empty.");
         }
-        headers = parseHeaders(headersToParse);
+        this.headers = parseHeaders(headersToParse, headers.allowUnsafeNonAsciiValues());
       } else if (annotation instanceof Multipart) {
         if (isFormEncoded) {
           throw methodError(method, "Only one encoding annotation is allowed.");
@@ -293,7 +294,7 @@ final class RequestFactory {
       this.relativeUrlParamNames = parsePathParameters(value);
     }
 
-    private Headers parseHeaders(String[] headers) {
+    private Headers parseHeaders(String[] headers, boolean allowUnsafeNonAsciiValues) {
       Headers.Builder builder = new Headers.Builder();
       for (String header : headers) {
         int colon = header.indexOf(':');
@@ -309,6 +310,8 @@ final class RequestFactory {
           } catch (IllegalArgumentException e) {
             throw methodError(method, e, "Malformed content type: %s", headerValue);
           }
+        } else if (allowUnsafeNonAsciiValues) {
+          builder.addUnsafeNonAscii(headerName, headerValue);
         } else {
           builder.add(headerName, headerValue);
         }
@@ -524,15 +527,17 @@ final class RequestFactory {
           ParameterizedType parameterizedType = (ParameterizedType) type;
           Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
           Converter<?, String> converter = retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.Header<>(name, converter).iterable();
+          return new ParameterHandler.Header<>(name, converter, header.allowUnsafeNonAsciiValues())
+              .iterable();
         } else if (rawParameterType.isArray()) {
           Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
           Converter<?, String> converter =
               retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.Header<>(name, converter).array();
+          return new ParameterHandler.Header<>(name, converter, header.allowUnsafeNonAsciiValues())
+              .array();
         } else {
           Converter<?, String> converter = retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.Header<>(name, converter);
+          return new ParameterHandler.Header<>(name, converter, header.allowUnsafeNonAsciiValues());
         }
 
       } else if (annotation instanceof HeaderMap) {
@@ -558,7 +563,8 @@ final class RequestFactory {
         Type valueType = Utils.getParameterUpperBound(1, parameterizedType);
         Converter<?, String> valueConverter = retrofit.stringConverter(valueType, annotations);
 
-        return new ParameterHandler.HeaderMap<>(method, p, valueConverter);
+        return new ParameterHandler.HeaderMap<>(
+            method, p, valueConverter, ((HeaderMap) annotation).allowUnsafeNonAsciiValues());
 
       } else if (annotation instanceof Field) {
         validateResolvableType(p, type);
diff --git a/retrofit/src/main/java/retrofit2/http/Header.java b/retrofit/src/main/java/retrofit2/http/Header.java
index 95b08cb1..5c383215 100644
--- a/retrofit/src/main/java/retrofit2/http/Header.java
+++ b/retrofit/src/main/java/retrofit2/http/Header.java
@@ -33,6 +33,14 @@ import java.lang.annotation.Target;
  * Header parameters may be {@code null} which will omit them from the request. Passing a {@link
  * java.util.List List} or array will result in a header for each non-{@code null} item.
  *
+ * <p>Parameter keys and values only allows ascii values by default. Specify {@link
+ * #allowUnsafeNonAsciiValues() allowUnsafeNonAsciiValues=true} to change this behavior.
+ *
+ * <pre><code>
+ * &#64;GET("/")
+ * Call&lt;ResponseBody&gt; foo(@Header("Accept-Language", allowUnsafeNonAsciiValues=true) String lang);
+ * </code></pre>
+ *
  * <p><strong>Note:</strong> Headers do not overwrite each other. All headers with the same name
  * will be included in the request.
  *
@@ -43,5 +51,12 @@ import java.lang.annotation.Target;
 @Retention(RUNTIME)
 @Target(PARAMETER)
 public @interface Header {
+
+  /** The query parameter name. */
   String value();
+
+  /**
+   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+   */
+  boolean allowUnsafeNonAsciiValues() default false;
 }
diff --git a/retrofit/src/main/java/retrofit2/http/HeaderMap.java b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
index e0fdccc7..c1aa98f4 100644
--- a/retrofit/src/main/java/retrofit2/http/HeaderMap.java
+++ b/retrofit/src/main/java/retrofit2/http/HeaderMap.java
@@ -45,10 +45,20 @@ import retrofit2.Retrofit;
  * foo.list(ImmutableMap.of("Accept", "text/plain", "Accept-Charset", "utf-8"));
  * </pre>
  *
+ * <p>Map keys and values representing parameter values allow only ascii values by default.
+ * Specify {@link #allowUnsafeNonAsciiValues() allowUnsafeNonAsciiValues=true} to change this behavior.
+ *
+ * <pre>
+ * &#64;GET("/search")
+ * void list(@HeaderMap(allowUnsafeNonAsciiValues=true) Map&lt;String, String&gt; headers);
+ *
  * @see Header
  * @see Headers
  */
 @Documented
 @Target(PARAMETER)
 @Retention(RUNTIME)
-public @interface HeaderMap {}
+public @interface HeaderMap {
+  /** Specifies whether the parameter values are allowed with unsafe non ascii values. */
+  boolean allowUnsafeNonAsciiValues() default false;
+}
diff --git a/retrofit/src/main/java/retrofit2/http/Headers.java b/retrofit/src/main/java/retrofit2/http/Headers.java
index 7bc48b89..ceb4b53d 100644
--- a/retrofit/src/main/java/retrofit2/http/Headers.java
+++ b/retrofit/src/main/java/retrofit2/http/Headers.java
@@ -38,8 +38,13 @@ import java.lang.annotation.Target;
  * ...
  * </code></pre>
  *
- * <strong>Note:</strong> Headers do not overwrite each other. All headers with the same name will
- * be included in the request.
+ * <p>Parameter keys and values only allows ascii values by default. Specify {@link
+ * #allowUnsafeNonAsciiValues() allowUnsafeNonAsciiValues=true} to change this behavior.
+ *
+ * <p>&#64;Headers({ "X-Foo: Bar", "X-Ping: Pong" }, allowUnsafeNonAsciiValues=true) &#64;GET("/")
+ *
+ * <p><strong>Note:</strong> Headers do not overwrite each other. All headers with the same name
+ * will be included in the request.
  *
  * @see Header
  * @see HeaderMap
@@ -48,5 +53,12 @@ import java.lang.annotation.Target;
 @Target(METHOD)
 @Retention(RUNTIME)
 public @interface Headers {
+
+  /** The query parameter name. */
   String[] value();
+
+  /**
+   * Specifies whether the parameter {@linkplain #value() name} and value are already URL encoded.
+   */
+  boolean allowUnsafeNonAsciiValues() default false;
 }
