diff --git a/core/deployment/src/main/java/io/quarkus/deployment/dev/RecompilationDependenciesBuildItem.java b/core/deployment/src/main/java/io/quarkus/deployment/dev/RecompilationDependenciesBuildItem.java
new file mode 100644
index 00000000000..9312f4bd570
--- /dev/null
+++ b/core/deployment/src/main/java/io/quarkus/deployment/dev/RecompilationDependenciesBuildItem.java
@@ -0,0 +1,50 @@
+package io.quarkus.deployment.dev;
+
+import java.util.Map;
+import java.util.Set;
+
+import org.jboss.jandex.DotName;
+
+import io.quarkus.builder.item.MultiBuildItem;
+
+/**
+ * Defines the relationship between classes for the purposes of recompilation.
+ * <p/>
+ * Idea is that multiple classes can be dependent on one other class. For this BuildItem a class can be an outermost class, a
+ * nested class, an annotation, an interface, an enum, or basically anything that has an FQN.
+ * A consolidation step in {@link RecompilationDependenciesProcessor} cleans up the collected recompilation dependencies and
+ * removes duplicates.
+ * <p/>
+ * The collected recompilation dependencies are used to build a relationship tree between the classes in the
+ * {@link RuntimeUpdatesProcessor}, which is build and traversed from the root up and outwards. Class a -> Set of Class -> where
+ * each element class can resolve to another set of classes.
+ * <p/>
+ * The collected recompilation dependencies are used to determine the set of classes which need to additionally be recompiled
+ * when one other class changes.
+ * <p/>
+ * For performance reasons, the scope of the collected recompilation dependencies should be quite narrow. For an
+ * example, the quarkus-mapstruct extension uses this BuildItem to recompile the dependent Mapper classes, once any of the
+ * referenced model classes
+ * changes.
+ */
+public final class RecompilationDependenciesBuildItem extends MultiBuildItem {
+
+    private final Map<DotName, Set<DotName>> classToRecompilationTargets;
+
+    public RecompilationDependenciesBuildItem(Map<DotName, Set<DotName>> classToRecompilationTargets) {
+        this.classToRecompilationTargets = classToRecompilationTargets;
+    }
+
+    /**
+     * Returns the map of recompilation dependencies.
+     * <p>
+     * The key is a dependency class name, while the value is a set of dependent class names that need to be recompiled as well
+     * when the
+     * dependency class changes.
+     *
+     * @return a map where each key is a dependency class name and each value is a set of class names that depend on it
+     */
+    public Map<DotName, Set<DotName>> getClassToRecompilationTargets() {
+        return classToRecompilationTargets;
+    }
+}
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/dev/RecompilationDependenciesProcessor.java b/core/deployment/src/main/java/io/quarkus/deployment/dev/RecompilationDependenciesProcessor.java
new file mode 100644
index 00000000000..5366c15b094
--- /dev/null
+++ b/core/deployment/src/main/java/io/quarkus/deployment/dev/RecompilationDependenciesProcessor.java
@@ -0,0 +1,82 @@
+package io.quarkus.deployment.dev;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.jboss.jandex.ClassInfo;
+import org.jboss.jandex.DotName;
+import org.jboss.jandex.IndexView;
+
+import io.quarkus.deployment.annotations.BuildStep;
+import io.quarkus.deployment.annotations.Produce;
+import io.quarkus.deployment.builditem.CombinedIndexBuildItem;
+import io.quarkus.deployment.builditem.ServiceStartBuildItem;
+
+public class RecompilationDependenciesProcessor {
+
+    /**
+     * Consolidation step, which prepares recompilation of dependent classes.
+     * <p/>
+     * Resolves inner classes to their outer classes. Inner classes and outer classes share
+     * source file (at least in java). For our goal of recompilation we therefore only need to outer class.
+     * <p/>
+     * After resolving outer classes, all the mappings classToRecompilationTargets are combined into one mapping,
+     * deduplicated by class name, and
+     * then given to the {@link RuntimeUpdatesProcessor#setClassToRecompilationTargets(Map)}.
+     *
+     * @param combinedIndexBuildItem Index, only the precomputed index is used, since for the purpose of (re)compilation the
+     *        class has to be in an application source path - which are always indexed.
+     * @param recompilationDependenciesBuildItems Provides the dependencies between classes. Currently, produced only by
+     *        extensions.
+     */
+    @BuildStep
+    @Produce(ServiceStartBuildItem.class)
+    public void consolidateRecompilationDependencies(CombinedIndexBuildItem combinedIndexBuildItem,
+            List<RecompilationDependenciesBuildItem> recompilationDependenciesBuildItems) {
+
+        // Cleanup and combine all the classToRecompilationTargets maps:
+        // - Resolve inner classes to their top-level class names
+        // - Remove entries where the class is not in the index
+        // - combine all classToRecompilationTargets values based on their keys
+
+        Map<DotName, Set<DotName>> classToRecompilationTargets = new HashMap<>();
+        for (RecompilationDependenciesBuildItem buildItem : recompilationDependenciesBuildItems) {
+            buildItem.getClassToRecompilationTargets().forEach((dependency, recompilationTargets) -> {
+                dependency = resolveOutermostClassName(dependency, combinedIndexBuildItem.getIndex());
+                if (dependency == null) {
+                    return;
+                }
+
+                for (DotName recompilationTarget : recompilationTargets) {
+                    recompilationTarget = resolveOutermostClassName(recompilationTarget, combinedIndexBuildItem.getIndex());
+                    if (recompilationTarget == null) {
+                        continue;
+                    }
+
+                    classToRecompilationTargets.computeIfAbsent(dependency, k -> new HashSet<>()).add(recompilationTarget);
+                }
+            });
+        }
+
+        if (RuntimeUpdatesProcessor.INSTANCE != null) {
+            RuntimeUpdatesProcessor.INSTANCE.setClassToRecompilationTargets(classToRecompilationTargets);
+        }
+    }
+
+    private DotName resolveOutermostClassName(DotName name, IndexView index) {
+
+        ClassInfo classInfo = index.getClassByName(name);
+        if (classInfo == null) {
+            return null;
+        }
+
+        if (classInfo.nestingType() != ClassInfo.NestingType.TOP_LEVEL) {
+            return resolveOutermostClassName(classInfo.enclosingClassAlways(), index);
+        }
+
+        return name;
+    }
+}
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java b/core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java
index c4ba5228fcb..36e525c876a 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/dev/RuntimeUpdatesProcessor.java
@@ -2,7 +2,6 @@
 
 import static java.util.Arrays.asList;
 import static java.util.Collections.singletonList;
-import static java.util.stream.Collectors.groupingBy;
 
 import java.io.ByteArrayInputStream;
 import java.io.Closeable;
@@ -21,9 +20,11 @@
 import java.nio.file.StandardCopyOption;
 import java.nio.file.attribute.BasicFileAttributes;
 import java.nio.file.attribute.FileTime;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Deque;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -52,6 +53,7 @@
 import java.util.stream.Stream;
 
 import org.jboss.jandex.ClassInfo;
+import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.IndexView;
 import org.jboss.jandex.Indexer;
@@ -104,6 +106,7 @@ public class RuntimeUpdatesProcessor implements HotReplacementContext, Closeable
     private final TimestampSet main = new TimestampSet();
     private final TimestampSet test = new TimestampSet();
     final Map<Path, Long> sourceFileTimestamps = new ConcurrentHashMap<>();
+    private Map<DotName, Set<DotName>> classToRecompilationTargets = new HashMap<>();
 
     private final List<Runnable> preScanSteps = new CopyOnWriteArrayList<>();
     private final List<Runnable> postRestartSteps = new CopyOnWriteArrayList<>();
@@ -709,6 +712,24 @@ ClassScanResult checkForChangedTestClasses(boolean firstScan) {
         return ret;
     }
 
+    private void collectRecompilationTargets(DotName changedDependency, Set<DotName> knownRecompilationTargets) {
+        Deque<DotName> toResolve = new ArrayDeque<>();
+        toResolve.add(changedDependency);
+        while (!toResolve.isEmpty()) {
+            DotName currentDependency = toResolve.poll();
+
+            Set<DotName> recompilationTargets = classToRecompilationTargets.get(currentDependency);
+
+            if (recompilationTargets != null) {
+                for (DotName className : recompilationTargets) {
+                    if (knownRecompilationTargets.add(className)) {
+                        toResolve.add(className);
+                    }
+                }
+            }
+        }
+    }
+
     /**
      * A first scan is considered done when we have visited all modules at least once.
      * This is useful in two ways.
@@ -720,33 +741,81 @@ ClassScanResult checkForChangedClasses(QuarkusCompiler compiler,
             Function<DevModeContext.ModuleInfo, DevModeContext.CompilationUnit> cuf, boolean firstScan,
             TimestampSet timestampSet, boolean compilingTests) {
         ClassScanResult classScanResult = new ClassScanResult();
-        boolean ignoreFirstScanChanges = firstScan;
+
+        record RecompilableLocationsBySourcePath(Path sourcePath, Set<File> changedFiles, Set<File> changedDependencies) {
+        }
+        record ChangeDetectionResult(DevModeContext.ModuleInfo moduleInfo,
+                List<RecompilableLocationsBySourcePath> changedLocations) {
+        }
+        List<ChangeDetectionResult> changeDetectionResults = new ArrayList<>();
+        Set<DotName> knownRecompilationTargets = new HashSet<>();
 
         for (DevModeContext.ModuleInfo module : context.getAllModules()) {
-            final List<Path> moduleChangedSourceFilePaths = new ArrayList<>();
+            ChangeDetectionResult changeDetectionResult = new ChangeDetectionResult(module, new ArrayList<>());
 
             for (Path sourcePath : cuf.apply(module).getSourcePaths()) {
                 if (!Files.exists(sourcePath)) {
                     continue;
                 }
+
                 final Set<File> changedSourceFiles;
                 try (final Stream<Path> sourcesStream = Files.walk(sourcePath)) {
                     changedSourceFiles = sourcesStream
                             .parallel()
                             .filter(p -> matchingHandledExtension(p).isPresent()
-                                    && sourceFileWasRecentModified(p, ignoreFirstScanChanges, firstScan))
+                                    && sourceFileWasRecentModified(p, firstScan, firstScan))
                             .map(Path::toFile)
                             //Needing a concurrent Set, not many standard options:
                             .collect(Collectors.toCollection(ConcurrentSkipListSet::new));
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }
+
                 if (!changedSourceFiles.isEmpty()) {
+                    RecompilableLocationsBySourcePath recompilableLocationsBySourcePath = new RecompilableLocationsBySourcePath(
+                            sourcePath, changedSourceFiles, new HashSet<>());
+                    changeDetectionResult.changedLocations().add(recompilableLocationsBySourcePath);
+
+                    for (File changedSourceFile : changedSourceFiles) {
+                        String changedDependency = convertFileToClassname(sourcePath, changedSourceFile);
+
+                        collectRecompilationTargets(DotName.createSimple(changedDependency), knownRecompilationTargets);
+                    }
+                }
+            }
+            changeDetectionResults.add(changeDetectionResult);
+        }
+
+        for (DotName recompilationTarget : knownRecompilationTargets) {
+            String partialRelativePath = recompilationTarget.toString('/');
+
+            OUT: for (ChangeDetectionResult changeDetectionResult : changeDetectionResults) {
+                for (RecompilableLocationsBySourcePath recompilableLocationsBySourcePath : changeDetectionResult
+                        .changedLocations()) {
+                    for (String extension : compiler.allHandledExtensions()) {
+                        Path resolved = recompilableLocationsBySourcePath.sourcePath().resolve(partialRelativePath + extension);
+
+                        if (Files.exists(resolved)) {
+                            recompilableLocationsBySourcePath.changedDependencies().add(resolved.toFile());
+                            break OUT;
+                        }
+                    }
+                }
+            }
+        }
+
+        for (ChangeDetectionResult changeDetectionResult : changeDetectionResults) {
+            final List<Path> moduleChangedSourceFilePaths = new ArrayList<>();
+            for (RecompilableLocationsBySourcePath recompilableLocationsBySourcePath : changeDetectionResult
+                    .changedLocations()) {
+                Path sourcePath = recompilableLocationsBySourcePath.sourcePath();
+                Set<File> changedSourceFiles = recompilableLocationsBySourcePath.changedFiles();
+                if (!changedSourceFiles.isEmpty() || !recompilableLocationsBySourcePath.changedDependencies().isEmpty()) {
                     classScanResult.compilationHappened = true;
                     //so this is pretty yuck, but on a lot of systems a write is actually a truncate + write
                     //its possible we see the truncated file timestamp, then the write updates the timestamp
                     //which will then re-trigger continuous testing/live reload
-                    //the empty fine does not normally cause issues as by the time we actually compile it the write
+                    //the empty file does not normally cause issues as by the time we actually compile it the write
                     //has completed (but the old timestamp is used)
                     for (File i : changedSourceFiles) {
                         if (i.length() == 0) {
@@ -761,6 +830,7 @@ && sourceFileWasRecentModified(p, ignoreFirstScanChanges, firstScan))
                             }
                         }
                     }
+
                     Map<File, Long> compileTimestamps = new HashMap<>();
 
                     //now we record the timestamps as they are before the compile phase
@@ -769,12 +839,18 @@ && sourceFileWasRecentModified(p, ignoreFirstScanChanges, firstScan))
                     }
                     for (;;) {
                         try {
-                            final Set<Path> changedPaths = changedSourceFiles.stream()
-                                    .map(File::toPath)
-                                    .collect(Collectors.toSet());
+                            Map<String, Set<File>> changedFilesByExtension = new HashMap<>();
+                            Set<Path> changedPaths = new HashSet<>();
+                            Stream.concat(changedSourceFiles.stream(),
+                                    recompilableLocationsBySourcePath.changedDependencies.stream()).forEach(file -> {
+                                        changedPaths.add(file.toPath());
+
+                                        Set<File> files = changedFilesByExtension.computeIfAbsent(this.getFileExtension(file),
+                                                k -> new HashSet<>());
+                                        files.add(file);
+                                    });
                             moduleChangedSourceFilePaths.addAll(changedPaths);
-                            compiler.compile(sourcePath.toString(), changedSourceFiles.stream()
-                                    .collect(groupingBy(this::getFileExtension, Collectors.toSet())));
+                            compiler.compile(sourcePath.toString(), changedFilesByExtension);
                             compileProblem = null;
                             if (compilingTests) {
                                 testCompileProblem = null;
@@ -812,12 +888,10 @@ && sourceFileWasRecentModified(p, ignoreFirstScanChanges, firstScan))
                         sourceFileTimestamps.put(entry.getKey().toPath(), entry.getValue());
                     }
                 }
-
             }
-
-            checkForClassFilesChangesInModule(module, moduleChangedSourceFilePaths, ignoreFirstScanChanges, classScanResult,
+            checkForClassFilesChangesInModule(changeDetectionResult.moduleInfo(), moduleChangedSourceFilePaths,
+                    firstScan, classScanResult,
                     cuf, timestampSet);
-
         }
 
         return classScanResult;
@@ -922,6 +996,19 @@ private String getFileExtension(File file) {
         return name.substring(lastIndexOf);
     }
 
+    // convert a filename to a class name with package
+    private String convertFileToClassname(Path sourcePath, File file) {
+        String className = sourcePath.relativize(file.toPath())
+                .toString();
+        className = className.replace(File.separatorChar, '.');
+
+        int lastIndexOf = className.lastIndexOf('.');
+        if (lastIndexOf > 0) {
+            className = className.substring(0, lastIndexOf);
+        }
+        return className;
+    }
+
     Set<String> checkForFileChange() {
         return checkForFileChange(DevModeContext.ModuleInfo::getMain, main);
     }
@@ -1155,6 +1242,11 @@ public RuntimeUpdatesProcessor setDisableInstrumentationForIndexPredicate(
         return this;
     }
 
+    public RuntimeUpdatesProcessor setClassToRecompilationTargets(Map<DotName, Set<DotName>> classToRecompilationTargets) {
+        this.classToRecompilationTargets = classToRecompilationTargets;
+        return this;
+    }
+
     public RuntimeUpdatesProcessor setWatchedFilePaths(Map<String, Boolean> watchedFilePaths,
             List<Entry<Predicate<String>, Boolean>> watchedFilePredicates, boolean isTest) {
         if (isTest) {
