diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 8b6740471..cf93689f7 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -124,6 +124,9 @@ Oliver Drotbohm (@odrotbohm)
   [3.1.0]
 
 @JacksonJang
+ * Contributed fix for #1516: Problem with multi-argument Creator with
+   `@JsonBackReference` property
+  [3.1.0]
  * Contributed fix for #4629: `@JsonIncludeProperties` and `@JsonIgnoreProperties`
    ignored when deserializing Records
   [3.1.0]
diff --git a/release-notes/VERSION b/release-notes/VERSION
index fd4597f0c..ac39ecd9c 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -11,6 +11,9 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #1196: Add opt-in error collection for deserialization
  (requested by @odrotbohm)
  (contributed by @sri-adarsh-kumar)
+#1516: Problem with multi-argument Creator with `@JsonBackReference` property
+ (reported by @sarahlikesglitter)
+ (fix by @JacksonJang)
 #1654: @JsonDeserialize(contentUsing=...) is ignored if content
   type is determined by @JsonTypeInfo
  (reported by @pdegoeje)
diff --git a/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java
index 43701c9d7..c10a4efd4 100644
--- a/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java
+++ b/src/main/java/tools/jackson/databind/deser/BasicDeserializerFactory.java
@@ -603,6 +603,13 @@ public abstract class BasicDeserializerFactory
         SettableBeanProperty prop = CreatorProperty.construct(name, type, property.getWrapperName(),
                 typeDeser, beanDescRef.getClassAnnotations(), param, index, injectable,
                 metadata);
+        // [databind#1516]: Handle @JsonManagedReference for creator properties
+        if (intr != null) {
+            AnnotationIntrospector.ReferenceProperty ref = intr.findReferenceType(config, param);
+            if (ref != null && ref.isManagedReference()) {
+                prop.setManagedReferenceName(ref.getName());
+            }
+        }
         ValueDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, param);
         if (deser == null) {
             deser = (ValueDeserializer<?>) type.getValueHandler();
diff --git a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
index 81d17bcb7..695d91b35 100644
--- a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
@@ -10,10 +10,7 @@ import tools.jackson.databind.deser.BeanDeserializerBuilder;
 import tools.jackson.databind.deser.ReadableObjectId.Referring;
 import tools.jackson.databind.deser.SettableBeanProperty;
 import tools.jackson.databind.deser.UnresolvedForwardReference;
-import tools.jackson.databind.deser.impl.ExternalTypeHandler;
-import tools.jackson.databind.deser.impl.MethodProperty;
-import tools.jackson.databind.deser.impl.ObjectIdReader;
-import tools.jackson.databind.deser.impl.UnwrappedPropertyHandler;
+import tools.jackson.databind.deser.impl.*;
 import tools.jackson.databind.util.ClassUtil;
 import tools.jackson.databind.util.IgnorePropertiesUtil;
 import tools.jackson.databind.util.NameTransformer;
@@ -679,6 +676,19 @@ public class BeanDeserializer
         } catch (Exception e) {
             return wrapInstantiationProblem(ctxt, e);
         }
+
+        // [databind#1516]: Inject back references for managed reference creator properties
+        if (creator.hasManagedReferenceProperties()) {
+            for (SettableBeanProperty prop : creator.properties()) {
+                if (prop instanceof ManagedReferenceProperty managedProp) {
+                    Object value = buffer.getParameter(ctxt, prop);
+                    if (value != null) {
+                        managedProp.set(ctxt, bean, value);
+                    }
+                }
+            }
+        }
+
         p.assignCurrentValue(bean);
         // [databind#4938] Since 2.19, allow returning `null` from creator,
         //  but if so, need to skip all possibly relevant content
diff --git a/src/main/java/tools/jackson/databind/deser/bean/PropertyBasedCreator.java b/src/main/java/tools/jackson/databind/deser/bean/PropertyBasedCreator.java
index f94f7fdd6..077ad6190 100644
--- a/src/main/java/tools/jackson/databind/deser/bean/PropertyBasedCreator.java
+++ b/src/main/java/tools/jackson/databind/deser/bean/PropertyBasedCreator.java
@@ -9,6 +9,7 @@ import tools.jackson.databind.*;
 import tools.jackson.databind.deser.SettableAnyProperty;
 import tools.jackson.databind.deser.SettableBeanProperty;
 import tools.jackson.databind.deser.ValueInstantiator;
+import tools.jackson.databind.deser.impl.ManagedReferenceProperty;
 import tools.jackson.databind.deser.impl.ObjectIdReader;
 import tools.jackson.databind.util.NameTransformer;
 
@@ -54,6 +55,14 @@ public final class PropertyBasedCreator
      */
     protected final BitSet _injectablePropIndexes;
 
+    /**
+     * Flag indicating whether any creator properties are ManagedReferenceProperty instances,
+     * used to optimize deserialization by skipping back-reference injection when not needed.
+     *
+     * @since 3.1
+     */
+    protected final boolean _hasManagedReferenceProperties;
+
     /*
     /**********************************************************************
     /* Construction, initialization
@@ -93,6 +102,7 @@ public final class PropertyBasedCreator
         _propertyCount = len;
         _propertiesInOrder = new SettableBeanProperty[len];
         BitSet injectablePropIndexes = null;
+        boolean hasManagedRef = false;
 
         for (int i = 0; i < len; ++i) {
             SettableBeanProperty prop = creatorProps[i];
@@ -107,9 +117,14 @@ public final class PropertyBasedCreator
                 }
                 injectablePropIndexes.set(i);
             }
+
+            // [databind#1516]: detect whether any ManagedReferenceProperty exists
+            // so we can avoid iterating over all properties when none are present
+            hasManagedRef |= prop instanceof ManagedReferenceProperty;
         }
 
         _injectablePropIndexes = injectablePropIndexes;
+        _hasManagedReferenceProperties = hasManagedRef;
     }
 
     protected PropertyBasedCreator(PropertyBasedCreator base,
@@ -121,6 +136,7 @@ public final class PropertyBasedCreator
         _injectablePropIndexes = base._injectablePropIndexes;
         _propertyLookup = propertyLookup;
         _propertiesInOrder = allProperties;
+        _hasManagedReferenceProperties = base._hasManagedReferenceProperties;
     }
 
     /**
@@ -238,6 +254,13 @@ public final class PropertyBasedCreator
         return null;
     }
 
+    /**
+     * @since 3.1
+     */
+    public boolean hasManagedReferenceProperties() {
+        return _hasManagedReferenceProperties;
+    }
+
     /*
     /**********************************************************************
     /* Building process
diff --git a/src/main/java/tools/jackson/databind/deser/impl/ManagedReferenceProperty.java b/src/main/java/tools/jackson/databind/deser/impl/ManagedReferenceProperty.java
index 97d364eda..9ccb3faa5 100644
--- a/src/main/java/tools/jackson/databind/deser/impl/ManagedReferenceProperty.java
+++ b/src/main/java/tools/jackson/databind/deser/impl/ManagedReferenceProperty.java
@@ -76,31 +76,52 @@ public final class ManagedReferenceProperty
     @Override
     public Object setAndReturn(DeserializationContext ctxt, Object instance, Object value)
     {
+        _setBackReference(ctxt, instance, value);
+        // and then the forward reference itself
+        return delegate.setAndReturn(ctxt, instance, value);
+	}
+
+    /*
+    /**********************************************************************
+    /* Helper methods
+    /**********************************************************************
+     */
+
+    /**
+     * Helper method to inject back reference into value(s).
+     */
+    private void _setBackReference(DeserializationContext ctxt, Object instance, Object value)
+    {
+        if (value == null) {
+            return;
+        }
         // 04-Feb-2014, tatu: As per [#390], it may be necessary to switch the
         //   ordering of forward/backward references, and start with back ref.
-        if (value != null) {
-            if (_isContainer) { // ok, this gets ugly... but has to do for now
-                if (value instanceof Object[]) {
-                    for (Object ob : (Object[]) value) {
-                        if (ob != null) { _backProperty.set(ctxt, ob, instance); }
+        if (_isContainer) { // ok, this gets ugly... but has to do for now
+            if (value instanceof Object[]) {
+                for (Object ob : (Object[]) value) {
+                    if (ob != null) {
+                        _backProperty.set(ctxt, ob, instance);
                     }
-                } else if (value instanceof Collection<?>) {
-                    for (Object ob : (Collection<?>) value) {
-                        if (ob != null) { _backProperty.set(ctxt, ob, instance); }
+                }
+            } else if (value instanceof Collection<?>) {
+                for (Object ob : (Collection<?>) value) {
+                    if (ob != null) {
+                        _backProperty.set(ctxt, ob, instance);
                     }
-                } else if (value instanceof Map<?,?>) {
-                    for (Object ob : ((Map<?,?>) value).values()) {
-                        if (ob != null) { _backProperty.set(ctxt, ob, instance); }
+                }
+            } else if (value instanceof Map<?,?>) {
+                for (Object ob : ((Map<?,?>) value).values()) {
+                    if (ob != null) {
+                        _backProperty.set(ctxt, ob, instance);
                     }
-                } else {
-                    throw new IllegalStateException("Unsupported container type ("+value.getClass().getName()
-                            +") when resolving reference '"+_referenceName+"'");
                 }
             } else {
-                _backProperty.set(ctxt, value, instance);
+                throw new IllegalStateException("Unsupported container type (" + value.getClass().getName()
+                        + ") when resolving reference '" + _referenceName + "'");
             }
+        } else {
+            _backProperty.set(ctxt, value, instance);
         }
-        // and then the forward reference itself
-        return delegate.setAndReturn(ctxt, instance, value);
-	}
+    }
 }
