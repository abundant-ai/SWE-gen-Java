diff --git a/src/main/java/org/mockito/internal/invocation/ArgumentMatcherAction.java b/src/main/java/org/mockito/internal/invocation/ArgumentMatcherAction.java
new file mode 100644
index 000000000..29156d0b4
--- /dev/null
+++ b/src/main/java/org/mockito/internal/invocation/ArgumentMatcherAction.java
@@ -0,0 +1,28 @@
+package org.mockito.internal.invocation;
+
+import org.mockito.ArgumentMatcher;
+
+public interface ArgumentMatcherAction {
+    /**
+     * Implementations must apply the given matcher to the argument and return
+     * <code>true</code> if the operation was successful or <code>false</code>
+     * if not. In this case no more matchers and arguments will be passed by
+     * {@link MatcherApplicationStrategy#forEachMatcherAndArgument(ArgumentMatcherAction)} to this method.
+     * .
+     * 
+     * @param matcher
+     *            to process the argument, never <code>null</code>
+     * @param argument
+     *            to be processed by the matcher, can be <code>null</code>
+     * @return
+     *         <ul>
+     *         <li><code>true</code> if the <b>matcher</b> was successfully
+     *         applied to the <b>argument</b> and the next pair of matcher and
+     *         argument should be passed
+     *         <li><code>false</code> otherwise
+     *         </ul>
+     * 
+     * 
+     */
+    boolean apply(ArgumentMatcher<?> matcher, Object argument);
+}
diff --git a/src/main/java/org/mockito/internal/invocation/ArgumentsComparator.java b/src/main/java/org/mockito/internal/invocation/ArgumentsComparator.java
deleted file mode 100644
index 7b12fb2af..000000000
--- a/src/main/java/org/mockito/internal/invocation/ArgumentsComparator.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.invocation;
-
-import java.lang.reflect.Method;
-import java.util.List;
-import org.mockito.ArgumentMatcher;
-import org.mockito.internal.matchers.VarargMatcher;
-import org.mockito.invocation.Invocation;
-
-@SuppressWarnings("unchecked")
-public class ArgumentsComparator {
-
-    private ArgumentsComparator() {}
-
-    public static boolean argumentsMatch(InvocationMatcher invocationMatcher, Invocation actual) {
-        Object[] actualArgs = actual.getArguments();
-        return argumentsMatch(invocationMatcher, actualArgs) || varArgsMatch(invocationMatcher, actual);
-    }
-
-    public static boolean argumentsMatch(InvocationMatcher invocationMatcher, Object[] actualArgs) {
-        if (actualArgs.length != invocationMatcher.getMatchers().size()) {
-            return false;
-        }
-        for (int i = 0; i < actualArgs.length; i++) {
-            ArgumentMatcher<Object> argumentMatcher = invocationMatcher.getMatchers().get(i);
-            Object argument = actualArgs[i];
-
-            if (!matches(argumentMatcher, argument)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    // ok, this method is a little bit messy but the vararg business unfortunately is messy...
-    private static boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {
-        if (!actual.getMethod().isVarArgs()) {
-            // if the method is not vararg forget about it
-            return false;
-        }
-
-        // we must use raw arguments, not arguments...
-        Object[] rawArgs = actual.getRawArguments();
-        List<ArgumentMatcher> matchers = invocationMatcher.getMatchers();
-
-        if (rawArgs.length != matchers.size()) {
-            return false;
-        }
-
-        for (int i = 0; i < rawArgs.length; i++) {
-            ArgumentMatcher m = matchers.get(i);
-            // it's a vararg because it's the last array in the arg list
-            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length - 1) {
-                // this is very important to only allow VarargMatchers here. If
-                // you're not sure why remove it and run all tests.
-                if (!(m instanceof VarargMatcher) || !m.matches(rawArgs[i])) {
-                    return false;
-                }
-                // it's not a vararg (i.e. some ordinary argument before
-                // varargs), just do the ordinary check
-            } else if (!m.matches(rawArgs[i])) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    private static boolean matches(ArgumentMatcher<Object> argumentMatcher, Object argument) {
-        return isCompatible(argumentMatcher, argument) && argumentMatcher.matches(argument);
-    }
-
-    /**
-     * Returns <code>true</code> if the given <b>argument</b> can be passed to
-     * the given <code>argumentMatcher</code> without causing a
-     * {@link ClassCastException}.
-     */
-    private static boolean isCompatible(ArgumentMatcher<?> argumentMatcher, Object argument) {
-        if (argument == null)
-            return true;
-
-        Class<?> expectedArgumentType = getArgumentType(argumentMatcher);
-
-        return expectedArgumentType.isInstance(argument);
-    }
-
-    /**
-     * Returns the type of {@link ArgumentMatcher#matches(Object)} of the given
-     * {@link ArgumentMatcher} implementation.
-     */
-    private static Class<?> getArgumentType(ArgumentMatcher<?> argumentMatcher) {
-        Method[] methods = argumentMatcher.getClass().getMethods();
-        for (Method method : methods) {
-            if (isMatchesMethod(method)) {
-                return method.getParameterTypes()[0];
-            }
-        }
-        throw new NoSuchMethodError("Method 'matches(T)' not found in ArgumentMatcher: " + argumentMatcher + " !\r\n Please file a bug with this stack trace at: https://github.com/mockito/mockito/issues/new ");
-    }
-
-    /**
-     * Returns <code>true</code> if the given method is
-     * {@link ArgumentMatcher#matches(Object)}
-     */
-    private static boolean isMatchesMethod(Method method) {
-        if (method.getParameterTypes().length != 1) {
-            return false;
-        }
-        if (method.isBridge()) {
-            return false;
-        }
-        return method.getName().equals("matches");
-    }
-}
diff --git a/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java b/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
index 66ea8f5fb..d955b7001 100644
--- a/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
+++ b/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
@@ -5,6 +5,15 @@
 
 package org.mockito.internal.invocation;
 
+import static org.mockito.internal.invocation.ArgumentsProcessor.argumentsToMatchers;
+import static org.mockito.internal.invocation.MatcherApplicationStrategy.getMatcherApplicationStrategyFor;
+import static org.mockito.internal.invocation.TypeSafeMatching.matchesTypeSafe;
+
+import java.io.Serializable;
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
 import org.mockito.ArgumentMatcher;
 import org.mockito.internal.matchers.CapturesArguments;
 import org.mockito.internal.reporting.PrintSettings;
@@ -12,36 +21,36 @@ import org.mockito.invocation.DescribedInvocation;
 import org.mockito.invocation.Invocation;
 import org.mockito.invocation.Location;
 
-import static org.mockito.internal.invocation.ArgumentsComparator.argumentsMatch;
-
-import java.io.Serializable;
-import java.lang.reflect.Array;
-import java.lang.reflect.Method;
-import java.util.*;
-
-@SuppressWarnings("unchecked")
 /**
- * In addition to all content of the invocation, the invocation matcher contains the argument matchers.
- * Invocation matcher is used during verification and stubbing.
- * In those cases, the user can provide argument matchers instead of 'raw' arguments.
- * Raw arguments are converted to 'equals' matchers anyway.
+ * In addition to all content of the invocation, the invocation matcher contains the argument matchers. Invocation matcher is used during verification and stubbing. In those cases, the user can provide argument matchers instead of 'raw' arguments. Raw arguments are converted to 'equals' matchers anyway.
  */
+@SuppressWarnings("serial")
 public class InvocationMatcher implements DescribedInvocation, CapturesArgumentsFromInvocation, Serializable {
 
     private final Invocation invocation;
-    private final List<ArgumentMatcher> matchers;
+    private final List<ArgumentMatcher<?>> matchers;
 
+    @SuppressWarnings({ "rawtypes", "unchecked" })
     public InvocationMatcher(Invocation invocation, List<ArgumentMatcher> matchers) {
         this.invocation = invocation;
         if (matchers.isEmpty()) {
-            this.matchers = ArgumentsProcessor.argumentsToMatchers(invocation.getArguments());
+            this.matchers = (List) argumentsToMatchers(invocation.getArguments());
         } else {
-            this.matchers = matchers;
+            this.matchers = (List) matchers;
         }
     }
 
+    @SuppressWarnings("rawtypes")
     public InvocationMatcher(Invocation invocation) {
-        this(invocation, Collections.<ArgumentMatcher>emptyList());
+        this(invocation, Collections.<ArgumentMatcher> emptyList());
+    }
+
+    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
+        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
+        for (Invocation i : invocations) {
+            out.add(new InvocationMatcher(i));
+        }
+        return out;
     }
 
     public Method getMethod() {
@@ -49,54 +58,50 @@ public class InvocationMatcher implements DescribedInvocation, CapturesArguments
     }
 
     public Invocation getInvocation() {
-        return this.invocation;
+        return invocation;
     }
 
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     public List<ArgumentMatcher> getMatchers() {
-        return this.matchers;
+        return (List) matchers;
     }
 
+    @Override
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     public String toString() {
-        return new PrintSettings().print(matchers, invocation);
+        return new PrintSettings().print((List) matchers, invocation);
     }
 
     public boolean matches(Invocation actual) {
-        return invocation.getMock().equals(actual.getMock())
-                && hasSameMethod(actual)
-                && argumentsMatch(this, actual);
-    }
-
-    private boolean safelyArgumentsMatch(Object[] actualArgs) {
-        try {
-            return argumentsMatch(this, actualArgs);
-        } catch (Throwable t) {
-            return false;
-        }
+        return invocation.getMock().equals(actual.getMock()) && hasSameMethod(actual) && argumentsMatch(actual);
     }
 
     /**
-     * similar means the same method name, same mock, unverified
-     * and: if arguments are the same cannot be overloaded
+     * similar means the same method name, same mock, unverified and: if arguments are the same cannot be overloaded
      */
     public boolean hasSimilarMethod(Invocation candidate) {
         String wantedMethodName = getMethod().getName();
-        String currentMethodName = candidate.getMethod().getName();
-
-        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);
-        final boolean isUnverified = !candidate.isVerified();
-        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();
-        final boolean methodEquals = hasSameMethod(candidate);
+        String candidateMethodName = candidate.getMethod().getName();
 
-        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {
+        if (!wantedMethodName.equals(candidateMethodName)) {
             return false;
         }
+        if (candidate.isVerified()) {
+            return false;
+        }
+        if (getInvocation().getMock() != candidate.getMock()) {
+            return false;
+        }
+        if (hasSameMethod(candidate)) {
+            return true;
+        }
 
-        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());
-
-        return !overloadedButSameArgs;
+        return !argumentsMatch(candidate);
     }
 
     public boolean hasSameMethod(Invocation candidate) {
+        // not using method.equals() for 1 good reason:
+        // sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest
         Method m1 = invocation.getMethod();
         Method m2 = candidate.getMethod();
 
@@ -115,59 +120,34 @@ public class InvocationMatcher implements DescribedInvocation, CapturesArguments
         return false;
     }
 
+    @Override
     public Location getLocation() {
         return invocation.getLocation();
     }
 
+    @Override
     public void captureArgumentsFrom(Invocation invocation) {
-        captureRegularArguments(invocation);
-        captureVarargsPart(invocation);
+        MatcherApplicationStrategy strategy = getMatcherApplicationStrategyFor(invocation, matchers);
+        strategy.forEachMatcherAndArgument(captureArgument());
     }
 
-    private void captureRegularArguments(Invocation invocation) {
-        for (int position = 0; position < regularArgumentsSize(invocation); position++) {
-            ArgumentMatcher m = matchers.get(position);
-            if (m instanceof CapturesArguments) {
-                ((CapturesArguments) m).captureFrom(invocation.getArgument(position));
-            }
-        }
-    }
-
-    private void captureVarargsPart(Invocation invocation) {
-        if (!invocation.getMethod().isVarArgs()) {
-            return;
-        }
-        int indexOfVararg = invocation.getRawArguments().length - 1;
-        for (ArgumentMatcher m : uniqueMatcherSet(indexOfVararg)) {
-            if (m instanceof CapturesArguments) {
-                Object rawArgument = invocation.getRawArguments()[indexOfVararg];
-                for (int i = 0; i < Array.getLength(rawArgument); i++) {
-                    ((CapturesArguments) m).captureFrom(Array.get(rawArgument, i));
+    private ArgumentMatcherAction captureArgument() {
+        return new ArgumentMatcherAction() {
+            
+            @Override
+            public boolean apply(ArgumentMatcher<?> matcher, Object argument) {
+                if (matcher instanceof CapturesArguments) {
+                    ((CapturesArguments) matcher).captureFrom(argument);
                 }
+                
+                return true;
             }
-        }
-    }
-
-    private int regularArgumentsSize(Invocation invocation) {
-        return invocation.getMethod().isVarArgs() ?
-                invocation.getRawArguments().length - 1 // ignores vararg holder array
-                : matchers.size();
-    }
-
-    private Set<ArgumentMatcher> uniqueMatcherSet(int indexOfVararg) {
-        HashSet<ArgumentMatcher> set = new HashSet<ArgumentMatcher>();
-        for (int position = indexOfVararg; position < matchers.size(); position++) {
-            ArgumentMatcher matcher = matchers.get(position);
-            set.add(matcher);
-        }
-        return set;
+        };
     }
-
-    public static List<InvocationMatcher> createFrom(List<Invocation> invocations) {
-        LinkedList<InvocationMatcher> out = new LinkedList<InvocationMatcher>();
-        for (Invocation i : invocations) {
-            out.add(new InvocationMatcher(i));
-        }
-        return out;
+    
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    private boolean argumentsMatch(Invocation actual) {
+        List matchers = getMatchers();
+        return getMatcherApplicationStrategyFor(actual, matchers).forEachMatcherAndArgument( matchesTypeSafe());
     }
-}
+}
\ No newline at end of file
diff --git a/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java b/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java
new file mode 100644
index 000000000..40c6519c9
--- /dev/null
+++ b/src/main/java/org/mockito/internal/invocation/MatcherApplicationStrategy.java
@@ -0,0 +1,128 @@
+package org.mockito.internal.invocation;
+
+import static org.mockito.internal.invocation.MatcherApplicationStrategy.MatcherApplicationType.ERROR_UNSUPPORTED_NUMBER_OF_MATCHERS;
+import static org.mockito.internal.invocation.MatcherApplicationStrategy.MatcherApplicationType.MATCH_EACH_VARARGS_WITH_LAST_MATCHER;
+import static org.mockito.internal.invocation.MatcherApplicationStrategy.MatcherApplicationType.ONE_MATCHER_PER_ARGUMENT;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.mockito.ArgumentMatcher;
+import org.mockito.internal.matchers.CapturingMatcher;
+import org.mockito.internal.matchers.VarargMatcher;
+import org.mockito.invocation.Invocation;
+
+public class MatcherApplicationStrategy {
+
+    private final Invocation invocation;
+    private final List<ArgumentMatcher<?>> matchers;
+    private final MatcherApplicationType matchingType;
+    
+
+
+    private MatcherApplicationStrategy(Invocation invocation, List<ArgumentMatcher<?>> matchers, MatcherApplicationType matchingType) {
+        this.invocation = invocation;
+        if (matchingType == MATCH_EACH_VARARGS_WITH_LAST_MATCHER) {
+            int times = varargLength(invocation);
+            this.matchers = appendLastMatcherNTimes(matchers, times);
+        } else {
+            this.matchers = matchers;
+        }
+
+        this.matchingType = matchingType;
+    }
+
+    /**
+     * Returns the {@link MatcherApplicationStrategy} that must be used to capture the
+     * arguments of the given <b>invocation</b> using the given <b>matchers</b>.
+     * 
+     * @param invocation
+     *            that contain the arguments to capture
+     * @param matchers
+     *            that will be used to capture the arguments of the invocation,
+     *            the passed {@link List} is not required to contain a
+     *            {@link CapturingMatcher}
+     * @return never <code>null</code>
+     */
+    public static MatcherApplicationStrategy getMatcherApplicationStrategyFor(Invocation invocation, List<ArgumentMatcher<?>> matchers) {
+
+        MatcherApplicationType type = getMatcherApplicationType(invocation, matchers);
+        return new MatcherApplicationStrategy(invocation, matchers, type);
+    }
+
+    /**
+     * Applies the given {@link ArgumentMatcherAction} to all arguments and
+     * corresponding matchers
+     * 
+     * @param action
+     *            must not be <code>null</code>
+     * @return
+     *         <ul>
+     *         <li><code>true</code> if the given <b>action</b> returned
+     *         <code>true</code> for all arguments and matchers passed to it.
+     *         <li><code>false</code> if the given <b>action</b> returned
+     *         <code>false</code> for one of the passed arguments and matchers
+     *         <li><code>false</code> if the given matchers don't fit to the given invocation
+     *         because too many or to few matchers are available.
+     *         </ul>
+     */
+    public boolean forEachMatcherAndArgument(ArgumentMatcherAction action) {
+        if (matchingType == ERROR_UNSUPPORTED_NUMBER_OF_MATCHERS)
+            return false;
+
+        Object[] arguments = invocation.getArguments();
+        for (int i = 0; i < arguments.length; i++) {
+            ArgumentMatcher<?> matcher = matchers.get(i);
+            Object argument = arguments[i];
+
+            if (!action.apply(matcher, argument)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    private static MatcherApplicationType getMatcherApplicationType(Invocation invocation, List<ArgumentMatcher<?>> matchers) {
+        final int rawArguments = invocation.getRawArguments().length;
+        final int expandedArguments = invocation.getArguments().length;
+        final int matcherCount = matchers.size();
+
+        if (expandedArguments == matcherCount) {
+            return ONE_MATCHER_PER_ARGUMENT;
+        }
+
+        if (rawArguments == matcherCount && isLastMatcherVargargMatcher(matchers)) {
+            return MATCH_EACH_VARARGS_WITH_LAST_MATCHER;
+        }
+
+        return ERROR_UNSUPPORTED_NUMBER_OF_MATCHERS;
+    }
+
+    private static boolean isLastMatcherVargargMatcher(final List<ArgumentMatcher<?>> matchers) {
+        return lastMatcher(matchers) instanceof VarargMatcher;
+    }
+
+    private static List<ArgumentMatcher<?>> appendLastMatcherNTimes(List<ArgumentMatcher<?>> matchers, int timesToAppendLastMatcher) {
+        ArgumentMatcher<?> lastMatcher = lastMatcher(matchers);
+
+        List<ArgumentMatcher<?>> expandedMatchers = new ArrayList<ArgumentMatcher<?>>(matchers);
+        for (int i = 0; i < timesToAppendLastMatcher; i++) {
+            expandedMatchers.add(lastMatcher);
+        }
+        return expandedMatchers;
+    }
+
+    private static int varargLength(Invocation invocation) {
+        int rawArgumentCount = invocation.getRawArguments().length;
+        int expandedArgumentCount = invocation.getArguments().length;
+        return expandedArgumentCount - rawArgumentCount;
+    }
+
+    private static ArgumentMatcher<?> lastMatcher(List<ArgumentMatcher<?>> matchers) {
+        return matchers.get(matchers.size() - 1);
+    }
+
+    enum MatcherApplicationType {
+        ONE_MATCHER_PER_ARGUMENT, MATCH_EACH_VARARGS_WITH_LAST_MATCHER, ERROR_UNSUPPORTED_NUMBER_OF_MATCHERS;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/mockito/internal/invocation/TypeSafeMatching.java b/src/main/java/org/mockito/internal/invocation/TypeSafeMatching.java
new file mode 100644
index 000000000..181e47fea
--- /dev/null
+++ b/src/main/java/org/mockito/internal/invocation/TypeSafeMatching.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockito.internal.invocation;
+
+import java.lang.reflect.Method;
+
+import org.mockito.ArgumentMatcher;
+
+@SuppressWarnings({"unchecked","rawtypes"})
+public class TypeSafeMatching implements ArgumentMatcherAction {
+
+    private final static ArgumentMatcherAction TYPE_SAFE_MATCHING_ACTION = new TypeSafeMatching();
+        
+    private TypeSafeMatching() {}
+
+    
+    public static ArgumentMatcherAction matchesTypeSafe(){
+        return TYPE_SAFE_MATCHING_ACTION;
+    }
+    @Override
+    public boolean apply(ArgumentMatcher matcher, Object argument) {
+        return isCompatible(matcher, argument) && matcher.matches(argument);
+    }
+
+    
+    /**
+     * Returns <code>true</code> if the given <b>argument</b> can be passed to
+     * the given <code>argumentMatcher</code> without causing a
+     * {@link ClassCastException}.
+     */
+    private static boolean isCompatible(ArgumentMatcher<?> argumentMatcher, Object argument) {
+        if (argument == null)
+            return true;
+
+        Class<?> expectedArgumentType = getArgumentType(argumentMatcher);
+
+        return expectedArgumentType.isInstance(argument);
+    }
+
+    /**
+     * Returns the type of {@link ArgumentMatcher#matches(Object)} of the given
+     * {@link ArgumentMatcher} implementation.
+     */
+    private static Class<?> getArgumentType(ArgumentMatcher<?> argumentMatcher) {
+        Method[] methods = argumentMatcher.getClass().getMethods();
+        
+        for (Method method : methods) {
+            if (isMatchesMethod(method)) {
+                return method.getParameterTypes()[0];
+            }
+        }
+        throw new NoSuchMethodError("Method 'matches(T)' not found in ArgumentMatcher: " + argumentMatcher + " !\r\n Please file a bug with this stack trace at: https://github.com/mockito/mockito/issues/new ");
+    }
+
+    /**
+     * Returns <code>true</code> if the given method is
+     * {@link ArgumentMatcher#matches(Object)}
+     */
+    private static boolean isMatchesMethod(Method method) {
+        if (method.getParameterTypes().length != 1) {
+            return false;
+        }
+        if (method.isBridge()) {
+            return false;
+        }
+        return method.getName().equals("matches");
+    }
+}
\ No newline at end of file
