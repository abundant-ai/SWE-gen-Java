diff --git a/build.gradle b/build.gradle
index c904c65a9..cea34df0b 100644
--- a/build.gradle
+++ b/build.gradle
@@ -45,8 +45,8 @@ apply from: 'gradle/root/version.gradle'
 apply from: "gradle/java-library.gradle"
 
 dependencies {
-    compile 'net.bytebuddy:byte-buddy:1.6.0'
-    compile 'net.bytebuddy:byte-buddy-agent:1.6.0'
+    compile 'net.bytebuddy:byte-buddy:1.5.12'
+    compile 'net.bytebuddy:byte-buddy-agent:1.5.12'
 
     provided "junit:junit:4.12", "org.hamcrest:hamcrest-core:1.3"
     compile "org.objenesis:objenesis:2.4"
diff --git a/gradle/mockito-core/osgi.gradle b/gradle/mockito-core/osgi.gradle
index 05d99eec9..dfed1fe32 100644
--- a/gradle/mockito-core/osgi.gradle
+++ b/gradle/mockito-core/osgi.gradle
@@ -16,7 +16,7 @@ afterEvaluate {
                     "org.mockito.*;version=${version}"
 
             instruction 'Import-Package',
-                    'net.bytebuddy.*;version="[1.6.0,2.0)"',
+                    'net.bytebuddy.*;version="[1.5.5,2.0)"',
                     'junit.*;resolution:=optional',
                     'org.junit.*;resolution:=optional',
                     'org.hamcrest;resolution:=optional',
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
index da0d52725..15fbbb3ab 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
@@ -8,8 +8,6 @@ import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.asm.Advice;
 import net.bytebuddy.asm.AsmVisitorWrapper;
-import net.bytebuddy.description.field.FieldDescription;
-import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.method.ParameterDescription;
@@ -39,7 +37,6 @@ import java.util.HashSet;
 import java.util.Set;
 
 import static net.bytebuddy.implementation.MethodDelegation.to;
-import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
 import static net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFixedValue.OfConstant.of;
 import static net.bytebuddy.matcher.ElementMatchers.*;
 
@@ -77,9 +74,8 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
         mocked = new WeakConcurrentSet<Class<?>>(WeakConcurrentSet.Cleaner.INLINE);
         identifier = RandomString.make();
         advice = new MockMethodAdvice(mocks, identifier);
-        subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
-                .withBinders(of(MockMethodAdvice.Identifier.class, identifier))
-                .to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
+        subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
+                .appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
         MockMethodDispatcher.set(identifier, advice);
         instrumentation.addTransformer(this, true);
     }
@@ -188,8 +184,6 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
                                  ClassVisitor classVisitor,
                                  Implementation.Context implementationContext,
                                  TypePool typePool,
-                                 FieldList<FieldDescription.InDefinedShape> fields,
-                                 MethodList<?> methods,
                                  int writerFlags,
                                  int readerFlags) {
             return implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V8)
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
index e68c5992e..fd75564f5 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
@@ -99,7 +99,7 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
                               .append(MockAccess.class, DispatcherDefaultingToRealMethod.class)
                               .append(MockMethodInterceptor.class,
                                       MockMethodInterceptor.ForHashCode.class,
-                                      MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
+                                      MockMethodInterceptor.ForEquals.class).build(),
                               loader.getStrategy(features.mockedType))
                       .getLoaded();
     }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
index 510e633ea..1deabc684 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
@@ -5,7 +5,7 @@ import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 class SubclassInjectionLoader implements SubclassLoader {
 
     @Override
-    public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
+    public ClassLoadingStrategy getStrategy(Class<?> mockedType) {
         return ClassLoadingStrategy.Default.INJECTION.with(mockedType.getProtectionDomain());
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
index 9d10de527..bdc2d6d9f 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
@@ -4,6 +4,6 @@ import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 
 public interface SubclassLoader {
 
-    ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
+    ClassLoadingStrategy getStrategy(Class<?> mockedType);
 
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java
index bacf1e0e1..b698bdd27 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java
@@ -4,70 +4,197 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
-import net.bytebuddy.TypeCache;
-import org.mockito.mock.SerializableMode;
-
+import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.util.Collections;
+import java.util.HashSet;
 import java.util.Set;
-import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader> implements BytecodeGenerator {
 
+    private static final ClassLoader BOOT_LOADER = new URLClassLoader(new URL[0], TypeCachingBytecodeGenerator.class.getClassLoader());
+
+    final ConcurrentMap<Key, CachedBytecodeGenerator> avoidingClassLeakageCache = new ConcurrentHashMap<Key, CachedBytecodeGenerator>();
+
     private final BytecodeGenerator bytecodeGenerator;
 
-    private final TypeCache<SerializationFeatureKey> typeCache;
+    private final boolean weak;
 
     public TypeCachingBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
         this.bytecodeGenerator = bytecodeGenerator;
-        typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
+        this.weak = weak;
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public <T> Class<T> mockClass(final MockFeatures<T> params) {
-        try {
-
-        return (Class<T>) typeCache.findOrInsert(params.mockedType.getClassLoader(),
-                new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
-                new Callable<Class<?>>() {
-                    @Override
-                    public Class<?> call() throws Exception {
-                        return bytecodeGenerator.mockClass(params);
-                    }
-                }, params.mockedType);
-        } catch (IllegalArgumentException exception) {
-            Throwable cause = exception.getCause();
-            if (cause instanceof RuntimeException) {
-                throw (RuntimeException) cause;
+    public <T> Class<T> mockClass(MockFeatures<T> params) {
+        cleanUpCachesForObsoleteClassLoaders();
+        return (Class<T>) mockCachePerClassLoaderOf(params.mockedType.getClassLoader()).getOrGenerateMockClass(params);
+    }
+
+    void cleanUpCachesForObsoleteClassLoaders() {
+        Reference<?> reference;
+        // Any weak key that is used in the map is enqueued to this reference queue once a class loader is no longer reachable.
+        while ((reference = poll()) != null) {
+            avoidingClassLeakageCache.remove(reference);
+        }
+    }
+
+    private CachedBytecodeGenerator mockCachePerClassLoaderOf(ClassLoader classLoader) {
+        classLoader = classLoader == null ? BOOT_LOADER : classLoader;
+        CachedBytecodeGenerator generator = avoidingClassLeakageCache.get(new LookupKey(classLoader));
+        if (generator == null) {
+            CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
+            generator = avoidingClassLeakageCache.putIfAbsent(new WeakKey(classLoader, this), newGenerator);
+            if (generator == null) {
+                generator = newGenerator;
+            }
+        }
+        return generator;
+    }
+
+    private static class CachedBytecodeGenerator {
+
+        private ConcurrentHashMap<MockKey, Reference<Class<?>>> generatedClassCache = new ConcurrentHashMap<MockKey, Reference<Class<?>>>();
+
+        private BytecodeGenerator bytecodeGenerator;
+
+        private final boolean weak;
+
+        private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
+            this.bytecodeGenerator = bytecodeGenerator;
+            this.weak = weak;
+        }
+
+        private Class<?> getMockClass(MockKey<?> mockKey) {
+            Reference<Class<?>> classReference = generatedClassCache.get(mockKey);
+            if (classReference != null) {
+                return classReference.get();
             } else {
-                throw exception;
+                return null;
+            }
+        }
+
+        Class<?> getOrGenerateMockClass(MockFeatures<?> features) {
+            MockKey<?> mockKey = MockKey.of(features.mockedType, features.interfaces);
+            Class<?> generatedMockClass = getMockClass(mockKey);
+            if (generatedMockClass == null) {
+                synchronized (features.mockedType) {
+                    generatedMockClass = getMockClass(mockKey);
+                    if (generatedMockClass == null) {
+                        generatedMockClass = bytecodeGenerator.mockClass(features);
+                        generatedClassCache.put(mockKey, weak ? new WeakReference<Class<?>>(generatedMockClass) : new SoftReference<Class<?>>(generatedMockClass));
+                    }
+                }
+            }
+            return generatedMockClass;
+        }
+
+        // should be stored as a weak reference
+        private static class MockKey<T> {
+
+            private final String mockedType;
+
+            private final Set<String> types;
+
+            private MockKey(Class<T> mockedType, Set<Class<?>> interfaces) {
+                this.mockedType = mockedType.getName();
+                if (interfaces.isEmpty()) { // Optimize memory footprint for the common case.
+                    types = Collections.emptySet();
+                } else {
+                    types = new HashSet<String>();
+                    for (Class<?> anInterface : interfaces) {
+                        types.add(anInterface.getName());
+                    }
+                    types.add(this.mockedType);
+                }
             }
+
+            @Override
+            public boolean equals(Object other) {
+                if (this == other) return true;
+                if (other == null || getClass() != other.getClass()) return false;
+
+                MockKey mockKey = (MockKey<?>) other;
+
+                if (!mockedType.equals(mockKey.mockedType)) return false;
+                if (!types.equals(mockKey.types)) return false;
+
+                return true;
+            }
+
+            @Override
+            public int hashCode() {
+                int result = mockedType.hashCode();
+                result = 31 * result + types.hashCode();
+                return result;
+            }
+
+            public static <T> MockKey<T> of(Class<T> mockedType, Set<Class<?>> interfaces) {
+                return new MockKey<T>(mockedType, interfaces);
+            }
+        }
+    }
+
+    private interface Key {
+
+        ClassLoader get();
+    }
+
+    private static class LookupKey implements Key {
+
+        private final ClassLoader value;
+
+        private final int hashCode;
+
+        public LookupKey(ClassLoader value) {
+            this.value = value;
+            hashCode = System.identityHashCode(value);
+        }
+
+        @Override
+        public ClassLoader get() {
+            return value;
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (this == object) return true;
+            if (!(object instanceof Key)) return false;
+            return value == ((Key) object).get();
+        }
+
+        @Override
+        public int hashCode() {
+            return hashCode;
         }
     }
 
-    private static class SerializationFeatureKey extends TypeCache.SimpleKey {
+    private static class WeakKey extends WeakReference<ClassLoader> implements Key {
 
-        private final SerializableMode serializableMode;
+        private final int hashCode;
 
-        private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
-            super(type, additionalType);
-            this.serializableMode = serializableMode;
+        public WeakKey(ClassLoader referent, ReferenceQueue<ClassLoader> q) {
+            super(referent, q);
+            hashCode = System.identityHashCode(referent);
         }
 
         @Override
         public boolean equals(Object object) {
             if (this == object) return true;
-            if (object == null || getClass() != object.getClass()) return false;
-            if (!super.equals(object)) return false;
-            SerializationFeatureKey that = (SerializationFeatureKey) object;
-            return serializableMode.equals(that.serializableMode);
+            if (!(object instanceof Key)) return false;
+            return get() == ((Key) object).get();
         }
 
         @Override
         public int hashCode() {
-            int result = super.hashCode();
-            result = 31 * result + serializableMode.hashCode();
-            return result;
+            return hashCode;
         }
     }
 }
diff --git a/src/test/java/org/mockito/internal/creation/bytebuddy/TypeCachingMockBytecodeGeneratorTest.java b/src/test/java/org/mockito/internal/creation/bytebuddy/TypeCachingMockBytecodeGeneratorTest.java
index f431fd1e5..bd0f77015 100644
--- a/src/test/java/org/mockito/internal/creation/bytebuddy/TypeCachingMockBytecodeGeneratorTest.java
+++ b/src/test/java/org/mockito/internal/creation/bytebuddy/TypeCachingMockBytecodeGeneratorTest.java
@@ -5,9 +5,6 @@ import org.junit.Test;
 import org.mockito.mock.SerializableMode;
 import org.mockitoutil.VmArgAssumptions;
 
-import java.lang.ref.PhantomReference;
-import java.lang.ref.Reference;
-import java.lang.ref.ReferenceQueue;
 import java.lang.ref.WeakReference;
 import java.util.Collections;
 import java.util.WeakHashMap;
@@ -32,15 +29,13 @@ public class TypeCachingMockBytecodeGeneratorTest {
                 .build();
 
         TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
-
         Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
                 classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
                 Collections.<Class<?>>emptySet(),
                 SerializableMode.NONE
         ));
 
-        ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
-        Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
+        assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
 
         // when
         classloader_with_life_shorter_than_cache = is_no_more_referenced();
@@ -49,8 +44,10 @@ public class TypeCachingMockBytecodeGeneratorTest {
         System.gc();
         ensure_gc_happened();
 
+        cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
+
         // then
-        assertThat(referenceQueue.poll()).isEqualTo(typeReference);
+        assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).isEmpty();
     }
 
     @Test
@@ -74,43 +71,19 @@ public class TypeCachingMockBytecodeGeneratorTest {
         ));
 
         assertThat(other_mock_type).isSameAs(the_mock_type);
-
-        ReferenceQueue<Object> referenceQueue = new ReferenceQueue<Object>();
-        Reference<Object> typeReference = new PhantomReference<Object>(the_mock_type, referenceQueue);
+        assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
 
         // when
         classloader_with_life_shorter_than_cache = is_no_more_referenced();
         the_mock_type = is_no_more_referenced();
-        other_mock_type = is_no_more_referenced();
 
         System.gc();
         ensure_gc_happened();
 
-        // then
-        assertThat(referenceQueue.poll()).isEqualTo(typeReference);
-    }
-
-    @Test
-    public void ensure_cache_returns_different_instance_serializableMode() throws Exception {
-        // given
-        ClassLoader classloader_with_life_shorter_than_cache = inMemoryClassLoader()
-                .withClassDefinition("foo.Bar", makeMarkerInterface("foo.Bar"))
-                .build();
-
-        TypeCachingBytecodeGenerator cachingMockBytecodeGenerator = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(), true);
-        Class<?> the_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
-                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
-                Collections.<Class<?>>emptySet(),
-                SerializableMode.NONE
-        ));
+        cachingMockBytecodeGenerator.cleanUpCachesForObsoleteClassLoaders();
 
-        Class<?> other_mock_type = cachingMockBytecodeGenerator.mockClass(withMockFeatures(
-                classloader_with_life_shorter_than_cache.loadClass("foo.Bar"),
-                Collections.<Class<?>>emptySet(),
-                SerializableMode.BASIC
-        ));
-
-        assertThat(other_mock_type).isNotSameAs(the_mock_type);
+        // then
+        assertThat(cachingMockBytecodeGenerator.avoidingClassLeakageCache).hasSize(1);
     }
 
     @Test
diff --git a/subprojects/android/android.gradle b/subprojects/android/android.gradle
index 92e4b515d..a8ad5acc5 100644
--- a/subprojects/android/android.gradle
+++ b/subprojects/android/android.gradle
@@ -12,7 +12,7 @@ apply from: "$rootDir/gradle/publishable-java-library.gradle"
 
 dependencies {
     compile project.rootProject
-    compile "net.bytebuddy:byte-buddy-android:1.6.0"
+    compile "net.bytebuddy:byte-buddy-android:1.5.12"
 }
 
 tasks.javadoc.enabled = false
\ No newline at end of file
diff --git a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
index 6675f1a1c..056560f73 100644
--- a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
+++ b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
@@ -12,7 +12,7 @@ import static org.mockito.internal.util.StringJoiner.join;
 class AndroidLoadingStrategy implements SubclassLoader {
 
     @Override
-    public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
+    public ClassLoadingStrategy getStrategy(Class<?> mockFeatures) {
         File target = AndroidTempFileLocator.target;
         if (target == null) {
             throw new MockitoException(join(
