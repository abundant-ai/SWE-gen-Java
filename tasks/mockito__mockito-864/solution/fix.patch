diff --git a/gradle/mockito-core/osgi.gradle b/gradle/mockito-core/osgi.gradle
index dfed1fe32..05d99eec9 100644
--- a/gradle/mockito-core/osgi.gradle
+++ b/gradle/mockito-core/osgi.gradle
@@ -16,7 +16,7 @@ afterEvaluate {
                     "org.mockito.*;version=${version}"
 
             instruction 'Import-Package',
-                    'net.bytebuddy.*;version="[1.5.5,2.0)"',
+                    'net.bytebuddy.*;version="[1.6.0,2.0)"',
                     'junit.*;resolution:=optional',
                     'org.junit.*;resolution:=optional',
                     'org.hamcrest;resolution:=optional',
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
index 15fbbb3ab..da0d52725 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/InlineBytecodeGenerator.java
@@ -8,6 +8,8 @@ import net.bytebuddy.ByteBuddy;
 import net.bytebuddy.ClassFileVersion;
 import net.bytebuddy.asm.Advice;
 import net.bytebuddy.asm.AsmVisitorWrapper;
+import net.bytebuddy.description.field.FieldDescription;
+import net.bytebuddy.description.field.FieldList;
 import net.bytebuddy.description.method.MethodDescription;
 import net.bytebuddy.description.method.MethodList;
 import net.bytebuddy.description.method.ParameterDescription;
@@ -37,6 +39,7 @@ import java.util.HashSet;
 import java.util.Set;
 
 import static net.bytebuddy.implementation.MethodDelegation.to;
+import static net.bytebuddy.implementation.MethodDelegation.withDefaultConfiguration;
 import static net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFixedValue.OfConstant.of;
 import static net.bytebuddy.matcher.ElementMatchers.*;
 
@@ -74,8 +77,9 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
         mocked = new WeakConcurrentSet<Class<?>>(WeakConcurrentSet.Cleaner.INLINE);
         identifier = RandomString.make();
         advice = new MockMethodAdvice(mocks, identifier);
-        subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(to(MockMethodAdvice.ForReadObject.class)
-                .appendParameterBinder(of(MockMethodAdvice.Identifier.class, identifier)), isAbstract().or(isNative())), false);
+        subclassEngine = new TypeCachingBytecodeGenerator(new SubclassBytecodeGenerator(withDefaultConfiguration()
+                .withBinders(of(MockMethodAdvice.Identifier.class, identifier))
+                .to(MockMethodAdvice.ForReadObject.class), isAbstract().or(isNative())), false);
         MockMethodDispatcher.set(identifier, advice);
         instrumentation.addTransformer(this, true);
     }
@@ -184,6 +188,8 @@ public class InlineBytecodeGenerator implements BytecodeGenerator, ClassFileTran
                                  ClassVisitor classVisitor,
                                  Implementation.Context implementationContext,
                                  TypePool typePool,
+                                 FieldList<FieldDescription.InDefinedShape> fields,
+                                 MethodList<?> methods,
                                  int writerFlags,
                                  int readerFlags) {
             return implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V8)
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
index fd75564f5..e68c5992e 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassBytecodeGenerator.java
@@ -99,7 +99,7 @@ class SubclassBytecodeGenerator implements BytecodeGenerator {
                               .append(MockAccess.class, DispatcherDefaultingToRealMethod.class)
                               .append(MockMethodInterceptor.class,
                                       MockMethodInterceptor.ForHashCode.class,
-                                      MockMethodInterceptor.ForEquals.class).build(),
+                                      MockMethodInterceptor.ForEquals.class).build(MockMethodInterceptor.class.getClassLoader()),
                               loader.getStrategy(features.mockedType))
                       .getLoaded();
     }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
index 1deabc684..510e633ea 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassInjectionLoader.java
@@ -5,7 +5,7 @@ import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 class SubclassInjectionLoader implements SubclassLoader {
 
     @Override
-    public ClassLoadingStrategy getStrategy(Class<?> mockedType) {
+    public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType) {
         return ClassLoadingStrategy.Default.INJECTION.with(mockedType.getProtectionDomain());
     }
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
index bdc2d6d9f..9d10de527 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/SubclassLoader.java
@@ -4,6 +4,6 @@ import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
 
 public interface SubclassLoader {
 
-    ClassLoadingStrategy getStrategy(Class<?> mockedType);
+    ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockedType);
 
 }
diff --git a/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java b/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java
index b698bdd27..bacf1e0e1 100644
--- a/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java
+++ b/src/main/java/org/mockito/internal/creation/bytebuddy/TypeCachingBytecodeGenerator.java
@@ -4,197 +4,70 @@
  */
 package org.mockito.internal.creation.bytebuddy;
 
-import java.lang.ref.Reference;
+import net.bytebuddy.TypeCache;
+import org.mockito.mock.SerializableMode;
+
 import java.lang.ref.ReferenceQueue;
-import java.lang.ref.SoftReference;
-import java.lang.ref.WeakReference;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.util.Collections;
-import java.util.HashSet;
 import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.Callable;
 
 class TypeCachingBytecodeGenerator extends ReferenceQueue<ClassLoader> implements BytecodeGenerator {
 
-    private static final ClassLoader BOOT_LOADER = new URLClassLoader(new URL[0], TypeCachingBytecodeGenerator.class.getClassLoader());
-
-    final ConcurrentMap<Key, CachedBytecodeGenerator> avoidingClassLeakageCache = new ConcurrentHashMap<Key, CachedBytecodeGenerator>();
-
     private final BytecodeGenerator bytecodeGenerator;
 
-    private final boolean weak;
+    private final TypeCache<SerializationFeatureKey> typeCache;
 
     public TypeCachingBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
         this.bytecodeGenerator = bytecodeGenerator;
-        this.weak = weak;
+        typeCache = new TypeCache.WithInlineExpunction<SerializationFeatureKey>(weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT);
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public <T> Class<T> mockClass(MockFeatures<T> params) {
-        cleanUpCachesForObsoleteClassLoaders();
-        return (Class<T>) mockCachePerClassLoaderOf(params.mockedType.getClassLoader()).getOrGenerateMockClass(params);
-    }
-
-    void cleanUpCachesForObsoleteClassLoaders() {
-        Reference<?> reference;
-        // Any weak key that is used in the map is enqueued to this reference queue once a class loader is no longer reachable.
-        while ((reference = poll()) != null) {
-            avoidingClassLeakageCache.remove(reference);
-        }
-    }
-
-    private CachedBytecodeGenerator mockCachePerClassLoaderOf(ClassLoader classLoader) {
-        classLoader = classLoader == null ? BOOT_LOADER : classLoader;
-        CachedBytecodeGenerator generator = avoidingClassLeakageCache.get(new LookupKey(classLoader));
-        if (generator == null) {
-            CachedBytecodeGenerator newGenerator = new CachedBytecodeGenerator(bytecodeGenerator, weak);
-            generator = avoidingClassLeakageCache.putIfAbsent(new WeakKey(classLoader, this), newGenerator);
-            if (generator == null) {
-                generator = newGenerator;
-            }
-        }
-        return generator;
-    }
-
-    private static class CachedBytecodeGenerator {
-
-        private ConcurrentHashMap<MockKey, Reference<Class<?>>> generatedClassCache = new ConcurrentHashMap<MockKey, Reference<Class<?>>>();
-
-        private BytecodeGenerator bytecodeGenerator;
-
-        private final boolean weak;
-
-        private CachedBytecodeGenerator(BytecodeGenerator bytecodeGenerator, boolean weak) {
-            this.bytecodeGenerator = bytecodeGenerator;
-            this.weak = weak;
-        }
-
-        private Class<?> getMockClass(MockKey<?> mockKey) {
-            Reference<Class<?>> classReference = generatedClassCache.get(mockKey);
-            if (classReference != null) {
-                return classReference.get();
-            } else {
-                return null;
-            }
-        }
-
-        Class<?> getOrGenerateMockClass(MockFeatures<?> features) {
-            MockKey<?> mockKey = MockKey.of(features.mockedType, features.interfaces);
-            Class<?> generatedMockClass = getMockClass(mockKey);
-            if (generatedMockClass == null) {
-                synchronized (features.mockedType) {
-                    generatedMockClass = getMockClass(mockKey);
-                    if (generatedMockClass == null) {
-                        generatedMockClass = bytecodeGenerator.mockClass(features);
-                        generatedClassCache.put(mockKey, weak ? new WeakReference<Class<?>>(generatedMockClass) : new SoftReference<Class<?>>(generatedMockClass));
+    public <T> Class<T> mockClass(final MockFeatures<T> params) {
+        try {
+
+        return (Class<T>) typeCache.findOrInsert(params.mockedType.getClassLoader(),
+                new SerializationFeatureKey(params.mockedType, params.interfaces, params.serializableMode),
+                new Callable<Class<?>>() {
+                    @Override
+                    public Class<?> call() throws Exception {
+                        return bytecodeGenerator.mockClass(params);
                     }
-                }
-            }
-            return generatedMockClass;
-        }
-
-        // should be stored as a weak reference
-        private static class MockKey<T> {
-
-            private final String mockedType;
-
-            private final Set<String> types;
-
-            private MockKey(Class<T> mockedType, Set<Class<?>> interfaces) {
-                this.mockedType = mockedType.getName();
-                if (interfaces.isEmpty()) { // Optimize memory footprint for the common case.
-                    types = Collections.emptySet();
-                } else {
-                    types = new HashSet<String>();
-                    for (Class<?> anInterface : interfaces) {
-                        types.add(anInterface.getName());
-                    }
-                    types.add(this.mockedType);
-                }
-            }
-
-            @Override
-            public boolean equals(Object other) {
-                if (this == other) return true;
-                if (other == null || getClass() != other.getClass()) return false;
-
-                MockKey mockKey = (MockKey<?>) other;
-
-                if (!mockedType.equals(mockKey.mockedType)) return false;
-                if (!types.equals(mockKey.types)) return false;
-
-                return true;
-            }
-
-            @Override
-            public int hashCode() {
-                int result = mockedType.hashCode();
-                result = 31 * result + types.hashCode();
-                return result;
-            }
-
-            public static <T> MockKey<T> of(Class<T> mockedType, Set<Class<?>> interfaces) {
-                return new MockKey<T>(mockedType, interfaces);
+                }, params.mockedType);
+        } catch (IllegalArgumentException exception) {
+            Throwable cause = exception.getCause();
+            if (cause instanceof RuntimeException) {
+                throw (RuntimeException) cause;
+            } else {
+                throw exception;
             }
         }
     }
 
-    private interface Key {
-
-        ClassLoader get();
-    }
-
-    private static class LookupKey implements Key {
-
-        private final ClassLoader value;
-
-        private final int hashCode;
-
-        public LookupKey(ClassLoader value) {
-            this.value = value;
-            hashCode = System.identityHashCode(value);
-        }
-
-        @Override
-        public ClassLoader get() {
-            return value;
-        }
-
-        @Override
-        public boolean equals(Object object) {
-            if (this == object) return true;
-            if (!(object instanceof Key)) return false;
-            return value == ((Key) object).get();
-        }
-
-        @Override
-        public int hashCode() {
-            return hashCode;
-        }
-    }
-
-    private static class WeakKey extends WeakReference<ClassLoader> implements Key {
+    private static class SerializationFeatureKey extends TypeCache.SimpleKey {
 
-        private final int hashCode;
+        private final SerializableMode serializableMode;
 
-        public WeakKey(ClassLoader referent, ReferenceQueue<ClassLoader> q) {
-            super(referent, q);
-            hashCode = System.identityHashCode(referent);
+        private SerializationFeatureKey(Class<?> type, Set<Class<?>> additionalType, SerializableMode serializableMode) {
+            super(type, additionalType);
+            this.serializableMode = serializableMode;
         }
 
         @Override
         public boolean equals(Object object) {
             if (this == object) return true;
-            if (!(object instanceof Key)) return false;
-            return get() == ((Key) object).get();
+            if (object == null || getClass() != object.getClass()) return false;
+            if (!super.equals(object)) return false;
+            SerializationFeatureKey that = (SerializationFeatureKey) object;
+            return serializableMode.equals(that.serializableMode);
         }
 
         @Override
         public int hashCode() {
-            return hashCode;
+            int result = super.hashCode();
+            result = 31 * result + serializableMode.hashCode();
+            return result;
         }
     }
 }
diff --git a/subprojects/android/android.gradle b/subprojects/android/android.gradle
index a8ad5acc5..92e4b515d 100644
--- a/subprojects/android/android.gradle
+++ b/subprojects/android/android.gradle
@@ -12,7 +12,7 @@ apply from: "$rootDir/gradle/publishable-java-library.gradle"
 
 dependencies {
     compile project.rootProject
-    compile "net.bytebuddy:byte-buddy-android:1.5.12"
+    compile "net.bytebuddy:byte-buddy-android:1.6.0"
 }
 
 tasks.javadoc.enabled = false
\ No newline at end of file
diff --git a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
index 056560f73..6675f1a1c 100644
--- a/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
+++ b/subprojects/android/src/main/java/org/mockito/android/internal/creation/AndroidLoadingStrategy.java
@@ -12,7 +12,7 @@ import static org.mockito.internal.util.StringJoiner.join;
 class AndroidLoadingStrategy implements SubclassLoader {
 
     @Override
-    public ClassLoadingStrategy getStrategy(Class<?> mockFeatures) {
+    public ClassLoadingStrategy<ClassLoader> getStrategy(Class<?> mockFeatures) {
         File target = AndroidTempFileLocator.target;
         if (target == null) {
             throw new MockitoException(join(
