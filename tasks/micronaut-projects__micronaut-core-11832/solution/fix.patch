diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/utils/AstBeanPropertiesUtils.java b/core-processor/src/main/java/io/micronaut/inject/ast/utils/AstBeanPropertiesUtils.java
index 44511eb534..ec96b0df1c 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/utils/AstBeanPropertiesUtils.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/utils/AstBeanPropertiesUtils.java
@@ -81,8 +81,9 @@ public final class AstBeanPropertiesUtils {
         Set<String> excludes = configuration.getExcludes();
         String[] readPrefixes = configuration.getReadPrefixes();
         String[] writePrefixes = configuration.getWritePrefixes();
+        var isRecord = classElement.isRecord();
 
-        Map<String, BeanPropertyData> props = new LinkedHashMap<>();
+        var props = new LinkedHashMap<String, BeanPropertyData>();
         for (MethodElement methodElement : methodsSupplier.get()) {
             // Records include everything
             if (methodElement.isStatic() && !configuration.isAllowStaticProperties() || !excludeElementsInRole && isMethodInRole(methodElement)) {
@@ -93,7 +94,7 @@ public final class AstBeanPropertiesUtils {
                 continue;
             }
             boolean isAccessor = canMethodBeUsedForAccess(methodElement, accessKinds, visibility);
-            if (classElement.isRecord()) {
+            if (isRecord) {
                 if (!isAccessor) {
                     continue;
                 }
@@ -126,57 +127,58 @@ public final class AstBeanPropertiesUtils {
             resolveWriteAccessForField(fieldElement, isAccessor, beanPropertyData);
         }
 
-        if (!props.isEmpty()) {
-            List<PropertyElement> beanProperties = new ArrayList<>(props.size());
-            for (Map.Entry<String, BeanPropertyData> entry : props.entrySet()) {
-                String propertyName = entry.getKey();
-                BeanPropertyData value = entry.getValue();
-                if (configuration.isIgnoreSettersWithDifferingType() && value.setter != null && value.getter != null) {
-                    // ensure types match
-                    ClassElement getterType = value.getter.getGenericReturnType();
-                    ClassElement setterType = value.setter.getParameters()[0].getGenericType();
-                    if (isIncompatibleSetterType(setterType, getterType)) {
-                        // getter and setter don't match, remove setter
-                        value.setter = null;
-                        value.type = getterType;
-                    }
-                }
-                // Define the property type based on its writer element
-                if (value.writeAccessKind == BeanProperties.AccessKind.FIELD && !value.field.getType().equals(value.type)) {
-                    value.type = value.field.getGenericType();
-                } else if (value.writeAccessKind == BeanProperties.AccessKind.METHOD
-                    && value.setter != null
-                    && value.setter.getParameters().length > 0) {
-                    value.type = value.setter.getParameters()[0].getGenericType();
-                }
-                // In a case when the field's type is the same as the selected property type,
-                // and it has more type arguments annotations - use it as the property type
-                if (value.field != null
-                    && value.field.getType().equals(value.type)
-                    && hasMoreAnnotations(value.field.getType(), value.type)) {
-                    value.type = value.field.getGenericType();
-                }
-                // In a case when the getter's type is the same as the selected property type,
-                // and it has more type arguments annotations - use it as the property type
-                if (value.getter != null
-                    && value.getter.getGenericReturnType().equals(value.type)
-                    && hasMoreAnnotations(value.getter.getGenericReturnType(), value.type)) {
-                    value.type = value.getter.getGenericReturnType();
+        if (props.isEmpty()) {
+            return Collections.emptyList();
+        }
+
+        var beanProperties = new ArrayList<PropertyElement>(props.size());
+        for (Map.Entry<String, BeanPropertyData> entry : props.entrySet()) {
+            String propertyName = entry.getKey();
+            BeanPropertyData value = entry.getValue();
+            if (configuration.isIgnoreSettersWithDifferingType() && value.setter != null && value.getter != null) {
+                // ensure types match
+                ClassElement getterType = value.getter.getGenericReturnType();
+                ClassElement setterType = value.setter.getParameters()[0].getGenericType();
+                if (isIncompatibleSetterType(setterType, getterType)) {
+                    // getter and setter don't match, remove setter
+                    value.setter = null;
+                    value.type = getterType;
                 }
-                if (value.readAccessKind != null || value.writeAccessKind != null) {
-                    value.isExcluded = shouldExclude(includes, excludes, propertyName)
-                        || isExcludedByAnnotations(configuration, value)
-                        || isExcludedBecauseOfMissingAccess(value);
+            }
+            // Define the property type based on its writer element
+            if (value.writeAccessKind == BeanProperties.AccessKind.FIELD && !value.field.getType().equals(value.type)) {
+                value.type = value.field.getGenericType();
+            } else if (value.writeAccessKind == BeanProperties.AccessKind.METHOD
+                && value.setter != null
+                && value.setter.getParameters().length > 0) {
+                value.type = value.setter.getParameters()[0].getGenericType();
+            }
+            // In a case when the field's type is the same as the selected property type,
+            // and it has more type arguments annotations - use it as the property type
+            if (value.field != null
+                && value.field.getType().equals(value.type)
+                && hasMoreAnnotations(value.field.getType(), value.type)) {
+                value.type = value.field.getGenericType();
+            }
+            // In a case when the getter's type is the same as the selected property type,
+            // and it has more type arguments annotations - use it as the property type
+            if (value.getter != null
+                && value.getter.getGenericReturnType().equals(value.type)
+                && hasMoreAnnotations(value.getter.getGenericReturnType(), value.type)) {
+                value.type = value.getter.getGenericReturnType();
+            }
+            if (value.readAccessKind != null || value.writeAccessKind != null) {
+                value.isExcluded = shouldExclude(includes, excludes, propertyName)
+                    || isExcludedByAnnotations(configuration, value)
+                    || isExcludedBecauseOfMissingAccess(value);
 
-                    PropertyElement propertyElement = propertyCreator.apply(value);
-                    if (propertyElement != null) {
-                        beanProperties.add(propertyElement);
-                    }
+                PropertyElement propertyElement = propertyCreator.apply(value);
+                if (propertyElement != null) {
+                    beanProperties.add(propertyElement);
                 }
             }
-            return beanProperties;
         }
-        return Collections.emptyList();
+        return beanProperties;
     }
 
     private static boolean hasMoreAnnotations(ClassElement c1, ClassElement c2) {
diff --git a/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java b/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java
index 164faf9cc0..f607ee2b0e 100644
--- a/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java
+++ b/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java
@@ -135,6 +135,7 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
     private final GroovyEnclosedElementsQuery groovySourceEnclosedElementsQuery = new GroovyEnclosedElementsQuery(true);
     @Nullable
     private AnnotationMetadata annotationMetadata;
+    private List<PropertyNode> propertyElements;
 
     /**
      * @param visitorContext The visitor context
@@ -254,6 +255,11 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
         return isTypeVar;
     }
 
+    @Override
+    public boolean isRecord() {
+        return classNode.isRecord();
+    }
+
     @Override
     public <T extends Element> @NonNull List<T> getEnclosedElements(@NonNull ElementQuery<T> query) {
         return groovyEnclosedElementsQuery.getEnclosedElements(this, query);
@@ -390,7 +396,20 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
 
     @Override
     public @NonNull List<PropertyElement> getBeanProperties(@NonNull PropertyElementQuery propertyElementQuery) {
-        Set<String> nativeProps = getPropertyNodes().stream().map(PropertyNode::getName).collect(Collectors.toCollection(LinkedHashSet::new));
+        if (isRecord()) {
+            return AstBeanPropertiesUtils.resolveBeanProperties(propertyElementQuery,
+                this,
+                this::getRecordMethods,
+                this::getRecordFields,
+                true,
+                Collections.emptySet(),
+                methodElement -> Optional.empty(),
+                methodElement -> Optional.empty(),
+                this::mapToPropertyElement);
+        }
+        Set<String> nativeProps = getPropertyNodes().stream()
+            .map(PropertyNode::getName)
+            .collect(Collectors.toCollection(LinkedHashSet::new));
         return AstBeanPropertiesUtils.resolveBeanProperties(propertyElementQuery,
             this,
             () -> getEnclosedElements(ElementQuery.ALL_METHODS.onlyInstance()),
@@ -410,6 +429,54 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
         return properties;
     }
 
+    private GroovyPropertyElement mapToPropertyElement(AstBeanPropertiesUtils.BeanPropertyData value) {
+        return new GroovyPropertyElement(
+            visitorContext,
+            GroovyClassElement.this,
+            value.type,
+            value.readAccessKind == null ? null : value.getter,
+            value.writeAccessKind == null ? null : value.setter,
+            value.field,
+            elementAnnotationMetadataFactory,
+            value.propertyName,
+            value.readAccessKind == null ? PropertyElement.AccessKind.METHOD : PropertyElement.AccessKind.valueOf(value.readAccessKind.name()),
+            value.writeAccessKind == null ? PropertyElement.AccessKind.METHOD : PropertyElement.AccessKind.valueOf(value.writeAccessKind.name()),
+            value.isExcluded
+        );
+    }
+
+    private List<MethodElement> getRecordMethods() {
+        var methodElements = new ArrayList<MethodElement>();
+        for (var recordComponentNode : classNode.getRecordComponents()) {
+            var method = classNode.getMethods(recordComponentNode.getName()).get(0);
+            methodElements.add(
+                new GroovyMethodElement(
+                    GroovyClassElement.this,
+                    visitorContext,
+                    new GroovyNativeElement.Method(method),
+                    method,
+                    elementAnnotationMetadataFactory
+                )
+            );
+        }
+        return methodElements;
+    }
+
+    private List<FieldElement> getRecordFields() {
+        var fieldElements = new ArrayList<FieldElement>();
+        for (var recordComponentNode : classNode.getRecordComponents()) {
+            fieldElements.add(
+                new GroovyFieldElement(
+                    visitorContext,
+                    GroovyClassElement.this,
+                    classNode.getField(recordComponentNode.getName()),
+                    elementAnnotationMetadataFactory
+                )
+            );
+        }
+        return fieldElements;
+    }
+
     @Nullable
     private GroovyPropertyElement mapPropertyElement(Set<String> nativeProps,
                                                      AstBeanPropertiesUtils.BeanPropertyData value,
@@ -487,7 +554,7 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
         if (value.readAccessKind != BeanProperties.AccessKind.METHOD) {
             value.getter = null;
         }
-        GroovyPropertyElement propertyElement = new GroovyPropertyElement(
+        var propertyElement = new GroovyPropertyElement(
             visitorContext,
             this,
             value.type,
@@ -498,7 +565,8 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
             value.propertyName,
             value.readAccessKind == null ? PropertyElement.AccessKind.METHOD : PropertyElement.AccessKind.valueOf(value.readAccessKind.name()),
             value.writeAccessKind == null ? PropertyElement.AccessKind.METHOD : PropertyElement.AccessKind.valueOf(value.writeAccessKind.name()),
-            value.isExcluded);
+            value.isExcluded
+        );
         ref.set(propertyElement);
         return propertyElement;
     }
@@ -541,15 +609,14 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
     @Override
     public PackageElement getPackage() {
         final PackageNode aPackage = classNode.getPackage();
-        if (aPackage != null) {
-            return new GroovyPackageElement(
-                visitorContext,
-                aPackage,
-                elementAnnotationMetadataFactory
-            );
-        } else {
+        if (aPackage == null) {
             return PackageElement.DEFAULT_PACKAGE;
         }
+        return new GroovyPackageElement(
+            visitorContext,
+            aPackage,
+            elementAnnotationMetadataFactory
+        );
     }
 
     @Override
@@ -632,6 +699,9 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
     }
 
     private List<PropertyNode> getPropertyNodes() {
+        if (propertyElements != null) {
+            return propertyElements;
+        }
         var propertyNodes = new ArrayList<PropertyNode>();
         ClassNode classNode = this.classNode;
         while (classNode != null && !classNode.equals(ClassHelper.OBJECT_TYPE) && !classNode.equals(ClassHelper.Enum_Type)) {
@@ -644,6 +714,7 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
                 propertyElements.add(propertyNode);
             }
         }
+        this.propertyElements = propertyElements;
         return propertyElements;
     }
 
@@ -708,7 +779,7 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
         @Override
         protected Set<AnnotatedNode> getExcludedNativeElements(ElementQuery.Result<?> result) {
             if (result.isExcludePropertyElements()) {
-                Set<AnnotatedNode> excluded = new HashSet<>();
+                var excluded = new HashSet<AnnotatedNode>();
                 for (PropertyElement excludePropertyElement : getBeanProperties()) {
                     excludePropertyElement.getReadMethod()
                         .filter(m -> !m.isSynthetic())
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
index f25af484a9..5b42c184ad 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
@@ -414,26 +414,24 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
     private List<MethodElement> getRecordMethods() {
         var recordComponents = new HashSet<String>();
         var methodElements = new ArrayList<MethodElement>();
-        if (JavaModelUtils.isRecord(classElement)) {
-            for (Element enclosedElement : classElement.getEnclosedElements()) {
-                if (JavaModelUtils.isRecordComponent(enclosedElement) || enclosedElement instanceof ExecutableElement) {
-                    if (enclosedElement.getKind() == ElementKind.CONSTRUCTOR) {
-                        continue;
-                    }
-                    String name = enclosedElement.getSimpleName().toString();
-                    if (enclosedElement instanceof ExecutableElement executableElement) {
-                        if (recordComponents.contains(name)) {
-                            methodElements.add(
-                                new JavaMethodElement(
-                                    JavaClassElement.this,
-                                    new JavaNativeElement.Method(executableElement),
-                                    elementAnnotationMetadataFactory,
-                                    visitorContext)
-                            );
-                        }
-                    } else if (enclosedElement instanceof VariableElement) {
-                        recordComponents.add(name);
+        for (Element enclosedElement : classElement.getEnclosedElements()) {
+            if (JavaModelUtils.isRecordComponent(enclosedElement) || enclosedElement instanceof ExecutableElement) {
+                if (enclosedElement.getKind() == ElementKind.CONSTRUCTOR) {
+                    continue;
+                }
+                String name = enclosedElement.getSimpleName().toString();
+                if (enclosedElement instanceof ExecutableElement executableElement) {
+                    if (recordComponents.contains(name)) {
+                        methodElements.add(
+                            new JavaMethodElement(
+                                JavaClassElement.this,
+                                new JavaNativeElement.Method(executableElement),
+                                elementAnnotationMetadataFactory,
+                                visitorContext)
+                        );
                     }
+                } else if (enclosedElement instanceof VariableElement) {
+                    recordComponents.add(name);
                 }
             }
         }
@@ -442,17 +440,15 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
 
     private List<FieldElement> getRecordFields() {
         var fieldElements = new ArrayList<FieldElement>();
-        if (JavaModelUtils.isRecord(classElement)) {
-            for (Element enclosedElement : classElement.getEnclosedElements()) {
-                if (!JavaModelUtils.isRecordComponent(enclosedElement) && enclosedElement instanceof VariableElement variableElement) {
-                    fieldElements.add(
-                        new JavaFieldElement(
-                            JavaClassElement.this,
-                            new JavaNativeElement.Variable(variableElement),
-                            elementAnnotationMetadataFactory,
-                            visitorContext)
-                    );
-                }
+        for (Element enclosedElement : classElement.getEnclosedElements()) {
+            if (!JavaModelUtils.isRecordComponent(enclosedElement) && enclosedElement instanceof VariableElement variableElement) {
+                fieldElements.add(
+                    new JavaFieldElement(
+                        JavaClassElement.this,
+                        new JavaNativeElement.Variable(variableElement),
+                        elementAnnotationMetadataFactory,
+                        visitorContext)
+                );
             }
         }
         return fieldElements;
