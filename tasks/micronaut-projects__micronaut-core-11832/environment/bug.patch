diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/utils/AstBeanPropertiesUtils.java b/core-processor/src/main/java/io/micronaut/inject/ast/utils/AstBeanPropertiesUtils.java
index ec96b0df1c..44511eb534 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/utils/AstBeanPropertiesUtils.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/utils/AstBeanPropertiesUtils.java
@@ -81,9 +81,8 @@ public final class AstBeanPropertiesUtils {
         Set<String> excludes = configuration.getExcludes();
         String[] readPrefixes = configuration.getReadPrefixes();
         String[] writePrefixes = configuration.getWritePrefixes();
-        var isRecord = classElement.isRecord();
 
-        var props = new LinkedHashMap<String, BeanPropertyData>();
+        Map<String, BeanPropertyData> props = new LinkedHashMap<>();
         for (MethodElement methodElement : methodsSupplier.get()) {
             // Records include everything
             if (methodElement.isStatic() && !configuration.isAllowStaticProperties() || !excludeElementsInRole && isMethodInRole(methodElement)) {
@@ -94,7 +93,7 @@ public final class AstBeanPropertiesUtils {
                 continue;
             }
             boolean isAccessor = canMethodBeUsedForAccess(methodElement, accessKinds, visibility);
-            if (isRecord) {
+            if (classElement.isRecord()) {
                 if (!isAccessor) {
                     continue;
                 }
@@ -127,58 +126,57 @@ public final class AstBeanPropertiesUtils {
             resolveWriteAccessForField(fieldElement, isAccessor, beanPropertyData);
         }
 
-        if (props.isEmpty()) {
-            return Collections.emptyList();
-        }
-
-        var beanProperties = new ArrayList<PropertyElement>(props.size());
-        for (Map.Entry<String, BeanPropertyData> entry : props.entrySet()) {
-            String propertyName = entry.getKey();
-            BeanPropertyData value = entry.getValue();
-            if (configuration.isIgnoreSettersWithDifferingType() && value.setter != null && value.getter != null) {
-                // ensure types match
-                ClassElement getterType = value.getter.getGenericReturnType();
-                ClassElement setterType = value.setter.getParameters()[0].getGenericType();
-                if (isIncompatibleSetterType(setterType, getterType)) {
-                    // getter and setter don't match, remove setter
-                    value.setter = null;
-                    value.type = getterType;
+        if (!props.isEmpty()) {
+            List<PropertyElement> beanProperties = new ArrayList<>(props.size());
+            for (Map.Entry<String, BeanPropertyData> entry : props.entrySet()) {
+                String propertyName = entry.getKey();
+                BeanPropertyData value = entry.getValue();
+                if (configuration.isIgnoreSettersWithDifferingType() && value.setter != null && value.getter != null) {
+                    // ensure types match
+                    ClassElement getterType = value.getter.getGenericReturnType();
+                    ClassElement setterType = value.setter.getParameters()[0].getGenericType();
+                    if (isIncompatibleSetterType(setterType, getterType)) {
+                        // getter and setter don't match, remove setter
+                        value.setter = null;
+                        value.type = getterType;
+                    }
                 }
-            }
-            // Define the property type based on its writer element
-            if (value.writeAccessKind == BeanProperties.AccessKind.FIELD && !value.field.getType().equals(value.type)) {
-                value.type = value.field.getGenericType();
-            } else if (value.writeAccessKind == BeanProperties.AccessKind.METHOD
-                && value.setter != null
-                && value.setter.getParameters().length > 0) {
-                value.type = value.setter.getParameters()[0].getGenericType();
-            }
-            // In a case when the field's type is the same as the selected property type,
-            // and it has more type arguments annotations - use it as the property type
-            if (value.field != null
-                && value.field.getType().equals(value.type)
-                && hasMoreAnnotations(value.field.getType(), value.type)) {
-                value.type = value.field.getGenericType();
-            }
-            // In a case when the getter's type is the same as the selected property type,
-            // and it has more type arguments annotations - use it as the property type
-            if (value.getter != null
-                && value.getter.getGenericReturnType().equals(value.type)
-                && hasMoreAnnotations(value.getter.getGenericReturnType(), value.type)) {
-                value.type = value.getter.getGenericReturnType();
-            }
-            if (value.readAccessKind != null || value.writeAccessKind != null) {
-                value.isExcluded = shouldExclude(includes, excludes, propertyName)
-                    || isExcludedByAnnotations(configuration, value)
-                    || isExcludedBecauseOfMissingAccess(value);
+                // Define the property type based on its writer element
+                if (value.writeAccessKind == BeanProperties.AccessKind.FIELD && !value.field.getType().equals(value.type)) {
+                    value.type = value.field.getGenericType();
+                } else if (value.writeAccessKind == BeanProperties.AccessKind.METHOD
+                    && value.setter != null
+                    && value.setter.getParameters().length > 0) {
+                    value.type = value.setter.getParameters()[0].getGenericType();
+                }
+                // In a case when the field's type is the same as the selected property type,
+                // and it has more type arguments annotations - use it as the property type
+                if (value.field != null
+                    && value.field.getType().equals(value.type)
+                    && hasMoreAnnotations(value.field.getType(), value.type)) {
+                    value.type = value.field.getGenericType();
+                }
+                // In a case when the getter's type is the same as the selected property type,
+                // and it has more type arguments annotations - use it as the property type
+                if (value.getter != null
+                    && value.getter.getGenericReturnType().equals(value.type)
+                    && hasMoreAnnotations(value.getter.getGenericReturnType(), value.type)) {
+                    value.type = value.getter.getGenericReturnType();
+                }
+                if (value.readAccessKind != null || value.writeAccessKind != null) {
+                    value.isExcluded = shouldExclude(includes, excludes, propertyName)
+                        || isExcludedByAnnotations(configuration, value)
+                        || isExcludedBecauseOfMissingAccess(value);
 
-                PropertyElement propertyElement = propertyCreator.apply(value);
-                if (propertyElement != null) {
-                    beanProperties.add(propertyElement);
+                    PropertyElement propertyElement = propertyCreator.apply(value);
+                    if (propertyElement != null) {
+                        beanProperties.add(propertyElement);
+                    }
                 }
             }
+            return beanProperties;
         }
-        return beanProperties;
+        return Collections.emptyList();
     }
 
     private static boolean hasMoreAnnotations(ClassElement c1, ClassElement c2) {
diff --git a/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java b/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java
index f607ee2b0e..164faf9cc0 100644
--- a/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java
+++ b/inject-groovy/src/main/groovy/io/micronaut/ast/groovy/visitor/GroovyClassElement.java
@@ -135,7 +135,6 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
     private final GroovyEnclosedElementsQuery groovySourceEnclosedElementsQuery = new GroovyEnclosedElementsQuery(true);
     @Nullable
     private AnnotationMetadata annotationMetadata;
-    private List<PropertyNode> propertyElements;
 
     /**
      * @param visitorContext The visitor context
@@ -255,11 +254,6 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
         return isTypeVar;
     }
 
-    @Override
-    public boolean isRecord() {
-        return classNode.isRecord();
-    }
-
     @Override
     public <T extends Element> @NonNull List<T> getEnclosedElements(@NonNull ElementQuery<T> query) {
         return groovyEnclosedElementsQuery.getEnclosedElements(this, query);
@@ -396,20 +390,7 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
 
     @Override
     public @NonNull List<PropertyElement> getBeanProperties(@NonNull PropertyElementQuery propertyElementQuery) {
-        if (isRecord()) {
-            return AstBeanPropertiesUtils.resolveBeanProperties(propertyElementQuery,
-                this,
-                this::getRecordMethods,
-                this::getRecordFields,
-                true,
-                Collections.emptySet(),
-                methodElement -> Optional.empty(),
-                methodElement -> Optional.empty(),
-                this::mapToPropertyElement);
-        }
-        Set<String> nativeProps = getPropertyNodes().stream()
-            .map(PropertyNode::getName)
-            .collect(Collectors.toCollection(LinkedHashSet::new));
+        Set<String> nativeProps = getPropertyNodes().stream().map(PropertyNode::getName).collect(Collectors.toCollection(LinkedHashSet::new));
         return AstBeanPropertiesUtils.resolveBeanProperties(propertyElementQuery,
             this,
             () -> getEnclosedElements(ElementQuery.ALL_METHODS.onlyInstance()),
@@ -429,54 +410,6 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
         return properties;
     }
 
-    private GroovyPropertyElement mapToPropertyElement(AstBeanPropertiesUtils.BeanPropertyData value) {
-        return new GroovyPropertyElement(
-            visitorContext,
-            GroovyClassElement.this,
-            value.type,
-            value.readAccessKind == null ? null : value.getter,
-            value.writeAccessKind == null ? null : value.setter,
-            value.field,
-            elementAnnotationMetadataFactory,
-            value.propertyName,
-            value.readAccessKind == null ? PropertyElement.AccessKind.METHOD : PropertyElement.AccessKind.valueOf(value.readAccessKind.name()),
-            value.writeAccessKind == null ? PropertyElement.AccessKind.METHOD : PropertyElement.AccessKind.valueOf(value.writeAccessKind.name()),
-            value.isExcluded
-        );
-    }
-
-    private List<MethodElement> getRecordMethods() {
-        var methodElements = new ArrayList<MethodElement>();
-        for (var recordComponentNode : classNode.getRecordComponents()) {
-            var method = classNode.getMethods(recordComponentNode.getName()).get(0);
-            methodElements.add(
-                new GroovyMethodElement(
-                    GroovyClassElement.this,
-                    visitorContext,
-                    new GroovyNativeElement.Method(method),
-                    method,
-                    elementAnnotationMetadataFactory
-                )
-            );
-        }
-        return methodElements;
-    }
-
-    private List<FieldElement> getRecordFields() {
-        var fieldElements = new ArrayList<FieldElement>();
-        for (var recordComponentNode : classNode.getRecordComponents()) {
-            fieldElements.add(
-                new GroovyFieldElement(
-                    visitorContext,
-                    GroovyClassElement.this,
-                    classNode.getField(recordComponentNode.getName()),
-                    elementAnnotationMetadataFactory
-                )
-            );
-        }
-        return fieldElements;
-    }
-
     @Nullable
     private GroovyPropertyElement mapPropertyElement(Set<String> nativeProps,
                                                      AstBeanPropertiesUtils.BeanPropertyData value,
@@ -554,7 +487,7 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
         if (value.readAccessKind != BeanProperties.AccessKind.METHOD) {
             value.getter = null;
         }
-        var propertyElement = new GroovyPropertyElement(
+        GroovyPropertyElement propertyElement = new GroovyPropertyElement(
             visitorContext,
             this,
             value.type,
@@ -565,8 +498,7 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
             value.propertyName,
             value.readAccessKind == null ? PropertyElement.AccessKind.METHOD : PropertyElement.AccessKind.valueOf(value.readAccessKind.name()),
             value.writeAccessKind == null ? PropertyElement.AccessKind.METHOD : PropertyElement.AccessKind.valueOf(value.writeAccessKind.name()),
-            value.isExcluded
-        );
+            value.isExcluded);
         ref.set(propertyElement);
         return propertyElement;
     }
@@ -609,14 +541,15 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
     @Override
     public PackageElement getPackage() {
         final PackageNode aPackage = classNode.getPackage();
-        if (aPackage == null) {
+        if (aPackage != null) {
+            return new GroovyPackageElement(
+                visitorContext,
+                aPackage,
+                elementAnnotationMetadataFactory
+            );
+        } else {
             return PackageElement.DEFAULT_PACKAGE;
         }
-        return new GroovyPackageElement(
-            visitorContext,
-            aPackage,
-            elementAnnotationMetadataFactory
-        );
     }
 
     @Override
@@ -699,9 +632,6 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
     }
 
     private List<PropertyNode> getPropertyNodes() {
-        if (propertyElements != null) {
-            return propertyElements;
-        }
         var propertyNodes = new ArrayList<PropertyNode>();
         ClassNode classNode = this.classNode;
         while (classNode != null && !classNode.equals(ClassHelper.OBJECT_TYPE) && !classNode.equals(ClassHelper.Enum_Type)) {
@@ -714,7 +644,6 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
                 propertyElements.add(propertyNode);
             }
         }
-        this.propertyElements = propertyElements;
         return propertyElements;
     }
 
@@ -779,7 +708,7 @@ public class GroovyClassElement extends AbstractGroovyElement implements Arrayab
         @Override
         protected Set<AnnotatedNode> getExcludedNativeElements(ElementQuery.Result<?> result) {
             if (result.isExcludePropertyElements()) {
-                var excluded = new HashSet<AnnotatedNode>();
+                Set<AnnotatedNode> excluded = new HashSet<>();
                 for (PropertyElement excludePropertyElement : getBeanProperties()) {
                     excludePropertyElement.getReadMethod()
                         .filter(m -> !m.isSynthetic())
diff --git a/inject-groovy/src/test/groovy/io/micronaut/ast/groovy/visitor/GroovyBeanPropertiesSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/ast/groovy/visitor/GroovyBeanPropertiesSpec.groovy
index 57eeaba4f3..bfd381f163 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/ast/groovy/visitor/GroovyBeanPropertiesSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/ast/groovy/visitor/GroovyBeanPropertiesSpec.groovy
@@ -32,72 +32,4 @@ class Test extends SuperClass {
         expect:
         classElement.getBeanProperties().every { it.hasAnnotation(NotBlank) }
     }
-
-    void "test groovy and java records"() {
-        def classElement = buildClassElement("""
-package test
-
-import io.micronaut.ast.groovy.visitor.GroovyRecord
-import io.micronaut.sample.EmptyRecord
-import io.micronaut.sample.JavaRecord 
-
-class ObjectWithProps {
-
-    private GroovyRecord groovyRecord
-    private JavaRecord javaRecord
-    private EmptyRecord emptyRecord
-    
-    GroovyRecord getGroovyRecord() {
-        return groovyRecord
-    }
-
-    void setGroovyRecord(GroovyRecord groovyRecord) {
-        this.groovyRecord = groovyRecord
-    }
-
-    JavaRecord getJavaRecord() {
-        return javaRecord
-    }
-
-    void setJavaRecord(JavaRecord javaRecord) {
-        this.javaRecord = javaRecord
-    }
-
-    EmptyRecord getEmptyRecord() {
-        return emptyRecord
-    }
-
-    void setEmptyRecord(EmptyRecord emptyRecord) {
-        this.emptyRecord = emptyRecord
-    }
-}
-
-""")
-
-        var props = classElement.getBeanProperties()
-
-        expect:
-        props.size() == 3
-        props[0].type.isRecord()
-        props[1].type.isRecord()
-        props[2].type.isRecord()
-
-        when:
-        var props1 = props[0].type.getBeanProperties()
-
-        then:
-        props1.size() == 2
-
-        when:
-        var props2 = props[1].type.getBeanProperties()
-
-        then:
-        props2.size() == 2
-
-        when:
-        var props3 = props[2].type.getBeanProperties()
-
-        then:
-        props3.size() == 0
-    }
 }
diff --git a/inject-groovy/src/test/groovy/io/micronaut/ast/groovy/visitor/GroovyRecord.groovy b/inject-groovy/src/test/groovy/io/micronaut/ast/groovy/visitor/GroovyRecord.groovy
deleted file mode 100644
index 157a875ec1..0000000000
--- a/inject-groovy/src/test/groovy/io/micronaut/ast/groovy/visitor/GroovyRecord.groovy
+++ /dev/null
@@ -1,6 +0,0 @@
-package io.micronaut.ast.groovy.visitor
-
-record GroovyRecord(
-        String param1,
-        int param2
-) {}
diff --git a/inject-groovy/src/test/java/io/micronaut/sample/EmptyRecord.java b/inject-groovy/src/test/java/io/micronaut/sample/EmptyRecord.java
deleted file mode 100644
index a617c3225a..0000000000
--- a/inject-groovy/src/test/java/io/micronaut/sample/EmptyRecord.java
+++ /dev/null
@@ -1,4 +0,0 @@
-package io.micronaut.sample;
-
-public record EmptyRecord() {
-}
diff --git a/inject-groovy/src/test/java/io/micronaut/sample/JavaRecord.java b/inject-groovy/src/test/java/io/micronaut/sample/JavaRecord.java
deleted file mode 100644
index 0fc8686fbd..0000000000
--- a/inject-groovy/src/test/java/io/micronaut/sample/JavaRecord.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package io.micronaut.sample;
-
-public record JavaRecord(
-    String field1,
-    Integer field2
-) {
-
-}
diff --git a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
index 5b42c184ad..f25af484a9 100644
--- a/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
+++ b/inject-java/src/main/java/io/micronaut/annotation/processing/visitor/JavaClassElement.java
@@ -414,24 +414,26 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
     private List<MethodElement> getRecordMethods() {
         var recordComponents = new HashSet<String>();
         var methodElements = new ArrayList<MethodElement>();
-        for (Element enclosedElement : classElement.getEnclosedElements()) {
-            if (JavaModelUtils.isRecordComponent(enclosedElement) || enclosedElement instanceof ExecutableElement) {
-                if (enclosedElement.getKind() == ElementKind.CONSTRUCTOR) {
-                    continue;
-                }
-                String name = enclosedElement.getSimpleName().toString();
-                if (enclosedElement instanceof ExecutableElement executableElement) {
-                    if (recordComponents.contains(name)) {
-                        methodElements.add(
-                            new JavaMethodElement(
-                                JavaClassElement.this,
-                                new JavaNativeElement.Method(executableElement),
-                                elementAnnotationMetadataFactory,
-                                visitorContext)
-                        );
+        if (JavaModelUtils.isRecord(classElement)) {
+            for (Element enclosedElement : classElement.getEnclosedElements()) {
+                if (JavaModelUtils.isRecordComponent(enclosedElement) || enclosedElement instanceof ExecutableElement) {
+                    if (enclosedElement.getKind() == ElementKind.CONSTRUCTOR) {
+                        continue;
+                    }
+                    String name = enclosedElement.getSimpleName().toString();
+                    if (enclosedElement instanceof ExecutableElement executableElement) {
+                        if (recordComponents.contains(name)) {
+                            methodElements.add(
+                                new JavaMethodElement(
+                                    JavaClassElement.this,
+                                    new JavaNativeElement.Method(executableElement),
+                                    elementAnnotationMetadataFactory,
+                                    visitorContext)
+                            );
+                        }
+                    } else if (enclosedElement instanceof VariableElement) {
+                        recordComponents.add(name);
                     }
-                } else if (enclosedElement instanceof VariableElement) {
-                    recordComponents.add(name);
                 }
             }
         }
@@ -440,15 +442,17 @@ public class JavaClassElement extends AbstractJavaElement implements ArrayableCl
 
     private List<FieldElement> getRecordFields() {
         var fieldElements = new ArrayList<FieldElement>();
-        for (Element enclosedElement : classElement.getEnclosedElements()) {
-            if (!JavaModelUtils.isRecordComponent(enclosedElement) && enclosedElement instanceof VariableElement variableElement) {
-                fieldElements.add(
-                    new JavaFieldElement(
-                        JavaClassElement.this,
-                        new JavaNativeElement.Variable(variableElement),
-                        elementAnnotationMetadataFactory,
-                        visitorContext)
-                );
+        if (JavaModelUtils.isRecord(classElement)) {
+            for (Element enclosedElement : classElement.getEnclosedElements()) {
+                if (!JavaModelUtils.isRecordComponent(enclosedElement) && enclosedElement instanceof VariableElement variableElement) {
+                    fieldElements.add(
+                        new JavaFieldElement(
+                            JavaClassElement.this,
+                            new JavaNativeElement.Variable(variableElement),
+                            elementAnnotationMetadataFactory,
+                            visitorContext)
+                    );
+                }
             }
         }
         return fieldElements;
