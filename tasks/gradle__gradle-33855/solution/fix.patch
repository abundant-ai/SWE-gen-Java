diff --git a/platforms/core-configuration/configuration-cache/src/integTest/groovy/org/gradle/internal/cc/impl/ConfigurationCacheGroovyClosureIntegrationTest.groovy b/platforms/core-configuration/configuration-cache/src/integTest/groovy/org/gradle/internal/cc/impl/ConfigurationCacheGroovyClosureIntegrationTest.groovy
index cecfe940dc8..282920068d2 100644
--- a/platforms/core-configuration/configuration-cache/src/integTest/groovy/org/gradle/internal/cc/impl/ConfigurationCacheGroovyClosureIntegrationTest.groovy
+++ b/platforms/core-configuration/configuration-cache/src/integTest/groovy/org/gradle/internal/cc/impl/ConfigurationCacheGroovyClosureIntegrationTest.groovy
@@ -19,17 +19,21 @@ package org.gradle.internal.cc.impl
 import org.gradle.api.DefaultTask
 import org.gradle.api.tasks.Internal
 import org.gradle.api.tasks.TaskAction
+import org.gradle.integtests.fixtures.configurationcache.ConfigurationCacheFixture
 import org.gradle.internal.serialize.codecs.core.ClosureCodec
 
 class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurationCacheIntegrationTest {
 
-    def "from-cache build fails when task action closure reads a project property"() {
+    def configurationCache = new ConfigurationCacheFixture(this)
+
+    def "task fails immediately when task action closure reads a project property"() {
         given:
         buildFile << """
             tasks.register("some") {
                 doFirst {
                     println(name) // task property is ok
                     println($expression)
+                    throw new IllegalStateException("UNREACHABLE")
                 }
             }
         """
@@ -41,7 +45,14 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
         failure.assertHasFileName("Build file '$buildFile'")
         failure.assertHasLineNumber(5)
         failure.assertHasFailure("Execution failed for task ':some'.") {
-            it.assertHasCause("Cannot reference a Gradle script object from a Groovy closure as these are not supported with the configuration cache.")
+            it.assertHasCause("Invocation of 'buildDir' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.")
+        }
+        outputDoesNotContain("UNREACHABLE")
+
+        configurationCache.assertStateStoredAndDiscarded {
+            hasStoreFailure = false
+            reportedOutsideBuildFailure = true
+            problem "Task `:some` of type `org.gradle.api.DefaultTask`: invocation of 'buildDir' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache."
         }
 
         where:
@@ -51,13 +62,14 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
         "owner.buildDir" | _
     }
 
-    def "from-cache build fails when task action closure sets a project property"() {
+    def "task fails immediately when task action closure sets a project property"() {
         given:
         buildFile << """
             tasks.register("some") {
                 doFirst {
                     description = "broken" // task property is ok
                     $expression = 1.2
+                    throw new IllegalStateException("UNREACHABLE")
                 }
             }
         """
@@ -69,7 +81,14 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
         failure.assertHasFileName("Build file '$buildFile'")
         failure.assertHasLineNumber(5)
         failure.assertHasFailure("Execution failed for task ':some'.") {
-            it.assertHasCause("Cannot reference a Gradle script object from a Groovy closure as these are not supported with the configuration cache.")
+            it.assertHasCause("Invocation of 'version' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.")
+        }
+        outputDoesNotContain("UNREACHABLE")
+
+        configurationCache.assertStateStoredAndDiscarded {
+            hasStoreFailure = false
+            reportedOutsideBuildFailure = true
+            problem "Task `:some` of type `org.gradle.api.DefaultTask`: invocation of 'version' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache."
         }
 
         where:
@@ -79,12 +98,13 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
         "owner.version" | _
     }
 
-    def "from-cache build fails when task action closure invokes a project method"() {
+    def "task fails immediately when task action closure invokes a project method"() {
         given:
         buildFile << """
             tasks.register("some") {
                 doFirst {
                     println(file("broken"))
+                    throw new IllegalStateException("UNREACHABLE")
                 }
             }
         """
@@ -96,11 +116,18 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
         failure.assertHasFileName("Build file '$buildFile'")
         failure.assertHasLineNumber(4)
         failure.assertHasFailure("Execution failed for task ':some'.") {
-            it.assertHasCause("Cannot reference a Gradle script object from a Groovy closure as these are not supported with the configuration cache.")
+            it.assertHasCause("Invocation of 'file' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.")
+        }
+        outputDoesNotContain("UNREACHABLE")
+
+        configurationCache.assertStateStoredAndDiscarded {
+            hasStoreFailure = false
+            reportedOutsideBuildFailure = true
+            problem "Task `:some` of type `org.gradle.api.DefaultTask`: invocation of 'file' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache."
         }
     }
 
-    def "from-cache build fails when task action nested closure reads a project property"() {
+    def "task fails immediately when task action nested closure reads a project property"() {
         given:
         buildFile << """
             tasks.register("some") {
@@ -110,6 +137,7 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
                         println(buildDir)
                     }
                     cl()
+                    throw new IllegalStateException("UNREACHABLE")
                 }
             }
         """
@@ -121,11 +149,18 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
         failure.assertHasFileName("Build file '$buildFile'")
         failure.assertHasLineNumber(6)
         failure.assertHasFailure("Execution failed for task ':some'.") {
-            it.assertHasCause("Cannot reference a Gradle script object from a Groovy closure as these are not supported with the configuration cache.")
+            it.assertHasCause("Invocation of 'buildDir' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.")
+        }
+        outputDoesNotContain("UNREACHABLE")
+
+        configurationCache.assertStateStoredAndDiscarded {
+            hasStoreFailure = false
+            reportedOutsideBuildFailure = true
+            problem "Task `:some` of type `org.gradle.api.DefaultTask`: invocation of 'buildDir' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache."
         }
     }
 
-    def "from-cache build fails when task action defined in settings script reads a settings property"() {
+    def "task fails immediately when task action defined in settings script reads a settings property"() {
         given:
         settingsFile << """
             gradle.rootProject {
@@ -133,6 +168,7 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
                     doFirst {
                         println(name) // task property is ok
                         println(rootProject)
+                        throw new IllegalStateException("UNREACHABLE")
                     }
                 }
             }
@@ -145,11 +181,18 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
         failure.assertHasFileName("Settings file '$settingsFile'")
         failure.assertHasLineNumber(6)
         failure.assertHasFailure("Execution failed for task ':some'.") {
-            it.assertHasCause("Cannot reference a Gradle script object from a Groovy closure as these are not supported with the configuration cache.")
+            it.assertHasCause("Invocation of 'rootProject' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.")
+        }
+        outputDoesNotContain("UNREACHABLE")
+
+        configurationCache.assertStateStoredAndDiscarded {
+            hasStoreFailure = false
+            reportedOutsideBuildFailure = true
+            problem "Task `:some` of type `org.gradle.api.DefaultTask`: invocation of 'rootProject' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache."
         }
     }
 
-    def "from-cache build fails when task action defined in init script reads a `Gradle` property"() {
+    def "task fails immediately when task action defined in init script reads a `Gradle` property"() {
         given:
         def initScript = file("init.gradle")
         initScript << """
@@ -158,11 +201,12 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
                     doFirst {
                         println(name) // task property is ok
                         println(gradleVersion)
+                        throw new IllegalStateException("UNREACHABLE")
                     }
                 }
             }
         """
-        executer.beforeExecute { withArguments("-I", initScript.absolutePath) }
+        executer.beforeExecute { withArgument("-I").withArgument(initScript.absolutePath) }
 
         when:
         configurationCacheFails ":some"
@@ -171,18 +215,25 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
         failure.assertHasFileName("Initialization script '$initScript'")
         failure.assertHasLineNumber(6)
         failure.assertHasFailure("Execution failed for task ':some'.") {
-            it.assertHasCause("Cannot reference a Gradle script object from a Groovy closure as these are not supported with the configuration cache.")
+            it.assertHasCause("Invocation of 'gradleVersion' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.")
+        }
+        outputDoesNotContain("UNREACHABLE")
+
+        configurationCache.assertStateStoredAndDiscarded {
+            hasStoreFailure = false
+            reportedOutsideBuildFailure = true
+            problem "Task `:some` of type `org.gradle.api.DefaultTask`: invocation of 'gradleVersion' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache."
         }
     }
 
-    def "from-cache build fails when task onlyIf closure reads a project property"() {
+    def "task fails immediately when task onlyIf closure reads a project property"() {
         given:
         buildFile << """
             tasks.register("some") {
                 onlyIf { t ->
                     println(t.name) // task property is ok
                     println(buildDir)
-                    true
+                    throw new IllegalStateException("UNREACHABLE")
                 }
                 doFirst {
                 }
@@ -195,9 +246,45 @@ class ConfigurationCacheGroovyClosureIntegrationTest extends AbstractConfigurati
         then:
         failure.assertHasFileName("Build file '$buildFile'")
         failure.assertHasLineNumber(5)
-        failure.assertHasFailure("Could not evaluate onlyIf predicate for task ':some'.") {
+        failure.assertHasFailure("Invocation of 'buildDir' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.") {
             // The cause is not reported
         }
+        outputDoesNotContain("UNREACHABLE")
+
+        configurationCache.assertStateStoredAndDiscarded {
+            hasStoreFailure = false
+            reportedOutsideBuildFailure = true
+            problem "Task `:some` of type `org.gradle.api.DefaultTask`: invocation of 'buildDir' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache."
+        }
+    }
+
+    def "in warning mode, cache entry is stored but task still fails immediately"() {
+        given:
+        buildFile << """
+            tasks.register("some") {
+                doFirst {
+                    println(buildDir)
+                    throw new IllegalStateException("UNREACHABLE")
+                }
+            }
+        """
+
+        when:
+        configurationCacheFails ":some", "$WARN_PROBLEMS_CLI_OPT"
+
+        then:
+        failure.assertHasFileName("Build file '$buildFile'")
+        failure.assertHasLineNumber(4)
+        failure.assertHasFailure("Execution failed for task ':some'.") {
+            it.assertHasCause("Invocation of 'buildDir' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.")
+        }
+        outputDoesNotContain("UNREACHABLE")
+
+        // TODO: use `configurationCache` fixture, when https://github.com/gradle/gradle/issues/33857 is fixed
+        configurationCache.configurationCacheBuildOperations.assertStateStored()
+        problems.assertResultHasProblems(result) {
+            withProblem("Task `:some` of type `org.gradle.api.DefaultTask`: invocation of 'buildDir' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.")
+        }
     }
 
     def "discards implicit objects for Groovy closure"() {
diff --git a/platforms/core-configuration/configuration-cache/src/integTest/groovy/org/gradle/internal/cc/impl/ConfigurationCacheTaskExecutionIntegrationTest.groovy b/platforms/core-configuration/configuration-cache/src/integTest/groovy/org/gradle/internal/cc/impl/ConfigurationCacheTaskExecutionIntegrationTest.groovy
index be6e78b204e..7963b31e13a 100644
--- a/platforms/core-configuration/configuration-cache/src/integTest/groovy/org/gradle/internal/cc/impl/ConfigurationCacheTaskExecutionIntegrationTest.groovy
+++ b/platforms/core-configuration/configuration-cache/src/integTest/groovy/org/gradle/internal/cc/impl/ConfigurationCacheTaskExecutionIntegrationTest.groovy
@@ -334,6 +334,9 @@ class ConfigurationCacheTaskExecutionIntegrationTest extends AbstractConfigurati
         configurationCacheRun("offender")
 
         then:
+        // TODO: use `configurationCache` fixture, when https://github.com/gradle/gradle/issues/33857 is fixed
+        configurationCache.configurationCacheBuildOperations.assertStorePhaseSuccessful()
+        configurationCache.configurationCacheBuildOperations.assertLoadPhaseSkipped()
         problems.assertResultHasProblems(result) {
             withProblemsWithStackTraceCount(2)
             withProblem("Build file 'build.gradle': line 11: invocation of 'Task.project' at execution time is unsupported with the configuration cache.")
@@ -359,6 +362,8 @@ class ConfigurationCacheTaskExecutionIntegrationTest extends AbstractConfigurati
         configurationCacheFails(WARN_PROBLEMS_CLI_OPT, 'report')
 
         then:
+        // TODO: use `configurationCache` fixture, when https://github.com/gradle/gradle/issues/33857 is fixed
+        configurationCache.configurationCacheBuildOperations.assertStateStored()
         problems.assertResultHasProblems(failure) {
             withProblem "Task `:report` of type `org.gradle.api.DefaultTask`: invocation of 'Task.extensions' at execution time is unsupported with the configuration cache."
         }
diff --git a/platforms/core-configuration/configuration-problems-base/src/main/kotlin/org/gradle/internal/configuration/problems/PropertyProblem.kt b/platforms/core-configuration/configuration-problems-base/src/main/kotlin/org/gradle/internal/configuration/problems/PropertyProblem.kt
index ce96456008b..7f63e2dcc49 100644
--- a/platforms/core-configuration/configuration-problems-base/src/main/kotlin/org/gradle/internal/configuration/problems/PropertyProblem.kt
+++ b/platforms/core-configuration/configuration-problems-base/src/main/kotlin/org/gradle/internal/configuration/problems/PropertyProblem.kt
@@ -56,7 +56,8 @@ enum class DocumentationSection(val page: String, val anchor: String) {
     RequirementsExternalProcess("configuration_cache_requirements","config_cache:requirements:external_processes"),
     RequirementsTaskAccess("configuration_cache_requirements","config_cache:requirements:task_access"),
     RequirementsSysPropEnvVarRead("configuration_cache_requirements","config_cache:requirements:reading_sys_props_and_env_vars"),
-    RequirementsUseProjectDuringExecution("configuration_cache_requirements","config_cache:requirements:use_project_during_execution")
+    RequirementsUseProjectDuringExecution("configuration_cache_requirements","config_cache:requirements:use_project_during_execution"),
+    RequirementsGradleModelTypes("configuration_cache_requirements","config_cache:requirements:gradle_model_types"),
 }
 
 
diff --git a/platforms/core-configuration/core-serialization-codecs/src/main/kotlin/org/gradle/internal/serialize/codecs/core/GroovyCodecs.kt b/platforms/core-configuration/core-serialization-codecs/src/main/kotlin/org/gradle/internal/serialize/codecs/core/GroovyCodecs.kt
index 4c33b0ac1cb..e56bfdae9d5 100644
--- a/platforms/core-configuration/core-serialization-codecs/src/main/kotlin/org/gradle/internal/serialize/codecs/core/GroovyCodecs.kt
+++ b/platforms/core-configuration/core-serialization-codecs/src/main/kotlin/org/gradle/internal/serialize/codecs/core/GroovyCodecs.kt
@@ -23,10 +23,15 @@ import groovy.lang.MissingMethodException
 import groovy.lang.MissingPropertyException
 import groovy.lang.Script
 import org.codehaus.groovy.runtime.InvokerHelper
+import org.gradle.api.InvalidUserCodeException
 import org.gradle.api.Project
 import org.gradle.api.initialization.Settings
 import org.gradle.api.invocation.Gradle
 import org.gradle.groovy.scripts.BasicScript
+import org.gradle.internal.configuration.problems.DocumentationSection.RequirementsGradleModelTypes
+import org.gradle.internal.configuration.problems.ProblemFactory
+import org.gradle.internal.configuration.problems.ProblemsListener
+import org.gradle.internal.configuration.problems.PropertyTrace
 import org.gradle.internal.metaobject.ConfigureDelegate
 import org.gradle.internal.serialize.graph.Codec
 import org.gradle.internal.serialize.graph.ReadContext
@@ -35,6 +40,7 @@ import org.gradle.internal.serialize.graph.codecs.BindingsBuilder
 import org.gradle.internal.serialize.graph.decodeBean
 import org.gradle.internal.serialize.graph.encodeBean
 import org.gradle.internal.serialize.graph.readEnum
+import org.gradle.internal.serialize.graph.serviceOf
 import org.gradle.internal.serialize.graph.writeEnum
 
 
@@ -92,12 +98,16 @@ object ClosureCodec : Codec<Closure<*>> {
     private
     fun ReadContext.readReference(): Any =
         when (readEnum<ClosureReference>()) {
-            ClosureReference.Project -> BrokenScript(Project::class.java)
-            ClosureReference.Settings -> BrokenScript(Settings::class.java)
-            ClosureReference.Init -> BrokenScript(Gradle::class.java)
+            ClosureReference.Project -> BrokenScript(Project::class.java, trace, problemsFactory(), problemsListener)
+            ClosureReference.Settings -> BrokenScript(Settings::class.java, trace, problemsFactory(), problemsListener)
+            ClosureReference.Init -> BrokenScript(Gradle::class.java, trace, problemsFactory(), problemsListener)
             ClosureReference.NotScript -> BrokenObject
         }
 
+    private
+    fun ReadContext.problemsFactory(): ProblemFactory =
+        isolate.owner.serviceOf<ProblemFactory>()
+
     private
     enum class ClosureReference {
         Project, Settings, Init, NotScript
@@ -107,12 +117,17 @@ object ClosureCodec : Codec<Closure<*>> {
     object BrokenObject : GroovyObjectSupport()
 
     private
-    class BrokenScript(targetType: Class<*>) : Script() {
+    class BrokenScript(
+        targetType: Class<*>,
+        private val trace: PropertyTrace,
+        private val problemFactory: ProblemFactory,
+        private val problemsListener: ProblemsListener
+    ) : Script() {
         private
         val targetMetadata = ThreadSafeMetaClassWrapper(targetType)
 
         override fun run(): Any {
-            scriptReferenced()
+            scriptReferenced(invocationDescription = "Script.run")
         }
 
         override fun getProperty(propertyName: String): Any {
@@ -125,7 +140,7 @@ object ClosureCodec : Codec<Closure<*>> {
                 }
                 throw MissingPropertyException(propertyName)
             }
-            scriptReferenced()
+            scriptReferenced(invocationDescription = propertyName)
         }
 
         override fun setProperty(propertyName: String, newValue: Any?) {
@@ -133,20 +148,38 @@ object ClosureCodec : Codec<Closure<*>> {
             if (targetMetadata.hasProperty(null, propertyName) == null) {
                 throw MissingPropertyException(propertyName)
             }
-            scriptReferenced()
+            scriptReferenced(invocationDescription = propertyName)
         }
 
         override fun invokeMethod(name: String, args: Any): Any {
             // See above for why this check happens
             if (targetMetadata.respondsTo(null, name).isEmpty()) {
-                throw MissingMethodException(name, Project::class.java, arrayOf())
+                throw MissingMethodException(name, targetMetadata.targetType, arrayOf())
             }
-            scriptReferenced()
+            scriptReferenced(invocationDescription = name)
         }
 
         private
-        fun scriptReferenced(): Nothing {
-            error("Cannot reference a Gradle script object from a Groovy closure as these are not supported with the configuration cache.")
+        fun scriptReferenced(invocationDescription: String): Nothing {
+            val exceptionMessage =
+                "Invocation of '$invocationDescription' references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache."
+
+            val problem = problemFactory.problem {
+                text("invocation of ")
+                reference(invocationDescription)
+                text(" references a Gradle script object from a Groovy closure at execution time, which is unsupported with the configuration cache.")
+            }
+                .exception(exceptionMessage)
+                .documentationSection(RequirementsGradleModelTypes)
+                .mapLocation { trace }
+                .build()
+
+            problemsListener.onExecutionTimeProblem(problem)
+
+            // We normally fail immediately on execution-time problems, except when in the warning mode.
+            // However, even in the warning mode, we don't have a reasonable way of proceeding in this situation
+            // so we make sure to throw
+            throw problem.exception ?: InvalidUserCodeException(exceptionMessage)
         }
     }
 }
@@ -176,6 +209,9 @@ private value class ThreadSafeMetaClassWrapper private constructor(
 ) {
     constructor(cls: Class<*>) : this(synchronized(cls) { InvokerHelper.getMetaClass(cls) })
 
+    val targetType: Class<*>
+        get() = metaClass.theClass
+
     fun hasProperty(obj: Any?, propertyName: String) = synchronized(metaClass) { metaClass.hasProperty(obj, propertyName) }
 
     fun respondsTo(obj: Any?, name: String) = synchronized(metaClass) { metaClass.respondsTo(obj, name) }
diff --git a/platforms/core-configuration/graph-serialization/src/main/kotlin/org/gradle/internal/serialize/graph/Codec.kt b/platforms/core-configuration/graph-serialization/src/main/kotlin/org/gradle/internal/serialize/graph/Codec.kt
index 65bdca1ab25..667cc699e24 100644
--- a/platforms/core-configuration/graph-serialization/src/main/kotlin/org/gradle/internal/serialize/graph/Codec.kt
+++ b/platforms/core-configuration/graph-serialization/src/main/kotlin/org/gradle/internal/serialize/graph/Codec.kt
@@ -17,6 +17,7 @@
 package org.gradle.internal.serialize.graph
 
 import org.gradle.api.logging.Logger
+import org.gradle.internal.configuration.problems.ProblemsListener
 import org.gradle.internal.configuration.problems.PropertyKind
 import org.gradle.internal.configuration.problems.PropertyProblem
 import org.gradle.internal.configuration.problems.PropertyTrace
@@ -168,6 +169,8 @@ interface IsolateContext {
 
     val trace: PropertyTrace
 
+    val problemsListener: ProblemsListener
+
     fun onProblem(problem: PropertyProblem)
 
     fun onError(error: Exception, message: StructuredMessageBuilder)
diff --git a/platforms/core-configuration/graph-serialization/src/main/kotlin/org/gradle/internal/serialize/graph/Contexts.kt b/platforms/core-configuration/graph-serialization/src/main/kotlin/org/gradle/internal/serialize/graph/Contexts.kt
index b968d756294..a1e4f4a2554 100644
--- a/platforms/core-configuration/graph-serialization/src/main/kotlin/org/gradle/internal/serialize/graph/Contexts.kt
+++ b/platforms/core-configuration/graph-serialization/src/main/kotlin/org/gradle/internal/serialize/graph/Contexts.kt
@@ -376,6 +376,9 @@ abstract class AbstractIsolateContext<T>(
         currentCodec = previousValues.second
     }
 
+    override val problemsListener: ProblemsListener
+        get() = currentProblemsListener
+
     override fun onProblem(problem: PropertyProblem) {
         currentProblemsListener.onProblem(problem)
     }
diff --git a/platforms/documentation/docs/src/docs/userguide/optimizing-builds/configuration-cache/configuration_cache_requirements.adoc b/platforms/documentation/docs/src/docs/userguide/optimizing-builds/configuration-cache/configuration_cache_requirements.adoc
index 2d24da848a6..6fb1dd32926 100644
--- a/platforms/documentation/docs/src/docs/userguide/optimizing-builds/configuration-cache/configuration_cache_requirements.adoc
+++ b/platforms/documentation/docs/src/docs/userguide/optimizing-builds/configuration-cache/configuration_cache_requirements.adoc
@@ -45,6 +45,7 @@ Live JVM state types (e.g., `ClassLoader`, `Thread`, `OutputStream`, `Socket`) a
 
 The only exceptions are standard streams (`System.in`, `System.out`, `System.err`), which can be used, for example, as parameters for link:{groovyDslPath}/org.gradle.api.tasks.Exec.html[`Exec`] and link:{groovyDslPath}/org.gradle.api.tasks.JavaExec.html[`JavaExec`] tasks.
 
+[[config_cache:requirements:gradle_model_types]]
 === Gradle Model Types
 
 Gradle model types (e.g., `Gradle`, `Settings`, `Project`, `SourceSet`, `Configuration`) are often used to pass task inputs that should instead be explicitly declared.
diff --git a/subprojects/core/src/integTest/groovy/org/gradle/api/invocation/GradleLifecycleIsolationIntegrationTest.groovy b/subprojects/core/src/integTest/groovy/org/gradle/api/invocation/GradleLifecycleIsolationIntegrationTest.groovy
index 0eb1cc2b8e7..ce4ab93ff11 100644
--- a/subprojects/core/src/integTest/groovy/org/gradle/api/invocation/GradleLifecycleIsolationIntegrationTest.groovy
+++ b/subprojects/core/src/integTest/groovy/org/gradle/api/invocation/GradleLifecycleIsolationIntegrationTest.groovy
@@ -17,8 +17,8 @@
 package org.gradle.api.invocation
 
 import org.gradle.integtests.fixtures.AbstractIntegrationSpec
-import org.gradle.util.internal.ToBeImplemented
 import org.gradle.internal.code.UserCodeApplicationContext
+import org.gradle.util.internal.ToBeImplemented
 
 class GradleLifecycleIsolationIntegrationTest extends AbstractIntegrationSpec {
 
@@ -170,7 +170,7 @@ class GradleLifecycleIsolationIntegrationTest extends AbstractIntegrationSpec {
         fails("help")
 
         then:
-        failure.assertHasCause("No signature of method: org.gradle.api.Project.printInfo() is applicable for argument types: () values: []")
+        failure.assertHasCause("No signature of method: org.gradle.api.initialization.Settings.printInfo() is applicable for argument types: () values: [")
 
 //        outputContains("project name = root")
 //        outputContains("project name = a")
