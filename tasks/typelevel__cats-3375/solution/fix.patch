diff --git a/core/src/main/scala-2.12/cats/instances/stream.scala b/core/src/main/scala-2.12/cats/instances/stream.scala
index 4bae0aa92..eef109e1c 100644
--- a/core/src/main/scala-2.12/cats/instances/stream.scala
+++ b/core/src/main/scala-2.12/cats/instances/stream.scala
@@ -199,12 +199,16 @@ private[instances] trait StreamInstancesBinCompat0 {
     override def flattenOption[A](fa: Stream[Option[A]]): Stream[A] = fa.flatten
 
     def traverseFilter[G[_], A, B](fa: Stream[A])(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Stream[B]] =
-      fa.foldRight(Eval.now(G.pure(Stream.empty[B])))((x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o)))
+      traverse
+        .foldRight(fa, Eval.now(G.pure(Stream.empty[B])))((x, xse) =>
+          G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ #:: o))
+        )
         .value
 
     override def filterA[G[_], A](fa: Stream[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Stream[A]] =
-      fa.foldRight(Eval.now(G.pure(Stream.empty[A])))((x, xse) =>
-          G.map2Eval(f(x), xse)((b, as) => if (b) x +: as else as)
+      traverse
+        .foldRight(fa, Eval.now(G.pure(Stream.empty[A])))((x, xse) =>
+          G.map2Eval(f(x), xse)((b, stream) => if (b) x #:: stream else stream)
         )
         .value
 
diff --git a/core/src/main/scala-2.13+/cats/instances/lazyList.scala b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
index 31bcd034d..5cd5019ae 100644
--- a/core/src/main/scala-2.13+/cats/instances/lazyList.scala
+++ b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
@@ -170,7 +170,8 @@ trait LazyListInstances extends cats.kernel.instances.LazyListInstances {
         .value
 
     override def filterA[G[_], A](fa: LazyList[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[LazyList[A]] =
-      fa.foldRight(Eval.now(G.pure(LazyList.empty[A])))((x, xse) =>
+      traverse
+        .foldRight(fa, Eval.now(G.pure(LazyList.empty[A])))((x, xse) =>
           G.map2Eval(f(x), xse)((b, as) => if (b) x +: as else as)
         )
         .value
diff --git a/core/src/main/scala-2.13+/cats/instances/stream.scala b/core/src/main/scala-2.13+/cats/instances/stream.scala
index e62f3be8d..14de524ec 100644
--- a/core/src/main/scala-2.13+/cats/instances/stream.scala
+++ b/core/src/main/scala-2.13+/cats/instances/stream.scala
@@ -201,12 +201,16 @@ private[instances] trait StreamInstancesBinCompat0 {
     override def flattenOption[A](fa: Stream[Option[A]]): Stream[A] = fa.flatten
 
     def traverseFilter[G[_], A, B](fa: Stream[A])(f: (A) => G[Option[B]])(implicit G: Applicative[G]): G[Stream[B]] =
-      fa.foldRight(Eval.now(G.pure(Stream.empty[B])))((x, xse) => G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ +: o)))
+      traverse
+        .foldRight(fa, Eval.now(G.pure(Stream.empty[B])))((x, xse) =>
+          G.map2Eval(f(x), xse)((i, o) => i.fold(o)(_ #:: o))
+        )
         .value
 
     override def filterA[G[_], A](fa: Stream[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Stream[A]] =
-      fa.foldRight(Eval.now(G.pure(Stream.empty[A])))((x, xse) =>
-          G.map2Eval(f(x), xse)((b, as) => if (b) x +: as else as)
+      traverse
+        .foldRight(fa, Eval.now(G.pure(Stream.empty[A])))((x, xse) =>
+          G.map2Eval(f(x), xse)((b, stream) => if (b) x #:: stream else stream)
         )
         .value
 
diff --git a/core/src/main/scala/cats/instances/queue.scala b/core/src/main/scala/cats/instances/queue.scala
index 2f229faac..c65efa056 100644
--- a/core/src/main/scala/cats/instances/queue.scala
+++ b/core/src/main/scala/cats/instances/queue.scala
@@ -177,8 +177,9 @@ private object QueueInstances {
         .value
 
     override def filterA[G[_], A](fa: Queue[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Queue[A]] =
-      fa.foldRight(Eval.now(G.pure(Queue.empty[A])))((x, xse) =>
-          G.map2Eval(f(x), xse)((b, vec) => if (b) x +: vec else vec)
+      traverse
+        .foldRight(fa, Eval.now(G.pure(Queue.empty[A])))((x, xse) =>
+          G.map2Eval(f(x), xse)((b, queue) => if (b) x +: queue else queue)
         )
         .value
   }
diff --git a/core/src/main/scala/cats/instances/vector.scala b/core/src/main/scala/cats/instances/vector.scala
index e8730718f..0d65766b5 100644
--- a/core/src/main/scala/cats/instances/vector.scala
+++ b/core/src/main/scala/cats/instances/vector.scala
@@ -179,8 +179,9 @@ private[instances] trait VectorInstancesBinCompat0 {
         .value
 
     override def filterA[G[_], A](fa: Vector[A])(f: (A) => G[Boolean])(implicit G: Applicative[G]): G[Vector[A]] =
-      fa.foldRight(Eval.now(G.pure(Vector.empty[A])))((x, xse) =>
-          G.map2Eval(f(x), xse)((b, vec) => if (b) x +: vec else vec)
+      traverse
+        .foldRight(fa, Eval.now(G.pure(Vector.empty[A])))((x, xse) =>
+          G.map2Eval(f(x), xse)((b, vector) => if (b) x +: vector else vector)
         )
         .value
   }
diff --git a/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala b/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
new file mode 100644
index 000000000..0811d6917
--- /dev/null
+++ b/laws/src/main/scala/cats/laws/ShortCircuitingLaws.scala
@@ -0,0 +1,93 @@
+package cats.laws
+
+import java.util.concurrent.atomic.AtomicLong
+
+import cats.instances.option._
+import cats.syntax.foldable._
+import cats.syntax.traverse._
+import cats.syntax.traverseFilter._
+import cats.{Applicative, Traverse, TraverseFilter}
+
+trait ShortCircuitingLaws[F[_]] {
+
+  def traverseShortCircuits[A](fa: F[A])(implicit F: Traverse[F]): IsEq[Long] = {
+    val size = fa.size
+    val maxInvocationsAllowed = size / 2
+    val f = new RestrictedFunction((i: A) => Some(i), maxInvocationsAllowed, None)
+
+    fa.traverse(f)
+    f.invocations.get <-> (maxInvocationsAllowed + 1).min(size)
+  }
+
+  def traverseWontShortCircuit[A](fa: F[A])(implicit F: Traverse[F]): IsEq[Long] = {
+    val size = fa.size
+    val maxInvocationsAllowed = size / 2
+    val f = new RestrictedFunction((i: A) => Some(i), maxInvocationsAllowed, None)
+
+    fa.traverse(f)(nonShortCircuitingApplicative)
+    f.invocations.get <-> size
+  }
+
+  def traverseFilterShortCircuits[A](fa: F[A])(implicit TF: TraverseFilter[F]): IsEq[Long] = {
+    implicit val F: Traverse[F] = TF.traverse
+
+    val size = fa.size
+    val maxInvocationsAllowed = size / 2
+    val f = new RestrictedFunction((i: A) => Option(Option(i)), maxInvocationsAllowed, None)
+
+    fa.traverseFilter(f)
+    f.invocations.get <-> (maxInvocationsAllowed + 1).min(size)
+  }
+
+  def traverseFilterWontShortCircuit[A](fa: F[A])(implicit TF: TraverseFilter[F]): IsEq[Long] = {
+    implicit val F: Traverse[F] = TF.traverse
+
+    val size = fa.size
+    val maxInvocationsAllowed = size / 2
+    val f = new RestrictedFunction((i: A) => Option(Option(i)), maxInvocationsAllowed, None)
+
+    fa.traverseFilter(f)(nonShortCircuitingApplicative)
+    f.invocations.get <-> size
+  }
+
+  def filterAShortCircuits[A](fa: F[A])(implicit TF: TraverseFilter[F]): IsEq[Long] = {
+    implicit val F: Traverse[F] = TF.traverse
+
+    val size = fa.size
+    val maxInvocationsAllowed = size / 2
+    val f = new RestrictedFunction((_: A) => Some(true), maxInvocationsAllowed, None)
+
+    fa.filterA(f)
+    f.invocations.get <-> (maxInvocationsAllowed + 1).min(size)
+  }
+
+  def filterAWontShortCircuit[A](fa: F[A])(implicit TF: TraverseFilter[F]): IsEq[Long] = {
+    implicit val F: Traverse[F] = TF.traverse
+
+    val size = fa.size
+    val maxInvocationsAllowed = size / 2
+    val f = new RestrictedFunction((_: A) => Some(true), maxInvocationsAllowed, None)
+
+    fa.filterA(f)(nonShortCircuitingApplicative)
+    f.invocations.get <-> size
+  }
+
+  private[this] class RestrictedFunction[-A, +B](f: A => B, maxInvocationsAllowed: Long, empty: => B) extends (A => B) {
+    val invocations = new AtomicLong(0)
+
+    override def apply(v1: A): B =
+      if (invocations.getAndIncrement < maxInvocationsAllowed)
+        f(v1)
+      else
+        empty
+  }
+
+  private[this] val nonShortCircuitingApplicative: Applicative[Option] = new Applicative[Option] {
+    override def pure[A](a: A): Option[A] = Some(a)
+    override def ap[A, B](ff: Option[A => B])(fa: Option[A]): Option[B] = ff.flatMap(f => fa.map(f))
+  }
+}
+
+object ShortCircuitingLaws {
+  def apply[F[_]]: ShortCircuitingLaws[F] = new ShortCircuitingLaws[F] {}
+}
diff --git a/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala b/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
new file mode 100644
index 000000000..412c5d524
--- /dev/null
+++ b/laws/src/main/scala/cats/laws/discipline/ShortCircuitingTests.scala
@@ -0,0 +1,43 @@
+package cats.laws.discipline
+
+import cats.laws.ShortCircuitingLaws
+import cats.{Eq, Traverse, TraverseFilter}
+import org.scalacheck.Arbitrary
+import org.scalacheck.Prop.forAll
+import org.typelevel.discipline.Laws
+
+trait ShortCircuitingTests[F[_]] extends Laws {
+  def laws: ShortCircuitingLaws[F]
+
+  def traverse[A: Arbitrary](implicit F: Traverse[F], ArbFA: Arbitrary[F[A]], lEq: Eq[Long]): RuleSet =
+    new DefaultRuleSet(
+      name = "traverseShortCircuiting",
+      parent = None,
+      "traverse short-circuits if Applicative[G].map2Eval shorts" -> forAll(laws.traverseShortCircuits[A] _),
+      "traverse won't short-circuit if Applicative[G].map2Eval won't" -> forAll(laws.traverseWontShortCircuit[A] _)
+    )
+
+  def traverseFilter[A: Arbitrary](
+    implicit TF: TraverseFilter[F],
+    ArbFA: Arbitrary[F[A]],
+    lEq: Eq[Long]
+  ): RuleSet = {
+    implicit val T: Traverse[F] = TF.traverse
+    new DefaultRuleSet(
+      name = "traverseFilterShortCircuiting",
+      parent = Some(traverse[A]),
+      "traverseFilter short-circuits if Applicative[G].map2Eval shorts" ->
+        forAll(laws.traverseFilterShortCircuits[A] _),
+      "traverseFilter short-circuits if Applicative[G].map2Eval won't" ->
+        forAll(laws.traverseFilterWontShortCircuit[A] _),
+      "filterA short-circuits if Applicative[G].map2Eval shorts" -> forAll(laws.filterAShortCircuits[A] _),
+      "filterA short-circuits if Applicative[G].map2Eval won't" -> forAll(laws.filterAWontShortCircuit[A] _)
+    )
+  }
+}
+
+object ShortCircuitingTests {
+  def apply[F[_]]: ShortCircuitingTests[F] = new ShortCircuitingTests[F] {
+    override def laws: ShortCircuitingLaws[F] = ShortCircuitingLaws[F]
+  }
+}
