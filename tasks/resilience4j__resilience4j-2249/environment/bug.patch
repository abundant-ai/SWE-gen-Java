diff --git a/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java b/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
index 11eea41c..d0e11c89 100644
--- a/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
+++ b/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
@@ -9,7 +9,10 @@ import io.github.resilience4j.core.CallableUtils;
 import io.github.resilience4j.core.CheckedFunctionUtils;
 import io.github.resilience4j.core.CompletionStageUtils;
 import io.github.resilience4j.core.SupplierUtils;
-import io.github.resilience4j.core.functions.*;
+import io.github.resilience4j.core.functions.CheckedBiFunction;
+import io.github.resilience4j.core.functions.CheckedFunction;
+import io.github.resilience4j.core.functions.CheckedRunnable;
+import io.github.resilience4j.core.functions.CheckedSupplier;
 import io.github.resilience4j.micrometer.Timer;
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.retry.Retry;
@@ -73,10 +76,6 @@ public interface Decorators {
         return new DecorateCheckedRunnable(supplier);
     }
 
-    static <T> DecorateCheckedConsumer<T> ofCheckedConsumer(CheckedConsumer<T> consumer) {
-        return new DecorateCheckedConsumer<>(consumer);
-    }
-
     static <T> DecorateCompletionStage<T> ofCompletionStage(
         Supplier<CompletionStage<T>> stageSupplier) {
         return new DecorateCompletionStage<>(stageSupplier);
@@ -551,53 +550,6 @@ public interface Decorators {
         }
     }
 
-    class DecorateCheckedConsumer<T> {
-
-        private CheckedConsumer<T> consumer;
-
-        private DecorateCheckedConsumer(CheckedConsumer<T> consumer) {
-            this.consumer = consumer;
-        }
-
-        public DecorateCheckedConsumer<T> withTimer(Timer timer) {
-            consumer = Timer.decorateCheckedConsumer(timer, consumer);
-            return this;
-        }
-
-        public DecorateCheckedConsumer<T> withCircuitBreaker(CircuitBreaker circuitBreaker) {
-            consumer = CircuitBreaker.decorateCheckedConsumer(circuitBreaker, consumer);
-            return this;
-        }
-
-        public DecorateCheckedConsumer<T> withRetry(Retry retryContext) {
-            consumer = Retry.decorateCheckedConsumer(retryContext, consumer);
-            return this;
-        }
-
-        public DecorateCheckedConsumer<T> withRateLimiter(RateLimiter rateLimiter) {
-            consumer = RateLimiter.decorateCheckedConsumer(rateLimiter, consumer);
-            return this;
-        }
-
-        public DecorateCheckedConsumer<T> withRateLimiter(RateLimiter rateLimiter, int permits) {
-            consumer = RateLimiter.decorateCheckedConsumer(rateLimiter, permits, consumer);
-            return this;
-        }
-
-        public DecorateCheckedConsumer<T> withBulkhead(Bulkhead bulkhead) {
-            consumer = Bulkhead.decorateCheckedConsumer(bulkhead, consumer);
-            return this;
-        }
-
-        public CheckedConsumer<T> decorate() {
-            return consumer;
-        }
-
-        public void accept(T t) throws Throwable {
-            consumer.accept(t);
-        }
-    }
-
     class DecorateCompletionStage<T> {
 
         private Supplier<CompletionStage<T>> stageSupplier;
@@ -695,11 +647,6 @@ public interface Decorators {
             return this;
         }
 
-        public DecorateConsumer<T> withRetry(Retry retryContext) {
-            consumer = Retry.decorateConsumer(retryContext, consumer);
-            return this;
-        }
-
         public DecorateConsumer<T> withRateLimiter(RateLimiter rateLimiter) {
             return withRateLimiter(rateLimiter, 1);
         }
diff --git a/resilience4j-all/src/test/java/io/github/resilience4j/decorators/DecoratorsTest.java b/resilience4j-all/src/test/java/io/github/resilience4j/decorators/DecoratorsTest.java
index 3ad219ee..9d571aa4 100644
--- a/resilience4j-all/src/test/java/io/github/resilience4j/decorators/DecoratorsTest.java
+++ b/resilience4j-all/src/test/java/io/github/resilience4j/decorators/DecoratorsTest.java
@@ -24,7 +24,6 @@ import io.github.resilience4j.bulkhead.ThreadPoolBulkhead;
 import io.github.resilience4j.cache.Cache;
 import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
 import io.github.resilience4j.circuitbreaker.CircuitBreaker;
-import io.github.resilience4j.core.functions.CheckedConsumer;
 import io.github.resilience4j.core.functions.CheckedFunction;
 import io.github.resilience4j.core.functions.CheckedRunnable;
 import io.github.resilience4j.core.functions.CheckedSupplier;
@@ -734,27 +733,6 @@ public class DecoratorsTest {
         assertThat(metrics.getNumberOfSuccessfulCalls()).isEqualTo(1);
     }
 
-    @Test
-    public void testDecorateCheckedConsumer() {
-        given(helloWorldService.returnHelloWorldWithName("Name"))
-            .willReturn("Hello world Name");
-        CircuitBreaker circuitBreaker = CircuitBreaker.ofDefaults("helloBackend");
-        CheckedConsumer<String> decoratedConsumer = Decorators
-            .ofCheckedConsumer(helloWorldService::returnHelloWorldWithName)
-            .withCircuitBreaker(circuitBreaker)
-            .withRetry(Retry.ofDefaults("id"))
-            .withRateLimiter(RateLimiter.ofDefaults("testName"))
-            .withBulkhead(Bulkhead.ofDefaults("testName"))
-            .decorate();
-
-        Try.run(() -> decoratedConsumer.accept("Name"));
-
-        CircuitBreaker.Metrics metrics = circuitBreaker.getMetrics();
-        assertThat(metrics.getNumberOfBufferedCalls()).isEqualTo(1);
-        assertThat(metrics.getNumberOfSuccessfulCalls()).isEqualTo(1);
-        then(helloWorldService).should(times(1)).returnHelloWorldWithName("Name");
-    }
-
     @Test
     public void testDecoratorBuilderWithRetry() {
         given(helloWorldService.returnHelloWorld()).willThrow(new RuntimeException("BAM!"));
diff --git a/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java b/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
index f21893f4..afbaa6c1 100644
--- a/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
+++ b/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
@@ -20,7 +20,10 @@ package io.github.resilience4j.ratelimiter;
 
 import io.github.resilience4j.core.EventConsumer;
 import io.github.resilience4j.core.exception.AcquirePermissionCancelledException;
-import io.github.resilience4j.core.functions.*;
+import io.github.resilience4j.core.functions.CheckedFunction;
+import io.github.resilience4j.core.functions.CheckedRunnable;
+import io.github.resilience4j.core.functions.CheckedSupplier;
+import io.github.resilience4j.core.functions.Either;
 import io.github.resilience4j.ratelimiter.event.RateLimiterEvent;
 import io.github.resilience4j.ratelimiter.event.RateLimiterOnFailureEvent;
 import io.github.resilience4j.ratelimiter.event.RateLimiterOnSuccessEvent;
@@ -306,50 +309,6 @@ public interface RateLimiter {
             .apply(t);
     }
 
-    /**
-     * Creates a consumer which is restricted by a RateLimiter.
-     *
-     * @param rateLimiter the RateLimiter
-     * @param consumer    the original consumer
-     * @param <T>         the type of consumer argument
-     * @return a consumer which is restricted by a RateLimiter.
-     */
-    static <T> CheckedConsumer<T> decorateCheckedConsumer(RateLimiter rateLimiter,
-                                                           CheckedConsumer<T> consumer) {
-        return decorateCheckedConsumer(rateLimiter, 1, consumer);
-    }
-
-    /**
-     * Creates a consumer which is restricted by a RateLimiter.
-     *
-     * @param rateLimiter the RateLimiter
-     * @param permits     number of permits that this call requires
-     * @param consumer    the original consumer
-     * @param <T>         the type of consumer argument
-     * @return a consumer which is restricted by a RateLimiter.
-     */
-    static <T> CheckedConsumer<T> decorateCheckedConsumer(RateLimiter rateLimiter,
-                                                                int permits, CheckedConsumer<T> consumer) {
-        return (T t) -> decorateCheckedRunnable(rateLimiter, permits, () -> consumer.accept(t))
-                .run();
-    }
-
-    /**
-     * Creates a consumer which is restricted by a RateLimiter.
-     *
-     * @param rateLimiter       the RateLimiter
-     * @param permitsCalculator calculates the number of permits required by this call based on the
-     *                          functions argument
-     * @param consumer          the original consumer
-     * @param <T>               the type of consumer argument
-     * @return a consumer which is restricted by a RateLimiter.
-     */
-    static <T> CheckedConsumer<T> decorateCheckedConsumer(RateLimiter rateLimiter,
-                                                                Function<T, Integer> permitsCalculator, CheckedConsumer<T> consumer) {
-        return (T t) -> decorateCheckedConsumer(rateLimiter, permitsCalculator.apply(t), consumer)
-                .accept(t);
-    }
-
     /**
      * Creates a supplier which is restricted by a RateLimiter.
      *
diff --git a/resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java b/resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java
index 09c0fbe3..9a6e953f 100644
--- a/resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java
+++ b/resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java
@@ -19,7 +19,6 @@
 package io.github.resilience4j.retry;
 
 import io.github.resilience4j.core.EventConsumer;
-import io.github.resilience4j.core.functions.CheckedConsumer;
 import io.github.resilience4j.core.functions.CheckedFunction;
 import io.github.resilience4j.core.functions.CheckedRunnable;
 import io.github.resilience4j.core.functions.CheckedSupplier;
@@ -29,7 +28,6 @@ import io.github.resilience4j.retry.internal.RetryImpl;
 import java.util.Collections;
 import java.util.Map;
 import java.util.concurrent.*;
-import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Supplier;
 
@@ -248,43 +246,6 @@ public interface Retry {
         return decorateCheckedFunction(this, function);
     }
 
-    /**
-     * Creates a retryable consumer.
-     *
-     * @param retry    the retry context
-     * @param consumer the original consumer
-     * @param <T>      the type of the input to the consumer
-     * @return a retryable consumer
-     */
-    static <T> CheckedConsumer<T> decorateCheckedConsumer(Retry retry, CheckedConsumer<T> consumer) {
-        return (T t) -> {
-            Retry.Context context = retry.context();
-            do {
-                try {
-                    consumer.accept(t);
-                    final boolean validationOfResult = context.onResult(null);
-                    if (!validationOfResult) {
-                        context.onComplete();
-                        break;
-                    }
-                } catch (Exception exception) {
-                    context.onError(exception);
-                }
-            } while (true);
-        };
-    }
-
-    /**
-     * Creates a retryable consumer using current instance as context.
-     *
-     * @param consumer the original consumer
-     * @param <T>      the type of the input to the consumer
-     * @return a retryable consumer
-     */
-    default <T> CheckedConsumer<T> decorateCheckedConsumer(CheckedConsumer<T> consumer) {
-        return decorateCheckedConsumer(this, consumer);
-    }
-
     /**
      * Creates a retryable supplier.
      *
@@ -422,42 +383,6 @@ public interface Retry {
         };
     }
 
-    /**
-     * Creates a retryable consumer.
-     *
-     * @param retry    the retry context
-     * @param consumer the original consumer
-     * @param <T>      the type of the input to the consumer
-     * @return a retryable consumer
-     */
-    static <T> Consumer<T> decorateConsumer(Retry retry, Consumer<T> consumer) {
-        return (T t) -> {
-            Retry.Context context = retry.context();
-            do {
-                try {
-                    consumer.accept(t);
-                    final boolean validationOfResult = context.onResult(null);
-                    if (!validationOfResult) {
-                        context.onComplete();
-                        break;
-                    }
-                } catch (RuntimeException runtimeException) {
-                    context.onRuntimeError(runtimeException);
-                }
-            } while (true);
-        };
-    }
-
-    /**
-     * Creates a retryable consumer using current instance as context.
-     *
-     * @param consumer the original consumer
-     * @return a retryable consumer
-     */
-    default <T> Consumer<T> decorateConsumer(Consumer<T> consumer) {
-        return decorateConsumer(this, consumer);
-    }
-
     /**
      * Returns the ID of this Retry.
      *
diff --git a/resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java b/resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
index c48cd40c..525f4fd0 100644
--- a/resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
+++ b/resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
@@ -285,11 +285,7 @@ public class RetryImpl<T> implements Retry {
 
             try {
                 sleepFunction.accept(interval);
-            } catch (InterruptedException ex) {
-                Thread.currentThread().interrupt();
-                throw lastRuntimeException.get();
-            }
-            catch (Throwable ex) {
+            } catch (Throwable ex) {
                 throw lastRuntimeException.get();
             }
         }
diff --git a/resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/ConsumerRetryTest.java b/resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/ConsumerRetryTest.java
deleted file mode 100644
index c6c8b42f..00000000
--- a/resilience4j-retry/src/test/java/io/github/resilience4j/retry/internal/ConsumerRetryTest.java
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- *
- *  Copyright 2016 Robert Winkler
- *
- *  Licensed under the Apache License, Version 2.0 (the "License");
- *  you may not use this file except in compliance with the License.
- *  You may obtain a copy of the License at
- *
- *         http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- *
- *
- */
-package io.github.resilience4j.retry.internal;
-
-import io.github.resilience4j.core.IntervalFunction;
-import io.github.resilience4j.core.functions.CheckedConsumer;
-import io.github.resilience4j.retry.MaxRetriesExceededException;
-import io.github.resilience4j.retry.Retry;
-import io.github.resilience4j.retry.RetryConfig;
-import io.github.resilience4j.test.HelloWorldException;
-import io.github.resilience4j.test.HelloWorldService;
-import io.vavr.Predicates;
-import io.vavr.control.Try;
-import org.junit.Before;
-import org.junit.Test;
-
-import java.time.Duration;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Consumer;
-
-import static io.vavr.API.*;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.mockito.BDDMockito.*;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.times;
-
-public class ConsumerRetryTest {
-
-    private HelloWorldService helloWorldService;
-    private long sleptTime = 0L;
-
-    @Before
-    public void setUp() {
-        helloWorldService = mock(HelloWorldService.class);
-        RetryImpl.sleepFunction = sleep -> sleptTime += sleep;
-    }
-
-    @Test
-    public void shouldNotRetry() {
-        Retry retryContext = Retry.ofDefaults("id");
-        Consumer<String> consumer = Retry.decorateConsumer(retryContext, helloWorldService::sayHelloWorldWithName);
-
-        consumer.accept("Name");
-
-        then(helloWorldService).should().sayHelloWorldWithName("Name");
-        assertThat(sleptTime).isZero();
-    }
-
-    @Test
-    public void testDecorateConsumer() {
-        willThrow(new HelloWorldException()).given(helloWorldService).sayHelloWorldWithName("Name");
-        Retry retry = Retry.ofDefaults("id");
-        Consumer<String> consumer = Retry.decorateConsumer(retry, helloWorldService::sayHelloWorldWithName);
-
-        Try<Void> result = Try.run(() -> consumer.accept("Name"));
-
-        then(helloWorldService).should(times(3)).sayHelloWorldWithName("Name");
-        assertThat(result.isFailure()).isTrue();
-        assertThat(result.failed().get()).isInstanceOf(HelloWorldException.class);
-        assertThat(sleptTime).isEqualTo(RetryConfig.DEFAULT_WAIT_DURATION * 2);
-    }
-
-    @Test
-    public void testDecorateConsumerAndInvokeTwice() {
-        doThrow(new HelloWorldException())
-                .doNothing()
-                .doThrow(new HelloWorldException())
-                .doNothing()
-                .when(helloWorldService).sayHelloWorldWithName("Name");
-
-        Retry retry = Retry.ofDefaults("id");
-        Consumer<String> consumer = Retry
-                .decorateConsumer(retry, helloWorldService::sayHelloWorldWithName);
-
-        consumer.accept("Name");
-        consumer.accept("Name");
-
-        then(helloWorldService).should(times(4)).sayHelloWorldWithName("Name");
-        assertThat(sleptTime).isEqualTo(RetryConfig.DEFAULT_WAIT_DURATION * 2);
-        assertThat(retry.getMetrics().getNumberOfSuccessfulCallsWithRetryAttempt()).isEqualTo(2);
-    }
-
-    @Test
-    public void shouldReturnAfterThreeAttempts() throws Throwable {
-        willThrow(new HelloWorldException()).given(helloWorldService).sayHelloWorldWithNameWithException("Name");
-        Retry retry = Retry.ofDefaults("id");
-        CheckedConsumer<String> retryableConsumer = Retry
-            .decorateCheckedConsumer(retry, helloWorldService::sayHelloWorldWithNameWithException);
-
-        Try<Void> result = Try.run(() -> retryableConsumer.accept("Name"));
-
-        then(helloWorldService).should(times(3)).sayHelloWorldWithNameWithException("Name");
-        assertThat(result.isFailure()).isTrue();
-        assertThat(result.failed().get()).isInstanceOf(HelloWorldException.class);
-        assertThat(sleptTime).isEqualTo(RetryConfig.DEFAULT_WAIT_DURATION * 2);
-    }
-
-    @Test
-    public void shouldReturnAfterOneAttempt() {
-        willThrow(new HelloWorldException()).given(helloWorldService).sayHelloWorldWithName("Name");
-        RetryConfig config = RetryConfig.custom().maxAttempts(1).build();
-        Retry retry = Retry.of("id", config);
-        CheckedConsumer<String> retryableConsumer = Retry
-            .decorateCheckedConsumer(retry, helloWorldService::sayHelloWorldWithName);
-
-        Try<Void> result = Try.run(() -> retryableConsumer.accept("Name"));
-
-        then(helloWorldService).should().sayHelloWorldWithName("Name");
-        assertThat(result.isFailure()).isTrue();
-        assertThat(result.failed().get()).isInstanceOf(HelloWorldException.class);
-        assertThat(sleptTime).isZero();
-    }
-
-    @Test
-    public void shouldReturnAfterOneAttemptAndIgnoreException() {
-        willThrow(new HelloWorldException()).given(helloWorldService).sayHelloWorldWithName("Name");
-        RetryConfig config = RetryConfig.custom()
-            .retryOnException(throwable -> Match(throwable).of(
-                Case($(Predicates.instanceOf(HelloWorldException.class)), false),
-                Case($(), true)))
-            .build();
-        Retry retry = Retry.of("id", config);
-        CheckedConsumer<String> retryableConsumer = Retry
-            .decorateCheckedConsumer(retry, helloWorldService::sayHelloWorldWithName);
-
-        Try<Void> result = Try.run(() -> retryableConsumer.accept("Name"));
-
-        // because the exception should be rethrown immediately
-        then(helloWorldService).should().sayHelloWorldWithName("Name");
-        assertThat(result.isFailure()).isTrue();
-        assertThat(result.failed().get()).isInstanceOf(HelloWorldException.class);
-        assertThat(sleptTime).isZero();
-    }
-
-    @Test
-    public void shouldTakeIntoAccountBackoffFunction() {
-        willThrow(new HelloWorldException()).given(helloWorldService).sayHelloWorldWithName("Name");
-        RetryConfig config = RetryConfig
-            .custom()
-            .intervalFunction(IntervalFunction.of(Duration.ofMillis(500), x -> x * x))
-            .build();
-        Retry retry = Retry.of("id", config);
-        CheckedConsumer<String> retryableConsumer = Retry
-            .decorateCheckedConsumer(retry, helloWorldService::sayHelloWorldWithName);
-
-        Try.run(() -> retryableConsumer.accept("Name"));
-
-        then(helloWorldService).should(times(3)).sayHelloWorldWithName("Name");
-        assertThat(sleptTime).isEqualTo(
-            RetryConfig.DEFAULT_WAIT_DURATION +
-                RetryConfig.DEFAULT_WAIT_DURATION * RetryConfig.DEFAULT_WAIT_DURATION);
-    }
-
-    @Test
-    public void shouldTakeIntoAccountRetryOnResult() {
-        AtomicInteger value = new AtomicInteger(0);
-        final int targetValue = 2;
-        RetryConfig config = RetryConfig
-                .custom()
-                .retryOnResult(result -> value.get() != targetValue)
-                .build();
-        Retry retry = Retry.of("shouldTakeIntoAccountRetryOnResult", config);
-        CheckedConsumer<String> retryableConsumer = Retry
-                .decorateCheckedConsumer(retry, (name) -> {
-                    helloWorldService.sayHelloWorldWithName(name);
-                    value.incrementAndGet();
-                });
-
-        Try.run(() -> retryableConsumer.accept("Name"));
-
-        then(helloWorldService).should(times(targetValue)).sayHelloWorldWithName("Name");
-        System.out.println(sleptTime);
-        assertThat(sleptTime).isEqualTo(RetryConfig.DEFAULT_WAIT_DURATION);
-    }
-
-    @Test
-    public void shouldReturnAfterThreeAttemptsAndRecover() throws Throwable{
-
-        willThrow(new HelloWorldException()).given(helloWorldService).sayHelloWorldWithName("Name");
-        doNothing().when(helloWorldService).sayHelloWorldWithName("RecoverName");
-
-        Retry retry = Retry.ofDefaults("id");
-        Consumer<String> retryableConsumer = Retry
-                .decorateConsumer(retry, helloWorldService::sayHelloWorldWithName);
-
-        Try.run(() -> retryableConsumer.accept("Name"))
-                .recover((throwable) -> {
-                    retryableConsumer.accept("RecoverName");
-                    return null;
-                });
-        assertThat(retry.getMetrics().getNumberOfFailedCallsWithRetryAttempt()).isEqualTo(1);
-
-        then(helloWorldService).should(times(3)).sayHelloWorldWithName("Name");
-        then(helloWorldService).should(times(1)).sayHelloWorldWithName("RecoverName");
-        assertThat(sleptTime).isEqualTo(RetryConfig.DEFAULT_WAIT_DURATION * 2);
-    }
-
-    @Test
-    public void shouldMarkThreadInterruptedWhenInterruptedDuringRetry() {
-        RetryImpl.sleepFunction = sleep -> {
-            throw new InterruptedException("Interrpted!");
-        };
-        willThrow(new HelloWorldException()).given(helloWorldService).sayHelloWorldWithName("Name");
-        Retry retry = Retry.ofDefaults("id");
-        Consumer<String> retryableConsumer = Retry
-                .decorateConsumer(retry, helloWorldService::sayHelloWorldWithName);
-
-        Try.run(() -> retryableConsumer.accept("Name"))
-                .recover((throwable) ->{
-                    retryableConsumer.accept("RecoverName");
-                    return null;
-                });
-        assertThat(Thread.currentThread().isInterrupted()).isTrue();
-        Thread.interrupted();
-    }
-
-    @Test
-    public void shouldThrowMaxRetriesExceededIfConfigured() {
-        doNothing().when(helloWorldService).sayHelloWorldWithName("Name");
-
-        RetryConfig retryConfig = RetryConfig.custom()
-                .retryOnResult(s -> true)
-                .maxAttempts(3)
-                .failAfterMaxAttempts(true)
-                .build();
-        Retry retry = Retry.of("test", retryConfig);
-        Consumer<String> consumer = Retry
-                .decorateConsumer(retry, helloWorldService::sayHelloWorldWithName);
-
-        assertThatThrownBy(() -> consumer.accept("Name"))
-                .isInstanceOf(MaxRetriesExceededException.class)
-                .hasMessage("Retry 'test' has exhausted all attempts (3)");
-
-        then(helloWorldService).should(times(3)).sayHelloWorldWithName("Name");
-    }
-
-    @Test
-    public void shouldNotThrowMaxRetriesExceededIfCompletedExceptionally() {
-
-        willThrow(new HelloWorldException()).given(helloWorldService).sayHelloWorldWithName("Name");
-
-        RetryConfig retryConfig = RetryConfig.<String>custom()
-                .retryOnException(HelloWorldException.class::isInstance)
-                .maxAttempts(3)
-                .failAfterMaxAttempts(true)
-                .build();
-        Retry retry = Retry.of("test", retryConfig);
-        Consumer<String> consumer = Retry
-                .decorateConsumer(retry, helloWorldService::sayHelloWorldWithName);
-
-        assertThatThrownBy(() -> consumer.accept("Name"))
-                .isInstanceOf(HelloWorldException.class)
-                .hasMessage("BAM!");
-
-        then(helloWorldService).should(times(3)).sayHelloWorldWithName("Name");
-    }
-}
