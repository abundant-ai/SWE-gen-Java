diff --git a/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java b/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
index d0e11c89..11eea41c 100644
--- a/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
+++ b/resilience4j-all/src/main/java/io/github/resilience4j/decorators/Decorators.java
@@ -9,10 +9,7 @@ import io.github.resilience4j.core.CallableUtils;
 import io.github.resilience4j.core.CheckedFunctionUtils;
 import io.github.resilience4j.core.CompletionStageUtils;
 import io.github.resilience4j.core.SupplierUtils;
-import io.github.resilience4j.core.functions.CheckedBiFunction;
-import io.github.resilience4j.core.functions.CheckedFunction;
-import io.github.resilience4j.core.functions.CheckedRunnable;
-import io.github.resilience4j.core.functions.CheckedSupplier;
+import io.github.resilience4j.core.functions.*;
 import io.github.resilience4j.micrometer.Timer;
 import io.github.resilience4j.ratelimiter.RateLimiter;
 import io.github.resilience4j.retry.Retry;
@@ -76,6 +73,10 @@ public interface Decorators {
         return new DecorateCheckedRunnable(supplier);
     }
 
+    static <T> DecorateCheckedConsumer<T> ofCheckedConsumer(CheckedConsumer<T> consumer) {
+        return new DecorateCheckedConsumer<>(consumer);
+    }
+
     static <T> DecorateCompletionStage<T> ofCompletionStage(
         Supplier<CompletionStage<T>> stageSupplier) {
         return new DecorateCompletionStage<>(stageSupplier);
@@ -550,6 +551,53 @@ public interface Decorators {
         }
     }
 
+    class DecorateCheckedConsumer<T> {
+
+        private CheckedConsumer<T> consumer;
+
+        private DecorateCheckedConsumer(CheckedConsumer<T> consumer) {
+            this.consumer = consumer;
+        }
+
+        public DecorateCheckedConsumer<T> withTimer(Timer timer) {
+            consumer = Timer.decorateCheckedConsumer(timer, consumer);
+            return this;
+        }
+
+        public DecorateCheckedConsumer<T> withCircuitBreaker(CircuitBreaker circuitBreaker) {
+            consumer = CircuitBreaker.decorateCheckedConsumer(circuitBreaker, consumer);
+            return this;
+        }
+
+        public DecorateCheckedConsumer<T> withRetry(Retry retryContext) {
+            consumer = Retry.decorateCheckedConsumer(retryContext, consumer);
+            return this;
+        }
+
+        public DecorateCheckedConsumer<T> withRateLimiter(RateLimiter rateLimiter) {
+            consumer = RateLimiter.decorateCheckedConsumer(rateLimiter, consumer);
+            return this;
+        }
+
+        public DecorateCheckedConsumer<T> withRateLimiter(RateLimiter rateLimiter, int permits) {
+            consumer = RateLimiter.decorateCheckedConsumer(rateLimiter, permits, consumer);
+            return this;
+        }
+
+        public DecorateCheckedConsumer<T> withBulkhead(Bulkhead bulkhead) {
+            consumer = Bulkhead.decorateCheckedConsumer(bulkhead, consumer);
+            return this;
+        }
+
+        public CheckedConsumer<T> decorate() {
+            return consumer;
+        }
+
+        public void accept(T t) throws Throwable {
+            consumer.accept(t);
+        }
+    }
+
     class DecorateCompletionStage<T> {
 
         private Supplier<CompletionStage<T>> stageSupplier;
@@ -647,6 +695,11 @@ public interface Decorators {
             return this;
         }
 
+        public DecorateConsumer<T> withRetry(Retry retryContext) {
+            consumer = Retry.decorateConsumer(retryContext, consumer);
+            return this;
+        }
+
         public DecorateConsumer<T> withRateLimiter(RateLimiter rateLimiter) {
             return withRateLimiter(rateLimiter, 1);
         }
diff --git a/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java b/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
index afbaa6c1..f21893f4 100644
--- a/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
+++ b/resilience4j-ratelimiter/src/main/java/io/github/resilience4j/ratelimiter/RateLimiter.java
@@ -20,10 +20,7 @@ package io.github.resilience4j.ratelimiter;
 
 import io.github.resilience4j.core.EventConsumer;
 import io.github.resilience4j.core.exception.AcquirePermissionCancelledException;
-import io.github.resilience4j.core.functions.CheckedFunction;
-import io.github.resilience4j.core.functions.CheckedRunnable;
-import io.github.resilience4j.core.functions.CheckedSupplier;
-import io.github.resilience4j.core.functions.Either;
+import io.github.resilience4j.core.functions.*;
 import io.github.resilience4j.ratelimiter.event.RateLimiterEvent;
 import io.github.resilience4j.ratelimiter.event.RateLimiterOnFailureEvent;
 import io.github.resilience4j.ratelimiter.event.RateLimiterOnSuccessEvent;
@@ -309,6 +306,50 @@ public interface RateLimiter {
             .apply(t);
     }
 
+    /**
+     * Creates a consumer which is restricted by a RateLimiter.
+     *
+     * @param rateLimiter the RateLimiter
+     * @param consumer    the original consumer
+     * @param <T>         the type of consumer argument
+     * @return a consumer which is restricted by a RateLimiter.
+     */
+    static <T> CheckedConsumer<T> decorateCheckedConsumer(RateLimiter rateLimiter,
+                                                           CheckedConsumer<T> consumer) {
+        return decorateCheckedConsumer(rateLimiter, 1, consumer);
+    }
+
+    /**
+     * Creates a consumer which is restricted by a RateLimiter.
+     *
+     * @param rateLimiter the RateLimiter
+     * @param permits     number of permits that this call requires
+     * @param consumer    the original consumer
+     * @param <T>         the type of consumer argument
+     * @return a consumer which is restricted by a RateLimiter.
+     */
+    static <T> CheckedConsumer<T> decorateCheckedConsumer(RateLimiter rateLimiter,
+                                                                int permits, CheckedConsumer<T> consumer) {
+        return (T t) -> decorateCheckedRunnable(rateLimiter, permits, () -> consumer.accept(t))
+                .run();
+    }
+
+    /**
+     * Creates a consumer which is restricted by a RateLimiter.
+     *
+     * @param rateLimiter       the RateLimiter
+     * @param permitsCalculator calculates the number of permits required by this call based on the
+     *                          functions argument
+     * @param consumer          the original consumer
+     * @param <T>               the type of consumer argument
+     * @return a consumer which is restricted by a RateLimiter.
+     */
+    static <T> CheckedConsumer<T> decorateCheckedConsumer(RateLimiter rateLimiter,
+                                                                Function<T, Integer> permitsCalculator, CheckedConsumer<T> consumer) {
+        return (T t) -> decorateCheckedConsumer(rateLimiter, permitsCalculator.apply(t), consumer)
+                .accept(t);
+    }
+
     /**
      * Creates a supplier which is restricted by a RateLimiter.
      *
diff --git a/resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java b/resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java
index 9a6e953f..09c0fbe3 100644
--- a/resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java
+++ b/resilience4j-retry/src/main/java/io/github/resilience4j/retry/Retry.java
@@ -19,6 +19,7 @@
 package io.github.resilience4j.retry;
 
 import io.github.resilience4j.core.EventConsumer;
+import io.github.resilience4j.core.functions.CheckedConsumer;
 import io.github.resilience4j.core.functions.CheckedFunction;
 import io.github.resilience4j.core.functions.CheckedRunnable;
 import io.github.resilience4j.core.functions.CheckedSupplier;
@@ -28,6 +29,7 @@ import io.github.resilience4j.retry.internal.RetryImpl;
 import java.util.Collections;
 import java.util.Map;
 import java.util.concurrent.*;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.Supplier;
 
@@ -246,6 +248,43 @@ public interface Retry {
         return decorateCheckedFunction(this, function);
     }
 
+    /**
+     * Creates a retryable consumer.
+     *
+     * @param retry    the retry context
+     * @param consumer the original consumer
+     * @param <T>      the type of the input to the consumer
+     * @return a retryable consumer
+     */
+    static <T> CheckedConsumer<T> decorateCheckedConsumer(Retry retry, CheckedConsumer<T> consumer) {
+        return (T t) -> {
+            Retry.Context context = retry.context();
+            do {
+                try {
+                    consumer.accept(t);
+                    final boolean validationOfResult = context.onResult(null);
+                    if (!validationOfResult) {
+                        context.onComplete();
+                        break;
+                    }
+                } catch (Exception exception) {
+                    context.onError(exception);
+                }
+            } while (true);
+        };
+    }
+
+    /**
+     * Creates a retryable consumer using current instance as context.
+     *
+     * @param consumer the original consumer
+     * @param <T>      the type of the input to the consumer
+     * @return a retryable consumer
+     */
+    default <T> CheckedConsumer<T> decorateCheckedConsumer(CheckedConsumer<T> consumer) {
+        return decorateCheckedConsumer(this, consumer);
+    }
+
     /**
      * Creates a retryable supplier.
      *
@@ -383,6 +422,42 @@ public interface Retry {
         };
     }
 
+    /**
+     * Creates a retryable consumer.
+     *
+     * @param retry    the retry context
+     * @param consumer the original consumer
+     * @param <T>      the type of the input to the consumer
+     * @return a retryable consumer
+     */
+    static <T> Consumer<T> decorateConsumer(Retry retry, Consumer<T> consumer) {
+        return (T t) -> {
+            Retry.Context context = retry.context();
+            do {
+                try {
+                    consumer.accept(t);
+                    final boolean validationOfResult = context.onResult(null);
+                    if (!validationOfResult) {
+                        context.onComplete();
+                        break;
+                    }
+                } catch (RuntimeException runtimeException) {
+                    context.onRuntimeError(runtimeException);
+                }
+            } while (true);
+        };
+    }
+
+    /**
+     * Creates a retryable consumer using current instance as context.
+     *
+     * @param consumer the original consumer
+     * @return a retryable consumer
+     */
+    default <T> Consumer<T> decorateConsumer(Consumer<T> consumer) {
+        return decorateConsumer(this, consumer);
+    }
+
     /**
      * Returns the ID of this Retry.
      *
diff --git a/resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java b/resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
index 525f4fd0..c48cd40c 100644
--- a/resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
+++ b/resilience4j-retry/src/main/java/io/github/resilience4j/retry/internal/RetryImpl.java
@@ -285,7 +285,11 @@ public class RetryImpl<T> implements Retry {
 
             try {
                 sleepFunction.accept(interval);
-            } catch (Throwable ex) {
+            } catch (InterruptedException ex) {
+                Thread.currentThread().interrupt();
+                throw lastRuntimeException.get();
+            }
+            catch (Throwable ex) {
                 throw lastRuntimeException.get();
             }
         }
