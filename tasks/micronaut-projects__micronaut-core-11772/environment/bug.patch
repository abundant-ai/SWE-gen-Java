diff --git a/http/src/main/java/io/micronaut/http/filter/AsyncFilter.java b/http/src/main/java/io/micronaut/http/filter/AsyncFilter.java
deleted file mode 100644
index 28031085a3..0000000000
--- a/http/src/main/java/io/micronaut/http/filter/AsyncFilter.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright 2017-2023 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.filter;
-
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.execution.ExecutionFlow;
-import io.micronaut.http.HttpRequest;
-
-import java.util.concurrent.Executor;
-import java.util.function.Function;
-
-/**
- * Wrapper around a filter that signifies the filter should be run asynchronously on the given
- * executor. Usually from an {@link io.micronaut.scheduling.annotation.ExecuteOn} annotation.
- *
- * @param actual   Actual filter
- * @param executor Executor to run the filter on
- * @author Jonas Konrad
- * @author Denis Stepanov
- * @since 4.2.0
- */
-@Internal
-record AsyncFilter(InternalHttpFilter actual, Executor executor) implements InternalHttpFilter {
-
-    @Override
-    public boolean isEnabled(HttpRequest<?> request) {
-        return actual.isEnabled(request);
-    }
-
-    @Override
-    public boolean isFiltersRequest() {
-        return actual.isFiltersRequest();
-    }
-
-    @Override
-    public boolean isFiltersResponse() {
-        return actual.isFiltersResponse();
-    }
-
-    @Override
-    public boolean hasContinuation() {
-        return actual.hasContinuation();
-    }
-
-    @Override
-    public ExecutionFlow<FilterContext> processRequestFilter(FilterContext context) {
-        if (isFiltersRequest()) {
-            return ExecutionFlow.async(executor, () -> actual.processRequestFilter(context));
-        }
-        return InternalHttpFilter.super.processRequestFilter(context);
-    }
-
-    @Override
-    public ExecutionFlow<FilterContext> processRequestFilter(FilterContext context,
-                                                             Function<FilterContext, ExecutionFlow<FilterContext>> downstream) {
-        if (isFiltersRequest()) {
-            return ExecutionFlow.async(executor, () -> actual.processRequestFilter(context, downstream));
-        }
-        return InternalHttpFilter.super.processRequestFilter(context, downstream);
-    }
-
-    @Override
-    public ExecutionFlow<FilterContext> processResponseFilter(FilterContext context, Throwable exceptionToFilter) {
-        if (isFiltersResponse()) {
-            return ExecutionFlow.async(executor, () -> actual.processResponseFilter(context, exceptionToFilter));
-        }
-        return InternalHttpFilter.super.processResponseFilter(context, exceptionToFilter);
-    }
-
-    @Override
-    public int getOrder() {
-        return actual.getOrder();
-    }
-}
diff --git a/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java b/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java
index ebe21f7e42..b0c11c2560 100644
--- a/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java
+++ b/http/src/main/java/io/micronaut/http/filter/BaseFilterProcessor.java
@@ -123,21 +123,21 @@ public abstract class BaseFilterProcessor<A extends Annotation> implements Execu
             if (method.isAnnotationPresent(RequestFilter.class)) {
                 FilterMetadata methodLevel = metadata(method, RequestFilter.class);
                 FilterMetadata combined = combineMetadata(beanLevel, methodLevel);
-                addFilter(() -> withAsync(combined, MethodFilter.prepareFilterMethod(beanContext.getConversionService(), beanContext.getBean(beanDefinition), method, false, combined.order, argumentBinderRegistry)), method, combined);
+                addFilter(() -> MethodFilter.prepareFilterMethod(beanContext.getConversionService(), beanContext.getBean(beanDefinition), method, false, combined.order, argumentBinderRegistry, getExecutor(combined)), method, combined);
             }
             if (method.isAnnotationPresent(ResponseFilter.class)) {
                 FilterMetadata methodLevel = metadata(method, ResponseFilter.class);
                 FilterMetadata combined = combineMetadata(beanLevel, methodLevel);
-                addFilter(() -> withAsync(combined, MethodFilter.prepareFilterMethod(beanContext.getConversionService(), beanContext.getBean(beanDefinition), method, true, combined.order, argumentBinderRegistry)), method, combined);
+                addFilter(() -> MethodFilter.prepareFilterMethod(beanContext.getConversionService(), beanContext.getBean(beanDefinition), method, true, combined.order, argumentBinderRegistry, getExecutor(combined)), method, combined);
             }
         }
     }
 
-    private GenericHttpFilter withAsync(FilterMetadata metadata, GenericHttpFilter filter) {
+    private Executor getExecutor(FilterMetadata metadata) {
         if (metadata.executeOn != null) {
-            return new AsyncFilter((InternalHttpFilter) filter, beanContext.getBean(Executor.class, Qualifiers.byName(metadata.executeOn)));
+            return beanContext.getBean(Executor.class, Qualifiers.byName(metadata.executeOn));
         } else {
-            return filter;
+            return null;
         }
     }
 
diff --git a/http/src/main/java/io/micronaut/http/filter/InternalHttpFilter.java b/http/src/main/java/io/micronaut/http/filter/InternalHttpFilter.java
index b8e5ba5545..e66b03eefc 100644
--- a/http/src/main/java/io/micronaut/http/filter/InternalHttpFilter.java
+++ b/http/src/main/java/io/micronaut/http/filter/InternalHttpFilter.java
@@ -32,7 +32,7 @@ import java.util.function.Function;
  * @since 4.2.0
  */
 @Internal
-sealed interface InternalHttpFilter extends GenericHttpFilter, Ordered permits AroundLegacyFilter, AsyncFilter, FilterRunner.RouteMatchResolverHttpFilter, MethodFilter {
+sealed interface InternalHttpFilter extends GenericHttpFilter, Ordered permits AroundLegacyFilter, FilterRunner.RouteMatchResolverHttpFilter, MethodFilter {
 
     /**
      * Checks the filter is implementing {@link ConditionalFilter} and is enabled.
diff --git a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
index b19fd10b13..b88ebcbd25 100644
--- a/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
+++ b/http/src/main/java/io/micronaut/http/filter/MethodFilter.java
@@ -50,12 +50,14 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.concurrent.CompletionStage;
 import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
 import java.util.function.Function;
 import java.util.function.Predicate;
 
 /**
  * Internal implementation of {@link io.micronaut.http.annotation.ServerFilter}.
  *
+ * @param <T>                 The bean type
  * @param order               The order
  * @param bean                The bean instance
  * @param method              The method
@@ -68,7 +70,7 @@ import java.util.function.Predicate;
  * @param filtersException    The filter exception
  * @param returnHandler       The return handler
  * @param isConditional       Is conditional filter
- * @param <T>                 The bean type
+ * @param executor            The executor to run this filter on
  * @author Jonas Konrad
  * @author Denis Stepanov
  * @since 4.2.0
@@ -89,8 +91,8 @@ record MethodFilter<T>(FilterOrder order,
                        ContinuationCreator continuationCreator,
                        boolean filtersException,
                        FilterReturnHandler returnHandler,
-                       boolean isConditional
-) implements InternalHttpFilter {
+                       boolean isConditional,
+                       Executor executor) implements InternalHttpFilter {
 
     private static final Predicate<FilterMethodContext> FILTER_CONDITION_ALWAYS_TRUE = runner -> true;
 
@@ -99,8 +101,9 @@ record MethodFilter<T>(FilterOrder order,
                                                    ExecutableMethod<T, ?> method,
                                                    boolean isResponseFilter,
                                                    FilterOrder order,
-                                                   RequestBinderRegistry argumentBinderRegistry) throws IllegalArgumentException {
-        return prepareFilterMethod(conversionService, bean, method, method.getArguments(), method.getReturnType().asArgument(), isResponseFilter, order, argumentBinderRegistry);
+                                                   RequestBinderRegistry argumentBinderRegistry,
+                                                   @Nullable Executor executor) throws IllegalArgumentException {
+        return prepareFilterMethod(conversionService, bean, method, method.getArguments(), method.getReturnType().asArgument(), isResponseFilter, order, argumentBinderRegistry, executor);
     }
 
     static <T> MethodFilter<T> prepareFilterMethod(ConversionService conversionService,
@@ -110,7 +113,8 @@ record MethodFilter<T>(FilterOrder order,
                                                    Argument<?> returnType,
                                                    boolean isResponseFilter,
                                                    FilterOrder order,
-                                                   RequestBinderRegistry argumentBinderRegistry) throws IllegalArgumentException {
+                                                   RequestBinderRegistry argumentBinderRegistry,
+                                                   @Nullable Executor executor) throws IllegalArgumentException {
 
         FilterArgBinder[] fulfilled = new FilterArgBinder[arguments.length];
         AsyncFilterArgBinder[] asyncArgBinders = null;
@@ -228,7 +232,8 @@ record MethodFilter<T>(FilterOrder order,
             continuationCreator,
             filtersException,
             returnHandler,
-            bean instanceof ConditionalFilter
+            bean instanceof ConditionalFilter,
+            executor
         );
     }
 
@@ -284,7 +289,7 @@ record MethodFilter<T>(FilterOrder order,
             context.response(),
             null,
             null);
-        return filter(context, filterMethodContext);
+        return filter(context, filterMethodContext, null, false);
     }
 
     @Override
@@ -300,7 +305,7 @@ record MethodFilter<T>(FilterOrder order,
             context.response(),
             null,
             createContinuation(downstream, context, mutablePropagatedContext));
-        return filter(context, filterMethodContext);
+        return filter(context, filterMethodContext, null, false);
     }
 
     @Override
@@ -317,7 +322,7 @@ record MethodFilter<T>(FilterOrder order,
             context.response(),
             exceptionToFilter,
             null);
-        return filter(context, filterMethodContext);
+        return filter(context, filterMethodContext, null, false);
     }
 
     @Override
@@ -331,30 +336,35 @@ record MethodFilter<T>(FilterOrder order,
         return continuationCreator.create(downstream, filterContext, mutablePropagatedContext);
     }
 
-    private ExecutionFlow<FilterContext> filter(FilterContext filterContext,
-                                                FilterMethodContext methodContext) {
+    private ExecutionFlow<FilterContext> filter(
+        FilterContext filterContext,
+        FilterMethodContext methodContext,
+        Object[] args,
+        boolean onExecutor
+    ) {
+        // this is intentionally one method instead of three nested ones to reduce stacktrace depth
+        // and avoid unnecessary propagate calls
+
         try (PropagatedContext.Scope ignore = filterContext.propagatedContext().propagate()) {
-            if (filterCondition != null && !filterCondition.test(methodContext)) {
-                return ExecutionFlow.just(filterContext);
-            }
-            if (asyncArgBinders != null) {
-                return bindArgsAsync(methodContext).flatMap(args -> filter0(filterContext, methodContext, args));
-            } else {
-                Object[] args;
-                try {
-                    args = bindArgsSync(methodContext);
-                } catch (Throwable e) {
-                    return ExecutionFlow.error(e);
+            if (args == null) {
+                if (filterCondition != null && !filterCondition.test(methodContext)) {
+                    return ExecutionFlow.just(filterContext);
+                }
+                if (asyncArgBinders != null) {
+                    return bindArgsAsync(methodContext).flatMap(a -> filter(filterContext, methodContext, a, onExecutor));
+                } else {
+                    try {
+                        args = bindArgsSync(methodContext);
+                    } catch (Throwable e) {
+                        return ExecutionFlow.error(e);
+                    }
                 }
-                return filter0(filterContext, methodContext, args);
             }
-        } catch (Throwable e) {
-            return ExecutionFlow.error(e);
-        }
-    }
+            if (!onExecutor && executor != null) {
+                Object[] finalArgs = args;
+                return ExecutionFlow.async(executor, () -> filter(filterContext, methodContext, finalArgs, true));
+            }
 
-    private ExecutionFlow<FilterContext> filter0(FilterContext filterContext, FilterMethodContext methodContext, Object[] args) {
-        try {
             Object returnValue;
             if (unsafeExecutable != null) {
                 returnValue = unsafeExecutable.invokeUnsafe(bean, args);
diff --git a/http/src/test/groovy/io/micronaut/http/filter/FilterRunnerSpec.groovy b/http/src/test/groovy/io/micronaut/http/filter/FilterRunnerSpec.groovy
index 771f4d8959..64a672951d 100644
--- a/http/src/test/groovy/io/micronaut/http/filter/FilterRunnerSpec.groovy
+++ b/http/src/test/groovy/io/micronaut/http/filter/FilterRunnerSpec.groovy
@@ -22,8 +22,6 @@ import spock.lang.Specification
 import java.lang.reflect.Method
 import java.util.concurrent.CompletableFuture
 import java.util.concurrent.ExecutionException
-import java.util.concurrent.Executors
-import java.util.concurrent.ThreadFactory
 import java.util.function.Supplier
 
 class FilterRunnerSpec extends Specification {
@@ -575,61 +573,6 @@ class FilterRunnerSpec extends Specification {
         events == ["terminal"]
     }
 
-    def 'async filter'() {
-        given:
-        def events = []
-        List<GenericHttpFilter> filters = [
-                before(ReturnType.of(void)) {
-                    events.add("before1 " + Thread.currentThread().name)
-                    null
-                },
-                new AsyncFilter(before(ReturnType.of(void)) {
-                    events.add("before2 " + Thread.currentThread().name)
-                    null
-                }, Executors.newCachedThreadPool(new ThreadFactory() {
-                    @Override
-                    Thread newThread(Runnable r) {
-                        return new Thread(r, "thread-before")
-                    }
-                })),
-                before(ReturnType.of(void)) {
-                    events.add("before3 " + Thread.currentThread().name)
-                    null
-                },
-                after(ReturnType.of(void)) {
-                    events.add("after1 " + Thread.currentThread().name)
-                    null
-                },
-                new AsyncFilter(after(ReturnType.of(void)) {
-                    events.add("after2 " + Thread.currentThread().name)
-                    null
-                }, Executors.newCachedThreadPool(new ThreadFactory() {
-                    @Override
-                    Thread newThread(Runnable r) {
-                        return new Thread(r, "thread-after")
-                    }
-                })),
-                after(ReturnType.of(void)) {
-                    events.add("after3 " + Thread.currentThread().name)
-                    null
-                }
-        ]
-
-        when:
-        def response = await(ExecutionFlow.async(Executors.newCachedThreadPool(new ThreadFactory() {
-            @Override
-            Thread newThread(Runnable r) {
-                return new Thread(r, "thread-outside")
-            }
-        }), () -> filterRunner(filters, {
-            events.add("terminal " + Thread.currentThread().name)
-            ExecutionFlow.just(HttpResponse.ok())
-        }).run(HttpRequest.GET("/")))).value
-        then:
-        response.status() == HttpStatus.OK
-        events == ["before1 thread-outside", "before2 thread-before", "before3 thread-before", "terminal thread-before", "after3 thread-before", "after2 thread-after", "after1 thread-after"]
-    }
-
     def 'around filter with blocking continuation'() {
         given:
         def events = []
@@ -659,11 +602,11 @@ class FilterRunnerSpec extends Specification {
     }
 
     private def after(ReturnType returnType, List<Argument> arguments = closure.parameterTypes.collect { Argument.of(it) }, Closure<?> closure) {
-        return MethodFilter.prepareFilterMethod(ConversionService.SHARED, null, new LambdaExecutable(closure, arguments.toArray(new Argument[0]), returnType), true, new FilterOrder.Fixed(0), new DefaultRequestBinderRegistry(ConversionService.SHARED))
+        return MethodFilter.prepareFilterMethod(ConversionService.SHARED, null, new LambdaExecutable(closure, arguments.toArray(new Argument[0]), returnType), true, new FilterOrder.Fixed(0), new DefaultRequestBinderRegistry(ConversionService.SHARED), null)
     }
 
     private def before(ReturnType returnType, List<Argument> arguments = closure.parameterTypes.collect { Argument.of(it) }, Closure<?> closure) {
-        return MethodFilter.prepareFilterMethod(ConversionService.SHARED, null, new LambdaExecutable(closure, arguments.toArray(new Argument[0]), returnType), false, new FilterOrder.Fixed(0), new DefaultRequestBinderRegistry(ConversionService.SHARED))
+        return MethodFilter.prepareFilterMethod(ConversionService.SHARED, null, new LambdaExecutable(closure, arguments.toArray(new Argument[0]), returnType), false, new FilterOrder.Fixed(0), new DefaultRequestBinderRegistry(ConversionService.SHARED), null)
     }
 
     private def around(boolean legacy, Closure<Publisher<MutableHttpResponse<?>>> closure) {
diff --git a/inject/custom-config/bootstrap.yml b/inject/custom-config/bootstrap.yml
deleted file mode 100644
index b4d95d8c98..0000000000
--- a/inject/custom-config/bootstrap.yml
+++ /dev/null
@@ -1,17 +0,0 @@
-#
-# Copyright 2017-2025 original authors
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# https://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
-custom-bootstrap-value: test
diff --git a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
index 3648cc7706..bbd5b5f0fb 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
@@ -832,12 +832,6 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
                 public ClassPathResourceLoader getResourceLoader() {
                     return resourceLoader;
                 }
-
-                @Nullable
-                @Override
-                public List<String> getOverrideConfigLocations() {
-                    return configuration.getOverrideConfigLocations();
-                }
             });
         }
 
diff --git a/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java b/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java
index ad7b72af14..741c3f7e6d 100644
--- a/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java
+++ b/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java
@@ -169,9 +169,8 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         if (!environments.isEmpty()) {
             log.info("Established active environments: {}", environments);
         }
-        List<String> configLocations = configuration.getOverrideConfigLocations() == null
-            ? new ArrayList<>(DEFAULT_CONFIG_LOCATIONS)
-            : new ArrayList<>(configuration.getOverrideConfigLocations());
+        List<String> configLocations = configuration.getOverrideConfigLocations() == null ?
+                new ArrayList<>(DEFAULT_CONFIG_LOCATIONS) : configuration.getOverrideConfigLocations();
         // Search config locations in reverse order
         Collections.reverse(configLocations);
         this.configLocations = configLocations;
diff --git a/inject/src/test/groovy/io/micronaut/context/env/DefaultEnvironmentSpec.groovy b/inject/src/test/groovy/io/micronaut/context/env/DefaultEnvironmentSpec.groovy
index e60e82a682..d8fe8a6e96 100644
--- a/inject/src/test/groovy/io/micronaut/context/env/DefaultEnvironmentSpec.groovy
+++ b/inject/src/test/groovy/io/micronaut/context/env/DefaultEnvironmentSpec.groovy
@@ -67,7 +67,6 @@ class DefaultEnvironmentSpec extends Specification {
         env.getProperty("test.foo", Map.class).get() == [bar: "10", baz: "20"]
     }
 
-    @RestoreSystemProperties
     void "test environment refresh and diff"() {
         given:
         System.setProperty(Environment.BOOTSTRAP_CONTEXT_PROPERTY, StringUtils.TRUE)
@@ -516,24 +515,6 @@ class DefaultEnvironmentSpec extends Specification {
             applicationContext.stop()
     }
 
-    @RestoreSystemProperties
-    void "test custom config locations used in bootstrap environment"() {
-        given:
-        System.setProperty(Environment.BOOTSTRAP_CONTEXT_PROPERTY, StringUtils.TRUE)
-
-        when:
-        ApplicationContext applicationContext = ApplicationContext.builder()
-                .overrideConfigLocations("file:./custom-config/")
-                .build()
-                .start()
-
-        then:
-        applicationContext.getRequiredProperty("custom-bootstrap-value", String.class) == "test"
-
-        cleanup:
-        applicationContext.stop()
-    }
-
     void "test custom config locations respect environment order"() {
         when:
             ApplicationContext applicationContext = ApplicationContext.builder()
