diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 554f5ea7a..2dd6b6e95 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,7 +1,7 @@
 [versions]
 agp = "8.13.0"
 biz-aQute-bnd = "7.1.0"
-checkStyle = "12.1.0"
+checkStyle = "12.0.1"
 com-squareup-moshi = "1.15.2"
 com-squareup-okio = "3.16.2"
 de-mannodermaus-junit5 = "1.9.0"
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt
index b9474540d..a4c6217d1 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt
@@ -82,15 +82,6 @@ class Request internal constructor(
       ),
   )
 
-  init {
-    val connectionHeader = headers["Connection"]
-    if ("upgrade".equals(connectionHeader, ignoreCase = true)) {
-      require(body == null || body.contentLength() == 0L) {
-        "expected a null or empty request body with 'Connection: upgrade'"
-      }
-    }
-  }
-
   fun header(name: String): String? = headers[name]
 
   fun headers(name: String): List<String> = headers.values(name)
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt
index 4484ca66e..64a902a91 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt
@@ -46,10 +46,6 @@ class Exchange(
   internal var isDuplex: Boolean = false
     private set
 
-  /** True if the request body should not be used, but the socket, instead. */
-  internal var isSocket: Boolean = false
-    private set
-
   /** True if there was an exception on the connection to the peer. */
   internal var hasFailure: Boolean = false
     private set
@@ -82,7 +78,11 @@ class Exchange(
     val contentLength = request.body!!.contentLength()
     eventListener.requestBodyStart(call)
     val rawRequestBody = codec.createRequestBody(request, contentLength)
-    return RequestBodySink(rawRequestBody, contentLength)
+    return RequestBodySink(
+      delegate = rawRequestBody,
+      contentLength = contentLength,
+      isSocket = false,
+    )
   }
 
   @Throws(IOException::class)
@@ -134,7 +134,12 @@ class Exchange(
       val contentType = response.header("Content-Type")
       val contentLength = codec.reportedContentLength(response)
       val rawSource = codec.openResponseBodySource(response)
-      val source = ResponseBodySource(rawSource, contentLength)
+      val source =
+        ResponseBodySource(
+          delegate = rawSource,
+          contentLength = contentLength,
+          isSocket = false,
+        )
       return RealResponseBody(contentType, contentLength, source.buffer())
     } catch (e: IOException) {
       eventListener.responseFailed(call, e)
@@ -147,8 +152,7 @@ class Exchange(
   fun peekTrailers(): Headers? = codec.peekTrailers()
 
   fun upgradeToSocket(): Socket {
-    isSocket = true
-    call.timeoutEarlyExit()
+    call.upgradeToSocket()
     (codec.carrier as RealConnection).useAsSocket()
 
     return object : Socket {
@@ -156,8 +160,18 @@ class Exchange(
         this@Exchange.cancel()
       }
 
-      override val sink = RequestBodySink(codec.socket.sink, -1L)
-      override val source = ResponseBodySource(codec.socket.source, -1L)
+      override val sink =
+        RequestBodySink(
+          delegate = codec.socket.sink,
+          contentLength = -1L,
+          isSocket = true,
+        )
+      override val source =
+        ResponseBodySource(
+          delegate = codec.socket.source,
+          contentLength = -1L,
+          isSocket = true,
+        )
     }
   }
 
@@ -179,6 +193,8 @@ class Exchange(
       exchange = this,
       requestDone = true,
       responseDone = true,
+      socketSinkDone = true,
+      socketSourceDone = true,
       e = null,
     )
   }
@@ -191,6 +207,7 @@ class Exchange(
   /** If [e] is non-null, this will return a non-null value. */
   fun bodyComplete(
     bytesRead: Long = -1L,
+    isSocket: Boolean,
     responseDone: Boolean = false,
     requestDone: Boolean = false,
     e: IOException?,
@@ -214,8 +231,10 @@ class Exchange(
     }
     return call.messageDone(
       exchange = this,
-      requestDone = requestDone,
-      responseDone = responseDone,
+      requestDone = requestDone && !isSocket,
+      responseDone = responseDone && !isSocket,
+      socketSinkDone = requestDone && isSocket,
+      socketSourceDone = responseDone && isSocket,
       e = e,
     )
   }
@@ -233,6 +252,7 @@ class Exchange(
     delegate: Sink,
     /** The exact number of bytes to be written, or -1L if that is unknown. */
     private val contentLength: Long,
+    private val isSocket: Boolean,
   ) : ForwardingSink(delegate) {
     private var completed = false
     private var bytesReceived = 0L
@@ -292,6 +312,7 @@ class Exchange(
       completed = true
       return bodyComplete(
         bytesRead = bytesReceived,
+        isSocket = isSocket,
         requestDone = true,
         e = e,
       )
@@ -302,6 +323,7 @@ class Exchange(
   internal inner class ResponseBodySource(
     delegate: Source,
     private val contentLength: Long,
+    private val isSocket: Boolean,
   ) : ForwardingSource(delegate) {
     private var bytesReceived = 0L
     private var invokeStartEvent = true
@@ -372,6 +394,7 @@ class Exchange(
       }
       return bodyComplete(
         bytesRead = bytesReceived,
+        isSocket = isSocket,
         responseDone = true,
         e = e,
       )
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
index c6e0f53fb..8a615fe3d 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
@@ -103,11 +103,10 @@ class RealCall(
   // These properties are guarded by `this`. They are typically only accessed by the thread executing
   // the call, but they may be accessed by other threads for duplex requests.
 
-  /** True if this call still has a request body open. */
   private var requestBodyOpen = false
-
-  /** True if this call still has a response body open. */
   private var responseBodyOpen = false
+  private var socketSinkOpen = false
+  private var socketSourceOpen = false
 
   /** True if there are more exchanges expected for this call. */
   private var expectMoreExchanges = true
@@ -241,7 +240,7 @@ class RealCall(
         "cannot make a new request because the previous response is still open: " +
           "please call response.close()"
       }
-      check(!requestBodyOpen)
+      check(!requestBodyOpen && !socketSourceOpen && !socketSinkOpen)
     }
 
     if (newRoutePlanner) {
@@ -273,8 +272,7 @@ class RealCall(
   internal fun initExchange(chain: RealInterceptorChain): Exchange {
     withLock {
       check(expectMoreExchanges) { "released" }
-      check(!responseBodyOpen)
-      check(!requestBodyOpen)
+      check(!responseBodyOpen && !requestBodyOpen && !socketSourceOpen && !socketSinkOpen)
     }
 
     val exchangeFinder = this.exchangeFinder!!
@@ -312,22 +310,34 @@ class RealCall(
     exchange: Exchange,
     requestDone: Boolean = false,
     responseDone: Boolean = false,
+    socketSourceDone: Boolean = false,
+    socketSinkDone: Boolean = false,
     e: IOException?,
   ): IOException? {
     if (exchange != this.exchange) return e // This exchange was detached violently!
 
-    var bothStreamsDone = false
+    var allStreamsDone = false
     var callDone = false
     withLock {
-      if (requestDone && requestBodyOpen || responseDone && responseBodyOpen) {
+      if (
+        requestDone && requestBodyOpen ||
+        responseDone && responseBodyOpen ||
+        socketSinkDone && socketSinkOpen ||
+        socketSourceDone && socketSourceOpen
+      ) {
         if (requestDone) requestBodyOpen = false
         if (responseDone) responseBodyOpen = false
-        bothStreamsDone = !requestBodyOpen && !responseBodyOpen
-        callDone = !requestBodyOpen && !responseBodyOpen && !expectMoreExchanges
+        if (socketSinkDone) socketSinkOpen = false
+        if (socketSourceDone) socketSourceOpen = false
+        allStreamsDone = !requestBodyOpen &&
+          !responseBodyOpen &&
+          !socketSinkOpen &&
+          !socketSourceOpen
+        callDone = allStreamsDone && !expectMoreExchanges
       }
     }
 
-    if (bothStreamsDone) {
+    if (allStreamsDone) {
       this.exchange = null
       this.connection?.incrementSuccessCount()
     }
@@ -344,7 +354,7 @@ class RealCall(
     withLock {
       if (expectMoreExchanges) {
         expectMoreExchanges = false
-        callDone = !requestBodyOpen && !responseBodyOpen
+        callDone = !requestBodyOpen && !responseBodyOpen && !socketSinkOpen && !socketSourceOpen
       }
     }
 
@@ -357,7 +367,8 @@ class RealCall(
 
   /**
    * Complete this call. This should be called once these properties are all false:
-   * [requestBodyOpen], [responseBodyOpen], and [expectMoreExchanges].
+   * [requestBodyOpen], [responseBodyOpen], [socketSinkOpen], [socketSourceOpen], and
+   * [expectMoreExchanges].
    *
    * This will release the connection if it is still held.
    *
@@ -443,6 +454,20 @@ class RealCall(
     timeout.exit()
   }
 
+  fun upgradeToSocket() {
+    timeoutEarlyExit()
+
+    withLock {
+      check(exchange != null)
+      check(!socketSinkOpen && !socketSourceOpen)
+      check(!requestBodyOpen)
+      check(responseBodyOpen)
+      responseBodyOpen = false
+      socketSinkOpen = true
+      socketSourceOpen = true
+    }
+  }
+
   /**
    * @param closeExchange true if the current exchange should be closed because it will not be used.
    *     This is usually due to either an exception or a retry.
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
index 8ca73379d..4451f8ca2 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
@@ -44,41 +44,39 @@ object CallServerInterceptor : Interceptor {
     try {
       exchange.writeRequestHeaders(request)
 
-      if (!isUpgradeRequest) {
-        if (hasRequestBody) {
-          // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-          // Continue" response before transmitting the request body. If we don't get that, return
-          // what we did get (such as a 4xx response) without ever transmitting the request body.
-          if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) {
+      if (hasRequestBody) {
+        // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+        // Continue" response before transmitting the request body. If we don't get that, return
+        // what we did get (such as a 4xx response) without ever transmitting the request body.
+        if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) {
+          exchange.flushRequest()
+          responseBuilder = exchange.readResponseHeaders(expectContinue = true)
+          exchange.responseHeadersStart()
+          invokeStartEvent = false
+        }
+        if (responseBuilder == null) {
+          if (requestBody.isDuplex()) {
+            // Prepare a duplex body so that the application can send a request body later.
             exchange.flushRequest()
-            responseBuilder = exchange.readResponseHeaders(expectContinue = true)
-            exchange.responseHeadersStart()
-            invokeStartEvent = false
-          }
-          if (responseBuilder == null) {
-            if (requestBody.isDuplex()) {
-              // Prepare a duplex body so that the application can send a request body later.
-              exchange.flushRequest()
-              val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
-              requestBody.writeTo(bufferedRequestBody)
-            } else {
-              // Write the request body if the "Expect: 100-continue" expectation was met.
-              val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
-              requestBody.writeTo(bufferedRequestBody)
-              bufferedRequestBody.close()
-            }
+            val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
+            requestBody.writeTo(bufferedRequestBody)
           } else {
-            exchange.noRequestBody()
-            if (!exchange.connection.isMultiplexed) {
-              // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-              // from being reused. Otherwise we're still obligated to transmit the request body to
-              // leave the connection in a consistent state.
-              exchange.noNewExchangesOnConnection()
-            }
+            // Write the request body if the "Expect: 100-continue" expectation was met.
+            val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
+            requestBody.writeTo(bufferedRequestBody)
+            bufferedRequestBody.close()
           }
         } else {
           exchange.noRequestBody()
+          if (!exchange.connection.isMultiplexed) {
+            // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+            // from being reused. Otherwise we're still obligated to transmit the request body to
+            // leave the connection in a consistent state.
+            exchange.noNewExchangesOnConnection()
+          }
         }
+      } else {
+        exchange.noRequestBody()
       }
 
       if (requestBody == null || !requestBody.isDuplex()) {
@@ -154,9 +152,6 @@ object CallServerInterceptor : Interceptor {
 
           // This is not an upgrade response.
           else -> {
-            if (isUpgradeRequest) {
-              exchange.noRequestBody() // Failed upgrade request has no outbound data.
-            }
             val responseBody = exchange.openResponseBody(response)
             response
               .newBuilder()
