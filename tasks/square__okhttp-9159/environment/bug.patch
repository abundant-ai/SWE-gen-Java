diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 2dd6b6e95..554f5ea7a 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -1,7 +1,7 @@
 [versions]
 agp = "8.13.0"
 biz-aQute-bnd = "7.1.0"
-checkStyle = "12.0.1"
+checkStyle = "12.1.0"
 com-squareup-moshi = "1.15.2"
 com-squareup-okio = "3.16.2"
 de-mannodermaus-junit5 = "1.9.0"
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt
index a4c6217d1..b9474540d 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Request.kt
@@ -82,6 +82,15 @@ class Request internal constructor(
       ),
   )
 
+  init {
+    val connectionHeader = headers["Connection"]
+    if ("upgrade".equals(connectionHeader, ignoreCase = true)) {
+      require(body == null || body.contentLength() == 0L) {
+        "expected a null or empty request body with 'Connection: upgrade'"
+      }
+    }
+  }
+
   fun header(name: String): String? = headers[name]
 
   fun headers(name: String): List<String> = headers.values(name)
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt
index 64a902a91..4484ca66e 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt
@@ -46,6 +46,10 @@ class Exchange(
   internal var isDuplex: Boolean = false
     private set
 
+  /** True if the request body should not be used, but the socket, instead. */
+  internal var isSocket: Boolean = false
+    private set
+
   /** True if there was an exception on the connection to the peer. */
   internal var hasFailure: Boolean = false
     private set
@@ -78,11 +82,7 @@ class Exchange(
     val contentLength = request.body!!.contentLength()
     eventListener.requestBodyStart(call)
     val rawRequestBody = codec.createRequestBody(request, contentLength)
-    return RequestBodySink(
-      delegate = rawRequestBody,
-      contentLength = contentLength,
-      isSocket = false,
-    )
+    return RequestBodySink(rawRequestBody, contentLength)
   }
 
   @Throws(IOException::class)
@@ -134,12 +134,7 @@ class Exchange(
       val contentType = response.header("Content-Type")
       val contentLength = codec.reportedContentLength(response)
       val rawSource = codec.openResponseBodySource(response)
-      val source =
-        ResponseBodySource(
-          delegate = rawSource,
-          contentLength = contentLength,
-          isSocket = false,
-        )
+      val source = ResponseBodySource(rawSource, contentLength)
       return RealResponseBody(contentType, contentLength, source.buffer())
     } catch (e: IOException) {
       eventListener.responseFailed(call, e)
@@ -152,7 +147,8 @@ class Exchange(
   fun peekTrailers(): Headers? = codec.peekTrailers()
 
   fun upgradeToSocket(): Socket {
-    call.upgradeToSocket()
+    isSocket = true
+    call.timeoutEarlyExit()
     (codec.carrier as RealConnection).useAsSocket()
 
     return object : Socket {
@@ -160,18 +156,8 @@ class Exchange(
         this@Exchange.cancel()
       }
 
-      override val sink =
-        RequestBodySink(
-          delegate = codec.socket.sink,
-          contentLength = -1L,
-          isSocket = true,
-        )
-      override val source =
-        ResponseBodySource(
-          delegate = codec.socket.source,
-          contentLength = -1L,
-          isSocket = true,
-        )
+      override val sink = RequestBodySink(codec.socket.sink, -1L)
+      override val source = ResponseBodySource(codec.socket.source, -1L)
     }
   }
 
@@ -193,8 +179,6 @@ class Exchange(
       exchange = this,
       requestDone = true,
       responseDone = true,
-      socketSinkDone = true,
-      socketSourceDone = true,
       e = null,
     )
   }
@@ -207,7 +191,6 @@ class Exchange(
   /** If [e] is non-null, this will return a non-null value. */
   fun bodyComplete(
     bytesRead: Long = -1L,
-    isSocket: Boolean,
     responseDone: Boolean = false,
     requestDone: Boolean = false,
     e: IOException?,
@@ -231,10 +214,8 @@ class Exchange(
     }
     return call.messageDone(
       exchange = this,
-      requestDone = requestDone && !isSocket,
-      responseDone = responseDone && !isSocket,
-      socketSinkDone = requestDone && isSocket,
-      socketSourceDone = responseDone && isSocket,
+      requestDone = requestDone,
+      responseDone = responseDone,
       e = e,
     )
   }
@@ -252,7 +233,6 @@ class Exchange(
     delegate: Sink,
     /** The exact number of bytes to be written, or -1L if that is unknown. */
     private val contentLength: Long,
-    private val isSocket: Boolean,
   ) : ForwardingSink(delegate) {
     private var completed = false
     private var bytesReceived = 0L
@@ -312,7 +292,6 @@ class Exchange(
       completed = true
       return bodyComplete(
         bytesRead = bytesReceived,
-        isSocket = isSocket,
         requestDone = true,
         e = e,
       )
@@ -323,7 +302,6 @@ class Exchange(
   internal inner class ResponseBodySource(
     delegate: Source,
     private val contentLength: Long,
-    private val isSocket: Boolean,
   ) : ForwardingSource(delegate) {
     private var bytesReceived = 0L
     private var invokeStartEvent = true
@@ -394,7 +372,6 @@ class Exchange(
       }
       return bodyComplete(
         bytesRead = bytesReceived,
-        isSocket = isSocket,
         responseDone = true,
         e = e,
       )
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
index 8a615fe3d..c6e0f53fb 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
@@ -103,10 +103,11 @@ class RealCall(
   // These properties are guarded by `this`. They are typically only accessed by the thread executing
   // the call, but they may be accessed by other threads for duplex requests.
 
+  /** True if this call still has a request body open. */
   private var requestBodyOpen = false
+
+  /** True if this call still has a response body open. */
   private var responseBodyOpen = false
-  private var socketSinkOpen = false
-  private var socketSourceOpen = false
 
   /** True if there are more exchanges expected for this call. */
   private var expectMoreExchanges = true
@@ -240,7 +241,7 @@ class RealCall(
         "cannot make a new request because the previous response is still open: " +
           "please call response.close()"
       }
-      check(!requestBodyOpen && !socketSourceOpen && !socketSinkOpen)
+      check(!requestBodyOpen)
     }
 
     if (newRoutePlanner) {
@@ -272,7 +273,8 @@ class RealCall(
   internal fun initExchange(chain: RealInterceptorChain): Exchange {
     withLock {
       check(expectMoreExchanges) { "released" }
-      check(!responseBodyOpen && !requestBodyOpen && !socketSourceOpen && !socketSinkOpen)
+      check(!responseBodyOpen)
+      check(!requestBodyOpen)
     }
 
     val exchangeFinder = this.exchangeFinder!!
@@ -310,34 +312,22 @@ class RealCall(
     exchange: Exchange,
     requestDone: Boolean = false,
     responseDone: Boolean = false,
-    socketSourceDone: Boolean = false,
-    socketSinkDone: Boolean = false,
     e: IOException?,
   ): IOException? {
     if (exchange != this.exchange) return e // This exchange was detached violently!
 
-    var allStreamsDone = false
+    var bothStreamsDone = false
     var callDone = false
     withLock {
-      if (
-        requestDone && requestBodyOpen ||
-        responseDone && responseBodyOpen ||
-        socketSinkDone && socketSinkOpen ||
-        socketSourceDone && socketSourceOpen
-      ) {
+      if (requestDone && requestBodyOpen || responseDone && responseBodyOpen) {
         if (requestDone) requestBodyOpen = false
         if (responseDone) responseBodyOpen = false
-        if (socketSinkDone) socketSinkOpen = false
-        if (socketSourceDone) socketSourceOpen = false
-        allStreamsDone = !requestBodyOpen &&
-          !responseBodyOpen &&
-          !socketSinkOpen &&
-          !socketSourceOpen
-        callDone = allStreamsDone && !expectMoreExchanges
+        bothStreamsDone = !requestBodyOpen && !responseBodyOpen
+        callDone = !requestBodyOpen && !responseBodyOpen && !expectMoreExchanges
       }
     }
 
-    if (allStreamsDone) {
+    if (bothStreamsDone) {
       this.exchange = null
       this.connection?.incrementSuccessCount()
     }
@@ -354,7 +344,7 @@ class RealCall(
     withLock {
       if (expectMoreExchanges) {
         expectMoreExchanges = false
-        callDone = !requestBodyOpen && !responseBodyOpen && !socketSinkOpen && !socketSourceOpen
+        callDone = !requestBodyOpen && !responseBodyOpen
       }
     }
 
@@ -367,8 +357,7 @@ class RealCall(
 
   /**
    * Complete this call. This should be called once these properties are all false:
-   * [requestBodyOpen], [responseBodyOpen], [socketSinkOpen], [socketSourceOpen], and
-   * [expectMoreExchanges].
+   * [requestBodyOpen], [responseBodyOpen], and [expectMoreExchanges].
    *
    * This will release the connection if it is still held.
    *
@@ -454,20 +443,6 @@ class RealCall(
     timeout.exit()
   }
 
-  fun upgradeToSocket() {
-    timeoutEarlyExit()
-
-    withLock {
-      check(exchange != null)
-      check(!socketSinkOpen && !socketSourceOpen)
-      check(!requestBodyOpen)
-      check(responseBodyOpen)
-      responseBodyOpen = false
-      socketSinkOpen = true
-      socketSourceOpen = true
-    }
-  }
-
   /**
    * @param closeExchange true if the current exchange should be closed because it will not be used.
    *     This is usually due to either an exception or a retry.
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
index 4451f8ca2..8ca73379d 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
@@ -44,39 +44,41 @@ object CallServerInterceptor : Interceptor {
     try {
       exchange.writeRequestHeaders(request)
 
-      if (hasRequestBody) {
-        // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-        // Continue" response before transmitting the request body. If we don't get that, return
-        // what we did get (such as a 4xx response) without ever transmitting the request body.
-        if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) {
-          exchange.flushRequest()
-          responseBuilder = exchange.readResponseHeaders(expectContinue = true)
-          exchange.responseHeadersStart()
-          invokeStartEvent = false
-        }
-        if (responseBuilder == null) {
-          if (requestBody.isDuplex()) {
-            // Prepare a duplex body so that the application can send a request body later.
+      if (!isUpgradeRequest) {
+        if (hasRequestBody) {
+          // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
+          // Continue" response before transmitting the request body. If we don't get that, return
+          // what we did get (such as a 4xx response) without ever transmitting the request body.
+          if ("100-continue".equals(request.header("Expect"), ignoreCase = true)) {
             exchange.flushRequest()
-            val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
-            requestBody.writeTo(bufferedRequestBody)
+            responseBuilder = exchange.readResponseHeaders(expectContinue = true)
+            exchange.responseHeadersStart()
+            invokeStartEvent = false
+          }
+          if (responseBuilder == null) {
+            if (requestBody.isDuplex()) {
+              // Prepare a duplex body so that the application can send a request body later.
+              exchange.flushRequest()
+              val bufferedRequestBody = exchange.createRequestBody(request, true).buffer()
+              requestBody.writeTo(bufferedRequestBody)
+            } else {
+              // Write the request body if the "Expect: 100-continue" expectation was met.
+              val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
+              requestBody.writeTo(bufferedRequestBody)
+              bufferedRequestBody.close()
+            }
           } else {
-            // Write the request body if the "Expect: 100-continue" expectation was met.
-            val bufferedRequestBody = exchange.createRequestBody(request, false).buffer()
-            requestBody.writeTo(bufferedRequestBody)
-            bufferedRequestBody.close()
+            exchange.noRequestBody()
+            if (!exchange.connection.isMultiplexed) {
+              // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+              // from being reused. Otherwise we're still obligated to transmit the request body to
+              // leave the connection in a consistent state.
+              exchange.noNewExchangesOnConnection()
+            }
           }
         } else {
           exchange.noRequestBody()
-          if (!exchange.connection.isMultiplexed) {
-            // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
-            // from being reused. Otherwise we're still obligated to transmit the request body to
-            // leave the connection in a consistent state.
-            exchange.noNewExchangesOnConnection()
-          }
         }
-      } else {
-        exchange.noRequestBody()
       }
 
       if (requestBody == null || !requestBody.isDuplex()) {
@@ -152,6 +154,9 @@ object CallServerInterceptor : Interceptor {
 
           // This is not an upgrade response.
           else -> {
+            if (isUpgradeRequest) {
+              exchange.noRequestBody() // Failed upgrade request has no outbound data.
+            }
             val responseBody = exchange.openResponseBody(response)
             response
               .newBuilder()
diff --git a/okhttp/src/jvmTest/kotlin/okhttp3/internal/http/HttpUpgradesTest.kt b/okhttp/src/jvmTest/kotlin/okhttp3/internal/http/HttpUpgradesTest.kt
index daba5a2a9..57af599ec 100644
--- a/okhttp/src/jvmTest/kotlin/okhttp3/internal/http/HttpUpgradesTest.kt
+++ b/okhttp/src/jvmTest/kotlin/okhttp3/internal/http/HttpUpgradesTest.kt
@@ -17,8 +17,8 @@ package okhttp3.internal.http
 
 import assertk.assertThat
 import assertk.assertions.containsExactly
+import assertk.assertions.hasMessage
 import assertk.assertions.isEqualTo
-import assertk.assertions.isInstanceOf
 import assertk.assertions.isNull
 import assertk.assertions.isTrue
 import kotlin.test.assertFailsWith
@@ -44,8 +44,6 @@ import okhttp3.CallEvent.ResponseBodyEnd
 import okhttp3.CallEvent.ResponseBodyStart
 import okhttp3.CallEvent.ResponseHeadersEnd
 import okhttp3.CallEvent.ResponseHeadersStart
-import okhttp3.CallEvent.SecureConnectEnd
-import okhttp3.CallEvent.SecureConnectStart
 import okhttp3.Headers.Companion.headersOf
 import okhttp3.OkHttpClientTestRule
 import okhttp3.Protocol
@@ -124,20 +122,10 @@ class HttpUpgradesTest {
   }
 
   @Test
-  fun upgradeWithEmptyRequestBody() {
+  fun upgradeWithRequestBody() {
     executeAndCheckUpgrade(upgradeRequest().newBuilder().post(RequestBody.EMPTY).build())
   }
 
-  @Test
-  fun upgradeWithNonEmptyRequestBody() {
-    executeAndCheckUpgrade(
-      upgradeRequest()
-        .newBuilder()
-        .post("Hello".toRequestBody())
-        .build(),
-    )
-  }
-
   @Test
   fun upgradeHttps() {
     enableTls(Protocol.HTTP_1_1)
@@ -250,8 +238,8 @@ class HttpUpgradesTest {
   }
 
   @Test
-  fun upgradeEventsWithEmptyRequestBody() {
-    upgradeWithEmptyRequestBody()
+  fun upgradeEventsWithRequestBody() {
+    upgradeWithRequestBody()
 
     assertThat(listener.recordedEventTypes()).containsExactly(
       CallStart::class,
@@ -264,8 +252,6 @@ class HttpUpgradesTest {
       ConnectionAcquired::class,
       RequestHeadersStart::class,
       RequestHeadersEnd::class,
-      RequestBodyStart::class,
-      RequestBodyEnd::class,
       ResponseHeadersStart::class,
       ResponseHeadersEnd::class,
       FollowUpDecision::class,
@@ -279,32 +265,17 @@ class HttpUpgradesTest {
   }
 
   @Test
-  fun upgradeEventsWithNonEmptyRequestBody() {
-    upgradeWithNonEmptyRequestBody()
-
-    assertThat(listener.recordedEventTypes()).containsExactly(
-      CallStart::class,
-      ProxySelectStart::class,
-      ProxySelectEnd::class,
-      DnsStart::class,
-      DnsEnd::class,
-      ConnectStart::class,
-      ConnectEnd::class,
-      ConnectionAcquired::class,
-      RequestHeadersStart::class,
-      RequestHeadersEnd::class,
-      RequestBodyStart::class,
-      RequestBodyEnd::class,
-      ResponseHeadersStart::class,
-      ResponseHeadersEnd::class,
-      FollowUpDecision::class,
-      RequestBodyStart::class,
-      ResponseBodyStart::class,
-      ResponseBodyEnd::class,
-      RequestBodyEnd::class,
-      ConnectionReleased::class,
-      CallEnd::class,
-    )
+  fun upgradeRequestMustHaveAnEmptyBody() {
+    val e =
+      assertFailsWith<IllegalArgumentException> {
+        Request
+          .Builder()
+          .url(server.url("/"))
+          .header("Connection", "upgrade")
+          .post("Hello".toRequestBody())
+          .build()
+      }
+    assertThat(e).hasMessage("expected a null or empty request body with 'Connection: upgrade'")
   }
 
   private fun enableTls(vararg protocols: Protocol) {
