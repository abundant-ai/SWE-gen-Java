diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 723d60cff..e74920ed9 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -224,7 +224,3 @@ RÃ©da Housni Alaoui (@reda-alaoui)
 Flinter (@jhan0121)
  * Contributed #5595: Add `FunctionalScalarDeserializer` for functional-style deserialization
   [3.1.0]
-
-Brandon Schmitt (@BrandonSchmitt)
- * Reported #5616: `ObjectWriter` serializes `Optional`s with subtypes incompletely
-  [3.1.0]
diff --git a/release-notes/VERSION b/release-notes/VERSION
index c1a9a10d7..c18fbec70 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -150,9 +150,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #5595: Add `FunctionalScalarDeserializer` for functional-style deserialization
  (contributed by @jhan0121)
 #5599: Reduce mutability of `JsonFormatVisitor` types in 3.1
-#5616: `ObjectWriter` serializes `Optional`s with subtypes incompletely
- (reported by Brandon S)
- (implemented by @cowtowncoder, w/ Claude code)
 
 3.0.4 (not yet released)
 
diff --git a/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java b/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java
index 6fcb81979..0413f848c 100644
--- a/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/std/ReferenceTypeSerializer.java
@@ -163,9 +163,7 @@ public abstract class ReferenceTypeSerializer<T>
             ser = _valueSerializer;
             if (ser == null) {
                 // A few conditions needed to be able to fetch serializer here:
-                // [databind#5616]: If we have a TypeSerializer for polymorphic types,
-                // do NOT use static typing -- need dynamic lookup for subtypes
-                if ((typeSer == null) && _useStatic(ctxt, property, _referredType)) {
+                if (_useStatic(ctxt, property, _referredType)) {
                     ser = _findSerializer(ctxt, _referredType, property);
                 }
             } else {
diff --git a/src/test/java/tools/jackson/databind/ext/jdk8/OptionalSubtypeSerializationTest.java b/src/test/java/tools/jackson/databind/ext/jdk8/OptionalSubtypeSerializationTest.java
deleted file mode 100644
index 8fd1e0182..000000000
--- a/src/test/java/tools/jackson/databind/ext/jdk8/OptionalSubtypeSerializationTest.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package tools.jackson.databind.ext.jdk8;
-
-import java.util.List;
-import java.util.Optional;
-
-import org.junit.jupiter.api.Test;
-
-import com.fasterxml.jackson.annotation.JsonSubTypes;
-import com.fasterxml.jackson.annotation.JsonTypeInfo;
-
-import tools.jackson.core.type.TypeReference;
-import tools.jackson.databind.ObjectMapper;
-import tools.jackson.databind.testutil.DatabindTestUtil;
-
-import static org.junit.jupiter.api.Assertions.assertEquals;
-
-/**
- * Test for <a href="https://github.com/FasterXML/jackson-databind/issues/5616">
- * [databind#5616]: ObjectWriter Serializes Optionals with SubTypes Incompletely
- * </a>
- * <p>
- * When serializing an {@code Optional<Supertype>} with a {@code TypeReference},
- * subtype-specific properties should be included in the output.
- */
-public class OptionalSubtypeSerializationTest extends DatabindTestUtil
-{
-    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME)
-    @JsonSubTypes({
-        @JsonSubTypes.Type(value = Supertype.Subtype.class, name = "subtype"),
-    })
-    interface Supertype {
-        class Subtype implements Supertype {
-            public String content = "hello";
-        }
-    }
-
-    private final ObjectMapper MAPPER = newJsonMapper();
-
-    // [databind#5616]: List<Supertype> works correctly (baseline test)
-    @Test
-    public void testListWithSubtypeProperties() throws Exception
-    {
-        Supertype object = new Supertype.Subtype();
-
-        String json = MAPPER.writerFor(new TypeReference<List<Supertype>>() {})
-                .writeValueAsString(List.of(object));
-
-        // This works: subtype property "content" is included
-        assertEquals("[{\"@type\":\"subtype\",\"content\":\"hello\"}]", json);
-    }
-
-    // [databind#5616]: Optional<Supertype> loses subtype properties
-    @Test
-    public void testOptionalWithSubtypeProperties() throws Exception
-    {
-        Supertype object = new Supertype.Subtype();
-
-        String json = MAPPER.writerFor(new TypeReference<Optional<Supertype>>() {})
-                .writeValueAsString(Optional.of(object));
-
-        // This fails: actual output is '{"@type":"subtype"}' - missing "content" property
-        assertEquals("{\"@type\":\"subtype\",\"content\":\"hello\"}", json);
-    }
-
-    // Additional test: direct subtype serialization works
-    @Test
-    public void testDirectSubtypeSerialization() throws Exception
-    {
-        Supertype.Subtype object = new Supertype.Subtype();
-
-        String json = MAPPER.writeValueAsString(object);
-
-        // Direct serialization includes all properties
-        assertEquals("{\"@type\":\"subtype\",\"content\":\"hello\"}", json);
-    }
-
-    // Additional test: Optional without TypeReference uses runtime type
-    @Test
-    public void testOptionalWithoutTypeReference() throws Exception
-    {
-        Supertype object = new Supertype.Subtype();
-
-        // When not using TypeReference, it serializes based on actual runtime type
-        // which is Subtype, so @type is not needed (not serializing as Supertype)
-        String json = MAPPER.writeValueAsString(Optional.of(object));
-
-        // Serializes as Subtype directly (no @type discriminator needed)
-        assertEquals("{\"content\":\"hello\"}", json);
-    }
-}
