diff --git a/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/Endpoint.kt b/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/Endpoint.kt
index cd0f45190..b7fcfd43a 100644
--- a/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/Endpoint.kt
+++ b/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/Endpoint.kt
@@ -40,7 +40,7 @@ internal class Endpoint(
     private val deliveryPoint: Channel<RequestTask> = Channel()
     private val maxEndpointIdleTime: Long = 2 * config.endpoint.connectTimeout
 
-    private val timeout = launch(coroutineContext + CoroutineName("Endpoint timeout($host:$port)")) {
+    private val timeout = launch(coroutineContext + CoroutineName("cio-endpoint-timeout")) {
         try {
             while (true) {
                 val remaining = (lastActivity.value + maxEndpointIdleTime) - getTimeMillis()
@@ -317,7 +317,7 @@ internal class Endpoint(
 private fun setupTimeout(callContext: CoroutineContext, request: HttpRequestData, timeout: Long) {
     if (timeout == HttpTimeoutConfig.INFINITE_TIMEOUT_MS || timeout == 0L) return
 
-    val timeoutJob = GlobalScope.launch {
+    val timeoutJob = GlobalScope.launch(CoroutineName("cio-request-timeout")) {
         delay(timeout)
         callContext.job.cancel("Request is timed out", HttpRequestTimeoutException(request))
     }
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt
index 298eb9472..e09d442e9 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt
@@ -33,6 +33,8 @@ import kotlin.coroutines.CoroutineContext
  */
 @OptIn(InternalAPI::class)
 public suspend fun HttpClientCall.save(): HttpClientCall {
+    if (this is SavedHttpCall) return this
+
     val responseBody = response.rawContent.readRemaining().readByteArray()
     return SavedHttpCall(client, request, response, responseBody)
 }
@@ -51,13 +53,6 @@ internal class SavedHttpCall(
         checkContentLength(response.contentLength(), responseBody.size.toLong(), request.method)
     }
 
-    /**
-     * Returns a channel with [responseBody] data.
-     */
-    override suspend fun getResponseContent(): ByteReadChannel {
-        return ByteReadChannel(responseBody)
-    }
-
     override val allowDoubleReceive: Boolean = true
 }
 
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/engine/Utils.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/engine/Utils.kt
index 0f3352d2f..fef333a8c 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/engine/Utils.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/engine/Utils.kt
@@ -9,8 +9,11 @@ import io.ktor.http.*
 import io.ktor.http.content.*
 import io.ktor.util.*
 import io.ktor.utils.io.*
-import kotlinx.coroutines.*
-import kotlin.coroutines.*
+import kotlinx.coroutines.InternalCoroutinesApi
+import kotlinx.coroutines.Job
+import kotlinx.coroutines.currentCoroutineContext
+import kotlin.coroutines.CoroutineContext
+import kotlin.coroutines.coroutineContext
 
 /**
  * Default user agent to use in a Ktor client.
@@ -98,7 +101,7 @@ internal class KtorCallContextElement(val callContext: CoroutineContext) : Corou
  */
 @OptIn(InternalCoroutinesApi::class)
 internal suspend inline fun attachToUserJob(callJob: Job) {
-    val userJob = coroutineContext[Job] ?: return
+    val userJob = currentCoroutineContext()[Job] ?: return
 
     val cleanupHandler = userJob.invokeOnCompletion(onCancelling = true) { cause ->
         cause ?: return@invokeOnCompletion
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/HttpRequestRetry.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/HttpRequestRetry.kt
index a92922820..25f097182 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/HttpRequestRetry.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/HttpRequestRetry.kt
@@ -15,10 +15,10 @@ import io.ktor.http.*
 import io.ktor.util.*
 import io.ktor.util.logging.*
 import io.ktor.utils.io.*
-import kotlinx.coroutines.*
 import kotlinx.coroutines.CancellationException
-import kotlin.math.*
-import kotlin.random.*
+import kotlinx.coroutines.CompletableJob
+import kotlin.math.pow
+import kotlin.random.Random
 
 private val LOGGER = KtorSimpleLogger("io.ktor.client.plugins.HttpRequestRetry")
 
@@ -479,5 +479,14 @@ private fun Throwable.isTimeoutException(): Boolean {
 private suspend fun HttpResponse.throwOnInvalidResponseBody(): Boolean {
     // wait for saved content to pass through intermediate processing
     // if the encoding is wrong, then this will throw an exception
-    return isSaved && rawContent.awaitContent()
+    return isSaved && rawContent.run {
+        try {
+            awaitContent()
+        } finally {
+            // Saved response returns a new instance of ByteReadChannel on each rawContent read,
+            // so we should close the channel to free up resources
+            runCatching { cancel() }
+                .onFailure { LOGGER.debug("Failed to close response body channel", it) }
+        }
+    }
 }
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpStatement.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpStatement.kt
index a27663c0e..b64cb5944 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpStatement.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpStatement.kt
@@ -9,7 +9,8 @@ import io.ktor.client.call.*
 import io.ktor.client.plugins.*
 import io.ktor.client.request.*
 import io.ktor.utils.io.*
-import kotlinx.coroutines.*
+import kotlinx.coroutines.CompletableJob
+import kotlinx.coroutines.job
 
 /**
  * Represents a prepared HTTP request statement for [HttpClient].
@@ -174,13 +175,17 @@ public class HttpStatement(
     @PublishedApi
     @OptIn(InternalAPI::class)
     internal suspend fun HttpResponse.cleanup() {
-        val job = coroutineContext[Job]!! as CompletableJob
+        val job = coroutineContext.job as CompletableJob
 
         job.apply {
             complete()
-            try {
-                rawContent.cancel()
-            } catch (_: Throwable) {
+            // If the response is saved, the underlying channel is already closed and
+            // calling `rawContent` would create a new one
+            if (!isSaved) {
+                try {
+                    rawContent.cancel()
+                } catch (_: Throwable) {
+                }
             }
             join()
         }
diff --git a/ktor-utils/jvm/src/io/ktor/util/Deflater.kt b/ktor-utils/jvm/src/io/ktor/util/Deflater.kt
index 86d3b5b67..16fc6c59e 100644
--- a/ktor-utils/jvm/src/io/ktor/util/Deflater.kt
+++ b/ktor-utils/jvm/src/io/ktor/util/Deflater.kt
@@ -8,10 +8,15 @@ import io.ktor.util.cio.*
 import io.ktor.utils.io.*
 import io.ktor.utils.io.bits.*
 import io.ktor.utils.io.pool.*
-import kotlinx.coroutines.*
+import kotlinx.coroutines.CoroutineName
+import kotlinx.coroutines.DelicateCoroutinesApi
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.GlobalScope
 import java.nio.ByteBuffer
-import java.util.zip.*
-import kotlin.coroutines.*
+import java.util.zip.CRC32
+import java.util.zip.Checksum
+import java.util.zip.Deflater
+import kotlin.coroutines.CoroutineContext
 
 internal const val GZIP_MAGIC: Short = 0x8b1f.toShort()
 internal val GZIP_HEADER_PADDING: ByteArray = ByteArray(7)
@@ -97,6 +102,9 @@ private suspend fun ByteReadChannel.deflateTo(
     }
 }
 
+private val DeflateWriterCoroutineName = CoroutineName("encoder-deflate-writer")
+private val DeflateReaderCoroutineName = CoroutineName("encoder-deflate-reader")
+
 /**
  * Launch a coroutine on [coroutineContext] that does deflate compression
  * optionally doing CRC and writing GZIP header and trailer if [gzip] = `true`
@@ -108,7 +116,7 @@ public fun ByteReadChannel.deflated(
     gzip: Boolean = true,
     pool: ObjectPool<ByteBuffer> = KtorDefaultPool,
     coroutineContext: CoroutineContext = Dispatchers.Unconfined
-): ByteReadChannel = GlobalScope.writer(coroutineContext, autoFlush = true) {
+): ByteReadChannel = GlobalScope.writer(coroutineContext + DeflateWriterCoroutineName, autoFlush = true) {
     this@deflated.deflateTo(channel, gzip, pool)
 }.channel
 
@@ -123,6 +131,6 @@ public fun ByteWriteChannel.deflated(
     gzip: Boolean = true,
     pool: ObjectPool<ByteBuffer> = KtorDefaultPool,
     coroutineContext: CoroutineContext = Dispatchers.Unconfined
-): ByteWriteChannel = GlobalScope.reader(coroutineContext, autoFlush = true) {
+): ByteWriteChannel = GlobalScope.reader(coroutineContext + DeflateReaderCoroutineName, autoFlush = true) {
     channel.deflateTo(this@deflated, gzip, pool)
 }.channel
diff --git a/ktor-utils/jvm/src/io/ktor/util/EncodersJvm.kt b/ktor-utils/jvm/src/io/ktor/util/EncodersJvm.kt
index e3c087615..c167cdc1f 100644
--- a/ktor-utils/jvm/src/io/ktor/util/EncodersJvm.kt
+++ b/ktor-utils/jvm/src/io/ktor/util/EncodersJvm.kt
@@ -7,10 +7,15 @@ package io.ktor.util
 import io.ktor.util.cio.*
 import io.ktor.utils.io.*
 import io.ktor.utils.io.core.*
-import kotlinx.coroutines.*
-import java.nio.*
-import java.util.zip.*
-import kotlin.coroutines.*
+import kotlinx.coroutines.CoroutineName
+import kotlinx.coroutines.DelicateCoroutinesApi
+import kotlinx.coroutines.GlobalScope
+import java.nio.ByteBuffer
+import java.util.zip.CRC32
+import java.util.zip.Checksum
+import java.util.zip.Deflater
+import java.util.zip.Inflater
+import kotlin.coroutines.CoroutineContext
 
 private const val GZIP_HEADER_SIZE: Int = 10
 
@@ -67,14 +72,17 @@ public val GZip: Encoder = object : Encoder {
         inflate(source, coroutineContext = coroutineContext)
 }
 
+private val InflateWriterCoroutineName = CoroutineName("encoder-inflate-writer")
+
 @OptIn(DelicateCoroutinesApi::class)
 private fun inflate(
     source: ByteReadChannel,
     gzip: Boolean = true,
     coroutineContext: CoroutineContext
-): ByteReadChannel = GlobalScope.writer(coroutineContext) {
+): ByteReadChannel = GlobalScope.writer(coroutineContext + InflateWriterCoroutineName) {
     val readBuffer = KtorDefaultPool.borrow()
     val writeBuffer = KtorDefaultPool.borrow()
+
     val inflater = Inflater(true)
     val checksum = CRC32()
 
@@ -116,7 +124,6 @@ private fun inflate(
         while (!source.isClosedForRead) {
             if (source.readAvailable(readBuffer) <= 0) continue
             readBuffer.flip()
-
             inflater.setInput(readBuffer.array(), readBuffer.position(), readBuffer.remaining())
 
             while (!inflater.needsInput() && !inflater.finished()) {
