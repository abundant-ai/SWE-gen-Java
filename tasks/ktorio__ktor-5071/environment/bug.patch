diff --git a/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/Endpoint.kt b/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/Endpoint.kt
index b7fcfd43a..cd0f45190 100644
--- a/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/Endpoint.kt
+++ b/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/Endpoint.kt
@@ -40,7 +40,7 @@ internal class Endpoint(
     private val deliveryPoint: Channel<RequestTask> = Channel()
     private val maxEndpointIdleTime: Long = 2 * config.endpoint.connectTimeout
 
-    private val timeout = launch(coroutineContext + CoroutineName("cio-endpoint-timeout")) {
+    private val timeout = launch(coroutineContext + CoroutineName("Endpoint timeout($host:$port)")) {
         try {
             while (true) {
                 val remaining = (lastActivity.value + maxEndpointIdleTime) - getTimeMillis()
@@ -317,7 +317,7 @@ internal class Endpoint(
 private fun setupTimeout(callContext: CoroutineContext, request: HttpRequestData, timeout: Long) {
     if (timeout == HttpTimeoutConfig.INFINITE_TIMEOUT_MS || timeout == 0L) return
 
-    val timeoutJob = GlobalScope.launch(CoroutineName("cio-request-timeout")) {
+    val timeoutJob = GlobalScope.launch {
         delay(timeout)
         callContext.job.cancel("Request is timed out", HttpRequestTimeoutException(request))
     }
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt
index e09d442e9..298eb9472 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt
@@ -33,8 +33,6 @@ import kotlin.coroutines.CoroutineContext
  */
 @OptIn(InternalAPI::class)
 public suspend fun HttpClientCall.save(): HttpClientCall {
-    if (this is SavedHttpCall) return this
-
     val responseBody = response.rawContent.readRemaining().readByteArray()
     return SavedHttpCall(client, request, response, responseBody)
 }
@@ -53,6 +51,13 @@ internal class SavedHttpCall(
         checkContentLength(response.contentLength(), responseBody.size.toLong(), request.method)
     }
 
+    /**
+     * Returns a channel with [responseBody] data.
+     */
+    override suspend fun getResponseContent(): ByteReadChannel {
+        return ByteReadChannel(responseBody)
+    }
+
     override val allowDoubleReceive: Boolean = true
 }
 
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/engine/Utils.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/engine/Utils.kt
index fef333a8c..0f3352d2f 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/engine/Utils.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/engine/Utils.kt
@@ -9,11 +9,8 @@ import io.ktor.http.*
 import io.ktor.http.content.*
 import io.ktor.util.*
 import io.ktor.utils.io.*
-import kotlinx.coroutines.InternalCoroutinesApi
-import kotlinx.coroutines.Job
-import kotlinx.coroutines.currentCoroutineContext
-import kotlin.coroutines.CoroutineContext
-import kotlin.coroutines.coroutineContext
+import kotlinx.coroutines.*
+import kotlin.coroutines.*
 
 /**
  * Default user agent to use in a Ktor client.
@@ -101,7 +98,7 @@ internal class KtorCallContextElement(val callContext: CoroutineContext) : Corou
  */
 @OptIn(InternalCoroutinesApi::class)
 internal suspend inline fun attachToUserJob(callJob: Job) {
-    val userJob = currentCoroutineContext()[Job] ?: return
+    val userJob = coroutineContext[Job] ?: return
 
     val cleanupHandler = userJob.invokeOnCompletion(onCancelling = true) { cause ->
         cause ?: return@invokeOnCompletion
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/HttpRequestRetry.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/HttpRequestRetry.kt
index 25f097182..a92922820 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/HttpRequestRetry.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/plugins/HttpRequestRetry.kt
@@ -15,10 +15,10 @@ import io.ktor.http.*
 import io.ktor.util.*
 import io.ktor.util.logging.*
 import io.ktor.utils.io.*
+import kotlinx.coroutines.*
 import kotlinx.coroutines.CancellationException
-import kotlinx.coroutines.CompletableJob
-import kotlin.math.pow
-import kotlin.random.Random
+import kotlin.math.*
+import kotlin.random.*
 
 private val LOGGER = KtorSimpleLogger("io.ktor.client.plugins.HttpRequestRetry")
 
@@ -479,14 +479,5 @@ private fun Throwable.isTimeoutException(): Boolean {
 private suspend fun HttpResponse.throwOnInvalidResponseBody(): Boolean {
     // wait for saved content to pass through intermediate processing
     // if the encoding is wrong, then this will throw an exception
-    return isSaved && rawContent.run {
-        try {
-            awaitContent()
-        } finally {
-            // Saved response returns a new instance of ByteReadChannel on each rawContent read,
-            // so we should close the channel to free up resources
-            runCatching { cancel() }
-                .onFailure { LOGGER.debug("Failed to close response body channel", it) }
-        }
-    }
+    return isSaved && rawContent.awaitContent()
 }
diff --git a/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpStatement.kt b/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpStatement.kt
index b64cb5944..a27663c0e 100644
--- a/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpStatement.kt
+++ b/ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpStatement.kt
@@ -9,8 +9,7 @@ import io.ktor.client.call.*
 import io.ktor.client.plugins.*
 import io.ktor.client.request.*
 import io.ktor.utils.io.*
-import kotlinx.coroutines.CompletableJob
-import kotlinx.coroutines.job
+import kotlinx.coroutines.*
 
 /**
  * Represents a prepared HTTP request statement for [HttpClient].
@@ -175,17 +174,13 @@ public class HttpStatement(
     @PublishedApi
     @OptIn(InternalAPI::class)
     internal suspend fun HttpResponse.cleanup() {
-        val job = coroutineContext.job as CompletableJob
+        val job = coroutineContext[Job]!! as CompletableJob
 
         job.apply {
             complete()
-            // If the response is saved, the underlying channel is already closed and
-            // calling `rawContent` would create a new one
-            if (!isSaved) {
-                try {
-                    rawContent.cancel()
-                } catch (_: Throwable) {
-                }
+            try {
+                rawContent.cancel()
+            } catch (_: Throwable) {
             }
             join()
         }
diff --git a/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/HttpRequestRetryTest.kt b/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/HttpRequestRetryTest.kt
index ec7ff475c..9534efda9 100644
--- a/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/HttpRequestRetryTest.kt
+++ b/ktor-client/ktor-client-tests/common/test/io/ktor/client/tests/HttpRequestRetryTest.kt
@@ -4,20 +4,15 @@
 
 package io.ktor.client.tests
 
-import io.ktor.client.call.*
+import io.ktor.client.call.body
 import io.ktor.client.engine.mock.*
 import io.ktor.client.plugins.*
-import io.ktor.client.plugins.compression.*
 import io.ktor.client.request.*
 import io.ktor.client.test.base.*
 import io.ktor.http.*
-import io.ktor.util.*
-import io.ktor.utils.io.*
 import kotlinx.coroutines.*
-import kotlinx.coroutines.CancellationException
 import kotlinx.io.IOException
 import kotlin.test.*
-import kotlin.time.Duration.Companion.seconds
 
 class HttpRequestRetryTest {
 
@@ -487,33 +482,4 @@ class HttpRequestRetryTest {
             }
         }
     }
-
-    // KTOR-8820
-    @Test
-    fun testRetryWithLargeEncodedBody() = testWithEngine(MockEngine, timeout = 1.seconds) {
-        config {
-            engine {
-                addHandler {
-                    // Compressed body size should be larger than DEFAULT_BUFFER_SIZE to reproduce the bug
-                    val bytes = ByteArray(2 * 1024 * 1024) { it.toByte() }
-                    respond(
-                        GZipEncoder.encode(ByteReadChannel(bytes)),
-                        headers = headersOf(HttpHeaders.ContentEncoding, "gzip"),
-                    )
-                }
-            }
-
-            install(HttpRequestRetry) {
-                noRetry()
-            }
-            install(ContentEncoding) {
-                gzip()
-            }
-        }
-
-        test { client ->
-            val response = client.get { }
-            assertEquals(HttpStatusCode.OK, response.status)
-        }
-    }
 }
diff --git a/ktor-utils/jvm/src/io/ktor/util/Deflater.kt b/ktor-utils/jvm/src/io/ktor/util/Deflater.kt
index 16fc6c59e..86d3b5b67 100644
--- a/ktor-utils/jvm/src/io/ktor/util/Deflater.kt
+++ b/ktor-utils/jvm/src/io/ktor/util/Deflater.kt
@@ -8,15 +8,10 @@ import io.ktor.util.cio.*
 import io.ktor.utils.io.*
 import io.ktor.utils.io.bits.*
 import io.ktor.utils.io.pool.*
-import kotlinx.coroutines.CoroutineName
-import kotlinx.coroutines.DelicateCoroutinesApi
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.GlobalScope
+import kotlinx.coroutines.*
 import java.nio.ByteBuffer
-import java.util.zip.CRC32
-import java.util.zip.Checksum
-import java.util.zip.Deflater
-import kotlin.coroutines.CoroutineContext
+import java.util.zip.*
+import kotlin.coroutines.*
 
 internal const val GZIP_MAGIC: Short = 0x8b1f.toShort()
 internal val GZIP_HEADER_PADDING: ByteArray = ByteArray(7)
@@ -102,9 +97,6 @@ private suspend fun ByteReadChannel.deflateTo(
     }
 }
 
-private val DeflateWriterCoroutineName = CoroutineName("encoder-deflate-writer")
-private val DeflateReaderCoroutineName = CoroutineName("encoder-deflate-reader")
-
 /**
  * Launch a coroutine on [coroutineContext] that does deflate compression
  * optionally doing CRC and writing GZIP header and trailer if [gzip] = `true`
@@ -116,7 +108,7 @@ public fun ByteReadChannel.deflated(
     gzip: Boolean = true,
     pool: ObjectPool<ByteBuffer> = KtorDefaultPool,
     coroutineContext: CoroutineContext = Dispatchers.Unconfined
-): ByteReadChannel = GlobalScope.writer(coroutineContext + DeflateWriterCoroutineName, autoFlush = true) {
+): ByteReadChannel = GlobalScope.writer(coroutineContext, autoFlush = true) {
     this@deflated.deflateTo(channel, gzip, pool)
 }.channel
 
@@ -131,6 +123,6 @@ public fun ByteWriteChannel.deflated(
     gzip: Boolean = true,
     pool: ObjectPool<ByteBuffer> = KtorDefaultPool,
     coroutineContext: CoroutineContext = Dispatchers.Unconfined
-): ByteWriteChannel = GlobalScope.reader(coroutineContext + DeflateReaderCoroutineName, autoFlush = true) {
+): ByteWriteChannel = GlobalScope.reader(coroutineContext, autoFlush = true) {
     channel.deflateTo(this@deflated, gzip, pool)
 }.channel
diff --git a/ktor-utils/jvm/src/io/ktor/util/EncodersJvm.kt b/ktor-utils/jvm/src/io/ktor/util/EncodersJvm.kt
index c167cdc1f..e3c087615 100644
--- a/ktor-utils/jvm/src/io/ktor/util/EncodersJvm.kt
+++ b/ktor-utils/jvm/src/io/ktor/util/EncodersJvm.kt
@@ -7,15 +7,10 @@ package io.ktor.util
 import io.ktor.util.cio.*
 import io.ktor.utils.io.*
 import io.ktor.utils.io.core.*
-import kotlinx.coroutines.CoroutineName
-import kotlinx.coroutines.DelicateCoroutinesApi
-import kotlinx.coroutines.GlobalScope
-import java.nio.ByteBuffer
-import java.util.zip.CRC32
-import java.util.zip.Checksum
-import java.util.zip.Deflater
-import java.util.zip.Inflater
-import kotlin.coroutines.CoroutineContext
+import kotlinx.coroutines.*
+import java.nio.*
+import java.util.zip.*
+import kotlin.coroutines.*
 
 private const val GZIP_HEADER_SIZE: Int = 10
 
@@ -72,17 +67,14 @@ public val GZip: Encoder = object : Encoder {
         inflate(source, coroutineContext = coroutineContext)
 }
 
-private val InflateWriterCoroutineName = CoroutineName("encoder-inflate-writer")
-
 @OptIn(DelicateCoroutinesApi::class)
 private fun inflate(
     source: ByteReadChannel,
     gzip: Boolean = true,
     coroutineContext: CoroutineContext
-): ByteReadChannel = GlobalScope.writer(coroutineContext + InflateWriterCoroutineName) {
+): ByteReadChannel = GlobalScope.writer(coroutineContext) {
     val readBuffer = KtorDefaultPool.borrow()
     val writeBuffer = KtorDefaultPool.borrow()
-
     val inflater = Inflater(true)
     val checksum = CRC32()
 
@@ -124,6 +116,7 @@ private fun inflate(
         while (!source.isClosedForRead) {
             if (source.readAvailable(readBuffer) <= 0) continue
             readBuffer.flip()
+
             inflater.setInput(readBuffer.array(), readBuffer.position(), readBuffer.remaining())
 
             while (!inflater.needsInput() && !inflater.finished()) {
