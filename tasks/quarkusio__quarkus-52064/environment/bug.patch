diff --git a/core/deployment/src/main/java/io/quarkus/deployment/ExtensionLoader.java b/core/deployment/src/main/java/io/quarkus/deployment/ExtensionLoader.java
index 0a94f70ad76..c787a22d59c 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/ExtensionLoader.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/ExtensionLoader.java
@@ -223,7 +223,7 @@ public boolean canHandleObject(final Object obj, final boolean staticInit) {
                     }
                 };
 
-                proxies.put(ValueRegistry.class, ValueRegistryImpl.builder().build());
+                proxies.put(ValueRegistry.class, new ValueRegistryImpl.Builder().build());
                 ObjectLoader valueRegistryLoader = new ObjectLoader() {
                     @Override
                     public ResultHandle load(BytecodeCreator body, Object obj, boolean staticInit) {
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/builditem/RuntimeConfigSetupCompleteBuildItem.java b/core/deployment/src/main/java/io/quarkus/deployment/builditem/RuntimeConfigSetupCompleteBuildItem.java
index 4c343f309f7..0b105592cf3 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/builditem/RuntimeConfigSetupCompleteBuildItem.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/builditem/RuntimeConfigSetupCompleteBuildItem.java
@@ -3,12 +3,8 @@
 import io.quarkus.builder.item.EmptyBuildItem;
 
 /**
- * Marker used by Build Steps that consume runtime configuration to ensure that they run after the runtime config has
- * been set up.
- *
- * @deprecated this build item has no effect. The runtime config is now always set up before build steps execute. Build
- *             steps consuming this annotation can safely remove it.
+ * Marker used by Build Steps that consume runtime configuration to ensure that they run after the runtime config has been set
+ * up.
  */
-@Deprecated(forRemoval = true, since = "3.31")
 public final class RuntimeConfigSetupCompleteBuildItem extends EmptyBuildItem {
 }
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/builditem/ValueRegistryRuntimeInfoProviderBuildItem.java b/core/deployment/src/main/java/io/quarkus/deployment/builditem/ValueRegistryRuntimeInfoProviderBuildItem.java
deleted file mode 100644
index e09e0afea96..00000000000
--- a/core/deployment/src/main/java/io/quarkus/deployment/builditem/ValueRegistryRuntimeInfoProviderBuildItem.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package io.quarkus.deployment.builditem;
-
-import io.quarkus.builder.item.MultiBuildItem;
-import io.quarkus.registry.RuntimeInfoProvider;
-
-public final class ValueRegistryRuntimeInfoProviderBuildItem extends MultiBuildItem {
-    private final Class<? extends RuntimeInfoProvider> runtimeInfoProvider;
-
-    public ValueRegistryRuntimeInfoProviderBuildItem(Class<? extends RuntimeInfoProvider> runtimeInfoProvider) {
-        this.runtimeInfoProvider = runtimeInfoProvider;
-    }
-
-    public Class<? extends RuntimeInfoProvider> getRuntimeInfoProvider() {
-        return runtimeInfoProvider;
-    }
-}
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/steps/MainClassBuildStep.java b/core/deployment/src/main/java/io/quarkus/deployment/steps/MainClassBuildStep.java
index 6ef71ea0a7d..4cfa09b5f85 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/steps/MainClassBuildStep.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/steps/MainClassBuildStep.java
@@ -58,7 +58,6 @@
 import io.quarkus.deployment.builditem.RecordableConstructorBuildItem;
 import io.quarkus.deployment.builditem.StaticBytecodeRecorderBuildItem;
 import io.quarkus.deployment.builditem.SystemPropertyBuildItem;
-import io.quarkus.deployment.builditem.ValueRegistryRuntimeInfoProviderBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveClassBuildItem;
 import io.quarkus.deployment.builditem.nativeimage.ReflectiveFieldBuildItem;
 import io.quarkus.deployment.configuration.RunTimeConfigurationGenerator;
@@ -77,8 +76,6 @@
 import io.quarkus.gizmo.MethodDescriptor;
 import io.quarkus.gizmo.ResultHandle;
 import io.quarkus.gizmo.TryBlock;
-import io.quarkus.registry.RuntimeInfoProvider;
-import io.quarkus.registry.RuntimeInfoProvider.RuntimeSource;
 import io.quarkus.registry.ValueRegistry;
 import io.quarkus.runtime.Application;
 import io.quarkus.runtime.ExecutionModeManager;
@@ -89,7 +86,6 @@
 import io.quarkus.runtime.QuarkusApplication;
 import io.quarkus.runtime.StartupContext;
 import io.quarkus.runtime.StartupTask;
-import io.quarkus.runtime.ValueRegistryImpl.ConfigRuntimeSource;
 import io.quarkus.runtime.annotations.QuarkusMain;
 import io.quarkus.runtime.configuration.ConfigUtils;
 import io.quarkus.runtime.util.StepTiming;
@@ -128,10 +124,8 @@ public class MainClassBuildStep {
     private static final Type STRING_ARRAY = Type.create(DotName.createSimple(String[].class.getName()), Type.Kind.ARRAY);
 
     @BuildStep
-    void build(
-            List<StaticBytecodeRecorderBuildItem> staticInitTasks,
+    void build(List<StaticBytecodeRecorderBuildItem> staticInitTasks,
             List<ObjectSubstitutionBuildItem> substitutions,
-            List<ValueRegistryRuntimeInfoProviderBuildItem> runtimeInfoProviders,
             List<MainBytecodeRecorderBuildItem> mainMethod,
             List<SystemPropertyBuildItem> properties,
             List<GeneratedRuntimeSystemPropertyBuildItem> generatedRuntimeSystemProperties,
@@ -230,15 +224,6 @@ void build(
         mv = file.getMethodCreator("doStart", void.class, String[].class);
         mv.setModifiers(Modifier.PROTECTED | Modifier.FINAL);
 
-        startupContext = mv.readStaticField(scField.getFieldDescriptor());
-
-        // Register ValueRegistry with StartupContext, so it can be injected into Recorders
-        ResultHandle valueRegistry = mv
-                .invokeVirtualMethod(ofMethod(Application.class, "getValueRegistry", ValueRegistry.class), mv.getThis());
-        MethodDescriptor putValueInStartupContext = ofMethod(StartupContext.class, "putValue", void.class, String.class,
-                Object.class);
-        mv.invokeVirtualMethod(putValueInStartupContext, startupContext, mv.load(ValueRegistry.class.getName()), valueRegistry);
-
         // Make sure we set properties in doStartup as well. This is necessary because setting them in the static-init
         // sets them at build-time, on the host JVM, while SVM has substitutions for System. get/setProperty at
         // run-time which will never see those properties unless we also set them at run-time.
@@ -280,6 +265,7 @@ void build(
         }
 
         mv.invokeStaticMethod(ofMethod(Timing.class, "mainStarted", void.class));
+        startupContext = mv.readStaticField(scField.getFieldDescriptor());
 
         //now set the command line arguments
         mv.invokeVirtualMethod(
@@ -288,23 +274,16 @@ void build(
 
         mv.invokeStaticMethod(CONFIGURE_STEP_TIME_ENABLED);
 
+        // Register ValueRegistry
+        MethodDescriptor getValueRegistry = ofMethod(Application.class, "getValueRegistry", ValueRegistry.class);
+        ResultHandle valueRegistry = mv.invokeVirtualMethod(getValueRegistry, mv.getThis());
+        MethodDescriptor putValueInStartupContext = ofMethod(StartupContext.class, "putValue", void.class, String.class,
+                Object.class);
+        mv.invokeVirtualMethod(putValueInStartupContext, startupContext, mv.load(ValueRegistry.class.getName()),
+                valueRegistry);
+
         tryBlock = mv.tryBlock();
         tryBlock.invokeStaticMethod(CONFIGURE_STEP_TIME_START);
-
-        // Create Runtime Config and associate it with the current classloader
-        tryBlock.invokeStaticMethod(RunTimeConfigurationGenerator.C_CREATE_RUN_TIME_CONFIG, valueRegistry);
-
-        // Register RuntimeInfoProviders with ValueRegistry
-        for (ValueRegistryRuntimeInfoProviderBuildItem runtimeInfoProviderClass : runtimeInfoProviders) {
-            ResultHandle runtimeInfoProvider = tryBlock
-                    .newInstance(ofConstructor(runtimeInfoProviderClass.getRuntimeInfoProvider()));
-            tryBlock.invokeInterfaceMethod(
-                    ofMethod(RuntimeInfoProvider.class, "register", void.class, ValueRegistry.class, RuntimeSource.class),
-                    runtimeInfoProvider,
-                    valueRegistry,
-                    tryBlock.invokeStaticMethod(ofMethod(ConfigRuntimeSource.class, "runtimeSource", RuntimeSource.class)));
-        }
-
         for (MainBytecodeRecorderBuildItem holder : mainMethod) {
             writeRecordedBytecode(holder.getBytecodeRecorder(), holder.getGeneratedStartupContextClassName(), substitutions,
                     recordableConstructorBuildItems,
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/steps/RuntimeConfigSetupBuildStep.java b/core/deployment/src/main/java/io/quarkus/deployment/steps/RuntimeConfigSetupBuildStep.java
index 8257ca51987..949c3e4061a 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/steps/RuntimeConfigSetupBuildStep.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/steps/RuntimeConfigSetupBuildStep.java
@@ -1,18 +1,61 @@
 package io.quarkus.deployment.steps;
 
+import static io.quarkus.deployment.configuration.RunTimeConfigurationGenerator.C_CREATE_RUN_TIME_CONFIG;
+import static io.quarkus.gizmo.MethodDescriptor.ofMethod;
+
+import io.quarkus.deployment.GeneratedClassGizmoAdaptor;
 import io.quarkus.deployment.annotations.BuildProducer;
 import io.quarkus.deployment.annotations.BuildStep;
 import io.quarkus.deployment.annotations.Produce;
 import io.quarkus.deployment.builditem.GeneratedClassBuildItem;
 import io.quarkus.deployment.builditem.MainBytecodeRecorderBuildItem;
 import io.quarkus.deployment.builditem.RuntimeConfigSetupCompleteBuildItem;
+import io.quarkus.gizmo.ClassCreator;
+import io.quarkus.gizmo.ClassOutput;
+import io.quarkus.gizmo.MethodCreator;
+import io.quarkus.gizmo.MethodDescriptor;
+import io.quarkus.gizmo.ResultHandle;
+import io.quarkus.registry.ValueRegistry;
+import io.quarkus.runtime.StartupContext;
+import io.quarkus.runtime.StartupTask;
 
-@Deprecated(forRemoval = true, since = "3.31")
 public class RuntimeConfigSetupBuildStep {
+    private static final String RUNTIME_CONFIG_STARTUP_TASK_CLASS_NAME = "io.quarkus.deployment.steps.RuntimeConfigSetup";
+
+    /**
+     * Generates a StartupTask that sets up the final runtime configuration and thus runs before any StartupTask that uses
+     * runtime configuration.
+     * If there are recorders that produce a ConfigSourceProvider, these objects are used to set up the final runtime
+     * configuration
+     */
     @BuildStep
     @Produce(RuntimeConfigSetupCompleteBuildItem.class)
     void setupRuntimeConfig(
             BuildProducer<GeneratedClassBuildItem> generatedClass,
             BuildProducer<MainBytecodeRecorderBuildItem> mainBytecodeRecorder) {
+        ClassOutput classOutput = new GeneratedClassGizmoAdaptor(generatedClass, true);
+
+        try (ClassCreator clazz = ClassCreator.builder().classOutput(classOutput)
+                .className(RUNTIME_CONFIG_STARTUP_TASK_CLASS_NAME)
+                .interfaces(StartupTask.class).build()) {
+
+            try (MethodCreator method = clazz.getMethodCreator("deploy", void.class, StartupContext.class)) {
+                ResultHandle startupContext = method.getMethodParam(0);
+
+                method.invokeVirtualMethod(ofMethod(StartupContext.class, "setCurrentBuildStepName", void.class, String.class),
+                        startupContext, method.load("RuntimeConfigSetupBuildStep.setupRuntimeConfig"));
+
+                // Pass ValueRegistry to Config, so we can have a bridge and support querying runtime values directly
+                MethodDescriptor getValue = MethodDescriptor.ofMethod(StartupContext.class, "getValue", Object.class,
+                        String.class);
+                ResultHandle valueRegistry = method.invokeVirtualMethod(getValue, startupContext,
+                        method.load(ValueRegistry.class.getName()));
+
+                method.invokeStaticMethod(C_CREATE_RUN_TIME_CONFIG, valueRegistry);
+                method.returnValue(null);
+            }
+        }
+
+        mainBytecodeRecorder.produce(new MainBytecodeRecorderBuildItem(RUNTIME_CONFIG_STARTUP_TASK_CLASS_NAME));
     }
 }
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/steps/ValueRegistryProcessor.java b/core/deployment/src/main/java/io/quarkus/deployment/steps/ValueRegistryProcessor.java
index 1a281163143..86782c16bc1 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/steps/ValueRegistryProcessor.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/steps/ValueRegistryProcessor.java
@@ -1,24 +1,13 @@
 package io.quarkus.deployment.steps;
 
-import static io.quarkus.deployment.util.ServiceUtil.classNamesNamedIn;
-
-import io.quarkus.bootstrap.classloading.QuarkusClassLoader;
 import io.quarkus.deployment.annotations.BuildProducer;
 import io.quarkus.deployment.annotations.BuildStep;
-import io.quarkus.deployment.builditem.ValueRegistryRuntimeInfoProviderBuildItem;
+import io.quarkus.deployment.builditem.nativeimage.ServiceProviderBuildItem;
 import io.quarkus.registry.RuntimeInfoProvider;
 
 class ValueRegistryProcessor {
     @BuildStep
-    @SuppressWarnings("unchecked")
-    void discoverRuntimeInfos(BuildProducer<ValueRegistryRuntimeInfoProviderBuildItem> runtimeInfoProviders) throws Exception {
-        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
-        for (String service : classNamesNamedIn(classLoader, "META-INF/services/" + RuntimeInfoProvider.class.getName())) {
-            if (QuarkusClassLoader.isClassPresentAtRuntime(service)) {
-                Class<? extends RuntimeInfoProvider> provider = (Class<? extends RuntimeInfoProvider>) classLoader
-                        .loadClass(service);
-                runtimeInfoProviders.produce(new ValueRegistryRuntimeInfoProviderBuildItem(provider));
-            }
-        }
+    void serviceProvider(BuildProducer<ServiceProviderBuildItem> serviceProvider) {
+        serviceProvider.produce(ServiceProviderBuildItem.allProvidersFromClassPath(RuntimeInfoProvider.class.getName()));
     }
 }
diff --git a/core/runtime/src/main/java/io/quarkus/runtime/Application.java b/core/runtime/src/main/java/io/quarkus/runtime/Application.java
index bf6e83b9ba2..ca00b48f4dd 100644
--- a/core/runtime/src/main/java/io/quarkus/runtime/Application.java
+++ b/core/runtime/src/main/java/io/quarkus/runtime/Application.java
@@ -4,6 +4,7 @@
 import java.util.concurrent.locks.Condition;
 import java.util.concurrent.locks.Lock;
 
+import org.eclipse.microprofile.config.ConfigProvider;
 import org.eclipse.microprofile.config.spi.ConfigProviderResolver;
 import org.jboss.logging.Logger;
 import org.wildfly.common.lock.Locks;
@@ -13,6 +14,7 @@
 import io.quarkus.registry.ValueRegistry;
 import io.quarkus.runtime.shutdown.ShutdownRecorder;
 import io.smallrye.common.constraint.Assert;
+import io.smallrye.config.SmallRyeConfig;
 
 /**
  * The application base class, which is extended and implemented by a generated class which implements the application
@@ -57,7 +59,10 @@ public abstract class Application implements Closeable {
      */
     protected Application(boolean auxiliaryApplication) {
         this.auxiliaryApplication = auxiliaryApplication;
-        this.valueRegistry = ValueRegistryImpl.builder().build();
+        this.valueRegistry = new ValueRegistryImpl.Builder()
+                .addDiscoveredInfos()
+                .withRuntimeSource(ConfigProvider.getConfig().unwrap(SmallRyeConfig.class))
+                .build();
     }
 
     /**
diff --git a/core/runtime/src/main/java/io/quarkus/runtime/ValueRegistryImpl.java b/core/runtime/src/main/java/io/quarkus/runtime/ValueRegistryImpl.java
index a028aabdfa8..65534554d65 100644
--- a/core/runtime/src/main/java/io/quarkus/runtime/ValueRegistryImpl.java
+++ b/core/runtime/src/main/java/io/quarkus/runtime/ValueRegistryImpl.java
@@ -6,9 +6,6 @@
 import java.util.ServiceLoader;
 import java.util.concurrent.ConcurrentHashMap;
 
-import org.eclipse.microprofile.config.Config;
-import org.eclipse.microprofile.config.ConfigProvider;
-
 import io.quarkus.registry.RuntimeInfoProvider;
 import io.quarkus.registry.RuntimeInfoProvider.RuntimeSource;
 import io.quarkus.registry.ValueRegistry;
@@ -68,24 +65,22 @@ public RuntimeInfo<?> get(final String key) {
         return values.get(key);
     }
 
-    public static Builder builder() {
-        return new Builder();
-    }
-
     public static class Builder {
         private boolean discoverInfos;
         private final List<RuntimeSource> sources = new ArrayList<>();
 
-        private Builder() {
-        }
-
         public Builder addDiscoveredInfos() {
             this.discoverInfos = true;
             return this;
         }
 
         public Builder withRuntimeSource(final SmallRyeConfig config) {
-            this.sources.add(new ConfigRuntimeSource(config));
+            this.sources.add(new RuntimeSource() {
+                @Override
+                public <T> T get(RuntimeKey<T> key) {
+                    return config.getOptionalValue(key.key(), key.type()).orElse(null);
+                }
+            });
             return this;
         }
 
@@ -112,25 +107,4 @@ public <T> T get(RuntimeKey<T> key) {
             return valueRegistry;
         }
     }
-
-    public static class ConfigRuntimeSource implements RuntimeSource {
-        private final Config config;
-
-        ConfigRuntimeSource(Config config) {
-            this.config = config;
-        }
-
-        @Override
-        public <T> T get(RuntimeKey<T> key) {
-            return config.getOptionalValue(key.key(), key.type()).orElse(null);
-        }
-
-        public static RuntimeSource runtimeSource(Config config) {
-            return new ConfigRuntimeSource(config);
-        }
-
-        public static RuntimeSource runtimeSource() {
-            return new ConfigRuntimeSource(ConfigProvider.getConfig());
-        }
-    }
 }
diff --git a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/VertxHttpRecorder.java b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/VertxHttpRecorder.java
index 26057a75973..18ebe65a422 100644
--- a/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/VertxHttpRecorder.java
+++ b/extensions/vertx-http/runtime/src/main/java/io/quarkus/vertx/http/runtime/VertxHttpRecorder.java
@@ -862,20 +862,17 @@ private static CompletableFuture<String> initializeMainHttpServer(
 
         AtomicInteger connectionCount = new AtomicInteger();
 
-        // Note that a new HttpServer is created for each IO thread, but we only want register once,
+        // Note that a new HttpServer is created for each IO thread but we only want to fire the events (HttpServerStart etc.) once,
         // for the first server that started listening
         // See https://vertx.io/docs/vertx-core/java/#_server_sharing for more information
         AtomicBoolean startEventsFired = new AtomicBoolean();
-        AtomicBoolean registerHttpServer = new AtomicBoolean();
-        AtomicBoolean registerHttpsServer = new AtomicBoolean();
 
         vertx.deployVerticle(new Supplier<>() {
             @Override
             public Verticle get() {
-                return new WebDeploymentVerticle(
-                        httpMainServerOptions, httpMainSslServerOptions, httpMainDomainSocketOptions,
-                        launchMode, insecureRequestStrategy, connectionCount, registry, startEventsFired,
-                        httpBuildTimeConfig, httpConfig, registerHttpServer, registerHttpsServer);
+                return new WebDeploymentVerticle(httpMainServerOptions, httpMainSslServerOptions, httpMainDomainSocketOptions,
+                        launchMode, insecureRequestStrategy, connectionCount, registry, startEventsFired, httpBuildTimeConfig,
+                        httpConfig);
             }
         }, new DeploymentOptions().setInstances(ioThreads), new Handler<>() {
             @Override
@@ -1190,6 +1187,9 @@ public GracefulShutdownFilter createGracefulShutdownHandler() {
     }
 
     private static class WebDeploymentVerticle extends AbstractVerticle implements Resource {
+        private static final AtomicBoolean registerHttpServer = new AtomicBoolean();
+        private static final AtomicBoolean registerHttpsServer = new AtomicBoolean();
+
         private final TlsConfigurationRegistry registry;
         private HttpServer httpServer;
         private HttpServer httpsServer;
@@ -1205,8 +1205,6 @@ private static class WebDeploymentVerticle extends AbstractVerticle implements R
         private final VertxHttpBuildTimeConfig httpBuildTimeConfig;
         private final VertxHttpConfig httpConfig;
         private final ValueRegistry valueRegistry;
-        private final AtomicBoolean registerHttpServer;
-        private final AtomicBoolean registerHttpsServer;
 
         public WebDeploymentVerticle(
                 HttpServerOptions httpOptions,
@@ -1218,9 +1216,7 @@ public WebDeploymentVerticle(
                 TlsConfigurationRegistry registry,
                 AtomicBoolean startEventsFired,
                 VertxHttpBuildTimeConfig httpBuildTimeConfig,
-                VertxHttpConfig httpConfig,
-                AtomicBoolean registerHttpServer,
-                AtomicBoolean registerHttpsServer) {
+                VertxHttpConfig httpConfig) {
 
             this.httpOptions = httpOptions;
             this.httpsOptions = httpsOptions;
@@ -1232,10 +1228,8 @@ public WebDeploymentVerticle(
             this.registry = registry;
             this.startEventsFired = startEventsFired;
             this.httpBuildTimeConfig = httpBuildTimeConfig;
-            this.registerHttpServer = registerHttpServer;
-            this.registerHttpsServer = registerHttpsServer;
             this.valueRegistry = VertxHttpRecorder.valueRegistry != null ? VertxHttpRecorder.valueRegistry.getValue()
-                    : ValueRegistryImpl.builder().build();
+                    : new ValueRegistryImpl.Builder().build();
             if (CracSupport.isEnabled()) {
                 org.crac.Core.getGlobalContext().register(this);
             }
diff --git a/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusDevModeTest.java b/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusDevModeTest.java
index fc2654594da..2ce8d7dd000 100644
--- a/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusDevModeTest.java
+++ b/test-framework/junit-internal/src/main/java/io/quarkus/test/QuarkusDevModeTest.java
@@ -234,7 +234,7 @@ public <T> T interceptTestClassConstructor(Invocation<T> invocation,
             ExtensionContext extensionContext) throws Throwable {
         T actualTestInstance = invocation.proceed();
         // TODO - QuarkusDevModeTest does not read the actual port from the logs. We need to implement it
-        ValueRegistry valueRegistry = ValueRegistryImpl.builder().build();
+        ValueRegistry valueRegistry = new ValueRegistryImpl.Builder().build();
         valueRegistry.register(ListeningAddress.HTTP_TEST_PORT, 8080);
         TestHTTPResourceManager.inject(actualTestInstance, valueRegistry);
         return actualTestInstance;
diff --git a/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusIntegrationTestExtension.java b/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusIntegrationTestExtension.java
index c2305899f74..1638fa1aefc 100644
--- a/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusIntegrationTestExtension.java
+++ b/test-framework/junit/src/main/java/io/quarkus/test/junit/QuarkusIntegrationTestExtension.java
@@ -321,7 +321,7 @@ public void close() throws Exception {
 
             activateLogging();
             Optional<ListeningAddress> listeningAddress = startLauncher(launcher, additionalProperties);
-            ValueRegistry valueRegistry = ValueRegistryImpl.builder().addDiscoveredInfos()
+            ValueRegistry valueRegistry = new ValueRegistryImpl.Builder().addDiscoveredInfos()
                     .withRuntimeSource(new SmallRyeConfigBuilder()
                             .withSources(new MapBackedConfigSource("Test Properties", additionalProperties, MAX_VALUE) {
                             }).build())
