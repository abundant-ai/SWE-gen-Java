diff --git a/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedTestModeMain.java b/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedTestModeMain.java
index 199f116df55..d0e1765d84b 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedTestModeMain.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/dev/IsolatedTestModeMain.java
@@ -21,6 +21,7 @@
 import io.quarkus.deployment.dev.testing.TestHandler;
 import io.quarkus.deployment.dev.testing.TestSetupBuildItem;
 import io.quarkus.deployment.dev.testing.TestSupport;
+import io.quarkus.deployment.jvm.ResolvedJVMRequirements;
 import io.quarkus.deployment.logging.LoggingSetupBuildItem;
 import io.quarkus.deployment.steps.ClassTransformingBuildStep;
 import io.quarkus.dev.spi.DevModeType;
@@ -133,7 +134,8 @@ public void accept(CuratedApplication o, Map<String, Object> params) {
             }
             try {
                 augmentAction.performCustomBuild(TestHandler.class.getName(), null, TestSetupBuildItem.class.getName(),
-                        LoggingSetupBuildItem.class.getName(), ConsoleFormatterBannerBuildItem.class.getName());
+                        LoggingSetupBuildItem.class.getName(), ConsoleFormatterBannerBuildItem.class.getName(),
+                        ResolvedJVMRequirements.class.getName());
             } catch (Throwable t) {
                 //logging may not have been started, this is more reliable
                 System.err.println("Failed to start quarkus test mode");
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/dev/testing/TestHandler.java b/core/deployment/src/main/java/io/quarkus/deployment/dev/testing/TestHandler.java
index e56a57c7590..21de381d302 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/dev/testing/TestHandler.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/dev/testing/TestHandler.java
@@ -8,6 +8,8 @@
 import io.quarkus.banner.BannerConfig;
 import io.quarkus.builder.BuildResult;
 import io.quarkus.deployment.dev.testing.TestConfig.Mode;
+import io.quarkus.deployment.jvm.JvmModulesReconfigurer;
+import io.quarkus.deployment.jvm.ResolvedJVMRequirements;
 import io.quarkus.deployment.steps.BannerProcessor;
 import io.quarkus.dev.console.QuarkusConsole;
 import io.quarkus.runtime.BannerRecorder;
@@ -17,8 +19,16 @@
 import io.smallrye.config.SmallRyeConfig;
 
 public class TestHandler implements BiConsumer<Object, BuildResult> {
+
+    private static final JvmModulesReconfigurer jvmModulesReconfigurer = JvmModulesReconfigurer.getInstance();
+
     @Override
     public void accept(Object o, BuildResult buildResult) {
+        // Apply JVM module configuration for test mode (add-opens, etc.)
+        ResolvedJVMRequirements jvmRequirements = buildResult.consume(ResolvedJVMRequirements.class);
+        jvmRequirements.applyJavaModuleConfigurationToRuntime(jvmModulesReconfigurer,
+                Thread.currentThread().getContextClassLoader());
+
         QuarkusConsole.start();
         TestSupport.instance().get().start();
 
diff --git a/core/deployment/src/main/java/io/quarkus/deployment/jvm/JvmModulesReconfigurer.java b/core/deployment/src/main/java/io/quarkus/deployment/jvm/JvmModulesReconfigurer.java
index 5b31bc489ed..7f993b2e6ab 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/jvm/JvmModulesReconfigurer.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/jvm/JvmModulesReconfigurer.java
@@ -19,13 +19,21 @@ public interface JvmModulesReconfigurer {
     void openJavaModules(List<ModuleOpenBuildItem> addOpens, ModulesClassloaderContext referenceClassloader);
 
     /**
-     * Creates a new instance of {@link JvmModulesReconfigurer}.
-     * Initialization of such services is fairly costly: try
-     * to avoid it, and aim to reuse the produced instance.
-     *
-     * @return a new {@link JvmModulesReconfigurer} instance
+     * Thread-safe lazy holder for the singleton instance: this is expensive to create and tied to the JVM,
+     * so we like it to be lazy and shared.
      */
-    static JvmModulesReconfigurer create() {
+    final class Holder {
+        static final JvmModulesReconfigurer INSTANCE = JvmModulesReconfigurer.create();
+    }
+
+    /**
+     * @return the shared {@link JvmModulesReconfigurer} instance
+     */
+    static JvmModulesReconfigurer getInstance() {
+        return Holder.INSTANCE;
+    }
+
+    private static JvmModulesReconfigurer create() {
         final Logger logger = JVMDeploymentLogger.logger;
 
         //First thing to check, is if we have our agent connected; that would make things really simple and avoid any need
diff --git a/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java b/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java
index b10293dc93d..751ad55f4ec 100644
--- a/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java
+++ b/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java
@@ -69,7 +69,7 @@ public class StartupActionImpl implements StartupAction {
     private final List<Closeable> runtimeCloseTasks = new ArrayList<>();
     private final DevServicesRegistryBuildItem devServicesRegistry;
 
-    private static final JvmModulesReconfigurer jvmModulesReconfigurer = JvmModulesReconfigurer.create();
+    private static final JvmModulesReconfigurer jvmModulesReconfigurer = JvmModulesReconfigurer.getInstance();
 
     public StartupActionImpl(CuratedApplication curatedApplication, BuildResult buildResult) {
         this.curatedApplication = curatedApplication;
