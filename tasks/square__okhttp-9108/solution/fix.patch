diff --git a/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt b/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
index 948482c2c..0c06968c1 100644
--- a/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
+++ b/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
@@ -170,9 +170,6 @@ class TestValueFactory : Closeable {
       index = 0,
       exchange = null,
       request = call.request(),
-      connectTimeoutMillis = 10_000,
-      readTimeoutMillis = 10_000,
-      writeTimeoutMillis = 10_000,
     )
 
   fun newRoutePlanner(
diff --git a/okhttp/api/android/okhttp.api b/okhttp/api/android/okhttp.api
index ac992d1ad..5c2fb7b67 100644
--- a/okhttp/api/android/okhttp.api
+++ b/okhttp/api/android/okhttp.api
@@ -749,12 +749,42 @@ public abstract interface class okhttp3/Interceptor$Chain {
 	public abstract fun call ()Lokhttp3/Call;
 	public abstract fun connectTimeoutMillis ()I
 	public abstract fun connection ()Lokhttp3/Connection;
+	public abstract fun getAuthenticator ()Lokhttp3/Authenticator;
+	public abstract fun getCache ()Lokhttp3/Cache;
+	public abstract fun getCertificatePinner ()Lokhttp3/CertificatePinner;
+	public abstract fun getConnectionPool ()Lokhttp3/ConnectionPool;
+	public abstract fun getCookieJar ()Lokhttp3/CookieJar;
+	public abstract fun getDns ()Lokhttp3/Dns;
+	public abstract fun getEventListener ()Lokhttp3/EventListener;
+	public abstract fun getFollowRedirects ()Z
+	public abstract fun getFollowSslRedirects ()Z
+	public abstract fun getHostnameVerifier ()Ljavax/net/ssl/HostnameVerifier;
+	public abstract fun getProxy ()Ljava/net/Proxy;
+	public abstract fun getProxyAuthenticator ()Lokhttp3/Authenticator;
+	public abstract fun getProxySelector ()Ljava/net/ProxySelector;
+	public abstract fun getRetryOnConnectionFailure ()Z
+	public abstract fun getSocketFactory ()Ljavax/net/SocketFactory;
+	public abstract fun getSslSocketFactoryOrNull ()Ljavax/net/ssl/SSLSocketFactory;
+	public abstract fun getX509TrustManagerOrNull ()Ljavax/net/ssl/X509TrustManager;
 	public abstract fun proceed (Lokhttp3/Request;)Lokhttp3/Response;
 	public abstract fun readTimeoutMillis ()I
 	public abstract fun request ()Lokhttp3/Request;
-	public abstract fun withConnectTimeout (ILjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
-	public abstract fun withReadTimeout (ILjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
-	public abstract fun withWriteTimeout (ILjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withAuthenticator (Lokhttp3/Authenticator;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withCache (Lokhttp3/Cache;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withCertificatePinner (Lokhttp3/CertificatePinner;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withConnectTimeout (JLjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withConnectionPool (Lokhttp3/ConnectionPool;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withCookieJar (Lokhttp3/CookieJar;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withDns (Lokhttp3/Dns;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withHostnameVerifier (Ljavax/net/ssl/HostnameVerifier;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withProxy (Ljava/net/Proxy;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withProxyAuthenticator (Lokhttp3/Authenticator;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withProxySelector (Ljava/net/ProxySelector;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withReadTimeout (JLjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withRetryOnConnectionFailure (Z)Lokhttp3/Interceptor$Chain;
+	public abstract fun withSocketFactory (Ljavax/net/SocketFactory;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withSslSocketFactory (Ljavax/net/ssl/SSLSocketFactory;Ljavax/net/ssl/X509TrustManager;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withWriteTimeout (JLjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
 	public abstract fun writeTimeoutMillis ()I
 }
 
diff --git a/okhttp/api/jvm/okhttp.api b/okhttp/api/jvm/okhttp.api
index b6ef6340d..62eead9ba 100644
--- a/okhttp/api/jvm/okhttp.api
+++ b/okhttp/api/jvm/okhttp.api
@@ -749,12 +749,42 @@ public abstract interface class okhttp3/Interceptor$Chain {
 	public abstract fun call ()Lokhttp3/Call;
 	public abstract fun connectTimeoutMillis ()I
 	public abstract fun connection ()Lokhttp3/Connection;
+	public abstract fun getAuthenticator ()Lokhttp3/Authenticator;
+	public abstract fun getCache ()Lokhttp3/Cache;
+	public abstract fun getCertificatePinner ()Lokhttp3/CertificatePinner;
+	public abstract fun getConnectionPool ()Lokhttp3/ConnectionPool;
+	public abstract fun getCookieJar ()Lokhttp3/CookieJar;
+	public abstract fun getDns ()Lokhttp3/Dns;
+	public abstract fun getEventListener ()Lokhttp3/EventListener;
+	public abstract fun getFollowRedirects ()Z
+	public abstract fun getFollowSslRedirects ()Z
+	public abstract fun getHostnameVerifier ()Ljavax/net/ssl/HostnameVerifier;
+	public abstract fun getProxy ()Ljava/net/Proxy;
+	public abstract fun getProxyAuthenticator ()Lokhttp3/Authenticator;
+	public abstract fun getProxySelector ()Ljava/net/ProxySelector;
+	public abstract fun getRetryOnConnectionFailure ()Z
+	public abstract fun getSocketFactory ()Ljavax/net/SocketFactory;
+	public abstract fun getSslSocketFactoryOrNull ()Ljavax/net/ssl/SSLSocketFactory;
+	public abstract fun getX509TrustManagerOrNull ()Ljavax/net/ssl/X509TrustManager;
 	public abstract fun proceed (Lokhttp3/Request;)Lokhttp3/Response;
 	public abstract fun readTimeoutMillis ()I
 	public abstract fun request ()Lokhttp3/Request;
-	public abstract fun withConnectTimeout (ILjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
-	public abstract fun withReadTimeout (ILjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
-	public abstract fun withWriteTimeout (ILjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withAuthenticator (Lokhttp3/Authenticator;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withCache (Lokhttp3/Cache;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withCertificatePinner (Lokhttp3/CertificatePinner;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withConnectTimeout (JLjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withConnectionPool (Lokhttp3/ConnectionPool;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withCookieJar (Lokhttp3/CookieJar;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withDns (Lokhttp3/Dns;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withHostnameVerifier (Ljavax/net/ssl/HostnameVerifier;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withProxy (Ljava/net/Proxy;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withProxyAuthenticator (Lokhttp3/Authenticator;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withProxySelector (Ljava/net/ProxySelector;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withReadTimeout (JLjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withRetryOnConnectionFailure (Z)Lokhttp3/Interceptor$Chain;
+	public abstract fun withSocketFactory (Ljavax/net/SocketFactory;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withSslSocketFactory (Ljavax/net/ssl/SSLSocketFactory;Ljavax/net/ssl/X509TrustManager;)Lokhttp3/Interceptor$Chain;
+	public abstract fun withWriteTimeout (JLjava/util/concurrent/TimeUnit;)Lokhttp3/Interceptor$Chain;
 	public abstract fun writeTimeoutMillis ()I
 }
 
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Interceptor.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Interceptor.kt
index bfa1f5823..662bc51d3 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Interceptor.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/Interceptor.kt
@@ -16,7 +16,14 @@
 package okhttp3
 
 import java.io.IOException
+import java.net.Proxy
+import java.net.ProxySelector
 import java.util.concurrent.TimeUnit
+import javax.net.SocketFactory
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+import okhttp3.internal.tls.CertificateChainCleaner
 
 /**
  * Observes, modifies, and potentially short-circuits requests going out and the corresponding
@@ -82,31 +89,210 @@ fun interface Interceptor {
 
     /**
      * Returns the connection the request will be executed on. This is only available in the chains
-     * of network interceptors; for application interceptors this is always null.
+     * of network interceptors. For application interceptors this is always null.
      */
     fun connection(): Connection?
 
+    /**
+     * Returns the `Call` to which this chain belongs.
+     */
     fun call(): Call
 
+    /**
+     * Returns the connect timeout in milliseconds.
+     */
     fun connectTimeoutMillis(): Int
 
+    /**
+     * Returns a new chain with the specified connect timeout.
+     */
     fun withConnectTimeout(
-      timeout: Int,
+      timeout: Long,
       unit: TimeUnit,
     ): Chain
 
+    /**
+     * Returns the read timeout in milliseconds.
+     */
     fun readTimeoutMillis(): Int
 
+    /**
+     * Returns a new chain with the specified read timeout.
+     */
     fun withReadTimeout(
-      timeout: Int,
+      timeout: Long,
       unit: TimeUnit,
     ): Chain
 
+    /**
+     * Returns the write timeout in milliseconds.
+     */
     fun writeTimeoutMillis(): Int
 
+    /**
+     * Returns a new chain with the specified write timeout.
+     */
     fun withWriteTimeout(
-      timeout: Int,
+      timeout: Long,
       unit: TimeUnit,
     ): Chain
+
+    val followSslRedirects: Boolean
+
+    val followRedirects: Boolean
+
+    /**
+     * Get the [DNS] instance for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val dns: Dns
+
+    /**
+     * Override the [DNS] for the Call.Chain.
+     *
+     * @throws IllegalStateException if this is a Network Interceptor, since the override is too late.
+     */
+    fun withDns(dns: Dns): Chain
+
+    /**
+     * Returns the [SocketFactory] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val socketFactory: SocketFactory
+
+    /**
+     * Override the [SocketFactory] for the Call.Chain.
+     *
+     * @throws IllegalStateException if this is a Network Interceptor, since the override is too late.
+     */
+    fun withSocketFactory(socketFactory: SocketFactory): Chain
+
+    /**
+     * Returns true if the call should retry on connection failures.
+     */
+    val retryOnConnectionFailure: Boolean
+
+    /**
+     * Returns a new chain with the specified retry on connection failure setting.
+     */
+    fun withRetryOnConnectionFailure(retryOnConnectionFailure: Boolean): Chain
+
+    /**
+     * Returns the [Authenticator] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val authenticator: Authenticator
+
+    /**
+     * Override the [Authenticator] for the Call.Chain.
+     *
+     * @throws IllegalStateException if this is a Network Interceptor, since the override is too late.
+     */
+    fun withAuthenticator(authenticator: Authenticator): Chain
+
+    /**
+     * Returns the [CookieJar] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val cookieJar: CookieJar
+
+    /**
+     * Returns a new chain with the specified [CookieJar].
+     */
+    fun withCookieJar(cookieJar: CookieJar): Chain
+
+    /**
+     * Returns the [Cache] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val cache: Cache?
+
+    /**
+     * Override the [Cache] for the Call.Chain.
+     *
+     * @throws IllegalStateException if this is a Network Interceptor, since the override is too late.
+     */
+    fun withCache(cache: Cache?): Chain
+
+    /**
+     * Returns the [Proxy] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val proxy: Proxy?
+
+    /**
+     * Returns a new chain with the specified [Proxy].
+     */
+    fun withProxy(proxy: Proxy?): Chain
+
+    /**
+     * Returns the [ProxySelector] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val proxySelector: ProxySelector
+
+    /**
+     * Override the [ProxySelector] for the Call.Chain.
+     *
+     * @throws IllegalStateException if this is a Network Interceptor, since the override is too late.
+     */
+    fun withProxySelector(proxySelector: ProxySelector): Chain
+
+    /**
+     * Returns the proxy [Authenticator] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val proxyAuthenticator: Authenticator
+
+    /**
+     * Returns a new chain with the specified proxy [Authenticator].
+     */
+    fun withProxyAuthenticator(proxyAuthenticator: Authenticator): Chain
+
+    /**
+     * Returns the [SSLSocketFactory] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val sslSocketFactoryOrNull: SSLSocketFactory?
+
+    /**
+     * Returns a new chain with the specified [SSLSocketFactory].
+     *
+     * @throws IllegalStateException if this is a Network Interceptor, since the override is too late.
+     */
+    fun withSslSocketFactory(
+      sslSocketFactory: SSLSocketFactory?,
+      x509TrustManager: X509TrustManager?,
+    ): Chain
+
+    /**
+     * Returns the [X509TrustManager] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val x509TrustManagerOrNull: X509TrustManager?
+
+    /**
+     * Returns the [HostnameVerifier] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val hostnameVerifier: HostnameVerifier
+
+    /**
+     * Override the [HostnameVerifier] for the Call.Chain.
+     *
+     * @throws IllegalStateException if this is a Network Interceptor, since the override is too late.
+     */
+    fun withHostnameVerifier(hostnameVerifier: HostnameVerifier): Chain
+
+    /**
+     * Returns the [CertificatePinner] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val certificatePinner: CertificatePinner
+
+    /**
+     * Returns a new chain with the specified [CertificatePinner].
+     */
+    fun withCertificatePinner(certificatePinner: CertificatePinner): Chain
+
+    /**
+     * Returns the [ConnectionPool] for the OkHttpClient, or an override from the Call.Chain.
+     */
+    val connectionPool: ConnectionPool
+
+    /**
+     * Returns a new chain with the specified [ConnectionPool].
+     */
+    fun withConnectionPool(connectionPool: ConnectionPool): Chain
+
+    val eventListener: EventListener
   }
 }
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/OkHttpClient.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/OkHttpClient.kt
index 6ab5bcf7d..ebdcafad3 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/OkHttpClient.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/OkHttpClient.kt
@@ -201,7 +201,7 @@ open class OkHttpClient internal constructor(
   @get:JvmName("socketFactory")
   val socketFactory: SocketFactory = builder.socketFactory
 
-  private val sslSocketFactoryOrNull: SSLSocketFactory?
+  internal val sslSocketFactoryOrNull: SSLSocketFactory?
 
   @get:JvmName("sslSocketFactory")
   val sslSocketFactory: SSLSocketFactory
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/cache/CacheInterceptor.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/cache/CacheInterceptor.kt
index e76c977c2..4482f905b 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/cache/CacheInterceptor.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/cache/CacheInterceptor.kt
@@ -40,12 +40,11 @@ import okio.Timeout
 import okio.buffer
 
 /** Serves requests from the cache and writes responses to the cache. */
-class CacheInterceptor(
-  internal val call: RealCall,
-  internal val cache: Cache?,
-) : Interceptor {
+class CacheInterceptor : Interceptor {
   @Throws(IOException::class)
   override fun intercept(chain: Interceptor.Chain): Response {
+    val call = chain.call()
+    val cache = chain.cache
     val cacheCandidate = cache?.get(chain.request().requestForCache())
 
     val now = System.currentTimeMillis()
@@ -73,7 +72,7 @@ class CacheInterceptor(
         .receivedResponseAtMillis(System.currentTimeMillis())
         .build()
         .also {
-          call.eventListener.satisfactionFailure(call, it)
+          chain.eventListener.satisfactionFailure(call, it)
         }
     }
 
@@ -84,14 +83,14 @@ class CacheInterceptor(
         .cacheResponse(cacheResponse.stripBody())
         .build()
         .also {
-          call.eventListener.cacheHit(call, it)
+          chain.eventListener.cacheHit(call, it)
         }
     }
 
     if (cacheResponse != null) {
-      call.eventListener.cacheConditionalHit(call, cacheResponse)
+      chain.eventListener.cacheConditionalHit(call, cacheResponse)
     } else if (cache != null) {
-      call.eventListener.cacheMiss(call)
+      chain.eventListener.cacheMiss(call)
     }
 
     var networkResponse: Response? = null
@@ -124,7 +123,7 @@ class CacheInterceptor(
         cache!!.trackConditionalCacheHit()
         cache.update(cacheResponse, response)
         return response.also {
-          call.eventListener.cacheHit(call, it)
+          chain.eventListener.cacheHit(call, it)
         }
       } else {
         cacheResponse.body.closeQuietly()
@@ -147,7 +146,7 @@ class CacheInterceptor(
         return cacheWritingResponse(cacheRequest, response).also {
           if (cacheResponse != null) {
             // This will log a conditional cache miss only.
-            call.eventListener.cacheMiss(call)
+            chain.eventListener.cacheMiss(call)
           }
         }
       }
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
index e2a4f7381..9c7721fc5 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
@@ -209,9 +209,9 @@ class RealCall(
     // Build a full stack of interceptors.
     val interceptors = mutableListOf<Interceptor>()
     interceptors += client.interceptors
-    interceptors += RetryAndFollowUpInterceptor(client)
-    interceptors += BridgeInterceptor(client.cookieJar)
-    interceptors += CacheInterceptor(this, client.cache)
+    interceptors += RetryAndFollowUpInterceptor()
+    interceptors += BridgeInterceptor()
+    interceptors += CacheInterceptor()
     interceptors += ConnectInterceptor
     if (!forWebSocket) {
       interceptors += client.networkInterceptors
@@ -225,9 +225,6 @@ class RealCall(
         index = 0,
         exchange = null,
         request = originalRequest,
-        connectTimeoutMillis = client.connectTimeoutMillis,
-        readTimeoutMillis = client.readTimeoutMillis,
-        writeTimeoutMillis = client.writeTimeoutMillis,
       )
 
     var calledNoMoreExchanges = false
@@ -275,15 +272,15 @@ class RealCall(
       val routePlanner =
         RealRoutePlanner(
           taskRunner = client.taskRunner,
-          connectionPool = connectionPool,
-          readTimeoutMillis = client.readTimeoutMillis,
-          writeTimeoutMillis = client.writeTimeoutMillis,
+          connectionPool = chain.connectionPool.delegate,
+          readTimeoutMillis = chain.readTimeoutMillis,
+          writeTimeoutMillis = chain.writeTimeoutMillis,
           socketConnectTimeoutMillis = chain.connectTimeoutMillis,
           socketReadTimeoutMillis = chain.readTimeoutMillis,
           pingIntervalMillis = client.pingIntervalMillis,
-          retryOnConnectionFailure = client.retryOnConnectionFailure,
+          retryOnConnectionFailure = chain.retryOnConnectionFailure,
           fastFallback = client.fastFallback,
-          address = client.address(request.url),
+          address = chain.address(request.url),
           routeDatabase = client.routeDatabase,
           call = this,
           request = request,
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/BridgeInterceptor.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/BridgeInterceptor.kt
index e5ff80a89..3d0bfba56 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/BridgeInterceptor.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/BridgeInterceptor.kt
@@ -31,9 +31,7 @@ import okio.buffer
  * request. Then it proceeds to call the network. Finally it builds a user response from the network
  * response.
  */
-class BridgeInterceptor(
-  private val cookieJar: CookieJar,
-) : Interceptor {
+class BridgeInterceptor : Interceptor {
   @Throws(IOException::class)
   override fun intercept(chain: Interceptor.Chain): Response {
     val userRequest = chain.request()
@@ -72,7 +70,7 @@ class BridgeInterceptor(
       requestBuilder.header("Accept-Encoding", "gzip")
     }
 
-    val cookies = cookieJar.loadForRequest(userRequest.url)
+    val cookies = chain.cookieJar.loadForRequest(userRequest.url)
     if (cookies.isNotEmpty()) {
       requestBuilder.header("Cookie", cookieHeader(cookies))
     }
@@ -84,7 +82,7 @@ class BridgeInterceptor(
     val networkRequest = requestBuilder.build()
     val networkResponse = chain.proceed(networkRequest)
 
-    cookieJar.receiveHeaders(networkRequest.url, networkResponse.headers)
+    chain.cookieJar.receiveHeaders(networkRequest.url, networkResponse.headers)
 
     val responseBuilder =
       networkResponse
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RealInterceptorChain.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RealInterceptorChain.kt
index e0a294271..7cf3ff781 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RealInterceptorChain.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RealInterceptorChain.kt
@@ -16,15 +16,32 @@
 package okhttp3.internal.http
 
 import java.io.IOException
+import java.net.Proxy
+import java.net.ProxySelector
 import java.util.concurrent.TimeUnit
+import javax.net.SocketFactory
+import javax.net.ssl.HostnameVerifier
+import javax.net.ssl.SSLSocketFactory
+import javax.net.ssl.X509TrustManager
+import okhttp3.Address
+import okhttp3.Authenticator
+import okhttp3.Cache
 import okhttp3.Call
+import okhttp3.CertificatePinner
 import okhttp3.Connection
+import okhttp3.ConnectionPool
+import okhttp3.CookieJar
+import okhttp3.Dns
+import okhttp3.EventListener
+import okhttp3.HttpUrl
 import okhttp3.Interceptor
+import okhttp3.OkHttpClient
 import okhttp3.Request
 import okhttp3.Response
 import okhttp3.internal.checkDuration
 import okhttp3.internal.connection.Exchange
 import okhttp3.internal.connection.RealCall
+import okhttp3.internal.tls.CertificateChainCleaner
 
 /**
  * A concrete interceptor chain that carries the entire interceptor chain: all application
@@ -42,7 +59,55 @@ class RealInterceptorChain(
   internal val connectTimeoutMillis: Int,
   internal val readTimeoutMillis: Int,
   internal val writeTimeoutMillis: Int,
+  override val authenticator: Authenticator,
+  override val cache: Cache?,
+  override val certificatePinner: CertificatePinner,
+  override val connectionPool: ConnectionPool,
+  override val cookieJar: CookieJar,
+  override val dns: Dns,
+  override val hostnameVerifier: HostnameVerifier,
+  override val proxy: Proxy?,
+  override val proxyAuthenticator: Authenticator,
+  override val proxySelector: ProxySelector,
+  override val retryOnConnectionFailure: Boolean,
+  override val socketFactory: SocketFactory,
+  override val sslSocketFactoryOrNull: SSLSocketFactory?,
+  override val x509TrustManagerOrNull: X509TrustManager?,
+  val certificateChainCleaner: CertificateChainCleaner?,
 ) : Interceptor.Chain {
+  internal constructor(
+    call: RealCall,
+    interceptors: List<Interceptor>,
+    index: Int,
+    exchange: Nothing?,
+    request: Request,
+    client: OkHttpClient = call.client,
+  ) : this(
+    call,
+    interceptors,
+    index,
+    exchange,
+    request,
+    client.connectTimeoutMillis,
+    client.readTimeoutMillis,
+    client.writeTimeoutMillis,
+    client.authenticator,
+    client.cache,
+    client.certificatePinner,
+    client.connectionPool,
+    client.cookieJar,
+    client.dns,
+    client.hostnameVerifier,
+    client.proxy,
+    client.proxyAuthenticator,
+    client.proxySelector,
+    client.retryOnConnectionFailure,
+    client.socketFactory,
+    client.sslSocketFactoryOrNull,
+    client.x509TrustManager,
+    client.certificateChainCleaner,
+  )
+
   private var calls: Int = 0
 
   internal fun copy(
@@ -52,6 +117,21 @@ class RealInterceptorChain(
     connectTimeoutMillis: Int = this.connectTimeoutMillis,
     readTimeoutMillis: Int = this.readTimeoutMillis,
     writeTimeoutMillis: Int = this.writeTimeoutMillis,
+    authenticator: Authenticator = this.authenticator,
+    cache: Cache? = this.cache,
+    certificatePinner: CertificatePinner = this.certificatePinner,
+    connectionPool: ConnectionPool = this.connectionPool,
+    cookieJar: CookieJar = this.cookieJar,
+    dns: Dns = this.dns,
+    hostnameVerifier: HostnameVerifier = this.hostnameVerifier,
+    proxy: Proxy? = this.proxy,
+    proxyAuthenticator: Authenticator = this.proxyAuthenticator,
+    proxySelector: ProxySelector = this.proxySelector,
+    retryOnConnectionFailure: Boolean = this.retryOnConnectionFailure,
+    socketFactory: SocketFactory = this.socketFactory,
+    sslSocketFactory: SSLSocketFactory? = this.sslSocketFactoryOrNull,
+    x509TrustManager: X509TrustManager? = this.x509TrustManagerOrNull,
+    certificateChainCleaner: CertificateChainCleaner? = this.certificateChainCleaner,
   ) = RealInterceptorChain(
     call,
     interceptors,
@@ -61,41 +141,167 @@ class RealInterceptorChain(
     connectTimeoutMillis,
     readTimeoutMillis,
     writeTimeoutMillis,
+    authenticator,
+    cache,
+    certificatePinner,
+    connectionPool,
+    cookieJar,
+    dns,
+    hostnameVerifier,
+    proxy,
+    proxyAuthenticator,
+    proxySelector,
+    retryOnConnectionFailure,
+    socketFactory,
+    sslSocketFactory,
+    x509TrustManager,
+    certificateChainCleaner,
   )
 
+  override val eventListener: EventListener
+    get() = call.eventListener
+
+  override val followSslRedirects: Boolean
+    get() = call.client.followSslRedirects
+
+  override val followRedirects: Boolean
+    get() = call.client.followRedirects
+
   override fun connection(): Connection? = exchange?.connection
 
   override fun connectTimeoutMillis(): Int = connectTimeoutMillis
 
   override fun withConnectTimeout(
-    timeout: Int,
+    timeout: Long,
     unit: TimeUnit,
   ): Interceptor.Chain {
     check(exchange == null) { "Timeouts can't be adjusted in a network interceptor" }
 
-    return copy(connectTimeoutMillis = checkDuration("connectTimeout", timeout.toLong(), unit))
+    return copy(connectTimeoutMillis = checkDuration("connectTimeout", timeout, unit))
   }
 
   override fun readTimeoutMillis(): Int = readTimeoutMillis
 
   override fun withReadTimeout(
-    timeout: Int,
+    timeout: Long,
     unit: TimeUnit,
   ): Interceptor.Chain {
     check(exchange == null) { "Timeouts can't be adjusted in a network interceptor" }
 
-    return copy(readTimeoutMillis = checkDuration("readTimeout", timeout.toLong(), unit))
+    return copy(readTimeoutMillis = checkDuration("readTimeout", timeout, unit))
   }
 
   override fun writeTimeoutMillis(): Int = writeTimeoutMillis
 
   override fun withWriteTimeout(
-    timeout: Int,
+    timeout: Long,
     unit: TimeUnit,
   ): Interceptor.Chain {
     check(exchange == null) { "Timeouts can't be adjusted in a network interceptor" }
 
-    return copy(writeTimeoutMillis = checkDuration("writeTimeout", timeout.toLong(), unit))
+    return copy(writeTimeoutMillis = checkDuration("writeTimeout", timeout, unit))
+  }
+
+  override fun withDns(dns: Dns): Interceptor.Chain {
+    check(exchange == null) { "dns can't be adjusted in a network interceptor" }
+
+    return copy(dns = dns)
+  }
+
+  override fun withSocketFactory(socketFactory: SocketFactory): Interceptor.Chain {
+    check(exchange == null) { "socketFactory can't be adjusted in a network interceptor" }
+
+    return copy(socketFactory = socketFactory)
+  }
+
+  override fun withRetryOnConnectionFailure(retryOnConnectionFailure: Boolean): Interceptor.Chain {
+    check(exchange == null) { "retryOnConnectionFailure can't be adjusted in a network interceptor" }
+
+    return copy(retryOnConnectionFailure = retryOnConnectionFailure)
+  }
+
+  override fun withAuthenticator(authenticator: Authenticator): Interceptor.Chain {
+    check(exchange == null) { "authenticator can't be adjusted in a network interceptor" }
+
+    return copy(authenticator = authenticator)
+  }
+
+  override fun withCookieJar(cookieJar: CookieJar): Interceptor.Chain {
+    check(exchange == null) { "cookieJar can't be adjusted in a network interceptor" }
+
+    return copy(cookieJar = cookieJar)
+  }
+
+  override fun withCache(cache: Cache?): Interceptor.Chain {
+    check(exchange == null) { "cache can't be adjusted in a network interceptor" }
+
+    return copy(cache = cache)
+  }
+
+  override fun withProxy(proxy: Proxy?): Interceptor.Chain {
+    check(exchange == null) { "proxy can't be adjusted in a network interceptor" }
+
+    return copy(proxy = proxy)
+  }
+
+  override fun withProxySelector(proxySelector: ProxySelector): Interceptor.Chain {
+    check(exchange == null) { "proxySelector can't be adjusted in a network interceptor" }
+
+    return copy(proxySelector = proxySelector)
+  }
+
+  override fun withProxyAuthenticator(proxyAuthenticator: Authenticator): Interceptor.Chain {
+    check(exchange == null) { "proxyAuthenticator can't be adjusted in a network interceptor" }
+
+    return copy(proxyAuthenticator = proxyAuthenticator)
+  }
+
+  override fun withSslSocketFactory(
+    sslSocketFactory: SSLSocketFactory?,
+    x509TrustManager: X509TrustManager?,
+  ): Interceptor.Chain {
+    check(exchange == null) { "sslSocketFactory can't be adjusted in a network interceptor" }
+
+    if (sslSocketFactory != null && x509TrustManager != null) {
+      val newCertificateChainCleaner = CertificateChainCleaner.get(x509TrustManager)
+      return copy(
+        sslSocketFactory = sslSocketFactory,
+        x509TrustManager = x509TrustManager,
+        certificateChainCleaner = newCertificateChainCleaner,
+        certificatePinner = certificatePinner.withCertificateChainCleaner(newCertificateChainCleaner),
+      )
+    } else {
+      return copy(
+        sslSocketFactory = null,
+        x509TrustManager = null,
+        certificateChainCleaner = null,
+      )
+    }
+  }
+
+  override fun withHostnameVerifier(hostnameVerifier: HostnameVerifier): Interceptor.Chain {
+    check(exchange == null) { "hostnameVerifier can't be adjusted in a network interceptor" }
+
+    return copy(hostnameVerifier = hostnameVerifier)
+  }
+
+  override fun withCertificatePinner(certificatePinner: CertificatePinner): Interceptor.Chain {
+    check(exchange == null) { "certificatePinner can't be adjusted in a network interceptor" }
+
+    val newCertificatePinner =
+      if (certificateChainCleaner != null) {
+        certificatePinner.withCertificateChainCleaner(certificateChainCleaner)
+      } else {
+        certificatePinner
+      }
+
+    return copy(certificatePinner = newCertificatePinner)
+  }
+
+  override fun withConnectionPool(connectionPool: ConnectionPool): Interceptor.Chain {
+    check(exchange == null) { "connectionPool can't be adjusted in a network interceptor" }
+
+    return copy(connectionPool = connectionPool)
   }
 
   override fun call(): Call = call
@@ -135,4 +341,34 @@ class RealInterceptorChain(
 
     return response
   }
+
+  /**
+   * Creates an [Address] of out of the provided [HttpUrl]
+   * that uses this clientâ€™s DNS, TLS, and proxy configuration.
+   */
+  fun address(url: HttpUrl): Address {
+    var useSslSocketFactory: SSLSocketFactory? = null
+    var useHostnameVerifier: HostnameVerifier? = null
+    var useCertificatePinner: CertificatePinner? = null
+    if (url.isHttps) {
+      useSslSocketFactory = this.sslSocketFactoryOrNull
+      useHostnameVerifier = this.hostnameVerifier
+      useCertificatePinner = this.certificatePinner
+    }
+
+    return Address(
+      uriHost = url.host,
+      uriPort = url.port,
+      dns = dns,
+      socketFactory = socketFactory,
+      sslSocketFactory = useSslSocketFactory,
+      hostnameVerifier = useHostnameVerifier,
+      certificatePinner = useCertificatePinner,
+      proxyAuthenticator = proxyAuthenticator,
+      proxy = proxy,
+      protocols = call.client.protocols,
+      connectionSpecs = call.client.connectionSpecs,
+      proxySelector = proxySelector,
+    )
+  }
 }
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
index d4ab34b05..a28ea5bf6 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/RetryAndFollowUpInterceptor.kt
@@ -48,9 +48,7 @@ import okhttp3.internal.withSuppressed
  * This interceptor recovers from failures and follows redirects as necessary. It may throw an
  * [IOException] if the call was canceled.
  */
-class RetryAndFollowUpInterceptor(
-  private val client: OkHttpClient,
-) : Interceptor {
+class RetryAndFollowUpInterceptor : Interceptor {
   @Throws(IOException::class)
   override fun intercept(chain: Interceptor.Chain): Response {
     val realChain = chain as RealInterceptorChain
@@ -75,7 +73,7 @@ class RetryAndFollowUpInterceptor(
           newRoutePlanner = true
         } catch (e: IOException) {
           // An attempt to communicate with a server failed. The request may have been sent.
-          val isRecoverable = recover(e, call, request)
+          val isRecoverable = recover(e, call, chain, request)
           call.eventListener.retryDecision(call, e, isRecoverable)
           if (!isRecoverable) throw e.withSuppressed(recoveredFailures)
           recoveredFailures += e
@@ -92,7 +90,7 @@ class RetryAndFollowUpInterceptor(
             .build()
 
         val exchange = call.interceptorScopedExchange
-        val followUp = followUpRequest(response, exchange)
+        val followUp = followUpRequest(response, exchange, chain)
 
         if (followUp == null) {
           if (exchange != null && exchange.isDuplex) {
@@ -135,12 +133,13 @@ class RetryAndFollowUpInterceptor(
   private fun recover(
     e: IOException,
     call: RealCall,
+    chain: Interceptor.Chain,
     userRequest: Request,
   ): Boolean {
     val requestSendStarted = e !is ConnectionShutdownException
 
     // The application layer has forbidden retries.
-    if (!client.retryOnConnectionFailure) return false
+    if (!chain.retryOnConnectionFailure) return false
 
     // We can't send the request body again.
     if (requestSendStarted && requestIsOneShot(e, userRequest)) return false
@@ -207,6 +206,7 @@ class RetryAndFollowUpInterceptor(
   private fun followUpRequest(
     userResponse: Response,
     exchange: Exchange?,
+    chain: Interceptor.Chain,
   ): Request? {
     val route = exchange?.connection?.route()
     val responseCode = userResponse.code
@@ -218,20 +218,20 @@ class RetryAndFollowUpInterceptor(
         if (selectedProxy.type() != Proxy.Type.HTTP) {
           throw ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy")
         }
-        return client.proxyAuthenticator.authenticate(route, userResponse)
+        return chain.proxyAuthenticator.authenticate(route, userResponse)
       }
 
-      HTTP_UNAUTHORIZED -> return client.authenticator.authenticate(route, userResponse)
+      HTTP_UNAUTHORIZED -> return chain.authenticator.authenticate(route, userResponse)
 
       HTTP_PERM_REDIRECT, HTTP_TEMP_REDIRECT, HTTP_MULT_CHOICE, HTTP_MOVED_PERM, HTTP_MOVED_TEMP, HTTP_SEE_OTHER -> {
-        return buildRedirectRequest(userResponse, method)
+        return buildRedirectRequest(userResponse, method, chain)
       }
 
       HTTP_CLIENT_TIMEOUT -> {
         // 408's are rare in practice, but some servers like HAProxy use this response code. The
         // spec says that we may repeat the request without modifications. Modern browsers also
         // repeat the request (even non-idempotent ones.)
-        if (!client.retryOnConnectionFailure) {
+        if (!chain.retryOnConnectionFailure) {
           // The application layer has directed us not to retry the request.
           return null
         }
@@ -292,9 +292,10 @@ class RetryAndFollowUpInterceptor(
   private fun buildRedirectRequest(
     userResponse: Response,
     method: String,
+    chain: Interceptor.Chain,
   ): Request? {
     // Does the client allow redirects?
-    if (!client.followRedirects) return null
+    if (!chain.followRedirects) return null
 
     val location = userResponse.header("Location") ?: return null
     // Don't follow redirects to unsupported protocols.
@@ -302,7 +303,7 @@ class RetryAndFollowUpInterceptor(
 
     // If configured, don't follow redirects between SSL and non-SSL.
     val sameScheme = url.scheme == userResponse.request.url.scheme
-    if (!sameScheme && !client.followSslRedirects) return null
+    if (!sameScheme && !chain.followSslRedirects) return null
 
     // Most redirects don't include a request body.
     val requestBuilder = userResponse.request.newBuilder()
