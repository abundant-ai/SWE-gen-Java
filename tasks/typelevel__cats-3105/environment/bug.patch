diff --git a/PULL_REQUEST_TEMPLATE.md b/PULL_REQUEST_TEMPLATE.md
index 172e3122b..053efff25 100644
--- a/PULL_REQUEST_TEMPLATE.md
+++ b/PULL_REQUEST_TEMPLATE.md
@@ -1,5 +1,5 @@
 Thank you for contributing to Cats!
 
-This is a kind reminder to run `sbt +prePR` and commit the changed files, if any, before submitting. 
+This is a kind reminder to run `sbt prePR` and commit the changed files, if any, before submitting. 
 
 
diff --git a/core/src/main/scala-2.13+/cats/instances/lazyList.scala b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
index 9e9c344a9..6c4e08354 100644
--- a/core/src/main/scala-2.13+/cats/instances/lazyList.scala
+++ b/core/src/main/scala-2.13+/cats/instances/lazyList.scala
@@ -8,8 +8,7 @@ import cats.data.ZipLazyList
 import scala.annotation.tailrec
 
 trait LazyListInstances extends cats.kernel.instances.LazyListInstances {
-  implicit val catsStdInstancesForLazyList
-    : Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] =
+  implicit val catsStdInstancesForLazyList: Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] =
     new Traverse[LazyList] with Alternative[LazyList] with Monad[LazyList] with CoflatMap[LazyList] {
 
       def empty[A]: LazyList[A] = LazyList.empty
diff --git a/core/src/main/scala-2.13+/cats/instances/stream.scala b/core/src/main/scala-2.13+/cats/instances/stream.scala
index fb313600e..df1c6feae 100644
--- a/core/src/main/scala-2.13+/cats/instances/stream.scala
+++ b/core/src/main/scala-2.13+/cats/instances/stream.scala
@@ -9,8 +9,7 @@ import scala.annotation.tailrec
 trait StreamInstances extends cats.kernel.instances.StreamInstances {
 
   @deprecated("Use cats.instances.lazyList", "2.0.0-RC2")
-  implicit val catsStdInstancesForStream
-    : Traverse[Stream] with Alternative[Stream] with Monad[Stream] with CoflatMap[Stream] =
+  implicit val catsStdInstancesForStream: Traverse[Stream] with Alternative[Stream] with Monad[Stream] with CoflatMap[Stream] =
     new Traverse[Stream] with Alternative[Stream] with Monad[Stream] with CoflatMap[Stream] {
 
       def empty[A]: Stream[A] = Stream.Empty
diff --git a/project/KernelBoiler.scala b/project/KernelBoiler.scala
index e0412152e..105e12dba 100644
--- a/project/KernelBoiler.scala
+++ b/project/KernelBoiler.scala
@@ -201,6 +201,12 @@ object KernelBoiler {
                   .mkString(s"$tupleNHeader(", ", ", ")")}.hashCode()
                     def eqv(x: ${`(A..N)`}, y: ${`(A..N)`}): Boolean = ${binMethod("eqv").mkString(" && ")}
                   }
+
+                implicit def catsKernelStdPartialOrderForTuple${arity}[${`A..N`}](implicit ${constraints("PartialOrder")}): PartialOrder[${`(A..N)`}] =
+                  new PartialOrder[${`(A..N)`}] {
+                    def partialCompare(x: ${`(A..N)`}, y: ${`(A..N)`}): Double =
+                      ${binMethod("partialCompare").mkString("Array(", ", ", ")")}.find(_ != 0.0).getOrElse(0.0)
+                }
         """
             }
         ),
@@ -211,12 +217,6 @@ object KernelBoiler {
               import tv._
               def content =
                 block"""
-                implicit def catsKernelStdPartialOrderForTuple${arity}[${`A..N`}](implicit ${constraints("PartialOrder")}): PartialOrder[${`(A..N)`}] =
-                  new PartialOrder[${`(A..N)`}] {
-                    def partialCompare(x: ${`(A..N)`}, y: ${`(A..N)`}): Double =
-                      ${binMethod("partialCompare").mkString("Array(", ", ", ")")}.find(_ != 0.0).getOrElse(0.0)
-                }
-
                 implicit def catsKernelStdBandForTuple${arity}[${`A..N`}](implicit ${constraints("Band")}): Band[${`(A..N)`}] =
                   new Band[${`(A..N)`}] {
                     def combine(x: ${`(A..N)`}, y: ${`(A..N)`}): ${`(A..N)`} = ${binTuple("combine")}
diff --git a/tests/src/test/scala-2.13+/cats/tests/LazyListSuite.scala b/tests/src/test/scala-2.13+/cats/tests/LazyListSuite.scala
index b8d56f6f1..171f89a34 100644
--- a/tests/src/test/scala-2.13+/cats/tests/LazyListSuite.scala
+++ b/tests/src/test/scala-2.13+/cats/tests/LazyListSuite.scala
@@ -1,16 +1,7 @@
 package cats
 package tests
 
-import cats.laws.discipline.{
-  AlternativeTests,
-  CoflatMapTests,
-  CommutativeApplyTests,
-  MonadTests,
-  SemigroupalTests,
-  SerializableTests,
-  TraverseFilterTests,
-  TraverseTests
-}
+import cats.laws.discipline.{AlternativeTests, CoflatMapTests, CommutativeApplyTests, MonadTests, SemigroupalTests, SerializableTests, TraverseFilterTests, TraverseTests}
 import cats.data.ZipLazyList
 import cats.laws.discipline.arbitrary._
 import org.scalatest.funsuite.AnyFunSuiteLike
diff --git a/tests/src/test/scala/cats/tests/EqSuite.scala b/tests/src/test/scala/cats/tests/EqSuite.scala
index 1b483010d..6898df582 100644
--- a/tests/src/test/scala/cats/tests/EqSuite.scala
+++ b/tests/src/test/scala/cats/tests/EqSuite.scala
@@ -6,8 +6,6 @@ import cats.laws.discipline.{ContravariantMonoidalTests, MiniInt}
 import cats.laws.discipline.arbitrary._
 import cats.laws.discipline.eq._
 
-import scala.collection.immutable.Queue
-
 class EqSuite extends CatsSuite {
   Invariant[Eq]
   Contravariant[Eq]
@@ -17,24 +15,4 @@ class EqSuite extends CatsSuite {
   checkAll("Eq", ContravariantMonoidalTests[Eq].contravariantMonoidal[MiniInt, Boolean, Boolean])
   checkAll("ContravariantMonoidal[Eq]", SerializableTests.serializable(ContravariantMonoidal[Eq]))
 
-  test("The Eq instance for tuples of A is not ambiguous when A has a Hash and a PartialOrder") {
-
-    import cats.kernel.{Hash, PartialOrder}
-
-    trait A
-    implicit def po: PartialOrder[A] = ???
-    implicit def ho: Hash[A] = ???
-
-    lazy val a2 = implicitly[Eq[(A, A)]]
-    lazy val b2 = implicitly[Eq[(List[A], List[A])]]
-    lazy val c2 = implicitly[Eq[(Set[A], Set[A])]]
-    lazy val d2 = implicitly[Eq[(Vector[A], Vector[A])]]
-    lazy val e2 = implicitly[Eq[(Queue[A], Queue[A])]]
-
-    lazy val a3 = implicitly[Eq[(A, A, A)]]
-    lazy val b3 = implicitly[Eq[(List[A], List[A], List[A])]]
-    lazy val c3 = implicitly[Eq[(Set[A], Set[A], Set[A])]]
-    lazy val d3 = implicitly[Eq[(Vector[A], Vector[A], Vector[A])]]
-    lazy val e3 = implicitly[Eq[(Queue[A], Queue[A], Queue[A])]]
-  }
 }
