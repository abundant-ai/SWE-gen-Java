diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index d9cf31564..cc7b58e43 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -191,10 +191,6 @@ Kenneth Jorgensen (@kennethjor)
   `@JsonDeserialize.builderPrefix` property
   [3.1.0]
 
-D치vid Cs치kv치ri (@dodie)
- * Requested #3079: Support `ObjectMapper.updateValue()` for Record classes
-  [3.1.0]
-
 Lee Jiwon (@dlwldnjs1009)
  * Fixed #3188: Skip unknown `Enum` keys in `Map` deserialization
   [3.1.0]
diff --git a/release-notes/VERSION b/release-notes/VERSION
index b4e7413e4..36bae998a 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -58,8 +58,6 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #2686: `@JsonBackReference` does not work with a builder
  (reported by @janrieke)
  (fix by @JacksonJang)
-#3079: Support `ObjectMapper.updateValue()` for Record classes
- (requested by D치vid C)
 #3188: Skip unknown `Enum` keys in `Map` deserialization
  (requested by @matthias-mueller)
  (fixed by Lee Jiwon)
diff --git a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
index 8e4901955..fe502627e 100644
--- a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
@@ -1,7 +1,5 @@
 package tools.jackson.databind.deser.bean;
 
-import java.lang.reflect.Method;
-import java.lang.reflect.RecordComponent;
 import java.util.*;
 
 import tools.jackson.core.*;
@@ -252,10 +250,6 @@ public class BeanDeserializer
         if (_injectables != null) {
             injectValues(ctxt, bean);
         }
-        // [databind#3079]: Records are immutable, need to construct a new instance
-        if (_beanType.isRecordType() && _propertyBasedCreator != null) {
-            return _deserializeRecordForUpdate(p, ctxt, bean);
-        }
         if (_unwrappedPropertyHandler != null) {
             return deserializeWithUnwrapped(p, ctxt, bean);
         }
@@ -303,120 +297,6 @@ public class BeanDeserializer
         return bean;
     }
 
-    /**
-     * Helper method for handling "update" deserialization for Record types
-     * (which are immutable and require constructing a new instance).
-     *<p>
-     * Pre-populates creator properties from the existing Record, then
-     * overrides with values from JSON input, and constructs a new Record instance.
-     *
-     * @since 3.1
-     */
-    protected Object _deserializeRecordForUpdate(JsonParser p,
-            DeserializationContext ctxt, Object existingRecord)
-        throws JacksonException
-    {
-        final PropertyBasedCreator creator = _propertyBasedCreator;
-        PropertyValueBuffer buffer = (_anySetter != null)
-            ? creator.startBuildingWithAnySetter(p, ctxt, _objectIdReader, _anySetter)
-            : creator.startBuilding(p, ctxt, _objectIdReader);
-
-        // Step 1: Pre-populate buffer from existing Record values
-        final Class<?> recordClass = _beanType.getRawClass();
-        final RecordComponent[] components = recordClass.getRecordComponents();
-        for (SettableBeanProperty creatorProp : creator.properties()) {
-            final int creatorIndex = creatorProp.getCreatorIndex();
-            if (creatorIndex >= 0 && creatorIndex < components.length) {
-                try {
-                    Method accessor = components[creatorIndex].getAccessor();
-                    Object value = accessor.invoke(existingRecord);
-                    buffer.assignParameter(creatorProp, value);
-                } catch (Exception e) {
-                    throw wrapAndThrow(e, recordClass, creatorProp.getName(), ctxt);
-                }
-            }
-        }
-
-        // Step 2: Parse JSON input, overriding pre-populated values
-        String propName;
-        if (p.isExpectedStartObjectToken()) {
-            propName = p.nextName();
-            if (propName == null) {
-                // Empty object: just build from pre-populated values
-                return _buildRecordFromBuffer(ctxt, creator, buffer);
-            }
-        } else if (p.hasTokenId(JsonTokenId.ID_PROPERTY_NAME)) {
-            propName = p.currentName();
-        } else {
-            // No properties to process: build from pre-populated values
-            return _buildRecordFromBuffer(ctxt, creator, buffer);
-        }
-
-        do {
-            p.nextToken(); // to point to value
-            final SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);
-            if (creatorProp != null) {
-                // Override the pre-populated value
-                buffer.assignParameter(creatorProp,
-                        _deserializeWithErrorWrapping(p, ctxt, creatorProp));
-                continue;
-            }
-            // Regular property? Buffer it
-            // 09-Feb-2026, tatu: Records really should not have non-Creator Mutators
-            //    so leave commented out until there's clear use case
-            /*
-            int ix = _propNameMatcher.matchName(propName);
-            if (ix >= 0) {
-                SettableBeanProperty prop = _propsByIndex[ix];
-                try {
-                    buffer.bufferProperty(prop, _deserializeWithErrorWrapping(p, ctxt, prop));
-                } catch (UnresolvedForwardReference reference) {
-                    // ignore for Records (unlikely but handle gracefully)
-                    p.skipChildren();
-                }
-                continue;
-            }
-            */
-            // "Any property"?
-            if (_anySetter != null) {
-                try {
-                    // 09-Feb-2026, tatu: as with Mutators, should never have non-Creator
-                    //   "any"-properties, so commento out
-                    /*
-                    if (_anySetter.isFieldType() || _anySetter.isSetterType()) {
-                        buffer.bufferAnyProperty(_anySetter, propName,
-                                _anySetter.deserialize(p, ctxt));
-                    } else {
-                        */
-                    buffer.bufferAnyParameterProperty(_anySetter, propName,
-                            _anySetter.deserialize(p, ctxt));
-                    //}
-                } catch (Exception e) {
-                    throw wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);
-                }
-                continue;
-            }
-            if (_ignoreAllUnknown) {
-                p.skipChildren();
-                continue;
-            }
-            handleUnknownVanilla(p, ctxt, existingRecord, propName);
-        } while ((propName = p.nextName()) != null);
-
-        return _buildRecordFromBuffer(ctxt, creator, buffer);
-    }
-
-    private Object _buildRecordFromBuffer(DeserializationContext ctxt,
-            PropertyBasedCreator creator, PropertyValueBuffer buffer)
-        throws JacksonException
-    {
-        try {
-            return creator.build(ctxt, buffer);
-        } catch (Exception e) {
-            return wrapInstantiationProblem(ctxt, e);
-        }
-    }
-
     /*
     /**********************************************************************
     /* Concrete deserialization methods
diff --git a/src/test/java/module-info.java b/src/test/java/module-info.java
index 07af4195c..1f1fd3607 100644
--- a/src/test/java/module-info.java
+++ b/src/test/java/module-info.java
@@ -91,6 +91,7 @@ module tools.jackson.databind
     opens tools.jackson.databind.mixins;
     opens tools.jackson.databind.objectid;
     opens tools.jackson.databind.records;
+    opens tools.jackson.databind.records.tofix;
     opens tools.jackson.databind.ser.dos;
     opens tools.jackson.databind.ser.enums;
     opens tools.jackson.databind.ser.filter;
diff --git a/src/test/java/tools/jackson/databind/records/RecordUpdate3079Test.java b/src/test/java/tools/jackson/databind/records/RecordUpdate3079Test.java
index 72cac297b..b1119e6fe 100644
--- a/src/test/java/tools/jackson/databind/records/RecordUpdate3079Test.java
+++ b/src/test/java/tools/jackson/databind/records/RecordUpdate3079Test.java
@@ -1,30 +1,17 @@
 package tools.jackson.databind.records;
 
-import java.util.Collections;
-import java.util.Map;
-
 import org.junit.jupiter.api.Test;
 
-import com.fasterxml.jackson.annotation.JsonAnySetter;
-import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
-
 import tools.jackson.databind.*;
-import tools.jackson.databind.json.JsonMapper;
 import tools.jackson.databind.testutil.DatabindTestUtil;
 
 import static org.junit.jupiter.api.Assertions.*;
 
+// see failing test
 public class RecordUpdate3079Test extends DatabindTestUtil
 {
     public record IdNameRecord(int id, String name) { }
 
-    @JsonIgnoreProperties(ignoreUnknown = true)
-    public record IgnoreAllRecord(int id) { }
-
-    // Record with @JsonAnySetter that captures UPPER-CASE property names
-    public record AnySetterRecord(int id, String name,
-            @JsonAnySetter Map<String, Object> extra) { }
-
     static class IdNameWrapper {
         public IdNameRecord value;
 
@@ -34,53 +21,7 @@ public class RecordUpdate3079Test extends DatabindTestUtil
 
     private final ObjectMapper MAPPER = newJsonMapper();
 
-    // [databind#3079]: Should be able to update Record value directly
-    @Test
-    public void testDirectRecordUpdate() throws Exception
-    {
-        IdNameRecord orig = new IdNameRecord(123, "Bob");
-        IdNameRecord result = MAPPER.updateValue(orig,
-                Collections.singletonMap("id", 137));
-        assertNotNull(result);
-        assertEquals(137, result.id());
-        assertEquals("Bob", result.name());
-        assertNotSame(orig, result);
-    }
-
-    // [databind#3079]: update with all properties overridden
-    @Test
-    public void testDirectRecordUpdateAllProperties() throws Exception
-    {
-        IdNameRecord orig = new IdNameRecord(123, "Bob");
-        IdNameRecord result = MAPPER.updateValue(orig,
-                Collections.singletonMap("name", "Gary"));
-        assertNotNull(result);
-        assertNotSame(orig, result);
-        assertEquals(123, result.id());
-        assertEquals("Gary", result.name());
-        assertNotSame(orig, result);
-    }
-
-    // [databind#3079]: update with no properties should return equivalent (but not same) Record
-    @Test
-    public void testDirectRecordUpdateNoProperties() throws Exception
-    {
-        IdNameRecord orig = new IdNameRecord(123, "Bob");
-        IdNameRecord result = MAPPER.updateValue(orig,
-                Collections.emptyMap());
-        assertNotNull(result);
-        assertNotSame(orig, result);
-        assertEquals(123, result.id());
-        assertEquals("Bob", result.name());
-
-        // Same with `null`:
-        result = MAPPER.updateValue(orig, null);
-        assertNotNull(result);
-        // actually same instance, impl detail
-        assertSame(orig, result);
-    }
-
-    // [databind#3079] also: should be able to update Record valued property
+    // [databind#3079]: also: should be able to Record valued property
     @Test
     public void testRecordAsPropertyUpdate() throws Exception
     {
@@ -95,123 +36,4 @@ public class RecordUpdate3079Test extends DatabindTestUtil
         assertSame(orig, result);
         assertNotSame(origRecord, result.value);
     }
-
-    // [databind#3079] exercise "ignore all" path
-    @Test
-    public void testIgnoreAllUnknown() throws Exception {
-        IgnoreAllRecord orig = new IgnoreAllRecord(1);
-        IgnoreAllRecord updated = MAPPER.updateValue(orig, Collections.singletonMap("value", 123));
-        assertNotNull(updated);
-        assertNotSame(orig, updated);
-    }
-
-    /*
-    /**********************************************************************
-    /* Tests via ObjectReader (readerForUpdating)
-    /**********************************************************************
-     */
-
-    // [databind#3079]: update Record via ObjectReader, partial override
-    @Test
-    public void testReaderForUpdatingRecordPartial() throws Exception
-    {
-        IdNameRecord orig = new IdNameRecord(123, "Bob");
-        IdNameRecord result = MAPPER.readerForUpdating(orig)
-                .readValue(a2q("{'id':137}"));
-        assertNotNull(result);
-        assertEquals(137, result.id());
-        assertEquals("Bob", result.name());
-        assertNotSame(orig, result);
-    }
-
-    // [databind#3079]: update Record via ObjectReader, all properties
-    @Test
-    public void testReaderForUpdatingRecordAllProps() throws Exception
-    {
-        IdNameRecord orig = new IdNameRecord(123, "Bob");
-        IdNameRecord result = MAPPER.readerForUpdating(orig)
-                .readValue(a2q("{'id':456,'name':'Gary'}"));
-        assertNotNull(result);
-        assertEquals(456, result.id());
-        assertEquals("Gary", result.name());
-        assertNotSame(orig, result);
-    }
-
-    // [databind#3079]: update Record via ObjectReader, empty JSON object
-    @Test
-    public void testReaderForUpdatingRecordEmpty() throws Exception
-    {
-        IdNameRecord orig = new IdNameRecord(123, "Bob");
-        IdNameRecord result = MAPPER.readerForUpdating(orig)
-                .readValue("{}");
-        assertNotNull(result);
-        // NOTE: will not be same instance in this particular case, but more of an impl detail
-        assertEquals(123, result.id());
-        assertEquals("Bob", result.name());
-
-        // Similarly with `null`:
-        result = MAPPER.readerForUpdating(orig).readValue("null");
-        // NOTE: will be same instance in this particular case
-        assertNotNull(result);
-        assertSame(orig, result);
-    }
-
-    // [databind#3079]: update Record via ObjectReader, original unchanged
-    @Test
-    public void testReaderForUpdatingRecordOrigUnchanged() throws Exception
-    {
-        IdNameRecord orig = new IdNameRecord(123, "Bob");
-        MAPPER.readerForUpdating(orig)
-                .readValue(a2q("{'id':999,'name':'Zed'}"));
-        assertEquals(123, orig.id());
-        assertEquals("Bob", orig.name());
-    }
-
-    // [databind#3079]: update Record-valued property via ObjectReader
-    @Test
-    public void testReaderForUpdatingRecordProperty() throws Exception
-    {
-        IdNameRecord origRecord = new IdNameRecord(123, "Bob");
-        IdNameWrapper orig = new IdNameWrapper(origRecord);
-
-        IdNameWrapper result = MAPPER.readerForUpdating(orig)
-                .readValue(a2q("{'value':{'id':200,'name':'Gary'}}"));
-        assertEquals(200, result.value.id());
-        assertEquals("Gary", result.value.name());
-        assertSame(orig, result);
-        assertNotSame(origRecord, result.value);
-    }
-
-    // [databind#3079]: unknown properties should be ignored when configured
-    @Test
-    public void testReaderForUpdatingRecordUnknownIgnored() throws Exception
-    {
-        ObjectMapper lenientMapper = JsonMapper.builder()
-                .disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
-                .build();
-        IdNameRecord orig = new IdNameRecord(123, "Bob");
-        IdNameRecord result = lenientMapper.readerForUpdating(orig)
-                .readValue(a2q("{'id':137,'unknown':'value'}"));
-        assertNotNull(result);
-        assertEquals(137, result.id());
-        assertEquals("Bob", result.name());
-    }
-
-    // [databind#3079]: @JsonAnySetter captures UPPER-CASE property names
-    //   that map to existing lower-case properties via any-setter Map
-    @Test
-    public void testReaderForUpdatingRecordWithAnySetter() throws Exception
-    {
-        AnySetterRecord orig = new AnySetterRecord(123, "Bob",
-                Map.of("ID", 999, "NAME", "Old"));
-        AnySetterRecord result = MAPPER.readerForUpdating(orig)
-                .readValue(a2q("{'ID':456,'NAME':'Gary'}"));
-        assertNotNull(result);
-        // Regular properties should be pre-populated from original
-        assertEquals(123, result.id());
-        assertEquals("Bob", result.name());
-        // UPPER-CASE properties should be captured by any-setter, overriding originals
-        assertEquals(456, result.extra().get("ID"));
-        assertEquals("Gary", result.extra().get("NAME"));
-    }
 }
diff --git a/src/test/java/tools/jackson/databind/records/tofix/RecordUpdate3079FailingTest.java b/src/test/java/tools/jackson/databind/records/tofix/RecordUpdate3079FailingTest.java
new file mode 100644
index 000000000..876b426b9
--- /dev/null
+++ b/src/test/java/tools/jackson/databind/records/tofix/RecordUpdate3079FailingTest.java
@@ -0,0 +1,41 @@
+package tools.jackson.databind.records.tofix;
+
+import java.util.Collections;
+
+import org.junit.jupiter.api.Test;
+
+import tools.jackson.databind.*;
+import tools.jackson.databind.testutil.DatabindTestUtil;
+import tools.jackson.databind.testutil.failure.JacksonTestFailureExpected;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+// 01-Dec-2022, tatu: Alas, fails on JDK 17
+// see related passing test in RecordUpdate3079Test
+public class RecordUpdate3079FailingTest extends DatabindTestUtil
+{
+    public record IdNameRecord(int id, String name) { }
+
+    static class IdNameWrapper {
+        public IdNameRecord value;
+
+        protected IdNameWrapper() { }
+        public IdNameWrapper(IdNameRecord v) { value = v; }
+    }
+
+    private final ObjectMapper MAPPER = newJsonMapper();
+
+    // [databind#3079]: Should be able to Record value directly
+    @JacksonTestFailureExpected
+    @Test
+    public void testDirectRecordUpdate() throws Exception
+    {
+        IdNameRecord orig = new IdNameRecord(123, "Bob");
+        IdNameRecord result = MAPPER.updateValue(orig,
+                Collections.singletonMap("id", 137));
+        assertNotNull(result);
+        assertEquals(137, result.id());
+        assertEquals("Bob", result.name());
+        assertNotSame(orig, result);
+    }
+}
