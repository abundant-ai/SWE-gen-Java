diff --git a/context-propagation/src/test/kotlin/io/micronaut/context/propagation/mdc/MdcPropagationSpec.kt b/context-propagation/src/test/kotlin/io/micronaut/context/propagation/mdc/MdcPropagationSpec.kt
index c549ca54ad..74749a6add 100644
--- a/context-propagation/src/test/kotlin/io/micronaut/context/propagation/mdc/MdcPropagationSpec.kt
+++ b/context-propagation/src/test/kotlin/io/micronaut/context/propagation/mdc/MdcPropagationSpec.kt
@@ -1,6 +1,5 @@
 package io.micronaut.context.propagation.mdc
 
-import com.fasterxml.jackson.annotation.JsonProperty
 import io.micronaut.context.ApplicationContext
 import io.micronaut.context.annotation.Requires
 import io.micronaut.context.propagation.slf4j.MdcPropagationContext
@@ -92,7 +91,7 @@ class NamingController(private val namingService: NamingService) {
 }
 
 @Introspected
-data class NameRequestBody(@JsonProperty("name") val name: String)
+class NameRequestBody(val name: String)
 
 @Requires(property = "mdc.reactortest.enabled")
 @Singleton
diff --git a/http-client-tck/build.gradle.kts b/http-client-tck/build.gradle.kts
index b36d01d10a..92a33f453a 100644
--- a/http-client-tck/build.gradle.kts
+++ b/http-client-tck/build.gradle.kts
@@ -5,7 +5,6 @@ dependencies {
     annotationProcessor(projects.micronautInjectJava)
     api(libs.junit.jupiter)
     api(projects.micronautHttpTck)
-    api(libs.managed.jackson.annotations)
     implementation(libs.managed.reactor)
     implementation(projects.micronautContext)
     implementation(projects.micronautHttpServerNetty)
diff --git a/http-client-tck/src/main/java/io/micronaut/http/client/tck/tests/Person.java b/http-client-tck/src/main/java/io/micronaut/http/client/tck/tests/Person.java
index 2ec06a6217..2fec60a4fe 100644
--- a/http-client-tck/src/main/java/io/micronaut/http/client/tck/tests/Person.java
+++ b/http-client-tck/src/main/java/io/micronaut/http/client/tck/tests/Person.java
@@ -17,12 +17,10 @@ package io.micronaut.http.client.tck.tests;
 
 import io.micronaut.core.annotation.Introspected;
 import org.jspecify.annotations.NonNull;
-import io.micronaut.core.annotation.ReflectiveAccess;
+
 import java.util.Objects;
-import com.fasterxml.jackson.annotation.JsonProperty;
 
 @Introspected
-@ReflectiveAccess
 class Person {
 
     @NonNull
@@ -30,7 +28,7 @@ class Person {
 
     private final int age;
 
-    Person(@JsonProperty("name") String name, @JsonProperty("age") int age) {
+    Person(String name, int age) {
         this.name = name;
         this.age = age;
     }
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CustomParameterBindingSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CustomParameterBindingSpec.groovy
index 6c336a2532..a444d3e135 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CustomParameterBindingSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/CustomParameterBindingSpec.groovy
@@ -1,6 +1,5 @@
 package io.micronaut.http.server.netty.binding
 
-import com.fasterxml.jackson.annotation.JsonProperty
 import io.micronaut.context.annotation.Requires
 import io.micronaut.core.annotation.Introspected
 import io.micronaut.core.convert.format.Format
@@ -207,8 +206,7 @@ class CustomParameterBindingSpec extends AbstractMicronautSpec {
             private String title
             private String author
 
-            Book(@JsonProperty("title") String title,
-                 @JsonProperty("author") @Nullable String author) {
+            Book(String title, @Nullable String author) {
                 this.title = title
                 this.author = author
             }
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/ParameterBindingSpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/ParameterBindingSpec.groovy
index 65d0af19e3..3c74e8c25a 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/ParameterBindingSpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/binding/ParameterBindingSpec.groovy
@@ -15,7 +15,6 @@
  */
 package io.micronaut.http.server.netty.binding
 
-import com.fasterxml.jackson.annotation.JsonProperty
 import io.micronaut.context.annotation.Requires
 import io.micronaut.core.annotation.Introspected
 import io.micronaut.core.convert.format.Format
@@ -250,9 +249,7 @@ class ParameterBindingSpec extends AbstractMicronautSpec {
             private String author
             private int age
 
-            Book(@JsonProperty("title") String title,
-                 @JsonProperty("age") Integer age,
-                 @JsonProperty("author") @Nullable String author) {
+            Book(String title, Integer age, @Nullable String author) {
                 this.age = age
                 this.title = title
                 this.author = author
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/BodyTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/BodyTest.java
index a4a1d46b91..5833ec35aa 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/BodyTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/BodyTest.java
@@ -15,10 +15,8 @@
  */
 package io.micronaut.http.server.tck.tests;
 
-import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.core.async.annotation.SingleResult;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
@@ -279,15 +277,11 @@ public class BodyTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class Point {
         private Integer x;
         private Integer y;
 
-        public Point(
-            @JsonProperty("x") Integer x, // @JsonProperty annotation for Jackson Databind
-            @JsonProperty("y") Integer y // @JsonProperty annotation for Jackson Databind
-        ) {
+        public Point(Integer x, Integer y) {
             this.x = x;
             this.y = y;
         }
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/ConsumesTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/ConsumesTest.java
index 07ba1c6fed..4ae188ee28 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/ConsumesTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/ConsumesTest.java
@@ -17,7 +17,6 @@ package io.micronaut.http.server.tck.tests;
 
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
@@ -80,7 +79,6 @@ public class ConsumesTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class Pojo {
         private String name;
 
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/ErrorHandlerTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/ErrorHandlerTest.java
index 361f173349..33c90e34f2 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/ErrorHandlerTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/ErrorHandlerTest.java
@@ -15,10 +15,8 @@
  */
 package io.micronaut.http.server.tck.tests;
 
-import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.core.util.StringUtils;
 import io.micronaut.http.HttpHeaders;
@@ -268,14 +266,11 @@ public class ErrorHandlerTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class RequestObject {
         @Min(1L)
-        private final Integer numberField;
+        private Integer numberField;
 
-        public RequestObject(
-            @JsonProperty("numberField") Integer numberField // @JsonProperty required for jackson databind
-        ) {
+        public RequestObject(Integer numberField) {
             this.numberField = numberField;
         }
 
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/HeadersTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/HeadersTest.java
index 5b0ef4932c..887dab22ad 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/HeadersTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/HeadersTest.java
@@ -17,7 +17,6 @@ package io.micronaut.http.server.tck.tests;
 
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
@@ -34,7 +33,7 @@ import java.util.List;
 import java.util.Optional;
 
 import static io.micronaut.http.tck.TestScenario.asserts;
-import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.*;
 
 @SuppressWarnings({
     "java:S5960", // We're allowed assertions, as these are used in tests only
@@ -122,7 +121,6 @@ public class HeadersTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     record ETags(List<String> headers) {
     }
 }
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/LocalErrorReadingBodyTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/LocalErrorReadingBodyTest.java
index e54e20d714..81fad00e80 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/LocalErrorReadingBodyTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/LocalErrorReadingBodyTest.java
@@ -18,16 +18,11 @@ package io.micronaut.http.server.tck.tests;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
 import org.jspecify.annotations.Nullable;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
-import io.micronaut.http.annotation.Body;
-import io.micronaut.http.annotation.Controller;
 import io.micronaut.http.annotation.Error;
-import io.micronaut.http.annotation.Post;
-import io.micronaut.http.annotation.Produces;
-import io.micronaut.http.annotation.Status;
+import io.micronaut.http.annotation.*;
 import io.micronaut.http.tck.AssertionUtils;
 import io.micronaut.http.tck.HttpResponseAssertion;
 import jakarta.validation.Valid;
@@ -60,7 +55,6 @@ public class LocalErrorReadingBodyTest {
 
 
     @Introspected
-    @ReflectiveAccess
     static class RequestObject {
         @Min(1L)
         private Integer numberField;
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/MiscTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/MiscTest.java
index 1f21c762fc..f8fcc190e4 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/MiscTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/MiscTest.java
@@ -15,11 +15,9 @@
  */
 package io.micronaut.http.server.tck.tests;
 
-import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
 import org.jspecify.annotations.NonNull;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpResponse;
@@ -189,16 +187,13 @@ public class MiscTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class MessageCreate {
 
         @NonNull
         @NotBlank
         private final String message;
 
-        MessageCreate(
-            @JsonProperty("message") @NonNull String message  // @JsonProperty annotation for Jackson Databind
-        ) {
+        MessageCreate(@NonNull String message) {
             this.message = message;
         }
 
@@ -209,7 +204,6 @@ public class MiscTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class MyResponse {
 
         @NonNull
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/MissingBodyAnnotationTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/MissingBodyAnnotationTest.java
index 324b5e2e37..8a0c8b9907 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/MissingBodyAnnotationTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/MissingBodyAnnotationTest.java
@@ -15,10 +15,8 @@
  */
 package io.micronaut.http.server.tck.tests;
 
-import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.annotation.Body;
@@ -84,14 +82,11 @@ public class MissingBodyAnnotationTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class Dto {
 
         private final String value;
 
-        public Dto(
-            @JsonProperty("value") String value // @JsonProperty for JacksonDatabind
-        ) {
+        public Dto(String value) {
             this.value = value;
         }
 
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/NoBodyResponseTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/NoBodyResponseTest.java
index 33a7f563e7..fd2143fd5f 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/NoBodyResponseTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/NoBodyResponseTest.java
@@ -15,10 +15,8 @@
  */
 package io.micronaut.http.server.tck.tests;
 
-import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.core.async.annotation.SingleResult;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
@@ -337,14 +335,11 @@ public class NoBodyResponseTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class Point {
         private Integer x;
         private Integer y;
 
-        public Point(@JsonProperty("x") Integer x, // @JsonProperty annotation for Jackson Databind
-                     @JsonProperty("y") Integer y // @JsonProperty annotation for Jackson Databind
-        ) {
+        public Point(Integer x, Integer y) {
             this.x = x;
             this.y = y;
         }
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/binding/LocalDateTimeTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/binding/LocalDateTimeTest.java
index 25c4624e17..3cc118ce57 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/binding/LocalDateTimeTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/binding/LocalDateTimeTest.java
@@ -15,19 +15,12 @@
  */
 package io.micronaut.http.server.tck.tests.binding;
 
-import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
-import io.micronaut.http.annotation.Body;
-import io.micronaut.http.annotation.Consumes;
-import io.micronaut.http.annotation.Controller;
-import io.micronaut.http.annotation.Get;
-import io.micronaut.http.annotation.Post;
-import io.micronaut.http.annotation.QueryValue;
+import io.micronaut.http.annotation.*;
 import io.micronaut.http.tck.AssertionUtils;
 import io.micronaut.http.tck.BodyAssertion;
 import io.micronaut.http.tck.HttpResponseAssertion;
@@ -114,13 +107,10 @@ public class LocalDateTimeTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     public static class Event {
         private final LocalDateTime eventDate;
 
-        public Event(
-            @JsonProperty("eventDate") LocalDateTime eventDate // @JsonProperty for JacksonDatabind
-        ) {
+        public Event(LocalDateTime eventDate) {
             this.eventDate = eventDate;
         }
 
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalType2Test.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalType2Test.java
index dba851a3eb..9c41bb21a4 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalType2Test.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalType2Test.java
@@ -18,7 +18,6 @@ package io.micronaut.http.server.tck.tests.codec;
 import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
@@ -92,7 +91,6 @@ public class JsonCodecAdditionalType2Test {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class JsonFeed {
         private final String version;
         private final String title;
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalTypeAutomaticTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalTypeAutomaticTest.java
index 7c22b5e114..750749b88d 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalTypeAutomaticTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalTypeAutomaticTest.java
@@ -18,7 +18,6 @@ package io.micronaut.http.server.tck.tests.codec;
 import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
@@ -88,7 +87,6 @@ public class JsonCodecAdditionalTypeAutomaticTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class JsonFeed {
         private final String version;
         private final String title;
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalTypeTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalTypeTest.java
index ce79105155..65e70f023c 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalTypeTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/codec/JsonCodecAdditionalTypeTest.java
@@ -18,7 +18,6 @@ package io.micronaut.http.server.tck.tests.codec;
 import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
@@ -92,7 +91,6 @@ public class JsonCodecAdditionalTypeTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class JsonFeed {
         private final String version;
         private final String title;
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/constraintshandler/ControllerConstraintHandlerTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/constraintshandler/ControllerConstraintHandlerTest.java
index 4dde02f04a..bb8d2ffc41 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/constraintshandler/ControllerConstraintHandlerTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/constraintshandler/ControllerConstraintHandlerTest.java
@@ -15,12 +15,10 @@
  */
 package io.micronaut.http.server.tck.tests.constraintshandler;
 
-import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
 import org.jspecify.annotations.NonNull;
 import org.jspecify.annotations.Nullable;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
@@ -199,7 +197,6 @@ public class ControllerConstraintHandlerTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class CredentialsWithoutNullabilityAnnotation {
         @NotBlank
         @Email
@@ -208,9 +205,7 @@ public class ControllerConstraintHandlerTest {
         @NotBlank
         private final String password;
 
-        CredentialsWithoutNullabilityAnnotation(@JsonProperty("username") String username, // @JsonProperty for JacksonDatabind
-                                                @JsonProperty("password") String password // @JsonProperty for JacksonDatabind
-        ) {
+        CredentialsWithoutNullabilityAnnotation(String username, String password) {
             this.username = username;
             this.password = password;
         }
@@ -225,7 +220,6 @@ public class ControllerConstraintHandlerTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class CredentialsWithNullable {
         @NotBlank
         @Email
@@ -236,9 +230,7 @@ public class ControllerConstraintHandlerTest {
         @Nullable
         private final String password;
 
-        CredentialsWithNullable(@JsonProperty("username") @Nullable String username, // @JsonProperty for JacksonDatabind
-                                @JsonProperty("password") @Nullable String password // @JsonProperty for JacksonDatabind
-        ) {
+        CredentialsWithNullable(@Nullable String username, @Nullable String password) {
             this.username = username;
             this.password = password;
         }
@@ -255,7 +247,6 @@ public class ControllerConstraintHandlerTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     static class CredentialsWithNonNull {
         @NotBlank
         @Email
@@ -266,9 +257,7 @@ public class ControllerConstraintHandlerTest {
         @NonNull
         private final String password;
 
-        CredentialsWithNonNull(@JsonProperty("username") @NonNull String username, // @JsonProperty for JacksonDatabind
-                               @JsonProperty("password") @NonNull String password // @JsonProperty for JacksonDatabind
-        ) {
+        CredentialsWithNonNull(@NonNull String username, @NonNull String password) {
             this.username = username;
             this.password = password;
         }
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/exceptions/HtmlErrorPageTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/exceptions/HtmlErrorPageTest.java
index 180e8adc86..49ed714e28 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/exceptions/HtmlErrorPageTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/exceptions/HtmlErrorPageTest.java
@@ -17,16 +17,11 @@ package io.micronaut.http.server.tck.tests.exceptions;
 
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpHeaders;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
-import io.micronaut.http.annotation.Body;
-import io.micronaut.http.annotation.Controller;
-import io.micronaut.http.annotation.Post;
-import io.micronaut.http.annotation.Produces;
-import io.micronaut.http.annotation.Status;
+import io.micronaut.http.annotation.*;
 import io.micronaut.http.tck.AssertionUtils;
 import io.micronaut.http.tck.BodyAssertion;
 import io.micronaut.http.tck.HttpResponseAssertion;
@@ -79,7 +74,6 @@ public class HtmlErrorPageTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     record Book(@NotBlank String title, @NotBlank String author, @Max(4032) int pages) {
 
     }
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormBindingUsingMethodParametersTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormBindingUsingMethodParametersTest.java
index 22991ae379..1062e0b2ba 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormBindingUsingMethodParametersTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormBindingUsingMethodParametersTest.java
@@ -19,7 +19,6 @@ import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
 import org.jspecify.annotations.NonNull;
 import org.jspecify.annotations.Nullable;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
@@ -83,7 +82,6 @@ public class FormBindingUsingMethodParametersTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     record Book(@NonNull String title, @Nullable Integer pages) {
     }
 }
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormUrlEncodedBodyInRequestFilterTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormUrlEncodedBodyInRequestFilterTest.java
index 2450fd04e2..8bc4d036ae 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormUrlEncodedBodyInRequestFilterTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormUrlEncodedBodyInRequestFilterTest.java
@@ -19,19 +19,8 @@ import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
 import org.jspecify.annotations.NonNull;
 import org.jspecify.annotations.Nullable;
-import io.micronaut.core.annotation.ReflectiveAccess;
-import io.micronaut.http.HttpRequest;
-import io.micronaut.http.HttpResponse;
-import io.micronaut.http.HttpStatus;
-import io.micronaut.http.MediaType;
-import io.micronaut.http.annotation.Body;
-import io.micronaut.http.annotation.Consumes;
-import io.micronaut.http.annotation.Controller;
-import io.micronaut.http.annotation.Post;
-import io.micronaut.http.annotation.Produces;
-import io.micronaut.http.annotation.RequestFilter;
-import io.micronaut.http.annotation.ServerFilter;
-import io.micronaut.http.annotation.Status;
+import io.micronaut.http.*;
+import io.micronaut.http.annotation.*;
 import io.micronaut.http.server.filter.FilterBodyParser;
 import io.micronaut.http.tck.AssertionUtils;
 import io.micronaut.http.tck.HttpResponseAssertion;
@@ -39,7 +28,6 @@ import io.micronaut.http.tck.TestScenario;
 import io.micronaut.scheduling.TaskExecutors;
 import io.micronaut.scheduling.annotation.ExecuteOn;
 import org.junit.jupiter.api.Test;
-
 import java.io.IOException;
 import java.util.Map;
 import java.util.concurrent.ExecutionException;
@@ -133,14 +121,12 @@ public class FormUrlEncodedBodyInRequestFilterTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     record PasswordChange(
             String username,
             String password) {
     }
 
     @Introspected
-    @ReflectiveAccess
     record PasswordChangeForm(
             String username,
             String password,
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsInputNumberOptionalTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsInputNumberOptionalTest.java
index 7b850cd146..1c1c0660a8 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsInputNumberOptionalTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsInputNumberOptionalTest.java
@@ -19,7 +19,6 @@ import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
 import org.jspecify.annotations.NonNull;
 import org.jspecify.annotations.Nullable;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
@@ -84,7 +83,6 @@ public class FormsInputNumberOptionalTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     record Book(@NonNull String title, @Nullable Integer pages) {
     }
 
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsJacksonAnnotationsTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsJacksonAnnotationsTest.java
index d7827991e6..ef3b134974 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsJacksonAnnotationsTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsJacksonAnnotationsTest.java
@@ -20,7 +20,6 @@ import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
 import org.jspecify.annotations.NonNull;
 import org.jspecify.annotations.Nullable;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
@@ -92,7 +91,6 @@ public class FormsJacksonAnnotationsTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     record Book(@JsonProperty("title") @NonNull String title, @JsonProperty("paginas") @Nullable Integer pages) {
     }
 
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsSubmissionsWithListsTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsSubmissionsWithListsTest.java
index 2bb0a01df8..1522ab03a1 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsSubmissionsWithListsTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/forms/FormsSubmissionsWithListsTest.java
@@ -17,7 +17,6 @@ package io.micronaut.http.server.tck.tests.forms;
 
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.MediaType;
@@ -86,7 +85,6 @@ public class FormsSubmissionsWithListsTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     public record QuestionSave(String question,
                                List<Long> usersId) {
     }
diff --git a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/routing/RootRoutingTest.java b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/routing/RootRoutingTest.java
index 9925f344c1..b065bea1d4 100644
--- a/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/routing/RootRoutingTest.java
+++ b/http-server-tck/src/main/java/io/micronaut/http/server/tck/tests/routing/RootRoutingTest.java
@@ -17,7 +17,6 @@ package io.micronaut.http.server.tck.tests.routing;
 
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.HttpStatus;
 import io.micronaut.http.annotation.Body;
@@ -81,7 +80,6 @@ public class RootRoutingTest {
     }
 
     @Introspected
-    @ReflectiveAccess
     private record KeyValue(String key, String value) {
     }
 
diff --git a/http/src/main/java/io/micronaut/http/hateoas/AbstractResource.java b/http/src/main/java/io/micronaut/http/hateoas/AbstractResource.java
index e7643cb73b..33a0d37464 100644
--- a/http/src/main/java/io/micronaut/http/hateoas/AbstractResource.java
+++ b/http/src/main/java/io/micronaut/http/hateoas/AbstractResource.java
@@ -26,13 +26,7 @@ import io.micronaut.core.value.OptionalMultiValues;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.annotation.Produces;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
+import java.util.*;
 
 /**
  * An abstract implementation of {@link Resource}.
@@ -44,7 +38,6 @@ import java.util.Optional;
 @Produces(MediaType.APPLICATION_HAL_JSON)
 @Introspected
 @SuppressWarnings("java:S119") // Impl is a better name than T
-@ReflectiveAccess // for jackson
 public abstract class AbstractResource<Impl extends AbstractResource<Impl>> implements Resource {
     private final Map<CharSequence, List<Link>> linkMap = new LinkedHashMap<>(1);
     private final Map<CharSequence, List<Resource>> embeddedMap = new LinkedHashMap<>(1);
diff --git a/http/src/main/java/io/micronaut/http/hateoas/DefaultLink.java b/http/src/main/java/io/micronaut/http/hateoas/DefaultLink.java
index a6b80cb3f4..e3ff1b6122 100644
--- a/http/src/main/java/io/micronaut/http/hateoas/DefaultLink.java
+++ b/http/src/main/java/io/micronaut/http/hateoas/DefaultLink.java
@@ -15,7 +15,6 @@
  */
 package io.micronaut.http.hateoas;
 
-import io.micronaut.core.annotation.ReflectiveAccess;
 import org.jspecify.annotations.Nullable;
 import io.micronaut.core.annotation.Introspected;
 import io.micronaut.core.util.StringUtils;
@@ -31,7 +30,6 @@ import java.util.Optional;
  * @since 1.1
  */
 @Introspected
-@ReflectiveAccess // for Jackson
 public class DefaultLink implements Link, Link.Builder {
 
     final String href;
diff --git a/http/src/main/java/io/micronaut/http/hateoas/GenericResource.java b/http/src/main/java/io/micronaut/http/hateoas/GenericResource.java
index 721915dbce..9a7f1dc38c 100644
--- a/http/src/main/java/io/micronaut/http/hateoas/GenericResource.java
+++ b/http/src/main/java/io/micronaut/http/hateoas/GenericResource.java
@@ -19,7 +19,6 @@ import com.fasterxml.jackson.annotation.JsonAnyGetter;
 import com.fasterxml.jackson.annotation.JsonAnySetter;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.core.util.ObjectUtils;
 
 import java.util.LinkedHashMap;
@@ -33,7 +32,6 @@ import java.util.Map;
  * @author yawkat
  */
 @Introspected
-@ReflectiveAccess // for jackson
 public final class GenericResource extends AbstractResource<GenericResource> {
     private final Map<String, Object> additionalProperties = new LinkedHashMap<>();
 
diff --git a/http/src/main/java/io/micronaut/http/hateoas/JsonError.java b/http/src/main/java/io/micronaut/http/hateoas/JsonError.java
index 35eeef0365..054154c581 100644
--- a/http/src/main/java/io/micronaut/http/hateoas/JsonError.java
+++ b/http/src/main/java/io/micronaut/http/hateoas/JsonError.java
@@ -17,10 +17,10 @@ package io.micronaut.http.hateoas;
 
 import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.core.type.Argument;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.annotation.Produces;
+
 import org.jspecify.annotations.Nullable;
 import java.util.Optional;
 
@@ -31,7 +31,6 @@ import java.util.Optional;
  * @since 1.1
  */
 @Produces(MediaType.APPLICATION_JSON)
-@ReflectiveAccess // for jackson
 public class JsonError extends AbstractResource<JsonError> {
 
     /**
diff --git a/http/src/main/java/io/micronaut/http/hateoas/Resource.java b/http/src/main/java/io/micronaut/http/hateoas/Resource.java
index a32a233f73..06de9f875a 100644
--- a/http/src/main/java/io/micronaut/http/hateoas/Resource.java
+++ b/http/src/main/java/io/micronaut/http/hateoas/Resource.java
@@ -19,7 +19,6 @@ import com.fasterxml.jackson.annotation.JsonCreator;
 import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.core.value.OptionalMultiValues;
 
 /**
@@ -29,7 +28,6 @@ import io.micronaut.core.value.OptionalMultiValues;
  * @since 1.1
  */
 @Introspected
-@ReflectiveAccess // for jackson
 public interface Resource {
 
     /**
diff --git a/http/src/main/java/io/micronaut/http/hateoas/VndError.java b/http/src/main/java/io/micronaut/http/hateoas/VndError.java
index 7e2742a664..bb0cb2d561 100644
--- a/http/src/main/java/io/micronaut/http/hateoas/VndError.java
+++ b/http/src/main/java/io/micronaut/http/hateoas/VndError.java
@@ -17,7 +17,6 @@ package io.micronaut.http.hateoas;
 
 import io.micronaut.core.annotation.Internal;
 import org.jspecify.annotations.Nullable;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.annotation.Produces;
 
@@ -30,7 +29,6 @@ import java.util.List;
  * @since 1.1
  */
 @Produces(MediaType.APPLICATION_VND_ERROR)
-@ReflectiveAccess // for jackson
 public class VndError extends JsonError {
 
     /**
diff --git a/http/src/main/java/io/micronaut/http/ssl/AbstractCertificateFileConfig.java b/http/src/main/java/io/micronaut/http/ssl/AbstractCertificateFileConfig.java
index 2c5d175c34..297c217348 100644
--- a/http/src/main/java/io/micronaut/http/ssl/AbstractCertificateFileConfig.java
+++ b/http/src/main/java/io/micronaut/http/ssl/AbstractCertificateFileConfig.java
@@ -31,6 +31,7 @@ import io.micronaut.core.naming.Named;
 abstract sealed class AbstractCertificateFileConfig implements Named permits FileCertificateProvider.Config, ResourceCertificateProvider.Config {
     final String name;
 
+
     FileCertificateProvider.@Nullable Format format;
     @Nullable
     String password;
diff --git a/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/BeanIntrospectionSpec.groovy b/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/BeanIntrospectionSpec.groovy
index 84aab0dedb..92cc2a9bc7 100644
--- a/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/BeanIntrospectionSpec.groovy
+++ b/inject-java-test/src/test/groovy/io/micronaut/inject/visitor/beans/BeanIntrospectionSpec.groovy
@@ -9,6 +9,7 @@ import io.micronaut.annotation.processing.test.AbstractTypeElementSpec
 import io.micronaut.annotation.processing.test.JavaParser
 import io.micronaut.context.ApplicationContext
 import io.micronaut.context.annotation.Executable
+import io.micronaut.context.annotation.Replaces
 import io.micronaut.context.visitor.ConfigurationReaderVisitor
 import io.micronaut.core.annotation.Introspected
 import io.micronaut.core.annotation.NextMajorVersion
@@ -32,7 +33,10 @@ import io.micronaut.inject.annotation.EvaluatedAnnotationMetadata
 import io.micronaut.inject.beans.visitor.IntrospectedTypeElementVisitor
 import io.micronaut.inject.visitor.TypeElementVisitor
 import io.micronaut.inject.visitor.beans.outer.MuxedEvent2
+import io.micronaut.jackson.modules.BeanIntrospectionModule
+import io.micronaut.json.JsonMapper
 import io.micronaut.validation.visitor.ValidationVisitor
+import jakarta.inject.Singleton
 import jakarta.validation.Constraint
 import jakarta.validation.constraints.DecimalMin
 import jakarta.validation.constraints.Min
@@ -1660,6 +1664,31 @@ public record Foo(int x, int y) {
         obj.y() == 10
     }
 
+    void "test serializing records respects json annotations"() {
+        given:
+        BeanIntrospection introspection = buildBeanIntrospection('json.test.Foo', '''
+package json.test;
+
+import io.micronaut.core.annotation.Creator;
+import java.util.List;
+import jakarta.validation.constraints.Min;
+import com.fasterxml.jackson.annotation.JsonIgnore;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+@io.micronaut.core.annotation.Introspected
+public record Foo(@JsonProperty("other") String name, @JsonIgnore int y) {
+}
+''')
+        when:
+        def obj = introspection.instantiate("test", 10)
+        String result = ApplicationContext.run('bean.introspection.test':'true').withCloseable {
+            it.getBean(StaticBeanIntrospectionModule).introspectionMap[introspection.beanType] = introspection
+            it.getBean(JsonMapper).writeValueAsString(obj)
+        }
+        then:
+        result == '{"other":"test"}'
+    }
+
     void "test secondary constructor with @Creator for Java 14+ records"() {
         given:
         BeanIntrospection introspection = buildBeanIntrospection('test.Foo', '''
@@ -5982,5 +6011,16 @@ class AbcPerson {
             return [new ValidationVisitor(), new ConfigurationReaderVisitor(), new io.micronaut.validation.visitor.IntrospectedValidationIndexesVisitor(), new IntrospectedTypeElementVisitor()]
         }
     }
+
+    @Singleton
+    @Replaces(BeanIntrospectionModule)
+    @io.micronaut.context.annotation.Requires(property = "bean.introspection.test")
+    static class StaticBeanIntrospectionModule extends BeanIntrospectionModule {
+        Map<Class<?>, BeanIntrospection> introspectionMap = [:]
+        @Override
+        protected BeanIntrospection<Object> findIntrospection(Class<?> beanClass) {
+            return introspectionMap.get(beanClass)
+        }
+    }
 }
 
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/JacksonConfiguration.java b/jackson-databind/src/main/java/io/micronaut/jackson/JacksonConfiguration.java
index 1e686667f4..316293a0c1 100644
--- a/jackson-databind/src/main/java/io/micronaut/jackson/JacksonConfiguration.java
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/JacksonConfiguration.java
@@ -28,6 +28,7 @@ import com.fasterxml.jackson.databind.PropertyNamingStrategy;
 import com.fasterxml.jackson.databind.SerializationFeature;
 import com.fasterxml.jackson.databind.type.TypeFactory;
 import io.micronaut.context.annotation.ConfigurationProperties;
+import io.micronaut.core.annotation.Experimental;
 import org.jspecify.annotations.NonNull;
 import io.micronaut.core.annotation.TypeHint;
 import io.micronaut.core.type.Argument;
@@ -69,8 +70,13 @@ public class JacksonConfiguration implements JsonConfiguration {
      * The property used to enable module scan.
      */
     public static final String PROPERTY_MODULE_SCAN = "jackson.module-scan";
+    /**
+     * The property used to enable bean introspection.
+     */
+    public static final String PROPERTY_USE_BEAN_INTROSPECTION = "jackson.bean-introspection-module";
 
     private boolean moduleScan = true;
+    private boolean beanIntrospectionModule = true;
     private String dateFormat;
     private Locale locale;
     private TimeZone timeZone;
@@ -87,6 +93,26 @@ public class JacksonConfiguration implements JsonConfiguration {
     private boolean alwaysSerializeErrorsAsList = true;
     private boolean trimStrings = false;
 
+    /**
+     * Whether the {@link io.micronaut.core.beans.BeanIntrospection} should be used for reflection free object serialialization/deserialialization.
+     *
+     * @return True if it should
+     */
+    @Experimental
+    public boolean isBeanIntrospectionModule() {
+        return beanIntrospectionModule;
+    }
+
+    /**
+     * Whether the {@link io.micronaut.core.beans.BeanIntrospection} should be used for reflection free object serialialization/deserialialization.
+     *
+     * @param beanIntrospectionModule True if it should
+     */
+    @Experimental
+    public void setBeanIntrospectionModule(boolean beanIntrospectionModule) {
+        this.beanIntrospectionModule = beanIntrospectionModule;
+    }
+
     /**
      * Whether Jackson modules should be scanned for.
      *
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/modules/BeanIntrospectionModule.java b/jackson-databind/src/main/java/io/micronaut/jackson/modules/BeanIntrospectionModule.java
new file mode 100644
index 0000000000..97518fbc9e
--- /dev/null
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/modules/BeanIntrospectionModule.java
@@ -0,0 +1,1200 @@
+/*
+ * Copyright 2017-2020 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.jackson.modules;
+
+import com.fasterxml.jackson.annotation.JsonAnyGetter;
+import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.annotation.JsonIgnore;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonPropertyDescription;
+import com.fasterxml.jackson.annotation.JsonUnwrapped;
+import com.fasterxml.jackson.annotation.JsonValue;
+import com.fasterxml.jackson.annotation.OptBoolean;
+import com.fasterxml.jackson.core.JsonGenerator;
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.ObjectCodec;
+import com.fasterxml.jackson.core.SerializableString;
+import com.fasterxml.jackson.core.io.SerializedString;
+import com.fasterxml.jackson.databind.BeanDescription;
+import com.fasterxml.jackson.databind.DeserializationConfig;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JavaType;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.JsonSerializer;
+import com.fasterxml.jackson.databind.MapperFeature;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.PropertyMetadata;
+import com.fasterxml.jackson.databind.PropertyName;
+import com.fasterxml.jackson.databind.PropertyNamingStrategy;
+import com.fasterxml.jackson.databind.SerializationConfig;
+import com.fasterxml.jackson.databind.SerializerProvider;
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import com.fasterxml.jackson.databind.annotation.JsonNaming;
+import com.fasterxml.jackson.databind.annotation.JsonSerialize;
+import com.fasterxml.jackson.databind.cfg.MapperConfig;
+import com.fasterxml.jackson.databind.deser.BeanDeserializerBuilder;
+import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;
+import com.fasterxml.jackson.databind.deser.CreatorProperty;
+import com.fasterxml.jackson.databind.deser.NullValueProvider;
+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;
+import com.fasterxml.jackson.databind.deser.ValueInstantiator;
+import com.fasterxml.jackson.databind.deser.impl.MethodProperty;
+import com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;
+import com.fasterxml.jackson.databind.introspect.AccessorNamingStrategy;
+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;
+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;
+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;
+import com.fasterxml.jackson.databind.introspect.AnnotationCollector;
+import com.fasterxml.jackson.databind.introspect.DefaultAccessorNamingStrategy;
+import com.fasterxml.jackson.databind.introspect.TypeResolutionContext;
+import com.fasterxml.jackson.databind.introspect.VirtualAnnotatedMember;
+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.fasterxml.jackson.databind.ser.AnyGetterWriter;
+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
+import com.fasterxml.jackson.databind.ser.BeanSerializerBuilder;
+import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;
+import com.fasterxml.jackson.databind.ser.std.MapSerializer;
+import com.fasterxml.jackson.databind.type.TypeFactory;
+import com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;
+import io.micronaut.context.annotation.Requires;
+import io.micronaut.core.annotation.AnnotatedElement;
+import io.micronaut.core.annotation.AnnotationMetadata;
+import io.micronaut.core.annotation.AnnotationValue;
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.Internal;
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.Nullable;
+import io.micronaut.core.beans.BeanIntrospection;
+import io.micronaut.core.beans.BeanIntrospector;
+import io.micronaut.core.beans.BeanProperty;
+import io.micronaut.core.beans.UnsafeBeanInstantiationIntrospection;
+import io.micronaut.core.beans.UnsafeBeanProperty;
+import io.micronaut.core.reflect.exception.InstantiationException;
+import io.micronaut.core.type.Argument;
+import io.micronaut.core.util.CollectionUtils;
+import io.micronaut.core.util.StringUtils;
+import io.micronaut.jackson.JacksonConfiguration;
+import io.micronaut.jackson.JacksonDeserializationPreInstantiateCallback;
+import jakarta.inject.Inject;
+import jakarta.inject.Singleton;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+/**
+ * A Jackson module that adds reflection-free bean serialization and deserialization for Micronaut.
+ *
+ * @author graemerocher
+ * @since 1.1
+ */
+@Internal
+@Experimental
+@Singleton
+@Requires(property = JacksonConfiguration.PROPERTY_USE_BEAN_INTROSPECTION, notEquals = StringUtils.FALSE)
+public class BeanIntrospectionModule extends SimpleModule {
+
+    private static final Logger LOG = LoggerFactory.getLogger(BeanIntrospectionModule.class);
+
+    /**
+     * For testing.
+     */
+    boolean ignoreReflectiveProperties = false;
+
+    /**
+     * The pre-instantiate callback.
+     */
+    @Nullable
+    private final JacksonDeserializationPreInstantiateCallback preInstantiateCallback;
+
+    /**
+     * Default constructor.
+     */
+    public BeanIntrospectionModule() {
+        this(null);
+    }
+
+    /**
+     * The constructor.
+     *
+     * @param preInstantiateCallback The optional instance {@link JacksonDeserializationPreInstantiateCallback}
+     */
+    @Inject
+    public BeanIntrospectionModule(@Nullable JacksonDeserializationPreInstantiateCallback preInstantiateCallback) {
+        this.preInstantiateCallback = preInstantiateCallback;
+        setDeserializerModifier(new BeanIntrospectionDeserializerModifier());
+        setSerializerModifier(new BeanIntrospectionSerializerModifier());
+    }
+
+    @Override
+    public void setupModule(SetupContext context) {
+        super.setupModule(context);
+
+        ObjectCodec owner = context.getOwner();
+        if (owner instanceof ObjectMapper mapper) {
+            mapper.setConfig(mapper.getSerializationConfig().with(new BeanIntrospectionAccessorNamingStrategyProvider(mapper.getSerializationConfig().getAccessorNaming())));
+            mapper.setConfig(mapper.getDeserializationConfig().with(new BeanIntrospectionAccessorNamingStrategyProvider(mapper.getDeserializationConfig().getAccessorNaming())));
+        }
+    }
+
+    /**
+     * Find an introspection for the given class.
+     *
+     * @param beanClass The bean class
+     * @return The introspection
+     */
+    @Nullable
+    protected BeanIntrospection<Object> findIntrospection(Class<?> beanClass) {
+        return (BeanIntrospection<Object>) BeanIntrospector.SHARED.findIntrospection(beanClass).orElse(null);
+    }
+
+    private JavaType newType(Argument<?> argument, TypeFactory typeFactory) {
+        return JacksonConfiguration.constructType(argument, typeFactory);
+    }
+
+    private PropertyMetadata newPropertyMetadata(Argument<?> argument, AnnotationMetadata annotationMetadata) {
+        final Boolean required = annotationMetadata.booleanValue(JsonProperty.class, "required").orElse(false);
+
+        int index = annotationMetadata.intValue(JsonProperty.class, "index").orElse(-1);
+        return PropertyMetadata.construct(
+            required,
+            annotationMetadata.stringValue(JsonPropertyDescription.class).orElse(null),
+            index > -1 ? index : null,
+            annotationMetadata.stringValue(JsonProperty.class, "defaultValue").orElse(null)
+        );
+    }
+
+    // copied from VirtualBeanPropertyWriter
+    private static boolean suppressNulls(JsonInclude.Value inclusion) {
+        if (inclusion == null) {
+            return false;
+        }
+        JsonInclude.Include incl = inclusion.getValueInclusion();
+        return (incl != JsonInclude.Include.ALWAYS) && (incl != JsonInclude.Include.USE_DEFAULTS);
+    }
+
+    // copied from VirtualBeanPropertyWriter
+    private static Object suppressableValue(JsonInclude.Value inclusion) {
+        if (inclusion == null) {
+            return false; // [sic]
+        }
+        JsonInclude.Include incl = inclusion.getValueInclusion();
+        if ((incl == JsonInclude.Include.ALWAYS)
+            || (incl == JsonInclude.Include.NON_NULL)
+            || (incl == JsonInclude.Include.USE_DEFAULTS)) {
+            return null;
+        }
+        return BeanPropertyWriter.MARKER_FOR_EMPTY;
+    }
+
+    /**
+     * Parse a {@link JsonSerialize} or {@link JsonDeserialize} annotation.
+     */
+    private <T> T findSerializerFromAnnotation(BeanProperty<?, ?> beanProperty, Class<? extends Annotation> annotationType) {
+        AnnotationValue<?> jsonSerializeAnnotation = beanProperty.getAnnotation(annotationType);
+        if (jsonSerializeAnnotation != null) {
+            // ideally, we'd use SerializerProvider here, but it's not exposed to the BeanSerializerModifier
+            Class<?> using = jsonSerializeAnnotation.classValue("using").orElse(null);
+            if (using != null) {
+                BeanIntrospection<Object> usingIntrospection = findIntrospection(using);
+                if (usingIntrospection != null) {
+                    return (T) usingIntrospection.instantiate();
+                } else {
+                    if (LOG.isWarnEnabled()) {
+                        LOG.warn("Cannot construct {}, please add the @Introspected annotation to the class declaration", using.getName());
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    private JsonFormat.@NonNull Value parseJsonFormat(@NonNull AnnotationValue<JsonFormat> formatAnnotation) {
+        return new JsonFormat.Value(
+            formatAnnotation.stringValue("pattern").orElse(""),
+            formatAnnotation.enumValue("shape", JsonFormat.Shape.class).orElse(JsonFormat.Shape.ANY),
+            formatAnnotation.stringValue("locale").orElse(JsonFormat.DEFAULT_LOCALE),
+            formatAnnotation.stringValue("timezone").orElse(JsonFormat.DEFAULT_TIMEZONE),
+            JsonFormat.Features.construct(
+                formatAnnotation.enumValues("with", JsonFormat.Feature.class),
+                formatAnnotation.enumValues("without", JsonFormat.Feature.class)
+            ),
+            formatAnnotation.enumValue("lenient", OptBoolean.class).orElse(OptBoolean.DEFAULT).asBoolean()
+        );
+    }
+
+    @Nullable
+    private PropertyNamingStrategy findNamingStrategy(MapperConfig<?> mapperConfig, BeanIntrospection<?> introspection) {
+        AnnotationValue<JsonNaming> namingAnnotation = introspection.getAnnotation(JsonNaming.class);
+        if (namingAnnotation != null) {
+            Optional<Class<?>> clazz = namingAnnotation.classValue();
+            if (clazz.isPresent()) {
+                try {
+                    Constructor<?> emptyConstructor = clazz.get().getConstructor();
+                    return (PropertyNamingStrategy) emptyConstructor.newInstance();
+                } catch (NoSuchMethodException ignored) {
+                    return mapperConfig.getPropertyNamingStrategy();
+                } catch (ReflectiveOperationException e) {
+                    throw new RuntimeException("Failed to construct configured PropertyNamingStrategy", e);
+                }
+            }
+        }
+        return mapperConfig.getPropertyNamingStrategy();
+    }
+
+    private String getName(MapperConfig<?> mapperConfig, @Nullable PropertyNamingStrategy namingStrategy, AnnotatedElement property) {
+        String explicitName = property.getAnnotationMetadata().stringValue(JsonProperty.class).orElse(JsonProperty.USE_DEFAULT_NAME);
+        if (!explicitName.equals(JsonProperty.USE_DEFAULT_NAME)) {
+            return explicitName;
+        }
+        String implicitName = property.getName();
+        if (namingStrategy != null) {
+            return namingStrategy.nameForGetterMethod(mapperConfig, null, implicitName);
+        } else {
+            return implicitName;
+        }
+    }
+
+    private static class IntrospectionVirtualAnnotatedMember extends VirtualAnnotatedMember {
+        private final AnnotationMetadata annotationMetadata;
+
+        public IntrospectionVirtualAnnotatedMember(TypeResolutionContext typeResolutionContext, Class<?> beanClass, String name, JavaType javaType, AnnotationMetadata annotationMetadata) {
+            super(typeResolutionContext, beanClass, name, javaType);
+            this.annotationMetadata = annotationMetadata;
+        }
+
+        @Override
+        public boolean hasOneOf(Class<? extends Annotation>[] annoClasses) {
+            return Arrays.stream(annoClasses).anyMatch(annotationMetadata::hasAnnotation);
+        }
+    }
+
+    /**
+     * Modifies bean serialization.
+     */
+    private final class BeanIntrospectionSerializerModifier extends BeanSerializerModifier {
+        @Override
+        public BeanSerializerBuilder updateBuilder(SerializationConfig config, BeanDescription beanDesc, BeanSerializerBuilder builder) {
+            final Class<?> beanClass = beanDesc.getBeanClass();
+            final BeanIntrospection<Object> introspection = findIntrospection(beanClass);
+
+            if (introspection == null) {
+                return super.updateBuilder(config, beanDesc, builder);
+            } else {
+                PropertyNamingStrategy namingStrategy = findNamingStrategy(config, introspection);
+
+                final BeanSerializerBuilder newBuilder = new BeanSerializerBuilder(beanDesc) {
+                    @Override
+                    public JsonSerializer<?> build() {
+                        setConfig(config);
+                        try {
+                            return super.build();
+                        } catch (RuntimeException e) {
+                            if (LOG.isErrorEnabled()) {
+                                LOG.error("Error building bean serializer for type [{}]: {}", beanClass, e.getMessage(), e);
+                            }
+                            throw e;
+                        }
+                    }
+                };
+
+                newBuilder.setAnyGetter(builder.getAnyGetter());
+                final List<BeanPropertyWriter> properties = builder.getProperties();
+                final Collection<BeanProperty<Object, Object>> beanProperties = introspection.getBeanProperties();
+                if (ignoreReflectiveProperties || (CollectionUtils.isEmpty(properties) && CollectionUtils.isNotEmpty(beanProperties))) {
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Bean {} has no properties, while BeanIntrospection does. Recreating from introspection.", beanClass);
+                    }
+                    TypeResolutionContext typeResolutionContext = new TypeResolutionContext.Empty(config.getTypeFactory());
+                    final List<BeanPropertyWriter> newProperties = new ArrayList<>(beanProperties.size());
+                    for (BeanProperty<Object, Object> bp : beanProperties) {
+                        if (bp.hasAnnotation(JsonIgnore.class) || bp.hasAnnotation(JsonValue.class)) {
+                            continue;
+                        }
+                        UnsafeBeanProperty<Object, Object> beanProperty = (UnsafeBeanProperty<Object, Object>) bp;
+                        final String propertyName = getName(config, namingStrategy, beanProperty);
+                        JsonSerializer<?> serializerFromAnnotation = findSerializerFromAnnotation(beanProperty, JsonSerialize.class);
+                        // normal property
+
+                        BeanPropertyWriter writer = new BeanIntrospectionPropertyWriter(
+                            new IntrospectionVirtualAnnotatedMember(
+                                typeResolutionContext,
+                                beanProperty.getDeclaringType(),
+                                propertyName,
+                                newType(beanProperty.asArgument(), config.getTypeFactory()),
+                                beanProperty
+                            ),
+                            config,
+                            propertyName,
+                            beanProperty,
+                            config.getTypeFactory(),
+                            serializerFromAnnotation
+                            // would be nice to add the TypeSerializer here too, but we don't have access to the
+                            // SerializerFactory for findPropertyTypeSerializer
+                        );
+
+                        if (bp.hasAnnotation(JsonAnyGetter.class)) {
+                            AnnotatedMember virtualMember = new IntrospectionVirtualAnnotatedMember(
+                                typeResolutionContext,
+                                beanProperty.getDeclaringType(),
+                                propertyName,
+                                newType(beanProperty.asArgument(), config.getTypeFactory()),
+                                beanProperty
+                            ) {
+                                @Override
+                                public Object getValue(Object pojo) throws IllegalArgumentException {
+                                    return beanProperty.get(pojo);
+                                }
+                            };
+                            JavaType anyType = newType(beanProperty.asArgument(), config.getTypeFactory());
+                            if (serializerFromAnnotation == null) {
+                                serializerFromAnnotation = MapSerializer.construct(/* ignored props*/ (Set<String>) null,
+                                    anyType, config.isEnabled(MapperFeature.USE_STATIC_TYPING),
+                                    null, null, null, /*filterId*/ null);
+                            }
+                            AnyGetterWriter anyGetter = new AnyGetterWriter(
+                                writer,
+                                new com.fasterxml.jackson.databind.BeanProperty.Std(
+                                    new PropertyName(bp.getName()),
+                                    anyType.getContentType(),
+                                    null,
+                                    virtualMember,
+                                    PropertyMetadata.STD_OPTIONAL
+                                ),
+                                virtualMember,
+                                serializerFromAnnotation
+                            );
+                            newBuilder.setAnyGetter(anyGetter);
+                        } else {
+                            newProperties.add(writer);
+                        }
+                    }
+
+                    if (newBuilder.getAnyGetter() != null) {
+                        // place it last
+                        newProperties.add(newBuilder.getAnyGetter());
+                    }
+                    newBuilder.setProperties(newProperties);
+                } else {
+                    if (LOG.isDebugEnabled()) {
+                        LOG.debug("Updating {} properties with BeanIntrospection data for type: {}", properties.size(), beanClass);
+                    }
+
+                    final var newProperties = new ArrayList<>(properties);
+                    var named = new LinkedHashMap<String, BeanProperty<Object, Object>>();
+                    for (BeanProperty<Object, Object> beanProperty : beanProperties) {
+                        if (!beanProperty.isWriteOnly()) {
+                            named.put(getName(config, namingStrategy, beanProperty), beanProperty);
+                        }
+                    }
+                    for (int i = 0; i < properties.size(); i++) {
+                        final BeanPropertyWriter existing = properties.get(i);
+
+                        final Optional<BeanProperty<Object, Object>> property = Optional.ofNullable(named.get(existing.getName()));
+                        // ignore properties that are @JsonIgnore, so that we don't replace other properties of the
+                        // same name
+                        if (property.isPresent() &&
+                            !property.get().isAnnotationPresent(JsonIgnore.class) &&
+                            // we can't support XmlBeanPropertyWriter easily https://github.com/micronaut-projects/micronaut-core/issues/5907
+                            !existing.getClass().getName().equals("com.fasterxml.jackson.dataformat.xml.ser.XmlBeanPropertyWriter")
+                            && !(existing instanceof AnyGetterWriter)) { // NOSONAR
+                            final UnsafeBeanProperty<Object, Object> beanProperty = (UnsafeBeanProperty<Object, Object>) property.get();
+                            newProperties.set(i, new BeanIntrospectionPropertyWriter(
+                                    existing,
+                                    beanProperty,
+                                    existing.getSerializer(),
+                                    config.getTypeFactory(),
+                                    existing.getViews()
+                                )
+                            );
+                        } else {
+                            newProperties.set(i, existing);
+                        }
+                    }
+                    newBuilder.setProperties(newProperties);
+                }
+                newBuilder.setFilteredProperties(builder.getFilteredProperties());
+                return newBuilder;
+            }
+        }
+    }
+
+    /**
+     * Modifies bean deserialization.
+     */
+    private class BeanIntrospectionDeserializerModifier extends BeanDeserializerModifier {
+
+        @Override
+        public BeanDeserializerBuilder updateBuilder(
+            DeserializationConfig config,
+            BeanDescription beanDesc,
+            BeanDeserializerBuilder builder) {
+
+            if (builder.getValueInstantiator().getDelegateType(config) != null) {
+                return builder;
+            }
+
+            final Class<?> beanClass = beanDesc.getBeanClass();
+            final var introspection = (UnsafeBeanInstantiationIntrospection<Object>) findIntrospection(beanClass);
+            if (introspection == null) {
+                return builder;
+            } else {
+                PropertyNamingStrategy propertyNamingStrategy = findNamingStrategy(config, introspection);
+
+                final Iterator<SettableBeanProperty> properties = builder.getProperties();
+                if ((ignoreReflectiveProperties || !properties.hasNext()) && introspection.getPropertyNames().length > 0) {
+                    // mismatch, probably GraalVM reflection not enabled for bean. Try recreate
+                    for (BeanProperty<Object, Object> beanProperty : introspection.getBeanProperties()) {
+                        if (!beanProperty.isReadOnly()) {
+                            builder.addOrReplaceProperty(new VirtualSetter(
+                                    beanDesc.getClassInfo(),
+                                    config.getTypeFactory(),
+                                    (UnsafeBeanProperty<Object, Object>) beanProperty,
+                                    getName(config, propertyNamingStrategy, beanProperty),
+                                    findSerializerFromAnnotation(beanProperty, JsonDeserialize.class)),
+                                true);
+                        }
+                    }
+                } else {
+                    var remainingProperties = new LinkedHashMap<String, BeanProperty<Object, Object>>();
+                    for (BeanProperty<Object, Object> beanProperty : introspection.getBeanProperties()) {
+                        // ignore properties that are @JsonIgnore, so that we don't replace other properties of the
+                        // same name
+                        if (beanProperty.isAnnotationPresent(JsonIgnore.class)) {
+                            continue;
+                        }
+
+                        remainingProperties.put(getName(config, propertyNamingStrategy, beanProperty), beanProperty);
+                    }
+                    while (properties.hasNext()) {
+                        final SettableBeanProperty settableBeanProperty = properties.next();
+                        if (settableBeanProperty instanceof MethodProperty methodProperty) {
+                            final UnsafeBeanProperty<Object, Object> beanProperty =
+                                (UnsafeBeanProperty<Object, Object>) remainingProperties.remove(settableBeanProperty.getName());
+
+                            if (beanProperty != null && !beanProperty.isReadOnly()) {
+                                SettableBeanProperty newProperty = new BeanIntrospectionSetter(
+                                    methodProperty,
+                                    beanProperty
+                                );
+                                builder.addOrReplaceProperty(newProperty, true);
+                            }
+                        }
+                    }
+                    // add any remaining properties. This can happen if the supertype has reflection-visible properties
+                    // so `properties` isn't empty, but the subtype doesn't have reflection enabled.
+                    for (Map.Entry<String, BeanProperty<Object, Object>> entry : remainingProperties.entrySet()) {
+                        if (!entry.getValue().isReadOnly()) {
+                            SettableBeanProperty existing = builder.findProperty(PropertyName.construct(entry.getKey()));
+                            if (existing == null) {
+                                builder.addOrReplaceProperty(new VirtualSetter(
+                                        beanDesc.getClassInfo(),
+                                        config.getTypeFactory(),
+                                        (UnsafeBeanProperty<Object, Object>) entry.getValue(),
+                                        entry.getKey(),
+                                        findSerializerFromAnnotation(entry.getValue(), JsonDeserialize.class)),
+                                    true);
+                            }
+                        }
+                    }
+                }
+
+                final Argument<?>[] constructorArguments = introspection.getConstructorArguments();
+                final TypeFactory typeFactory = config.getTypeFactory();
+                ValueInstantiator defaultInstantiator = builder.getValueInstantiator();
+                builder.setValueInstantiator(new StdValueInstantiator(config, typeFactory.constructType(beanClass)) {
+                    SettableBeanProperty[] props;
+
+                    @Override
+                    public SettableBeanProperty[] getFromObjectArguments(DeserializationConfig config) {
+
+                        SettableBeanProperty[] existing = ignoreReflectiveProperties ? null : defaultInstantiator.getFromObjectArguments(config);
+                        if (props == null) {
+                            props = new SettableBeanProperty[constructorArguments.length];
+                            for (int i = 0; i < constructorArguments.length; i++) {
+                                Argument<?> argument = constructorArguments[i];
+                                SettableBeanProperty existingProperty = existing != null && existing.length > i ? existing[i] : null;
+                                final JavaType javaType = existingProperty != null ? existingProperty.getType() : newType(argument, typeFactory);
+                                final AnnotationMetadata annotationMetadata = argument.getAnnotationMetadata();
+                                PropertyMetadata propertyMetadata = newPropertyMetadata(argument, annotationMetadata);
+                                final String simpleName = existingProperty != null ? existingProperty.getName() : getName(config, propertyNamingStrategy, argument);
+                                TypeDeserializer typeDeserializer;
+                                try {
+                                    typeDeserializer = config.findTypeDeserializer(javaType);
+                                } catch (JsonMappingException e) {
+                                    typeDeserializer = null;
+                                }
+                                PropertyName propertyName = PropertyName.construct(simpleName);
+                                if (typeDeserializer == null) {
+                                    SettableBeanProperty settableBeanProperty = builder.findProperty(propertyName);
+                                    if (settableBeanProperty != null) {
+                                        typeDeserializer = settableBeanProperty.getValueTypeDeserializer();
+                                    }
+                                }
+
+                                props[i] = new CreatorProperty(
+                                    propertyName,
+                                    javaType,
+                                    null,
+                                    typeDeserializer,
+                                    null,
+                                    null,
+                                    i,
+                                    null,
+                                    propertyMetadata
+
+                                ) {
+                                    private final UnsafeBeanProperty<Object, Object> property = (UnsafeBeanProperty<Object, Object>) introspection.getProperty(argument.getName()).orElse(null);
+
+                                    @Override
+                                    public <A extends Annotation> A getAnnotation(Class<A> acls) {
+                                        return annotationMetadata.synthesize(acls);
+                                    }
+
+                                    @Override
+                                    public AnnotatedMember getMember() {
+                                        return new IntrospectionVirtualAnnotatedMember(beanDesc.getClassInfo(), beanClass, argument.getName(), javaType, annotationMetadata);
+                                    }
+
+                                    @Override
+                                    public void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {
+                                        if (property != null) {
+                                            property.setUnsafe(instance, deserialize(p, ctxt));
+                                        }
+                                    }
+
+                                    @Override
+                                    public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {
+                                        if (property != null) {
+                                            property.setUnsafe(instance, deserialize(p, ctxt));
+                                        }
+                                        return null;
+                                    }
+
+                                    @Override
+                                    public void set(Object instance, Object value) {
+                                        if (property != null) {
+                                            property.setUnsafe(instance, value);
+                                        }
+                                    }
+
+                                    @Override
+                                    public Object setAndReturn(Object instance, Object value) {
+                                        if (property != null) {
+                                            property.setUnsafe(instance, value);
+                                        }
+                                        return null;
+                                    }
+
+                                    @Override
+                                    public JsonFormat.Value findPropertyFormat(MapperConfig<?> config, Class<?> baseType) {
+                                        JsonFormat.Value v1 = config.getDefaultPropertyFormat(baseType);
+                                        JsonFormat.Value v2 = null;
+                                        if (property != null) {
+                                            AnnotationValue<JsonFormat> formatAnnotation = property.getAnnotation(JsonFormat.class);
+                                            if (formatAnnotation != null) {
+                                                v2 = parseJsonFormat(formatAnnotation);
+                                            }
+                                        }
+                                        if (v1 == null) {
+                                            return (v2 == null) ? EMPTY_FORMAT : v2;
+                                        }
+                                        return (v2 == null) ? v1 : v1.withOverrides(v2);
+                                    }
+                                };
+                            }
+                        }
+                        return props;
+                    }
+
+                    @Override
+                    public boolean canInstantiate() {
+                        return true;
+                    }
+
+                    @Override
+                    public boolean canCreateUsingDefault() {
+                        return constructorArguments.length == 0;
+                    }
+
+                    @Override
+                    public boolean canCreateFromObjectWith() {
+                        return constructorArguments.length > 0;
+                    }
+
+                    @Override
+                    public boolean canCreateUsingArrayDelegate() {
+                        return defaultInstantiator.canCreateUsingArrayDelegate();
+                    }
+
+                    @Override
+                    public boolean canCreateUsingDelegate() {
+                        return false;
+                    }
+
+                    @Override
+                    public JavaType getArrayDelegateType(DeserializationConfig config) {
+                        return newType(constructorArguments[0], typeFactory);
+                    }
+
+                    @Override
+                    public JavaType getDelegateType(DeserializationConfig config) {
+                        return newType(constructorArguments[0], typeFactory);
+                    }
+
+                    @Override
+                    public boolean canCreateFromString() {
+                        return constructorArguments.length == 1 && constructorArguments[0].equalsType(Argument.STRING);
+                    }
+
+                    @Override
+                    public boolean canCreateFromInt() {
+                        return constructorArguments.length == 1 && (
+                            constructorArguments[0].equalsType(Argument.INT) ||
+                                constructorArguments[0].equalsType(Argument.LONG));
+                    }
+
+                    @Override
+                    public boolean canCreateFromLong() {
+                        return constructorArguments.length == 1 && constructorArguments[0].equalsType(Argument.LONG);
+                    }
+
+                    @Override
+                    public boolean canCreateFromDouble() {
+                        return constructorArguments.length == 1 && constructorArguments[0].equalsType(Argument.DOUBLE);
+                    }
+
+                    @Override
+                    public boolean canCreateFromBoolean() {
+                        return constructorArguments.length == 1 && constructorArguments[0].equalsType(Argument.BOOLEAN);
+                    }
+
+                    @Override
+                    public Object createUsingDefault(DeserializationContext ctxt) {
+                        return introspection.instantiate();
+                    }
+
+                    @Override
+                    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) {
+                        if (preInstantiateCallback != null) {
+                            preInstantiateCallback.preInstantiate(introspection, delegate);
+                        }
+                        return introspection.instantiate(false, new Object[] { delegate });
+                    }
+
+                    @Override
+                    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) {
+                        if (preInstantiateCallback != null) {
+                            preInstantiateCallback.preInstantiate(introspection, args);
+                        }
+                        return ((UnsafeBeanInstantiationIntrospection<?>) introspection).instantiateUnsafe(args);
+                    }
+
+                    @Override
+                    public Object createUsingArrayDelegate(DeserializationContext ctxt, Object delegate) {
+                        if (preInstantiateCallback != null) {
+                            preInstantiateCallback.preInstantiate(introspection, delegate);
+                        }
+                        return introspection.instantiateUnsafe(new Object[] { delegate });                    }
+
+                    @Override
+                    public Object createFromString(DeserializationContext ctxt, String value) {
+                        if (preInstantiateCallback != null) {
+                            preInstantiateCallback.preInstantiate(introspection, value);
+                        }
+                        return introspection.instantiateUnsafe(new Object[]{ value });
+                    }
+
+                    @Override
+                    public Object createFromInt(DeserializationContext ctxt, int value) {
+                        if (preInstantiateCallback != null) {
+                            preInstantiateCallback.preInstantiate(introspection, value);
+                        }
+                        InstantiationException originalException;
+                        try {
+                            return introspection.instantiate(false, new Object[]{value});
+                        } catch (InstantiationException e) {
+                            originalException = e;
+                        }
+                        try {
+                            return introspection.instantiate(false, new Object[]{Long.valueOf(value)});
+                        } catch (InstantiationException e) {
+                            throw originalException;
+                        }
+                    }
+
+                    @Override
+                    public Object createFromLong(DeserializationContext ctxt, long value) {
+                        if (preInstantiateCallback != null) {
+                            preInstantiateCallback.preInstantiate(introspection, value);
+                        }
+                        return introspection.instantiateUnsafe(new Object[]{ value });
+                    }
+
+                    @Override
+                    public Object createFromDouble(DeserializationContext ctxt, double value) {
+                        if (preInstantiateCallback != null) {
+                            preInstantiateCallback.preInstantiate(introspection, value);
+                        }
+                        return introspection.instantiateUnsafe(new Object[]{ value });
+                    }
+
+                    @Override
+                    public Object createFromBoolean(DeserializationContext ctxt, boolean value) {
+                        if (preInstantiateCallback != null) {
+                            preInstantiateCallback.preInstantiate(introspection, value);
+                        }
+                        return introspection.instantiateUnsafe(new Object[]{ value });
+                    }
+
+                });
+                return builder;
+            }
+        }
+    }
+
+    /**
+     * A virtual property setter.
+     */
+    private class VirtualSetter extends SettableBeanProperty {
+
+        final UnsafeBeanProperty<Object, Object> beanProperty;
+        final TypeResolutionContext typeResolutionContext;
+
+        VirtualSetter(TypeResolutionContext typeResolutionContext,
+                      TypeFactory typeFactory,
+                      UnsafeBeanProperty<Object, Object> beanProperty,
+                      String propertyName,
+                      JsonDeserializer<Object> valueDeser) {
+            super(
+                new PropertyName(propertyName),
+                newType(beanProperty.asArgument(), typeFactory),
+                newPropertyMetadata(beanProperty.asArgument(), beanProperty.getAnnotationMetadata()), valueDeser);
+            this.beanProperty = beanProperty;
+            this.typeResolutionContext = typeResolutionContext;
+        }
+
+        VirtualSetter(PropertyName propertyName, VirtualSetter src) {
+            super(propertyName, src._type, src._metadata, src._valueDeserializer);
+            this.beanProperty = src.beanProperty;
+            this.typeResolutionContext = src.typeResolutionContext;
+        }
+
+        VirtualSetter(NullValueProvider nullValueProvider, VirtualSetter src) {
+            super(src, src._valueDeserializer, nullValueProvider);
+            this.beanProperty = src.beanProperty;
+            this.typeResolutionContext = src.typeResolutionContext;
+        }
+
+        VirtualSetter(JsonDeserializer<Object> deser, VirtualSetter src) {
+            super(src._propName, src._type, src._metadata, deser);
+            this.beanProperty = src.beanProperty;
+            this.typeResolutionContext = src.typeResolutionContext;
+        }
+
+        @Override
+        public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {
+            return new VirtualSetter((JsonDeserializer<Object>) deser, this);
+        }
+
+        @Override
+        public SettableBeanProperty withName(PropertyName newName) {
+            return new VirtualSetter(newName, this);
+        }
+
+        @Override
+        public SettableBeanProperty withNullProvider(NullValueProvider nva) {
+            return new VirtualSetter(nva, this);
+        }
+
+        @Override
+        public AnnotatedMember getMember() {
+            return new IntrospectionVirtualAnnotatedMember(
+                typeResolutionContext,
+                beanProperty.getDeclaringType(),
+                _propName.getSimpleName(),
+                _type,
+                beanProperty
+            );
+        }
+
+        @Override
+        public <A extends Annotation> A getAnnotation(Class<A> acls) {
+            return beanProperty.getAnnotationMetadata().synthesize(acls);
+        }
+
+        @Override
+        public void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {
+            beanProperty.setUnsafe(instance, deserialize(p, ctxt));
+        }
+
+        @Override
+        public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {
+            beanProperty.setUnsafe(instance, deserialize(p, ctxt));
+            return null;
+        }
+
+        @Override
+        public void set(Object instance, Object value) {
+            beanProperty.setUnsafe(instance, value);
+        }
+
+        @Override
+        public Object setAndReturn(Object instance, Object value) {
+            beanProperty.setUnsafe(instance, value);
+            return null;
+        }
+
+        @Override
+        public JsonFormat.Value findPropertyFormat(MapperConfig<?> config, Class<?> baseType) {
+            JsonFormat.Value v1 = config.getDefaultPropertyFormat(baseType);
+            JsonFormat.Value v2 = null;
+            AnnotationValue<JsonFormat> formatAnnotation = beanProperty.getAnnotation(JsonFormat.class);
+            if (formatAnnotation != null) {
+                v2 = parseJsonFormat(formatAnnotation);
+            }
+            if (v1 == null) {
+                return (v2 == null) ? EMPTY_FORMAT : v2;
+            }
+            return (v2 == null) ? v1 : v1.withOverrides(v2);
+        }
+    }
+
+
+    /**
+     * Introspected property writer.
+     */
+    private class BeanIntrospectionPropertyWriter extends BeanPropertyWriter {
+        protected final Class<?>[] _views;
+        final UnsafeBeanProperty<Object, Object> beanProperty;
+        final SerializableString fastName;
+        private final JavaType type;
+        private final boolean unwrapping;
+
+        BeanIntrospectionPropertyWriter(BeanPropertyWriter src,
+                                        UnsafeBeanProperty<Object, Object> beanProperty,
+                                        JsonSerializer<Object> ser,
+                                        TypeFactory typeFactory,
+                                        Class<?>[] views) {
+            this(src.getSerializedName(), src, beanProperty, ser, typeFactory, views);
+        }
+
+        BeanIntrospectionPropertyWriter(SerializableString name,
+                                        BeanPropertyWriter src,
+                                        UnsafeBeanProperty<Object, Object> beanProperty,
+                                        JsonSerializer<Object> ser,
+                                        TypeFactory typeFactory,
+                                        Class<?>[] views) {
+            super(src);
+            // either use the passed on serializer or the original one
+            _serializer = (ser != null) ? ser : src.getSerializer();
+            this.beanProperty = beanProperty;
+            fastName = name;
+            _views = views;
+            this.type = JacksonConfiguration.constructType(this.beanProperty.asArgument(), typeFactory);
+            _dynamicSerializers = (ser == null) ? PropertySerializerMap
+                .emptyForProperties() : null;
+            this.unwrapping = beanProperty.hasAnnotation(JsonUnwrapped.class);
+        }
+
+        BeanIntrospectionPropertyWriter(
+            AnnotatedMember virtualMember,
+            SerializationConfig config,
+            String name,
+            UnsafeBeanProperty<Object, Object> beanProperty,
+            TypeFactory typeFactory,
+            JsonSerializer<?> ser) {
+            super(
+                SimpleBeanPropertyDefinition.construct(config, virtualMember),
+                virtualMember,
+                AnnotationCollector.emptyAnnotations(),
+                JacksonConfiguration.constructType(beanProperty.asArgument(), typeFactory),
+                ser, null, null,
+                suppressNulls(config.getDefaultPropertyInclusion()),
+                suppressableValue(config.getDefaultPropertyInclusion()),
+                null
+            );
+            this.type = super.getType();
+            this.beanProperty = beanProperty;
+            fastName = new SerializedString(name);
+            _views = null;
+            _dynamicSerializers = PropertySerializerMap
+                .emptyForProperties();
+            this.unwrapping = beanProperty.hasAnnotation(JsonUnwrapped.class);
+        }
+
+        @Override
+        public boolean isUnwrapping() {
+            return unwrapping;
+        }
+
+        @Override
+        public String getName() {
+            return fastName.getValue();
+        }
+
+        @Override
+        public PropertyName getFullName() {
+            return new PropertyName(getName());
+        }
+
+        @Override
+        public void fixAccess(SerializationConfig config) {
+            // no-op
+        }
+
+        @Override
+        public JavaType getType() {
+            return type;
+        }
+
+        private boolean inView(Class<?> activeView) {
+            if (activeView == null || _views == null) {
+                return true;
+            }
+            final int len = _views.length;
+            for (int i = 0; i < len; ++i) {
+                if (_views[i].isAssignableFrom(activeView)) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        @Override
+        public final void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception {
+            if (!inView(prov.getActiveView())) {
+                serializeAsOmittedField(bean, gen, prov);
+                return;
+            }
+            Object value = beanProperty.get(bean);
+            // Null (etc.) handling; copied from super-class impl
+            if (value == null) {
+                boolean willSuppressNulls = willSuppressNulls();
+                if (!willSuppressNulls && _nullSerializer != null) {
+                    if (!isUnwrapping()) {
+                        gen.writeFieldName(fastName);
+                        _nullSerializer.serialize(null, gen, prov);
+                    }
+                } else if (!willSuppressNulls) {
+                    gen.writeFieldName(fastName);
+                    prov.defaultSerializeNull(gen);
+                }
+                return;
+            }
+            JsonSerializer<Object> ser = _serializer;
+            if (ser == null) {
+                Class<?> cls = value.getClass();
+                PropertySerializerMap map = _dynamicSerializers;
+                ser = map.serializerFor(cls);
+                if (ser == null) {
+                    ser = _findAndAddDynamic(map, cls, prov);
+                }
+            }
+            if (_suppressableValue != null) {
+                if (MARKER_FOR_EMPTY == _suppressableValue) {
+                    if (ser.isEmpty(prov, value)) {
+                        return;
+                    }
+                } else if (_suppressableValue.equals(value)) {
+                    return;
+                }
+            }
+            if (value == bean && _handleSelfReference(bean, gen, prov, ser)) {
+                // three choices: exception; handled by call; or pass-through
+                return;
+            }
+            if (isUnwrapping()) {
+                JsonSerializer<Object> unwrappingSerializer = ser.unwrappingSerializer(null);
+                unwrappingSerializer.serialize(value, gen, prov);
+            } else {
+                gen.writeFieldName(fastName);
+                if (_typeSerializer == null) {
+                    ser.serialize(value, gen, prov);
+                } else {
+                    ser.serializeWithType(value, gen, prov, _typeSerializer);
+                }
+            }
+        }
+
+        @Override
+        public final void serializeAsElement(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception {
+            if (!inView(prov.getActiveView())) {
+                serializeAsOmittedField(bean, gen, prov);
+                return;
+            }
+
+            Object value = beanProperty.get(bean);
+            // Null (etc.) handling; copied from super-class impl
+            if (value == null) {
+                boolean willSuppressNulls = willSuppressNulls();
+                if (!willSuppressNulls && _nullSerializer != null) {
+                    _nullSerializer.serialize(null, gen, prov);
+                } else if (willSuppressNulls) {
+                    serializeAsPlaceholder(bean, gen, prov);
+                } else {
+                    prov.defaultSerializeNull(gen);
+                }
+                return;
+            }
+            JsonSerializer<Object> ser = _serializer;
+            if (ser == null) {
+                Class<?> cls = value.getClass();
+                PropertySerializerMap map = _dynamicSerializers;
+                ser = map.serializerFor(cls);
+                if (ser == null) {
+                    ser = _findAndAddDynamic(map, cls, prov);
+                }
+            }
+            if (_suppressableValue != null) {
+                if (MARKER_FOR_EMPTY == _suppressableValue) {
+                    if (ser.isEmpty(prov, value)) {
+                        serializeAsPlaceholder(bean, gen, prov);
+                        return;
+                    }
+                } else if (_suppressableValue.equals(value)) {
+                    serializeAsPlaceholder(bean, gen, prov);
+                    return;
+                }
+            }
+            if (value == bean && _handleSelfReference(bean, gen, prov, ser)) {
+                // three choices: exception; handled by call; or pass-through
+                return;
+            }
+            if (_typeSerializer == null) {
+                ser.serialize(value, gen, prov);
+            } else {
+                ser.serializeWithType(value, gen, prov, _typeSerializer);
+            }
+        }
+
+        @Override
+        public JsonFormat.Value findPropertyFormat(MapperConfig<?> config, Class<?> baseType) {
+            JsonFormat.Value v1 = config.getDefaultPropertyFormat(baseType);
+            JsonFormat.Value v2 = null;
+            AnnotationValue<JsonFormat> formatAnnotation = beanProperty.getAnnotation(JsonFormat.class);
+            if (formatAnnotation != null) {
+                v2 = parseJsonFormat(formatAnnotation);
+            }
+            if (v1 == null) {
+                return (v2 == null) ? EMPTY_FORMAT : v2;
+            }
+            return (v2 == null) ? v1 : v1.withOverrides(v2);
+        }
+    }
+
+    /**
+     * A bean introspection setter.
+     */
+    private static final class BeanIntrospectionSetter extends SettableBeanProperty.Delegating {
+
+        final UnsafeBeanProperty<Object, Object> beanProperty;
+
+        BeanIntrospectionSetter(SettableBeanProperty methodProperty, UnsafeBeanProperty<Object, Object> beanProperty) {
+            super(methodProperty);
+            this.beanProperty = beanProperty;
+        }
+
+        @Override
+        protected SettableBeanProperty withDelegate(SettableBeanProperty d) {
+            return new BeanIntrospectionSetter(d, beanProperty);
+        }
+
+        @Override
+        public void deserializeAndSet(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {
+            beanProperty.setUnsafe(instance, deserialize(p, ctxt));
+        }
+
+        @Override
+        public Object deserializeSetAndReturn(JsonParser p, DeserializationContext ctxt, Object instance) throws IOException {
+            beanProperty.setUnsafe(instance, deserialize(p, ctxt));
+            return null;
+        }
+
+        @Override
+        public void set(Object instance, Object value) {
+            beanProperty.setUnsafe(instance, value);
+        }
+
+        @Override
+        public Object setAndReturn(Object instance, Object value) {
+            beanProperty.setUnsafe(instance, value);
+            return null;
+        }
+    }
+
+    private class BeanIntrospectionAccessorNamingStrategyProvider extends AccessorNamingStrategy.Provider {
+        private final AccessorNamingStrategy.Provider delegate;
+
+        BeanIntrospectionAccessorNamingStrategyProvider(AccessorNamingStrategy.Provider delegate) {
+            this.delegate = delegate;
+        }
+
+        @Override
+        public AccessorNamingStrategy forPOJO(MapperConfig<?> config, AnnotatedClass valueClass) {
+            return delegate.forPOJO(config, valueClass);
+        }
+
+        @Override
+        public AccessorNamingStrategy forBuilder(MapperConfig<?> config, AnnotatedClass builderClass, BeanDescription valueTypeDesc) {
+            return delegate.forBuilder(config, builderClass, valueTypeDesc);
+        }
+
+        @Override
+        public AccessorNamingStrategy forRecord(MapperConfig<?> config, AnnotatedClass recordClass) {
+            BeanIntrospection<Object> introspection = findIntrospection(recordClass.getRawType());
+            if (introspection != null) {
+                return new DefaultAccessorNamingStrategy(config, recordClass, null, "get", "is", null) {
+                    final Set<String> names = introspection.getBeanProperties().stream().map(BeanProperty::getName).collect(Collectors.toSet());
+
+                    @Override
+                    public String findNameForRegularGetter(AnnotatedMethod am, String name) {
+                        if (names.contains(name)) {
+                            return name;
+                        }
+                        return super.findNameForRegularGetter(am, name);
+                    }
+                };
+            } else {
+                try {
+                    return delegate.forRecord(config, recordClass);
+                } catch (IllegalArgumentException e) {
+                    if (e.getMessage().startsWith("Failed to access RecordComponents of type")) {
+                        throw new RuntimeException("Failed to construct AccessorNamingStrategy for record. This can happen when running in native-image. Either make this type @Introspected, or mark it for @ReflectiveAccess.", e);
+                    } else {
+                        throw e;
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/modules/package-info.java b/jackson-databind/src/main/java/io/micronaut/jackson/modules/package-info.java
new file mode 100644
index 0000000000..dc82dbb243
--- /dev/null
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/modules/package-info.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright 2017-2020 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/**
+ * Contains factories for modules.
+ *
+ * @author graemerocher
+ * @since 1.1
+ */
+package io.micronaut.jackson.modules;
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/serialize/ResourceDeserializerModifier.java b/jackson-databind/src/main/java/io/micronaut/jackson/serialize/ResourceDeserializerModifier.java
index 9c17fbc05d..8890e92acf 100644
--- a/jackson-databind/src/main/java/io/micronaut/jackson/serialize/ResourceDeserializerModifier.java
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/serialize/ResourceDeserializerModifier.java
@@ -19,8 +19,10 @@ import com.fasterxml.jackson.databind.BeanDescription;
 import com.fasterxml.jackson.databind.DeserializationConfig;
 import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;
 import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.http.hateoas.Resource;
+import io.micronaut.jackson.modules.BeanIntrospectionModule;
 
 import java.util.List;
 
@@ -29,6 +31,7 @@ import java.util.List;
  * @since 1.0
  */
 @Internal
+@Requires(missingBeans = BeanIntrospectionModule.class)
 public class ResourceDeserializerModifier extends BeanDeserializerModifier {
 
     @Override
diff --git a/jackson-databind/src/main/java/io/micronaut/jackson/serialize/ResourceSerializerModifier.java b/jackson-databind/src/main/java/io/micronaut/jackson/serialize/ResourceSerializerModifier.java
index fc3ff27d8a..55c0f7b715 100644
--- a/jackson-databind/src/main/java/io/micronaut/jackson/serialize/ResourceSerializerModifier.java
+++ b/jackson-databind/src/main/java/io/micronaut/jackson/serialize/ResourceSerializerModifier.java
@@ -20,8 +20,10 @@ import com.fasterxml.jackson.databind.SerializationConfig;
 import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;
 import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;
 import com.fasterxml.jackson.databind.util.NameTransformer;
+import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.http.hateoas.Resource;
+import io.micronaut.jackson.modules.BeanIntrospectionModule;
 import jakarta.inject.Singleton;
 
 import java.util.Iterator;
@@ -35,6 +37,7 @@ import java.util.List;
  */
 @Internal
 @Singleton
+@Requires(missingBeans = BeanIntrospectionModule.class)
 class ResourceSerializerModifier extends BeanSerializerModifier {
 
     @Override
diff --git a/jackson-databind/src/test/groovy/io/micronaut/jackson/modules/BeanIntrospectionModuleRecordSpec.groovy b/jackson-databind/src/test/groovy/io/micronaut/jackson/modules/BeanIntrospectionModuleRecordSpec.groovy
new file mode 100644
index 0000000000..7e2de0c5e3
--- /dev/null
+++ b/jackson-databind/src/test/groovy/io/micronaut/jackson/modules/BeanIntrospectionModuleRecordSpec.groovy
@@ -0,0 +1,78 @@
+package io.micronaut.jackson.modules
+
+import com.fasterxml.jackson.databind.ObjectMapper
+import io.micronaut.annotation.processing.test.AbstractTypeElementSpec
+import io.micronaut.context.ApplicationContext
+import io.micronaut.context.annotation.Replaces
+import io.micronaut.context.annotation.Requires
+import io.micronaut.core.beans.BeanIntrospection
+import jakarta.inject.Singleton
+import spock.lang.IgnoreIf
+import spock.lang.Issue
+
+import java.time.LocalDateTime
+
+class BeanIntrospectionModuleRecordSpec extends AbstractTypeElementSpec {
+    def 'test record support'() {
+        given:
+        BeanIntrospection introspection = buildBeanIntrospection('test.Test', '''
+package test;
+import io.micronaut.core.annotation.Introspected;
+
+@Introspected
+record Test(String foo, String bar) {
+}
+''')
+        def ctx = ApplicationContext.run(['spec.name': 'BeanIntrospectionModuleRecordSpec'])
+        ctx.getBean(StaticBeanIntrospectionModule).introspectionMap[introspection.beanType] = introspection
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        def mapper = ctx.getBean(ObjectMapper)
+
+        when:
+        def value = mapper.readValue('{"foo":"1","bar":"2"}', introspection.beanType)
+        then:
+        value.foo == '1'
+        value.bar == '2'
+
+        where:
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    @Issue('https://github.com/micronaut-projects/micronaut-core/issues/8330')
+    def 'JsonFormat'() {
+        given:
+        BeanIntrospection introspection = buildBeanIntrospection('test.Test', '''
+package test;
+import java.time.LocalDateTime;
+import com.fasterxml.jackson.annotation.JsonFormat;
+import io.micronaut.core.annotation.Introspected;
+
+@Introspected
+record Test(@JsonFormat(pattern = "dd.MM.yyyy HH:mm:ss") LocalDateTime date) {
+}
+''')
+        def ctx = ApplicationContext.run(['spec.name': 'BeanIntrospectionModuleRecordSpec'])
+        ctx.getBean(StaticBeanIntrospectionModule).introspectionMap[introspection.beanType] = introspection
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        def mapper = ctx.getBean(ObjectMapper)
+
+        when:
+        def value = mapper.readValue('{"date":"13.11.2022 22:44:55"}', introspection.beanType)
+        then:
+        value.date == LocalDateTime.of(2022, 11, 13, 22, 44, 55)
+
+        where:
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    @Singleton
+    @Replaces(BeanIntrospectionModule)
+    @Requires(property = "spec.name", value = 'BeanIntrospectionModuleRecordSpec')
+    static class StaticBeanIntrospectionModule extends BeanIntrospectionModule {
+        Map<Class<?>, BeanIntrospection> introspectionMap = [:]
+        @Override
+        protected BeanIntrospection<Object> findIntrospection(Class<?> beanClass) {
+            return introspectionMap.get(beanClass)
+        }
+    }
+}
diff --git a/jackson-databind/src/test/groovy/io/micronaut/jackson/modules/BeanIntrospectionModuleSpec.groovy b/jackson-databind/src/test/groovy/io/micronaut/jackson/modules/BeanIntrospectionModuleSpec.groovy
new file mode 100644
index 0000000000..9186db718d
--- /dev/null
+++ b/jackson-databind/src/test/groovy/io/micronaut/jackson/modules/BeanIntrospectionModuleSpec.groovy
@@ -0,0 +1,1229 @@
+package io.micronaut.jackson.modules
+
+import com.fasterxml.jackson.annotation.JsonAnyGetter
+import com.fasterxml.jackson.annotation.JsonAnySetter
+import com.fasterxml.jackson.annotation.JsonCreator
+import com.fasterxml.jackson.annotation.JsonFormat
+import com.fasterxml.jackson.annotation.JsonIgnore
+import com.fasterxml.jackson.annotation.JsonInclude
+import com.fasterxml.jackson.annotation.JsonProperty
+import com.fasterxml.jackson.annotation.JsonUnwrapped
+import com.fasterxml.jackson.annotation.JsonView
+import com.fasterxml.jackson.core.JsonGenerator
+import com.fasterxml.jackson.core.JsonParser
+import com.fasterxml.jackson.core.JsonProcessingException
+import com.fasterxml.jackson.databind.DeserializationContext
+import com.fasterxml.jackson.databind.JsonDeserializer
+import com.fasterxml.jackson.databind.JsonSerializer
+import com.fasterxml.jackson.databind.ObjectMapper
+import com.fasterxml.jackson.databind.PropertyNamingStrategies
+import com.fasterxml.jackson.databind.SerializerProvider
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize
+import com.fasterxml.jackson.databind.annotation.JsonNaming
+import com.fasterxml.jackson.databind.annotation.JsonSerialize
+import com.fasterxml.jackson.dataformat.xml.XmlMapper
+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper
+import groovy.transform.EqualsAndHashCode
+import groovy.transform.PackageScope
+import io.micronaut.context.ApplicationContext
+import io.micronaut.core.annotation.Creator
+import io.micronaut.core.annotation.Introspected
+import io.micronaut.http.hateoas.JsonError
+import io.micronaut.jackson.JacksonConfiguration
+import io.micronaut.jackson.modules.testcase.EmailTemplate
+import io.micronaut.jackson.modules.testcase.Notification
+import io.micronaut.jackson.modules.testclasses.HTTPCheck
+import io.micronaut.jackson.modules.testclasses.InstanceInfo
+import io.micronaut.jackson.modules.wrappers.BooleanWrapper
+import io.micronaut.jackson.modules.wrappers.DoubleWrapper
+import io.micronaut.jackson.modules.wrappers.IntWrapper
+import io.micronaut.jackson.modules.wrappers.IntegerWrapper
+import io.micronaut.jackson.modules.wrappers.LongWrapper
+import io.micronaut.jackson.modules.wrappers.StringWrapper
+import io.micronaut.json.JsonMapper
+import spock.lang.Issue
+import spock.lang.Specification
+import spock.lang.Unroll
+
+import java.beans.ConstructorProperties
+import java.time.LocalDateTime
+
+class BeanIntrospectionModuleSpec extends Specification {
+
+    void "test serialize/deserialize wrap/unwrap - simple"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run(
+                'jackson.deserialization.UNWRAP_ROOT_VALUE': true,
+                'jackson.serialization.WRAP_ROOT_VALUE': true
+        )
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        Author author = new Author(name:"Bob")
+
+        String result = objectMapper.writeValueAsString(author)
+
+        then:
+        result == '{"Author":{"name":"Bob"}}'
+
+        when:
+        def read = objectMapper.readValue(result, Author)
+
+        then:
+        author == read
+
+    }
+
+    void "test serialize/deserialize wrap/unwrap -* complex"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run(
+                'jackson.deserialization.UNWRAP_ROOT_VALUE': true,
+                'jackson.serialization.WRAP_ROOT_VALUE': true
+        )
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        HTTPCheck check = new HTTPCheck(headers:[
+                Accept:['application/json', 'application/xml']
+        ] )
+
+        String result = objectMapper.writeValueAsString(check)
+
+        then:
+        result == '{"HTTPCheck":{"Header":{"Accept":["application/json","application/xml"]}}}'
+
+        when:
+        def read = objectMapper.readValue(result, HTTPCheck)
+
+        then:
+        check == read
+
+    }
+
+    void "test serialize/deserialize wrap/unwrap -* constructors"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run(
+                'jackson.deserialization.UNWRAP_ROOT_VALUE': true,
+                'jackson.serialization.WRAP_ROOT_VALUE': true
+        )
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        IntrospectionCreator check = new IntrospectionCreator("test")
+
+        String result = objectMapper.writeValueAsString(check)
+
+        then:
+        result == '{"IntrospectionCreator":{"label":"TEST"}}'
+
+        when:
+        def read = objectMapper.readValue(result, IntrospectionCreator)
+
+        then:
+        check == read
+
+    }
+
+    void "test serialize/deserialize wrap/unwrap -* constructors & JsonRootName"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run(
+                'jackson.deserialization.UNWRAP_ROOT_VALUE': true,
+                'jackson.serialization.WRAP_ROOT_VALUE': true
+        )
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        InstanceInfo check = new InstanceInfo("test")
+
+        String result = objectMapper.writeValueAsString(check)
+
+        then:
+        result == '{"instance":{"hostName":"test"}}'
+
+        when:
+        def read = objectMapper.readValue(result, InstanceInfo)
+
+        then:
+        check == read
+
+    }
+
+
+    void "test serialize/deserialize convertible values"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        HTTPCheck check = new HTTPCheck(headers:[
+                Accept:['application/json', 'application/xml']
+        ] )
+
+        String result = objectMapper.writeValueAsString(check)
+
+        then:
+        result == '{"Header":{"Accept":["application/json","application/xml"]}}'
+
+        when:
+        def read = objectMapper.readValue(result, HTTPCheck)
+
+        then:
+        check.header.getAll("Accept") == read.header.getAll("Accept")
+
+    }
+
+    void "Bean introspection works with a bean without JsonIgnore annotations"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        IgnoreTest guide = new IgnoreTest(name:"Test", code: 9999)
+        String json = objectMapper.writeValueAsString(guide)
+
+        then:
+        noExceptionThrown()
+        json == '{"name":"Test"}'
+
+        cleanup:
+        ctx.close()
+    }
+
+    void "Bean introspection works with a bean without JsonInclude annotations"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        GuideWithoutJsonIncludeAnnotations guide = new GuideWithoutJsonIncludeAnnotations()
+        guide.name = 'Bean Introspection Guide'
+        String json = objectMapper.writeValueAsString(guide)
+
+        then:
+        noExceptionThrown()
+        json == '{"name":"Bean Introspection Guide"}'
+
+        cleanup:
+        ctx.close()
+
+        where:
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    void "Bean introspection works with a bean without JsonInclude annotations - serializationInclusion ALWAYS"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run(
+                'jackson.serializationInclusion':'ALWAYS'
+        )
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        GuideWithoutJsonIncludeAnnotations guide = new GuideWithoutJsonIncludeAnnotations()
+        guide.name = 'Bean Introspection Guide'
+        String json = objectMapper.writeValueAsString(guide)
+
+        then:
+        noExceptionThrown()
+        json == '{"name":"Bean Introspection Guide","author":null}'
+
+        cleanup:
+        ctx.close()
+    }
+
+    void "Bean introspection works with JsonInclude.Include.NON_NULL"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run(
+                'jackson.serializationInclusion':'ALWAYS'
+        )
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        Guide guide = new Guide()
+        guide.name = 'Bean Introspection Guide'
+        String json = objectMapper.writeValueAsString(guide)
+
+        then:
+        noExceptionThrown()
+        json == '{"name":"Bean Introspection Guide"}'
+
+        cleanup:
+        ctx.close()
+    }
+
+    void "Bean introspection works with JsonInclude.Include.ALWAYS"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run(
+                'jackson.serializationInclusion':'ALWAYS'
+        )
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        GuideWithNull guide = new GuideWithNull()
+        guide.name = 'Bean Introspection Guide'
+        String json = objectMapper.writeValueAsString(guide)
+
+        then:
+        noExceptionThrown()
+        json == '{"name":"Bean Introspection Guide","author":null}'
+
+        cleanup:
+        ctx.close()
+    }
+
+    void "Bean introspection with empty optional"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        def value = new OptionalAuthor(name: Optional.<String>empty())
+        String json = objectMapper.writeValueAsString(value)
+
+        then:
+        noExceptionThrown()
+        json == '{}'
+
+        cleanup:
+        ctx.close()
+
+        where:
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    void "test that introspected serialization works"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:"json unwrapped is used"
+        def plant = new Plant(name: "Rose", attributes: new Attributes(hasFlowers: true, color: "green"))
+        def str = objectMapper.writeValueAsString(plant)
+
+        then:"The result is correct"
+        str == '{"name":"Rose","color":"green","hasFlowers":true}'
+
+        when:"deserializing"
+        def read = objectMapper.readValue(str, Plant)
+
+        then:
+        read == plant
+        read.attributes.color == 'green'
+        read.attributes.hasFlowers
+
+        when:
+        Book b = objectMapper.readValue('{"opt":null,"book_title":"The Stand", "book_pages":1000,"author":{"name":"Fred"}}', Book)
+
+        then:
+        ctx.getBean(JacksonConfiguration).beanIntrospectionModule
+        ctx.containsBean(BeanIntrospectionModule)
+        b.title == 'The Stand'
+        b.pages == 1000
+        b.author.name == "Fred"
+        !b.opt.isPresent()
+
+        when:
+        def sw = new StringWriter()
+        objectMapper.writeValue(sw, b)
+        def result = sw.toString()
+
+        then:
+        !result.contains('"opt":{"present":false}')
+        result.contains('"book_title":"The Stand"') // '{"book_title":"The Stand","book_pages":1000,author":{"name":"Fred"}}'
+        result.contains('"book_pages":1000')
+        result.contains('"author":{"name":"Fred"}')
+
+        when:
+        result = objectMapper.writerWithView(PublicView).writeValueAsString(b)
+        then:
+        result.contains('"book_title":')
+        !result.contains('"book_pages":')
+
+        when:
+        result = objectMapper.writerWithView(AllView).writeValueAsString(b)
+        then:
+        result.contains('"book_title":')
+        result.contains('"book_pages":')
+
+
+        cleanup:
+        ctx.close()
+    }
+
+    void "test that introspected serialization works with @JsonAnyGetter"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        when:
+        def plant = new PlantWithAnyGetter(name: "Rose", attributes: [color: "green", hasFlowers: true])
+        String str = objectMapper.writeValueAsString(plant)
+
+        then:
+        str == '{"name":"Rose","color":"green","hasFlowers":true}'
+
+        when:"deserializing"
+        def read = objectMapper.readValue(str, PlantWithAnyGetter)
+
+        then:
+        read == plant
+        read.attributes.color == 'green'
+        read.attributes.hasFlowers
+
+        cleanup:
+        ctx.close()
+
+        where:
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    void "test that introspected serialization of errors works"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:
+        JsonError error = objectMapper.readValue('{"message":"Page Not Found","_links":{"self":{"href":"/","templated":false}}}', JsonError)
+
+        then:
+        ctx.getBean(JacksonConfiguration).beanIntrospectionModule
+        ctx.containsBean(BeanIntrospectionModule)
+        error.message == 'Page Not Found'
+        error.links.size() == 1
+        error.links.get("self").isPresent()
+        error.links.get("self").get().first().href == '/'
+
+        when:
+        def sw = new StringWriter()
+        objectMapper.writeValue(sw, error)
+        def result = sw.toString()
+
+        then:
+        result == '{"message":"Page Not Found","_links":{"self":{"href":"/","templated":false}}}'
+
+        cleanup:
+        ctx.close()
+    }
+
+    void "test that introspected serialization works for JsonCreator.Mode.DELEGATING"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:
+        Edition e = objectMapper.readValue('{"book_title":"The Stand"}', Edition)
+
+        then:
+        ctx.getBean(JacksonConfiguration).beanIntrospectionModule
+        ctx.containsBean(BeanIntrospectionModule)
+        e.title == 'The Stand'
+
+        when:
+        def sw = new StringWriter()
+        objectMapper.writeValue(sw, e)
+        def result = sw.toString()
+
+        then:
+        result.contains('"title":"The Stand"')
+
+        cleanup:
+        ctx.close()
+    }
+
+    def "should deserialize field with hierarchy"() {
+        ApplicationContext ctx = ApplicationContext.run()
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:
+        def notif = """
+{"id":586387198220282880, "template":{"templateType":"email","textTemplate":"Ahoj"}}
+"""
+        def value = objectMapper.readValue(notif, Notification.class)
+
+        then:
+        value.getTemplate() instanceof EmailTemplate
+
+        cleanup:
+        ctx.close()
+    }
+
+    void "test deserializing from basic types"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:
+        def wrapper = objectMapper.readValue("\"string\"", StringWrapper)
+
+        then:
+        noExceptionThrown()
+        wrapper.value == "string"
+
+        when:
+        wrapper = objectMapper.readValue("32", IntWrapper)
+
+        then:
+        noExceptionThrown()
+        wrapper.value == 32I
+
+        when:
+        wrapper = objectMapper.readValue("32", IntegerWrapper)
+
+        then:
+        noExceptionThrown()
+        wrapper.value == 32I
+
+        when:
+        wrapper = objectMapper.readValue("32", LongWrapper)
+
+        then:
+        noExceptionThrown()
+        wrapper.value == 32L
+
+        when:
+        wrapper = objectMapper.readValue("false", BooleanWrapper)
+
+        then:
+        noExceptionThrown()
+        !wrapper.value
+
+        when:
+        wrapper = objectMapper.readValue("23.23", DoubleWrapper)
+
+        then:
+        noExceptionThrown()
+        wrapper.value == 23.23D
+
+        cleanup:
+        ctx.close()
+    }
+
+    void "test deserializing with a json naming strategy"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:
+        NamingStrategy instance = objectMapper.readValue("{ \"FooBar\": \"bad\" }", NamingStrategy)
+
+        then:
+        instance.fooBar == "bad"
+
+        cleanup:
+        ctx.close()
+    }
+
+    void "test deserializing from a list"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:
+        ListWrapper instance = objectMapper.readValue("[\"bad\"]", ListWrapper)
+
+        then:
+        instance.value == ["bad"]
+
+        cleanup:
+        ctx.close()
+    }
+
+    @Issue("https://github.com/micronaut-projects/micronaut-core/issues/5160")
+    void "test that snake_case with non-introspected beans works"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run([
+                'jackson.property-naming-strategy': 'SNAKE_CASE',
+                'jackson.json-view.enabled': true,
+                'jackson.bean-introspection-module': true
+        ])
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:
+        Publisher p = objectMapper.readValue('{"publisher_name":"RandomHouse"}', Publisher)
+
+        then:
+        ctx.getBean(JacksonConfiguration).beanIntrospectionModule
+        ctx.containsBean(BeanIntrospectionModule)
+        p.publisherName == 'RandomHouse'
+
+        when:
+        def result = objectMapper.writerWithView(PublicView).writeValueAsString(p)
+
+        then:
+        !result.contains('"publisher_name":')
+
+
+        when:
+        result = objectMapper.writerWithView(AllView).writeValueAsString(p)
+        then:
+        result.contains('"publisher_name":')
+
+        cleanup:
+        ctx.close()
+    }
+
+    @Issue("https://github.com/micronaut-projects/micronaut-core/issues/5088")
+    void "test deserializing from a list of pojos"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:
+        MyReqBody reqBody = objectMapper.readValue('[{"name":"Joe"},{"name":"Sally"}]', MyReqBody)
+
+        then:
+        reqBody.getItems().size() == 2
+        reqBody.getItems()[0].name == "Joe"
+        reqBody.getItems()[1].name == "Sally"
+
+        when:
+        MyItemBody itemBody = objectMapper.readValue('[{"name":"Joe"},{"name":"Sally"}]', MyItemBody)
+
+        then:
+        itemBody.getItems().size() == 2
+        itemBody.getItems()[0].name == "Joe"
+        itemBody.getItems()[1].name == "Sally"
+
+        cleanup:
+        ctx.close()
+    }
+
+    @Issue("https://github.com/micronaut-projects/micronaut-core/issues/5078")
+    void "test more list wrapping scenarios"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ObjectMapper objectMapper = ctx.getBean(ObjectMapper)
+
+        when:
+        OuterList outerList = objectMapper.readValue("{\"wrapper\":{\"inner\":[]}}", OuterList.class)
+
+        then:
+        noExceptionThrown()
+        outerList.wrapper.inner.isEmpty()
+
+        when:
+        OuterArray outerArray = objectMapper.readValue("{\"wrapper\":{\"inner\":[]}}", OuterArray.class)
+
+        then:
+        noExceptionThrown()
+        outerArray.wrapper.inner.length == 0
+    }
+
+    @Issue("https://github.com/micronaut-projects/micronaut-core/issues/6472")
+    void "@JsonProperty annotation on setter"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        expect:
+        objectMapper.readValue('{"bar":"baz"}', JsonPropertyOnSetter.class).foo == 'baz'
+        objectMapper.writeValueAsString(new JsonPropertyOnSetter(foo: 'baz')) == '{"bar":"baz"}'
+
+        cleanup:
+        ctx.close()
+
+        where:
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    @Issue("https://github.com/micronaut-projects/micronaut-core/issues/6309")
+    void "@JsonSerialize annotation"() {
+      given:
+      ApplicationContext ctx = ApplicationContext.run()
+      ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+      JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+      expect:
+      objectMapper.readValue('{"foo":"Bar"}', JsonSerializeAnnotated.class).foo == 'bar'
+      objectMapper.writeValueAsString(new JsonSerializeAnnotated(foo: 'Bar')) == '{"foo":"BAR"}'
+
+      cleanup:
+      ctx.close()
+
+      where:
+      ignoreReflectiveProperties << [true, false]
+
+    }
+
+    void "creator property that doesn't have a getter"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        expect:
+        objectMapper.writeValueAsString(new DifferentCreator('baz')) == '{"fooBar":"baz"}'
+        objectMapper.readValue('{"foo_bar":"baz"}', DifferentCreator).fooBar == 'baz'
+        // this is currently broken with ignoreReflectiveProperties
+        ignoreReflectiveProperties || objectMapper.readValue('{"fooBar":"baz"}', DifferentCreator).fooBar == 'baz'
+
+        cleanup:
+        ctx.close()
+
+        where:
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    void "introspection creator property that doesn't have a getter"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        expect:
+        objectMapper.writeValueAsString(new IntrospectionCreator('baz')) == '{"label":"BAZ"}'
+        objectMapper.readValue('{"name":"baz","label":"foo"}', IntrospectionCreator).name == 'baz'
+
+        cleanup:
+        ctx.close()
+
+        where:
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    @Introspected
+    static class Book {
+        @JsonProperty("book_title")
+        @JsonView(PublicView)
+        String title
+
+        @JsonProperty("book_pages")
+        @JsonView(AllView)
+        int pages
+
+        Author author
+
+        Optional<String> opt
+
+        @JsonCreator Book(@JsonProperty("book_title") String title) {
+            this.title = title
+        }
+    }
+
+    @Introspected
+    static class Publisher {
+
+        @JsonView(AllView)
+        String publisherName
+
+    }
+
+    @Introspected
+    static class GuideWithoutJsonIncludeAnnotations {
+        String name
+        String author
+    }
+
+    @JsonInclude(JsonInclude.Include.NON_NULL)
+    @Introspected
+    static class Guide {
+        String name
+        String author
+    }
+
+    @JsonInclude(JsonInclude.Include.ALWAYS)
+    @Introspected
+    static class GuideWithNull {
+        String name
+        String author
+    }
+
+    @Introspected
+    @EqualsAndHashCode
+    static class Author {
+        String name
+    }
+
+    @Introspected
+    static class OptionalAuthor {
+        Optional<String> name
+    }
+
+    @Introspected
+    static class Edition {
+
+        String title
+
+        @JsonCreator(mode = JsonCreator.Mode.DELEGATING)
+        static Edition fromBook(Book book) {
+            return new Edition(title: book.title)
+        }
+
+    }
+
+    @Introspected
+    @EqualsAndHashCode
+    static class Plant {
+        String name
+        @JsonUnwrapped
+        Attributes attributes
+    }
+
+    @Introspected
+    @EqualsAndHashCode
+    static class Attributes {
+        String color
+        boolean hasFlowers
+
+    }
+
+    @Introspected
+    @EqualsAndHashCode
+    static class PlantWithAnyGetter {
+        String name
+
+        private Map<String, Object> attributes = [:]
+
+        @JsonAnyGetter
+        Map<String, Object> getAttributes() {
+            return attributes
+        }
+
+        @JsonAnySetter
+        void addAttribute(String key, Object value) {
+            attributes[key] = value
+        }
+
+    }
+        //Used for @JsonView
+    static class PublicView {}
+    static class AllView extends PublicView {}
+
+    @Introspected
+    @JsonNaming(value = PropertyNamingStrategies.UpperCamelCaseStrategy.class)
+    static class NamingStrategy {
+
+        @PackageScope
+        final String fooBar
+
+        @ConstructorProperties(["fooBar"])
+        NamingStrategy(String fooBar) {
+            this.fooBar = fooBar
+        }
+    }
+
+    @Introspected
+    static class ListWrapper {
+        final List<String> value
+
+        @JsonCreator
+        ListWrapper(List<String> value) {
+            this.value = value
+        }
+    }
+
+    @Introspected
+    static class IgnoreTest {
+        String name
+        @JsonIgnore
+        int code
+    }
+
+    @Introspected
+    static class MyReqBody {
+
+        private final List<MyItem> items
+
+        @JsonCreator
+        MyReqBody(final List<MyItem> items) {
+            this.items = items
+        }
+
+        List<MyItem> getItems() {
+            items
+        }
+    }
+
+    @Introspected
+    static class MyItem {
+        String name
+    }
+
+    @Introspected
+    static class MyGenericBody<T> {
+
+        private final List<T> items
+
+        MyGenericBody(final List<T> items) {
+            this.items = items
+        }
+
+        List<T> getItems() {
+            items
+        }
+    }
+
+    @Introspected
+    static class MyItemBody extends MyGenericBody<MyItem> {
+
+        @JsonCreator
+        MyItemBody(final List<MyItem> items) {
+            super(items)
+        }
+    }
+
+    @Introspected
+    static class WrapperList {
+        public final List<String> inner
+
+        @ConstructorProperties(["inner"])
+        @JsonCreator
+        WrapperList(List<String> inner) {
+            this.inner = inner
+        }
+    }
+
+    @Introspected
+    static class OuterList {
+        public final WrapperList wrapper
+
+        @ConstructorProperties(["wrapper"])
+        @JsonCreator
+        OuterList(WrapperList wrapper) {
+            this.wrapper = wrapper
+        }
+    }
+
+    @Introspected
+    static class WrapperArray {
+        public final String[] inner
+
+        @ConstructorProperties(["inner"])
+        @JsonCreator
+        WrapperArray(String[] inner) {
+            this.inner = inner
+        }
+    }
+
+    @Introspected
+    static class OuterArray {
+        public final WrapperArray wrapper
+
+        @ConstructorProperties(["wrapper"])
+        @JsonCreator
+        OuterArray(WrapperArray wrapper) {
+            this.wrapper = wrapper
+        }
+    }
+
+    @Introspected
+    static class JsonPropertyOnSetter {
+        private String foo
+
+        public String getFoo() {
+            return foo
+        }
+
+        @JsonProperty("bar")
+        public void setFoo(String foo) {
+            this.foo = foo
+        }
+    }
+
+    @Introspected
+    static class JsonSerializeAnnotated {
+        @JsonSerialize(using = UpperCaseSerializer)
+        @JsonDeserialize(using = LowerCaseDeserializer)
+        String foo
+
+        @Introspected
+        static class UpperCaseSerializer extends JsonSerializer<String> {
+            @Override
+            void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
+                gen.writeString(value.toUpperCase(Locale.ENGLISH))
+            }
+        }
+
+        @Introspected
+        static class LowerCaseDeserializer extends JsonDeserializer<String> {
+            @Override
+            String deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
+                return p.valueAsString.toLowerCase(Locale.ENGLISH)
+            }
+        }
+    }
+
+    @Introspected
+    static class DifferentCreator {
+        private final String fooBar;
+
+        @JsonCreator
+        public DifferentCreator(@JsonProperty('foo_bar') String fooBar) {
+            this.fooBar = fooBar
+        }
+
+        public String getFooBar() {
+            return fooBar;
+        }
+    }
+
+    @Introspected
+    @EqualsAndHashCode
+    static class IntrospectionCreator {
+        private final String name
+
+        @Creator
+        public IntrospectionCreator(String name) {
+            this.name = name
+        }
+
+        public String getLabel() {
+            name.toUpperCase()
+        }
+    }
+
+    void "JsonFormat"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+        LocalDateTime ldt = LocalDateTime.of(2021, 11, 22, 10, 37)
+
+        expect:
+        objectMapper.writeValueAsString(new FormatBean(ldt: ldt)) == '{"ldt":"2021-11-22 10:37:00"}'
+        objectMapper.readValue('{"ldt":"2021-11-22 10:37:00"}', FormatBean).ldt == ldt
+
+        cleanup:
+        ctx.close()
+
+        where:
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    @Introspected
+    static class FormatBean {
+        private LocalDateTime ldt
+
+        @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
+        public LocalDateTime getLdt() {
+            return ldt
+        }
+
+        public void setLdt(LocalDateTime ldt) {
+            this.ldt = ldt
+        }
+    }
+
+    @Issue('https://github.com/micronaut-projects/micronaut-core/issues/6625')
+    void "JsonIgnore on main accessor, with secondary override"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        expect:
+        objectMapper.writeValueAsString(new IgnoreBean()) == '{"foo":"bar"}'
+        objectMapper.readValue('{"foo":"bar"}', IgnoreBean).foo == 'foo'
+        objectMapper.readValue('{"foo":"bar"}', IgnoreBean).secondary == 'bar'
+
+        cleanup:
+        ctx.close()
+
+        where:
+        // need reflective access here, because with only introspections, the secondary methods arent available.
+        ignoreReflectiveProperties << [false]//[true, false]
+    }
+
+    @Introspected
+    static class IgnoreBean {
+
+        private String foo = 'foo'
+        private String secondary = 'bar'
+
+        @JsonProperty('foo')
+        public String secondary() {
+            return secondary
+        }
+
+        @JsonProperty('foo')
+        public void secondary(String s) {
+            this.secondary = s
+        }
+
+        @JsonIgnore
+        public String getFoo() {
+            return foo
+        }
+
+        @JsonIgnore
+        public void setFoo(String s) {
+            this.foo = s
+        }
+    }
+
+    @Unroll("JsonIgnore is supported with ignoreReflectiveProperties: #ignoreReflectiveProperties")
+    void "JsonIgnore on one accessor"(boolean ignoreReflectiveProperties) {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        expect:
+        objectMapper.writeValueAsString(new IgnoreBean2(foo: 'x', bar: 'y')) == '{"bar":"y"}'
+        objectMapper.readValue('{"foo":"x","bar":"y"}', IgnoreBean2).foo == 'x'
+        objectMapper.readValue('{"foo":"x","bar":"y"}', IgnoreBean2).bar == null
+
+        cleanup:
+        ctx.close()
+
+        where:
+        // without reflection we only see JsonIgnore on the whole property
+        ignoreReflectiveProperties << [false]
+    }
+
+    @Introspected
+    static class IgnoreBean2 {
+
+        @JsonIgnore
+        private String foo
+        @JsonIgnore
+        private String bar
+
+        @JsonIgnore
+        public String getFoo() {
+            return foo
+        }
+
+        @JsonProperty('foo')
+        public void setFoo(String s) {
+            this.foo = s
+        }
+
+        @JsonProperty('bar')
+        public String getBar() {
+            return bar
+        }
+
+        @JsonIgnore
+        public void setBar(String s) {
+            this.bar = s
+        }
+    }
+
+    @Issue('https://github.com/micronaut-projects/micronaut-core/issues/5907')
+    void "xml modifier"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        XmlMapper objectMapper = new XmlMapper()
+        objectMapper.registerModule(ctx.getBean(BeanIntrospectionModule))
+
+        expect:
+        objectMapper.writeValueAsString(new UsesXmlElementWrapper()) ==
+                '<UsesXmlElementWrapper><nestedItems><strings>foo</strings><strings>bar</strings></nestedItems></UsesXmlElementWrapper>'
+
+        cleanup:
+        ctx.close()
+    }
+
+    @Introspected
+    static class UsesXmlElementWrapper {
+        private List<String> strings = ["foo", "bar"];
+
+        @JacksonXmlElementWrapper(/*useWrapping = false, */localName = "nestedItems")
+        public List<String> getStrings() {
+            return strings
+        }
+    }
+
+    @Unroll("JsonProperty annotation is supported with ignoreReflectiveProperties: #ignoreReflectiveProperties")
+    void "JsonProperty support"(boolean ignoreReflectiveProperties) {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        expect:
+        objectMapper.writeValueAsString(new JsonPropertyBean(foo: 'x')) == '{"bar":"x"}'
+        objectMapper.readValue('{"bar":"x"}', JsonPropertyBean).foo == 'x'
+
+        cleanup:
+        ctx.close()
+
+        where:
+        // without reflection we only see JsonIgnore on the whole property
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    @Introspected
+    static class JsonPropertyBean {
+
+        private String foo
+
+        @JsonProperty('bar')
+        public String getFoo() {
+            return foo
+        }
+
+        public void setFoo(String s) {
+            this.foo = s
+        }
+    }
+
+    void "JsonNaming support"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run()
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        expect:
+        objectMapper.writeValueAsString(new JsonNamingBean(fooBar: 'x')) == '{"foo_bar":"x"}'
+        objectMapper.readValue('{"foo_bar":"x"}', JsonNamingBean).fooBar == 'x'
+
+        cleanup:
+        ctx.close()
+
+        where:
+        // without reflection we only see JsonIgnore on the whole property
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    @Introspected
+    @JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy)
+    static class JsonNamingBean {
+
+        private String fooBar
+
+        public String getFooBar() {
+            return fooBar
+        }
+
+        public void setFooBar(String s) {
+            this.fooBar = s
+        }
+    }
+
+    void "JsonNaming support in config"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run(["jackson.property-naming-strategy": "SNAKE_CASE"])
+        ctx.getBean(BeanIntrospectionModule).ignoreReflectiveProperties = ignoreReflectiveProperties
+        JsonMapper objectMapper = ctx.getBean(JsonMapper)
+
+        expect:
+        objectMapper.writeValueAsString(new JsonNamingBeanConfig(fooBar: 'x')) == '{"foo_bar":"x"}'
+        objectMapper.readValue('{"foo_bar":"x"}', JsonNamingBeanConfig).fooBar == 'x'
+
+        cleanup:
+        ctx.close()
+
+        where:
+        // without reflection we only see JsonIgnore on the whole property
+        ignoreReflectiveProperties << [true, false]
+    }
+
+    @Introspected
+    static class JsonNamingBeanConfig {
+
+        private String fooBar
+
+        public String getFooBar() {
+            return fooBar
+        }
+
+        public void setFooBar(String s) {
+            this.fooBar = s
+        }
+    }
+}
diff --git a/src/main/docs/guide/appendix/breaks.adoc b/src/main/docs/guide/appendix/breaks.adoc
index 245192d2c6..b6fd7a9970 100644
--- a/src/main/docs/guide/appendix/breaks.adoc
+++ b/src/main/docs/guide/appendix/breaks.adoc
@@ -78,109 +78,6 @@ Executable methods annotated with `@Parallel` will not trigger parallel executio
 
 `@Scheduled` is no longer processed in parallel, this reduced the complexity of the method processor and removed unnecessary overhead.
 
-==== Jackson Bean Introspection Module removed
-
-NOTE: This change only affects users using <<serializationUsingJacksonDatabind, Micronaut Jackson Databind>>
-
-Previous versions of Micronaut Core contained a so-called "bean introspection module". This Jackson module hooked into jackson-databind to replace reflective field and method access with Micronaut introspection-based calls. The performance difference is negligible, but the module allows serialization in native images without having to add reflection metadata.
-
-In version 5, we removed this module because it is difficult to maintain. Native image users now have a good alternative to <<serializationUsingJacksonDatabind, Micronaut Jackson Databind>> in https://micronaut-projects.github.io/micronaut-serialization/latest/guide[Micronaut Serialization].
-
-Users who do not wish to use Micronaut Serialization will have to add reflection metadata for the objects they serialize.
-
-If you want to keep using <<serializationUsingJacksonDatabind, Micronaut Jackson Databind>>, beware that deserialization of such class works in Micronaut 4:
-
-[source, java]
-----
-package example;
-
-import java.util.Objects;
-
-public class Person {
-    private final String name;
-    private final int age;
-
-    public Person(String name, int age) {
-        this.name = name;
-        this.age = age;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public int getAge() {
-        return age;
-    }
-}
-----
-
-In Micronaut 5, you will need to add `@JsonProperty` annotations to the constructor parameters. This is standard Jackson databind deserialization behavior.
-
-[source, java]
-----
-package example;
-
-import com.fasterxml.jackson.annotation.JsonProperty;
-
-import java.util.Objects;
-
-public class Person {
-    private final String name;
-    private final int age;
-
-    public Person(@JsonProperty("name") String name,
-                  @JsonProperty("age") int age) {
-        this.name = name;
-        this.age = age;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public int getAge() {
-        return age;
-    }
-}
-----
-
-To generate a GraalVM Native Image, where you need to de/serialize such as class, you can add the following dependency:
-
-dependency:micronaut-graal[scope="annotationProcessor",groupId="io.micronaut.graal"]
-
-and annotate it with api:core.annotation.ReflectiveAccess[]. Read <<graal, Graal>> section of the Micronaut core documentation.
-
-
-[source, java]
-----
-package example;
-
-import java.util.Objects;
-import com.fasterxml.jackson.annotation.JsonProperty;
-import io.micronaut.core.annotation.ReflectiveAccess;
-
-@ReflectiveAccess
-public class Person {
-    private final String name;
-    private final int age;
-
-    public Person(@JsonProperty("name") String name,
-                  @JsonProperty("age") int age) {
-        this.name = name;
-        this.age = age;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public int getAge() {
-        return age;
-    }
-}
-----
-
 == 4.0.0
 
 === Core Changes
diff --git a/src/main/docs/guide/ioc/introspection/jacksonAndBeanIntrospection.adoc b/src/main/docs/guide/ioc/introspection/jacksonAndBeanIntrospection.adoc
new file mode 100644
index 0000000000..816e738f39
--- /dev/null
+++ b/src/main/docs/guide/ioc/introspection/jacksonAndBeanIntrospection.adoc
@@ -0,0 +1,5 @@
+Jackson is configured to use the api:core.beans.BeanIntrospection[] API to read and write property values and construct objects, resulting in reflection-free serialization/deserialization. This is beneficial from a performance perspective and requires less configuration to operate correctly with runtimes such as GraalVM native.
+
+This feature is enabled by default; disable it by setting the `jackson.bean-introspection-module` configuration to `false`.
+
+NOTE: Currently only bean properties (private field with public getter/setter) are supported and usage of public fields is not supported.
diff --git a/src/main/docs/guide/toc.yml b/src/main/docs/guide/toc.yml
index e49df97426..5f0ecd81c3 100644
--- a/src/main/docs/guide/toc.yml
+++ b/src/main/docs/guide/toc.yml
@@ -56,6 +56,7 @@ ioc:
     introspectedAnnotationOnAConfigurationClass: Use the @Introspected Annotation on a Configuration Class
     introspectExistingAnnotations: Write an AnnotationMapper to Introspect Existing Annotations
     beanWrapperApi: The BeanWrapper API
+    jacksonAndBeanIntrospection: Jackson and Bean Introspection
     kotlinAndBeanIntrospection: Kotlin and Bean Introspection
   beanMappers:
     title: Bean Mappers
diff --git a/test-suite-annotation-remapper/build.gradle.kts b/test-suite-annotation-remapper/build.gradle.kts
index dd429e8851..72dd75e0b8 100644
--- a/test-suite-annotation-remapper/build.gradle.kts
+++ b/test-suite-annotation-remapper/build.gradle.kts
@@ -10,7 +10,6 @@ tasks.withType<Test>().configureEach {
 }
 
 dependencies {
-    testAnnotationProcessor(projects.micronautGraal)
     testAnnotationProcessor(projects.testSuiteAnnotationRemapperVisitor)
     testAnnotationProcessor(projects.micronautInjectJava)
     testImplementation(projects.micronautHttpServerNetty)
@@ -32,7 +31,6 @@ graalvmNative {
     binaries {
         configureEach {
             if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_21)) {
-                buildArgs.add("--initialize-at-build-time=org.junit.platform.commons.logging.LoggerFactory\$DelegatingLogger")
                 buildArgs.add("--initialize-at-build-time=org.junit.platform.suite.engine.IsSuiteClass")
                 buildArgs.add("--initialize-at-build-time=org.junit.platform.suite.engine.IsPotentialTestContainer")
                 buildArgs.add("--strict-image-heap")
diff --git a/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloControllerTest.java b/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloControllerTest.java
index d098638773..60b3a99046 100644
--- a/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloControllerTest.java
+++ b/test-suite-annotation-remapper/src/test/java/example/micronaut/HelloControllerTest.java
@@ -13,7 +13,7 @@ import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 @MicronautTest
-class HelloControllerTest {
+public class HelloControllerTest {
 
     @Inject
     @Client("/")
diff --git a/test-suite-annotation-remapper/src/test/java/example/micronaut/MyRecord.java b/test-suite-annotation-remapper/src/test/java/example/micronaut/MyRecord.java
index 6be4a61406..20f7cccd9f 100644
--- a/test-suite-annotation-remapper/src/test/java/example/micronaut/MyRecord.java
+++ b/test-suite-annotation-remapper/src/test/java/example/micronaut/MyRecord.java
@@ -1,9 +1,7 @@
 package example.micronaut;
 
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 
-@ReflectiveAccess
 @Introspected
 public record MyRecord(String name, int age) {
 }
diff --git a/test-suite-groovy/src/test/groovy/io/micronaut/docs/server/binding/Point.groovy b/test-suite-groovy/src/test/groovy/io/micronaut/docs/server/binding/Point.groovy
index d1ff5d61d6..d2012acd90 100644
--- a/test-suite-groovy/src/test/groovy/io/micronaut/docs/server/binding/Point.groovy
+++ b/test-suite-groovy/src/test/groovy/io/micronaut/docs/server/binding/Point.groovy
@@ -19,6 +19,12 @@ import io.micronaut.core.annotation.Introspected
 
 @Introspected
 class Point {
+
     Integer x
     Integer y
+
+    Point(Integer x, Integer y) {
+        this.x = x
+        this.y = y
+    }
 }
diff --git a/test-suite-groovy/src/test/groovy/io/micronaut/docs/server/binding/PointController.groovy b/test-suite-groovy/src/test/groovy/io/micronaut/docs/server/binding/PointController.groovy
index 9a33859827..dfae29eb9c 100644
--- a/test-suite-groovy/src/test/groovy/io/micronaut/docs/server/binding/PointController.groovy
+++ b/test-suite-groovy/src/test/groovy/io/micronaut/docs/server/binding/PointController.groovy
@@ -31,14 +31,14 @@ class PointController {
     @Post(uri = "/no-body-json")
     @Status(HttpStatus.CREATED)
     Point noBodyJson(Integer x, Integer y) { // (1)
-        new Point(x: x,y: y)
+        new Point(x,y)
     }
 
     @Consumes(MediaType.APPLICATION_FORM_URLENCODED)
     @Post("/no-body-form")
     @Status(HttpStatus.CREATED)
     Point noBodyForm(Integer x, Integer y) {  // (2)
-        new Point(x: x, y: y)
+        new Point(x,y)
     }
 }
 // end::class[]
diff --git a/test-suite-kotlin-graalvm/build.gradle.kts b/test-suite-kotlin-graalvm/build.gradle.kts
index 0d1fcf9193..2f92923887 100644
--- a/test-suite-kotlin-graalvm/build.gradle.kts
+++ b/test-suite-kotlin-graalvm/build.gradle.kts
@@ -45,7 +45,6 @@ graalvmNative {
         configureEach {
             resources.autodetect()
             if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_21)) {
-                buildArgs.add("--initialize-at-build-time=org.junit.platform.commons.logging.LoggerFactory\$DelegatingLogger")
                 buildArgs.add("--initialize-at-build-time=org.junit.platform.suite.engine.IsSuiteClass")
                 buildArgs.add("--initialize-at-build-time=org.junit.platform.suite.engine.IsPotentialTestContainer")
                 buildArgs.add("--strict-image-heap")
diff --git a/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/reactor/ReactorContextPropagationSpec.kt b/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/reactor/ReactorContextPropagationSpec.kt
index 6e1f5a0277..49afc40002 100644
--- a/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/reactor/ReactorContextPropagationSpec.kt
+++ b/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/reactor/ReactorContextPropagationSpec.kt
@@ -1,6 +1,5 @@
 package io.micronaut.docs.reactor
 
-import com.fasterxml.jackson.annotation.JsonProperty
 import io.micronaut.context.ApplicationContext
 import io.micronaut.context.annotation.Requires
 import io.micronaut.core.annotation.Introspected
@@ -81,7 +80,7 @@ class TestController(private val someService: SomeService) {
 }
 
 @Introspected
-data class SomeBody(@JsonProperty("name") val name: String)
+class SomeBody(val name: String)
 
 @Requires(property = "mdc.reactortestpropagation.enabled")
 @Singleton
@@ -104,7 +103,7 @@ class SomeService {
 }
 
 @Introspected
-data class NameRequestBody(@JsonProperty("name") val name: String)
+class NameRequestBody(val name: String)
 
 @Requires(property = "mdc.reactortestpropagation.enabled")
 // tag::simplefilter[]
diff --git a/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/server/binding/Point.kt b/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/server/binding/Point.kt
index 558630c5be..bddb49ea86 100644
--- a/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/server/binding/Point.kt
+++ b/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/server/binding/Point.kt
@@ -15,10 +15,8 @@
  */
 package io.micronaut.docs.server.binding
 
-import com.fasterxml.jackson.annotation.JsonProperty
 import io.micronaut.core.annotation.Introspected
 
 @Introspected
-data class Point (@JsonProperty("x") val x: Int,
-                  @JsonProperty("y") val y: Int)
+data class Point (val x: Int, val y: Int)
 
diff --git a/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/server/request_scope/DemoObject.kt b/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/server/request_scope/DemoObject.kt
index 4d8e13e003..2c5cd2cbdd 100644
--- a/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/server/request_scope/DemoObject.kt
+++ b/test-suite-kotlin/src/test/kotlin/io/micronaut/docs/server/request_scope/DemoObject.kt
@@ -1,10 +1,9 @@
 package io.micronaut.docs.server.request_scope
 
-import com.fasterxml.jackson.annotation.JsonProperty
 import io.micronaut.core.annotation.Introspected
 
 @Introspected
 data class DemoObject(
-    @JsonProperty("text") val text: String,
-    @JsonProperty("list") val list: List<String>,
+    val text: String,
+    val list: List<String>,
 )
diff --git a/test-suite-kotlin/src/test/kotlin/io/micronaut/jackson/NonNullConstructorDto.kt b/test-suite-kotlin/src/test/kotlin/io/micronaut/jackson/NonNullConstructorDto.kt
index bfebd120cd..a074cd0c17 100644
--- a/test-suite-kotlin/src/test/kotlin/io/micronaut/jackson/NonNullConstructorDto.kt
+++ b/test-suite-kotlin/src/test/kotlin/io/micronaut/jackson/NonNullConstructorDto.kt
@@ -1,9 +1,8 @@
 package io.micronaut.jackson
 
-import com.fasterxml.jackson.annotation.JsonProperty
 import io.micronaut.core.annotation.Introspected
 
 @Introspected
 data class NonNullConstructorDto(
-    @JsonProperty("longField") val longField: Long,
+    val longField: Long,
 )
diff --git a/test-suite-netty-ssl-graalvm/build.gradle.kts b/test-suite-netty-ssl-graalvm/build.gradle.kts
index 68c849cf47..2ddc1e63f7 100644
--- a/test-suite-netty-ssl-graalvm/build.gradle.kts
+++ b/test-suite-netty-ssl-graalvm/build.gradle.kts
@@ -31,7 +31,6 @@ graalvmNative {
     binaries {
         all {
             if (JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_21)) {
-                buildArgs.add("--initialize-at-build-time=org.junit.platform.commons.logging.LoggerFactory\$DelegatingLogger")
                 buildArgs.add("--initialize-at-build-time=org.junit.platform.suite.engine.IsSuiteClass")
                 buildArgs.add("--initialize-at-build-time=org.junit.platform.suite.engine.IsPotentialTestContainer")
                 buildArgs.add("--strict-image-heap")
diff --git a/test-suite-netty-ssl-graalvm/src/test/java/example/micronaut/HelloControllerTest.java b/test-suite-netty-ssl-graalvm/src/test/java/example/micronaut/HelloControllerTest.java
index 5d9b58e898..b2096889e1 100644
--- a/test-suite-netty-ssl-graalvm/src/test/java/example/micronaut/HelloControllerTest.java
+++ b/test-suite-netty-ssl-graalvm/src/test/java/example/micronaut/HelloControllerTest.java
@@ -15,7 +15,7 @@ import static org.junit.jupiter.api.Assertions.assertEquals;
 @Property(name = "micronaut.server.ssl.buildSelfSigned", value = "true")
 @Property(name = "micronaut.server.ssl.port", value = "0")
 @Property(name = "micronaut.http.client.ssl.insecure-trust-all-certificates", value = "true")
-class HelloControllerTest {
+public class HelloControllerTest {
 
     @Inject
     @Client("/")
diff --git a/test-suite/src/test/java/io/micronaut/context/router/RouteBuilderMediaTypeTest.java b/test-suite/src/test/java/io/micronaut/context/router/RouteBuilderMediaTypeTest.java
index cf7831a632..d465ba852e 100644
--- a/test-suite/src/test/java/io/micronaut/context/router/RouteBuilderMediaTypeTest.java
+++ b/test-suite/src/test/java/io/micronaut/context/router/RouteBuilderMediaTypeTest.java
@@ -6,19 +6,9 @@ import io.micronaut.context.annotation.Executable;
 import io.micronaut.context.annotation.Property;
 import io.micronaut.context.annotation.Requires;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.core.util.StringUtils;
-import io.micronaut.http.HttpHeaders;
-import io.micronaut.http.HttpMethod;
-import io.micronaut.http.HttpRequest;
-import io.micronaut.http.HttpResponse;
-import io.micronaut.http.HttpStatus;
-import io.micronaut.http.MediaType;
-import io.micronaut.http.annotation.Body;
-import io.micronaut.http.annotation.Consumes;
-import io.micronaut.http.annotation.Get;
-import io.micronaut.http.annotation.Post;
-import io.micronaut.http.annotation.Produces;
+import io.micronaut.http.*;
+import io.micronaut.http.annotation.*;
 import io.micronaut.http.client.BlockingHttpClient;
 import io.micronaut.http.client.HttpClient;
 import io.micronaut.http.client.annotation.Client;
@@ -40,10 +30,7 @@ import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 
-import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
-import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assertions.*;
 
 @Property(name = "micronaut.http.client.follow-redirects", value = StringUtils.FALSE)
 @Property(name = "spec.name", value = "RouteBuilderMediaTypeSpec")
@@ -116,7 +103,6 @@ class RouteBuilderMediaTypeTest extends Specification {
     }
 
     @Introspected
-    @ReflectiveAccess
     record Contact(String firstName, String lastName) {
 
     }
diff --git a/test-suite/src/test/java/io/micronaut/docs/ioc/builders/Person.java b/test-suite/src/test/java/io/micronaut/docs/ioc/builders/Person.java
index 63432d7517..2e3ba7cb72 100644
--- a/test-suite/src/test/java/io/micronaut/docs/ioc/builders/Person.java
+++ b/test-suite/src/test/java/io/micronaut/docs/ioc/builders/Person.java
@@ -1,12 +1,10 @@
 package io.micronaut.docs.ioc.builders;
 
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 
 import java.util.Objects;
 
 // tag::class[]
-@ReflectiveAccess
 @Introspected(builder = @Introspected.IntrospectionBuilder(
     builderClass = Person.Builder.class
 ))
diff --git a/test-suite/src/test/java/io/micronaut/docs/ioc/mappers/AdditionalMappers.java b/test-suite/src/test/java/io/micronaut/docs/ioc/mappers/AdditionalMappers.java
index 9601d93403..35de433288 100644
--- a/test-suite/src/test/java/io/micronaut/docs/ioc/mappers/AdditionalMappers.java
+++ b/test-suite/src/test/java/io/micronaut/docs/ioc/mappers/AdditionalMappers.java
@@ -4,7 +4,6 @@ import io.micronaut.context.annotation.Mapper;
 import io.micronaut.context.annotation.Mapper.Mapping;
 import io.micronaut.context.annotation.Mapper.MergeStrategy;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.docs.ioc.mappers.ChristmasTypes.ChristmasPresent;
 import io.micronaut.docs.ioc.mappers.ChristmasTypes.Present;
 import io.micronaut.docs.ioc.mappers.ChristmasTypes.PresentPackaging;
@@ -44,7 +43,6 @@ public interface AdditionalMappers {
         }
     }
 
-    @ReflectiveAccess
     @Introspected
     record Card(
         String greetingCard
diff --git a/test-suite/src/test/java/io/micronaut/docs/server/binding/Point.java b/test-suite/src/test/java/io/micronaut/docs/server/binding/Point.java
index c5ec3c72dd..7382f6b9b0 100644
--- a/test-suite/src/test/java/io/micronaut/docs/server/binding/Point.java
+++ b/test-suite/src/test/java/io/micronaut/docs/server/binding/Point.java
@@ -1,21 +1,15 @@
 package io.micronaut.docs.server.binding;
 
-import com.fasterxml.jackson.annotation.JsonProperty;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 
 import java.util.Objects;
 
-@ReflectiveAccess
 @Introspected
 public class Point {
     private Integer x;
     private Integer y;
 
-    public Point(
-        @JsonProperty("x") Integer x, // @JsonProperty for jackson databind
-        @JsonProperty("y") Integer y // @JsonProperty for jackson databind
-    ) {
+    public Point(Integer x, Integer y) {
         this.x = x;
         this.y = y;
     }
diff --git a/test-suite/src/test/java/io/micronaut/docs/server/consumes/ConsumesControllerSpec.java b/test-suite/src/test/java/io/micronaut/docs/server/consumes/ConsumesControllerSpec.java
index bbb3fd70dd..55a4926aa9 100644
--- a/test-suite/src/test/java/io/micronaut/docs/server/consumes/ConsumesControllerSpec.java
+++ b/test-suite/src/test/java/io/micronaut/docs/server/consumes/ConsumesControllerSpec.java
@@ -17,7 +17,6 @@ package io.micronaut.docs.server.consumes;
 
 import io.micronaut.context.ApplicationContext;
 import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
 import io.micronaut.http.HttpRequest;
 import io.micronaut.http.MediaType;
 import io.micronaut.http.client.HttpClient;
@@ -83,7 +82,6 @@ class ConsumesControllerSpec {
                 .contentType(MediaType.TEXT_PLAIN)));
     }
 
-    @ReflectiveAccess
     @Introspected
     static class Book {
         public String title;
diff --git a/test-suite/src/test/java/io/micronaut/docs/server/form/Person.java b/test-suite/src/test/java/io/micronaut/docs/server/form/Person.java
index a93fba561d..33f43514d6 100644
--- a/test-suite/src/test/java/io/micronaut/docs/server/form/Person.java
+++ b/test-suite/src/test/java/io/micronaut/docs/server/form/Person.java
@@ -15,12 +15,10 @@
  */
 package io.micronaut.docs.server.form;
 
-import io.micronaut.core.annotation.Introspected;
-import io.micronaut.core.annotation.ReflectiveAccess;
-
 import java.util.Objects;
 
-@ReflectiveAccess
+import io.micronaut.core.annotation.Introspected;
+
 @Introspected
 public class Person {
 
