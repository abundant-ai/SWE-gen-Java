diff --git a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
index 170c46f8..8edf72fa 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/BehaviorCall.java
@@ -119,6 +119,10 @@ final class BehaviorCall<T> implements Call<T> {
     });
   }
 
+  @Override public synchronized boolean isExecuted() {
+    return executed;
+  }
+
   @Override public Response<T> execute() throws IOException {
     final AtomicReference<Response<T>> responseRef = new AtomicReference<>();
     final AtomicReference<Throwable> failureRef = new AtomicReference<>();
diff --git a/retrofit-mock/src/main/java/retrofit/mock/Calls.java b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
index d56c9589..21343074 100644
--- a/retrofit-mock/src/main/java/retrofit/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit/mock/Calls.java
@@ -36,6 +36,10 @@ public final class Calls {
         callback.onResponse(response);
       }
 
+      @Override public boolean isExecuted() {
+        return false;
+      }
+
       @Override public void cancel() {
       }
 
@@ -60,6 +64,10 @@ public final class Calls {
         callback.onFailure(failure);
       }
 
+      @Override public boolean isExecuted() {
+        return false;
+      }
+
       @Override public void cancel() {
       }
 
diff --git a/retrofit/src/main/java/retrofit/Call.java b/retrofit/src/main/java/retrofit/Call.java
index 75e3e8a0..968aba8b 100644
--- a/retrofit/src/main/java/retrofit/Call.java
+++ b/retrofit/src/main/java/retrofit/Call.java
@@ -46,6 +46,12 @@ public interface Call<T> extends Cloneable {
    */
   void enqueue(Callback<T> callback);
 
+  /**
+   * Returns true if this call has been either {@linkplain #execute() executed} or {@linkplain
+   * #enqueue(Callback) enqueued}. It is an error to execute or enqueue a call more than once.
+   */
+  boolean isExecuted();
+
   /**
    * Cancel this call. An attempt will be made to cancel in-flight calls, and if the call has not
    * yet been executed it never will be.
diff --git a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
index 2862063a..15ed0877 100644
--- a/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
+++ b/retrofit/src/main/java/retrofit/ExecutorCallAdapterFactory.java
@@ -78,6 +78,10 @@ final class ExecutorCallAdapterFactory implements CallAdapter.Factory {
       });
     }
 
+    @Override public boolean isExecuted() {
+      return delegate.isExecuted();
+    }
+
     @Override public Response<T> execute() throws IOException {
       return delegate.execute();
     }
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index 10483380..70cef831 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -102,6 +102,10 @@ final class OkHttpCall<T> implements Call<T> {
     });
   }
 
+  @Override public synchronized boolean isExecuted() {
+    return executed;
+  }
+
   public Response<T> execute() throws IOException {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already executed");
