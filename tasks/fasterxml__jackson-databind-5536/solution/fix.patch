diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 3261e7fc7..f8d2a84ec 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -151,6 +151,8 @@ Konstantin Labun (@kulabun)
  * Contributed fix for #5405: `@JsonFormat(shape = Shape.POJO)` does not work for
    `java.util.Map` serialization via property annotation
   [3.1.0]
+ * Contributed #5515: Support `@JsonInclude.content` for Arrays
+  [3.1.0]
 
 Oliver Drotbohm (@odrotbohm)
  * Requested #1196: Add opt-in error collection for deserialization
diff --git a/release-notes/VERSION b/release-notes/VERSION
index c4b4db51f..74872442c 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -58,7 +58,7 @@ Versions: 3.x (for earlier see VERSION-2.x)
 #5361: Fix Maven SBOM publishing (worked in 3.0.0-rc4 but not in rc5 or later)
 (date-time)#359: `InstantDeserializer` deserializes the nanosecond portion of
   fractional negative timestamps incorrectly
-#5369: Support `@JsonInclude` for `Collection`s
+#5369: Support `@JsonInclude.content` for `Collection`s
   (with `SerializationFeature.APPLY_JSON_INCLUDE_FOR_CONTAINERS`)
  (implementation by Joo-Hyuk K)
 #5405: `@JsonFormat(shape = Shape.POJO)` does not work for `java.util.Map`
@@ -77,6 +77,8 @@ Versions: 3.x (for earlier see VERSION-2.x)
  (fixed by Joo-Hyuk K)
 #5475: Support `@JsonDeserializeAs` annotation
  (implemented by @cowtowncoder, w/ Claude code)
+#5515: Support `@JsonInclude.content` for Arrays
+ (implemented by @JacksonJang)
 #5519: Add 2 new `JavaTimeFeature`s: (`TRUNCATE_TO_MSECS_ON_WRITE`,
   `TRUNCATE_TO_MSECS_ON_READ`) for truncating `java.time` values before serialization,
   after deserialization
diff --git a/src/main/java/tools/jackson/databind/SerializationFeature.java b/src/main/java/tools/jackson/databind/SerializationFeature.java
index 625a44d0e..dba6779ae 100644
--- a/src/main/java/tools/jackson/databind/SerializationFeature.java
+++ b/src/main/java/tools/jackson/databind/SerializationFeature.java
@@ -258,14 +258,14 @@ public enum SerializationFeature implements ConfigFeature
 
     /**
      * Feature that determines whether {@code JsonInclude#content()} configured
-     * filtering is applied to elements of {@link java.util.Collection} valued
-     * properties.
+     * filtering is applied to elements of {@link java.util.Collection} and
+     * array valued properties.
      * By default, {@code content()} inclusion rules are only applied to
      * {@code Map} values and reference type contents, and are ignored for
-     * {@code Collection} elements.
+     * {@code Collection} and array elements.
      * <p>
      * When this feature is enabled, {@code JsonInclude#content()} rules
-     * are used for filtering {@code Collection} elements during serialization.
+     * are used for filtering {@code Collection} and array elements during serialization.
      * <p>
      * This feature is <b>disabled by default</b> for backwards
      * compatibility.
diff --git a/src/main/java/tools/jackson/databind/ser/jdk/JDKArraySerializers.java b/src/main/java/tools/jackson/databind/ser/jdk/JDKArraySerializers.java
index 1df559a1f..395574d2a 100644
--- a/src/main/java/tools/jackson/databind/ser/jdk/JDKArraySerializers.java
+++ b/src/main/java/tools/jackson/databind/ser/jdk/JDKArraySerializers.java
@@ -80,9 +80,13 @@ public class JDKArraySerializers
             super(cls);
         }
 
+        /**
+         * @since 3.1
+         */
         protected TypedPrimitiveArraySerializer(TypedPrimitiveArraySerializer<T> src,
-                BeanProperty prop, Boolean unwrapSingle) {
-            super(src, prop, unwrapSingle);
+                BeanProperty prop, Boolean unwrapSingle,
+                Object suppressableValue, boolean suppressNulls) {
+            super(src, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         // 01-Dec-2016, tatu: Only now realized that due strong typing of Java arrays,
@@ -109,14 +113,19 @@ public class JDKArraySerializers
 
         public BooleanArraySerializer() { super(boolean[].class); }
 
+        /**
+         * @since 3.1
+         */
         protected BooleanArraySerializer(BooleanArraySerializer src,
-                BeanProperty prop, Boolean unwrapSingle) {
-            super(src, prop, unwrapSingle);
+                BeanProperty prop, Boolean unwrapSingle,
+                Object suppressableValue, boolean suppressNulls) {
+            super(src, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         @Override
-        public ValueSerializer<?> _withResolved(BeanProperty prop, Boolean unwrapSingle) {
-            return new BooleanArraySerializer(this, prop, unwrapSingle);
+        protected BooleanArraySerializer _withResolved(BeanProperty prop,
+                Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls) {
+            return new BooleanArraySerializer(this, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         /**
@@ -150,23 +159,27 @@ public class JDKArraySerializers
         }
 
         @Override
-        public final void serialize(boolean[] value, JsonGenerator g, SerializationContext provider) throws JacksonException
+        public final void serialize(boolean[] value, JsonGenerator g, SerializationContext ctxt) throws JacksonException
         {
             final int len = value.length;
-            if ((len == 1) && _shouldUnwrapSingle(provider)) {
-                serializeContents(value, g, provider);
+            if ((len == 1) && _shouldUnwrapSingle(ctxt)) {
+                serializeContents(value, g, ctxt);
                 return;
             }
             g.writeStartArray(value, len);
-            serializeContents(value, g, provider);
+            serializeContents(value, g, ctxt);
             g.writeEndArray();
         }
 
         @Override
-        public void serializeContents(boolean[] value, JsonGenerator g, SerializationContext provider)
+        public void serializeContents(boolean[] value, JsonGenerator g, SerializationContext ctxt)
             throws JacksonException
         {
+            final boolean filtered = _needToCheckFiltering(ctxt);
             for (int i = 0, len = value.length; i < len; ++i) {
+                if (filtered && !_shouldSerializeElement(ctxt, Boolean.valueOf(value[i]))) {
+                    continue;
+                }
                 g.writeBoolean(value[i]);
             }
         }
@@ -185,14 +198,19 @@ public class JDKArraySerializers
         private final static JavaType VALUE_TYPE = simpleElementType(Short.TYPE);
 
         public ShortArraySerializer() { super(short[].class); }
-        public ShortArraySerializer(ShortArraySerializer src, BeanProperty prop,
-                 Boolean unwrapSingle) {
-            super(src, prop, unwrapSingle);
+
+        /**
+         * @since 3.1
+         */
+        protected ShortArraySerializer(ShortArraySerializer src, BeanProperty prop,
+                Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls) {
+            super(src, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         @Override
-        public ValueSerializer<?> _withResolved(BeanProperty prop,Boolean unwrapSingle) {
-            return new ShortArraySerializer(this, prop, unwrapSingle);
+        protected ShortArraySerializer _withResolved(BeanProperty prop,
+                Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls) {
+            return new ShortArraySerializer(this, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         @Override
@@ -217,23 +235,27 @@ public class JDKArraySerializers
         }
 
         @Override
-        public final void serialize(short[] value, JsonGenerator g, SerializationContext provider) throws JacksonException
+        public final void serialize(short[] value, JsonGenerator g, SerializationContext ctxt) throws JacksonException
         {
             final int len = value.length;
-            if ((len == 1) && _shouldUnwrapSingle(provider)) {
-                serializeContents(value, g, provider);
+            if ((len == 1) && _shouldUnwrapSingle(ctxt)) {
+                serializeContents(value, g, ctxt);
                 return;
             }
             g.writeStartArray(value, len);
-            serializeContents(value, g, provider);
+            serializeContents(value, g, ctxt);
             g.writeEndArray();
         }
 
         @Override
-        public void serializeContents(short[] value, JsonGenerator g, SerializationContext provider)
+        public void serializeContents(short[] value, JsonGenerator g, SerializationContext ctxt)
             throws JacksonException
         {
+            final boolean filtered = _needToCheckFiltering(ctxt);
             for (int i = 0, len = value.length; i < len; ++i) {
+                if (filtered && !_shouldSerializeElement(ctxt, Short.valueOf(value[i]))) {
+                    continue;
+                }
                 g.writeNumber((int)value[i]);
             }
         }
@@ -263,11 +285,11 @@ public class JDKArraySerializers
         }
 
         @Override
-        public void serialize(char[] value, JsonGenerator g, SerializationContext provider)
+        public void serialize(char[] value, JsonGenerator g, SerializationContext ctxt)
             throws JacksonException
         {
             // [JACKSON-289] allows serializing as 'sparse' char array too:
-            if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {
+            if (ctxt.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {
                 g.writeStartArray(value, value.length);
                 _writeArrayContents(g, value);
                 g.writeEndArray();
@@ -319,14 +341,19 @@ public class JDKArraySerializers
 
         public IntArraySerializer() { super(int[].class); }
 
+        /**
+         * @since 3.1
+         */
         protected IntArraySerializer(IntArraySerializer src,
-                BeanProperty prop, Boolean unwrapSingle) {
-            super(src, prop, unwrapSingle);
+                BeanProperty prop, Boolean unwrapSingle,
+                Object suppressableValue, boolean suppressNulls) {
+            super(src, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         @Override
-        public ValueSerializer<?> _withResolved(BeanProperty prop, Boolean unwrapSingle) {
-            return new IntArraySerializer(this, prop, unwrapSingle);
+        protected IntArraySerializer _withResolved(BeanProperty prop,
+                Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls) {
+            return new IntArraySerializer(this, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         /**
@@ -360,11 +387,18 @@ public class JDKArraySerializers
         }
 
         @Override
-        public final void serialize(int[] value, JsonGenerator g, SerializationContext provider) throws JacksonException
+        public final void serialize(int[] value, JsonGenerator g, SerializationContext ctxt) throws JacksonException
         {
             final int len = value.length;
-            if ((len == 1) && _shouldUnwrapSingle(provider)) {
-                serializeContents(value, g, provider);
+            if ((len == 1) && _shouldUnwrapSingle(ctxt)) {
+                serializeContents(value, g, ctxt);
+                return;
+            }
+            // Check if filtering is needed
+            if (_needToCheckFiltering(ctxt)) {
+                g.writeStartArray(value, len);
+                serializeContents(value, g, ctxt);
+                g.writeEndArray();
                 return;
             }
             // 11-May-2016, tatu: As per [core#277] we have efficient `writeArray(...)` available
@@ -372,10 +406,14 @@ public class JDKArraySerializers
         }
 
         @Override
-        public void serializeContents(int[] value, JsonGenerator g, SerializationContext provider)
+        public void serializeContents(int[] value, JsonGenerator g, SerializationContext ctxt)
             throws JacksonException
         {
+            final boolean filtered = _needToCheckFiltering(ctxt);
             for (int i = 0, len = value.length; i < len; ++i) {
+                if (filtered && !_shouldSerializeElement(ctxt, Integer.valueOf(value[i]))) {
+                    continue;
+                }
                 g.writeNumber(value[i]);
             }
         }
@@ -394,14 +432,19 @@ public class JDKArraySerializers
         private final static JavaType VALUE_TYPE = simpleElementType(Long.TYPE);
 
         public LongArraySerializer() { super(long[].class); }
-        public LongArraySerializer(LongArraySerializer src, BeanProperty prop,
-                Boolean unwrapSingle) {
-            super(src, prop, unwrapSingle);
+
+        /**
+         * @since 3.1
+         */
+        protected LongArraySerializer(LongArraySerializer src, BeanProperty prop,
+                Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls) {
+            super(src, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         @Override
-        public ValueSerializer<?> _withResolved(BeanProperty prop,Boolean unwrapSingle) {
-            return new LongArraySerializer(this, prop, unwrapSingle);
+        protected LongArraySerializer _withResolved(BeanProperty prop,
+                Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls) {
+            return new LongArraySerializer(this, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         @Override
@@ -426,11 +469,18 @@ public class JDKArraySerializers
         }
 
         @Override
-        public final void serialize(long[] value, JsonGenerator g, SerializationContext provider) throws JacksonException
+        public final void serialize(long[] value, JsonGenerator g, SerializationContext ctxt) throws JacksonException
         {
             final int len = value.length;
-            if ((len == 1) && _shouldUnwrapSingle(provider)) {
-                serializeContents(value, g, provider);
+            if ((len == 1) && _shouldUnwrapSingle(ctxt)) {
+                serializeContents(value, g, ctxt);
+                return;
+            }
+            // Check if filtering is needed
+            if (_needToCheckFiltering(ctxt)) {
+                g.writeStartArray(value, len);
+                serializeContents(value, g, ctxt);
+                g.writeEndArray();
                 return;
             }
             // 11-May-2016, tatu: As per [core#277] we have efficient `writeArray(...)` available
@@ -438,10 +488,14 @@ public class JDKArraySerializers
         }
 
         @Override
-        public void serializeContents(long[] value, JsonGenerator g, SerializationContext provider)
+        public void serializeContents(long[] value, JsonGenerator g, SerializationContext ctxt)
             throws JacksonException
         {
+            final boolean filtered = _needToCheckFiltering(ctxt);
             for (int i = 0, len = value.length; i < len; ++i) {
+                if (filtered && !_shouldSerializeElement(ctxt, Long.valueOf(value[i]))) {
+                    continue;
+                }
                 g.writeNumber(value[i]);
             }
         }
@@ -466,14 +520,18 @@ public class JDKArraySerializers
             super(float[].class);
         }
 
-        public FloatArraySerializer(FloatArraySerializer src, BeanProperty prop,
-                Boolean unwrapSingle) {
-            super(src, prop, unwrapSingle);
+        /**
+         * @since 3.1
+         */
+        protected FloatArraySerializer(FloatArraySerializer src, BeanProperty prop,
+                Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls) {
+            super(src, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         @Override
-        public ValueSerializer<?> _withResolved(BeanProperty prop, Boolean unwrapSingle) {
-            return new FloatArraySerializer(this, prop, unwrapSingle);
+        protected FloatArraySerializer _withResolved(BeanProperty prop,
+                Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls) {
+            return new FloatArraySerializer(this, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         @Override
@@ -524,10 +582,14 @@ public class JDKArraySerializers
         }
 
         @Override
-        public void serializeContents(float[] value, JsonGenerator g, SerializationContext provider)
+        public void serializeContents(float[] value, JsonGenerator g, SerializationContext ctxt)
             throws JacksonException
         {
+            final boolean filtered = _needToCheckFiltering(ctxt);
             for (int i = 0, len = value.length; i < len; ++i) {
+                if (filtered && !_shouldSerializeElement(ctxt, Float.valueOf(value[i]))) {
+                    continue;
+                }
                 g.writeNumber(value[i]);
             }
         }
@@ -547,20 +609,22 @@ public class JDKArraySerializers
 
         // @since 2.20
         final static DoubleArraySerializer instance = new DoubleArraySerializer();
-        
+
         public DoubleArraySerializer() { super(double[].class); }
 
         /**
-         * @since 2.6
+         * @since 3.1
          */
         protected DoubleArraySerializer(DoubleArraySerializer src,
-                BeanProperty prop, Boolean unwrapSingle) {
-            super(src, prop, unwrapSingle);
+                BeanProperty prop, Boolean unwrapSingle,
+                Object suppressableValue, boolean suppressNulls) {
+            super(src, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         @Override
-        public ValueSerializer<?> _withResolved(BeanProperty prop, Boolean unwrapSingle) {
-            return new DoubleArraySerializer(this, prop, unwrapSingle);
+        protected DoubleArraySerializer _withResolved(BeanProperty prop,
+                Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls) {
+            return new DoubleArraySerializer(this, prop, unwrapSingle, suppressableValue, suppressNulls);
         }
 
         /**
@@ -605,7 +669,7 @@ public class JDKArraySerializers
             }
             return super.createContextual(ctxt, property);
         }
-        
+
         @Override
         public void serialize(double[] value, JsonGenerator g, SerializationContext ctxt)
             throws JacksonException
@@ -615,6 +679,13 @@ public class JDKArraySerializers
                 serializeContents(value, g, ctxt);
                 return;
             }
+            // Check if filtering is needed
+            if (_needToCheckFiltering(ctxt)) {
+                g.writeStartArray(value, len);
+                serializeContents(value, g, ctxt);
+                g.writeEndArray();
+                return;
+            }
             // 11-May-2016, tatu: As per [core#277] we have efficient `writeArray(...)` available
             g.writeArray(value, 0, value.length);
         }
@@ -622,7 +693,11 @@ public class JDKArraySerializers
         @Override
         public void serializeContents(double[] value, JsonGenerator g, SerializationContext ctxt) throws JacksonException
         {
+            final boolean filtered = _needToCheckFiltering(ctxt);
             for (int i = 0, len = value.length; i < len; ++i) {
+                if (filtered && !_shouldSerializeElement(ctxt, Double.valueOf(value[i]))) {
+                    continue;
+                }
                 g.writeNumber(value[i]);
             }
         }
diff --git a/src/main/java/tools/jackson/databind/ser/jdk/ObjectArraySerializer.java b/src/main/java/tools/jackson/databind/ser/jdk/ObjectArraySerializer.java
index b46f65532..600d855ea 100644
--- a/src/main/java/tools/jackson/databind/ser/jdk/ObjectArraySerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/jdk/ObjectArraySerializer.java
@@ -3,6 +3,7 @@ package tools.jackson.databind.ser.jdk;
 import java.util.Objects;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.annotation.JsonInclude;
 
 import tools.jackson.core.*;
 import tools.jackson.databind.*;
@@ -13,6 +14,8 @@ import tools.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;
 import tools.jackson.databind.jsontype.TypeSerializer;
 import tools.jackson.databind.ser.std.ArraySerializerBase;
 import tools.jackson.databind.ser.std.StdContainerSerializer;
+import tools.jackson.databind.util.ArrayBuilders;
+import tools.jackson.databind.util.BeanUtil;
 
 /**
  * Generic serializer for Object arrays (<code>Object[]</code>).
@@ -21,6 +24,8 @@ import tools.jackson.databind.ser.std.StdContainerSerializer;
 public class ObjectArraySerializer
     extends ArraySerializerBase<Object[]>
 {
+    protected final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;
+
     /**
      * Whether we are using static typing (using declared types, ignoring
      * runtime type) or not for elements.
@@ -67,12 +72,23 @@ public class ObjectArraySerializer
         _elementSerializer = src._elementSerializer;
     }
 
-    @SuppressWarnings("unchecked")
+    @Deprecated // since 3.1
     public ObjectArraySerializer(ObjectArraySerializer src,
             BeanProperty property, TypeSerializer vts, ValueSerializer<?> elementSerializer,
             Boolean unwrapSingle)
     {
-        super(src,  property, unwrapSingle);
+        this(src, property, vts, elementSerializer, unwrapSingle, null, false);
+    }
+
+    /**
+     * @since 3.1
+     */
+    @SuppressWarnings("unchecked")
+    public ObjectArraySerializer(ObjectArraySerializer src,
+            BeanProperty property, TypeSerializer vts, ValueSerializer<?> elementSerializer,
+            Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls)
+    {
+        super(src, property, unwrapSingle, suppressableValue, suppressNulls);
         _elementType = src._elementType;
         _valueTypeSerializer = vts;
         _staticTyping = src._staticTyping;
@@ -80,9 +96,11 @@ public class ObjectArraySerializer
     }
 
     @Override
-    public ValueSerializer<?> _withResolved(BeanProperty prop, Boolean unwrapSingle) {
+    public ObjectArraySerializer _withResolved(BeanProperty prop, Boolean unwrapSingle,
+            Object suppressableValue, boolean suppressNulls) {
         return new ObjectArraySerializer(this, prop,
-                _valueTypeSerializer, _elementSerializer, unwrapSingle);
+                _valueTypeSerializer, _elementSerializer, unwrapSingle,
+                suppressableValue, suppressNulls);
     }
 
     @Override
@@ -90,13 +108,23 @@ public class ObjectArraySerializer
         return new ObjectArraySerializer(_elementType, _staticTyping, vts, _elementSerializer);
     }
 
-    public ObjectArraySerializer withResolved(BeanProperty prop,
-            TypeSerializer vts, ValueSerializer<?> ser, Boolean unwrapSingle) {
-        if ((_property == prop) && (ser == _elementSerializer)
-                && (_valueTypeSerializer == vts) && (Objects.equals(_unwrapSingle, unwrapSingle))) {
+    /**
+     * @since 3.1
+     */
+    protected ObjectArraySerializer _withResolved(BeanProperty prop,
+            TypeSerializer vts, ValueSerializer<?> elementSer, Boolean unwrapSingle,
+            Object suppressableValue, boolean suppressNulls) {
+        if ((_property == prop)
+                && (_valueTypeSerializer == vts)
+                && (_elementSerializer == elementSer)
+                && Objects.equals(_unwrapSingle, unwrapSingle)
+                && Objects.equals(_suppressableValue, suppressableValue)
+                && (_suppressNulls == suppressNulls)
+        ) {
             return this;
         }
-        return new ObjectArraySerializer(this, prop, vts, ser, unwrapSingle);
+        return new ObjectArraySerializer(this, prop, vts, elementSer, unwrapSingle,
+                suppressableValue, suppressNulls);
     }
 
     /*
@@ -143,7 +171,55 @@ public class ObjectArraySerializer
                 }
             }
         }
-        return withResolved(property, vts, ser, unwrapSingle);
+
+        // [databind#5515]: Handle content inclusion for arrays
+        JsonInclude.Value inclV = findIncludeOverrides(ctxt, property, handledType());
+        Object valueToSuppress = _suppressableValue;
+        boolean suppressNulls = _suppressNulls;
+
+        if (inclV != null) {
+            JsonInclude.Include incl = inclV.getContentInclusion();
+            if (incl != JsonInclude.Include.USE_DEFAULTS) {
+                switch (incl) {
+                    case NON_DEFAULT:
+                        valueToSuppress = BeanUtil.getDefaultValue(_elementType);
+                        suppressNulls = true;
+                        if (valueToSuppress != null) {
+                            if (valueToSuppress.getClass().isArray()) {
+                                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
+                            }
+                        }
+                        break;
+                    case NON_ABSENT:
+                        suppressNulls = true;
+                        valueToSuppress = MARKER_FOR_EMPTY;
+                        break;
+                    case NON_EMPTY:
+                        suppressNulls = true;
+                        valueToSuppress = MARKER_FOR_EMPTY;
+                        break;
+                    case CUSTOM:
+                        valueToSuppress = ctxt.includeFilterInstance(null, inclV.getContentFilter());
+                        if (valueToSuppress == null) {
+                            suppressNulls = true;
+                        } else {
+                            suppressNulls = ctxt.includeFilterSuppressNulls(valueToSuppress);
+                        }
+                        break;
+                    case NON_NULL:
+                        valueToSuppress = null;
+                        suppressNulls = true;
+                        break;
+                    case ALWAYS:
+                    default:
+                        valueToSuppress = null;
+                        suppressNulls = false;
+                        break;
+                }
+            }
+        }
+
+        return _withResolved(property, vts, ser, unwrapSingle, valueToSuppress, suppressNulls);
     }
 
     /*
@@ -212,12 +288,16 @@ public class ObjectArraySerializer
             serializeTypedContents(value, g, ctxt);
             return;
         }
+        final boolean filtered = _needToCheckFiltering(ctxt);
         int i = 0;
         Object elem = null;
         try {
             for (; i < len; ++i) {
                 elem = value[i];
                 if (elem == null) {
+                    if (filtered && _suppressNulls) {
+                        continue;
+                    }
                     ctxt.defaultSerializeNullValue(g);
                     continue;
                 }
@@ -231,6 +311,10 @@ public class ObjectArraySerializer
                         serializer = _findAndAddDynamic(ctxt, cc);
                     }
                 }
+                // Check if this element should be suppressed (only in filtered mode)
+                if (filtered && !_shouldSerializeElement(ctxt, elem, serializer)) {
+                    continue;
+                }
                 serializer.serialize(elem, g, ctxt);
             }
         } catch (Exception e) {
@@ -244,6 +328,7 @@ public class ObjectArraySerializer
     {
         final int len = value.length;
         final TypeSerializer typeSer = _valueTypeSerializer;
+        final boolean filtered = _needToCheckFiltering(ctxt);
 
         int i = 0;
         Object elem = null;
@@ -251,9 +336,16 @@ public class ObjectArraySerializer
             for (; i < len; ++i) {
                 elem = value[i];
                 if (elem == null) {
+                    if (filtered && _suppressNulls) {
+                        continue;
+                    }
                     ctxt.defaultSerializeNullValue(g);
                     continue;
                 }
+                // Check if this element should be suppressed (only in filtered mode)
+                if (filtered && !_shouldSerializeElement(ctxt, elem, ser)) {
+                    continue;
+                }
                 if (typeSer == null) {
                     ser.serialize(elem, g, ctxt);
                 } else {
@@ -270,12 +362,16 @@ public class ObjectArraySerializer
     {
         final int len = value.length;
         final TypeSerializer typeSer = _valueTypeSerializer;
+        final boolean filtered = _needToCheckFiltering(ctxt);
         int i = 0;
         Object elem = null;
         try {
             for (; i < len; ++i) {
                 elem = value[i];
                 if (elem == null) {
+                    if (filtered && _suppressNulls) {
+                        continue;
+                    }
                     ctxt.defaultSerializeNullValue(g);
                     continue;
                 }
@@ -284,6 +380,10 @@ public class ObjectArraySerializer
                 if (serializer == null) {
                     serializer = _findAndAddDynamic(ctxt, cc);
                 }
+                // Check if this element should be suppressed (only in filtered mode)
+                if (filtered && !_shouldSerializeElement(ctxt, elem, serializer)) {
+                    continue;
+                }
                 serializer.serializeWithType(elem, g, ctxt, typeSer);
             }
         } catch (Exception e) {
@@ -291,6 +391,43 @@ public class ObjectArraySerializer
         }
     }
 
+    /*
+    /**********************************************************************
+    /* Helper methods for content filtering
+    /**********************************************************************
+     */
+
+    /**
+     * Common utility method for checking if an element should be filtered/suppressed
+     * based on @JsonInclude settings. Returns {@code true} if element should be serialized,
+     * {@code false} if it should be skipped.
+     *
+     * @param ctxt Serialization context
+     * @param elem Element to check for suppression
+     * @param serializer Serializer for the element (may be null for strings)
+     * @return true if element should be serialized, false if suppressed
+     *
+     * @since 3.1
+     */
+    protected boolean _shouldSerializeElement(SerializationContext ctxt,
+            Object elem, ValueSerializer<Object> serializer)
+    {
+        if (_suppressableValue == null) {
+            return true;
+        }
+        if (_suppressableValue == MARKER_FOR_EMPTY) {
+            if (serializer != null) {
+                return !serializer.isEmpty(ctxt, elem);
+            }
+            // For strings, check emptiness directly
+            if (elem instanceof String str) {
+                return !str.isEmpty();
+            }
+            return true;
+        }
+        return !_suppressableValue.equals(elem);
+    }
+
     @Override
     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)
     {
diff --git a/src/main/java/tools/jackson/databind/ser/jdk/StringArraySerializer.java b/src/main/java/tools/jackson/databind/ser/jdk/StringArraySerializer.java
index 3f087953b..95fc8fb39 100644
--- a/src/main/java/tools/jackson/databind/ser/jdk/StringArraySerializer.java
+++ b/src/main/java/tools/jackson/databind/ser/jdk/StringArraySerializer.java
@@ -1,8 +1,7 @@
 package tools.jackson.databind.ser.jdk;
 
-import java.util.Objects;
-
 import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.annotation.JsonInclude;
 
 import tools.jackson.core.JacksonException;
 import tools.jackson.core.JsonGenerator;
@@ -15,6 +14,8 @@ import tools.jackson.databind.jsontype.TypeSerializer;
 import tools.jackson.databind.ser.std.ArraySerializerBase;
 import tools.jackson.databind.ser.std.StdContainerSerializer;
 import tools.jackson.databind.type.TypeFactory;
+import tools.jackson.databind.util.ArrayBuilders;
+import tools.jackson.databind.util.BeanUtil;
 
 /**
  * Standard serializer used for <code>String[]</code> values.
@@ -23,6 +24,8 @@ import tools.jackson.databind.type.TypeFactory;
 public class StringArraySerializer
     extends ArraySerializerBase<String[]>
 {
+    protected final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;
+
     /* Note: not clean in general, but we are betting against
      * anyone re-defining properties of String.class here...
      */
@@ -47,16 +50,22 @@ public class StringArraySerializer
         _elementSerializer = null;
     }
 
+    /**
+     * @since 3.1
+     */
     @SuppressWarnings("unchecked")
     public StringArraySerializer(StringArraySerializer src,
-            BeanProperty prop, ValueSerializer<?> ser, Boolean unwrapSingle) {
-        super(src, prop, unwrapSingle);
+            BeanProperty prop, ValueSerializer<?> ser, Boolean unwrapSingle,
+            Object suppressableValue, boolean suppressNulls) {
+        super(src, prop, unwrapSingle, suppressableValue, suppressNulls);
         _elementSerializer = (ValueSerializer<Object>) ser;
     }
 
     @Override
-    public ValueSerializer<?> _withResolved(BeanProperty prop, Boolean unwrapSingle) {
-        return new StringArraySerializer(this, prop, _elementSerializer, unwrapSingle);
+    public StringArraySerializer _withResolved(BeanProperty prop, Boolean unwrapSingle,
+            Object suppressableValue, boolean suppressNulls) {
+        return new StringArraySerializer(this, prop, _elementSerializer, unwrapSingle,
+                suppressableValue, suppressNulls);
     }
 
     /**
@@ -108,11 +117,56 @@ public class StringArraySerializer
         if (isDefaultSerializer(ser)) {
             ser = null;
         }
-        // note: will never have TypeSerializer, because Strings are "natural" type
-        if ((ser == _elementSerializer) && (Objects.equals(unwrapSingle, _unwrapSingle))) {
-            return this;
+
+        // [databind#5515]: Handle content inclusion for arrays
+        JsonInclude.Value inclV = findIncludeOverrides(ctxt, property, handledType());
+        Object valueToSuppress = _suppressableValue;
+        boolean suppressNulls = _suppressNulls;
+
+        if (inclV != null) {
+            JsonInclude.Include incl = inclV.getContentInclusion();
+            if (incl != JsonInclude.Include.USE_DEFAULTS) {
+                switch (incl) {
+                    case NON_DEFAULT:
+                        valueToSuppress = BeanUtil.getDefaultValue(VALUE_TYPE);
+                        suppressNulls = true;
+                        if (valueToSuppress != null) {
+                            if (valueToSuppress.getClass().isArray()) {
+                                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
+                            }
+                        }
+                        break;
+                    case NON_ABSENT:
+                        suppressNulls = true;
+                        valueToSuppress = MARKER_FOR_EMPTY;
+                        break;
+                    case NON_EMPTY:
+                        suppressNulls = true;
+                        valueToSuppress = MARKER_FOR_EMPTY;
+                        break;
+                    case CUSTOM:
+                        valueToSuppress = ctxt.includeFilterInstance(null, inclV.getContentFilter());
+                        if (valueToSuppress == null) {
+                            suppressNulls = true;
+                        } else {
+                            suppressNulls = ctxt.includeFilterSuppressNulls(valueToSuppress);
+                        }
+                        break;
+                    case NON_NULL:
+                        valueToSuppress = null;
+                        suppressNulls = true;
+                        break;
+                    case ALWAYS:
+                    default:
+                        valueToSuppress = null;
+                        suppressNulls = false;
+                        break;
+                }
+            }
         }
-        return new StringArraySerializer(this, property, ser, unwrapSingle);
+        // note: will never have TypeSerializer, because Strings are "natural" type
+        return new StringArraySerializer(this, property, ser, unwrapSingle,
+                valueToSuppress, suppressNulls);
     }
 
     /*
@@ -177,12 +231,20 @@ public class StringArraySerializer
             serializeContentsSlow(value, g, ctxt, _elementSerializer);
             return;
         }
+        final boolean filtered = _needToCheckFiltering(ctxt);
         for (int i = 0; i < len; ++i) {
             String str = value[i];
             if (str == null) {
+                if (filtered && _suppressNulls) {
+                    continue;
+                }
                 g.writeNull();
             } else {
-                g.writeString(value[i]);
+                // Check if this element should be suppressed (only in filtered mode)
+                if (filtered && !_shouldSerializeElement(ctxt, str, null)) {
+                    continue;
+                }
+                g.writeString(str);
             }
         }
     }
@@ -191,14 +253,56 @@ public class StringArraySerializer
             SerializationContext ctxt, ValueSerializer<Object> ser)
         throws JacksonException
     {
+        final boolean filtered = _needToCheckFiltering(ctxt);
         for (int i = 0, len = value.length; i < len; ++i) {
             String str = value[i];
             if (str == null) {
+                if (filtered && _suppressNulls) {
+                    continue;
+                }
                 ctxt.defaultSerializeNullValue(g);
             } else {
-                ser.serialize(value[i], g, ctxt);
+                // Check if this element should be suppressed (only in filtered mode)
+                if (filtered && !_shouldSerializeElement(ctxt, str, ser)) {
+                    continue;
+                }
+                ser.serialize(str, g, ctxt);
+            }
+        }
+    }
+
+    /*
+    /**********************************************************************
+    /* Helper methods for content filtering
+    /**********************************************************************
+     */
+
+    /**
+     * Common utility method for checking if an element should be filtered/suppressed
+     * based on @JsonInclude settings. Returns {@code true} if element should be serialized,
+     * {@code false} if it should be skipped.
+     *
+     * @param ctxt Serialization context
+     * @param elem Element to check for suppression
+     * @param serializer Serializer for the element (may be null for strings)
+     * @return true if element should be serialized, false if suppressed
+     *
+     * @since 3.1
+     */
+    protected boolean _shouldSerializeElement(SerializationContext ctxt,
+            String elem, ValueSerializer<Object> serializer)
+    {
+        if (_suppressableValue == null) {
+            return true;
+        }
+        if (_suppressableValue == MARKER_FOR_EMPTY) {
+            if (serializer != null) {
+                return !serializer.isEmpty(ctxt, elem);
             }
+            // For strings, check emptiness directly
+            return !elem.isEmpty();
         }
+        return !_suppressableValue.equals(elem);
     }
 
     @Override
diff --git a/src/main/java/tools/jackson/databind/ser/std/ArraySerializerBase.java b/src/main/java/tools/jackson/databind/ser/std/ArraySerializerBase.java
index e1ae86941..9a1daddc2 100644
--- a/src/main/java/tools/jackson/databind/ser/std/ArraySerializerBase.java
+++ b/src/main/java/tools/jackson/databind/ser/std/ArraySerializerBase.java
@@ -3,11 +3,14 @@ package tools.jackson.databind.ser.std;
 import java.util.Objects;
 
 import com.fasterxml.jackson.annotation.JsonFormat;
+import com.fasterxml.jackson.annotation.JsonInclude;
 
 import tools.jackson.core.*;
 import tools.jackson.core.type.WritableTypeId;
 import tools.jackson.databind.*;
 import tools.jackson.databind.jsontype.TypeSerializer;
+import tools.jackson.databind.util.ArrayBuilders;
+import tools.jackson.databind.util.BeanUtil;
 
 /**
  * Intermediate base class for serializers used for various Java arrays.
@@ -17,6 +20,8 @@ import tools.jackson.databind.jsontype.TypeSerializer;
 public abstract class ArraySerializerBase<T>
     extends StdContainerSerializer<T>
 {
+    protected final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;
+
     /**
      * Setting for specific local override for "unwrap single element arrays":
      * true for enable unwrapping, false for preventing it, `null` for using
@@ -24,26 +29,57 @@ public abstract class ArraySerializerBase<T>
      */
     protected final Boolean _unwrapSingle;
 
+    /**
+     * Value that indicates suppression mechanism to use for
+     * content values (elements of array), if any; null
+     * for no filtering.
+     *
+     * @since 3.1
+     */
+    protected final Object _suppressableValue;
+
+    /**
+     * Flag that indicates whether nulls should be suppressed.
+     *
+     * @since 3.1
+     */
+    protected final boolean _suppressNulls;
+
     protected ArraySerializerBase(Class<T> cls)
     {
         super(cls);
         _unwrapSingle = null;
+        _suppressableValue = null;
+        _suppressNulls = false;
     }
 
     protected ArraySerializerBase(ArraySerializerBase<?> src) {
         super(src);
         _unwrapSingle = src._unwrapSingle;
+        _suppressableValue = src._suppressableValue;
+        _suppressNulls = src._suppressNulls;
     }
 
+    /**
+     * @since 3.1
+     */
     protected ArraySerializerBase(ArraySerializerBase<?> src, BeanProperty property,
-            Boolean unwrapSingle)
+            Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls)
     {
         super(src, property);
         _unwrapSingle = unwrapSingle;
+        _suppressableValue = suppressableValue;
+        _suppressNulls = suppressNulls;
     }
 
-    public abstract ValueSerializer<?> _withResolved(BeanProperty prop,
-            Boolean unwrapSingle);
+    /**
+     * Factory method to use for creating differently configured instances with
+     * content inclusion settings, called by this class from {@link #createContextual}.
+     *
+     * @since 3.1
+     */
+    protected abstract ArraySerializerBase<T> _withResolved(BeanProperty prop,
+            Boolean unwrapSingle, Object suppressableValue, boolean suppressNulls);
 
     @Override
     public ValueSerializer<?> createContextual(SerializationContext serializers,
@@ -56,11 +92,61 @@ public abstract class ArraySerializerBase<T>
             JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());
             if (format != null) {
                 unwrapSingle = format.getFeature(JsonFormat.Feature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED);
-                if (!Objects.equals(unwrapSingle, _unwrapSingle)) {
-                    return _withResolved(property, unwrapSingle);
+            }
+        }
+
+        // [databind#5515]: Handle content inclusion for arrays
+        JsonInclude.Value inclV = findIncludeOverrides(serializers, property, handledType());
+        Object valueToSuppress = _suppressableValue;
+        boolean suppressNulls = _suppressNulls;
+
+        if (inclV != null) {
+            JsonInclude.Include incl = inclV.getContentInclusion();
+            if (incl != JsonInclude.Include.USE_DEFAULTS) {
+                switch (incl) {
+                    case NON_DEFAULT:
+                        valueToSuppress = BeanUtil.getDefaultValue(getContentType());
+                        suppressNulls = true;
+                        if (valueToSuppress != null) {
+                            if (valueToSuppress.getClass().isArray()) {
+                                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);
+                            }
+                        }
+                        break;
+                    case NON_ABSENT:
+                        suppressNulls = true;
+                        valueToSuppress = MARKER_FOR_EMPTY;
+                        break;
+                    case NON_EMPTY:
+                        suppressNulls = true;
+                        valueToSuppress = MARKER_FOR_EMPTY;
+                        break;
+                    case CUSTOM:
+                        valueToSuppress = serializers.includeFilterInstance(null, inclV.getContentFilter());
+                        if (valueToSuppress == null) {
+                            suppressNulls = true;
+                        } else {
+                            suppressNulls = serializers.includeFilterSuppressNulls(valueToSuppress);
+                        }
+                        break;
+                    case NON_NULL:
+                        valueToSuppress = null;
+                        suppressNulls = true;
+                        break;
+                    case ALWAYS:
+                    default:
+                        valueToSuppress = null;
+                        suppressNulls = false;
+                        break;
                 }
             }
         }
+
+        if (!Objects.equals(unwrapSingle, _unwrapSingle)
+                || !Objects.equals(valueToSuppress, _suppressableValue)
+                || (suppressNulls != _suppressNulls)) {
+            return _withResolved(property, unwrapSingle, valueToSuppress, suppressNulls);
+        }
         return this;
     }
 
@@ -86,4 +172,46 @@ public abstract class ArraySerializerBase<T>
         }
         return _unwrapSingle.booleanValue();
     }
+
+    /*
+    /**********************************************************************
+    /* Helper methods for content filtering
+    /**********************************************************************
+     */
+
+    /**
+     * Common utility method for checking if this serializer needs to consider
+     * filtering of its elements.
+     * Returns {@code true} if filtering needs to be checked,
+     * {@code false} if not.
+     *
+     * @since 3.1
+     */
+    protected boolean _needToCheckFiltering(SerializationContext ctxt) {
+        return ((_suppressableValue != null) || _suppressNulls)
+                && ctxt.isEnabled(SerializationFeature.APPLY_JSON_INCLUDE_FOR_CONTAINERS);
+    }
+
+    /**
+     * Common utility method for checking if an element should be filtered/suppressed
+     * based on @JsonInclude settings. Returns {@code true} if element should be serialized,
+     * {@code false} if it should be skipped.
+     *
+     * @param ctxt Serialization context
+     * @param elem Element to check for suppression (boxed primitive)
+     * @return true if element should be serialized, false if suppressed
+     *
+     * @since 3.1
+     */
+    protected boolean _shouldSerializeElement(SerializationContext ctxt, Object elem)
+    {
+        if (_suppressableValue == null) {
+            return true;
+        }
+        if (_suppressableValue == MARKER_FOR_EMPTY) {
+            // For primitives, no concept of "empty"
+            return true;
+        }
+        return !_suppressableValue.equals(elem);
+    }
 }
