diff --git a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
index 8e92a0d93..7e2ed1b82 100644
--- a/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
+++ b/src/main/java/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
@@ -42,6 +42,9 @@ import org.mockito.stubbing.Answer;
  * Returns an {@code java.util.stream.Stream#empty() empty Stream} for Stream. Similarly for primitive stream variants.
  * </li>
  * <li>
+ * Returns an {@code java.time.Duration.ZERO zero Duration} for empty Duration and {@code java.time.Period.ZERO zero Period} for empty Period.
+ * </li>
+ * <li>
  * Returns null for everything else
  * </li>
  * </ul>
@@ -125,6 +128,10 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {
             return JavaEightUtil.emptyIntStream();
         } else if ("java.util.stream.LongStream".equals(type.getName())) {
             return JavaEightUtil.emptyLongStream();
+        } else if ("java.time.Duration".equals(type.getName())) {
+            return JavaEightUtil.emptyDuration();
+        } else if ("java.time.Period".equals(type.getName())) {
+            return JavaEightUtil.emptyPeriod();
         }
 
         //Let's not care about the rest of collections.
diff --git a/src/main/java/org/mockito/internal/util/JavaEightUtil.java b/src/main/java/org/mockito/internal/util/JavaEightUtil.java
index ce85487a8..5b2ffc3fb 100644
--- a/src/main/java/org/mockito/internal/util/JavaEightUtil.java
+++ b/src/main/java/org/mockito/internal/util/JavaEightUtil.java
@@ -4,9 +4,10 @@
  */
 package org.mockito.internal.util;
 
+import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 
-import org.mockito.internal.creation.instance.InstantiationException;
+import org.mockito.creation.instance.InstantiationException;
 
 /**
  * Helper class to work with features that were introduced in Java versions after 1.5.
@@ -19,6 +20,8 @@ public final class JavaEightUtil {
     private static Object emptyOptionalDouble;
     private static Object emptyOptionalInt;
     private static Object emptyOptionalLong;
+    private static Object emptyDuration;
+    private static Object emptyPeriod;
 
     private JavaEightUtil() {
         // utility class
@@ -121,6 +124,35 @@ public final class JavaEightUtil {
         return invokeNullaryFactoryMethod("java.util.stream.LongStream", "empty");
     }
 
+
+    /**
+     * Creates an empty Duration using reflection to stay backwards-compatible with older JDKs.
+     *
+     * @return an empty (ZERO) Duration.
+     */
+    public static Object emptyDuration() {
+        // no need for double-checked locking
+        if (emptyDuration != null) {
+            return emptyDuration;
+        }
+
+        return emptyDuration = getStaticFieldValue("java.time.Duration", "ZERO");
+    }
+
+    /**
+     * Creates an empty Period using reflection to stay backwards-compatible with older JDKs.
+     *
+     * @return an empty (ZERO) Period.
+     */
+    public static Object emptyPeriod() {
+        // no need for double-checked locking
+        if (emptyPeriod != null) {
+            return emptyPeriod;
+        }
+
+        return emptyPeriod = getStaticFieldValue("java.time.Period", "ZERO");
+    }
+
     /**
      * Invokes a nullary static factory method using reflection to stay backwards-compatible with older JDKs.
      *
@@ -130,15 +162,69 @@ public final class JavaEightUtil {
      */
     private static Object invokeNullaryFactoryMethod(final String fqcn, final String methodName) {
         try {
-            final Class<?> type = Class.forName(fqcn);
-            final Method method = type.getMethod(methodName);
-
+            final Method method = getMethod(fqcn, methodName);
             return method.invoke(null);
             // any exception is really unexpected since the type name has
             // already been verified
         } catch (final Exception e) {
             throw new InstantiationException(
-                    String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
+                String.format("Could not create %s#%s(): %s", fqcn, methodName, e), e);
+        }
+    }
+
+
+    /**
+     * Gets a value of the classes' field using reflection to stay backwards-compatible with older JDKs.
+     *
+     * @param fqcn The fully qualified class name of the type to be produced.
+     * @param fieldName The name of th classes' field which value is going to be returned.
+     * @return the restored value.
+     */
+    private static Object getStaticFieldValue(final String fqcn, final String fieldName) {
+        try {
+            final Class<?> type = getClass(fqcn);
+            final Field field = type.getDeclaredField(fieldName);
+            return field.get(null);
+            // any exception is really unexpected since the type name has
+            // already been verified
+        } catch (Exception e) {
+            throw new InstantiationException(
+                String.format("Could not get %s#%s(): %s", fqcn, fieldName, e), e);
+        }
+    }
+
+    /**
+     * Returns the {@code Class} object associated with the class or interface with the given string name.
+     *
+     * @param fqcn The fully qualified class name of the type to be produced.
+     * @return the Class object for the class with the specified name.
+     */
+    private static Class<?> getClass(String fqcn) {
+        try {
+            return Class.forName(fqcn);
+            // any exception is really unexpected since the type name has
+            // already been verified
+        } catch (ClassNotFoundException e) {
+            throw new InstantiationException(
+                String.format("Could not find %s: %s", fqcn, e), e);
+        }
+    }
+
+    /**
+     * Returns a Method object that reflects the specified public member method of the class or interface represented by the fully qualified class name.
+     *
+     * @param fqcn The fully qualified class name of the type to be produced.
+     * @param methodName The name of the method.
+     * @param parameterClasses The list of parameters.
+     * @return The Method object that matches the specified name and parameterTypes.
+     */
+    private static Method getMethod(final String fqcn, final String methodName, final Class<?>... parameterClasses) {
+        try {
+            final Class<?> type = getClass(fqcn);
+            return type.getMethod(methodName, parameterClasses);
+        } catch (Exception e) {
+            throw new InstantiationException(
+                String.format("Could not find %s#%s(): %s", fqcn, methodName, e), e);
         }
     }
 }
