diff --git a/CHANGELOG.md b/CHANGELOG.md
index 511a9e05..89233553 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -12,7 +12,7 @@
 
 **Fixed**
 
- - Nothing yet!
+ - Ensure that exceptions thrown from failure to parse method annotations can be observed by multiple threads/callers. Previously only the first caller would see the actual parsing exception and other callers would get a cryptic `ClassCastException`.
 
 
 ## [2.10.0] - 2024-03-18
diff --git a/retrofit/src/main/java/retrofit2/Retrofit.java b/retrofit/src/main/java/retrofit2/Retrofit.java
index c66f8212..9e5a5bd5 100644
--- a/retrofit/src/main/java/retrofit2/Retrofit.java
+++ b/retrofit/src/main/java/retrofit2/Retrofit.java
@@ -212,38 +212,53 @@ public final class Retrofit {
   }
 
   ServiceMethod<?> loadServiceMethod(Class<?> service, Method method) {
-    // Note: Once we are minSdk 24 this whole method can be replaced by computeIfAbsent.
-    Object lookup = serviceMethodCache.get(method);
+    while (true) {
+      // Note: Once we are minSdk 24 this whole method can be replaced by computeIfAbsent.
+      Object lookup = serviceMethodCache.get(method);
 
-    if (lookup instanceof ServiceMethod<?>) {
-      // Happy path: method is already parsed into the model.
-      return (ServiceMethod<?>) lookup;
-    }
+      if (lookup instanceof ServiceMethod<?>) {
+        // Happy path: method is already parsed into the model.
+        return (ServiceMethod<?>) lookup;
+      }
 
-    if (lookup == null) {
-      // Map does not contain any value. Try to put in a lock for this method. We MUST synchronize
-      // on the lock before it is visible to others via the map to signal we are doing the work.
-      Object lock = new Object();
-      synchronized (lock) {
-        lookup = serviceMethodCache.putIfAbsent(method, lock);
-        if (lookup == null) {
-          // On successful lock insertion, perform the work and update the map before releasing.
-          // Other threads may be waiting on lock now and will expect the parsed model.
-          ServiceMethod<Object> result = ServiceMethod.parseAnnotations(this, service, method);
-          serviceMethodCache.put(method, result);
-          return result;
+      if (lookup == null) {
+        // Map does not contain any value. Try to put in a lock for this method. We MUST synchronize
+        // on the lock before it is visible to others via the map to signal we are doing the work.
+        Object lock = new Object();
+        synchronized (lock) {
+          lookup = serviceMethodCache.putIfAbsent(method, lock);
+          if (lookup == null) {
+            // On successful lock insertion, perform the work and update the map before releasing.
+            // Other threads may be waiting on lock now and will expect the parsed model.
+            ServiceMethod<Object> result;
+            try {
+              result = ServiceMethod.parseAnnotations(this, service, method);
+            } catch (Throwable e) {
+              // Remove the lock on failure. Any other locked threads will retry as a result.
+              serviceMethodCache.remove(method);
+              throw e;
+            }
+            serviceMethodCache.put(method, result);
+            return result;
+          }
         }
       }
-    }
 
-    // Either the initial lookup or the attempt to put our lock in the map has returned someone
-    // else's lock. This means they are doing the parsing, and will update the map before releasing
-    // the lock. Once we can take the lock, the map is guaranteed to contain the model.
-    // Note: There's a chance that our effort to put a lock into the map has actually returned a
-    // finished model instead of a lock. In that case this code will perform a pointless lock and
-    // redundant lookup in the map of the same instance. This is rare, and ultimately harmless.
-    synchronized (lookup) {
-      return (ServiceMethod<?>) serviceMethodCache.get(method);
+      // Either the initial lookup or the attempt to put our lock in the map has returned someone
+      // else's lock. This means they are doing the parsing, and will update the map before
+      // releasing
+      // the lock. Once we can take the lock, the map is guaranteed to contain the model or null.
+      // Note: There's a chance that our effort to put a lock into the map has actually returned a
+      // finished model instead of a lock. In that case this code will perform a pointless lock and
+      // redundant lookup in the map of the same instance. This is rare, and ultimately harmless.
+      synchronized (lookup) {
+        Object result = serviceMethodCache.get(method);
+        if (result == null) {
+          // The other thread failed its parsing. We will retry (and probably also fail).
+          continue;
+        }
+        return (ServiceMethod<?>) result;
+      }
     }
   }
 
