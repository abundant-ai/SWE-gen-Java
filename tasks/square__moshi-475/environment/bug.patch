diff --git a/README.md b/README.md
index 7268b5e1..1c6e9423 100644
--- a/README.md
+++ b/README.md
@@ -498,7 +498,7 @@ Download [the latest JAR][dl] or depend via Maven:
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.moshi:moshi:1.5.0'
+implementation 'com.squareup.moshi:moshi:1.5.0'
 ```
 and for additional Kotlin support:
 ```xml
@@ -510,7 +510,7 @@ and for additional Kotlin support:
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.moshi:moshi-kotlin:1.5.0'
+implementation 'com.squareup.moshi:moshi-kotlin:1.5.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/adapters/README.md b/adapters/README.md
index d3808e51..d94849c2 100644
--- a/adapters/README.md
+++ b/adapters/README.md
@@ -25,7 +25,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-compile 'com.squareup.moshi:moshi-adapters:latest.version'
+implementation 'com.squareup.moshi:moshi-adapters:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/kotlin-codegen/compiler/pom.xml b/kotlin-codegen/compiler/pom.xml
index d6aa8dd4..092d18e5 100644
--- a/kotlin-codegen/compiler/pom.xml
+++ b/kotlin-codegen/compiler/pom.xml
@@ -25,20 +25,10 @@
       <artifactId>moshi</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi-kotlin-codegen-runtime</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>org.jetbrains.kotlin</groupId>
       <artifactId>kotlin-stdlib</artifactId>
     </dependency>
-    <dependency>
-      <groupId>me.eugeniomarletti</groupId>
-      <artifactId>kotlin-metadata</artifactId>
-      <version>1.2.1</version>
-    </dependency>
     <dependency>
       <groupId>com.google.auto</groupId>
       <artifactId>auto-common</artifactId>
@@ -65,6 +55,32 @@
       <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
+
+    <!--
+      The Kotlin compiler must be near the end of the list because its .jar file includes an
+      obsolete version of Guava!
+    -->
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-compiler-embeddable</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-annotation-processing-embeddable</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>me.eugeniomarletti</groupId>
+      <artifactId>kotlin-metadata</artifactId>
+    </dependency>
+    <!--
+      Though we don't use compile-testing, including it is a convenient way to get tools.jar on the
+      classpath. This dependency is required by kapt3.
+    -->
+    <dependency>
+      <groupId>com.google.testing.compile</groupId>
+      <artifactId>compile-testing</artifactId>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -129,6 +145,18 @@
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-surefire-plugin</artifactId>
+        <version>2.21.0</version>
+        <configuration>
+          <!--
+            Suppress the surefire classloader which prevents introspecting the classpath.
+            http://maven.apache.org/surefire/maven-surefire-plugin/examples/class-loading.html
+          -->
+          <useManifestOnlyJar>false</useManifestOnlyJar>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
index 399a6513..4f93169f 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
@@ -16,6 +16,7 @@
 package com.squareup.moshi
 
 import com.squareup.kotlinpoet.ARRAY
+import com.squareup.kotlinpoet.AnnotationSpec
 import com.squareup.kotlinpoet.ClassName
 import com.squareup.kotlinpoet.FileSpec
 import com.squareup.kotlinpoet.FunSpec
@@ -31,24 +32,22 @@ import com.squareup.kotlinpoet.asTypeName
 import org.jetbrains.kotlin.serialization.ProtoBuf
 import java.lang.reflect.Type
 import javax.lang.model.element.Element
+import javax.lang.model.element.TypeElement
 import javax.lang.model.util.Elements
 
 /** Generates a JSON adapter for a target type. */
 internal class AdapterGenerator(
-  val fqClassName: String,
-  val packageName: String,
+  val className: ClassName,
   val propertyList: List<PropertyGenerator>,
   val originalElement: Element,
-  name: String = fqClassName.substringAfter(packageName)
-      .replace('.', '_')
-      .removePrefix("_"),
+  val isDataClass: Boolean,
   val hasCompanionObject: Boolean,
   val visibility: ProtoBuf.Visibility,
   val elements: Elements,
   val genericTypeNames: List<TypeVariableName>?
 ) {
   val nameAllocator = NameAllocator()
-  val adapterName = "${name}JsonAdapter"
+  val adapterName = "${className.simpleNames().joinToString(separator = "_")}JsonAdapter"
   val originalTypeName = originalElement.asType().asTypeName()
 
   val moshiParam = ParameterSpec.builder(
@@ -84,7 +83,7 @@ internal class AdapterGenerator(
 
   val delegateAdapters = propertyList.distinctBy { it.delegateKey() }
 
-  fun generateFile(): FileSpec {
+  fun generateFile(generatedOption: TypeElement?): FileSpec {
     for (property in delegateAdapters) {
       property.reserveDelegateNames(nameAllocator)
     }
@@ -92,16 +91,24 @@ internal class AdapterGenerator(
       property.allocateNames(nameAllocator)
     }
 
-    val result = FileSpec.builder(packageName, adapterName)
+    val result = FileSpec.builder(className.packageName(), adapterName)
     if (hasCompanionObject) {
       result.addFunction(generateJsonAdapterFun())
     }
-    result.addType(generateType())
+    result.addType(generateType(generatedOption))
     return result.build()
   }
 
-  private fun generateType(): TypeSpec {
+  private fun generateType(generatedOption: TypeElement?): TypeSpec {
     val result = TypeSpec.classBuilder(adapterName)
+
+    generatedOption?.let {
+      result.addAnnotation(AnnotationSpec.builder(it.asClassName())
+          .addMember("%S", JsonClassCodeGenProcessor::class.java.canonicalName)
+          .addMember("%S", "https://github.com/square/moshi")
+          .build())
+    }
+
     result.superclass(jsonAdapterTypeName)
 
     genericTypeNames?.let {
@@ -148,6 +155,8 @@ internal class AdapterGenerator(
   }
 
   private fun generateFromJsonFun(): FunSpec {
+    val resultName = nameAllocator.newName("result")
+
     val result = FunSpec.builder("fromJson")
         .addModifiers(KModifier.OVERRIDE)
         .addParameter(readerParam)
@@ -168,7 +177,7 @@ internal class AdapterGenerator(
       if (property.differentiateAbsentFromNull) {
         result.beginControlFlow("%L -> ", index)
         result.addStatement("%N = %N.fromJson(%N)",
-            property.localName, property.delegateName, readerParam);
+            property.localName, property.delegateName, readerParam)
         result.addStatement("%N = true", property.localIsPresentName)
         result.endControlFlow()
       } else {
@@ -187,36 +196,72 @@ internal class AdapterGenerator(
     result.endControlFlow() // while
     result.addStatement("%N.endObject()", readerParam)
 
-    val propertiesWithoutDefaults = propertyList.filter { !it.hasDefault }
-    result.addCode("%[return %T(\n", originalTypeName)
-    propertiesWithoutDefaults.forEachIndexed { index, property ->
+    // Call the constructor providing only required parameters.
+    var hasOptionalParameters = false
+    result.addCode("%[var %N = %T(", resultName, originalTypeName)
+    var separator = "\n"
+    for (property in propertyList) {
+      if (!property.hasConstructorParameter) {
+        continue
+      }
+      if (property.hasDefault) {
+        hasOptionalParameters = true
+        continue
+      }
+      result.addCode(separator)
       result.addCode("%N = %N", property.name, property.localName)
       if (property.isRequired) {
         result.addCode(" ?: throw %T(\"Required property '%L' missing at \${%N.path}\")",
             JsonDataException::class, property.localName, readerParam)
       }
-      result.addCode(if (index + 1 < propertiesWithoutDefaults.size) ",\n" else "\n")
+      separator = ",\n"
     }
-    result.addCode("%])\n", originalTypeName)
+    result.addCode(")%]\n", originalTypeName)
 
-    val propertiesWithDefaults = propertyList.filter { it.hasDefault }
-    if (!propertiesWithDefaults.isEmpty()) {
-      result.addCode(".let {%>\n")
-      result.addCode("%[it.copy(\n")
-      propertiesWithDefaults.forEachIndexed { index, property ->
+    // Call either the constructor again, or the copy() method, this time providing any optional
+    // parameters that we have.
+    if (hasOptionalParameters) {
+      if (isDataClass) {
+        result.addCode("%[%1N = %1N.copy(", resultName)
+      } else {
+        result.addCode("%[%1N = %2T(", resultName, originalTypeName)
+      }
+      separator = "\n"
+      for (property in propertyList) {
+        if (!property.hasConstructorParameter) {
+          continue // No constructor parameter for this property.
+        }
+        if (isDataClass && !property.hasDefault) {
+          continue // Property already assigned.
+        }
+
+        result.addCode(separator)
         if (property.differentiateAbsentFromNull) {
-          result.addCode("%1N = if (%2N) %3N else it.%1N",
-              property.name, property.localIsPresentName, property.localName)
+          result.addCode("%2N = if (%3N) %4N else %1N.%2N",
+              resultName, property.name, property.localIsPresentName, property.localName)
         } else {
-          result.addCode("%1N = %2N ?: it.%1N",
-              property.name, property.localName)
+          result.addCode("%2N = %3N ?: %1N.%2N", resultName, property.name, property.localName)
         }
-        result.addCode(if (index + 1 < propertiesWithDefaults.size) ",\n" else "\n")
+        separator = ",\n"
       }
       result.addCode("%])\n")
-      result.addCode("%<}\n")
     }
 
+    // Assign properties not present in the constructor.
+    for (property in propertyList) {
+      if (property.hasConstructorParameter) {
+        continue // Property already handled.
+      }
+      if (property.differentiateAbsentFromNull) {
+        result.addStatement("%1N.%2N = if (%3N) %4N else %1N.%2N",
+            resultName, property.name, property.localIsPresentName, property.localName)
+      } else {
+        result.addStatement("%1N.%2N = %3N ?: %1N.%2N",
+            resultName, property.name, property.localName)
+      }
+    }
+
+    result.addStatement("return %1N", resultName)
     return result.build()
   }
 
@@ -244,8 +289,7 @@ internal class AdapterGenerator(
 
   private fun generateJsonAdapterFun(): FunSpec {
     val rawType = when (originalTypeName) {
-      is TypeVariableName -> throw IllegalArgumentException(
-          "Cannot get raw type of TypeVariable!")
+      is TypeVariableName -> throw IllegalArgumentException("Cannot get raw type of TypeVariable!")
       is ParameterizedTypeName -> originalTypeName.rawType
       else -> originalTypeName as ClassName
     }
@@ -273,4 +317,4 @@ internal class AdapterGenerator(
 
     return result.build()
   }
-}
\ No newline at end of file
+}
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
new file mode 100644
index 00000000..82fc8f21
--- /dev/null
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
@@ -0,0 +1,291 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi
+
+import com.google.auto.common.AnnotationMirrors
+import com.google.auto.service.AutoService
+import com.squareup.kotlinpoet.ClassName
+import com.squareup.kotlinpoet.KModifier.OUT
+import com.squareup.kotlinpoet.ParameterizedTypeName
+import com.squareup.kotlinpoet.TypeSpec
+import com.squareup.kotlinpoet.TypeVariableName
+import com.squareup.kotlinpoet.asTypeName
+import me.eugeniomarletti.kotlin.metadata.KotlinClassMetadata
+import me.eugeniomarletti.kotlin.metadata.KotlinMetadataUtils
+import me.eugeniomarletti.kotlin.metadata.classKind
+import me.eugeniomarletti.kotlin.metadata.declaresDefaultValue
+import me.eugeniomarletti.kotlin.metadata.isDataClass
+import me.eugeniomarletti.kotlin.metadata.isPrimary
+import me.eugeniomarletti.kotlin.metadata.jvm.getJvmConstructorSignature
+import me.eugeniomarletti.kotlin.metadata.kotlinMetadata
+import me.eugeniomarletti.kotlin.metadata.visibility
+import me.eugeniomarletti.kotlin.processing.KotlinAbstractProcessor
+import org.jetbrains.kotlin.serialization.ProtoBuf
+import org.jetbrains.kotlin.serialization.ProtoBuf.ValueParameter
+import java.io.File
+import javax.annotation.processing.ProcessingEnvironment
+import javax.annotation.processing.Processor
+import javax.annotation.processing.RoundEnvironment
+import javax.lang.model.SourceVersion
+import javax.lang.model.element.AnnotationMirror
+import javax.lang.model.element.Element
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+import javax.lang.model.element.VariableElement
+import javax.tools.Diagnostic.Kind.ERROR
+
+/**
+ * An annotation processor that reads Kotlin data classes and generates Moshi JsonAdapters for them.
+ * This generates Kotlin code, and understands basic Kotlin language features like default values
+ * and companion objects.
+ *
+ * The generated class will match the visibility of the given data class (i.e. if it's internal, the
+ * adapter will also be internal).
+ *
+ * If you define a companion object, a jsonAdapter() extension function will be generated onto it.
+ * If you don't want this though, you can use the runtime [JsonClass] factory implementation.
+ */
+@AutoService(Processor::class)
+class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils {
+
+  companion object {
+    /**
+     * This annotation processing argument can be specified to have a `@Generated` annotation
+     * included in the generated code. It is not encouraged unless you need it for static analysis
+     * reasons and not enabled by default.
+     *
+     * Note that this can only be one of the following values:
+     *   * `"javax.annotation.processing.Generated"` (JRE 9+)
+     *   * `"javax.annotation.Generated"` (JRE <9)
+     */
+    const val OPTION_GENERATED = "moshi.generated"
+    private val POSSIBLE_GENERATED_NAMES = setOf(
+        "javax.annotation.processing.Generated",
+        "javax.annotation.Generated"
+    )
+  }
+
+  private val annotation = JsonClass::class.java
+  private var generatedType: TypeElement? = null
+
+  override fun getSupportedAnnotationTypes() = setOf(annotation.canonicalName)
+
+  override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latest()
+
+  override fun getSupportedOptions() = setOf(OPTION_GENERATED)
+
+  override fun init(processingEnv: ProcessingEnvironment) {
+    super.init(processingEnv)
+    generatedType = processingEnv.options[OPTION_GENERATED]?.let {
+      if (it !in POSSIBLE_GENERATED_NAMES) {
+        throw IllegalArgumentException(
+            "Invalid option value for $OPTION_GENERATED. Found $it, allowable values are $POSSIBLE_GENERATED_NAMES.")
+      }
+      processingEnv.elementUtils.getTypeElement(it)
+    }
+  }
+
+  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
+    for (type in roundEnv.getElementsAnnotatedWith(annotation)) {
+      val jsonClass = type.getAnnotation(annotation)
+      if (jsonClass.generateAdapter) {
+        val adapterGenerator = processElement(type) ?: continue
+        adapterGenerator.generateAndWrite(generatedType)
+      }
+    }
+
+    return true
+  }
+
+  private fun processElement(element: Element): AdapterGenerator? {
+    val metadata = element.kotlinMetadata
+
+    if (metadata !is KotlinClassMetadata) {
+      errorMustBeKotlinClass(element)
+      return null
+    }
+
+    val classData = metadata.data
+    val (nameResolver, classProto) = classData
+
+    if (classProto.classKind != ProtoBuf.Class.Kind.CLASS) {
+      errorMustBeKotlinClass(element)
+      return null
+    }
+
+    val typeName = element.asType().asTypeName()
+    val className = when (typeName) {
+      is ClassName -> typeName
+      is ParameterizedTypeName -> typeName.rawType
+      else -> throw IllegalStateException("unexpected TypeName: ${typeName::class}")
+    }
+
+    val hasCompanionObject = classProto.hasCompanionObjectName()
+    // todo allow custom constructor
+    val protoConstructor = classProto.constructorList
+        .single { it.isPrimary }
+    val constructorJvmSignature = protoConstructor.getJvmConstructorSignature(nameResolver,
+        classProto.typeTable)
+    val constructor = classProto.fqName
+        .let(nameResolver::getString)
+        .replace('/', '.')
+        .let(elementUtils::getTypeElement)
+        .enclosedElements
+        .mapNotNull {
+          it.takeIf { it.kind == ElementKind.CONSTRUCTOR }?.let { it as ExecutableElement }
+        }
+        .first()
+    // TODO Temporary until jvm method signature matching is better
+    //  .single { it.jvmMethodSignature == constructorJvmSignature }
+    val parameters: Map<String, ValueParameter> = protoConstructor.valueParameterList.associateBy {
+      nameResolver.getString(it.name)
+    }
+
+    val properties = classData.classProto.propertyList.associateBy {
+      nameResolver.getString(it.name)
+    }
+
+    val propertyGenerators = mutableListOf<PropertyGenerator>()
+    for (enclosedElement in element.enclosedElements) {
+      if (enclosedElement !is VariableElement) continue
+
+      val name = enclosedElement.simpleName.toString()
+      val property = properties[name] ?: continue
+      val parameter = parameters[name]
+
+      val parameterElement = if (parameter != null) {
+        val parameterIndex = protoConstructor.valueParameterList.indexOf(parameter)
+        constructor.parameters[parameterIndex]
+      } else {
+        null
+      }
+
+      if (property.visibility != ProtoBuf.Visibility.INTERNAL
+          && property.visibility != ProtoBuf.Visibility.PROTECTED
+          && property.visibility != ProtoBuf.Visibility.PUBLIC) {
+        messager.printMessage(ERROR, "property $name is not visible", enclosedElement)
+        return null
+      }
+
+      propertyGenerators += PropertyGenerator(
+          name,
+          serializedName(name, enclosedElement, parameterElement),
+          parameter != null,
+          parameter?.declaresDefaultValue ?: true,
+          property.returnType.nullable,
+          property.returnType.asTypeName(nameResolver, classProto::getTypeParameter),
+          property.returnType.asTypeName(nameResolver, classProto::getTypeParameter, true),
+          jsonQualifiers(enclosedElement, parameterElement))
+    }
+
+    // Sort properties so that those with constructor parameters come first.
+    propertyGenerators.sortBy { if (it.hasConstructorParameter) -1 else 1 }
+
+    val genericTypeNames = classProto.typeParameterList
+        .map {
+          val variance = it.variance.asKModifier().let {
+            // We don't redeclare out variance here
+            if (it == OUT) {
+              null
+            } else {
+              it
+            }
+          }
+          TypeVariableName(
+              name = nameResolver.getString(it.name),
+              bounds = *(it.upperBoundList
+                  .map { it.asTypeName(nameResolver, classProto::getTypeParameter) }
+                  .toTypedArray()),
+              variance = variance)
+              .reified(it.reified)
+        }.let {
+          if (it.isEmpty()) {
+            null
+          } else {
+            it
+          }
+        }
+
+    return AdapterGenerator(
+        className,
+        propertyList = propertyGenerators,
+        originalElement = element,
+        hasCompanionObject = hasCompanionObject,
+        visibility = classProto.visibility!!,
+        genericTypeNames = genericTypeNames,
+        elements = elementUtils,
+        isDataClass = classProto.isDataClass)
+  }
+
+  /** Returns the JsonQualifiers on the field and parameter of a property. */
+  private fun jsonQualifiers(
+    field: VariableElement,
+    parameter: VariableElement?
+  ): Set<AnnotationMirror> {
+    val fieldJsonQualifiers = AnnotationMirrors.getAnnotatedAnnotations(
+        field, JsonQualifier::class.java)
+
+    val parameterJsonQualifiers: Set<AnnotationMirror> = if (parameter != null) {
+      AnnotationMirrors.getAnnotatedAnnotations(parameter, JsonQualifier::class.java)
+    } else {
+      setOf()
+    }
+
+    // TODO(jwilson): union the qualifiers somehow?
+    if (fieldJsonQualifiers.isNotEmpty()) {
+      return fieldJsonQualifiers
+    } else {
+      return parameterJsonQualifiers
+    }
+  }
+
+  /** Returns the @Json name of a property, or `propertyName` if none is provided. */
+  private fun serializedName(
+    propertyName: String,
+    field: VariableElement,
+    parameter: VariableElement?
+  ): String {
+    val fieldAnnotation = field.getAnnotation(Json::class.java)
+    if (fieldAnnotation != null) return fieldAnnotation.name
+
+    val parameterAnnotation = parameter?.getAnnotation(Json::class.java)
+    if (parameterAnnotation != null) return parameterAnnotation.name
+
+    return propertyName
+  }
+
+  private fun errorMustBeKotlinClass(element: Element) {
+    messager.printMessage(ERROR,
+        "@${JsonClass::class.java.simpleName} can't be applied to $element: must be a Kotlin class",
+        element)
+  }
+
+  private fun AdapterGenerator.generateAndWrite(generatedOption: TypeElement?) {
+    val fileSpec = generateFile(generatedOption)
+    val adapterName = fileSpec.members.filterIsInstance<TypeSpec>().first().name!!
+    val outputDir = generatedDir ?: mavenGeneratedDir(adapterName)
+    fileSpec.writeTo(outputDir)
+  }
+
+  private fun mavenGeneratedDir(adapterName: String): File {
+    // Hack since the maven plugin doesn't supply `kapt.kotlin.generated` option
+    // Bug filed at https://youtrack.jetbrains.com/issue/KT-22783
+    val file = filer.createSourceFile(adapterName).toUri().let(::File)
+    return file.parentFile.also { file.delete() }
+  }
+}
+
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/MoshiKotlinCodeGenProcessor.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/MoshiKotlinCodeGenProcessor.kt
deleted file mode 100644
index 3b280deb..00000000
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/MoshiKotlinCodeGenProcessor.kt
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi
-
-import com.google.auto.common.AnnotationMirrors
-import com.google.auto.service.AutoService
-import com.squareup.kotlinpoet.KModifier.OUT
-import com.squareup.kotlinpoet.TypeSpec
-import com.squareup.kotlinpoet.TypeVariableName
-import me.eugeniomarletti.kotlin.metadata.KotlinClassMetadata
-import me.eugeniomarletti.kotlin.metadata.KotlinMetadataUtils
-import me.eugeniomarletti.kotlin.metadata.declaresDefaultValue
-import me.eugeniomarletti.kotlin.metadata.extractFullName
-import me.eugeniomarletti.kotlin.metadata.isDataClass
-import me.eugeniomarletti.kotlin.metadata.isPrimary
-import me.eugeniomarletti.kotlin.metadata.jvm.getJvmConstructorSignature
-import me.eugeniomarletti.kotlin.metadata.kotlinMetadata
-import me.eugeniomarletti.kotlin.metadata.visibility
-import me.eugeniomarletti.kotlin.processing.KotlinAbstractProcessor
-import org.jetbrains.kotlin.serialization.ProtoBuf
-import java.io.File
-import javax.annotation.processing.Processor
-import javax.annotation.processing.RoundEnvironment
-import javax.lang.model.SourceVersion
-import javax.lang.model.element.Element
-import javax.lang.model.element.ElementKind
-import javax.lang.model.element.ExecutableElement
-import javax.lang.model.element.TypeElement
-import javax.tools.Diagnostic.Kind.ERROR
-
-/**
- * An annotation processor that reads Kotlin data classes and generates Moshi JsonAdapters for them.
- * This generates Kotlin code, and understands basic Kotlin language features like default values
- * and companion objects.
- *
- * The generated class will match the visibility of the given data class (i.e. if it's internal, the
- * adapter will also be internal).
- *
- * If you define a companion object, a jsonAdapter() extension function will be generated onto it.
- * If you don't want this though, you can use the runtime [MoshiSerializable] factory implementation.
- */
-@AutoService(Processor::class)
-class MoshiKotlinCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils {
-
-  private val annotationName = MoshiSerializable::class.java.canonicalName
-
-  override fun getSupportedAnnotationTypes() = setOf(annotationName)
-
-  override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latest()
-
-  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
-    val annotationElement = elementUtils.getTypeElement(annotationName)
-    roundEnv.getElementsAnnotatedWith(annotationElement)
-        .asSequence()
-        .mapNotNull { processElement(it) }
-        .forEach { it.generateAndWrite() }
-
-    return true
-  }
-
-  private fun processElement(element: Element): AdapterGenerator? {
-    val metadata = element.kotlinMetadata
-
-    if (metadata !is KotlinClassMetadata) {
-      errorMustBeDataClass(element)
-      return null
-    }
-
-    val classData = metadata.data
-    val (nameResolver, classProto) = classData
-
-    fun ProtoBuf.Type.extractFullName() = extractFullName(classData)
-
-    if (!classProto.isDataClass) {
-      errorMustBeDataClass(element)
-      return null
-    }
-
-    val fqClassName = nameResolver.getString(classProto.fqName).replace('/', '.')
-
-    val packageName = nameResolver.getString(classProto.fqName).substringBeforeLast('/').replace(
-        '/', '.')
-
-    val hasCompanionObject = classProto.hasCompanionObjectName()
-    // todo allow custom constructor
-    val protoConstructor = classProto.constructorList
-        .single { it.isPrimary }
-    val constructorJvmSignature = protoConstructor.getJvmConstructorSignature(nameResolver,
-        classProto.typeTable)
-    val constructor = classProto.fqName
-        .let(nameResolver::getString)
-        .replace('/', '.')
-        .let(elementUtils::getTypeElement)
-        .enclosedElements
-        .mapNotNull {
-          it.takeIf { it.kind == ElementKind.CONSTRUCTOR }?.let { it as ExecutableElement }
-        }
-        .first()
-    // TODO Temporary until jvm method signature matching is better
-    //  .single { it.jvmMethodSignature == constructorJvmSignature }
-    val parameters = protoConstructor
-        .valueParameterList
-        .mapIndexed { index, valueParameter ->
-          val paramName = nameResolver.getString(valueParameter.name)
-
-          val nullable = valueParameter.type.nullable
-          val paramFqcn = valueParameter.type.extractFullName()
-              .replace("`", "")
-              .removeSuffix("?")
-
-          val actualElement = constructor.parameters[index]
-
-          val serializedName = actualElement.getAnnotation(Json::class.java)?.name
-              ?: paramName
-
-          val jsonQualifiers = AnnotationMirrors.getAnnotatedAnnotations(actualElement,
-              JsonQualifier::class.java)
-
-          PropertyGenerator(
-              name = paramName,
-              serializedName = serializedName,
-              hasDefault = valueParameter.declaresDefaultValue,
-              nullable = nullable,
-              typeName = valueParameter.type.asTypeName(nameResolver, classProto::getTypeParameter),
-              unaliasedName = valueParameter.type.asTypeName(nameResolver,
-                  classProto::getTypeParameter, true),
-              jsonQualifiers = jsonQualifiers)
-        }
-
-    val genericTypeNames = classProto.typeParameterList
-        .map {
-          val variance = it.variance.asKModifier().let {
-            // We don't redeclare out variance here
-            if (it == OUT) {
-              null
-            } else {
-              it
-            }
-          }
-          TypeVariableName(
-              name = nameResolver.getString(it.name),
-              bounds = *(it.upperBoundList
-                  .map { it.asTypeName(nameResolver, classProto::getTypeParameter) }
-                  .toTypedArray()),
-              variance = variance)
-              .reified(it.reified)
-        }.let {
-          if (it.isEmpty()) {
-            null
-          } else {
-            it
-          }
-        }
-
-    return AdapterGenerator(
-        fqClassName = fqClassName,
-        packageName = packageName,
-        propertyList = parameters,
-        originalElement = element,
-        hasCompanionObject = hasCompanionObject,
-        visibility = classProto.visibility!!,
-        genericTypeNames = genericTypeNames,
-        elements = elementUtils)
-  }
-
-  private fun errorMustBeDataClass(element: Element) {
-    messager.printMessage(ERROR,
-        "@${MoshiSerializable::class.java.simpleName} can't be applied to $element: must be a Kotlin data class",
-        element)
-  }
-
-  private fun AdapterGenerator.generateAndWrite() {
-    val fileSpec = generateFile()
-    val adapterName = fileSpec.members.filterIsInstance<TypeSpec>().first().name!!
-    val outputDir = generatedDir ?: mavenGeneratedDir(adapterName)
-    fileSpec.writeTo(outputDir)
-  }
-
-  private fun mavenGeneratedDir(adapterName: String): File {
-    // Hack since the maven plugin doesn't supply `kapt.kotlin.generated` option
-    // Bug filed at https://youtrack.jetbrains.com/issue/KT-22783
-    val file = filer.createSourceFile(adapterName).toUri().let(::File)
-    return file.parentFile.also { file.delete() }
-  }
-}
-
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt
index 3d8319ca..68b61d77 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt
@@ -32,6 +32,7 @@ import javax.lang.model.element.AnnotationMirror
 internal class PropertyGenerator(
   val name: String,
   val serializedName: String,
+  val hasConstructorParameter: Boolean,
   val hasDefault: Boolean,
   val nullable: Boolean,
   val typeName: TypeName,
diff --git a/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/CompilerTest.kt b/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/CompilerTest.kt
new file mode 100644
index 00000000..6a0ac2c6
--- /dev/null
+++ b/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/CompilerTest.kt
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi
+
+import org.assertj.core.api.Assertions.assertThat
+import org.jetbrains.kotlin.cli.common.ExitCode
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import javax.annotation.processing.Processor
+
+/** Execute kotlinc to confirm that either files are generated or errors are printed. */
+class CompilerTest {
+  @Rule @JvmField var temporaryFolder: TemporaryFolder = TemporaryFolder()
+
+  @Test
+  fun test() {
+    val call = KotlinCompilerCall(temporaryFolder.root)
+    call.inheritClasspath = true
+    call.addService(Processor::class, JsonClassCodeGenProcessor::class)
+    call.addKt("source.kt", """
+        |import com.squareup.moshi.JsonClass
+        |
+        |@JsonClass(generateAdapter = true)
+        |class PrivateConstructorParameter(private var a: Int)
+        |""".trimMargin())
+
+    val result = call.execute()
+    assertThat(result.exitCode).isEqualTo(ExitCode.COMPILATION_ERROR)
+    assertThat(result.systemErr).contains("property a is not visible")
+  }
+}
\ No newline at end of file
diff --git a/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/KotlinCompilerCall.kt b/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/KotlinCompilerCall.kt
new file mode 100644
index 00000000..3abb126d
--- /dev/null
+++ b/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/KotlinCompilerCall.kt
@@ -0,0 +1,169 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi
+
+import com.google.common.collect.LinkedHashMultimap
+import okio.Buffer
+import okio.Okio
+import org.jetbrains.kotlin.cli.common.CLITool
+import org.jetbrains.kotlin.cli.jvm.K2JVMCompiler
+import java.io.File
+import java.io.FileOutputStream
+import java.io.PrintStream
+import java.net.URLClassLoader
+import java.net.URLDecoder
+import java.util.zip.ZipEntry
+import java.util.zip.ZipOutputStream
+import kotlin.reflect.KClass
+
+/** Prepares an invocation of the Kotlin compiler. */
+class KotlinCompilerCall(var scratchDir: File) {
+  val sourcesDir = File(scratchDir, "sources")
+  val classesDir = File(scratchDir, "classes")
+  val servicesJar = File(scratchDir, "services.jar")
+
+  var inheritClasspath = false
+
+  val args = mutableListOf<String>()
+  val classpath = mutableListOf<String>()
+  val services = LinkedHashMultimap.create<KClass<*>, KClass<*>>()
+
+  /** Adds a source file to be compiled. */
+  fun addKt(path: String, source: String) {
+    val sourceFile = File(sourcesDir, path)
+    sourceFile.parentFile.mkdirs()
+    Okio.buffer(Okio.sink(sourceFile)).use {
+      it.writeUtf8(source)
+    }
+  }
+
+  /** Adds a service like an annotation processor to make available to the compiler. */
+  fun addService(serviceClass: KClass<*>, implementation: KClass<*>) {
+    services.put(serviceClass, implementation)
+  }
+
+  fun execute(): KotlinCompilerResult {
+    val fullArgs = mutableListOf<String>()
+    fullArgs.addAll(args)
+
+    fullArgs.add("-d")
+    fullArgs.add(classesDir.toString())
+
+    val fullClasspath = fullClasspath()
+    if (fullClasspath.isNotEmpty()) {
+      fullArgs.add("-classpath")
+      fullArgs.add(fullClasspath.joinToString(separator = ":"))
+    }
+
+    for (source in sourcesDir.listFiles()) {
+      fullArgs.add(source.toString())
+    }
+
+    fullArgs.addAll(annotationProcessorArgs())
+
+    val systemErrBuffer = Buffer()
+    val oldSystemErr = System.err
+    System.setErr(PrintStream(systemErrBuffer.outputStream()))
+    try {
+      val exitCode = CLITool.doMainNoExit(K2JVMCompiler(), fullArgs.toTypedArray())
+      val systemErr = systemErrBuffer.readUtf8()
+      return KotlinCompilerResult(systemErr, exitCode)
+    } finally {
+      System.setErr(oldSystemErr)
+    }
+  }
+
+  /** Returns arguments necessary to enable and configure kapt3. */
+  private fun annotationProcessorArgs(): List<String> {
+    val kaptSourceDir = File(scratchDir, "kapt/sources")
+    val kaptStubsDir = File(scratchDir, "kapt/stubs")
+
+    return listOf(
+        "-Xplugin=${kapt3Jar()}",
+        "-P", "plugin:org.jetbrains.kotlin.kapt3:sources=$kaptSourceDir",
+        "-P", "plugin:org.jetbrains.kotlin.kapt3:classes=$classesDir",
+        "-P", "plugin:org.jetbrains.kotlin.kapt3:stubs=$kaptStubsDir",
+        "-P", "plugin:org.jetbrains.kotlin.kapt3:apclasspath=$servicesJar",
+        "-P", "plugin:org.jetbrains.kotlin.kapt3:correctErrorTypes=true"
+    )
+  }
+
+  /** Returns the classpath to use when compiling code. */
+  private fun fullClasspath(): List<String> {
+    val result = mutableListOf<String>()
+    result.addAll(classpath)
+
+    // Copy over the classpath of the running application.
+    if (inheritClasspath) {
+      for (classpathFile in classpathFiles()) {
+        result.add(classpathFile.toString())
+      }
+    }
+
+    if (!services.isEmpty) {
+      writeServicesJar()
+      result.add(servicesJar.toString())
+    }
+
+    return result.toList()
+  }
+
+  /**
+   * Generate a .jar file that holds ServiceManager registrations. Necessary because AutoService's
+   * results might not be visible to this test.
+   */
+  private fun writeServicesJar() {
+    ZipOutputStream(FileOutputStream(servicesJar)).use { zipOutputStream ->
+      for (entry in services.asMap()) {
+        zipOutputStream.putNextEntry(
+            ZipEntry("META-INF/services/${entry.key.qualifiedName}"))
+        val serviceFile = Okio.buffer(Okio.sink(zipOutputStream))
+        for (implementation in entry.value) {
+          serviceFile.writeUtf8(implementation.qualifiedName)
+          serviceFile.writeUtf8("\n")
+        }
+        serviceFile.emit() // Don't close the entry; that closes the file.
+        zipOutputStream.closeEntry()
+      }
+    }
+  }
+
+  /** Returns the files on the host process' classpath. */
+  private fun classpathFiles(): List<File> {
+    val classLoader = CompilerTest::class.java.classLoader
+    if (classLoader !is URLClassLoader) {
+      throw UnsupportedOperationException("unable to extract classpath from $classLoader")
+    }
+
+    val result = mutableListOf<File>()
+    for (url in classLoader.urLs) {
+      if (url.protocol != "file") {
+        throw UnsupportedOperationException("unable to handle classpath element $url")
+      }
+      result.add(File(URLDecoder.decode(url.path, "UTF-8")))
+    }
+    return result.toList()
+  }
+
+  /** Returns the path to the kotlin-annotation-processing .jar file. */
+  private fun kapt3Jar(): File {
+    for (file in classpathFiles()) {
+      if (file.name.startsWith("kotlin-annotation-processing-embeddable")) return file
+    }
+    throw IllegalStateException("no kotlin-annotation-processing-embeddable jar on classpath:\n  " +
+        "${classpathFiles().joinToString(separator = "\n  ")}}")
+  }
+}
\ No newline at end of file
diff --git a/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/KotlinCompilerResult.kt b/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/KotlinCompilerResult.kt
new file mode 100644
index 00000000..27a65a3d
--- /dev/null
+++ b/kotlin-codegen/compiler/src/test/java/com/squareup/moshi/KotlinCompilerResult.kt
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi
+
+import org.jetbrains.kotlin.cli.common.ExitCode
+
+class KotlinCompilerResult(
+  val systemErr: String,
+  var exitCode: ExitCode
+)
\ No newline at end of file
diff --git a/kotlin-codegen/integration-test/pom.xml b/kotlin-codegen/integration-test/pom.xml
index 2ecc4b2d..8b24a4e9 100644
--- a/kotlin-codegen/integration-test/pom.xml
+++ b/kotlin-codegen/integration-test/pom.xml
@@ -18,11 +18,6 @@
       <artifactId>moshi</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi-kotlin-codegen-runtime</artifactId>
-      <version>${project.version}</version>
-    </dependency>
     <dependency>
       <groupId>org.jetbrains.kotlin</groupId>
       <artifactId>kotlin-stdlib</artifactId>
@@ -57,7 +52,6 @@
             <configuration>
               <sourceDirs>
                 <sourceDir>src/main/kotlin</sourceDir>
-                <sourceDir>src/main/java</sourceDir>
               </sourceDirs>
               <annotationProcessorPaths>
                 <annotationProcessorPath>
diff --git a/kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/DataClassesTest.kt b/kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/GeneratedAdaptersTest.kt
similarity index 67%
rename from kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/DataClassesTest.kt
rename to kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/GeneratedAdaptersTest.kt
index 7dea3d8f..e077d805 100644
--- a/kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/DataClassesTest.kt
+++ b/kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/GeneratedAdaptersTest.kt
@@ -20,9 +20,9 @@ import org.assertj.core.api.Assertions.fail
 import org.intellij.lang.annotations.Language
 import org.junit.Test
 
-class DataClassesTest {
+class GeneratedAdaptersTest {
 
-  private val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+  private val moshi = Moshi.Builder().build()
 
   @Test
   fun jsonAnnotation() {
@@ -42,7 +42,7 @@ class DataClassesTest {
     assertThat(adapter.toJson(JsonAnnotation("baz"))).isEqualTo(expectedJson)
   }
 
-  @MoshiSerializable
+  @JsonClass(generateAdapter = true)
   data class JsonAnnotation(@Json(name = "foo") val bar: String)
 
   @Test
@@ -79,7 +79,7 @@ class DataClassesTest {
     assertThat(adapter.toJson(instance2)).isEqualTo(json2)
   }
 
-  @MoshiSerializable
+  @JsonClass(generateAdapter = true)
   data class DefaultValues(val foo: String,
       val bar: String = "",
       val nullableBar: String? = null,
@@ -97,7 +97,7 @@ class DataClassesTest {
     assertThat(adapter.toJson(instance)).isEqualTo(json)
   }
 
-  @MoshiSerializable
+  @JsonClass(generateAdapter = true)
   data class NullableArray(val data: Array<String?>)
 
   @Test
@@ -112,7 +112,7 @@ class DataClassesTest {
     assertThat(adapter.toJson(instance)).isEqualTo(json)
   }
 
-  @MoshiSerializable
+  @JsonClass(generateAdapter = true)
   data class PrimitiveArray(val ints: IntArray)
 
   @Test
@@ -136,7 +136,7 @@ class DataClassesTest {
     }
   }
 
-  @MoshiSerializable
+  @JsonClass(generateAdapter = true)
   data class NullabeTypes(
       val foo: String,
       val nullableString: String?
@@ -160,7 +160,7 @@ class DataClassesTest {
     assertThat(newCollections).isEqualTo(specialCollections)
   }
 
-  @MoshiSerializable
+  @JsonClass(generateAdapter = true)
   data class SpecialCollections(
       val mutableList: MutableList<String>,
       val mutableSet: MutableSet<String>,
@@ -194,7 +194,7 @@ class DataClassesTest {
     assertThat(newMutableProperties).isEqualTo(mutableProperties)
   }
 
-  @MoshiSerializable
+  @JsonClass(generateAdapter = true)
   data class MutableProperties(
       val immutableProperty: String,
       var mutableProperty: String,
@@ -238,10 +238,125 @@ class DataClassesTest {
     val nullSerializedNullableTypeParams = adapter.fromJson(nullSerializedJson)
     assertThat(nullSerializedNullableTypeParams).isEqualTo(nullableTypeParams)
   }
+
+  @Test
+  fun doNotGenerateAdapter() {
+    try {
+      StandardJsonAdapters.generatedAdapter(
+          moshi, DoNotGenerateAdapter::class.java, DoNotGenerateAdapter::class.java)
+      fail("found a generated adapter for a type that shouldn't have one")
+    } catch (e: RuntimeException) {
+      assertThat(e).hasCauseInstanceOf(ClassNotFoundException::class.java)
+    }
+  }
+
+  @JsonClass(generateAdapter = false)
+  data class DoNotGenerateAdapter(val foo: String)
+
+  @Test fun constructorParameters() {
+    val moshi = Moshi.Builder().build()
+    val jsonAdapter = moshi.adapter(ConstructorParameters::class.java)
+
+    val encoded = ConstructorParameters(3, 5)
+    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
+
+    val decoded = jsonAdapter.fromJson("""{"a":4,"b":6}""")!!
+    assertThat(decoded.a).isEqualTo(4)
+    assertThat(decoded.b).isEqualTo(6)
+  }
+
+  @JsonClass(generateAdapter = true)
+  class ConstructorParameters(var a: Int, var b: Int)
+
+  @Test fun properties() {
+    val moshi = Moshi.Builder().build()
+    val jsonAdapter = moshi.adapter(Properties::class.java)
+
+    val encoded = Properties()
+    encoded.a = 3
+    encoded.b = 5
+    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
+
+    val decoded = jsonAdapter.fromJson("""{"a":3,"b":5}""")!!
+    assertThat(decoded.a).isEqualTo(3)
+    assertThat(decoded.b).isEqualTo(5)
+  }
+
+  @JsonClass(generateAdapter = true)
+  class Properties {
+    var a: Int = -1
+    var b: Int = -1
+  }
+
+  @Test fun constructorParametersAndProperties() {
+    val moshi = Moshi.Builder().build()
+    val jsonAdapter = moshi.adapter(ConstructorParametersAndProperties::class.java)
+
+    val encoded = ConstructorParametersAndProperties(3)
+    encoded.b = 5
+    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
+
+    val decoded = jsonAdapter.fromJson("""{"a":4,"b":6}""")!!
+    assertThat(decoded.a).isEqualTo(4)
+    assertThat(decoded.b).isEqualTo(6)
+  }
+
+  @JsonClass(generateAdapter = true)
+  class ConstructorParametersAndProperties(var a: Int) {
+    var b: Int = -1
+  }
+
+  @Test fun immutableConstructorParameters() {
+    val moshi = Moshi.Builder().build()
+    val jsonAdapter = moshi.adapter(ImmutableConstructorParameters::class.java)
+
+    val encoded = ImmutableConstructorParameters(3, 5)
+    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
+
+    val decoded = jsonAdapter.fromJson("""{"a":4,"b":6}""")!!
+    assertThat(decoded.a).isEqualTo(4)
+    assertThat(decoded.b).isEqualTo(6)
+  }
+
+  @JsonClass(generateAdapter = true)
+  class ImmutableConstructorParameters(val a: Int, val b: Int)
+
+  @Test fun immutableProperties() {
+    val moshi = Moshi.Builder().build()
+    val jsonAdapter = moshi.adapter(ImmutableProperties::class.java)
+
+    val encoded = ImmutableProperties(3, 5)
+    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
+
+    val decoded = jsonAdapter.fromJson("""{"a":3,"b":5}""")!!
+    assertThat(decoded.a).isEqualTo(3)
+    assertThat(decoded.b).isEqualTo(5)
+  }
+
+  @JsonClass(generateAdapter = true)
+  class ImmutableProperties(a: Int, b: Int) {
+    val a = a
+    val b = b
+  }
+
+  @Test fun constructorDefaults() {
+    val moshi = Moshi.Builder().build()
+    val jsonAdapter = moshi.adapter(ConstructorDefaultValues::class.java)
+
+    val encoded = ConstructorDefaultValues(3, 5)
+    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
+
+    val decoded = jsonAdapter.fromJson("""{"b":6}""")!!
+    assertThat(decoded.a).isEqualTo(-1)
+    assertThat(decoded.b).isEqualTo(6)
+  }
+
+  @JsonClass(generateAdapter = true)
+  class ConstructorDefaultValues(var a: Int = -1, var b: Int = -2)
 }
 
 // Has to be outside to avoid Types seeing an owning class
-@MoshiSerializable
+@JsonClass(generateAdapter = true)
 data class NullableTypeParams<T>(
     val nullableList: List<String?>,
     val nullableSet: Set<String?>,
@@ -255,7 +370,7 @@ typealias TypeAliasName = String
  * This is here mostly just to ensure it still compiles. Covers variance, @Json, default values,
  * nullability, primitive arrays, and some wacky generics.
  */
-@MoshiSerializable
+@JsonClass(generateAdapter = true)
 data class SmokeTestType(
     @Json(name = "first_name") val firstName: String,
     @Json(name = "last_name") val lastName: String,
diff --git a/kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/KotlinCodeGenTest.kt b/kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/KotlinCodeGenTest.kt
index 6b12614d..151f124b 100644
--- a/kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/KotlinCodeGenTest.kt
+++ b/kotlin-codegen/integration-test/src/test/kotlin/com/squareup/moshi/KotlinCodeGenTest.kt
@@ -25,104 +25,8 @@ import java.util.SimpleTimeZone
 import kotlin.annotation.AnnotationRetention.RUNTIME
 
 class KotlinCodeGenTest {
-  @Ignore @Test fun constructorParameters() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
-    val jsonAdapter = moshi.adapter(ConstructorParameters::class.java)
-
-    val encoded = ConstructorParameters(3, 5)
-    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
-
-    val decoded = jsonAdapter.fromJson("""{"a":4,"b":6}""")!!
-    assertThat(decoded.a).isEqualTo(4)
-    assertThat(decoded.b).isEqualTo(6)
-  }
-
-  class ConstructorParameters(var a: Int, var b: Int)
-
-  @Ignore @Test fun properties() {
-
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
-    val jsonAdapter = moshi.adapter(Properties::class.java)
-
-    val encoded = Properties()
-    encoded.a = 3
-    encoded.b = 5
-    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
-
-    val decoded = jsonAdapter.fromJson("""{"a":3,"b":5}""")!!
-    assertThat(decoded.a).isEqualTo(3)
-    assertThat(decoded.b).isEqualTo(5)
-  }
-
-  class Properties {
-    var a: Int = -1
-    var b: Int = -1
-  }
-
-  @Ignore @Test fun constructorParametersAndProperties() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
-    val jsonAdapter = moshi.adapter(ConstructorParametersAndProperties::class.java)
-
-    val encoded = ConstructorParametersAndProperties(3)
-    encoded.b = 5
-    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
-
-    val decoded = jsonAdapter.fromJson("""{"a":4,"b":6}""")!!
-    assertThat(decoded.a).isEqualTo(4)
-    assertThat(decoded.b).isEqualTo(6)
-  }
-
-  class ConstructorParametersAndProperties(var a: Int) {
-    var b: Int = -1
-  }
-
-  @Ignore @Test fun immutableConstructorParameters() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
-    val jsonAdapter = moshi.adapter(ImmutableConstructorParameters::class.java)
-
-    val encoded = ImmutableConstructorParameters(3, 5)
-    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
-
-    val decoded = jsonAdapter.fromJson("""{"a":4,"b":6}""")!!
-    assertThat(decoded.a).isEqualTo(4)
-    assertThat(decoded.b).isEqualTo(6)
-  }
-
-  class ImmutableConstructorParameters(val a: Int, val b: Int)
-
-  @Ignore @Test fun immutableProperties() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
-    val jsonAdapter = moshi.adapter(ImmutableProperties::class.java)
-
-    val encoded = ImmutableProperties(3, 5)
-    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
-
-    val decoded = jsonAdapter.fromJson("""{"a":3,"b":5}""")!!
-    assertThat(decoded.a).isEqualTo(3)
-    assertThat(decoded.b).isEqualTo(5)
-  }
-
-  class ImmutableProperties(a: Int, b: Int) {
-    val a = a
-    val b = b
-  }
-
-  @Ignore @Test fun constructorDefaults() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
-    val jsonAdapter = moshi.adapter(ConstructorDefaultValues::class.java)
-
-    val encoded = ConstructorDefaultValues(3, 5)
-    assertThat(jsonAdapter.toJson(encoded)).isEqualTo("""{"a":3,"b":5}""")
-
-    val decoded = jsonAdapter.fromJson("""{"b":6}""")!!
-    assertThat(decoded.a).isEqualTo(-1)
-    assertThat(decoded.b).isEqualTo(6)
-  }
-
-  class ConstructorDefaultValues(var a: Int = -1, var b: Int = -2)
-
   @Ignore @Test fun requiredValueAbsent() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(RequiredValueAbsent::class.java)
 
     try {
@@ -136,7 +40,7 @@ class KotlinCodeGenTest {
   class RequiredValueAbsent(var a: Int = 3, var b: Int)
 
   @Ignore @Test fun nonNullConstructorParameterCalledWithNullFailsWithJsonDataException() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(HasNonNullConstructorParameter::class.java)
 
     try {
@@ -150,7 +54,7 @@ class KotlinCodeGenTest {
   class HasNonNullConstructorParameter(val a: String)
 
   @Ignore @Test fun nonNullPropertySetToNullFailsWithJsonDataException() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(HasNonNullProperty::class.java)
 
     try {
@@ -166,7 +70,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun duplicatedValue() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(DuplicateValue::class.java)
 
     try {
@@ -180,7 +84,7 @@ class KotlinCodeGenTest {
   class DuplicateValue(var a: Int = -1, var b: Int = -2)
 
   @Ignore @Test fun explicitNull() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(ExplicitNull::class.java)
 
     val encoded = ExplicitNull(null, 5)
@@ -195,7 +99,7 @@ class KotlinCodeGenTest {
   class ExplicitNull(var a: Int?, var b: Int?)
 
   @Ignore @Test fun absentNull() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(AbsentNull::class.java)
 
     val encoded = AbsentNull(null, 5)
@@ -210,7 +114,7 @@ class KotlinCodeGenTest {
   class AbsentNull(var a: Int?, var b: Int?)
 
   @Ignore @Test fun repeatedValue() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(RepeatedValue::class.java)
 
     try {
@@ -225,7 +129,6 @@ class KotlinCodeGenTest {
 
   @Ignore @Test fun constructorParameterWithQualifier() {
     val moshi = Moshi.Builder()
-        .add(MoshiSerializableFactory())
         .add(UppercaseJsonAdapter())
         .build()
     val jsonAdapter = moshi.adapter(ConstructorParameterWithQualifier::class.java)
@@ -242,7 +145,6 @@ class KotlinCodeGenTest {
 
   @Ignore @Test fun propertyWithQualifier() {
     val moshi = Moshi.Builder()
-        .add(MoshiSerializableFactory())
         .add(UppercaseJsonAdapter())
         .build()
     val jsonAdapter = moshi.adapter(PropertyWithQualifier::class.java)
@@ -263,7 +165,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun constructorParameterWithJsonName() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(ConstructorParameterWithJsonName::class.java)
 
     val encoded = ConstructorParameterWithJsonName(3, 5)
@@ -277,7 +179,7 @@ class KotlinCodeGenTest {
   class ConstructorParameterWithJsonName(@Json(name = "key a") var a: Int, var b: Int)
 
   @Ignore @Test fun propertyWithJsonName() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(PropertyWithJsonName::class.java)
 
     val encoded = PropertyWithJsonName()
@@ -296,7 +198,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun transientConstructorParameter() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(TransientConstructorParameter::class.java)
 
     val encoded = TransientConstructorParameter(3, 5)
@@ -310,7 +212,7 @@ class KotlinCodeGenTest {
   class TransientConstructorParameter(@Transient var a: Int = -1, var b: Int = -1)
 
   @Ignore @Test fun requiredTransientConstructorParameterFails() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     try {
       moshi.adapter(RequiredTransientConstructorParameter::class.java)
       fail()
@@ -324,7 +226,7 @@ class KotlinCodeGenTest {
   class RequiredTransientConstructorParameter(@Transient var a: Int)
 
   @Ignore @Test fun transientProperty() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(TransientProperty::class.java)
 
     val encoded = TransientProperty()
@@ -343,7 +245,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun supertypeConstructorParameters() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(SubtypeConstructorParameters::class.java)
 
     val encoded = SubtypeConstructorParameters(3, 5)
@@ -359,7 +261,7 @@ class KotlinCodeGenTest {
   class SubtypeConstructorParameters(a: Int, var b: Int) : SupertypeConstructorParameters(a)
 
   @Ignore @Test fun supertypeProperties() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(SubtypeProperties::class.java)
 
     val encoded = SubtypeProperties()
@@ -381,7 +283,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun extendsPlatformClassWithPrivateField() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(ExtendsPlatformClassWithPrivateField::class.java)
 
     val encoded = ExtendsPlatformClassWithPrivateField(3)
@@ -395,7 +297,7 @@ class KotlinCodeGenTest {
   internal class ExtendsPlatformClassWithPrivateField(var a: Int) : SimpleTimeZone(0, "C")
 
   @Ignore @Test fun extendsPlatformClassWithProtectedField() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(ExtendsPlatformClassWithProtectedField::class.java)
 
     val encoded = ExtendsPlatformClassWithProtectedField(3)
@@ -413,7 +315,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun platformTypeThrows() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     try {
       moshi.adapter(Triple::class.java)
       fail()
@@ -424,7 +326,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun privateConstructorParameters() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(PrivateConstructorParameters::class.java)
 
     val encoded = PrivateConstructorParameters(3, 5)
@@ -441,7 +343,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun privateConstructor() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(PrivateConstructor::class.java)
 
     val encoded = PrivateConstructor.newInstance(3, 5)
@@ -461,7 +363,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun privateProperties() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(PrivateProperties::class.java)
 
     val encoded = PrivateProperties()
@@ -492,7 +394,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun unsettablePropertyIgnored() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(UnsettableProperty::class.java)
 
     val encoded = UnsettableProperty()
@@ -510,7 +412,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun getterOnlyNoBackingField() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(GetterOnly::class.java)
 
     val encoded = GetterOnly(3, 5)
@@ -528,7 +430,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun getterAndSetterNoBackingField() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(GetterAndSetter::class.java)
 
     val encoded = GetterAndSetter(3, 5)
@@ -556,7 +458,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun nonPropertyConstructorParameter() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     try {
       moshi.adapter(NonPropertyConstructorParameter::class.java)
       fail()
@@ -570,7 +472,7 @@ class KotlinCodeGenTest {
   class NonPropertyConstructorParameter(a: Int, val b: Int)
 
   @Ignore @Test fun kotlinEnumsAreNotCovered() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val adapter = moshi.adapter(UsingEnum::class.java)
 
     assertThat(adapter.fromJson("""{"e": "A"}""")).isEqualTo(UsingEnum(KotlinEnum.A))
@@ -583,7 +485,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun interfacesNotSupported() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     try {
       moshi.adapter(Interface::class.java)
       fail()
@@ -596,7 +498,7 @@ class KotlinCodeGenTest {
   interface Interface
 
   @Ignore @Test fun abstractClassesNotSupported() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     try {
       moshi.adapter(AbstractClass::class.java)
       fail()
@@ -609,7 +511,7 @@ class KotlinCodeGenTest {
   abstract class AbstractClass(val a: Int)
 
   @Ignore @Test fun innerClassesNotSupported() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     try {
       moshi.adapter(InnerClass::class.java)
       fail()
@@ -623,7 +525,7 @@ class KotlinCodeGenTest {
 
   @Ignore @Test fun localClassesNotSupported() {
     class LocalClass(val a: Int)
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     try {
       moshi.adapter(LocalClass::class.java)
       fail()
@@ -634,7 +536,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun objectDeclarationsNotSupported() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     try {
       moshi.adapter(ObjectDeclaration.javaClass)
       fail()
@@ -652,7 +554,7 @@ class KotlinCodeGenTest {
     val expression = object : Any() {
       var a = 5
     }
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     try {
       moshi.adapter(expression.javaClass)
       fail()
@@ -663,7 +565,7 @@ class KotlinCodeGenTest {
   }
 
   @Ignore @Test fun manyProperties32() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(ManyProperties32::class.java)
 
     val encoded = ManyProperties32(
@@ -703,7 +605,7 @@ class KotlinCodeGenTest {
       var v31: Int, var v32: Int)
 
   @Ignore @Test fun manyProperties33() {
-    val moshi = Moshi.Builder().add(MoshiSerializableFactory()).build()
+    val moshi = Moshi.Builder().build()
     val jsonAdapter = moshi.adapter(ManyProperties33::class.java)
 
     val encoded = ManyProperties33(
diff --git a/kotlin-codegen/runtime/pom.xml b/kotlin-codegen/runtime/pom.xml
deleted file mode 100644
index 08b8e367..00000000
--- a/kotlin-codegen/runtime/pom.xml
+++ /dev/null
@@ -1,82 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
-  <modelVersion>4.0.0</modelVersion>
-
-  <parent>
-    <groupId>com.squareup.moshi</groupId>
-    <artifactId>moshi-parent</artifactId>
-    <version>1.6.0-SNAPSHOT</version>
-    <relativePath>../../pom.xml</relativePath>
-  </parent>
-
-  <artifactId>moshi-kotlin-codegen-runtime</artifactId>
-
-  <dependencies>
-    <dependency>
-      <groupId>com.squareup.moshi</groupId>
-      <artifactId>moshi</artifactId>
-      <version>${project.version}</version>
-    </dependency>
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.assertj</groupId>
-      <artifactId>assertj-core</artifactId>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.jetbrains.kotlin</groupId>
-      <artifactId>kotlin-stdlib</artifactId>
-    </dependency>
-  </dependencies>
-
-  <build>
-    <plugins>
-      <plugin>
-        <groupId>org.jetbrains.kotlin</groupId>
-        <artifactId>kotlin-maven-plugin</artifactId>
-        <version>${kotlin.version}</version>
-        <executions>
-          <execution>
-            <id>compile</id>
-            <phase>compile</phase>
-            <goals>
-              <goal>compile</goal>
-            </goals>
-          </execution>
-          <execution>
-            <id>test-compile</id>
-            <phase>test-compile</phase>
-            <goals>
-              <goal>test-compile</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-compiler-plugin</artifactId>
-        <executions>
-          <execution>
-            <id>compile</id>
-            <phase>compile</phase>
-            <goals>
-              <goal>compile</goal>
-            </goals>
-          </execution>
-          <execution>
-            <id>testCompile</id>
-            <phase>test-compile</phase>
-            <goals>
-              <goal>testCompile</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
-    </plugins>
-  </build>
-</project>
diff --git a/kotlin-codegen/runtime/src/main/java/com/squareup/moshi/MoshiSerializable.kt b/kotlin-codegen/runtime/src/main/java/com/squareup/moshi/MoshiSerializable.kt
deleted file mode 100644
index d6857659..00000000
--- a/kotlin-codegen/runtime/src/main/java/com/squareup/moshi/MoshiSerializable.kt
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi
-
-import java.lang.reflect.InvocationTargetException
-import java.lang.reflect.ParameterizedType
-import java.lang.reflect.Type
-import kotlin.annotation.AnnotationRetention.RUNTIME
-import kotlin.annotation.AnnotationTarget.CLASS
-
-@Retention(RUNTIME)
-@Target(CLASS)
-annotation class MoshiSerializable
-
-class MoshiSerializableFactory : JsonAdapter.Factory {
-
-  override fun create(type: Type, annotations: Set<Annotation>, moshi: Moshi): JsonAdapter<*>? {
-
-    val rawType = Types.getRawType(type)
-    if (!rawType.isAnnotationPresent(MoshiSerializable::class.java)) {
-      return null
-    }
-
-    val clsName = rawType.name.replace("$", "_")
-    val constructor = try {
-      @Suppress("UNCHECKED_CAST")
-      val bindingClass = rawType.classLoader
-          .loadClass(clsName + "JsonAdapter") as Class<out JsonAdapter<*>>
-      if (type is ParameterizedType) {
-        // This is generic, use the two param moshi + type constructor
-        bindingClass.getDeclaredConstructor(Moshi::class.java, Array<Type>::class.java)
-      } else {
-        // The standard single param moshi constructor
-        bindingClass.getDeclaredConstructor(Moshi::class.java)
-      }
-    } catch (e: ClassNotFoundException) {
-      throw RuntimeException("Unable to find generated Moshi adapter class for $clsName", e)
-    } catch (e: NoSuchMethodException) {
-      throw RuntimeException("Unable to find generated Moshi adapter constructor for $clsName", e)
-    }
-
-    try {
-      return when {
-        constructor.parameterTypes.size == 1 -> constructor.newInstance(moshi)
-        type is ParameterizedType -> constructor.newInstance(moshi, type.actualTypeArguments)
-        else -> throw IllegalStateException("Unable to handle type $type")
-      }
-    } catch (e: IllegalAccessException) {
-      throw RuntimeException("Unable to invoke $constructor", e)
-    } catch (e: InstantiationException) {
-      throw RuntimeException("Unable to invoke $constructor", e)
-    } catch (e: InvocationTargetException) {
-      val cause = e.cause
-      if (cause is RuntimeException) {
-        throw cause
-      }
-      if (cause is Error) {
-        throw cause
-      }
-      throw RuntimeException(
-          "Could not create generated JsonAdapter instance for type $rawType", cause)
-    }
-  }
-}
diff --git a/kotlin/src/main/java/com/squareup/moshi/kotlin/KotlinJsonAdapter.kt b/kotlin/src/main/java/com/squareup/moshi/kotlin/KotlinJsonAdapter.kt
index 3f005c9d..3d3b205f 100644
--- a/kotlin/src/main/java/com/squareup/moshi/kotlin/KotlinJsonAdapter.kt
+++ b/kotlin/src/main/java/com/squareup/moshi/kotlin/KotlinJsonAdapter.kt
@@ -225,9 +225,8 @@ class KotlinJsonAdapterFactory : JsonAdapter.Factory {
       }
 
       val name = jsonAnnotation?.name ?: property.name
-      val resolvedPropertyType = Types.resolve(type, rawType, property.returnType.javaType)
       val adapter = moshi.adapter<Any>(
-          resolvedPropertyType, Util.jsonAnnotations(allAnnotations.toTypedArray()))
+          property.returnType.javaType, Util.jsonAnnotations(allAnnotations.toTypedArray()))
 
       bindingsByName[property.name] =
           KotlinJsonAdapter.Binding(name, adapter, property as KProperty1<Any, Any?>, parameter)
diff --git a/kotlin/src/test/java/com/squareup/moshi/kotlin/KotlinJsonAdapterTest.kt b/kotlin/src/test/java/com/squareup/moshi/kotlin/KotlinJsonAdapterTest.kt
index 706cf302..6fc35d26 100644
--- a/kotlin/src/test/java/com/squareup/moshi/kotlin/KotlinJsonAdapterTest.kt
+++ b/kotlin/src/test/java/com/squareup/moshi/kotlin/KotlinJsonAdapterTest.kt
@@ -21,7 +21,6 @@ import com.squareup.moshi.JsonDataException
 import com.squareup.moshi.JsonQualifier
 import com.squareup.moshi.Moshi
 import com.squareup.moshi.ToJson
-import com.squareup.moshi.Types
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Assert.fail
 import org.junit.Test
@@ -764,53 +763,7 @@ class KotlinJsonAdapterTest {
       var v26: Int, var v27: Int, var v28: Int, var v29: Int, var v30: Int,
       var v31: Int, var v32: Int, var v33: Int)
 
-  data class Box<out T>(val data: T)
-
-  @Test fun genericTypes() {
-    val moshi = Moshi.Builder().add(KotlinJsonAdapterFactory()).build()
-    val stringBoxAdapter = moshi.adapter<Box<String>>(
-        Types.newParameterizedTypeWithOwner(KotlinJsonAdapterTest::class.java, Box::class.java,
-            String::class.java))
-    assertThat(stringBoxAdapter.fromJson("""{"data":"hello"}""")).isEqualTo(Box("hello"))
-    assertThat(stringBoxAdapter.toJson(Box("hello"))).isEqualTo("""{"data":"hello"}""")
-  }
-
-  data class NestedGenerics<R, C, out V>(val value: Map<R, Map<C, List<V>>>)
-
-  @Test fun nestedGenericTypes() {
-    val moshi = Moshi.Builder().add(KotlinJsonAdapterFactory()).build()
-    val type = Types.newParameterizedTypeWithOwner(
-        KotlinJsonAdapterTest::class.java,
-        NestedGenerics::class.java,
-        String::class.java,
-        Int::class.javaObjectType,
-        Types.newParameterizedTypeWithOwner(
-            KotlinJsonAdapterTest::class.java,
-            Box::class.java,
-            String::class.java
-        )
-    )
-    val adapter = moshi.adapter<NestedGenerics<String, Int, Box<String>>>(type).indent("  ")
-    val json = """
-      |{
-      |  "value": {
-      |    "hello": {
-      |      "1": [
-      |        {
-      |          "data": " "
-      |        },
-      |        {
-      |          "data": "world!"
-      |        }
-      |      ]
-      |    }
-      |  }
-      |}
-      """.trimMargin()
-    val value = NestedGenerics(mapOf("hello" to mapOf(1 to listOf(Box(" "), Box("world!")))))
-    assertThat(adapter.fromJson(json)).isEqualTo(value)
-    assertThat(adapter.toJson(value)).isEqualTo(json)
-  }
+  // TODO(jwilson): resolve generic types?
 
   @Retention(RUNTIME)
   @JsonQualifier
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonClass.java b/moshi/src/main/java/com/squareup/moshi/JsonClass.java
new file mode 100644
index 00000000..059f41bb
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/JsonClass.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Customizes how a type is encoded as JSON.
+ *
+ * <p>This annotation is currently only permitted on declarations of data classes in Kotlin.
+ */
+@Retention(RUNTIME)
+@Documented
+public @interface JsonClass {
+  boolean generateAdapter();
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index 5a7eb461..5b1be373 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -18,6 +18,9 @@ package com.squareup.moshi;
 import com.squareup.moshi.internal.Util;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.Arrays;
 import java.util.Collection;
@@ -53,6 +56,12 @@ final class StandardJsonAdapters {
       if (type == Object.class) return new ObjectJsonAdapter(moshi).nullSafe();
 
       Class<?> rawType = Types.getRawType(type);
+
+      JsonClass jsonClass = rawType.getAnnotation(JsonClass.class);
+      if (jsonClass != null && jsonClass.generateAdapter()) {
+        return generatedAdapter(moshi, type, rawType);
+      }
+
       if (rawType.isEnum()) {
         //noinspection unchecked
         return new EnumJsonAdapter<>((Class<? extends Enum>) rawType).nullSafe();
@@ -215,6 +224,45 @@ final class StandardJsonAdapters {
     }
   };
 
+  /**
+   * Loads the generated JsonAdapter for classes annotated {@link JsonClass}. This works because it
+   * uses the same naming conventions as {@code JsonClassCodeGenProcessor}.
+   */
+  static JsonAdapter<?> generatedAdapter(Moshi moshi, Type type, Class<?> rawType) {
+    String adapterClassName = rawType.getName().replace("$", "_") + "JsonAdapter";
+    try {
+      @SuppressWarnings("unchecked") // We generate types to match.
+      Class<? extends JsonAdapter<?>> adapterClass = (Class<? extends JsonAdapter<?>>)
+          Class.forName(adapterClassName, true, rawType.getClassLoader());
+      if (type instanceof ParameterizedType) {
+        Constructor<? extends JsonAdapter<?>> constructor
+            = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);
+        constructor.setAccessible(true);
+        return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments());
+      } else {
+        Constructor<? extends JsonAdapter<?>> constructor
+            = adapterClass.getDeclaredConstructor(Moshi.class);
+        constructor.setAccessible(true);
+        return constructor.newInstance(moshi);
+      }
+    } catch (ClassNotFoundException e) {
+      throw new RuntimeException(
+          "Failed to find the generated JsonAdapter class for " + rawType, e);
+    } catch (NoSuchMethodException e) {
+      throw new RuntimeException(
+          "Failed to find the generated JsonAdapter constructor for " + rawType, e);
+    } catch (IllegalAccessException e) {
+      throw new RuntimeException(
+          "Failed to access the generated JsonAdapter for " + rawType, e);
+    } catch (InvocationTargetException e) {
+      throw new RuntimeException(
+          "Failed to construct the generated JsonAdapter for " + rawType, e);
+    } catch (InstantiationException e) {
+      throw new RuntimeException(
+          "Failed to instantiate the generated JsonAdapter for " + rawType, e);
+    }
+  }
+
   static final class EnumJsonAdapter<T extends Enum<T>> extends JsonAdapter<T> {
     private final Class<T> enumType;
     private final String[] nameStrings;
diff --git a/moshi/src/main/java/com/squareup/moshi/Types.java b/moshi/src/main/java/com/squareup/moshi/Types.java
index ae6fdf0f..80459d14 100644
--- a/moshi/src/main/java/com/squareup/moshi/Types.java
+++ b/moshi/src/main/java/com/squareup/moshi/Types.java
@@ -373,8 +373,7 @@ public final class Types {
     return new Type[] { Object.class, Object.class };
   }
 
-  @CheckReturnValue // TODO(eric): Move this to internal Utils.
-  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
     // This implementation is made a little more complicated in an attempt to avoid object-creation.
     while (true) {
       if (toResolve instanceof TypeVariable) {
diff --git a/pom.xml b/pom.xml
index 30b64163..eebd3a4f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -24,18 +24,19 @@
     <module>kotlin</module>
     <module>kotlin-codegen/compiler</module>
     <module>kotlin-codegen/integration-test</module>
-    <module>kotlin-codegen/runtime</module>
   </modules>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <java.version>1.7</java.version>
     <kotlin.version>1.2.21</kotlin.version>
+    <kotlin-metadata.version>1.2.1</kotlin-metadata.version>
 
     <!-- Dependencies -->
     <okio.version>1.13.0</okio.version>
 
     <!-- Test Dependencies -->
+    <compile-testing.version>0.8</compile-testing.version>
     <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
   </properties>
@@ -98,6 +99,26 @@
         <version>${kotlin.version}</version>
         <scope>test</scope>
       </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-compiler-embeddable</artifactId>
+        <version>${kotlin.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-annotation-processing-embeddable</artifactId>
+        <version>${kotlin.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>me.eugeniomarletti</groupId>
+        <artifactId>kotlin-metadata</artifactId>
+        <version>${kotlin-metadata.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.testing.compile</groupId>
+        <artifactId>compile-testing</artifactId>
+        <version>${compile-testing.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
