diff --git a/README.md b/README.md
index 1c6e9423..7268b5e1 100644
--- a/README.md
+++ b/README.md
@@ -498,7 +498,7 @@ Download [the latest JAR][dl] or depend via Maven:
 ```
 or Gradle:
 ```groovy
-implementation 'com.squareup.moshi:moshi:1.5.0'
+compile 'com.squareup.moshi:moshi:1.5.0'
 ```
 and for additional Kotlin support:
 ```xml
@@ -510,7 +510,7 @@ and for additional Kotlin support:
 ```
 or Gradle:
 ```groovy
-implementation 'com.squareup.moshi:moshi-kotlin:1.5.0'
+compile 'com.squareup.moshi:moshi-kotlin:1.5.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/adapters/README.md b/adapters/README.md
index d94849c2..d3808e51 100644
--- a/adapters/README.md
+++ b/adapters/README.md
@@ -25,7 +25,7 @@ Download [the latest JAR][1] or grab via [Maven][2]:
 ```
 or [Gradle][2]:
 ```groovy
-implementation 'com.squareup.moshi:moshi-adapters:latest.version'
+compile 'com.squareup.moshi:moshi-adapters:latest.version'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
diff --git a/kotlin-codegen/compiler/pom.xml b/kotlin-codegen/compiler/pom.xml
index 092d18e5..d6aa8dd4 100644
--- a/kotlin-codegen/compiler/pom.xml
+++ b/kotlin-codegen/compiler/pom.xml
@@ -25,10 +25,20 @@
       <artifactId>moshi</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi-kotlin-codegen-runtime</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>org.jetbrains.kotlin</groupId>
       <artifactId>kotlin-stdlib</artifactId>
     </dependency>
+    <dependency>
+      <groupId>me.eugeniomarletti</groupId>
+      <artifactId>kotlin-metadata</artifactId>
+      <version>1.2.1</version>
+    </dependency>
     <dependency>
       <groupId>com.google.auto</groupId>
       <artifactId>auto-common</artifactId>
@@ -55,32 +65,6 @@
       <artifactId>assertj-core</artifactId>
       <scope>test</scope>
     </dependency>
-
-    <!--
-      The Kotlin compiler must be near the end of the list because its .jar file includes an
-      obsolete version of Guava!
-    -->
-    <dependency>
-      <groupId>org.jetbrains.kotlin</groupId>
-      <artifactId>kotlin-compiler-embeddable</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>org.jetbrains.kotlin</groupId>
-      <artifactId>kotlin-annotation-processing-embeddable</artifactId>
-    </dependency>
-    <dependency>
-      <groupId>me.eugeniomarletti</groupId>
-      <artifactId>kotlin-metadata</artifactId>
-    </dependency>
-    <!--
-      Though we don't use compile-testing, including it is a convenient way to get tools.jar on the
-      classpath. This dependency is required by kapt3.
-    -->
-    <dependency>
-      <groupId>com.google.testing.compile</groupId>
-      <artifactId>compile-testing</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
 
   <build>
@@ -145,18 +129,6 @@
           </execution>
         </executions>
       </plugin>
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-surefire-plugin</artifactId>
-        <version>2.21.0</version>
-        <configuration>
-          <!--
-            Suppress the surefire classloader which prevents introspecting the classpath.
-            http://maven.apache.org/surefire/maven-surefire-plugin/examples/class-loading.html
-          -->
-          <useManifestOnlyJar>false</useManifestOnlyJar>
-        </configuration>
-      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
index 4f93169f..399a6513 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/AdapterGenerator.kt
@@ -16,7 +16,6 @@
 package com.squareup.moshi
 
 import com.squareup.kotlinpoet.ARRAY
-import com.squareup.kotlinpoet.AnnotationSpec
 import com.squareup.kotlinpoet.ClassName
 import com.squareup.kotlinpoet.FileSpec
 import com.squareup.kotlinpoet.FunSpec
@@ -32,22 +31,24 @@ import com.squareup.kotlinpoet.asTypeName
 import org.jetbrains.kotlin.serialization.ProtoBuf
 import java.lang.reflect.Type
 import javax.lang.model.element.Element
-import javax.lang.model.element.TypeElement
 import javax.lang.model.util.Elements
 
 /** Generates a JSON adapter for a target type. */
 internal class AdapterGenerator(
-  val className: ClassName,
+  val fqClassName: String,
+  val packageName: String,
   val propertyList: List<PropertyGenerator>,
   val originalElement: Element,
-  val isDataClass: Boolean,
+  name: String = fqClassName.substringAfter(packageName)
+      .replace('.', '_')
+      .removePrefix("_"),
   val hasCompanionObject: Boolean,
   val visibility: ProtoBuf.Visibility,
   val elements: Elements,
   val genericTypeNames: List<TypeVariableName>?
 ) {
   val nameAllocator = NameAllocator()
-  val adapterName = "${className.simpleNames().joinToString(separator = "_")}JsonAdapter"
+  val adapterName = "${name}JsonAdapter"
   val originalTypeName = originalElement.asType().asTypeName()
 
   val moshiParam = ParameterSpec.builder(
@@ -83,7 +84,7 @@ internal class AdapterGenerator(
 
   val delegateAdapters = propertyList.distinctBy { it.delegateKey() }
 
-  fun generateFile(generatedOption: TypeElement?): FileSpec {
+  fun generateFile(): FileSpec {
     for (property in delegateAdapters) {
       property.reserveDelegateNames(nameAllocator)
     }
@@ -91,24 +92,16 @@ internal class AdapterGenerator(
       property.allocateNames(nameAllocator)
     }
 
-    val result = FileSpec.builder(className.packageName(), adapterName)
+    val result = FileSpec.builder(packageName, adapterName)
     if (hasCompanionObject) {
       result.addFunction(generateJsonAdapterFun())
     }
-    result.addType(generateType(generatedOption))
+    result.addType(generateType())
     return result.build()
   }
 
-  private fun generateType(generatedOption: TypeElement?): TypeSpec {
+  private fun generateType(): TypeSpec {
     val result = TypeSpec.classBuilder(adapterName)
-
-    generatedOption?.let {
-      result.addAnnotation(AnnotationSpec.builder(it.asClassName())
-          .addMember("%S", JsonClassCodeGenProcessor::class.java.canonicalName)
-          .addMember("%S", "https://github.com/square/moshi")
-          .build())
-    }
-
     result.superclass(jsonAdapterTypeName)
 
     genericTypeNames?.let {
@@ -155,8 +148,6 @@ internal class AdapterGenerator(
   }
 
   private fun generateFromJsonFun(): FunSpec {
-    val resultName = nameAllocator.newName("result")
-
     val result = FunSpec.builder("fromJson")
         .addModifiers(KModifier.OVERRIDE)
         .addParameter(readerParam)
@@ -177,7 +168,7 @@ internal class AdapterGenerator(
       if (property.differentiateAbsentFromNull) {
         result.beginControlFlow("%L -> ", index)
         result.addStatement("%N = %N.fromJson(%N)",
-            property.localName, property.delegateName, readerParam)
+            property.localName, property.delegateName, readerParam);
         result.addStatement("%N = true", property.localIsPresentName)
         result.endControlFlow()
       } else {
@@ -196,72 +187,36 @@ internal class AdapterGenerator(
     result.endControlFlow() // while
     result.addStatement("%N.endObject()", readerParam)
 
-    // Call the constructor providing only required parameters.
-    var hasOptionalParameters = false
-    result.addCode("%[var %N = %T(", resultName, originalTypeName)
-    var separator = "\n"
-    for (property in propertyList) {
-      if (!property.hasConstructorParameter) {
-        continue
-      }
-      if (property.hasDefault) {
-        hasOptionalParameters = true
-        continue
-      }
-      result.addCode(separator)
+    val propertiesWithoutDefaults = propertyList.filter { !it.hasDefault }
+    result.addCode("%[return %T(\n", originalTypeName)
+    propertiesWithoutDefaults.forEachIndexed { index, property ->
       result.addCode("%N = %N", property.name, property.localName)
       if (property.isRequired) {
         result.addCode(" ?: throw %T(\"Required property '%L' missing at \${%N.path}\")",
             JsonDataException::class, property.localName, readerParam)
       }
-      separator = ",\n"
+      result.addCode(if (index + 1 < propertiesWithoutDefaults.size) ",\n" else "\n")
     }
-    result.addCode(")%]\n", originalTypeName)
+    result.addCode("%])\n", originalTypeName)
 
-    // Call either the constructor again, or the copy() method, this time providing any optional
-    // parameters that we have.
-    if (hasOptionalParameters) {
-      if (isDataClass) {
-        result.addCode("%[%1N = %1N.copy(", resultName)
-      } else {
-        result.addCode("%[%1N = %2T(", resultName, originalTypeName)
-      }
-      separator = "\n"
-      for (property in propertyList) {
-        if (!property.hasConstructorParameter) {
-          continue // No constructor parameter for this property.
-        }
-        if (isDataClass && !property.hasDefault) {
-          continue // Property already assigned.
-        }
-
-        result.addCode(separator)
+    val propertiesWithDefaults = propertyList.filter { it.hasDefault }
+    if (!propertiesWithDefaults.isEmpty()) {
+      result.addCode(".let {%>\n")
+      result.addCode("%[it.copy(\n")
+      propertiesWithDefaults.forEachIndexed { index, property ->
         if (property.differentiateAbsentFromNull) {
-          result.addCode("%2N = if (%3N) %4N else %1N.%2N",
-              resultName, property.name, property.localIsPresentName, property.localName)
+          result.addCode("%1N = if (%2N) %3N else it.%1N",
+              property.name, property.localIsPresentName, property.localName)
         } else {
-          result.addCode("%2N = %3N ?: %1N.%2N", resultName, property.name, property.localName)
+          result.addCode("%1N = %2N ?: it.%1N",
+              property.name, property.localName)
         }
-        separator = ",\n"
+        result.addCode(if (index + 1 < propertiesWithDefaults.size) ",\n" else "\n")
       }
       result.addCode("%])\n")
+      result.addCode("%<}\n")
     }
 
-    // Assign properties not present in the constructor.
-    for (property in propertyList) {
-      if (property.hasConstructorParameter) {
-        continue // Property already handled.
-      }
-      if (property.differentiateAbsentFromNull) {
-        result.addStatement("%1N.%2N = if (%3N) %4N else %1N.%2N",
-            resultName, property.name, property.localIsPresentName, property.localName)
-      } else {
-        result.addStatement("%1N.%2N = %3N ?: %1N.%2N",
-            resultName, property.name, property.localName)
-      }
-    }
-
-    result.addStatement("return %1N", resultName)
     return result.build()
   }
 
@@ -289,7 +244,8 @@ internal class AdapterGenerator(
 
   private fun generateJsonAdapterFun(): FunSpec {
     val rawType = when (originalTypeName) {
-      is TypeVariableName -> throw IllegalArgumentException("Cannot get raw type of TypeVariable!")
+      is TypeVariableName -> throw IllegalArgumentException(
+          "Cannot get raw type of TypeVariable!")
       is ParameterizedTypeName -> originalTypeName.rawType
       else -> originalTypeName as ClassName
     }
@@ -317,4 +273,4 @@ internal class AdapterGenerator(
 
     return result.build()
   }
-}
+}
\ No newline at end of file
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
deleted file mode 100644
index 82fc8f21..00000000
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/JsonClassCodeGenProcessor.kt
+++ /dev/null
@@ -1,291 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi
-
-import com.google.auto.common.AnnotationMirrors
-import com.google.auto.service.AutoService
-import com.squareup.kotlinpoet.ClassName
-import com.squareup.kotlinpoet.KModifier.OUT
-import com.squareup.kotlinpoet.ParameterizedTypeName
-import com.squareup.kotlinpoet.TypeSpec
-import com.squareup.kotlinpoet.TypeVariableName
-import com.squareup.kotlinpoet.asTypeName
-import me.eugeniomarletti.kotlin.metadata.KotlinClassMetadata
-import me.eugeniomarletti.kotlin.metadata.KotlinMetadataUtils
-import me.eugeniomarletti.kotlin.metadata.classKind
-import me.eugeniomarletti.kotlin.metadata.declaresDefaultValue
-import me.eugeniomarletti.kotlin.metadata.isDataClass
-import me.eugeniomarletti.kotlin.metadata.isPrimary
-import me.eugeniomarletti.kotlin.metadata.jvm.getJvmConstructorSignature
-import me.eugeniomarletti.kotlin.metadata.kotlinMetadata
-import me.eugeniomarletti.kotlin.metadata.visibility
-import me.eugeniomarletti.kotlin.processing.KotlinAbstractProcessor
-import org.jetbrains.kotlin.serialization.ProtoBuf
-import org.jetbrains.kotlin.serialization.ProtoBuf.ValueParameter
-import java.io.File
-import javax.annotation.processing.ProcessingEnvironment
-import javax.annotation.processing.Processor
-import javax.annotation.processing.RoundEnvironment
-import javax.lang.model.SourceVersion
-import javax.lang.model.element.AnnotationMirror
-import javax.lang.model.element.Element
-import javax.lang.model.element.ElementKind
-import javax.lang.model.element.ExecutableElement
-import javax.lang.model.element.TypeElement
-import javax.lang.model.element.VariableElement
-import javax.tools.Diagnostic.Kind.ERROR
-
-/**
- * An annotation processor that reads Kotlin data classes and generates Moshi JsonAdapters for them.
- * This generates Kotlin code, and understands basic Kotlin language features like default values
- * and companion objects.
- *
- * The generated class will match the visibility of the given data class (i.e. if it's internal, the
- * adapter will also be internal).
- *
- * If you define a companion object, a jsonAdapter() extension function will be generated onto it.
- * If you don't want this though, you can use the runtime [JsonClass] factory implementation.
- */
-@AutoService(Processor::class)
-class JsonClassCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils {
-
-  companion object {
-    /**
-     * This annotation processing argument can be specified to have a `@Generated` annotation
-     * included in the generated code. It is not encouraged unless you need it for static analysis
-     * reasons and not enabled by default.
-     *
-     * Note that this can only be one of the following values:
-     *   * `"javax.annotation.processing.Generated"` (JRE 9+)
-     *   * `"javax.annotation.Generated"` (JRE <9)
-     */
-    const val OPTION_GENERATED = "moshi.generated"
-    private val POSSIBLE_GENERATED_NAMES = setOf(
-        "javax.annotation.processing.Generated",
-        "javax.annotation.Generated"
-    )
-  }
-
-  private val annotation = JsonClass::class.java
-  private var generatedType: TypeElement? = null
-
-  override fun getSupportedAnnotationTypes() = setOf(annotation.canonicalName)
-
-  override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latest()
-
-  override fun getSupportedOptions() = setOf(OPTION_GENERATED)
-
-  override fun init(processingEnv: ProcessingEnvironment) {
-    super.init(processingEnv)
-    generatedType = processingEnv.options[OPTION_GENERATED]?.let {
-      if (it !in POSSIBLE_GENERATED_NAMES) {
-        throw IllegalArgumentException(
-            "Invalid option value for $OPTION_GENERATED. Found $it, allowable values are $POSSIBLE_GENERATED_NAMES.")
-      }
-      processingEnv.elementUtils.getTypeElement(it)
-    }
-  }
-
-  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
-    for (type in roundEnv.getElementsAnnotatedWith(annotation)) {
-      val jsonClass = type.getAnnotation(annotation)
-      if (jsonClass.generateAdapter) {
-        val adapterGenerator = processElement(type) ?: continue
-        adapterGenerator.generateAndWrite(generatedType)
-      }
-    }
-
-    return true
-  }
-
-  private fun processElement(element: Element): AdapterGenerator? {
-    val metadata = element.kotlinMetadata
-
-    if (metadata !is KotlinClassMetadata) {
-      errorMustBeKotlinClass(element)
-      return null
-    }
-
-    val classData = metadata.data
-    val (nameResolver, classProto) = classData
-
-    if (classProto.classKind != ProtoBuf.Class.Kind.CLASS) {
-      errorMustBeKotlinClass(element)
-      return null
-    }
-
-    val typeName = element.asType().asTypeName()
-    val className = when (typeName) {
-      is ClassName -> typeName
-      is ParameterizedTypeName -> typeName.rawType
-      else -> throw IllegalStateException("unexpected TypeName: ${typeName::class}")
-    }
-
-    val hasCompanionObject = classProto.hasCompanionObjectName()
-    // todo allow custom constructor
-    val protoConstructor = classProto.constructorList
-        .single { it.isPrimary }
-    val constructorJvmSignature = protoConstructor.getJvmConstructorSignature(nameResolver,
-        classProto.typeTable)
-    val constructor = classProto.fqName
-        .let(nameResolver::getString)
-        .replace('/', '.')
-        .let(elementUtils::getTypeElement)
-        .enclosedElements
-        .mapNotNull {
-          it.takeIf { it.kind == ElementKind.CONSTRUCTOR }?.let { it as ExecutableElement }
-        }
-        .first()
-    // TODO Temporary until jvm method signature matching is better
-    //  .single { it.jvmMethodSignature == constructorJvmSignature }
-    val parameters: Map<String, ValueParameter> = protoConstructor.valueParameterList.associateBy {
-      nameResolver.getString(it.name)
-    }
-
-    val properties = classData.classProto.propertyList.associateBy {
-      nameResolver.getString(it.name)
-    }
-
-    val propertyGenerators = mutableListOf<PropertyGenerator>()
-    for (enclosedElement in element.enclosedElements) {
-      if (enclosedElement !is VariableElement) continue
-
-      val name = enclosedElement.simpleName.toString()
-      val property = properties[name] ?: continue
-      val parameter = parameters[name]
-
-      val parameterElement = if (parameter != null) {
-        val parameterIndex = protoConstructor.valueParameterList.indexOf(parameter)
-        constructor.parameters[parameterIndex]
-      } else {
-        null
-      }
-
-      if (property.visibility != ProtoBuf.Visibility.INTERNAL
-          && property.visibility != ProtoBuf.Visibility.PROTECTED
-          && property.visibility != ProtoBuf.Visibility.PUBLIC) {
-        messager.printMessage(ERROR, "property $name is not visible", enclosedElement)
-        return null
-      }
-
-      propertyGenerators += PropertyGenerator(
-          name,
-          serializedName(name, enclosedElement, parameterElement),
-          parameter != null,
-          parameter?.declaresDefaultValue ?: true,
-          property.returnType.nullable,
-          property.returnType.asTypeName(nameResolver, classProto::getTypeParameter),
-          property.returnType.asTypeName(nameResolver, classProto::getTypeParameter, true),
-          jsonQualifiers(enclosedElement, parameterElement))
-    }
-
-    // Sort properties so that those with constructor parameters come first.
-    propertyGenerators.sortBy { if (it.hasConstructorParameter) -1 else 1 }
-
-    val genericTypeNames = classProto.typeParameterList
-        .map {
-          val variance = it.variance.asKModifier().let {
-            // We don't redeclare out variance here
-            if (it == OUT) {
-              null
-            } else {
-              it
-            }
-          }
-          TypeVariableName(
-              name = nameResolver.getString(it.name),
-              bounds = *(it.upperBoundList
-                  .map { it.asTypeName(nameResolver, classProto::getTypeParameter) }
-                  .toTypedArray()),
-              variance = variance)
-              .reified(it.reified)
-        }.let {
-          if (it.isEmpty()) {
-            null
-          } else {
-            it
-          }
-        }
-
-    return AdapterGenerator(
-        className,
-        propertyList = propertyGenerators,
-        originalElement = element,
-        hasCompanionObject = hasCompanionObject,
-        visibility = classProto.visibility!!,
-        genericTypeNames = genericTypeNames,
-        elements = elementUtils,
-        isDataClass = classProto.isDataClass)
-  }
-
-  /** Returns the JsonQualifiers on the field and parameter of a property. */
-  private fun jsonQualifiers(
-    field: VariableElement,
-    parameter: VariableElement?
-  ): Set<AnnotationMirror> {
-    val fieldJsonQualifiers = AnnotationMirrors.getAnnotatedAnnotations(
-        field, JsonQualifier::class.java)
-
-    val parameterJsonQualifiers: Set<AnnotationMirror> = if (parameter != null) {
-      AnnotationMirrors.getAnnotatedAnnotations(parameter, JsonQualifier::class.java)
-    } else {
-      setOf()
-    }
-
-    // TODO(jwilson): union the qualifiers somehow?
-    if (fieldJsonQualifiers.isNotEmpty()) {
-      return fieldJsonQualifiers
-    } else {
-      return parameterJsonQualifiers
-    }
-  }
-
-  /** Returns the @Json name of a property, or `propertyName` if none is provided. */
-  private fun serializedName(
-    propertyName: String,
-    field: VariableElement,
-    parameter: VariableElement?
-  ): String {
-    val fieldAnnotation = field.getAnnotation(Json::class.java)
-    if (fieldAnnotation != null) return fieldAnnotation.name
-
-    val parameterAnnotation = parameter?.getAnnotation(Json::class.java)
-    if (parameterAnnotation != null) return parameterAnnotation.name
-
-    return propertyName
-  }
-
-  private fun errorMustBeKotlinClass(element: Element) {
-    messager.printMessage(ERROR,
-        "@${JsonClass::class.java.simpleName} can't be applied to $element: must be a Kotlin class",
-        element)
-  }
-
-  private fun AdapterGenerator.generateAndWrite(generatedOption: TypeElement?) {
-    val fileSpec = generateFile(generatedOption)
-    val adapterName = fileSpec.members.filterIsInstance<TypeSpec>().first().name!!
-    val outputDir = generatedDir ?: mavenGeneratedDir(adapterName)
-    fileSpec.writeTo(outputDir)
-  }
-
-  private fun mavenGeneratedDir(adapterName: String): File {
-    // Hack since the maven plugin doesn't supply `kapt.kotlin.generated` option
-    // Bug filed at https://youtrack.jetbrains.com/issue/KT-22783
-    val file = filer.createSourceFile(adapterName).toUri().let(::File)
-    return file.parentFile.also { file.delete() }
-  }
-}
-
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/MoshiKotlinCodeGenProcessor.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/MoshiKotlinCodeGenProcessor.kt
new file mode 100644
index 00000000..3b280deb
--- /dev/null
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/MoshiKotlinCodeGenProcessor.kt
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi
+
+import com.google.auto.common.AnnotationMirrors
+import com.google.auto.service.AutoService
+import com.squareup.kotlinpoet.KModifier.OUT
+import com.squareup.kotlinpoet.TypeSpec
+import com.squareup.kotlinpoet.TypeVariableName
+import me.eugeniomarletti.kotlin.metadata.KotlinClassMetadata
+import me.eugeniomarletti.kotlin.metadata.KotlinMetadataUtils
+import me.eugeniomarletti.kotlin.metadata.declaresDefaultValue
+import me.eugeniomarletti.kotlin.metadata.extractFullName
+import me.eugeniomarletti.kotlin.metadata.isDataClass
+import me.eugeniomarletti.kotlin.metadata.isPrimary
+import me.eugeniomarletti.kotlin.metadata.jvm.getJvmConstructorSignature
+import me.eugeniomarletti.kotlin.metadata.kotlinMetadata
+import me.eugeniomarletti.kotlin.metadata.visibility
+import me.eugeniomarletti.kotlin.processing.KotlinAbstractProcessor
+import org.jetbrains.kotlin.serialization.ProtoBuf
+import java.io.File
+import javax.annotation.processing.Processor
+import javax.annotation.processing.RoundEnvironment
+import javax.lang.model.SourceVersion
+import javax.lang.model.element.Element
+import javax.lang.model.element.ElementKind
+import javax.lang.model.element.ExecutableElement
+import javax.lang.model.element.TypeElement
+import javax.tools.Diagnostic.Kind.ERROR
+
+/**
+ * An annotation processor that reads Kotlin data classes and generates Moshi JsonAdapters for them.
+ * This generates Kotlin code, and understands basic Kotlin language features like default values
+ * and companion objects.
+ *
+ * The generated class will match the visibility of the given data class (i.e. if it's internal, the
+ * adapter will also be internal).
+ *
+ * If you define a companion object, a jsonAdapter() extension function will be generated onto it.
+ * If you don't want this though, you can use the runtime [MoshiSerializable] factory implementation.
+ */
+@AutoService(Processor::class)
+class MoshiKotlinCodeGenProcessor : KotlinAbstractProcessor(), KotlinMetadataUtils {
+
+  private val annotationName = MoshiSerializable::class.java.canonicalName
+
+  override fun getSupportedAnnotationTypes() = setOf(annotationName)
+
+  override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latest()
+
+  override fun process(annotations: Set<TypeElement>, roundEnv: RoundEnvironment): Boolean {
+    val annotationElement = elementUtils.getTypeElement(annotationName)
+    roundEnv.getElementsAnnotatedWith(annotationElement)
+        .asSequence()
+        .mapNotNull { processElement(it) }
+        .forEach { it.generateAndWrite() }
+
+    return true
+  }
+
+  private fun processElement(element: Element): AdapterGenerator? {
+    val metadata = element.kotlinMetadata
+
+    if (metadata !is KotlinClassMetadata) {
+      errorMustBeDataClass(element)
+      return null
+    }
+
+    val classData = metadata.data
+    val (nameResolver, classProto) = classData
+
+    fun ProtoBuf.Type.extractFullName() = extractFullName(classData)
+
+    if (!classProto.isDataClass) {
+      errorMustBeDataClass(element)
+      return null
+    }
+
+    val fqClassName = nameResolver.getString(classProto.fqName).replace('/', '.')
+
+    val packageName = nameResolver.getString(classProto.fqName).substringBeforeLast('/').replace(
+        '/', '.')
+
+    val hasCompanionObject = classProto.hasCompanionObjectName()
+    // todo allow custom constructor
+    val protoConstructor = classProto.constructorList
+        .single { it.isPrimary }
+    val constructorJvmSignature = protoConstructor.getJvmConstructorSignature(nameResolver,
+        classProto.typeTable)
+    val constructor = classProto.fqName
+        .let(nameResolver::getString)
+        .replace('/', '.')
+        .let(elementUtils::getTypeElement)
+        .enclosedElements
+        .mapNotNull {
+          it.takeIf { it.kind == ElementKind.CONSTRUCTOR }?.let { it as ExecutableElement }
+        }
+        .first()
+    // TODO Temporary until jvm method signature matching is better
+    //  .single { it.jvmMethodSignature == constructorJvmSignature }
+    val parameters = protoConstructor
+        .valueParameterList
+        .mapIndexed { index, valueParameter ->
+          val paramName = nameResolver.getString(valueParameter.name)
+
+          val nullable = valueParameter.type.nullable
+          val paramFqcn = valueParameter.type.extractFullName()
+              .replace("`", "")
+              .removeSuffix("?")
+
+          val actualElement = constructor.parameters[index]
+
+          val serializedName = actualElement.getAnnotation(Json::class.java)?.name
+              ?: paramName
+
+          val jsonQualifiers = AnnotationMirrors.getAnnotatedAnnotations(actualElement,
+              JsonQualifier::class.java)
+
+          PropertyGenerator(
+              name = paramName,
+              serializedName = serializedName,
+              hasDefault = valueParameter.declaresDefaultValue,
+              nullable = nullable,
+              typeName = valueParameter.type.asTypeName(nameResolver, classProto::getTypeParameter),
+              unaliasedName = valueParameter.type.asTypeName(nameResolver,
+                  classProto::getTypeParameter, true),
+              jsonQualifiers = jsonQualifiers)
+        }
+
+    val genericTypeNames = classProto.typeParameterList
+        .map {
+          val variance = it.variance.asKModifier().let {
+            // We don't redeclare out variance here
+            if (it == OUT) {
+              null
+            } else {
+              it
+            }
+          }
+          TypeVariableName(
+              name = nameResolver.getString(it.name),
+              bounds = *(it.upperBoundList
+                  .map { it.asTypeName(nameResolver, classProto::getTypeParameter) }
+                  .toTypedArray()),
+              variance = variance)
+              .reified(it.reified)
+        }.let {
+          if (it.isEmpty()) {
+            null
+          } else {
+            it
+          }
+        }
+
+    return AdapterGenerator(
+        fqClassName = fqClassName,
+        packageName = packageName,
+        propertyList = parameters,
+        originalElement = element,
+        hasCompanionObject = hasCompanionObject,
+        visibility = classProto.visibility!!,
+        genericTypeNames = genericTypeNames,
+        elements = elementUtils)
+  }
+
+  private fun errorMustBeDataClass(element: Element) {
+    messager.printMessage(ERROR,
+        "@${MoshiSerializable::class.java.simpleName} can't be applied to $element: must be a Kotlin data class",
+        element)
+  }
+
+  private fun AdapterGenerator.generateAndWrite() {
+    val fileSpec = generateFile()
+    val adapterName = fileSpec.members.filterIsInstance<TypeSpec>().first().name!!
+    val outputDir = generatedDir ?: mavenGeneratedDir(adapterName)
+    fileSpec.writeTo(outputDir)
+  }
+
+  private fun mavenGeneratedDir(adapterName: String): File {
+    // Hack since the maven plugin doesn't supply `kapt.kotlin.generated` option
+    // Bug filed at https://youtrack.jetbrains.com/issue/KT-22783
+    val file = filer.createSourceFile(adapterName).toUri().let(::File)
+    return file.parentFile.also { file.delete() }
+  }
+}
+
diff --git a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt
index 68b61d77..3d8319ca 100644
--- a/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt
+++ b/kotlin-codegen/compiler/src/main/java/com/squareup/moshi/PropertyGenerator.kt
@@ -32,7 +32,6 @@ import javax.lang.model.element.AnnotationMirror
 internal class PropertyGenerator(
   val name: String,
   val serializedName: String,
-  val hasConstructorParameter: Boolean,
   val hasDefault: Boolean,
   val nullable: Boolean,
   val typeName: TypeName,
diff --git a/kotlin-codegen/integration-test/pom.xml b/kotlin-codegen/integration-test/pom.xml
index 8b24a4e9..2ecc4b2d 100644
--- a/kotlin-codegen/integration-test/pom.xml
+++ b/kotlin-codegen/integration-test/pom.xml
@@ -18,6 +18,11 @@
       <artifactId>moshi</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi-kotlin-codegen-runtime</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>org.jetbrains.kotlin</groupId>
       <artifactId>kotlin-stdlib</artifactId>
@@ -52,6 +57,7 @@
             <configuration>
               <sourceDirs>
                 <sourceDir>src/main/kotlin</sourceDir>
+                <sourceDir>src/main/java</sourceDir>
               </sourceDirs>
               <annotationProcessorPaths>
                 <annotationProcessorPath>
diff --git a/kotlin-codegen/runtime/pom.xml b/kotlin-codegen/runtime/pom.xml
new file mode 100644
index 00000000..08b8e367
--- /dev/null
+++ b/kotlin-codegen/runtime/pom.xml
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.moshi</groupId>
+    <artifactId>moshi-parent</artifactId>
+    <version>1.6.0-SNAPSHOT</version>
+    <relativePath>../../pom.xml</relativePath>
+  </parent>
+
+  <artifactId>moshi-kotlin-codegen-runtime</artifactId>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-stdlib</artifactId>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-maven-plugin</artifactId>
+        <version>${kotlin.version}</version>
+        <executions>
+          <execution>
+            <id>compile</id>
+            <phase>compile</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+          <execution>
+            <id>test-compile</id>
+            <phase>test-compile</phase>
+            <goals>
+              <goal>test-compile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>compile</id>
+            <phase>compile</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+          <execution>
+            <id>testCompile</id>
+            <phase>test-compile</phase>
+            <goals>
+              <goal>testCompile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/kotlin-codegen/runtime/src/main/java/com/squareup/moshi/MoshiSerializable.kt b/kotlin-codegen/runtime/src/main/java/com/squareup/moshi/MoshiSerializable.kt
new file mode 100644
index 00000000..d6857659
--- /dev/null
+++ b/kotlin-codegen/runtime/src/main/java/com/squareup/moshi/MoshiSerializable.kt
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi
+
+import java.lang.reflect.InvocationTargetException
+import java.lang.reflect.ParameterizedType
+import java.lang.reflect.Type
+import kotlin.annotation.AnnotationRetention.RUNTIME
+import kotlin.annotation.AnnotationTarget.CLASS
+
+@Retention(RUNTIME)
+@Target(CLASS)
+annotation class MoshiSerializable
+
+class MoshiSerializableFactory : JsonAdapter.Factory {
+
+  override fun create(type: Type, annotations: Set<Annotation>, moshi: Moshi): JsonAdapter<*>? {
+
+    val rawType = Types.getRawType(type)
+    if (!rawType.isAnnotationPresent(MoshiSerializable::class.java)) {
+      return null
+    }
+
+    val clsName = rawType.name.replace("$", "_")
+    val constructor = try {
+      @Suppress("UNCHECKED_CAST")
+      val bindingClass = rawType.classLoader
+          .loadClass(clsName + "JsonAdapter") as Class<out JsonAdapter<*>>
+      if (type is ParameterizedType) {
+        // This is generic, use the two param moshi + type constructor
+        bindingClass.getDeclaredConstructor(Moshi::class.java, Array<Type>::class.java)
+      } else {
+        // The standard single param moshi constructor
+        bindingClass.getDeclaredConstructor(Moshi::class.java)
+      }
+    } catch (e: ClassNotFoundException) {
+      throw RuntimeException("Unable to find generated Moshi adapter class for $clsName", e)
+    } catch (e: NoSuchMethodException) {
+      throw RuntimeException("Unable to find generated Moshi adapter constructor for $clsName", e)
+    }
+
+    try {
+      return when {
+        constructor.parameterTypes.size == 1 -> constructor.newInstance(moshi)
+        type is ParameterizedType -> constructor.newInstance(moshi, type.actualTypeArguments)
+        else -> throw IllegalStateException("Unable to handle type $type")
+      }
+    } catch (e: IllegalAccessException) {
+      throw RuntimeException("Unable to invoke $constructor", e)
+    } catch (e: InstantiationException) {
+      throw RuntimeException("Unable to invoke $constructor", e)
+    } catch (e: InvocationTargetException) {
+      val cause = e.cause
+      if (cause is RuntimeException) {
+        throw cause
+      }
+      if (cause is Error) {
+        throw cause
+      }
+      throw RuntimeException(
+          "Could not create generated JsonAdapter instance for type $rawType", cause)
+    }
+  }
+}
diff --git a/kotlin/src/main/java/com/squareup/moshi/kotlin/KotlinJsonAdapter.kt b/kotlin/src/main/java/com/squareup/moshi/kotlin/KotlinJsonAdapter.kt
index 3d3b205f..3f005c9d 100644
--- a/kotlin/src/main/java/com/squareup/moshi/kotlin/KotlinJsonAdapter.kt
+++ b/kotlin/src/main/java/com/squareup/moshi/kotlin/KotlinJsonAdapter.kt
@@ -225,8 +225,9 @@ class KotlinJsonAdapterFactory : JsonAdapter.Factory {
       }
 
       val name = jsonAnnotation?.name ?: property.name
+      val resolvedPropertyType = Types.resolve(type, rawType, property.returnType.javaType)
       val adapter = moshi.adapter<Any>(
-          property.returnType.javaType, Util.jsonAnnotations(allAnnotations.toTypedArray()))
+          resolvedPropertyType, Util.jsonAnnotations(allAnnotations.toTypedArray()))
 
       bindingsByName[property.name] =
           KotlinJsonAdapter.Binding(name, adapter, property as KProperty1<Any, Any?>, parameter)
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonClass.java b/moshi/src/main/java/com/squareup/moshi/JsonClass.java
deleted file mode 100644
index 059f41bb..00000000
--- a/moshi/src/main/java/com/squareup/moshi/JsonClass.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * Customizes how a type is encoded as JSON.
- *
- * <p>This annotation is currently only permitted on declarations of data classes in Kotlin.
- */
-@Retention(RUNTIME)
-@Documented
-public @interface JsonClass {
-  boolean generateAdapter();
-}
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index 5b1be373..5a7eb461 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -18,9 +18,6 @@ package com.squareup.moshi;
 import com.squareup.moshi.internal.Util;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.util.Arrays;
 import java.util.Collection;
@@ -56,12 +53,6 @@ final class StandardJsonAdapters {
       if (type == Object.class) return new ObjectJsonAdapter(moshi).nullSafe();
 
       Class<?> rawType = Types.getRawType(type);
-
-      JsonClass jsonClass = rawType.getAnnotation(JsonClass.class);
-      if (jsonClass != null && jsonClass.generateAdapter()) {
-        return generatedAdapter(moshi, type, rawType);
-      }
-
       if (rawType.isEnum()) {
         //noinspection unchecked
         return new EnumJsonAdapter<>((Class<? extends Enum>) rawType).nullSafe();
@@ -224,45 +215,6 @@ final class StandardJsonAdapters {
     }
   };
 
-  /**
-   * Loads the generated JsonAdapter for classes annotated {@link JsonClass}. This works because it
-   * uses the same naming conventions as {@code JsonClassCodeGenProcessor}.
-   */
-  static JsonAdapter<?> generatedAdapter(Moshi moshi, Type type, Class<?> rawType) {
-    String adapterClassName = rawType.getName().replace("$", "_") + "JsonAdapter";
-    try {
-      @SuppressWarnings("unchecked") // We generate types to match.
-      Class<? extends JsonAdapter<?>> adapterClass = (Class<? extends JsonAdapter<?>>)
-          Class.forName(adapterClassName, true, rawType.getClassLoader());
-      if (type instanceof ParameterizedType) {
-        Constructor<? extends JsonAdapter<?>> constructor
-            = adapterClass.getDeclaredConstructor(Moshi.class, Type[].class);
-        constructor.setAccessible(true);
-        return constructor.newInstance(moshi, ((ParameterizedType) type).getActualTypeArguments());
-      } else {
-        Constructor<? extends JsonAdapter<?>> constructor
-            = adapterClass.getDeclaredConstructor(Moshi.class);
-        constructor.setAccessible(true);
-        return constructor.newInstance(moshi);
-      }
-    } catch (ClassNotFoundException e) {
-      throw new RuntimeException(
-          "Failed to find the generated JsonAdapter class for " + rawType, e);
-    } catch (NoSuchMethodException e) {
-      throw new RuntimeException(
-          "Failed to find the generated JsonAdapter constructor for " + rawType, e);
-    } catch (IllegalAccessException e) {
-      throw new RuntimeException(
-          "Failed to access the generated JsonAdapter for " + rawType, e);
-    } catch (InvocationTargetException e) {
-      throw new RuntimeException(
-          "Failed to construct the generated JsonAdapter for " + rawType, e);
-    } catch (InstantiationException e) {
-      throw new RuntimeException(
-          "Failed to instantiate the generated JsonAdapter for " + rawType, e);
-    }
-  }
-
   static final class EnumJsonAdapter<T extends Enum<T>> extends JsonAdapter<T> {
     private final Class<T> enumType;
     private final String[] nameStrings;
diff --git a/moshi/src/main/java/com/squareup/moshi/Types.java b/moshi/src/main/java/com/squareup/moshi/Types.java
index 80459d14..ae6fdf0f 100644
--- a/moshi/src/main/java/com/squareup/moshi/Types.java
+++ b/moshi/src/main/java/com/squareup/moshi/Types.java
@@ -373,7 +373,8 @@ public final class Types {
     return new Type[] { Object.class, Object.class };
   }
 
-  static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
+  @CheckReturnValue // TODO(eric): Move this to internal Utils.
+  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
     // This implementation is made a little more complicated in an attempt to avoid object-creation.
     while (true) {
       if (toResolve instanceof TypeVariable) {
diff --git a/pom.xml b/pom.xml
index eebd3a4f..30b64163 100644
--- a/pom.xml
+++ b/pom.xml
@@ -24,19 +24,18 @@
     <module>kotlin</module>
     <module>kotlin-codegen/compiler</module>
     <module>kotlin-codegen/integration-test</module>
+    <module>kotlin-codegen/runtime</module>
   </modules>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <java.version>1.7</java.version>
     <kotlin.version>1.2.21</kotlin.version>
-    <kotlin-metadata.version>1.2.1</kotlin-metadata.version>
 
     <!-- Dependencies -->
     <okio.version>1.13.0</okio.version>
 
     <!-- Test Dependencies -->
-    <compile-testing.version>0.8</compile-testing.version>
     <junit.version>4.12</junit.version>
     <assertj.version>1.7.0</assertj.version>
   </properties>
@@ -99,26 +98,6 @@
         <version>${kotlin.version}</version>
         <scope>test</scope>
       </dependency>
-      <dependency>
-        <groupId>org.jetbrains.kotlin</groupId>
-        <artifactId>kotlin-compiler-embeddable</artifactId>
-        <version>${kotlin.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>org.jetbrains.kotlin</groupId>
-        <artifactId>kotlin-annotation-processing-embeddable</artifactId>
-        <version>${kotlin.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>me.eugeniomarletti</groupId>
-        <artifactId>kotlin-metadata</artifactId>
-        <version>${kotlin-metadata.version}</version>
-      </dependency>
-      <dependency>
-        <groupId>com.google.testing.compile</groupId>
-        <artifactId>compile-testing</artifactId>
-        <version>${compile-testing.version}</version>
-      </dependency>
     </dependencies>
   </dependencyManagement>
 
