diff --git a/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/utils.kt b/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/utils.kt
index 0f5892ca6..a776758e7 100644
--- a/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/utils.kt
+++ b/ktor-client/ktor-client-cio/common/src/io/ktor/client/engine/cio/utils.kt
@@ -16,9 +16,8 @@ import io.ktor.utils.io.*
 import io.ktor.utils.io.CancellationException
 import io.ktor.websocket.*
 import kotlinx.coroutines.*
-import kotlinx.io.EOFException
 import kotlinx.io.IOException
-import kotlin.coroutines.CoroutineContext
+import kotlin.coroutines.*
 
 internal suspend fun writeRequest(
     request: HttpRequestData,
@@ -170,9 +169,7 @@ internal suspend fun readResponse(
     callContext: CoroutineContext
 ): HttpResponseData = withContext(callContext) {
     val rawResponse = parseResponse(input)
-        ?: throw ClosedReadChannelException(
-            EOFException("Failed to parse HTTP response: the server prematurely closed the connection")
-        )
+        ?: throw kotlinx.io.EOFException("Failed to parse HTTP response: the server prematurely closed the connection")
 
     rawResponse.use {
         val status = HttpStatusCode(rawResponse.status, rawResponse.statusText.toString())
@@ -240,7 +237,7 @@ internal suspend fun startTunnel(
         output.flush()
 
         val rawResponse = parseResponse(input)
-            ?: throw ClosedReadChannelException(EOFException("Failed to parse CONNECT response: unexpected EOF"))
+            ?: throw kotlinx.io.EOFException("Failed to parse CONNECT response: unexpected EOF")
         rawResponse.use {
             if (rawResponse.status / 200 != 1) {
                 throw IOException("Can not establish tunnel connection")
diff --git a/ktor-client/ktor-client-cio/jvm/src/io/ktor/client/engine/cio/ConnectionPipeline.kt b/ktor-client/ktor-client-cio/jvm/src/io/ktor/client/engine/cio/ConnectionPipeline.kt
index fde317c77..0d75c9bb2 100644
--- a/ktor-client/ktor-client-cio/jvm/src/io/ktor/client/engine/cio/ConnectionPipeline.kt
+++ b/ktor-client/ktor-client-cio/jvm/src/io/ktor/client/engine/cio/ConnectionPipeline.kt
@@ -15,12 +15,12 @@ import io.ktor.utils.io.*
 import io.ktor.utils.io.pool.*
 import kotlinx.coroutines.*
 import kotlinx.coroutines.CancellationException
+import kotlinx.coroutines.channels.*
 import kotlinx.coroutines.channels.Channel
-import kotlinx.coroutines.channels.ClosedReceiveChannelException
-import kotlinx.coroutines.sync.Semaphore
-import kotlinx.io.EOFException
-import java.nio.channels.ClosedChannelException
-import kotlin.coroutines.CoroutineContext
+import kotlinx.coroutines.sync.*
+import kotlinx.io.*
+import java.nio.channels.*
+import kotlin.coroutines.*
 import io.ktor.utils.io.ByteChannel as KtorByteChannel
 
 internal actual class ConnectionPipeline actual constructor(
@@ -73,9 +73,7 @@ internal actual class ConnectionPipeline actual constructor(
                 requestLimit.release()
                 try {
                     val rawResponse = parseResponse(networkInput)
-                        ?: throw ClosedReadChannelException(
-                            EOFException("Failed to parse HTTP response: unexpected EOF")
-                        )
+                        ?: throw EOFException("Failed to parse HTTP response: unexpected EOF")
 
                     val callContext = task.context
                     val callJob = callContext[Job]!!
diff --git a/ktor-client/ktor-client-cio/jvm/test/io/ktor/client/engine/cio/ConnectErrorsTest.kt b/ktor-client/ktor-client-cio/jvm/test/io/ktor/client/engine/cio/ConnectErrorsTest.kt
index a5fd4c1f4..f57b8c5a2 100644
--- a/ktor-client/ktor-client-cio/jvm/test/io/ktor/client/engine/cio/ConnectErrorsTest.kt
+++ b/ktor-client/ktor-client-cio/jvm/test/io/ktor/client/engine/cio/ConnectErrorsTest.kt
@@ -17,9 +17,9 @@ import io.ktor.server.engine.*
 import io.ktor.server.netty.*
 import io.ktor.server.response.*
 import io.ktor.server.routing.*
-import io.ktor.utils.io.*
-import kotlinx.coroutines.test.runTest
-import org.junit.jupiter.api.assertThrows
+import kotlinx.coroutines.debug.junit5.CoroutinesTimeout
+import kotlinx.coroutines.runBlocking
+import kotlinx.coroutines.withTimeout
 import java.io.File
 import java.net.ConnectException
 import java.net.ServerSocket
@@ -30,6 +30,7 @@ import javax.net.ssl.X509TrustManager
 import kotlin.concurrent.thread
 import kotlin.test.*
 
+@CoroutinesTimeout(5 * 60 * 1000)
 class ConnectErrorsTest {
 
     private val serverSocket = ServerSocket(0, 1)
@@ -40,7 +41,7 @@ class ConnectErrorsTest {
     }
 
     @Test
-    fun testConnectAfterConnectionErrors() = runTest {
+    fun testConnectAfterConnectionErrors(): Unit = runBlocking {
         val client = HttpClient(CIO) {
             engine {
                 maxConnectionsCount = 1
@@ -75,15 +76,16 @@ class ConnectErrorsTest {
                     } catch (ignore: SocketException) {
                     }
                 }
-
-                assertEquals("OK", client.get("http://localhost:${serverSocket.localPort}/").body())
+                withTimeout(10000L) {
+                    assertEquals("OK", client.get("http://localhost:${serverSocket.localPort}/").body())
+                }
                 thread.join()
             }
         }
     }
 
     @Test
-    fun testResponseWithNoLengthChunkedAndConnectionClosedWithHttp10() = runTest {
+    fun testResponseWithNoLengthChunkedAndConnectionClosedWithHttp10(): Unit = runBlocking {
         val client = HttpClient(CIO)
 
         client.use {
@@ -110,7 +112,7 @@ class ConnectErrorsTest {
     }
 
     @Test
-    fun testResponseErrorWithNoLengthChunkedAndConnectionClosedWithHttp11() = runTest {
+    fun testResponseErrorWithNoLengthChunkedAndConnectionClosedWithHttp11(): Unit = runBlocking {
         val client = HttpClient(CIO)
 
         client.use {
@@ -137,7 +139,7 @@ class ConnectErrorsTest {
     }
 
     @Test
-    fun testResponseErrorWithInvalidChunkException() = runTest {
+    fun testResponseErrorWithInvalidChunkException(): Unit = runBlocking {
         val client = HttpClient(CIO) {
             install(HttpRequestRetry) {
                 retryOnException(maxRetries = 3)
@@ -183,29 +185,7 @@ class ConnectErrorsTest {
     }
 
     @Test
-    fun testConnectionClosedBeforeReadingResponseStatusLine() = runTest {
-        val client = HttpClient(CIO)
-
-        client.use {
-            serverSocket.close()
-
-            ServerSocket(serverSocket.localPort).use { server ->
-                val thread = thread {
-                    server.accept().use {
-                        // emulate connection closed before sending status line
-                    }
-                }
-
-                assertThrows<ClosedReadChannelException> {
-                    client.get("http://localhost:${serverSocket.localPort}/")
-                }
-                thread.join()
-            }
-        }
-    }
-
-    @Test
-    fun testLateServerStart() = runTest {
+    fun testLateServerStart(): Unit = runBlocking {
         val keyStoreFile = File("build/temp.jks")
         val keyStore = generateCertificate(keyStoreFile, algorithm = "SHA256withECDSA", keySizeInBits = 256)
 
