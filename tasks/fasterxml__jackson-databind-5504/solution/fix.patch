diff --git a/release-notes/CREDITS b/release-notes/CREDITS
index 43d35a6b7..04aeb40e1 100644
--- a/release-notes/CREDITS
+++ b/release-notes/CREDITS
@@ -115,16 +115,16 @@ Fouad Almalki (@Eng-Fouad)
  * Contributed fix for 5442: Make `JsonMapper/ObjectMapper` fully proxyable by CGLIB
   [3.1.0]
 
-Oliver Drotbohm (@odrotbohm)
- * Requested #1196: Add opt-in error collection for deserialization
-  [3.1.0]
-
-@sri-adarsh-kumar
- * Contributed #1196: Add opt-in error collection for deserialization
+Konstantin Labun (@kulabun)
+ * Reported #650: `@JsonUnwrapped` prevents checks for
+  `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`
   [3.1.0]
 
 @JacksonJang
- * Contributed fix for #1516: Problem with multi-argument Creator with
+* Contributed fix for #650: `@JsonUnwrapped` prevents checks for
+  `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`
+  [3.1.0]
+* Contributed fix for #1516: Problem with multi-argument Creator with
    `@JsonBackReference` property
   [3.1.0]
  * Contributed fix for #2686: `@JsonBackReference` does not work with a builder
@@ -139,6 +139,14 @@ Oliver Drotbohm (@odrotbohm)
    `java.util.Map` serialization via property annotation
   [3.1.0]
 
+Oliver Drotbohm (@odrotbohm)
+ * Requested #1196: Add opt-in error collection for deserialization
+  [3.1.0]
+
+@sri-adarsh-kumar
+ * Contributed #1196: Add opt-in error collection for deserialization
+  [3.1.0]
+
 Viktor SzathmÃ¡ry (@phraktle)
  * Reported #5115: `@JsonUnwrapped` Record deserialization can't handle name collision
  (reported by Viktor S)
diff --git a/release-notes/VERSION b/release-notes/VERSION
index f59d07090..f2cbec843 100644
--- a/release-notes/VERSION
+++ b/release-notes/VERSION
@@ -8,6 +8,10 @@ Versions: 3.x (for earlier see VERSION-2.x)
 
 3.1.0 (not yet released)
 
+#650: `@JsonUnwrapped` prevents checks for
+  `DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`
+ (reported by Konstantin L)
+ (fix by @JacksonJang)
 #1196: Add opt-in error collection for deserialization
  (requested by @odrotbohm)
  (contributed by @sri-adarsh-kumar)
diff --git a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
index 695d91b35..e80191fb0 100644
--- a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
+++ b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializer.java
@@ -11,6 +11,7 @@ import tools.jackson.databind.deser.ReadableObjectId.Referring;
 import tools.jackson.databind.deser.SettableBeanProperty;
 import tools.jackson.databind.deser.UnresolvedForwardReference;
 import tools.jackson.databind.deser.impl.*;
+import tools.jackson.databind.exc.UnrecognizedPropertyException;
 import tools.jackson.databind.util.ClassUtil;
 import tools.jackson.databind.util.IgnorePropertiesUtil;
 import tools.jackson.databind.util.NameTransformer;
@@ -928,13 +929,17 @@ public class BeanDeserializer
             // 29-Nov-2016, tatu: probably should try to avoid sending content
             //    both to any setter AND buffer... but, for now, the only thing
             //    we can do.
-            // how about any setter? We'll get copies but...
-            if (_anySetter == null) {
-                // but... others should be passed to unwrapped property deserializers
+            // 19-Dec-2025: [databind#650] We can now distinguish the cases
+            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
                 tokens.writeName(propName);
                 tokens.copyCurrentStructure(p);
                 continue;
             }
+            // how about any setter? We'll get copies but...
+            if (_anySetter == null) {
+                handleUnknownVanilla(p, ctxt, bean, propName);
+                continue;
+            }
             // Need to copy to a separate buffer first
             TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);
             tokens.writeName(propName);
@@ -992,11 +997,12 @@ public class BeanDeserializer
             // 29-Nov-2016, tatu: probably should try to avoid sending content
             //    both to any setter AND buffer... but, for now, the only thing
             //    we can do.
-            // how about any setter? We'll get copies but...
-            if (_anySetter == null) {
-                // but... others should be passed to unwrapped property deserializers
+            // 19-Dec-2025: [databind#650] We can now distinguish the cases
+            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
                 tokens.writeName(propName);
                 tokens.copyCurrentStructure(p);
+            } else if (_anySetter == null) {
+                handleUnknownVanilla(p, ctxt, bean, propName);
             } else {
                 // Need to copy to a separate buffer first
                 TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);
@@ -1072,11 +1078,22 @@ public class BeanDeserializer
             // 29-Nov-2016, tatu: probably should try to avoid sending content
             //    both to any setter AND buffer... but, for now, the only thing
             //    we can do.
-            // how about any setter? We'll get copies but...
-            if (_anySetter == null) {
-                // but... others should be passed to unwrapped property deserializers
+            // 19-Dec-2025: [databind#650] We can now distinguish the cases
+            // but... others should be passed to unwrapped property deserializers
+            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propName)) {
                 tokens.writeName(propName);
                 tokens.copyCurrentStructure(p);
+            } else if (_anySetter == null) {
+                // [databind#650]: priority: @JsonIgnoreProperties > FAIL_ON_UNKNOWN_PROPERTIES
+                if (_ignoreAllUnknown) {
+                    p.skipChildren();
+                } else if (IgnorePropertiesUtil.shouldIgnore(propName, _ignorableProps, _includableProps)) {
+                    handleIgnoredProperty(p, ctxt, handledType(), propName);
+                } else if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {
+                    throw UnrecognizedPropertyException.from(p, handledType(), propName, getKnownPropertyNames());
+                } else {
+                    p.skipChildren();
+                }
             } else {
                 // Need to copy to a separate buffer first
                 TokenBuffer b2 = ctxt.bufferAsCopyOfValue(p);
diff --git a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializerBase.java b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializerBase.java
index b6be791a8..cb0143a61 100644
--- a/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializerBase.java
+++ b/src/main/java/tools/jackson/databind/deser/bean/BeanDeserializerBase.java
@@ -635,9 +635,12 @@ ClassUtil.getTypeDescription(_beanType), ClassUtil.classNameOf(_valueInstantiato
             _nonStandardCreation = true;
         }
 
-        _unwrappedPropertyHandler = unwrapped;
         if (unwrapped != null) { // we consider this non-standard, to offline handling
             _nonStandardCreation = true;
+            // [databind#650]: Initialize nested property names cache for hasUnwrappedProperty()
+            _unwrappedPropertyHandler = unwrapped.initializedNestedPropertyNames();
+        } else {
+            _unwrappedPropertyHandler = null;
         }
         // may need to disable vanilla processing, if unwrapped handling was enabled...
         _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation;
@@ -1132,14 +1135,46 @@ ClassUtil.name(refName), ClassUtil.getTypeDescription(backRefType),
         return _objectIdReader;
     }
 
+    /**
+     * Accessor for checking if the POJO handled by this deserializer has given
+     *    physical property (regular or unwrapped, not including
+     *    "any properties".
+     *
+     * @param propertyName Property to check
+     *
+     * @return True if the POJO handled by this deserializer has given
+     *    physical property (regular or unwrapped); not including
+     *    "any properties"
+     */
     public boolean hasProperty(String propertyName) {
-        return _beanProperties.findDefinition(propertyName) != null;
+        // normal properties
+        if (_beanProperties.findDefinition(propertyName) != null) {
+            return true;
+        }
+        // 19-Dec-2025: [databind#650] Check unwrapped properties too.
+        if (_unwrappedPropertyHandler != null) {
+            if (_unwrappedPropertyHandler.hasUnwrappedProperty(propertyName)) {
+                return true;
+            }
+        }
+        // 19-Dec-2025: [databind#650] but should "any-setter" be considered too?
+        // if (_anySetter != null) {
+        //     return true;
+        // }
+        return false;
     }
 
     public boolean hasViews() {
         return _needViewProcesing;
     }
 
+    /**
+     * @since 3.1
+     */
+    public boolean hasAnySetter() {
+        return _anySetter != null;
+    }
+
     /**
      * Accessor for checking number of deserialized properties.
      */
@@ -1149,7 +1184,7 @@ ClassUtil.name(refName), ClassUtil.getTypeDescription(backRefType),
 
     @Override
     public Collection<Object> getKnownPropertyNames() {
-        ArrayList<Object> names = new ArrayList<Object>();
+        ArrayList<Object> names = new ArrayList<>();
         for (SettableBeanProperty prop : _beanProperties) {
             names.add(prop.getName());
         }
@@ -1164,6 +1199,23 @@ ClassUtil.name(refName), ClassUtil.getTypeDescription(backRefType),
         return names;
     }
 
+    /**
+     * Method to collect all property names including nested unwrapped properties
+     *
+     * @param names (not null) Set to add property names to; for both regular
+     *   and "any" properties.
+     *
+     * @since 3.1
+     */
+    public void collectAllPropertyNamesTo(Set<String> names) {
+        for (SettableBeanProperty prop : _beanProperties) {
+            names.add(prop.getName());
+        }
+        if (_unwrappedPropertyHandler != null) {
+            _unwrappedPropertyHandler.collectNestedPropertyNamesTo(names);
+        }
+    }
+
     @Override
     public JavaType getValueType() { return _beanType; }
 
@@ -1202,7 +1254,6 @@ ClassUtil.name(refName), ClassUtil.getTypeDescription(backRefType),
 
     public SettableBeanProperty findProperty(PropertyName propertyName)
     {
-        // TODO: start matching full name?
         return findProperty(propertyName.getSimpleName());
     }
 
@@ -1210,6 +1261,8 @@ ClassUtil.name(refName), ClassUtil.getTypeDescription(backRefType),
      * Accessor for finding the property with given name, if POJO
      * has one. Name used is the external name, i.e. name used
      * in external data representation (JSON).
+     *<p>
+     * NOTE: does NOT match "unwrapped" properties POJO contains (if any).
      */
     protected SettableBeanProperty findProperty(String propertyName)
     {
diff --git a/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java b/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java
index 9d2121636..e19f20992 100644
--- a/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java
+++ b/src/main/java/tools/jackson/databind/deser/impl/UnwrappedPropertyHandler.java
@@ -5,7 +5,9 @@ import java.util.*;
 import tools.jackson.core.*;
 import tools.jackson.databind.DeserializationContext;
 import tools.jackson.databind.PropertyName;
+import tools.jackson.databind.ValueDeserializer;
 import tools.jackson.databind.deser.SettableBeanProperty;
+import tools.jackson.databind.deser.bean.BeanDeserializerBase;
 import tools.jackson.databind.deser.bean.PropertyValueBuffer;
 import tools.jackson.databind.util.NameTransformer;
 import tools.jackson.databind.util.TokenBuffer;
@@ -28,15 +30,44 @@ public class UnwrappedPropertyHandler
     protected final List<SettableBeanProperty> _creatorProperties;
     protected final List<SettableBeanProperty> _properties;
 
-    public UnwrappedPropertyHandler()  {
+    /**
+     * Set of all nested property names from unwrapped deserializers.
+     */
+    protected final Set<String> _nestedPropertyNames;
+
+    /**
+     * Flag indicating whether any unwrapped deserializer has an AnySetter,
+     * which means it can handle any property name.
+     */
+    protected final boolean _hasNestedAnySetter;
+
+    public UnwrappedPropertyHandler() {
         _creatorProperties = new ArrayList<>();
         _properties = new ArrayList<>();
+        // placeholder: won't be modified in-place
+        _nestedPropertyNames = Collections.emptySet();
+        _hasNestedAnySetter = false;
     }
 
     protected UnwrappedPropertyHandler(List<SettableBeanProperty> creatorProps,
-            List<SettableBeanProperty> props) {
+            List<SettableBeanProperty> props,
+            Set<String> nestedPropertyNames,
+            boolean hasNestedAnySetter) {
         _creatorProperties = creatorProps;
         _properties = props;
+        _nestedPropertyNames = nestedPropertyNames;
+        _hasNestedAnySetter = hasNestedAnySetter;
+    }
+
+    /**
+     * Creates a new UnwrappedPropertyHandler with initialized nested property names cache.
+     *
+     * @since 3.1
+     */
+    public UnwrappedPropertyHandler initializedNestedPropertyNames() {
+        Set<String> nestedNames = new HashSet<>();
+        boolean hasAnySetter = _collectNestedPropertyNames(_properties, _creatorProperties, nestedNames);
+        return new UnwrappedPropertyHandler(_creatorProperties, _properties, nestedNames, hasAnySetter);
     }
 
     /**
@@ -53,10 +84,14 @@ public class UnwrappedPropertyHandler
     public UnwrappedPropertyHandler renameAll(DeserializationContext ctxt,
             NameTransformer transformer)
     {
-        return new UnwrappedPropertyHandler(
-                renameProperties(ctxt,_creatorProperties, transformer),
-                renameProperties(ctxt, _properties, transformer)
-        );
+        List<SettableBeanProperty> renamedCreatorProps = renameProperties(ctxt, _creatorProperties, transformer);
+        List<SettableBeanProperty> renamedProps = renameProperties(ctxt, _properties, transformer);
+
+        // Collect nested property names and check for AnySetter
+        Set<String> nestedNames = new HashSet<>();
+        boolean hasAnySetter = _collectNestedPropertyNames(renamedProps, renamedCreatorProps, nestedNames);
+
+        return new UnwrappedPropertyHandler(renamedCreatorProps, renamedProps, nestedNames, hasAnySetter);
     }
 
     private List<SettableBeanProperty> renameProperties(DeserializationContext ctxt,
@@ -109,4 +144,69 @@ public class UnwrappedPropertyHandler
     public static PropertyName creatorParamName(int index) {
         return new PropertyName(JSON_UNWRAPPED_NAME_PREFIX + index);
     }
+
+    /**
+     * Method that checks if the given property name belongs to any unwrapped property.
+     *
+     * @return {@code true} if any nested deserializers has an "any-setter".
+     *
+     * @since 3.1
+     */
+    public boolean hasUnwrappedProperty(String propName) {
+        // If any nested deserializer has AnySetter, it can handle any property
+        if (_hasNestedAnySetter) {
+            return true;
+        }
+        return _nestedPropertyNames.contains(propName);
+    }
+
+    /**
+     * Collects all nested property names from unwrapped deserializers.
+     *
+     * @since 3.1
+     */
+    public void collectNestedPropertyNamesTo(Set<String> names) {
+        _collectNestedPropertyNames(_properties, _creatorProperties, names);
+    }
+
+    /**
+     * Helper method to collect nested property names.
+     *
+     * @return {@code true} if any property deserializer has AnySetter.
+     *
+     * @since 3.1
+     */
+    private boolean _collectNestedPropertyNames(List<SettableBeanProperty> properties,
+            List<SettableBeanProperty> creatorProperties,
+            Set<String> names) {
+        boolean hasAnySetter = false;
+        for (SettableBeanProperty prop : properties) {
+            if (_collectDeserializerPropertyNames(prop, names)) {
+                hasAnySetter = true;
+            }
+        }
+        for (SettableBeanProperty prop : creatorProperties) {
+            if (_collectDeserializerPropertyNames(prop, names)) {
+                hasAnySetter = true;
+            }
+        }
+        return hasAnySetter;
+    }
+
+    /**
+     * Helper method to collect property names from a property's deserializer.
+     *
+     * @return {@code true} if the property deserializer has AnySetter.
+     */
+    private boolean _collectDeserializerPropertyNames(SettableBeanProperty prop, Set<String> names) {
+        if (prop != null) {
+            ValueDeserializer<?> deser = prop.getValueDeserializer();
+            if (deser instanceof BeanDeserializerBase bd) {
+                // Recursively collect property names
+                bd.collectAllPropertyNamesTo(names);
+                return bd.hasAnySetter();
+            }
+        }
+        return false;
+    }
 }
