diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt
index 3a9aa470..eedd2f88 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/TargetType.kt
@@ -182,7 +182,7 @@ internal data class TargetType(
       for (property in classProto.propertyList) {
         val name = nameResolver.getString(property.name)
         val type = typeResolver.resolve(property.returnType.asTypeName(
-            nameResolver, classProto::getTypeParameter, true))
+            nameResolver, classProto::getTypeParameter, false))
         result[name] = TargetProperty(name, type, property, constructor.parameters[name],
             annotationHolders[name], fields[name], setters[name], getters[name])
       }
@@ -207,7 +207,7 @@ internal data class TargetType(
         TypeVariableName(
             name = nameResolver.getString(it.name),
             bounds = *(it.upperBoundList
-                .map { it.asTypeName(nameResolver, proto::getTypeParameter) }
+                .map { it.asTypeName(nameResolver, proto::getTypeParameter, false) }
                 .toTypedArray()),
             variance = it.varianceModifier)
             .reified(it.reified)
diff --git a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
index 59936f74..f224e323 100644
--- a/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
+++ b/kotlin/codegen/src/main/java/com/squareup/moshi/kotlin/codegen/metadata.kt
@@ -61,30 +61,30 @@ internal fun TypeParameter.Variance.asKModifier(): KModifier? {
 internal fun Type.asTypeName(
   nameResolver: NameResolver,
   getTypeParameter: (index: Int) -> TypeParameter,
-  resolveAliases: Boolean = false
+  useAbbreviatedType: Boolean = true
 ): TypeName {
 
   val argumentList = when {
-    hasAbbreviatedType() -> abbreviatedType.argumentList
+    useAbbreviatedType && hasAbbreviatedType() -> abbreviatedType.argumentList
     else -> argumentList
   }
 
   if (hasFlexibleUpperBound()) {
     return WildcardTypeName.subtypeOf(
-        flexibleUpperBound.asTypeName(nameResolver, getTypeParameter, resolveAliases))
+        flexibleUpperBound.asTypeName(nameResolver, getTypeParameter, useAbbreviatedType))
         .asNullableIf(nullable)
   } else if (hasOuterType()) {
     return WildcardTypeName.supertypeOf(
-        outerType.asTypeName(nameResolver, getTypeParameter, resolveAliases))
+        outerType.asTypeName(nameResolver, getTypeParameter, useAbbreviatedType))
         .asNullableIf(nullable)
   }
 
   val realType = when {
     hasTypeParameter() -> return getTypeParameter(typeParameter)
-        .asTypeName(nameResolver, getTypeParameter, resolveAliases)
+        .asTypeName(nameResolver, getTypeParameter, useAbbreviatedType)
         .asNullableIf(nullable)
     hasTypeParameterName() -> typeParameterName
-    hasAbbreviatedType() && !resolveAliases -> abbreviatedType.typeAliasName
+    useAbbreviatedType && hasAbbreviatedType() -> abbreviatedType.typeAliasName
     else -> className
   }
 
@@ -98,7 +98,7 @@ internal fun Type.asTypeName(
         argumentType.projection
       } else null
       if (argumentType.hasType()) {
-        argumentType.type.asTypeName(nameResolver, getTypeParameter, resolveAliases)
+        argumentType.type.asTypeName(nameResolver, getTypeParameter, useAbbreviatedType)
             .let { argumentTypeName ->
               nullableProjection?.let { projection ->
                 when (projection) {
