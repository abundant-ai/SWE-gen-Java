diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 7628370c..8f8878fa 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -34,6 +34,7 @@ import javax.annotation.CheckReturnValue;
 import javax.annotation.Nullable;
 
 import static com.squareup.moshi.internal.Util.canonicalize;
+import static com.squareup.moshi.internal.Util.removeSubtypeWildcard;
 import static com.squareup.moshi.internal.Util.typeAnnotatedWithAnnotations;
 
 /**
@@ -112,7 +113,7 @@ public final class Moshi {
       throw new NullPointerException("annotations == null");
     }
 
-    type = canonicalize(type);
+    type = removeSubtypeWildcard(canonicalize(type));
 
     // If there's an equivalent adapter in the cache, we're done!
     Object cacheKey = cacheKey(type, annotations);
@@ -158,7 +159,7 @@ public final class Moshi {
       Set<? extends Annotation> annotations) {
     if (annotations == null) throw new NullPointerException("annotations == null");
 
-    type = canonicalize(type);
+    type = removeSubtypeWildcard(canonicalize(type));
 
     int skipPastIndex = factories.indexOf(skipPast);
     if (skipPastIndex == -1) {
diff --git a/moshi/src/main/java/com/squareup/moshi/internal/Util.java b/moshi/src/main/java/com/squareup/moshi/internal/Util.java
index 2aff94c4..572c998f 100644
--- a/moshi/src/main/java/com/squareup/moshi/internal/Util.java
+++ b/moshi/src/main/java/com/squareup/moshi/internal/Util.java
@@ -139,6 +139,21 @@ public final class Util {
     }
   }
 
+  /**
+   * If type is a "? extends X" wildcard, returns X; otherwise returns type unchanged.
+   */
+  public static Type removeSubtypeWildcard(Type type) {
+    if (!(type instanceof WildcardType)) return type;
+
+    Type[] lowerBounds = ((WildcardType) type).getLowerBounds();
+    if (lowerBounds.length != 0) return type;
+
+    Type[] upperBounds = ((WildcardType) type).getUpperBounds();
+    if (upperBounds.length != 1) throw new IllegalArgumentException();
+
+    return upperBounds[0];
+  }
+
   public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {
     // This implementation is made a little more complicated in an attempt to avoid object-creation.
     while (true) {
