diff --git a/config/accepted-api-changes.json b/config/accepted-api-changes.json
index c0bcfba0cb..b102fcb027 100644
--- a/config/accepted-api-changes.json
+++ b/config/accepted-api-changes.json
@@ -1096,35 +1096,5 @@
   {
     "type": "io.micronaut.http.server.netty.jackson.$JsonHttpContentSubscriberFactory$Definition",
     "reason": "Internal class removed"
-  },
-  {
-    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
-    "member": "Field RAW",
-    "reason": "Deprecated internal type"
-  },
-  {
-    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
-    "member": "Field NORMALIZED",
-    "reason": "Deprecated internal type"
-  },
-  {
-    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
-    "member": "Field GENERATED",
-    "reason": "Deprecated internal type"
-  },
-  {
-    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
-    "member": "Implemented interface java.lang.constant.Constable",
-    "reason": "Deprecated internal type"
-  },
-  {
-    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
-    "member": "Implemented interface java.lang.Comparable",
-    "reason": "Deprecated internal type"
-  },
-  {
-    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
-    "member": "Implemented interface java.io.Serializable",
-    "reason": "Deprecated internal type"
   }
 ]
diff --git a/core/src/main/java/io/micronaut/core/annotation/AnnotationUtil.java b/core/src/main/java/io/micronaut/core/annotation/AnnotationUtil.java
index b3cbdd6d35..0c2e7f52e4 100644
--- a/core/src/main/java/io/micronaut/core/annotation/AnnotationUtil.java
+++ b/core/src/main/java/io/micronaut/core/annotation/AnnotationUtil.java
@@ -135,11 +135,6 @@ public class AnnotationUtil {
      */
     public static final String ANN_INTRODUCTION = "io.micronaut.aop.Introduction";
 
-    /**
-     * The adapter annotation type.
-     */
-    public static final String ANN_ADAPTER = "io.micronaut.aop.Adapter";
-
     /**
      * Name of the interceptor binding type.
      */
diff --git a/core/src/main/java/io/micronaut/core/type/TypeInformation.java b/core/src/main/java/io/micronaut/core/type/TypeInformation.java
index 1ba0aa7dc4..c0affd367a 100644
--- a/core/src/main/java/io/micronaut/core/type/TypeInformation.java
+++ b/core/src/main/java/io/micronaut/core/type/TypeInformation.java
@@ -15,13 +15,9 @@
  */
 package io.micronaut.core.type;
 
-import io.micronaut.core.annotation.AnnotationMetadata;
 import io.micronaut.core.annotation.AnnotationMetadataProvider;
-import io.micronaut.core.annotation.AnnotationUtil;
 import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.reflect.ReflectionUtils;
-import io.micronaut.core.util.AnsiColour;
 import io.micronaut.core.util.ArrayUtils;
 
 import java.lang.reflect.ParameterizedType;
@@ -36,16 +32,15 @@ import java.util.stream.Collectors;
 /**
  * Provides information about a type at runtime.
  *
- * @param <T> The generic type
  * @author graemerocher
+ * @param <T> The generic type
  * @since 2.4.0
  */
 public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMetadataProvider, Type {
     /**
      * @return The type
      */
-    @NonNull
-    Class<T> getType();
+    @NonNull Class<T> getType();
 
     /**
      * @return Is the type primitive.
@@ -57,7 +52,6 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * If the type is primitive returns the wrapper type, otherwise returns the actual type.
-     *
      * @return The wrapper type if primitive
      */
     default Class<?> getWrapperType() {
@@ -74,7 +68,7 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
         Argument<?>[] typeParameters = getTypeParameters();
         if (ArrayUtils.isNotEmpty(typeParameters)) {
             String typeName = getType().getTypeName();
-            return typeName + "<" + Arrays.stream(typeParameters).map(Argument::getTypeName).collect(Collectors.joining(",")) + ">";
+            return typeName +  "<" + Arrays.stream(typeParameters).map(Argument::getTypeName).collect(Collectors.joining(",")) + ">";
         } else {
             return getType().getTypeName();
         }
@@ -100,7 +94,6 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * Returns the wrapped type in the case where {@link #isWrapperType()} returns true.
-     *
      * @return The wrapped type
      */
     default Argument<?> getWrappedType() {
@@ -137,7 +130,7 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
      */
     default boolean isContainerType() {
         final Class<T> type = getType();
-        return Map.class == type || DefaultArgument.CONTAINER_TYPES.contains(type.getName());
+        return Map.class == type ||  DefaultArgument.CONTAINER_TYPES.contains(type.getName());
     }
 
     /**
@@ -154,35 +147,19 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
      * @return The type string representation
      */
     default String getTypeString(boolean simple) {
-        return getTypeString(simple ? TypeFormat.SIMPLE : TypeFormat.QUALIFIED);
-    }
-
-    /**
-     * Similar to {@link #getTypeString(TypeFormat)} but includes any scopes and qualifiers.
-     *
-     * @param format The format
-     * @return The type string including the scope and qualifier
-     * @see #getTypeString(TypeFormat)
-     */
-    default String getBeanTypeString(@NonNull TypeFormat format) {
-        return TypeFormat.getBeanTypeString(
-            format,
-            getType(),
-            getTypeVariables(),
-            getAnnotationMetadata()
-        );
-    }
-
-    /**
-     * Returns the string representation of the argument type, including generics.
-     *
-     * @param format The format.
-     * @return The type string representation
-     * @since 4.8.0
-     */
-    default @NonNull String getTypeString(@NonNull TypeFormat format) {
         Class<T> type = getType();
-        return TypeFormat.getTypeString(format, type, getTypeVariables());
+        StringBuilder returnType = new StringBuilder(simple ? type.getSimpleName() : type.getName());
+        Map<String, Argument<?>> generics = getTypeVariables();
+        if (!generics.isEmpty()) {
+            returnType
+                    .append("<")
+                    .append(generics.values()
+                            .stream()
+                            .map(arg -> arg.getTypeString(simple))
+                            .collect(Collectors.joining(", ")))
+                    .append(">");
+        }
+        return returnType.toString();
     }
 
     /**
@@ -227,7 +204,6 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * Represent this argument as a {@link Type}.
-     *
      * @return The {@link Type}
      * @since 3.5.2
      */
@@ -240,7 +216,6 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * Represent this argument as a {@link ParameterizedType}.
-     *
      * @return The {@link ParameterizedType}
      * @since 2.0.0
      */
@@ -301,7 +276,6 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * Obtains the type's simple name.
-     *
      * @return The simple name
      * @since 3.0.0
      */
@@ -310,193 +284,11 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
     }
 
     default boolean isProvider() {
-        for (String type : DefaultArgument.PROVIDER_TYPES) {
+        for (String type: DefaultArgument.PROVIDER_TYPES) {
             if (getType().getName().equals(type)) {
                 return true;
             }
         }
         return false;
     }
-
-    /**
-     * Type formatting to apply.
-     *
-     * @see TypeInformation#getTypeString(boolean)
-     * @since 4.8.0
-     */
-    enum TypeFormat {
-        /**
-         * Simple format.
-         */
-        SIMPLE,
-        /**
-         * Qualified format.
-         */
-        QUALIFIED,
-        /**
-         * Shorted format.
-         */
-        SHORTENED,
-        /**
-         * Simple name highlighted wit ANSI.
-         */
-        ANSI_SIMPLE,
-        /**
-         * Qualified name highlighted with ANSI.
-         */
-        ANSI_QUALIFIED,
-        /**
-         * Shortened name highlighted with ANSI.
-         */
-        ANSI_SHORTENED;
-
-        private static final String ANN_CR = "io.micronaut.context.annotation.ConfigurationReader";
-
-        /**
-         * Obtain the bean type string.
-         *
-         * @param typeFormat The type format
-         * @param argument   The argument
-         * @return The string
-         */
-        public static @NonNull String getBeanTypeString(
-            @NonNull TypeInformation.TypeFormat typeFormat, @NonNull Argument<?> argument) {
-            return getBeanTypeString(
-                typeFormat,
-                argument.getType(),
-                argument.getTypeVariables(),
-                argument.getAnnotationMetadata()
-            );
-        }
-
-        /**
-         * @return Is an ANSI format.
-         */
-        public boolean isAnsi() {
-            return this == ANSI_SIMPLE ||
-                this == ANSI_QUALIFIED ||
-                this == ANSI_SHORTENED;
-        }
-
-        /**
-         * Format the annotation name.
-         *
-         * @param annotationRef The type name
-         * @return The annotation
-         */
-        public String formatAnnotation(String annotationRef) {
-            int i = annotationRef.indexOf("(");
-            String members = i > -1 ? annotationRef.substring(i) : "";
-            annotationRef = i > -1 ? annotationRef.substring(0, i) : annotationRef;
-            return switch (this) {
-                case SIMPLE -> "@" + NameUtils.getSimpleName(annotationRef) + members;
-                case QUALIFIED -> "@" + annotationRef + members;
-                case SHORTENED -> "@" + NameUtils.getShortenedName(annotationRef) + members;
-                case ANSI_SIMPLE ->
-                    AnsiColour.yellow("@" + NameUtils.getSimpleName(annotationRef)) + members;
-                case ANSI_QUALIFIED -> AnsiColour.yellow("@" + annotationRef) + members;
-                case ANSI_SHORTENED ->
-                    AnsiColour.yellow("@" + NameUtils.getShortenedName(annotationRef)) + members;
-            };
-        }
-
-        /**
-         * Get a type string for the given format.
-         *
-         * @param format   The format
-         * @param type     The type
-         * @param generics The generics
-         * @return the type string
-         */
-        public static @NonNull String getTypeString(
-            @NonNull TypeFormat format,
-            @NonNull Class<?> type,
-            @NonNull Map<String, Argument<?>> generics) {
-            String typeName = switch (format) {
-                case SIMPLE -> type.getSimpleName();
-                case QUALIFIED -> type.getCanonicalName();
-                case SHORTENED -> NameUtils.getShortenedName(type.getTypeName());
-                case ANSI_SIMPLE -> AnsiColour.cyan(type.getSimpleName());
-                case ANSI_QUALIFIED -> AnsiColour.cyan(type.getCanonicalName());
-                case ANSI_SHORTENED ->
-                    AnsiColour.cyan(NameUtils.getShortenedName(type.getCanonicalName()));
-            };
-            StringBuilder returnType = new StringBuilder(typeName);
-            if (!generics.isEmpty()) {
-                returnType
-                    .append(format.isAnsi() ? AnsiColour.brightCyan("<") : "<")
-                    .append(generics.values()
-                        .stream()
-                        .map(arg -> arg.getTypeString(format))
-                        .collect(Collectors.joining(", ")))
-                    .append(format.isAnsi() ? AnsiColour.brightCyan(">") : ">");
-            }
-            return returnType.toString();
-        }
-
-        /**
-         * Get a type string for the given format.
-         *
-         * @param format             The format
-         * @param type               The type
-         * @param generics           The generics
-         * @param annotationMetadata The annotation metadata
-         * @return the type string
-         */
-        public static @NonNull String getBeanTypeString(
-            @NonNull TypeFormat format,
-            @NonNull Class<?> type,
-            @NonNull Map<String, Argument<?>> generics,
-            @NonNull AnnotationMetadata annotationMetadata) {
-            String typeFormat = TypeFormat.getTypeString(
-                format,
-                type,
-                generics
-            );
-            Optional<String> q = annotationMetadata.getAnnotationNameByStereotype(AnnotationUtil.QUALIFIER)
-                .map(qualifier -> {
-                    if (AnnotationUtil.NAMED.equals(qualifier)) {
-                        String name = annotationMetadata.stringValue(AnnotationUtil.NAMED).orElse(null);
-                        if (name != null) {
-                            if (format.isAnsi()) {
-                                return qualifier + "(" + AnsiColour.green("\"" + name + "\"") + ")";
-                            } else {
-                                return qualifier + "(\"" + name + "\")";
-                            }
-                        }
-                    }
-                    return qualifier;
-                });
-            Optional<String> s = annotationMetadata.getAnnotationNameByStereotype(AnnotationUtil.SCOPE)
-                .map(scope -> {
-                    if (AnnotationUtil.SINGLETON.equals(scope)) {
-                        // handle case where @Singleton is used as a meta annotation
-                        scope = annotationMetadata.getAnnotationNameByStereotype(scope)
-                            .orElse(scope);
-                        String configuration = annotationMetadata.stringValue(
-                                ANN_CR,
-                                "prefix"
-                            )
-                            .orElse(null);
-                        if (configuration != null) {
-                            if (format.isAnsi()) {
-                                scope = scope + "(" + AnsiColour.green("\"" + configuration + "\"") + ")";
-                            } else {
-                                scope = scope + "(\"" + configuration + "\")";
-                            }
-                        }
-                    }
-                    return scope;
-                });
-            if (s.isPresent()) {
-                typeFormat = format.formatAnnotation(s.get()) + " " + typeFormat;
-            }
-            if (q.isPresent()) {
-                typeFormat = format.formatAnnotation(q.get()) + " " + typeFormat;
-            }
-            return typeFormat;
-        }
-    }
-
-
 }
diff --git a/core/src/main/java/io/micronaut/core/util/AnsiColour.java b/core/src/main/java/io/micronaut/core/util/AnsiColour.java
deleted file mode 100644
index 7167becfda..0000000000
--- a/core/src/main/java/io/micronaut/core/util/AnsiColour.java
+++ /dev/null
@@ -1,240 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.core.util;
-
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
-
-/**
- * Ansi color coding.
- *
- * @since 4.8.0
- */
-public enum AnsiColour {
-    //Color end string, color reset
-    RESET("\033[0m"),
-
-    // Regular Colors. Normal color, no bold, background color etc.
-    BLACK("\033[0;30m"),    // BLACK
-    RED("\033[0;31m"),      // RED
-    GREEN("\033[0;32m"),    // GREEN
-    YELLOW("\033[0;33m"),   // YELLOW
-    BLUE("\033[0;34m"),     // BLUE
-    MAGENTA("\033[0;35m"),  // MAGENTA
-    CYAN("\033[0;36m"),     // CYAN
-    WHITE("\033[0;37m"),    // WHITE
-
-    // Bold
-    BLACK_BOLD("\033[1;30m"),   // BLACK
-    RED_BOLD("\033[1;31m"),     // RED
-    GREEN_BOLD("\033[1;32m"),   // GREEN
-    YELLOW_BOLD("\033[1;33m"),  // YELLOW
-    BLUE_BOLD("\033[1;34m"),    // BLUE
-    MAGENTA_BOLD("\033[1;35m"), // MAGENTA
-    CYAN_BOLD("\033[1;36m"),    // CYAN
-    WHITE_BOLD("\033[1;37m"),   // WHITE
-
-    // Underline
-    BLACK_UNDERLINED("\033[4;30m"),     // BLACK
-    RED_UNDERLINED("\033[4;31m"),       // RED
-    GREEN_UNDERLINED("\033[4;32m"),     // GREEN
-    YELLOW_UNDERLINED("\033[4;33m"),    // YELLOW
-    BLUE_UNDERLINED("\033[4;34m"),      // BLUE
-    MAGENTA_UNDERLINED("\033[4;35m"),   // MAGENTA
-    CYAN_UNDERLINED("\033[4;36m"),      // CYAN
-    WHITE_UNDERLINED("\033[4;37m"),     // WHITE
-
-    // Background
-    BLACK_BACKGROUND("\033[40m"),   // BLACK
-    RED_BACKGROUND("\033[41m"),     // RED
-    GREEN_BACKGROUND("\033[42m"),   // GREEN
-    YELLOW_BACKGROUND("\033[43m"),  // YELLOW
-    BLUE_BACKGROUND("\033[44m"),    // BLUE
-    MAGENTA_BACKGROUND("\033[45m"), // MAGENTA
-    CYAN_BACKGROUND("\033[46m"),    // CYAN
-    WHITE_BACKGROUND("\033[47m"),   // WHITE
-
-    // High Intensity
-    BLACK_BRIGHT("\033[0;90m"),     // BLACK
-    RED_BRIGHT("\033[0;91m"),       // RED
-    GREEN_BRIGHT("\033[0;92m"),     // GREEN
-    YELLOW_BRIGHT("\033[0;93m"),    // YELLOW
-    BLUE_BRIGHT("\033[0;94m"),      // BLUE
-    MAGENTA_BRIGHT("\033[0;95m"),   // MAGENTA
-    CYAN_BRIGHT("\033[0;96m"),      // CYAN
-    WHITE_BRIGHT("\033[0;97m"),     // WHITE
-
-    // Bold High Intensity
-    BLACK_BOLD_BRIGHT("\033[1;90m"),    // BLACK
-    RED_BOLD_BRIGHT("\033[1;91m"),      // RED
-    GREEN_BOLD_BRIGHT("\033[1;92m"),    // GREEN
-    YELLOW_BOLD_BRIGHT("\033[1;93m"),   // YELLOW
-    BLUE_BOLD_BRIGHT("\033[1;94m"),     // BLUE
-    MAGENTA_BOLD_BRIGHT("\033[1;95m"),  // MAGENTA
-    CYAN_BOLD_BRIGHT("\033[1;96m"),     // CYAN
-    WHITE_BOLD_BRIGHT("\033[1;97m"),    // WHITE
-
-    // High Intensity backgrounds
-    BLACK_BACKGROUND_BRIGHT("\033[0;100m"),     // BLACK
-    RED_BACKGROUND_BRIGHT("\033[0;101m"),       // RED
-    GREEN_BACKGROUND_BRIGHT("\033[0;102m"),     // GREEN
-    YELLOW_BACKGROUND_BRIGHT("\033[0;103m"),    // YELLOW
-    BLUE_BACKGROUND_BRIGHT("\033[0;104m"),      // BLUE
-    MAGENTA_BACKGROUND_BRIGHT("\033[0;105m"),   // MAGENTA
-    CYAN_BACKGROUND_BRIGHT("\033[0;106m"),      // CYAN
-    WHITE_BACKGROUND_BRIGHT("\033[0;107m");     // WHITE
-
-    private final String code;
-
-    AnsiColour(String code) {
-        this.code = code;
-    }
-
-    /**
-     * Highlight cyan if supported.
-     * @param text The text
-     * @return the string
-     */
-    public static String cyan(String text) {
-        if (isSupported()) {
-            return AnsiColour.CYAN + text + AnsiColour.RESET;
-        } else {
-            return text;
-        }
-    }
-
-    /**
-     * Highlight bright cyan if supported.
-     * @param text The text
-     * @return the string
-     */
-    public static String brightCyan(String text) {
-        if (isSupported()) {
-            return AnsiColour.CYAN_BRIGHT + text + AnsiColour.RESET;
-        } else {
-            return text;
-        }
-    }
-
-    /**
-     * Highlight in yellow.
-     * @param text The text
-     * @return The formatted string
-     */
-    public static String yellow(@NonNull String text) {
-        if (isSupported()) {
-            return AnsiColour.YELLOW + text + AnsiColour.RESET;
-        } else {
-            return text;
-        }
-    }
-
-    /**
-     * Highlight in bright blue.
-     * @param text The text
-     * @return The formatted string
-     */
-    public static String brightBlue(String text) {
-        if (isSupported()) {
-            return AnsiColour.BLUE_BRIGHT + text + AnsiColour.RESET;
-        } else {
-            return text;
-        }
-    }
-
-    /**
-     * Output in magenta bold.
-     * @param text The text
-     * @return The formatted text.
-     */
-    public static String magentaBold(String text) {
-        if (isSupported()) {
-            return AnsiColour.MAGENTA_BOLD + text + AnsiColour.RESET;
-        } else {
-            return text;
-        }
-    }
-
-    /**
-     * Output green.
-     * @param text The text
-     * @return The formatted text
-     */
-    public static String green(String text) {
-        if (isSupported()) {
-            return AnsiColour.GREEN + text + AnsiColour.RESET;
-        } else {
-            return text;
-        }
-    }
-
-    /**
-     * Output bright yellow.
-     * @param text The text
-     * @return The formatted text
-     */
-    public static String brightYellow(String text) {
-        if (isSupported()) {
-            return AnsiColour.YELLOW_BRIGHT + text + AnsiColour.RESET;
-        } else {
-            return text;
-        }
-    }
-
-    /**
-     * Format an object for display.
-     * @param object The object
-     * @return The formatted object
-     */
-    public static @NonNull String formatObject(@Nullable Object object) {
-        if (object instanceof CharSequence charSequence) {
-            return green("\"" + charSequence + "\"");
-        } else if (object instanceof Number number) {
-            return brightBlue(number.toString());
-        } else if (object == null) {
-            return brightBlue("null");
-        } else {
-            return brightYellow(object.toString());
-        }
-    }
-
-    /**
-     * Format blue.
-     * @param text The text
-     * @return The formatted text
-     */
-    public static @NonNull String blue(@NonNull String text) {
-        if (isSupported()) {
-            return AnsiColour.BLUE + text + AnsiColour.RESET;
-        } else {
-            return text;
-        }
-    }
-
-    @Override
-    public String toString() {
-        return code;
-    }
-
-    /**
-     * Are ANSI colors supported.
-     * @return True if they are
-     */
-    public static boolean isSupported() {
-        String os = System.getProperty("os.name").toLowerCase();
-        return !os.contains("win") || System.console() != null;
-    }
-}
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/ConstructorCircularDependencyFailureSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/ConstructorCircularDependencyFailureSpec.groovy
index 07f4a78fee..9dcec01c61 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/ConstructorCircularDependencyFailureSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/ConstructorCircularDependencyFailureSpec.groovy
@@ -40,9 +40,9 @@ Failed to inject value for field [propA] of class: io.micronaut.inject.failures.
 
 Message: Circular dependency detected
 Path Taken:
-new @j.i.Singleton i.m.i.f.C$MyClassB()
-      \\---> @j.i.Singleton i.m.i.f.C$MyClassB#propA
-            ^  \\---> new @j.i.Singleton i.m.i.f.C$MyClassA([MyClassC propC])
+new i.m.i.f.C$MyClassB()
+      \\---> i.m.i.f.C$MyClassB#propA
+            ^  \\---> new i.m.i.f.C$MyClassA([MyClassC propC])
             |        \\---> new i.m.i.f.C$MyClassC([MyClassB propB])
             |              |
             +--------------+'''
@@ -65,10 +65,10 @@ Failed to inject value for field [propA] of class: io.micronaut.inject.failures.
 
 Message: Circular dependency detected
 Path Taken:
-new @j.i.Singleton i.m.i.f.C$MyClassD(MyClassB propB)
-      \\---> new @j.i.Singleton i.m.i.f.C$MyClassD([MyClassB propB])
-            \\---> @j.i.Singleton i.m.i.f.C$MyClassB#propA
-                  ^  \\---> new @j.i.Singleton i.m.i.f.C$MyClassA([MyClassC propC])
+new i.m.i.f.C$MyClassD(MyClassB propB)
+      \\---> new i.m.i.f.C$MyClassD([MyClassB propB])
+            \\---> i.m.i.f.C$MyClassB#propA
+                  ^  \\---> new i.m.i.f.C$MyClassA([MyClassC propC])
                   |        \\---> new i.m.i.f.C$MyClassC([MyClassB propB])
                   |              |
                   +--------------+'''
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/ConstructorExceptionSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/ConstructorExceptionSpec.groovy
index a0b6117f93..ac56564f80 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/ConstructorExceptionSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/ConstructorExceptionSpec.groovy
@@ -42,7 +42,7 @@ Message: bad
 Path Taken:
 new i.m.i.f.C$MyClassB()
 \\---> i.m.i.f.C$MyClassB#propA
-      \\---> new @j.i.Singleton i.m.i.f.C$MyClassA([MyClassC propC])'''
+      \\---> new i.m.i.f.C$MyClassA([MyClassC propC])'''
 
         cleanup:
         context.close()
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FactoryCircularDependencyFailureSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FactoryCircularDependencyFailureSpec.groovy
index 9ed409f5ea..6db5e278e5 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FactoryCircularDependencyFailureSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FactoryCircularDependencyFailureSpec.groovy
@@ -40,10 +40,10 @@ Failed to inject value for parameter [stations] of class: io.micronaut.inject.fa
 
 Message: Circular dependency detected
 Path Taken:
-new i.m.i.f.F$ElectricalGrid(List<ElectricStation> stations)
-      \\---> new i.m.i.f.F$ElectricalGrid([List<ElectricStation> stations])
-            ^  \\---> @j.i.Singleton i.m.i.f.F$ElectricStation i.m.i.f.F$ElectricStationFactory.nuclearStation#nuclearStation([MeasuringEquipment equipment])
-            |        \\---> @j.i.Singleton i.m.i.f.F$MeasuringEquipment#grid
+new i.m.i.f.F$ElectricalGrid(List<ElectricStation E> stations)
+      \\---> new i.m.i.f.F$ElectricalGrid([List<ElectricStation E> stations])
+            ^  \\---> i.m.i.f.F$ElectricStationFactory#nuclearStation([MeasuringEquipment equipment])
+            |        \\---> i.m.i.f.F$MeasuringEquipment#grid
             |              |
             +--------------+'''
 
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FactoryDependencyFailureSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FactoryDependencyFailureSpec.groovy
index d212d35b41..844182feb3 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FactoryDependencyFailureSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FactoryDependencyFailureSpec.groovy
@@ -41,9 +41,9 @@ Error instantiating bean of type  [io.micronaut.inject.failures.FactoryDependenc
 
 Message: Outdated equipment
 Path Taken:
-new i.m.i.f.F$ElectricalGrid(List<ElectricStation> stations)
-\\---> new i.m.i.f.F$ElectricalGrid([List<ElectricStation> stations])
-      \\---> @j.i.Singleton i.m.i.f.F$ElectricStation i.m.i.f.F$ElectricStationFactory.nuclearStation#nuclearStation([MeasuringEquipment equipment])'''
+new i.m.i.f.F$ElectricalGrid(List<ElectricStation E> stations)
+\\---> new i.m.i.f.F$ElectricalGrid([List<ElectricStation E> stations])
+      \\---> i.m.i.f.F$ElectricStationFactory#nuclearStation([MeasuringEquipment equipment])'''
 
         cleanup:
         context.close()
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FieldCircularDependencyFailureSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FieldCircularDependencyFailureSpec.groovy
index 5d98877b96..a50e3238fc 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FieldCircularDependencyFailureSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/FieldCircularDependencyFailureSpec.groovy
@@ -40,9 +40,9 @@ Failed to inject value for field [propA] of class: io.micronaut.inject.failures.
 
 Message: Circular dependency detected
 Path Taken:
-new @j.i.Singleton i.m.i.f.F$MyClassB()
-      \\---> @j.i.Singleton i.m.i.f.F$MyClassB#propA
-            ^  \\---> new @j.i.Singleton i.m.i.f.F$MyClassA([MyClassC propC])
+new i.m.i.f.F$MyClassB()
+      \\---> i.m.i.f.F$MyClassB#propA
+            ^  \\---> new i.m.i.f.F$MyClassA([MyClassC propC])
             |        \\---> i.m.i.f.F$MyClassC#propB
             |              |
             +--------------+'''
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/NestedDependencyFailureSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/NestedDependencyFailureSpec.groovy
index 5bf6082c09..0fe100aba5 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/NestedDependencyFailureSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/NestedDependencyFailureSpec.groovy
@@ -43,8 +43,8 @@ Message: No bean of type [io.micronaut.inject.failures.NestedDependencyFailureSp
 Path Taken:$space
 new i.m.i.f.N\$MyClassB()
 \\---> i.m.i.f.N\$MyClassB#propA
-      \\---> new @j.i.Singleton i.m.i.f.N\$MyClassA([MyClassC propC])
-            \\---> new @j.i.Singleton i.m.i.f.N\$MyClassC([MyClassD propD])"""
+      \\---> new i.m.i.f.N\$MyClassA([MyClassC propC])
+            \\---> new i.m.i.f.N\$MyClassC([MyClassD propD])"""
 
         cleanup:
         context.close()
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/PostConstructExceptionSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/PostConstructExceptionSpec.groovy
index ae4a8cc4fc..622308c7be 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/PostConstructExceptionSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/PostConstructExceptionSpec.groovy
@@ -41,7 +41,7 @@ Error instantiating bean of type  [io.micronaut.inject.failures.PostConstructExc
 
 Message: bad
 Path Taken:
-new @j.i.Singleton i.m.i.f.P$MyClassB()'''
+new i.m.i.f.P$MyClassB()'''
 
         cleanup:
         context.close()
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/PropertyCircularDependencyFailureSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/PropertyCircularDependencyFailureSpec.groovy
index 74a312df31..d1eab32fe8 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/failures/PropertyCircularDependencyFailureSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/failures/PropertyCircularDependencyFailureSpec.groovy
@@ -39,9 +39,9 @@ Failed to inject value for parameter [propA] of method [setPropA] of class: io.m
 
 Message: Circular dependency detected
 Path Taken:
-new @j.i.Singleton i.m.i.f.P$MyClassB()
-      \\---> @j.i.Singleton i.m.i.f.P$MyClassB#setPropA([MyClassA propA])
-            ^  \\---> @j.i.Singleton i.m.i.f.P$MyClassA#setPropB([MyClassB propB])
+new i.m.i.f.P$MyClassB()
+      \\---> i.m.i.f.P$MyClassB#setPropA([MyClassA propA])
+            ^  \\---> i.m.i.f.P$MyClassA#setPropB([MyClassB propB])
             |        |
             +--------+'''
 
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/field/FieldInjectionSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/field/FieldInjectionSpec.groovy
index c6b7ee42b7..7d2e698ca8 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/field/FieldInjectionSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/field/FieldInjectionSpec.groovy
@@ -2,7 +2,6 @@ package io.micronaut.inject.field
 
 import io.micronaut.context.ApplicationContext
 import io.micronaut.context.BeanContext
-import io.micronaut.context.BeanResolutionTraceMode
 import io.micronaut.context.annotation.Property
 import io.micronaut.context.annotation.Value
 import io.micronaut.context.exceptions.BeanContextException
@@ -16,9 +15,7 @@ class FieldInjectionSpec extends Specification {
 
     void "test bean injection via private field"() {
         given:
-        BeanContext context = ApplicationContext.builder()
-            .beanResolutionTrace(BeanResolutionTraceMode.STANDARD_OUT)
-            .start()
+        BeanContext context = ApplicationContext.run()
 
         when:"A bean is obtained that has a setter with @Inject"
         C c =  context.getBean(C)
diff --git a/inject-java/src/test/groovy/io/micronaut/aop/adapter/MethodAdapterSpec.groovy b/inject-java/src/test/groovy/io/micronaut/aop/adapter/MethodAdapterSpec.groovy
index 91dd315e13..480358c320 100644
--- a/inject-java/src/test/groovy/io/micronaut/aop/adapter/MethodAdapterSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/aop/adapter/MethodAdapterSpec.groovy
@@ -21,7 +21,6 @@ import io.micronaut.context.annotation.Requires
 import io.micronaut.context.event.ApplicationEventListener
 import io.micronaut.context.event.StartupEvent
 import io.micronaut.core.reflect.ReflectionUtils
-import io.micronaut.core.type.TypeInformation
 import io.micronaut.inject.AdvisedBeanType
 import io.micronaut.inject.BeanDefinition
 import org.atinject.jakartatck.auto.events.EventHandlerMultipleArguments
@@ -101,11 +100,9 @@ interface Parser {
 ''')
         def adaptedType = context.classLoader.loadClass('issue5054.Parser')
         def parser = context.getBean(adaptedType)
-        def beanDef = context.getBeanDefinition(adaptedType)
         def result = parser.parse("test".getBytes(StandardCharsets.US_ASCII))
 
         expect:
-        beanDef.getBeanDescription(TypeInformation.TypeFormat.SHORTENED) == '@j.i.Singleton i.AsciiParser.parseAsAscii()'
         result == 'test'
     }
 
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/beans/BeanDefinitionSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/beans/BeanDefinitionSpec.groovy
index 85230f8e34..79d56f8211 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/beans/BeanDefinitionSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/beans/BeanDefinitionSpec.groovy
@@ -8,7 +8,6 @@ import io.micronaut.core.annotation.Order
 import io.micronaut.core.reflect.ClassUtils
 import io.micronaut.core.type.Argument
 import io.micronaut.core.type.GenericPlaceholder
-import io.micronaut.core.type.TypeInformation
 import io.micronaut.inject.BeanDefinition
 import io.micronaut.inject.qualifiers.Qualifiers
 import spock.lang.Issue
@@ -16,34 +15,6 @@ import test.another.BeanWithPackagePrivate
 
 class BeanDefinitionSpec extends AbstractTypeElementSpec {
 
-    void "test getTypeString for format #format"() {
-        given:
-        def definition = buildBeanDefinition('typestring.Test', '''
-package typestring;
-
-import io.micronaut.context.annotation.*;
-import jakarta.inject.*;
-
-@Singleton
-class Test  {
-}
-
-''')
-
-        expect:
-        definition.asArgument().getTypeString(format) == result
-
-        where:
-        format                                    | result
-        TypeInformation.TypeFormat.SIMPLE         | "Test"
-        TypeInformation.TypeFormat.QUALIFIED      | "typestring.Test"
-        TypeInformation.TypeFormat.SHORTENED      | "t.Test"
-        TypeInformation.TypeFormat.ANSI_SIMPLE    | "\u001B[0;36mTest\u001B[0m"
-        TypeInformation.TypeFormat.ANSI_QUALIFIED | "\u001B[0;36mtypestring.Test\u001B[0m"
-        TypeInformation.TypeFormat.ANSI_SHORTENED | "\u001B[0;36mt.Test\u001B[0m"
-
-    }
-
     void "test limit the exposed bean types"() {
         given:
         def definition = buildBeanDefinition('limittypes.Test', '''
@@ -472,7 +443,7 @@ class TestBean {
 
     void "test deep type parameters are created in definition"() {
         given:
-        BeanDefinition definition = buildBeanDefinition('test', 'Test', '''
+        BeanDefinition definition = buildBeanDefinition('test','Test','''
 package test;
 import java.util.List;
 
@@ -499,7 +470,7 @@ public class Test {
 
     void "test annotation metadata present on deep type parameters of definition"() {
         given:
-        BeanDefinition definition = buildBeanDefinition('test', 'Test', '''
+        BeanDefinition definition = buildBeanDefinition('test','Test','''
 package test;
 import jakarta.validation.constraints.*;
 import java.util.List;
@@ -527,7 +498,7 @@ public class Test {
 
     void "test isTypeVariable"() {
         given:
-        ApplicationContext context = buildContext('''
+        ApplicationContext context = buildContext( '''
 package test;
 import jakarta.validation.constraints.*;
 import java.util.*;
@@ -562,27 +533,27 @@ class SetTest<E> implements Serde<HashSet<E>> {
 
 
         when: "Micronaut Serialization use-case"
-        def serdeTypeParam = definition.getTypeArguments("test.Serde")[0]
-        def serializerTypeParam = definition.getTypeArguments("test.Serializer")[0]
-        def deserializerTypeParam = definition.getTypeArguments("test.Deserializer")[0]
-        def listDeser = context.getBean(Argument.of(context.classLoader.loadClass('test.Deserializer'), Argument.listOf(String)))
-        def collectionDeser = context.getBean(Argument.of(context.classLoader.loadClass('test.Deserializer'), Argument.of(Collection.class, String)))
+            def serdeTypeParam = definition.getTypeArguments("test.Serde")[0]
+            def serializerTypeParam = definition.getTypeArguments("test.Serializer")[0]
+            def deserializerTypeParam = definition.getTypeArguments("test.Deserializer")[0]
+            def listDeser = context.getBean(Argument.of(context.classLoader.loadClass('test.Deserializer'), Argument.listOf(String)))
+            def collectionDeser = context.getBean(Argument.of(context.classLoader.loadClass('test.Deserializer'), Argument.of(Collection.class, String)))
 
         then: "The first is a placeholder"
-        listDeser.getClass().name == 'test.ArrayListTest'
-        listDeser.is(collectionDeser)
-        !serdeTypeParam.isTypeVariable() //
-        !(serdeTypeParam instanceof GenericPlaceholder)
+            listDeser.getClass().name == 'test.ArrayListTest'
+            listDeser.is(collectionDeser)
+            !serdeTypeParam.isTypeVariable() //
+            !(serdeTypeParam instanceof GenericPlaceholder)
         and: "threat resolved placeholder as not a type variable"
-        !serializerTypeParam.isTypeVariable()
-        !(serializerTypeParam instanceof GenericPlaceholder)
-        !deserializerTypeParam.isTypeVariable()
-        !(deserializerTypeParam instanceof GenericPlaceholder)
+            !serializerTypeParam.isTypeVariable()
+            !(serializerTypeParam instanceof GenericPlaceholder)
+            !deserializerTypeParam.isTypeVariable()
+            !(deserializerTypeParam instanceof GenericPlaceholder)
     }
 
     void "test isTypeVariable array"() {
         given:
-        BeanDefinition definition = buildBeanDefinition('test', 'Test', '''
+            BeanDefinition definition = buildBeanDefinition('test', 'Test', '''
 package test;
 import jakarta.validation.constraints.*;
 import java.util.List;
@@ -604,26 +575,26 @@ interface Deserializer<T> {
         ''')
 
         when: "Micronaut Serialization use-case"
-        def serdeTypeParam = definition.getTypeArguments("test.Serde")[0]
-        def serializerTypeParam = definition.getTypeArguments("test.Serializer")[0]
-        def deserializerTypeParam = definition.getTypeArguments("test.Deserializer")[0]
+            def serdeTypeParam = definition.getTypeArguments("test.Serde")[0]
+            def serializerTypeParam = definition.getTypeArguments("test.Serializer")[0]
+            def deserializerTypeParam = definition.getTypeArguments("test.Deserializer")[0]
         // Arrays are not resolved as JavaClassElements or placeholders
         then: "The first is a placeholder"
-        serdeTypeParam.simpleName == "String[]"
-        !serdeTypeParam.isTypeVariable()
-        !(serdeTypeParam instanceof GenericPlaceholder)
+            serdeTypeParam.simpleName == "String[]"
+            !serdeTypeParam.isTypeVariable()
+            !(serdeTypeParam instanceof GenericPlaceholder)
         and: "threat resolved placeholder as not a type variable"
-        serializerTypeParam.simpleName == "String[]"
-        !serializerTypeParam.isTypeVariable()
-        !(serializerTypeParam instanceof GenericPlaceholder)
-        deserializerTypeParam.simpleName == "String[]"
-        !deserializerTypeParam.isTypeVariable()
-        !(deserializerTypeParam instanceof GenericPlaceholder)
+            serializerTypeParam.simpleName == "String[]"
+            !serializerTypeParam.isTypeVariable()
+            !(serializerTypeParam instanceof GenericPlaceholder)
+            deserializerTypeParam.simpleName == "String[]"
+            !deserializerTypeParam.isTypeVariable()
+            !(deserializerTypeParam instanceof GenericPlaceholder)
     }
 
     void "test intercepted type arguments"() {
         given:
-        BeanDefinition definition = buildSimpleInterceptedBeanDefinition('test.AImplementationLong', '''
+            BeanDefinition definition = buildSimpleInterceptedBeanDefinition('test.AImplementationLong', '''
 package test;
 
 import io.micronaut.aop.Introduction;
@@ -693,16 +664,16 @@ interface AInterface<K, V> {
 ''')
 
         when:
-        def arguments = definition.getTypeArguments(ClassUtils.forName("test.AInterface", definition.getClass().classLoader).orElseThrow())
+            def arguments = definition.getTypeArguments(ClassUtils.forName("test.AInterface", definition.getClass().classLoader).orElseThrow())
         then:
-        arguments[0].type == Long
-        arguments[1].type == Long
+            arguments[0].type == Long
+            arguments[1].type == Long
     }
 
     void "test package-private methods with different package are marked as overridden"() {
         when:
-        def ctx = ApplicationContext.builder().build().start()
-        BeanDefinition definition = buildBeanDefinition('test.another.Test', '''
+            def ctx = ApplicationContext.builder().build().start()
+            BeanDefinition definition = buildBeanDefinition('test.another.Test', '''
 package test.another;
 
 import test.Middle;
@@ -718,79 +689,79 @@ class Test extends Middle {
 
 ''')
 
-        def bean1 = ctx.getBean(BeanWithPackagePrivate)
-        def bean2 = ctx.getBean(definition)
+            def bean1 = ctx.getBean(BeanWithPackagePrivate)
+            def bean2 = ctx.getBean(definition)
         then: """By Java rules the base method is not overridden and should have been injected too, but it's not possible to invoked using the reflection,
 so we mark it as overridden
 """
-        !bean1.@root
-        bean1.@middle
-        !bean1.@base
-        !bean2.@root
-        bean2.@middle
-        !bean2.@base
+            !bean1.@root
+            bean1.@middle
+            !bean1.@base
+            !bean2.@root
+            bean2.@middle
+            !bean2.@base
         cleanup:
-        ctx.close()
+            ctx.close()
     }
 
     void "test repeatable inner type annotation 1"() {
         when:
-        def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
-        def beanDef = ctx.getBeanDefinition(MapOfListsBean1)
+            def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
+            def beanDef = ctx.getBeanDefinition(MapOfListsBean1)
         then:
-        beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin1).isPresent()
+            beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin1).isPresent()
 
         cleanup:
-        ctx.close()
+            ctx.close()
     }
 
     void "test repeatable inner type annotation 2"() {
         when:
-        def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
-        def beanDef = ctx.getBeanDefinition(MapOfListsBean2)
+            def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
+            def beanDef = ctx.getBeanDefinition(MapOfListsBean2)
         then:
-        beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin2).isPresent()
+            beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin2).isPresent()
 
         cleanup:
-        ctx.close()
+            ctx.close()
     }
 
     void "test repeatable inner type annotation 3"() {
         when:
-        def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
-        def beanDef = ctx.getBeanDefinition(MapOfListsBean3)
+            def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
+            def beanDef = ctx.getBeanDefinition(MapOfListsBean3)
         then:
-        beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin3).isPresent()
+            beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin3).isPresent()
 
         cleanup:
-        ctx.close()
+            ctx.close()
     }
 
     void "test repeatable inner type annotation 4"() {
         when:
-        def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
-        def beanDef = ctx.getBeanDefinition(MapOfListsBean4)
+            def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
+            def beanDef = ctx.getBeanDefinition(MapOfListsBean4)
         then:
-        beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin4).isPresent()
+            beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin4).isPresent()
 
         cleanup:
-        ctx.close()
+            ctx.close()
     }
 
     void "test repeatable inner type annotation 5"() {
         when:
-        def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
-        def beanDef = ctx.getBeanDefinition(MapOfListsBean5)
+            def ctx = ApplicationContext.builder().properties(["repeatabletest": "true"]).build().start()
+            def beanDef = ctx.getBeanDefinition(MapOfListsBean5)
         then:
-        beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin5).isPresent()
+            beanDef.getAnnotationMetadata().findRepeatableAnnotation(MyMin5).isPresent()
 
         cleanup:
-        ctx.close()
+            ctx.close()
     }
 
     void "test interface bean"() {
         given:
-        def definition = buildBeanDefinition('test.MyEntityControllerInterface', '''
+            def definition = buildBeanDefinition('test.MyEntityControllerInterface', '''
 package test;
 
 import io.micronaut.http.annotation.Controller;
@@ -801,12 +772,12 @@ interface MyEntityControllerInterface {
 ''')
 
         expect:
-        definition == null
+            definition == null
     }
 
     void "test interface bean 2"() {
         given:
-        def definition = buildBeanDefinition('test.MyEntityControllerInterface', '''
+            def definition = buildBeanDefinition('test.MyEntityControllerInterface', '''
 package test;
 
 import jakarta.inject.Singleton;
@@ -817,12 +788,12 @@ interface MyEntityControllerInterface {
 ''')
 
         expect:
-        definition == null
+            definition == null
     }
 
     void "test mapped interface bean"() {
         given:
-        def definition = buildSimpleInterceptedBeanDefinition('test.ProductMappers', '''
+            def definition = buildSimpleInterceptedBeanDefinition('test.ProductMappers', '''
 package test;
 
 import io.micronaut.context.annotation.Mapper.Mapping;
@@ -860,7 +831,7 @@ record ProductDTO(String name, String price, String distributor) {
 ''')
 
         expect:
-        definition.getExecutableMethods()[0].hasDeclaredAnnotation(Mapper)
-        definition.getExecutableMethods()[0].hasDeclaredAnnotation(Mapper.Mapping)
+            definition.getExecutableMethods()[0].hasDeclaredAnnotation(Mapper)
+            definition.getExecutableMethods()[0].hasDeclaredAnnotation(Mapper.Mapping)
     }
 }
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/factory/beanfield/FactoryBeanFieldSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/factory/beanfield/FactoryBeanFieldSpec.groovy
index c28726f1ca..cba22bdeec 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/factory/beanfield/FactoryBeanFieldSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/factory/beanfield/FactoryBeanFieldSpec.groovy
@@ -4,7 +4,6 @@ import io.micronaut.annotation.processing.test.AbstractTypeElementSpec
 import io.micronaut.context.ApplicationContext
 import io.micronaut.context.annotation.Prototype
 import io.micronaut.core.annotation.AnnotationUtil
-import io.micronaut.core.type.TypeInformation
 import io.micronaut.core.util.CollectionUtils
 import io.micronaut.inject.BeanDefinition
 import io.micronaut.inject.qualifiers.Qualifiers
@@ -339,10 +338,8 @@ class TestInterceptor implements MethodInterceptor<Object, Object> {
 ''')
 
         def barBean = getBean(context, 'test.Bar')
-        def definition = context.getBeanDefinition(context.classLoader.loadClass('test.Foo'))
 
         expect:
-        definition.getBeanDescription(TypeInformation.TypeFormat.SHORTENED) == '@i.m.c.a.Primary @j.i.Singleton t.Foo t.T$TestField.one'
         barBean.test("good") == 'GOOD' // proxied
         getBean(context, "test.Foo").name == 'one'
         getBean(context, "test.Foo", Qualifiers.byName("two")).name == 'two'
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/factory/beanmethod/FactoryBeanMethodSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/factory/beanmethod/FactoryBeanMethodSpec.groovy
index 9d9d0719cd..127edaed31 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/factory/beanmethod/FactoryBeanMethodSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/factory/beanmethod/FactoryBeanMethodSpec.groovy
@@ -4,13 +4,11 @@ import io.micronaut.annotation.processing.test.AbstractTypeElementSpec
 import io.micronaut.context.ApplicationContext
 import io.micronaut.context.annotation.Prototype
 import io.micronaut.core.annotation.AnnotationUtil
-import io.micronaut.core.type.TypeInformation
 import io.micronaut.inject.BeanDefinition
 import jakarta.inject.Singleton
 
 class FactoryBeanMethodSpec extends AbstractTypeElementSpec {
 
-
     void "test a factory bean with static method or field"() {
         given:
         ApplicationContext context = buildContext('test.TestFactory', '''\
@@ -50,7 +48,7 @@ class Bar2 {
 ''')
 
         when:
-        BeanDefinition<?> bar1BeanDefinition = context.getBeanDefinitions(context.classLoader.loadClass('test.Bar1'))
+        def bar1BeanDefinition = context.getBeanDefinitions(context.classLoader.loadClass('test.Bar1'))
                 .find {it.getDeclaringType().get().simpleName.contains("TestFactory")}
 
                 .find {it.getDeclaringType().get().simpleName.contains("TestFactory")}
@@ -59,7 +57,6 @@ class Bar2 {
         def bar2 = getBean(context, 'test.Bar2')
 
         then:
-        bar1BeanDefinition.getBeanDescription(TypeInformation.TypeFormat.SHORTENED) == '@i.m.c.a.Prototype t.Bar1 t.TestFactory.bar()'
         bar1 != null
         bar2 != null
         bar1BeanDefinition.getScope().get() == Prototype.class
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/failures/ctorcirculardependency/ConstructorCircularDependencyFailureSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/failures/ctorcirculardependency/ConstructorCircularDependencyFailureSpec.groovy
index 0d25197244..591f007510 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/failures/ctorcirculardependency/ConstructorCircularDependencyFailureSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/failures/ctorcirculardependency/ConstructorCircularDependencyFailureSpec.groovy
@@ -35,9 +35,9 @@ Failed to inject value for field [propA] of class: io.micronaut.inject.failures.
 
 Message: Circular dependency detected
 Path Taken:
-new @j.i.Singleton i.m.i.f.c.MyClassB()
-      \\---> @j.i.Singleton i.m.i.f.c.MyClassB#propA
-            ^  \\---> new @j.i.Singleton i.m.i.f.c.MyClassA([MyClassC propC])
+new i.m.i.f.c.MyClassB()
+      \\---> i.m.i.f.c.MyClassB#propA
+            ^  \\---> new i.m.i.f.c.MyClassA([MyClassC propC])
             |        \\---> new i.m.i.f.c.MyClassC([MyClassB propB])
             |              |
             +--------------+'''
@@ -57,10 +57,10 @@ Failed to inject value for field [propA] of class: io.micronaut.inject.failures.
 
 Message: Circular dependency detected
 Path Taken:
-new @j.i.Singleton i.m.i.f.c.MyClassD(MyClassB propB)
-      \\---> new @j.i.Singleton i.m.i.f.c.MyClassD([MyClassB propB])
-            \\---> @j.i.Singleton i.m.i.f.c.MyClassB#propA
-                  ^  \\---> new @j.i.Singleton i.m.i.f.c.MyClassA([MyClassC propC])
+new i.m.i.f.c.MyClassD(MyClassB propB)
+      \\---> new i.m.i.f.c.MyClassD([MyClassB propB])
+            \\---> i.m.i.f.c.MyClassB#propA
+                  ^  \\---> new i.m.i.f.c.MyClassA([MyClassC propC])
                   |        \\---> new i.m.i.f.c.MyClassC([MyClassB propB])
                   |              |
                   +--------------+'''
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/failures/ctorexception/ConstructorExceptionSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/failures/ctorexception/ConstructorExceptionSpec.groovy
index d56351057c..88a2c39bc6 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/failures/ctorexception/ConstructorExceptionSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/failures/ctorexception/ConstructorExceptionSpec.groovy
@@ -38,7 +38,7 @@ Message: bad
 Path Taken:
 new i.m.i.f.c.MyClassB()
 \\---> i.m.i.f.c.MyClassB#propA
-      \\---> new @j.i.Singleton i.m.i.f.c.MyClassA([MyClassC propC])'''
+      \\---> new i.m.i.f.c.MyClassA([MyClassC propC])'''
 
         cleanup:
         context.close()
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/failures/fieldcirculardependency/FieldCircularDependencyFailureSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/failures/fieldcirculardependency/FieldCircularDependencyFailureSpec.groovy
index 4b37b63c2e..219189689d 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/failures/fieldcirculardependency/FieldCircularDependencyFailureSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/failures/fieldcirculardependency/FieldCircularDependencyFailureSpec.groovy
@@ -35,9 +35,9 @@ Failed to inject value for field [propA] of class: io.micronaut.inject.failures.
 
 Message: Circular dependency detected
 Path Taken:
-new @j.i.Singleton i.m.i.f.f.MyClassB()
-      \\---> @j.i.Singleton i.m.i.f.f.MyClassB#propA
-            ^  \\---> new @j.i.Singleton i.m.i.f.f.MyClassA([MyClassC propC])
+new i.m.i.f.f.MyClassB()
+      \\---> i.m.i.f.f.MyClassB#propA
+            ^  \\---> new i.m.i.f.f.MyClassA([MyClassC propC])
             |        \\---> i.m.i.f.f.MyClassC#propB
             |              |
             +--------------+'''
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/failures/nesteddependency/NestedDependencyFailureSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/failures/nesteddependency/NestedDependencyFailureSpec.groovy
index 2e811432b6..98e6083dc5 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/failures/nesteddependency/NestedDependencyFailureSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/failures/nesteddependency/NestedDependencyFailureSpec.groovy
@@ -39,8 +39,8 @@ Message: No bean of type [io.micronaut.inject.failures.nesteddependency.MyClassD
 Path Taken:$space
 new i.m.i.f.n.MyClassB()
 \\---> i.m.i.f.n.MyClassB#propA
-      \\---> new @j.i.Singleton i.m.i.f.n.MyClassA([MyClassC propC])
-            \\---> new @j.i.Singleton i.m.i.f.n.MyClassC([MyClassD propD])"""
+      \\---> new i.m.i.f.n.MyClassA([MyClassC propC])
+            \\---> new i.m.i.f.n.MyClassC([MyClassD propD])"""
 
         cleanup:
         context.close()
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/failures/postconstruct/PostConstructExceptionSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/failures/postconstruct/PostConstructExceptionSpec.groovy
index 49b13fb1a5..2a7b5ce323 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/failures/postconstruct/PostConstructExceptionSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/failures/postconstruct/PostConstructExceptionSpec.groovy
@@ -35,7 +35,7 @@ Error instantiating bean of type  [io.micronaut.inject.failures.postconstruct.My
 
 Message: bad
 Path Taken:
-new @j.i.Singleton i.m.i.f.p.MyClassB()'''
+new i.m.i.f.p.MyClassB()'''
 
         cleanup:
         context.close()
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/field/simpleinjection/FieldInjectionSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/field/simpleinjection/FieldInjectionSpec.groovy
index 9779796380..b6fdcb65be 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/field/simpleinjection/FieldInjectionSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/field/simpleinjection/FieldInjectionSpec.groovy
@@ -18,7 +18,6 @@ package io.micronaut.inject.field.simpleinjection
 import io.micronaut.annotation.processing.test.AbstractTypeElementSpec
 import io.micronaut.context.ApplicationContext
 import io.micronaut.context.BeanContext
-import io.micronaut.context.BeanResolutionTraceMode
 
 class FieldInjectionSpec extends AbstractTypeElementSpec {
 
@@ -32,7 +31,7 @@ import jakarta.inject.*;
 @Singleton
 class Test {
     @Inject
-    java.util.List<Bar> bars;
+    java.util.List<Bar> bars;   
 }
 
 class Bar {
@@ -45,9 +44,7 @@ class Bar {
 
     void "test injection via field with interface"() {
         given:
-        ApplicationContext context = ApplicationContext.builder()
-                                            .beanResolutionTrace(BeanResolutionTraceMode.STANDARD_OUT)
-                                            .start()
+        ApplicationContext context = ApplicationContext.run()
 
         when:"Alpha bean is obtained that has a field with @Inject"
         B b =  context.getBean(B)
diff --git a/inject-kotlin/src/test/groovy/io/micronaut/kotlin/processing/beans/BeanDefinitionSpec.groovy b/inject-kotlin/src/test/groovy/io/micronaut/kotlin/processing/beans/BeanDefinitionSpec.groovy
index 67c1fee410..c986eb794a 100644
--- a/inject-kotlin/src/test/groovy/io/micronaut/kotlin/processing/beans/BeanDefinitionSpec.groovy
+++ b/inject-kotlin/src/test/groovy/io/micronaut/kotlin/processing/beans/BeanDefinitionSpec.groovy
@@ -1279,9 +1279,8 @@ annotation class NotNull
                     .filter {f -> !f.isSynthetic()}
                     .findFirst().orElseThrow()
             def supertypeMethods = definition.getBeanType().getSuperclass().getDeclaredMethods()
-                    .findAll { !it.name.contains('$jacoco')}
         then:
-            supertypeMethods.every {doWorkMethod.name.contains(it.name)}
+            supertypeMethods.collect { it.name}.contains(doWorkMethod.name)
     }
 
     void "test java class value annotation"() {
diff --git a/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java b/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java
index 7a2121bbcd..2e16c769c9 100644
--- a/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java
+++ b/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java
@@ -20,28 +20,20 @@ import io.micronaut.context.env.CachedEnvironment;
 import io.micronaut.context.annotation.InjectScope;
 import io.micronaut.context.env.ConfigurationPath;
 import io.micronaut.context.exceptions.CircularDependencyException;
-import io.micronaut.context.exceptions.DependencyInjectionException;
 import io.micronaut.context.scope.CustomScope;
 import io.micronaut.core.annotation.AnnotationMetadata;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.bind.annotation.Bindable;
 import io.micronaut.core.convert.ArgumentConversionContext;
-import io.micronaut.core.convert.ConversionContext;
 import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.naming.Named;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.ArgumentCoercible;
-import io.micronaut.core.type.TypeInformation;
-import io.micronaut.core.type.TypeInformation.TypeFormat;
-import io.micronaut.core.util.AnsiColour;
 import io.micronaut.core.util.ObjectUtils;
 import io.micronaut.inject.*;
 
-import io.micronaut.inject.proxy.InterceptedBean;
 import java.util.*;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 /**
@@ -57,8 +49,6 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
     protected final DefaultBeanContext context;
     protected final BeanDefinition<?> rootDefinition;
     protected final Path path;
-    private final @NonNull BeanResolutionTraceMode traceMode;
-    private final boolean traceEnabled;
     private Map<CharSequence, Object> attributes;
     private Qualifier<?> qualifier;
     private List<BeanRegistration<?>> dependentBeans;
@@ -75,8 +65,6 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         this.context = context;
         this.rootDefinition = rootDefinition;
         this.path = new DefaultPath();
-        this.traceMode = context.traceMode;
-        this.traceEnabled = rootDefinition != null && isTraceEnabled(rootDefinition.getBeanType().getTypeName(), context.tracePatterns);
     }
 
     @Override
@@ -96,154 +84,16 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         return old;
     }
 
-    @Override
-    public void valueResolved(Argument<?> argument, Qualifier<?> qualifier, String property, Object value) {
-        if (traceEnabled) {
-            traceMode.traceValueResolved(
-                this,
-                argument,
-                property,
-                value
-            );
-        }
-    }
-
-    private boolean isTraceEnabled(@NonNull String typeName, @NonNull Set<String> tracePatterns) {
-        return traceMode != BeanResolutionTraceMode.NONE &&
-            (tracePatterns.isEmpty() || tracePatterns.stream().anyMatch(typeName::matches));
-    }
-
-    @Override
-    public Object resolvePropertyValue(Argument<?> argument, String stringValue, String cliProperty, boolean isPlaceholder) {
-        ApplicationContext applicationContext = (ApplicationContext) context;
-
-        Argument<?> argumentType = argument;
-        Class<?> wrapperType = null;
-        Class<?> type = argument.getType();
-        if (type == Optional.class) {
-            wrapperType = Optional.class;
-            argumentType = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
-        } else if (type == OptionalInt.class) {
-            wrapperType = OptionalInt.class;
-            argumentType = Argument.INT;
-        } else if (type == OptionalLong.class) {
-            wrapperType = OptionalLong.class;
-            argumentType = Argument.LONG;
-        } else if (type == OptionalDouble.class) {
-            wrapperType = OptionalDouble.class;
-            argumentType = Argument.DOUBLE;
-        }
-
-        ArgumentConversionContext<?> conversionContext = wrapperType != null ? ConversionContext.of(argumentType) : ConversionContext.of(argument);
-
-        Optional<?> value;
-        if (isPlaceholder) {
-            value = applicationContext.resolvePlaceholders(stringValue).flatMap(v -> applicationContext.getConversionService().convert(v, conversionContext));
-        } else {
-            stringValue = substituteWildCards(stringValue);
-            value = applicationContext.getProperty(stringValue, conversionContext);
-            if (value.isEmpty() && cliProperty != null) {
-                value = applicationContext.getProperty(cliProperty, conversionContext);
-            }
-        }
-
-        if (traceEnabled) {
-            traceMode.traceValueResolved(
-                this,
-                argument,
-                stringValue,
-                value.orElse(null)
-            );
-        }
-
-        if (argument.isOptional()) {
-            if (value.isEmpty()) {
-                return value;
-            } else {
-                Object convertedOptional = value.get();
-                if (convertedOptional instanceof Optional) {
-                    return convertedOptional;
-                } else {
-                    return value;
-                }
-            }
-        } else {
-            if (wrapperType != null) {
-                final Object v = value.orElse(null);
-                if (OptionalInt.class == wrapperType) {
-                    return v instanceof Integer i ? OptionalInt.of(i) : OptionalInt.empty();
-                } else if (OptionalLong.class == wrapperType) {
-                    return v instanceof Long l ? OptionalLong.of(l) : OptionalLong.empty();
-                } else if (OptionalDouble.class == wrapperType) {
-                    return v instanceof Double d ? OptionalDouble.of(d) : OptionalDouble.empty();
-                }
-            }
-            if (value.isPresent()) {
-                return value.get();
-            } else {
-                if (argument.isDeclaredNullable()) {
-                    return null;
-                }
-                String finalStringValue = stringValue;
-                return argument.getAnnotationMetadata().getValue(Bindable.class, "defaultValue", argument)
-                    .orElseThrow(() -> DependencyInjectionException.missingProperty(this, conversionContext, finalStringValue));
-            }
-        }
-    }
-
-    private String substituteWildCards(String valString) {
-        ConfigurationPath configurationPath = getConfigurationPath();
-        if (configurationPath.isNotEmpty()) {
-            return configurationPath.resolveValue(valString);
-        }
-        return valString;
-    }
-
     @NonNull
     @Override
     public <T> T getBean(@NonNull Argument<T> beanType, @Nullable Qualifier<T> qualifier) {
-        T bean = context.getBean(this, beanType, qualifier);
-        if (traceEnabled) {
-            traceMode.traceBeanResolved(
-                this,
-                beanType,
-                qualifier,
-                bean
-            );
-            String disabledBeanMessage = context.resolveDisabledBeanMessage(
-                this,
-                beanType,
-                qualifier
-            );
-            if (disabledBeanMessage != null) {
-                traceMode.traceBeanDisabled(AbstractBeanResolutionContext.this, disabledBeanMessage);
-            }
-        }
-        return bean;
+        return context.getBean(this, beanType, qualifier);
     }
 
     @NonNull
     @Override
     public <T> Collection<T> getBeansOfType(@NonNull Argument<T> beanType, @Nullable Qualifier<T> qualifier) {
-        Collection<T> beans = context.getBeansOfType(this, beanType, qualifier);
-        if (traceEnabled) {
-            traceBeanCollection(beanType, qualifier, beans);
-        }
-        return beans;
-    }
-
-    private <T> void traceBeanCollection(Argument<T> beanType, Qualifier<T> qualifier, Collection<T> beans) {
-        for (T bean : beans) {
-            traceMode.traceBeanResolved(this, beanType, qualifier, bean);
-        }
-        String disabledBeanMessage = context.resolveDisabledBeanMessage(
-            this,
-            beanType,
-            qualifier
-        );
-        if (disabledBeanMessage != null) {
-            traceMode.traceBeanDisabled(AbstractBeanResolutionContext.this, disabledBeanMessage);
-        }
+        return context.getBeansOfType(this, beanType, qualifier);
     }
 
     @NonNull
@@ -254,43 +104,19 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
     @Override
     public <V> Map<String, V> mapOfType(Argument<V> beanType, Qualifier<V> qualifier) {
-        Map<String, V> beanMap = context.mapOfType(this, beanType, qualifier);
-        if (traceEnabled) {
-            traceBeanCollection(beanType, qualifier, beanMap.values());
-        }
-        return beanMap;
+        return context.mapOfType(this, beanType, qualifier);
     }
 
     @NonNull
     @Override
     public <T> Optional<T> findBean(@NonNull Argument<T> beanType, @Nullable Qualifier<T> qualifier) {
-        Optional<T> resolved = context.findBean(this, beanType, qualifier);
-        if (traceEnabled) {
-            traceMode.traceBeanResolved(this, beanType, qualifier, resolved.orElse(null));
-            String disabledBeanMessage = context.resolveDisabledBeanMessage(
-                this,
-                beanType,
-                qualifier
-            );
-            if (disabledBeanMessage != null) {
-                traceMode.traceBeanDisabled(AbstractBeanResolutionContext.this, disabledBeanMessage);
-            }
-        }
-        return resolved;
+        return context.findBean(this, beanType, qualifier);
     }
 
     @NonNull
     @Override
     public <T> Collection<BeanRegistration<T>> getBeanRegistrations(@NonNull Argument<T> beanType, @Nullable Qualifier<T> qualifier) {
-        Collection<BeanRegistration<T>> registrations = context.getBeanRegistrations(this, beanType, qualifier);
-        if (traceEnabled) {
-            traceBeanCollection(
-                beanType,
-                qualifier,
-                registrations.stream().map(BeanRegistration::getBean).collect(Collectors.toList())
-            );
-        }
-        return registrations;
+        return context.getBeanRegistrations(this, beanType, qualifier);
     }
 
     /**
@@ -477,14 +303,13 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
     class DefaultPath extends LinkedList<Segment<?, ?>> implements Path {
 
         public static final String RIGHT_ARROW = "\\---> ";
-        public static final String RIGHT_ARROW_EMOJI = "   ";
         private static final String CIRCULAR_ERROR_MSG = "Circular dependency detected";
 
         DefaultPath() {
         }
 
         @Override
-        public String toConsoleString(boolean ansiSupported) {
+        public String toString() {
             Iterator<Segment<?, ?>> i = descendingIterator();
             String ls = CachedEnvironment.getProperty("line.separator");
             StringBuilder pathString = new StringBuilder().append(ls);
@@ -493,29 +318,16 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
             while (i.hasNext()) {
                 pathString.append(i.next().toString());
                 if (i.hasNext()) {
-                    pathString
-                        .append(ls)
-                        .append(spaces)
-                        .append(ansiSupported ? RIGHT_ARROW_EMOJI : RIGHT_ARROW);
+                    pathString.append(ls).append(spaces).append(RIGHT_ARROW);
                     spaces += "      ";
                 }
             }
             return pathString.toString();
         }
 
-        @Override
-        public String toString() {
-            return toConsoleString(false);
-        }
-
-        @Override
-        public String toCircularString() {
-            return toConsoleCircularString(false);
-        }
-
         @SuppressWarnings("MagicNumber")
         @Override
-        public String toConsoleCircularString(boolean ansiSupported) {
+        public String toCircularString() {
             Iterator<Segment<?, ?>> i = descendingIterator();
             StringBuilder pathString = new StringBuilder();
             String ls = CachedEnvironment.getProperty("line.separator");
@@ -535,14 +347,10 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
             while (i.hasNext() && index < size() - 1) {
                 String segmentString = i.next().toString();
                 if (index == cycleIndex) {
-                    pathString.append(ls).append(spaces).append("^").append("  ")
-                        .append(ansiSupported ? RIGHT_ARROW_EMOJI : RIGHT_ARROW);
+                    pathString.append(ls).append(spaces).append("^").append("  \\---> ");
                     spaces = spaces + "|  ";
                 } else if (index != 0) {
-                    pathString
-                        .append(ls)
-                        .append(spaces)
-                        .append(ansiSupported ? RIGHT_ARROW_EMOJI : RIGHT_ARROW);
+                    pathString.append(ls).append(spaces).append(RIGHT_ARROW);
                 }
                 pathString.append(segmentString);
                 spaces = spaces + "      ";
@@ -574,60 +382,37 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public Path pushConstructorResolve(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments) {
-            try {
-                if (CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
-                    ConstructorSegment constructorSegment = new ConstructorArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments);
-                    detectCircularDependency(declaringType, argument, constructorSegment);
+            if (CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
+                ConstructorSegment constructorSegment = new ConstructorArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments);
+                detectCircularDependency(declaringType, argument, constructorSegment);
+            } else {
+                Segment<?, ?> previous = peek();
+                MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
+                if (contains(methodSegment)) {
+                    push(methodSegment);
+                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, argument, CIRCULAR_ERROR_MSG);
                 } else {
-                    Segment<?, ?> previous = peek();
-                    MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
-                    if (contains(methodSegment)) {
-                        push(methodSegment);
-                        throw new CircularDependencyException(AbstractBeanResolutionContext.this, argument, CIRCULAR_ERROR_MSG);
-                    } else {
-                        push(methodSegment);
-                    }
+                    push(methodSegment);
                 }
-            } finally {
-                traceResolution();
             }
             return this;
         }
 
         @Override
         public Path pushBeanCreate(BeanDefinition<?> declaringType, Argument<?> beanType) {
-            if (traceEnabled) {
-                traceMode.startTrace(
-                    AbstractBeanResolutionContext.this,
-                    beanType,
-                    declaringType
-                );
-            }
             return pushConstructorResolve(declaringType, beanType);
         }
 
-        private void traceResolution() {
-            if (traceEnabled) {
-               traceMode.traceSegment(
-                    AbstractBeanResolutionContext.this
-               );
-            }
-        }
-
         @Override
         public Path pushMethodArgumentResolve(BeanDefinition declaringType, MethodInjectionPoint methodInjectionPoint, Argument argument) {
-            try {
-                Segment<?, ?> previous = peek();
-                MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodInjectionPoint.getName(), argument,
-                        methodInjectionPoint.getArguments(), previous instanceof MethodSegment ms ? ms : null);
-                if (contains(methodSegment)) {
-                    push(methodSegment);
-                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, methodInjectionPoint, argument, CIRCULAR_ERROR_MSG);
-                } else {
-                    push(methodSegment);
-                }
-            } finally {
-                traceResolution();
+            Segment<?, ?> previous = peek();
+            MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodInjectionPoint.getName(), argument,
+                    methodInjectionPoint.getArguments(), previous instanceof MethodSegment ms ? ms : null);
+            if (contains(methodSegment)) {
+                push(methodSegment);
+                throw new CircularDependencyException(AbstractBeanResolutionContext.this, methodInjectionPoint, argument, CIRCULAR_ERROR_MSG);
+            } else {
+                push(methodSegment);
             }
 
             return this;
@@ -635,41 +420,13 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public Path pushMethodArgumentResolve(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments) {
-            try {
-                Segment<?, ?> previous = peek();
-                MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
-                if (contains(methodSegment)) {
-                    push(methodSegment);
-                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, methodName, argument, CIRCULAR_ERROR_MSG);
-                } else {
-                    push(methodSegment);
-                }
-            } finally {
-                traceResolution();
-            }
-
-            return this;
-        }
-
-        @Override
-        public Path pushEventListenerResolve(BeanDefinition<?> declaringType, Argument<?> eventType) {
-            try {
-                EventListenerSegment<?, ?> segment = new EventListenerSegment<>(
-                    declaringType,
-                    eventType
-                );
-                if (contains(segment)) {
-                    push(segment);
-                    throw new CircularDependencyException(
-                        AbstractBeanResolutionContext.this,
-                        eventType,
-                        CIRCULAR_ERROR_MSG
-                    );
-                } else {
-                    push(segment);
-                }
-            } finally {
-                traceResolution();
+            Segment<?, ?> previous = peek();
+            MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
+            if (contains(methodSegment)) {
+                push(methodSegment);
+                throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, methodName, argument, CIRCULAR_ERROR_MSG);
+            } else {
+                push(methodSegment);
             }
 
             return this;
@@ -677,48 +434,36 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public Path pushFieldResolve(BeanDefinition declaringType, FieldInjectionPoint fieldInjectionPoint) {
-            try {
-                FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldInjectionPoint.asArgument());
-                if (contains(fieldSegment)) {
-                    push(fieldSegment);
-                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, fieldInjectionPoint, CIRCULAR_ERROR_MSG);
-                } else {
-                    push(fieldSegment);
-                }
-            } finally {
-                traceResolution();
+            FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldInjectionPoint.asArgument());
+            if (contains(fieldSegment)) {
+                push(fieldSegment);
+                throw new CircularDependencyException(AbstractBeanResolutionContext.this, fieldInjectionPoint, CIRCULAR_ERROR_MSG);
+            } else {
+                push(fieldSegment);
             }
             return this;
         }
 
         @Override
         public Path pushFieldResolve(BeanDefinition declaringType, Argument fieldAsArgument) {
-            try {
-                FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldAsArgument);
-                if (contains(fieldSegment)) {
-                    push(fieldSegment);
-                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, fieldAsArgument.getName(), CIRCULAR_ERROR_MSG);
-                } else {
-                    push(fieldSegment);
-                }
-            } finally {
-                traceResolution();
+            FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldAsArgument);
+            if (contains(fieldSegment)) {
+                push(fieldSegment);
+                throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, fieldAsArgument.getName(), CIRCULAR_ERROR_MSG);
+            } else {
+                push(fieldSegment);
             }
             return this;
         }
 
         @Override
         public Path pushAnnotationResolve(BeanDefinition beanDefinition, Argument annotationMemberBeanAsArgument) {
-            try {
-                AnnotationSegment annotationSegment = new AnnotationSegment(beanDefinition, getCurrentQualifier(), annotationMemberBeanAsArgument);
-                if (contains(annotationSegment)) {
-                    push(annotationSegment);
-                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, beanDefinition, annotationMemberBeanAsArgument.getName(), CIRCULAR_ERROR_MSG);
-                } else {
-                    push(annotationSegment);
-                }
-            } finally {
-                traceResolution();
+            AnnotationSegment annotationSegment = new AnnotationSegment(beanDefinition, getCurrentQualifier(), annotationMemberBeanAsArgument);
+            if (contains(annotationSegment)) {
+                push(annotationSegment);
+                throw new CircularDependencyException(AbstractBeanResolutionContext.this, beanDefinition, annotationMemberBeanAsArgument.getName(), CIRCULAR_ERROR_MSG);
+            } else {
+                push(annotationSegment);
             }
             return this;
         }
@@ -769,17 +514,6 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
             super.push(segment);
             AbstractBeanResolutionContext.this.onNewSegment(segment);
         }
-
-        @Override
-        public void close() {
-            Path.super.close();
-            if (traceEnabled && isEmpty()) {
-                traceMode.finishTrace(
-                    AbstractBeanResolutionContext.this,
-                    rootDefinition
-                );
-            }
-        }
     }
 
     /**
@@ -807,7 +541,6 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
      */
     public static class ConstructorSegment extends AbstractSegment<Object, Object> implements ArgumentInjectionPoint<Object, Object> {
 
-        private static final String ANN_ADAPTER = "io.micronaut.aop.Adapter";
         private final String methodName;
         private final Argument<Object>[] arguments;
 
@@ -826,40 +559,15 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public String toString() {
-            return toConsoleString(false);
-        }
-
-        @NonNull
-        public String toConsoleString(boolean ansiSupported) {
             StringBuilder baseString;
-            BeanDefinition<Object> declaringType = getDeclaringType();
-            TypeInformation<Object> typeInformation = declaringType.getTypeInformation();
-            if (declaringType.hasDeclaredStereotype(ANN_ADAPTER)) {
-                ExecutableMethod<Object, ?> method = declaringType.getExecutableMethods().iterator().next();
-                // Not great, but to produce accurate debug output we have to reach into AOP internals
-                Class<?> beanType = method.classValue(ANN_ADAPTER, "adaptedBean").orElse(declaringType.getBeanType());
-                String beanMethod = method.stringValue(ANN_ADAPTER, "adaptedMethod").orElse("unknown");
-                baseString = new StringBuilder(TypeFormat.getBeanTypeString(
-                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED,
-                    beanType,
-                    declaringType.asArgument().getTypeVariables(),
-                    declaringType.getAnnotationMetadata()
-                )).append(MEMBER_SEPARATOR);
-                baseString.append(beanMethod);
-            } else if (CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
-                baseString = new StringBuilder(
-                    ansiSupported ? AnsiColour.magentaBold("new ") : "new "
-                );
-                baseString.append(typeInformation.getBeanTypeString(
-                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED
-                ));
+            if (CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
+                baseString = new StringBuilder("new ");
+                baseString.append(getTypeName(getDeclaringType().getBeanType()));
             } else {
-                baseString = new StringBuilder(typeInformation.getBeanTypeString(
-                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED
-                )).append(MEMBER_SEPARATOR);
+                baseString = new StringBuilder(getTypeName(getDeclaringType().getBeanType())).append('#');
                 baseString.append(methodName);
             }
-            outputArguments(baseString, arguments, ansiSupported);
+            outputArguments(baseString, arguments);
             return baseString.toString();
         }
 
@@ -917,77 +625,17 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public String toString() {
-            return toConsoleString(false);
-        }
-
-        @Override
-        public String toConsoleString(boolean ansiSupported) {
             BeanDefinition<?> declaringBean = getDeclaringBean();
             if (declaringBean.hasAnnotation(Factory.class)) {
-                String beanDescription = declaringBean.getBeanDescription(
-                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED,
-                    false
-                );
-
-                var baseString = new StringBuilder(beanDescription);
-                String methodName = getName();
-                if (!CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
-                    String memberSeparator = ansiSupported ? AnsiColour.CYAN_BOLD + MEMBER_SEPARATOR + AnsiColour.RESET : MEMBER_SEPARATOR;
-                    baseString.append(memberSeparator);
-                    baseString.append(methodName);
-                }
-
-                outputArguments(baseString, getArguments(), ansiSupported);
+                ConstructorInjectionPoint<?> constructor = declaringBean.getConstructor();
+                var baseString = new StringBuilder(getTypeName(constructor.getDeclaringBeanType())).append(MEMBER_SEPARATOR);
+                baseString.append(getName());
+                outputArguments(baseString, getArguments());
                 return baseString.toString();
             } else {
-                return super.toConsoleString(ansiSupported);
-            }
-        }
-    }
-
-    /**
-     * Represents a segment that is an event listener.
-     * @param <B> The bean type
-     * @param <T> The event type
-     */
-    public static class EventListenerSegment<B, T> extends AbstractSegment<B, T> implements CallableInjectionPoint<B> {
-        /**
-         * @param declaringClass The declaring class
-         * @param eventType       The argument
-         */
-        EventListenerSegment(
-            BeanDefinition<B> declaringClass,
-            Argument<T> eventType) {
-            super(declaringClass, null, eventType.getName(), eventType);
-        }
-
-        @Override
-        public String toConsoleString(boolean ansiSupported) {
-            if (ansiSupported) {
-                String event = getArgument().getTypeString(TypeFormat.ANSI_SIMPLE);
-                return event + "   " +
-                    getDeclaringBean().getBeanDescription(TypeFormat.ANSI_SHORTENED);
-            } else {
-                String event = getArgument().getTypeString(TypeFormat.SIMPLE);
-                return event + " -> " +
-                    getDeclaringBean().getBeanDescription(TypeFormat.SHORTENED);
+                return super.toString();
             }
         }
-
-        @Override
-        public InjectionPoint<B> getInjectionPoint() {
-            return this;
-        }
-
-        @Override
-        public Argument<?>[] getArguments() {
-            return new Argument[] { getArgument() };
-        }
-
-        @Override
-        public BeanDefinition<B> getDeclaringBean() {
-            return getDeclaringType();
-        }
     }
 
     /**
@@ -1011,20 +659,9 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public String toString() {
-            return toConsoleString(false);
-        }
-
-        @Override
-        public String toConsoleString(boolean ansiSupported) {
-            StringBuilder baseString = new StringBuilder(
-                getDeclaringType().getTypeInformation().getBeanTypeString(
-                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED
-                )
-            );
-            String memberSeparator = ansiSupported ? AnsiColour.CYAN_BOLD + MEMBER_SEPARATOR + AnsiColour.RESET : MEMBER_SEPARATOR;
-            baseString.append(memberSeparator);
+            StringBuilder baseString = new StringBuilder(getTypeName(getDeclaringType().getBeanType())).append(MEMBER_SEPARATOR);
             baseString.append(getName());
-            outputArguments(baseString, arguments, ansiSupported);
+            outputArguments(baseString, arguments);
             return baseString.toString();
         }
 
@@ -1070,21 +707,7 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public String toString() {
-            return toConsoleString(false);
-        }
-
-        @Override
-        public String toConsoleString(boolean ansiSupported) {
-            String beanDescription = getDeclaringType().getBeanDescription(
-                ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED,
-                false
-            );
-            StringBuilder baseString = new StringBuilder(beanDescription);
-            String memberSeparator = ansiSupported ? AnsiColour.CYAN_BOLD + MEMBER_SEPARATOR + AnsiColour.RESET : MEMBER_SEPARATOR;
-            baseString.append(memberSeparator);
-            baseString.append(getName());
-
-            return baseString.toString();
+            return getTypeName(getDeclaringType().getBeanType()) + MEMBER_SEPARATOR + getName();
         }
 
         @Override
@@ -1196,23 +819,7 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
          * @return The name to be shown to user
          */
         protected String getTypeName(Class<?> type) {
-            if (InterceptedBean.class.isAssignableFrom(type)) {
-                Class<?>[] interfaces = type.getInterfaces();
-                Set<String> interfaceNames = Arrays.stream(interfaces)
-                    .map(Class::getName)
-                    .collect(Collectors.toSet());
-                if (type.isInterface() && interfaceNames.contains("io.micronaut.aop.Introduced")) {
-                    return NameUtils.getShortenedName(
-                        interfaces[0].getTypeName()
-                    );
-                } else {
-                    return NameUtils.getShortenedName(
-                        type.getSuperclass().getTypeName()
-                    );
-                }
-            } else {
-                return NameUtils.getShortenedName(type.getTypeName());
-            }
+            return NameUtils.getShortenedName(type.getName());
         }
 
         @Override
@@ -1255,46 +862,26 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         }
 
         /**
-         * @param baseString    The base string
-         * @param arguments     The arguments
-         * @param ansiSupported Whether ANSI colour is supported
+         * @param baseString The base string
+         * @param arguments  The arguments
          */
-        void outputArguments(StringBuilder baseString, Argument[] arguments, boolean ansiSupported) {
-            baseString.append(ansiSupported ? AnsiColour.brightCyan("(") : "(");
+        void outputArguments(StringBuilder baseString, Argument[] arguments) {
+            baseString.append('(');
             for (int i = 0; i < arguments.length; i++) {
                 Argument<?> argument = arguments[i];
                 boolean isInjectedArgument = argument.equals(getArgument());
                 if (isInjectedArgument) {
-                    if (ansiSupported) {
-                        baseString.append(AnsiColour.BLUE_UNDERLINED);
-                    }
                     baseString.append('[');
                 }
-                String beanTypeString = argument.getBeanTypeString(
-                    ansiSupported && !isInjectedArgument ? TypeFormat.ANSI_SIMPLE : TypeFormat.SIMPLE
-                );
-                baseString.append(beanTypeString)
-                    .append(' ')
-                    .append(ansiSupported && !isInjectedArgument ? AnsiColour.brightBlue(argument.getName()) : argument.getName());
+                baseString.append(argument);
                 if (isInjectedArgument) {
                     baseString.append(']');
-                    if (ansiSupported) {
-                        baseString.append(AnsiColour.RESET);
-                    }
                 }
-
                 if (i != arguments.length - 1) {
-                    Argument<?> next = arguments[i + 1];
-                    if (getDeclaringType().getBeanType().isSynthetic() &&
-                        next.getName().startsWith("$")) {
-                        // skip synthetic arguments
-                        break;
-                    }
-                    baseString.append(", ");
+                    baseString.append(',');
                 }
             }
-            baseString.append(ansiSupported ? AnsiColour.brightCyan(")") : ")");
-
+            baseString.append(')');
         }
     }
 }
diff --git a/inject/src/main/java/io/micronaut/context/AbstractInitializableBeanDefinition.java b/inject/src/main/java/io/micronaut/context/AbstractInitializableBeanDefinition.java
index 705b2043c0..c931ddf5e5 100644
--- a/inject/src/main/java/io/micronaut/context/AbstractInitializableBeanDefinition.java
+++ b/inject/src/main/java/io/micronaut/context/AbstractInitializableBeanDefinition.java
@@ -1000,7 +1000,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         Argument<?> argument = methodRef.arguments[argIndex];
         try (BeanResolutionContext.Path path = resolutionContext.getPath()
                 .pushMethodArgumentResolve(this, methodRef.methodName, argument, methodRef.arguments)) {
-            Object val = resolutionContext.resolvePropertyValue( argument, propertyValue, cliProperty, false);
+            Object val = resolvePropertyValue(resolutionContext, context, argument, propertyValue, cliProperty, false);
             if (this instanceof ValidatedBeanDefinition validatedBeanDefinition) {
                 validatedBeanDefinition.validateBeanArgument(
                     resolutionContext,
@@ -1035,7 +1035,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         Argument<?> argument = methodRef.arguments[argIndex];
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath()
                 .pushMethodArgumentResolve(this, methodRef.methodName, argument, methodRef.arguments)) {
-            return resolutionContext.resolvePropertyValue(argument, value, null, true);
+            return resolvePropertyValue(resolutionContext, context, argument, value, null, true);
         }
     }
 
@@ -1069,7 +1069,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
                                                      String cliProperty) {
         try (BeanResolutionContext.Path path = resolutionContext.getPath()
                 .pushMethodArgumentResolve(this, setterName, argument, new Argument[]{argument})) {
-            Object val = resolutionContext.resolvePropertyValue(argument, propertyValue, cliProperty, false);
+            Object val = resolvePropertyValue(resolutionContext, context, argument, propertyValue, cliProperty, false);
             if (this instanceof ValidatedBeanDefinition validatedBeanDefinition) {
                 validatedBeanDefinition.validateBeanArgument(
                     resolutionContext,
@@ -1102,7 +1102,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
                                                                 String value) {
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath()
                 .pushMethodArgumentResolve(this, setterName, argument, new Argument[]{argument})) {
-            return resolutionContext.resolvePropertyValue(argument, value, null, true);
+            return resolvePropertyValue(resolutionContext, context, argument, value, null, true);
         }
     }
 
@@ -1145,8 +1145,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     protected final <K> K getBeanForMethodArgument(BeanResolutionContext resolutionContext, BeanContext context, int methodIndex, int argIndex, Qualifier<K> qualifier) {
         MethodReference methodRef = methodInjection[methodIndex];
         Argument<K> argument = resolveArgument(context, argIndex, methodRef.arguments);
-        BeanResolutionContext.Path path = resolutionContext.getPath();
-        try (BeanResolutionContext.Path ignored = path
+        try (BeanResolutionContext.Path ignored = resolutionContext.getPath()
                 .pushMethodArgumentResolve(this, methodRef.methodName, argument, methodRef.arguments)) {
             return resolveBean(
                 resolutionContext,
@@ -1340,14 +1339,13 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     protected final Object getBeanForConstructorArgument(BeanResolutionContext resolutionContext, BeanContext context, int argIndex, Qualifier qualifier) {
         MethodReference constructorMethodRef = (MethodReference) constructor;
         Argument<?> argument = resolveArgument(context, argIndex, constructorMethodRef.arguments);
-        BeanResolutionContext.Path path = resolutionContext.getPath();
         if (argument != null && argument.isDeclaredNullable()) {
-            BeanResolutionContext.Segment<?, ?> current = path.peek();
+            BeanResolutionContext.Segment<?, ?> current = resolutionContext.getPath().peek();
             if (current != null && current.getArgument().equals(argument)) {
                 return null;
             }
         }
-        try (BeanResolutionContext.Path ignored = path
+        try (BeanResolutionContext.Path ignored = resolutionContext.getPath()
                 .pushConstructorResolve(this, argument)) {
             return resolveBean(resolutionContext, argument, qualifier, false);
         }
@@ -1414,7 +1412,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         Argument<?> argument = constructorRef.arguments[argIndex];
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath().pushConstructorResolve(this, argument)) {
             try {
-                Object result = resolutionContext.resolvePropertyValue(argument, propertyValue, cliProperty, false);
+                Object result = resolvePropertyValue(resolutionContext, context, argument, propertyValue, cliProperty, false);
 
                 if (this instanceof ValidatedBeanDefinition validatedBeanDefinition) {
                     validatedBeanDefinition.validateBeanArgument(
@@ -1462,7 +1460,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         Argument<?> argument = constructorRef.arguments[argIndex];
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath().pushConstructorResolve(this, argument)) {
             try {
-                Object result = resolutionContext.resolvePropertyValue(argument, propertyValue, null, true);
+                Object result = resolvePropertyValue(resolutionContext, context, argument, propertyValue, null, true);
 
                 if (this instanceof ValidatedBeanDefinition validatedBeanDefinition) {
                     validatedBeanDefinition.validateBeanArgument(
@@ -1745,7 +1743,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     @Deprecated
     protected final Object getPropertyValueForField(BeanResolutionContext resolutionContext, BeanContext context, Argument argument, String propertyValue, String cliProperty) {
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath().pushFieldResolve(this, argument)) {
-            return resolutionContext.resolvePropertyValue(argument, propertyValue, cliProperty, false);
+            return resolvePropertyValue(resolutionContext, context, argument, propertyValue, cliProperty, false);
         }
     }
 
@@ -1765,7 +1763,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     @Deprecated
     protected final Object getPropertyPlaceholderValueForField(BeanResolutionContext resolutionContext, BeanContext context, Argument argument, String placeholder) {
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath().pushFieldResolve(this, argument)) {
-            return resolutionContext.resolvePropertyValue(argument, placeholder, null, true);
+            return resolvePropertyValue(resolutionContext, context, argument, placeholder, null, true);
         }
     }
 
@@ -2023,11 +2021,14 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     }
 
     private Object resolveValue(BeanResolutionContext resolutionContext, BeanContext context, AnnotationMetadata parentAnnotationMetadata, Argument<?> argument, Qualifier qualifier) {
+        if (!(context instanceof PropertyResolver)) {
+            throw new DependencyInjectionException(resolutionContext, "@Value requires a BeanContext that implements PropertyResolver");
+        }
         AnnotationMetadata argumentAnnotationMetadata = argument.getAnnotationMetadata();
         if (argumentAnnotationMetadata.hasEvaluatedExpressions()) {
             boolean isOptional = argument.isOptional();
             if (isOptional) {
-                Argument<?> t = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
+                Argument<?> t = isOptional ? argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT) : argument;
                 Object v = argumentAnnotationMetadata.getValue(Value.class, t).orElse(null);
                 return Optional.ofNullable(v);
             } else {
@@ -2060,12 +2061,6 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
             String valString = resolvePropertyValueName(resolutionContext, parentAnnotationMetadata, argumentAnnotationMetadata, valueAnnVal);
             ArgumentConversionContext conversionContext = wrapperType ? ConversionContext.of(argumentType) : ConversionContext.of(argument);
             Optional value = resolveValue((ApplicationContext) context, conversionContext, valueAnnVal != null, valString);
-            resolutionContext.valueResolved(
-                argument,
-                qualifier,
-                valString,
-                value.orElse(null)
-            );
             if (argument.isOptional()) {
                 if (value.isEmpty()) {
                     return value;
@@ -2101,6 +2096,78 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         }
     }
 
+    private Object resolvePropertyValue(BeanResolutionContext resolutionContext, BeanContext context, Argument<?> argument,
+                                        String stringValue, String cliProperty, boolean isPlaceholder) {
+        if (!(context instanceof PropertyResolver)) {
+            throw new DependencyInjectionException(resolutionContext, "@Value requires a BeanContext that implements PropertyResolver");
+        }
+        ApplicationContext applicationContext = (ApplicationContext) context;
+
+        Argument<?> argumentType = argument;
+        Class<?> wrapperType = null;
+        Class<?> type = argument.getType();
+        if (type == Optional.class) {
+            wrapperType = Optional.class;
+            argumentType = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
+        } else if (type == OptionalInt.class) {
+            wrapperType = OptionalInt.class;
+            argumentType = Argument.INT;
+        } else if (type == OptionalLong.class) {
+            wrapperType = OptionalLong.class;
+            argumentType = Argument.LONG;
+        } else if (type == OptionalDouble.class) {
+            wrapperType = OptionalDouble.class;
+            argumentType = Argument.DOUBLE;
+        }
+
+        ArgumentConversionContext<?> conversionContext = wrapperType != null ? ConversionContext.of(argumentType) : ConversionContext.of(argument);
+
+        Optional<?> value;
+        if (isPlaceholder) {
+            value = applicationContext.resolvePlaceholders(stringValue).flatMap(v -> applicationContext.getConversionService().convert(v, conversionContext));
+        } else {
+            stringValue = substituteWildCards(resolutionContext, stringValue);
+            value = applicationContext.getProperty(stringValue, conversionContext);
+            if (value.isEmpty() && cliProperty != null) {
+                value = applicationContext.getProperty(cliProperty, conversionContext);
+            }
+        }
+
+        if (argument.isOptional()) {
+            if (value.isEmpty()) {
+                return value;
+            } else {
+                Object convertedOptional = value.get();
+                if (convertedOptional instanceof Optional) {
+                    return convertedOptional;
+                } else {
+                    return value;
+                }
+            }
+        } else {
+            if (wrapperType != null) {
+                final Object v = value.orElse(null);
+                if (OptionalInt.class == wrapperType) {
+                    return v instanceof Integer i ? OptionalInt.of(i) : OptionalInt.empty();
+                } else if (OptionalLong.class == wrapperType) {
+                    return v instanceof Long l ? OptionalLong.of(l) : OptionalLong.empty();
+                } else if (OptionalDouble.class == wrapperType) {
+                    return v instanceof Double d ? OptionalDouble.of(d) : OptionalDouble.empty();
+                }
+            }
+            if (value.isPresent()) {
+                return value.get();
+            } else {
+                if (argument.isDeclaredNullable()) {
+                    return null;
+                }
+                String finalStringValue = stringValue;
+                return argument.getAnnotationMetadata().getValue(Bindable.class, "defaultValue", argument)
+                        .orElseThrow(() -> DependencyInjectionException.missingProperty(resolutionContext, conversionContext, finalStringValue));
+            }
+        }
+    }
+
     private <K> @Nullable K resolveBean(
         BeanResolutionContext resolutionContext,
         Argument<K> argument,
diff --git a/inject/src/main/java/io/micronaut/context/ApplicationContextBuilder.java b/inject/src/main/java/io/micronaut/context/ApplicationContextBuilder.java
index 3fa826318d..8b554e37e7 100644
--- a/inject/src/main/java/io/micronaut/context/ApplicationContextBuilder.java
+++ b/inject/src/main/java/io/micronaut/context/ApplicationContextBuilder.java
@@ -36,20 +36,6 @@ import java.util.Map;
  */
 public interface ApplicationContextBuilder {
 
-    /**
-     * Sets the trace mode for bean resolution.
-     * @param traceMode The debug mode
-     * @param classPatterns The patterns
-     * @since 4.8.0
-     * @see BeanResolutionTraceMode
-     * @return This builder
-     */
-    default @NonNull ApplicationContextBuilder beanResolutionTrace(
-        @NonNull BeanResolutionTraceMode traceMode,
-        String... classPatterns) {
-        return this;
-    }
-
     /**
      * Whether to eager initialize {@link io.micronaut.context.annotation.ConfigurationProperties} beans.
      * @param eagerInitConfiguration True if configuration properties should be eagerly initialized
diff --git a/inject/src/main/java/io/micronaut/context/BeanContextConfiguration.java b/inject/src/main/java/io/micronaut/context/BeanContextConfiguration.java
index 99b89adb1f..bfcfb71220 100644
--- a/inject/src/main/java/io/micronaut/context/BeanContextConfiguration.java
+++ b/inject/src/main/java/io/micronaut/context/BeanContextConfiguration.java
@@ -32,27 +32,6 @@ import java.util.Set;
  */
 public interface BeanContextConfiguration {
 
-    /**
-     * The debug mode for bean resolution.
-     *
-     * @since 4.8.0
-     * @see BeanResolutionTraceMode
-     * @return The bean resolution debug mode.
-     */
-    default @NonNull BeanResolutionTraceMode getTraceMode() {
-        return BeanResolutionTraceMode.NONE;
-    }
-
-    /**
-     * The class patterns to trace.
-     *
-     * @return A set of regex patterns for tracing.
-     * @since 4.8.0
-     */
-    default Set<String> getTraceClasses() {
-        return Set.of();
-    }
-
     /**
      * @return If a {@link io.micronaut.context.exceptions.NoSuchBeanException} should be thrown on a missing {@link io.micronaut.context.BeanProvider} or {@link jakarta.inject.Provider}
      * @since 3.0.0
diff --git a/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java b/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java
index efca024776..2c48f33608 100644
--- a/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java
+++ b/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java
@@ -300,25 +300,6 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
     @Nullable
     ConfigurationPath setConfigurationPath(@Nullable ConfigurationPath configurationPath);
 
-    /**
-     * Resolve a property value.
-     * @param argument The argument
-     * @param stringValue The string value
-     * @param cliProperty The CLI property
-     * @param isPlaceholder Whether it is a place holder
-     * @return The resolved value
-     */
-    @Nullable Object resolvePropertyValue(Argument<?> argument, String stringValue, String cliProperty, boolean isPlaceholder);
-
-    /**
-     * Callback when a value is resolved in some other context.
-     * @param argument The argument
-     * @param qualifier The qualifier
-     * @param property The property
-     * @param value The value
-     */
-    void valueResolved(Argument<?> argument, Qualifier<?> qualifier, String property, @Nullable Object value);
-
     /**
      * Represents a path taken to resolve a bean definitions dependencies.
      */
@@ -373,14 +354,6 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
          */
         Path pushMethodArgumentResolve(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments);
 
-        /**
-         * Push resolution of an event listener
-         * @param declaringType The declaration type
-         * @param eventType The event type
-         * @return The path
-         */
-        Path pushEventListenerResolve(BeanDefinition<?> declaringType, Argument<?> eventType);
-
         /**
          * Push an unresolved field onto the queue.
          *
@@ -399,12 +372,6 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
          */
         Path pushFieldResolve(BeanDefinition declaringType, Argument fieldAsArgument);
 
-        /**
-         * Push resolution of a bean from an annotation.
-         * @param beanDefinition The bean definition
-         * @param annotationMemberBeanAsArgument The annotation member
-         * @return The path
-         */
         Path pushAnnotationResolve(BeanDefinition beanDefinition, Argument annotationMemberBeanAsArgument);
 
         /**
@@ -414,28 +381,6 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
          */
         String toCircularString();
 
-        /**
-         * Converts the path to a circular string.
-         *
-         * @param ansiSupported  Whether ANSI colour is supported
-         * @return The circular string
-         * @since 4.8.0
-         */
-        default String toConsoleCircularString(boolean ansiSupported) {
-            return toCircularString();
-        }
-
-        /**
-         * Converts the path to a string.
-         *
-         * @param ansiSupported  Whether ANSI colour is supported
-         * @return The string
-         * @since 4.8.0
-         */
-        default String toConsoleString(boolean ansiSupported) {
-            return toString();
-        }
-
         /**
          * @return The current path segment
          */
@@ -455,15 +400,6 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
      */
     interface Segment<B, T> {
 
-        /**
-         * To a console string.
-         * @param ansiSupported Whether ansi is supported
-         * @return The string
-         */
-        default String toConsoleString(boolean ansiSupported) {
-            return toString();
-        }
-
         /**
          * @return The type requested
          */
diff --git a/inject/src/main/java/io/micronaut/context/BeanResolutionTraceMode.java b/inject/src/main/java/io/micronaut/context/BeanResolutionTraceMode.java
deleted file mode 100644
index bcc3dbd2be..0000000000
--- a/inject/src/main/java/io/micronaut/context/BeanResolutionTraceMode.java
+++ /dev/null
@@ -1,427 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.context;
-
-import io.micronaut.context.annotation.ConfigurationReader;
-import io.micronaut.context.env.Environment;
-import io.micronaut.context.env.PropertyEntry;
-import io.micronaut.context.env.PropertySource;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.naming.NameUtils;
-import io.micronaut.core.naming.Named;
-import io.micronaut.core.order.OrderUtil;
-import io.micronaut.core.type.Argument;
-import io.micronaut.core.type.TypeInformation;
-import io.micronaut.core.util.AnsiColour;
-import io.micronaut.core.util.StringUtils;
-import io.micronaut.inject.BeanDefinition;
-import io.micronaut.inject.BeanDefinitionReference;
-import java.io.BufferedWriter;
-import java.io.IOException;
-import java.io.StringWriter;
-import java.util.Collection;
-import java.util.List;
-import java.util.Optional;
-import java.util.Set;
-import java.util.stream.Collectors;
-import org.jetbrains.annotations.NotNull;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * Allows enabling more verbose debugging on bean resolution.
- */
-public enum BeanResolutionTraceMode {
-    /**
-     * No debug enabled (the default).
-     */
-    NONE,
-
-    /**
-     * When log mode is enabled output will be
-     * written to a logger named {@code io.micronaut.context.resolution} at DEBUG level.
-     */
-    LOG,
-
-    /**
-     * With standard out debug output will be written to {@link System#out} avoiding any log formatting.
-     */
-    STANDARD_OUT;
-
-    static final Logger LOGGER = LoggerFactory.getLogger("io.micronaut.inject");
-    private static final String MODE_SYS_PROP = "micronaut.inject.trace.mode";
-    private static final String MODE_ENV_VAR = "MICRONAUT_INJECT_TRACE_MODE";
-    private static final String CLASSES_SYS_PROP = "micronaut.inject.trace";
-    private static final String CLASSES_ENV_VAR = "MICRONAUT_INJECT_TRACE";
-    private static final Set<String> INTERNAL_PACKAGES = Set.of(
-        "io.micronaut.context",
-        "io.micronaut.aop",
-        "io.micronaut.core.util",
-        "org.codehaus.groovy.vmplugin",
-        "java.util"
-    );
-
-    private static final String RIGHT_ARROW = AnsiColour.isSupported() ? "   " : " -> ";
-    private static final String RIGHT_ARROW_LOOP = AnsiColour.isSupported() ? "   " : "\\---> ";
-    private static final CharSequence START_TIME = "BeanResolutionTrace-start";
-
-    /**
-     * Obtains the default mode.
-     *
-     * @return The default mode
-     */
-    static BeanResolutionTraceMode getDefaultMode(Set<String> traceClasses) {
-        String mode = Optional
-            .ofNullable(System.getProperty(MODE_SYS_PROP))
-            .orElseGet(() -> System.getenv(MODE_ENV_VAR));
-        if (mode != null) {
-            return BeanResolutionTraceMode
-                .valueOf(NameUtils.environmentName(mode));
-        }
-        if (traceClasses.isEmpty()) {
-            return LOGGER.isTraceEnabled() ? BeanResolutionTraceMode.LOG : BeanResolutionTraceMode.NONE;
-        } else {
-            return LOGGER.isTraceEnabled() ? BeanResolutionTraceMode.LOG : BeanResolutionTraceMode.STANDARD_OUT;
-        }
-    }
-
-    static Set<String> getDefaultTraceClasses() {
-        String classes = Optional
-            .ofNullable(System.getProperty(CLASSES_SYS_PROP))
-            .orElseGet(() -> System.getenv(CLASSES_ENV_VAR));
-        if (classes != null) {
-            return Set.of(classes.split(","));
-        }
-        return Set.of();
-    }
-
-    void startTrace(
-        BeanResolutionContext resolutionContext,
-        Argument<?> beanType,
-        BeanDefinition<?> beanDefinition) {
-        resolutionContext.setAttribute(START_TIME, System.currentTimeMillis());
-        List<StackWalker.StackFrame> interestingFrames = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)
-            .walk(s ->
-                s.dropWhile(f ->
-                        (INTERNAL_PACKAGES.stream().anyMatch(p -> f.getClassName().startsWith(p)) || f.getDeclaringClass().isSynthetic()) &&
-                            // capture startup beans
-                            !(f.getClassName().equals(DefaultBeanContext.class.getName()) && f.getMethodName().equals("start")))
-                    .limit(3)
-                    .collect(Collectors.toList())
-            );
-        String beanName = getBeanName(beanType, beanDefinition);
-        StringWriter sw = new StringWriter();
-        try (BufferedWriter writer = new BufferedWriter(sw)) {
-            writer.newLine();
-            String beanDescription = beanDefinition.getBeanDescription(TypeInformation.TypeFormat.ANSI_SHORTENED);
-            writer.write(beanName + RIGHT_ARROW + beanDescription + " at location:");
-            writer.newLine();
-            for (StackWalker.StackFrame stackFrame : interestingFrames) {
-                StackTraceElement traceElement = stackFrame.toStackTraceElement();
-                StackTraceElement shortened = new StackTraceElement(
-                    NameUtils.getShortenedName(traceElement.getClassName()),
-                    traceElement.getMethodName(),
-                    traceElement.getFileName(),
-                    traceElement.getLineNumber()
-                );
-                writer.write(shortened.toString());
-                writer.newLine();
-            }
-            writer.newLine();
-        } catch (IOException e) {
-            // ignore, should never happen
-        }
-        switch (this) {
-            case STANDARD_OUT -> System.out.println(sw);
-            case LOG -> LOGGER.info(sw.toString());
-        }
-    }
-
-    private static String getBeanName(Argument<?> beanType, BeanDefinition<?> beanDefinition) {
-        String beanName;
-        if (beanType.getType().isSynthetic()) {
-            beanName = beanDefinition.getTypeInformation().getBeanTypeString(TypeInformation.TypeFormat.ANSI_SIMPLE);
-        } else {
-            beanName = beanType
-                .getBeanTypeString(TypeInformation.TypeFormat.ANSI_SIMPLE);
-        }
-        return beanName;
-    }
-
-    <T> void traceBeanResolved(
-        BeanResolutionContext resolutionContext,
-        @NonNull Argument<T> beanType,
-        @Nullable Qualifier<T> qualifier,
-        @Nullable T bean) {
-        String prefix = padLeft(resolutionContext, 1) + RIGHT_ARROW;
-        StringWriter sw = new StringWriter();
-        try (BufferedWriter writer = new BufferedWriter(sw)) {
-
-            writer.write(prefix);
-            writer.write(bean != null ? " " : " ");
-            if (bean != null) {
-                if (qualifier != null) {
-                    if (qualifier instanceof Named named) {
-                        writer.write(AnsiColour.yellow("@Named("));
-                        writer.write(AnsiColour.green("\"" + named.getName() + "\""));
-                        writer.write(AnsiColour.yellow(")"));
-                    } else {
-                        writer.write(AnsiColour.yellow(qualifier.toString()));
-                    }
-                    writer.write(" ");
-                }
-                writer.write(AnsiColour.formatObject(bean));
-            } else {
-                writer.write("Bean of type ");
-                writer.write(beanType.getBeanTypeString(TypeInformation.TypeFormat.ANSI_SIMPLE));
-                writer.write(" does not exist.");
-            }
-
-            writer.newLine();
-        } catch (IOException e) {
-            // ignore, should never happen
-        }
-        switch (this) {
-            case STANDARD_OUT -> System.out.println(sw);
-            case LOG -> LOGGER.trace(sw.toString());
-        }
-    }
-
-    void traceValueResolved(
-        BeanResolutionContext resolutionContext,
-        Argument<?> argument,
-        String property,
-        Object value) {
-        BeanContext context = resolutionContext.getContext();
-        if (context instanceof ApplicationContext applicationContext) {
-            Environment environment = applicationContext.getEnvironment();
-            PropertySource.Origin origin = environment.getPropertyEntry(property)
-                .map(PropertyEntry::origin)
-                .orElse(null);
-            String prefix = padLeft(resolutionContext, 1) + RIGHT_ARROW;
-            StringWriter sw = new StringWriter();
-            try (BufferedWriter writer = new BufferedWriter(sw)) {
-                writer.write(prefix);
-                writer.write(AnsiColour.formatObject(property));
-                writer.write(" = ");
-                writer.write(AnsiColour.formatObject(value));
-                if (origin != null) {
-                    writer.write(" (Origin: " + AnsiColour.brightYellow(origin.location()) + ")");
-                }
-                writer.newLine();
-            } catch (IOException e) {
-                // ignore, should not happen
-            }
-            switch (this) {
-                case STANDARD_OUT -> System.out.println(sw);
-                case LOG -> LOGGER.trace(sw.toString());
-            }
-        }
-    }
-
-    @NotNull
-    private static String padLeft(BeanResolutionContext resolutionContext, int amount) {
-        int size = resolutionContext.getPath().size() + amount;
-        String prefix = "";
-        if (size > 1) {
-            prefix = "   ".repeat(size);
-        }
-        return prefix;
-    }
-
-    void finishTrace(BeanResolutionContext resolutionContext, BeanDefinition<?> rootDefinition) {
-        Object v = resolutionContext.getAttribute(START_TIME);
-        if (v instanceof Long start) {
-            StringWriter sw = new StringWriter();
-            try (BufferedWriter writer = new BufferedWriter(sw)) {
-                writer.newLine();
-                String beanName = rootDefinition.getBeanDescription(TypeInformation.TypeFormat.ANSI_SIMPLE, false);
-                long now = System.currentTimeMillis();
-                writer.write(" Created " + beanName + " in " + (now - start) + "ms");
-                writer.newLine();
-                writer.write("------------");
-                writer.newLine();
-            } catch (IOException e) {
-                // ignore, should not happen
-            }
-            switch (this) {
-                case STANDARD_OUT -> System.out.println(sw);
-                case LOG -> LOGGER.trace(sw.toString());
-            }
-        }
-    }
-
-    void traceSegment(BeanResolutionContext context) {
-        BeanResolutionContext.Path path = context.getPath();
-        BeanResolutionContext.Segment<?, ?> segment = path.peek();
-        if (segment != null) {
-            if (segment.getDeclaringType() != null &&
-                segment.getDeclaringType().getBeanType().isSynthetic() &&
-                segment.getArgument().getName().startsWith("$")) {
-                // skip synthetic arguments
-                return;
-            }
-            int size = path.size();
-            String prefix = "";
-            if (size > 1) {
-                String spaces = "   ".repeat(size);
-                prefix = spaces + RIGHT_ARROW_LOOP;
-            }
-            String content = prefix + segment.toConsoleString(AnsiColour.isSupported());
-            switch (this) {
-                case STANDARD_OUT -> System.out.println(content);
-                case LOG -> LOGGER.trace(content);
-            }
-        }
-    }
-
-    void traceBeanDisabled(BeanResolutionContext resolutionContext, String disabledBeanMessage) {
-        String[] lines = disabledBeanMessage.split("\\r?\\n");
-        String prefix = padLeft(resolutionContext, 3);
-        StringWriter sw = new StringWriter();
-        try (BufferedWriter writer = new BufferedWriter(sw)) {
-            for (String line : lines) {
-                if (StringUtils.isNotEmpty(line.trim())) {
-                    writer.write(prefix);
-                    if (line.startsWith("*")) {
-                        writer.write(" ");
-                        writer.write(line.substring(1));
-                        writer.newLine();
-                    } else {
-                        writer.write(line);
-                        writer.newLine();
-                    }
-                }
-            }
-        } catch (IOException e) {
-            // ignore, should not happen
-        }
-        switch (this) {
-            case STANDARD_OUT -> System.out.println(sw);
-            case LOG -> LOGGER.trace(sw.toString());
-        }
-    }
-
-    void traceConfiguration(
-        Environment environment,
-        @NonNull Collection<BeanDefinitionReference<?>> beanReferences,
-        Collection<DisabledBean<?>> disabledBeans) {
-        Collection<PropertySource> propertySources = environment.getPropertySources();
-        Set<String> activeNames = environment.getActiveNames();
-        StringWriter sw = new StringWriter();
-        try (BufferedWriter writer = new BufferedWriter(sw)) {
-            writer.newLine();
-            writer.write("Configuration Profile");
-            writer.newLine();
-            writer.write("---------------------");
-            writer.newLine();
-            writer.write(AnsiColour.brightBlue("Active Environment Names: ") + activeNames);
-            writer.newLine();
-            writer.newLine();
-            writer.write(AnsiColour.brightBlue("Available Property Sources (Priority Order Highest to Lowest): "));
-            writer.newLine();
-            propertySources.stream().sorted(OrderUtil.REVERSE_ORDERED_COMPARATOR)
-                .forEach(propertySource -> {
-                    try {
-                        writer.write("  ");
-                        writer.write(AnsiColour.formatObject(propertySource));
-                        writer.write(" (");
-                        writer.write(propertySource.getOrigin().location() + ")");
-                        writer.newLine();
-                    } catch (IOException e) {
-                        // ignore.
-                    }
-                });
-            writer.newLine();
-            writer.write(AnsiColour.brightBlue("Configurable Beans: "));
-            writer.newLine();
-            List<BeanDefinitionReference<?>> configRefs = beanReferences.stream()
-                .filter(ref -> ref.hasStereotype(ConfigurationReader.class) &&
-                    ref.stringValue(ConfigurationReader.class, "prefix").isPresent())
-                .sorted((b1, b2) ->
-                    {
-                        String p1 = b1.stringValue(ConfigurationReader.class, "prefix").get();
-                        String p2 = b2.stringValue(ConfigurationReader.class, "prefix").get();
-                        return p1.compareTo(p2);
-                    }
-                ).toList();
-
-            configRefs.forEach(ref -> {
-                String prefix = ref.stringValue(ConfigurationReader.class, "prefix").orElse(null);
-                if (prefix != null) {
-                    Argument<?> argument = ref.asArgument();
-                    try {
-                        writer.write("  ");
-                        writer.write(AnsiColour.formatObject(prefix));
-                        writer.write(RIGHT_ARROW);
-                        writer.write(TypeInformation.TypeFormat.getTypeString(
-                            TypeInformation.TypeFormat.ANSI_SHORTENED,
-                            argument.getType(),
-                            argument.getTypeVariables()
-                        ));
-                        writer.newLine();
-                    } catch (IOException e) {
-                        // ignore
-                    }
-                }
-            });
-            writer.newLine();
-            writer.write(AnsiColour.brightBlue("Applicable Configuration Present: "));
-            writer.newLine();
-            configRefs.stream()
-                .flatMap(ref -> ref.stringValue(ConfigurationReader.class, "prefix").stream())
-                .flatMap(prefix -> {
-                    if (prefix.endsWith(".*")) {
-                        String eachProperty = prefix.substring(0, prefix.length() - 2);
-                        return environment.getPropertyEntries(eachProperty).stream().flatMap(entry ->
-                            {
-                                String path = eachProperty + '.' + entry;
-                                return environment.getPropertyEntries(
-                                    path
-                                ).stream().map(p -> path + '.' + p);
-                            }
-                        );
-                    } else {
-                        return environment.getPropertyEntries(prefix).stream().map(entry ->
-                            prefix + '.' + entry
-                        );
-                    }
-                }).sorted().distinct().forEach(entry -> {
-                    try {
-                        writer.write("  ");
-                        writer.write(AnsiColour.formatObject(entry));
-                        PropertyEntry pe = environment.getPropertyEntry(entry).orElse(null);
-                        if (pe != null) {
-                            String text = " Origin(" + AnsiColour.formatObject(pe.raw()) + " from " + AnsiColour.brightYellow(pe.origin().location()) + ")";
-                            writer.write(text);
-                        }
-                        writer.newLine();
-                    } catch (IOException e) {
-                        // ignore
-                    }
-                });
-            writer.write("---------------------");
-            writer.newLine();
-        } catch (IOException e) {
-            // ignore, should never happen
-        }
-        switch (this) {
-            case STANDARD_OUT -> System.out.println(sw);
-            case LOG -> LOGGER.trace(sw.toString());
-        }
-    }
-}
diff --git a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
index 195f2e14ee..a5e735c2b2 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
@@ -143,13 +143,6 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
         configuration.getContextConfigurer().ifPresent(configurer ->
             configurer.configure(this)
         );
-        if (traceMode != BeanResolutionTraceMode.NONE) {
-            traceMode.traceConfiguration(
-                this.environment,
-                this.getBeanDefinitionReferences(),
-                this.getDisabledBeans()
-            );
-        }
     }
 
     @Override
diff --git a/inject/src/main/java/io/micronaut/context/DefaultApplicationContextBuilder.java b/inject/src/main/java/io/micronaut/context/DefaultApplicationContextBuilder.java
index 16fd7e9e0a..6995ceebf8 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultApplicationContextBuilder.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultApplicationContextBuilder.java
@@ -25,7 +25,6 @@ import io.micronaut.core.cli.CommandLine;
 import io.micronaut.core.io.scan.ClassPathResourceLoader;
 import io.micronaut.core.io.service.SoftServiceLoader;
 import io.micronaut.core.order.OrderUtil;
-import io.micronaut.core.util.ArrayUtils;
 import io.micronaut.core.util.StringUtils;
 
 import java.lang.annotation.Annotation;
@@ -73,8 +72,6 @@ public class DefaultApplicationContextBuilder implements ApplicationContextBuild
     private boolean allowEmptyProviders = false;
     private Boolean bootstrapEnvironment = null;
     private boolean enableDefaultPropertySources = true;
-    private Set<String> traceClasses = BeanResolutionTraceMode.getDefaultTraceClasses();
-    private BeanResolutionTraceMode traceMode = BeanResolutionTraceMode.getDefaultMode(traceClasses);
 
     /**
      * Default constructor.
@@ -92,27 +89,6 @@ public class DefaultApplicationContextBuilder implements ApplicationContextBuild
         this.classLoader = classLoader;
     }
 
-    @Override
-    public ApplicationContextBuilder beanResolutionTrace(
-        BeanResolutionTraceMode traceMode,
-        String... classPatterns) {
-        this.traceMode = traceMode == null ? BeanResolutionTraceMode.NONE : traceMode;
-        if (ArrayUtils.isNotEmpty(classPatterns)) {
-            this.traceClasses = Set.of(classPatterns);
-        }
-        return this;
-    }
-
-    @Override
-    public BeanResolutionTraceMode getTraceMode() {
-        return this.traceMode;
-    }
-
-    @Override
-    public Set<String> getTraceClasses() {
-        return traceClasses;
-    }
-
     private ClassLoader resolveClassLoader() {
         final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
         if (contextClassLoader != null) {
diff --git a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
index 5b6f8803db..ae0471ea4c 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
@@ -113,7 +113,6 @@ import io.micronaut.inject.qualifiers.AnyQualifier;
 import io.micronaut.inject.qualifiers.FilteringQualifier;
 import io.micronaut.inject.qualifiers.Qualified;
 import io.micronaut.inject.qualifiers.Qualifiers;
-import io.micronaut.inject.qualifiers.TypeArgumentQualifier;
 import io.micronaut.inject.validation.BeanDefinitionValidator;
 import jakarta.inject.Singleton;
 import org.slf4j.Logger;
@@ -176,8 +175,6 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     protected final AtomicBoolean initializing = new AtomicBoolean(false);
     protected final AtomicBoolean terminating = new AtomicBoolean(false);
 
-    final @NonNull BeanResolutionTraceMode traceMode;
-    final @NonNull Set<String> tracePatterns;
     final Map<BeanIdentifier, BeanRegistration<?>> singlesInCreation = new ConcurrentHashMap<>(5);
 
     protected final SingletonScope singletonScope = new SingletonScope();
@@ -305,8 +302,6 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         this.eagerInitStereotypesPresent = !configuredEagerSingletonAnnotations.isEmpty();
         this.eagerInitSingletons = eagerInitStereotypesPresent && (configuredEagerSingletonAnnotations.contains(AnnotationUtil.SINGLETON) || configuredEagerSingletonAnnotations.contains(Singleton.class.getName()));
         this.beanContextConfiguration = contextConfiguration;
-        this.traceMode = beanContextConfiguration.getTraceMode();
-        this.tracePatterns = beanContextConfiguration.getTraceClasses();
     }
 
     /**
@@ -633,7 +628,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                     return false;
                 });
         }
-        return foundMethod.map(executableMethod -> new BeanExecutionHandle<>(this, beanDefinition, beanType, qualifier, executableMethod));
+        return foundMethod.map(executableMethod -> new BeanExecutionHandle<>(this, beanType, qualifier, executableMethod));
     }
 
     @Override
@@ -1034,12 +1029,8 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         ArgumentUtils.requireNonNull("beanType", beanType);
         Optional<BeanDefinition<T>> candidate = findBeanDefinition(Argument.of(beanType), qualifier);
         if (candidate.isPresent()) {
-            BeanDefinition<T> beanDefinition = candidate.get();
-            try (BeanResolutionContext resolutionContext = newResolutionContext(beanDefinition, null)) {
-                if (beanDefinition instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
-                    T bean = resolveByBeanFactory(resolutionContext, instantiatableBeanDefinition, qualifier, argumentValues);
-                    return postBeanCreated(resolutionContext, beanDefinition, qualifier, bean);
-                }
+            try (BeanResolutionContext resolutionContext = newResolutionContext(candidate.get(), null)) {
+                return doCreateBean(resolutionContext, candidate.get(), qualifier, argumentValues);
             }
         }
         throw newNoSuchBeanException(
@@ -1059,7 +1050,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         if (candidate.isPresent()) {
             BeanDefinition<T> definition = candidate.get();
             try (BeanResolutionContext resolutionContext = newResolutionContext(definition, null)) {
-                return doCreateBeanWithArguments(resolutionContext, definition, qualifier, args);
+                return doCreateBean(resolutionContext, definition, qualifier, args);
             }
         }
         throw newNoSuchBeanException(
@@ -1071,20 +1062,15 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     }
 
     @NonNull
-    private <T> T doCreateBeanWithArguments(@NonNull BeanResolutionContext resolutionContext,
-                                            @NonNull BeanDefinition<T> definition,
-                                            @Nullable Qualifier<T> qualifier,
-                                            @Nullable Object... args) {
+    private <T> T doCreateBean(@NonNull BeanResolutionContext resolutionContext,
+                               @NonNull BeanDefinition<T> definition,
+                               @Nullable Qualifier<T> qualifier,
+                               @Nullable Object... args) {
         Map<String, Object> argumentValues = resolveArgumentValues(resolutionContext, definition, args);
         if (LOG.isTraceEnabled()) {
             LOG.trace("Computed bean argument values: {}", argumentValues);
         }
-        if (definition instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
-            T bean = resolveByBeanFactory(resolutionContext, instantiatableBeanDefinition, qualifier, argumentValues);
-            return postBeanCreated(resolutionContext, definition, qualifier, bean);
-        } else {
-            throw new BeanInstantiationException("BeanDefinition doesn't support creating a new instance of the bean");
-        }
+        return doCreateBean(resolutionContext, definition, qualifier, argumentValues);
     }
 
     @NonNull
@@ -1392,12 +1378,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         if (concreteCandidate.isPresent()) {
             BeanDefinition<T> candidate = concreteCandidate.get();
             try (BeanResolutionContext context = newResolutionContext(candidate, resolutionContext)) {
-                if (candidate instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
-                    T bean = resolveByBeanFactory(context, instantiatableBeanDefinition, qualifier, Collections.emptyMap());
-                    return postBeanCreated(context, candidate, qualifier, bean);
-                } else {
-                    throw new BeanInstantiationException("BeanDefinition doesn't support creating a new instance of the bean");
-                }
+                return doCreateBean(context, candidate, qualifier);
             }
         }
         throw newNoSuchBeanException(
@@ -1960,10 +1941,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         }
         List<Map.Entry<Class<?>, ListenersSupplier<T>>> eventToListeners = new ArrayList<>(typeToListener.size());
         for (Map.Entry<Class<?>, List<BeanDefinition<T>>> e : typeToListener.entrySet()) {
-            eventToListeners.add(new AbstractMap.SimpleEntry<>(e.getKey(), new EventListenerListenersSupplier<>(
-                Argument.of(listenerType, e.getKey()),
-                e.getValue()
-            )));
+            eventToListeners.add(new AbstractMap.SimpleEntry<>(e.getKey(), new EventListenerListenersSupplier<>(e.getValue())));
         }
         return eventToListeners;
     }
@@ -2304,6 +2282,40 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         beanConfigurations.put(configuration.getName(), configuration);
     }
 
+    /**
+     * Execution the creation of a bean. The returned value can be null if a
+     * factory method returned null.
+     *
+     * @param resolutionContext The {@link BeanResolutionContext}
+     * @param beanDefinition    The {@link BeanDefinition}
+     * @param qualifier         The {@link Qualifier}
+     * @param argumentValues    Any argument values passed to create the bean
+     * @param <T>               The bean generic type
+     * @return The created bean
+     */
+    @Internal
+    @NonNull
+    private <T> T doCreateBean(@NonNull BeanResolutionContext resolutionContext,
+                               @NonNull BeanDefinition<T> beanDefinition,
+                               @Nullable Qualifier<T> qualifier,
+                               @Nullable Map<String, Object> argumentValues) {
+        T bean;
+        if (beanDefinition instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
+            bean = resolveByBeanFactory(resolutionContext, instantiatableBeanDefinition, qualifier, argumentValues);
+        } else {
+            throw new BeanInstantiationException("BeanDefinition doesn't support creating a new instance of the bean");
+        }
+        return postBeanCreated(resolutionContext, beanDefinition, qualifier, bean);
+    }
+
+    @Internal
+    @NonNull
+    private <T> T doCreateBean(@NonNull BeanResolutionContext resolutionContext,
+                               @NonNull BeanDefinition<T> beanDefinition,
+                               @Nullable Qualifier<T> qualifier) {
+        return doCreateBean(resolutionContext, beanDefinition, qualifier, Collections.emptyMap());
+    }
+
     @NonNull
     private <T> T resolveByBeanFactory(@NonNull BeanResolutionContext resolutionContext,
                                        @NonNull BeanDefinition<T> beanDefinition,
@@ -2678,7 +2690,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                 Argument.OBJECT_ARGUMENT
             );
             for (BeanDefinition beanCandidate : beanCandidates) {
-                intializeEagerBean(
+                findOrCreateSingletonBeanRegistration(
                         null,
                         beanCandidate,
                         beanCandidate.asArgument(),
@@ -2687,7 +2699,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
             }
 
         } else {
-            intializeEagerBean(null, beanDefinition, beanDefinition.asArgument(), null);
+            findOrCreateSingletonBeanRegistration(null, beanDefinition, beanDefinition.asArgument(), null);
         }
     }
 
@@ -2975,11 +2987,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         }
 
         if (definition.isSingleton() && !isScopedProxyDefinition) {
-            BeanRegistration<T> beanRegistration = singletonScope.findBeanRegistration(definition, beanType, qualifier);
-            if (beanRegistration != null) {
-                return beanRegistration;
-            }
-            return singletonScope.getOrCreate(this, resolutionContext, definition, beanType, qualifier);
+            return findOrCreateSingletonBeanRegistration(resolutionContext, definition, beanType, qualifier);
         }
 
         final boolean isProxy = definition.isProxy();
@@ -3010,10 +3018,10 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     }
 
     @NonNull
-    private <T> BeanRegistration<T> intializeEagerBean(@Nullable BeanResolutionContext resolutionContext,
-                                                       @NonNull BeanDefinition<T> definition,
-                                                       @NonNull Argument<T> beanType,
-                                                       @Nullable Qualifier<T> qualifier) {
+    private <T> BeanRegistration<T> findOrCreateSingletonBeanRegistration(@Nullable BeanResolutionContext resolutionContext,
+                                                                          @NonNull BeanDefinition<T> definition,
+                                                                          @NonNull Argument<T> beanType,
+                                                                          @Nullable Qualifier<T> qualifier) {
         BeanRegistration<T> beanRegistration = singletonScope.findBeanRegistration(definition, beanType, qualifier);
         if (beanRegistration != null) {
             return beanRegistration;
@@ -3112,29 +3120,11 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
             final BeanResolutionContext.Path path = context.getPath();
             final boolean isNewPath = path.isEmpty();
             if (isNewPath) {
-                Argument<T> resolvedBeanType;
-                if (qualifier instanceof TypeArgumentQualifier<T> taq) {
-                    Class<?>[] typeArguments = taq.getTypeArguments();
-                    resolvedBeanType = Argument.of(
-                        beanType.getType(),
-                        beanType.getAnnotationMetadata(),
-                        typeArguments
-                    );
-                } else {
-                    resolvedBeanType = beanType;
-                }
-                path.pushBeanCreate(definition, resolvedBeanType);
+                path.pushBeanCreate(definition, beanType);
             }
             try {
                 List<BeanRegistration<?>> parentDependentBeans = context.popDependentBeans();
-                T bean;
-                if (definition instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
-                    bean = resolveByBeanFactory(context, instantiatableBeanDefinition, qualifier, Collections.emptyMap());
-                } else {
-                    throw new BeanInstantiationException("BeanDefinition doesn't support creating a new instance of the bean");
-                }
-                bean = postBeanCreated(context, definition, qualifier, bean);
-
+                T bean = doCreateBean(context, definition, qualifier);
                 BeanRegistration<?> dependentFactoryBean = context.getAndResetDependentFactoryBean();
                 if (dependentFactoryBean != null) {
                     destroyBean(dependentFactoryBean);
@@ -3149,7 +3139,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                 return beanRegistration;
             } finally {
                 if (isNewPath) {
-                    path.close();
+                    path.pop();
                 }
             }
         }
@@ -3588,12 +3578,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                                         @NonNull Collection<BeanRegistration<T>> beansOfTypeList) {
         BeanRegistration<T> beanRegistration = null;
         try {
-            beanRegistration = resolveBeanRegistration(
-                resolutionContext,
-                candidate,
-                candidate.asArgument(),
-                candidate.getDeclaredQualifier()
-            );
+            beanRegistration = resolveBeanRegistration(resolutionContext, candidate);
             if (LOG.isDebugEnabled()) {
                 LOG.debug("Found a registration {} for candidate: {} with qualifier: {}", beanRegistration, candidate, qualifier);
             }
@@ -3905,12 +3890,10 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
      * @param <R>
      */
     private static final class BeanExecutionHandle<T, R> extends AbstractExecutionHandle<T, R> {
-        private final DefaultBeanContext beanContext;
+        private final BeanContext beanContext;
         private final Class<T> beanType;
-        private final Argument<T> beanArgument;
         private final Qualifier<T> qualifier;
         private final boolean isSingleton;
-        private final BeanDefinition<T> definition;
 
         private T target;
 
@@ -3920,14 +3903,12 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
          * @param qualifier   The qualifier
          * @param method      The method
          */
-        BeanExecutionHandle(DefaultBeanContext beanContext, BeanDefinition<T> definition, Class<T> beanType, Qualifier<T> qualifier, ExecutableMethod<T, R> method) {
+        BeanExecutionHandle(BeanContext beanContext, Class<T> beanType, Qualifier<T> qualifier, ExecutableMethod<T, R> method) {
             super(method);
             this.beanContext = beanContext;
             this.beanType = beanType;
-            this.beanArgument = Argument.of(beanType);
             this.qualifier = qualifier;
-            this.isSingleton = definition.isSingleton();
-            this.definition = definition;
+            this.isSingleton = beanContext.findBeanDefinition(beanType, qualifier).map(BeanDefinition::isSingleton).orElse(false);
         }
 
         @Override
@@ -3937,10 +3918,8 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                 synchronized (this) { // double check
                     target = this.target;
                     if (target == null) {
-                        try (BeanResolutionContext resolutionContext = beanContext.newResolutionContext(definition, null)) {
-                            target = beanContext.getBean(resolutionContext, beanArgument, qualifier);
-                            this.target = target;
-                        }
+                        target = beanContext.getBean(beanType, qualifier);
+                        this.target = target;
                     }
                 }
             }
@@ -4128,14 +4107,12 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     private final class EventListenerListenersSupplier<T extends EventListener> implements ListenersSupplier<T> {
 
         private final List<BeanDefinition<T>> listenersDefinitions;
-        private final Argument<?> eventType;
         // The supplier can be triggered concurrently.
         // We allow for the listeners collection to be initialized multiple times.
         @SuppressWarnings("java:S3077")
         private volatile List<T> listeners;
 
-        EventListenerListenersSupplier(Argument<?> eventType, List<BeanDefinition<T>> listenersDefinitions) {
-            this.eventType = eventType;
+        public EventListenerListenersSupplier(List<BeanDefinition<T>> listenersDefinitions) {
             this.listenersDefinitions = listenersDefinitions;
         }
 
@@ -4147,20 +4124,10 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                     T listener;
                     if (beanResolutionContext == null) {
                         try (BeanResolutionContext context = newResolutionContext(listenersDefinition, null)) {
-                            try (BeanResolutionContext.Path ignored = context.getPath().pushEventListenerResolve(
-                                listenersDefinition,
-                                eventType
-                            )) {
-                                listener = resolveBeanRegistration(context, listenersDefinition).bean;
-                            }
+                            listener = resolveBeanRegistration(context, listenersDefinition).bean;
                         }
                     } else {
-                        try (BeanResolutionContext.Path ignored = beanResolutionContext.getPath().pushEventListenerResolve(
-                            listenersDefinition,
-                            eventType
-                        )) {
-                            listener = resolveBeanRegistration(beanResolutionContext, listenersDefinition).bean;
-                        }
+                        listener = resolveBeanRegistration(beanResolutionContext, listenersDefinition).bean;
                     }
                     listeners.add(listener);
                 }
diff --git a/inject/src/main/java/io/micronaut/context/DefaultFieldConstructorInjectionPoint.java b/inject/src/main/java/io/micronaut/context/DefaultFieldConstructorInjectionPoint.java
index fe137b45d5..ee2a9b0169 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultFieldConstructorInjectionPoint.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultFieldConstructorInjectionPoint.java
@@ -53,8 +53,4 @@ final class DefaultFieldConstructorInjectionPoint<T> extends DefaultFieldInjecti
         return Argument.ZERO_ARGUMENTS;
     }
 
-    @Override
-    public Class<T> getDeclaringBeanType() {
-        return (Class<T>) declaringType;
-    }
 }
diff --git a/inject/src/main/java/io/micronaut/context/DefaultFieldInjectionPoint.java b/inject/src/main/java/io/micronaut/context/DefaultFieldInjectionPoint.java
index 82b775252b..8da059df49 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultFieldInjectionPoint.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultFieldInjectionPoint.java
@@ -45,7 +45,7 @@ import java.util.Objects;
 class DefaultFieldInjectionPoint<B, T> implements FieldInjectionPoint<B, T>, EnvironmentConfigurable {
 
     private final BeanDefinition declaringBean;
-    protected final Class declaringType;
+    private final Class declaringType;
     private final Class<T> fieldType;
     private final String field;
     private final AnnotationMetadata annotationMetadata;
diff --git a/inject/src/main/java/io/micronaut/context/env/AbstractPropertySourceLoader.java b/inject/src/main/java/io/micronaut/context/env/AbstractPropertySourceLoader.java
index b816830729..aabc83483f 100644
--- a/inject/src/main/java/io/micronaut/context/env/AbstractPropertySourceLoader.java
+++ b/inject/src/main/java/io/micronaut/context/env/AbstractPropertySourceLoader.java
@@ -77,9 +77,7 @@ public abstract class AbstractPropertySourceLoader implements PropertySourceLoad
                 Map<String, Object> finalMap = loadProperties(resourceLoader, fileName, fileExt);
 
                 if (!finalMap.isEmpty()) {
-                    return Optional.of(
-                        createPropertySource(fileName, finalMap, order, PropertySource.Origin.of(fileExt))
-                    );
+                    return Optional.of(createPropertySource(fileName, finalMap, order));
                 }
             }
         }
@@ -94,30 +92,6 @@ public abstract class AbstractPropertySourceLoader implements PropertySourceLoad
      * @param order The order of the property source
      * @return property source
      */
-    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order, PropertySource.Origin origin) {
-        return new MapPropertySource(name, map) {
-            @Override
-            public int getOrder() {
-                return order;
-            }
-
-            @Override
-            public Origin getOrigin() {
-                return origin != null ? origin : super.getOrigin();
-            }
-        };
-    }
-
-
-    /**
-     *
-     * @param name The name of the property source
-     * @param map  The map
-     * @param order The order of the property source
-     * @return property source
-     * @deprecated Use {@link #createPropertySource(String, Map, int, PropertySource.Origin)}
-     */
-    @Deprecated(forRemoval = true)
     protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order) {
         return new MapPropertySource(name, map) {
                             @Override
diff --git a/inject/src/main/java/io/micronaut/context/env/CommandLinePropertySource.java b/inject/src/main/java/io/micronaut/context/env/CommandLinePropertySource.java
index ea63996433..6d61220651 100644
--- a/inject/src/main/java/io/micronaut/context/env/CommandLinePropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/CommandLinePropertySource.java
@@ -47,11 +47,6 @@ public class CommandLinePropertySource extends MapPropertySource {
         super(NAME, resolveValues(commandLine));
     }
 
-    @Override
-    public Origin getOrigin() {
-        return Origin.of("main(String...args)");
-    }
-
     @Override
     public int getOrder() {
         return POSITION;
diff --git a/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java b/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java
index 496608ce85..74340ecaaa 100644
--- a/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java
+++ b/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java
@@ -36,7 +36,6 @@ import io.micronaut.core.order.OrderUtil;
 import io.micronaut.core.reflect.ClassUtils;
 import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.core.util.StringUtils;
-import io.micronaut.core.value.PropertyCatalog;
 import io.micronaut.inject.BeanConfiguration;
 
 import java.io.BufferedReader;
@@ -301,7 +300,7 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
 
     @Override
     public Map<String, Object> refreshAndDiff() {
-        Map<String, DefaultPropertyEntry>[] copiedCatalog = copyCatalog();
+        Map<String, Object>[] copiedCatalog = copyCatalog();
         refresh();
         return diffCatalog(copiedCatalog, catalog);
     }
@@ -598,20 +597,6 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         return SoftServiceLoader.load(PropertySourceLoader.class, getClassLoader());
     }
 
-    @Override
-    public Optional<PropertyEntry> getPropertyEntry(String name) {
-        for (PropertyCatalog propertyCatalog : PropertyCatalog.values()) {
-            Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, propertyCatalog);
-            if (entries != null) {
-                DefaultPropertyEntry entry = entries.get(name);
-                if (entry != null) {
-                    return Optional.of(entry);
-                }
-            }
-        }
-        return Optional.empty();
-    }
-
     /**
      * Obtains the {@link PropertySourceLoader} instances.
      *
@@ -845,11 +830,11 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         }
     }
 
-    private Map<String, Object> diffCatalog(Map<String, DefaultPropertyEntry>[] original, Map<String, DefaultPropertyEntry>[] newCatalog) {
+    private Map<String, Object> diffCatalog(Map<String, Object>[] original, Map<String, Object>[] newCatalog) {
         Map<String, Object> changes = new LinkedHashMap<>();
         for (int i = 0; i < original.length; i++) {
-            Map<String, DefaultPropertyEntry> map = original[i];
-            Map<String, DefaultPropertyEntry> newMap = newCatalog[i];
+            Map<String, Object> map = original[i];
+            Map<String, Object> newMap = newCatalog[i];
             boolean hasNew = newMap != null;
             boolean hasOld = map != null;
             if (!hasOld && hasNew) {
@@ -864,14 +849,13 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         }
         if (!changes.isEmpty()) {
             Map<String, Object> placeholdersAltered = new LinkedHashMap<>();
-            for (Map<String, DefaultPropertyEntry> map :
-                newCatalog) {
+            for (Map<String, Object> map : newCatalog) {
                 if (map != null) {
                     map.forEach((key, v) -> {
-                        if (v.value() instanceof String val) {
+                        if (v instanceof String val) {
                             for (String changed : changes.keySet()) {
                                 if (val.contains(changed)) {
-                                    placeholdersAltered.put(key, v.value());
+                                    placeholdersAltered.put(key, v);
                                 }
                             }
                         }
@@ -883,14 +867,14 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         return changes;
     }
 
-    private void diffMap(Map<String, DefaultPropertyEntry> map, Map<String, DefaultPropertyEntry> newMap, Map<String, Object> changes) {
-        for (Map.Entry<String, DefaultPropertyEntry> entry : newMap.entrySet()) {
+    private void diffMap(Map<String, Object> map, Map<String, Object> newMap, Map<String, Object> changes) {
+        for (Map.Entry<String, Object> entry : newMap.entrySet()) {
             String key = entry.getKey();
-            Object newValue = entry.getValue().value();
+            Object newValue = entry.getValue();
             if (!map.containsKey(key)) {
                 changes.put(key, newValue);
             } else {
-                Object oldValue = map.getOrDefault(key, PropertySourcePropertyResolver.NULL_ENTRY).value();
+                Object oldValue = map.get(key);
                 boolean hasNew = newValue != null;
                 boolean hasOld = oldValue != null;
                 if (hasNew && !hasOld) {
@@ -908,10 +892,10 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         return !Objects.deepEquals(newValue, oldValue);
     }
 
-    private Map<String, DefaultPropertyEntry>[] copyCatalog() {
-        Map<String, DefaultPropertyEntry>[] newCatalog = new Map[catalog.length];
+    private Map<String, Object>[] copyCatalog() {
+        Map<String, Object>[] newCatalog = new Map[catalog.length];
         for (int i = 0; i < catalog.length; i++) {
-            Map<String, DefaultPropertyEntry> entry = catalog[i];
+            Map<String, Object> entry = catalog[i];
             if (entry != null) {
                 newCatalog[i] = new LinkedHashMap<>(entry);
             }
diff --git a/inject/src/main/java/io/micronaut/context/env/DefaultOrigin.java b/inject/src/main/java/io/micronaut/context/env/DefaultOrigin.java
deleted file mode 100644
index dd4cedfc33..0000000000
--- a/inject/src/main/java/io/micronaut/context/env/DefaultOrigin.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.context.env;
-
-/**
- * Default implementation of {@link io.micronaut.context.env.PropertySource.Origin}.
- *
- * @since 4.8.0
- * @param location The location
- */
-record DefaultOrigin(String location) implements PropertySource.Origin {
-}
diff --git a/inject/src/main/java/io/micronaut/context/env/DefaultPropertyEntry.java b/inject/src/main/java/io/micronaut/context/env/DefaultPropertyEntry.java
deleted file mode 100644
index 9b2284ede5..0000000000
--- a/inject/src/main/java/io/micronaut/context/env/DefaultPropertyEntry.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.context.env;
-
-import io.micronaut.core.annotation.Experimental;
-
-/**
- * A property entry models
- *
- * @param property The normalized property key
- * @param value    The property value
- * @param raw      The raw property key that originated the property
- * @param origin
- */
-@Experimental
-record DefaultPropertyEntry(
-    String property,
-    Object value,
-    String raw,
-    PropertySource.Origin origin
-) implements PropertyEntry {
-}
diff --git a/inject/src/main/java/io/micronaut/context/env/Environment.java b/inject/src/main/java/io/micronaut/context/env/Environment.java
index b47e6e617e..bfdff21e43 100644
--- a/inject/src/main/java/io/micronaut/context/env/Environment.java
+++ b/inject/src/main/java/io/micronaut/context/env/Environment.java
@@ -16,8 +16,6 @@
 package io.micronaut.context.env;
 
 import io.micronaut.context.LifeCycle;
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.convert.MutableConversionService;
 import io.micronaut.core.io.ResourceLoader;
@@ -32,7 +30,6 @@ import java.lang.annotation.Annotation;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Map;
-import java.util.Optional;
 import java.util.Set;
 import java.util.stream.Stream;
 
@@ -287,9 +284,7 @@ public interface Environment extends PropertyResolver, LifeCycle<Environment>, M
      * @param name   The name
      * @param values The values
      * @return This environment
-     * @deprecated Use {@link #addPropertySource(PropertySource)}
      */
-    @Deprecated(forRemoval = true, since = "4.8.0")
     default Environment addPropertySource(String name, @Nullable Map<String, ? super Object> values) {
         if (StringUtils.isNotEmpty(name) && CollectionUtils.isNotEmpty(values)) {
             return addPropertySource(PropertySource.of(name, values));
@@ -364,16 +359,4 @@ public interface Environment extends PropertyResolver, LifeCycle<Environment>, M
      * @return A collection of {@link PropertySourceLoader}
      */
     Collection<PropertySourceLoader> getPropertySourceLoaders();
-
-    /**
-     * Resolve information about a property.
-     *
-     * @param name The property name
-     * @return The entry.
-     * @since 4.8.0
-     */
-    @Experimental
-    default Optional<PropertyEntry> getPropertyEntry(@NonNull String name) {
-        return Optional.empty();
-    }
 }
diff --git a/inject/src/main/java/io/micronaut/context/env/EnvironmentPropertySource.java b/inject/src/main/java/io/micronaut/context/env/EnvironmentPropertySource.java
index 6f5464a4ee..c39c02de88 100644
--- a/inject/src/main/java/io/micronaut/context/env/EnvironmentPropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/EnvironmentPropertySource.java
@@ -38,7 +38,6 @@ public class EnvironmentPropertySource extends MapPropertySource {
      * Constant for Environment property source.
      */
     public static final String NAME = "env";
-    public static final Origin ORIGIN = Origin.of("System.env");
 
     /**
      * Default constructor.
@@ -62,11 +61,6 @@ public class EnvironmentPropertySource extends MapPropertySource {
         return POSITION;
     }
 
-    @Override
-    public Origin getOrigin() {
-        return ORIGIN;
-    }
-
     @Override
     public PropertyConvention getConvention() {
         return PropertyConvention.ENVIRONMENT_VARIABLE;
diff --git a/inject/src/main/java/io/micronaut/context/env/KubernetesEnvironmentPropertySource.java b/inject/src/main/java/io/micronaut/context/env/KubernetesEnvironmentPropertySource.java
index 9735bdc01f..e4314f44e3 100644
--- a/inject/src/main/java/io/micronaut/context/env/KubernetesEnvironmentPropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/KubernetesEnvironmentPropertySource.java
@@ -71,11 +71,6 @@ public class KubernetesEnvironmentPropertySource extends MapPropertySource {
         super(NAME, getEnv(getEnvNoK8s(), includes, excludes));
     }
 
-    @Override
-    public Origin getOrigin() {
-        return EnvironmentPropertySource.ORIGIN;
-    }
-
     @Override
     public int getOrder() {
         return EnvironmentPropertySource.POSITION;
diff --git a/inject/src/main/java/io/micronaut/context/env/PropertyEntry.java b/inject/src/main/java/io/micronaut/context/env/PropertyEntry.java
deleted file mode 100644
index 029cae264b..0000000000
--- a/inject/src/main/java/io/micronaut/context/env/PropertyEntry.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.context.env;
-
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.NonNull;
-
-/**
- * A property entry models a configuration property registration within a
- * particular
- *
- * @since 4.8.0
- */
-@Experimental
-public interface PropertyEntry {
-
-    /**
-     * @return The name of the property.
-     */
-    @NonNull
-    String property();
-
-    /**
-     * @return The value of the property.
-     */
-    @NonNull
-    Object value();
-
-    /**
-     * @return The raw name of the property prior to normalization.
-     */
-    @NonNull
-    String raw();
-
-    /**
-     * @return The origin of the property.
-     */
-    @NonNull
-    PropertySource.Origin origin();
-}
diff --git a/inject/src/main/java/io/micronaut/context/env/PropertySource.java b/inject/src/main/java/io/micronaut/context/env/PropertySource.java
index 2c8e6cacf5..3d49dc3b2d 100644
--- a/inject/src/main/java/io/micronaut/context/env/PropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/PropertySource.java
@@ -15,13 +15,10 @@
  */
 package io.micronaut.context.env;
 
-import io.micronaut.core.annotation.Experimental;
-import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.order.Ordered;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.Objects;
 
 /**
  * A PropertySource is a location to resolve property values from. The property keys are available via the
@@ -50,14 +47,6 @@ public interface PropertySource extends Iterable<String>, Ordered {
      */
     Object get(String key);
 
-    /**
-     * @return The origin of the property source.
-     * @since 4.8.0
-     */
-    default @NonNull Origin getOrigin() {
-        return Origin.of(getName());
-    }
-
     /**
      * @return Whether the property source has upper case underscore separated keys
      */
@@ -76,23 +65,6 @@ public interface PropertySource extends Iterable<String>, Ordered {
         return new MapPropertySource(name, map);
     }
 
-    /**
-     * Create a {@link PropertySource} from the given map.
-     *
-     * @param name The name of the property source
-     * @param map  The map
-     * @param origin The origin
-     * @return The {@link PropertySource}
-     */
-    static PropertySource of(String name, Map<String, Object> map, Origin origin) {
-        return new MapPropertySource(name, map) {
-            @Override
-            public Origin getOrigin() {
-                return origin != null ? origin : super.getOrigin();
-            }
-        };
-    }
-
     /**
      * Create a {@link PropertySource} from the given map.
      *
@@ -100,13 +72,8 @@ public interface PropertySource extends Iterable<String>, Ordered {
      * @param map        The map
      * @param convention The convention type of the property source
      * @return The {@link PropertySource}
-     * @deprecated Use {@link #of(String, Map, PropertyConvention, Origin)}
      */
-    @Deprecated(forRemoval = true, since = "4.8.0")
-    static PropertySource of(
-        String name,
-        Map<String, Object> map,
-        PropertyConvention convention) {
+    static PropertySource of(String name, Map<String, Object> map, PropertyConvention convention) {
         return new MapPropertySource(name, map) {
             @Override
             public PropertyConvention getConvention() {
@@ -115,33 +82,6 @@ public interface PropertySource extends Iterable<String>, Ordered {
         };
     }
 
-    /**
-     * Create a {@link PropertySource} from the given map.
-     *
-     * @param name       The name of the property source
-     * @param map        The map
-     * @param convention The convention type of the property source
-     * @param origin     The origin
-     * @return The {@link PropertySource}
-     */
-    static PropertySource of(
-        String name,
-        Map<String, Object> map,
-        PropertyConvention convention,
-        Origin origin) {
-        return new MapPropertySource(name, map) {
-            @Override
-            public PropertyConvention getConvention() {
-                return convention;
-            }
-
-            @Override
-            public Origin getOrigin() {
-                return origin != null ? origin : super.getOrigin();
-            }
-        };
-    }
-
     /**
      * Create a {@link PropertySource} from the given map.
      *
@@ -149,9 +89,7 @@ public interface PropertySource extends Iterable<String>, Ordered {
      * @param values The values as an array of alternating key/value entries
      * @return The {@link PropertySource}
      * @since 2.0
-     * @deprecated Use {@link #of(String, Map, Origin)}
      */
-    @Deprecated(forRemoval = true)
     static PropertySource of(String name, Object... values) {
         return new MapPropertySource(name, mapOf(values));
     }
@@ -197,30 +135,6 @@ public interface PropertySource extends Iterable<String>, Ordered {
         };
     }
 
-    /**
-     * Create a {@link PropertySource} from the given map.
-     *
-     * @param name     The name of the property source
-     * @param map      The map
-     * @param origin   The origin
-     * @param priority The priority to order by
-     * @return The {@link PropertySource}
-     * @since 4.8.0
-     */
-    static PropertySource of(String name, Map<String, Object> map, Origin origin, int priority) {
-        return new MapPropertySource(name, map) {
-            @Override
-            public int getOrder() {
-                return priority;
-            }
-
-            @Override
-            public Origin getOrigin() {
-                return origin != null ? origin : super.getOrigin();
-            }
-        };
-    }
-
     /**
      * Create a {@link PropertySource} named {@link Environment#DEFAULT_NAME} from the given map.
      *
@@ -246,26 +160,4 @@ public interface PropertySource extends Iterable<String>, Ordered {
          */
         JAVA_PROPERTIES
     }
-
-    /**
-     * The origin of the property source.
-     * @since 4.8.0
-     */
-    @Experimental
-    sealed interface Origin permits DefaultOrigin {
-        /**
-         * @return The location.
-         */
-        String location();
-
-        /**
-         * Create an origin from a location.
-         * @param location The location
-         * @return The origin
-         */
-        static @NonNull Origin of(@NonNull String location) {
-            Objects.requireNonNull(location, "Location cannot be null");
-            return new DefaultOrigin(location);
-        }
-    }
 }
diff --git a/inject/src/main/java/io/micronaut/context/env/PropertySourcePropertyResolver.java b/inject/src/main/java/io/micronaut/context/env/PropertySourcePropertyResolver.java
index c477887455..88f917ba9e 100644
--- a/inject/src/main/java/io/micronaut/context/env/PropertySourcePropertyResolver.java
+++ b/inject/src/main/java/io/micronaut/context/env/PropertySourcePropertyResolver.java
@@ -31,7 +31,6 @@ import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.core.util.EnvironmentProperties;
 import io.micronaut.core.util.StringUtils;
 import io.micronaut.core.value.MapPropertyResolver;
-import io.micronaut.core.value.PropertyCatalog;
 import io.micronaut.core.value.PropertyResolver;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -64,9 +63,6 @@ import java.util.regex.Pattern;
  */
 public class PropertySourcePropertyResolver implements PropertyResolver, AutoCloseable {
 
-    public static final DefaultPropertyEntry NULL_ENTRY = new DefaultPropertyEntry(
-        "NULL", null, null, null
-    );
     private static final EnvironmentProperties CURRENT_ENV = StaticOptimizations.get(EnvironmentProperties.class)
             .orElseGet(EnvironmentProperties::empty);
     private static final Pattern DOT_PATTERN = Pattern.compile("\\.");
@@ -80,9 +76,9 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
     // properties are stored in an array of maps organized by character in the alphabet
     // this allows optimization of searches by prefix
     @SuppressWarnings("MagicNumber")
-    protected final Map<String, DefaultPropertyEntry>[] catalog = new Map[58];
-    protected final Map<String, DefaultPropertyEntry>[] rawCatalog = new Map[58];
-    protected final Map<String, DefaultPropertyEntry>[] nonGenerated = new Map[58];
+    protected final Map<String, Object>[] catalog = new Map[58];
+    protected final Map<String, Object>[] rawCatalog = new Map[58];
+    protected final Map<String, Object>[] nonGenerated = new Map[58];
 
     protected Logger log;
 
@@ -175,7 +171,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         Boolean result = containsCache.get(name);
         if (result == null) {
             for (PropertyCatalog convention : CONVENTIONS) {
-                Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, convention);
+                Map<String, Object> entries = resolveEntriesForKey(name, false, convention);
                 if (entries != null) {
                     if (entries.containsKey(name)) {
                         result = true;
@@ -197,7 +193,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
             return false;
         }
         for (PropertyCatalog propertyCatalog : CONVENTIONS) {
-            Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, propertyCatalog);
+            Map<String, Object> entries = resolveEntriesForKey(name, false, propertyCatalog);
             if (entries != null) {
                 if (entries.containsKey(name)) {
                     return true;
@@ -226,7 +222,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         if (StringUtils.isEmpty(name)) {
             return Collections.emptySet();
         }
-        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, PropertyCatalog.valueOf(propertyCatalog.name()));
+        Map<String, Object> entries = resolveEntriesForKey(name, false, PropertyCatalog.valueOf(propertyCatalog.name()));
         if (entries == null) {
             return Collections.emptySet();
         }
@@ -254,7 +250,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         if (StringUtils.isEmpty(pathPattern)) {
             return Collections.emptySet();
         }
-        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(pathPattern, false, null);
+        Map<String, Object> entries = resolveEntriesForKey(pathPattern, false, null);
         if (entries == null) {
             return Collections.emptySet();
         }
@@ -295,7 +291,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         if (StringUtils.isEmpty(name)) {
             return Collections.emptyMap();
         }
-        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, keyFormat == StringConvention.RAW ? PropertyCatalog.RAW : PropertyCatalog.GENERATED);
+        Map<String, Object> entries = resolveEntriesForKey(name, false, keyFormat == StringConvention.RAW ? PropertyCatalog.RAW : PropertyCatalog.GENERATED);
         if (entries != null) {
             if (keyFormat == null) {
                 keyFormat = StringConvention.RAW;
@@ -340,7 +336,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         }
         Object value = placeholderResolutionCache.get(name);
         // entries map to get the value from, only populated if there's a cache miss with placeholderResolutionCache
-        Map<String, DefaultPropertyEntry> entries = null;
+        Map<String, Object> entries = null;
         if (value == null) {
             entries = resolveEntriesForKey(name, false, PropertyCatalog.GENERATED);
             if (entries == null) {
@@ -349,14 +345,14 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         }
         if (entries != null || value != null) {
             if (value == null) {
-                value = entries.getOrDefault(name, NULL_ENTRY).value();
+                value = entries.get(name);
             }
             if (value == null) {
-                value = entries.getOrDefault(normalizeName(name), NULL_ENTRY).value();
+                value = entries.get(normalizeName(name));
                 if (value == null && name.indexOf('[') == -1) {
                     // last chance lookup the raw value
-                    Map<String, DefaultPropertyEntry> rawEntries = resolveEntriesForKey(name, false, PropertyCatalog.RAW);
-                    value = rawEntries != null ? rawEntries.getOrDefault(name, NULL_ENTRY).value() : null;
+                    Map<String, Object> rawEntries = resolveEntriesForKey(name, false, PropertyCatalog.RAW);
+                    value = rawEntries != null ? rawEntries.get(name) : null;
                     if (value != null) {
                         entries = rawEntries;
                     }
@@ -366,7 +362,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
                 int i = name.indexOf('[');
                 if (i > -1 && name.endsWith("]")) {
                     String newKey = name.substring(0, i);
-                    value = entries.getOrDefault(newKey, NULL_ENTRY).value();
+                    value = entries.get(newKey);
                     String index = name.substring(i + 1, name.length() - 1);
                     if (StringUtils.isNotEmpty(index)) {
                         if (value != null) {
@@ -385,7 +381,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
                             }
                         } else {
                             String subKey = newKey + '.' + index;
-                            value = entries.getOrDefault(subKey, NULL_ENTRY).value();
+                            value = entries.get(subKey);
                         }
                     }
                 }
@@ -460,9 +456,9 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
             .filter(Objects::nonNull)
             .map(Map::entrySet)
             .flatMap(Collection::stream)
-            .forEach((Map.Entry<String, DefaultPropertyEntry> entry) -> {
+            .forEach((Map.Entry<String, Object> entry) -> {
                 String k = keyConvention.format(entry.getKey());
-                Object value = resolvePlaceHoldersIfNecessary(entry.getValue().value());
+                Object value = resolvePlaceHoldersIfNecessary(entry.getValue());
                 Map finalMap = map;
                 int index = k.indexOf('.');
                 if (index != -1 && isNested) {
@@ -491,7 +487,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
      * @param conversionContext The conversion context
      * @return The subproperties
      */
-    protected Properties resolveSubProperties(String name, Map<String, DefaultPropertyEntry> entries, ArgumentConversionContext<?> conversionContext) {
+    protected Properties resolveSubProperties(String name, Map<String, Object> entries, ArgumentConversionContext<?> conversionContext) {
         // special handling for maps for resolving sub keys
         Properties properties = new Properties();
         AnnotationMetadata annotationMetadata = conversionContext.getAnnotationMetadata();
@@ -504,8 +500,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         entries.entrySet().stream()
             .filter(map -> map.getKey().startsWith(prefix))
             .forEach(entry -> {
-                DefaultPropertyEntry propertyEntry = entry.getValue();
-                Object value = propertyEntry.value();
+                Object value = entry.getValue();
                 if (value != null) {
                     String key = entry.getKey().substring(prefix.length());
                     key = keyConvention != null ? keyConvention.format(key) : key;
@@ -522,7 +517,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
      * @param conversionContext The conversion context
      * @return The submap
      */
-    protected Map<String, Object> resolveSubMap(String name, Map<String, DefaultPropertyEntry> entries, ArgumentConversionContext<?> conversionContext) {
+    protected Map<String, Object> resolveSubMap(String name, Map<String, Object> entries, ArgumentConversionContext<?> conversionContext) {
         // special handling for maps for resolving sub keys
         AnnotationMetadata annotationMetadata = conversionContext.getAnnotationMetadata();
         StringConvention keyConvention = annotationMetadata.enumValue(MapFormat.class, "keyFormat", StringConvention.class).orElse(null);
@@ -550,7 +545,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
     @NonNull
     protected Map<String, Object> resolveSubMap(
             String name,
-            Map<String, DefaultPropertyEntry> entries,
+            Map<String, Object> entries,
             ArgumentConversionContext<?> conversionContext,
             @Nullable StringConvention keyConvention,
             MapFormat.MapTransformation transformation) {
@@ -559,7 +554,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         Map<String, Object> subMap = CollectionUtils.newLinkedHashMap(entries.size());
 
         String prefix = name + '.';
-        for (Map.Entry<String, DefaultPropertyEntry> entry : entries.entrySet()) {
+        for (Map.Entry<String, Object> entry : entries.entrySet()) {
             final String key = entry.getKey();
 
             if (valueTypeIsList && key.contains("[") && key.endsWith("]")) {
@@ -569,7 +564,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
             if (key.startsWith(prefix)) {
                 String subMapKey = key.substring(prefix.length());
 
-                Object value = resolvePlaceHoldersIfNecessary(entry.getValue().value());
+                Object value = resolvePlaceHoldersIfNecessary(entry.getValue());
 
                 if (transformation == MapFormat.MapTransformation.FLAT) {
                     subMapKey = keyConvention != null ? keyConvention.format(subMapKey) : subMapKey;
@@ -608,74 +603,39 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
                     int i = resolvedProperty.indexOf('[');
                     if (i > -1) {
                         String propertyName = resolvedProperty.substring(0, i);
-                        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(propertyName, true, PropertyCatalog.GENERATED);
+                        Map<String, Object> entries = resolveEntriesForKey(propertyName, true, PropertyCatalog.GENERATED);
                         if (entries != null) {
-                            entries.put(resolvedProperty, new DefaultPropertyEntry(
-                                resolvedProperty,
-                                value,
-                                property,
-                                properties.getOrigin()
-                            ));
-                            expandProperty(
-                                resolvedProperty.substring(i),
-                                val -> entries.put(propertyName, new DefaultPropertyEntry(
-                                    propertyName,
-                                    val,
-                                    property,
-                                    properties.getOrigin()
-                                )),
-                                () -> entries.getOrDefault(propertyName, NULL_ENTRY).value(),
-                                value
-                            );
+                            entries.put(resolvedProperty, value);
+                            expandProperty(resolvedProperty.substring(i), val -> entries.put(propertyName, val), () -> entries.get(propertyName), value);
                         }
                         if (first) {
-                            Map<String, DefaultPropertyEntry> normalized = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.NORMALIZED);
+                            Map<String, Object> normalized = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.NORMALIZED);
                             if (normalized != null) {
-                                normalized.put(propertyName, new DefaultPropertyEntry(
-                                    propertyName,
-                                    value,
-                                    property,
-                                    properties.getOrigin()
-                                ));
+                                normalized.put(propertyName, value);
                             }
                             first = false;
                         }
                     } else {
-                        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.GENERATED);
+                        Map<String, Object> entries = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.GENERATED);
                         if (entries != null) {
                             if (value instanceof List || value instanceof Map) {
-                                collapseProperty(property, resolvedProperty, entries, value, properties.getOrigin());
+                                collapseProperty(resolvedProperty, entries, value);
                             }
-                            entries.put(resolvedProperty, new DefaultPropertyEntry(
-                                resolvedProperty,
-                                value,
-                                property,
-                                properties.getOrigin()
-                            ));
+                            entries.put(resolvedProperty, value);
                         }
                         if (first) {
-                            Map<String, DefaultPropertyEntry> normalized = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.NORMALIZED);
+                            Map<String, Object> normalized = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.NORMALIZED);
                             if (normalized != null) {
-                                normalized.put(resolvedProperty, new DefaultPropertyEntry(
-                                    resolvedProperty,
-                                    value,
-                                    property,
-                                    properties.getOrigin()
-                                ));
+                                normalized.put(resolvedProperty, value);
                             }
                             first = false;
                         }
                     }
                 }
 
-                final Map<String, DefaultPropertyEntry> rawEntries = resolveEntriesForKey(property, true, PropertyCatalog.RAW);
+                final Map<String, Object> rawEntries = resolveEntriesForKey(property, true, PropertyCatalog.RAW);
                 if (rawEntries != null) {
-                    rawEntries.put(property, new DefaultPropertyEntry(
-                        property,
-                        value,
-                        property,
-                        properties.getOrigin()
-                    ));
+                    rawEntries.put(property, value);
                 }
             }
         }
@@ -737,39 +697,24 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         }
     }
 
-    private void collapseProperty(
-        String originalProperty,
-        String prefix,
-        Map<String, DefaultPropertyEntry> entries,
-        Object value,
-        PropertySource.Origin origin) {
+    private void collapseProperty(String prefix, Map<String, Object> entries, Object value) {
         if (value instanceof List<?> list) {
             for (int i = 0; i < list.size(); i++) {
                 Object item = list.get(i);
                 if (item != null) {
-                    collapseProperty(originalProperty, prefix + "[" + i + "]", entries, item, origin);
+                    collapseProperty(prefix + "[" + i + "]", entries, item);
                 }
             }
-            entries.put(prefix, new DefaultPropertyEntry(
-                prefix,
-                value,
-                originalProperty,
-                origin
-            ));
+            entries.put(prefix, value);
         } else if (value instanceof Map<?, ?> map) {
             for (Map.Entry<?, ?> entry: map.entrySet()) {
                 Object key = entry.getKey();
                 if (key instanceof CharSequence charSequence) {
-                    collapseProperty(originalProperty, prefix + "." + charSequence, entries, entry.getValue(), origin);
+                    collapseProperty(prefix + "." + charSequence, entries, entry.getValue());
                 }
             }
         } else {
-            entries.put(prefix, new DefaultPropertyEntry(
-                prefix,
-                value,
-                originalProperty,
-                origin
-            ));
+            entries.put(prefix, value);
         }
     }
 
@@ -780,13 +725,13 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
      * @return The map with the resolved entries for the name
      */
     @SuppressWarnings("MagicNumber")
-    protected Map<String, DefaultPropertyEntry> resolveEntriesForKey(String name, boolean allowCreate, @Nullable PropertyCatalog propertyCatalog) {
+    protected Map<String, Object> resolveEntriesForKey(String name, boolean allowCreate, @Nullable PropertyCatalog propertyCatalog) {
         if (name.isEmpty()) {
             return null;
         }
-        final Map<String, DefaultPropertyEntry>[] catalog = getCatalog(propertyCatalog);
+        final Map<String, Object>[] catalog = getCatalog(propertyCatalog);
 
-        Map<String, DefaultPropertyEntry> entries = null;
+        Map<String, Object> entries = null;
         char firstChar = name.charAt(0);
         if (Character.isLetter(firstChar)) {
             int index = firstChar - 65;
@@ -801,12 +746,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         return entries;
     }
 
-    /**
-     * Obtain a property catalog.
-     * @param propertyCatalog The catalog
-     * @return The catalog
-     */
-    private Map<String, DefaultPropertyEntry>[] getCatalog(@Nullable PropertyCatalog propertyCatalog) {
+    private Map<String, Object>[] getCatalog(@Nullable PropertyCatalog propertyCatalog) {
         propertyCatalog = propertyCatalog != null ? propertyCatalog : PropertyCatalog.GENERATED;
         return switch (propertyCatalog) {
             case RAW -> this.rawCatalog;
@@ -901,6 +841,31 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         }
     }
 
+    /**
+     * The property catalog to use.
+     *
+     * @deprecated Replaced by {@link io.micronaut.core.value.PropertyCatalog}
+     */
+    @Deprecated(forRemoval = true)
+    protected enum PropertyCatalog {
+        /**
+         * The catalog that contains the raw keys.
+         */
+        RAW,
+        /**
+         * The catalog that contains normalized keys. A key is normalized into
+         * lower case hyphen separated form. For example an environment variable {@code FOO_BAR} would be
+         * normalized to {@code foo.bar}.
+         */
+        NORMALIZED,
+        /**
+         * The catalog that contains normalized keys and also generated keys. A synthetic key can be generated from
+         * an environment variable such as {@code FOO_BAR_BAZ} which will produce the following keys: {@code foo.bar.baz},
+         * {@code foo.bar-baz}, and {@code foo-bar.baz}.
+         */
+        GENERATED
+    }
+
     private record ConversionCacheKey(@NonNull String name, Class<?> requiredType) {
 
         @Override
diff --git a/inject/src/main/java/io/micronaut/context/env/SystemPropertiesPropertySource.java b/inject/src/main/java/io/micronaut/context/env/SystemPropertiesPropertySource.java
index a3095438c7..105eaa1468 100644
--- a/inject/src/main/java/io/micronaut/context/env/SystemPropertiesPropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/SystemPropertiesPropertySource.java
@@ -44,9 +44,4 @@ public class SystemPropertiesPropertySource extends MapPropertySource {
     public int getOrder() {
         return POSITION;
     }
-
-    @Override
-    public Origin getOrigin() {
-        return Origin.of("System.properties");
-    }
 }
diff --git a/inject/src/main/java/io/micronaut/context/exceptions/MessageUtils.java b/inject/src/main/java/io/micronaut/context/exceptions/MessageUtils.java
index 545c87658a..e564d95e0b 100644
--- a/inject/src/main/java/io/micronaut/context/exceptions/MessageUtils.java
+++ b/inject/src/main/java/io/micronaut/context/exceptions/MessageUtils.java
@@ -176,7 +176,7 @@ class MessageUtils {
     private static void appendPath(boolean circular, StringBuilder builder, String ls, BeanResolutionContext.Path path) {
         builder.append("Path Taken:");
         if (circular) {
-            builder.append(ls).append(path.toConsoleCircularString(false));
+            builder.append(ls).append(path.toCircularString());
         } else {
             builder.append(" ").append(path);
         }
diff --git a/inject/src/main/java/io/micronaut/inject/BeanDefinition.java b/inject/src/main/java/io/micronaut/inject/BeanDefinition.java
index 2f6300f48c..b5d2363d41 100644
--- a/inject/src/main/java/io/micronaut/inject/BeanDefinition.java
+++ b/inject/src/main/java/io/micronaut/inject/BeanDefinition.java
@@ -15,15 +15,11 @@
  */
 package io.micronaut.inject;
 
-import static io.micronaut.core.annotation.AnnotationUtil.ANN_ADAPTER;
-import static io.micronaut.core.type.TypeInformation.TypeFormat.getBeanTypeString;
-
 import io.micronaut.context.Qualifier;
 import io.micronaut.context.annotation.ConfigurationReader;
 import io.micronaut.context.annotation.DefaultScope;
 import io.micronaut.context.annotation.EachBean;
 import io.micronaut.context.annotation.EachProperty;
-import io.micronaut.core.annotation.AnnotationMetadata;
 import io.micronaut.core.annotation.AnnotationUtil;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
@@ -31,10 +27,6 @@ import io.micronaut.core.naming.Named;
 import io.micronaut.core.reflect.ReflectionUtils;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.ArgumentCoercible;
-import io.micronaut.core.type.TypeInformation;
-import io.micronaut.core.type.TypeInformation.TypeFormat;
-import io.micronaut.core.util.AnsiColour;
-import io.micronaut.inject.proxy.InterceptedBean;
 import jakarta.inject.Singleton;
 
 import java.lang.annotation.Annotation;
@@ -42,7 +34,6 @@ import java.lang.reflect.Modifier;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
-import java.util.Map;
 import java.util.Optional;
 import java.util.stream.Stream;
 
@@ -56,72 +47,6 @@ import java.util.stream.Stream;
  */
 public interface BeanDefinition<T> extends QualifiedBeanType<T>, Named, BeanType<T>, ArgumentCoercible<T> {
 
-    /**
-     * @return The type information for the bean.
-     * @since 4.8.0
-     */
-    default @NonNull TypeInformation<T> getTypeInformation() {
-        return new TypeInformation<>() {
-            @Override
-            public String getBeanTypeString(TypeFormat format) {
-                Class<T> beanType = getType();
-                boolean synthetic = beanType.isSynthetic();
-                if (synthetic) {
-                    AnnotationMetadata annotationMetadata = getAnnotationMetadata();
-                    // synthetic bean so produce better formatting.
-                    if (annotationMetadata.hasDeclaredStereotype(ANN_ADAPTER)) {
-                        @SuppressWarnings("unchecked") ExecutableMethod<Object, ?> method =
-                            (ExecutableMethod<Object, ?>) BeanDefinition.this.getExecutableMethods().iterator().next();
-                        // Not great, but to produce accurate debug output we have to reach into AOP internals
-                        Class<?> resolvedBeanType = method.classValue(ANN_ADAPTER, "adaptedBean")
-                            .orElse(beanType);
-                        return TypeFormat.getBeanTypeString(
-                            format,
-                            resolvedBeanType,
-                            getGenericBeanType().getTypeVariables(),
-                            annotationMetadata
-                        );
-                    } else if (InterceptedBean.class.isAssignableFrom(beanType)) {
-                        if (beanType.isInterface()) {
-                            return TypeFormat.getBeanTypeString(
-                                format,
-                                beanType.getInterfaces()[0],
-                                getGenericBeanType().getTypeVariables(),
-                                annotationMetadata
-                            );
-                        } else {
-                            return TypeFormat.getBeanTypeString(
-                                format,
-                                beanType.getSuperclass(),
-                                getGenericBeanType().getTypeVariables(),
-                                annotationMetadata
-                            );
-                        }
-                    } else {
-                        return TypeInformation.super.getBeanTypeString(format);
-                    }
-                } else {
-                    return TypeInformation.super.getBeanTypeString(format);
-                }
-            }
-
-            @Override
-            public Class<T> getType() {
-                return getBeanType();
-            }
-
-            @Override
-            public Map<String, Argument<?>> getTypeVariables() {
-                return BeanDefinition.this.getGenericBeanType().getTypeVariables();
-            }
-
-            @Override
-            public AnnotationMetadata getAnnotationMetadata() {
-                return BeanDefinition.this.getAnnotationMetadata();
-            }
-        };
-    }
-
     /**
      * @return The scope of the bean
      */
@@ -261,10 +186,6 @@ public interface BeanDefinition<T> extends QualifiedBeanType<T>, Named, BeanType
                 return BeanDefinition.this;
             }
 
-            @Override
-            public String toString() {
-                return getDeclaringBeanType().getName() + "(" + Argument.toString(getArguments()) + ")";
-            }
         };
     }
 
@@ -369,7 +290,6 @@ public interface BeanDefinition<T> extends QualifiedBeanType<T>, Named, BeanType
     default Argument<T> asArgument() {
         return Argument.of(
                 getBeanType(),
-                getAnnotationMetadata(),
                 getTypeParameters()
         );
     }
@@ -490,162 +410,4 @@ public interface BeanDefinition<T> extends QualifiedBeanType<T>, Named, BeanType
     default @Nullable Qualifier<T> resolveDynamicQualifier() {
         return QualifiedBeanType.super.resolveDynamicQualifier();
     }
-
-    /**
-     * Gets a description of the bean as close as possible to source representation.
-     * @param typeFormat The type format to use.
-     * @param includeArguments Whether to include arguments.
-     * @return The bean description.
-     * @since 4.8.0
-     */
-    default @NonNull String getBeanDescription(@NonNull TypeFormat typeFormat, boolean includeArguments) {
-        ConstructorInjectionPoint<T> constructor = getConstructor();
-        StringBuilder beanDescription = new StringBuilder();
-        Argument<?>[] arguments = constructor.getArguments();
-        if (constructor instanceof MethodInjectionPoint<?,?> methodInjectionPoint) {
-            // factory bean with method
-            Class<?> declaringType = methodInjectionPoint.getDeclaringType();
-            Class<T> declaringBeanType = constructor.getDeclaringBeanType();
-            String factoryType = TypeFormat.getTypeString(
-                typeFormat,
-                declaringBeanType,
-                Map.of()
-            );
-            String beanTypeName = getBeanTypeString(
-                typeFormat,
-                declaringType,
-                asArgument().getTypeVariables(),
-                methodInjectionPoint.getAnnotationMetadata()
-            );
-
-            beanDescription.append(beanTypeName).append(" ");
-            beanDescription.append(factoryType)
-                .append(".")
-                .append(methodInjectionPoint.getName());
-        } else if (constructor instanceof FieldInjectionPoint<?,?> fieldInjectionPoint) {
-            // factory bean with method
-            Class<T> declaringBeanType = constructor.getDeclaringBeanType();
-            String factoryType = TypeFormat.getTypeString(
-                typeFormat,
-                declaringBeanType,
-                Map.of()
-            );
-            Class<?> declaringType = fieldInjectionPoint.getDeclaringBean().getBeanType();
-            String beanTypeName = getBeanTypeString(
-                typeFormat,
-                declaringType,
-                asArgument().getTypeVariables(),
-                fieldInjectionPoint.getAnnotationMetadata()
-            );
-            beanDescription.append(beanTypeName).append(" ");
-            beanDescription.append(factoryType)
-                .append(".")
-                .append(fieldInjectionPoint.getName());
-            return beanDescription.toString();
-        } else {
-            boolean synthetic = getBeanType().isSynthetic();
-            if (synthetic) {
-                // AOP proxy or generated event listener
-                AnnotationMetadata annotationMetadata = getAnnotationMetadata();
-                if (annotationMetadata.hasDeclaredStereotype(ANN_ADAPTER)) {
-                    @SuppressWarnings("unchecked") ExecutableMethod<Object, ?> method =
-                        (ExecutableMethod<Object, ?>) getExecutableMethods().iterator().next();
-                    // Not great, but to produce accurate debug output we have to reach into AOP internals
-                    Class<?> adaptedType = method.classValue(ANN_ADAPTER).orElse(getBeanType());
-                    Class<?> beanType = method.classValue(ANN_ADAPTER, "adaptedBean").orElse(getBeanType());
-                    String beanMethod = method.stringValue(ANN_ADAPTER, "adaptedMethod").orElse("unknown");
-                    String beanTypeString = getBeanTypeString(
-                        typeFormat,
-                        beanType,
-                        asArgument().getTypeVariables(),
-                        annotationMetadata
-                    );
-                    beanDescription.append(beanTypeString)
-                        .append(".")
-                        .append(beanMethod);
-                    @NonNull Argument<?>[] methodArguments = method.getArguments();
-                    List<Argument<?>> typeArguments = getTypeArguments(adaptedType);
-                    if (typeArguments.size() == methodArguments.length) {
-                        arguments = new Argument[methodArguments.length];
-                        for (int i = 0; i < methodArguments.length; i++) {
-                            @NonNull Argument<?> methodArgument = methodArguments[i];
-                            Argument<?> t = typeArguments.get(i);
-                            arguments[i] = Argument.of(
-                                t.getType(),
-                                methodArgument.getName(),
-                                methodArgument.getAnnotationMetadata(),
-                                t.getTypeParameters()
-                            );
-                        }
-                    }
-                } else {
-                    Class<T> beanType = getBeanType();
-                    String beanTypeString;
-                    if (beanType.isInterface()) {
-                        beanTypeString = getBeanTypeString(
-                            typeFormat,
-                            beanType.getInterfaces()[0],
-                            asArgument().getTypeVariables(),
-                            annotationMetadata
-                        );
-                    } else {
-                        beanTypeString = getBeanTypeString(
-                            typeFormat,
-                            beanType.getSuperclass(),
-                            asArgument().getTypeVariables(),
-                            annotationMetadata
-                        );
-                    }
-                    beanDescription.append(beanTypeString);
-                }
-            } else {
-                beanDescription.append(
-                    getTypeInformation().getBeanTypeString(typeFormat)
-                );
-            }
-        }
-
-        if (includeArguments) {
-            beanDescription.append(typeFormat.isAnsi() ? AnsiColour.brightCyan("(") : "(");
-
-            for (int i = 0; i < arguments.length; i++) {
-                Argument<?> argument = arguments[i];
-                if (argument.getName().startsWith("$")) {
-                    // skip internal
-                    continue;
-                }
-                String argType = getBeanTypeString(
-                    typeFormat,
-                    argument
-                );
-                String argumentName = argument.getName();
-                beanDescription.append(argType)
-                    .append(" ")
-                    .append(typeFormat.isAnsi() ? AnsiColour.brightBlue(argumentName) : argumentName);
-
-                if (i != arguments.length - 1) {
-                    Argument<?> next = arguments[i + 1];
-                    if (getBeanType().isSynthetic() &&
-                        next.getName().startsWith("$")) {
-                        // skip synthetic arguments
-                        break;
-                    }
-                    beanDescription.append(", ");
-                }
-            }
-
-            beanDescription.append(typeFormat.isAnsi() ? AnsiColour.brightCyan(")") : ")");
-        }
-        return beanDescription.toString();
-    }
-
-    /**
-     * Gets a description of the bean as close as possible to source representation.
-     * @param typeFormat The type format to use.
-     * @return The bean description.
-     * @since 4.8.0
-     */
-    default @NonNull String getBeanDescription(@NonNull TypeFormat typeFormat) {
-        return getBeanDescription(typeFormat, true);
-    }
 }
diff --git a/inject/src/main/java/io/micronaut/inject/provider/BeanProviderDefinition.java b/inject/src/main/java/io/micronaut/inject/provider/BeanProviderDefinition.java
index 8f10441926..fb1df8bf0c 100644
--- a/inject/src/main/java/io/micronaut/inject/provider/BeanProviderDefinition.java
+++ b/inject/src/main/java/io/micronaut/inject/provider/BeanProviderDefinition.java
@@ -121,11 +121,6 @@ public final class BeanProviderDefinition extends AbstractProviderDefinition<Bea
             public Stream<Object> stream() {
                 return defaultBeanContext.streamOfType(resolutionContext.copy(), argument, finalQualifier);
             }
-
-            @Override
-            public String toString() {
-                return "Provider(" + argument + ")";
-            }
         };
     }
 
@@ -133,5 +128,4 @@ public final class BeanProviderDefinition extends AbstractProviderDefinition<Bea
     protected boolean isAllowEmptyProviders(BeanContext context) {
         return true;
     }
-
 }
diff --git a/inject/src/main/java/io/micronaut/inject/qualifiers/InterceptorBindingQualifier.java b/inject/src/main/java/io/micronaut/inject/qualifiers/InterceptorBindingQualifier.java
index a38118d564..88481508d9 100644
--- a/inject/src/main/java/io/micronaut/inject/qualifiers/InterceptorBindingQualifier.java
+++ b/inject/src/main/java/io/micronaut/inject/qualifiers/InterceptorBindingQualifier.java
@@ -21,7 +21,6 @@ import io.micronaut.core.annotation.AnnotationValue;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.core.util.ObjectUtils;
 import io.micronaut.inject.BeanType;
@@ -178,8 +177,8 @@ public final class InterceptorBindingQualifier<T> extends FilteringQualifier<T>
         if (CollectionUtils.isEmpty(supportedAnnotationNames) && CollectionUtils.isEmpty(supportedInterceptorTypes)) {
             return "@InterceptorBinding(NONE)";
         } else {
-            return supportedAnnotationNames.keySet().stream().map((name) -> "@InterceptorBinding(" + NameUtils.getShortenedName(name) + ")").collect(Collectors.joining(" ")) +
-                    supportedInterceptorTypes.stream().map((type) -> "@InterceptorBinding(interceptorType = " + NameUtils.getShortenedName(type.getTypeName()) + ")").collect(Collectors.joining(" "));
+            return supportedAnnotationNames.keySet().stream().map((name) -> "@InterceptorBinding(" + name + ")").collect(Collectors.joining(" ")) +
+                    supportedInterceptorTypes.stream().map((name) -> "@InterceptorBinding(interceptorType = " + name + ")").collect(Collectors.joining(" "));
         }
     }
 
diff --git a/inject/src/test/groovy/io/micronaut/context/ConfigurationPathSpec.groovy b/inject/src/test/groovy/io/micronaut/context/ConfigurationPathSpec.groovy
index eb65bc29dd..1c0bedff2e 100644
--- a/inject/src/test/groovy/io/micronaut/context/ConfigurationPathSpec.groovy
+++ b/inject/src/test/groovy/io/micronaut/context/ConfigurationPathSpec.groovy
@@ -15,11 +15,8 @@ class ConfigurationPathSpec extends Specification {
         given:
         def bc = BeanContext.build()
 
-
-        def mock = RuntimeBeanDefinition.of(ConfigurationPathSpec.class, {-> this})
-
         when:
-        def context = new DefaultBeanResolutionContext(bc, mock)
+        def context = new DefaultBeanResolutionContext(bc, Mock(BeanDefinition))
         ConfigurationPath configurationPath = context.configurationPath
 
         then:
diff --git a/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapApplicationPropertySourceLoader.java b/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapApplicationPropertySourceLoader.java
index 79d2a0e7f3..f9d56bb326 100644
--- a/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapApplicationPropertySourceLoader.java
+++ b/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapApplicationPropertySourceLoader.java
@@ -18,7 +18,6 @@ package io.micronaut.jackson.core.env;
 import com.fasterxml.jackson.core.JsonParseException;
 import io.micronaut.context.env.CachedEnvironment;
 import io.micronaut.context.env.MapPropertySource;
-import io.micronaut.context.env.PropertySource;
 import io.micronaut.context.exceptions.ConfigurationException;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.io.ResourceLoader;
@@ -36,9 +35,7 @@ import java.util.Set;
  *
  * @author Fabian Nonnenmacher
  * @since 2.0
- * @deprecated CloudFoundry support should be added manually
  */
-@Deprecated(forRemoval = true)
 @Internal
 public class CloudFoundryVcapApplicationPropertySourceLoader extends EnvJsonPropertySourceLoader {
 
@@ -90,7 +87,7 @@ public class CloudFoundryVcapApplicationPropertySourceLoader extends EnvJsonProp
     }
 
     @Override
-    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order, PropertySource.Origin origin) {
-        return super.createPropertySource("cloudfoundry-vcap-application", map, order, PropertySource.Origin.of("env.VCAP_APPLICATION"));
+    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order) {
+        return super.createPropertySource("cloudfoundry-vcap-application", map, order);
     }
 }
diff --git a/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapServicesPropertySourceLoader.java b/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapServicesPropertySourceLoader.java
index f8e5592544..e28e47a90d 100644
--- a/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapServicesPropertySourceLoader.java
+++ b/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapServicesPropertySourceLoader.java
@@ -18,7 +18,6 @@ package io.micronaut.jackson.core.env;
 import com.fasterxml.jackson.core.JsonParseException;
 import io.micronaut.context.env.CachedEnvironment;
 import io.micronaut.context.env.MapPropertySource;
-import io.micronaut.context.env.PropertySource;
 import io.micronaut.context.exceptions.ConfigurationException;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.io.ResourceLoader;
@@ -37,9 +36,7 @@ import java.util.Set;
  *
  * @author Fabian Nonnenmacher
  * @since 2.0
- * @deprecated CloudFoundry support should be added manually
  */
-@Deprecated(forRemoval = true)
 @Internal
 public class CloudFoundryVcapServicesPropertySourceLoader extends EnvJsonPropertySourceLoader {
 
@@ -109,7 +106,7 @@ public class CloudFoundryVcapServicesPropertySourceLoader extends EnvJsonPropert
     }
 
     @Override
-    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order, PropertySource.Origin origin) {
-        return super.createPropertySource("cloudfoundry-vcap-services", map, order, PropertySource.Origin.of("env.VCAP_SERVICES"));
+    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order) {
+        return super.createPropertySource("cloudfoundry-vcap-services", map, order);
     }
 }
diff --git a/management/src/test/groovy/io/micronaut/management/endpoint/routes/RoutesEndpointSpec.groovy b/management/src/test/groovy/io/micronaut/management/endpoint/routes/RoutesEndpointSpec.groovy
index 35530bf30c..726928e8c9 100644
--- a/management/src/test/groovy/io/micronaut/management/endpoint/routes/RoutesEndpointSpec.groovy
+++ b/management/src/test/groovy/io/micronaut/management/endpoint/routes/RoutesEndpointSpec.groovy
@@ -44,7 +44,7 @@ class RoutesEndpointSpec extends Specification {
 
         then:
         response.code() == HttpStatus.OK.code
-        result['{[/refresh],method=[POST],produces=[application/json]}']['method'] == "java.lang.String[] io.micronaut.management.endpoint.refresh.RefreshEndpoint.refresh(java.lang.Boolean force)"
+        result['{[/refresh],method=[POST],produces=[application/json]}']['method'] == "[Ljava.lang.String; io.micronaut.management.endpoint.refresh.RefreshEndpoint.refresh(java.lang.Boolean force)"
         result['{[/test],method=[GET],produces=[application/json]}']['method'] == "java.lang.String io.micronaut.management.endpoint.routes.RoutesEndpointSpec\$TestController.index()"
         result['{[/test/generics],method=[PUT],produces=[application/json]}']['method'] == "java.util.Map<java.lang.String, java.lang.Integer> io.micronaut.management.endpoint.routes.RoutesEndpointSpec\$TestController.generics()"
         result['{[/routes],method=[GET],produces=[application/json]}']['method'] == "java.lang.Object io.micronaut.management.endpoint.routes.RoutesEndpoint.getRoutes()"
diff --git a/src/main/docs/guide/ioc.adoc b/src/main/docs/guide/ioc.adoc
index 89ebfa2b61..8add71aee6 100644
--- a/src/main/docs/guide/ioc.adoc
+++ b/src/main/docs/guide/ioc.adoc
@@ -1,6 +1,3 @@
-https://en.wikipedia.org/wiki/Dependency_injection[Dependency Injection] (often referred to as https://en.wikipedia.org/wiki/Inversion_of_control[Inversion of Control]) is a pattern that allows your code to remain independent of configuration and allows the definition of loosely coupled applications. Reducing coupling increases the ability to test your application by ensuring code is not tied directly to an external systems (like a database).
-
-
 Unlike other frameworks which rely on runtime reflection and proxies, the Micronaut framework uses compile time data to implement dependency injection.
 
 This is a similar approach taken by tools such as Google https://google.github.io/dagger/[Dagger], which is designed primarily with Android in mind. Micronaut, on the other hand, is designed for building server-side microservices and provides many of the same tools and utilities as other frameworks but without using reflection or caching excessive amounts of reflection metadata.
@@ -8,7 +5,7 @@ This is a similar approach taken by tools such as Google https://google.github.i
 The goals of the Micronaut IoC container are summarized as:
 
 * Use reflection as a last resort
-* Avoid runtime-generated proxies
+* Avoid proxies
 * Optimize start-up time
 * Reduce memory footprint
 * Provide clear, understandable error handling
diff --git a/src/main/docs/guide/ioc/iocDebugging.adoc b/src/main/docs/guide/ioc/iocDebugging.adoc
deleted file mode 100644
index 01f819a26d..0000000000
--- a/src/main/docs/guide/ioc/iocDebugging.adoc
+++ /dev/null
@@ -1,23 +0,0 @@
-To help you easily understand what Micronaut is doing at startup and when a particular bean is created Micronaut includes a dependency injection tracing feature which can be activated in a number of different ways including via the api:context.ApplicationContextBuilder[] API.
-
-The simplest way to activate injection trace mode is using an environment variable. For example if you are running your application locally you can do:
-
-.Activating Injection Trace Mode
-[source,bash]
-----
-MICRONAUT_INJECT_TRACE=.+ ./gradlew run
-----
-
-Or for Maven:
-
-.Activating Injection Trace Mode
-[source,bash]
-----
-MICRONAUT_INJECT_TRACE=.+ ./mvnw mn:run
-----
-
-Trace mode will output useful information such as:
-
-* The Configuration profile of the application
-* The applicable configuration and where it came from
-* The beans that are created, where they were created and how long was taken to create the bean.
diff --git a/src/main/docs/guide/toc.yml b/src/main/docs/guide/toc.yml
index fd3ba66ac5..1ced95bf76 100644
--- a/src/main/docs/guide/toc.yml
+++ b/src/main/docs/guide/toc.yml
@@ -15,10 +15,9 @@ quickStart:
   creatingClient: Creating a Client
   deployingApp: Deploying the Application
 ioc:
-  title: Dependency Injection
+  title: Inversion of Control
   beans: Defining Beans
   how: How Does it Work?
-  iocDebugging: Debugging Dependency Injection
   beanContext: The BeanContext
   injection:
     title: Dependency Injection Types
