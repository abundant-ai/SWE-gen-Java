diff --git a/config/accepted-api-changes.json b/config/accepted-api-changes.json
index b102fcb027..c0bcfba0cb 100644
--- a/config/accepted-api-changes.json
+++ b/config/accepted-api-changes.json
@@ -1096,5 +1096,35 @@
   {
     "type": "io.micronaut.http.server.netty.jackson.$JsonHttpContentSubscriberFactory$Definition",
     "reason": "Internal class removed"
+  },
+  {
+    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
+    "member": "Field RAW",
+    "reason": "Deprecated internal type"
+  },
+  {
+    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
+    "member": "Field NORMALIZED",
+    "reason": "Deprecated internal type"
+  },
+  {
+    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
+    "member": "Field GENERATED",
+    "reason": "Deprecated internal type"
+  },
+  {
+    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
+    "member": "Implemented interface java.lang.constant.Constable",
+    "reason": "Deprecated internal type"
+  },
+  {
+    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
+    "member": "Implemented interface java.lang.Comparable",
+    "reason": "Deprecated internal type"
+  },
+  {
+    "type": "io.micronaut.context.env.PropertySourcePropertyResolver$PropertyCatalog",
+    "member": "Implemented interface java.io.Serializable",
+    "reason": "Deprecated internal type"
   }
 ]
diff --git a/core/src/main/java/io/micronaut/core/annotation/AnnotationUtil.java b/core/src/main/java/io/micronaut/core/annotation/AnnotationUtil.java
index 0c2e7f52e4..b3cbdd6d35 100644
--- a/core/src/main/java/io/micronaut/core/annotation/AnnotationUtil.java
+++ b/core/src/main/java/io/micronaut/core/annotation/AnnotationUtil.java
@@ -135,6 +135,11 @@ public class AnnotationUtil {
      */
     public static final String ANN_INTRODUCTION = "io.micronaut.aop.Introduction";
 
+    /**
+     * The adapter annotation type.
+     */
+    public static final String ANN_ADAPTER = "io.micronaut.aop.Adapter";
+
     /**
      * Name of the interceptor binding type.
      */
diff --git a/core/src/main/java/io/micronaut/core/type/TypeInformation.java b/core/src/main/java/io/micronaut/core/type/TypeInformation.java
index c0affd367a..1ba0aa7dc4 100644
--- a/core/src/main/java/io/micronaut/core/type/TypeInformation.java
+++ b/core/src/main/java/io/micronaut/core/type/TypeInformation.java
@@ -15,9 +15,13 @@
  */
 package io.micronaut.core.type;
 
+import io.micronaut.core.annotation.AnnotationMetadata;
 import io.micronaut.core.annotation.AnnotationMetadataProvider;
+import io.micronaut.core.annotation.AnnotationUtil;
 import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.reflect.ReflectionUtils;
+import io.micronaut.core.util.AnsiColour;
 import io.micronaut.core.util.ArrayUtils;
 
 import java.lang.reflect.ParameterizedType;
@@ -32,15 +36,16 @@ import java.util.stream.Collectors;
 /**
  * Provides information about a type at runtime.
  *
- * @author graemerocher
  * @param <T> The generic type
+ * @author graemerocher
  * @since 2.4.0
  */
 public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMetadataProvider, Type {
     /**
      * @return The type
      */
-    @NonNull Class<T> getType();
+    @NonNull
+    Class<T> getType();
 
     /**
      * @return Is the type primitive.
@@ -52,6 +57,7 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * If the type is primitive returns the wrapper type, otherwise returns the actual type.
+     *
      * @return The wrapper type if primitive
      */
     default Class<?> getWrapperType() {
@@ -68,7 +74,7 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
         Argument<?>[] typeParameters = getTypeParameters();
         if (ArrayUtils.isNotEmpty(typeParameters)) {
             String typeName = getType().getTypeName();
-            return typeName +  "<" + Arrays.stream(typeParameters).map(Argument::getTypeName).collect(Collectors.joining(",")) + ">";
+            return typeName + "<" + Arrays.stream(typeParameters).map(Argument::getTypeName).collect(Collectors.joining(",")) + ">";
         } else {
             return getType().getTypeName();
         }
@@ -94,6 +100,7 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * Returns the wrapped type in the case where {@link #isWrapperType()} returns true.
+     *
      * @return The wrapped type
      */
     default Argument<?> getWrappedType() {
@@ -130,7 +137,7 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
      */
     default boolean isContainerType() {
         final Class<T> type = getType();
-        return Map.class == type ||  DefaultArgument.CONTAINER_TYPES.contains(type.getName());
+        return Map.class == type || DefaultArgument.CONTAINER_TYPES.contains(type.getName());
     }
 
     /**
@@ -147,19 +154,35 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
      * @return The type string representation
      */
     default String getTypeString(boolean simple) {
+        return getTypeString(simple ? TypeFormat.SIMPLE : TypeFormat.QUALIFIED);
+    }
+
+    /**
+     * Similar to {@link #getTypeString(TypeFormat)} but includes any scopes and qualifiers.
+     *
+     * @param format The format
+     * @return The type string including the scope and qualifier
+     * @see #getTypeString(TypeFormat)
+     */
+    default String getBeanTypeString(@NonNull TypeFormat format) {
+        return TypeFormat.getBeanTypeString(
+            format,
+            getType(),
+            getTypeVariables(),
+            getAnnotationMetadata()
+        );
+    }
+
+    /**
+     * Returns the string representation of the argument type, including generics.
+     *
+     * @param format The format.
+     * @return The type string representation
+     * @since 4.8.0
+     */
+    default @NonNull String getTypeString(@NonNull TypeFormat format) {
         Class<T> type = getType();
-        StringBuilder returnType = new StringBuilder(simple ? type.getSimpleName() : type.getName());
-        Map<String, Argument<?>> generics = getTypeVariables();
-        if (!generics.isEmpty()) {
-            returnType
-                    .append("<")
-                    .append(generics.values()
-                            .stream()
-                            .map(arg -> arg.getTypeString(simple))
-                            .collect(Collectors.joining(", ")))
-                    .append(">");
-        }
-        return returnType.toString();
+        return TypeFormat.getTypeString(format, type, getTypeVariables());
     }
 
     /**
@@ -204,6 +227,7 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * Represent this argument as a {@link Type}.
+     *
      * @return The {@link Type}
      * @since 3.5.2
      */
@@ -216,6 +240,7 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * Represent this argument as a {@link ParameterizedType}.
+     *
      * @return The {@link ParameterizedType}
      * @since 2.0.0
      */
@@ -276,6 +301,7 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
 
     /**
      * Obtains the type's simple name.
+     *
      * @return The simple name
      * @since 3.0.0
      */
@@ -284,11 +310,193 @@ public interface TypeInformation<T> extends TypeVariableResolver, AnnotationMeta
     }
 
     default boolean isProvider() {
-        for (String type: DefaultArgument.PROVIDER_TYPES) {
+        for (String type : DefaultArgument.PROVIDER_TYPES) {
             if (getType().getName().equals(type)) {
                 return true;
             }
         }
         return false;
     }
+
+    /**
+     * Type formatting to apply.
+     *
+     * @see TypeInformation#getTypeString(boolean)
+     * @since 4.8.0
+     */
+    enum TypeFormat {
+        /**
+         * Simple format.
+         */
+        SIMPLE,
+        /**
+         * Qualified format.
+         */
+        QUALIFIED,
+        /**
+         * Shorted format.
+         */
+        SHORTENED,
+        /**
+         * Simple name highlighted wit ANSI.
+         */
+        ANSI_SIMPLE,
+        /**
+         * Qualified name highlighted with ANSI.
+         */
+        ANSI_QUALIFIED,
+        /**
+         * Shortened name highlighted with ANSI.
+         */
+        ANSI_SHORTENED;
+
+        private static final String ANN_CR = "io.micronaut.context.annotation.ConfigurationReader";
+
+        /**
+         * Obtain the bean type string.
+         *
+         * @param typeFormat The type format
+         * @param argument   The argument
+         * @return The string
+         */
+        public static @NonNull String getBeanTypeString(
+            @NonNull TypeInformation.TypeFormat typeFormat, @NonNull Argument<?> argument) {
+            return getBeanTypeString(
+                typeFormat,
+                argument.getType(),
+                argument.getTypeVariables(),
+                argument.getAnnotationMetadata()
+            );
+        }
+
+        /**
+         * @return Is an ANSI format.
+         */
+        public boolean isAnsi() {
+            return this == ANSI_SIMPLE ||
+                this == ANSI_QUALIFIED ||
+                this == ANSI_SHORTENED;
+        }
+
+        /**
+         * Format the annotation name.
+         *
+         * @param annotationRef The type name
+         * @return The annotation
+         */
+        public String formatAnnotation(String annotationRef) {
+            int i = annotationRef.indexOf("(");
+            String members = i > -1 ? annotationRef.substring(i) : "";
+            annotationRef = i > -1 ? annotationRef.substring(0, i) : annotationRef;
+            return switch (this) {
+                case SIMPLE -> "@" + NameUtils.getSimpleName(annotationRef) + members;
+                case QUALIFIED -> "@" + annotationRef + members;
+                case SHORTENED -> "@" + NameUtils.getShortenedName(annotationRef) + members;
+                case ANSI_SIMPLE ->
+                    AnsiColour.yellow("@" + NameUtils.getSimpleName(annotationRef)) + members;
+                case ANSI_QUALIFIED -> AnsiColour.yellow("@" + annotationRef) + members;
+                case ANSI_SHORTENED ->
+                    AnsiColour.yellow("@" + NameUtils.getShortenedName(annotationRef)) + members;
+            };
+        }
+
+        /**
+         * Get a type string for the given format.
+         *
+         * @param format   The format
+         * @param type     The type
+         * @param generics The generics
+         * @return the type string
+         */
+        public static @NonNull String getTypeString(
+            @NonNull TypeFormat format,
+            @NonNull Class<?> type,
+            @NonNull Map<String, Argument<?>> generics) {
+            String typeName = switch (format) {
+                case SIMPLE -> type.getSimpleName();
+                case QUALIFIED -> type.getCanonicalName();
+                case SHORTENED -> NameUtils.getShortenedName(type.getTypeName());
+                case ANSI_SIMPLE -> AnsiColour.cyan(type.getSimpleName());
+                case ANSI_QUALIFIED -> AnsiColour.cyan(type.getCanonicalName());
+                case ANSI_SHORTENED ->
+                    AnsiColour.cyan(NameUtils.getShortenedName(type.getCanonicalName()));
+            };
+            StringBuilder returnType = new StringBuilder(typeName);
+            if (!generics.isEmpty()) {
+                returnType
+                    .append(format.isAnsi() ? AnsiColour.brightCyan("<") : "<")
+                    .append(generics.values()
+                        .stream()
+                        .map(arg -> arg.getTypeString(format))
+                        .collect(Collectors.joining(", ")))
+                    .append(format.isAnsi() ? AnsiColour.brightCyan(">") : ">");
+            }
+            return returnType.toString();
+        }
+
+        /**
+         * Get a type string for the given format.
+         *
+         * @param format             The format
+         * @param type               The type
+         * @param generics           The generics
+         * @param annotationMetadata The annotation metadata
+         * @return the type string
+         */
+        public static @NonNull String getBeanTypeString(
+            @NonNull TypeFormat format,
+            @NonNull Class<?> type,
+            @NonNull Map<String, Argument<?>> generics,
+            @NonNull AnnotationMetadata annotationMetadata) {
+            String typeFormat = TypeFormat.getTypeString(
+                format,
+                type,
+                generics
+            );
+            Optional<String> q = annotationMetadata.getAnnotationNameByStereotype(AnnotationUtil.QUALIFIER)
+                .map(qualifier -> {
+                    if (AnnotationUtil.NAMED.equals(qualifier)) {
+                        String name = annotationMetadata.stringValue(AnnotationUtil.NAMED).orElse(null);
+                        if (name != null) {
+                            if (format.isAnsi()) {
+                                return qualifier + "(" + AnsiColour.green("\"" + name + "\"") + ")";
+                            } else {
+                                return qualifier + "(\"" + name + "\")";
+                            }
+                        }
+                    }
+                    return qualifier;
+                });
+            Optional<String> s = annotationMetadata.getAnnotationNameByStereotype(AnnotationUtil.SCOPE)
+                .map(scope -> {
+                    if (AnnotationUtil.SINGLETON.equals(scope)) {
+                        // handle case where @Singleton is used as a meta annotation
+                        scope = annotationMetadata.getAnnotationNameByStereotype(scope)
+                            .orElse(scope);
+                        String configuration = annotationMetadata.stringValue(
+                                ANN_CR,
+                                "prefix"
+                            )
+                            .orElse(null);
+                        if (configuration != null) {
+                            if (format.isAnsi()) {
+                                scope = scope + "(" + AnsiColour.green("\"" + configuration + "\"") + ")";
+                            } else {
+                                scope = scope + "(\"" + configuration + "\")";
+                            }
+                        }
+                    }
+                    return scope;
+                });
+            if (s.isPresent()) {
+                typeFormat = format.formatAnnotation(s.get()) + " " + typeFormat;
+            }
+            if (q.isPresent()) {
+                typeFormat = format.formatAnnotation(q.get()) + " " + typeFormat;
+            }
+            return typeFormat;
+        }
+    }
+
+
 }
diff --git a/core/src/main/java/io/micronaut/core/util/AnsiColour.java b/core/src/main/java/io/micronaut/core/util/AnsiColour.java
new file mode 100644
index 0000000000..7167becfda
--- /dev/null
+++ b/core/src/main/java/io/micronaut/core/util/AnsiColour.java
@@ -0,0 +1,240 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.core.util;
+
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
+
+/**
+ * Ansi color coding.
+ *
+ * @since 4.8.0
+ */
+public enum AnsiColour {
+    //Color end string, color reset
+    RESET("\033[0m"),
+
+    // Regular Colors. Normal color, no bold, background color etc.
+    BLACK("\033[0;30m"),    // BLACK
+    RED("\033[0;31m"),      // RED
+    GREEN("\033[0;32m"),    // GREEN
+    YELLOW("\033[0;33m"),   // YELLOW
+    BLUE("\033[0;34m"),     // BLUE
+    MAGENTA("\033[0;35m"),  // MAGENTA
+    CYAN("\033[0;36m"),     // CYAN
+    WHITE("\033[0;37m"),    // WHITE
+
+    // Bold
+    BLACK_BOLD("\033[1;30m"),   // BLACK
+    RED_BOLD("\033[1;31m"),     // RED
+    GREEN_BOLD("\033[1;32m"),   // GREEN
+    YELLOW_BOLD("\033[1;33m"),  // YELLOW
+    BLUE_BOLD("\033[1;34m"),    // BLUE
+    MAGENTA_BOLD("\033[1;35m"), // MAGENTA
+    CYAN_BOLD("\033[1;36m"),    // CYAN
+    WHITE_BOLD("\033[1;37m"),   // WHITE
+
+    // Underline
+    BLACK_UNDERLINED("\033[4;30m"),     // BLACK
+    RED_UNDERLINED("\033[4;31m"),       // RED
+    GREEN_UNDERLINED("\033[4;32m"),     // GREEN
+    YELLOW_UNDERLINED("\033[4;33m"),    // YELLOW
+    BLUE_UNDERLINED("\033[4;34m"),      // BLUE
+    MAGENTA_UNDERLINED("\033[4;35m"),   // MAGENTA
+    CYAN_UNDERLINED("\033[4;36m"),      // CYAN
+    WHITE_UNDERLINED("\033[4;37m"),     // WHITE
+
+    // Background
+    BLACK_BACKGROUND("\033[40m"),   // BLACK
+    RED_BACKGROUND("\033[41m"),     // RED
+    GREEN_BACKGROUND("\033[42m"),   // GREEN
+    YELLOW_BACKGROUND("\033[43m"),  // YELLOW
+    BLUE_BACKGROUND("\033[44m"),    // BLUE
+    MAGENTA_BACKGROUND("\033[45m"), // MAGENTA
+    CYAN_BACKGROUND("\033[46m"),    // CYAN
+    WHITE_BACKGROUND("\033[47m"),   // WHITE
+
+    // High Intensity
+    BLACK_BRIGHT("\033[0;90m"),     // BLACK
+    RED_BRIGHT("\033[0;91m"),       // RED
+    GREEN_BRIGHT("\033[0;92m"),     // GREEN
+    YELLOW_BRIGHT("\033[0;93m"),    // YELLOW
+    BLUE_BRIGHT("\033[0;94m"),      // BLUE
+    MAGENTA_BRIGHT("\033[0;95m"),   // MAGENTA
+    CYAN_BRIGHT("\033[0;96m"),      // CYAN
+    WHITE_BRIGHT("\033[0;97m"),     // WHITE
+
+    // Bold High Intensity
+    BLACK_BOLD_BRIGHT("\033[1;90m"),    // BLACK
+    RED_BOLD_BRIGHT("\033[1;91m"),      // RED
+    GREEN_BOLD_BRIGHT("\033[1;92m"),    // GREEN
+    YELLOW_BOLD_BRIGHT("\033[1;93m"),   // YELLOW
+    BLUE_BOLD_BRIGHT("\033[1;94m"),     // BLUE
+    MAGENTA_BOLD_BRIGHT("\033[1;95m"),  // MAGENTA
+    CYAN_BOLD_BRIGHT("\033[1;96m"),     // CYAN
+    WHITE_BOLD_BRIGHT("\033[1;97m"),    // WHITE
+
+    // High Intensity backgrounds
+    BLACK_BACKGROUND_BRIGHT("\033[0;100m"),     // BLACK
+    RED_BACKGROUND_BRIGHT("\033[0;101m"),       // RED
+    GREEN_BACKGROUND_BRIGHT("\033[0;102m"),     // GREEN
+    YELLOW_BACKGROUND_BRIGHT("\033[0;103m"),    // YELLOW
+    BLUE_BACKGROUND_BRIGHT("\033[0;104m"),      // BLUE
+    MAGENTA_BACKGROUND_BRIGHT("\033[0;105m"),   // MAGENTA
+    CYAN_BACKGROUND_BRIGHT("\033[0;106m"),      // CYAN
+    WHITE_BACKGROUND_BRIGHT("\033[0;107m");     // WHITE
+
+    private final String code;
+
+    AnsiColour(String code) {
+        this.code = code;
+    }
+
+    /**
+     * Highlight cyan if supported.
+     * @param text The text
+     * @return the string
+     */
+    public static String cyan(String text) {
+        if (isSupported()) {
+            return AnsiColour.CYAN + text + AnsiColour.RESET;
+        } else {
+            return text;
+        }
+    }
+
+    /**
+     * Highlight bright cyan if supported.
+     * @param text The text
+     * @return the string
+     */
+    public static String brightCyan(String text) {
+        if (isSupported()) {
+            return AnsiColour.CYAN_BRIGHT + text + AnsiColour.RESET;
+        } else {
+            return text;
+        }
+    }
+
+    /**
+     * Highlight in yellow.
+     * @param text The text
+     * @return The formatted string
+     */
+    public static String yellow(@NonNull String text) {
+        if (isSupported()) {
+            return AnsiColour.YELLOW + text + AnsiColour.RESET;
+        } else {
+            return text;
+        }
+    }
+
+    /**
+     * Highlight in bright blue.
+     * @param text The text
+     * @return The formatted string
+     */
+    public static String brightBlue(String text) {
+        if (isSupported()) {
+            return AnsiColour.BLUE_BRIGHT + text + AnsiColour.RESET;
+        } else {
+            return text;
+        }
+    }
+
+    /**
+     * Output in magenta bold.
+     * @param text The text
+     * @return The formatted text.
+     */
+    public static String magentaBold(String text) {
+        if (isSupported()) {
+            return AnsiColour.MAGENTA_BOLD + text + AnsiColour.RESET;
+        } else {
+            return text;
+        }
+    }
+
+    /**
+     * Output green.
+     * @param text The text
+     * @return The formatted text
+     */
+    public static String green(String text) {
+        if (isSupported()) {
+            return AnsiColour.GREEN + text + AnsiColour.RESET;
+        } else {
+            return text;
+        }
+    }
+
+    /**
+     * Output bright yellow.
+     * @param text The text
+     * @return The formatted text
+     */
+    public static String brightYellow(String text) {
+        if (isSupported()) {
+            return AnsiColour.YELLOW_BRIGHT + text + AnsiColour.RESET;
+        } else {
+            return text;
+        }
+    }
+
+    /**
+     * Format an object for display.
+     * @param object The object
+     * @return The formatted object
+     */
+    public static @NonNull String formatObject(@Nullable Object object) {
+        if (object instanceof CharSequence charSequence) {
+            return green("\"" + charSequence + "\"");
+        } else if (object instanceof Number number) {
+            return brightBlue(number.toString());
+        } else if (object == null) {
+            return brightBlue("null");
+        } else {
+            return brightYellow(object.toString());
+        }
+    }
+
+    /**
+     * Format blue.
+     * @param text The text
+     * @return The formatted text
+     */
+    public static @NonNull String blue(@NonNull String text) {
+        if (isSupported()) {
+            return AnsiColour.BLUE + text + AnsiColour.RESET;
+        } else {
+            return text;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return code;
+    }
+
+    /**
+     * Are ANSI colors supported.
+     * @return True if they are
+     */
+    public static boolean isSupported() {
+        String os = System.getProperty("os.name").toLowerCase();
+        return !os.contains("win") || System.console() != null;
+    }
+}
diff --git a/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java b/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java
index 2e16c769c9..7a2121bbcd 100644
--- a/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java
+++ b/inject/src/main/java/io/micronaut/context/AbstractBeanResolutionContext.java
@@ -20,20 +20,28 @@ import io.micronaut.context.env.CachedEnvironment;
 import io.micronaut.context.annotation.InjectScope;
 import io.micronaut.context.env.ConfigurationPath;
 import io.micronaut.context.exceptions.CircularDependencyException;
+import io.micronaut.context.exceptions.DependencyInjectionException;
 import io.micronaut.context.scope.CustomScope;
 import io.micronaut.core.annotation.AnnotationMetadata;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.bind.annotation.Bindable;
 import io.micronaut.core.convert.ArgumentConversionContext;
+import io.micronaut.core.convert.ConversionContext;
 import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.naming.Named;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.ArgumentCoercible;
+import io.micronaut.core.type.TypeInformation;
+import io.micronaut.core.type.TypeInformation.TypeFormat;
+import io.micronaut.core.util.AnsiColour;
 import io.micronaut.core.util.ObjectUtils;
 import io.micronaut.inject.*;
 
+import io.micronaut.inject.proxy.InterceptedBean;
 import java.util.*;
+import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 /**
@@ -49,6 +57,8 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
     protected final DefaultBeanContext context;
     protected final BeanDefinition<?> rootDefinition;
     protected final Path path;
+    private final @NonNull BeanResolutionTraceMode traceMode;
+    private final boolean traceEnabled;
     private Map<CharSequence, Object> attributes;
     private Qualifier<?> qualifier;
     private List<BeanRegistration<?>> dependentBeans;
@@ -65,6 +75,8 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         this.context = context;
         this.rootDefinition = rootDefinition;
         this.path = new DefaultPath();
+        this.traceMode = context.traceMode;
+        this.traceEnabled = rootDefinition != null && isTraceEnabled(rootDefinition.getBeanType().getTypeName(), context.tracePatterns);
     }
 
     @Override
@@ -84,16 +96,154 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         return old;
     }
 
+    @Override
+    public void valueResolved(Argument<?> argument, Qualifier<?> qualifier, String property, Object value) {
+        if (traceEnabled) {
+            traceMode.traceValueResolved(
+                this,
+                argument,
+                property,
+                value
+            );
+        }
+    }
+
+    private boolean isTraceEnabled(@NonNull String typeName, @NonNull Set<String> tracePatterns) {
+        return traceMode != BeanResolutionTraceMode.NONE &&
+            (tracePatterns.isEmpty() || tracePatterns.stream().anyMatch(typeName::matches));
+    }
+
+    @Override
+    public Object resolvePropertyValue(Argument<?> argument, String stringValue, String cliProperty, boolean isPlaceholder) {
+        ApplicationContext applicationContext = (ApplicationContext) context;
+
+        Argument<?> argumentType = argument;
+        Class<?> wrapperType = null;
+        Class<?> type = argument.getType();
+        if (type == Optional.class) {
+            wrapperType = Optional.class;
+            argumentType = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
+        } else if (type == OptionalInt.class) {
+            wrapperType = OptionalInt.class;
+            argumentType = Argument.INT;
+        } else if (type == OptionalLong.class) {
+            wrapperType = OptionalLong.class;
+            argumentType = Argument.LONG;
+        } else if (type == OptionalDouble.class) {
+            wrapperType = OptionalDouble.class;
+            argumentType = Argument.DOUBLE;
+        }
+
+        ArgumentConversionContext<?> conversionContext = wrapperType != null ? ConversionContext.of(argumentType) : ConversionContext.of(argument);
+
+        Optional<?> value;
+        if (isPlaceholder) {
+            value = applicationContext.resolvePlaceholders(stringValue).flatMap(v -> applicationContext.getConversionService().convert(v, conversionContext));
+        } else {
+            stringValue = substituteWildCards(stringValue);
+            value = applicationContext.getProperty(stringValue, conversionContext);
+            if (value.isEmpty() && cliProperty != null) {
+                value = applicationContext.getProperty(cliProperty, conversionContext);
+            }
+        }
+
+        if (traceEnabled) {
+            traceMode.traceValueResolved(
+                this,
+                argument,
+                stringValue,
+                value.orElse(null)
+            );
+        }
+
+        if (argument.isOptional()) {
+            if (value.isEmpty()) {
+                return value;
+            } else {
+                Object convertedOptional = value.get();
+                if (convertedOptional instanceof Optional) {
+                    return convertedOptional;
+                } else {
+                    return value;
+                }
+            }
+        } else {
+            if (wrapperType != null) {
+                final Object v = value.orElse(null);
+                if (OptionalInt.class == wrapperType) {
+                    return v instanceof Integer i ? OptionalInt.of(i) : OptionalInt.empty();
+                } else if (OptionalLong.class == wrapperType) {
+                    return v instanceof Long l ? OptionalLong.of(l) : OptionalLong.empty();
+                } else if (OptionalDouble.class == wrapperType) {
+                    return v instanceof Double d ? OptionalDouble.of(d) : OptionalDouble.empty();
+                }
+            }
+            if (value.isPresent()) {
+                return value.get();
+            } else {
+                if (argument.isDeclaredNullable()) {
+                    return null;
+                }
+                String finalStringValue = stringValue;
+                return argument.getAnnotationMetadata().getValue(Bindable.class, "defaultValue", argument)
+                    .orElseThrow(() -> DependencyInjectionException.missingProperty(this, conversionContext, finalStringValue));
+            }
+        }
+    }
+
+    private String substituteWildCards(String valString) {
+        ConfigurationPath configurationPath = getConfigurationPath();
+        if (configurationPath.isNotEmpty()) {
+            return configurationPath.resolveValue(valString);
+        }
+        return valString;
+    }
+
     @NonNull
     @Override
     public <T> T getBean(@NonNull Argument<T> beanType, @Nullable Qualifier<T> qualifier) {
-        return context.getBean(this, beanType, qualifier);
+        T bean = context.getBean(this, beanType, qualifier);
+        if (traceEnabled) {
+            traceMode.traceBeanResolved(
+                this,
+                beanType,
+                qualifier,
+                bean
+            );
+            String disabledBeanMessage = context.resolveDisabledBeanMessage(
+                this,
+                beanType,
+                qualifier
+            );
+            if (disabledBeanMessage != null) {
+                traceMode.traceBeanDisabled(AbstractBeanResolutionContext.this, disabledBeanMessage);
+            }
+        }
+        return bean;
     }
 
     @NonNull
     @Override
     public <T> Collection<T> getBeansOfType(@NonNull Argument<T> beanType, @Nullable Qualifier<T> qualifier) {
-        return context.getBeansOfType(this, beanType, qualifier);
+        Collection<T> beans = context.getBeansOfType(this, beanType, qualifier);
+        if (traceEnabled) {
+            traceBeanCollection(beanType, qualifier, beans);
+        }
+        return beans;
+    }
+
+    private <T> void traceBeanCollection(Argument<T> beanType, Qualifier<T> qualifier, Collection<T> beans) {
+        for (T bean : beans) {
+            traceMode.traceBeanResolved(this, beanType, qualifier, bean);
+        }
+        String disabledBeanMessage = context.resolveDisabledBeanMessage(
+            this,
+            beanType,
+            qualifier
+        );
+        if (disabledBeanMessage != null) {
+            traceMode.traceBeanDisabled(AbstractBeanResolutionContext.this, disabledBeanMessage);
+        }
     }
 
     @NonNull
@@ -104,19 +254,43 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
     @Override
     public <V> Map<String, V> mapOfType(Argument<V> beanType, Qualifier<V> qualifier) {
-        return context.mapOfType(this, beanType, qualifier);
+        Map<String, V> beanMap = context.mapOfType(this, beanType, qualifier);
+        if (traceEnabled) {
+            traceBeanCollection(beanType, qualifier, beanMap.values());
+        }
+        return beanMap;
     }
 
     @NonNull
     @Override
     public <T> Optional<T> findBean(@NonNull Argument<T> beanType, @Nullable Qualifier<T> qualifier) {
-        return context.findBean(this, beanType, qualifier);
+        Optional<T> resolved = context.findBean(this, beanType, qualifier);
+        if (traceEnabled) {
+            traceMode.traceBeanResolved(this, beanType, qualifier, resolved.orElse(null));
+            String disabledBeanMessage = context.resolveDisabledBeanMessage(
+                this,
+                beanType,
+                qualifier
+            );
+            if (disabledBeanMessage != null) {
+                traceMode.traceBeanDisabled(AbstractBeanResolutionContext.this, disabledBeanMessage);
+            }
+        }
+        return resolved;
     }
 
     @NonNull
     @Override
     public <T> Collection<BeanRegistration<T>> getBeanRegistrations(@NonNull Argument<T> beanType, @Nullable Qualifier<T> qualifier) {
-        return context.getBeanRegistrations(this, beanType, qualifier);
+        Collection<BeanRegistration<T>> registrations = context.getBeanRegistrations(this, beanType, qualifier);
+        if (traceEnabled) {
+            traceBeanCollection(
+                beanType,
+                qualifier,
+                registrations.stream().map(BeanRegistration::getBean).collect(Collectors.toList())
+            );
+        }
+        return registrations;
     }
 
     /**
@@ -303,13 +477,14 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
     class DefaultPath extends LinkedList<Segment<?, ?>> implements Path {
 
         public static final String RIGHT_ARROW = "\\---> ";
+        public static final String RIGHT_ARROW_EMOJI = " ↪️  ";
         private static final String CIRCULAR_ERROR_MSG = "Circular dependency detected";
 
         DefaultPath() {
         }
 
         @Override
-        public String toString() {
+        public String toConsoleString(boolean ansiSupported) {
             Iterator<Segment<?, ?>> i = descendingIterator();
             String ls = CachedEnvironment.getProperty("line.separator");
             StringBuilder pathString = new StringBuilder().append(ls);
@@ -318,16 +493,29 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
             while (i.hasNext()) {
                 pathString.append(i.next().toString());
                 if (i.hasNext()) {
-                    pathString.append(ls).append(spaces).append(RIGHT_ARROW);
+                    pathString
+                        .append(ls)
+                        .append(spaces)
+                        .append(ansiSupported ? RIGHT_ARROW_EMOJI : RIGHT_ARROW);
                     spaces += "      ";
                 }
             }
             return pathString.toString();
         }
 
-        @SuppressWarnings("MagicNumber")
+        @Override
+        public String toString() {
+            return toConsoleString(false);
+        }
+
         @Override
         public String toCircularString() {
+            return toConsoleCircularString(false);
+        }
+
+        @SuppressWarnings("MagicNumber")
+        @Override
+        public String toConsoleCircularString(boolean ansiSupported) {
             Iterator<Segment<?, ?>> i = descendingIterator();
             StringBuilder pathString = new StringBuilder();
             String ls = CachedEnvironment.getProperty("line.separator");
@@ -347,10 +535,14 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
             while (i.hasNext() && index < size() - 1) {
                 String segmentString = i.next().toString();
                 if (index == cycleIndex) {
-                    pathString.append(ls).append(spaces).append("^").append("  \\---> ");
+                    pathString.append(ls).append(spaces).append("^").append("  ")
+                        .append(ansiSupported ? RIGHT_ARROW_EMOJI : RIGHT_ARROW);
                     spaces = spaces + "|  ";
                 } else if (index != 0) {
-                    pathString.append(ls).append(spaces).append(RIGHT_ARROW);
+                    pathString
+                        .append(ls)
+                        .append(spaces)
+                        .append(ansiSupported ? RIGHT_ARROW_EMOJI : RIGHT_ARROW);
                 }
                 pathString.append(segmentString);
                 spaces = spaces + "      ";
@@ -382,37 +574,60 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public Path pushConstructorResolve(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments) {
-            if (CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
-                ConstructorSegment constructorSegment = new ConstructorArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments);
-                detectCircularDependency(declaringType, argument, constructorSegment);
-            } else {
-                Segment<?, ?> previous = peek();
-                MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
-                if (contains(methodSegment)) {
-                    push(methodSegment);
-                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, argument, CIRCULAR_ERROR_MSG);
+            try {
+                if (CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
+                    ConstructorSegment constructorSegment = new ConstructorArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments);
+                    detectCircularDependency(declaringType, argument, constructorSegment);
                 } else {
-                    push(methodSegment);
+                    Segment<?, ?> previous = peek();
+                    MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
+                    if (contains(methodSegment)) {
+                        push(methodSegment);
+                        throw new CircularDependencyException(AbstractBeanResolutionContext.this, argument, CIRCULAR_ERROR_MSG);
+                    } else {
+                        push(methodSegment);
+                    }
                 }
+            } finally {
+                traceResolution();
             }
             return this;
         }
 
         @Override
         public Path pushBeanCreate(BeanDefinition<?> declaringType, Argument<?> beanType) {
+            if (traceEnabled) {
+                traceMode.startTrace(
+                    AbstractBeanResolutionContext.this,
+                    beanType,
+                    declaringType
+                );
+            }
             return pushConstructorResolve(declaringType, beanType);
         }
 
+        private void traceResolution() {
+            if (traceEnabled) {
+               traceMode.traceSegment(
+                    AbstractBeanResolutionContext.this
+               );
+            }
+        }
+
         @Override
         public Path pushMethodArgumentResolve(BeanDefinition declaringType, MethodInjectionPoint methodInjectionPoint, Argument argument) {
-            Segment<?, ?> previous = peek();
-            MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodInjectionPoint.getName(), argument,
-                    methodInjectionPoint.getArguments(), previous instanceof MethodSegment ms ? ms : null);
-            if (contains(methodSegment)) {
-                push(methodSegment);
-                throw new CircularDependencyException(AbstractBeanResolutionContext.this, methodInjectionPoint, argument, CIRCULAR_ERROR_MSG);
-            } else {
-                push(methodSegment);
+            try {
+                Segment<?, ?> previous = peek();
+                MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodInjectionPoint.getName(), argument,
+                        methodInjectionPoint.getArguments(), previous instanceof MethodSegment ms ? ms : null);
+                if (contains(methodSegment)) {
+                    push(methodSegment);
+                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, methodInjectionPoint, argument, CIRCULAR_ERROR_MSG);
+                } else {
+                    push(methodSegment);
+                }
+            } finally {
+                traceResolution();
             }
 
             return this;
@@ -420,13 +635,41 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public Path pushMethodArgumentResolve(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments) {
-            Segment<?, ?> previous = peek();
-            MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
-            if (contains(methodSegment)) {
-                push(methodSegment);
-                throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, methodName, argument, CIRCULAR_ERROR_MSG);
-            } else {
-                push(methodSegment);
+            try {
+                Segment<?, ?> previous = peek();
+                MethodSegment<?, ?> methodSegment = new MethodArgumentSegment(declaringType, (Qualifier<Object>) getCurrentQualifier(), methodName, argument, arguments, previous instanceof MethodSegment ms ? ms : null);
+                if (contains(methodSegment)) {
+                    push(methodSegment);
+                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, methodName, argument, CIRCULAR_ERROR_MSG);
+                } else {
+                    push(methodSegment);
+                }
+            } finally {
+                traceResolution();
+            }
+
+            return this;
+        }
+
+        @Override
+        public Path pushEventListenerResolve(BeanDefinition<?> declaringType, Argument<?> eventType) {
+            try {
+                EventListenerSegment<?, ?> segment = new EventListenerSegment<>(
+                    declaringType,
+                    eventType
+                );
+                if (contains(segment)) {
+                    push(segment);
+                    throw new CircularDependencyException(
+                        AbstractBeanResolutionContext.this,
+                        eventType,
+                        CIRCULAR_ERROR_MSG
+                    );
+                } else {
+                    push(segment);
+                }
+            } finally {
+                traceResolution();
             }
 
             return this;
@@ -434,36 +677,48 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public Path pushFieldResolve(BeanDefinition declaringType, FieldInjectionPoint fieldInjectionPoint) {
-            FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldInjectionPoint.asArgument());
-            if (contains(fieldSegment)) {
-                push(fieldSegment);
-                throw new CircularDependencyException(AbstractBeanResolutionContext.this, fieldInjectionPoint, CIRCULAR_ERROR_MSG);
-            } else {
-                push(fieldSegment);
+            try {
+                FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldInjectionPoint.asArgument());
+                if (contains(fieldSegment)) {
+                    push(fieldSegment);
+                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, fieldInjectionPoint, CIRCULAR_ERROR_MSG);
+                } else {
+                    push(fieldSegment);
+                }
+            } finally {
+                traceResolution();
             }
             return this;
         }
 
         @Override
         public Path pushFieldResolve(BeanDefinition declaringType, Argument fieldAsArgument) {
-            FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldAsArgument);
-            if (contains(fieldSegment)) {
-                push(fieldSegment);
-                throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, fieldAsArgument.getName(), CIRCULAR_ERROR_MSG);
-            } else {
-                push(fieldSegment);
+            try {
+                FieldSegment<?, ?> fieldSegment = new FieldSegment<>(declaringType, getCurrentQualifier(), fieldAsArgument);
+                if (contains(fieldSegment)) {
+                    push(fieldSegment);
+                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, declaringType, fieldAsArgument.getName(), CIRCULAR_ERROR_MSG);
+                } else {
+                    push(fieldSegment);
+                }
+            } finally {
+                traceResolution();
             }
             return this;
         }
 
         @Override
         public Path pushAnnotationResolve(BeanDefinition beanDefinition, Argument annotationMemberBeanAsArgument) {
-            AnnotationSegment annotationSegment = new AnnotationSegment(beanDefinition, getCurrentQualifier(), annotationMemberBeanAsArgument);
-            if (contains(annotationSegment)) {
-                push(annotationSegment);
-                throw new CircularDependencyException(AbstractBeanResolutionContext.this, beanDefinition, annotationMemberBeanAsArgument.getName(), CIRCULAR_ERROR_MSG);
-            } else {
-                push(annotationSegment);
+            try {
+                AnnotationSegment annotationSegment = new AnnotationSegment(beanDefinition, getCurrentQualifier(), annotationMemberBeanAsArgument);
+                if (contains(annotationSegment)) {
+                    push(annotationSegment);
+                    throw new CircularDependencyException(AbstractBeanResolutionContext.this, beanDefinition, annotationMemberBeanAsArgument.getName(), CIRCULAR_ERROR_MSG);
+                } else {
+                    push(annotationSegment);
+                }
+            } finally {
+                traceResolution();
             }
             return this;
         }
@@ -514,6 +769,17 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
             super.push(segment);
             AbstractBeanResolutionContext.this.onNewSegment(segment);
         }
+
+        @Override
+        public void close() {
+            Path.super.close();
+            if (traceEnabled && isEmpty()) {
+                traceMode.finishTrace(
+                    AbstractBeanResolutionContext.this,
+                    rootDefinition
+                );
+            }
+        }
     }
 
     /**
@@ -541,6 +807,7 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
      */
     public static class ConstructorSegment extends AbstractSegment<Object, Object> implements ArgumentInjectionPoint<Object, Object> {
 
+        private static final String ANN_ADAPTER = "io.micronaut.aop.Adapter";
         private final String methodName;
         private final Argument<Object>[] arguments;
 
@@ -559,15 +826,40 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public String toString() {
+            return toConsoleString(false);
+        }
+
+        @NonNull
+        public String toConsoleString(boolean ansiSupported) {
             StringBuilder baseString;
-            if (CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
-                baseString = new StringBuilder("new ");
-                baseString.append(getTypeName(getDeclaringType().getBeanType()));
+            BeanDefinition<Object> declaringType = getDeclaringType();
+            TypeInformation<Object> typeInformation = declaringType.getTypeInformation();
+            if (declaringType.hasDeclaredStereotype(ANN_ADAPTER)) {
+                ExecutableMethod<Object, ?> method = declaringType.getExecutableMethods().iterator().next();
+                // Not great, but to produce accurate debug output we have to reach into AOP internals
+                Class<?> beanType = method.classValue(ANN_ADAPTER, "adaptedBean").orElse(declaringType.getBeanType());
+                String beanMethod = method.stringValue(ANN_ADAPTER, "adaptedMethod").orElse("unknown");
+                baseString = new StringBuilder(TypeFormat.getBeanTypeString(
+                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED,
+                    beanType,
+                    declaringType.asArgument().getTypeVariables(),
+                    declaringType.getAnnotationMetadata()
+                )).append(MEMBER_SEPARATOR);
+                baseString.append(beanMethod);
+            } else if (CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
+                baseString = new StringBuilder(
+                    ansiSupported ? AnsiColour.magentaBold("new ") : "new "
+                );
+                baseString.append(typeInformation.getBeanTypeString(
+                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED
+                ));
             } else {
-                baseString = new StringBuilder(getTypeName(getDeclaringType().getBeanType())).append('#');
+                baseString = new StringBuilder(typeInformation.getBeanTypeString(
+                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED
+                )).append(MEMBER_SEPARATOR);
                 baseString.append(methodName);
             }
-            outputArguments(baseString, arguments);
+            outputArguments(baseString, arguments, ansiSupported);
             return baseString.toString();
         }
 
@@ -625,17 +917,77 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public String toString() {
+            return toConsoleString(false);
+        }
+
+        @Override
+        public String toConsoleString(boolean ansiSupported) {
             BeanDefinition<?> declaringBean = getDeclaringBean();
             if (declaringBean.hasAnnotation(Factory.class)) {
-                ConstructorInjectionPoint<?> constructor = declaringBean.getConstructor();
-                var baseString = new StringBuilder(getTypeName(constructor.getDeclaringBeanType())).append(MEMBER_SEPARATOR);
-                baseString.append(getName());
-                outputArguments(baseString, getArguments());
+                String beanDescription = declaringBean.getBeanDescription(
+                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED,
+                    false
+                );
+
+                var baseString = new StringBuilder(beanDescription);
+                String methodName = getName();
+                if (!CONSTRUCTOR_METHOD_NAME.equals(methodName)) {
+                    String memberSeparator = ansiSupported ? AnsiColour.CYAN_BOLD + MEMBER_SEPARATOR + AnsiColour.RESET : MEMBER_SEPARATOR;
+                    baseString.append(memberSeparator);
+                    baseString.append(methodName);
+                }
+
+                outputArguments(baseString, getArguments(), ansiSupported);
                 return baseString.toString();
             } else {
-                return super.toString();
+                return super.toConsoleString(ansiSupported);
+            }
+        }
+    }
+
+    /**
+     * Represents a segment that is an event listener.
+     * @param <B> The bean type
+     * @param <T> The event type
+     */
+    public static class EventListenerSegment<B, T> extends AbstractSegment<B, T> implements CallableInjectionPoint<B> {
+        /**
+         * @param declaringClass The declaring class
+         * @param eventType       The argument
+         */
+        EventListenerSegment(
+            BeanDefinition<B> declaringClass,
+            Argument<T> eventType) {
+            super(declaringClass, null, eventType.getName(), eventType);
+        }
+
+        @Override
+        public String toConsoleString(boolean ansiSupported) {
+            if (ansiSupported) {
+                String event = getArgument().getTypeString(TypeFormat.ANSI_SIMPLE);
+                return event + " ➡️  " +
+                    getDeclaringBean().getBeanDescription(TypeFormat.ANSI_SHORTENED);
+            } else {
+                String event = getArgument().getTypeString(TypeFormat.SIMPLE);
+                return event + " -> " +
+                    getDeclaringBean().getBeanDescription(TypeFormat.SHORTENED);
             }
         }
+
+        @Override
+        public InjectionPoint<B> getInjectionPoint() {
+            return this;
+        }
+
+        @Override
+        public Argument<?>[] getArguments() {
+            return new Argument[] { getArgument() };
+        }
+
+        @Override
+        public BeanDefinition<B> getDeclaringBean() {
+            return getDeclaringType();
+        }
     }
 
     /**
@@ -659,9 +1011,20 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public String toString() {
-            StringBuilder baseString = new StringBuilder(getTypeName(getDeclaringType().getBeanType())).append(MEMBER_SEPARATOR);
+            return toConsoleString(false);
+        }
+
+        @Override
+        public String toConsoleString(boolean ansiSupported) {
+            StringBuilder baseString = new StringBuilder(
+                getDeclaringType().getTypeInformation().getBeanTypeString(
+                    ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED
+                )
+            );
+            String memberSeparator = ansiSupported ? AnsiColour.CYAN_BOLD + MEMBER_SEPARATOR + AnsiColour.RESET : MEMBER_SEPARATOR;
+            baseString.append(memberSeparator);
             baseString.append(getName());
-            outputArguments(baseString, arguments);
+            outputArguments(baseString, arguments, ansiSupported);
             return baseString.toString();
         }
 
@@ -707,7 +1070,21 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
 
         @Override
         public String toString() {
-            return getTypeName(getDeclaringType().getBeanType()) + MEMBER_SEPARATOR + getName();
+            return toConsoleString(false);
+        }
+
+        @Override
+        public String toConsoleString(boolean ansiSupported) {
+            String beanDescription = getDeclaringType().getBeanDescription(
+                ansiSupported ? TypeFormat.ANSI_SHORTENED : TypeFormat.SHORTENED,
+                false
+            );
+            StringBuilder baseString = new StringBuilder(beanDescription);
+            String memberSeparator = ansiSupported ? AnsiColour.CYAN_BOLD + MEMBER_SEPARATOR + AnsiColour.RESET : MEMBER_SEPARATOR;
+            baseString.append(memberSeparator);
+            baseString.append(getName());
+
+            return baseString.toString();
         }
 
         @Override
@@ -819,7 +1196,23 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
          * @return The name to be shown to user
          */
         protected String getTypeName(Class<?> type) {
-            return NameUtils.getShortenedName(type.getName());
+            if (InterceptedBean.class.isAssignableFrom(type)) {
+                Class<?>[] interfaces = type.getInterfaces();
+                Set<String> interfaceNames = Arrays.stream(interfaces)
+                    .map(Class::getName)
+                    .collect(Collectors.toSet());
+                if (type.isInterface() && interfaceNames.contains("io.micronaut.aop.Introduced")) {
+                    return NameUtils.getShortenedName(
+                        interfaces[0].getTypeName()
+                    );
+                } else {
+                    return NameUtils.getShortenedName(
+                        type.getSuperclass().getTypeName()
+                    );
+                }
+            } else {
+                return NameUtils.getShortenedName(type.getTypeName());
+            }
         }
 
         @Override
@@ -862,26 +1255,46 @@ public abstract class AbstractBeanResolutionContext implements BeanResolutionCon
         }
 
         /**
-         * @param baseString The base string
-         * @param arguments  The arguments
+         * @param baseString    The base string
+         * @param arguments     The arguments
+         * @param ansiSupported Whether ANSI colour is supported
          */
-        void outputArguments(StringBuilder baseString, Argument[] arguments) {
-            baseString.append('(');
+        void outputArguments(StringBuilder baseString, Argument[] arguments, boolean ansiSupported) {
+            baseString.append(ansiSupported ? AnsiColour.brightCyan("(") : "(");
             for (int i = 0; i < arguments.length; i++) {
                 Argument<?> argument = arguments[i];
                 boolean isInjectedArgument = argument.equals(getArgument());
                 if (isInjectedArgument) {
+                    if (ansiSupported) {
+                        baseString.append(AnsiColour.BLUE_UNDERLINED);
+                    }
                     baseString.append('[');
                 }
-                baseString.append(argument);
+                String beanTypeString = argument.getBeanTypeString(
+                    ansiSupported && !isInjectedArgument ? TypeFormat.ANSI_SIMPLE : TypeFormat.SIMPLE
+                );
+                baseString.append(beanTypeString)
+                    .append(' ')
+                    .append(ansiSupported && !isInjectedArgument ? AnsiColour.brightBlue(argument.getName()) : argument.getName());
                 if (isInjectedArgument) {
                     baseString.append(']');
+                    if (ansiSupported) {
+                        baseString.append(AnsiColour.RESET);
+                    }
                 }
+
                 if (i != arguments.length - 1) {
-                    baseString.append(',');
+                    Argument<?> next = arguments[i + 1];
+                    if (getDeclaringType().getBeanType().isSynthetic() &&
+                        next.getName().startsWith("$")) {
+                        // skip synthetic arguments
+                        break;
+                    }
+                    baseString.append(", ");
                 }
             }
-            baseString.append(')');
+            baseString.append(ansiSupported ? AnsiColour.brightCyan(")") : ")");
+
         }
     }
 }
diff --git a/inject/src/main/java/io/micronaut/context/AbstractInitializableBeanDefinition.java b/inject/src/main/java/io/micronaut/context/AbstractInitializableBeanDefinition.java
index c931ddf5e5..705b2043c0 100644
--- a/inject/src/main/java/io/micronaut/context/AbstractInitializableBeanDefinition.java
+++ b/inject/src/main/java/io/micronaut/context/AbstractInitializableBeanDefinition.java
@@ -1000,7 +1000,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         Argument<?> argument = methodRef.arguments[argIndex];
         try (BeanResolutionContext.Path path = resolutionContext.getPath()
                 .pushMethodArgumentResolve(this, methodRef.methodName, argument, methodRef.arguments)) {
-            Object val = resolvePropertyValue(resolutionContext, context, argument, propertyValue, cliProperty, false);
+            Object val = resolutionContext.resolvePropertyValue( argument, propertyValue, cliProperty, false);
             if (this instanceof ValidatedBeanDefinition validatedBeanDefinition) {
                 validatedBeanDefinition.validateBeanArgument(
                     resolutionContext,
@@ -1035,7 +1035,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         Argument<?> argument = methodRef.arguments[argIndex];
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath()
                 .pushMethodArgumentResolve(this, methodRef.methodName, argument, methodRef.arguments)) {
-            return resolvePropertyValue(resolutionContext, context, argument, value, null, true);
+            return resolutionContext.resolvePropertyValue(argument, value, null, true);
         }
     }
 
@@ -1069,7 +1069,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
                                                      String cliProperty) {
         try (BeanResolutionContext.Path path = resolutionContext.getPath()
                 .pushMethodArgumentResolve(this, setterName, argument, new Argument[]{argument})) {
-            Object val = resolvePropertyValue(resolutionContext, context, argument, propertyValue, cliProperty, false);
+            Object val = resolutionContext.resolvePropertyValue(argument, propertyValue, cliProperty, false);
             if (this instanceof ValidatedBeanDefinition validatedBeanDefinition) {
                 validatedBeanDefinition.validateBeanArgument(
                     resolutionContext,
@@ -1102,7 +1102,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
                                                                 String value) {
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath()
                 .pushMethodArgumentResolve(this, setterName, argument, new Argument[]{argument})) {
-            return resolvePropertyValue(resolutionContext, context, argument, value, null, true);
+            return resolutionContext.resolvePropertyValue(argument, value, null, true);
         }
     }
 
@@ -1145,7 +1145,8 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     protected final <K> K getBeanForMethodArgument(BeanResolutionContext resolutionContext, BeanContext context, int methodIndex, int argIndex, Qualifier<K> qualifier) {
         MethodReference methodRef = methodInjection[methodIndex];
         Argument<K> argument = resolveArgument(context, argIndex, methodRef.arguments);
-        try (BeanResolutionContext.Path ignored = resolutionContext.getPath()
+        BeanResolutionContext.Path path = resolutionContext.getPath();
+        try (BeanResolutionContext.Path ignored = path
                 .pushMethodArgumentResolve(this, methodRef.methodName, argument, methodRef.arguments)) {
             return resolveBean(
                 resolutionContext,
@@ -1339,13 +1340,14 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     protected final Object getBeanForConstructorArgument(BeanResolutionContext resolutionContext, BeanContext context, int argIndex, Qualifier qualifier) {
         MethodReference constructorMethodRef = (MethodReference) constructor;
         Argument<?> argument = resolveArgument(context, argIndex, constructorMethodRef.arguments);
+        BeanResolutionContext.Path path = resolutionContext.getPath();
         if (argument != null && argument.isDeclaredNullable()) {
-            BeanResolutionContext.Segment<?, ?> current = resolutionContext.getPath().peek();
+            BeanResolutionContext.Segment<?, ?> current = path.peek();
             if (current != null && current.getArgument().equals(argument)) {
                 return null;
             }
         }
-        try (BeanResolutionContext.Path ignored = resolutionContext.getPath()
+        try (BeanResolutionContext.Path ignored = path
                 .pushConstructorResolve(this, argument)) {
             return resolveBean(resolutionContext, argument, qualifier, false);
         }
@@ -1412,7 +1414,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         Argument<?> argument = constructorRef.arguments[argIndex];
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath().pushConstructorResolve(this, argument)) {
             try {
-                Object result = resolvePropertyValue(resolutionContext, context, argument, propertyValue, cliProperty, false);
+                Object result = resolutionContext.resolvePropertyValue(argument, propertyValue, cliProperty, false);
 
                 if (this instanceof ValidatedBeanDefinition validatedBeanDefinition) {
                     validatedBeanDefinition.validateBeanArgument(
@@ -1460,7 +1462,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         Argument<?> argument = constructorRef.arguments[argIndex];
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath().pushConstructorResolve(this, argument)) {
             try {
-                Object result = resolvePropertyValue(resolutionContext, context, argument, propertyValue, null, true);
+                Object result = resolutionContext.resolvePropertyValue(argument, propertyValue, null, true);
 
                 if (this instanceof ValidatedBeanDefinition validatedBeanDefinition) {
                     validatedBeanDefinition.validateBeanArgument(
@@ -1743,7 +1745,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     @Deprecated
     protected final Object getPropertyValueForField(BeanResolutionContext resolutionContext, BeanContext context, Argument argument, String propertyValue, String cliProperty) {
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath().pushFieldResolve(this, argument)) {
-            return resolvePropertyValue(resolutionContext, context, argument, propertyValue, cliProperty, false);
+            return resolutionContext.resolvePropertyValue(argument, propertyValue, cliProperty, false);
         }
     }
 
@@ -1763,7 +1765,7 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     @Deprecated
     protected final Object getPropertyPlaceholderValueForField(BeanResolutionContext resolutionContext, BeanContext context, Argument argument, String placeholder) {
         try (BeanResolutionContext.Path ignored = resolutionContext.getPath().pushFieldResolve(this, argument)) {
-            return resolvePropertyValue(resolutionContext, context, argument, placeholder, null, true);
+            return resolutionContext.resolvePropertyValue(argument, placeholder, null, true);
         }
     }
 
@@ -2021,14 +2023,11 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
     }
 
     private Object resolveValue(BeanResolutionContext resolutionContext, BeanContext context, AnnotationMetadata parentAnnotationMetadata, Argument<?> argument, Qualifier qualifier) {
-        if (!(context instanceof PropertyResolver)) {
-            throw new DependencyInjectionException(resolutionContext, "@Value requires a BeanContext that implements PropertyResolver");
-        }
         AnnotationMetadata argumentAnnotationMetadata = argument.getAnnotationMetadata();
         if (argumentAnnotationMetadata.hasEvaluatedExpressions()) {
             boolean isOptional = argument.isOptional();
             if (isOptional) {
-                Argument<?> t = isOptional ? argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT) : argument;
+                Argument<?> t = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
                 Object v = argumentAnnotationMetadata.getValue(Value.class, t).orElse(null);
                 return Optional.ofNullable(v);
             } else {
@@ -2061,6 +2060,12 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
             String valString = resolvePropertyValueName(resolutionContext, parentAnnotationMetadata, argumentAnnotationMetadata, valueAnnVal);
             ArgumentConversionContext conversionContext = wrapperType ? ConversionContext.of(argumentType) : ConversionContext.of(argument);
             Optional value = resolveValue((ApplicationContext) context, conversionContext, valueAnnVal != null, valString);
+            resolutionContext.valueResolved(
+                argument,
+                qualifier,
+                valString,
+                value.orElse(null)
+            );
             if (argument.isOptional()) {
                 if (value.isEmpty()) {
                     return value;
@@ -2096,78 +2101,6 @@ public abstract class AbstractInitializableBeanDefinition<T> extends AbstractBea
         }
     }
 
-    private Object resolvePropertyValue(BeanResolutionContext resolutionContext, BeanContext context, Argument<?> argument,
-                                        String stringValue, String cliProperty, boolean isPlaceholder) {
-        if (!(context instanceof PropertyResolver)) {
-            throw new DependencyInjectionException(resolutionContext, "@Value requires a BeanContext that implements PropertyResolver");
-        }
-        ApplicationContext applicationContext = (ApplicationContext) context;
-
-        Argument<?> argumentType = argument;
-        Class<?> wrapperType = null;
-        Class<?> type = argument.getType();
-        if (type == Optional.class) {
-            wrapperType = Optional.class;
-            argumentType = argument.getFirstTypeVariable().orElse(Argument.OBJECT_ARGUMENT);
-        } else if (type == OptionalInt.class) {
-            wrapperType = OptionalInt.class;
-            argumentType = Argument.INT;
-        } else if (type == OptionalLong.class) {
-            wrapperType = OptionalLong.class;
-            argumentType = Argument.LONG;
-        } else if (type == OptionalDouble.class) {
-            wrapperType = OptionalDouble.class;
-            argumentType = Argument.DOUBLE;
-        }
-
-        ArgumentConversionContext<?> conversionContext = wrapperType != null ? ConversionContext.of(argumentType) : ConversionContext.of(argument);
-
-        Optional<?> value;
-        if (isPlaceholder) {
-            value = applicationContext.resolvePlaceholders(stringValue).flatMap(v -> applicationContext.getConversionService().convert(v, conversionContext));
-        } else {
-            stringValue = substituteWildCards(resolutionContext, stringValue);
-            value = applicationContext.getProperty(stringValue, conversionContext);
-            if (value.isEmpty() && cliProperty != null) {
-                value = applicationContext.getProperty(cliProperty, conversionContext);
-            }
-        }
-
-        if (argument.isOptional()) {
-            if (value.isEmpty()) {
-                return value;
-            } else {
-                Object convertedOptional = value.get();
-                if (convertedOptional instanceof Optional) {
-                    return convertedOptional;
-                } else {
-                    return value;
-                }
-            }
-        } else {
-            if (wrapperType != null) {
-                final Object v = value.orElse(null);
-                if (OptionalInt.class == wrapperType) {
-                    return v instanceof Integer i ? OptionalInt.of(i) : OptionalInt.empty();
-                } else if (OptionalLong.class == wrapperType) {
-                    return v instanceof Long l ? OptionalLong.of(l) : OptionalLong.empty();
-                } else if (OptionalDouble.class == wrapperType) {
-                    return v instanceof Double d ? OptionalDouble.of(d) : OptionalDouble.empty();
-                }
-            }
-            if (value.isPresent()) {
-                return value.get();
-            } else {
-                if (argument.isDeclaredNullable()) {
-                    return null;
-                }
-                String finalStringValue = stringValue;
-                return argument.getAnnotationMetadata().getValue(Bindable.class, "defaultValue", argument)
-                        .orElseThrow(() -> DependencyInjectionException.missingProperty(resolutionContext, conversionContext, finalStringValue));
-            }
-        }
-    }
-
     private <K> @Nullable K resolveBean(
         BeanResolutionContext resolutionContext,
         Argument<K> argument,
diff --git a/inject/src/main/java/io/micronaut/context/ApplicationContextBuilder.java b/inject/src/main/java/io/micronaut/context/ApplicationContextBuilder.java
index 8b554e37e7..3fa826318d 100644
--- a/inject/src/main/java/io/micronaut/context/ApplicationContextBuilder.java
+++ b/inject/src/main/java/io/micronaut/context/ApplicationContextBuilder.java
@@ -36,6 +36,20 @@ import java.util.Map;
  */
 public interface ApplicationContextBuilder {
 
+    /**
+     * Sets the trace mode for bean resolution.
+     * @param traceMode The debug mode
+     * @param classPatterns The patterns
+     * @since 4.8.0
+     * @see BeanResolutionTraceMode
+     * @return This builder
+     */
+    default @NonNull ApplicationContextBuilder beanResolutionTrace(
+        @NonNull BeanResolutionTraceMode traceMode,
+        String... classPatterns) {
+        return this;
+    }
+
     /**
      * Whether to eager initialize {@link io.micronaut.context.annotation.ConfigurationProperties} beans.
      * @param eagerInitConfiguration True if configuration properties should be eagerly initialized
diff --git a/inject/src/main/java/io/micronaut/context/BeanContextConfiguration.java b/inject/src/main/java/io/micronaut/context/BeanContextConfiguration.java
index bfcfb71220..99b89adb1f 100644
--- a/inject/src/main/java/io/micronaut/context/BeanContextConfiguration.java
+++ b/inject/src/main/java/io/micronaut/context/BeanContextConfiguration.java
@@ -32,6 +32,27 @@ import java.util.Set;
  */
 public interface BeanContextConfiguration {
 
+    /**
+     * The debug mode for bean resolution.
+     *
+     * @since 4.8.0
+     * @see BeanResolutionTraceMode
+     * @return The bean resolution debug mode.
+     */
+    default @NonNull BeanResolutionTraceMode getTraceMode() {
+        return BeanResolutionTraceMode.NONE;
+    }
+
+    /**
+     * The class patterns to trace.
+     *
+     * @return A set of regex patterns for tracing.
+     * @since 4.8.0
+     */
+    default Set<String> getTraceClasses() {
+        return Set.of();
+    }
+
     /**
      * @return If a {@link io.micronaut.context.exceptions.NoSuchBeanException} should be thrown on a missing {@link io.micronaut.context.BeanProvider} or {@link jakarta.inject.Provider}
      * @since 3.0.0
diff --git a/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java b/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java
index 2c48f33608..efca024776 100644
--- a/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java
+++ b/inject/src/main/java/io/micronaut/context/BeanResolutionContext.java
@@ -300,6 +300,25 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
     @Nullable
     ConfigurationPath setConfigurationPath(@Nullable ConfigurationPath configurationPath);
 
+    /**
+     * Resolve a property value.
+     * @param argument The argument
+     * @param stringValue The string value
+     * @param cliProperty The CLI property
+     * @param isPlaceholder Whether it is a place holder
+     * @return The resolved value
+     */
+    @Nullable Object resolvePropertyValue(Argument<?> argument, String stringValue, String cliProperty, boolean isPlaceholder);
+
+    /**
+     * Callback when a value is resolved in some other context.
+     * @param argument The argument
+     * @param qualifier The qualifier
+     * @param property The property
+     * @param value The value
+     */
+    void valueResolved(Argument<?> argument, Qualifier<?> qualifier, String property, @Nullable Object value);
+
     /**
      * Represents a path taken to resolve a bean definitions dependencies.
      */
@@ -354,6 +373,14 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
          */
         Path pushMethodArgumentResolve(BeanDefinition declaringType, String methodName, Argument argument, Argument[] arguments);
 
+        /**
+         * Push resolution of an event listener
+         * @param declaringType The declaration type
+         * @param eventType The event type
+         * @return The path
+         */
+        Path pushEventListenerResolve(BeanDefinition<?> declaringType, Argument<?> eventType);
+
         /**
          * Push an unresolved field onto the queue.
          *
@@ -372,6 +399,12 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
          */
         Path pushFieldResolve(BeanDefinition declaringType, Argument fieldAsArgument);
 
+        /**
+         * Push resolution of a bean from an annotation.
+         * @param beanDefinition The bean definition
+         * @param annotationMemberBeanAsArgument The annotation member
+         * @return The path
+         */
         Path pushAnnotationResolve(BeanDefinition beanDefinition, Argument annotationMemberBeanAsArgument);
 
         /**
@@ -381,6 +414,28 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
          */
         String toCircularString();
 
+        /**
+         * Converts the path to a circular string.
+         *
+         * @param ansiSupported  Whether ANSI colour is supported
+         * @return The circular string
+         * @since 4.8.0
+         */
+        default String toConsoleCircularString(boolean ansiSupported) {
+            return toCircularString();
+        }
+
+        /**
+         * Converts the path to a string.
+         *
+         * @param ansiSupported  Whether ANSI colour is supported
+         * @return The string
+         * @since 4.8.0
+         */
+        default String toConsoleString(boolean ansiSupported) {
+            return toString();
+        }
+
         /**
          * @return The current path segment
          */
@@ -400,6 +455,15 @@ public interface BeanResolutionContext extends ValueResolver<CharSequence>, Auto
      */
     interface Segment<B, T> {
 
+        /**
+         * To a console string.
+         * @param ansiSupported Whether ansi is supported
+         * @return The string
+         */
+        default String toConsoleString(boolean ansiSupported) {
+            return toString();
+        }
+
         /**
          * @return The type requested
          */
diff --git a/inject/src/main/java/io/micronaut/context/BeanResolutionTraceMode.java b/inject/src/main/java/io/micronaut/context/BeanResolutionTraceMode.java
new file mode 100644
index 0000000000..bcc3dbd2be
--- /dev/null
+++ b/inject/src/main/java/io/micronaut/context/BeanResolutionTraceMode.java
@@ -0,0 +1,427 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.context;
+
+import io.micronaut.context.annotation.ConfigurationReader;
+import io.micronaut.context.env.Environment;
+import io.micronaut.context.env.PropertyEntry;
+import io.micronaut.context.env.PropertySource;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.naming.NameUtils;
+import io.micronaut.core.naming.Named;
+import io.micronaut.core.order.OrderUtil;
+import io.micronaut.core.type.Argument;
+import io.micronaut.core.type.TypeInformation;
+import io.micronaut.core.util.AnsiColour;
+import io.micronaut.core.util.StringUtils;
+import io.micronaut.inject.BeanDefinition;
+import io.micronaut.inject.BeanDefinitionReference;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.util.Collection;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.stream.Collectors;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * Allows enabling more verbose debugging on bean resolution.
+ */
+public enum BeanResolutionTraceMode {
+    /**
+     * No debug enabled (the default).
+     */
+    NONE,
+
+    /**
+     * When log mode is enabled output will be
+     * written to a logger named {@code io.micronaut.context.resolution} at DEBUG level.
+     */
+    LOG,
+
+    /**
+     * With standard out debug output will be written to {@link System#out} avoiding any log formatting.
+     */
+    STANDARD_OUT;
+
+    static final Logger LOGGER = LoggerFactory.getLogger("io.micronaut.inject");
+    private static final String MODE_SYS_PROP = "micronaut.inject.trace.mode";
+    private static final String MODE_ENV_VAR = "MICRONAUT_INJECT_TRACE_MODE";
+    private static final String CLASSES_SYS_PROP = "micronaut.inject.trace";
+    private static final String CLASSES_ENV_VAR = "MICRONAUT_INJECT_TRACE";
+    private static final Set<String> INTERNAL_PACKAGES = Set.of(
+        "io.micronaut.context",
+        "io.micronaut.aop",
+        "io.micronaut.core.util",
+        "org.codehaus.groovy.vmplugin",
+        "java.util"
+    );
+
+    private static final String RIGHT_ARROW = AnsiColour.isSupported() ? " ➡️  " : " -> ";
+    private static final String RIGHT_ARROW_LOOP = AnsiColour.isSupported() ? " ↪️  " : "\\---> ";
+    private static final CharSequence START_TIME = "BeanResolutionTrace-start";
+
+    /**
+     * Obtains the default mode.
+     *
+     * @return The default mode
+     */
+    static BeanResolutionTraceMode getDefaultMode(Set<String> traceClasses) {
+        String mode = Optional
+            .ofNullable(System.getProperty(MODE_SYS_PROP))
+            .orElseGet(() -> System.getenv(MODE_ENV_VAR));
+        if (mode != null) {
+            return BeanResolutionTraceMode
+                .valueOf(NameUtils.environmentName(mode));
+        }
+        if (traceClasses.isEmpty()) {
+            return LOGGER.isTraceEnabled() ? BeanResolutionTraceMode.LOG : BeanResolutionTraceMode.NONE;
+        } else {
+            return LOGGER.isTraceEnabled() ? BeanResolutionTraceMode.LOG : BeanResolutionTraceMode.STANDARD_OUT;
+        }
+    }
+
+    static Set<String> getDefaultTraceClasses() {
+        String classes = Optional
+            .ofNullable(System.getProperty(CLASSES_SYS_PROP))
+            .orElseGet(() -> System.getenv(CLASSES_ENV_VAR));
+        if (classes != null) {
+            return Set.of(classes.split(","));
+        }
+        return Set.of();
+    }
+
+    void startTrace(
+        BeanResolutionContext resolutionContext,
+        Argument<?> beanType,
+        BeanDefinition<?> beanDefinition) {
+        resolutionContext.setAttribute(START_TIME, System.currentTimeMillis());
+        List<StackWalker.StackFrame> interestingFrames = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE)
+            .walk(s ->
+                s.dropWhile(f ->
+                        (INTERNAL_PACKAGES.stream().anyMatch(p -> f.getClassName().startsWith(p)) || f.getDeclaringClass().isSynthetic()) &&
+                            // capture startup beans
+                            !(f.getClassName().equals(DefaultBeanContext.class.getName()) && f.getMethodName().equals("start")))
+                    .limit(3)
+                    .collect(Collectors.toList())
+            );
+        String beanName = getBeanName(beanType, beanDefinition);
+        StringWriter sw = new StringWriter();
+        try (BufferedWriter writer = new BufferedWriter(sw)) {
+            writer.newLine();
+            String beanDescription = beanDefinition.getBeanDescription(TypeInformation.TypeFormat.ANSI_SHORTENED);
+            writer.write(beanName + RIGHT_ARROW + beanDescription + " at location:");
+            writer.newLine();
+            for (StackWalker.StackFrame stackFrame : interestingFrames) {
+                StackTraceElement traceElement = stackFrame.toStackTraceElement();
+                StackTraceElement shortened = new StackTraceElement(
+                    NameUtils.getShortenedName(traceElement.getClassName()),
+                    traceElement.getMethodName(),
+                    traceElement.getFileName(),
+                    traceElement.getLineNumber()
+                );
+                writer.write(shortened.toString());
+                writer.newLine();
+            }
+            writer.newLine();
+        } catch (IOException e) {
+            // ignore, should never happen
+        }
+        switch (this) {
+            case STANDARD_OUT -> System.out.println(sw);
+            case LOG -> LOGGER.info(sw.toString());
+        }
+    }
+
+    private static String getBeanName(Argument<?> beanType, BeanDefinition<?> beanDefinition) {
+        String beanName;
+        if (beanType.getType().isSynthetic()) {
+            beanName = beanDefinition.getTypeInformation().getBeanTypeString(TypeInformation.TypeFormat.ANSI_SIMPLE);
+        } else {
+            beanName = beanType
+                .getBeanTypeString(TypeInformation.TypeFormat.ANSI_SIMPLE);
+        }
+        return beanName;
+    }
+
+    <T> void traceBeanResolved(
+        BeanResolutionContext resolutionContext,
+        @NonNull Argument<T> beanType,
+        @Nullable Qualifier<T> qualifier,
+        @Nullable T bean) {
+        String prefix = padLeft(resolutionContext, 1) + RIGHT_ARROW;
+        StringWriter sw = new StringWriter();
+        try (BufferedWriter writer = new BufferedWriter(sw)) {
+
+            writer.write(prefix);
+            writer.write(bean != null ? "✅ " : "❌ ");
+            if (bean != null) {
+                if (qualifier != null) {
+                    if (qualifier instanceof Named named) {
+                        writer.write(AnsiColour.yellow("@Named("));
+                        writer.write(AnsiColour.green("\"" + named.getName() + "\""));
+                        writer.write(AnsiColour.yellow(")"));
+                    } else {
+                        writer.write(AnsiColour.yellow(qualifier.toString()));
+                    }
+                    writer.write(" ");
+                }
+                writer.write(AnsiColour.formatObject(bean));
+            } else {
+                writer.write("Bean of type ");
+                writer.write(beanType.getBeanTypeString(TypeInformation.TypeFormat.ANSI_SIMPLE));
+                writer.write(" does not exist.");
+            }
+
+            writer.newLine();
+        } catch (IOException e) {
+            // ignore, should never happen
+        }
+        switch (this) {
+            case STANDARD_OUT -> System.out.println(sw);
+            case LOG -> LOGGER.trace(sw.toString());
+        }
+    }
+
+    void traceValueResolved(
+        BeanResolutionContext resolutionContext,
+        Argument<?> argument,
+        String property,
+        Object value) {
+        BeanContext context = resolutionContext.getContext();
+        if (context instanceof ApplicationContext applicationContext) {
+            Environment environment = applicationContext.getEnvironment();
+            PropertySource.Origin origin = environment.getPropertyEntry(property)
+                .map(PropertyEntry::origin)
+                .orElse(null);
+            String prefix = padLeft(resolutionContext, 1) + RIGHT_ARROW;
+            StringWriter sw = new StringWriter();
+            try (BufferedWriter writer = new BufferedWriter(sw)) {
+                writer.write(prefix);
+                writer.write(AnsiColour.formatObject(property));
+                writer.write(" = ");
+                writer.write(AnsiColour.formatObject(value));
+                if (origin != null) {
+                    writer.write(" (Origin: " + AnsiColour.brightYellow(origin.location()) + ")");
+                }
+                writer.newLine();
+            } catch (IOException e) {
+                // ignore, should not happen
+            }
+            switch (this) {
+                case STANDARD_OUT -> System.out.println(sw);
+                case LOG -> LOGGER.trace(sw.toString());
+            }
+        }
+    }
+
+    @NotNull
+    private static String padLeft(BeanResolutionContext resolutionContext, int amount) {
+        int size = resolutionContext.getPath().size() + amount;
+        String prefix = "";
+        if (size > 1) {
+            prefix = "   ".repeat(size);
+        }
+        return prefix;
+    }
+
+    void finishTrace(BeanResolutionContext resolutionContext, BeanDefinition<?> rootDefinition) {
+        Object v = resolutionContext.getAttribute(START_TIME);
+        if (v instanceof Long start) {
+            StringWriter sw = new StringWriter();
+            try (BufferedWriter writer = new BufferedWriter(sw)) {
+                writer.newLine();
+                String beanName = rootDefinition.getBeanDescription(TypeInformation.TypeFormat.ANSI_SIMPLE, false);
+                long now = System.currentTimeMillis();
+                writer.write("✅ Created " + beanName + " in " + (now - start) + "ms");
+                writer.newLine();
+                writer.write("------------");
+                writer.newLine();
+            } catch (IOException e) {
+                // ignore, should not happen
+            }
+            switch (this) {
+                case STANDARD_OUT -> System.out.println(sw);
+                case LOG -> LOGGER.trace(sw.toString());
+            }
+        }
+    }
+
+    void traceSegment(BeanResolutionContext context) {
+        BeanResolutionContext.Path path = context.getPath();
+        BeanResolutionContext.Segment<?, ?> segment = path.peek();
+        if (segment != null) {
+            if (segment.getDeclaringType() != null &&
+                segment.getDeclaringType().getBeanType().isSynthetic() &&
+                segment.getArgument().getName().startsWith("$")) {
+                // skip synthetic arguments
+                return;
+            }
+            int size = path.size();
+            String prefix = "";
+            if (size > 1) {
+                String spaces = "   ".repeat(size);
+                prefix = spaces + RIGHT_ARROW_LOOP;
+            }
+            String content = prefix + segment.toConsoleString(AnsiColour.isSupported());
+            switch (this) {
+                case STANDARD_OUT -> System.out.println(content);
+                case LOG -> LOGGER.trace(content);
+            }
+        }
+    }
+
+    void traceBeanDisabled(BeanResolutionContext resolutionContext, String disabledBeanMessage) {
+        String[] lines = disabledBeanMessage.split("\\r?\\n");
+        String prefix = padLeft(resolutionContext, 3);
+        StringWriter sw = new StringWriter();
+        try (BufferedWriter writer = new BufferedWriter(sw)) {
+            for (String line : lines) {
+                if (StringUtils.isNotEmpty(line.trim())) {
+                    writer.write(prefix);
+                    if (line.startsWith("*")) {
+                        writer.write("❌ ");
+                        writer.write(line.substring(1));
+                        writer.newLine();
+                    } else {
+                        writer.write(line);
+                        writer.newLine();
+                    }
+                }
+            }
+        } catch (IOException e) {
+            // ignore, should not happen
+        }
+        switch (this) {
+            case STANDARD_OUT -> System.out.println(sw);
+            case LOG -> LOGGER.trace(sw.toString());
+        }
+    }
+
+    void traceConfiguration(
+        Environment environment,
+        @NonNull Collection<BeanDefinitionReference<?>> beanReferences,
+        Collection<DisabledBean<?>> disabledBeans) {
+        Collection<PropertySource> propertySources = environment.getPropertySources();
+        Set<String> activeNames = environment.getActiveNames();
+        StringWriter sw = new StringWriter();
+        try (BufferedWriter writer = new BufferedWriter(sw)) {
+            writer.newLine();
+            writer.write("Configuration Profile");
+            writer.newLine();
+            writer.write("---------------------");
+            writer.newLine();
+            writer.write(AnsiColour.brightBlue("Active Environment Names: ") + activeNames);
+            writer.newLine();
+            writer.newLine();
+            writer.write(AnsiColour.brightBlue("Available Property Sources (Priority Order Highest to Lowest): "));
+            writer.newLine();
+            propertySources.stream().sorted(OrderUtil.REVERSE_ORDERED_COMPARATOR)
+                .forEach(propertySource -> {
+                    try {
+                        writer.write(" ✚ ");
+                        writer.write(AnsiColour.formatObject(propertySource));
+                        writer.write(" (");
+                        writer.write(propertySource.getOrigin().location() + ")");
+                        writer.newLine();
+                    } catch (IOException e) {
+                        // ignore.
+                    }
+                });
+            writer.newLine();
+            writer.write(AnsiColour.brightBlue("Configurable Beans: "));
+            writer.newLine();
+            List<BeanDefinitionReference<?>> configRefs = beanReferences.stream()
+                .filter(ref -> ref.hasStereotype(ConfigurationReader.class) &&
+                    ref.stringValue(ConfigurationReader.class, "prefix").isPresent())
+                .sorted((b1, b2) ->
+                    {
+                        String p1 = b1.stringValue(ConfigurationReader.class, "prefix").get();
+                        String p2 = b2.stringValue(ConfigurationReader.class, "prefix").get();
+                        return p1.compareTo(p2);
+                    }
+                ).toList();
+
+            configRefs.forEach(ref -> {
+                String prefix = ref.stringValue(ConfigurationReader.class, "prefix").orElse(null);
+                if (prefix != null) {
+                    Argument<?> argument = ref.asArgument();
+                    try {
+                        writer.write(" ✚ ");
+                        writer.write(AnsiColour.formatObject(prefix));
+                        writer.write(RIGHT_ARROW);
+                        writer.write(TypeInformation.TypeFormat.getTypeString(
+                            TypeInformation.TypeFormat.ANSI_SHORTENED,
+                            argument.getType(),
+                            argument.getTypeVariables()
+                        ));
+                        writer.newLine();
+                    } catch (IOException e) {
+                        // ignore
+                    }
+                }
+            });
+            writer.newLine();
+            writer.write(AnsiColour.brightBlue("Applicable Configuration Present: "));
+            writer.newLine();
+            configRefs.stream()
+                .flatMap(ref -> ref.stringValue(ConfigurationReader.class, "prefix").stream())
+                .flatMap(prefix -> {
+                    if (prefix.endsWith(".*")) {
+                        String eachProperty = prefix.substring(0, prefix.length() - 2);
+                        return environment.getPropertyEntries(eachProperty).stream().flatMap(entry ->
+                            {
+                                String path = eachProperty + '.' + entry;
+                                return environment.getPropertyEntries(
+                                    path
+                                ).stream().map(p -> path + '.' + p);
+                            }
+                        );
+                    } else {
+                        return environment.getPropertyEntries(prefix).stream().map(entry ->
+                            prefix + '.' + entry
+                        );
+                    }
+                }).sorted().distinct().forEach(entry -> {
+                    try {
+                        writer.write(" ✚ ");
+                        writer.write(AnsiColour.formatObject(entry));
+                        PropertyEntry pe = environment.getPropertyEntry(entry).orElse(null);
+                        if (pe != null) {
+                            String text = " Origin(" + AnsiColour.formatObject(pe.raw()) + " from " + AnsiColour.brightYellow(pe.origin().location()) + ")";
+                            writer.write(text);
+                        }
+                        writer.newLine();
+                    } catch (IOException e) {
+                        // ignore
+                    }
+                });
+            writer.write("---------------------");
+            writer.newLine();
+        } catch (IOException e) {
+            // ignore, should never happen
+        }
+        switch (this) {
+            case STANDARD_OUT -> System.out.println(sw);
+            case LOG -> LOGGER.trace(sw.toString());
+        }
+    }
+}
diff --git a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
index a5e735c2b2..195f2e14ee 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultApplicationContext.java
@@ -143,6 +143,13 @@ public class DefaultApplicationContext extends DefaultBeanContext implements Con
         configuration.getContextConfigurer().ifPresent(configurer ->
             configurer.configure(this)
         );
+        if (traceMode != BeanResolutionTraceMode.NONE) {
+            traceMode.traceConfiguration(
+                this.environment,
+                this.getBeanDefinitionReferences(),
+                this.getDisabledBeans()
+            );
+        }
     }
 
     @Override
diff --git a/inject/src/main/java/io/micronaut/context/DefaultApplicationContextBuilder.java b/inject/src/main/java/io/micronaut/context/DefaultApplicationContextBuilder.java
index 6995ceebf8..16fd7e9e0a 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultApplicationContextBuilder.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultApplicationContextBuilder.java
@@ -25,6 +25,7 @@ import io.micronaut.core.cli.CommandLine;
 import io.micronaut.core.io.scan.ClassPathResourceLoader;
 import io.micronaut.core.io.service.SoftServiceLoader;
 import io.micronaut.core.order.OrderUtil;
+import io.micronaut.core.util.ArrayUtils;
 import io.micronaut.core.util.StringUtils;
 
 import java.lang.annotation.Annotation;
@@ -72,6 +73,8 @@ public class DefaultApplicationContextBuilder implements ApplicationContextBuild
     private boolean allowEmptyProviders = false;
     private Boolean bootstrapEnvironment = null;
     private boolean enableDefaultPropertySources = true;
+    private Set<String> traceClasses = BeanResolutionTraceMode.getDefaultTraceClasses();
+    private BeanResolutionTraceMode traceMode = BeanResolutionTraceMode.getDefaultMode(traceClasses);
 
     /**
      * Default constructor.
@@ -89,6 +92,27 @@ public class DefaultApplicationContextBuilder implements ApplicationContextBuild
         this.classLoader = classLoader;
     }
 
+    @Override
+    public ApplicationContextBuilder beanResolutionTrace(
+        BeanResolutionTraceMode traceMode,
+        String... classPatterns) {
+        this.traceMode = traceMode == null ? BeanResolutionTraceMode.NONE : traceMode;
+        if (ArrayUtils.isNotEmpty(classPatterns)) {
+            this.traceClasses = Set.of(classPatterns);
+        }
+        return this;
+    }
+
+    @Override
+    public BeanResolutionTraceMode getTraceMode() {
+        return this.traceMode;
+    }
+
+    @Override
+    public Set<String> getTraceClasses() {
+        return traceClasses;
+    }
+
     private ClassLoader resolveClassLoader() {
         final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
         if (contextClassLoader != null) {
diff --git a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
index ae0471ea4c..5b6f8803db 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultBeanContext.java
@@ -113,6 +113,7 @@ import io.micronaut.inject.qualifiers.AnyQualifier;
 import io.micronaut.inject.qualifiers.FilteringQualifier;
 import io.micronaut.inject.qualifiers.Qualified;
 import io.micronaut.inject.qualifiers.Qualifiers;
+import io.micronaut.inject.qualifiers.TypeArgumentQualifier;
 import io.micronaut.inject.validation.BeanDefinitionValidator;
 import jakarta.inject.Singleton;
 import org.slf4j.Logger;
@@ -175,6 +176,8 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     protected final AtomicBoolean initializing = new AtomicBoolean(false);
     protected final AtomicBoolean terminating = new AtomicBoolean(false);
 
+    final @NonNull BeanResolutionTraceMode traceMode;
+    final @NonNull Set<String> tracePatterns;
     final Map<BeanIdentifier, BeanRegistration<?>> singlesInCreation = new ConcurrentHashMap<>(5);
 
     protected final SingletonScope singletonScope = new SingletonScope();
@@ -302,6 +305,8 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         this.eagerInitStereotypesPresent = !configuredEagerSingletonAnnotations.isEmpty();
         this.eagerInitSingletons = eagerInitStereotypesPresent && (configuredEagerSingletonAnnotations.contains(AnnotationUtil.SINGLETON) || configuredEagerSingletonAnnotations.contains(Singleton.class.getName()));
         this.beanContextConfiguration = contextConfiguration;
+        this.traceMode = beanContextConfiguration.getTraceMode();
+        this.tracePatterns = beanContextConfiguration.getTraceClasses();
     }
 
     /**
@@ -628,7 +633,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                     return false;
                 });
         }
-        return foundMethod.map(executableMethod -> new BeanExecutionHandle<>(this, beanType, qualifier, executableMethod));
+        return foundMethod.map(executableMethod -> new BeanExecutionHandle<>(this, beanDefinition, beanType, qualifier, executableMethod));
     }
 
     @Override
@@ -1029,8 +1034,12 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         ArgumentUtils.requireNonNull("beanType", beanType);
         Optional<BeanDefinition<T>> candidate = findBeanDefinition(Argument.of(beanType), qualifier);
         if (candidate.isPresent()) {
-            try (BeanResolutionContext resolutionContext = newResolutionContext(candidate.get(), null)) {
-                return doCreateBean(resolutionContext, candidate.get(), qualifier, argumentValues);
+            BeanDefinition<T> beanDefinition = candidate.get();
+            try (BeanResolutionContext resolutionContext = newResolutionContext(beanDefinition, null)) {
+                if (beanDefinition instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
+                    T bean = resolveByBeanFactory(resolutionContext, instantiatableBeanDefinition, qualifier, argumentValues);
+                    return postBeanCreated(resolutionContext, beanDefinition, qualifier, bean);
+                }
             }
         }
         throw newNoSuchBeanException(
@@ -1050,7 +1059,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         if (candidate.isPresent()) {
             BeanDefinition<T> definition = candidate.get();
             try (BeanResolutionContext resolutionContext = newResolutionContext(definition, null)) {
-                return doCreateBean(resolutionContext, definition, qualifier, args);
+                return doCreateBeanWithArguments(resolutionContext, definition, qualifier, args);
             }
         }
         throw newNoSuchBeanException(
@@ -1062,15 +1071,20 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     }
 
     @NonNull
-    private <T> T doCreateBean(@NonNull BeanResolutionContext resolutionContext,
-                               @NonNull BeanDefinition<T> definition,
-                               @Nullable Qualifier<T> qualifier,
-                               @Nullable Object... args) {
+    private <T> T doCreateBeanWithArguments(@NonNull BeanResolutionContext resolutionContext,
+                                            @NonNull BeanDefinition<T> definition,
+                                            @Nullable Qualifier<T> qualifier,
+                                            @Nullable Object... args) {
         Map<String, Object> argumentValues = resolveArgumentValues(resolutionContext, definition, args);
         if (LOG.isTraceEnabled()) {
             LOG.trace("Computed bean argument values: {}", argumentValues);
         }
-        return doCreateBean(resolutionContext, definition, qualifier, argumentValues);
+        if (definition instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
+            T bean = resolveByBeanFactory(resolutionContext, instantiatableBeanDefinition, qualifier, argumentValues);
+            return postBeanCreated(resolutionContext, definition, qualifier, bean);
+        } else {
+            throw new BeanInstantiationException("BeanDefinition doesn't support creating a new instance of the bean");
+        }
     }
 
     @NonNull
@@ -1378,7 +1392,12 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         if (concreteCandidate.isPresent()) {
             BeanDefinition<T> candidate = concreteCandidate.get();
             try (BeanResolutionContext context = newResolutionContext(candidate, resolutionContext)) {
-                return doCreateBean(context, candidate, qualifier);
+                if (candidate instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
+                    T bean = resolveByBeanFactory(context, instantiatableBeanDefinition, qualifier, Collections.emptyMap());
+                    return postBeanCreated(context, candidate, qualifier, bean);
+                } else {
+                    throw new BeanInstantiationException("BeanDefinition doesn't support creating a new instance of the bean");
+                }
             }
         }
         throw newNoSuchBeanException(
@@ -1941,7 +1960,10 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         }
         List<Map.Entry<Class<?>, ListenersSupplier<T>>> eventToListeners = new ArrayList<>(typeToListener.size());
         for (Map.Entry<Class<?>, List<BeanDefinition<T>>> e : typeToListener.entrySet()) {
-            eventToListeners.add(new AbstractMap.SimpleEntry<>(e.getKey(), new EventListenerListenersSupplier<>(e.getValue())));
+            eventToListeners.add(new AbstractMap.SimpleEntry<>(e.getKey(), new EventListenerListenersSupplier<>(
+                Argument.of(listenerType, e.getKey()),
+                e.getValue()
+            )));
         }
         return eventToListeners;
     }
@@ -2282,40 +2304,6 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         beanConfigurations.put(configuration.getName(), configuration);
     }
 
-    /**
-     * Execution the creation of a bean. The returned value can be null if a
-     * factory method returned null.
-     *
-     * @param resolutionContext The {@link BeanResolutionContext}
-     * @param beanDefinition    The {@link BeanDefinition}
-     * @param qualifier         The {@link Qualifier}
-     * @param argumentValues    Any argument values passed to create the bean
-     * @param <T>               The bean generic type
-     * @return The created bean
-     */
-    @Internal
-    @NonNull
-    private <T> T doCreateBean(@NonNull BeanResolutionContext resolutionContext,
-                               @NonNull BeanDefinition<T> beanDefinition,
-                               @Nullable Qualifier<T> qualifier,
-                               @Nullable Map<String, Object> argumentValues) {
-        T bean;
-        if (beanDefinition instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
-            bean = resolveByBeanFactory(resolutionContext, instantiatableBeanDefinition, qualifier, argumentValues);
-        } else {
-            throw new BeanInstantiationException("BeanDefinition doesn't support creating a new instance of the bean");
-        }
-        return postBeanCreated(resolutionContext, beanDefinition, qualifier, bean);
-    }
-
-    @Internal
-    @NonNull
-    private <T> T doCreateBean(@NonNull BeanResolutionContext resolutionContext,
-                               @NonNull BeanDefinition<T> beanDefinition,
-                               @Nullable Qualifier<T> qualifier) {
-        return doCreateBean(resolutionContext, beanDefinition, qualifier, Collections.emptyMap());
-    }
-
     @NonNull
     private <T> T resolveByBeanFactory(@NonNull BeanResolutionContext resolutionContext,
                                        @NonNull BeanDefinition<T> beanDefinition,
@@ -2690,7 +2678,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                 Argument.OBJECT_ARGUMENT
             );
             for (BeanDefinition beanCandidate : beanCandidates) {
-                findOrCreateSingletonBeanRegistration(
+                intializeEagerBean(
                         null,
                         beanCandidate,
                         beanCandidate.asArgument(),
@@ -2699,7 +2687,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
             }
 
         } else {
-            findOrCreateSingletonBeanRegistration(null, beanDefinition, beanDefinition.asArgument(), null);
+            intializeEagerBean(null, beanDefinition, beanDefinition.asArgument(), null);
         }
     }
 
@@ -2987,7 +2975,11 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
         }
 
         if (definition.isSingleton() && !isScopedProxyDefinition) {
-            return findOrCreateSingletonBeanRegistration(resolutionContext, definition, beanType, qualifier);
+            BeanRegistration<T> beanRegistration = singletonScope.findBeanRegistration(definition, beanType, qualifier);
+            if (beanRegistration != null) {
+                return beanRegistration;
+            }
+            return singletonScope.getOrCreate(this, resolutionContext, definition, beanType, qualifier);
         }
 
         final boolean isProxy = definition.isProxy();
@@ -3018,10 +3010,10 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     }
 
     @NonNull
-    private <T> BeanRegistration<T> findOrCreateSingletonBeanRegistration(@Nullable BeanResolutionContext resolutionContext,
-                                                                          @NonNull BeanDefinition<T> definition,
-                                                                          @NonNull Argument<T> beanType,
-                                                                          @Nullable Qualifier<T> qualifier) {
+    private <T> BeanRegistration<T> intializeEagerBean(@Nullable BeanResolutionContext resolutionContext,
+                                                       @NonNull BeanDefinition<T> definition,
+                                                       @NonNull Argument<T> beanType,
+                                                       @Nullable Qualifier<T> qualifier) {
         BeanRegistration<T> beanRegistration = singletonScope.findBeanRegistration(definition, beanType, qualifier);
         if (beanRegistration != null) {
             return beanRegistration;
@@ -3120,11 +3112,29 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
             final BeanResolutionContext.Path path = context.getPath();
             final boolean isNewPath = path.isEmpty();
             if (isNewPath) {
-                path.pushBeanCreate(definition, beanType);
+                Argument<T> resolvedBeanType;
+                if (qualifier instanceof TypeArgumentQualifier<T> taq) {
+                    Class<?>[] typeArguments = taq.getTypeArguments();
+                    resolvedBeanType = Argument.of(
+                        beanType.getType(),
+                        beanType.getAnnotationMetadata(),
+                        typeArguments
+                    );
+                } else {
+                    resolvedBeanType = beanType;
+                }
+                path.pushBeanCreate(definition, resolvedBeanType);
             }
             try {
                 List<BeanRegistration<?>> parentDependentBeans = context.popDependentBeans();
-                T bean = doCreateBean(context, definition, qualifier);
+                T bean;
+                if (definition instanceof InstantiatableBeanDefinition<T> instantiatableBeanDefinition) {
+                    bean = resolveByBeanFactory(context, instantiatableBeanDefinition, qualifier, Collections.emptyMap());
+                } else {
+                    throw new BeanInstantiationException("BeanDefinition doesn't support creating a new instance of the bean");
+                }
+                bean = postBeanCreated(context, definition, qualifier, bean);
+
                 BeanRegistration<?> dependentFactoryBean = context.getAndResetDependentFactoryBean();
                 if (dependentFactoryBean != null) {
                     destroyBean(dependentFactoryBean);
@@ -3139,7 +3149,7 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                 return beanRegistration;
             } finally {
                 if (isNewPath) {
-                    path.pop();
+                    path.close();
                 }
             }
         }
@@ -3578,7 +3588,12 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                                         @NonNull Collection<BeanRegistration<T>> beansOfTypeList) {
         BeanRegistration<T> beanRegistration = null;
         try {
-            beanRegistration = resolveBeanRegistration(resolutionContext, candidate);
+            beanRegistration = resolveBeanRegistration(
+                resolutionContext,
+                candidate,
+                candidate.asArgument(),
+                candidate.getDeclaredQualifier()
+            );
             if (LOG.isDebugEnabled()) {
                 LOG.debug("Found a registration {} for candidate: {} with qualifier: {}", beanRegistration, candidate, qualifier);
             }
@@ -3890,10 +3905,12 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
      * @param <R>
      */
     private static final class BeanExecutionHandle<T, R> extends AbstractExecutionHandle<T, R> {
-        private final BeanContext beanContext;
+        private final DefaultBeanContext beanContext;
         private final Class<T> beanType;
+        private final Argument<T> beanArgument;
         private final Qualifier<T> qualifier;
         private final boolean isSingleton;
+        private final BeanDefinition<T> definition;
 
         private T target;
 
@@ -3903,12 +3920,14 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
          * @param qualifier   The qualifier
          * @param method      The method
          */
-        BeanExecutionHandle(BeanContext beanContext, Class<T> beanType, Qualifier<T> qualifier, ExecutableMethod<T, R> method) {
+        BeanExecutionHandle(DefaultBeanContext beanContext, BeanDefinition<T> definition, Class<T> beanType, Qualifier<T> qualifier, ExecutableMethod<T, R> method) {
             super(method);
             this.beanContext = beanContext;
             this.beanType = beanType;
+            this.beanArgument = Argument.of(beanType);
             this.qualifier = qualifier;
-            this.isSingleton = beanContext.findBeanDefinition(beanType, qualifier).map(BeanDefinition::isSingleton).orElse(false);
+            this.isSingleton = definition.isSingleton();
+            this.definition = definition;
         }
 
         @Override
@@ -3918,8 +3937,10 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                 synchronized (this) { // double check
                     target = this.target;
                     if (target == null) {
-                        target = beanContext.getBean(beanType, qualifier);
-                        this.target = target;
+                        try (BeanResolutionContext resolutionContext = beanContext.newResolutionContext(definition, null)) {
+                            target = beanContext.getBean(resolutionContext, beanArgument, qualifier);
+                            this.target = target;
+                        }
                     }
                 }
             }
@@ -4107,12 +4128,14 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
     private final class EventListenerListenersSupplier<T extends EventListener> implements ListenersSupplier<T> {
 
         private final List<BeanDefinition<T>> listenersDefinitions;
+        private final Argument<?> eventType;
         // The supplier can be triggered concurrently.
         // We allow for the listeners collection to be initialized multiple times.
         @SuppressWarnings("java:S3077")
         private volatile List<T> listeners;
 
-        public EventListenerListenersSupplier(List<BeanDefinition<T>> listenersDefinitions) {
+        EventListenerListenersSupplier(Argument<?> eventType, List<BeanDefinition<T>> listenersDefinitions) {
+            this.eventType = eventType;
             this.listenersDefinitions = listenersDefinitions;
         }
 
@@ -4124,10 +4147,20 @@ public class DefaultBeanContext implements InitializableBeanContext, Configurabl
                     T listener;
                     if (beanResolutionContext == null) {
                         try (BeanResolutionContext context = newResolutionContext(listenersDefinition, null)) {
-                            listener = resolveBeanRegistration(context, listenersDefinition).bean;
+                            try (BeanResolutionContext.Path ignored = context.getPath().pushEventListenerResolve(
+                                listenersDefinition,
+                                eventType
+                            )) {
+                                listener = resolveBeanRegistration(context, listenersDefinition).bean;
+                            }
                         }
                     } else {
-                        listener = resolveBeanRegistration(beanResolutionContext, listenersDefinition).bean;
+                        try (BeanResolutionContext.Path ignored = beanResolutionContext.getPath().pushEventListenerResolve(
+                            listenersDefinition,
+                            eventType
+                        )) {
+                            listener = resolveBeanRegistration(beanResolutionContext, listenersDefinition).bean;
+                        }
                     }
                     listeners.add(listener);
                 }
diff --git a/inject/src/main/java/io/micronaut/context/DefaultFieldConstructorInjectionPoint.java b/inject/src/main/java/io/micronaut/context/DefaultFieldConstructorInjectionPoint.java
index ee2a9b0169..fe137b45d5 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultFieldConstructorInjectionPoint.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultFieldConstructorInjectionPoint.java
@@ -53,4 +53,8 @@ final class DefaultFieldConstructorInjectionPoint<T> extends DefaultFieldInjecti
         return Argument.ZERO_ARGUMENTS;
     }
 
+    @Override
+    public Class<T> getDeclaringBeanType() {
+        return (Class<T>) declaringType;
+    }
 }
diff --git a/inject/src/main/java/io/micronaut/context/DefaultFieldInjectionPoint.java b/inject/src/main/java/io/micronaut/context/DefaultFieldInjectionPoint.java
index 8da059df49..82b775252b 100644
--- a/inject/src/main/java/io/micronaut/context/DefaultFieldInjectionPoint.java
+++ b/inject/src/main/java/io/micronaut/context/DefaultFieldInjectionPoint.java
@@ -45,7 +45,7 @@ import java.util.Objects;
 class DefaultFieldInjectionPoint<B, T> implements FieldInjectionPoint<B, T>, EnvironmentConfigurable {
 
     private final BeanDefinition declaringBean;
-    private final Class declaringType;
+    protected final Class declaringType;
     private final Class<T> fieldType;
     private final String field;
     private final AnnotationMetadata annotationMetadata;
diff --git a/inject/src/main/java/io/micronaut/context/env/AbstractPropertySourceLoader.java b/inject/src/main/java/io/micronaut/context/env/AbstractPropertySourceLoader.java
index aabc83483f..b816830729 100644
--- a/inject/src/main/java/io/micronaut/context/env/AbstractPropertySourceLoader.java
+++ b/inject/src/main/java/io/micronaut/context/env/AbstractPropertySourceLoader.java
@@ -77,7 +77,9 @@ public abstract class AbstractPropertySourceLoader implements PropertySourceLoad
                 Map<String, Object> finalMap = loadProperties(resourceLoader, fileName, fileExt);
 
                 if (!finalMap.isEmpty()) {
-                    return Optional.of(createPropertySource(fileName, finalMap, order));
+                    return Optional.of(
+                        createPropertySource(fileName, finalMap, order, PropertySource.Origin.of(fileExt))
+                    );
                 }
             }
         }
@@ -92,6 +94,30 @@ public abstract class AbstractPropertySourceLoader implements PropertySourceLoad
      * @param order The order of the property source
      * @return property source
      */
+    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order, PropertySource.Origin origin) {
+        return new MapPropertySource(name, map) {
+            @Override
+            public int getOrder() {
+                return order;
+            }
+
+            @Override
+            public Origin getOrigin() {
+                return origin != null ? origin : super.getOrigin();
+            }
+        };
+    }
+
+
+    /**
+     *
+     * @param name The name of the property source
+     * @param map  The map
+     * @param order The order of the property source
+     * @return property source
+     * @deprecated Use {@link #createPropertySource(String, Map, int, PropertySource.Origin)}
+     */
+    @Deprecated(forRemoval = true)
     protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order) {
         return new MapPropertySource(name, map) {
                             @Override
diff --git a/inject/src/main/java/io/micronaut/context/env/CommandLinePropertySource.java b/inject/src/main/java/io/micronaut/context/env/CommandLinePropertySource.java
index 6d61220651..ea63996433 100644
--- a/inject/src/main/java/io/micronaut/context/env/CommandLinePropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/CommandLinePropertySource.java
@@ -47,6 +47,11 @@ public class CommandLinePropertySource extends MapPropertySource {
         super(NAME, resolveValues(commandLine));
     }
 
+    @Override
+    public Origin getOrigin() {
+        return Origin.of("main(String...args)");
+    }
+
     @Override
     public int getOrder() {
         return POSITION;
diff --git a/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java b/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java
index 74340ecaaa..496608ce85 100644
--- a/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java
+++ b/inject/src/main/java/io/micronaut/context/env/DefaultEnvironment.java
@@ -36,6 +36,7 @@ import io.micronaut.core.order.OrderUtil;
 import io.micronaut.core.reflect.ClassUtils;
 import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.core.util.StringUtils;
+import io.micronaut.core.value.PropertyCatalog;
 import io.micronaut.inject.BeanConfiguration;
 
 import java.io.BufferedReader;
@@ -300,7 +301,7 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
 
     @Override
     public Map<String, Object> refreshAndDiff() {
-        Map<String, Object>[] copiedCatalog = copyCatalog();
+        Map<String, DefaultPropertyEntry>[] copiedCatalog = copyCatalog();
         refresh();
         return diffCatalog(copiedCatalog, catalog);
     }
@@ -597,6 +598,20 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         return SoftServiceLoader.load(PropertySourceLoader.class, getClassLoader());
     }
 
+    @Override
+    public Optional<PropertyEntry> getPropertyEntry(String name) {
+        for (PropertyCatalog propertyCatalog : PropertyCatalog.values()) {
+            Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, propertyCatalog);
+            if (entries != null) {
+                DefaultPropertyEntry entry = entries.get(name);
+                if (entry != null) {
+                    return Optional.of(entry);
+                }
+            }
+        }
+        return Optional.empty();
+    }
+
     /**
      * Obtains the {@link PropertySourceLoader} instances.
      *
@@ -830,11 +845,11 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         }
     }
 
-    private Map<String, Object> diffCatalog(Map<String, Object>[] original, Map<String, Object>[] newCatalog) {
+    private Map<String, Object> diffCatalog(Map<String, DefaultPropertyEntry>[] original, Map<String, DefaultPropertyEntry>[] newCatalog) {
         Map<String, Object> changes = new LinkedHashMap<>();
         for (int i = 0; i < original.length; i++) {
-            Map<String, Object> map = original[i];
-            Map<String, Object> newMap = newCatalog[i];
+            Map<String, DefaultPropertyEntry> map = original[i];
+            Map<String, DefaultPropertyEntry> newMap = newCatalog[i];
             boolean hasNew = newMap != null;
             boolean hasOld = map != null;
             if (!hasOld && hasNew) {
@@ -849,13 +864,14 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         }
         if (!changes.isEmpty()) {
             Map<String, Object> placeholdersAltered = new LinkedHashMap<>();
-            for (Map<String, Object> map : newCatalog) {
+            for (Map<String, DefaultPropertyEntry> map :
+                newCatalog) {
                 if (map != null) {
                     map.forEach((key, v) -> {
-                        if (v instanceof String val) {
+                        if (v.value() instanceof String val) {
                             for (String changed : changes.keySet()) {
                                 if (val.contains(changed)) {
-                                    placeholdersAltered.put(key, v);
+                                    placeholdersAltered.put(key, v.value());
                                 }
                             }
                         }
@@ -867,14 +883,14 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         return changes;
     }
 
-    private void diffMap(Map<String, Object> map, Map<String, Object> newMap, Map<String, Object> changes) {
-        for (Map.Entry<String, Object> entry : newMap.entrySet()) {
+    private void diffMap(Map<String, DefaultPropertyEntry> map, Map<String, DefaultPropertyEntry> newMap, Map<String, Object> changes) {
+        for (Map.Entry<String, DefaultPropertyEntry> entry : newMap.entrySet()) {
             String key = entry.getKey();
-            Object newValue = entry.getValue();
+            Object newValue = entry.getValue().value();
             if (!map.containsKey(key)) {
                 changes.put(key, newValue);
             } else {
-                Object oldValue = map.get(key);
+                Object oldValue = map.getOrDefault(key, PropertySourcePropertyResolver.NULL_ENTRY).value();
                 boolean hasNew = newValue != null;
                 boolean hasOld = oldValue != null;
                 if (hasNew && !hasOld) {
@@ -892,10 +908,10 @@ public class DefaultEnvironment extends PropertySourcePropertyResolver implement
         return !Objects.deepEquals(newValue, oldValue);
     }
 
-    private Map<String, Object>[] copyCatalog() {
-        Map<String, Object>[] newCatalog = new Map[catalog.length];
+    private Map<String, DefaultPropertyEntry>[] copyCatalog() {
+        Map<String, DefaultPropertyEntry>[] newCatalog = new Map[catalog.length];
         for (int i = 0; i < catalog.length; i++) {
-            Map<String, Object> entry = catalog[i];
+            Map<String, DefaultPropertyEntry> entry = catalog[i];
             if (entry != null) {
                 newCatalog[i] = new LinkedHashMap<>(entry);
             }
diff --git a/inject/src/main/java/io/micronaut/context/env/DefaultOrigin.java b/inject/src/main/java/io/micronaut/context/env/DefaultOrigin.java
new file mode 100644
index 0000000000..dd4cedfc33
--- /dev/null
+++ b/inject/src/main/java/io/micronaut/context/env/DefaultOrigin.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright 2017-2025 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.context.env;
+
+/**
+ * Default implementation of {@link io.micronaut.context.env.PropertySource.Origin}.
+ *
+ * @since 4.8.0
+ * @param location The location
+ */
+record DefaultOrigin(String location) implements PropertySource.Origin {
+}
diff --git a/inject/src/main/java/io/micronaut/context/env/DefaultPropertyEntry.java b/inject/src/main/java/io/micronaut/context/env/DefaultPropertyEntry.java
new file mode 100644
index 0000000000..9b2284ede5
--- /dev/null
+++ b/inject/src/main/java/io/micronaut/context/env/DefaultPropertyEntry.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2017-2025 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.context.env;
+
+import io.micronaut.core.annotation.Experimental;
+
+/**
+ * A property entry models
+ *
+ * @param property The normalized property key
+ * @param value    The property value
+ * @param raw      The raw property key that originated the property
+ * @param origin
+ */
+@Experimental
+record DefaultPropertyEntry(
+    String property,
+    Object value,
+    String raw,
+    PropertySource.Origin origin
+) implements PropertyEntry {
+}
diff --git a/inject/src/main/java/io/micronaut/context/env/Environment.java b/inject/src/main/java/io/micronaut/context/env/Environment.java
index bfdff21e43..b47e6e617e 100644
--- a/inject/src/main/java/io/micronaut/context/env/Environment.java
+++ b/inject/src/main/java/io/micronaut/context/env/Environment.java
@@ -16,6 +16,8 @@
 package io.micronaut.context.env;
 
 import io.micronaut.context.LifeCycle;
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.convert.MutableConversionService;
 import io.micronaut.core.io.ResourceLoader;
@@ -30,6 +32,7 @@ import java.lang.annotation.Annotation;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 import java.util.stream.Stream;
 
@@ -284,7 +287,9 @@ public interface Environment extends PropertyResolver, LifeCycle<Environment>, M
      * @param name   The name
      * @param values The values
      * @return This environment
+     * @deprecated Use {@link #addPropertySource(PropertySource)}
      */
+    @Deprecated(forRemoval = true, since = "4.8.0")
     default Environment addPropertySource(String name, @Nullable Map<String, ? super Object> values) {
         if (StringUtils.isNotEmpty(name) && CollectionUtils.isNotEmpty(values)) {
             return addPropertySource(PropertySource.of(name, values));
@@ -359,4 +364,16 @@ public interface Environment extends PropertyResolver, LifeCycle<Environment>, M
      * @return A collection of {@link PropertySourceLoader}
      */
     Collection<PropertySourceLoader> getPropertySourceLoaders();
+
+    /**
+     * Resolve information about a property.
+     *
+     * @param name The property name
+     * @return The entry.
+     * @since 4.8.0
+     */
+    @Experimental
+    default Optional<PropertyEntry> getPropertyEntry(@NonNull String name) {
+        return Optional.empty();
+    }
 }
diff --git a/inject/src/main/java/io/micronaut/context/env/EnvironmentPropertySource.java b/inject/src/main/java/io/micronaut/context/env/EnvironmentPropertySource.java
index c39c02de88..6f5464a4ee 100644
--- a/inject/src/main/java/io/micronaut/context/env/EnvironmentPropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/EnvironmentPropertySource.java
@@ -38,6 +38,7 @@ public class EnvironmentPropertySource extends MapPropertySource {
      * Constant for Environment property source.
      */
     public static final String NAME = "env";
+    public static final Origin ORIGIN = Origin.of("System.env");
 
     /**
      * Default constructor.
@@ -61,6 +62,11 @@ public class EnvironmentPropertySource extends MapPropertySource {
         return POSITION;
     }
 
+    @Override
+    public Origin getOrigin() {
+        return ORIGIN;
+    }
+
     @Override
     public PropertyConvention getConvention() {
         return PropertyConvention.ENVIRONMENT_VARIABLE;
diff --git a/inject/src/main/java/io/micronaut/context/env/KubernetesEnvironmentPropertySource.java b/inject/src/main/java/io/micronaut/context/env/KubernetesEnvironmentPropertySource.java
index e4314f44e3..9735bdc01f 100644
--- a/inject/src/main/java/io/micronaut/context/env/KubernetesEnvironmentPropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/KubernetesEnvironmentPropertySource.java
@@ -71,6 +71,11 @@ public class KubernetesEnvironmentPropertySource extends MapPropertySource {
         super(NAME, getEnv(getEnvNoK8s(), includes, excludes));
     }
 
+    @Override
+    public Origin getOrigin() {
+        return EnvironmentPropertySource.ORIGIN;
+    }
+
     @Override
     public int getOrder() {
         return EnvironmentPropertySource.POSITION;
diff --git a/inject/src/main/java/io/micronaut/context/env/PropertyEntry.java b/inject/src/main/java/io/micronaut/context/env/PropertyEntry.java
new file mode 100644
index 0000000000..029cae264b
--- /dev/null
+++ b/inject/src/main/java/io/micronaut/context/env/PropertyEntry.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2017-2025 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.context.env;
+
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.NonNull;
+
+/**
+ * A property entry models a configuration property registration within a
+ * particular
+ *
+ * @since 4.8.0
+ */
+@Experimental
+public interface PropertyEntry {
+
+    /**
+     * @return The name of the property.
+     */
+    @NonNull
+    String property();
+
+    /**
+     * @return The value of the property.
+     */
+    @NonNull
+    Object value();
+
+    /**
+     * @return The raw name of the property prior to normalization.
+     */
+    @NonNull
+    String raw();
+
+    /**
+     * @return The origin of the property.
+     */
+    @NonNull
+    PropertySource.Origin origin();
+}
diff --git a/inject/src/main/java/io/micronaut/context/env/PropertySource.java b/inject/src/main/java/io/micronaut/context/env/PropertySource.java
index 3d49dc3b2d..2c8e6cacf5 100644
--- a/inject/src/main/java/io/micronaut/context/env/PropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/PropertySource.java
@@ -15,10 +15,13 @@
  */
 package io.micronaut.context.env;
 
+import io.micronaut.core.annotation.Experimental;
+import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.order.Ordered;
 
 import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.Objects;
 
 /**
  * A PropertySource is a location to resolve property values from. The property keys are available via the
@@ -47,6 +50,14 @@ public interface PropertySource extends Iterable<String>, Ordered {
      */
     Object get(String key);
 
+    /**
+     * @return The origin of the property source.
+     * @since 4.8.0
+     */
+    default @NonNull Origin getOrigin() {
+        return Origin.of(getName());
+    }
+
     /**
      * @return Whether the property source has upper case underscore separated keys
      */
@@ -65,6 +76,23 @@ public interface PropertySource extends Iterable<String>, Ordered {
         return new MapPropertySource(name, map);
     }
 
+    /**
+     * Create a {@link PropertySource} from the given map.
+     *
+     * @param name The name of the property source
+     * @param map  The map
+     * @param origin The origin
+     * @return The {@link PropertySource}
+     */
+    static PropertySource of(String name, Map<String, Object> map, Origin origin) {
+        return new MapPropertySource(name, map) {
+            @Override
+            public Origin getOrigin() {
+                return origin != null ? origin : super.getOrigin();
+            }
+        };
+    }
+
     /**
      * Create a {@link PropertySource} from the given map.
      *
@@ -72,8 +100,13 @@ public interface PropertySource extends Iterable<String>, Ordered {
      * @param map        The map
      * @param convention The convention type of the property source
      * @return The {@link PropertySource}
+     * @deprecated Use {@link #of(String, Map, PropertyConvention, Origin)}
      */
-    static PropertySource of(String name, Map<String, Object> map, PropertyConvention convention) {
+    @Deprecated(forRemoval = true, since = "4.8.0")
+    static PropertySource of(
+        String name,
+        Map<String, Object> map,
+        PropertyConvention convention) {
         return new MapPropertySource(name, map) {
             @Override
             public PropertyConvention getConvention() {
@@ -82,6 +115,33 @@ public interface PropertySource extends Iterable<String>, Ordered {
         };
     }
 
+    /**
+     * Create a {@link PropertySource} from the given map.
+     *
+     * @param name       The name of the property source
+     * @param map        The map
+     * @param convention The convention type of the property source
+     * @param origin     The origin
+     * @return The {@link PropertySource}
+     */
+    static PropertySource of(
+        String name,
+        Map<String, Object> map,
+        PropertyConvention convention,
+        Origin origin) {
+        return new MapPropertySource(name, map) {
+            @Override
+            public PropertyConvention getConvention() {
+                return convention;
+            }
+
+            @Override
+            public Origin getOrigin() {
+                return origin != null ? origin : super.getOrigin();
+            }
+        };
+    }
+
     /**
      * Create a {@link PropertySource} from the given map.
      *
@@ -89,7 +149,9 @@ public interface PropertySource extends Iterable<String>, Ordered {
      * @param values The values as an array of alternating key/value entries
      * @return The {@link PropertySource}
      * @since 2.0
+     * @deprecated Use {@link #of(String, Map, Origin)}
      */
+    @Deprecated(forRemoval = true)
     static PropertySource of(String name, Object... values) {
         return new MapPropertySource(name, mapOf(values));
     }
@@ -135,6 +197,30 @@ public interface PropertySource extends Iterable<String>, Ordered {
         };
     }
 
+    /**
+     * Create a {@link PropertySource} from the given map.
+     *
+     * @param name     The name of the property source
+     * @param map      The map
+     * @param origin   The origin
+     * @param priority The priority to order by
+     * @return The {@link PropertySource}
+     * @since 4.8.0
+     */
+    static PropertySource of(String name, Map<String, Object> map, Origin origin, int priority) {
+        return new MapPropertySource(name, map) {
+            @Override
+            public int getOrder() {
+                return priority;
+            }
+
+            @Override
+            public Origin getOrigin() {
+                return origin != null ? origin : super.getOrigin();
+            }
+        };
+    }
+
     /**
      * Create a {@link PropertySource} named {@link Environment#DEFAULT_NAME} from the given map.
      *
@@ -160,4 +246,26 @@ public interface PropertySource extends Iterable<String>, Ordered {
          */
         JAVA_PROPERTIES
     }
+
+    /**
+     * The origin of the property source.
+     * @since 4.8.0
+     */
+    @Experimental
+    sealed interface Origin permits DefaultOrigin {
+        /**
+         * @return The location.
+         */
+        String location();
+
+        /**
+         * Create an origin from a location.
+         * @param location The location
+         * @return The origin
+         */
+        static @NonNull Origin of(@NonNull String location) {
+            Objects.requireNonNull(location, "Location cannot be null");
+            return new DefaultOrigin(location);
+        }
+    }
 }
diff --git a/inject/src/main/java/io/micronaut/context/env/PropertySourcePropertyResolver.java b/inject/src/main/java/io/micronaut/context/env/PropertySourcePropertyResolver.java
index 88f917ba9e..c477887455 100644
--- a/inject/src/main/java/io/micronaut/context/env/PropertySourcePropertyResolver.java
+++ b/inject/src/main/java/io/micronaut/context/env/PropertySourcePropertyResolver.java
@@ -31,6 +31,7 @@ import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.core.util.EnvironmentProperties;
 import io.micronaut.core.util.StringUtils;
 import io.micronaut.core.value.MapPropertyResolver;
+import io.micronaut.core.value.PropertyCatalog;
 import io.micronaut.core.value.PropertyResolver;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -63,6 +64,9 @@ import java.util.regex.Pattern;
  */
 public class PropertySourcePropertyResolver implements PropertyResolver, AutoCloseable {
 
+    public static final DefaultPropertyEntry NULL_ENTRY = new DefaultPropertyEntry(
+        "NULL", null, null, null
+    );
     private static final EnvironmentProperties CURRENT_ENV = StaticOptimizations.get(EnvironmentProperties.class)
             .orElseGet(EnvironmentProperties::empty);
     private static final Pattern DOT_PATTERN = Pattern.compile("\\.");
@@ -76,9 +80,9 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
     // properties are stored in an array of maps organized by character in the alphabet
     // this allows optimization of searches by prefix
     @SuppressWarnings("MagicNumber")
-    protected final Map<String, Object>[] catalog = new Map[58];
-    protected final Map<String, Object>[] rawCatalog = new Map[58];
-    protected final Map<String, Object>[] nonGenerated = new Map[58];
+    protected final Map<String, DefaultPropertyEntry>[] catalog = new Map[58];
+    protected final Map<String, DefaultPropertyEntry>[] rawCatalog = new Map[58];
+    protected final Map<String, DefaultPropertyEntry>[] nonGenerated = new Map[58];
 
     protected Logger log;
 
@@ -171,7 +175,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         Boolean result = containsCache.get(name);
         if (result == null) {
             for (PropertyCatalog convention : CONVENTIONS) {
-                Map<String, Object> entries = resolveEntriesForKey(name, false, convention);
+                Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, convention);
                 if (entries != null) {
                     if (entries.containsKey(name)) {
                         result = true;
@@ -193,7 +197,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
             return false;
         }
         for (PropertyCatalog propertyCatalog : CONVENTIONS) {
-            Map<String, Object> entries = resolveEntriesForKey(name, false, propertyCatalog);
+            Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, propertyCatalog);
             if (entries != null) {
                 if (entries.containsKey(name)) {
                     return true;
@@ -222,7 +226,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         if (StringUtils.isEmpty(name)) {
             return Collections.emptySet();
         }
-        Map<String, Object> entries = resolveEntriesForKey(name, false, PropertyCatalog.valueOf(propertyCatalog.name()));
+        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, PropertyCatalog.valueOf(propertyCatalog.name()));
         if (entries == null) {
             return Collections.emptySet();
         }
@@ -250,7 +254,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         if (StringUtils.isEmpty(pathPattern)) {
             return Collections.emptySet();
         }
-        Map<String, Object> entries = resolveEntriesForKey(pathPattern, false, null);
+        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(pathPattern, false, null);
         if (entries == null) {
             return Collections.emptySet();
         }
@@ -291,7 +295,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         if (StringUtils.isEmpty(name)) {
             return Collections.emptyMap();
         }
-        Map<String, Object> entries = resolveEntriesForKey(name, false, keyFormat == StringConvention.RAW ? PropertyCatalog.RAW : PropertyCatalog.GENERATED);
+        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(name, false, keyFormat == StringConvention.RAW ? PropertyCatalog.RAW : PropertyCatalog.GENERATED);
         if (entries != null) {
             if (keyFormat == null) {
                 keyFormat = StringConvention.RAW;
@@ -336,7 +340,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         }
         Object value = placeholderResolutionCache.get(name);
         // entries map to get the value from, only populated if there's a cache miss with placeholderResolutionCache
-        Map<String, Object> entries = null;
+        Map<String, DefaultPropertyEntry> entries = null;
         if (value == null) {
             entries = resolveEntriesForKey(name, false, PropertyCatalog.GENERATED);
             if (entries == null) {
@@ -345,14 +349,14 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         }
         if (entries != null || value != null) {
             if (value == null) {
-                value = entries.get(name);
+                value = entries.getOrDefault(name, NULL_ENTRY).value();
             }
             if (value == null) {
-                value = entries.get(normalizeName(name));
+                value = entries.getOrDefault(normalizeName(name), NULL_ENTRY).value();
                 if (value == null && name.indexOf('[') == -1) {
                     // last chance lookup the raw value
-                    Map<String, Object> rawEntries = resolveEntriesForKey(name, false, PropertyCatalog.RAW);
-                    value = rawEntries != null ? rawEntries.get(name) : null;
+                    Map<String, DefaultPropertyEntry> rawEntries = resolveEntriesForKey(name, false, PropertyCatalog.RAW);
+                    value = rawEntries != null ? rawEntries.getOrDefault(name, NULL_ENTRY).value() : null;
                     if (value != null) {
                         entries = rawEntries;
                     }
@@ -362,7 +366,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
                 int i = name.indexOf('[');
                 if (i > -1 && name.endsWith("]")) {
                     String newKey = name.substring(0, i);
-                    value = entries.get(newKey);
+                    value = entries.getOrDefault(newKey, NULL_ENTRY).value();
                     String index = name.substring(i + 1, name.length() - 1);
                     if (StringUtils.isNotEmpty(index)) {
                         if (value != null) {
@@ -381,7 +385,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
                             }
                         } else {
                             String subKey = newKey + '.' + index;
-                            value = entries.get(subKey);
+                            value = entries.getOrDefault(subKey, NULL_ENTRY).value();
                         }
                     }
                 }
@@ -456,9 +460,9 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
             .filter(Objects::nonNull)
             .map(Map::entrySet)
             .flatMap(Collection::stream)
-            .forEach((Map.Entry<String, Object> entry) -> {
+            .forEach((Map.Entry<String, DefaultPropertyEntry> entry) -> {
                 String k = keyConvention.format(entry.getKey());
-                Object value = resolvePlaceHoldersIfNecessary(entry.getValue());
+                Object value = resolvePlaceHoldersIfNecessary(entry.getValue().value());
                 Map finalMap = map;
                 int index = k.indexOf('.');
                 if (index != -1 && isNested) {
@@ -487,7 +491,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
      * @param conversionContext The conversion context
      * @return The subproperties
      */
-    protected Properties resolveSubProperties(String name, Map<String, Object> entries, ArgumentConversionContext<?> conversionContext) {
+    protected Properties resolveSubProperties(String name, Map<String, DefaultPropertyEntry> entries, ArgumentConversionContext<?> conversionContext) {
         // special handling for maps for resolving sub keys
         Properties properties = new Properties();
         AnnotationMetadata annotationMetadata = conversionContext.getAnnotationMetadata();
@@ -500,7 +504,8 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         entries.entrySet().stream()
             .filter(map -> map.getKey().startsWith(prefix))
             .forEach(entry -> {
-                Object value = entry.getValue();
+                DefaultPropertyEntry propertyEntry = entry.getValue();
+                Object value = propertyEntry.value();
                 if (value != null) {
                     String key = entry.getKey().substring(prefix.length());
                     key = keyConvention != null ? keyConvention.format(key) : key;
@@ -517,7 +522,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
      * @param conversionContext The conversion context
      * @return The submap
      */
-    protected Map<String, Object> resolveSubMap(String name, Map<String, Object> entries, ArgumentConversionContext<?> conversionContext) {
+    protected Map<String, Object> resolveSubMap(String name, Map<String, DefaultPropertyEntry> entries, ArgumentConversionContext<?> conversionContext) {
         // special handling for maps for resolving sub keys
         AnnotationMetadata annotationMetadata = conversionContext.getAnnotationMetadata();
         StringConvention keyConvention = annotationMetadata.enumValue(MapFormat.class, "keyFormat", StringConvention.class).orElse(null);
@@ -545,7 +550,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
     @NonNull
     protected Map<String, Object> resolveSubMap(
             String name,
-            Map<String, Object> entries,
+            Map<String, DefaultPropertyEntry> entries,
             ArgumentConversionContext<?> conversionContext,
             @Nullable StringConvention keyConvention,
             MapFormat.MapTransformation transformation) {
@@ -554,7 +559,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         Map<String, Object> subMap = CollectionUtils.newLinkedHashMap(entries.size());
 
         String prefix = name + '.';
-        for (Map.Entry<String, Object> entry : entries.entrySet()) {
+        for (Map.Entry<String, DefaultPropertyEntry> entry : entries.entrySet()) {
             final String key = entry.getKey();
 
             if (valueTypeIsList && key.contains("[") && key.endsWith("]")) {
@@ -564,7 +569,7 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
             if (key.startsWith(prefix)) {
                 String subMapKey = key.substring(prefix.length());
 
-                Object value = resolvePlaceHoldersIfNecessary(entry.getValue());
+                Object value = resolvePlaceHoldersIfNecessary(entry.getValue().value());
 
                 if (transformation == MapFormat.MapTransformation.FLAT) {
                     subMapKey = keyConvention != null ? keyConvention.format(subMapKey) : subMapKey;
@@ -603,39 +608,74 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
                     int i = resolvedProperty.indexOf('[');
                     if (i > -1) {
                         String propertyName = resolvedProperty.substring(0, i);
-                        Map<String, Object> entries = resolveEntriesForKey(propertyName, true, PropertyCatalog.GENERATED);
+                        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(propertyName, true, PropertyCatalog.GENERATED);
                         if (entries != null) {
-                            entries.put(resolvedProperty, value);
-                            expandProperty(resolvedProperty.substring(i), val -> entries.put(propertyName, val), () -> entries.get(propertyName), value);
+                            entries.put(resolvedProperty, new DefaultPropertyEntry(
+                                resolvedProperty,
+                                value,
+                                property,
+                                properties.getOrigin()
+                            ));
+                            expandProperty(
+                                resolvedProperty.substring(i),
+                                val -> entries.put(propertyName, new DefaultPropertyEntry(
+                                    propertyName,
+                                    val,
+                                    property,
+                                    properties.getOrigin()
+                                )),
+                                () -> entries.getOrDefault(propertyName, NULL_ENTRY).value(),
+                                value
+                            );
                         }
                         if (first) {
-                            Map<String, Object> normalized = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.NORMALIZED);
+                            Map<String, DefaultPropertyEntry> normalized = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.NORMALIZED);
                             if (normalized != null) {
-                                normalized.put(propertyName, value);
+                                normalized.put(propertyName, new DefaultPropertyEntry(
+                                    propertyName,
+                                    value,
+                                    property,
+                                    properties.getOrigin()
+                                ));
                             }
                             first = false;
                         }
                     } else {
-                        Map<String, Object> entries = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.GENERATED);
+                        Map<String, DefaultPropertyEntry> entries = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.GENERATED);
                         if (entries != null) {
                             if (value instanceof List || value instanceof Map) {
-                                collapseProperty(resolvedProperty, entries, value);
+                                collapseProperty(property, resolvedProperty, entries, value, properties.getOrigin());
                             }
-                            entries.put(resolvedProperty, value);
+                            entries.put(resolvedProperty, new DefaultPropertyEntry(
+                                resolvedProperty,
+                                value,
+                                property,
+                                properties.getOrigin()
+                            ));
                         }
                         if (first) {
-                            Map<String, Object> normalized = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.NORMALIZED);
+                            Map<String, DefaultPropertyEntry> normalized = resolveEntriesForKey(resolvedProperty, true, PropertyCatalog.NORMALIZED);
                             if (normalized != null) {
-                                normalized.put(resolvedProperty, value);
+                                normalized.put(resolvedProperty, new DefaultPropertyEntry(
+                                    resolvedProperty,
+                                    value,
+                                    property,
+                                    properties.getOrigin()
+                                ));
                             }
                             first = false;
                         }
                     }
                 }
 
-                final Map<String, Object> rawEntries = resolveEntriesForKey(property, true, PropertyCatalog.RAW);
+                final Map<String, DefaultPropertyEntry> rawEntries = resolveEntriesForKey(property, true, PropertyCatalog.RAW);
                 if (rawEntries != null) {
-                    rawEntries.put(property, value);
+                    rawEntries.put(property, new DefaultPropertyEntry(
+                        property,
+                        value,
+                        property,
+                        properties.getOrigin()
+                    ));
                 }
             }
         }
@@ -697,24 +737,39 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         }
     }
 
-    private void collapseProperty(String prefix, Map<String, Object> entries, Object value) {
+    private void collapseProperty(
+        String originalProperty,
+        String prefix,
+        Map<String, DefaultPropertyEntry> entries,
+        Object value,
+        PropertySource.Origin origin) {
         if (value instanceof List<?> list) {
             for (int i = 0; i < list.size(); i++) {
                 Object item = list.get(i);
                 if (item != null) {
-                    collapseProperty(prefix + "[" + i + "]", entries, item);
+                    collapseProperty(originalProperty, prefix + "[" + i + "]", entries, item, origin);
                 }
             }
-            entries.put(prefix, value);
+            entries.put(prefix, new DefaultPropertyEntry(
+                prefix,
+                value,
+                originalProperty,
+                origin
+            ));
         } else if (value instanceof Map<?, ?> map) {
             for (Map.Entry<?, ?> entry: map.entrySet()) {
                 Object key = entry.getKey();
                 if (key instanceof CharSequence charSequence) {
-                    collapseProperty(prefix + "." + charSequence, entries, entry.getValue());
+                    collapseProperty(originalProperty, prefix + "." + charSequence, entries, entry.getValue(), origin);
                 }
             }
         } else {
-            entries.put(prefix, value);
+            entries.put(prefix, new DefaultPropertyEntry(
+                prefix,
+                value,
+                originalProperty,
+                origin
+            ));
         }
     }
 
@@ -725,13 +780,13 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
      * @return The map with the resolved entries for the name
      */
     @SuppressWarnings("MagicNumber")
-    protected Map<String, Object> resolveEntriesForKey(String name, boolean allowCreate, @Nullable PropertyCatalog propertyCatalog) {
+    protected Map<String, DefaultPropertyEntry> resolveEntriesForKey(String name, boolean allowCreate, @Nullable PropertyCatalog propertyCatalog) {
         if (name.isEmpty()) {
             return null;
         }
-        final Map<String, Object>[] catalog = getCatalog(propertyCatalog);
+        final Map<String, DefaultPropertyEntry>[] catalog = getCatalog(propertyCatalog);
 
-        Map<String, Object> entries = null;
+        Map<String, DefaultPropertyEntry> entries = null;
         char firstChar = name.charAt(0);
         if (Character.isLetter(firstChar)) {
             int index = firstChar - 65;
@@ -746,7 +801,12 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         return entries;
     }
 
-    private Map<String, Object>[] getCatalog(@Nullable PropertyCatalog propertyCatalog) {
+    /**
+     * Obtain a property catalog.
+     * @param propertyCatalog The catalog
+     * @return The catalog
+     */
+    private Map<String, DefaultPropertyEntry>[] getCatalog(@Nullable PropertyCatalog propertyCatalog) {
         propertyCatalog = propertyCatalog != null ? propertyCatalog : PropertyCatalog.GENERATED;
         return switch (propertyCatalog) {
             case RAW -> this.rawCatalog;
@@ -841,31 +901,6 @@ public class PropertySourcePropertyResolver implements PropertyResolver, AutoClo
         }
     }
 
-    /**
-     * The property catalog to use.
-     *
-     * @deprecated Replaced by {@link io.micronaut.core.value.PropertyCatalog}
-     */
-    @Deprecated(forRemoval = true)
-    protected enum PropertyCatalog {
-        /**
-         * The catalog that contains the raw keys.
-         */
-        RAW,
-        /**
-         * The catalog that contains normalized keys. A key is normalized into
-         * lower case hyphen separated form. For example an environment variable {@code FOO_BAR} would be
-         * normalized to {@code foo.bar}.
-         */
-        NORMALIZED,
-        /**
-         * The catalog that contains normalized keys and also generated keys. A synthetic key can be generated from
-         * an environment variable such as {@code FOO_BAR_BAZ} which will produce the following keys: {@code foo.bar.baz},
-         * {@code foo.bar-baz}, and {@code foo-bar.baz}.
-         */
-        GENERATED
-    }
-
     private record ConversionCacheKey(@NonNull String name, Class<?> requiredType) {
 
         @Override
diff --git a/inject/src/main/java/io/micronaut/context/env/SystemPropertiesPropertySource.java b/inject/src/main/java/io/micronaut/context/env/SystemPropertiesPropertySource.java
index 105eaa1468..a3095438c7 100644
--- a/inject/src/main/java/io/micronaut/context/env/SystemPropertiesPropertySource.java
+++ b/inject/src/main/java/io/micronaut/context/env/SystemPropertiesPropertySource.java
@@ -44,4 +44,9 @@ public class SystemPropertiesPropertySource extends MapPropertySource {
     public int getOrder() {
         return POSITION;
     }
+
+    @Override
+    public Origin getOrigin() {
+        return Origin.of("System.properties");
+    }
 }
diff --git a/inject/src/main/java/io/micronaut/context/exceptions/MessageUtils.java b/inject/src/main/java/io/micronaut/context/exceptions/MessageUtils.java
index e564d95e0b..545c87658a 100644
--- a/inject/src/main/java/io/micronaut/context/exceptions/MessageUtils.java
+++ b/inject/src/main/java/io/micronaut/context/exceptions/MessageUtils.java
@@ -176,7 +176,7 @@ class MessageUtils {
     private static void appendPath(boolean circular, StringBuilder builder, String ls, BeanResolutionContext.Path path) {
         builder.append("Path Taken:");
         if (circular) {
-            builder.append(ls).append(path.toCircularString());
+            builder.append(ls).append(path.toConsoleCircularString(false));
         } else {
             builder.append(" ").append(path);
         }
diff --git a/inject/src/main/java/io/micronaut/inject/BeanDefinition.java b/inject/src/main/java/io/micronaut/inject/BeanDefinition.java
index b5d2363d41..2f6300f48c 100644
--- a/inject/src/main/java/io/micronaut/inject/BeanDefinition.java
+++ b/inject/src/main/java/io/micronaut/inject/BeanDefinition.java
@@ -15,11 +15,15 @@
  */
 package io.micronaut.inject;
 
+import static io.micronaut.core.annotation.AnnotationUtil.ANN_ADAPTER;
+import static io.micronaut.core.type.TypeInformation.TypeFormat.getBeanTypeString;
+
 import io.micronaut.context.Qualifier;
 import io.micronaut.context.annotation.ConfigurationReader;
 import io.micronaut.context.annotation.DefaultScope;
 import io.micronaut.context.annotation.EachBean;
 import io.micronaut.context.annotation.EachProperty;
+import io.micronaut.core.annotation.AnnotationMetadata;
 import io.micronaut.core.annotation.AnnotationUtil;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
@@ -27,6 +31,10 @@ import io.micronaut.core.naming.Named;
 import io.micronaut.core.reflect.ReflectionUtils;
 import io.micronaut.core.type.Argument;
 import io.micronaut.core.type.ArgumentCoercible;
+import io.micronaut.core.type.TypeInformation;
+import io.micronaut.core.type.TypeInformation.TypeFormat;
+import io.micronaut.core.util.AnsiColour;
+import io.micronaut.inject.proxy.InterceptedBean;
 import jakarta.inject.Singleton;
 
 import java.lang.annotation.Annotation;
@@ -34,6 +42,7 @@ import java.lang.reflect.Modifier;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
+import java.util.Map;
 import java.util.Optional;
 import java.util.stream.Stream;
 
@@ -47,6 +56,72 @@ import java.util.stream.Stream;
  */
 public interface BeanDefinition<T> extends QualifiedBeanType<T>, Named, BeanType<T>, ArgumentCoercible<T> {
 
+    /**
+     * @return The type information for the bean.
+     * @since 4.8.0
+     */
+    default @NonNull TypeInformation<T> getTypeInformation() {
+        return new TypeInformation<>() {
+            @Override
+            public String getBeanTypeString(TypeFormat format) {
+                Class<T> beanType = getType();
+                boolean synthetic = beanType.isSynthetic();
+                if (synthetic) {
+                    AnnotationMetadata annotationMetadata = getAnnotationMetadata();
+                    // synthetic bean so produce better formatting.
+                    if (annotationMetadata.hasDeclaredStereotype(ANN_ADAPTER)) {
+                        @SuppressWarnings("unchecked") ExecutableMethod<Object, ?> method =
+                            (ExecutableMethod<Object, ?>) BeanDefinition.this.getExecutableMethods().iterator().next();
+                        // Not great, but to produce accurate debug output we have to reach into AOP internals
+                        Class<?> resolvedBeanType = method.classValue(ANN_ADAPTER, "adaptedBean")
+                            .orElse(beanType);
+                        return TypeFormat.getBeanTypeString(
+                            format,
+                            resolvedBeanType,
+                            getGenericBeanType().getTypeVariables(),
+                            annotationMetadata
+                        );
+                    } else if (InterceptedBean.class.isAssignableFrom(beanType)) {
+                        if (beanType.isInterface()) {
+                            return TypeFormat.getBeanTypeString(
+                                format,
+                                beanType.getInterfaces()[0],
+                                getGenericBeanType().getTypeVariables(),
+                                annotationMetadata
+                            );
+                        } else {
+                            return TypeFormat.getBeanTypeString(
+                                format,
+                                beanType.getSuperclass(),
+                                getGenericBeanType().getTypeVariables(),
+                                annotationMetadata
+                            );
+                        }
+                    } else {
+                        return TypeInformation.super.getBeanTypeString(format);
+                    }
+                } else {
+                    return TypeInformation.super.getBeanTypeString(format);
+                }
+            }
+
+            @Override
+            public Class<T> getType() {
+                return getBeanType();
+            }
+
+            @Override
+            public Map<String, Argument<?>> getTypeVariables() {
+                return BeanDefinition.this.getGenericBeanType().getTypeVariables();
+            }
+
+            @Override
+            public AnnotationMetadata getAnnotationMetadata() {
+                return BeanDefinition.this.getAnnotationMetadata();
+            }
+        };
+    }
+
     /**
      * @return The scope of the bean
      */
@@ -186,6 +261,10 @@ public interface BeanDefinition<T> extends QualifiedBeanType<T>, Named, BeanType
                 return BeanDefinition.this;
             }
 
+            @Override
+            public String toString() {
+                return getDeclaringBeanType().getName() + "(" + Argument.toString(getArguments()) + ")";
+            }
         };
     }
 
@@ -290,6 +369,7 @@ public interface BeanDefinition<T> extends QualifiedBeanType<T>, Named, BeanType
     default Argument<T> asArgument() {
         return Argument.of(
                 getBeanType(),
+                getAnnotationMetadata(),
                 getTypeParameters()
         );
     }
@@ -410,4 +490,162 @@ public interface BeanDefinition<T> extends QualifiedBeanType<T>, Named, BeanType
     default @Nullable Qualifier<T> resolveDynamicQualifier() {
         return QualifiedBeanType.super.resolveDynamicQualifier();
     }
+
+    /**
+     * Gets a description of the bean as close as possible to source representation.
+     * @param typeFormat The type format to use.
+     * @param includeArguments Whether to include arguments.
+     * @return The bean description.
+     * @since 4.8.0
+     */
+    default @NonNull String getBeanDescription(@NonNull TypeFormat typeFormat, boolean includeArguments) {
+        ConstructorInjectionPoint<T> constructor = getConstructor();
+        StringBuilder beanDescription = new StringBuilder();
+        Argument<?>[] arguments = constructor.getArguments();
+        if (constructor instanceof MethodInjectionPoint<?,?> methodInjectionPoint) {
+            // factory bean with method
+            Class<?> declaringType = methodInjectionPoint.getDeclaringType();
+            Class<T> declaringBeanType = constructor.getDeclaringBeanType();
+            String factoryType = TypeFormat.getTypeString(
+                typeFormat,
+                declaringBeanType,
+                Map.of()
+            );
+            String beanTypeName = getBeanTypeString(
+                typeFormat,
+                declaringType,
+                asArgument().getTypeVariables(),
+                methodInjectionPoint.getAnnotationMetadata()
+            );
+
+            beanDescription.append(beanTypeName).append(" ");
+            beanDescription.append(factoryType)
+                .append(".")
+                .append(methodInjectionPoint.getName());
+        } else if (constructor instanceof FieldInjectionPoint<?,?> fieldInjectionPoint) {
+            // factory bean with method
+            Class<T> declaringBeanType = constructor.getDeclaringBeanType();
+            String factoryType = TypeFormat.getTypeString(
+                typeFormat,
+                declaringBeanType,
+                Map.of()
+            );
+            Class<?> declaringType = fieldInjectionPoint.getDeclaringBean().getBeanType();
+            String beanTypeName = getBeanTypeString(
+                typeFormat,
+                declaringType,
+                asArgument().getTypeVariables(),
+                fieldInjectionPoint.getAnnotationMetadata()
+            );
+            beanDescription.append(beanTypeName).append(" ");
+            beanDescription.append(factoryType)
+                .append(".")
+                .append(fieldInjectionPoint.getName());
+            return beanDescription.toString();
+        } else {
+            boolean synthetic = getBeanType().isSynthetic();
+            if (synthetic) {
+                // AOP proxy or generated event listener
+                AnnotationMetadata annotationMetadata = getAnnotationMetadata();
+                if (annotationMetadata.hasDeclaredStereotype(ANN_ADAPTER)) {
+                    @SuppressWarnings("unchecked") ExecutableMethod<Object, ?> method =
+                        (ExecutableMethod<Object, ?>) getExecutableMethods().iterator().next();
+                    // Not great, but to produce accurate debug output we have to reach into AOP internals
+                    Class<?> adaptedType = method.classValue(ANN_ADAPTER).orElse(getBeanType());
+                    Class<?> beanType = method.classValue(ANN_ADAPTER, "adaptedBean").orElse(getBeanType());
+                    String beanMethod = method.stringValue(ANN_ADAPTER, "adaptedMethod").orElse("unknown");
+                    String beanTypeString = getBeanTypeString(
+                        typeFormat,
+                        beanType,
+                        asArgument().getTypeVariables(),
+                        annotationMetadata
+                    );
+                    beanDescription.append(beanTypeString)
+                        .append(".")
+                        .append(beanMethod);
+                    @NonNull Argument<?>[] methodArguments = method.getArguments();
+                    List<Argument<?>> typeArguments = getTypeArguments(adaptedType);
+                    if (typeArguments.size() == methodArguments.length) {
+                        arguments = new Argument[methodArguments.length];
+                        for (int i = 0; i < methodArguments.length; i++) {
+                            @NonNull Argument<?> methodArgument = methodArguments[i];
+                            Argument<?> t = typeArguments.get(i);
+                            arguments[i] = Argument.of(
+                                t.getType(),
+                                methodArgument.getName(),
+                                methodArgument.getAnnotationMetadata(),
+                                t.getTypeParameters()
+                            );
+                        }
+                    }
+                } else {
+                    Class<T> beanType = getBeanType();
+                    String beanTypeString;
+                    if (beanType.isInterface()) {
+                        beanTypeString = getBeanTypeString(
+                            typeFormat,
+                            beanType.getInterfaces()[0],
+                            asArgument().getTypeVariables(),
+                            annotationMetadata
+                        );
+                    } else {
+                        beanTypeString = getBeanTypeString(
+                            typeFormat,
+                            beanType.getSuperclass(),
+                            asArgument().getTypeVariables(),
+                            annotationMetadata
+                        );
+                    }
+                    beanDescription.append(beanTypeString);
+                }
+            } else {
+                beanDescription.append(
+                    getTypeInformation().getBeanTypeString(typeFormat)
+                );
+            }
+        }
+
+        if (includeArguments) {
+            beanDescription.append(typeFormat.isAnsi() ? AnsiColour.brightCyan("(") : "(");
+
+            for (int i = 0; i < arguments.length; i++) {
+                Argument<?> argument = arguments[i];
+                if (argument.getName().startsWith("$")) {
+                    // skip internal
+                    continue;
+                }
+                String argType = getBeanTypeString(
+                    typeFormat,
+                    argument
+                );
+                String argumentName = argument.getName();
+                beanDescription.append(argType)
+                    .append(" ")
+                    .append(typeFormat.isAnsi() ? AnsiColour.brightBlue(argumentName) : argumentName);
+
+                if (i != arguments.length - 1) {
+                    Argument<?> next = arguments[i + 1];
+                    if (getBeanType().isSynthetic() &&
+                        next.getName().startsWith("$")) {
+                        // skip synthetic arguments
+                        break;
+                    }
+                    beanDescription.append(", ");
+                }
+            }
+
+            beanDescription.append(typeFormat.isAnsi() ? AnsiColour.brightCyan(")") : ")");
+        }
+        return beanDescription.toString();
+    }
+
+    /**
+     * Gets a description of the bean as close as possible to source representation.
+     * @param typeFormat The type format to use.
+     * @return The bean description.
+     * @since 4.8.0
+     */
+    default @NonNull String getBeanDescription(@NonNull TypeFormat typeFormat) {
+        return getBeanDescription(typeFormat, true);
+    }
 }
diff --git a/inject/src/main/java/io/micronaut/inject/provider/BeanProviderDefinition.java b/inject/src/main/java/io/micronaut/inject/provider/BeanProviderDefinition.java
index fb1df8bf0c..8f10441926 100644
--- a/inject/src/main/java/io/micronaut/inject/provider/BeanProviderDefinition.java
+++ b/inject/src/main/java/io/micronaut/inject/provider/BeanProviderDefinition.java
@@ -121,6 +121,11 @@ public final class BeanProviderDefinition extends AbstractProviderDefinition<Bea
             public Stream<Object> stream() {
                 return defaultBeanContext.streamOfType(resolutionContext.copy(), argument, finalQualifier);
             }
+
+            @Override
+            public String toString() {
+                return "Provider(" + argument + ")";
+            }
         };
     }
 
@@ -128,4 +133,5 @@ public final class BeanProviderDefinition extends AbstractProviderDefinition<Bea
     protected boolean isAllowEmptyProviders(BeanContext context) {
         return true;
     }
+
 }
diff --git a/inject/src/main/java/io/micronaut/inject/qualifiers/InterceptorBindingQualifier.java b/inject/src/main/java/io/micronaut/inject/qualifiers/InterceptorBindingQualifier.java
index 88481508d9..a38118d564 100644
--- a/inject/src/main/java/io/micronaut/inject/qualifiers/InterceptorBindingQualifier.java
+++ b/inject/src/main/java/io/micronaut/inject/qualifiers/InterceptorBindingQualifier.java
@@ -21,6 +21,7 @@ import io.micronaut.core.annotation.AnnotationValue;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.core.util.ObjectUtils;
 import io.micronaut.inject.BeanType;
@@ -177,8 +178,8 @@ public final class InterceptorBindingQualifier<T> extends FilteringQualifier<T>
         if (CollectionUtils.isEmpty(supportedAnnotationNames) && CollectionUtils.isEmpty(supportedInterceptorTypes)) {
             return "@InterceptorBinding(NONE)";
         } else {
-            return supportedAnnotationNames.keySet().stream().map((name) -> "@InterceptorBinding(" + name + ")").collect(Collectors.joining(" ")) +
-                    supportedInterceptorTypes.stream().map((name) -> "@InterceptorBinding(interceptorType = " + name + ")").collect(Collectors.joining(" "));
+            return supportedAnnotationNames.keySet().stream().map((name) -> "@InterceptorBinding(" + NameUtils.getShortenedName(name) + ")").collect(Collectors.joining(" ")) +
+                    supportedInterceptorTypes.stream().map((type) -> "@InterceptorBinding(interceptorType = " + NameUtils.getShortenedName(type.getTypeName()) + ")").collect(Collectors.joining(" "));
         }
     }
 
diff --git a/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapApplicationPropertySourceLoader.java b/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapApplicationPropertySourceLoader.java
index f9d56bb326..79d2a0e7f3 100644
--- a/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapApplicationPropertySourceLoader.java
+++ b/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapApplicationPropertySourceLoader.java
@@ -18,6 +18,7 @@ package io.micronaut.jackson.core.env;
 import com.fasterxml.jackson.core.JsonParseException;
 import io.micronaut.context.env.CachedEnvironment;
 import io.micronaut.context.env.MapPropertySource;
+import io.micronaut.context.env.PropertySource;
 import io.micronaut.context.exceptions.ConfigurationException;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.io.ResourceLoader;
@@ -35,7 +36,9 @@ import java.util.Set;
  *
  * @author Fabian Nonnenmacher
  * @since 2.0
+ * @deprecated CloudFoundry support should be added manually
  */
+@Deprecated(forRemoval = true)
 @Internal
 public class CloudFoundryVcapApplicationPropertySourceLoader extends EnvJsonPropertySourceLoader {
 
@@ -87,7 +90,7 @@ public class CloudFoundryVcapApplicationPropertySourceLoader extends EnvJsonProp
     }
 
     @Override
-    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order) {
-        return super.createPropertySource("cloudfoundry-vcap-application", map, order);
+    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order, PropertySource.Origin origin) {
+        return super.createPropertySource("cloudfoundry-vcap-application", map, order, PropertySource.Origin.of("env.VCAP_APPLICATION"));
     }
 }
diff --git a/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapServicesPropertySourceLoader.java b/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapServicesPropertySourceLoader.java
index e28e47a90d..f8e5592544 100644
--- a/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapServicesPropertySourceLoader.java
+++ b/jackson-core/src/main/java/io/micronaut/jackson/core/env/CloudFoundryVcapServicesPropertySourceLoader.java
@@ -18,6 +18,7 @@ package io.micronaut.jackson.core.env;
 import com.fasterxml.jackson.core.JsonParseException;
 import io.micronaut.context.env.CachedEnvironment;
 import io.micronaut.context.env.MapPropertySource;
+import io.micronaut.context.env.PropertySource;
 import io.micronaut.context.exceptions.ConfigurationException;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.io.ResourceLoader;
@@ -36,7 +37,9 @@ import java.util.Set;
  *
  * @author Fabian Nonnenmacher
  * @since 2.0
+ * @deprecated CloudFoundry support should be added manually
  */
+@Deprecated(forRemoval = true)
 @Internal
 public class CloudFoundryVcapServicesPropertySourceLoader extends EnvJsonPropertySourceLoader {
 
@@ -106,7 +109,7 @@ public class CloudFoundryVcapServicesPropertySourceLoader extends EnvJsonPropert
     }
 
     @Override
-    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order) {
-        return super.createPropertySource("cloudfoundry-vcap-services", map, order);
+    protected MapPropertySource createPropertySource(String name, Map<String, Object> map, int order, PropertySource.Origin origin) {
+        return super.createPropertySource("cloudfoundry-vcap-services", map, order, PropertySource.Origin.of("env.VCAP_SERVICES"));
     }
 }
diff --git a/src/main/docs/guide/ioc.adoc b/src/main/docs/guide/ioc.adoc
index 8add71aee6..89ebfa2b61 100644
--- a/src/main/docs/guide/ioc.adoc
+++ b/src/main/docs/guide/ioc.adoc
@@ -1,3 +1,6 @@
+https://en.wikipedia.org/wiki/Dependency_injection[Dependency Injection] (often referred to as https://en.wikipedia.org/wiki/Inversion_of_control[Inversion of Control]) is a pattern that allows your code to remain independent of configuration and allows the definition of loosely coupled applications. Reducing coupling increases the ability to test your application by ensuring code is not tied directly to an external systems (like a database).
+
+
 Unlike other frameworks which rely on runtime reflection and proxies, the Micronaut framework uses compile time data to implement dependency injection.
 
 This is a similar approach taken by tools such as Google https://google.github.io/dagger/[Dagger], which is designed primarily with Android in mind. Micronaut, on the other hand, is designed for building server-side microservices and provides many of the same tools and utilities as other frameworks but without using reflection or caching excessive amounts of reflection metadata.
@@ -5,7 +8,7 @@ This is a similar approach taken by tools such as Google https://google.github.i
 The goals of the Micronaut IoC container are summarized as:
 
 * Use reflection as a last resort
-* Avoid proxies
+* Avoid runtime-generated proxies
 * Optimize start-up time
 * Reduce memory footprint
 * Provide clear, understandable error handling
diff --git a/src/main/docs/guide/ioc/iocDebugging.adoc b/src/main/docs/guide/ioc/iocDebugging.adoc
new file mode 100644
index 0000000000..01f819a26d
--- /dev/null
+++ b/src/main/docs/guide/ioc/iocDebugging.adoc
@@ -0,0 +1,23 @@
+To help you easily understand what Micronaut is doing at startup and when a particular bean is created Micronaut includes a dependency injection tracing feature which can be activated in a number of different ways including via the api:context.ApplicationContextBuilder[] API.
+
+The simplest way to activate injection trace mode is using an environment variable. For example if you are running your application locally you can do:
+
+.Activating Injection Trace Mode
+[source,bash]
+----
+MICRONAUT_INJECT_TRACE=.+ ./gradlew run
+----
+
+Or for Maven:
+
+.Activating Injection Trace Mode
+[source,bash]
+----
+MICRONAUT_INJECT_TRACE=.+ ./mvnw mn:run
+----
+
+Trace mode will output useful information such as:
+
+* The Configuration profile of the application
+* The applicable configuration and where it came from
+* The beans that are created, where they were created and how long was taken to create the bean.
diff --git a/src/main/docs/guide/toc.yml b/src/main/docs/guide/toc.yml
index 1ced95bf76..fd3ba66ac5 100644
--- a/src/main/docs/guide/toc.yml
+++ b/src/main/docs/guide/toc.yml
@@ -15,9 +15,10 @@ quickStart:
   creatingClient: Creating a Client
   deployingApp: Deploying the Application
 ioc:
-  title: Inversion of Control
+  title: Dependency Injection
   beans: Defining Beans
   how: How Does it Work?
+  iocDebugging: Debugging Dependency Injection
   beanContext: The BeanContext
   injection:
     title: Dependency Injection Types
