diff --git a/ktor-client/ktor-client-okhttp/api/ktor-client-okhttp.api b/ktor-client/ktor-client-okhttp/api/ktor-client-okhttp.api
index 454b838c8..0faf85248 100644
--- a/ktor-client/ktor-client-okhttp/api/ktor-client-okhttp.api
+++ b/ktor-client/ktor-client-okhttp/api/ktor-client-okhttp.api
@@ -12,9 +12,11 @@ public final class io/ktor/client/engine/okhttp/OkHttpConfig : io/ktor/client/en
 	public final fun addNetworkInterceptor (Lokhttp3/Interceptor;)V
 	public final fun config (Lkotlin/jvm/functions/Function1;)V
 	public final fun getClientCacheSize ()I
+	public final fun getDuplexStreamingEnabled ()Z
 	public final fun getPreconfigured ()Lokhttp3/OkHttpClient;
 	public final fun getWebSocketFactory ()Lokhttp3/WebSocket$Factory;
 	public final fun setClientCacheSize (I)V
+	public final fun setDuplexStreamingEnabled (Z)V
 	public final fun setPreconfigured (Lokhttp3/OkHttpClient;)V
 	public final fun setWebSocketFactory (Lokhttp3/WebSocket$Factory;)V
 }
diff --git a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpConfig.kt b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpConfig.kt
index 75af6ddcd..f001a7c3a 100644
--- a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpConfig.kt
+++ b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpConfig.kt
@@ -44,6 +44,17 @@ public class OkHttpConfig : HttpClientEngineConfig() {
      */
     public var webSocketFactory: WebSocket.Factory? = null
 
+    /**
+     * Specifies if duplex streaming is enabled for the [OkHttpClient].
+     * Setting this to `true` allows clients to send and receive data simultaneously
+     * using bidirectional streaming (HTTP/2 only).
+     *
+     * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.client.engine.okhttp.OkHttpConfig.duplexStreamingEnabled)
+     *
+     * @see [okhttp3.RequestBody.isDuplex]
+     */
+    public var duplexStreamingEnabled: Boolean = false
+
     /**
      * Configures [OkHttpClient] using [OkHttpClient.Builder].
      *
diff --git a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt
index c18fff1ab..cb9a41156 100644
--- a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt
+++ b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt
@@ -59,7 +59,7 @@ public class OkHttpEngine(override val config: OkHttpConfig) : HttpClientEngineB
 
     override suspend fun execute(data: HttpRequestData): HttpResponseData {
         val callContext = callContext()
-        val engineRequest = data.convertToOkHttpRequest(callContext)
+        val engineRequest = data.convertToOkHttpRequest(callContext, config)
 
         val requestEngine = clientCache[data.getCapabilityOrNull(HttpTimeoutCapability)]
             ?: error("OkHttpClient can't be constructed because HttpTimeout plugin is not installed")
@@ -181,7 +181,7 @@ private fun mapExceptions(cause: Throwable, request: HttpRequestData): Throwable
 }
 
 @OptIn(InternalAPI::class)
-private fun HttpRequestData.convertToOkHttpRequest(callContext: CoroutineContext): Request {
+private fun HttpRequestData.convertToOkHttpRequest(callContext: CoroutineContext, config: OkHttpConfig): Request {
     val builder = Request.Builder()
 
     with(builder) {
@@ -190,7 +190,7 @@ private fun HttpRequestData.convertToOkHttpRequest(callContext: CoroutineContext
         forEachHeader(::addHeader)
 
         val bodyBytes = if (HttpMethod.permitsRequestBody(method.value)) {
-            body.convertToOkHttpBody(callContext)
+            body.convertToOkHttpBody(callContext, config)
         } else {
             null
         }
@@ -202,18 +202,34 @@ private fun HttpRequestData.convertToOkHttpRequest(callContext: CoroutineContext
 }
 
 @OptIn(DelicateCoroutinesApi::class)
-internal fun OutgoingContent.convertToOkHttpBody(callContext: CoroutineContext): RequestBody = when (this) {
+internal fun OutgoingContent.convertToOkHttpBody(
+    callContext: CoroutineContext,
+    config: OkHttpConfig,
+): RequestBody = when (this) {
     is OutgoingContent.ByteArrayContent -> bytes().let {
         it.toRequestBody(contentType.toString().toMediaTypeOrNull(), 0, it.size)
     }
 
-    is OutgoingContent.ReadChannelContent -> StreamRequestBody(contentLength) { readFrom() }
+    is OutgoingContent.ReadChannelContent -> {
+        StreamRequestBody(
+            callContext,
+            contentLength,
+            config.duplexStreamingEnabled,
+        ) { readFrom() }
+    }
+
     is OutgoingContent.WriteChannelContent -> {
-        StreamRequestBody(contentLength) { GlobalScope.writer(callContext) { writeTo(channel) }.channel }
+        StreamRequestBody(
+            callContext,
+            contentLength,
+            config.duplexStreamingEnabled,
+        ) {
+            GlobalScope.writer(callContext) { writeTo(channel) }.channel
+        }
     }
 
     is OutgoingContent.NoContent -> ByteArray(0).toRequestBody(null, 0, 0)
-    is OutgoingContent.ContentWrapper -> delegate().convertToOkHttpBody(callContext)
+    is OutgoingContent.ContentWrapper -> delegate().convertToOkHttpBody(callContext, config)
     is OutgoingContent.ProtocolUpgrade -> throw UnsupportedContentTypeException(this)
 }
 
diff --git a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/StreamRequestBody.kt b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/StreamRequestBody.kt
index 4822e9911..fcdf61f91 100644
--- a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/StreamRequestBody.kt
+++ b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/StreamRequestBody.kt
@@ -5,32 +5,43 @@
 package io.ktor.client.engine.okhttp
 
 import io.ktor.utils.io.*
-import io.ktor.utils.io.jvm.javaio.*
+import io.ktor.utils.io.streams.asByteWriteChannel
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
 import okhttp3.*
 import okio.*
+import kotlin.coroutines.CoroutineContext
 
 internal class StreamAdapterIOException(cause: Throwable) : IOException(cause)
 
 internal class StreamRequestBody(
+    private val callContext: CoroutineContext,
     private val contentLength: Long?,
+    private val duplex: Boolean,
     private val block: () -> ByteReadChannel
 ) : RequestBody() {
 
     override fun contentType(): MediaType? = null
 
     override fun writeTo(sink: BufferedSink) {
-        try {
-            block().toInputStream().source().use {
-                sink.writeAll(it)
+        val job = CoroutineScope(callContext).launch(Dispatchers.IO) {
+            try {
+                val channel = block()
+                channel.copyTo(sink.outputStream().asByteWriteChannel())
+            } catch (cause: IOException) {
+                throw cause
+            } catch (cause: Throwable) {
+                throw StreamAdapterIOException(cause)
             }
-        } catch (cause: IOException) {
-            throw cause
-        } catch (cause: Throwable) {
-            throw StreamAdapterIOException(cause)
         }
+        if (!duplex) runBlocking { job.join() }
     }
 
     override fun contentLength(): Long = contentLength ?: -1
 
     override fun isOneShot(): Boolean = true
+
+    override fun isDuplex(): Boolean = duplex
 }
