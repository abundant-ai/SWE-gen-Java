diff --git a/ktor-client/ktor-client-okhttp/api/ktor-client-okhttp.api b/ktor-client/ktor-client-okhttp/api/ktor-client-okhttp.api
index 0faf85248..454b838c8 100644
--- a/ktor-client/ktor-client-okhttp/api/ktor-client-okhttp.api
+++ b/ktor-client/ktor-client-okhttp/api/ktor-client-okhttp.api
@@ -12,11 +12,9 @@ public final class io/ktor/client/engine/okhttp/OkHttpConfig : io/ktor/client/en
 	public final fun addNetworkInterceptor (Lokhttp3/Interceptor;)V
 	public final fun config (Lkotlin/jvm/functions/Function1;)V
 	public final fun getClientCacheSize ()I
-	public final fun getDuplexStreamingEnabled ()Z
 	public final fun getPreconfigured ()Lokhttp3/OkHttpClient;
 	public final fun getWebSocketFactory ()Lokhttp3/WebSocket$Factory;
 	public final fun setClientCacheSize (I)V
-	public final fun setDuplexStreamingEnabled (Z)V
 	public final fun setPreconfigured (Lokhttp3/OkHttpClient;)V
 	public final fun setWebSocketFactory (Lokhttp3/WebSocket$Factory;)V
 }
diff --git a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpConfig.kt b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpConfig.kt
index f001a7c3a..75af6ddcd 100644
--- a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpConfig.kt
+++ b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpConfig.kt
@@ -44,17 +44,6 @@ public class OkHttpConfig : HttpClientEngineConfig() {
      */
     public var webSocketFactory: WebSocket.Factory? = null
 
-    /**
-     * Specifies if duplex streaming is enabled for the [OkHttpClient].
-     * Setting this to `true` allows clients to send and receive data simultaneously
-     * using bidirectional streaming (HTTP/2 only).
-     *
-     * [Report a problem](https://ktor.io/feedback/?fqname=io.ktor.client.engine.okhttp.OkHttpConfig.duplexStreamingEnabled)
-     *
-     * @see [okhttp3.RequestBody.isDuplex]
-     */
-    public var duplexStreamingEnabled: Boolean = false
-
     /**
      * Configures [OkHttpClient] using [OkHttpClient.Builder].
      *
diff --git a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt
index cb9a41156..c18fff1ab 100644
--- a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt
+++ b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/OkHttpEngine.kt
@@ -59,7 +59,7 @@ public class OkHttpEngine(override val config: OkHttpConfig) : HttpClientEngineB
 
     override suspend fun execute(data: HttpRequestData): HttpResponseData {
         val callContext = callContext()
-        val engineRequest = data.convertToOkHttpRequest(callContext, config)
+        val engineRequest = data.convertToOkHttpRequest(callContext)
 
         val requestEngine = clientCache[data.getCapabilityOrNull(HttpTimeoutCapability)]
             ?: error("OkHttpClient can't be constructed because HttpTimeout plugin is not installed")
@@ -181,7 +181,7 @@ private fun mapExceptions(cause: Throwable, request: HttpRequestData): Throwable
 }
 
 @OptIn(InternalAPI::class)
-private fun HttpRequestData.convertToOkHttpRequest(callContext: CoroutineContext, config: OkHttpConfig): Request {
+private fun HttpRequestData.convertToOkHttpRequest(callContext: CoroutineContext): Request {
     val builder = Request.Builder()
 
     with(builder) {
@@ -190,7 +190,7 @@ private fun HttpRequestData.convertToOkHttpRequest(callContext: CoroutineContext
         forEachHeader(::addHeader)
 
         val bodyBytes = if (HttpMethod.permitsRequestBody(method.value)) {
-            body.convertToOkHttpBody(callContext, config)
+            body.convertToOkHttpBody(callContext)
         } else {
             null
         }
@@ -202,34 +202,18 @@ private fun HttpRequestData.convertToOkHttpRequest(callContext: CoroutineContext
 }
 
 @OptIn(DelicateCoroutinesApi::class)
-internal fun OutgoingContent.convertToOkHttpBody(
-    callContext: CoroutineContext,
-    config: OkHttpConfig,
-): RequestBody = when (this) {
+internal fun OutgoingContent.convertToOkHttpBody(callContext: CoroutineContext): RequestBody = when (this) {
     is OutgoingContent.ByteArrayContent -> bytes().let {
         it.toRequestBody(contentType.toString().toMediaTypeOrNull(), 0, it.size)
     }
 
-    is OutgoingContent.ReadChannelContent -> {
-        StreamRequestBody(
-            callContext,
-            contentLength,
-            config.duplexStreamingEnabled,
-        ) { readFrom() }
-    }
-
+    is OutgoingContent.ReadChannelContent -> StreamRequestBody(contentLength) { readFrom() }
     is OutgoingContent.WriteChannelContent -> {
-        StreamRequestBody(
-            callContext,
-            contentLength,
-            config.duplexStreamingEnabled,
-        ) {
-            GlobalScope.writer(callContext) { writeTo(channel) }.channel
-        }
+        StreamRequestBody(contentLength) { GlobalScope.writer(callContext) { writeTo(channel) }.channel }
     }
 
     is OutgoingContent.NoContent -> ByteArray(0).toRequestBody(null, 0, 0)
-    is OutgoingContent.ContentWrapper -> delegate().convertToOkHttpBody(callContext, config)
+    is OutgoingContent.ContentWrapper -> delegate().convertToOkHttpBody(callContext)
     is OutgoingContent.ProtocolUpgrade -> throw UnsupportedContentTypeException(this)
 }
 
diff --git a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/StreamRequestBody.kt b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/StreamRequestBody.kt
index fcdf61f91..4822e9911 100644
--- a/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/StreamRequestBody.kt
+++ b/ktor-client/ktor-client-okhttp/jvm/src/io/ktor/client/engine/okhttp/StreamRequestBody.kt
@@ -5,43 +5,32 @@
 package io.ktor.client.engine.okhttp
 
 import io.ktor.utils.io.*
-import io.ktor.utils.io.streams.asByteWriteChannel
-import kotlinx.coroutines.CoroutineScope
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.launch
-import kotlinx.coroutines.runBlocking
+import io.ktor.utils.io.jvm.javaio.*
 import okhttp3.*
 import okio.*
-import kotlin.coroutines.CoroutineContext
 
 internal class StreamAdapterIOException(cause: Throwable) : IOException(cause)
 
 internal class StreamRequestBody(
-    private val callContext: CoroutineContext,
     private val contentLength: Long?,
-    private val duplex: Boolean,
     private val block: () -> ByteReadChannel
 ) : RequestBody() {
 
     override fun contentType(): MediaType? = null
 
     override fun writeTo(sink: BufferedSink) {
-        val job = CoroutineScope(callContext).launch(Dispatchers.IO) {
-            try {
-                val channel = block()
-                channel.copyTo(sink.outputStream().asByteWriteChannel())
-            } catch (cause: IOException) {
-                throw cause
-            } catch (cause: Throwable) {
-                throw StreamAdapterIOException(cause)
+        try {
+            block().toInputStream().source().use {
+                sink.writeAll(it)
             }
+        } catch (cause: IOException) {
+            throw cause
+        } catch (cause: Throwable) {
+            throw StreamAdapterIOException(cause)
         }
-        if (!duplex) runBlocking { job.join() }
     }
 
     override fun contentLength(): Long = contentLength ?: -1
 
     override fun isOneShot(): Boolean = true
-
-    override fun isDuplex(): Boolean = duplex
 }
diff --git a/ktor-client/ktor-client-okhttp/jvm/test/io/ktor/client/engine/okhttp/OkHttpHttp2Test.kt b/ktor-client/ktor-client-okhttp/jvm/test/io/ktor/client/engine/okhttp/OkHttpHttp2Test.kt
deleted file mode 100644
index 3382bdc9f..000000000
--- a/ktor-client/ktor-client-okhttp/jvm/test/io/ktor/client/engine/okhttp/OkHttpHttp2Test.kt
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Copyright 2014-2023 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
- */
-
-package io.ktor.client.engine.okhttp
-
-import io.ktor.client.request.*
-import io.ktor.client.statement.*
-import io.ktor.client.test.base.*
-import io.ktor.client.tests.utils.*
-import io.ktor.http.*
-import io.ktor.http.content.*
-import io.ktor.server.engine.*
-import io.ktor.server.netty.*
-import io.ktor.server.request.*
-import io.ktor.server.response.*
-import io.ktor.server.routing.*
-import io.ktor.utils.io.*
-import kotlinx.coroutines.CompletableDeferred
-import okhttp3.Protocol
-import kotlin.test.Test
-import kotlin.test.assertEquals
-import kotlin.test.assertFailsWith
-import kotlin.test.fail
-
-class OkHttpHttp2Test : TestWithKtor() {
-
-    override val server = embeddedServer(
-        Netty,
-        configure = {
-            connector {
-                port = serverPort
-            }
-            enableHttp2 = true
-            enableH2c = true
-        }
-    ) {
-        routing {
-            post("/echo-stream") {
-                val inputChannel = call.receiveChannel()
-
-                call.respondBytesWriter(status = HttpStatusCode.OK) {
-                    val outputChannel = this
-                    while (true) {
-                        val inputLine = inputChannel.readUTF8Line() ?: break
-                        outputChannel.writeStringUtf8("server: $inputLine\n")
-                        outputChannel.flush()
-                    }
-                }
-            }
-        }
-    }
-
-    @Test
-    fun testDuplexStreaming() = testWithEngine(OkHttp) {
-        config {
-            engine {
-                duplexStreamingEnabled = true
-                config {
-                    protocols(listOf(Protocol.H2_PRIOR_KNOWLEDGE))
-                }
-            }
-        }
-
-        test { client ->
-            val inputChannel = ByteChannel(true)
-            val response = client
-                .preparePost("$testUrl/echo-stream") {
-                    setBody(inputChannel)
-                }
-                .execute {
-                    val outputChannel = it.bodyAsChannel()
-                    var acc = ""
-                    (0..2).forEach {
-                        inputChannel.writeStringUtf8("client: $it\n")
-                        inputChannel.flush()
-                        acc += outputChannel.readUTF8Line()
-                        acc += "\n"
-                    }
-                    acc
-                }
-            assertEquals(
-                """
-                    server: client: 0
-                    server: client: 1
-                    server: client: 2
-                """.trimIndent(),
-                response.trim()
-            )
-        }
-    }
-
-    @Test
-    fun testDuplexStreamingExceptionPropagates() = testWithEngine(OkHttp) {
-        config {
-            engine {
-                duplexStreamingEnabled = true
-                config {
-                    protocols(listOf(Protocol.H2_PRIOR_KNOWLEDGE))
-                }
-            }
-        }
-
-        test { client ->
-            val established = CompletableDeferred<Unit>()
-            val failingBody = object : OutgoingContent.WriteChannelContent() {
-                override suspend fun writeTo(channel: ByteWriteChannel) {
-                    channel.writeStringUtf8("client: 0\n")
-                    channel.flush()
-                    established.await()
-                    throw IllegalStateException("Client-side exception")
-                }
-            }
-
-            assertFailsWith<ClosedByteChannelException> {
-                client.preparePost("$testUrl/echo-stream") {
-                    setBody(failingBody)
-                }.execute { response ->
-                    val out = response.bodyAsChannel()
-                    val first = out.readUTF8Line()
-                    assertEquals("server: client: 0", first)
-                    established.complete(Unit)
-                    out.readUTF8Line()
-                    fail("Expected duplex writer failure")
-                }
-            }.apply {
-                assertEquals("Client-side exception", cause?.message)
-            }
-        }
-    }
-}
