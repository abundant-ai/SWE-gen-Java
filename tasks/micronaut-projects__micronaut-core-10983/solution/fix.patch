diff --git a/http-client-core/src/main/java/io/micronaut/http/client/DefaultHttpClientConfiguration.java b/http-client-core/src/main/java/io/micronaut/http/client/DefaultHttpClientConfiguration.java
index 3aa14fbf48..c82d28f2c2 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/DefaultHttpClientConfiguration.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/DefaultHttpClientConfiguration.java
@@ -40,6 +40,7 @@ public class DefaultHttpClientConfiguration extends HttpClientConfiguration {
     public static final String PREFIX = "micronaut.http.client";
     private final DefaultConnectionPoolConfiguration connectionPoolConfiguration;
     private final DefaultWebSocketCompressionConfiguration webSocketCompressionConfiguration;
+    private final DefaultHttp2ClientConfiguration http2Configuration;
 
     /**
      * Default constructor.
@@ -47,31 +48,47 @@ public class DefaultHttpClientConfiguration extends HttpClientConfiguration {
     public DefaultHttpClientConfiguration() {
         this.connectionPoolConfiguration = new DefaultConnectionPoolConfiguration();
         this.webSocketCompressionConfiguration = new DefaultWebSocketCompressionConfiguration();
+        this.http2Configuration = new DefaultHttp2ClientConfiguration();
     }
 
     /**
      * @param connectionPoolConfiguration The connection pool configuration
      * @param applicationConfiguration The application configuration
-     * @deprecated Use {@link DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration, DefaultWebSocketCompressionConfiguration, ApplicationConfiguration)} instead.
+     * @deprecated Use {@link DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration, DefaultWebSocketCompressionConfiguration, DefaultHttp2ClientConfiguration , ApplicationConfiguration)} instead.
      */
     @Deprecated(since = "4.3.0")
     public DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration connectionPoolConfiguration, ApplicationConfiguration applicationConfiguration) {
         this(connectionPoolConfiguration, new DefaultWebSocketCompressionConfiguration(), applicationConfiguration);
     }
 
+    /**
+     * @param connectionPoolConfiguration The connection pool configuration
+     * @param webSocketCompressionConfiguration The WebSocket compression configuration
+     * @param applicationConfiguration The application configuration
+     * @deprecated Use {@link DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration, DefaultWebSocketCompressionConfiguration, DefaultHttp2ClientConfiguration , ApplicationConfiguration)} instead.
+     */
+    @Deprecated(since = "4.6.0")
+    public DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration connectionPoolConfiguration,
+                                          DefaultWebSocketCompressionConfiguration webSocketCompressionConfiguration,
+                                          ApplicationConfiguration applicationConfiguration) {
+        this(connectionPoolConfiguration, webSocketCompressionConfiguration, new DefaultHttp2ClientConfiguration(), applicationConfiguration);
+    }
 
     /**
      * @param connectionPoolConfiguration The connection pool configuration
      * @param webSocketCompressionConfiguration The WebSocket compression configuration
+     * @param http2Configuration The HTTP/2 configuration
      * @param applicationConfiguration The application configuration
      */
     @Inject
     public DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration connectionPoolConfiguration,
                                           DefaultWebSocketCompressionConfiguration webSocketCompressionConfiguration,
+                                          DefaultHttp2ClientConfiguration http2Configuration,
                                           ApplicationConfiguration applicationConfiguration) {
         super(applicationConfiguration);
         this.connectionPoolConfiguration = connectionPoolConfiguration;
         this.webSocketCompressionConfiguration = webSocketCompressionConfiguration;
+        this.http2Configuration = http2Configuration;
     }
 
     @Override
@@ -96,6 +113,11 @@ public class DefaultHttpClientConfiguration extends HttpClientConfiguration {
         }
     }
 
+    @Override
+    public Http2ClientConfiguration getHttp2Configuration() {
+        return http2Configuration;
+    }
+
     /**
      * The default connection pool configuration.
      */
@@ -113,4 +135,13 @@ public class DefaultHttpClientConfiguration extends HttpClientConfiguration {
     @Primary
     public static class DefaultWebSocketCompressionConfiguration extends WebSocketCompressionConfiguration {
     }
+
+    /**
+     * The default HTTP/2 configuration.
+     */
+    @ConfigurationProperties(Http2ClientConfiguration.PREFIX)
+    @BootstrapContextCompatible
+    @Primary
+    public static class DefaultHttp2ClientConfiguration extends Http2ClientConfiguration {
+    }
 }
diff --git a/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java b/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
index 377a8dfc1e..eba4b60c88 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
@@ -16,6 +16,7 @@
 package io.micronaut.http.client;
 
 import io.micronaut.context.env.CachedEnvironment;
+import io.micronaut.core.annotation.NextMajorVersion;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.convert.format.ReadableBytes;
@@ -127,6 +128,8 @@ public abstract class HttpClientConfiguration {
 
     private Duration readTimeout = Duration.ofSeconds(DEFAULT_READ_TIMEOUT_SECONDS);
 
+    private Duration requestTimeout = null;
+
     private Duration readIdleTimeout = Duration.of(DEFAULT_READ_IDLE_TIMEOUT_MINUTES, ChronoUnit.MINUTES);
 
     private Duration connectionPoolIdleTimeout = DEFAULT_CONNECTION_POOL_IDLE_TIMEOUT_SECONDS == 0 ? null : Duration.ofSeconds(DEFAULT_CONNECTION_POOL_IDLE_TIMEOUT_SECONDS);
@@ -413,12 +416,36 @@ public abstract class HttpClientConfiguration {
     }
 
     /**
-     * For streaming requests and WebSockets, the {@link #getReadTimeout()} method does not apply instead a configurable
+     * The request timeout for non-streaming requests. This is the maximum time until the response
+     * must be completely received. Defaults to one second more than read-timeout.
+     *
+     * @return The request timeout
+     * @since 4.6.0
+     */
+    @Nullable
+    @NextMajorVersion("Set a default that isn't just requestTimeout+1 in DefaultHttpClient")
+    public Duration getRequestTimeout() {
+        return requestTimeout;
+    }
+
+    /**
+     * The request timeout for non-streaming requests. This is the maximum time until the response
+     * must be completely received. Defaults to one second more than read-timeout.
+     *
+     * @param requestTimeout The request timeout
+     */
+    public void setRequestTimeout(@Nullable Duration requestTimeout) {
+        this.requestTimeout = requestTimeout;
+    }
+
+    /**
+     * For WebSockets, the {@link #getReadTimeout()} method does not apply instead a configurable
      * idle timeout is applied.
      * [available in the Netty HTTP client]
      *
      * @return The default amount of time to allow read operation connections  to remain idle
      */
+    @NextMajorVersion("Rename to websocket-idle-timeout")
     public Optional<Duration> getReadIdleTimeout() {
         return Optional.ofNullable(readIdleTimeout);
     }
@@ -498,7 +525,8 @@ public abstract class HttpClientConfiguration {
     }
 
     /**
-     * Sets the max read idle time for streaming requests. Default value ({@value io.micronaut.http.client.HttpClientConfiguration#DEFAULT_READ_IDLE_TIMEOUT_MINUTES} minutes).
+     * For WebSockets, the {@link #getReadTimeout()} method does not apply instead a configurable
+     * idle timeout is applied.
      *
      * @param readIdleTimeout The read idle time
      */
@@ -833,6 +861,17 @@ public abstract class HttpClientConfiguration {
         this.addressResolverGroupName = addressResolverGroupName;
     }
 
+    /**
+     * Obtains the HTTP/2 configuration.
+     *
+     * @return The HTTP/2 configuration.
+     * @since 4.6.0
+     */
+    @Nullable
+    public HttpClientConfiguration.Http2ClientConfiguration getHttp2Configuration() {
+        return null;
+    }
+
     /**
      * Configuration for the HTTP client connnection pool.
      */
@@ -1039,6 +1078,87 @@ public abstract class HttpClientConfiguration {
         }
     }
 
+    /**
+     * HTTP/2-specific client configuration.
+     *
+     * @since 4.6.0
+     */
+    public static class Http2ClientConfiguration {
+        /**
+         * The prefix to use for configuration.
+         */
+        public static final String PREFIX = "http2";
+
+        private Duration pingIntervalRead = null;
+
+        private Duration pingIntervalWrite = null;
+
+        private Duration pingIntervalIdle = null;
+
+        /**
+         * For HTTP/2 connections, the interval from the last inbound message to when an automated ping
+         * should be sent. This can be used to keep low-traffic connections alive.
+         *
+         * @return The timeout when to send a ping frame
+         */
+        @Nullable
+        public Duration getPingIntervalRead() {
+            return pingIntervalRead;
+        }
+
+        /**
+         * For HTTP/2 connections, the interval from the last inbound message to when an automated ping
+         * should be sent. This can be used to keep low-traffic connections alive.
+         *
+         * @param pingIntervalRead The timeout when to send a ping frame
+         */
+        public void setPingIntervalRead(@Nullable Duration pingIntervalRead) {
+            this.pingIntervalRead = pingIntervalRead;
+        }
+
+        /**
+         * For HTTP/2 connections, the interval from the last outbound message to when an automated ping
+         * should be sent. This can be used to keep low-traffic connections alive.
+         *
+         * @return The timeout when to send a ping frame
+         */
+        @Nullable
+        public Duration getPingIntervalWrite() {
+            return pingIntervalWrite;
+        }
+
+        /**
+         * For HTTP/2 connections, the interval from the last outbound message to when an automated ping
+         * should be sent. This can be used to keep low-traffic connections alive.
+         *
+         * @param pingIntervalWrite The timeout when to send a ping frame
+         */
+        public void setPingIntervalWrite(@Nullable Duration pingIntervalWrite) {
+            this.pingIntervalWrite = pingIntervalWrite;
+        }
+
+        /**
+         * For HTTP/2 connections, the interval from the last message (inbound or outbound) to when an
+         * automated ping should be sent. This can be used to keep low-traffic connections alive.
+         *
+         * @return The timeout when to send a ping frame
+         */
+        @Nullable
+        public Duration getPingIntervalIdle() {
+            return pingIntervalIdle;
+        }
+
+        /**
+         * For HTTP/2 connections, the interval from the last message (inbound or outbound) to when an
+         * automated ping should be sent. This can be used to keep low-traffic connections alive.
+         *
+         * @param pingIntervalIdle The timeout when to send a ping frame
+         */
+        public void setPingIntervalIdle(@Nullable Duration pingIntervalIdle) {
+            this.pingIntervalIdle = pingIntervalIdle;
+        }
+    }
+
     /**
      * The DNS resolution mode.
      *
diff --git a/http-client-core/src/main/java/io/micronaut/http/client/ServiceHttpClientConfiguration.java b/http-client-core/src/main/java/io/micronaut/http/client/ServiceHttpClientConfiguration.java
index cc5aefc3d4..e13105770c 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/ServiceHttpClientConfiguration.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/ServiceHttpClientConfiguration.java
@@ -30,6 +30,7 @@ import java.net.URI;
 import java.time.Duration;
 import java.util.Collections;
 import java.util.List;
+import java.util.Objects;
 import java.util.Optional;
 
 import static io.micronaut.http.client.ServiceHttpClientConfiguration.PREFIX;
@@ -69,6 +70,7 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
     private final String serviceId;
     private final ServiceConnectionPoolConfiguration connectionPoolConfiguration;
     private final ServiceWebSocketCompressionConfiguration webSocketCompressionConfiguration;
+    private final ServiceHttp2ClientConfiguration http2Configuration;
     private List<URI> urls = Collections.emptyList();
     private String healthCheckUri = DEFAULT_HEALTHCHECKURI;
     private boolean healthCheck = DEFAULT_HEALTHCHECK;
@@ -99,6 +101,7 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
             this.connectionPoolConfiguration = new ServiceConnectionPoolConfiguration();
         }
         this.webSocketCompressionConfiguration = new ServiceWebSocketCompressionConfiguration();
+        this.http2Configuration = new ServiceHttp2ClientConfiguration();
     }
 
     /**
@@ -108,7 +111,7 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
      * @param connectionPoolConfiguration The connection pool configuration
      * @param sslConfiguration The SSL configuration
      * @param defaultHttpClientConfiguration The default HTTP client configuration
-     * @deprecated Use {@link ServiceHttpClientConfiguration(String, ServiceConnectionPoolConfiguration, ServiceWebSocketCompressionConfiguration, ServiceSslClientConfiguration, HttpClientConfiguration)} instead.
+     * @deprecated Use {@link ServiceHttpClientConfiguration(String, ServiceConnectionPoolConfiguration, ServiceWebSocketCompressionConfiguration, ServiceHttp2ClientConfiguration , ServiceSslClientConfiguration, HttpClientConfiguration)} instead.
      */
     @Deprecated(since = "4.3.0")
     public ServiceHttpClientConfiguration(
@@ -127,12 +130,34 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
      * @param webSocketCompressionConfiguration The WebSocket compression configuration
      * @param sslConfiguration The SSL configuration
      * @param defaultHttpClientConfiguration The default HTTP client configuration
+     * @deprecated Use {@link ServiceHttpClientConfiguration(String, ServiceConnectionPoolConfiguration, ServiceWebSocketCompressionConfiguration, ServiceHttp2ClientConfiguration , ServiceSslClientConfiguration, HttpClientConfiguration)} instead.
+     */
+    @Deprecated(since = "4.6.0")
+    public ServiceHttpClientConfiguration(
+        @Parameter String serviceId,
+        @Nullable ServiceConnectionPoolConfiguration connectionPoolConfiguration,
+        @Nullable ServiceWebSocketCompressionConfiguration webSocketCompressionConfiguration,
+        @Nullable ServiceSslClientConfiguration sslConfiguration,
+        HttpClientConfiguration defaultHttpClientConfiguration) {
+        this(serviceId, connectionPoolConfiguration, webSocketCompressionConfiguration, new ServiceHttp2ClientConfiguration(), sslConfiguration, defaultHttpClientConfiguration);
+    }
+
+    /**
+     * Creates a new client configuration for the given service ID.
+     *
+     * @param serviceId The service id
+     * @param connectionPoolConfiguration The connection pool configuration
+     * @param webSocketCompressionConfiguration The WebSocket compression configuration
+     * @param http2Configuration The HTTP/2 configuration
+     * @param sslConfiguration The SSL configuration
+     * @param defaultHttpClientConfiguration The default HTTP client configuration
      */
     @Inject
     public ServiceHttpClientConfiguration(
             @Parameter String serviceId,
             @Nullable ServiceConnectionPoolConfiguration connectionPoolConfiguration,
             @Nullable ServiceWebSocketCompressionConfiguration webSocketCompressionConfiguration,
+            @Nullable ServiceHttpClientConfiguration.ServiceHttp2ClientConfiguration http2Configuration,
             @Nullable ServiceSslClientConfiguration sslConfiguration,
             HttpClientConfiguration defaultHttpClientConfiguration) {
         super(defaultHttpClientConfiguration);
@@ -140,16 +165,9 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
         if (sslConfiguration != null) {
             setSslConfiguration(sslConfiguration);
         }
-        if (connectionPoolConfiguration != null) {
-            this.connectionPoolConfiguration = connectionPoolConfiguration;
-        } else {
-            this.connectionPoolConfiguration = new ServiceConnectionPoolConfiguration();
-        }
-        if (webSocketCompressionConfiguration != null) {
-            this.webSocketCompressionConfiguration = webSocketCompressionConfiguration;
-        } else {
-            this.webSocketCompressionConfiguration = new ServiceWebSocketCompressionConfiguration();
-        }
+        this.connectionPoolConfiguration = Objects.requireNonNullElseGet(connectionPoolConfiguration, ServiceConnectionPoolConfiguration::new);
+        this.webSocketCompressionConfiguration = Objects.requireNonNullElseGet(webSocketCompressionConfiguration, ServiceWebSocketCompressionConfiguration::new);
+        this.http2Configuration = Objects.requireNonNullElseGet(http2Configuration, ServiceHttp2ClientConfiguration::new);
     }
 
     /**
@@ -280,6 +298,11 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
         return webSocketCompressionConfiguration;
     }
 
+    @Override
+    public ServiceHttp2ClientConfiguration getHttp2Configuration() {
+        return http2Configuration;
+    }
+
     /**
      * The default connection pool configuration.
      */
@@ -294,6 +317,13 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
     public static class ServiceWebSocketCompressionConfiguration extends WebSocketCompressionConfiguration {
     }
 
+    /**
+     * The service HTTP/2 configuration.
+     */
+    @ConfigurationProperties(WebSocketCompressionConfiguration.PREFIX)
+    public static class ServiceHttp2ClientConfiguration extends Http2ClientConfiguration {
+    }
+
     /**
      * The default connection pool configuration.
      */
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
index 70f3f40ad5..29adf6b9a2 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
@@ -18,7 +18,6 @@ package io.micronaut.http.client.netty;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.propagation.PropagatedContext;
 import io.micronaut.core.reflect.InstantiationUtils;
 import io.micronaut.core.util.StringUtils;
@@ -122,7 +121,6 @@ import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Base64;
 import java.util.List;
-import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
 import java.util.OptionalInt;
@@ -366,7 +364,7 @@ public class ConnectionManager {
             Object v = entry.getValue();
             if (v != null) {
                 String channelOption = entry.getKey();
-                bootstrap.option(ChannelOption.valueOf(NameUtils.underscoreSeparate(channelOption).toUpperCase(Locale.ENGLISH)), v);
+                bootstrap.option(ChannelOption.valueOf(channelOption), v);
             }
         }
 
@@ -1155,7 +1153,7 @@ public class ConnectionManager {
             ScheduledFuture<?> ttlFuture;
             volatile boolean windDownConnection = false;
 
-            private ResettableReadTimeoutHandler readTimeoutHandler;
+            private ReadTimeoutHandler readTimeoutHandler;
 
             ConnectionHolder(Channel channel, NettyClientCustomizer connectionCustomizer) {
                 this.channel = channel;
@@ -1167,7 +1165,7 @@ public class ConnectionManager {
              */
             private void resetReadTimeout() {
                 if (readTimeoutHandler != null) {
-                    readTimeoutHandler.resetReadTimeoutMn();
+                    readTimeoutHandler.resetReadTimeout();
                 }
             }
 
@@ -1182,7 +1180,7 @@ public class ConnectionManager {
                 // read timeout handles timeouts *during* a request
                 configuration.getReadTimeout()
                     .ifPresent(dur -> {
-                        ResettableReadTimeoutHandler readTimeoutHandler = new ResettableReadTimeoutHandler(dur.toNanos(), TimeUnit.NANOSECONDS) {
+                        ReadTimeoutHandler readTimeoutHandler = new ReadTimeoutHandler(dur.toNanos(), TimeUnit.NANOSECONDS) {
                             @Override
                             protected void readTimedOut(ChannelHandlerContext ctx) {
                                 if (hasLiveRequests()) {
@@ -1451,6 +1449,27 @@ public class ConnectionManager {
                         ChannelPipelineCustomizer.HANDLER_SSL :
                         ChannelPipelineCustomizer.HANDLER_HTTP2_CONNECTION
                 );
+
+                HttpClientConfiguration.Http2ClientConfiguration http2Configuration = configuration.getHttp2Configuration();
+                if (http2Configuration != null) {
+                    long read = toNanos(http2Configuration.getPingIntervalRead());
+                    long write = toNanos(http2Configuration.getPingIntervalWrite());
+                    long idle = toNanos(http2Configuration.getPingIntervalIdle());
+                    if (read > 0 || write > 0 || idle > 0) {
+                        channel.pipeline().addAfter(
+                            ChannelPipelineCustomizer.HANDLER_HTTP2_CONNECTION,
+                            ChannelPipelineCustomizer.HANDLER_HTTP2_PING_SENDER,
+                            new Http2PingSender(read, write, idle, TimeUnit.NANOSECONDS));
+                    }
+                }
+            }
+
+            private static long toNanos(@Nullable Duration timeout) {
+                if (timeout == null) {
+                    return 0;
+                }
+                long nanos = timeout.toNanos();
+                return nanos < 0 ? 0 : nanos;
             }
 
             @Override
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index e563539031..812e2721c3 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -1132,15 +1132,16 @@ public class DefaultHttpClient implements
             responsePublisher
         );
         Flux<io.micronaut.http.HttpResponse<?>> finalReactiveSequence = Flux.from(finalPublisher);
-        // apply timeout to flowable too in case a filter applied another policy
-        Optional<Duration> readTimeout = configuration.getReadTimeout();
-        if (readTimeout.isPresent()) {
-            // add an additional second, because generally the timeout should occur
-            // from the Netty request handling pipeline
-            final Duration rt = readTimeout.get();
-            if (!rt.isNegative()) {
-                Duration duration = rt.plus(Duration.ofSeconds(1));
-                finalReactiveSequence = finalReactiveSequence.timeout(duration) // todo: move to CM
+        Duration requestTimeout = configuration.getRequestTimeout();
+        if (requestTimeout == null) {
+            // for compatibility
+            requestTimeout = configuration.getReadTimeout()
+                .filter(d -> !d.isNegative())
+                .map(d -> d.plusSeconds(1)).orElse(null);
+        }
+        if (requestTimeout != null) {
+            if (!requestTimeout.isNegative()) {
+                finalReactiveSequence = finalReactiveSequence.timeout(requestTimeout)
                     .onErrorResume(throwable -> {
                         if (throwable instanceof TimeoutException) {
                             return Flux.error(ReadTimeoutException.TIMEOUT_EXCEPTION);
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/Http2PingSender.java b/http-client/src/main/java/io/micronaut/http/client/netty/Http2PingSender.java
new file mode 100644
index 0000000000..960cb9e160
--- /dev/null
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/Http2PingSender.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.client.netty;
+
+import io.micronaut.core.annotation.Internal;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;
+import io.netty.handler.timeout.IdleStateEvent;
+import io.netty.handler.timeout.IdleStateHandler;
+
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * IdleStateHandler that automatically sends HTTP/2 ping frames on timeout.
+ *
+ * @since 4.6.0
+ * @author Jonas Konrad
+ */
+@Internal
+final class Http2PingSender extends IdleStateHandler {
+    public Http2PingSender(long readerIdleTime, long writerIdleTime, long allIdleTime, TimeUnit unit) {
+        super(readerIdleTime, writerIdleTime, allIdleTime, unit);
+    }
+
+    @Override
+    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) {
+        resetReadTimeout();
+        resetWriteTimeout();
+
+        ctx.writeAndFlush(new DefaultHttp2PingFrame(ThreadLocalRandom.current().nextLong()), ctx.voidPromise());
+    }
+}
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ResettableReadTimeoutHandler.java b/http-client/src/main/java/io/micronaut/http/client/netty/ResettableReadTimeoutHandler.java
deleted file mode 100644
index 9368fcaf28..0000000000
--- a/http-client/src/main/java/io/micronaut/http/client/netty/ResettableReadTimeoutHandler.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright 2017-2023 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.client.netty;
-
-import io.micronaut.core.annotation.Internal;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerAdapter;
-import io.netty.handler.timeout.ReadTimeoutHandler;
-
-import java.util.NoSuchElementException;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Resettable version of {@link ReadTimeoutHandler}, as a workaround before
- * <a href="https://github.com/netty/netty/pull/13598">https://github.com/netty/netty/pull/13598</a>
- * is merged. (TODO: move to new API when that is merged)
- *
- * @author Jonas Konrad
- * @since 4.1.4
- */
-@Internal
-class ResettableReadTimeoutHandler extends ReadTimeoutHandler {
-    private static final Object FAKE_MESSAGE = new Object();
-
-    private ChannelHandlerContext ctx;
-    private boolean reading = false;
-
-    public ResettableReadTimeoutHandler(long timeout, TimeUnit unit) {
-        super(timeout, unit);
-    }
-
-    @Override
-    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
-        super.handlerAdded(ctx);
-        this.ctx = ctx;
-        ctx.pipeline().addAfter(ctx.name(), ctx.name() + "-reset-interceptor", NextInterceptor.INSTANCE);
-    }
-
-    @Override
-    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
-        super.handlerRemoved(ctx);
-        try {
-            ctx.pipeline().remove(ctx.name() + "-reset-interceptor");
-        } catch (NoSuchElementException ignored) {
-        }
-    }
-
-    @Override
-    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-        reading = true;
-        super.channelRead(ctx, msg);
-    }
-
-    @Override
-    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
-        reading = false;
-        super.channelReadComplete(ctx);
-    }
-
-    void resetReadTimeoutMn() {
-        if (!reading) {
-            try {
-                channelRead(ctx, FAKE_MESSAGE);
-                channelReadComplete(ctx);
-            } catch (Exception ignored) {
-            }
-        }
-    }
-
-    @Sharable
-    private static class NextInterceptor extends ChannelInboundHandlerAdapter {
-        static final NextInterceptor INSTANCE = new NextInterceptor();
-
-        @Override
-        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
-            if (msg == FAKE_MESSAGE) {
-                return;
-            }
-            super.channelRead(ctx, msg);
-        }
-    }
-}
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/ChannelPipelineCustomizer.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/ChannelPipelineCustomizer.java
index 69a2ab91bd..0c06fcf295 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/ChannelPipelineCustomizer.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/ChannelPipelineCustomizer.java
@@ -15,6 +15,7 @@
  */
 package io.micronaut.http.netty.channel;
 
+import io.micronaut.core.annotation.NextMajorVersion;
 import io.micronaut.core.annotation.NonNull;
 
 /**
@@ -24,6 +25,7 @@ import io.micronaut.core.annotation.NonNull;
  * @author graemerocher
  * @since 2.0.0
  */
+@NextMajorVersion("Move constants to a different class and delete this one")
 public interface ChannelPipelineCustomizer {
     String HANDLER_HTTP_COMPRESSOR = "http-compressor";
     String HANDLER_HTTP_DECOMPRESSOR = "http-decompressor";
@@ -51,6 +53,7 @@ public interface ChannelPipelineCustomizer {
     String HANDLER_MICRONAUT_HTTP_RESPONSE_FULL = "micronaut-http-response-full";
     String HANDLER_MICRONAUT_HTTP_RESPONSE = "micronaut-http-response";
     String HANDLER_HTTP2_CONNECTION = "http2-connection";
+    String HANDLER_HTTP2_PING_SENDER = "http2-ping-sender";
     String HANDLER_HTTP2_SETTINGS = "http2-settings";
     String HANDLER_HTTP2_UPGRADE_REQUEST = "http2-upgrade-request";
     String HANDLER_HTTP2_PROTOCOL_NEGOTIATOR = "http2-protocol-negotiator";
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupConfiguration.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupConfiguration.java
index f36d2e219d..1d5a4f39e7 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupConfiguration.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupConfiguration.java
@@ -50,7 +50,11 @@ public class DefaultEventLoopGroupConfiguration implements EventLoopGroupConfigu
      * @param numThreads            The number of threads
      * @param ioRatio               The IO ratio (optional)
      * @param preferNativeTransport Whether native transport is to be preferred
-     * @param executor              A named executor service to use (optional)
+     * @param executor              A named executor service to use for event loop threads
+     *                              (optional). This property is very specialized. In particular,
+     *                              it will <i>not</i> solve read timeouts or fix blocking
+     *                              operations on the event loop, in fact it may do the opposite.
+     *                              Don't use unless you really know what this does.
      * @param shutdownQuietPeriod   The shutdown quiet period
      * @param shutdownTimeout       The shutdown timeout (must be &gt;= shutdownQuietPeriod)
      */
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java
index bf4fb2da64..d26b2ff1f6 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java
@@ -1321,7 +1321,12 @@ public class NettyHttpServerConfiguration extends HttpServerConfiguration {
         }
 
         /**
-         * Sets the name of the executor.
+         * A named executor service to use for event loop threads
+         * (optional). This property is very specialized. In particular,
+         * it will <i>not</i> solve read timeouts or fix blocking
+         * operations on the event loop, in fact it may do the opposite.
+         * Don't use unless you really know what this does.
+         *
          * @param executor The executor
          */
         public void setExecutor(String executor) {
diff --git a/inject/src/main/java/io/micronaut/context/AnnotationReflectionUtils.java b/inject/src/main/java/io/micronaut/context/AnnotationReflectionUtils.java
deleted file mode 100644
index 2701a356a5..0000000000
--- a/inject/src/main/java/io/micronaut/context/AnnotationReflectionUtils.java
+++ /dev/null
@@ -1,454 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.context;
-
-import io.micronaut.core.annotation.AnnotationMetadata;
-import io.micronaut.core.annotation.Internal;
-import io.micronaut.core.annotation.NonNull;
-import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.reflect.ClassUtils;
-import io.micronaut.core.reflect.ReflectionUtils;
-import io.micronaut.core.type.Argument;
-import io.micronaut.inject.annotation.AnnotationMetadataHierarchy;
-import io.micronaut.inject.annotation.MutableAnnotationMetadata;
-
-import java.lang.annotation.Annotation;
-import java.lang.reflect.AnnotatedArrayType;
-import java.lang.reflect.AnnotatedElement;
-import java.lang.reflect.AnnotatedParameterizedType;
-import java.lang.reflect.AnnotatedType;
-import java.lang.reflect.AnnotatedWildcardType;
-import java.lang.reflect.Array;
-import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.Method;
-import java.lang.reflect.ParameterizedType;
-import java.lang.reflect.Type;
-import java.lang.reflect.TypeVariable;
-import java.lang.reflect.WildcardType;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.stream.Stream;
-
-/**
- * The annotation reflection utils.
- *
- * @author Denis Stepanov
- * @since 4.6.0
- */
-@Internal
-public final class AnnotationReflectionUtils {
-
-    private AnnotationReflectionUtils() {
-    }
-
-    /**
-     * Find implementation as an argument with types and annotations.
-     *
-     * @param runtimeGenericType The implementation class of the interface
-     * @param rawSuperType       The implementedType type - interface or an abstract class
-     * @return The argument of the interface with types and annotations
-     * @since 4.6
-     */
-    @Nullable
-    public static <T> Argument<T> resolveGenericToArgument(@NonNull Class<?> runtimeGenericType,
-                                                           @NonNull Class<T> rawSuperType) {
-        if (ClassUtils.REFLECTION_LOGGER.isDebugEnabled()) {
-            ClassUtils.REFLECTION_LOGGER.debug("Reflectively finding a generic argument of '{}' from the implementation '{}'",
-                rawSuperType, runtimeGenericType);
-        }
-
-        AnnotatedType st = findAnnotatedSupertype(new SimpleAnnotatedType(runtimeGenericType), rawSuperType);
-        if (st == null) {
-            return null;
-        }
-        //noinspection unchecked
-        return (Argument<T>) toArgument(st);
-    }
-
-    /**
-     * Find the {@link AnnotatedType} in {@code subType}'s type hierarchy that has the raw type
-     * {@code superType}. For example, for a {@code class A extends AbstractList<@Nullable String>},
-     * {@code findAnnotatedSupertype(A, Collection.class)} would return
-     * {@code Collection<@Nullable String>}.
-     * <p>
-     * Note that this can return special {@link AnnotatedType} instances like
-     * {@link LazySubstitutingType} or {@link MergedAnnotatedType}.
-     *
-     * @param subType   The type that should have its type hierarchy analyzed
-     * @param superType The supertype that we want to get the type information for
-     * @return The annotated generic supertype, with the same raw type as {@code superType}
-     */
-    @Nullable
-    private static AnnotatedType findAnnotatedSupertype(AnnotatedType subType, Class<?> superType) {
-        Class<?> raw = getRawType(subType.getType());
-        if (superType == raw) {
-            return subType;
-        } else if (!superType.isAssignableFrom(raw)) {
-            return null;
-        }
-
-        Map<TypeVariable<?>, AnnotatedType> substitutions = new HashMap<>();
-        collectTypeSubstitutions(subType, substitutions);
-
-        Stream<AnnotatedType> supertypes = getSupertypes(raw);
-        if (!substitutions.isEmpty()) {
-            supertypes = supertypes.map(t -> new LazySubstitutingType(t, substitutions));
-        }
-        List<AnnotatedType> candidates = supertypes
-            .map(at -> findAnnotatedSupertype(at, superType))
-            .filter(Objects::nonNull)
-            .toList();
-        if (candidates.isEmpty()) {
-            return null;
-        } else if (candidates.size() == 1) {
-            return candidates.get(0);
-        } else {
-            return new MergedAnnotatedType(candidates.get(0), candidates);
-        }
-    }
-
-    /**
-     * Collect the necessary type substitutions into the {@code substitutions} map. For example,
-     * if {@code type} is {@code Map<String, List<Integer>>}, then the collected substitutions
-     * would be {@code K -> String, V -> List<Integer>} (both K and V come from {@link Map}).
-     *
-     * @param type          The type to get the substitutions from. This only makes sense to be
-     *                      some form of {@link ParameterizedType}
-     * @param substitutions The output map
-     */
-    private static void collectTypeSubstitutions(AnnotatedType type, Map<TypeVariable<?>, AnnotatedType> substitutions) {
-        if (type instanceof AnnotatedParameterizedType apt) {
-            TypeVariable<? extends Class<?>>[] variables = getRawType(type.getType()).getTypeParameters();
-            AnnotatedType[] args = apt.getAnnotatedActualTypeArguments();
-            if (variables.length == args.length) {
-                for (int i = 0; i < args.length; i++) {
-                    substitutions.put(variables[i], args[i]);
-                }
-            }
-            if (apt.getAnnotatedOwnerType() instanceof AnnotatedParameterizedType owner) {
-                collectTypeSubstitutions(owner, substitutions);
-            }
-        } else if (type instanceof LazySubstitutingType lst) {
-            Map<TypeVariable<?>, AnnotatedType> intermediate = new HashMap<>();
-            collectTypeSubstitutions(lst.actual, intermediate);
-            intermediate.replaceAll((k, v) -> new LazySubstitutingType(v, lst.substitutions));
-            substitutions.putAll(intermediate);
-        } else if (type instanceof MergedAnnotatedType mat) {
-            collectTypeSubstitutions(mat.actual, substitutions);
-        } else {
-            collectTypeSubstitutions(type.getType(), substitutions);
-        }
-    }
-
-    /**
-     * Collect the necessary type substitutions into the {@code substitutions} map. For example,
-     * if {@code type} is {@code Map<String, List<Integer>>}, then the collected substitutions
-     * would be {@code K -> String, V -> List<Integer>} (both K and V come from {@link Map}).
-     *
-     * @param type          The type to get the substitutions from. This only makes sense to be
-     *                      some form of {@link ParameterizedType}
-     * @param substitutions The output map
-     */
-    private static void collectTypeSubstitutions(Type type, Map<TypeVariable<?>, AnnotatedType> substitutions) {
-        if (type instanceof ParameterizedType pt) {
-            TypeVariable<? extends Class<?>>[] variables = getRawType(pt.getRawType()).getTypeParameters();
-            Type[] args = pt.getActualTypeArguments();
-            if (variables.length == args.length) {
-                for (int i = 0; i < args.length; i++) {
-                    substitutions.put(variables[i], new SimpleAnnotatedType(args[i]));
-                }
-            }
-        }
-    }
-
-    private static AnnotationMetadata annotationMetadataOf(AnnotatedElement annotatedElement) {
-        Annotation[] annotations = annotatedElement.getAnnotations();
-        if (annotations.length == 0) {
-            return AnnotationMetadata.EMPTY_METADATA;
-        }
-        MutableAnnotationMetadata mutableAnnotationMetadata = new MutableAnnotationMetadata();
-        for (Annotation annotation : annotations) {
-            Map<CharSequence, Object> values = new LinkedHashMap<>();
-            Class<? extends Annotation> annotationType = annotation.annotationType();
-            Method[] methods = annotationType.getMethods();
-            for (Method method : methods) {
-                if (!method.getDeclaringClass().equals(annotationType)) {
-                    continue;
-                }
-                Object value = ReflectionUtils.invokeMethod(annotation, method);
-                if (value != null) {
-                    values.put(method.getName(), value);
-                }
-            }
-            mutableAnnotationMetadata.addAnnotation(annotationType.getName(), values);
-        }
-        return mutableAnnotationMetadata;
-    }
-
-    /**
-     * Convert the given annotated type to an {@link Argument}.
-     *
-     * @param annotatedType The type to convert
-     * @return The converted argument
-     */
-    private static Argument<?> toArgument(AnnotatedType annotatedType) {
-        return toArgument(null, annotatedType, Map.of());
-    }
-
-    /**
-     * Convert the given annotated type to an {@link Argument}.
-     *
-     * @param name          The name of the returned {@link Argument}, or {@code null}
-     * @param annotatedType The type to convert
-     * @param substitutions Type variables to replace
-     * @return The converted argument
-     */
-    private static Argument<?> toArgument(@Nullable String name, AnnotatedType annotatedType, Map<TypeVariable<?>, AnnotatedType> substitutions) {
-        if (annotatedType instanceof AnnotatedParameterizedType apt) {
-            Class<?> rawType = getRawType(apt.getType());
-            TypeVariable<? extends Class<?>>[] variables = rawType.getTypeParameters();
-            Argument<?>[] typeArgs = new Argument[apt.getAnnotatedActualTypeArguments().length];
-            for (int i = 0; i < typeArgs.length; i++) {
-                typeArgs[i] = toArgument(variables.length > i ? variables[i].getName() : null, apt.getAnnotatedActualTypeArguments()[i], substitutions);
-            }
-            return Argument.of(getRawType(apt.getType()), name, annotationMetadataOf(apt), typeArgs);
-        } else if (annotatedType instanceof AnnotatedArrayType aat) {
-            Argument<?> component = toArgument(null, aat.getAnnotatedGenericComponentType(), substitutions);
-            AnnotationMetadata componentAnnotations = component.getAnnotationMetadata();
-            AnnotationMetadata ourAnnotations = annotationMetadataOf(aat);
-            AnnotationMetadata combined = combine(componentAnnotations, ourAnnotations);
-            return Argument.of(
-                Array.newInstance(component.getType(), 0).getClass(),
-                name,
-                combined
-            );
-        } else if (annotatedType instanceof AnnotatedWildcardType awt) {
-            Argument<?> upper = toArgument(null, awt.getAnnotatedUpperBounds()[0], substitutions);
-            return Argument.of(upper.getType(), name, combine(upper.getAnnotationMetadata(), annotationMetadataOf(annotatedType)), upper.getTypeParameters());
-        } else if (annotatedType instanceof LazySubstitutingType lst) {
-            Map<TypeVariable<?>, AnnotatedType> newSubstitutions;
-            if (substitutions.isEmpty()) {
-                newSubstitutions = lst.substitutions;
-            } else {
-                newSubstitutions = new HashMap<>();
-                newSubstitutions.putAll(substitutions);
-                newSubstitutions.putAll(lst.substitutions);
-            }
-            return toArgument(name, lst.actual, newSubstitutions);
-        } else if (annotatedType instanceof MergedAnnotatedType mat) {
-            Argument<?> argument = toArgument(null, mat.actual, substitutions);
-            return Argument.of(
-                argument.getType(),
-                name,
-                combine(argument.getAnnotationMetadata(), annotationMetadataOf(mat)),
-                argument.getTypeParameters()
-            );
-        } else {
-            Argument<?> simple = toArgument(null, annotatedType.getType(), substitutions);
-            AnnotationMetadata annotations = annotationMetadataOf(annotatedType);
-            return Argument.of(simple.getType(), name, combine(annotations, simple.getAnnotationMetadata()), simple.getTypeParameters());
-        }
-    }
-
-    /**
-     * Convert the given non-annotated type to an {@link Argument}.
-     *
-     * @param name          The name of the returned {@link Argument}, or {@code null}
-     * @param type          The type to convert
-     * @param substitutions Type variables to replace
-     * @return The converted argument
-     */
-    private static Argument<?> toArgument(@Nullable String name, Type type, Map<TypeVariable<?>, AnnotatedType> substitutions) {
-        if (type instanceof ParameterizedType pt) {
-            Class<?> rawType = getRawType(pt.getRawType());
-            TypeVariable<? extends Class<?>>[] variables = rawType.getTypeParameters();
-            Argument<?>[] typeArgs = new Argument[pt.getActualTypeArguments().length];
-            for (int i = 0; i < typeArgs.length; i++) {
-                typeArgs[i] = toArgument(variables.length > i ? variables[i].getName() : null, pt.getActualTypeArguments()[i], substitutions);
-            }
-            return Argument.of(rawType, typeArgs);
-        } else if (type instanceof GenericArrayType gat) {
-            Argument<?> component = toArgument(null, gat.getGenericComponentType(), substitutions);
-            return Argument.of(
-                Array.newInstance(component.getType(), 0).getClass(),
-                name,
-                component.getAnnotationMetadata()
-            );
-        } else if (type instanceof WildcardType wt) {
-            return toArgument(name, wt.getUpperBounds()[0], substitutions);
-        } else if (type instanceof Class<?> cl) {
-            return Argument.of(cl, name);
-        } else if (type instanceof TypeVariable<?> tv) {
-            AnnotatedType sub = substitutions.get(tv);
-            if (sub == null) {
-                return toArgument(name, tv.getAnnotatedBounds()[0], Map.of());
-            } else {
-                return toArgument(name, sub, Map.of());
-            }
-        } else {
-            throw new IllegalArgumentException("Unsupported type " + type.getClass().getName());
-        }
-    }
-
-    private static AnnotationMetadata combine(AnnotationMetadata left, AnnotationMetadata right) {
-        if (left.isEmpty()) {
-            return right;
-        } else if (right.isEmpty()) {
-            return left;
-        } else {
-            return new AnnotationMetadataHierarchy(true, left, right);
-        }
-    }
-
-    /**
-     * Get all annotated supertypes of a class or interface.
-     *
-     * @param cl The class
-     * @return A stream of supertypes
-     */
-    private static Stream<AnnotatedType> getSupertypes(Class<?> cl) {
-        Stream<AnnotatedType> itf = Stream.of(cl.getAnnotatedInterfaces());
-        if (cl.isInterface()) {
-            return itf;
-        }
-        return Stream.concat(Stream.of(cl.getAnnotatedSuperclass()), itf);
-    }
-
-    /**
-     * Get the raw type of a given complex type.
-     *
-     * @param type The complex type
-     * @return The raw type
-     */
-    private static Class<?> getRawType(Type type) {
-        if (type instanceof Class<?> cl) {
-            return cl;
-        } else if (type instanceof ParameterizedType ptype) {
-            return getRawType(ptype.getRawType());
-        } else if (type instanceof TypeVariable<?> tv) {
-            return getRawType(tv.getBounds()[0]);
-        } else if (type instanceof WildcardType wt) {
-            return getRawType(wt.getUpperBounds()[0]);
-        } else if (type instanceof GenericArrayType gat) {
-            Class<?> rawComponentType = getRawType(gat.getGenericComponentType());
-            return Array.newInstance(rawComponentType, 0).getClass();
-        } else {
-            throw new IllegalArgumentException("Unsupported type " + type.getClass().getName());
-        }
-    }
-
-    /**
-     * Wrapper around a {@link AnnotatedType} to signals that certain {@link TypeVariable}s should
-     * be substituted lazily. For example, if {@code actual} is {@code List<T>} and
-     * {@code substitutions} is {@code T -> @Ann1 String}, users should treat this type as
-     * {@code List<@Ann1 String>}.
-     *
-     * @param actual        The type to delegate to
-     * @param substitutions Substitutions to apply to the type
-     */
-    private record LazySubstitutingType(AnnotatedType actual,
-                                        Map<TypeVariable<?>, AnnotatedType> substitutions) implements AnnotatedType {
-        @Override
-        public Type getType() {
-            return actual.getType();
-        }
-
-        @Override
-        public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
-            return actual.getAnnotation(annotationClass);
-        }
-
-        @Override
-        public Annotation[] getAnnotations() {
-            return actual.getAnnotations();
-        }
-
-        @Override
-        public Annotation[] getDeclaredAnnotations() {
-            return actual.getDeclaredAnnotations();
-        }
-    }
-
-    /**
-     * Simple, annotation-less {@link AnnotatedType} implementation.
-     *
-     * @param actual The type
-     */
-    private record SimpleAnnotatedType(Type actual) implements AnnotatedType {
-        @Override
-        public Type getType() {
-            return actual;
-        }
-
-        @Override
-        public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
-            return null;
-        }
-
-        @Override
-        public Annotation[] getAnnotations() {
-            return new Annotation[0];
-        }
-
-        @Override
-        public Annotation[] getDeclaredAnnotations() {
-            return new Annotation[0];
-        }
-    }
-
-    /**
-     * This record represents an {@link AnnotatedType} that merges the annotations of multiple
-     * different types. e.g. when {@code class A implements @Ann1 I {}},
-     * {@code class B extends A implements @Ann2 I {}}, this record is used to create a type
-     * {@code @Ann1 @Ann2 I} that represents the annotations of both {@code implements I} clauses.
-     *
-     * @param actual            The type to delegate to for {@link #getType()}
-     * @param annotationSources Elements to take annotations from
-     */
-    private record MergedAnnotatedType(AnnotatedType actual,
-                                       List<AnnotatedType> annotationSources) implements AnnotatedType {
-        @Override
-        public Type getType() {
-            return actual.getType();
-        }
-
-        @Override
-        public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
-            return annotationSources.stream()
-                .map(s -> s.getAnnotation(annotationClass))
-                .filter(Objects::nonNull)
-                .findFirst().orElse(null);
-        }
-
-        @Override
-        public Annotation[] getAnnotations() {
-            return annotationSources.stream()
-                .flatMap(s -> Arrays.stream(s.getAnnotations()))
-                .toArray(Annotation[]::new);
-        }
-
-        @Override
-        public Annotation[] getDeclaredAnnotations() {
-            return annotationSources.stream()
-                .flatMap(s -> Arrays.stream(s.getDeclaredAnnotations()))
-                .toArray(Annotation[]::new);
-        }
-    }
-}
