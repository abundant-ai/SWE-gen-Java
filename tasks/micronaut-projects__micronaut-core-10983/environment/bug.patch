diff --git a/context-propagation/src/test/groovy/io/micronaut/context/AnnotationReflectionUtilsSpec.groovy b/context-propagation/src/test/groovy/io/micronaut/context/AnnotationReflectionUtilsSpec.groovy
new file mode 100644
index 0000000000..c38ff546d0
--- /dev/null
+++ b/context-propagation/src/test/groovy/io/micronaut/context/AnnotationReflectionUtilsSpec.groovy
@@ -0,0 +1,201 @@
+package io.micronaut.context
+
+import io.micronaut.core.annotation.Nullable
+import spock.lang.PendingFeature
+import spock.lang.Specification
+
+import java.lang.annotation.ElementType
+import java.lang.annotation.Retention
+import java.lang.annotation.RetentionPolicy
+import java.lang.annotation.Target
+import java.util.function.BiFunction
+import java.util.function.Consumer
+
+class AnnotationReflectionUtilsSpec extends Specification {
+
+    void "test generic"() {
+        given:
+            Consumer<String> consumer = new Consumer<String>() {
+                @Override
+                void accept(String s) {
+                }
+            }
+
+        when:
+            def argument = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), Consumer)
+
+        then:
+            argument.type == Consumer
+            argument.getTypeVariable("T").get().type == String
+    }
+
+    void "test generic 1 "() {
+        given:
+            Consumer<String> consumer = new @MyTypeUseAnnotation Consumer<@Nullable String>() {
+                @Override
+                void accept(String s) {
+                }
+            }
+
+        when:
+            def argument = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), Consumer)
+
+        then:
+            argument.type == Consumer
+            argument.annotationMetadata.annotationNames.isEmpty()
+            argument.getTypeVariable("T").get().type == String
+            argument.getTypeVariable("T").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.core.annotation.Nullable"]
+    }
+
+    void "test generic 2"() {
+        given:
+            Consumer<String> consumer = new AbstractConsumer<@Nullable String>() {
+            }
+
+        when:
+            def argumentAbstractConsumer = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), AbstractConsumer)
+
+        then:
+            argumentAbstractConsumer.type == AbstractConsumer
+            argumentAbstractConsumer.annotationMetadata.annotationNames.isEmpty()
+            argumentAbstractConsumer.getTypeVariable("T").get().type == String
+            argumentAbstractConsumer.getTypeVariable("T").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.core.annotation.Nullable"]
+
+        when:
+            def argumentConsumer = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), Consumer)
+
+        then:
+            argumentConsumer.type == Consumer
+            argumentConsumer.annotationMetadata.annotationNames.isEmpty()
+            argumentConsumer.getTypeVariable("T").get().type == String
+            argumentConsumer.getTypeVariable("T").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.core.annotation.Nullable"]
+    }
+
+    void "test generic 3"() {
+        given:
+            Consumer<String> consumer = new AbstractConsumer2<@Nullable String>() {
+            }
+
+        when:
+            def argumentConsumer = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), Consumer)
+        then:
+            argumentConsumer.type == Consumer
+            argumentConsumer.annotationMetadata.annotationNames.toList() == ["io.micronaut.context.MyTypeUseAnnotation"]
+            argumentConsumer.getTypeVariable("T").get().type == String
+            argumentConsumer.getTypeVariable("T").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.core.annotation.Nullable"]
+
+        when:
+            def argumentAbstractConsumer = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), AbstractConsumer)
+        then:
+            argumentAbstractConsumer.type == AbstractConsumer
+            argumentAbstractConsumer.annotationMetadata.annotationNames.isEmpty()
+            argumentAbstractConsumer.getTypeVariable("T").get().type == String
+            argumentAbstractConsumer.getTypeVariable("T").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.core.annotation.Nullable"]
+
+        when:
+            def argumentAbstractConsumer2 = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), AbstractConsumer2)
+        then:
+            argumentAbstractConsumer2.type == AbstractConsumer2
+            argumentAbstractConsumer2.annotationMetadata.annotationNames.isEmpty()
+            argumentAbstractConsumer2.getTypeVariable("T").get().type == String
+            argumentAbstractConsumer2.getTypeVariable("T").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.core.annotation.Nullable"]
+    }
+
+    void "test generic 4"() {
+        given:
+            BiFunction<String, Integer, Long> consumer = new BiFunction<@Nullable String, @MyTypeUseAnnotation Integer, Long>() {
+                @Override
+                Long apply(String s, Integer integer) {
+                    return null
+                }
+            }
+
+        when:
+            def argument = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), BiFunction)
+
+        then:
+            argument.type == BiFunction
+            argument.annotationMetadata.annotationNames.isEmpty()
+            argument.getTypeVariable("T").get().type == String
+            argument.getTypeVariable("T").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.core.annotation.Nullable"]
+            argument.getTypeVariable("U").get().type == Integer
+            argument.getTypeVariable("U").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.context.MyTypeUseAnnotation"]
+            argument.getTypeVariable("R").get().type == Long
+            argument.getTypeVariable("R").get().annotationMetadata.annotationNames.isEmpty()
+    }
+
+    @PendingFeature // doesn't work with groovy for some reason
+    void "test array annotations"() {
+        given:
+        Consumer<String[]> consumer = new Consumer<@T1 String @T2 []>() {
+            @Override
+            void accept(String[] s) {
+            }
+        }
+
+        when:
+        def argument = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), Consumer)
+
+        then:
+        argument.type == Consumer
+        argument.annotationMetadata.annotationNames.isEmpty()
+        argument.getTypeVariable("T").get().type == String[]
+        argument.getTypeVariable("T").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.context.T1", "io.micronaut.context.T2"]
+    }
+
+    void "test indirect"() {
+        given:
+        Consumer<String> consumer = new AbstractConsumer3<@T3 String>() {
+            @Override
+            void accept(String s) {
+            }
+        }
+
+        when:
+        def argument = AnnotationReflectionUtils.resolveGenericToArgument(consumer.getClass(), Consumer)
+
+        then:
+        argument.type == Consumer
+        argument.annotationMetadata.annotationNames.isEmpty()
+        argument.getTypeVariable("T").get().type == String
+        argument.getTypeVariable("T").get().annotationMetadata.annotationNames.toList() == ["io.micronaut.context.T3"]
+    }
+}
+
+abstract class AbstractConsumer<T> implements Consumer<T> {
+    @Override
+    void accept(T s) {
+    }
+}
+
+abstract class AbstractConsumer2<T> extends AbstractConsumer<T> implements @MyTypeUseAnnotation Consumer<T> {
+    @Override
+    void accept(T s) {
+    }
+}
+
+abstract class AbstractConsumer3<T> extends AbstractConsumer<T> {
+    @Override
+    void accept(T s) {
+    }
+}
+
+@Target(ElementType.TYPE_USE)
+@Retention(RetentionPolicy.RUNTIME)
+@interface MyTypeUseAnnotation {
+}
+
+@Target(ElementType.TYPE_USE)
+@Retention(RetentionPolicy.RUNTIME)
+@interface T1 {
+}
+
+@Target(ElementType.TYPE_USE)
+@Retention(RetentionPolicy.RUNTIME)
+@interface T2 {
+}
+
+@Target(ElementType.TYPE_USE)
+@Retention(RetentionPolicy.RUNTIME)
+@interface T3 {
+}
diff --git a/http-client-core/src/main/java/io/micronaut/http/client/DefaultHttpClientConfiguration.java b/http-client-core/src/main/java/io/micronaut/http/client/DefaultHttpClientConfiguration.java
index c82d28f2c2..3aa14fbf48 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/DefaultHttpClientConfiguration.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/DefaultHttpClientConfiguration.java
@@ -40,7 +40,6 @@ public class DefaultHttpClientConfiguration extends HttpClientConfiguration {
     public static final String PREFIX = "micronaut.http.client";
     private final DefaultConnectionPoolConfiguration connectionPoolConfiguration;
     private final DefaultWebSocketCompressionConfiguration webSocketCompressionConfiguration;
-    private final DefaultHttp2ClientConfiguration http2Configuration;
 
     /**
      * Default constructor.
@@ -48,47 +47,31 @@ public class DefaultHttpClientConfiguration extends HttpClientConfiguration {
     public DefaultHttpClientConfiguration() {
         this.connectionPoolConfiguration = new DefaultConnectionPoolConfiguration();
         this.webSocketCompressionConfiguration = new DefaultWebSocketCompressionConfiguration();
-        this.http2Configuration = new DefaultHttp2ClientConfiguration();
     }
 
     /**
      * @param connectionPoolConfiguration The connection pool configuration
      * @param applicationConfiguration The application configuration
-     * @deprecated Use {@link DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration, DefaultWebSocketCompressionConfiguration, DefaultHttp2ClientConfiguration , ApplicationConfiguration)} instead.
+     * @deprecated Use {@link DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration, DefaultWebSocketCompressionConfiguration, ApplicationConfiguration)} instead.
      */
     @Deprecated(since = "4.3.0")
     public DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration connectionPoolConfiguration, ApplicationConfiguration applicationConfiguration) {
         this(connectionPoolConfiguration, new DefaultWebSocketCompressionConfiguration(), applicationConfiguration);
     }
 
-    /**
-     * @param connectionPoolConfiguration The connection pool configuration
-     * @param webSocketCompressionConfiguration The WebSocket compression configuration
-     * @param applicationConfiguration The application configuration
-     * @deprecated Use {@link DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration, DefaultWebSocketCompressionConfiguration, DefaultHttp2ClientConfiguration , ApplicationConfiguration)} instead.
-     */
-    @Deprecated(since = "4.6.0")
-    public DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration connectionPoolConfiguration,
-                                          DefaultWebSocketCompressionConfiguration webSocketCompressionConfiguration,
-                                          ApplicationConfiguration applicationConfiguration) {
-        this(connectionPoolConfiguration, webSocketCompressionConfiguration, new DefaultHttp2ClientConfiguration(), applicationConfiguration);
-    }
 
     /**
      * @param connectionPoolConfiguration The connection pool configuration
      * @param webSocketCompressionConfiguration The WebSocket compression configuration
-     * @param http2Configuration The HTTP/2 configuration
      * @param applicationConfiguration The application configuration
      */
     @Inject
     public DefaultHttpClientConfiguration(DefaultConnectionPoolConfiguration connectionPoolConfiguration,
                                           DefaultWebSocketCompressionConfiguration webSocketCompressionConfiguration,
-                                          DefaultHttp2ClientConfiguration http2Configuration,
                                           ApplicationConfiguration applicationConfiguration) {
         super(applicationConfiguration);
         this.connectionPoolConfiguration = connectionPoolConfiguration;
         this.webSocketCompressionConfiguration = webSocketCompressionConfiguration;
-        this.http2Configuration = http2Configuration;
     }
 
     @Override
@@ -113,11 +96,6 @@ public class DefaultHttpClientConfiguration extends HttpClientConfiguration {
         }
     }
 
-    @Override
-    public Http2ClientConfiguration getHttp2Configuration() {
-        return http2Configuration;
-    }
-
     /**
      * The default connection pool configuration.
      */
@@ -135,13 +113,4 @@ public class DefaultHttpClientConfiguration extends HttpClientConfiguration {
     @Primary
     public static class DefaultWebSocketCompressionConfiguration extends WebSocketCompressionConfiguration {
     }
-
-    /**
-     * The default HTTP/2 configuration.
-     */
-    @ConfigurationProperties(Http2ClientConfiguration.PREFIX)
-    @BootstrapContextCompatible
-    @Primary
-    public static class DefaultHttp2ClientConfiguration extends Http2ClientConfiguration {
-    }
 }
diff --git a/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java b/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
index eba4b60c88..377a8dfc1e 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/HttpClientConfiguration.java
@@ -16,7 +16,6 @@
 package io.micronaut.http.client;
 
 import io.micronaut.context.env.CachedEnvironment;
-import io.micronaut.core.annotation.NextMajorVersion;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.convert.format.ReadableBytes;
@@ -128,8 +127,6 @@ public abstract class HttpClientConfiguration {
 
     private Duration readTimeout = Duration.ofSeconds(DEFAULT_READ_TIMEOUT_SECONDS);
 
-    private Duration requestTimeout = null;
-
     private Duration readIdleTimeout = Duration.of(DEFAULT_READ_IDLE_TIMEOUT_MINUTES, ChronoUnit.MINUTES);
 
     private Duration connectionPoolIdleTimeout = DEFAULT_CONNECTION_POOL_IDLE_TIMEOUT_SECONDS == 0 ? null : Duration.ofSeconds(DEFAULT_CONNECTION_POOL_IDLE_TIMEOUT_SECONDS);
@@ -416,36 +413,12 @@ public abstract class HttpClientConfiguration {
     }
 
     /**
-     * The request timeout for non-streaming requests. This is the maximum time until the response
-     * must be completely received. Defaults to one second more than read-timeout.
-     *
-     * @return The request timeout
-     * @since 4.6.0
-     */
-    @Nullable
-    @NextMajorVersion("Set a default that isn't just requestTimeout+1 in DefaultHttpClient")
-    public Duration getRequestTimeout() {
-        return requestTimeout;
-    }
-
-    /**
-     * The request timeout for non-streaming requests. This is the maximum time until the response
-     * must be completely received. Defaults to one second more than read-timeout.
-     *
-     * @param requestTimeout The request timeout
-     */
-    public void setRequestTimeout(@Nullable Duration requestTimeout) {
-        this.requestTimeout = requestTimeout;
-    }
-
-    /**
-     * For WebSockets, the {@link #getReadTimeout()} method does not apply instead a configurable
+     * For streaming requests and WebSockets, the {@link #getReadTimeout()} method does not apply instead a configurable
      * idle timeout is applied.
      * [available in the Netty HTTP client]
      *
      * @return The default amount of time to allow read operation connections  to remain idle
      */
-    @NextMajorVersion("Rename to websocket-idle-timeout")
     public Optional<Duration> getReadIdleTimeout() {
         return Optional.ofNullable(readIdleTimeout);
     }
@@ -525,8 +498,7 @@ public abstract class HttpClientConfiguration {
     }
 
     /**
-     * For WebSockets, the {@link #getReadTimeout()} method does not apply instead a configurable
-     * idle timeout is applied.
+     * Sets the max read idle time for streaming requests. Default value ({@value io.micronaut.http.client.HttpClientConfiguration#DEFAULT_READ_IDLE_TIMEOUT_MINUTES} minutes).
      *
      * @param readIdleTimeout The read idle time
      */
@@ -861,17 +833,6 @@ public abstract class HttpClientConfiguration {
         this.addressResolverGroupName = addressResolverGroupName;
     }
 
-    /**
-     * Obtains the HTTP/2 configuration.
-     *
-     * @return The HTTP/2 configuration.
-     * @since 4.6.0
-     */
-    @Nullable
-    public HttpClientConfiguration.Http2ClientConfiguration getHttp2Configuration() {
-        return null;
-    }
-
     /**
      * Configuration for the HTTP client connnection pool.
      */
@@ -1078,87 +1039,6 @@ public abstract class HttpClientConfiguration {
         }
     }
 
-    /**
-     * HTTP/2-specific client configuration.
-     *
-     * @since 4.6.0
-     */
-    public static class Http2ClientConfiguration {
-        /**
-         * The prefix to use for configuration.
-         */
-        public static final String PREFIX = "http2";
-
-        private Duration pingIntervalRead = null;
-
-        private Duration pingIntervalWrite = null;
-
-        private Duration pingIntervalIdle = null;
-
-        /**
-         * For HTTP/2 connections, the interval from the last inbound message to when an automated ping
-         * should be sent. This can be used to keep low-traffic connections alive.
-         *
-         * @return The timeout when to send a ping frame
-         */
-        @Nullable
-        public Duration getPingIntervalRead() {
-            return pingIntervalRead;
-        }
-
-        /**
-         * For HTTP/2 connections, the interval from the last inbound message to when an automated ping
-         * should be sent. This can be used to keep low-traffic connections alive.
-         *
-         * @param pingIntervalRead The timeout when to send a ping frame
-         */
-        public void setPingIntervalRead(@Nullable Duration pingIntervalRead) {
-            this.pingIntervalRead = pingIntervalRead;
-        }
-
-        /**
-         * For HTTP/2 connections, the interval from the last outbound message to when an automated ping
-         * should be sent. This can be used to keep low-traffic connections alive.
-         *
-         * @return The timeout when to send a ping frame
-         */
-        @Nullable
-        public Duration getPingIntervalWrite() {
-            return pingIntervalWrite;
-        }
-
-        /**
-         * For HTTP/2 connections, the interval from the last outbound message to when an automated ping
-         * should be sent. This can be used to keep low-traffic connections alive.
-         *
-         * @param pingIntervalWrite The timeout when to send a ping frame
-         */
-        public void setPingIntervalWrite(@Nullable Duration pingIntervalWrite) {
-            this.pingIntervalWrite = pingIntervalWrite;
-        }
-
-        /**
-         * For HTTP/2 connections, the interval from the last message (inbound or outbound) to when an
-         * automated ping should be sent. This can be used to keep low-traffic connections alive.
-         *
-         * @return The timeout when to send a ping frame
-         */
-        @Nullable
-        public Duration getPingIntervalIdle() {
-            return pingIntervalIdle;
-        }
-
-        /**
-         * For HTTP/2 connections, the interval from the last message (inbound or outbound) to when an
-         * automated ping should be sent. This can be used to keep low-traffic connections alive.
-         *
-         * @param pingIntervalIdle The timeout when to send a ping frame
-         */
-        public void setPingIntervalIdle(@Nullable Duration pingIntervalIdle) {
-            this.pingIntervalIdle = pingIntervalIdle;
-        }
-    }
-
     /**
      * The DNS resolution mode.
      *
diff --git a/http-client-core/src/main/java/io/micronaut/http/client/ServiceHttpClientConfiguration.java b/http-client-core/src/main/java/io/micronaut/http/client/ServiceHttpClientConfiguration.java
index e13105770c..cc5aefc3d4 100644
--- a/http-client-core/src/main/java/io/micronaut/http/client/ServiceHttpClientConfiguration.java
+++ b/http-client-core/src/main/java/io/micronaut/http/client/ServiceHttpClientConfiguration.java
@@ -30,7 +30,6 @@ import java.net.URI;
 import java.time.Duration;
 import java.util.Collections;
 import java.util.List;
-import java.util.Objects;
 import java.util.Optional;
 
 import static io.micronaut.http.client.ServiceHttpClientConfiguration.PREFIX;
@@ -70,7 +69,6 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
     private final String serviceId;
     private final ServiceConnectionPoolConfiguration connectionPoolConfiguration;
     private final ServiceWebSocketCompressionConfiguration webSocketCompressionConfiguration;
-    private final ServiceHttp2ClientConfiguration http2Configuration;
     private List<URI> urls = Collections.emptyList();
     private String healthCheckUri = DEFAULT_HEALTHCHECKURI;
     private boolean healthCheck = DEFAULT_HEALTHCHECK;
@@ -101,7 +99,6 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
             this.connectionPoolConfiguration = new ServiceConnectionPoolConfiguration();
         }
         this.webSocketCompressionConfiguration = new ServiceWebSocketCompressionConfiguration();
-        this.http2Configuration = new ServiceHttp2ClientConfiguration();
     }
 
     /**
@@ -111,7 +108,7 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
      * @param connectionPoolConfiguration The connection pool configuration
      * @param sslConfiguration The SSL configuration
      * @param defaultHttpClientConfiguration The default HTTP client configuration
-     * @deprecated Use {@link ServiceHttpClientConfiguration(String, ServiceConnectionPoolConfiguration, ServiceWebSocketCompressionConfiguration, ServiceHttp2ClientConfiguration , ServiceSslClientConfiguration, HttpClientConfiguration)} instead.
+     * @deprecated Use {@link ServiceHttpClientConfiguration(String, ServiceConnectionPoolConfiguration, ServiceWebSocketCompressionConfiguration, ServiceSslClientConfiguration, HttpClientConfiguration)} instead.
      */
     @Deprecated(since = "4.3.0")
     public ServiceHttpClientConfiguration(
@@ -130,34 +127,12 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
      * @param webSocketCompressionConfiguration The WebSocket compression configuration
      * @param sslConfiguration The SSL configuration
      * @param defaultHttpClientConfiguration The default HTTP client configuration
-     * @deprecated Use {@link ServiceHttpClientConfiguration(String, ServiceConnectionPoolConfiguration, ServiceWebSocketCompressionConfiguration, ServiceHttp2ClientConfiguration , ServiceSslClientConfiguration, HttpClientConfiguration)} instead.
-     */
-    @Deprecated(since = "4.6.0")
-    public ServiceHttpClientConfiguration(
-        @Parameter String serviceId,
-        @Nullable ServiceConnectionPoolConfiguration connectionPoolConfiguration,
-        @Nullable ServiceWebSocketCompressionConfiguration webSocketCompressionConfiguration,
-        @Nullable ServiceSslClientConfiguration sslConfiguration,
-        HttpClientConfiguration defaultHttpClientConfiguration) {
-        this(serviceId, connectionPoolConfiguration, webSocketCompressionConfiguration, new ServiceHttp2ClientConfiguration(), sslConfiguration, defaultHttpClientConfiguration);
-    }
-
-    /**
-     * Creates a new client configuration for the given service ID.
-     *
-     * @param serviceId The service id
-     * @param connectionPoolConfiguration The connection pool configuration
-     * @param webSocketCompressionConfiguration The WebSocket compression configuration
-     * @param http2Configuration The HTTP/2 configuration
-     * @param sslConfiguration The SSL configuration
-     * @param defaultHttpClientConfiguration The default HTTP client configuration
      */
     @Inject
     public ServiceHttpClientConfiguration(
             @Parameter String serviceId,
             @Nullable ServiceConnectionPoolConfiguration connectionPoolConfiguration,
             @Nullable ServiceWebSocketCompressionConfiguration webSocketCompressionConfiguration,
-            @Nullable ServiceHttpClientConfiguration.ServiceHttp2ClientConfiguration http2Configuration,
             @Nullable ServiceSslClientConfiguration sslConfiguration,
             HttpClientConfiguration defaultHttpClientConfiguration) {
         super(defaultHttpClientConfiguration);
@@ -165,9 +140,16 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
         if (sslConfiguration != null) {
             setSslConfiguration(sslConfiguration);
         }
-        this.connectionPoolConfiguration = Objects.requireNonNullElseGet(connectionPoolConfiguration, ServiceConnectionPoolConfiguration::new);
-        this.webSocketCompressionConfiguration = Objects.requireNonNullElseGet(webSocketCompressionConfiguration, ServiceWebSocketCompressionConfiguration::new);
-        this.http2Configuration = Objects.requireNonNullElseGet(http2Configuration, ServiceHttp2ClientConfiguration::new);
+        if (connectionPoolConfiguration != null) {
+            this.connectionPoolConfiguration = connectionPoolConfiguration;
+        } else {
+            this.connectionPoolConfiguration = new ServiceConnectionPoolConfiguration();
+        }
+        if (webSocketCompressionConfiguration != null) {
+            this.webSocketCompressionConfiguration = webSocketCompressionConfiguration;
+        } else {
+            this.webSocketCompressionConfiguration = new ServiceWebSocketCompressionConfiguration();
+        }
     }
 
     /**
@@ -298,11 +280,6 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
         return webSocketCompressionConfiguration;
     }
 
-    @Override
-    public ServiceHttp2ClientConfiguration getHttp2Configuration() {
-        return http2Configuration;
-    }
-
     /**
      * The default connection pool configuration.
      */
@@ -317,13 +294,6 @@ public class ServiceHttpClientConfiguration extends HttpClientConfiguration impl
     public static class ServiceWebSocketCompressionConfiguration extends WebSocketCompressionConfiguration {
     }
 
-    /**
-     * The service HTTP/2 configuration.
-     */
-    @ConfigurationProperties(WebSocketCompressionConfiguration.PREFIX)
-    public static class ServiceHttp2ClientConfiguration extends Http2ClientConfiguration {
-    }
-
     /**
      * The default connection pool configuration.
      */
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
index 29adf6b9a2..70f3f40ad5 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/ConnectionManager.java
@@ -18,6 +18,7 @@ package io.micronaut.http.client.netty;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.propagation.PropagatedContext;
 import io.micronaut.core.reflect.InstantiationUtils;
 import io.micronaut.core.util.StringUtils;
@@ -121,6 +122,7 @@ import java.time.Duration;
 import java.util.ArrayList;
 import java.util.Base64;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
 import java.util.OptionalInt;
@@ -364,7 +366,7 @@ public class ConnectionManager {
             Object v = entry.getValue();
             if (v != null) {
                 String channelOption = entry.getKey();
-                bootstrap.option(ChannelOption.valueOf(channelOption), v);
+                bootstrap.option(ChannelOption.valueOf(NameUtils.underscoreSeparate(channelOption).toUpperCase(Locale.ENGLISH)), v);
             }
         }
 
@@ -1153,7 +1155,7 @@ public class ConnectionManager {
             ScheduledFuture<?> ttlFuture;
             volatile boolean windDownConnection = false;
 
-            private ReadTimeoutHandler readTimeoutHandler;
+            private ResettableReadTimeoutHandler readTimeoutHandler;
 
             ConnectionHolder(Channel channel, NettyClientCustomizer connectionCustomizer) {
                 this.channel = channel;
@@ -1165,7 +1167,7 @@ public class ConnectionManager {
              */
             private void resetReadTimeout() {
                 if (readTimeoutHandler != null) {
-                    readTimeoutHandler.resetReadTimeout();
+                    readTimeoutHandler.resetReadTimeoutMn();
                 }
             }
 
@@ -1180,7 +1182,7 @@ public class ConnectionManager {
                 // read timeout handles timeouts *during* a request
                 configuration.getReadTimeout()
                     .ifPresent(dur -> {
-                        ReadTimeoutHandler readTimeoutHandler = new ReadTimeoutHandler(dur.toNanos(), TimeUnit.NANOSECONDS) {
+                        ResettableReadTimeoutHandler readTimeoutHandler = new ResettableReadTimeoutHandler(dur.toNanos(), TimeUnit.NANOSECONDS) {
                             @Override
                             protected void readTimedOut(ChannelHandlerContext ctx) {
                                 if (hasLiveRequests()) {
@@ -1449,27 +1451,6 @@ public class ConnectionManager {
                         ChannelPipelineCustomizer.HANDLER_SSL :
                         ChannelPipelineCustomizer.HANDLER_HTTP2_CONNECTION
                 );
-
-                HttpClientConfiguration.Http2ClientConfiguration http2Configuration = configuration.getHttp2Configuration();
-                if (http2Configuration != null) {
-                    long read = toNanos(http2Configuration.getPingIntervalRead());
-                    long write = toNanos(http2Configuration.getPingIntervalWrite());
-                    long idle = toNanos(http2Configuration.getPingIntervalIdle());
-                    if (read > 0 || write > 0 || idle > 0) {
-                        channel.pipeline().addAfter(
-                            ChannelPipelineCustomizer.HANDLER_HTTP2_CONNECTION,
-                            ChannelPipelineCustomizer.HANDLER_HTTP2_PING_SENDER,
-                            new Http2PingSender(read, write, idle, TimeUnit.NANOSECONDS));
-                    }
-                }
-            }
-
-            private static long toNanos(@Nullable Duration timeout) {
-                if (timeout == null) {
-                    return 0;
-                }
-                long nanos = timeout.toNanos();
-                return nanos < 0 ? 0 : nanos;
             }
 
             @Override
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
index 812e2721c3..e563539031 100644
--- a/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/DefaultHttpClient.java
@@ -1132,16 +1132,15 @@ public class DefaultHttpClient implements
             responsePublisher
         );
         Flux<io.micronaut.http.HttpResponse<?>> finalReactiveSequence = Flux.from(finalPublisher);
-        Duration requestTimeout = configuration.getRequestTimeout();
-        if (requestTimeout == null) {
-            // for compatibility
-            requestTimeout = configuration.getReadTimeout()
-                .filter(d -> !d.isNegative())
-                .map(d -> d.plusSeconds(1)).orElse(null);
-        }
-        if (requestTimeout != null) {
-            if (!requestTimeout.isNegative()) {
-                finalReactiveSequence = finalReactiveSequence.timeout(requestTimeout)
+        // apply timeout to flowable too in case a filter applied another policy
+        Optional<Duration> readTimeout = configuration.getReadTimeout();
+        if (readTimeout.isPresent()) {
+            // add an additional second, because generally the timeout should occur
+            // from the Netty request handling pipeline
+            final Duration rt = readTimeout.get();
+            if (!rt.isNegative()) {
+                Duration duration = rt.plus(Duration.ofSeconds(1));
+                finalReactiveSequence = finalReactiveSequence.timeout(duration) // todo: move to CM
                     .onErrorResume(throwable -> {
                         if (throwable instanceof TimeoutException) {
                             return Flux.error(ReadTimeoutException.TIMEOUT_EXCEPTION);
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/Http2PingSender.java b/http-client/src/main/java/io/micronaut/http/client/netty/Http2PingSender.java
deleted file mode 100644
index 960cb9e160..0000000000
--- a/http-client/src/main/java/io/micronaut/http/client/netty/Http2PingSender.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright 2017-2024 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.client.netty;
-
-import io.micronaut.core.annotation.Internal;
-import io.netty.channel.ChannelHandlerContext;
-import io.netty.handler.codec.http2.DefaultHttp2PingFrame;
-import io.netty.handler.timeout.IdleStateEvent;
-import io.netty.handler.timeout.IdleStateHandler;
-
-import java.util.concurrent.ThreadLocalRandom;
-import java.util.concurrent.TimeUnit;
-
-/**
- * IdleStateHandler that automatically sends HTTP/2 ping frames on timeout.
- *
- * @since 4.6.0
- * @author Jonas Konrad
- */
-@Internal
-final class Http2PingSender extends IdleStateHandler {
-    public Http2PingSender(long readerIdleTime, long writerIdleTime, long allIdleTime, TimeUnit unit) {
-        super(readerIdleTime, writerIdleTime, allIdleTime, unit);
-    }
-
-    @Override
-    protected void channelIdle(ChannelHandlerContext ctx, IdleStateEvent evt) {
-        resetReadTimeout();
-        resetWriteTimeout();
-
-        ctx.writeAndFlush(new DefaultHttp2PingFrame(ThreadLocalRandom.current().nextLong()), ctx.voidPromise());
-    }
-}
diff --git a/http-client/src/main/java/io/micronaut/http/client/netty/ResettableReadTimeoutHandler.java b/http-client/src/main/java/io/micronaut/http/client/netty/ResettableReadTimeoutHandler.java
new file mode 100644
index 0000000000..9368fcaf28
--- /dev/null
+++ b/http-client/src/main/java/io/micronaut/http/client/netty/ResettableReadTimeoutHandler.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2017-2023 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.client.netty;
+
+import io.micronaut.core.annotation.Internal;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.timeout.ReadTimeoutHandler;
+
+import java.util.NoSuchElementException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Resettable version of {@link ReadTimeoutHandler}, as a workaround before
+ * <a href="https://github.com/netty/netty/pull/13598">https://github.com/netty/netty/pull/13598</a>
+ * is merged. (TODO: move to new API when that is merged)
+ *
+ * @author Jonas Konrad
+ * @since 4.1.4
+ */
+@Internal
+class ResettableReadTimeoutHandler extends ReadTimeoutHandler {
+    private static final Object FAKE_MESSAGE = new Object();
+
+    private ChannelHandlerContext ctx;
+    private boolean reading = false;
+
+    public ResettableReadTimeoutHandler(long timeout, TimeUnit unit) {
+        super(timeout, unit);
+    }
+
+    @Override
+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
+        super.handlerAdded(ctx);
+        this.ctx = ctx;
+        ctx.pipeline().addAfter(ctx.name(), ctx.name() + "-reset-interceptor", NextInterceptor.INSTANCE);
+    }
+
+    @Override
+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
+        super.handlerRemoved(ctx);
+        try {
+            ctx.pipeline().remove(ctx.name() + "-reset-interceptor");
+        } catch (NoSuchElementException ignored) {
+        }
+    }
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+        reading = true;
+        super.channelRead(ctx, msg);
+    }
+
+    @Override
+    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
+        reading = false;
+        super.channelReadComplete(ctx);
+    }
+
+    void resetReadTimeoutMn() {
+        if (!reading) {
+            try {
+                channelRead(ctx, FAKE_MESSAGE);
+                channelReadComplete(ctx);
+            } catch (Exception ignored) {
+            }
+        }
+    }
+
+    @Sharable
+    private static class NextInterceptor extends ChannelInboundHandlerAdapter {
+        static final NextInterceptor INSTANCE = new NextInterceptor();
+
+        @Override
+        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+            if (msg == FAKE_MESSAGE) {
+                return;
+            }
+            super.channelRead(ctx, msg);
+        }
+    }
+}
diff --git a/http-client/src/test/groovy/io/micronaut/http/client/netty/ConnectionManagerSpec.groovy b/http-client/src/test/groovy/io/micronaut/http/client/netty/ConnectionManagerSpec.groovy
index e40b7601c9..87386ee20b 100644
--- a/http-client/src/test/groovy/io/micronaut/http/client/netty/ConnectionManagerSpec.groovy
+++ b/http-client/src/test/groovy/io/micronaut/http/client/netty/ConnectionManagerSpec.groovy
@@ -56,7 +56,6 @@ import io.netty.handler.codec.http2.Http2FrameStream
 import io.netty.handler.codec.http2.Http2FrameStreamEvent
 import io.netty.handler.codec.http2.Http2Headers
 import io.netty.handler.codec.http2.Http2HeadersFrame
-import io.netty.handler.codec.http2.Http2PingFrame
 import io.netty.handler.codec.http2.Http2ResetFrame
 import io.netty.handler.codec.http2.Http2ServerUpgradeCodec
 import io.netty.handler.codec.http2.Http2SettingsAckFrame
@@ -1144,80 +1143,6 @@ class ConnectionManagerSpec extends Specification {
         http2 << [false, true]
     }
 
-    def 'automated ping, writes only'(String prop, boolean ping) {
-        given:
-        def props = ['micronaut.http.client.ssl.insecure-trust-all-certificates': true]
-        props.put(prop, '1s')
-        def ctx = ApplicationContext.run(props)
-        def client = ctx.getBean(DefaultHttpClient)
-
-        def conn = new EmbeddedTestConnectionHttp2()
-        conn.setupHttp2Tls()
-        patch(client, conn)
-
-        // do one request
-        def r1 = conn.testExchangeRequest(client)
-        conn.exchangeSettings()
-        conn.testExchangeResponse(r1)
-
-        conn.clientChannel.unfreezeTime()
-        for (int i = 0; i < 8; i++) {
-            conn.testExchangeRequest(client)
-            TimeUnit.MILLISECONDS.sleep(250)
-        }
-        conn.advance()
-
-        def msgs = conn.serverChannel.inboundMessages().toList()
-
-        expect:
-        msgs.size() >= (ping ? 9 : 8)
-        msgs.any { it instanceof Http2PingFrame } == ping
-
-        cleanup:
-        client.close()
-        ctx.close()
-
-        where:
-        prop                                              | ping
-        'micronaut.http.client.http2.ping-interval-read'  | true
-        'micronaut.http.client.http2.ping-interval-write' | false
-        'micronaut.http.client.http2.ping-interval-idle'  | false
-    }
-
-    def 'automated ping, no traffic'(String prop, boolean ping) {
-        given:
-        def props = ['micronaut.http.client.ssl.insecure-trust-all-certificates': true]
-        props.put(prop, '1s')
-        def ctx = ApplicationContext.run(props)
-        def client = ctx.getBean(DefaultHttpClient)
-
-        def conn = new EmbeddedTestConnectionHttp2()
-        conn.setupHttp2Tls()
-        patch(client, conn)
-
-        // do one request
-        def r1 = conn.testExchangeRequest(client)
-        conn.exchangeSettings()
-        conn.testExchangeResponse(r1)
-
-        conn.clientChannel.unfreezeTime()
-        TimeUnit.SECONDS.sleep(2)
-        conn.advance()
-
-        expect:
-        conn.serverChannel.readInbound() instanceof Http2PingFrame == ping
-
-        cleanup:
-        client.close()
-        ctx.close()
-
-        where:
-        prop                                              | ping
-        'micronaut.http.client.http2.ping-interval-read'  | true
-        'micronaut.http.client.http2.ping-interval-write' | true
-        'micronaut.http.client.http2.ping-interval-idle'  | true
-    }
-
     void assertPoolConnections(DefaultHttpClient client, int count) {
         assert client.connectionManager.getChannels().size() == count
         client.connectionManager.getChannels().forEach { assert it.isActive() }
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/ChannelPipelineCustomizer.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/ChannelPipelineCustomizer.java
index 0c06fcf295..69a2ab91bd 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/ChannelPipelineCustomizer.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/ChannelPipelineCustomizer.java
@@ -15,7 +15,6 @@
  */
 package io.micronaut.http.netty.channel;
 
-import io.micronaut.core.annotation.NextMajorVersion;
 import io.micronaut.core.annotation.NonNull;
 
 /**
@@ -25,7 +24,6 @@ import io.micronaut.core.annotation.NonNull;
  * @author graemerocher
  * @since 2.0.0
  */
-@NextMajorVersion("Move constants to a different class and delete this one")
 public interface ChannelPipelineCustomizer {
     String HANDLER_HTTP_COMPRESSOR = "http-compressor";
     String HANDLER_HTTP_DECOMPRESSOR = "http-decompressor";
@@ -53,7 +51,6 @@ public interface ChannelPipelineCustomizer {
     String HANDLER_MICRONAUT_HTTP_RESPONSE_FULL = "micronaut-http-response-full";
     String HANDLER_MICRONAUT_HTTP_RESPONSE = "micronaut-http-response";
     String HANDLER_HTTP2_CONNECTION = "http2-connection";
-    String HANDLER_HTTP2_PING_SENDER = "http2-ping-sender";
     String HANDLER_HTTP2_SETTINGS = "http2-settings";
     String HANDLER_HTTP2_UPGRADE_REQUEST = "http2-upgrade-request";
     String HANDLER_HTTP2_PROTOCOL_NEGOTIATOR = "http2-protocol-negotiator";
diff --git a/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupConfiguration.java b/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupConfiguration.java
index 1d5a4f39e7..f36d2e219d 100644
--- a/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupConfiguration.java
+++ b/http-netty/src/main/java/io/micronaut/http/netty/channel/DefaultEventLoopGroupConfiguration.java
@@ -50,11 +50,7 @@ public class DefaultEventLoopGroupConfiguration implements EventLoopGroupConfigu
      * @param numThreads            The number of threads
      * @param ioRatio               The IO ratio (optional)
      * @param preferNativeTransport Whether native transport is to be preferred
-     * @param executor              A named executor service to use for event loop threads
-     *                              (optional). This property is very specialized. In particular,
-     *                              it will <i>not</i> solve read timeouts or fix blocking
-     *                              operations on the event loop, in fact it may do the opposite.
-     *                              Don't use unless you really know what this does.
+     * @param executor              A named executor service to use (optional)
      * @param shutdownQuietPeriod   The shutdown quiet period
      * @param shutdownTimeout       The shutdown timeout (must be &gt;= shutdownQuietPeriod)
      */
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java
index d26b2ff1f6..bf4fb2da64 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/configuration/NettyHttpServerConfiguration.java
@@ -1321,12 +1321,7 @@ public class NettyHttpServerConfiguration extends HttpServerConfiguration {
         }
 
         /**
-         * A named executor service to use for event loop threads
-         * (optional). This property is very specialized. In particular,
-         * it will <i>not</i> solve read timeouts or fix blocking
-         * operations on the event loop, in fact it may do the opposite.
-         * Don't use unless you really know what this does.
-         *
+         * Sets the name of the executor.
          * @param executor The executor
          */
         public void setExecutor(String executor) {
diff --git a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/converters/ConverterRegistrySpec.groovy b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/converters/ConverterRegistrySpec.groovy
index d0fc17f93d..a8055bdae1 100644
--- a/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/converters/ConverterRegistrySpec.groovy
+++ b/http-server-netty/src/test/groovy/io/micronaut/http/server/netty/converters/ConverterRegistrySpec.groovy
@@ -17,6 +17,8 @@ package io.micronaut.http.server.netty.converters
 
 import io.micronaut.context.ApplicationContext
 import io.micronaut.core.convert.ConversionService
+import io.micronaut.http.client.HttpClient
+import io.micronaut.http.client.netty.DefaultHttpClient
 import io.netty.buffer.ByteBuf
 import io.netty.buffer.CompositeByteBuf
 import io.netty.buffer.Unpooled
@@ -85,4 +87,15 @@ class ConverterRegistrySpec extends Specification {
         cleanup:
         ctx1.close()
     }
+
+    def "config properties"() {
+        given:
+        ApplicationContext ctx = ApplicationContext.run(['micronaut.http.client.channel-options.SO_TIMEOUT': 1])
+
+        expect:
+        ((DefaultHttpClient) ctx.getBean(HttpClient)).connectionManager().bootstrap.config().options().get(ChannelOption.SO_TIMEOUT) == 1
+
+        cleanup:
+        ctx.close()
+    }
 }
diff --git a/inject/src/main/java/io/micronaut/context/AnnotationReflectionUtils.java b/inject/src/main/java/io/micronaut/context/AnnotationReflectionUtils.java
new file mode 100644
index 0000000000..2701a356a5
--- /dev/null
+++ b/inject/src/main/java/io/micronaut/context/AnnotationReflectionUtils.java
@@ -0,0 +1,454 @@
+/*
+ * Copyright 2017-2024 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.context;
+
+import io.micronaut.core.annotation.AnnotationMetadata;
+import io.micronaut.core.annotation.Internal;
+import io.micronaut.core.annotation.NonNull;
+import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.reflect.ClassUtils;
+import io.micronaut.core.reflect.ReflectionUtils;
+import io.micronaut.core.type.Argument;
+import io.micronaut.inject.annotation.AnnotationMetadataHierarchy;
+import io.micronaut.inject.annotation.MutableAnnotationMetadata;
+
+import java.lang.annotation.Annotation;
+import java.lang.reflect.AnnotatedArrayType;
+import java.lang.reflect.AnnotatedElement;
+import java.lang.reflect.AnnotatedParameterizedType;
+import java.lang.reflect.AnnotatedType;
+import java.lang.reflect.AnnotatedWildcardType;
+import java.lang.reflect.Array;
+import java.lang.reflect.GenericArrayType;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.lang.reflect.TypeVariable;
+import java.lang.reflect.WildcardType;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.stream.Stream;
+
+/**
+ * The annotation reflection utils.
+ *
+ * @author Denis Stepanov
+ * @since 4.6.0
+ */
+@Internal
+public final class AnnotationReflectionUtils {
+
+    private AnnotationReflectionUtils() {
+    }
+
+    /**
+     * Find implementation as an argument with types and annotations.
+     *
+     * @param runtimeGenericType The implementation class of the interface
+     * @param rawSuperType       The implementedType type - interface or an abstract class
+     * @return The argument of the interface with types and annotations
+     * @since 4.6
+     */
+    @Nullable
+    public static <T> Argument<T> resolveGenericToArgument(@NonNull Class<?> runtimeGenericType,
+                                                           @NonNull Class<T> rawSuperType) {
+        if (ClassUtils.REFLECTION_LOGGER.isDebugEnabled()) {
+            ClassUtils.REFLECTION_LOGGER.debug("Reflectively finding a generic argument of '{}' from the implementation '{}'",
+                rawSuperType, runtimeGenericType);
+        }
+
+        AnnotatedType st = findAnnotatedSupertype(new SimpleAnnotatedType(runtimeGenericType), rawSuperType);
+        if (st == null) {
+            return null;
+        }
+        //noinspection unchecked
+        return (Argument<T>) toArgument(st);
+    }
+
+    /**
+     * Find the {@link AnnotatedType} in {@code subType}'s type hierarchy that has the raw type
+     * {@code superType}. For example, for a {@code class A extends AbstractList<@Nullable String>},
+     * {@code findAnnotatedSupertype(A, Collection.class)} would return
+     * {@code Collection<@Nullable String>}.
+     * <p>
+     * Note that this can return special {@link AnnotatedType} instances like
+     * {@link LazySubstitutingType} or {@link MergedAnnotatedType}.
+     *
+     * @param subType   The type that should have its type hierarchy analyzed
+     * @param superType The supertype that we want to get the type information for
+     * @return The annotated generic supertype, with the same raw type as {@code superType}
+     */
+    @Nullable
+    private static AnnotatedType findAnnotatedSupertype(AnnotatedType subType, Class<?> superType) {
+        Class<?> raw = getRawType(subType.getType());
+        if (superType == raw) {
+            return subType;
+        } else if (!superType.isAssignableFrom(raw)) {
+            return null;
+        }
+
+        Map<TypeVariable<?>, AnnotatedType> substitutions = new HashMap<>();
+        collectTypeSubstitutions(subType, substitutions);
+
+        Stream<AnnotatedType> supertypes = getSupertypes(raw);
+        if (!substitutions.isEmpty()) {
+            supertypes = supertypes.map(t -> new LazySubstitutingType(t, substitutions));
+        }
+        List<AnnotatedType> candidates = supertypes
+            .map(at -> findAnnotatedSupertype(at, superType))
+            .filter(Objects::nonNull)
+            .toList();
+        if (candidates.isEmpty()) {
+            return null;
+        } else if (candidates.size() == 1) {
+            return candidates.get(0);
+        } else {
+            return new MergedAnnotatedType(candidates.get(0), candidates);
+        }
+    }
+
+    /**
+     * Collect the necessary type substitutions into the {@code substitutions} map. For example,
+     * if {@code type} is {@code Map<String, List<Integer>>}, then the collected substitutions
+     * would be {@code K -> String, V -> List<Integer>} (both K and V come from {@link Map}).
+     *
+     * @param type          The type to get the substitutions from. This only makes sense to be
+     *                      some form of {@link ParameterizedType}
+     * @param substitutions The output map
+     */
+    private static void collectTypeSubstitutions(AnnotatedType type, Map<TypeVariable<?>, AnnotatedType> substitutions) {
+        if (type instanceof AnnotatedParameterizedType apt) {
+            TypeVariable<? extends Class<?>>[] variables = getRawType(type.getType()).getTypeParameters();
+            AnnotatedType[] args = apt.getAnnotatedActualTypeArguments();
+            if (variables.length == args.length) {
+                for (int i = 0; i < args.length; i++) {
+                    substitutions.put(variables[i], args[i]);
+                }
+            }
+            if (apt.getAnnotatedOwnerType() instanceof AnnotatedParameterizedType owner) {
+                collectTypeSubstitutions(owner, substitutions);
+            }
+        } else if (type instanceof LazySubstitutingType lst) {
+            Map<TypeVariable<?>, AnnotatedType> intermediate = new HashMap<>();
+            collectTypeSubstitutions(lst.actual, intermediate);
+            intermediate.replaceAll((k, v) -> new LazySubstitutingType(v, lst.substitutions));
+            substitutions.putAll(intermediate);
+        } else if (type instanceof MergedAnnotatedType mat) {
+            collectTypeSubstitutions(mat.actual, substitutions);
+        } else {
+            collectTypeSubstitutions(type.getType(), substitutions);
+        }
+    }
+
+    /**
+     * Collect the necessary type substitutions into the {@code substitutions} map. For example,
+     * if {@code type} is {@code Map<String, List<Integer>>}, then the collected substitutions
+     * would be {@code K -> String, V -> List<Integer>} (both K and V come from {@link Map}).
+     *
+     * @param type          The type to get the substitutions from. This only makes sense to be
+     *                      some form of {@link ParameterizedType}
+     * @param substitutions The output map
+     */
+    private static void collectTypeSubstitutions(Type type, Map<TypeVariable<?>, AnnotatedType> substitutions) {
+        if (type instanceof ParameterizedType pt) {
+            TypeVariable<? extends Class<?>>[] variables = getRawType(pt.getRawType()).getTypeParameters();
+            Type[] args = pt.getActualTypeArguments();
+            if (variables.length == args.length) {
+                for (int i = 0; i < args.length; i++) {
+                    substitutions.put(variables[i], new SimpleAnnotatedType(args[i]));
+                }
+            }
+        }
+    }
+
+    private static AnnotationMetadata annotationMetadataOf(AnnotatedElement annotatedElement) {
+        Annotation[] annotations = annotatedElement.getAnnotations();
+        if (annotations.length == 0) {
+            return AnnotationMetadata.EMPTY_METADATA;
+        }
+        MutableAnnotationMetadata mutableAnnotationMetadata = new MutableAnnotationMetadata();
+        for (Annotation annotation : annotations) {
+            Map<CharSequence, Object> values = new LinkedHashMap<>();
+            Class<? extends Annotation> annotationType = annotation.annotationType();
+            Method[] methods = annotationType.getMethods();
+            for (Method method : methods) {
+                if (!method.getDeclaringClass().equals(annotationType)) {
+                    continue;
+                }
+                Object value = ReflectionUtils.invokeMethod(annotation, method);
+                if (value != null) {
+                    values.put(method.getName(), value);
+                }
+            }
+            mutableAnnotationMetadata.addAnnotation(annotationType.getName(), values);
+        }
+        return mutableAnnotationMetadata;
+    }
+
+    /**
+     * Convert the given annotated type to an {@link Argument}.
+     *
+     * @param annotatedType The type to convert
+     * @return The converted argument
+     */
+    private static Argument<?> toArgument(AnnotatedType annotatedType) {
+        return toArgument(null, annotatedType, Map.of());
+    }
+
+    /**
+     * Convert the given annotated type to an {@link Argument}.
+     *
+     * @param name          The name of the returned {@link Argument}, or {@code null}
+     * @param annotatedType The type to convert
+     * @param substitutions Type variables to replace
+     * @return The converted argument
+     */
+    private static Argument<?> toArgument(@Nullable String name, AnnotatedType annotatedType, Map<TypeVariable<?>, AnnotatedType> substitutions) {
+        if (annotatedType instanceof AnnotatedParameterizedType apt) {
+            Class<?> rawType = getRawType(apt.getType());
+            TypeVariable<? extends Class<?>>[] variables = rawType.getTypeParameters();
+            Argument<?>[] typeArgs = new Argument[apt.getAnnotatedActualTypeArguments().length];
+            for (int i = 0; i < typeArgs.length; i++) {
+                typeArgs[i] = toArgument(variables.length > i ? variables[i].getName() : null, apt.getAnnotatedActualTypeArguments()[i], substitutions);
+            }
+            return Argument.of(getRawType(apt.getType()), name, annotationMetadataOf(apt), typeArgs);
+        } else if (annotatedType instanceof AnnotatedArrayType aat) {
+            Argument<?> component = toArgument(null, aat.getAnnotatedGenericComponentType(), substitutions);
+            AnnotationMetadata componentAnnotations = component.getAnnotationMetadata();
+            AnnotationMetadata ourAnnotations = annotationMetadataOf(aat);
+            AnnotationMetadata combined = combine(componentAnnotations, ourAnnotations);
+            return Argument.of(
+                Array.newInstance(component.getType(), 0).getClass(),
+                name,
+                combined
+            );
+        } else if (annotatedType instanceof AnnotatedWildcardType awt) {
+            Argument<?> upper = toArgument(null, awt.getAnnotatedUpperBounds()[0], substitutions);
+            return Argument.of(upper.getType(), name, combine(upper.getAnnotationMetadata(), annotationMetadataOf(annotatedType)), upper.getTypeParameters());
+        } else if (annotatedType instanceof LazySubstitutingType lst) {
+            Map<TypeVariable<?>, AnnotatedType> newSubstitutions;
+            if (substitutions.isEmpty()) {
+                newSubstitutions = lst.substitutions;
+            } else {
+                newSubstitutions = new HashMap<>();
+                newSubstitutions.putAll(substitutions);
+                newSubstitutions.putAll(lst.substitutions);
+            }
+            return toArgument(name, lst.actual, newSubstitutions);
+        } else if (annotatedType instanceof MergedAnnotatedType mat) {
+            Argument<?> argument = toArgument(null, mat.actual, substitutions);
+            return Argument.of(
+                argument.getType(),
+                name,
+                combine(argument.getAnnotationMetadata(), annotationMetadataOf(mat)),
+                argument.getTypeParameters()
+            );
+        } else {
+            Argument<?> simple = toArgument(null, annotatedType.getType(), substitutions);
+            AnnotationMetadata annotations = annotationMetadataOf(annotatedType);
+            return Argument.of(simple.getType(), name, combine(annotations, simple.getAnnotationMetadata()), simple.getTypeParameters());
+        }
+    }
+
+    /**
+     * Convert the given non-annotated type to an {@link Argument}.
+     *
+     * @param name          The name of the returned {@link Argument}, or {@code null}
+     * @param type          The type to convert
+     * @param substitutions Type variables to replace
+     * @return The converted argument
+     */
+    private static Argument<?> toArgument(@Nullable String name, Type type, Map<TypeVariable<?>, AnnotatedType> substitutions) {
+        if (type instanceof ParameterizedType pt) {
+            Class<?> rawType = getRawType(pt.getRawType());
+            TypeVariable<? extends Class<?>>[] variables = rawType.getTypeParameters();
+            Argument<?>[] typeArgs = new Argument[pt.getActualTypeArguments().length];
+            for (int i = 0; i < typeArgs.length; i++) {
+                typeArgs[i] = toArgument(variables.length > i ? variables[i].getName() : null, pt.getActualTypeArguments()[i], substitutions);
+            }
+            return Argument.of(rawType, typeArgs);
+        } else if (type instanceof GenericArrayType gat) {
+            Argument<?> component = toArgument(null, gat.getGenericComponentType(), substitutions);
+            return Argument.of(
+                Array.newInstance(component.getType(), 0).getClass(),
+                name,
+                component.getAnnotationMetadata()
+            );
+        } else if (type instanceof WildcardType wt) {
+            return toArgument(name, wt.getUpperBounds()[0], substitutions);
+        } else if (type instanceof Class<?> cl) {
+            return Argument.of(cl, name);
+        } else if (type instanceof TypeVariable<?> tv) {
+            AnnotatedType sub = substitutions.get(tv);
+            if (sub == null) {
+                return toArgument(name, tv.getAnnotatedBounds()[0], Map.of());
+            } else {
+                return toArgument(name, sub, Map.of());
+            }
+        } else {
+            throw new IllegalArgumentException("Unsupported type " + type.getClass().getName());
+        }
+    }
+
+    private static AnnotationMetadata combine(AnnotationMetadata left, AnnotationMetadata right) {
+        if (left.isEmpty()) {
+            return right;
+        } else if (right.isEmpty()) {
+            return left;
+        } else {
+            return new AnnotationMetadataHierarchy(true, left, right);
+        }
+    }
+
+    /**
+     * Get all annotated supertypes of a class or interface.
+     *
+     * @param cl The class
+     * @return A stream of supertypes
+     */
+    private static Stream<AnnotatedType> getSupertypes(Class<?> cl) {
+        Stream<AnnotatedType> itf = Stream.of(cl.getAnnotatedInterfaces());
+        if (cl.isInterface()) {
+            return itf;
+        }
+        return Stream.concat(Stream.of(cl.getAnnotatedSuperclass()), itf);
+    }
+
+    /**
+     * Get the raw type of a given complex type.
+     *
+     * @param type The complex type
+     * @return The raw type
+     */
+    private static Class<?> getRawType(Type type) {
+        if (type instanceof Class<?> cl) {
+            return cl;
+        } else if (type instanceof ParameterizedType ptype) {
+            return getRawType(ptype.getRawType());
+        } else if (type instanceof TypeVariable<?> tv) {
+            return getRawType(tv.getBounds()[0]);
+        } else if (type instanceof WildcardType wt) {
+            return getRawType(wt.getUpperBounds()[0]);
+        } else if (type instanceof GenericArrayType gat) {
+            Class<?> rawComponentType = getRawType(gat.getGenericComponentType());
+            return Array.newInstance(rawComponentType, 0).getClass();
+        } else {
+            throw new IllegalArgumentException("Unsupported type " + type.getClass().getName());
+        }
+    }
+
+    /**
+     * Wrapper around a {@link AnnotatedType} to signals that certain {@link TypeVariable}s should
+     * be substituted lazily. For example, if {@code actual} is {@code List<T>} and
+     * {@code substitutions} is {@code T -> @Ann1 String}, users should treat this type as
+     * {@code List<@Ann1 String>}.
+     *
+     * @param actual        The type to delegate to
+     * @param substitutions Substitutions to apply to the type
+     */
+    private record LazySubstitutingType(AnnotatedType actual,
+                                        Map<TypeVariable<?>, AnnotatedType> substitutions) implements AnnotatedType {
+        @Override
+        public Type getType() {
+            return actual.getType();
+        }
+
+        @Override
+        public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
+            return actual.getAnnotation(annotationClass);
+        }
+
+        @Override
+        public Annotation[] getAnnotations() {
+            return actual.getAnnotations();
+        }
+
+        @Override
+        public Annotation[] getDeclaredAnnotations() {
+            return actual.getDeclaredAnnotations();
+        }
+    }
+
+    /**
+     * Simple, annotation-less {@link AnnotatedType} implementation.
+     *
+     * @param actual The type
+     */
+    private record SimpleAnnotatedType(Type actual) implements AnnotatedType {
+        @Override
+        public Type getType() {
+            return actual;
+        }
+
+        @Override
+        public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
+            return null;
+        }
+
+        @Override
+        public Annotation[] getAnnotations() {
+            return new Annotation[0];
+        }
+
+        @Override
+        public Annotation[] getDeclaredAnnotations() {
+            return new Annotation[0];
+        }
+    }
+
+    /**
+     * This record represents an {@link AnnotatedType} that merges the annotations of multiple
+     * different types. e.g. when {@code class A implements @Ann1 I {}},
+     * {@code class B extends A implements @Ann2 I {}}, this record is used to create a type
+     * {@code @Ann1 @Ann2 I} that represents the annotations of both {@code implements I} clauses.
+     *
+     * @param actual            The type to delegate to for {@link #getType()}
+     * @param annotationSources Elements to take annotations from
+     */
+    private record MergedAnnotatedType(AnnotatedType actual,
+                                       List<AnnotatedType> annotationSources) implements AnnotatedType {
+        @Override
+        public Type getType() {
+            return actual.getType();
+        }
+
+        @Override
+        public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {
+            return annotationSources.stream()
+                .map(s -> s.getAnnotation(annotationClass))
+                .filter(Objects::nonNull)
+                .findFirst().orElse(null);
+        }
+
+        @Override
+        public Annotation[] getAnnotations() {
+            return annotationSources.stream()
+                .flatMap(s -> Arrays.stream(s.getAnnotations()))
+                .toArray(Annotation[]::new);
+        }
+
+        @Override
+        public Annotation[] getDeclaredAnnotations() {
+            return annotationSources.stream()
+                .flatMap(s -> Arrays.stream(s.getDeclaredAnnotations()))
+                .toArray(Annotation[]::new);
+        }
+    }
+}
diff --git a/management/src/test/groovy/io/micronaut/management/health/indicator/client/ServiceHttpClientHealthIndicatorSpec.groovy b/management/src/test/groovy/io/micronaut/management/health/indicator/client/ServiceHttpClientHealthIndicatorSpec.groovy
index 85f4f643c6..ab6ff8b973 100644
--- a/management/src/test/groovy/io/micronaut/management/health/indicator/client/ServiceHttpClientHealthIndicatorSpec.groovy
+++ b/management/src/test/groovy/io/micronaut/management/health/indicator/client/ServiceHttpClientHealthIndicatorSpec.groovy
@@ -17,7 +17,7 @@ class ServiceHttpClientHealthIndicatorSpec extends Specification {
     ServiceHttpClientConfiguration.ServiceConnectionPoolConfiguration connectionPoolConfiguration = null
     ServiceHttpClientConfiguration.ServiceWebSocketCompressionConfiguration webSocketCompressionConfiguration = null
     ServiceHttpClientConfiguration.ServiceSslClientConfiguration sslConfiguration = null
-    ServiceHttpClientConfiguration serviceHttpConfiguration = new ServiceHttpClientConfiguration("some-http-service", connectionPoolConfiguration, webSocketCompressionConfiguration, null, sslConfiguration, Mock(HttpClientConfiguration))
+    ServiceHttpClientConfiguration serviceHttpConfiguration = new ServiceHttpClientConfiguration("some-http-service", connectionPoolConfiguration, webSocketCompressionConfiguration, sslConfiguration, Mock(HttpClientConfiguration))
 
     def "Health Indicator is set to true and is healthy"() {
         given:
diff --git a/test-suite-groovy/src/test/groovy/io/micronaut/docs/http/server/stream/StreamControllerSpec.groovy b/test-suite-groovy/src/test/groovy/io/micronaut/docs/http/server/stream/StreamControllerSpec.groovy
index 7812bcf2d1..94c6128788 100644
--- a/test-suite-groovy/src/test/groovy/io/micronaut/docs/http/server/stream/StreamControllerSpec.groovy
+++ b/test-suite-groovy/src/test/groovy/io/micronaut/docs/http/server/stream/StreamControllerSpec.groovy
@@ -12,7 +12,7 @@ import spock.lang.Specification
 class StreamControllerSpec extends Specification {
 
     @Shared @AutoCleanup
-    EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.port':-1])
+    EmbeddedServer embeddedServer = ApplicationContext.run(EmbeddedServer, ['micronaut.server.port':'8080'])
 
     @Shared @AutoCleanup
     HttpClient client = embeddedServer.getApplicationContext().createBean(HttpClient, embeddedServer.getURL())
