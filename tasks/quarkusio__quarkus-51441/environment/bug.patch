diff --git a/docs/src/main/asciidoc/deploying-to-kubernetes.adoc b/docs/src/main/asciidoc/deploying-to-kubernetes.adoc
index 4c5d76efc45..91f3dc8ab23 100644
--- a/docs/src/main/asciidoc/deploying-to-kubernetes.adoc
+++ b/docs/src/main/asciidoc/deploying-to-kubernetes.adoc
@@ -575,6 +575,29 @@ A conflict between two definitions, e.g. mistakenly assigning both a value and s
 
 Similarly, two redundant definitions, e.g. defining an injection from the same secret twice, will not cause an issue but will indeed report a warning to let you know that you might not have intended to duplicate that definition.
 
+[[env-vars-backwards]]
+===== Backwards compatibility
+
+Previous versions of the Kubernetes extension supported a different syntax to add environment variables. The older syntax is still supported but is deprecated, and it's advised that you migrate to the new syntax.
+
+.Old vs. new syntax
+|====
+|                               |Old                                                    | New                                                 |
+| Plain variable                |`quarkus.kubernetes.env-vars.my-env-var.value=foobar`  | `quarkus.kubernetes.env.vars.my-env-var=foobar`     |
+| From field                    |`quarkus.kubernetes.env-vars.my-env-var.field=foobar`  | `quarkus.kubernetes.env.fields.my-env-var=foobar`   |
+| All from `ConfigMap`          |`quarkus.kubernetes.env-vars.xxx.configmap=foobar`     | `quarkus.kubernetes.env.configmaps=foobar`          |
+| All from `Secret`             |`quarkus.kubernetes.env-vars.xxx.secret=foobar`        | `quarkus.kubernetes.env.secrets=foobar`             |
+| From one `Secret` field       |`quarkus.kubernetes.env-vars.foo.secret=foobar`        | `quarkus.kubernetes.env.mapping.foo.from-secret=foobar` |
+|                               |`quarkus.kubernetes.env-vars.foo.value=field`          | `quarkus.kubernetes.env.mapping.foo.with-key=field` |
+| From one `ConfigMap` field    |`quarkus.kubernetes.env-vars.foo.configmap=foobar`     | `quarkus.kubernetes.env.mapping.foo.from-configmap=foobar` |
+|                               |`quarkus.kubernetes.env-vars.foo.value=field`          | `quarkus.kubernetes.env.mapping.foo.with-key=field` |
+|====
+
+NOTE: If you redefine the same variable using the new syntax while keeping the old syntax, **ONLY** the new version will be kept
+and a warning will be issued to alert you of the problem.For example, if you define both
+`quarkus.kubernetes.env-vars.my-env-var.value=foobar` and `quarkus.kubernetes.env.vars.my-env-var=newValue`, the extension will
+only generate an environment variable `MY_ENV_VAR=newValue` and issue a warning.
+
 === Mounting volumes
 
 The Kubernetes extension allows the user to configure both volumes and mounts for the application.
@@ -1340,7 +1363,7 @@ The properties for configuring `docker` and `s2i` are also deprecated in favor o
 
 ==== Config group arrays
 
-Properties referring to config group arrays (e.g. `kubernetes.labels[0]`, etc.) have been converted to Maps to align with the rest of the Quarkus ecosystem.
+Properties referring to config group arrays (e.g. `kubernetes.labels[0]`, `kubernetes.env-vars[0]` etc) have been converted to Maps to align with the rest of the Quarkus ecosystem.
 
 The code below demonstrates the change in `labels` config:
 
@@ -1354,6 +1377,23 @@ kubernetes.labels[0].value=bar
 quarkus.kubernetes.labels.foo=bar
 ----
 
+The code below demonstrates the change in `env-vars` config:
+
+[source,properties]
+----
+# Old env-vars config:
+kubernetes.env-vars[0].name=foo
+kubernetes.env-vars[0].configmap=my-configmap
+
+# New env-vars
+quarkus.kubernetes.env-vars.foo.configmap=myconfigmap
+----
+
+==== `env-vars` properties
+
+`quarkus.kubernetes.env-vars` are deprecated (though still currently supported as of this writing) and the new declaration style should be used instead.
+See <<#env-vars>> and more specifically <<env-vars-backwards>> for more details.
+
 [[deployment]]
 == Deployment
 
diff --git a/docs/src/main/asciidoc/rest.adoc b/docs/src/main/asciidoc/rest.adoc
index 7967fb8452b..66499d88099 100644
--- a/docs/src/main/asciidoc/rest.adoc
+++ b/docs/src/main/asciidoc/rest.adoc
@@ -1465,14 +1465,14 @@ There are situations where various Jackson related exceptions need to handled in
 This becomes a problem when taking JAX-RS / Jakarta REST rules into account, because the exception mapper `ExceptionMapper` for `MismatchedInputException` would be used instead of the user provide
 `ExceptionMapper` for `JsonMappingException` (as `MismatchedInputException` is a subtype of `JsonMappingException`).
 
-One solution for this case is to configure the following:
+To handle this, you can disable the built-in exception mapper:
 
 [source,properties]
 ----
-quarkus.class-loading.removed-resources."io.quarkus\:quarkus-rest-jackson"=io/quarkus/resteasy/reactive/jackson/runtime/mappers/BuiltinMismatchedInputExceptionMapper.class
+quarkus.rest.exception-mapping.disable-mapper-for=io.quarkus.resteasy.reactive.jackson.runtime.mappers.BuiltinMismatchedInputExceptionMapper
 ----
 
-which essentially makes Quarkus ignore the `ExceptionMapper` for `MismatchedInputException` completely.
+This allows your custom `ExceptionMapper` for `JsonMappingException` to handle all its subclasses, including `MismatchedInputException`.
 ====
 
 [[secure-serialization]]
diff --git a/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesEnvBuildItem.java b/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesEnvBuildItem.java
index e1f0eafa9f5..0159d30cf2a 100644
--- a/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesEnvBuildItem.java
+++ b/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesEnvBuildItem.java
@@ -44,42 +44,47 @@ public boolean mightConflictWith(EnvType type) {
     private final String secret;
     private final String field;
     private final EnvType type;
+    private final boolean oldStyle;
     private final String prefix;
 
-    public static KubernetesEnvBuildItem createFromField(String name, String targetField, String target) {
-        return create(name, null, null, null, targetField, target, null);
+    public static KubernetesEnvBuildItem createFromField(String name, String targetField, String target,
+            boolean... oldStyle) {
+        return create(name, null, null, null, targetField, target, null, isOldStyle(oldStyle));
     }
 
-    public static KubernetesEnvBuildItem createFromConfigMap(String configMapName, String target, String prefix) {
-        return create(configMapName, null, null, configMapName, null, target, prefix);
+    public static KubernetesEnvBuildItem createFromConfigMap(String configMapName, String target, String prefix,
+            boolean... oldStyle) {
+        return create(configMapName, null, null, configMapName, null, target, prefix, isOldStyle(oldStyle));
     }
 
-    public static KubernetesEnvBuildItem createFromSecret(String secretName, String target, String prefix) {
-        return create(secretName, null, secretName, null, null, target, prefix);
+    public static KubernetesEnvBuildItem createFromSecret(String secretName, String target, String prefix,
+            boolean... oldStyle) {
+        return create(secretName, null, secretName, null, null, target, prefix, isOldStyle(oldStyle));
     }
 
-    public static KubernetesEnvBuildItem createSimpleVar(String name, String value, String target) {
-        return create(name, value, null, null, null, target, null);
+    public static KubernetesEnvBuildItem createSimpleVar(String name, String value, String target,
+            boolean... oldStyle) {
+        return create(name, value, null, null, null, target, null, isOldStyle(oldStyle));
     }
 
     public static KubernetesEnvBuildItem createFromConfigMapKey(String varName, String key, String configmap, String target,
-            String prefix) {
-        return create(varName, key, null, configmap, null, target, prefix);
+            String prefix, boolean... oldStyle) {
+        return create(varName, key, null, configmap, null, target, prefix, isOldStyle(oldStyle));
     }
 
     @SuppressWarnings("unused")
     public static KubernetesEnvBuildItem createFromSecretKey(String varName, String key, String secret, String target,
-            String prefix) {
-        return create(varName, key, secret, null, null, target, prefix);
+            String prefix, boolean... oldStyle) {
+        return create(varName, key, secret, null, null, target, prefix, isOldStyle(oldStyle));
     }
 
     public static KubernetesEnvBuildItem createFromResourceKey(String varName, String key, String secret,
-            String configmap, String target) {
-        return create(varName, key, secret, configmap, null, target, null);
+            String configmap, String target, boolean... oldStyle) {
+        return create(varName, key, secret, configmap, null, target, null, isOldStyle(oldStyle));
     }
 
     public static KubernetesEnvBuildItem create(String name, String value, String secret, String configmap, String field,
-            String target, String prefix) throws IllegalArgumentException {
+            String target, String prefix, boolean... oldStyle) throws IllegalArgumentException {
         final boolean secretPresent = secret != null;
         final boolean configmapPresent = configmap != null;
         final boolean valuePresent = value != null;
@@ -124,11 +129,15 @@ public static KubernetesEnvBuildItem create(String name, String value, String se
         } else {
             type = EnvType.var;
         }
-        return new KubernetesEnvBuildItem(name, value, configmap, secret, field, type, target, prefix);
+        return new KubernetesEnvBuildItem(name, value, configmap, secret, field, type, target, prefix, isOldStyle(oldStyle));
+    }
+
+    private static boolean isOldStyle(boolean[] oldStyle) {
+        return oldStyle.length >= 1 && oldStyle[0];
     }
 
     KubernetesEnvBuildItem(String name, String value, String configmap, String secret, String field, EnvType type,
-            String target, String prefix) {
+            String target, String prefix, boolean oldStyle) {
         super(target);
         this.name = name;
         this.value = value;
@@ -137,6 +146,7 @@ public static KubernetesEnvBuildItem create(String name, String value, String se
         this.field = field;
         this.type = type;
         this.prefix = prefix;
+        this.oldStyle = oldStyle;
     }
 
     public String getConfigMap() {
@@ -151,6 +161,10 @@ public String getField() {
         return field;
     }
 
+    public boolean isOldStyle() {
+        return oldStyle;
+    }
+
     public String getName() {
         return name;
     }
@@ -170,7 +184,7 @@ public String getPrefix() {
     @SuppressWarnings("unused")
     public KubernetesEnvBuildItem newWithTarget(String newTarget) {
         return new KubernetesEnvBuildItem(this.name, this.value, this.configmap, this.secret, this.field, this.type, newTarget,
-                this.prefix);
+                this.prefix, this.oldStyle);
     }
 
     public String toString() {
diff --git a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvConfig.java b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvConfig.java
new file mode 100644
index 00000000000..2c9f4d335b8
--- /dev/null
+++ b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvConfig.java
@@ -0,0 +1,30 @@
+package io.quarkus.kubernetes.deployment;
+
+import java.util.Optional;
+
+public interface EnvConfig {
+    /**
+     * The environment variable name.
+     */
+    Optional<String> name();
+
+    /**
+     * The environment variable value.
+     */
+    Optional<String> value();
+
+    /**
+     * The environment variable secret.
+     */
+    Optional<String> secret();
+
+    /**
+     * The environment variable config map.
+     */
+    Optional<String> configmap();
+
+    /**
+     * The environment variable field.
+     */
+    Optional<String> field();
+}
diff --git a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvConverter.java b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvConverter.java
index 5d2103abd21..a4cbae8a5db 100644
--- a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvConverter.java
+++ b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvConverter.java
@@ -1,30 +1,73 @@
 
 package io.quarkus.kubernetes.deployment;
 
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.stream.Collectors;
 
+import io.dekorate.kubernetes.config.Env;
+import io.dekorate.kubernetes.config.EnvBuilder;
+
 public class EnvConverter {
 
+    public static Env convert(Map.Entry<String, EnvConfig> e) {
+        return convert(e.getValue()).withName(convertName(e.getKey())).build();
+    }
+
+    private static EnvBuilder convert(EnvConfig env) {
+        EnvBuilder b = new EnvBuilder();
+        env.name().ifPresent(b::withName);
+        env.value().ifPresent(b::withValue);
+        env.secret().ifPresent(b::withSecret);
+        env.configmap().ifPresent(b::withConfigmap);
+        env.field().ifPresent(b::withField);
+        return b;
+    }
+
+    public static List<Env> convert(EnvVarsConfig e) {
+        List<Env> envs = new LinkedList<>();
+
+        Map<String, EnvVarPrefixConfig> prefixMap = collectPrefixes(e);
+
+        e.secrets().ifPresent(sl -> sl
+                .forEach(s -> envs.add(new EnvBuilder().withName(convertName(s)).withSecret(s)
+                        .withPrefix(extractSecretPrefix(s, prefixMap).orElse(null)).build())));
+        e.configmaps()
+                .ifPresent(cl -> cl.forEach(c -> envs
+                        .add(new EnvBuilder().withName(convertName(c)).withConfigmap(c)
+                                .withPrefix(extractConfigmapPrefix(c, prefixMap).orElse(null)).build())));
+        e.vars().forEach((k, v) -> envs.add(new EnvBuilder().withName(convertName(k)).withValue(v.value().orElse("")).build()));
+        e.fields().forEach((k, v) -> {
+            // env vars from fields need to have their name set in addition to their field field :)
+            final String field = convertName(k);
+            envs.add(new EnvBuilder().withName(field).withField(field).withValue(v).build());
+        });
+        e.mapping().forEach(
+                (k, v) -> envs.add(new EnvBuilder().withName(convertName(k)).withSecret(v.fromSecret().orElse(null))
+                        .withConfigmap(v.fromConfigmap().orElse(null)).withValue(v.withKey()).build()));
+        return envs;
+    }
+
     public static String convertName(String name) {
         return name != null ? name.toUpperCase().replace('-', '_').replace('.', '_').replace('/', '_') : null;
     }
 
-    static Optional<String> extractSecretPrefix(String secret, Map<String, EnvVarPrefixConfig> mappingWithPrefix) {
+    public static Optional<String> extractSecretPrefix(String secret, Map<String, EnvVarPrefixConfig> mappingWithPrefix) {
         return mappingWithPrefix.entrySet().stream()
                 .filter(m -> m.getValue().hasPrefixForSecret(secret))
                 .findFirst().map(Map.Entry::getKey);
     }
 
-    static Optional<String> extractConfigmapPrefix(String configmap,
+    public static Optional<String> extractConfigmapPrefix(String configmap,
             Map<String, EnvVarPrefixConfig> mappingWithPrefix) {
         return mappingWithPrefix.entrySet().stream()
                 .filter(m -> m.getValue().hasPrefixForConfigmap(configmap))
                 .findFirst().map(Map.Entry::getKey);
     }
 
-    static Map<String, EnvVarPrefixConfig> collectPrefixes(EnvVarsConfig e) {
+    public static Map<String, EnvVarPrefixConfig> collectPrefixes(EnvVarsConfig e) {
         return e.prefixes().entrySet().stream()
                 .filter(p -> p.getValue().anyPresent() && p.getKey() != null && !p.getKey().isBlank())
                 .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
diff --git a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvVarHolder.java b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvVarHolder.java
index be860367b09..adac6203a75 100644
--- a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvVarHolder.java
+++ b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvVarHolder.java
@@ -6,6 +6,7 @@
 
 import java.util.Collection;
 import java.util.Map;
+import java.util.Optional;
 
 import io.quarkus.kubernetes.spi.KubernetesEnvBuildItem;
 
@@ -18,6 +19,12 @@ public interface EnvVarHolder {
      */
     EnvVarsConfig env();
 
+    /**
+     * @deprecated use {@link #env()} instead
+     */
+    @Deprecated
+    Map<String, EnvConfig> envVars();
+
     /**
      * Specifies which the name of the platform this EnvVarHolder targets. This name, when needed, is used by dekorate
      * to generate the descriptor associated with the targeted deployment platform.
@@ -29,15 +36,22 @@ default String targetPlatformName() {
     }
 
     /**
-     * Converts the environment variable configuration held by this EnvVarHolder (as returned by {@link #env()}) into a
-     * collection of associated {@link KubernetesEnvBuildItem}.
+     * Converts the environment variable configuration held by this EnvVarHolder (as returned by {@link #env()} and
+     * {@link #envVars()}) into a collection of associated {@link KubernetesEnvBuildItem}.
      *
      * @return a collection of {@link KubernetesEnvBuildItem} corresponding to the environment variable configurations
      */
     default Collection<KubernetesEnvBuildItem> convertToBuildItems() {
         EnvVarValidator validator = new EnvVarValidator();
 
-        final String target = targetPlatformName();
+        // first process old-style configuration, this relies on each configuration having a name
+        String target = targetPlatformName();
+        envVars().forEach((key, envConfig) -> {
+            validator.process(key, envConfig.value(), envConfig.secret(), envConfig.configmap(), envConfig.field(), target,
+                    Optional.empty(), true);
+        });
+
+        // override old-style with newer versions if present
         final EnvVarsConfig c = env();
         Map<String, EnvVarPrefixConfig> prefixMap = collectPrefixes(c);
 
diff --git a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvVarValidator.java b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvVarValidator.java
index 78743a7b7fd..85c62e5aa0f 100644
--- a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvVarValidator.java
+++ b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/EnvVarValidator.java
@@ -17,6 +17,17 @@ public class EnvVarValidator {
     private final Map<String, Set<KubernetesEnvBuildItem>> conflicting = new HashMap<>();
     private final Set<String> errors = new HashSet<>();
 
+    void process(String name, Optional<String> value, Optional<String> secret, Optional<String> configmap,
+            Optional<String> field, String target, Optional<String> prefix, boolean... oldStyle) {
+        try {
+            final KubernetesEnvBuildItem kebi = KubernetesEnvBuildItem.create(name, value.orElse(null),
+                    secret.orElse(null), configmap.orElse(null), field.orElse(null), target, prefix.orElse(null), oldStyle);
+            process(kebi);
+        } catch (IllegalArgumentException e) {
+            errors.add(e.getMessage());
+        }
+    }
+
     /**
      * Processes the specified {@link KubernetesEnvBuildItem} to check whether it's valid with respect to the set of already
      * known configuration, accumulating errors or outputting warnings if needed.
@@ -32,27 +43,39 @@ void process(KubernetesEnvBuildItem item) {
             // as the item might not get added, reset the wrapper's state
             wrapper.setShouldAdd(false);
             // then go through already added items to check if the item needs to be added, warning logged or error added
-            items.values().stream()
-                    .filter(kebi -> name.equals(kebi.getName()))
-                    .forEach(existing -> {
-                        final KubernetesEnvBuildItem.EnvType existingType = existing.getType();
-                        // if the type doesn't allow multiple definitions, we need to check if we're adding a "compatible" env var
-                        if (!existingType.allowMultipleDefinitions) {
-                            // check if we have a conflict and thus an error
-                            if (existingType.mightConflictWith(type)) {
-                                addError(item, existing);
-                            } else {
-                                // we're not dealing with a potentially conflicting var so add the new item
+            items.values().stream().filter(kebi -> name.equals(kebi.getName())).forEach(existing -> {
+                final KubernetesEnvBuildItem.EnvType existingType = existing.getType();
+                // if the type doesn't allow multiple definitions, we need to check if we're adding a "compatible" env var
+                if (!existingType.allowMultipleDefinitions) {
+                    // check if we have a conflict and thus an error
+                    if (existingType.mightConflictWith(type)) {
+                        // but we first need to check if we're not simply replacing an old style definition by a new one
+                        final boolean currentIsNew = existing.isOldStyle() && !item.isOldStyle();
+                        final boolean existingIsNew = item.isOldStyle() && !existing.isOldStyle();
+                        if ((currentIsNew || existingIsNew) && existingType.equals(type)) {
+                            // only keep definition using new style and output warning
+                            log.warn("Duplicate definition of '" + name
+                                    + "' environment variable. ONLY the quarkus.kubernetes.env prefixed version will be kept: "
+                                    + (currentIsNew ? item : existing));
+                            if (currentIsNew) {
+                                // replace existing, old-style value by current, new-style one
                                 wrapper.setShouldAdd(true);
                             }
                         } else {
-                            if (existingType.mightConflictWith(type)) {
-                                log.warn("Ignoring duplicate definition of " + item);
-                            }
-                            wrapper.setShouldAdd(true);
-
+                            addError(item, existing);
                         }
-                    });
+                    } else {
+                        // we're not dealing with a potentially conflicting var so add the new item
+                        wrapper.setShouldAdd(true);
+                    }
+                } else {
+                    if (existingType.mightConflictWith(type)) {
+                        log.warn("Ignoring duplicate definition of " + item);
+                    }
+                    wrapper.setShouldAdd(true);
+
+                }
+            });
         }
         if (wrapper.shouldAdd()) {
             items.put(ItemKey.keyFor(item), item);
diff --git a/extensions/kubernetes/vanilla/deployment/src/test/java/io/quarkus/kubernetes/deployment/EnvVarValidatorTest.java b/extensions/kubernetes/vanilla/deployment/src/test/java/io/quarkus/kubernetes/deployment/EnvVarValidatorTest.java
index 54adf40140c..747d7052828 100644
--- a/extensions/kubernetes/vanilla/deployment/src/test/java/io/quarkus/kubernetes/deployment/EnvVarValidatorTest.java
+++ b/extensions/kubernetes/vanilla/deployment/src/test/java/io/quarkus/kubernetes/deployment/EnvVarValidatorTest.java
@@ -3,6 +3,7 @@
 import static org.junit.jupiter.api.Assertions.*;
 
 import java.util.Collection;
+import java.util.Optional;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
@@ -87,6 +88,79 @@ void getBuildItemsSimilarlyNamedCompatibleItemsShouldWork() {
         assertTrue(items.contains(first) && items.contains(second) && items.contains(third));
     }
 
+    @Test
+    void getBuildItemsSameItemsOldAndNewShouldWork() {
+        final String name = "name";
+        final String value1 = "foo";
+        final KubernetesEnvBuildItem oldStyleVar = KubernetesEnvBuildItem.createSimpleVar(name, value1, TARGET, true);
+        final KubernetesEnvBuildItem newStyleVar = KubernetesEnvBuildItem.createSimpleVar(name, "newValue", TARGET);
+        validator.process(oldStyleVar);
+        validator.process(newStyleVar);
+        Collection<KubernetesEnvBuildItem> items = validator.getBuildItems();
+        assertEquals(1, items.size());
+        assertTrue(items.contains(newStyleVar));
+
+        // check reverse order
+        validator = new EnvVarValidator();
+        validator.process(newStyleVar);
+        validator.process(oldStyleVar);
+        items = validator.getBuildItems();
+        assertEquals(1, items.size());
+        assertTrue(items.contains(newStyleVar));
+    }
+
+    @Test
+    void getBuildItemsOldConflictShouldNotPreventNewToWork() {
+        /*
+         * quarkus.kubernetes.env.configmaps=configMap
+         * quarkus.kubernetes.env-vars.xxx.configmap=configMap
+         * quarkus.kubernetes.env.secrets=secret
+         * quarkus.kubernetes.env-vars.xxx.secret=secret
+         */
+        final KubernetesEnvBuildItem newCM = KubernetesEnvBuildItem.createFromConfigMap("configmap", TARGET, null);
+        final KubernetesEnvBuildItem newS = KubernetesEnvBuildItem.createFromSecret("secret", TARGET, null);
+        validator.process("foo", Optional.empty(), Optional.empty(), Optional.of("configmap"), Optional.empty(),
+                TARGET, Optional.empty(), true);
+        validator.process(newS);
+        validator.process(newCM);
+        validator.process("foo", Optional.empty(), Optional.of("secret"), Optional.empty(), Optional.empty(),
+                TARGET, Optional.empty(), true);
+        Collection<KubernetesEnvBuildItem> items = validator.getBuildItems();
+        assertEquals(2, items.size());
+        assertTrue(items.contains(newCM));
+        assertTrue(items.contains(newS));
+    }
+
+    @Test
+    void getBuildItemsTwoConflictingItemsUsingDifferentStylesShouldFail() {
+        final String name = "name";
+        final String value1 = "foo";
+        final String value2 = "bar";
+        final KubernetesEnvBuildItem first = KubernetesEnvBuildItem.createSimpleVar(name, value1, TARGET, true);
+        final KubernetesEnvBuildItem second = KubernetesEnvBuildItem.createFromField(name, value2, TARGET);
+        validator.process(first);
+        validator.process(second);
+        try {
+            validator.getBuildItems();
+            fail();
+        } catch (Exception e) {
+            final String message = e.getMessage();
+            assertTrue(message.contains(name) && message.contains(value1) && message.contains(value2));
+        }
+
+        // check different order
+        validator = new EnvVarValidator();
+        validator.process(second);
+        validator.process(first);
+        try {
+            validator.getBuildItems();
+            fail();
+        } catch (Exception e) {
+            final String message = e.getMessage();
+            assertTrue(message.contains(name) && message.contains(value1) && message.contains(value2));
+        }
+    }
+
     @Test
     void getBuildItemsDirectAndFromSecretShouldConflict() {
         final String name = "name";
@@ -120,4 +194,27 @@ void getBuildItemsDirectAndFromSecretShouldConflict() {
                     message.contains(name) && message.contains(value1) && message.contains(configmap) && message.contains(key));
         }
     }
+
+    @Test
+    void getBuildItemsUsingOldStyleProcessAndNewStyleCreateForSameItemShouldKeepNewStyle() {
+        final String name = "name";
+        final String configmap = "configmap";
+        final String key = "key";
+        final KubernetesEnvBuildItem first = KubernetesEnvBuildItem.createFromConfigMapKey(name, key, configmap, null, TARGET);
+        validator.process(first);
+        validator.process(name, Optional.of("oldKey"), Optional.empty(), Optional.of(configmap), Optional.empty(),
+                TARGET, Optional.empty(), true);
+        Collection<KubernetesEnvBuildItem> buildItems = validator.getBuildItems();
+        assertEquals(1, buildItems.size());
+        assertTrue(buildItems.contains(first));
+
+        // check different order
+        validator = new EnvVarValidator();
+        validator.process(name, Optional.of("oldKey"), Optional.empty(), Optional.of(configmap), Optional.empty(),
+                TARGET, Optional.empty(), true);
+        validator.process(first);
+        buildItems = validator.getBuildItems();
+        assertEquals(1, buildItems.size());
+        assertTrue(buildItems.contains(first));
+    }
 }
diff --git a/extensions/resteasy-reactive/rest-common/runtime/src/main/java/io/quarkus/resteasy/reactive/common/runtime/ResteasyReactiveConfig.java b/extensions/resteasy-reactive/rest-common/runtime/src/main/java/io/quarkus/resteasy/reactive/common/runtime/ResteasyReactiveConfig.java
index 94db6a36c9b..cbff8c36f92 100644
--- a/extensions/resteasy-reactive/rest-common/runtime/src/main/java/io/quarkus/resteasy/reactive/common/runtime/ResteasyReactiveConfig.java
+++ b/extensions/resteasy-reactive/rest-common/runtime/src/main/java/io/quarkus/resteasy/reactive/common/runtime/ResteasyReactiveConfig.java
@@ -1,5 +1,8 @@
 package io.quarkus.resteasy.reactive.common.runtime;
 
+import java.util.List;
+import java.util.Optional;
+
 import io.quarkus.runtime.annotations.ConfigPhase;
 import io.quarkus.runtime.annotations.ConfigRoot;
 import io.quarkus.runtime.configuration.MemorySize;
@@ -11,6 +14,11 @@
 @ConfigRoot(phase = ConfigPhase.BUILD_AND_RUN_TIME_FIXED)
 public interface ResteasyReactiveConfig {
 
+    /**
+     * Exception mapping configuration.
+     */
+    ExceptionMappingConfig exceptionMapping();
+
     /**
      * The amount of memory that can be used to buffer input before switching to
      * blocking IO, up to {@code Long.MAX_VALUE} bytes.
@@ -81,4 +89,15 @@ public interface ResteasyReactiveConfig {
      */
     @WithDefault("true")
     boolean removesTrailingSlash();
+
+    /**
+     * Configuration for exception mapping.
+     */
+    interface ExceptionMappingConfig {
+        /**
+         * A list of exception mapper classes that should be disabled.
+         * This allows users to override the default built-in exception mappers provided by Quarkus extensions.
+         */
+        Optional<List<String>> disableMapperFor();
+    }
 }
diff --git a/extensions/resteasy-reactive/rest-jackson/deployment/src/test/java/io/quarkus/resteasy/reactive/jackson/deployment/test/ExceptionInReaderWithDisabledBuiltInMapperTest.java b/extensions/resteasy-reactive/rest-jackson/deployment/src/test/java/io/quarkus/resteasy/reactive/jackson/deployment/test/ExceptionInReaderWithDisabledBuiltInMapperTest.java
new file mode 100644
index 00000000000..24332387776
--- /dev/null
+++ b/extensions/resteasy-reactive/rest-jackson/deployment/src/test/java/io/quarkus/resteasy/reactive/jackson/deployment/test/ExceptionInReaderWithDisabledBuiltInMapperTest.java
@@ -0,0 +1,46 @@
+package io.quarkus.resteasy.reactive.jackson.deployment.test;
+
+import java.util.function.Supplier;
+
+import jakarta.ws.rs.core.Response;
+import jakarta.ws.rs.ext.ExceptionMapper;
+import jakarta.ws.rs.ext.Provider;
+
+import org.jboss.shrinkwrap.api.ShrinkWrap;
+import org.jboss.shrinkwrap.api.spec.JavaArchive;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import com.fasterxml.jackson.databind.JsonMappingException;
+
+import io.quarkus.test.QuarkusUnitTest;
+import io.restassured.RestAssured;
+
+public class ExceptionInReaderWithDisabledBuiltInMapperTest {
+
+    @RegisterExtension
+    static QuarkusUnitTest test = new QuarkusUnitTest()
+            .setArchiveProducer(new Supplier<>() {
+                @Override
+                public JavaArchive get() {
+                    return ShrinkWrap.create(JavaArchive.class)
+                            .addClasses(FroMage.class, FroMageEndpoint.class, CustomJsonMappingExceptionMapper.class);
+                }
+            }).overrideConfigKey("quarkus.rest.exception-mapping.disable-mapper-for",
+                    "io.quarkus.resteasy.reactive.jackson.runtime.mappers.BuiltinMismatchedInputExceptionMapper");
+
+    @Test
+    public void test() {
+        RestAssured.with().contentType("application/json").body("{\"price\": \"ten\"}").put("/fromage")
+                .then().statusCode(888);
+    }
+
+    @Provider
+    public static class CustomJsonMappingExceptionMapper implements ExceptionMapper<JsonMappingException> {
+
+        @Override
+        public Response toResponse(JsonMappingException exception) {
+            return Response.status(888).entity("Custom mapper handled: " + exception.getMessage()).build();
+        }
+    }
+}
diff --git a/extensions/resteasy-reactive/rest/deployment/src/main/java/io/quarkus/resteasy/reactive/server/deployment/ResteasyReactiveScanningProcessor.java b/extensions/resteasy-reactive/rest/deployment/src/main/java/io/quarkus/resteasy/reactive/server/deployment/ResteasyReactiveScanningProcessor.java
index ef7923b16eb..a36a63a30c6 100644
--- a/extensions/resteasy-reactive/rest/deployment/src/main/java/io/quarkus/resteasy/reactive/server/deployment/ResteasyReactiveScanningProcessor.java
+++ b/extensions/resteasy-reactive/rest/deployment/src/main/java/io/quarkus/resteasy/reactive/server/deployment/ResteasyReactiveScanningProcessor.java
@@ -65,6 +65,7 @@
 import io.quarkus.resteasy.reactive.common.deployment.ApplicationResultBuildItem;
 import io.quarkus.resteasy.reactive.common.deployment.ResourceInterceptorsContributorBuildItem;
 import io.quarkus.resteasy.reactive.common.deployment.ResourceScanningResultBuildItem;
+import io.quarkus.resteasy.reactive.common.runtime.ResteasyReactiveConfig;
 import io.quarkus.resteasy.reactive.server.spi.MethodScannerBuildItem;
 import io.quarkus.resteasy.reactive.server.spi.UnwrappedExceptionBuildItem;
 import io.quarkus.resteasy.reactive.spi.ContainerRequestFilterBuildItem;
@@ -189,11 +190,20 @@ public ExceptionMappersBuildItem scanForExceptionMappers(CombinedIndexBuildItem
             BuildProducer<AdditionalBeanBuildItem> additionalBeanBuildItemBuildProducer,
             BuildProducer<ReflectiveClassBuildItem> reflectiveClassBuildItemBuildProducer,
             List<ExceptionMapperBuildItem> mappers, List<UnwrappedExceptionBuildItem> unwrappedExceptions,
-            Capabilities capabilities) {
+            Capabilities capabilities,
+            ResteasyReactiveConfig config) {
         AdditionalBeanBuildItem.Builder beanBuilder = AdditionalBeanBuildItem.builder().setUnremovable();
         ExceptionMapping exceptions = ResteasyReactiveExceptionMappingScanner
                 .scanForExceptionMappers(combinedIndexBuildItem.getComputingIndex(), applicationResultBuildItem.getResult());
 
+        if (config.exceptionMapping().disableMapperFor().isPresent()) {
+            for (String disabledMapper : config.exceptionMapping().disableMapperFor().get()) {
+                if (disabledMapper != null && !disabledMapper.isEmpty()) {
+                    exceptions.addDisabledMapper(disabledMapper);
+                }
+            }
+        }
+
         exceptions.addBlockingProblem(BlockingOperationNotAllowedException.class);
         exceptions.addBlockingProblem(BlockingNotAllowedException.class);
         for (UnwrappedExceptionBuildItem bi : unwrappedExceptions) {
diff --git a/independent-projects/resteasy-reactive/server/runtime/src/main/java/org/jboss/resteasy/reactive/server/core/ExceptionMapping.java b/independent-projects/resteasy-reactive/server/runtime/src/main/java/org/jboss/resteasy/reactive/server/core/ExceptionMapping.java
index b300a0bf1c1..0970800b2f7 100644
--- a/independent-projects/resteasy-reactive/server/runtime/src/main/java/org/jboss/resteasy/reactive/server/core/ExceptionMapping.java
+++ b/independent-projects/resteasy-reactive/server/runtime/src/main/java/org/jboss/resteasy/reactive/server/core/ExceptionMapping.java
@@ -3,8 +3,10 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
@@ -31,6 +33,11 @@ public class ExceptionMapping {
     // this is going to be used when there are mappers that are removable at runtime
     final Map<String, List<ResourceExceptionMapper<? extends Throwable>>> runtimeCheckMappers = new HashMap<>();
 
+    /**
+     * Exception mapper class names that should be disabled.
+     */
+    final Set<String> disabledMappers = new HashSet<>();
+
     /**
      * Exceptions that indicate an blocking operation was performed on an IO thread.
      * <p>
@@ -126,9 +133,17 @@ public Map<String, List<ResourceExceptionMapper<? extends Throwable>>> getRuntim
         return runtimeCheckMappers;
     }
 
+    public Set<String> getDisabledMappers() {
+        return disabledMappers;
+    }
+
+    public void addDisabledMapper(String mapperClassName) {
+        disabledMappers.add(mapperClassName);
+    }
+
     public Map<String, ResourceExceptionMapper<? extends Throwable>> effectiveMappers() {
         if (runtimeCheckMappers.isEmpty()) {
-            return mappers;
+            return filterDisabledMappers(mappers);
         }
         Map<String, ResourceExceptionMapper<? extends Throwable>> result = new HashMap<>();
         for (var entry : runtimeCheckMappers.entrySet()) {
@@ -147,6 +162,20 @@ public Map<String, ResourceExceptionMapper<? extends Throwable>> effectiveMapper
             }
         }
         result.putAll(mappers);
+        return filterDisabledMappers(result);
+    }
+
+    private Map<String, ResourceExceptionMapper<? extends Throwable>> filterDisabledMappers(
+            Map<String, ResourceExceptionMapper<? extends Throwable>> mappers) {
+        if (disabledMappers.isEmpty()) {
+            return mappers;
+        }
+        Map<String, ResourceExceptionMapper<? extends Throwable>> result = new HashMap<>();
+        for (Map.Entry<String, ResourceExceptionMapper<? extends Throwable>> entry : mappers.entrySet()) {
+            if (!disabledMappers.contains(entry.getValue().getClassName())) {
+                result.put(entry.getKey(), entry.getValue());
+            }
+        }
         return result;
     }
 
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesWithMixedStyleEnvTest.java b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesWithMixedStyleEnvTest.java
new file mode 100644
index 00000000000..bda40f4dc76
--- /dev/null
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesWithMixedStyleEnvTest.java
@@ -0,0 +1,73 @@
+package io.quarkus.it.kubernetes;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.fabric8.kubernetes.api.model.EnvFromSource;
+import io.fabric8.kubernetes.api.model.HasMetadata;
+import io.fabric8.kubernetes.api.model.apps.Deployment;
+import io.quarkus.test.ProdBuildResults;
+import io.quarkus.test.ProdModeTestResults;
+import io.quarkus.test.QuarkusProdModeTest;
+
+public class KubernetesWithMixedStyleEnvTest {
+    private static final String APPLICATION_NAME = "mixed-style";
+
+    @RegisterExtension
+    static final QuarkusProdModeTest config = new QuarkusProdModeTest()
+            .withApplicationRoot((jar) -> jar.addClasses(GreetingResource.class))
+            .setApplicationName(APPLICATION_NAME)
+            .setApplicationVersion("0.1-SNAPSHOT")
+            .withConfigurationResource("kubernetes-with-" + APPLICATION_NAME + "-env.properties");
+
+    @ProdBuildResults
+    private ProdModeTestResults prodModeTestResults;
+
+    @Test
+    public void assertGeneratedResources() throws IOException {
+        Path kubernetesDir = prodModeTestResults.getBuildDir().resolve("kubernetes");
+        assertThat(kubernetesDir)
+                .isDirectoryContaining(p -> p.getFileName().endsWith("kubernetes.json"))
+                .isDirectoryContaining(p -> p.getFileName().endsWith("kubernetes.yml"));
+        List<HasMetadata> kubernetesList = DeserializationUtil
+                .deserializeAsList(kubernetesDir.resolve("kubernetes.yml"));
+        assertThat(kubernetesList.get(0)).isInstanceOfSatisfying(Deployment.class, d -> {
+            assertThat(d.getMetadata()).satisfies(m -> {
+                assertThat(m.getName()).isEqualTo(APPLICATION_NAME);
+            });
+
+            assertThat(d.getSpec()).satisfies(deploymentSpec -> {
+                assertThat(deploymentSpec.getTemplate()).satisfies(t -> {
+                    assertThat(t.getSpec()).satisfies(podSpec -> {
+                        assertThat(podSpec.getContainers()).singleElement().satisfies(container -> {
+                            assertThat(container.getEnv())
+                                    .filteredOn(env -> "FROMFIELD".equals(env.getName()))
+                                    .singleElement().satisfies(
+                                            env -> assertThat(env.getValueFrom().getFieldRef().getFieldPath())
+                                                    .isEqualTo("metadata.name"));
+                            assertThat(container.getEnv())
+                                    .filteredOn(env -> "ENVVAR".equals(env.getName()))
+                                    .singleElement().satisfies(env -> assertThat(env.getValue()).isEqualTo("value"));
+                            final List<EnvFromSource> envFrom = container.getEnvFrom();
+                            assertThat(envFrom).hasSize(2);
+                            assertThat(envFrom)
+                                    .filteredOn(e -> e.getSecretRef() != null)
+                                    .singleElement().satisfies(
+                                            e -> assertThat(e.getSecretRef().getName()).isEqualTo("secretName"));
+                            assertThat(envFrom)
+                                    .filteredOn(e -> e.getConfigMapRef() != null)
+                                    .singleElement().satisfies(
+                                            e -> assertThat(e.getConfigMapRef().getName()).isEqualTo("configName"));
+                        });
+                    });
+                });
+            });
+        });
+    }
+}
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesWithOldStyleEnvTest.java b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesWithOldStyleEnvTest.java
new file mode 100644
index 00000000000..554e7c5f8c6
--- /dev/null
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesWithOldStyleEnvTest.java
@@ -0,0 +1,70 @@
+package io.quarkus.it.kubernetes;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.fabric8.kubernetes.api.model.EnvFromSource;
+import io.fabric8.kubernetes.api.model.HasMetadata;
+import io.fabric8.kubernetes.api.model.apps.Deployment;
+import io.quarkus.test.ProdBuildResults;
+import io.quarkus.test.ProdModeTestResults;
+import io.quarkus.test.QuarkusProdModeTest;
+
+public class KubernetesWithOldStyleEnvTest {
+
+    private static final String APPLICATION_NAME = "old-style-env";
+
+    @RegisterExtension
+    static final QuarkusProdModeTest config = new QuarkusProdModeTest()
+            .withApplicationRoot((jar) -> jar.addClasses(GreetingResource.class))
+            .setApplicationName(APPLICATION_NAME)
+            .setApplicationVersion("0.1-SNAPSHOT")
+            .withConfigurationResource("kubernetes-with-old-style-env.properties");
+
+    @ProdBuildResults
+    private ProdModeTestResults prodModeTestResults;
+
+    @Test
+    public void assertGeneratedResources() throws IOException {
+        Path kubernetesDir = prodModeTestResults.getBuildDir().resolve("kubernetes");
+        assertThat(kubernetesDir)
+                .isDirectoryContaining(p -> p.getFileName().endsWith("kubernetes.json"))
+                .isDirectoryContaining(p -> p.getFileName().endsWith("kubernetes.yml"));
+        List<HasMetadata> kubernetesList = DeserializationUtil
+                .deserializeAsList(kubernetesDir.resolve("kubernetes.yml"));
+        assertThat(kubernetesList.get(0)).isInstanceOfSatisfying(Deployment.class, d -> {
+            assertThat(d.getMetadata()).satisfies(m -> {
+                assertThat(m.getName()).isEqualTo(APPLICATION_NAME);
+            });
+
+            assertThat(d.getSpec()).satisfies(deploymentSpec -> {
+                assertThat(deploymentSpec.getTemplate()).satisfies(t -> {
+                    assertThat(t.getSpec()).satisfies(podSpec -> {
+                        assertThat(podSpec.getContainers()).singleElement().satisfies(container -> {
+                            assertThat(container.getEnv())
+                                    .filteredOn(env -> "FROMFIELD".equals(env.getName()))
+                                    .singleElement().satisfies(
+                                            env -> assertThat(env.getValueFrom().getFieldRef().getFieldPath())
+                                                    .isEqualTo("metadata.name"));
+                            assertThat(container.getEnv())
+                                    .filteredOn(env -> "ENVVAR".equals(env.getName()))
+                                    .singleElement().satisfies(env -> assertThat(env.getValue()).isEqualTo("value"));
+                            final List<EnvFromSource> envFrom = container.getEnvFrom();
+                            assertThat(envFrom).hasSize(1);
+                            assertThat(envFrom)
+                                    .filteredOn(e -> e.getSecretRef() != null)
+                                    .singleElement().satisfies(
+                                            e -> assertThat(e.getSecretRef().getName()).isEqualTo("secretName"));
+                        });
+                    });
+                });
+            });
+        });
+    }
+}
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesWithWarningsEnvTest.java b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesWithWarningsEnvTest.java
new file mode 100644
index 00000000000..13c69c64fe7
--- /dev/null
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesWithWarningsEnvTest.java
@@ -0,0 +1,93 @@
+package io.quarkus.it.kubernetes;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.logging.LogRecord;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.fabric8.kubernetes.api.model.EnvFromSource;
+import io.fabric8.kubernetes.api.model.HasMetadata;
+import io.fabric8.kubernetes.api.model.apps.Deployment;
+import io.quarkus.test.ProdBuildResults;
+import io.quarkus.test.ProdModeTestResults;
+import io.quarkus.test.QuarkusProdModeTest;
+
+public class KubernetesWithWarningsEnvTest {
+    private static final String APPLICATION_NAME = "warnings";
+
+    @RegisterExtension
+    static final QuarkusProdModeTest config = new QuarkusProdModeTest()
+            .withApplicationRoot((jar) -> jar.addClasses(GreetingResource.class))
+            .setApplicationName(APPLICATION_NAME)
+            .setApplicationVersion("0.1-SNAPSHOT")
+            .setLogRecordPredicate(r -> "io.quarkus.kubernetes.deployment.EnvVarValidator".equals(r.getLoggerName())
+                    || "io.quarkus.kubernetes.spi.KubernetesEnvBuildItem".equals(r.getLoggerName()))
+            .withConfigurationResource("kubernetes-with-" + APPLICATION_NAME + "-env.properties");
+
+    @ProdBuildResults
+    private ProdModeTestResults prodModeTestResults;
+
+    @Test
+    public void ensureProperQuarkusPropertiesLogged() throws IOException {
+        Path kubernetesDir = prodModeTestResults.getBuildDir().resolve("kubernetes");
+        assertThat(kubernetesDir)
+                .isDirectoryContaining(p -> p.getFileName().endsWith("kubernetes.json"))
+                .isDirectoryContaining(p -> p.getFileName().endsWith("kubernetes.yml"));
+        List<HasMetadata> kubernetesList = DeserializationUtil
+                .deserializeAsList(kubernetesDir.resolve("kubernetes.yml"));
+        assertThat(kubernetesList.get(0)).isInstanceOfSatisfying(Deployment.class, d -> {
+            assertThat(d.getMetadata()).satisfies(m -> {
+                assertThat(m.getName()).isEqualTo(APPLICATION_NAME);
+            });
+
+            assertThat(d.getSpec()).satisfies(deploymentSpec -> {
+                assertThat(deploymentSpec.getTemplate()).satisfies(t -> {
+                    assertThat(t.getSpec()).satisfies(podSpec -> {
+                        assertThat(podSpec.getContainers()).singleElement().satisfies(container -> {
+                            assertThat(container.getEnv())
+                                    .filteredOn(env -> "MY_FIELD".equals(env.getName()))
+                                    .singleElement().satisfies(
+                                            env -> assertThat(env.getValueFrom().getFieldRef().getFieldPath())
+                                                    .isEqualTo("newField"));
+                            assertThat(container.getEnv())
+                                    .filteredOn(env -> "MY_VAR".equals(env.getName()))
+                                    .singleElement().satisfies(env -> assertThat(env.getValue()).isEqualTo("newVariable"));
+                            final List<EnvFromSource> envFrom = container.getEnvFrom();
+                            assertThat(envFrom).hasSize(2);
+                            assertThat(envFrom)
+                                    .filteredOn(e -> e.getSecretRef() != null)
+                                    .singleElement().satisfies(
+                                            e -> assertThat(e.getSecretRef().getName()).isEqualTo("secret"));
+                            assertThat(envFrom)
+                                    .filteredOn(e -> e.getConfigMapRef() != null)
+                                    .singleElement().satisfies(
+                                            e -> assertThat(e.getConfigMapRef().getName()).isEqualTo("configMap"));
+                        });
+                    });
+                });
+            });
+        });
+
+        List<LogRecord> buildLogRecords = prodModeTestResults.getRetainedBuildLogRecords();
+        buildLogRecords.forEach(l -> System.out.println("l = " + l.getMessage()));
+        assertThat(buildLogRecords).hasSize(4);
+        assertThat(buildLogRecords)
+                .filteredOn(r -> r.getMessage().contains("my-field"))
+                .singleElement().satisfies(r -> assertThat(r.getMessage()).contains("newField"));
+        assertThat(buildLogRecords)
+                .filteredOn(r -> r.getMessage().contains("my-var"))
+                .singleElement().satisfies(r -> assertThat(r.getMessage()).contains("newVariable"));
+        assertThat(buildLogRecords)
+                .filteredOn(r -> r.getMessage().contains("configMap"))
+                .singleElement().satisfies(
+                        r -> assertThat(r.getMessage().contains("'xxx'") && r.getMessage().contains("'secret'")));
+        assertThat(buildLogRecords)
+                .filteredOn(r -> r.getMessage().contains("secret"))
+                .hasSize(2);
+    }
+}
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/MinikubeWithApplicationPropertiesTest.java b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/MinikubeWithApplicationPropertiesTest.java
index 53315ca902f..f47aa065c95 100644
--- a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/MinikubeWithApplicationPropertiesTest.java
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/MinikubeWithApplicationPropertiesTest.java
@@ -1,4 +1,3 @@
-
 package io.quarkus.it.kubernetes;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -12,7 +11,6 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
-import io.fabric8.kubernetes.api.model.EnvFromSource;
 import io.fabric8.kubernetes.api.model.HasMetadata;
 import io.fabric8.kubernetes.api.model.Service;
 import io.fabric8.kubernetes.api.model.apps.Deployment;
@@ -59,24 +57,6 @@ public void assertGeneratedResources() throws IOException {
                         assertThat(t.getSpec()).satisfies(podSpec -> {
                             assertThat(podSpec.getContainers()).singleElement().satisfies(container -> {
                                 assertThat(container.getImagePullPolicy()).isEqualTo("IfNotPresent");
-                                assertThat(container.getEnv())
-                                        .filteredOn(env -> "FROMFIELD".equals(env.getName()))
-                                        .singleElement().satisfies(
-                                                env -> assertThat(env.getValueFrom().getFieldRef().getFieldPath())
-                                                        .isEqualTo("metadata.name"));
-                                assertThat(container.getEnv())
-                                        .filteredOn(env -> "ENVVAR".equals(env.getName()))
-                                        .singleElement().satisfies(env -> assertThat(env.getValue()).isEqualTo("value"));
-                                final List<EnvFromSource> envFrom = container.getEnvFrom();
-                                assertThat(envFrom).hasSize(2);
-                                assertThat(envFrom)
-                                        .filteredOn(e -> e.getSecretRef() != null)
-                                        .singleElement().satisfies(
-                                                e -> assertThat(e.getSecretRef().getName()).isEqualTo("secretName"));
-                                assertThat(envFrom)
-                                        .filteredOn(e -> e.getConfigMapRef() != null)
-                                        .singleElement().satisfies(
-                                                e -> assertThat(e.getConfigMapRef().getName()).isEqualTo("configName"));
                             });
                         });
                     });
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/MinikubeWithMixedStyleEnvTest.java b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/MinikubeWithMixedStyleEnvTest.java
new file mode 100644
index 00000000000..fe294035bdd
--- /dev/null
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/MinikubeWithMixedStyleEnvTest.java
@@ -0,0 +1,74 @@
+package io.quarkus.it.kubernetes;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.fabric8.kubernetes.api.model.EnvFromSource;
+import io.fabric8.kubernetes.api.model.HasMetadata;
+import io.fabric8.kubernetes.api.model.apps.Deployment;
+import io.quarkus.builder.Version;
+import io.quarkus.maven.dependency.Dependency;
+import io.quarkus.test.ProdBuildResults;
+import io.quarkus.test.ProdModeTestResults;
+import io.quarkus.test.QuarkusProdModeTest;
+
+public class MinikubeWithMixedStyleEnvTest {
+
+    @RegisterExtension
+    static final QuarkusProdModeTest config = new QuarkusProdModeTest()
+            .withApplicationRoot((jar) -> jar.addClasses(GreetingResource.class))
+            .setApplicationName("minikube-with-mixed-style-env")
+            .setApplicationVersion("0.1-SNAPSHOT")
+            .withConfigurationResource("minikube-with-mixed-style-env.properties")
+            .setForcedDependencies(List.of(Dependency.of("io.quarkus", "quarkus-minikube", Version.getVersion())));
+
+    @ProdBuildResults
+    private ProdModeTestResults prodModeTestResults;
+
+    @Test
+    public void assertGeneratedResources() throws IOException {
+        Path kubernetesDir = prodModeTestResults.getBuildDir().resolve("kubernetes");
+        assertThat(kubernetesDir)
+                .isDirectoryContaining(p -> p.getFileName().endsWith("minikube.json"))
+                .isDirectoryContaining(p -> p.getFileName().endsWith("minikube.yml"));
+        List<HasMetadata> kubernetesList = DeserializationUtil
+                .deserializeAsList(kubernetesDir.resolve("minikube.yml"));
+
+        assertThat(kubernetesList).filteredOn(i -> "Deployment".equals(i.getKind())).singleElement().satisfies(i -> {
+            assertThat(i).isInstanceOfSatisfying(Deployment.class, d -> {
+                assertThat(d.getSpec()).satisfies(deploymentSpec -> {
+                    assertThat(deploymentSpec.getTemplate()).satisfies(t -> {
+                        assertThat(t.getSpec()).satisfies(podSpec -> {
+                            assertThat(podSpec.getContainers()).singleElement().satisfies(container -> {
+                                assertThat(container.getEnv())
+                                        .filteredOn(env -> "FROMFIELD".equals(env.getName()))
+                                        .singleElement().satisfies(
+                                                env -> assertThat(env.getValueFrom().getFieldRef().getFieldPath())
+                                                        .isEqualTo("metadata.name"));
+                                assertThat(container.getEnv())
+                                        .filteredOn(env -> "ENVVAR".equals(env.getName()))
+                                        .singleElement().satisfies(env -> assertThat(env.getValue()).isEqualTo("value"));
+                                final List<EnvFromSource> envFrom = container.getEnvFrom();
+                                assertThat(envFrom).hasSize(2);
+                                assertThat(envFrom)
+                                        .filteredOn(e -> e.getSecretRef() != null)
+                                        .singleElement().satisfies(
+                                                e -> assertThat(e.getSecretRef().getName()).isEqualTo("secretName"));
+                                assertThat(envFrom)
+                                        .filteredOn(e -> e.getConfigMapRef() != null)
+                                        .singleElement().satisfies(
+                                                e -> assertThat(e.getConfigMapRef().getName()).isEqualTo("configName"));
+                            });
+                        });
+                    });
+                });
+            });
+        });
+    }
+}
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-application.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-application.properties
index cb21895eab9..698af3b9baa 100644
--- a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-application.properties
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-application.properties
@@ -3,8 +3,8 @@ quarkus.kubernetes.name=test-it
 quarkus.kubernetes.namespace=applications
 quarkus.kubernetes.labels.foo=bar
 quarkus.kubernetes.annotations.bar=baz
-quarkus.kubernetes.env.vars.my-env-var=SOMEVALUE
-quarkus.kubernetes.env.fields.my-name=metadata.name
+quarkus.kubernetes.env-vars.my-env-var.value=SOMEVALUE
+quarkus.kubernetes.env-vars.my-name.field=metadata.name
 quarkus.kubernetes.add-version-to-label-selectors=false
 quarkus.container-image.group=grp
 quarkus.container-image.registry=quay.io
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-env-from-configmap.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-env-from-configmap.properties
index a915735a4f3..de149a60265 100644
--- a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-env-from-configmap.properties
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-env-from-configmap.properties
@@ -1,3 +1,4 @@
-quarkus.kubernetes.env.configmaps=my-configmap
-quarkus.kubernetes.env.mapping.DB_DATABASE.from-configmap=db-config
-quarkus.kubernetes.env.mapping.DB_DATABASE.with-key=database.name
+quarkus.kubernetes.env-vars.ignored.configmap=my-configmap
+
+quarkus.kubernetes.env-vars.DB_DATABASE.configmap=db-config
+quarkus.kubernetes.env-vars.DB_DATABASE.value=database.name
\ No newline at end of file
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-env-from-field.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-env-from-field.properties
index c345b610300..ad30527b4de 100644
--- a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-env-from-field.properties
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-env-from-field.properties
@@ -1 +1 @@
-quarkus.kubernetes.env.fields.my-name=metadata.name
+quarkus.kubernetes.env-vars.my-name.field=metadata.name
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-mixed-style-env.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-mixed-style-env.properties
new file mode 100644
index 00000000000..ca9d181b770
--- /dev/null
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-mixed-style-env.properties
@@ -0,0 +1,6 @@
+quarkus.kubernetes.env-vars.envvar.value=value
+quarkus.kubernetes.env-vars.my-name.secret=secretName
+quarkus.kubernetes.env.fields.fromfield=metadata.name
+quarkus.kubernetes.env.configmaps=configName
+
+
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-old-style-env.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-old-style-env.properties
new file mode 100644
index 00000000000..114da239864
--- /dev/null
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-old-style-env.properties
@@ -0,0 +1,4 @@
+quarkus.kubernetes.env-vars.fromfield.field=metadata.name
+quarkus.kubernetes.env-vars.envvar.value=value
+quarkus.kubernetes.env-vars.my-name.configmap=configName
+quarkus.kubernetes.env-vars.my-name.secret=secretName
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-sidecar-and-jib.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-sidecar-and-jib.properties
index 0288cc5595f..45a41b5cc8c 100644
--- a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-sidecar-and-jib.properties
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-sidecar-and-jib.properties
@@ -8,8 +8,8 @@ quarkus.kubernetes.sidecars.sc.working-dir=/work
 quarkus.kubernetes.sidecars.sc.arguments=-l
 quarkus.kubernetes.sidecars.sc.mounts.app-config.path=/deployments/config
 quarkus.kubernetes.sidecars.sc.ports.http.container-port=3000
-quarkus.kubernetes.sidecars.sc.env.vars.foo=bar
+quarkus.kubernetes.sidecars.sc.env-vars.foo.value=bar
 quarkus.kubernetes.sidecars.sc.resources.requests.memory=201Mi
 quarkus.kubernetes.sidecars.sc.resources.limits.memory=200Mi
 quarkus.kubernetes.sidecars.sc.resources.requests.cpu=102m
-quarkus.kubernetes.sidecars.sc.resources.limits.cpu=100m
+quarkus.kubernetes.sidecars.sc.resources.limits.cpu=100m
\ No newline at end of file
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-warnings-env.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-warnings-env.properties
new file mode 100644
index 00000000000..3b831131e71
--- /dev/null
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/kubernetes-with-warnings-env.properties
@@ -0,0 +1,8 @@
+quarkus.kubernetes.env.fields.my-field=newField
+quarkus.kubernetes.env-vars.my-field.field=oldField
+quarkus.kubernetes.env-vars.my-var.value=oldVariable
+quarkus.kubernetes.env.vars.my-var=newVariable
+quarkus.kubernetes.env.configmaps=configMap
+quarkus.kubernetes.env-vars.xxx.configmap=configMap
+quarkus.kubernetes.env.secrets=secret
+quarkus.kubernetes.env-vars.xxx.secret=secret
\ No newline at end of file
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/minikube-with-application.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/minikube-with-application.properties
index e98de423837..b997cb52c87 100644
--- a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/minikube-with-application.properties
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/minikube-with-application.properties
@@ -4,7 +4,3 @@ quarkus.http.port=9090
 quarkus.kubernetes.node-port=31999
 quarkus.kubernetes.labels.foo=bar
 quarkus.kubernetes.annotations.bar=baz
-quarkus.kubernetes.env.vars.envvar=value
-quarkus.kubernetes.env.secrets=secretName
-quarkus.kubernetes.env.fields.fromfield=metadata.name
-quarkus.kubernetes.env.configmaps=configName
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/minikube-with-mixed-style-env.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/minikube-with-mixed-style-env.properties
new file mode 100644
index 00000000000..d5ce0b7ec85
--- /dev/null
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/minikube-with-mixed-style-env.properties
@@ -0,0 +1,7 @@
+quarkus.kubernetes.deployment-target=minikube
+quarkus.kubernetes.env-vars.envvar.value=value
+quarkus.kubernetes.env-vars.my-name.secret=secretName
+quarkus.kubernetes.env.fields.fromfield=metadata.name
+quarkus.kubernetes.env.configmaps=configName
+
+
diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/openshift-with-application.properties b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/openshift-with-application.properties
index 432e83585cc..854044beed6 100644
--- a/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/openshift-with-application.properties
+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/resources/openshift-with-application.properties
@@ -4,7 +4,7 @@ quarkus.openshift.name=test-it
 quarkus.openshift.namespace=applications
 quarkus.openshift.labels.foo=bar
 quarkus.openshift.annotations.bar=baz
-quarkus.openshift.env.vars.my-env-var=SOMEVALUE
+quarkus.openshift.env-vars.my-env-var.value=SOMEVALUE
 quarkus.openshift.group=grp
 quarkus.openshift.route.expose=true
 quarkus.openshift.registry=quay.io
