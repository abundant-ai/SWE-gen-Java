On Kotlin/Native platforms, creating a `SelectorManager` with a caller-provided coroutine dispatcher is currently ignored: the selector manager starts its own dedicated thread/worker instead of running its selection loop on the provided dispatcher. This differs from JVM behavior, where a provided dispatcher is honored and the selector can run on a shared IO pool.

Fix `SelectorManager` (and the native selector implementation it uses) so that when a dispatcher is supplied it is actually used for selector processing on Native, instead of creating a separate thread per `SelectorManager`. The behavior should match JVM semantics: if an IO dispatcher (or any dispatcher) is passed, selector work should execute in that context and avoid spinning up an extra thread unnecessarily.

Additionally, closing sockets and the selector on Native must reliably close the underlying POSIX file descriptors. After calling `close()` on a native UDP datagram socket (e.g., `DatagramSocketNative`) or native TCP server/client sockets (e.g., `TCPServerSocketNative`, `TCPSocketNative`), and after calling `SelectorManager.close()`, awaiting closure via `awaitClosed()` must complete and the associated `descriptor` must be invalid at the OS level (i.e., `fcntl(descriptor, F_GETFL)` should fail with `EBADF`). This must hold for:

- A bound UDP socket that is closed, then the selector is closed, then `socket.awaitClosed()` is awaited.
- A bound TCP server socket that is closed, then the selector is closed, then `socket.awaitClosed()` is awaited.
- A TCP server accepting a client connection where both sides open a read channel (`openReadChannel()`), then the server connection, client connection, server socket, and selector are closed; `awaitClosed()` on each must complete and all three descriptors (server, server-connection, client) must be fully closed.

Finally, ensure the native selector managerâ€™s coroutine context/lifecycle is consistent with JVM behavior (in particular, do not introduce an extra `Job` in the selector manager context if it causes lifecycle differences), so that cancellation/closure semantics behave the same across platforms when using a provided dispatcher.