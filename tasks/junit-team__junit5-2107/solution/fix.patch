diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
index 8c73d6d54..17797c007 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
@@ -32,6 +32,9 @@ repository on GitHub.
   which return a `Stream`.
 * New `tryToLoadClass(...)` variant in `ReflectionSupport` that accepts an explicit
   `ClassLoader`, allowing classes to be resolved with custom `ClassLoader` arrangements.
+* New overloaded constructors for `ClassSelector` and `MethodSelector` that take an
+  explicit `ClassLoader` as a parameter, allowing selectors to select classes in custom
+  `ClassLoader` arrangements like in OSGi.
 * `ReflectionSupport.findMethod(Class<?>, String, String)` now uses the `ClassLoader` of
   the supplied `Class` to load parameter types instead of using the _default_
   `ClassLoader`. This allows parameter types to be resolved with custom `ClassLoader`
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassSelector.java
index 30f690699..d9e77967b 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassSelector.java
@@ -16,6 +16,7 @@ import java.util.Objects;
 
 import org.apiguardian.api.API;
 import org.junit.platform.commons.PreconditionViolationException;
+import org.junit.platform.commons.function.Try;
 import org.junit.platform.commons.util.ReflectionUtils;
 import org.junit.platform.commons.util.ToStringBuilder;
 import org.junit.platform.engine.DiscoverySelector;
@@ -43,15 +44,22 @@ import org.junit.platform.engine.DiscoverySelector;
 public class ClassSelector implements DiscoverySelector {
 
 	private final String className;
+	private final ClassLoader classLoader;
 
 	private Class<?> javaClass;
 
 	ClassSelector(String className) {
+		this(className, null);
+	}
+
+	ClassSelector(String className, ClassLoader classLoader) {
 		this.className = className;
+		this.classLoader = classLoader;
 	}
 
 	ClassSelector(Class<?> javaClass) {
 		this.className = javaClass.getName();
+		this.classLoader = javaClass.getClassLoader();
 		this.javaClass = javaClass;
 	}
 
@@ -62,6 +70,13 @@ public class ClassSelector implements DiscoverySelector {
 		return this.className;
 	}
 
+	/**
+	 * Get the class loader used to load the selected class.
+	 */
+	public ClassLoader getClassLoader() {
+		return this.classLoader;
+	}
+
 	/**
 	 * Get the selected {@link Class}.
 	 *
@@ -71,9 +86,10 @@ public class ClassSelector implements DiscoverySelector {
 	 */
 	public Class<?> getJavaClass() {
 		if (this.javaClass == null) {
-			this.javaClass = ReflectionUtils.tryToLoadClass(this.className).getOrThrow(
-				cause -> new PreconditionViolationException("Could not load class with name: " + this.className,
-					cause));
+			final Try<Class<?>> clazz = this.classLoader == null ? ReflectionUtils.tryToLoadClass(this.className)
+					: ReflectionUtils.tryToLoadClass(className, this.classLoader);
+			this.javaClass = clazz.getOrThrow(cause -> new PreconditionViolationException(
+				"Could not load class with name: " + this.className, cause));
 		}
 		return this.javaClass;
 	}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
index 98a722756..6951cdc5b 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
@@ -393,6 +393,21 @@ public final class DiscoverySelectors {
 		return new ClassSelector(className);
 	}
 
+	/**
+	 * Create a {@code ClassSelector} for the supplied class name using the
+	 * supplied class loader.
+	 *
+	 * @param className the fully qualified name of the class to select;
+	 * never {@code null} or blank
+	 * @param classLoader the class loader to use to try and load the
+	 * supplied class. If {@code null}, the default class loader will be used.
+	 * @see ClassSelector
+	 */
+	public static ClassSelector selectClass(String className, ClassLoader classLoader) {
+		Preconditions.notBlank(className, "Class name must not be null or blank");
+		return new ClassSelector(className, classLoader);
+	}
+
 	/**
 	 * Create a {@code MethodSelector} for the supplied <em>fully qualified
 	 * method name</em>.
@@ -436,12 +451,28 @@ public final class DiscoverySelectors {
 	 * @see MethodSelector
 	 */
 	public static MethodSelector selectMethod(String fullyQualifiedMethodName) throws PreconditionViolationException {
+		return selectMethod(fullyQualifiedMethodName, (ClassLoader) null);
+	}
+
+	/**
+	 * Create a {@code MethodSelector} for the supplied <em>fully qualified
+	 * method name</em> using the given classloader.
+	 *
+	 * @param fullyQualifiedMethodName the fully qualified name of the method to select; never
+	 * {@code null} or blank (see {@link #selectMethod(String)} for the format of this string).
+	 * @param classLoader the class loader to use to try and load the
+	 * supplied class. If {@code null}, the default class loader will be used.
+	 * @see #selectMethod(String)
+	 */
+	public static MethodSelector selectMethod(String fullyQualifiedMethodName, ClassLoader classLoader)
+			throws PreconditionViolationException {
 		String[] methodParts = ReflectionUtils.parseFullyQualifiedMethodName(fullyQualifiedMethodName);
-		return selectMethod(methodParts[0], methodParts[1], methodParts[2]);
+		return selectMethod(methodParts[0], methodParts[1], methodParts[2], classLoader);
 	}
 
 	/**
-	 * Create a {@code MethodSelector} for the supplied class name and method name.
+	 * Create a {@code MethodSelector} for the supplied class name and method name
+	 * using the default class loader.
 	 *
 	 * @param className the fully qualified name of the class in which the method
 	 * is declared, or a subclass thereof; never {@code null} or blank
@@ -449,9 +480,24 @@ public final class DiscoverySelectors {
 	 * @see MethodSelector
 	 */
 	public static MethodSelector selectMethod(String className, String methodName) {
+		return selectMethod(className, methodName, (ClassLoader) null);
+	}
+
+	/**
+	 * Create a {@code MethodSelector} for the supplied class name and method name, using
+	 * the given class loader to find the class.
+	 *
+	 * @param className the fully qualified name of the class in which the method
+	 * is declared, or a subclass thereof; never {@code null} or blank
+	 * @param methodName the name of the method to select; never {@code null} or blank
+	 * @param classLoader the class loader to use to try and load the
+	 * supplied class. If {@code null}, the default class loader will be used.
+	 * @see MethodSelector
+	 */
+	public static MethodSelector selectMethod(String className, String methodName, ClassLoader classLoader) {
 		Preconditions.notBlank(className, "Class name must not be null or blank");
 		Preconditions.notBlank(methodName, "Method name must not be null or blank");
-		return new MethodSelector(className, methodName);
+		return new MethodSelector(className, methodName, classLoader);
 	}
 
 	/**
@@ -471,10 +517,31 @@ public final class DiscoverySelectors {
 	 * @see MethodSelector
 	 */
 	public static MethodSelector selectMethod(String className, String methodName, String methodParameterTypes) {
+		return selectMethod(className, methodName, methodParameterTypes, null);
+	}
+
+	/**
+	 * Create a {@code MethodSelector} for the supplied class name, method name,
+	 * and method parameter types, using the specified class loader.
+	 *
+	 * <p>The parameter types {@code String} is typically a comma-separated list
+	 * of atomic types, fully qualified class names, or array types; however,
+	 * the exact syntax depends on the underlying test engine.
+	 *
+	 * @param className the fully qualified name of the class in which the method
+	 * is declared, or a subclass thereof; never {@code null} or blank
+	 * @param methodName the name of the method to select; never {@code null} or blank
+	 * @param methodParameterTypes the method parameter types as a single string; never
+	 * {@code null} though potentially an empty string if the method does not accept
+	 * arguments
+	 * @see MethodSelector
+	 */
+	public static MethodSelector selectMethod(String className, String methodName, String methodParameterTypes,
+			ClassLoader classLoader) {
 		Preconditions.notBlank(className, "Class name must not be null or blank");
 		Preconditions.notBlank(methodName, "Method name must not be null or blank");
 		Preconditions.notNull(methodParameterTypes, "Parameter types must not be null");
-		return new MethodSelector(className, methodName, methodParameterTypes.trim());
+		return new MethodSelector(className, methodName, methodParameterTypes.trim(), classLoader);
 	}
 
 	/**
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
index ff7e627ac..460f9b552 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
@@ -17,6 +17,7 @@ import java.util.Objects;
 
 import org.apiguardian.api.API;
 import org.junit.platform.commons.PreconditionViolationException;
+import org.junit.platform.commons.function.Try;
 import org.junit.platform.commons.util.ClassUtils;
 import org.junit.platform.commons.util.ReflectionUtils;
 import org.junit.platform.commons.util.StringUtils;
@@ -53,6 +54,7 @@ import org.junit.platform.engine.DiscoverySelector;
 @API(status = STABLE, since = "1.0")
 public class MethodSelector implements DiscoverySelector {
 
+	private final ClassLoader classLoader;
 	private final String className;
 	private final String methodName;
 	private final String methodParameterTypes;
@@ -61,10 +63,19 @@ public class MethodSelector implements DiscoverySelector {
 	private Method javaMethod;
 
 	MethodSelector(String className, String methodName) {
-		this(className, methodName, "");
+		this(className, methodName, "", (ClassLoader) null);
+	}
+
+	MethodSelector(String className, String methodName, ClassLoader classLoader) {
+		this(className, methodName, "", classLoader);
 	}
 
 	MethodSelector(String className, String methodName, String methodParameterTypes) {
+		this(className, methodName, methodParameterTypes, (ClassLoader) null);
+	}
+
+	MethodSelector(String className, String methodName, String methodParameterTypes, ClassLoader classLoader) {
+		this.classLoader = classLoader;
 		this.className = className;
 		this.methodName = methodName;
 		this.methodParameterTypes = methodParameterTypes;
@@ -75,6 +86,7 @@ public class MethodSelector implements DiscoverySelector {
 	}
 
 	MethodSelector(Class<?> javaClass, String methodName, String methodParameterTypes) {
+		this.classLoader = javaClass.getClassLoader();
 		this.javaClass = javaClass;
 		this.className = javaClass.getName();
 		this.methodName = methodName;
@@ -82,6 +94,7 @@ public class MethodSelector implements DiscoverySelector {
 	}
 
 	MethodSelector(Class<?> javaClass, Method method) {
+		this.classLoader = javaClass.getClassLoader();
 		this.javaClass = javaClass;
 		this.className = javaClass.getName();
 		this.javaMethod = method;
@@ -96,6 +109,13 @@ public class MethodSelector implements DiscoverySelector {
 		return this.className;
 	}
 
+	/**
+	 * Get the class loader used to load the specified class.
+	 */
+	public ClassLoader getClassLoader() {
+		return this.classLoader;
+	}
+
 	/**
 	 * Get the selected method name.
 	 */
@@ -153,7 +173,9 @@ public class MethodSelector implements DiscoverySelector {
 	private void lazyLoadJavaClass() {
 		if (this.javaClass == null) {
 			// @formatter:off
-			this.javaClass = ReflectionUtils.tryToLoadClass(this.className).getOrThrow(
+			final Try<Class<?>> clazz = this.classLoader == null ? ReflectionUtils.tryToLoadClass(this.className)
+					: ReflectionUtils.tryToLoadClass(className, this.classLoader);
+			this.javaClass = clazz.getOrThrow(
 				cause -> new PreconditionViolationException("Could not load class with name: " + this.className, cause));
 			// @formatter:on
 		}
