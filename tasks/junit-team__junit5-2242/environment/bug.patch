diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M1.adoc
index 27175a6eb..a6fedc1a6 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M1.adoc
@@ -22,10 +22,6 @@ on GitHub.
 * In the `EngineTestKit` API, the `all()`, `containers()`, and `tests()` methods in
   `EngineExecutionResults` that were deprecated in JUnit Platform 1.6.0 have been removed
   in favor of `allEvents()`, `containerEvents()`, and `testEvents()`, respectively.
-* The following methods in `EngineTestKit` are now deprecated with replacements:
-  - `execute(String, EngineDiscoveryRequest)` → `execute(String, LauncherDiscoveryRequest)`
-  - `execute(TestEngine, EngineDiscoveryRequest)` → `execute(TestEngine, LauncherDiscoveryRequest)`
-  - `Builder.filters(DiscoveryFilter...)` → `Builder.filters(Filter...)`
 
 ==== New Features and Improvements
 
@@ -40,9 +36,6 @@ on GitHub.
   execution of a submitted test via the returned `Future`.
 * Add `EngineExecutionListener.NOOP` and change all declared methods to have empty default
   implementations.
-* The `EngineTestKit` now reuses the same test discovery and execution logic as the
-  `Launcher`. Thus, it's now possible to test that an engine's behavior in the presence of
-  post-discovery filters (e.g. tag filters) and with regard to pruning.
 * The TestKit now allows to match conditions with events loosely, i.e. an incomplete match
   with or without a fixed order.
 
diff --git a/documentation/src/docs/asciidoc/user-guide/testkit.adoc b/documentation/src/docs/asciidoc/user-guide/testkit.adoc
index 32658381e..83748cb09 100644
--- a/documentation/src/docs/asciidoc/user-guide/testkit.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/testkit.adoc
@@ -17,10 +17,10 @@ given `{TestEngine}` running on the JUnit Platform and then accessing the result
 fluent API to verify the expected results. The key entry point into this API is the
 `{EngineTestKit}` which provides static factory methods named `engine()` and `execute()`.
 It is recommended that you select one of the `engine()` variants to benefit from the
-fluent API for building a `LauncherDiscoveryRequest`.
+fluent API for building an `EngineDiscoveryRequest`.
 
 NOTE: If you prefer to use the `LauncherDiscoveryRequestBuilder` from the `Launcher` API
-to build your `LauncherDiscoveryRequest`, you must use one of the `execute()` variants in
+to build your `EngineDiscoveryRequest`, you must use one of the `execute()` variants in
 `EngineTestKit`.
 
 The following test class written using JUnit Jupiter will be used in subsequent examples.
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java
index 2a12f6c19..e769bc8f6 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/NestedTestClassesTests.java
@@ -12,7 +12,6 @@ package org.junit.jupiter.engine;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.util.Throwables.getRootCause;
 import static org.junit.jupiter.api.Assertions.assertAll;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
@@ -183,7 +182,7 @@ class NestedTestClassesTests extends AbstractJupiterTestEngineTests {
 		assertThatExceptionOfType(JUnitException.class)//
 				.isThrownBy(() -> executeTestsForClass(start))//
 				.withCauseExactlyInstanceOf(JUnitException.class)//
-				.satisfies(ex -> assertThat(getRootCause(ex)).hasMessageMatching(
+				.satisfies(ex -> assertThat(ex.getCause()).hasMessageMatching(
 					String.format("Detected cycle in inner class hierarchy between .+%s and .+%s", from.getSimpleName(),
 						to.getSimpleName())));
 	}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java
index ff7890538..e68f1d968 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java
@@ -10,9 +10,27 @@
 
 package org.junit.platform.launcher.core;
 
+import java.util.HashSet;
+import java.util.Optional;
+import java.util.Set;
+import java.util.function.Consumer;
+
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.BlacklistedExceptions;
 import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.engine.ConfigurationParameters;
+import org.junit.platform.engine.EngineExecutionListener;
+import org.junit.platform.engine.ExecutionRequest;
+import org.junit.platform.engine.FilterResult;
+import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestEngine;
+import org.junit.platform.engine.TestExecutionResult;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.launcher.EngineDiscoveryResult;
 import org.junit.platform.launcher.Launcher;
+import org.junit.platform.launcher.LauncherDiscoveryListener;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
 import org.junit.platform.launcher.TestExecutionListener;
 import org.junit.platform.launcher.TestPlan;
@@ -29,9 +47,11 @@ import org.junit.platform.launcher.TestPlan;
  */
 class DefaultLauncher implements Launcher {
 
+	private static final Logger logger = LoggerFactory.getLogger(DefaultLauncher.class);
+
 	private final TestExecutionListenerRegistry listenerRegistry = new TestExecutionListenerRegistry();
-	private final EngineExecutionOrchestrator executionOrchestrator = new EngineExecutionOrchestrator(listenerRegistry);
-	private final EngineDiscoveryOrchestrator discoveryOrchestrator;
+	private final EngineDiscoveryResultValidator discoveryResultValidator = new EngineDiscoveryResultValidator();
+	private final Iterable<TestEngine> testEngines;
 
 	/**
 	 * Construct a new {@code DefaultLauncher} with the supplied test engines.
@@ -42,7 +62,53 @@ class DefaultLauncher implements Launcher {
 		Preconditions.condition(testEngines != null && testEngines.iterator().hasNext(),
 			() -> "Cannot create Launcher without at least one TestEngine; "
 					+ "consider adding an engine implementation JAR to the classpath");
-		this.discoveryOrchestrator = new EngineDiscoveryOrchestrator(EngineIdValidator.validate(testEngines));
+		this.testEngines = validateEngineIds(testEngines);
+	}
+
+	private static Iterable<TestEngine> validateEngineIds(Iterable<TestEngine> testEngines) {
+		Set<String> ids = new HashSet<>();
+		for (TestEngine testEngine : testEngines) {
+			// check usage of reserved id prefix
+			if (!validateReservedIds(testEngine)) {
+				logger.warn(() -> String.format(
+					"Third-party TestEngine implementations are forbidden to use the reserved 'junit-' prefix for their ID: '%s'",
+					testEngine.getId()));
+			}
+
+			// check uniqueness
+			if (!ids.add(testEngine.getId())) {
+				throw new JUnitException(String.format(
+					"Cannot create Launcher for multiple engines with the same ID '%s'.", testEngine.getId()));
+			}
+		}
+		return testEngines;
+	}
+
+	// https://github.com/junit-team/junit5/issues/1557
+	private static boolean validateReservedIds(TestEngine testEngine) {
+		String engineId = testEngine.getId();
+		if (!engineId.startsWith("junit-")) {
+			return true;
+		}
+		if (engineId.equals("junit-jupiter")) {
+			validateWellKnownClassName(testEngine, "org.junit.jupiter.engine.JupiterTestEngine");
+			return true;
+		}
+		if (engineId.equals("junit-vintage")) {
+			validateWellKnownClassName(testEngine, "org.junit.vintage.engine.VintageTestEngine");
+			return true;
+		}
+		return false;
+	}
+
+	private static void validateWellKnownClassName(TestEngine testEngine, String expectedClassName) {
+		String actualClassName = testEngine.getClass().getName();
+		if (actualClassName.equals(expectedClassName)) {
+			return;
+		}
+		throw new JUnitException(
+			String.format("Third-party TestEngine '%s' is forbidden to use the reserved '%s' TestEngine ID.",
+				actualClassName, testEngine.getId()));
 	}
 
 	@Override
@@ -55,7 +121,7 @@ class DefaultLauncher implements Launcher {
 	@Override
 	public TestPlan discover(LauncherDiscoveryRequest discoveryRequest) {
 		Preconditions.notNull(discoveryRequest, "LauncherDiscoveryRequest must not be null");
-		return InternalTestPlan.from(discover(discoveryRequest, "discovery"));
+		return InternalTestPlan.from(discoverRoot(discoveryRequest, "discovery"));
 	}
 
 	@Override
@@ -63,7 +129,7 @@ class DefaultLauncher implements Launcher {
 		Preconditions.notNull(discoveryRequest, "LauncherDiscoveryRequest must not be null");
 		Preconditions.notNull(listeners, "TestExecutionListener array must not be null");
 		Preconditions.containsNoNullElements(listeners, "individual listeners must not be null");
-		execute(InternalTestPlan.from(discover(discoveryRequest, "execution")), listeners);
+		execute(InternalTestPlan.from(discoverRoot(discoveryRequest, "execution")), listeners);
 	}
 
 	@Override
@@ -79,12 +145,114 @@ class DefaultLauncher implements Launcher {
 		return listenerRegistry;
 	}
 
-	private LauncherDiscoveryResult discover(LauncherDiscoveryRequest discoveryRequest, String phase) {
-		return discoveryOrchestrator.discover(discoveryRequest, phase);
+	private Root discoverRoot(LauncherDiscoveryRequest discoveryRequest, String phase) {
+		Root root = new Root(discoveryRequest.getConfigurationParameters());
+
+		for (TestEngine testEngine : this.testEngines) {
+			// @formatter:off
+			boolean engineIsExcluded = discoveryRequest.getEngineFilters().stream()
+					.map(engineFilter -> engineFilter.apply(testEngine))
+					.anyMatch(FilterResult::excluded);
+			// @formatter:on
+
+			if (engineIsExcluded) {
+				logger.debug(() -> String.format(
+					"Test discovery for engine '%s' was skipped due to an EngineFilter in phase '%s'.",
+					testEngine.getId(), phase));
+				continue;
+			}
+
+			logger.debug(() -> String.format("Discovering tests during Launcher %s phase in engine '%s'.", phase,
+				testEngine.getId()));
+
+			TestDescriptor rootDescriptor = discoverEngineRoot(testEngine, discoveryRequest);
+			root.add(testEngine, rootDescriptor);
+		}
+		root.applyPostDiscoveryFilters(discoveryRequest);
+		root.prune();
+		return root;
+	}
+
+	private TestDescriptor discoverEngineRoot(TestEngine testEngine, LauncherDiscoveryRequest discoveryRequest) {
+		LauncherDiscoveryListener discoveryListener = discoveryRequest.getDiscoveryListener();
+		UniqueId uniqueEngineId = UniqueId.forEngine(testEngine.getId());
+		try {
+			discoveryListener.engineDiscoveryStarted(uniqueEngineId);
+			TestDescriptor engineRoot = testEngine.discover(discoveryRequest, uniqueEngineId);
+			discoveryResultValidator.validate(testEngine, engineRoot);
+			discoveryListener.engineDiscoveryFinished(uniqueEngineId, EngineDiscoveryResult.successful());
+			return engineRoot;
+		}
+		catch (Throwable throwable) {
+			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
+			String message = String.format("TestEngine with ID '%s' failed to discover tests", testEngine.getId());
+			JUnitException cause = new JUnitException(message, throwable);
+			discoveryListener.engineDiscoveryFinished(uniqueEngineId, EngineDiscoveryResult.failed(cause));
+			return new EngineDiscoveryErrorDescriptor(uniqueEngineId, testEngine, cause);
+		}
 	}
 
 	private void execute(InternalTestPlan internalTestPlan, TestExecutionListener[] listeners) {
-		executionOrchestrator.execute(internalTestPlan, listeners);
+		Root root = internalTestPlan.getRoot();
+		ConfigurationParameters configurationParameters = root.getConfigurationParameters();
+		TestExecutionListenerRegistry listenerRegistry = buildListenerRegistryForExecution(listeners);
+		withInterceptedStreams(configurationParameters, listenerRegistry, testExecutionListener -> {
+			testExecutionListener.testPlanExecutionStarted(internalTestPlan);
+			ExecutionListenerAdapter engineExecutionListener = new ExecutionListenerAdapter(internalTestPlan,
+				testExecutionListener);
+			for (TestEngine testEngine : root.getTestEngines()) {
+				TestDescriptor engineDescriptor = root.getTestDescriptorFor(testEngine);
+				if (engineDescriptor instanceof EngineDiscoveryErrorDescriptor) {
+					engineExecutionListener.executionStarted(engineDescriptor);
+					engineExecutionListener.executionFinished(engineDescriptor,
+						TestExecutionResult.failed(((EngineDiscoveryErrorDescriptor) engineDescriptor).getCause()));
+				}
+				else {
+					execute(engineDescriptor, engineExecutionListener, configurationParameters, testEngine);
+				}
+			}
+			testExecutionListener.testPlanExecutionFinished(internalTestPlan);
+		});
+	}
+
+	private void withInterceptedStreams(ConfigurationParameters configurationParameters,
+			TestExecutionListenerRegistry listenerRegistry, Consumer<TestExecutionListener> action) {
+
+		TestExecutionListener testExecutionListener = listenerRegistry.getCompositeTestExecutionListener();
+		Optional<StreamInterceptingTestExecutionListener> streamInterceptingTestExecutionListener = StreamInterceptingTestExecutionListener.create(
+			configurationParameters, testExecutionListener::reportingEntryPublished);
+		streamInterceptingTestExecutionListener.ifPresent(listenerRegistry::registerListeners);
+		try {
+			action.accept(testExecutionListener);
+		}
+		finally {
+			streamInterceptingTestExecutionListener.ifPresent(StreamInterceptingTestExecutionListener::unregister);
+		}
+	}
+
+	private TestExecutionListenerRegistry buildListenerRegistryForExecution(TestExecutionListener... listeners) {
+		if (listeners.length == 0) {
+			return this.listenerRegistry;
+		}
+		TestExecutionListenerRegistry registry = new TestExecutionListenerRegistry(this.listenerRegistry);
+		registry.registerListeners(listeners);
+		return registry;
+	}
+
+	private void execute(TestDescriptor engineDescriptor, EngineExecutionListener listener,
+			ConfigurationParameters configurationParameters, TestEngine testEngine) {
+
+		OutcomeDelayingEngineExecutionListener delayingListener = new OutcomeDelayingEngineExecutionListener(listener,
+			engineDescriptor);
+		try {
+			testEngine.execute(new ExecutionRequest(engineDescriptor, delayingListener, configurationParameters));
+			delayingListener.reportEngineOutcome();
+		}
+		catch (Throwable throwable) {
+			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
+			delayingListener.reportEngineFailure(new JUnitException(
+				String.format("TestEngine with ID '%s' failed to execute tests", testEngine.getId()), throwable));
+		}
 	}
 
 }
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java
deleted file mode 100644
index 9c18943f3..000000000
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright 2015-2020 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.launcher.core;
-
-import static java.util.stream.Collectors.joining;
-import static org.apiguardian.api.API.Status.INTERNAL;
-import static org.junit.platform.engine.Filter.composeFilters;
-
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-
-import org.apiguardian.api.API;
-import org.junit.platform.commons.JUnitException;
-import org.junit.platform.commons.logging.Logger;
-import org.junit.platform.commons.logging.LoggerFactory;
-import org.junit.platform.commons.util.BlacklistedExceptions;
-import org.junit.platform.engine.Filter;
-import org.junit.platform.engine.FilterResult;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.TestEngine;
-import org.junit.platform.engine.UniqueId;
-import org.junit.platform.launcher.EngineDiscoveryResult;
-import org.junit.platform.launcher.LauncherDiscoveryListener;
-import org.junit.platform.launcher.LauncherDiscoveryRequest;
-import org.junit.platform.launcher.PostDiscoveryFilter;
-
-/**
- * Orchestrates test discovery using the configured test engines.
- *
- * @since 1.7
- */
-@API(status = INTERNAL, since = "1.7", consumers = "testkit")
-public class EngineDiscoveryOrchestrator {
-
-	private static final Logger logger = LoggerFactory.getLogger(EngineDiscoveryOrchestrator.class);
-
-	private final EngineDiscoveryResultValidator discoveryResultValidator = new EngineDiscoveryResultValidator();
-	private final Iterable<TestEngine> testEngines;
-
-	public EngineDiscoveryOrchestrator(Iterable<TestEngine> testEngines) {
-		this.testEngines = testEngines;
-	}
-
-	/**
-	 * Discovers tests for the supplied request in the supplied phase using the
-	 * configured test engines.
-	 *
-	 * <p>Applies {@linkplain org.junit.platform.launcher.EngineFilter engine
-	 * filters} and {@linkplain PostDiscoveryFilter post-discovery filters} and
-	 * {@linkplain TestDescriptor#prune() prunes} the resulting test tree.
-	 */
-	public LauncherDiscoveryResult discover(LauncherDiscoveryRequest request, String phase) {
-		Map<TestEngine, TestDescriptor> testEngineDescriptors = new LinkedHashMap<>();
-
-		for (TestEngine testEngine : this.testEngines) {
-			boolean engineIsExcluded = request.getEngineFilters().stream() //
-					.map(engineFilter -> engineFilter.apply(testEngine)) //
-					.anyMatch(FilterResult::excluded);
-
-			if (engineIsExcluded) {
-				logger.debug(() -> String.format(
-					"Test discovery for engine '%s' was skipped due to an EngineFilter in phase '%s'.",
-					testEngine.getId(), phase));
-				continue;
-			}
-
-			logger.debug(() -> String.format("Discovering tests during Launcher %s phase in engine '%s'.", phase,
-				testEngine.getId()));
-
-			TestDescriptor rootDescriptor = discoverEngineRoot(testEngine, request);
-			testEngineDescriptors.put(testEngine, rootDescriptor);
-		}
-
-		applyPostDiscoveryFilters(testEngineDescriptors, request.getPostDiscoveryFilters());
-		prune(testEngineDescriptors);
-
-		return new LauncherDiscoveryResult(testEngineDescriptors, request.getConfigurationParameters());
-	}
-
-	private TestDescriptor discoverEngineRoot(TestEngine testEngine, LauncherDiscoveryRequest discoveryRequest) {
-		LauncherDiscoveryListener discoveryListener = discoveryRequest.getDiscoveryListener();
-		UniqueId uniqueEngineId = UniqueId.forEngine(testEngine.getId());
-		try {
-			discoveryListener.engineDiscoveryStarted(uniqueEngineId);
-			TestDescriptor engineRoot = testEngine.discover(discoveryRequest, uniqueEngineId);
-			discoveryResultValidator.validate(testEngine, engineRoot);
-			discoveryListener.engineDiscoveryFinished(uniqueEngineId, EngineDiscoveryResult.successful());
-			return engineRoot;
-		}
-		catch (Throwable throwable) {
-			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
-			String message = String.format("TestEngine with ID '%s' failed to discover tests", testEngine.getId());
-			JUnitException cause = new JUnitException(message, throwable);
-			discoveryListener.engineDiscoveryFinished(uniqueEngineId, EngineDiscoveryResult.failed(cause));
-			return new EngineDiscoveryErrorDescriptor(uniqueEngineId, testEngine, cause);
-		}
-	}
-
-	private void applyPostDiscoveryFilters(Map<TestEngine, TestDescriptor> testEngineDescriptors,
-			List<PostDiscoveryFilter> filters) {
-		Filter<TestDescriptor> postDiscoveryFilter = composeFilters(filters);
-		Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason = new LinkedHashMap<>();
-		TestDescriptor.Visitor removeExcludedTestDescriptors = descriptor -> {
-			FilterResult filterResult = postDiscoveryFilter.apply(descriptor);
-			if (!descriptor.isRoot() && isExcluded(descriptor, filterResult)) {
-				populateExclusionReasonInMap(filterResult.getReason(), descriptor, excludedTestDescriptorsByReason);
-				descriptor.removeFromHierarchy();
-			}
-		};
-		acceptInAllTestEngines(testEngineDescriptors, removeExcludedTestDescriptors);
-		logTestDescriptorExclusionReasons(excludedTestDescriptorsByReason);
-	}
-
-	private void populateExclusionReasonInMap(Optional<String> reason, TestDescriptor testDescriptor,
-			Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
-		excludedTestDescriptorsByReason.computeIfAbsent(reason.orElse("Unknown"), list -> new LinkedList<>()).add(
-			testDescriptor);
-	}
-
-	private void logTestDescriptorExclusionReasons(Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
-		excludedTestDescriptorsByReason.forEach((exclusionReason, testDescriptors) -> {
-			String displayNames = testDescriptors.stream().map(TestDescriptor::getDisplayName).collect(joining(", "));
-			long containerCount = testDescriptors.stream().filter(TestDescriptor::isContainer).count();
-			long methodCount = testDescriptors.stream().filter(TestDescriptor::isTest).count();
-			logger.info(() -> String.format("%d containers and %d tests were %s", containerCount, methodCount,
-				exclusionReason));
-			logger.debug(
-				() -> String.format("The following containers and tests were %s: %s", exclusionReason, displayNames));
-		});
-	}
-
-	/**
-	 * Prune all branches in the tree of {@link TestDescriptor TestDescriptors}
-	 * that do not have executable tests.
-	 *
-	 * <p>If a {@link TestEngine} ends up with no {@code TestDescriptors} after
-	 * pruning, it will <strong>not</strong> be removed.
-	 */
-	private void prune(Map<TestEngine, TestDescriptor> testEngineDescriptors) {
-		acceptInAllTestEngines(testEngineDescriptors, TestDescriptor::prune);
-	}
-
-	private boolean isExcluded(TestDescriptor descriptor, FilterResult filterResult) {
-		return descriptor.getChildren().isEmpty() && filterResult.excluded();
-	}
-
-	private void acceptInAllTestEngines(Map<TestEngine, TestDescriptor> testEngineDescriptors,
-			TestDescriptor.Visitor visitor) {
-		testEngineDescriptors.values().forEach(descriptor -> descriptor.accept(visitor));
-	}
-
-}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java
deleted file mode 100644
index bf36a0030..000000000
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright 2015-2020 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.launcher.core;
-
-import static org.apiguardian.api.API.Status.INTERNAL;
-
-import java.util.Optional;
-import java.util.function.Consumer;
-
-import org.apiguardian.api.API;
-import org.junit.platform.commons.JUnitException;
-import org.junit.platform.commons.util.BlacklistedExceptions;
-import org.junit.platform.engine.ConfigurationParameters;
-import org.junit.platform.engine.EngineExecutionListener;
-import org.junit.platform.engine.ExecutionRequest;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.TestEngine;
-import org.junit.platform.engine.TestExecutionResult;
-import org.junit.platform.launcher.TestExecutionListener;
-
-/**
- * Orchestrates test execution using the configured test engines.
- *
- * @since 1.7
- */
-@API(status = INTERNAL, since = "1.7", consumers = "testkit")
-public class EngineExecutionOrchestrator {
-
-	private final TestExecutionListenerRegistry listenerRegistry;
-
-	public EngineExecutionOrchestrator() {
-		this(new TestExecutionListenerRegistry());
-	}
-
-	EngineExecutionOrchestrator(TestExecutionListenerRegistry listenerRegistry) {
-		this.listenerRegistry = listenerRegistry;
-	}
-
-	void execute(InternalTestPlan internalTestPlan, TestExecutionListener... listeners) {
-		LauncherDiscoveryResult discoveryResult = internalTestPlan.getDiscoveryResult();
-		ConfigurationParameters configurationParameters = discoveryResult.getConfigurationParameters();
-		TestExecutionListenerRegistry listenerRegistry = buildListenerRegistryForExecution(listeners);
-		withInterceptedStreams(configurationParameters, listenerRegistry, testExecutionListener -> {
-			testExecutionListener.testPlanExecutionStarted(internalTestPlan);
-			execute(discoveryResult, new ExecutionListenerAdapter(internalTestPlan, testExecutionListener));
-			testExecutionListener.testPlanExecutionFinished(internalTestPlan);
-		});
-	}
-
-	private void withInterceptedStreams(ConfigurationParameters configurationParameters,
-			TestExecutionListenerRegistry listenerRegistry, Consumer<TestExecutionListener> action) {
-
-		TestExecutionListener testExecutionListener = listenerRegistry.getCompositeTestExecutionListener();
-		Optional<StreamInterceptingTestExecutionListener> streamInterceptingTestExecutionListener = StreamInterceptingTestExecutionListener.create(
-			configurationParameters, testExecutionListener::reportingEntryPublished);
-		streamInterceptingTestExecutionListener.ifPresent(listenerRegistry::registerListeners);
-		try {
-			action.accept(testExecutionListener);
-		}
-		finally {
-			streamInterceptingTestExecutionListener.ifPresent(StreamInterceptingTestExecutionListener::unregister);
-		}
-	}
-
-	/**
-	 * Executes tests for the supplied {@linkplain LauncherDiscoveryResult
-	 * discovery results} and notifies the supplied {@linkplain
-	 * EngineExecutionListener listener} of execution events.
-	 */
-	public void execute(LauncherDiscoveryResult discoveryResult, EngineExecutionListener listener) {
-		for (TestEngine testEngine : discoveryResult.getTestEngines()) {
-			TestDescriptor engineDescriptor = discoveryResult.getEngineTestDescriptor(testEngine);
-			if (engineDescriptor instanceof EngineDiscoveryErrorDescriptor) {
-				listener.executionStarted(engineDescriptor);
-				listener.executionFinished(engineDescriptor,
-					TestExecutionResult.failed(((EngineDiscoveryErrorDescriptor) engineDescriptor).getCause()));
-			}
-			else {
-				execute(engineDescriptor, listener, discoveryResult.getConfigurationParameters(), testEngine);
-			}
-		}
-	}
-
-	private TestExecutionListenerRegistry buildListenerRegistryForExecution(TestExecutionListener... listeners) {
-		if (listeners.length == 0) {
-			return this.listenerRegistry;
-		}
-		TestExecutionListenerRegistry registry = new TestExecutionListenerRegistry(this.listenerRegistry);
-		registry.registerListeners(listeners);
-		return registry;
-	}
-
-	private void execute(TestDescriptor engineDescriptor, EngineExecutionListener listener,
-			ConfigurationParameters configurationParameters, TestEngine testEngine) {
-
-		OutcomeDelayingEngineExecutionListener delayingListener = new OutcomeDelayingEngineExecutionListener(listener,
-			engineDescriptor);
-		try {
-			testEngine.execute(new ExecutionRequest(engineDescriptor, delayingListener, configurationParameters));
-			delayingListener.reportEngineOutcome();
-		}
-		catch (Throwable throwable) {
-			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
-			delayingListener.reportEngineFailure(new JUnitException(
-				String.format("TestEngine with ID '%s' failed to execute tests", testEngine.getId()), throwable));
-		}
-	}
-}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineIdValidator.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineIdValidator.java
deleted file mode 100644
index 7fe0d0787..000000000
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineIdValidator.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright 2015-2020 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.launcher.core;
-
-import java.util.HashSet;
-import java.util.Set;
-
-import org.junit.platform.commons.JUnitException;
-import org.junit.platform.commons.logging.Logger;
-import org.junit.platform.commons.logging.LoggerFactory;
-import org.junit.platform.engine.TestEngine;
-
-/**
- * @since 1.7
- */
-class EngineIdValidator {
-
-	private static final Logger logger = LoggerFactory.getLogger(EngineIdValidator.class);
-
-	private EngineIdValidator() {
-	}
-
-	static Iterable<TestEngine> validate(Iterable<TestEngine> testEngines) {
-		Set<String> ids = new HashSet<>();
-		for (TestEngine testEngine : testEngines) {
-			// check usage of reserved id prefix
-			if (!validateReservedIds(testEngine)) {
-				logger.warn(() -> String.format(
-					"Third-party TestEngine implementations are forbidden to use the reserved 'junit-' prefix for their ID: '%s'",
-					testEngine.getId()));
-			}
-
-			// check uniqueness
-			if (!ids.add(testEngine.getId())) {
-				throw new JUnitException(String.format(
-					"Cannot create Launcher for multiple engines with the same ID '%s'.", testEngine.getId()));
-			}
-		}
-		return testEngines;
-	}
-
-	// https://github.com/junit-team/junit5/issues/1557
-	private static boolean validateReservedIds(TestEngine testEngine) {
-		String engineId = testEngine.getId();
-		if (!engineId.startsWith("junit-")) {
-			return true;
-		}
-		if (engineId.equals("junit-jupiter")) {
-			validateWellKnownClassName(testEngine, "org.junit.jupiter.engine.JupiterTestEngine");
-			return true;
-		}
-		if (engineId.equals("junit-vintage")) {
-			validateWellKnownClassName(testEngine, "org.junit.vintage.engine.VintageTestEngine");
-			return true;
-		}
-		return false;
-	}
-
-	private static void validateWellKnownClassName(TestEngine testEngine, String expectedClassName) {
-		String actualClassName = testEngine.getClass().getName();
-		if (actualClassName.equals(expectedClassName)) {
-			return;
-		}
-		throw new JUnitException(
-			String.format("Third-party TestEngine '%s' is forbidden to use the reserved '%s' TestEngine ID.",
-				actualClassName, testEngine.getId()));
-	}
-}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java
index 99426d516..176b500d8 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java
@@ -29,22 +29,22 @@ class InternalTestPlan extends TestPlan {
 	private static final Logger logger = LoggerFactory.getLogger(InternalTestPlan.class);
 
 	private final AtomicBoolean warningEmitted = new AtomicBoolean(false);
-	private final LauncherDiscoveryResult discoveryResult;
+	private final Root root;
 	private final TestPlan delegate;
 
-	static InternalTestPlan from(LauncherDiscoveryResult discoveryResult) {
-		TestPlan delegate = TestPlan.from(discoveryResult.getEngineTestDescriptors());
-		return new InternalTestPlan(discoveryResult, delegate);
+	static InternalTestPlan from(Root root) {
+		TestPlan delegate = TestPlan.from(root.getEngineDescriptors());
+		return new InternalTestPlan(root, delegate);
 	}
 
-	private InternalTestPlan(LauncherDiscoveryResult discoveryResult, TestPlan delegate) {
+	private InternalTestPlan(Root root, TestPlan delegate) {
 		super(delegate.containsTests());
-		this.discoveryResult = discoveryResult;
+		this.root = root;
 		this.delegate = delegate;
 	}
 
-	LauncherDiscoveryResult getDiscoveryResult() {
-		return discoveryResult;
+	Root getRoot() {
+		return root;
 	}
 
 	@Override
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryResult.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryResult.java
deleted file mode 100644
index 72e4a5110..000000000
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryResult.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright 2015-2020 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.launcher.core;
-
-import static java.util.Collections.unmodifiableMap;
-import static org.apiguardian.api.API.Status.INTERNAL;
-
-import java.util.Collection;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import org.apiguardian.api.API;
-import org.junit.platform.engine.ConfigurationParameters;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.TestEngine;
-
-/**
- * Represents the result of test discovery of the configured
- * {@linkplain TestEngine test engines}.
- *
- * @since 1.7
- */
-@API(status = INTERNAL, since = "1.7", consumers = "testkit")
-public class LauncherDiscoveryResult {
-
-	private final Map<TestEngine, TestDescriptor> testEngineDescriptors;
-	private final ConfigurationParameters configurationParameters;
-
-	LauncherDiscoveryResult(Map<TestEngine, TestDescriptor> testEngineDescriptors,
-			ConfigurationParameters configurationParameters) {
-		this.testEngineDescriptors = unmodifiableMap(new LinkedHashMap<>(testEngineDescriptors));
-		this.configurationParameters = configurationParameters;
-	}
-
-	public TestDescriptor getEngineTestDescriptor(TestEngine testEngine) {
-		return this.testEngineDescriptors.get(testEngine);
-	}
-
-	ConfigurationParameters getConfigurationParameters() {
-		return configurationParameters;
-	}
-
-	Collection<TestEngine> getTestEngines() {
-		return this.testEngineDescriptors.keySet();
-	}
-
-	Collection<TestDescriptor> getEngineTestDescriptors() {
-		return this.testEngineDescriptors.values();
-	}
-
-}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java
new file mode 100644
index 000000000..170183baa
--- /dev/null
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2015-2020 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.launcher.core;
+
+import static org.junit.platform.engine.Filter.composeFilters;
+
+import java.util.Collection;
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.engine.ConfigurationParameters;
+import org.junit.platform.engine.Filter;
+import org.junit.platform.engine.FilterResult;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.TestEngine;
+import org.junit.platform.launcher.LauncherDiscoveryRequest;
+
+/**
+ * Represents the root of all discovered {@link TestEngine TestEngines} and
+ * their {@link TestDescriptor TestDescriptors}.
+ *
+ * @since 1.0
+ */
+class Root {
+	private static final Logger logger = LoggerFactory.getLogger(Root.class);
+
+	private final Map<TestEngine, TestDescriptor> testEngineDescriptors = new LinkedHashMap<>(4);
+	private final ConfigurationParameters configurationParameters;
+
+	Root(ConfigurationParameters configurationParameters) {
+		this.configurationParameters = configurationParameters;
+	}
+
+	public ConfigurationParameters getConfigurationParameters() {
+		return configurationParameters;
+	}
+
+	/**
+	 * Add an {@code engine}'s root {@link TestDescriptor}.
+	 */
+	void add(TestEngine engine, TestDescriptor testDescriptor) {
+		this.testEngineDescriptors.put(engine, testDescriptor);
+	}
+
+	Iterable<TestEngine> getTestEngines() {
+		return this.testEngineDescriptors.keySet();
+	}
+
+	Collection<TestDescriptor> getEngineDescriptors() {
+		return this.testEngineDescriptors.values();
+	}
+
+	TestDescriptor getTestDescriptorFor(TestEngine testEngine) {
+		return this.testEngineDescriptors.get(testEngine);
+	}
+
+	void applyPostDiscoveryFilters(LauncherDiscoveryRequest discoveryRequest) {
+		Filter<TestDescriptor> postDiscoveryFilter = composeFilters(discoveryRequest.getPostDiscoveryFilters());
+		Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason = new LinkedHashMap<>();
+		TestDescriptor.Visitor removeExcludedTestDescriptors = descriptor -> {
+			FilterResult filterResult = postDiscoveryFilter.apply(descriptor);
+			if (!descriptor.isRoot() && isExcluded(descriptor, filterResult)) {
+				populateExclusionReasonInMap(filterResult.getReason(), descriptor, excludedTestDescriptorsByReason);
+				descriptor.removeFromHierarchy();
+			}
+		};
+		acceptInAllTestEngines(removeExcludedTestDescriptors);
+		logTestDescriptorExclusionReasons(excludedTestDescriptorsByReason);
+	}
+
+	private void populateExclusionReasonInMap(Optional<String> reason, TestDescriptor testDescriptor,
+			Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
+		excludedTestDescriptorsByReason.computeIfAbsent(reason.orElse("Unknown"), list -> new LinkedList<>()).add(
+			testDescriptor);
+	}
+
+	/**
+	 * Prune all branches in the tree of {@link TestDescriptor TestDescriptors}
+	 * that do not have executable tests.
+	 *
+	 * <p>If a {@link TestEngine} ends up with no {@code TestDescriptors} after
+	 * pruning, it will <strong>not</strong> be removed.
+	 */
+	void prune() {
+		acceptInAllTestEngines(TestDescriptor::prune);
+	}
+
+	private boolean isExcluded(TestDescriptor descriptor, FilterResult filterResult) {
+		return descriptor.getChildren().isEmpty() && filterResult.excluded();
+	}
+
+	private void acceptInAllTestEngines(TestDescriptor.Visitor visitor) {
+		this.testEngineDescriptors.values().forEach(descriptor -> descriptor.accept(visitor));
+	}
+
+	private void logTestDescriptorExclusionReasons(Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
+		excludedTestDescriptorsByReason.forEach((exclusionReason, testDescriptors) -> {
+			String displayNames = testDescriptors.stream().map(TestDescriptor::getDisplayName).collect(
+				Collectors.joining(", "));
+			long containerCount = testDescriptors.stream().filter(TestDescriptor::isContainer).count();
+			long methodCount = testDescriptors.stream().filter(TestDescriptor::isTest).count();
+			logger.info(() -> String.format("%d containers and %d tests were %s", containerCount, methodCount,
+				exclusionReason));
+			logger.debug(
+				() -> String.format("The following containers and tests were %s: %s", exclusionReason, displayNames));
+		});
+	}
+}
diff --git a/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java b/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java
index a4aa4de99..5fad367c3 100644
--- a/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java
+++ b/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java
@@ -11,10 +11,8 @@
 package org.junit.platform.testkit.engine;
 
 import static java.lang.String.join;
-import static java.util.Collections.singleton;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.StreamSupport.stream;
-import static org.apiguardian.api.API.Status.DEPRECATED;
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 
 import java.util.ArrayList;
@@ -35,15 +33,10 @@ import org.junit.platform.engine.DiscoverySelector;
 import org.junit.platform.engine.EngineDiscoveryRequest;
 import org.junit.platform.engine.EngineExecutionListener;
 import org.junit.platform.engine.ExecutionRequest;
-import org.junit.platform.engine.Filter;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestEngine;
 import org.junit.platform.engine.UniqueId;
-import org.junit.platform.launcher.LauncherDiscoveryRequest;
-import org.junit.platform.launcher.core.EngineDiscoveryOrchestrator;
-import org.junit.platform.launcher.core.EngineExecutionOrchestrator;
 import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
-import org.junit.platform.launcher.core.LauncherDiscoveryResult;
 
 /**
  * {@code EngineTestKit} provides support for executing a test plan for a given
@@ -53,8 +46,8 @@ import org.junit.platform.launcher.core.LauncherDiscoveryResult;
  * @since 1.4
  * @see #engine(String)
  * @see #engine(TestEngine)
- * @see #execute(String, LauncherDiscoveryRequest)
- * @see #execute(TestEngine, LauncherDiscoveryRequest)
+ * @see #execute(String, EngineDiscoveryRequest)
+ * @see #execute(TestEngine, EngineDiscoveryRequest)
  * @see EngineExecutionResults
  */
 @API(status = EXPERIMENTAL, since = "1.4")
@@ -88,8 +81,8 @@ public final class EngineTestKit {
 	 * or <em>blank</em>, or if the {@code TestEngine} with the supplied ID
 	 * cannot be loaded
 	 * @see #engine(TestEngine)
-	 * @see #execute(String, LauncherDiscoveryRequest)
-	 * @see #execute(TestEngine, LauncherDiscoveryRequest)
+	 * @see #execute(String, EngineDiscoveryRequest)
+	 * @see #execute(TestEngine, EngineDiscoveryRequest)
 	 */
 	public static Builder engine(String engineId) {
 		Preconditions.notBlank(engineId, "TestEngine ID must not be null or blank");
@@ -115,8 +108,8 @@ public final class EngineTestKit {
 	 * @throws PreconditionViolationException if the {@code TestEngine} is
 	 * {@code null}
 	 * @see #engine(String)
-	 * @see #execute(String, LauncherDiscoveryRequest)
-	 * @see #execute(TestEngine, LauncherDiscoveryRequest)
+	 * @see #execute(String, EngineDiscoveryRequest)
+	 * @see #execute(TestEngine, EngineDiscoveryRequest)
 	 */
 	public static Builder engine(TestEngine testEngine) {
 		Preconditions.notNull(testEngine, "TestEngine must not be null");
@@ -146,49 +139,15 @@ public final class EngineTestKit {
 	 * @return the results of the execution
 	 * @throws PreconditionViolationException for invalid arguments or if the
 	 * {@code TestEngine} with the supplied ID cannot be loaded
-	 * @see #execute(String, LauncherDiscoveryRequest)
+	 * @see #execute(TestEngine, EngineDiscoveryRequest)
 	 * @see #engine(String)
 	 * @see #engine(TestEngine)
-	 * @deprecated Please use {@link #execute(String, LauncherDiscoveryRequest)}
-	 * instead.
 	 */
-	@Deprecated
-	@API(status = DEPRECATED, since = "1.7")
 	public static EngineExecutionResults execute(String engineId, EngineDiscoveryRequest discoveryRequest) {
 		Preconditions.notBlank(engineId, "TestEngine ID must not be null or blank");
 		return execute(loadTestEngine(engineId.trim()), discoveryRequest);
 	}
 
-	/**
-	 * Execute tests for the given {@link LauncherDiscoveryRequest} using the
-	 * {@link TestEngine} with the supplied ID.
-	 *
-	 * <p>The {@code TestEngine} will be loaded via Java's {@link ServiceLoader}
-	 * mechanism, analogous to the manner in which test engines are loaded in
-	 * the JUnit Platform Launcher API.
-	 *
-	 * <p>{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}
-	 * provides a convenient way to build an appropriate discovery request to
-	 * supply to this method. As an alternative, consider using
-	 * {@link #engine(TestEngine)} for a more fluent API.
-	 *
-	 * @param engineId the ID of the {@code TestEngine} to use; must not be
-	 * {@code null} or <em>blank</em>
-	 * @param discoveryRequest the {@code LauncherDiscoveryRequest} to use
-	 * @return the results of the execution
-	 * @throws PreconditionViolationException for invalid arguments or if the
-	 * {@code TestEngine} with the supplied ID cannot be loaded
-	 * @see #execute(TestEngine, LauncherDiscoveryRequest)
-	 * @see #engine(String)
-	 * @see #engine(TestEngine)
-	 * @since 1.7
-	 */
-	@API(status = EXPERIMENTAL, since = "1.7")
-	public static EngineExecutionResults execute(String engineId, LauncherDiscoveryRequest discoveryRequest) {
-		Preconditions.notBlank(engineId, "TestEngine ID must not be null or blank");
-		return execute(loadTestEngine(engineId.trim()), discoveryRequest);
-	}
-
 	/**
 	 * Execute tests for the given {@link EngineDiscoveryRequest} using the
 	 * supplied {@link TestEngine}.
@@ -207,54 +166,22 @@ public final class EngineTestKit {
 	 * not be {@code null}
 	 * @return the recorded {@code EngineExecutionResults}
 	 * @throws PreconditionViolationException for invalid arguments
-	 * @see #execute(TestEngine, LauncherDiscoveryRequest)
+	 * @see #execute(String, EngineDiscoveryRequest)
 	 * @see #engine(String)
 	 * @see #engine(TestEngine)
-	 * @deprecated Please use {@link #execute(TestEngine, LauncherDiscoveryRequest)}
-	 * instead.
 	 */
-	@Deprecated
-	@API(status = DEPRECATED, since = "1.7")
 	public static EngineExecutionResults execute(TestEngine testEngine, EngineDiscoveryRequest discoveryRequest) {
 		Preconditions.notNull(testEngine, "TestEngine must not be null");
 		Preconditions.notNull(discoveryRequest, "EngineDiscoveryRequest must not be null");
 
 		ExecutionRecorder executionRecorder = new ExecutionRecorder();
-		executeDirectly(testEngine, discoveryRequest, executionRecorder);
-		return executionRecorder.getExecutionResults();
-	}
-
-	/**
-	 * Execute tests for the given {@link LauncherDiscoveryRequest} using the
-	 * supplied {@link TestEngine}.
-	 *
-	 * <p>{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}
-	 * provides a convenient way to build an appropriate discovery request to
-	 * supply to this method. As an alternative, consider using
-	 * {@link #engine(TestEngine)} for a more fluent API.
-	 *
-	 * @param testEngine the {@code TestEngine} to use; must not be {@code null}
-	 * @param discoveryRequest the {@code LauncherDiscoveryRequest} to use; must
-	 * not be {@code null}
-	 * @return the recorded {@code EngineExecutionResults}
-	 * @throws PreconditionViolationException for invalid arguments
-	 * @see #execute(String, LauncherDiscoveryRequest)
-	 * @see #engine(String)
-	 * @see #engine(TestEngine)
-	 * @since 1.7
-	 */
-	@API(status = EXPERIMENTAL, since = "1.7")
-	public static EngineExecutionResults execute(TestEngine testEngine, LauncherDiscoveryRequest discoveryRequest) {
-		Preconditions.notNull(testEngine, "TestEngine must not be null");
-		Preconditions.notNull(discoveryRequest, "EngineDiscoveryRequest must not be null");
-
-		ExecutionRecorder executionRecorder = new ExecutionRecorder();
-		executeUsingLauncherOrchestration(testEngine, discoveryRequest, executionRecorder);
+		execute(testEngine, discoveryRequest, executionRecorder);
 		return executionRecorder.getExecutionResults();
 	}
 
-	private static void executeDirectly(TestEngine testEngine, EngineDiscoveryRequest discoveryRequest,
+	private static void execute(TestEngine testEngine, EngineDiscoveryRequest discoveryRequest,
 			EngineExecutionListener listener) {
+
 		UniqueId engineUniqueId = UniqueId.forEngine(testEngine.getId());
 		TestDescriptor engineTestDescriptor = testEngine.discover(discoveryRequest, engineUniqueId);
 		ExecutionRequest request = new ExecutionRequest(engineTestDescriptor, listener,
@@ -262,16 +189,6 @@ public final class EngineTestKit {
 		testEngine.execute(request);
 	}
 
-	private static void executeUsingLauncherOrchestration(TestEngine testEngine,
-			LauncherDiscoveryRequest discoveryRequest, EngineExecutionListener listener) {
-		TestDescriptor engineTestDescriptor;
-		LauncherDiscoveryResult discoveryResult = new EngineDiscoveryOrchestrator(singleton(testEngine)).discover(
-			discoveryRequest, "testing");
-		engineTestDescriptor = discoveryResult.getEngineTestDescriptor(testEngine);
-		Preconditions.notNull(engineTestDescriptor, "TestEngine did not yield a TestDescriptor");
-		new EngineExecutionOrchestrator().execute(discoveryResult, listener);
-	}
-
 	private static TestEngine loadTestEngine(String engineId) {
 		return stream((loadTestEngines()).spliterator(), false)//
 				.filter(engine -> engineId.equals(engine.getId()))//
@@ -323,7 +240,7 @@ public final class EngineTestKit {
 	 *
 	 * @since 1.4
 	 * @see #selectors(DiscoverySelector...)
-	 * @see #filters(Filter...)
+	 * @see #filters(DiscoveryFilter...)
 	 * @see #configurationParameter(String, String)
 	 * @see #configurationParameters(Map)
 	 * @see #execute()
@@ -345,7 +262,7 @@ public final class EngineTestKit {
 		 *
 		 * @param selectors the discovery selectors to add; never {@code null}
 		 * @return this builder for method chaining
-		 * @see #filters(Filter...)
+		 * @see #filters(DiscoveryFilter...)
 		 * @see #configurationParameter(String, String)
 		 * @see #configurationParameters(Map)
 		 * @see #execute()
@@ -364,45 +281,16 @@ public final class EngineTestKit {
 		 *
 		 * @param filters the discovery filters to add; never {@code null}
 		 * @return this builder for method chaining
-		 * @see #filters(Filter...)
 		 * @see #selectors(DiscoverySelector...)
 		 * @see #configurationParameter(String, String)
 		 * @see #configurationParameters(Map)
 		 * @see #execute()
-		 * @deprecated Please use {@link #filters(Filter...)} instead.
-		 * instead.
 		 */
-		@Deprecated
-		@API(status = DEPRECATED, since = "1.7")
 		public Builder filters(DiscoveryFilter<?>... filters) {
 			this.requestBuilder.filters(filters);
 			return this;
 		}
 
-		/**
-		 * Add all of the supplied {@linkplain Filter filters}.
-		 *
-		 * <p>Built-in discovery filters can be created via the static factory
-		 * methods in {@link org.junit.platform.engine.discovery.ClassNameFilter}
-		 * and {@link org.junit.platform.engine.discovery.PackageNameFilter}.
-		 *
-		 * <p>Built-in post-discovery filters can be created via the static
-		 * factory methods in {@link org.junit.platform.launcher.TagFilter}.
-		 *
-		 * @param filters the filters to add; never {@code null}
-		 * @return this builder for method chaining
-		 * @see #selectors(DiscoverySelector...)
-		 * @see #configurationParameter(String, String)
-		 * @see #configurationParameters(Map)
-		 * @see #execute()
-		 * @since 1.7
-		 */
-		@API(status = EXPERIMENTAL, since = "1.7")
-		public Builder filters(Filter<?>... filters) {
-			this.requestBuilder.filters(filters);
-			return this;
-		}
-
 		/**
 		 * Add the supplied <em>configuration parameter</em>.
 		 *
@@ -411,7 +299,7 @@ public final class EngineTestKit {
 		 * @param value the value to store
 		 * @return this builder for method chaining
 		 * @see #selectors(DiscoverySelector...)
-		 * @see #filters(Filter...)
+		 * @see #filters(DiscoveryFilter...)
 		 * @see #configurationParameters(Map)
 		 * @see #execute()
 		 * @see org.junit.platform.engine.ConfigurationParameters
@@ -428,7 +316,7 @@ public final class EngineTestKit {
 		 * never {@code null}
 		 * @return this builder for method chaining
 		 * @see #selectors(DiscoverySelector...)
-		 * @see #filters(Filter...)
+		 * @see #filters(DiscoveryFilter...)
 		 * @see #configurationParameter(String, String)
 		 * @see #execute()
 		 * @see org.junit.platform.engine.ConfigurationParameters
@@ -446,14 +334,13 @@ public final class EngineTestKit {
 		 *
 		 * @return the recorded {@code EngineExecutionResults}
 		 * @see #selectors(DiscoverySelector...)
-		 * @see #filters(Filter...)
+		 * @see #filters(DiscoveryFilter...)
 		 * @see #configurationParameter(String, String)
 		 * @see #configurationParameters(Map)
 		 */
 		public EngineExecutionResults execute() {
 			ExecutionRecorder executionRecorder = new ExecutionRecorder();
-			EngineTestKit.executeUsingLauncherOrchestration(this.testEngine, this.requestBuilder.build(),
-				executionRecorder);
+			EngineTestKit.execute(this.testEngine, this.requestBuilder.build(), executionRecorder);
 			return executionRecorder.getExecutionResults();
 		}
 
diff --git a/platform-tests/src/test/java/org/junit/platform/launcher/TagIntegrationTests.java b/platform-tests/src/test/java/org/junit/platform/launcher/TagIntegrationTests.java
index 6f5e9089e..4ced9ff22 100644
--- a/platform-tests/src/test/java/org/junit/platform/launcher/TagIntegrationTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/launcher/TagIntegrationTests.java
@@ -18,13 +18,14 @@ import static org.junit.platform.launcher.TagIntegrationTests.TaggedTestCase.dou
 import static org.junit.platform.launcher.TagIntegrationTests.TaggedTestCase.tag1WasExecuted;
 import static org.junit.platform.launcher.TagIntegrationTests.TaggedTestCase.tag2WasExecuted;
 import static org.junit.platform.launcher.TagIntegrationTests.TaggedTestCase.unTaggedWasExecuted;
+import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
-import org.junit.platform.testkit.engine.EngineTestKit;
+import org.junit.platform.launcher.core.LauncherFactory;
 
 class TagIntegrationTests {
 
@@ -79,10 +80,11 @@ class TagIntegrationTests {
 	}
 
 	private void executeTaggedTestCase(PostDiscoveryFilter filter) {
-		EngineTestKit.engine("junit-jupiter") //
+		var request = request() //
 				.selectors(selectClass(TaggedTestCase.class)) //
 				.filters(filter) //
-				.execute();
+				.build();
+		LauncherFactory.create().execute(request);
 	}
 
 	static class TaggedTestCase {
diff --git a/platform-tests/src/test/java/org/junit/platform/launcher/core/DefaultLauncherTests.java b/platform-tests/src/test/java/org/junit/platform/launcher/core/DefaultLauncherTests.java
index 969ce2b9a..aa24d09f9 100644
--- a/platform-tests/src/test/java/org/junit/platform/launcher/core/DefaultLauncherTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/launcher/core/DefaultLauncherTests.java
@@ -742,7 +742,7 @@ class DefaultLauncherTests {
 	void thirdPartyEngineUsingReservedEngineIdPrefixEmitsWarning(LogRecordListener listener) {
 		String id = "junit-using-reserved-prefix";
 		createLauncher(new TestEngineStub(id));
-		assertThat(listener.stream(EngineIdValidator.class, Level.WARNING).map(LogRecord::getMessage)) //
+		assertThat(listener.stream(DefaultLauncher.class, Level.WARNING).map(LogRecord::getMessage)) //
 				.containsExactly(
 					"Third-party TestEngine implementations are forbidden to use the reserved 'junit-' prefix for their ID: '"
 							+ id + "'");
diff --git a/platform-tests/src/test/java/org/junit/platform/launcher/core/ExecutionListenerAdapterTests.java b/platform-tests/src/test/java/org/junit/platform/launcher/core/ExecutionListenerAdapterTests.java
index a505c3d7f..fd803ef7c 100644
--- a/platform-tests/src/test/java/org/junit/platform/launcher/core/ExecutionListenerAdapterTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/launcher/core/ExecutionListenerAdapterTests.java
@@ -14,7 +14,6 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 
 import java.lang.reflect.Method;
-import java.util.Map;
 
 import org.junit.jupiter.api.Test;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -36,9 +35,10 @@ class ExecutionListenerAdapterTests {
 	void testReportingEntryPublished() {
 		TestDescriptor testDescriptor = getSampleMethodTestDescriptor();
 
-		LauncherDiscoveryResult discoveryResult = new LauncherDiscoveryResult(
-			Map.of(mock(TestEngine.class), testDescriptor), null);
-		InternalTestPlan testPlan = InternalTestPlan.from(discoveryResult);
+		//cannot mock final classes with mockito
+		Root root = new Root(null);
+		root.add(mock(TestEngine.class), testDescriptor);
+		InternalTestPlan testPlan = InternalTestPlan.from(root);
 		TestIdentifier testIdentifier = testPlan.getTestIdentifier(testDescriptor.getUniqueId().toString());
 
 		//not yet spyable with mockito? -> https://github.com/mockito/mockito/issues/146
diff --git a/platform-tests/src/test/resources/log4j2-test.xml b/platform-tests/src/test/resources/log4j2-test.xml
index 049091133..2df9896e5 100644
--- a/platform-tests/src/test/resources/log4j2-test.xml
+++ b/platform-tests/src/test/resources/log4j2-test.xml
@@ -9,7 +9,7 @@
 		<Logger name="org.junit" level="warn" />
 		<Logger name="org.junit.platform.commons.util.ClasspathScanner" level="error" />
 		<Logger name="org.junit.platform.engine.support.descriptor.DemoClassTestDescriptor" level="error" />
-		<Logger name="org.junit.platform.launcher.core.EngineIdValidator" level="fatal" />
+		<Logger name="org.junit.platform.launcher.core.DefaultLauncher" level="fatal" />
 		<Logger name="org.junit.platform.launcher.core.InternalTestPlan" level="error" />
 		<Logger name="org.junit.platform.launcher.core.TestExecutionListenerRegistry" level="error" />
 		<Logger name="org.junit.platform.launcher.listeners.discovery.LoggingLauncherDiscoveryListener" level="off" />
@@ -20,4 +20,4 @@
 			<AppenderRef ref="Console" />
 		</Root>
 	</Loggers>
-</Configuration>
+</Configuration>
\ No newline at end of file
