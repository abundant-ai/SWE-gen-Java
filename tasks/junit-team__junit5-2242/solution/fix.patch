diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M1.adoc
index a6fedc1a6..27175a6eb 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M1.adoc
@@ -22,6 +22,10 @@ on GitHub.
 * In the `EngineTestKit` API, the `all()`, `containers()`, and `tests()` methods in
   `EngineExecutionResults` that were deprecated in JUnit Platform 1.6.0 have been removed
   in favor of `allEvents()`, `containerEvents()`, and `testEvents()`, respectively.
+* The following methods in `EngineTestKit` are now deprecated with replacements:
+  - `execute(String, EngineDiscoveryRequest)` → `execute(String, LauncherDiscoveryRequest)`
+  - `execute(TestEngine, EngineDiscoveryRequest)` → `execute(TestEngine, LauncherDiscoveryRequest)`
+  - `Builder.filters(DiscoveryFilter...)` → `Builder.filters(Filter...)`
 
 ==== New Features and Improvements
 
@@ -36,6 +40,9 @@ on GitHub.
   execution of a submitted test via the returned `Future`.
 * Add `EngineExecutionListener.NOOP` and change all declared methods to have empty default
   implementations.
+* The `EngineTestKit` now reuses the same test discovery and execution logic as the
+  `Launcher`. Thus, it's now possible to test that an engine's behavior in the presence of
+  post-discovery filters (e.g. tag filters) and with regard to pruning.
 * The TestKit now allows to match conditions with events loosely, i.e. an incomplete match
   with or without a fixed order.
 
diff --git a/documentation/src/docs/asciidoc/user-guide/testkit.adoc b/documentation/src/docs/asciidoc/user-guide/testkit.adoc
index 83748cb09..32658381e 100644
--- a/documentation/src/docs/asciidoc/user-guide/testkit.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/testkit.adoc
@@ -17,10 +17,10 @@ given `{TestEngine}` running on the JUnit Platform and then accessing the result
 fluent API to verify the expected results. The key entry point into this API is the
 `{EngineTestKit}` which provides static factory methods named `engine()` and `execute()`.
 It is recommended that you select one of the `engine()` variants to benefit from the
-fluent API for building an `EngineDiscoveryRequest`.
+fluent API for building a `LauncherDiscoveryRequest`.
 
 NOTE: If you prefer to use the `LauncherDiscoveryRequestBuilder` from the `Launcher` API
-to build your `EngineDiscoveryRequest`, you must use one of the `execute()` variants in
+to build your `LauncherDiscoveryRequest`, you must use one of the `execute()` variants in
 `EngineTestKit`.
 
 The following test class written using JUnit Jupiter will be used in subsequent examples.
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java
index e68f1d968..ff7890538 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java
@@ -10,27 +10,9 @@
 
 package org.junit.platform.launcher.core;
 
-import java.util.HashSet;
-import java.util.Optional;
-import java.util.Set;
-import java.util.function.Consumer;
-
-import org.junit.platform.commons.JUnitException;
-import org.junit.platform.commons.logging.Logger;
-import org.junit.platform.commons.logging.LoggerFactory;
-import org.junit.platform.commons.util.BlacklistedExceptions;
 import org.junit.platform.commons.util.Preconditions;
-import org.junit.platform.engine.ConfigurationParameters;
-import org.junit.platform.engine.EngineExecutionListener;
-import org.junit.platform.engine.ExecutionRequest;
-import org.junit.platform.engine.FilterResult;
-import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestEngine;
-import org.junit.platform.engine.TestExecutionResult;
-import org.junit.platform.engine.UniqueId;
-import org.junit.platform.launcher.EngineDiscoveryResult;
 import org.junit.platform.launcher.Launcher;
-import org.junit.platform.launcher.LauncherDiscoveryListener;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
 import org.junit.platform.launcher.TestExecutionListener;
 import org.junit.platform.launcher.TestPlan;
@@ -47,11 +29,9 @@ import org.junit.platform.launcher.TestPlan;
  */
 class DefaultLauncher implements Launcher {
 
-	private static final Logger logger = LoggerFactory.getLogger(DefaultLauncher.class);
-
 	private final TestExecutionListenerRegistry listenerRegistry = new TestExecutionListenerRegistry();
-	private final EngineDiscoveryResultValidator discoveryResultValidator = new EngineDiscoveryResultValidator();
-	private final Iterable<TestEngine> testEngines;
+	private final EngineExecutionOrchestrator executionOrchestrator = new EngineExecutionOrchestrator(listenerRegistry);
+	private final EngineDiscoveryOrchestrator discoveryOrchestrator;
 
 	/**
 	 * Construct a new {@code DefaultLauncher} with the supplied test engines.
@@ -62,53 +42,7 @@ class DefaultLauncher implements Launcher {
 		Preconditions.condition(testEngines != null && testEngines.iterator().hasNext(),
 			() -> "Cannot create Launcher without at least one TestEngine; "
 					+ "consider adding an engine implementation JAR to the classpath");
-		this.testEngines = validateEngineIds(testEngines);
-	}
-
-	private static Iterable<TestEngine> validateEngineIds(Iterable<TestEngine> testEngines) {
-		Set<String> ids = new HashSet<>();
-		for (TestEngine testEngine : testEngines) {
-			// check usage of reserved id prefix
-			if (!validateReservedIds(testEngine)) {
-				logger.warn(() -> String.format(
-					"Third-party TestEngine implementations are forbidden to use the reserved 'junit-' prefix for their ID: '%s'",
-					testEngine.getId()));
-			}
-
-			// check uniqueness
-			if (!ids.add(testEngine.getId())) {
-				throw new JUnitException(String.format(
-					"Cannot create Launcher for multiple engines with the same ID '%s'.", testEngine.getId()));
-			}
-		}
-		return testEngines;
-	}
-
-	// https://github.com/junit-team/junit5/issues/1557
-	private static boolean validateReservedIds(TestEngine testEngine) {
-		String engineId = testEngine.getId();
-		if (!engineId.startsWith("junit-")) {
-			return true;
-		}
-		if (engineId.equals("junit-jupiter")) {
-			validateWellKnownClassName(testEngine, "org.junit.jupiter.engine.JupiterTestEngine");
-			return true;
-		}
-		if (engineId.equals("junit-vintage")) {
-			validateWellKnownClassName(testEngine, "org.junit.vintage.engine.VintageTestEngine");
-			return true;
-		}
-		return false;
-	}
-
-	private static void validateWellKnownClassName(TestEngine testEngine, String expectedClassName) {
-		String actualClassName = testEngine.getClass().getName();
-		if (actualClassName.equals(expectedClassName)) {
-			return;
-		}
-		throw new JUnitException(
-			String.format("Third-party TestEngine '%s' is forbidden to use the reserved '%s' TestEngine ID.",
-				actualClassName, testEngine.getId()));
+		this.discoveryOrchestrator = new EngineDiscoveryOrchestrator(EngineIdValidator.validate(testEngines));
 	}
 
 	@Override
@@ -121,7 +55,7 @@ class DefaultLauncher implements Launcher {
 	@Override
 	public TestPlan discover(LauncherDiscoveryRequest discoveryRequest) {
 		Preconditions.notNull(discoveryRequest, "LauncherDiscoveryRequest must not be null");
-		return InternalTestPlan.from(discoverRoot(discoveryRequest, "discovery"));
+		return InternalTestPlan.from(discover(discoveryRequest, "discovery"));
 	}
 
 	@Override
@@ -129,7 +63,7 @@ class DefaultLauncher implements Launcher {
 		Preconditions.notNull(discoveryRequest, "LauncherDiscoveryRequest must not be null");
 		Preconditions.notNull(listeners, "TestExecutionListener array must not be null");
 		Preconditions.containsNoNullElements(listeners, "individual listeners must not be null");
-		execute(InternalTestPlan.from(discoverRoot(discoveryRequest, "execution")), listeners);
+		execute(InternalTestPlan.from(discover(discoveryRequest, "execution")), listeners);
 	}
 
 	@Override
@@ -145,114 +79,12 @@ class DefaultLauncher implements Launcher {
 		return listenerRegistry;
 	}
 
-	private Root discoverRoot(LauncherDiscoveryRequest discoveryRequest, String phase) {
-		Root root = new Root(discoveryRequest.getConfigurationParameters());
-
-		for (TestEngine testEngine : this.testEngines) {
-			// @formatter:off
-			boolean engineIsExcluded = discoveryRequest.getEngineFilters().stream()
-					.map(engineFilter -> engineFilter.apply(testEngine))
-					.anyMatch(FilterResult::excluded);
-			// @formatter:on
-
-			if (engineIsExcluded) {
-				logger.debug(() -> String.format(
-					"Test discovery for engine '%s' was skipped due to an EngineFilter in phase '%s'.",
-					testEngine.getId(), phase));
-				continue;
-			}
-
-			logger.debug(() -> String.format("Discovering tests during Launcher %s phase in engine '%s'.", phase,
-				testEngine.getId()));
-
-			TestDescriptor rootDescriptor = discoverEngineRoot(testEngine, discoveryRequest);
-			root.add(testEngine, rootDescriptor);
-		}
-		root.applyPostDiscoveryFilters(discoveryRequest);
-		root.prune();
-		return root;
-	}
-
-	private TestDescriptor discoverEngineRoot(TestEngine testEngine, LauncherDiscoveryRequest discoveryRequest) {
-		LauncherDiscoveryListener discoveryListener = discoveryRequest.getDiscoveryListener();
-		UniqueId uniqueEngineId = UniqueId.forEngine(testEngine.getId());
-		try {
-			discoveryListener.engineDiscoveryStarted(uniqueEngineId);
-			TestDescriptor engineRoot = testEngine.discover(discoveryRequest, uniqueEngineId);
-			discoveryResultValidator.validate(testEngine, engineRoot);
-			discoveryListener.engineDiscoveryFinished(uniqueEngineId, EngineDiscoveryResult.successful());
-			return engineRoot;
-		}
-		catch (Throwable throwable) {
-			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
-			String message = String.format("TestEngine with ID '%s' failed to discover tests", testEngine.getId());
-			JUnitException cause = new JUnitException(message, throwable);
-			discoveryListener.engineDiscoveryFinished(uniqueEngineId, EngineDiscoveryResult.failed(cause));
-			return new EngineDiscoveryErrorDescriptor(uniqueEngineId, testEngine, cause);
-		}
+	private LauncherDiscoveryResult discover(LauncherDiscoveryRequest discoveryRequest, String phase) {
+		return discoveryOrchestrator.discover(discoveryRequest, phase);
 	}
 
 	private void execute(InternalTestPlan internalTestPlan, TestExecutionListener[] listeners) {
-		Root root = internalTestPlan.getRoot();
-		ConfigurationParameters configurationParameters = root.getConfigurationParameters();
-		TestExecutionListenerRegistry listenerRegistry = buildListenerRegistryForExecution(listeners);
-		withInterceptedStreams(configurationParameters, listenerRegistry, testExecutionListener -> {
-			testExecutionListener.testPlanExecutionStarted(internalTestPlan);
-			ExecutionListenerAdapter engineExecutionListener = new ExecutionListenerAdapter(internalTestPlan,
-				testExecutionListener);
-			for (TestEngine testEngine : root.getTestEngines()) {
-				TestDescriptor engineDescriptor = root.getTestDescriptorFor(testEngine);
-				if (engineDescriptor instanceof EngineDiscoveryErrorDescriptor) {
-					engineExecutionListener.executionStarted(engineDescriptor);
-					engineExecutionListener.executionFinished(engineDescriptor,
-						TestExecutionResult.failed(((EngineDiscoveryErrorDescriptor) engineDescriptor).getCause()));
-				}
-				else {
-					execute(engineDescriptor, engineExecutionListener, configurationParameters, testEngine);
-				}
-			}
-			testExecutionListener.testPlanExecutionFinished(internalTestPlan);
-		});
-	}
-
-	private void withInterceptedStreams(ConfigurationParameters configurationParameters,
-			TestExecutionListenerRegistry listenerRegistry, Consumer<TestExecutionListener> action) {
-
-		TestExecutionListener testExecutionListener = listenerRegistry.getCompositeTestExecutionListener();
-		Optional<StreamInterceptingTestExecutionListener> streamInterceptingTestExecutionListener = StreamInterceptingTestExecutionListener.create(
-			configurationParameters, testExecutionListener::reportingEntryPublished);
-		streamInterceptingTestExecutionListener.ifPresent(listenerRegistry::registerListeners);
-		try {
-			action.accept(testExecutionListener);
-		}
-		finally {
-			streamInterceptingTestExecutionListener.ifPresent(StreamInterceptingTestExecutionListener::unregister);
-		}
-	}
-
-	private TestExecutionListenerRegistry buildListenerRegistryForExecution(TestExecutionListener... listeners) {
-		if (listeners.length == 0) {
-			return this.listenerRegistry;
-		}
-		TestExecutionListenerRegistry registry = new TestExecutionListenerRegistry(this.listenerRegistry);
-		registry.registerListeners(listeners);
-		return registry;
-	}
-
-	private void execute(TestDescriptor engineDescriptor, EngineExecutionListener listener,
-			ConfigurationParameters configurationParameters, TestEngine testEngine) {
-
-		OutcomeDelayingEngineExecutionListener delayingListener = new OutcomeDelayingEngineExecutionListener(listener,
-			engineDescriptor);
-		try {
-			testEngine.execute(new ExecutionRequest(engineDescriptor, delayingListener, configurationParameters));
-			delayingListener.reportEngineOutcome();
-		}
-		catch (Throwable throwable) {
-			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
-			delayingListener.reportEngineFailure(new JUnitException(
-				String.format("TestEngine with ID '%s' failed to execute tests", testEngine.getId()), throwable));
-		}
+		executionOrchestrator.execute(internalTestPlan, listeners);
 	}
 
 }
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java
new file mode 100644
index 000000000..9c18943f3
--- /dev/null
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryOrchestrator.java
@@ -0,0 +1,163 @@
+/*
+ * Copyright 2015-2020 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.launcher.core;
+
+import static java.util.stream.Collectors.joining;
+import static org.apiguardian.api.API.Status.INTERNAL;
+import static org.junit.platform.engine.Filter.composeFilters;
+
+import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
+import org.apiguardian.api.API;
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.BlacklistedExceptions;
+import org.junit.platform.engine.Filter;
+import org.junit.platform.engine.FilterResult;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.TestEngine;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.launcher.EngineDiscoveryResult;
+import org.junit.platform.launcher.LauncherDiscoveryListener;
+import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.junit.platform.launcher.PostDiscoveryFilter;
+
+/**
+ * Orchestrates test discovery using the configured test engines.
+ *
+ * @since 1.7
+ */
+@API(status = INTERNAL, since = "1.7", consumers = "testkit")
+public class EngineDiscoveryOrchestrator {
+
+	private static final Logger logger = LoggerFactory.getLogger(EngineDiscoveryOrchestrator.class);
+
+	private final EngineDiscoveryResultValidator discoveryResultValidator = new EngineDiscoveryResultValidator();
+	private final Iterable<TestEngine> testEngines;
+
+	public EngineDiscoveryOrchestrator(Iterable<TestEngine> testEngines) {
+		this.testEngines = testEngines;
+	}
+
+	/**
+	 * Discovers tests for the supplied request in the supplied phase using the
+	 * configured test engines.
+	 *
+	 * <p>Applies {@linkplain org.junit.platform.launcher.EngineFilter engine
+	 * filters} and {@linkplain PostDiscoveryFilter post-discovery filters} and
+	 * {@linkplain TestDescriptor#prune() prunes} the resulting test tree.
+	 */
+	public LauncherDiscoveryResult discover(LauncherDiscoveryRequest request, String phase) {
+		Map<TestEngine, TestDescriptor> testEngineDescriptors = new LinkedHashMap<>();
+
+		for (TestEngine testEngine : this.testEngines) {
+			boolean engineIsExcluded = request.getEngineFilters().stream() //
+					.map(engineFilter -> engineFilter.apply(testEngine)) //
+					.anyMatch(FilterResult::excluded);
+
+			if (engineIsExcluded) {
+				logger.debug(() -> String.format(
+					"Test discovery for engine '%s' was skipped due to an EngineFilter in phase '%s'.",
+					testEngine.getId(), phase));
+				continue;
+			}
+
+			logger.debug(() -> String.format("Discovering tests during Launcher %s phase in engine '%s'.", phase,
+				testEngine.getId()));
+
+			TestDescriptor rootDescriptor = discoverEngineRoot(testEngine, request);
+			testEngineDescriptors.put(testEngine, rootDescriptor);
+		}
+
+		applyPostDiscoveryFilters(testEngineDescriptors, request.getPostDiscoveryFilters());
+		prune(testEngineDescriptors);
+
+		return new LauncherDiscoveryResult(testEngineDescriptors, request.getConfigurationParameters());
+	}
+
+	private TestDescriptor discoverEngineRoot(TestEngine testEngine, LauncherDiscoveryRequest discoveryRequest) {
+		LauncherDiscoveryListener discoveryListener = discoveryRequest.getDiscoveryListener();
+		UniqueId uniqueEngineId = UniqueId.forEngine(testEngine.getId());
+		try {
+			discoveryListener.engineDiscoveryStarted(uniqueEngineId);
+			TestDescriptor engineRoot = testEngine.discover(discoveryRequest, uniqueEngineId);
+			discoveryResultValidator.validate(testEngine, engineRoot);
+			discoveryListener.engineDiscoveryFinished(uniqueEngineId, EngineDiscoveryResult.successful());
+			return engineRoot;
+		}
+		catch (Throwable throwable) {
+			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
+			String message = String.format("TestEngine with ID '%s' failed to discover tests", testEngine.getId());
+			JUnitException cause = new JUnitException(message, throwable);
+			discoveryListener.engineDiscoveryFinished(uniqueEngineId, EngineDiscoveryResult.failed(cause));
+			return new EngineDiscoveryErrorDescriptor(uniqueEngineId, testEngine, cause);
+		}
+	}
+
+	private void applyPostDiscoveryFilters(Map<TestEngine, TestDescriptor> testEngineDescriptors,
+			List<PostDiscoveryFilter> filters) {
+		Filter<TestDescriptor> postDiscoveryFilter = composeFilters(filters);
+		Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason = new LinkedHashMap<>();
+		TestDescriptor.Visitor removeExcludedTestDescriptors = descriptor -> {
+			FilterResult filterResult = postDiscoveryFilter.apply(descriptor);
+			if (!descriptor.isRoot() && isExcluded(descriptor, filterResult)) {
+				populateExclusionReasonInMap(filterResult.getReason(), descriptor, excludedTestDescriptorsByReason);
+				descriptor.removeFromHierarchy();
+			}
+		};
+		acceptInAllTestEngines(testEngineDescriptors, removeExcludedTestDescriptors);
+		logTestDescriptorExclusionReasons(excludedTestDescriptorsByReason);
+	}
+
+	private void populateExclusionReasonInMap(Optional<String> reason, TestDescriptor testDescriptor,
+			Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
+		excludedTestDescriptorsByReason.computeIfAbsent(reason.orElse("Unknown"), list -> new LinkedList<>()).add(
+			testDescriptor);
+	}
+
+	private void logTestDescriptorExclusionReasons(Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
+		excludedTestDescriptorsByReason.forEach((exclusionReason, testDescriptors) -> {
+			String displayNames = testDescriptors.stream().map(TestDescriptor::getDisplayName).collect(joining(", "));
+			long containerCount = testDescriptors.stream().filter(TestDescriptor::isContainer).count();
+			long methodCount = testDescriptors.stream().filter(TestDescriptor::isTest).count();
+			logger.info(() -> String.format("%d containers and %d tests were %s", containerCount, methodCount,
+				exclusionReason));
+			logger.debug(
+				() -> String.format("The following containers and tests were %s: %s", exclusionReason, displayNames));
+		});
+	}
+
+	/**
+	 * Prune all branches in the tree of {@link TestDescriptor TestDescriptors}
+	 * that do not have executable tests.
+	 *
+	 * <p>If a {@link TestEngine} ends up with no {@code TestDescriptors} after
+	 * pruning, it will <strong>not</strong> be removed.
+	 */
+	private void prune(Map<TestEngine, TestDescriptor> testEngineDescriptors) {
+		acceptInAllTestEngines(testEngineDescriptors, TestDescriptor::prune);
+	}
+
+	private boolean isExcluded(TestDescriptor descriptor, FilterResult filterResult) {
+		return descriptor.getChildren().isEmpty() && filterResult.excluded();
+	}
+
+	private void acceptInAllTestEngines(Map<TestEngine, TestDescriptor> testEngineDescriptors,
+			TestDescriptor.Visitor visitor) {
+		testEngineDescriptors.values().forEach(descriptor -> descriptor.accept(visitor));
+	}
+
+}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java
new file mode 100644
index 000000000..bf36a0030
--- /dev/null
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineExecutionOrchestrator.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2015-2020 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.launcher.core;
+
+import static org.apiguardian.api.API.Status.INTERNAL;
+
+import java.util.Optional;
+import java.util.function.Consumer;
+
+import org.apiguardian.api.API;
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.util.BlacklistedExceptions;
+import org.junit.platform.engine.ConfigurationParameters;
+import org.junit.platform.engine.EngineExecutionListener;
+import org.junit.platform.engine.ExecutionRequest;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.TestEngine;
+import org.junit.platform.engine.TestExecutionResult;
+import org.junit.platform.launcher.TestExecutionListener;
+
+/**
+ * Orchestrates test execution using the configured test engines.
+ *
+ * @since 1.7
+ */
+@API(status = INTERNAL, since = "1.7", consumers = "testkit")
+public class EngineExecutionOrchestrator {
+
+	private final TestExecutionListenerRegistry listenerRegistry;
+
+	public EngineExecutionOrchestrator() {
+		this(new TestExecutionListenerRegistry());
+	}
+
+	EngineExecutionOrchestrator(TestExecutionListenerRegistry listenerRegistry) {
+		this.listenerRegistry = listenerRegistry;
+	}
+
+	void execute(InternalTestPlan internalTestPlan, TestExecutionListener... listeners) {
+		LauncherDiscoveryResult discoveryResult = internalTestPlan.getDiscoveryResult();
+		ConfigurationParameters configurationParameters = discoveryResult.getConfigurationParameters();
+		TestExecutionListenerRegistry listenerRegistry = buildListenerRegistryForExecution(listeners);
+		withInterceptedStreams(configurationParameters, listenerRegistry, testExecutionListener -> {
+			testExecutionListener.testPlanExecutionStarted(internalTestPlan);
+			execute(discoveryResult, new ExecutionListenerAdapter(internalTestPlan, testExecutionListener));
+			testExecutionListener.testPlanExecutionFinished(internalTestPlan);
+		});
+	}
+
+	private void withInterceptedStreams(ConfigurationParameters configurationParameters,
+			TestExecutionListenerRegistry listenerRegistry, Consumer<TestExecutionListener> action) {
+
+		TestExecutionListener testExecutionListener = listenerRegistry.getCompositeTestExecutionListener();
+		Optional<StreamInterceptingTestExecutionListener> streamInterceptingTestExecutionListener = StreamInterceptingTestExecutionListener.create(
+			configurationParameters, testExecutionListener::reportingEntryPublished);
+		streamInterceptingTestExecutionListener.ifPresent(listenerRegistry::registerListeners);
+		try {
+			action.accept(testExecutionListener);
+		}
+		finally {
+			streamInterceptingTestExecutionListener.ifPresent(StreamInterceptingTestExecutionListener::unregister);
+		}
+	}
+
+	/**
+	 * Executes tests for the supplied {@linkplain LauncherDiscoveryResult
+	 * discovery results} and notifies the supplied {@linkplain
+	 * EngineExecutionListener listener} of execution events.
+	 */
+	public void execute(LauncherDiscoveryResult discoveryResult, EngineExecutionListener listener) {
+		for (TestEngine testEngine : discoveryResult.getTestEngines()) {
+			TestDescriptor engineDescriptor = discoveryResult.getEngineTestDescriptor(testEngine);
+			if (engineDescriptor instanceof EngineDiscoveryErrorDescriptor) {
+				listener.executionStarted(engineDescriptor);
+				listener.executionFinished(engineDescriptor,
+					TestExecutionResult.failed(((EngineDiscoveryErrorDescriptor) engineDescriptor).getCause()));
+			}
+			else {
+				execute(engineDescriptor, listener, discoveryResult.getConfigurationParameters(), testEngine);
+			}
+		}
+	}
+
+	private TestExecutionListenerRegistry buildListenerRegistryForExecution(TestExecutionListener... listeners) {
+		if (listeners.length == 0) {
+			return this.listenerRegistry;
+		}
+		TestExecutionListenerRegistry registry = new TestExecutionListenerRegistry(this.listenerRegistry);
+		registry.registerListeners(listeners);
+		return registry;
+	}
+
+	private void execute(TestDescriptor engineDescriptor, EngineExecutionListener listener,
+			ConfigurationParameters configurationParameters, TestEngine testEngine) {
+
+		OutcomeDelayingEngineExecutionListener delayingListener = new OutcomeDelayingEngineExecutionListener(listener,
+			engineDescriptor);
+		try {
+			testEngine.execute(new ExecutionRequest(engineDescriptor, delayingListener, configurationParameters));
+			delayingListener.reportEngineOutcome();
+		}
+		catch (Throwable throwable) {
+			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
+			delayingListener.reportEngineFailure(new JUnitException(
+				String.format("TestEngine with ID '%s' failed to execute tests", testEngine.getId()), throwable));
+		}
+	}
+}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineIdValidator.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineIdValidator.java
new file mode 100644
index 000000000..7fe0d0787
--- /dev/null
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineIdValidator.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2015-2020 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.launcher.core;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.engine.TestEngine;
+
+/**
+ * @since 1.7
+ */
+class EngineIdValidator {
+
+	private static final Logger logger = LoggerFactory.getLogger(EngineIdValidator.class);
+
+	private EngineIdValidator() {
+	}
+
+	static Iterable<TestEngine> validate(Iterable<TestEngine> testEngines) {
+		Set<String> ids = new HashSet<>();
+		for (TestEngine testEngine : testEngines) {
+			// check usage of reserved id prefix
+			if (!validateReservedIds(testEngine)) {
+				logger.warn(() -> String.format(
+					"Third-party TestEngine implementations are forbidden to use the reserved 'junit-' prefix for their ID: '%s'",
+					testEngine.getId()));
+			}
+
+			// check uniqueness
+			if (!ids.add(testEngine.getId())) {
+				throw new JUnitException(String.format(
+					"Cannot create Launcher for multiple engines with the same ID '%s'.", testEngine.getId()));
+			}
+		}
+		return testEngines;
+	}
+
+	// https://github.com/junit-team/junit5/issues/1557
+	private static boolean validateReservedIds(TestEngine testEngine) {
+		String engineId = testEngine.getId();
+		if (!engineId.startsWith("junit-")) {
+			return true;
+		}
+		if (engineId.equals("junit-jupiter")) {
+			validateWellKnownClassName(testEngine, "org.junit.jupiter.engine.JupiterTestEngine");
+			return true;
+		}
+		if (engineId.equals("junit-vintage")) {
+			validateWellKnownClassName(testEngine, "org.junit.vintage.engine.VintageTestEngine");
+			return true;
+		}
+		return false;
+	}
+
+	private static void validateWellKnownClassName(TestEngine testEngine, String expectedClassName) {
+		String actualClassName = testEngine.getClass().getName();
+		if (actualClassName.equals(expectedClassName)) {
+			return;
+		}
+		throw new JUnitException(
+			String.format("Third-party TestEngine '%s' is forbidden to use the reserved '%s' TestEngine ID.",
+				actualClassName, testEngine.getId()));
+	}
+}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java
index 176b500d8..99426d516 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java
@@ -29,22 +29,22 @@ class InternalTestPlan extends TestPlan {
 	private static final Logger logger = LoggerFactory.getLogger(InternalTestPlan.class);
 
 	private final AtomicBoolean warningEmitted = new AtomicBoolean(false);
-	private final Root root;
+	private final LauncherDiscoveryResult discoveryResult;
 	private final TestPlan delegate;
 
-	static InternalTestPlan from(Root root) {
-		TestPlan delegate = TestPlan.from(root.getEngineDescriptors());
-		return new InternalTestPlan(root, delegate);
+	static InternalTestPlan from(LauncherDiscoveryResult discoveryResult) {
+		TestPlan delegate = TestPlan.from(discoveryResult.getEngineTestDescriptors());
+		return new InternalTestPlan(discoveryResult, delegate);
 	}
 
-	private InternalTestPlan(Root root, TestPlan delegate) {
+	private InternalTestPlan(LauncherDiscoveryResult discoveryResult, TestPlan delegate) {
 		super(delegate.containsTests());
-		this.root = root;
+		this.discoveryResult = discoveryResult;
 		this.delegate = delegate;
 	}
 
-	Root getRoot() {
-		return root;
+	LauncherDiscoveryResult getDiscoveryResult() {
+		return discoveryResult;
 	}
 
 	@Override
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryResult.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryResult.java
new file mode 100644
index 000000000..72e4a5110
--- /dev/null
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/LauncherDiscoveryResult.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2015-2020 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.launcher.core;
+
+import static java.util.Collections.unmodifiableMap;
+import static org.apiguardian.api.API.Status.INTERNAL;
+
+import java.util.Collection;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+import org.apiguardian.api.API;
+import org.junit.platform.engine.ConfigurationParameters;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.TestEngine;
+
+/**
+ * Represents the result of test discovery of the configured
+ * {@linkplain TestEngine test engines}.
+ *
+ * @since 1.7
+ */
+@API(status = INTERNAL, since = "1.7", consumers = "testkit")
+public class LauncherDiscoveryResult {
+
+	private final Map<TestEngine, TestDescriptor> testEngineDescriptors;
+	private final ConfigurationParameters configurationParameters;
+
+	LauncherDiscoveryResult(Map<TestEngine, TestDescriptor> testEngineDescriptors,
+			ConfigurationParameters configurationParameters) {
+		this.testEngineDescriptors = unmodifiableMap(new LinkedHashMap<>(testEngineDescriptors));
+		this.configurationParameters = configurationParameters;
+	}
+
+	public TestDescriptor getEngineTestDescriptor(TestEngine testEngine) {
+		return this.testEngineDescriptors.get(testEngine);
+	}
+
+	ConfigurationParameters getConfigurationParameters() {
+		return configurationParameters;
+	}
+
+	Collection<TestEngine> getTestEngines() {
+		return this.testEngineDescriptors.keySet();
+	}
+
+	Collection<TestDescriptor> getEngineTestDescriptors() {
+		return this.testEngineDescriptors.values();
+	}
+
+}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java
deleted file mode 100644
index 170183baa..000000000
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright 2015-2020 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.launcher.core;
-
-import static org.junit.platform.engine.Filter.composeFilters;
-
-import java.util.Collection;
-import java.util.LinkedHashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.stream.Collectors;
-
-import org.junit.platform.commons.logging.Logger;
-import org.junit.platform.commons.logging.LoggerFactory;
-import org.junit.platform.engine.ConfigurationParameters;
-import org.junit.platform.engine.Filter;
-import org.junit.platform.engine.FilterResult;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.TestEngine;
-import org.junit.platform.launcher.LauncherDiscoveryRequest;
-
-/**
- * Represents the root of all discovered {@link TestEngine TestEngines} and
- * their {@link TestDescriptor TestDescriptors}.
- *
- * @since 1.0
- */
-class Root {
-	private static final Logger logger = LoggerFactory.getLogger(Root.class);
-
-	private final Map<TestEngine, TestDescriptor> testEngineDescriptors = new LinkedHashMap<>(4);
-	private final ConfigurationParameters configurationParameters;
-
-	Root(ConfigurationParameters configurationParameters) {
-		this.configurationParameters = configurationParameters;
-	}
-
-	public ConfigurationParameters getConfigurationParameters() {
-		return configurationParameters;
-	}
-
-	/**
-	 * Add an {@code engine}'s root {@link TestDescriptor}.
-	 */
-	void add(TestEngine engine, TestDescriptor testDescriptor) {
-		this.testEngineDescriptors.put(engine, testDescriptor);
-	}
-
-	Iterable<TestEngine> getTestEngines() {
-		return this.testEngineDescriptors.keySet();
-	}
-
-	Collection<TestDescriptor> getEngineDescriptors() {
-		return this.testEngineDescriptors.values();
-	}
-
-	TestDescriptor getTestDescriptorFor(TestEngine testEngine) {
-		return this.testEngineDescriptors.get(testEngine);
-	}
-
-	void applyPostDiscoveryFilters(LauncherDiscoveryRequest discoveryRequest) {
-		Filter<TestDescriptor> postDiscoveryFilter = composeFilters(discoveryRequest.getPostDiscoveryFilters());
-		Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason = new LinkedHashMap<>();
-		TestDescriptor.Visitor removeExcludedTestDescriptors = descriptor -> {
-			FilterResult filterResult = postDiscoveryFilter.apply(descriptor);
-			if (!descriptor.isRoot() && isExcluded(descriptor, filterResult)) {
-				populateExclusionReasonInMap(filterResult.getReason(), descriptor, excludedTestDescriptorsByReason);
-				descriptor.removeFromHierarchy();
-			}
-		};
-		acceptInAllTestEngines(removeExcludedTestDescriptors);
-		logTestDescriptorExclusionReasons(excludedTestDescriptorsByReason);
-	}
-
-	private void populateExclusionReasonInMap(Optional<String> reason, TestDescriptor testDescriptor,
-			Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
-		excludedTestDescriptorsByReason.computeIfAbsent(reason.orElse("Unknown"), list -> new LinkedList<>()).add(
-			testDescriptor);
-	}
-
-	/**
-	 * Prune all branches in the tree of {@link TestDescriptor TestDescriptors}
-	 * that do not have executable tests.
-	 *
-	 * <p>If a {@link TestEngine} ends up with no {@code TestDescriptors} after
-	 * pruning, it will <strong>not</strong> be removed.
-	 */
-	void prune() {
-		acceptInAllTestEngines(TestDescriptor::prune);
-	}
-
-	private boolean isExcluded(TestDescriptor descriptor, FilterResult filterResult) {
-		return descriptor.getChildren().isEmpty() && filterResult.excluded();
-	}
-
-	private void acceptInAllTestEngines(TestDescriptor.Visitor visitor) {
-		this.testEngineDescriptors.values().forEach(descriptor -> descriptor.accept(visitor));
-	}
-
-	private void logTestDescriptorExclusionReasons(Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
-		excludedTestDescriptorsByReason.forEach((exclusionReason, testDescriptors) -> {
-			String displayNames = testDescriptors.stream().map(TestDescriptor::getDisplayName).collect(
-				Collectors.joining(", "));
-			long containerCount = testDescriptors.stream().filter(TestDescriptor::isContainer).count();
-			long methodCount = testDescriptors.stream().filter(TestDescriptor::isTest).count();
-			logger.info(() -> String.format("%d containers and %d tests were %s", containerCount, methodCount,
-				exclusionReason));
-			logger.debug(
-				() -> String.format("The following containers and tests were %s: %s", exclusionReason, displayNames));
-		});
-	}
-}
diff --git a/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java b/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java
index 5fad367c3..a4aa4de99 100644
--- a/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java
+++ b/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EngineTestKit.java
@@ -11,8 +11,10 @@
 package org.junit.platform.testkit.engine;
 
 import static java.lang.String.join;
+import static java.util.Collections.singleton;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.StreamSupport.stream;
+import static org.apiguardian.api.API.Status.DEPRECATED;
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 
 import java.util.ArrayList;
@@ -33,10 +35,15 @@ import org.junit.platform.engine.DiscoverySelector;
 import org.junit.platform.engine.EngineDiscoveryRequest;
 import org.junit.platform.engine.EngineExecutionListener;
 import org.junit.platform.engine.ExecutionRequest;
+import org.junit.platform.engine.Filter;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestEngine;
 import org.junit.platform.engine.UniqueId;
+import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.junit.platform.launcher.core.EngineDiscoveryOrchestrator;
+import org.junit.platform.launcher.core.EngineExecutionOrchestrator;
 import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
+import org.junit.platform.launcher.core.LauncherDiscoveryResult;
 
 /**
  * {@code EngineTestKit} provides support for executing a test plan for a given
@@ -46,8 +53,8 @@ import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
  * @since 1.4
  * @see #engine(String)
  * @see #engine(TestEngine)
- * @see #execute(String, EngineDiscoveryRequest)
- * @see #execute(TestEngine, EngineDiscoveryRequest)
+ * @see #execute(String, LauncherDiscoveryRequest)
+ * @see #execute(TestEngine, LauncherDiscoveryRequest)
  * @see EngineExecutionResults
  */
 @API(status = EXPERIMENTAL, since = "1.4")
@@ -81,8 +88,8 @@ public final class EngineTestKit {
 	 * or <em>blank</em>, or if the {@code TestEngine} with the supplied ID
 	 * cannot be loaded
 	 * @see #engine(TestEngine)
-	 * @see #execute(String, EngineDiscoveryRequest)
-	 * @see #execute(TestEngine, EngineDiscoveryRequest)
+	 * @see #execute(String, LauncherDiscoveryRequest)
+	 * @see #execute(TestEngine, LauncherDiscoveryRequest)
 	 */
 	public static Builder engine(String engineId) {
 		Preconditions.notBlank(engineId, "TestEngine ID must not be null or blank");
@@ -108,8 +115,8 @@ public final class EngineTestKit {
 	 * @throws PreconditionViolationException if the {@code TestEngine} is
 	 * {@code null}
 	 * @see #engine(String)
-	 * @see #execute(String, EngineDiscoveryRequest)
-	 * @see #execute(TestEngine, EngineDiscoveryRequest)
+	 * @see #execute(String, LauncherDiscoveryRequest)
+	 * @see #execute(TestEngine, LauncherDiscoveryRequest)
 	 */
 	public static Builder engine(TestEngine testEngine) {
 		Preconditions.notNull(testEngine, "TestEngine must not be null");
@@ -139,15 +146,49 @@ public final class EngineTestKit {
 	 * @return the results of the execution
 	 * @throws PreconditionViolationException for invalid arguments or if the
 	 * {@code TestEngine} with the supplied ID cannot be loaded
-	 * @see #execute(TestEngine, EngineDiscoveryRequest)
+	 * @see #execute(String, LauncherDiscoveryRequest)
 	 * @see #engine(String)
 	 * @see #engine(TestEngine)
+	 * @deprecated Please use {@link #execute(String, LauncherDiscoveryRequest)}
+	 * instead.
 	 */
+	@Deprecated
+	@API(status = DEPRECATED, since = "1.7")
 	public static EngineExecutionResults execute(String engineId, EngineDiscoveryRequest discoveryRequest) {
 		Preconditions.notBlank(engineId, "TestEngine ID must not be null or blank");
 		return execute(loadTestEngine(engineId.trim()), discoveryRequest);
 	}
 
+	/**
+	 * Execute tests for the given {@link LauncherDiscoveryRequest} using the
+	 * {@link TestEngine} with the supplied ID.
+	 *
+	 * <p>The {@code TestEngine} will be loaded via Java's {@link ServiceLoader}
+	 * mechanism, analogous to the manner in which test engines are loaded in
+	 * the JUnit Platform Launcher API.
+	 *
+	 * <p>{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}
+	 * provides a convenient way to build an appropriate discovery request to
+	 * supply to this method. As an alternative, consider using
+	 * {@link #engine(TestEngine)} for a more fluent API.
+	 *
+	 * @param engineId the ID of the {@code TestEngine} to use; must not be
+	 * {@code null} or <em>blank</em>
+	 * @param discoveryRequest the {@code LauncherDiscoveryRequest} to use
+	 * @return the results of the execution
+	 * @throws PreconditionViolationException for invalid arguments or if the
+	 * {@code TestEngine} with the supplied ID cannot be loaded
+	 * @see #execute(TestEngine, LauncherDiscoveryRequest)
+	 * @see #engine(String)
+	 * @see #engine(TestEngine)
+	 * @since 1.7
+	 */
+	@API(status = EXPERIMENTAL, since = "1.7")
+	public static EngineExecutionResults execute(String engineId, LauncherDiscoveryRequest discoveryRequest) {
+		Preconditions.notBlank(engineId, "TestEngine ID must not be null or blank");
+		return execute(loadTestEngine(engineId.trim()), discoveryRequest);
+	}
+
 	/**
 	 * Execute tests for the given {@link EngineDiscoveryRequest} using the
 	 * supplied {@link TestEngine}.
@@ -166,22 +207,54 @@ public final class EngineTestKit {
 	 * not be {@code null}
 	 * @return the recorded {@code EngineExecutionResults}
 	 * @throws PreconditionViolationException for invalid arguments
-	 * @see #execute(String, EngineDiscoveryRequest)
+	 * @see #execute(TestEngine, LauncherDiscoveryRequest)
 	 * @see #engine(String)
 	 * @see #engine(TestEngine)
+	 * @deprecated Please use {@link #execute(TestEngine, LauncherDiscoveryRequest)}
+	 * instead.
 	 */
+	@Deprecated
+	@API(status = DEPRECATED, since = "1.7")
 	public static EngineExecutionResults execute(TestEngine testEngine, EngineDiscoveryRequest discoveryRequest) {
 		Preconditions.notNull(testEngine, "TestEngine must not be null");
 		Preconditions.notNull(discoveryRequest, "EngineDiscoveryRequest must not be null");
 
 		ExecutionRecorder executionRecorder = new ExecutionRecorder();
-		execute(testEngine, discoveryRequest, executionRecorder);
+		executeDirectly(testEngine, discoveryRequest, executionRecorder);
 		return executionRecorder.getExecutionResults();
 	}
 
-	private static void execute(TestEngine testEngine, EngineDiscoveryRequest discoveryRequest,
-			EngineExecutionListener listener) {
+	/**
+	 * Execute tests for the given {@link LauncherDiscoveryRequest} using the
+	 * supplied {@link TestEngine}.
+	 *
+	 * <p>{@link org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder}
+	 * provides a convenient way to build an appropriate discovery request to
+	 * supply to this method. As an alternative, consider using
+	 * {@link #engine(TestEngine)} for a more fluent API.
+	 *
+	 * @param testEngine the {@code TestEngine} to use; must not be {@code null}
+	 * @param discoveryRequest the {@code LauncherDiscoveryRequest} to use; must
+	 * not be {@code null}
+	 * @return the recorded {@code EngineExecutionResults}
+	 * @throws PreconditionViolationException for invalid arguments
+	 * @see #execute(String, LauncherDiscoveryRequest)
+	 * @see #engine(String)
+	 * @see #engine(TestEngine)
+	 * @since 1.7
+	 */
+	@API(status = EXPERIMENTAL, since = "1.7")
+	public static EngineExecutionResults execute(TestEngine testEngine, LauncherDiscoveryRequest discoveryRequest) {
+		Preconditions.notNull(testEngine, "TestEngine must not be null");
+		Preconditions.notNull(discoveryRequest, "EngineDiscoveryRequest must not be null");
 
+		ExecutionRecorder executionRecorder = new ExecutionRecorder();
+		executeUsingLauncherOrchestration(testEngine, discoveryRequest, executionRecorder);
+		return executionRecorder.getExecutionResults();
+	}
+
+	private static void executeDirectly(TestEngine testEngine, EngineDiscoveryRequest discoveryRequest,
+			EngineExecutionListener listener) {
 		UniqueId engineUniqueId = UniqueId.forEngine(testEngine.getId());
 		TestDescriptor engineTestDescriptor = testEngine.discover(discoveryRequest, engineUniqueId);
 		ExecutionRequest request = new ExecutionRequest(engineTestDescriptor, listener,
@@ -189,6 +262,16 @@ public final class EngineTestKit {
 		testEngine.execute(request);
 	}
 
+	private static void executeUsingLauncherOrchestration(TestEngine testEngine,
+			LauncherDiscoveryRequest discoveryRequest, EngineExecutionListener listener) {
+		TestDescriptor engineTestDescriptor;
+		LauncherDiscoveryResult discoveryResult = new EngineDiscoveryOrchestrator(singleton(testEngine)).discover(
+			discoveryRequest, "testing");
+		engineTestDescriptor = discoveryResult.getEngineTestDescriptor(testEngine);
+		Preconditions.notNull(engineTestDescriptor, "TestEngine did not yield a TestDescriptor");
+		new EngineExecutionOrchestrator().execute(discoveryResult, listener);
+	}
+
 	private static TestEngine loadTestEngine(String engineId) {
 		return stream((loadTestEngines()).spliterator(), false)//
 				.filter(engine -> engineId.equals(engine.getId()))//
@@ -240,7 +323,7 @@ public final class EngineTestKit {
 	 *
 	 * @since 1.4
 	 * @see #selectors(DiscoverySelector...)
-	 * @see #filters(DiscoveryFilter...)
+	 * @see #filters(Filter...)
 	 * @see #configurationParameter(String, String)
 	 * @see #configurationParameters(Map)
 	 * @see #execute()
@@ -262,7 +345,7 @@ public final class EngineTestKit {
 		 *
 		 * @param selectors the discovery selectors to add; never {@code null}
 		 * @return this builder for method chaining
-		 * @see #filters(DiscoveryFilter...)
+		 * @see #filters(Filter...)
 		 * @see #configurationParameter(String, String)
 		 * @see #configurationParameters(Map)
 		 * @see #execute()
@@ -281,16 +364,45 @@ public final class EngineTestKit {
 		 *
 		 * @param filters the discovery filters to add; never {@code null}
 		 * @return this builder for method chaining
+		 * @see #filters(Filter...)
 		 * @see #selectors(DiscoverySelector...)
 		 * @see #configurationParameter(String, String)
 		 * @see #configurationParameters(Map)
 		 * @see #execute()
+		 * @deprecated Please use {@link #filters(Filter...)} instead.
+		 * instead.
 		 */
+		@Deprecated
+		@API(status = DEPRECATED, since = "1.7")
 		public Builder filters(DiscoveryFilter<?>... filters) {
 			this.requestBuilder.filters(filters);
 			return this;
 		}
 
+		/**
+		 * Add all of the supplied {@linkplain Filter filters}.
+		 *
+		 * <p>Built-in discovery filters can be created via the static factory
+		 * methods in {@link org.junit.platform.engine.discovery.ClassNameFilter}
+		 * and {@link org.junit.platform.engine.discovery.PackageNameFilter}.
+		 *
+		 * <p>Built-in post-discovery filters can be created via the static
+		 * factory methods in {@link org.junit.platform.launcher.TagFilter}.
+		 *
+		 * @param filters the filters to add; never {@code null}
+		 * @return this builder for method chaining
+		 * @see #selectors(DiscoverySelector...)
+		 * @see #configurationParameter(String, String)
+		 * @see #configurationParameters(Map)
+		 * @see #execute()
+		 * @since 1.7
+		 */
+		@API(status = EXPERIMENTAL, since = "1.7")
+		public Builder filters(Filter<?>... filters) {
+			this.requestBuilder.filters(filters);
+			return this;
+		}
+
 		/**
 		 * Add the supplied <em>configuration parameter</em>.
 		 *
@@ -299,7 +411,7 @@ public final class EngineTestKit {
 		 * @param value the value to store
 		 * @return this builder for method chaining
 		 * @see #selectors(DiscoverySelector...)
-		 * @see #filters(DiscoveryFilter...)
+		 * @see #filters(Filter...)
 		 * @see #configurationParameters(Map)
 		 * @see #execute()
 		 * @see org.junit.platform.engine.ConfigurationParameters
@@ -316,7 +428,7 @@ public final class EngineTestKit {
 		 * never {@code null}
 		 * @return this builder for method chaining
 		 * @see #selectors(DiscoverySelector...)
-		 * @see #filters(DiscoveryFilter...)
+		 * @see #filters(Filter...)
 		 * @see #configurationParameter(String, String)
 		 * @see #execute()
 		 * @see org.junit.platform.engine.ConfigurationParameters
@@ -334,13 +446,14 @@ public final class EngineTestKit {
 		 *
 		 * @return the recorded {@code EngineExecutionResults}
 		 * @see #selectors(DiscoverySelector...)
-		 * @see #filters(DiscoveryFilter...)
+		 * @see #filters(Filter...)
 		 * @see #configurationParameter(String, String)
 		 * @see #configurationParameters(Map)
 		 */
 		public EngineExecutionResults execute() {
 			ExecutionRecorder executionRecorder = new ExecutionRecorder();
-			EngineTestKit.execute(this.testEngine, this.requestBuilder.build(), executionRecorder);
+			EngineTestKit.executeUsingLauncherOrchestration(this.testEngine, this.requestBuilder.build(),
+				executionRecorder);
 			return executionRecorder.getExecutionResults();
 		}
 
