diff --git a/CHANGELOG.md b/CHANGELOG.md
index f3f6ccb40..8f86b53d3 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -32,7 +32,7 @@ Currently the versioning policy of this project follows [Semantic Versioning v2.
 - Dead store fix when switch case contains loops  ([#3530](https://github.com/spotbugs/spotbugs/issues/3530))  ([#3449](https://github.com/spotbugs/spotbugs/issues/3449))
 -  Consider PUTFIELD and PUTSTATIC when looking for assertions with side effects ([#3463](https://github.com/spotbugs/spotbugs/issues/3463))
 - Detect cases when equals() unconditionally returns true or false ([#3528](https://github.com/spotbugs/spotbugs/issues/3528))
-
+- Do not report that an Iterator does not throw `NoSuchElementException` when `hasNext()` returns true ([#3501](https://github.com/spotbugs/spotbugs/issues/3501))
 ### Added
 - Added the unnecessary annotation to the `US_USELESS_SUPPRESSION_ON_*` messages ([#3395](https://github.com/spotbugs/spotbugs/issues/3395))
 - Multi-threaded code checks can be skipped with `@NotThreadSafe` ([#3390](https://github.com/spotbugs/spotbugs/issues/3390))
diff --git a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/IteratorIdioms.java b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/IteratorIdioms.java
index 1c099481b..6ce945d62 100644
--- a/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/IteratorIdioms.java
+++ b/spotbugs/src/main/java/edu/umd/cs/findbugs/detect/IteratorIdioms.java
@@ -21,8 +21,10 @@ package edu.umd.cs.findbugs.detect;
 
 import org.apache.bcel.Const;
 import org.apache.bcel.classfile.Code;
+import org.apache.bcel.classfile.JavaClass;
 import org.apache.bcel.classfile.Method;
 
+import edu.umd.cs.findbugs.BugAccumulator;
 import edu.umd.cs.findbugs.BugInstance;
 import edu.umd.cs.findbugs.BugReporter;
 import edu.umd.cs.findbugs.BytecodeScanningDetector;
@@ -34,19 +36,29 @@ import edu.umd.cs.findbugs.classfile.ClassDescriptor;
 import edu.umd.cs.findbugs.classfile.DescriptorFactory;
 
 public class IteratorIdioms extends BytecodeScanningDetector implements StatelessDetector {
+    private static final String NEXT_NAME = "next";
+
+    private static final String HAS_NEXT_NAME = "hasNext";
 
     private final ClassDescriptor iteratorDescriptor = DescriptorFactory.createClassDescriptor(java.util.Iterator.class);
 
     private final BugReporter bugReporter;
 
+    private final BugAccumulator bugAccumulator;
+
     private boolean sawNoSuchElement;
 
     private boolean sawCall;
 
     private boolean shouldVisitCode;
 
+    private boolean hasNextAlwaysReturnsTrue;
+
+    private boolean sawBranch;
+
     public IteratorIdioms(BugReporter bugReporter) {
         this.bugReporter = bugReporter;
+        this.bugAccumulator = new BugAccumulator(bugReporter);
     }
 
     @Override
@@ -54,6 +66,8 @@ public class IteratorIdioms extends BytecodeScanningDetector implements Stateles
         Subtypes2 subtypes2 = AnalysisContext.currentAnalysisContext().getSubtypes2();
         try {
             if (subtypes2.isSubtype(classContext.getClassDescriptor(), iteratorDescriptor)) {
+                hasNextAlwaysReturnsTrue = false;
+
                 super.visitClassContext(classContext);
             }
         } catch (ClassNotFoundException e) {
@@ -64,7 +78,9 @@ public class IteratorIdioms extends BytecodeScanningDetector implements Stateles
 
     @Override
     public void visit(Method method) {
-        if (method.isPublic() && "next".equals(method.getName()) && method.getArgumentTypes().length == 0) {
+        if (method.isPublic()
+                && (NEXT_NAME.equals(method.getName()) || HAS_NEXT_NAME.equals(method.getName()))
+                && method.getArgumentTypes().length == 0) {
             shouldVisitCode = true;
             super.visit(method);
         } else {
@@ -73,17 +89,30 @@ public class IteratorIdioms extends BytecodeScanningDetector implements Stateles
     }
 
     @Override
-    public void visit(Code obj) {
+    public void visit(Code code) {
         if (!shouldVisitCode) {
             return;
         }
         sawNoSuchElement = false;
         sawCall = false;
-        super.visit(obj);
-        if (!sawNoSuchElement) {
+        sawBranch = false;
+
+        super.visit(code);
+
+        if (!sawNoSuchElement && NEXT_NAME.equals(getMethodName())) {
+            // Accumulate the bug but do not report it because we don't know if we have visited `hasNext()`
             BugInstance bug = new BugInstance(this, "IT_NO_SUCH_ELEMENT", sawCall ? LOW_PRIORITY : NORMAL_PRIORITY);
             bug.addClassAndMethod(this);
-            bugReporter.reportBug(bug);
+            bugAccumulator.accumulateBug(bug, this);
+        }
+    }
+
+    @Override
+    public void visitAfter(JavaClass obj) {
+        if (hasNextAlwaysReturnsTrue) {
+            bugAccumulator.clearBugs();
+        } else {
+            bugAccumulator.reportAccumulatedBugs();
         }
     }
 
@@ -99,5 +128,12 @@ public class IteratorIdioms extends BytecodeScanningDetector implements Stateles
                 sawNoSuchElement = true;
             }
         }
+
+        // Unconditional `return true;`
+        if (seen == Const.IRETURN && getPC() >= 1 && getPrevOpcode(1) == Const.ICONST_1 && !sawBranch) {
+            hasNextAlwaysReturnsTrue = true;
+        }
+
+        sawBranch |= isBranch(seen);
     }
 }
diff --git a/spotbugsTestCases/src/java/ghIssues/Issue3501.java b/spotbugsTestCases/src/java/ghIssues/Issue3501.java
new file mode 100644
index 000000000..4c9266b1d
--- /dev/null
+++ b/spotbugsTestCases/src/java/ghIssues/Issue3501.java
@@ -0,0 +1,21 @@
+package ghIssues;
+
+import java.util.Iterator;
+
+public class Issue3501<T> implements Iterator<T> {
+    private final T value;
+
+    private Issue3501(T value) {
+        this.value = value;
+    }
+
+    @Override
+    public boolean hasNext() {
+        return true;
+    }
+
+    @Override
+    public T next() {
+        return value;
+    }
+}
