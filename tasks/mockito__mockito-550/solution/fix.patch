diff --git a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
index 92e586891..5b52a7126 100644
--- a/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
+++ b/src/main/java/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
@@ -98,7 +98,7 @@ public class PropertyAndSetterInjection extends MockInjectionStrategy {
                 Throwable realCause = e.getCause().getCause();
                 throw fieldInitialisationThrewException(field, realCause);
             }
-            throw cannotInitializeForInjectMocksAnnotation(field.getName(), e);
+            throw cannotInitializeForInjectMocksAnnotation(field.getName(),e.getMessage());
         }
     }
 
diff --git a/src/main/java/org/mockito/internal/exceptions/Reporter.java b/src/main/java/org/mockito/internal/exceptions/Reporter.java
index 3a63d69dd..8a28e67f8 100644
--- a/src/main/java/org/mockito/internal/exceptions/Reporter.java
+++ b/src/main/java/org/mockito/internal/exceptions/Reporter.java
@@ -627,16 +627,14 @@ public class Reporter {
                                          ""), details);
     }
 
-    public static MockitoException cannotInitializeForInjectMocksAnnotation(String fieldName, Exception details) {
-        return new MockitoException(join("Cannot instantiate @InjectMocks field named '" + fieldName + "'.",
+    public static MockitoException cannotInitializeForInjectMocksAnnotation(String fieldName, String causeMessage) {
+        return new MockitoException(join("Cannot instantiate @InjectMocks field named '" + fieldName + "'! Cause: "+causeMessage,
                                          "You haven't provided the instance at field declaration so I tried to construct the instance.",
-                                         "However, I failed because: " + details.getMessage(),
                                          "Examples of correct usage of @InjectMocks:",
                                          "   @InjectMocks Service service = new Service();",
                                          "   @InjectMocks Service service;",
-                                         "   //also, don't forget about MockitoAnnotations.initMocks();",
                                          "   //and... don't forget about some @Mocks for injection :)",
-                                         ""), details);
+                                         ""));
     }
 
     public static MockitoException atMostAndNeverShouldNotBeUsedWithTimeout() {
diff --git a/src/main/java/org/mockito/internal/util/reflection/FieldInitializer.java b/src/main/java/org/mockito/internal/util/reflection/FieldInitializer.java
index 7a49e1f6b..fdc697549 100644
--- a/src/main/java/org/mockito/internal/util/reflection/FieldInitializer.java
+++ b/src/main/java/org/mockito/internal/util/reflection/FieldInitializer.java
@@ -7,6 +7,7 @@ package org.mockito.internal.util.reflection;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.internal.util.MockUtil;
 
+import static java.lang.reflect.Modifier.isStatic;
 import static org.mockito.internal.util.reflection.FieldSetter.setField;
 
 import java.lang.reflect.Constructor;
@@ -68,7 +69,9 @@ public class FieldInitializer {
             checkNotLocal(field);
             checkNotInner(field);
             checkNotInterface(field);
+            checkNotEnum(field);
             checkNotAbstract(field);
+            
         }
         this.fieldOwner = fieldOwner;
         this.field = field;
@@ -100,8 +103,9 @@ public class FieldInitializer {
     }
 
     private void checkNotInner(Field field) {
-        if(field.getType().isMemberClass() && !Modifier.isStatic(field.getType().getModifiers())) {
-            throw new MockitoException("the type '" + field.getType().getSimpleName() + "' is an inner class.");
+        Class<?> type = field.getType();
+        if(type.isMemberClass() && !isStatic(type.getModifiers())) {
+            throw new MockitoException("the type '" + type.getSimpleName() + "' is an inner non static class.");
         }
     }
 
@@ -113,10 +117,17 @@ public class FieldInitializer {
 
     private void checkNotAbstract(Field field) {
         if(Modifier.isAbstract(field.getType().getModifiers())) {
-            throw new MockitoException("the type '" + field.getType().getSimpleName() + " is an abstract class.");
+            throw new MockitoException("the type '" + field.getType().getSimpleName() + "' is an abstract class.");
+        }
+    }
+    
+    private void checkNotEnum(Field field) {
+        if(field.getType().isEnum()) {
+            throw new MockitoException("the type '" + field.getType().getSimpleName() + "' is an enum.");
         }
     }
 
+
     private FieldInitializationReport acquireFieldInstance() throws IllegalAccessException {
         Object fieldInstance = field.get(fieldOwner);
         if(fieldInstance != null) {
