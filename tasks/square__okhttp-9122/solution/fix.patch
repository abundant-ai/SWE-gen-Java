diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 94b68b837..b6a300a65 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -9,7 +9,7 @@ graalvm = "25.0.0"
 #noinspection UnusedVersionCatalogEntry
 junit-platform = "1.13.4"
 kotlinx-serialization = "1.9.0"
-ksp = "2.2.20-2.0.4"
+ksp = "2.2.20-2.0.3"
 lintGradle = "1.0.0-alpha05"
 mockserverClient = "5.15.0"
 org-bouncycastle = "1.82"
diff --git a/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt b/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
index dee06c026..948482c2c 100644
--- a/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
+++ b/okhttp-testing-support/src/main/kotlin/okhttp3/TestValueFactory.kt
@@ -35,7 +35,6 @@ import okhttp3.internal.RecordingOkAuthenticator
 import okhttp3.internal.concurrent.TaskFaker
 import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.concurrent.withLock
-import okhttp3.internal.connection.CallConnectionUser
 import okhttp3.internal.connection.ConnectionListener
 import okhttp3.internal.connection.RealCall
 import okhttp3.internal.connection.RealConnection
@@ -194,12 +193,8 @@ class TestValueFactory : Closeable {
       fastFallback = client.fastFallback,
       address = address,
       routeDatabase = client.routeDatabase,
-      connectionUser =
-        CallConnectionUser(
-          call,
-          client.connectionPool.delegate.connectionListener,
-          chain,
-        ),
+      call = call,
+      request = call.request(),
     )
   }
 
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/CallConnectionUser.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/CallConnectionUser.kt
deleted file mode 100644
index 5f2c7a315..000000000
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/CallConnectionUser.kt
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
- * Copyright (C) 2025 Block, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection
-
-import java.io.IOException
-import java.net.InetAddress
-import java.net.Proxy
-import java.net.Socket
-import okhttp3.Connection
-import okhttp3.EventListener
-import okhttp3.Handshake
-import okhttp3.HttpUrl
-import okhttp3.Protocol
-import okhttp3.Route
-import okhttp3.internal.http.RealInterceptorChain
-
-/**
- * A connection user that is a specific [RealCall].
- */
-internal class CallConnectionUser(
-  private val call: RealCall,
-  private val poolConnectionListener: ConnectionListener,
-  private val chain: RealInterceptorChain,
-) : ConnectionUser {
-  private val eventListener: EventListener
-    get() = call.eventListener
-
-  override fun addPlanToCancel(connectPlan: ConnectPlan) {
-    call.plansToCancel += connectPlan
-  }
-
-  override fun removePlanToCancel(connectPlan: ConnectPlan) {
-    call.plansToCancel -= connectPlan
-  }
-
-  override fun updateRouteDatabaseAfterSuccess(route: Route) {
-    call.client.routeDatabase.connected(route)
-  }
-
-  override fun connectStart(route: Route) {
-    eventListener.connectStart(call, route.socketAddress, route.proxy)
-    poolConnectionListener.connectStart(route, call)
-  }
-
-  override fun connectFailed(
-    route: Route,
-    protocol: Protocol?,
-    e: IOException,
-  ) {
-    eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
-    poolConnectionListener.connectFailed(route, call, e)
-  }
-
-  override fun secureConnectStart() {
-    eventListener.secureConnectStart(call)
-  }
-
-  override fun secureConnectEnd(handshake: Handshake?) {
-    eventListener.secureConnectEnd(call, handshake)
-  }
-
-  override fun callConnectEnd(
-    route: Route,
-    protocol: Protocol?,
-  ) {
-    eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
-  }
-
-  override fun connectionConnectEnd(
-    connection: Connection,
-    route: Route,
-  ) {
-    poolConnectionListener.connectEnd(connection, route, call)
-  }
-
-  override fun connectionAcquired(connection: Connection) {
-    eventListener.connectionAcquired(call, connection)
-  }
-
-  override fun acquireConnectionNoEvents(connection: RealConnection) {
-    call.acquireConnectionNoEvents(connection)
-  }
-
-  override fun releaseConnectionNoEvents(): Socket? = call.releaseConnectionNoEvents()
-
-  override fun connectionReleased(connection: Connection) {
-    eventListener.connectionReleased(call, connection)
-  }
-
-  override fun connectionConnectionAcquired(connection: RealConnection) {
-    connection.connectionListener.connectionAcquired(connection, call)
-  }
-
-  override fun connectionConnectionReleased(connection: RealConnection) {
-    connection.connectionListener.connectionReleased(connection, call)
-  }
-
-  override fun connectionConnectionClosed(connection: RealConnection) {
-    connection.connectionListener.connectionClosed(connection)
-  }
-
-  override fun noNewExchanges(connection: RealConnection) {
-    connection.connectionListener.noNewExchanges(connection)
-  }
-
-  override fun doExtensiveHealthChecks(): Boolean = chain.request.method != "GET"
-
-  override fun isCanceled(): Boolean = call.isCanceled()
-
-  override fun candidateConnection(): RealConnection? = call.connection
-
-  override fun proxySelectStart(url: HttpUrl) {
-    eventListener.proxySelectStart(call, url)
-  }
-
-  override fun proxySelectEnd(
-    url: HttpUrl,
-    proxies: List<Proxy>,
-  ) {
-    eventListener.proxySelectEnd(call, url, proxies)
-  }
-
-  override fun dnsStart(socketHost: String) {
-    eventListener.dnsStart(call, socketHost)
-  }
-
-  override fun dnsEnd(
-    socketHost: String,
-    result: List<InetAddress>,
-  ) {
-    eventListener.dnsEnd(call, socketHost, result)
-  }
-}
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/ConnectPlan.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/ConnectPlan.kt
index 2ad364175..a83bb3559 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/ConnectPlan.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/ConnectPlan.kt
@@ -54,7 +54,7 @@ import okhttp3.internal.toHostHeader
  * Each step may fail. If a retry is possible, a new instance is created with the next plan, which
  * will be configured differently.
  */
-class ConnectPlan(
+class ConnectPlan internal constructor(
   private val taskRunner: TaskRunner,
   private val connectionPool: RealConnectionPool,
   private val readTimeoutMillis: Int,
@@ -63,7 +63,7 @@ class ConnectPlan(
   private val socketReadTimeoutMillis: Int,
   private val pingIntervalMillis: Int,
   private val retryOnConnectionFailure: Boolean,
-  private val user: ConnectionUser,
+  private val call: RealCall,
   private val routePlanner: RealRoutePlanner,
   // Specifics to this plan.
   override val route: Route,
@@ -111,7 +111,7 @@ class ConnectPlan(
       socketReadTimeoutMillis = socketReadTimeoutMillis,
       pingIntervalMillis = pingIntervalMillis,
       retryOnConnectionFailure = retryOnConnectionFailure,
-      user = user,
+      call = call,
       routePlanner = routePlanner,
       route = route,
       routes = routes,
@@ -127,9 +127,10 @@ class ConnectPlan(
     var success = false
 
     // Tell the call about the connecting call so async cancels work.
-    user.addPlanToCancel(this)
+    call.plansToCancel += this
     try {
-      user.connectStart(route)
+      call.eventListener.connectStart(call, route.socketAddress, route.proxy)
+      connectionPool.connectionListener.connectStart(route, call)
 
       connectSocket()
       success = true
@@ -143,10 +144,11 @@ class ConnectPlan(
           e,
         )
       }
-      user.connectFailed(route, null, e)
+      call.eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
+      connectionPool.connectionListener.connectFailed(route, call, e)
       return ConnectResult(plan = this, throwable = e)
     } finally {
-      user.removePlanToCancel(this)
+      call.plansToCancel -= this
       if (!success) {
         rawSocket?.closeQuietly()
       }
@@ -162,7 +164,7 @@ class ConnectPlan(
     var success = false
 
     // Tell the call about the connecting call so async cancels work.
-    user.addPlanToCancel(this)
+    call.plansToCancel += this
     try {
       if (tunnelRequest != null) {
         val tunnelResult = connectTunnel()
@@ -182,7 +184,7 @@ class ConnectPlan(
           throw IOException("TLS tunnel buffered too many bytes!")
         }
 
-        user.secureConnectStart()
+        call.eventListener.secureConnectStart(call)
 
         // Create the wrapper over the connected socket.
         val sslSocket =
@@ -202,7 +204,7 @@ class ConnectPlan(
 
         connectionSpec.apply(sslSocket, isFallback = tlsEquipPlan.isTlsFallback)
         connectTls(sslSocket, connectionSpec)
-        user.secureConnectEnd(handshake)
+        call.eventListener.secureConnectEnd(call, handshake)
       } else {
         javaNetSocket = rawSocket
         protocol =
@@ -229,11 +231,12 @@ class ConnectPlan(
       connection.start()
 
       // Success.
-      user.callConnectEnd(route, protocol)
+      call.eventListener.connectEnd(call, route.socketAddress, route.proxy, protocol)
       success = true
       return ConnectResult(plan = this)
     } catch (e: IOException) {
-      user.connectFailed(route, null, e)
+      call.eventListener.connectFailed(call, route.socketAddress, route.proxy, null, e)
+      connectionPool.connectionListener.connectFailed(route, call, e)
 
       if (!retryOnConnectionFailure || !retryTlsHandshake(e)) {
         retryTlsConnection = null
@@ -245,7 +248,7 @@ class ConnectPlan(
         throwable = e,
       )
     } finally {
-      user.removePlanToCancel(this)
+      call.plansToCancel -= this
       if (!success) {
         javaNetSocket?.closeQuietly()
         rawSocket.closeQuietly()
@@ -310,7 +313,7 @@ class ConnectPlan(
     val nextAttempt = attempt + 1
     return when {
       nextAttempt < MAX_TUNNEL_ATTEMPTS -> {
-        user.callConnectEnd(route, null)
+        call.eventListener.connectEnd(call, route.socketAddress, route.proxy, null)
         ConnectResult(
           plan = this,
           nextPlan =
@@ -325,7 +328,8 @@ class ConnectPlan(
           ProtocolException(
             "Too many tunnel connections attempted: $MAX_TUNNEL_ATTEMPTS",
           )
-        user.connectFailed(route, null, failure)
+        call.eventListener.connectFailed(call, route.socketAddress, route.proxy, null, failure)
+        connectionPool.connectionListener.connectFailed(route, call, failure)
         return ConnectResult(plan = this, throwable = failure)
       }
     }
@@ -491,10 +495,10 @@ class ConnectPlan(
 
   /** Returns the connection to use, which might be different from [connection]. */
   override fun handleSuccess(): RealConnection {
-    user.updateRouteDatabaseAfterSuccess(route)
+    call.client.routeDatabase.connected(route)
 
     val connection = this.connection!!
-    user.connectionConnectEnd(connection, route)
+    connection.connectionListener.connectEnd(connection, route, call)
 
     // If we raced another call connecting to this host, coalesce the connections. This makes for
     // 3 different lookups in the connection pool!
@@ -503,11 +507,11 @@ class ConnectPlan(
 
     connection.withLock {
       connectionPool.put(connection)
-      user.acquireConnectionNoEvents(connection)
+      call.acquireConnectionNoEvents(connection)
     }
 
-    user.connectionAcquired(connection)
-    user.connectionConnectionAcquired(connection)
+    call.eventListener.connectionAcquired(call, connection)
+    connection.connectionListener.connectionAcquired(connection, call)
     return connection
   }
 
@@ -538,7 +542,7 @@ class ConnectPlan(
       socketReadTimeoutMillis = socketReadTimeoutMillis,
       pingIntervalMillis = pingIntervalMillis,
       retryOnConnectionFailure = retryOnConnectionFailure,
-      user = user,
+      call = call,
       routePlanner = routePlanner,
       route = route,
       routes = routes,
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/ConnectionUser.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/ConnectionUser.kt
deleted file mode 100644
index d6856c0d1..000000000
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/ConnectionUser.kt
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2024 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection
-
-import java.io.IOException
-import java.net.InetAddress
-import java.net.Proxy
-import java.net.Socket
-import okhttp3.Connection
-import okhttp3.Handshake
-import okhttp3.HttpUrl
-import okhttp3.Protocol
-import okhttp3.Route
-
-/**
- * The object that is asking for a connection. Either a call or a connect policy from the pool.
- */
-interface ConnectionUser {
-  fun addPlanToCancel(connectPlan: ConnectPlan)
-
-  fun removePlanToCancel(connectPlan: ConnectPlan)
-
-  fun updateRouteDatabaseAfterSuccess(route: Route)
-
-  fun connectStart(route: Route)
-
-  fun secureConnectStart()
-
-  fun secureConnectEnd(handshake: Handshake?)
-
-  fun callConnectEnd(
-    route: Route,
-    protocol: Protocol?,
-  )
-
-  fun connectionConnectEnd(
-    connection: Connection,
-    route: Route,
-  )
-
-  fun connectFailed(
-    route: Route,
-    protocol: Protocol?,
-    e: IOException,
-  )
-
-  fun connectionAcquired(connection: Connection)
-
-  fun acquireConnectionNoEvents(connection: RealConnection)
-
-  fun releaseConnectionNoEvents(): Socket?
-
-  fun connectionReleased(connection: Connection)
-
-  fun connectionConnectionAcquired(connection: RealConnection)
-
-  fun connectionConnectionReleased(connection: RealConnection)
-
-  fun connectionConnectionClosed(connection: RealConnection)
-
-  fun noNewExchanges(connection: RealConnection)
-
-  fun doExtensiveHealthChecks(): Boolean
-
-  fun isCanceled(): Boolean
-
-  fun candidateConnection(): RealConnection?
-
-  fun proxySelectStart(url: HttpUrl)
-
-  fun proxySelectEnd(
-    url: HttpUrl,
-    proxies: List<Proxy>,
-  )
-
-  fun dnsStart(socketHost: String)
-
-  fun dnsEnd(
-    socketHost: String,
-    result: List<InetAddress>,
-  )
-}
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/PoolConnectionUser.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/PoolConnectionUser.kt
deleted file mode 100644
index cccdb50aa..000000000
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/PoolConnectionUser.kt
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2024 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection
-
-import java.io.IOException
-import java.net.InetAddress
-import java.net.Proxy
-import java.net.Socket
-import okhttp3.Connection
-import okhttp3.Handshake
-import okhttp3.HttpUrl
-import okhttp3.Protocol
-import okhttp3.Route
-
-/**
- * A user that is a connection pool creating connections in the background
- * without an intent to immediately use them.
- */
-object PoolConnectionUser : ConnectionUser {
-  override fun addPlanToCancel(connectPlan: ConnectPlan) {
-  }
-
-  override fun removePlanToCancel(connectPlan: ConnectPlan) {
-  }
-
-  override fun updateRouteDatabaseAfterSuccess(route: Route) {
-  }
-
-  override fun connectStart(route: Route) {
-  }
-
-  override fun secureConnectStart() {
-  }
-
-  override fun secureConnectEnd(handshake: Handshake?) {
-  }
-
-  override fun callConnectEnd(
-    route: Route,
-    protocol: Protocol?,
-  ) {
-  }
-
-  override fun connectionConnectEnd(
-    connection: Connection,
-    route: Route,
-  ) {
-  }
-
-  override fun connectFailed(
-    route: Route,
-    protocol: Protocol?,
-    e: IOException,
-  ) {
-  }
-
-  override fun connectionAcquired(connection: Connection) {
-  }
-
-  override fun acquireConnectionNoEvents(connection: RealConnection) {
-  }
-
-  override fun releaseConnectionNoEvents(): Socket? = null
-
-  override fun connectionReleased(connection: Connection) {
-  }
-
-  override fun connectionConnectionAcquired(connection: RealConnection) {
-  }
-
-  override fun connectionConnectionReleased(connection: RealConnection) {
-  }
-
-  override fun connectionConnectionClosed(connection: RealConnection) {
-  }
-
-  override fun noNewExchanges(connection: RealConnection) {
-  }
-
-  override fun doExtensiveHealthChecks(): Boolean = false
-
-  override fun isCanceled(): Boolean = false
-
-  override fun candidateConnection(): RealConnection? = null
-
-  override fun proxySelectStart(url: HttpUrl) {
-  }
-
-  override fun proxySelectEnd(
-    url: HttpUrl,
-    proxies: List<Proxy>,
-  ) {
-  }
-
-  override fun dnsStart(socketHost: String) {
-  }
-
-  override fun dnsEnd(
-    socketHost: String,
-    result: List<InetAddress>,
-  ) {
-  }
-}
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
index 7d6f9755a..c6e0f53fb 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
@@ -133,7 +133,7 @@ class RealCall(
    * and response body streams; otherwise resources may be leaked.
    *
    * This method is safe to be called concurrently, but provides limited guarantees. If a transport
-   * layer connection has been established (such as a HTTP/2 stream) that is terminated. Otherwise
+   * layer connection has been established (such as a HTTP/2 stream) that is terminated. Otherwise,
    * if a socket connection is being established, that is terminated.
    */
   override fun cancel() {
@@ -257,8 +257,9 @@ class RealCall(
           retryOnConnectionFailure = client.retryOnConnectionFailure,
           fastFallback = client.fastFallback,
           address = client.address(request.url),
-          connectionUser = CallConnectionUser(this, connectionPool.connectionListener, chain),
           routeDatabase = client.routeDatabase,
+          call = this,
+          request = request,
         )
       this.exchangeFinder =
         when {
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealConnectionPool.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealConnectionPool.kt
index b7d84907d..85b334cd6 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealConnectionPool.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealConnectionPool.kt
@@ -68,9 +68,9 @@ class RealConnectionPool internal constructor(
   fun connectionCount(): Int = connections.size
 
   /**
-   * Attempts to acquire a recycled connection to [address] for [connectionUser]. Returns the connection if it
+   * Attempts to acquire a recycled connection to [address] for [call]. Returns the connection if it
    * was acquired, or null if no connection was acquired. The acquired connection will also be
-   * given to [connectionUser] who may (for example) assign it to a [RealCall.connection].
+   * given to [call] who may (for example) assign it to a [RealCall.connection].
    *
    * This confirms the returned connection is healthy before returning it. If this encounters any
    * unhealthy connections in its search, this will clean them up.
@@ -79,10 +79,10 @@ class RealConnectionPool internal constructor(
    * This is used to coalesce related domains to the same HTTP/2 connection, such as `square.com`
    * and `square.ca`.
    */
-  fun callAcquirePooledConnection(
+  internal fun callAcquirePooledConnection(
     doExtensiveHealthChecks: Boolean,
     address: Address,
-    connectionUser: ConnectionUser,
+    call: RealCall,
     routes: List<Route>?,
     requireMultiplexed: Boolean,
   ): RealConnection? {
@@ -94,7 +94,7 @@ class RealConnectionPool internal constructor(
             requireMultiplexed && !connection.isMultiplexed -> false
             !connection.isEligible(address, routes) -> false
             else -> {
-              connectionUser.acquireConnectionNoEvents(connection)
+              call.acquireConnectionNoEvents(connection)
               true
             }
           }
@@ -111,7 +111,7 @@ class RealConnectionPool internal constructor(
         connection.withLock {
           noNewExchangesEvent = !connection.noNewExchanges
           connection.noNewExchanges = true
-          connectionUser.releaseConnectionNoEvents()
+          call.releaseConnectionNoEvents()
         }
       if (toClose != null) {
         toClose.closeQuietly()
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt
index 8ce85aa66..5b6e6ddcb 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealRoutePlanner.kt
@@ -35,7 +35,7 @@ import okhttp3.internal.connection.RoutePlanner.Plan
 import okhttp3.internal.platform.Platform
 import okhttp3.internal.toHostHeader
 
-class RealRoutePlanner(
+class RealRoutePlanner internal constructor(
   private val taskRunner: TaskRunner,
   private val connectionPool: RealConnectionPool,
   private val readTimeoutMillis: Int,
@@ -47,15 +47,17 @@ class RealRoutePlanner(
   private val fastFallback: Boolean,
   override val address: Address,
   private val routeDatabase: RouteDatabase,
-  private val connectionUser: ConnectionUser,
+  private val call: RealCall,
+  request: Request,
 ) : RoutePlanner {
+  private val doExtensiveHealthChecks = request.method != "GET"
   private var routeSelection: RouteSelector.Selection? = null
   private var routeSelector: RouteSelector? = null
   private var nextRouteToTry: Route? = null
 
   override val deferredPlans = ArrayDeque<Plan>()
 
-  override fun isCanceled(): Boolean = connectionUser.isCanceled()
+  override fun isCanceled(): Boolean = call.isCanceled()
 
   @Throws(IOException::class)
   override fun plan(): Plan {
@@ -88,11 +90,11 @@ class RealRoutePlanner(
    */
   private fun planReuseCallConnection(): ReusePlan? {
     // This may be mutated by releaseConnectionNoEvents()!
-    val candidate = connectionUser.candidateConnection() ?: return null
+    val candidate = call.connection ?: return null
 
     // Make sure this connection is healthy & eligible for new exchanges. If it's no longer needed
     // then we're on the hook to close it.
-    val healthy = candidate.isHealthy(connectionUser.doExtensiveHealthChecks())
+    val healthy = candidate.isHealthy(doExtensiveHealthChecks)
     var noNewExchangesEvent = false
     val toClose: Socket? =
       candidate.withLock {
@@ -100,10 +102,10 @@ class RealRoutePlanner(
           !healthy -> {
             noNewExchangesEvent = !candidate.noNewExchanges
             candidate.noNewExchanges = true
-            connectionUser.releaseConnectionNoEvents()
+            call.releaseConnectionNoEvents()
           }
           candidate.noNewExchanges || !sameHostAndPort(candidate.route().address.url) -> {
-            connectionUser.releaseConnectionNoEvents()
+            call.releaseConnectionNoEvents()
           }
           else -> null
         }
@@ -111,19 +113,19 @@ class RealRoutePlanner(
 
     // If the call's connection wasn't released, reuse it. We don't call connectionAcquired() here
     // because we already acquired it.
-    if (connectionUser.candidateConnection() != null) {
+    if (call.connection != null) {
       check(toClose == null)
       return ReusePlan(candidate)
     }
 
     // The call's connection was released.
     toClose?.closeQuietly()
-    connectionUser.connectionReleased(candidate)
-    connectionUser.connectionConnectionReleased(candidate)
+    call.eventListener.connectionReleased(call, candidate)
+    candidate.connectionListener.connectionReleased(candidate, call)
     if (toClose != null) {
-      connectionUser.connectionConnectionClosed(candidate)
+      candidate.connectionListener.connectionClosed(candidate)
     } else if (noNewExchangesEvent) {
-      connectionUser.noNewExchanges(candidate)
+      candidate.connectionListener.noNewExchanges(candidate)
     }
     return null
   }
@@ -151,7 +153,7 @@ class RealRoutePlanner(
         RouteSelector(
           address = address,
           routeDatabase = routeDatabase,
-          connectionUser = connectionUser,
+          call = call,
           fastFallback = fastFallback,
         )
       routeSelector = newRouteSelector
@@ -180,9 +182,9 @@ class RealRoutePlanner(
   ): ReusePlan? {
     val result =
       connectionPool.callAcquirePooledConnection(
-        doExtensiveHealthChecks = connectionUser.doExtensiveHealthChecks(),
+        doExtensiveHealthChecks = doExtensiveHealthChecks,
         address = address,
-        connectionUser = connectionUser,
+        call = call,
         routes = routes,
         requireMultiplexed = planToReplace != null && planToReplace.isReady,
       ) ?: return null
@@ -194,8 +196,8 @@ class RealRoutePlanner(
       planToReplace.closeQuietly()
     }
 
-    connectionUser.connectionAcquired(result)
-    connectionUser.connectionConnectionAcquired(result)
+    call.eventListener.connectionAcquired(call, result)
+    result.connectionListener.connectionAcquired(result, call)
     return ReusePlan(result)
   }
 
@@ -237,7 +239,7 @@ class RealRoutePlanner(
       socketReadTimeoutMillis = socketReadTimeoutMillis,
       pingIntervalMillis = pingIntervalMillis,
       retryOnConnectionFailure = retryOnConnectionFailure,
-      user = connectionUser,
+      call = call,
       routePlanner = this,
       route = route,
       routes = routes,
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RouteSelector.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RouteSelector.kt
index 8d90cca78..c4fc3149d 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RouteSelector.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RouteSelector.kt
@@ -21,7 +21,6 @@ import java.net.InetSocketAddress
 import java.net.Proxy
 import java.net.SocketException
 import java.net.UnknownHostException
-import java.util.NoSuchElementException
 import okhttp3.Address
 import okhttp3.HttpUrl
 import okhttp3.Route
@@ -33,10 +32,10 @@ import okhttp3.internal.toImmutableList
  * Selects routes to connect to an origin server. Each connection requires a choice of proxy server,
  * IP address, and TLS mode. Connections may also be recycled.
  */
-class RouteSelector(
+class RouteSelector internal constructor(
   private val address: Address,
   private val routeDatabase: RouteDatabase,
-  private val connectionUser: ConnectionUser,
+  private val call: RealCall,
   private val fastFallback: Boolean,
 ) {
   // State for negotiating the next proxy to use.
@@ -112,10 +111,10 @@ class RouteSelector(
       return proxiesOrNull.toImmutableList()
     }
 
-    connectionUser.proxySelectStart(url)
+    call.eventListener.proxySelectStart(call, url)
     proxies = selectProxies()
     nextProxyIndex = 0
-    connectionUser.proxySelectEnd(url, proxies)
+    call.eventListener.proxySelectEnd(call, url, proxies)
   }
 
   /** Returns true if there's another proxy to try. */
@@ -166,14 +165,14 @@ class RouteSelector(
         if (socketHost.canParseAsIpAddress()) {
           listOf(InetAddress.getByName(socketHost))
         } else {
-          connectionUser.dnsStart(socketHost)
+          call.eventListener.dnsStart(call, socketHost)
 
           val result = address.dns.lookup(socketHost)
           if (result.isEmpty()) {
             throw UnknownHostException("${address.dns} returned no addresses for $socketHost")
           }
 
-          connectionUser.dnsEnd(socketHost, result)
+          call.eventListener.dnsEnd(call, socketHost, result)
           result
         }
 
