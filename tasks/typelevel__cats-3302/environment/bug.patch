diff --git a/core/src/main/scala-2.13+/cats/instances/arraySeq.scala b/core/src/main/scala-2.13+/cats/instances/arraySeq.scala
index 494925bea..961ce0b89 100644
--- a/core/src/main/scala-2.13+/cats/instances/arraySeq.scala
+++ b/core/src/main/scala-2.13+/cats/instances/arraySeq.scala
@@ -1,14 +1,11 @@
 package cats
 package instances
 
-import cats.data.Ior
 import scala.annotation.tailrec
 import scala.collection.immutable.ArraySeq
-import scala.collection.mutable.Builder
 
 trait ArraySeqInstances extends cats.kernel.instances.ArraySeqInstances {
-  implicit def catsStdInstancesForArraySeq
-    : Traverse[ArraySeq] with Monad[ArraySeq] with Alternative[ArraySeq] with CoflatMap[ArraySeq] with Align[ArraySeq] =
+  implicit def catsStdInstancesForArraySeq: Monad[ArraySeq] with MonoidK[ArraySeq] with Traverse[ArraySeq] =
     ArraySeqInstances.stdInstances
 
   implicit def catsStdTraverseFilterForArraySeq: TraverseFilter[ArraySeq] =
@@ -20,14 +17,9 @@ trait ArraySeqInstances extends cats.kernel.instances.ArraySeqInstances {
     }
 }
 
-private[cats] object ArraySeqInstances {
-  final private val stdInstances
-    : Traverse[ArraySeq] with Monad[ArraySeq] with Alternative[ArraySeq] with CoflatMap[ArraySeq] with Align[ArraySeq] =
-    new Traverse[ArraySeq]
-      with Monad[ArraySeq]
-      with Alternative[ArraySeq]
-      with CoflatMap[ArraySeq]
-      with Align[ArraySeq] {
+object ArraySeqInstances {
+  final private val stdInstances =
+    new Monad[ArraySeq] with MonoidK[ArraySeq] with Traverse[ArraySeq] {
       def empty[A]: ArraySeq[A] =
         ArraySeq.untagged.empty
 
@@ -46,15 +38,6 @@ private[cats] object ArraySeqInstances {
       def flatMap[A, B](fa: ArraySeq[A])(f: A => ArraySeq[B]): ArraySeq[B] =
         fa.flatMap(f)
 
-      def coflatMap[A, B](fa: ArraySeq[A])(f: ArraySeq[A] => B): ArraySeq[B] = {
-        @tailrec def loop(builder: Builder[B, ArraySeq[B]], as: ArraySeq[A]): ArraySeq[B] =
-          as match {
-            case _ +: rest => loop(builder += f(as), rest)
-            case _         => builder.result()
-          }
-        loop(ArraySeq.untagged.newBuilder[B], fa)
-      }
-
       override def map2[A, B, Z](fa: ArraySeq[A], fb: ArraySeq[B])(f: (A, B) => Z): ArraySeq[Z] =
         if (fb.isEmpty) ArraySeq.empty // do O(1) work if fb is empty
         else fa.flatMap(a => fb.map(b => f(a, b))) // already O(1) if fa is empty
@@ -155,21 +138,9 @@ private[cats] object ArraySeqInstances {
 
       override def collectFirstSome[A, B](fa: ArraySeq[A])(f: A => Option[B]): Option[B] =
         fa.collectFirst(Function.unlift(f))
-
-      def functor: Functor[ArraySeq] = this
-
-      def align[A, B](fa: ArraySeq[A], fb: ArraySeq[B]): ArraySeq[Ior[A, B]] = {
-        val aLarger = fa.size >= fb.size
-        if (aLarger) {
-          fa.lazyZip(fb).map(Ior.both) ++ fa.drop(fb.size).map(Ior.left)
-        } else {
-          fa.lazyZip(fb).map(Ior.both) ++ fb.drop(fa.size).map(Ior.right)
-        }
-      }
-
     }
 
-  final private val stdTraverseFilterInstance: TraverseFilter[ArraySeq] =
+  final private val stdTraverseFilterInstance =
     new TraverseFilter[ArraySeq] {
       val traverse: Traverse[ArraySeq] = stdInstances
 
diff --git a/kernel/src/main/scala-2.13+/cats/kernel/instances/ArraySeqInstances.scala b/kernel/src/main/scala-2.13+/cats/kernel/instances/ArraySeqInstances.scala
index 2c7021b75..09a242f34 100644
--- a/kernel/src/main/scala-2.13+/cats/kernel/instances/ArraySeqInstances.scala
+++ b/kernel/src/main/scala-2.13+/cats/kernel/instances/ArraySeqInstances.scala
@@ -15,7 +15,7 @@ trait ArraySeqInstances extends ArraySeqInstances.ArraySeqInstances1 {
 }
 
 object ArraySeqInstances {
-  private[instances] trait ArraySeqInstances1 extends ArraySeqInstances2 {
+  trait ArraySeqInstances1 extends ArraySeqInstances2 {
     implicit def catsKernelStdPartialOrderForArraySeq[A: PartialOrder]: PartialOrder[ArraySeq[A]] =
       new ArraySeqPartialOrder[A]
 
@@ -23,7 +23,7 @@ object ArraySeqInstances {
       new ArraySeqHash[A]
   }
 
-  private[instances] trait ArraySeqInstances2 {
+  trait ArraySeqInstances2 {
     implicit def catsKernelStdEqForArraySeq[A: Eq]: Eq[ArraySeq[A]] =
       new ArraySeqEq[A]
   }
diff --git a/tests/src/test/scala-2.13+/cats/tests/ArraySeqSuite.scala b/tests/src/test/scala-2.13+/cats/tests/ArraySeqSuite.scala
index fa1a29199..5aef9eb2c 100644
--- a/tests/src/test/scala-2.13+/cats/tests/ArraySeqSuite.scala
+++ b/tests/src/test/scala-2.13+/cats/tests/ArraySeqSuite.scala
@@ -2,15 +2,7 @@ package cats
 package tests
 
 import cats.kernel.laws.discipline.{EqTests, HashTests, MonoidTests, OrderTests, PartialOrderTests}
-import cats.laws.discipline.{
-  AlignTests,
-  AlternativeTests,
-  CoflatMapTests,
-  MonadTests,
-  SerializableTests,
-  TraverseFilterTests,
-  TraverseTests
-}
+import cats.laws.discipline.{MonadTests, MonoidKTests, SerializableTests, TraverseFilterTests, TraverseTests}
 import cats.laws.discipline.arbitrary._
 
 import scala.collection.immutable.ArraySeq
@@ -22,24 +14,18 @@ class ArraySeqSuite extends CatsSuite {
   checkAll("ArraySeq[Int]", OrderTests[ArraySeq[Int]].order)
   checkAll("Order[ArraySeq]", SerializableTests.serializable(Order[ArraySeq[Int]]))
 
-  checkAll("ArraySeq[Int]", CoflatMapTests[ArraySeq].coflatMap[Int, Int, Int])
-  checkAll("CoflatMap[ArraySeq]", SerializableTests.serializable(CoflatMap[ArraySeq]))
+  checkAll("ArraySeq[Int]", MonadTests[ArraySeq].monad[Int, Int, Int])
+  checkAll("Monad[ArraySeq]", SerializableTests.serializable(Monad[ArraySeq]))
 
-  checkAll("ArraySeq[Int]", AlternativeTests[ArraySeq].alternative[Int, Int, Int])
-  checkAll("Alternative[ArraySeq]", SerializableTests.serializable(Alternative[ArraySeq]))
+  checkAll("ArraySeq[Int]", MonoidKTests[ArraySeq].monoidK[Int])
+  checkAll("MonoidK[ArraySeq]", SerializableTests.serializable(MonoidK[ArraySeq]))
 
   checkAll("ArraySeq[Int] with Option", TraverseTests[ArraySeq].traverse[Int, Int, Int, Set[Int], Option, Option])
   checkAll("Traverse[ArraySeq]", SerializableTests.serializable(Traverse[ArraySeq]))
 
-  checkAll("ArraySeq[Int]", MonadTests[ArraySeq].monad[Int, Int, Int])
-  checkAll("Monad[ArraySeq]", SerializableTests.serializable(Monad[ArraySeq]))
-
   checkAll("ArraySeq[Int]", TraverseFilterTests[ArraySeq].traverseFilter[Int, Int, Int])
   checkAll("TraverseFilter[ArraySeq]", SerializableTests.serializable(TraverseFilter[ArraySeq]))
 
-  checkAll("ArraySeq[Int]", AlignTests[ArraySeq].align[Int, Int, Int, Int])
-  checkAll("Align[ArraySeq]", SerializableTests.serializable(Align[ArraySeq]))
-
   {
     implicit val eqv: Eq[ListWrapper[Int]] = ListWrapper.eqv[Int]
     checkAll("ArraySeq[Int]", EqTests[ArraySeq[ListWrapper[Int]]].eqv)
