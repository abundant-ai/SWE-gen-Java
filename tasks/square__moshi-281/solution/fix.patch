diff --git a/kotlin/pom.xml b/kotlin/pom.xml
new file mode 100644
index 00000000..8c50a160
--- /dev/null
+++ b/kotlin/pom.xml
@@ -0,0 +1,89 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.moshi</groupId>
+    <artifactId>moshi-parent</artifactId>
+    <version>1.5.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>moshi-kotlin</artifactId>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.moshi</groupId>
+      <artifactId>moshi</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.assertj</groupId>
+      <artifactId>assertj-core</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-stdlib</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-reflect</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.jetbrains.kotlin</groupId>
+      <artifactId>kotlin-test</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-maven-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>compile</id>
+            <phase>compile</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+          <execution>
+            <id>test-compile</id>
+            <phase>test-compile</phase>
+            <goals>
+              <goal>test-compile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <executions>
+          <execution>
+            <id>compile</id>
+            <phase>compile</phase>
+            <goals>
+              <goal>compile</goal>
+            </goals>
+          </execution>
+          <execution>
+            <id>testCompile</id>
+            <phase>test-compile</phase>
+            <goals>
+              <goal>testCompile</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/kotlin/src/main/java/com/squareup/moshi/KotlinJsonAdapter.kt b/kotlin/src/main/java/com/squareup/moshi/KotlinJsonAdapter.kt
new file mode 100644
index 00000000..cc8792a3
--- /dev/null
+++ b/kotlin/src/main/java/com/squareup/moshi/KotlinJsonAdapter.kt
@@ -0,0 +1,203 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi
+
+import java.lang.reflect.Modifier
+import java.util.AbstractMap.SimpleEntry
+import kotlin.collections.Map.Entry
+import kotlin.reflect.KFunction
+import kotlin.reflect.KMutableProperty1
+import kotlin.reflect.KParameter
+import kotlin.reflect.KProperty1
+import kotlin.reflect.full.findAnnotation
+import kotlin.reflect.full.memberProperties
+import kotlin.reflect.full.primaryConstructor
+import kotlin.reflect.jvm.isAccessible
+import kotlin.reflect.jvm.javaField
+import kotlin.reflect.jvm.javaType
+
+/** Classes annotated with this are eligible for this adapter. */
+private val KOTLIN_METADATA = Class.forName("kotlin.Metadata") as Class<out Annotation>
+
+/**
+ * Placeholder value used when a field is absent from the JSON. Note that this code
+ * distinguishes between absent values and present-but-null values.
+ */
+private object ABSENT_VALUE
+
+/**
+ * This class encodes Kotlin classes using their properties. It decodes them by first invoking the
+ * constructor, and then by setting any additional properties that exist, if any.
+ */
+internal class KotlinJsonAdapter<T> private constructor(
+    val constructor: KFunction<T>,
+    val bindings: List<Binding<T, Any?>?>,
+    val options: JsonReader.Options) : JsonAdapter<T>() {
+
+  override fun fromJson(reader: JsonReader): T {
+    val constructorSize = constructor.parameters.size
+
+    // Read each value into its slot in the array.
+    val values = Array<Any?>(bindings.size) { ABSENT_VALUE }
+    reader.beginObject()
+    while (reader.hasNext()) {
+      val index = reader.selectName(options)
+      val binding = if (index != -1) bindings[index] else null
+
+      if (binding == null) {
+        reader.nextName()
+        reader.skipValue()
+        continue
+      }
+
+      if (values[index] !== ABSENT_VALUE) {
+        throw JsonDataException(
+            "Multiple values for ${constructor.parameters[index].name} at ${reader.path}")
+      }
+
+      values[index] = binding.adapter.fromJson(reader)
+    }
+    reader.endObject()
+
+    // Call the constructor using a Map so that absent optionals get defaults.
+    for (i in 0 until constructorSize) {
+      if (!constructor.parameters[i].isOptional && values[i] === ABSENT_VALUE) {
+        throw JsonDataException(
+            "Required value ${constructor.parameters[i].name} missing at ${reader.path}")
+      }
+    }
+    val result = constructor.callBy(IndexedParameterMap(constructor.parameters, values))
+
+    // Set remaining properties.
+    for (i in constructorSize until bindings.size) {
+      bindings[i]!!.set(result, values[i])
+    }
+
+    return result
+  }
+
+  override fun toJson(writer: JsonWriter, value: T) {
+    writer.beginObject()
+    for (binding in bindings) {
+      if (binding == null) continue // Skip constructor parameters that aren't properties.
+
+      writer.name(binding.name)
+      binding.adapter.toJson(writer, binding.get(value))
+    }
+    writer.endObject()
+  }
+
+  override fun toString() = "KotlinJsonAdapter(${constructor.returnType})"
+
+  data class Binding<K, P>(
+      val name: String,
+      val adapter: JsonAdapter<P>,
+      val property: KProperty1<K, P>,
+      val parameter: KParameter?) {
+    init {
+      if (property !is KMutableProperty1 && parameter == null) {
+        throw IllegalArgumentException("No constructor or var property for ${property.name}")
+      }
+    }
+
+    fun get(value: K) = property.get(value)
+
+    fun set(result: K, value: P) {
+      if (value !== ABSENT_VALUE) {
+        (property as KMutableProperty1<K, P>).set(result, value)
+      }
+    }
+  }
+
+  /** A simple [Map] that uses parameter indexes instead of sorting or hashing. */
+  class IndexedParameterMap(val parameterKeys: List<KParameter>, val parameterValues: Array<Any?>)
+    : AbstractMap<KParameter, Any?>() {
+
+    override val entries: Set<Entry<KParameter, Any?>>
+      get() {
+        val allPossibleEntries = parameterKeys.mapIndexed { index, value ->
+          SimpleEntry<KParameter, Any?>(value, parameterValues[index])
+        }
+        return allPossibleEntries.filterTo(LinkedHashSet<Entry<KParameter, Any?>>()) {
+          it.value !== ABSENT_VALUE
+        }
+      }
+
+    override fun containsKey(key: KParameter) = parameterValues[key.index] !== ABSENT_VALUE
+
+    override fun get(key: KParameter): Any? {
+      val value = parameterValues[key.index]
+      return if (value !== ABSENT_VALUE) value else null
+    }
+  }
+
+  companion object {
+    @JvmField val FACTORY = Factory { type, annotations, moshi ->
+      if (!annotations.isEmpty()) return@Factory null
+
+      val rawType = Types.getRawType(type)
+      val platformType = ClassJsonAdapter.isPlatformType(rawType)
+      if (platformType) return@Factory null
+
+      if (!rawType.isAnnotationPresent(KOTLIN_METADATA)) return@Factory null
+
+      val constructor = rawType.kotlin.primaryConstructor ?: return@Factory null
+      val parametersByName = constructor.parameters.associateBy { it.name }
+      constructor.isAccessible = true
+
+      val bindingsByName = LinkedHashMap<String, Binding<Any, Any?>>()
+
+      for (property in rawType.kotlin.memberProperties) {
+        if (Modifier.isTransient(property.javaField?.modifiers ?: 0)) continue
+
+        property.isAccessible = true
+        var allAnnotations = property.annotations
+        var jsonAnnotation = property.findAnnotation<Json>()
+
+        val parameter = parametersByName[property.name]
+        if (parameter != null) {
+          allAnnotations += parameter.annotations
+          if (jsonAnnotation == null) {
+            jsonAnnotation = parameter.findAnnotation<Json>()
+          }
+        }
+
+        val name = jsonAnnotation?.name ?: property.name
+        val adapter = moshi.adapter<Any>(
+            property.returnType.javaType, Util.jsonAnnotations(allAnnotations.toTypedArray()))
+
+        bindingsByName[property.name] =
+            Binding(name, adapter, property as KProperty1<Any, Any?>, parameter)
+      }
+
+      val bindings = ArrayList<Binding<Any, Any?>?>()
+
+      for (parameter in constructor.parameters) {
+        val binding = bindingsByName.remove(parameter.name)
+        if (binding == null && !parameter.isOptional) {
+          throw IllegalArgumentException(
+              "No property for required constructor parameter ${parameter.name}")
+        }
+        bindings += binding
+      }
+
+      bindings += bindingsByName.values
+
+      val options = JsonReader.Options.of(*bindings.map { it?.name ?: "\u0000" }.toTypedArray())
+      KotlinJsonAdapter(constructor, bindings, options)
+    }
+  }
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
index 377efa99..e364bb60 100644
--- a/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/ClassJsonAdapter.java
@@ -105,19 +105,6 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
       }
     }
 
-    /**
-     * Returns true if {@code rawType} is built in. We don't reflect on private fields of platform
-     * types because they're unspecified and likely to be different on Java vs. Android.
-     */
-    private boolean isPlatformType(Class<?> rawType) {
-      String name = rawType.getName();
-      return name.startsWith("android.")
-          || name.startsWith("java.")
-          || name.startsWith("javax.")
-          || name.startsWith("kotlin.")
-          || name.startsWith("scala.");
-    }
-
     /** Returns true if fields with {@code modifiers} are included in the emitted JSON. */
     private boolean includeField(boolean platformType, int modifiers) {
       if (Modifier.isStatic(modifiers) || Modifier.isTransient(modifiers)) return false;
@@ -125,6 +112,19 @@ final class ClassJsonAdapter<T> extends JsonAdapter<T> {
     }
   };
 
+  /**
+   * Returns true if {@code rawType} is built in. We don't reflect on private fields of platform
+   * types because they're unspecified and likely to be different on Java vs. Android.
+   */
+  static boolean isPlatformType(Class<?> rawType) {
+    String name = rawType.getName();
+    return name.startsWith("android.")
+        || name.startsWith("java.")
+        || name.startsWith("javax.")
+        || name.startsWith("kotlin.")
+        || name.startsWith("scala.");
+  }
+
   private final ClassFactory<T> classFactory;
   private final FieldBinding<?>[] fieldsArray;
   private final JsonReader.Options options;
diff --git a/moshi/src/main/java/com/squareup/moshi/Json.java b/moshi/src/main/java/com/squareup/moshi/Json.java
index 908fa459..0da3be92 100644
--- a/moshi/src/main/java/com/squareup/moshi/Json.java
+++ b/moshi/src/main/java/com/squareup/moshi/Json.java
@@ -19,12 +19,23 @@ import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
-import static java.lang.annotation.ElementType.FIELD;
-import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-/** Customizes how a field is encoded as JSON. */
-@Target({FIELD, METHOD})
+/**
+ * Customizes how a field is encoded as JSON.
+ *
+ * <p>Although this annotation doesn't declare a {@link Target}, it is only honored in the following
+ * elements:
+ *
+ * <ul>
+ *   <li><strong>Java class fields</strong>
+ *   <li><strong>Kotlin properties</strong> for use with {@code moshi-kotlin}. This includes both
+ *       properties declared in the constructor and properties declared as members.
+ * </ul>
+ *
+ * <p>Users of the <a href="https://github.com/rharter/auto-value-moshi">AutoValue: Moshi
+ * Extension</a> may also use this annotation on abstract getters.
+ */
 @Retention(RUNTIME)
 @Documented
 public @interface Json {
diff --git a/pom.xml b/pom.xml
index 09016e41..3f7af26d 100644
--- a/pom.xml
+++ b/pom.xml
@@ -21,14 +21,16 @@
     <module>moshi</module>
     <module>examples</module>
     <module>adapters</module>
+    <module>kotlin</module>
   </modules>
 
   <properties>
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
     <java.version>1.7</java.version>
+    <kotlin.version>1.1.1</kotlin.version>
 
     <!-- Dependencies -->
-    <okio.version>1.11.0</okio.version>
+    <okio.version>1.12.0</okio.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -71,6 +73,22 @@
         <artifactId>assertj-core</artifactId>
         <version>${assertj.version}</version>
       </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-stdlib</artifactId>
+        <version>${kotlin.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-reflect</artifactId>
+        <version>${kotlin.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.jetbrains.kotlin</groupId>
+        <artifactId>kotlin-test</artifactId>
+        <version>${kotlin.version}</version>
+        <scope>test</scope>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -100,6 +118,11 @@
             </dependency>
           </dependencies>
         </plugin>
+        <plugin>
+          <groupId>org.jetbrains.kotlin</groupId>
+          <artifactId>kotlin-maven-plugin</artifactId>
+          <version>${kotlin.version}</version>
+        </plugin>
       </plugins>
     </pluginManagement>
 
