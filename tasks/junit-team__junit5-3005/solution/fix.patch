diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
index 8827a8633..8457ce84a 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
@@ -40,6 +40,8 @@ on GitHub.
   references a factory method whose name is the same as other non-factory methods in the
   same class no longer fails with an exception stating that multiple factory methods with
   the same name were found.
+* Assertion failures thrown from methods with applied timeouts using `ThreadMode.SEPARATE`
+  are now properly reported.
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java
index 81268f7ea..93c7c11f8 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java
@@ -11,23 +11,13 @@
 package org.junit.jupiter.api;
 
 import static org.junit.jupiter.api.AssertionFailureBuilder.assertionFailure;
+import static org.junit.platform.commons.util.ExceptionUtils.throwAsUncheckedException;
 
 import java.time.Duration;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Supplier;
 
 import org.junit.jupiter.api.function.Executable;
 import org.junit.jupiter.api.function.ThrowingSupplier;
-import org.junit.platform.commons.JUnitException;
-import org.junit.platform.commons.util.ExceptionUtils;
 
 /**
  * {@code AssertTimeout} is a collection of utility methods that support asserting
@@ -79,7 +69,7 @@ class AssertTimeout {
 			result = supplier.get();
 		}
 		catch (Throwable ex) {
-			ExceptionUtils.throwAsUncheckedException(ex);
+			throwAsUncheckedException(ex);
 		}
 
 		long timeElapsed = System.currentTimeMillis() - start;
@@ -93,105 +83,4 @@ class AssertTimeout {
 		return result;
 	}
 
-	static void assertTimeoutPreemptively(Duration timeout, Executable executable) {
-		assertTimeoutPreemptively(timeout, executable, (String) null);
-	}
-
-	static void assertTimeoutPreemptively(Duration timeout, Executable executable, String message) {
-		assertTimeoutPreemptively(timeout, () -> {
-			executable.execute();
-			return null;
-		}, message);
-	}
-
-	static void assertTimeoutPreemptively(Duration timeout, Executable executable, Supplier<String> messageSupplier) {
-		assertTimeoutPreemptively(timeout, () -> {
-			executable.execute();
-			return null;
-		}, messageSupplier);
-	}
-
-	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier) {
-		return assertTimeoutPreemptively(timeout, supplier, (Object) null);
-	}
-
-	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier, String message) {
-		return assertTimeoutPreemptively(timeout, supplier, (Object) message);
-	}
-
-	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
-			Supplier<String> messageSupplier) {
-
-		return assertTimeoutPreemptively(timeout, supplier, (Object) messageSupplier);
-	}
-
-	private static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
-			Object messageOrSupplier) {
-
-		AtomicReference<Thread> threadReference = new AtomicReference<>();
-		ExecutorService executorService = Executors.newSingleThreadExecutor(new TimeoutThreadFactory());
-
-		try {
-			Future<T> future = executorService.submit(() -> {
-				try {
-					threadReference.set(Thread.currentThread());
-					return supplier.get();
-				}
-				catch (Throwable throwable) {
-					throw ExceptionUtils.throwAsUncheckedException(throwable);
-				}
-			});
-
-			long timeoutInMillis = timeout.toMillis();
-			try {
-				return future.get(timeoutInMillis, TimeUnit.MILLISECONDS);
-			}
-			catch (TimeoutException ex) {
-				AssertionFailureBuilder failure = assertionFailure() //
-						.message(messageOrSupplier) //
-						.reason("execution timed out after " + timeoutInMillis + " ms");
-
-				Thread thread = threadReference.get();
-				if (thread != null) {
-					ExecutionTimeoutException exception = new ExecutionTimeoutException(
-						"Execution timed out in thread " + thread.getName());
-					exception.setStackTrace(thread.getStackTrace());
-					failure.cause(exception);
-				}
-				throw failure.build();
-			}
-			catch (ExecutionException ex) {
-				throw ExceptionUtils.throwAsUncheckedException(ex.getCause());
-			}
-			catch (Throwable ex) {
-				throw ExceptionUtils.throwAsUncheckedException(ex);
-			}
-		}
-		finally {
-			executorService.shutdownNow();
-		}
-	}
-
-	private static class ExecutionTimeoutException extends JUnitException {
-
-		private static final long serialVersionUID = 1L;
-
-		ExecutionTimeoutException(String message) {
-			super(message);
-		}
-	}
-
-	/**
-	 * The thread factory used for preemptive timeout.
-	 *
-	 * The factory creates threads with meaningful names, helpful for debugging purposes.
-	 */
-	private static class TimeoutThreadFactory implements ThreadFactory {
-		private static final AtomicInteger threadNumber = new AtomicInteger(1);
-
-		public Thread newThread(Runnable r) {
-			return new Thread(r, "junit-timeout-thread-" + threadNumber.getAndIncrement());
-		}
-	}
-
 }
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeoutPreemptively.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeoutPreemptively.java
new file mode 100644
index 000000000..94534171d
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeoutPreemptively.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api;
+
+import static org.junit.jupiter.api.AssertionFailureBuilder.assertionFailure;
+import static org.junit.platform.commons.util.ExceptionUtils.throwAsUncheckedException;
+
+import java.time.Duration;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Supplier;
+
+import org.junit.jupiter.api.function.Executable;
+import org.junit.jupiter.api.function.ThrowingSupplier;
+import org.junit.platform.commons.JUnitException;
+import org.opentest4j.AssertionFailedError;
+
+/**
+ * {@code AssertTimeout} is a collection of utility methods that support asserting
+ * the execution of the code under test did not take longer than the timeout duration
+ * using a preemptive approach.
+ *
+ * @since 5.9.1
+ */
+class AssertTimeoutPreemptively {
+
+	static void assertTimeoutPreemptively(Duration timeout, Executable executable) {
+		assertTimeoutPreemptively(timeout, executable, (String) null);
+	}
+
+	static void assertTimeoutPreemptively(Duration timeout, Executable executable, String message) {
+		assertTimeoutPreemptively(timeout, () -> {
+			executable.execute();
+			return null;
+		}, message);
+	}
+
+	static void assertTimeoutPreemptively(Duration timeout, Executable executable, Supplier<String> messageSupplier) {
+		assertTimeoutPreemptively(timeout, () -> {
+			executable.execute();
+			return null;
+		}, messageSupplier);
+	}
+
+	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier) {
+		return assertTimeoutPreemptively(timeout, supplier, null, AssertTimeoutPreemptively::createAssertionFailure);
+	}
+
+	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier, String message) {
+		return assertTimeoutPreemptively(timeout, supplier, message == null ? null : () -> message,
+			AssertTimeoutPreemptively::createAssertionFailure);
+	}
+
+	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
+			Supplier<String> messageSupplier) {
+		return assertTimeoutPreemptively(timeout, supplier, messageSupplier,
+			AssertTimeoutPreemptively::createAssertionFailure);
+	}
+
+	static <T, E extends Throwable> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
+			Supplier<String> messageSupplier, Assertions.TimeoutFailureFactory<E> failureFactory) throws E {
+		AtomicReference<Thread> threadReference = new AtomicReference<>();
+		ExecutorService executorService = Executors.newSingleThreadExecutor(new TimeoutThreadFactory());
+
+		try {
+			Future<T> future = submitTask(supplier, threadReference, executorService);
+			return resolveFutureAndHandleException(future, timeout, messageSupplier, threadReference::get,
+				failureFactory);
+		}
+		finally {
+			executorService.shutdownNow();
+		}
+	}
+
+	private static <T> Future<T> submitTask(ThrowingSupplier<T> supplier, AtomicReference<Thread> threadReference,
+			ExecutorService executorService) {
+		return executorService.submit(() -> {
+			try {
+				threadReference.set(Thread.currentThread());
+				return supplier.get();
+			}
+			catch (Throwable throwable) {
+				throw throwAsUncheckedException(throwable);
+			}
+		});
+	}
+
+	private static <T, E extends Throwable> T resolveFutureAndHandleException(Future<T> future, Duration timeout,
+			Supplier<String> messageSupplier, Supplier<Thread> threadSupplier,
+			Assertions.TimeoutFailureFactory<E> failureFactory) throws E {
+		try {
+			return future.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
+		}
+		catch (TimeoutException ex) {
+			Thread thread = threadSupplier.get();
+			ExecutionTimeoutException cause = null;
+			if (thread != null) {
+				cause = new ExecutionTimeoutException("Execution timed out in thread " + thread.getName());
+				cause.setStackTrace(thread.getStackTrace());
+			}
+			throw failureFactory.createTimeoutFailure(timeout, messageSupplier, cause);
+		}
+		catch (ExecutionException ex) {
+			throw throwAsUncheckedException(ex.getCause());
+		}
+		catch (Throwable ex) {
+			throw throwAsUncheckedException(ex);
+		}
+	}
+
+	private static AssertionFailedError createAssertionFailure(Duration timeout, Supplier<String> messageSupplier,
+			Throwable cause) {
+		return assertionFailure() //
+				.message(messageSupplier) //
+				.reason("execution timed out after " + timeout.toMillis() + " ms") //
+				.cause(cause) //
+				.build();
+	}
+
+	private static class ExecutionTimeoutException extends JUnitException {
+
+		private static final long serialVersionUID = 1L;
+
+		ExecutionTimeoutException(String message) {
+			super(message);
+		}
+	}
+
+	/**
+	 * The thread factory used for preemptive timeout.
+	 * <p>
+	 * The factory creates threads with meaningful names, helpful for debugging purposes.
+	 */
+	private static class TimeoutThreadFactory implements ThreadFactory {
+		private static final AtomicInteger threadNumber = new AtomicInteger(1);
+
+		public Thread newThread(Runnable r) {
+			return new Thread(r, "junit-timeout-thread-" + threadNumber.getAndIncrement());
+		}
+	}
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java
index fa6585771..62fefbe63 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java
@@ -11,6 +11,7 @@
 package org.junit.jupiter.api;
 
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import java.time.Duration;
@@ -3395,7 +3396,7 @@ public class Assertions {
 	 * @see #assertTimeout(Duration, Executable)
 	 */
 	public static void assertTimeoutPreemptively(Duration timeout, Executable executable) {
-		AssertTimeout.assertTimeoutPreemptively(timeout, executable);
+		AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable);
 	}
 
 	/**
@@ -3418,7 +3419,7 @@ public class Assertions {
 	 * @see #assertTimeout(Duration, Executable, String)
 	 */
 	public static void assertTimeoutPreemptively(Duration timeout, Executable executable, String message) {
-		AssertTimeout.assertTimeoutPreemptively(timeout, executable, message);
+		AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable, message);
 	}
 
 	/**
@@ -3443,7 +3444,7 @@ public class Assertions {
 	 */
 	public static void assertTimeoutPreemptively(Duration timeout, Executable executable,
 			Supplier<String> messageSupplier) {
-		AssertTimeout.assertTimeoutPreemptively(timeout, executable, messageSupplier);
+		AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable, messageSupplier);
 	}
 
 	// --- supplier - preemptively ---
@@ -3468,7 +3469,7 @@ public class Assertions {
 	 * @see #assertTimeout(Duration, Executable)
 	 */
 	public static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier) {
-		return AssertTimeout.assertTimeoutPreemptively(timeout, supplier);
+		return AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier);
 	}
 
 	/**
@@ -3493,7 +3494,7 @@ public class Assertions {
 	 * @see #assertTimeout(Duration, Executable, String)
 	 */
 	public static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier, String message) {
-		return AssertTimeout.assertTimeoutPreemptively(timeout, supplier, message);
+		return AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier, message);
 	}
 
 	/**
@@ -3520,7 +3521,39 @@ public class Assertions {
 	 */
 	public static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
 			Supplier<String> messageSupplier) {
-		return AssertTimeout.assertTimeoutPreemptively(timeout, supplier, messageSupplier);
+		return AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier, messageSupplier);
+	}
+
+	/**
+	 * <em>Assert</em> that execution of the supplied {@code supplier}
+	 * completes before the given {@code timeout} is exceeded.
+	 *
+	 * <p>If the assertion passes then the {@code supplier}'s result is returned.
+	 *
+	 * <p>In the case the assertion does not pass, the supplied
+	 * {@link TimeoutFailureFactory} is invoked to create an exception which is
+	 * then thrown.
+	 *
+	 * <p>Note: the {@code supplier} will be executed in a different thread than
+	 * that of the calling code. Furthermore, execution of the {@code supplier} will
+	 * be preemptively aborted if the timeout is exceeded. See the
+	 * {@linkplain Assertions Preemptive Timeouts} section of the class-level
+	 * Javadoc for a discussion of possible undesirable side effects.
+	 *
+	 * <p>If necessary, the failure message will be retrieved lazily from the
+	 * supplied {@code messageSupplier}.
+	 *
+	 * @see #assertTimeoutPreemptively(Duration, Executable)
+	 * @see #assertTimeoutPreemptively(Duration, Executable, String)
+	 * @see #assertTimeoutPreemptively(Duration, Executable, Supplier)
+	 * @see #assertTimeoutPreemptively(Duration, ThrowingSupplier)
+	 * @see #assertTimeoutPreemptively(Duration, ThrowingSupplier, String)
+	 * @see #assertTimeout(Duration, Executable, Supplier)
+	 */
+	@API(status = INTERNAL, since = "5.9.1")
+	public static <T, E extends Throwable> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
+			Supplier<String> messageSupplier, TimeoutFailureFactory<E> failureFactory) throws E {
+		return AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier, messageSupplier, failureFactory);
 	}
 
 	// --- assertInstanceOf ----------------------------------------------------
@@ -3572,4 +3605,21 @@ public class Assertions {
 		return AssertInstanceOf.assertInstanceOf(expectedType, actualValue, messageSupplier);
 	}
 
+	/**
+	 * Factory for timeout failures.
+	 *
+	 * @param <T> The type of error or exception created
+	 * @since 5.9.1
+	 * @see Assertions#assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier, TimeoutFailureFactory)
+	 */
+	@API(status = INTERNAL, since = "5.9.1")
+	public interface TimeoutFailureFactory<T extends Throwable> {
+
+		/**
+		 * Create a failure for the given timeout, message, and cause.
+		 *
+		 * @return timeout failure; never {@code null}
+		 */
+		T createTimeoutFailure(Duration timeout, Supplier<String> messageSupplier, Throwable cause);
+	}
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java
index 1860f4134..16f22d1b0 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java
@@ -16,7 +16,6 @@ import java.util.concurrent.TimeoutException;
 import java.util.function.Supplier;
 
 import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
-import org.opentest4j.AssertionFailedError;
 
 /**
  * @since 5.9
@@ -36,13 +35,11 @@ class SeparateThreadTimeoutInvocation<T> implements Invocation<T> {
 
 	@Override
 	public T proceed() throws Throwable {
-		try {
-			return assertTimeoutPreemptively(timeout.toDuration(), delegate::proceed, descriptionSupplier);
-		}
-		catch (AssertionFailedError failure) {
-			TimeoutException exception = TimeoutExceptionFactory.create(descriptionSupplier.get(), timeout, null);
-			exception.initCause(failure.getCause());
-			throw exception;
-		}
+		return assertTimeoutPreemptively(timeout.toDuration(), delegate::proceed, descriptionSupplier,
+			(__, messageSupplier, cause) -> {
+				TimeoutException exception = TimeoutExceptionFactory.create(messageSupplier.get(), timeout, null);
+				exception.initCause(cause);
+				return exception;
+			});
 	}
 }
