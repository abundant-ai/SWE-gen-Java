diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
index 8457ce84a..8827a8633 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
@@ -40,8 +40,6 @@ on GitHub.
   references a factory method whose name is the same as other non-factory methods in the
   same class no longer fails with an exception stating that multiple factory methods with
   the same name were found.
-* Assertion failures thrown from methods with applied timeouts using `ThreadMode.SEPARATE`
-  are now properly reported.
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java
index 93c7c11f8..81268f7ea 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeout.java
@@ -11,13 +11,23 @@
 package org.junit.jupiter.api;
 
 import static org.junit.jupiter.api.AssertionFailureBuilder.assertionFailure;
-import static org.junit.platform.commons.util.ExceptionUtils.throwAsUncheckedException;
 
 import java.time.Duration;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Supplier;
 
 import org.junit.jupiter.api.function.Executable;
 import org.junit.jupiter.api.function.ThrowingSupplier;
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.util.ExceptionUtils;
 
 /**
  * {@code AssertTimeout} is a collection of utility methods that support asserting
@@ -69,7 +79,7 @@ class AssertTimeout {
 			result = supplier.get();
 		}
 		catch (Throwable ex) {
-			throwAsUncheckedException(ex);
+			ExceptionUtils.throwAsUncheckedException(ex);
 		}
 
 		long timeElapsed = System.currentTimeMillis() - start;
@@ -83,4 +93,105 @@ class AssertTimeout {
 		return result;
 	}
 
+	static void assertTimeoutPreemptively(Duration timeout, Executable executable) {
+		assertTimeoutPreemptively(timeout, executable, (String) null);
+	}
+
+	static void assertTimeoutPreemptively(Duration timeout, Executable executable, String message) {
+		assertTimeoutPreemptively(timeout, () -> {
+			executable.execute();
+			return null;
+		}, message);
+	}
+
+	static void assertTimeoutPreemptively(Duration timeout, Executable executable, Supplier<String> messageSupplier) {
+		assertTimeoutPreemptively(timeout, () -> {
+			executable.execute();
+			return null;
+		}, messageSupplier);
+	}
+
+	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier) {
+		return assertTimeoutPreemptively(timeout, supplier, (Object) null);
+	}
+
+	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier, String message) {
+		return assertTimeoutPreemptively(timeout, supplier, (Object) message);
+	}
+
+	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
+			Supplier<String> messageSupplier) {
+
+		return assertTimeoutPreemptively(timeout, supplier, (Object) messageSupplier);
+	}
+
+	private static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
+			Object messageOrSupplier) {
+
+		AtomicReference<Thread> threadReference = new AtomicReference<>();
+		ExecutorService executorService = Executors.newSingleThreadExecutor(new TimeoutThreadFactory());
+
+		try {
+			Future<T> future = executorService.submit(() -> {
+				try {
+					threadReference.set(Thread.currentThread());
+					return supplier.get();
+				}
+				catch (Throwable throwable) {
+					throw ExceptionUtils.throwAsUncheckedException(throwable);
+				}
+			});
+
+			long timeoutInMillis = timeout.toMillis();
+			try {
+				return future.get(timeoutInMillis, TimeUnit.MILLISECONDS);
+			}
+			catch (TimeoutException ex) {
+				AssertionFailureBuilder failure = assertionFailure() //
+						.message(messageOrSupplier) //
+						.reason("execution timed out after " + timeoutInMillis + " ms");
+
+				Thread thread = threadReference.get();
+				if (thread != null) {
+					ExecutionTimeoutException exception = new ExecutionTimeoutException(
+						"Execution timed out in thread " + thread.getName());
+					exception.setStackTrace(thread.getStackTrace());
+					failure.cause(exception);
+				}
+				throw failure.build();
+			}
+			catch (ExecutionException ex) {
+				throw ExceptionUtils.throwAsUncheckedException(ex.getCause());
+			}
+			catch (Throwable ex) {
+				throw ExceptionUtils.throwAsUncheckedException(ex);
+			}
+		}
+		finally {
+			executorService.shutdownNow();
+		}
+	}
+
+	private static class ExecutionTimeoutException extends JUnitException {
+
+		private static final long serialVersionUID = 1L;
+
+		ExecutionTimeoutException(String message) {
+			super(message);
+		}
+	}
+
+	/**
+	 * The thread factory used for preemptive timeout.
+	 *
+	 * The factory creates threads with meaningful names, helpful for debugging purposes.
+	 */
+	private static class TimeoutThreadFactory implements ThreadFactory {
+		private static final AtomicInteger threadNumber = new AtomicInteger(1);
+
+		public Thread newThread(Runnable r) {
+			return new Thread(r, "junit-timeout-thread-" + threadNumber.getAndIncrement());
+		}
+	}
+
 }
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeoutPreemptively.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeoutPreemptively.java
deleted file mode 100644
index 94534171d..000000000
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AssertTimeoutPreemptively.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright 2015-2022 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.api;
-
-import static org.junit.jupiter.api.AssertionFailureBuilder.assertionFailure;
-import static org.junit.platform.commons.util.ExceptionUtils.throwAsUncheckedException;
-
-import java.time.Duration;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.function.Supplier;
-
-import org.junit.jupiter.api.function.Executable;
-import org.junit.jupiter.api.function.ThrowingSupplier;
-import org.junit.platform.commons.JUnitException;
-import org.opentest4j.AssertionFailedError;
-
-/**
- * {@code AssertTimeout} is a collection of utility methods that support asserting
- * the execution of the code under test did not take longer than the timeout duration
- * using a preemptive approach.
- *
- * @since 5.9.1
- */
-class AssertTimeoutPreemptively {
-
-	static void assertTimeoutPreemptively(Duration timeout, Executable executable) {
-		assertTimeoutPreemptively(timeout, executable, (String) null);
-	}
-
-	static void assertTimeoutPreemptively(Duration timeout, Executable executable, String message) {
-		assertTimeoutPreemptively(timeout, () -> {
-			executable.execute();
-			return null;
-		}, message);
-	}
-
-	static void assertTimeoutPreemptively(Duration timeout, Executable executable, Supplier<String> messageSupplier) {
-		assertTimeoutPreemptively(timeout, () -> {
-			executable.execute();
-			return null;
-		}, messageSupplier);
-	}
-
-	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier) {
-		return assertTimeoutPreemptively(timeout, supplier, null, AssertTimeoutPreemptively::createAssertionFailure);
-	}
-
-	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier, String message) {
-		return assertTimeoutPreemptively(timeout, supplier, message == null ? null : () -> message,
-			AssertTimeoutPreemptively::createAssertionFailure);
-	}
-
-	static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
-			Supplier<String> messageSupplier) {
-		return assertTimeoutPreemptively(timeout, supplier, messageSupplier,
-			AssertTimeoutPreemptively::createAssertionFailure);
-	}
-
-	static <T, E extends Throwable> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
-			Supplier<String> messageSupplier, Assertions.TimeoutFailureFactory<E> failureFactory) throws E {
-		AtomicReference<Thread> threadReference = new AtomicReference<>();
-		ExecutorService executorService = Executors.newSingleThreadExecutor(new TimeoutThreadFactory());
-
-		try {
-			Future<T> future = submitTask(supplier, threadReference, executorService);
-			return resolveFutureAndHandleException(future, timeout, messageSupplier, threadReference::get,
-				failureFactory);
-		}
-		finally {
-			executorService.shutdownNow();
-		}
-	}
-
-	private static <T> Future<T> submitTask(ThrowingSupplier<T> supplier, AtomicReference<Thread> threadReference,
-			ExecutorService executorService) {
-		return executorService.submit(() -> {
-			try {
-				threadReference.set(Thread.currentThread());
-				return supplier.get();
-			}
-			catch (Throwable throwable) {
-				throw throwAsUncheckedException(throwable);
-			}
-		});
-	}
-
-	private static <T, E extends Throwable> T resolveFutureAndHandleException(Future<T> future, Duration timeout,
-			Supplier<String> messageSupplier, Supplier<Thread> threadSupplier,
-			Assertions.TimeoutFailureFactory<E> failureFactory) throws E {
-		try {
-			return future.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
-		}
-		catch (TimeoutException ex) {
-			Thread thread = threadSupplier.get();
-			ExecutionTimeoutException cause = null;
-			if (thread != null) {
-				cause = new ExecutionTimeoutException("Execution timed out in thread " + thread.getName());
-				cause.setStackTrace(thread.getStackTrace());
-			}
-			throw failureFactory.createTimeoutFailure(timeout, messageSupplier, cause);
-		}
-		catch (ExecutionException ex) {
-			throw throwAsUncheckedException(ex.getCause());
-		}
-		catch (Throwable ex) {
-			throw throwAsUncheckedException(ex);
-		}
-	}
-
-	private static AssertionFailedError createAssertionFailure(Duration timeout, Supplier<String> messageSupplier,
-			Throwable cause) {
-		return assertionFailure() //
-				.message(messageSupplier) //
-				.reason("execution timed out after " + timeout.toMillis() + " ms") //
-				.cause(cause) //
-				.build();
-	}
-
-	private static class ExecutionTimeoutException extends JUnitException {
-
-		private static final long serialVersionUID = 1L;
-
-		ExecutionTimeoutException(String message) {
-			super(message);
-		}
-	}
-
-	/**
-	 * The thread factory used for preemptive timeout.
-	 * <p>
-	 * The factory creates threads with meaningful names, helpful for debugging purposes.
-	 */
-	private static class TimeoutThreadFactory implements ThreadFactory {
-		private static final AtomicInteger threadNumber = new AtomicInteger(1);
-
-		public Thread newThread(Runnable r) {
-			return new Thread(r, "junit-timeout-thread-" + threadNumber.getAndIncrement());
-		}
-	}
-}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java
index 62fefbe63..fa6585771 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Assertions.java
@@ -11,7 +11,6 @@
 package org.junit.jupiter.api;
 
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
-import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import java.time.Duration;
@@ -3396,7 +3395,7 @@ public class Assertions {
 	 * @see #assertTimeout(Duration, Executable)
 	 */
 	public static void assertTimeoutPreemptively(Duration timeout, Executable executable) {
-		AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable);
+		AssertTimeout.assertTimeoutPreemptively(timeout, executable);
 	}
 
 	/**
@@ -3419,7 +3418,7 @@ public class Assertions {
 	 * @see #assertTimeout(Duration, Executable, String)
 	 */
 	public static void assertTimeoutPreemptively(Duration timeout, Executable executable, String message) {
-		AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable, message);
+		AssertTimeout.assertTimeoutPreemptively(timeout, executable, message);
 	}
 
 	/**
@@ -3444,7 +3443,7 @@ public class Assertions {
 	 */
 	public static void assertTimeoutPreemptively(Duration timeout, Executable executable,
 			Supplier<String> messageSupplier) {
-		AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, executable, messageSupplier);
+		AssertTimeout.assertTimeoutPreemptively(timeout, executable, messageSupplier);
 	}
 
 	// --- supplier - preemptively ---
@@ -3469,7 +3468,7 @@ public class Assertions {
 	 * @see #assertTimeout(Duration, Executable)
 	 */
 	public static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier) {
-		return AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier);
+		return AssertTimeout.assertTimeoutPreemptively(timeout, supplier);
 	}
 
 	/**
@@ -3494,7 +3493,7 @@ public class Assertions {
 	 * @see #assertTimeout(Duration, Executable, String)
 	 */
 	public static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier, String message) {
-		return AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier, message);
+		return AssertTimeout.assertTimeoutPreemptively(timeout, supplier, message);
 	}
 
 	/**
@@ -3521,39 +3520,7 @@ public class Assertions {
 	 */
 	public static <T> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
 			Supplier<String> messageSupplier) {
-		return AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier, messageSupplier);
-	}
-
-	/**
-	 * <em>Assert</em> that execution of the supplied {@code supplier}
-	 * completes before the given {@code timeout} is exceeded.
-	 *
-	 * <p>If the assertion passes then the {@code supplier}'s result is returned.
-	 *
-	 * <p>In the case the assertion does not pass, the supplied
-	 * {@link TimeoutFailureFactory} is invoked to create an exception which is
-	 * then thrown.
-	 *
-	 * <p>Note: the {@code supplier} will be executed in a different thread than
-	 * that of the calling code. Furthermore, execution of the {@code supplier} will
-	 * be preemptively aborted if the timeout is exceeded. See the
-	 * {@linkplain Assertions Preemptive Timeouts} section of the class-level
-	 * Javadoc for a discussion of possible undesirable side effects.
-	 *
-	 * <p>If necessary, the failure message will be retrieved lazily from the
-	 * supplied {@code messageSupplier}.
-	 *
-	 * @see #assertTimeoutPreemptively(Duration, Executable)
-	 * @see #assertTimeoutPreemptively(Duration, Executable, String)
-	 * @see #assertTimeoutPreemptively(Duration, Executable, Supplier)
-	 * @see #assertTimeoutPreemptively(Duration, ThrowingSupplier)
-	 * @see #assertTimeoutPreemptively(Duration, ThrowingSupplier, String)
-	 * @see #assertTimeout(Duration, Executable, Supplier)
-	 */
-	@API(status = INTERNAL, since = "5.9.1")
-	public static <T, E extends Throwable> T assertTimeoutPreemptively(Duration timeout, ThrowingSupplier<T> supplier,
-			Supplier<String> messageSupplier, TimeoutFailureFactory<E> failureFactory) throws E {
-		return AssertTimeoutPreemptively.assertTimeoutPreemptively(timeout, supplier, messageSupplier, failureFactory);
+		return AssertTimeout.assertTimeoutPreemptively(timeout, supplier, messageSupplier);
 	}
 
 	// --- assertInstanceOf ----------------------------------------------------
@@ -3605,21 +3572,4 @@ public class Assertions {
 		return AssertInstanceOf.assertInstanceOf(expectedType, actualValue, messageSupplier);
 	}
 
-	/**
-	 * Factory for timeout failures.
-	 *
-	 * @param <T> The type of error or exception created
-	 * @since 5.9.1
-	 * @see Assertions#assertTimeoutPreemptively(Duration, ThrowingSupplier, Supplier, TimeoutFailureFactory)
-	 */
-	@API(status = INTERNAL, since = "5.9.1")
-	public interface TimeoutFailureFactory<T extends Throwable> {
-
-		/**
-		 * Create a failure for the given timeout, message, and cause.
-		 *
-		 * @return timeout failure; never {@code null}
-		 */
-		T createTimeoutFailure(Duration timeout, Supplier<String> messageSupplier, Throwable cause);
-	}
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java
index 16f22d1b0..1860f4134 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/SeparateThreadTimeoutInvocation.java
@@ -16,6 +16,7 @@ import java.util.concurrent.TimeoutException;
 import java.util.function.Supplier;
 
 import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
+import org.opentest4j.AssertionFailedError;
 
 /**
  * @since 5.9
@@ -35,11 +36,13 @@ class SeparateThreadTimeoutInvocation<T> implements Invocation<T> {
 
 	@Override
 	public T proceed() throws Throwable {
-		return assertTimeoutPreemptively(timeout.toDuration(), delegate::proceed, descriptionSupplier,
-			(__, messageSupplier, cause) -> {
-				TimeoutException exception = TimeoutExceptionFactory.create(messageSupplier.get(), timeout, null);
-				exception.initCause(cause);
-				return exception;
-			});
+		try {
+			return assertTimeoutPreemptively(timeout.toDuration(), delegate::proceed, descriptionSupplier);
+		}
+		catch (AssertionFailedError failure) {
+			TimeoutException exception = TimeoutExceptionFactory.create(descriptionSupplier.get(), timeout, null);
+			exception.initCause(failure.getCause());
+			throw exception;
+		}
 	}
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/AssertTimeoutAssertionsTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/AssertTimeoutAssertionsTests.java
index 0dfd4e7d6..424317ed6 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/AssertTimeoutAssertionsTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/AssertTimeoutAssertionsTests.java
@@ -11,28 +11,37 @@
 package org.junit.jupiter.api;
 
 import static java.time.Duration.ofMillis;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.AssertionTestUtils.assertMessageEquals;
 import static org.junit.jupiter.api.AssertionTestUtils.assertMessageStartsWith;
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTimeout;
+import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.fail;
+import static org.junit.jupiter.api.condition.OS.WINDOWS;
 
+import java.time.Duration;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicReference;
 
 import org.junit.jupiter.api.function.Executable;
 import org.junit.platform.commons.util.ExceptionUtils;
 import org.opentest4j.AssertionFailedError;
 
 /**
- * Unit tests for {@link AssertTimeout}.
+ * Unit tests for JUnit Jupiter {@link Assertions}.
  *
  * @since 5.0
  */
 class AssertTimeoutAssertionsTests {
 
-	private static final ThreadLocal<AtomicBoolean> changed = ThreadLocal.withInitial(() -> new AtomicBoolean(false));
+	private static final Duration PREEMPTIVE_TIMEOUT = ofMillis(WINDOWS.isCurrentOs() ? 1000 : 100);
+
+	private static ThreadLocal<AtomicBoolean> changed = ThreadLocal.withInitial(() -> new AtomicBoolean(false));
 
 	private final Executable nix = () -> {
 	};
@@ -154,6 +163,157 @@ class AssertTimeoutAssertionsTests {
 		assertMessageStartsWith(error, "Tempus Fugit ==> execution exceeded timeout of 10 ms by");
 	}
 
+	// -- executable - preemptively ---
+
+	@Test
+	void assertTimeoutPreemptivelyForExecutableThatCompletesBeforeTheTimeout() {
+		changed.get().set(false);
+		assertTimeoutPreemptively(ofMillis(500), () -> changed.get().set(true));
+		assertFalse(changed.get().get(), "should have executed in a different thread");
+		assertTimeoutPreemptively(ofMillis(500), nix, "message");
+		assertTimeoutPreemptively(ofMillis(500), nix, () -> "message");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyForExecutableThatThrowsAnException() {
+		RuntimeException exception = assertThrows(RuntimeException.class,
+			() -> assertTimeoutPreemptively(ofMillis(500), () -> {
+				throw new RuntimeException("not this time");
+			}));
+		assertMessageEquals(exception, "not this time");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyForExecutableThatThrowsAnAssertionFailedError() {
+		AssertionFailedError exception = assertThrows(AssertionFailedError.class,
+			() -> assertTimeoutPreemptively(ofMillis(500), () -> fail("enigma")));
+		assertMessageEquals(exception, "enigma");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyForExecutableThatCompletesAfterTheTimeout() {
+		AssertionFailedError error = assertThrows(AssertionFailedError.class,
+			() -> assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, this::waitForInterrupt));
+		assertMessageEquals(error, "execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
+		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
+		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyWithMessageForExecutableThatCompletesAfterTheTimeout() {
+		AssertionFailedError error = assertThrows(AssertionFailedError.class,
+			() -> assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, this::waitForInterrupt, "Tempus Fugit"));
+		assertMessageEquals(error,
+			"Tempus Fugit ==> execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
+		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
+		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyWithMessageSupplierForExecutableThatCompletesAfterTheTimeout() {
+		AssertionFailedError error = assertThrows(AssertionFailedError.class,
+			() -> assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, this::waitForInterrupt,
+				() -> "Tempus" + " " + "Fugit"));
+		assertMessageEquals(error,
+			"Tempus Fugit ==> execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
+		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
+		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyWithMessageSupplierForExecutableThatCompletesBeforeTheTimeout() {
+		assertTimeoutPreemptively(ofMillis(500), nix, () -> "Tempus" + " " + "Fugit");
+	}
+
+	// -- supplier - preemptively ---
+
+	@Test
+	void assertTimeoutPreemptivelyForSupplierThatCompletesBeforeTheTimeout() {
+		changed.get().set(false);
+		String result = assertTimeoutPreemptively(ofMillis(500), () -> {
+			changed.get().set(true);
+			return "Tempus Fugit";
+		});
+		assertFalse(changed.get().get(), "should have executed in a different thread");
+		assertEquals("Tempus Fugit", result);
+		assertEquals("Tempus Fugit", assertTimeoutPreemptively(ofMillis(500), () -> "Tempus Fugit", "message"));
+		assertEquals("Tempus Fugit", assertTimeoutPreemptively(ofMillis(500), () -> "Tempus Fugit", () -> "message"));
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyForSupplierThatThrowsAnException() {
+		RuntimeException exception = assertThrows(RuntimeException.class, () -> {
+			assertTimeoutPreemptively(ofMillis(500), () -> {
+				ExceptionUtils.throwAsUncheckedException(new RuntimeException("not this time"));
+				return "Tempus Fugit";
+			});
+		});
+		assertMessageEquals(exception, "not this time");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyForSupplierThatThrowsAnAssertionFailedError() {
+		AssertionFailedError exception = assertThrows(AssertionFailedError.class, () -> {
+			assertTimeoutPreemptively(ofMillis(500), () -> {
+				fail("enigma");
+				return "Tempus Fugit";
+			});
+		});
+		assertMessageEquals(exception, "enigma");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyForSupplierThatCompletesAfterTheTimeout() {
+		AssertionFailedError error = assertThrows(AssertionFailedError.class, () -> {
+			assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, () -> {
+				waitForInterrupt();
+				return "Tempus Fugit";
+			});
+		});
+
+		assertMessageEquals(error, "execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
+		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
+		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyWithMessageForSupplierThatCompletesAfterTheTimeout() {
+		AssertionFailedError error = assertThrows(AssertionFailedError.class, () -> {
+			assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, () -> {
+				waitForInterrupt();
+				return "Tempus Fugit";
+			}, "Tempus Fugit");
+		});
+
+		assertMessageEquals(error,
+			"Tempus Fugit ==> execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
+		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
+		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyWithMessageSupplierForSupplierThatCompletesAfterTheTimeout() {
+		AssertionFailedError error = assertThrows(AssertionFailedError.class, () -> {
+			assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, () -> {
+				waitForInterrupt();
+				return "Tempus Fugit";
+			}, () -> "Tempus" + " " + "Fugit");
+		});
+
+		assertMessageEquals(error,
+			"Tempus Fugit ==> execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
+		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
+		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
+	}
+
+	@Test
+	void assertTimeoutPreemptivelyUsesThreadsWithSpecificNamePrefix() {
+		AtomicReference<String> threadName = new AtomicReference<>("");
+		assertTimeoutPreemptively(ofMillis(1000), () -> threadName.set(Thread.currentThread().getName()));
+		assertTrue(threadName.get().startsWith("junit-timeout-thread-"),
+			"Thread name does not match the expected prefix");
+	}
+
 	/**
 	 * Take a nap for 100 milliseconds.
 	 */
@@ -165,4 +325,24 @@ class AssertTimeoutAssertionsTests {
 		} while (System.currentTimeMillis() - start < 100);
 	}
 
+	private void waitForInterrupt() {
+		try {
+			assertFalse(Thread.interrupted(), "Already interrupted");
+			new CountDownLatch(1).await();
+		}
+		catch (InterruptedException ignore) {
+			// ignore
+		}
+	}
+
+	/**
+	 * Assert the given stack trace elements contain an element with the given class name and method name.
+	 */
+	private static void assertStackTraceContains(StackTraceElement[] stackTrace, String className, String methodName) {
+		assertThat(stackTrace).anySatisfy(element -> {
+			assertThat(element.getClassName()).endsWith(className);
+			assertThat(element.getMethodName()).isEqualTo(methodName);
+		});
+	}
+
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/AssertTimeoutPreemptivelyAssertionsTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/AssertTimeoutPreemptivelyAssertionsTests.java
deleted file mode 100644
index 1f4d453cd..000000000
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/AssertTimeoutPreemptivelyAssertionsTests.java
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Copyright 2015-2022 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.api;
-
-import static java.time.Duration.ofMillis;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.jupiter.api.AssertionTestUtils.assertMessageEquals;
-import static org.junit.jupiter.api.AssertionTestUtils.assertMessageStartsWith;
-import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertThrows;
-import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;
-import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.api.Assertions.fail;
-import static org.junit.jupiter.api.condition.OS.WINDOWS;
-
-import java.time.Duration;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeoutException;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicReference;
-
-import org.junit.jupiter.api.function.Executable;
-import org.junit.platform.commons.util.ExceptionUtils;
-import org.opentest4j.AssertionFailedError;
-
-/**
- * Unit tests for {@link AssertTimeoutPreemptively}.
- *
- * @since 5.0
- */
-class AssertTimeoutPreemptivelyAssertionsTests {
-
-	private static final Duration PREEMPTIVE_TIMEOUT = ofMillis(WINDOWS.isCurrentOs() ? 1000 : 100);
-	private static final Assertions.TimeoutFailureFactory<TimeoutException> TIMEOUT_EXCEPTION_FACTORY = (__, ___,
-			____) -> new TimeoutException();
-
-	private static final ThreadLocal<AtomicBoolean> changed = ThreadLocal.withInitial(() -> new AtomicBoolean(false));
-
-	private final Executable nix = () -> {
-	};
-
-	// --- executable ----------------------------------------------------------
-
-	@Test
-	void assertTimeoutPreemptivelyForExecutableThatCompletesBeforeTheTimeout() {
-		changed.get().set(false);
-		assertTimeoutPreemptively(ofMillis(500), () -> changed.get().set(true));
-		assertFalse(changed.get().get(), "should have executed in a different thread");
-		assertTimeoutPreemptively(ofMillis(500), nix, "message");
-		assertTimeoutPreemptively(ofMillis(500), nix, () -> "message");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyForExecutableThatThrowsAnException() {
-		RuntimeException exception = assertThrows(RuntimeException.class,
-			() -> assertTimeoutPreemptively(ofMillis(500), () -> {
-				throw new RuntimeException("not this time");
-			}));
-		assertMessageEquals(exception, "not this time");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyForExecutableThatThrowsAnAssertionFailedError() {
-		AssertionFailedError exception = assertThrows(AssertionFailedError.class,
-			() -> assertTimeoutPreemptively(ofMillis(500), () -> fail("enigma")));
-		assertMessageEquals(exception, "enigma");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyForExecutableThatCompletesAfterTheTimeout() {
-		AssertionFailedError error = assertThrows(AssertionFailedError.class,
-			() -> assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, this::waitForInterrupt));
-		assertMessageEquals(error, "execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
-		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
-		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyWithMessageForExecutableThatCompletesAfterTheTimeout() {
-		AssertionFailedError error = assertThrows(AssertionFailedError.class,
-			() -> assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, this::waitForInterrupt, "Tempus Fugit"));
-		assertMessageEquals(error,
-			"Tempus Fugit ==> execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
-		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
-		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyWithMessageSupplierForExecutableThatCompletesAfterTheTimeout() {
-		AssertionFailedError error = assertThrows(AssertionFailedError.class,
-			() -> assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, this::waitForInterrupt,
-				() -> "Tempus" + " " + "Fugit"));
-		assertMessageEquals(error,
-			"Tempus Fugit ==> execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
-		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
-		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyWithMessageSupplierForExecutableThatCompletesBeforeTheTimeout() {
-		assertTimeoutPreemptively(ofMillis(500), nix, () -> "Tempus" + " " + "Fugit");
-	}
-
-	// --- supplier ------------------------------------------------------------
-
-	@Test
-	void assertTimeoutPreemptivelyForSupplierThatCompletesBeforeTheTimeout() {
-		changed.get().set(false);
-		String result = assertTimeoutPreemptively(ofMillis(500), () -> {
-			changed.get().set(true);
-			return "Tempus Fugit";
-		});
-		assertFalse(changed.get().get(), "should have executed in a different thread");
-		assertEquals("Tempus Fugit", result);
-		assertEquals("Tempus Fugit", assertTimeoutPreemptively(ofMillis(500), () -> "Tempus Fugit", "message"));
-		assertEquals("Tempus Fugit", assertTimeoutPreemptively(ofMillis(500), () -> "Tempus Fugit", () -> "message"));
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyForSupplierThatThrowsAnException() {
-		RuntimeException exception = assertThrows(RuntimeException.class, () -> {
-			assertTimeoutPreemptively(ofMillis(500), () -> {
-				ExceptionUtils.throwAsUncheckedException(new RuntimeException("not this time"));
-				return "Tempus Fugit";
-			});
-		});
-		assertMessageEquals(exception, "not this time");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyForSupplierThatThrowsAnAssertionFailedError() {
-		AssertionFailedError exception = assertThrows(AssertionFailedError.class, () -> {
-			assertTimeoutPreemptively(ofMillis(500), () -> {
-				fail("enigma");
-				return "Tempus Fugit";
-			});
-		});
-		assertMessageEquals(exception, "enigma");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyForSupplierThatCompletesAfterTheTimeout() {
-		AssertionFailedError error = assertThrows(AssertionFailedError.class, () -> {
-			assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, () -> {
-				waitForInterrupt();
-				return "Tempus Fugit";
-			});
-		});
-
-		assertMessageEquals(error, "execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
-		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
-		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyWithMessageForSupplierThatCompletesAfterTheTimeout() {
-		AssertionFailedError error = assertThrows(AssertionFailedError.class, () -> {
-			assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, () -> {
-				waitForInterrupt();
-				return "Tempus Fugit";
-			}, "Tempus Fugit");
-		});
-
-		assertMessageEquals(error,
-			"Tempus Fugit ==> execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
-		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
-		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyWithMessageSupplierForSupplierThatCompletesAfterTheTimeout() {
-		AssertionFailedError error = assertThrows(AssertionFailedError.class, () -> {
-			assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, () -> {
-				waitForInterrupt();
-				return "Tempus Fugit";
-			}, () -> "Tempus" + " " + "Fugit");
-		});
-
-		assertMessageEquals(error,
-			"Tempus Fugit ==> execution timed out after " + PREEMPTIVE_TIMEOUT.toMillis() + " ms");
-		assertMessageStartsWith(error.getCause(), "Execution timed out in ");
-		assertStackTraceContains(error.getCause().getStackTrace(), "CountDownLatch", "await");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyUsesThreadsWithSpecificNamePrefix() {
-		AtomicReference<String> threadName = new AtomicReference<>("");
-		assertTimeoutPreemptively(ofMillis(1000), () -> threadName.set(Thread.currentThread().getName()));
-		assertTrue(threadName.get().startsWith("junit-timeout-thread-"),
-			"Thread name does not match the expected prefix");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyThrowingTimeoutExceptionWithMessageForSupplierThatCompletesAfterTheTimeout() {
-		assertThrows(TimeoutException.class, () -> Assertions.assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, () -> {
-			waitForInterrupt();
-			return "Tempus Fugit";
-		}, () -> "Tempus Fugit", TIMEOUT_EXCEPTION_FACTORY));
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyThrowingTimeoutExceptionWithMessageForSupplierThatThrowsAnAssertionFailedError() {
-		AssertionFailedError exception = assertThrows(AssertionFailedError.class,
-			() -> Assertions.assertTimeoutPreemptively(ofMillis(500), () -> fail("enigma"), () -> "Tempus Fugit",
-				TIMEOUT_EXCEPTION_FACTORY));
-		assertMessageEquals(exception, "enigma");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyThrowingTimeoutExceptionWithMessageForSupplierThatThrowsAnException() {
-		RuntimeException exception = assertThrows(RuntimeException.class,
-			() -> Assertions.assertTimeoutPreemptively(ofMillis(500),
-				() -> ExceptionUtils.throwAsUncheckedException(new RuntimeException(":(")), () -> "Tempus Fugit",
-				TIMEOUT_EXCEPTION_FACTORY));
-		assertMessageEquals(exception, ":(");
-	}
-
-	@Test
-	void assertTimeoutPreemptivelyThrowingTimeoutExceptionWithMessageForSupplierThatCompletesBeforeTimeout()
-			throws Exception {
-		var result = Assertions.assertTimeoutPreemptively(PREEMPTIVE_TIMEOUT, () -> "Tempus Fugit",
-			() -> "Tempus Fugit", TIMEOUT_EXCEPTION_FACTORY);
-
-		assertThat(result).isEqualTo("Tempus Fugit");
-	}
-
-	private void waitForInterrupt() {
-		try {
-			assertFalse(Thread.interrupted(), "Already interrupted");
-			new CountDownLatch(1).await();
-		}
-		catch (InterruptedException ignore) {
-			// ignore
-		}
-	}
-
-	/**
-	 * Assert the given stack trace elements contain an element with the given class name and method name.
-	 */
-	private static void assertStackTraceContains(StackTraceElement[] stackTrace, String className, String methodName) {
-		assertThat(stackTrace).anySatisfy(element -> {
-			assertThat(element.getClassName()).endsWith(className);
-			assertThat(element.getMethodName()).isEqualTo(methodName);
-		});
-	}
-}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExtensionTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExtensionTests.java
index 012074155..449ee09a0 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExtensionTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TimeoutExtensionTests.java
@@ -60,7 +60,6 @@ import org.junit.platform.engine.TestExecutionResult.Status;
 import org.junit.platform.testkit.engine.EngineExecutionResults;
 import org.junit.platform.testkit.engine.Events;
 import org.junit.platform.testkit.engine.Execution;
-import org.opentest4j.AssertionFailedError;
 
 /**
  * @since 5.5
@@ -349,13 +348,9 @@ class TimeoutExtensionTests extends AbstractJupiterTestEngineTests {
 			EngineExecutionResults results = executeTestsForClass(TimeoutExceedingSeparateThreadTestCase.class);
 
 			Execution execution = findExecution(results.testEvents(), "testMethod()");
-			Throwable failure = execution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow();
-			assertThat(failure) //
+			assertThat(execution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
 					.isInstanceOf(TimeoutException.class) //
-					.hasMessage("testMethod() timed out after 100 milliseconds");
-			assertThat(failure.getCause()) //
-					.hasMessageStartingWith("Execution timed out in ") //
-					.hasStackTraceContaining(TimeoutExceedingSeparateThreadTestCase.class.getName() + ".testMethod");
+					.hasMessage("testMethod() timed out after 10 milliseconds");
 		}
 
 		@Test
@@ -387,29 +382,13 @@ class TimeoutExtensionTests extends AbstractJupiterTestEngineTests {
 					.hasMessage("Oppps!");
 		}
 
-		@Test
-		@DisplayName("propagates assertion exceptions")
-		void separateThreadHandlesOpenTestFailedAssertion() {
-			EngineExecutionResults results = executeTestsForClass(FailedAssertionInSeparateThreadTestCase.class);
-
-			Execution openTestFailure = findExecution(results.testEvents(), "testOpenTestAssertion()");
-			assertThat(openTestFailure.getDuration()) //
-					.isLessThan(Duration.ofSeconds(5));
-			assertThat(openTestFailure.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
-					.isInstanceOf(AssertionFailedError.class);
-
-			Execution javaLangFailure = findExecution(results.testEvents(), "testJavaLangAssertion()");
-			assertThat(javaLangFailure.getDuration()) //
-					.isLessThan(Duration.ofSeconds(5));
-			assertThat(javaLangFailure.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
-					.isInstanceOf(AssertionError.class);
-		}
-
 		@Test
 		@DisplayName("when one test is stuck \"forever\" the next tests should not get stuck")
 		void oneThreadStuckForever() {
 			EngineExecutionResults results = executeTestsForClass(OneTestStuckForeverAndTheOthersNotTestCase.class);
 
+			results.allEvents().debug();
+
 			Execution stuckExecution = findExecution(results.testEvents(), "stuck()");
 			assertThat(stuckExecution.getTerminationInfo().getExecutionResult().getThrowable().orElseThrow()) //
 					.isInstanceOf(TimeoutException.class) //
@@ -721,7 +700,7 @@ class TimeoutExtensionTests extends AbstractJupiterTestEngineTests {
 
 	static class TimeoutExceedingSeparateThreadTestCase {
 		@Test
-		@Timeout(value = 100, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
+		@Timeout(value = 10, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
 		void testMethod() throws InterruptedException {
 			Thread.sleep(1000);
 		}
@@ -750,20 +729,6 @@ class TimeoutExtensionTests extends AbstractJupiterTestEngineTests {
 		}
 	}
 
-	static class FailedAssertionInSeparateThreadTestCase {
-		@Test
-		@Timeout(value = 5, unit = SECONDS, threadMode = SEPARATE_THREAD)
-		void testOpenTestAssertion() {
-			throw new AssertionFailedError();
-		}
-
-		@Test
-		@Timeout(value = 5, unit = SECONDS, threadMode = SEPARATE_THREAD)
-		void testJavaLangAssertion() {
-			throw new AssertionError();
-		}
-	}
-
 	@Timeout(value = 100, unit = MILLISECONDS, threadMode = SEPARATE_THREAD)
 	static class TimeoutExceededOnClassLevelTestCase {
 		@Test
