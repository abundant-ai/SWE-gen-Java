diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java
deleted file mode 100644
index ed311c323..000000000
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright 2015-2025 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * https://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.jupiter.api.extension;
-
-import static org.apiguardian.api.API.Status.INTERNAL;
-
-import java.lang.annotation.Annotation;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-import org.apiguardian.api.API;
-
-/**
- * Internal marker annotation for lifecycle methods specific to implementations
- * of {@link ClassTemplateInvocationContextProvider}.
- *
- * @since 5.13
- */
-@API(status = INTERNAL, since = "5.13")
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.ANNOTATION_TYPE)
-public @interface ClassTemplateInvocationLifecycleMethod {
-
-	/**
-	 * The actual annotation class for reporting of discovery issues.
-	 */
-	Class<? extends Annotation> value();
-
-}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java
index b91c39bb4..469c477e2 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java
@@ -13,8 +13,6 @@ package org.junit.jupiter.engine.descriptor;
 import static java.util.stream.Collectors.toCollection;
 import static java.util.stream.Collectors.toList;
 import static org.apiguardian.api.API.Status.INTERNAL;
-import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD;
-import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.validateClassTemplateInvocationLifecycleMethods;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -41,7 +39,6 @@ import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestTag;
 import org.junit.platform.engine.UniqueId;
-import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
 import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
 import org.junit.platform.engine.support.hierarchical.Node;
 
@@ -77,15 +74,6 @@ public class ClassTemplateTestDescriptor extends ClassBasedTestDescriptor implem
 		return this.delegate.getTags();
 	}
 
-	// --- Validatable ---------------------------------------------------------
-
-	@Override
-	public void validate(DiscoveryIssueReporter reporter) {
-		this.delegate.validate(reporter);
-		boolean requireStatic = this.classInfo.lifecycle == PER_METHOD;
-		validateClassTemplateInvocationLifecycleMethods(getTestClass(), requireStatic, reporter);
-	}
-
 	// --- Filterable ----------------------------------------------------------
 
 	@Override
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java
index 7eee75e47..a73d9fc2f 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java
@@ -17,16 +17,11 @@ import static org.junit.platform.engine.support.discovery.DiscoveryIssueReporter
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.List;
-import java.util.function.Function;
-import java.util.function.Supplier;
-import java.util.stream.Stream;
 
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.extension.ClassTemplateInvocationLifecycleMethod;
-import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.support.HierarchyTraversalMode;
 import org.junit.platform.commons.support.ModifierSupport;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -69,35 +64,11 @@ final class LifecycleMethodUtils {
 			issueReporter);
 	}
 
-	static void validateClassTemplateInvocationLifecycleMethods(Class<?> testClass, boolean requireStatic,
-			DiscoveryIssueReporter issueReporter) {
-
-		Stream<Method> allMethods = Stream.concat( //
-			findAnnotatedMethods(testClass, ClassTemplateInvocationLifecycleMethod.class,
-				HierarchyTraversalMode.TOP_DOWN).stream(), //
-			findAnnotatedMethods(testClass, ClassTemplateInvocationLifecycleMethod.class,
-				HierarchyTraversalMode.BOTTOM_UP).stream() //
-		);
-		allMethods //
-				.distinct() //
-				.forEach(allOf( //
-					isNotPrivateError(issueReporter), //
-					returnsPrimitiveVoid(issueReporter,
-						LifecycleMethodUtils::classTemplateInvocationLifecycleMethodAnnotationName), //
-					requireStatic
-							? isStatic(issueReporter,
-								LifecycleMethodUtils::classTemplateInvocationLifecycleMethodAnnotationName)
-							: __ -> true //
-				));
-	}
-
 	private static List<Method> findMethodsAndCheckStatic(Class<?> testClass, boolean requireStatic,
 			Class<? extends Annotation> annotationType, HierarchyTraversalMode traversalMode,
 			DiscoveryIssueReporter issueReporter) {
 
-		Condition<Method> additionalCondition = requireStatic
-				? isStatic(issueReporter, __ -> annotationType.getSimpleName())
-				: __ -> true;
+		Condition<Method> additionalCondition = requireStatic ? isStatic(annotationType, issueReporter) : __ -> true;
 		return findMethodsAndCheckVoidReturnType(testClass, annotationType, traversalMode, issueReporter,
 			additionalCondition);
 	}
@@ -107,7 +78,7 @@ final class LifecycleMethodUtils {
 			DiscoveryIssueReporter issueReporter) {
 
 		return findMethodsAndCheckVoidReturnType(testClass, annotationType, traversalMode, issueReporter,
-			isNotStatic(issueReporter, __ -> annotationType.getSimpleName()));
+			isNotStatic(annotationType, issueReporter));
 	}
 
 	private static List<Method> findMethodsAndCheckVoidReturnType(Class<?> testClass,
@@ -115,64 +86,49 @@ final class LifecycleMethodUtils {
 			DiscoveryIssueReporter issueReporter, Condition<? super Method> additionalCondition) {
 
 		return findAnnotatedMethods(testClass, annotationType, traversalMode).stream() //
-				.peek(isNotPrivateDeprecation(issueReporter, annotationType::getSimpleName)) //
-				.filter(allOf(returnsPrimitiveVoid(issueReporter, __ -> annotationType.getSimpleName()),
-					additionalCondition)) //
+				.peek(isNotPrivate(annotationType, issueReporter)) //
+				.filter(allOf(returnsPrimitiveVoid(annotationType, issueReporter), additionalCondition)) //
 				.collect(toUnmodifiableList());
 	}
 
-	private static Condition<Method> isStatic(DiscoveryIssueReporter issueReporter,
-			Function<Method, String> annotationNameProvider) {
+	private static Condition<Method> isStatic(Class<? extends Annotation> annotationType,
+			DiscoveryIssueReporter issueReporter) {
 		return issueReporter.createReportingCondition(ModifierSupport::isStatic, method -> {
 			String message = String.format(
 				"@%s method '%s' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).",
-				annotationNameProvider.apply(method), method.toGenericString());
+				annotationType.getSimpleName(), method.toGenericString());
 			return createIssue(Severity.ERROR, message, method);
 		});
 	}
 
-	private static Condition<Method> isNotStatic(DiscoveryIssueReporter issueReporter,
-			Function<Method, String> annotationNameProvider) {
+	private static Condition<Method> isNotStatic(Class<? extends Annotation> annotationType,
+			DiscoveryIssueReporter issueReporter) {
 		return issueReporter.createReportingCondition(ModifierSupport::isNotStatic, method -> {
-			String message = String.format("@%s method '%s' must not be static.", annotationNameProvider.apply(method),
+			String message = String.format("@%s method '%s' must not be static.", annotationType.getSimpleName(),
 				method.toGenericString());
 			return createIssue(Severity.ERROR, message, method);
 		});
 	}
 
-	private static Condition<Method> isNotPrivateError(DiscoveryIssueReporter issueReporter) {
-		return issueReporter.createReportingCondition(ModifierSupport::isNotPrivate, method -> {
-			String message = String.format("@%s method '%s' must not be private.",
-				classTemplateInvocationLifecycleMethodAnnotationName(method), method.toGenericString());
-			return createIssue(Severity.ERROR, message, method);
-		});
-	}
-
-	private static Condition<Method> isNotPrivateDeprecation(DiscoveryIssueReporter issueReporter,
-			Supplier<String> annotationNameProvider) {
+	private static Condition<Method> isNotPrivate(Class<? extends Annotation> annotationType,
+			DiscoveryIssueReporter issueReporter) {
 		return issueReporter.createReportingCondition(ModifierSupport::isNotPrivate, method -> {
 			String message = String.format(
 				"@%s method '%s' should not be private. This will be disallowed in a future release.",
-				annotationNameProvider.get(), method.toGenericString());
+				annotationType.getSimpleName(), method.toGenericString());
 			return createIssue(Severity.DEPRECATION, message, method);
 		});
 	}
 
-	private static Condition<Method> returnsPrimitiveVoid(DiscoveryIssueReporter issueReporter,
-			Function<Method, String> annotationNameProvider) {
+	private static Condition<Method> returnsPrimitiveVoid(Class<? extends Annotation> annotationType,
+			DiscoveryIssueReporter issueReporter) {
 		return issueReporter.createReportingCondition(ReflectionUtils::returnsPrimitiveVoid, method -> {
-			String message = String.format("@%s method '%s' must not return a value.",
-				annotationNameProvider.apply(method), method.toGenericString());
+			String message = String.format("@%s method '%s' must not return a value.", annotationType.getSimpleName(),
+				method.toGenericString());
 			return createIssue(Severity.ERROR, message, method);
 		});
 	}
 
-	private static String classTemplateInvocationLifecycleMethodAnnotationName(Method method) {
-		return AnnotationSupport.findAnnotation(method, ClassTemplateInvocationLifecycleMethod.class) //
-				.map(ClassTemplateInvocationLifecycleMethod::value).map(Class::getSimpleName) //
-				.orElseGet(ClassTemplateInvocationLifecycleMethod.class::getSimpleName);
-	}
-
 	private static DiscoveryIssue createIssue(Severity severity, String message, Method method) {
 		return DiscoveryIssue.builder(severity, message).source(MethodSource.from(method)).build();
 	}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java
index 112347a0b..a97c62e6a 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java
@@ -19,7 +19,6 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.apiguardian.api.API;
-import org.junit.jupiter.api.extension.ClassTemplateInvocationLifecycleMethod;
 import org.junit.jupiter.params.aggregator.AggregateWith;
 import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 
@@ -158,7 +157,6 @@ import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @API(status = EXPERIMENTAL, since = "5.13")
-@ClassTemplateInvocationLifecycleMethod(AfterParameterizedClassInvocation.class)
 public @interface AfterParameterizedClassInvocation {
 
 	/**
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java
index 0ede11363..c6b23587e 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java
@@ -19,7 +19,6 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.apiguardian.api.API;
-import org.junit.jupiter.api.extension.ClassTemplateInvocationLifecycleMethod;
 import org.junit.jupiter.params.aggregator.AggregateWith;
 import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 
@@ -159,7 +158,6 @@ import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @API(status = EXPERIMENTAL, since = "5.13")
-@ClassTemplateInvocationLifecycleMethod(BeforeParameterizedClassInvocation.class)
 public @interface BeforeParameterizedClassInvocation {
 
 	/**
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java
index f73fff4e1..31528072b 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java
@@ -12,15 +12,15 @@ package org.junit.jupiter.params;
 
 import static java.util.Collections.emptyList;
 import static java.util.Collections.reverse;
-import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD;
+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
 import static org.junit.platform.commons.support.AnnotationSupport.findAnnotatedMethods;
-import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;
 import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
 import static org.junit.platform.commons.support.HierarchyTraversalMode.BOTTOM_UP;
 import static org.junit.platform.commons.support.HierarchyTraversalMode.TOP_DOWN;
 import static org.junit.platform.commons.support.ReflectionSupport.findFields;
 import static org.junit.platform.commons.util.CollectionUtils.toUnmodifiableList;
 import static org.junit.platform.commons.util.ReflectionUtils.isRecordClass;
+import static org.junit.platform.commons.util.ReflectionUtils.returnsPrimitiveVoid;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
@@ -33,6 +33,7 @@ import org.junit.jupiter.api.TestInstance;
 import org.junit.jupiter.api.extension.ClassTemplateInvocationContext;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.support.HierarchyTraversalMode;
 import org.junit.platform.commons.support.ModifierSupport;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -152,12 +153,14 @@ class ParameterizedClassContext implements ParameterizedDeclarationContext<Class
 			Class<?> testClass, TestInstance.Lifecycle testInstanceLifecycle, HierarchyTraversalMode traversalMode,
 			Class<A> annotationType, Predicate<A> injectArgumentsPredicate, ResolverFacade resolverFacade) {
 
-		List<Method> methods = findAnnotatedMethods(testClass, annotationType, traversalMode);
+		List<Method> methods = findMethodsAndCheckVoidReturnTypeAndNonPrivate(testClass, annotationType, traversalMode);
 
 		return methods.stream() //
-				.filter(ModifierSupport::isNotPrivate) //
-				.filter(testInstanceLifecycle == PER_METHOD ? ModifierSupport::isStatic : __ -> true) //
-				.filter(ReflectionUtils::returnsPrimitiveVoid) //
+				.peek(method -> {
+					if (testInstanceLifecycle != PER_CLASS) {
+						assertStatic(annotationType, method);
+					}
+				}) //
 				.map(method -> {
 					A annotation = getAnnotation(method, annotationType);
 					if (injectArgumentsPredicate.test(annotation)) {
@@ -170,10 +173,43 @@ class ParameterizedClassContext implements ParameterizedDeclarationContext<Class
 	}
 
 	private static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {
-		return findAnnotation(method, annotationType) //
+		return AnnotationSupport.findAnnotation(method, annotationType) //
 				.orElseThrow(() -> new JUnitException("Method not annotated with @" + annotationType.getSimpleName()));
 	}
 
+	private static List<Method> findMethodsAndCheckVoidReturnTypeAndNonPrivate(Class<?> testClass,
+			Class<? extends Annotation> annotationType, HierarchyTraversalMode traversalMode) {
+
+		List<Method> methods = findAnnotatedMethods(testClass, annotationType, traversalMode);
+		methods.forEach(method -> {
+			assertVoid(annotationType, method);
+			assertNonPrivate(annotationType, method);
+		});
+		return methods;
+	}
+
+	private static void assertStatic(Class<? extends Annotation> annotationType, Method method) {
+		if (ModifierSupport.isNotStatic(method)) {
+			throw new JUnitException(String.format(
+				"@%s method '%s' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).",
+				annotationType.getSimpleName(), method.toGenericString()));
+		}
+	}
+
+	private static void assertVoid(Class<? extends Annotation> annotationType, Method method) {
+		if (!returnsPrimitiveVoid(method)) {
+			throw new JUnitException(String.format("@%s method '%s' must not return a value.",
+				annotationType.getSimpleName(), method.toGenericString()));
+		}
+	}
+
+	private static void assertNonPrivate(Class<? extends Annotation> annotationType, Method method) {
+		if (ModifierSupport.isPrivate(method)) {
+			throw new JUnitException(String.format("@%s method '%s' must not be private.",
+				annotationType.getSimpleName(), method.toGenericString()));
+		}
+	}
+
 	enum InjectionType {
 		CONSTRUCTOR, FIELDS
 	}
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java
index 1f715d089..3bbfc99ff 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/params/ParameterizedClassIntegrationTests.java
@@ -27,7 +27,6 @@ import static org.junit.jupiter.params.ParameterizedInvocationConstants.DISPLAY_
 import static org.junit.jupiter.params.ParameterizedInvocationConstants.INDEX_PLACEHOLDER;
 import static org.junit.jupiter.params.provider.Arguments.argumentSet;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
-import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
 import static org.junit.platform.testkit.engine.EventConditions.container;
 import static org.junit.platform.testkit.engine.EventConditions.displayName;
@@ -94,7 +93,6 @@ import org.junit.jupiter.params.provider.ValueSource;
 import org.junit.jupiter.params.support.FieldContext;
 import org.junit.jupiter.params.support.ParameterDeclarations;
 import org.junit.platform.commons.util.StringUtils;
-import org.junit.platform.engine.DiscoveryIssue;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestExecutionResult;
 import org.junit.platform.engine.UniqueId;
@@ -609,49 +607,23 @@ public class ParameterizedClassIntegrationTests extends AbstractJupiterTestEngin
 
 			var className = ParameterizedClassIntegrationTests.class.getName() + "$" + simpleClassName;
 
-			var results = discoverTestsForClass(Class.forName(className));
+			var results = executeTestsForClass(Class.forName(className));
 
-			var issue = getOnlyElement(results.getDiscoveryIssues());
-			assertThat(issue.severity()) //
-					.isEqualTo(DiscoveryIssue.Severity.ERROR);
-			assertThat(issue.message()) //
-					.isEqualTo(
-						"%s method 'void %s.%s()' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).",
-						annotationName, className, lifecycleMethodName);
-			assertThat(issue.source()) //
-					.containsInstanceOf(org.junit.platform.engine.support.descriptor.MethodSource.class);
+			results.containerEvents().assertThatEvents() //
+					.haveExactly(1, finishedWithFailure(message(
+						"%s method 'void %s.%s()' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS)." //
+								.formatted(annotationName, className, lifecycleMethodName))));
 		}
 
 		@Test
 		void lifecycleMethodsMustNotBePrivate() {
 
-			var results = discoverTestsForClass(PrivateLifecycleMethodTestCase.class);
-
-			var issue = getOnlyElement(results.getDiscoveryIssues());
-			assertThat(issue.severity()) //
-					.isEqualTo(DiscoveryIssue.Severity.ERROR);
-			assertThat(issue.message()) //
-					.isEqualTo(
-						"@BeforeParameterizedClassInvocation method 'private static void %s.beforeParameterizedClassInvocation()' must not be private.",
-						PrivateLifecycleMethodTestCase.class.getName());
-			assertThat(issue.source()) //
-					.containsInstanceOf(org.junit.platform.engine.support.descriptor.MethodSource.class);
-		}
-
-		@Test
-		void lifecycleMethodsMustNotDeclareReturnType() {
+			var results = executeTestsForClass(PrivateLifecycleMethodTestCase.class);
 
-			var results = discoverTestsForClass(NonVoidLifecycleMethodTestCase.class);
-
-			var issue = getOnlyElement(results.getDiscoveryIssues());
-			assertThat(issue.severity()) //
-					.isEqualTo(DiscoveryIssue.Severity.ERROR);
-			assertThat(issue.message()) //
-					.isEqualTo(
-						"@BeforeParameterizedClassInvocation method 'static int %s.beforeParameterizedClassInvocation()' must not return a value.",
-						NonVoidLifecycleMethodTestCase.class.getName());
-			assertThat(issue.source()) //
-					.containsInstanceOf(org.junit.platform.engine.support.descriptor.MethodSource.class);
+			results.containerEvents().assertThatEvents() //
+					.haveExactly(1, finishedWithFailure(message(
+						"@BeforeParameterizedClassInvocation method 'private static void %s.beforeParameterizedClassInvocation()' must not be private." //
+								.formatted(PrivateLifecycleMethodTestCase.class.getName()))));
 		}
 
 		@Test
@@ -1795,21 +1767,6 @@ public class ParameterizedClassIntegrationTests extends AbstractJupiterTestEngin
 		}
 	}
 
-	@ParameterizedClass
-	@ValueSource(ints = 1)
-	record NonVoidLifecycleMethodTestCase() {
-
-		@BeforeParameterizedClassInvocation
-		static int beforeParameterizedClassInvocation() {
-			return fail("should not be called");
-		}
-
-		@Test
-		void test() {
-			fail("should not be called");
-		}
-	}
-
 	static abstract class AbstractBaseLifecycleTestCase {
 
 		@BeforeParameterizedClassInvocation
