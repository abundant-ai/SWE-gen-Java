diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java
new file mode 100644
index 000000000..ed311c323
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ClassTemplateInvocationLifecycleMethod.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.apiguardian.api.API.Status.INTERNAL;
+
+import java.lang.annotation.Annotation;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import org.apiguardian.api.API;
+
+/**
+ * Internal marker annotation for lifecycle methods specific to implementations
+ * of {@link ClassTemplateInvocationContextProvider}.
+ *
+ * @since 5.13
+ */
+@API(status = INTERNAL, since = "5.13")
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.ANNOTATION_TYPE)
+public @interface ClassTemplateInvocationLifecycleMethod {
+
+	/**
+	 * The actual annotation class for reporting of discovery issues.
+	 */
+	Class<? extends Annotation> value();
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java
index 469c477e2..b91c39bb4 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTemplateTestDescriptor.java
@@ -13,6 +13,8 @@ package org.junit.jupiter.engine.descriptor;
 import static java.util.stream.Collectors.toCollection;
 import static java.util.stream.Collectors.toList;
 import static org.apiguardian.api.API.Status.INTERNAL;
+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD;
+import static org.junit.jupiter.engine.descriptor.LifecycleMethodUtils.validateClassTemplateInvocationLifecycleMethods;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -39,6 +41,7 @@ import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestTag;
 import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
 import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
 import org.junit.platform.engine.support.hierarchical.Node;
 
@@ -74,6 +77,15 @@ public class ClassTemplateTestDescriptor extends ClassBasedTestDescriptor implem
 		return this.delegate.getTags();
 	}
 
+	// --- Validatable ---------------------------------------------------------
+
+	@Override
+	public void validate(DiscoveryIssueReporter reporter) {
+		this.delegate.validate(reporter);
+		boolean requireStatic = this.classInfo.lifecycle == PER_METHOD;
+		validateClassTemplateInvocationLifecycleMethods(getTestClass(), requireStatic, reporter);
+	}
+
 	// --- Filterable ----------------------------------------------------------
 
 	@Override
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java
index a73d9fc2f..7eee75e47 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/LifecycleMethodUtils.java
@@ -17,11 +17,16 @@ import static org.junit.platform.engine.support.discovery.DiscoveryIssueReporter
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.List;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.Stream;
 
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.extension.ClassTemplateInvocationLifecycleMethod;
+import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.support.HierarchyTraversalMode;
 import org.junit.platform.commons.support.ModifierSupport;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -64,11 +69,35 @@ final class LifecycleMethodUtils {
 			issueReporter);
 	}
 
+	static void validateClassTemplateInvocationLifecycleMethods(Class<?> testClass, boolean requireStatic,
+			DiscoveryIssueReporter issueReporter) {
+
+		Stream<Method> allMethods = Stream.concat( //
+			findAnnotatedMethods(testClass, ClassTemplateInvocationLifecycleMethod.class,
+				HierarchyTraversalMode.TOP_DOWN).stream(), //
+			findAnnotatedMethods(testClass, ClassTemplateInvocationLifecycleMethod.class,
+				HierarchyTraversalMode.BOTTOM_UP).stream() //
+		);
+		allMethods //
+				.distinct() //
+				.forEach(allOf( //
+					isNotPrivateError(issueReporter), //
+					returnsPrimitiveVoid(issueReporter,
+						LifecycleMethodUtils::classTemplateInvocationLifecycleMethodAnnotationName), //
+					requireStatic
+							? isStatic(issueReporter,
+								LifecycleMethodUtils::classTemplateInvocationLifecycleMethodAnnotationName)
+							: __ -> true //
+				));
+	}
+
 	private static List<Method> findMethodsAndCheckStatic(Class<?> testClass, boolean requireStatic,
 			Class<? extends Annotation> annotationType, HierarchyTraversalMode traversalMode,
 			DiscoveryIssueReporter issueReporter) {
 
-		Condition<Method> additionalCondition = requireStatic ? isStatic(annotationType, issueReporter) : __ -> true;
+		Condition<Method> additionalCondition = requireStatic
+				? isStatic(issueReporter, __ -> annotationType.getSimpleName())
+				: __ -> true;
 		return findMethodsAndCheckVoidReturnType(testClass, annotationType, traversalMode, issueReporter,
 			additionalCondition);
 	}
@@ -78,7 +107,7 @@ final class LifecycleMethodUtils {
 			DiscoveryIssueReporter issueReporter) {
 
 		return findMethodsAndCheckVoidReturnType(testClass, annotationType, traversalMode, issueReporter,
-			isNotStatic(annotationType, issueReporter));
+			isNotStatic(issueReporter, __ -> annotationType.getSimpleName()));
 	}
 
 	private static List<Method> findMethodsAndCheckVoidReturnType(Class<?> testClass,
@@ -86,49 +115,64 @@ final class LifecycleMethodUtils {
 			DiscoveryIssueReporter issueReporter, Condition<? super Method> additionalCondition) {
 
 		return findAnnotatedMethods(testClass, annotationType, traversalMode).stream() //
-				.peek(isNotPrivate(annotationType, issueReporter)) //
-				.filter(allOf(returnsPrimitiveVoid(annotationType, issueReporter), additionalCondition)) //
+				.peek(isNotPrivateDeprecation(issueReporter, annotationType::getSimpleName)) //
+				.filter(allOf(returnsPrimitiveVoid(issueReporter, __ -> annotationType.getSimpleName()),
+					additionalCondition)) //
 				.collect(toUnmodifiableList());
 	}
 
-	private static Condition<Method> isStatic(Class<? extends Annotation> annotationType,
-			DiscoveryIssueReporter issueReporter) {
+	private static Condition<Method> isStatic(DiscoveryIssueReporter issueReporter,
+			Function<Method, String> annotationNameProvider) {
 		return issueReporter.createReportingCondition(ModifierSupport::isStatic, method -> {
 			String message = String.format(
 				"@%s method '%s' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).",
-				annotationType.getSimpleName(), method.toGenericString());
+				annotationNameProvider.apply(method), method.toGenericString());
 			return createIssue(Severity.ERROR, message, method);
 		});
 	}
 
-	private static Condition<Method> isNotStatic(Class<? extends Annotation> annotationType,
-			DiscoveryIssueReporter issueReporter) {
+	private static Condition<Method> isNotStatic(DiscoveryIssueReporter issueReporter,
+			Function<Method, String> annotationNameProvider) {
 		return issueReporter.createReportingCondition(ModifierSupport::isNotStatic, method -> {
-			String message = String.format("@%s method '%s' must not be static.", annotationType.getSimpleName(),
+			String message = String.format("@%s method '%s' must not be static.", annotationNameProvider.apply(method),
 				method.toGenericString());
 			return createIssue(Severity.ERROR, message, method);
 		});
 	}
 
-	private static Condition<Method> isNotPrivate(Class<? extends Annotation> annotationType,
-			DiscoveryIssueReporter issueReporter) {
+	private static Condition<Method> isNotPrivateError(DiscoveryIssueReporter issueReporter) {
+		return issueReporter.createReportingCondition(ModifierSupport::isNotPrivate, method -> {
+			String message = String.format("@%s method '%s' must not be private.",
+				classTemplateInvocationLifecycleMethodAnnotationName(method), method.toGenericString());
+			return createIssue(Severity.ERROR, message, method);
+		});
+	}
+
+	private static Condition<Method> isNotPrivateDeprecation(DiscoveryIssueReporter issueReporter,
+			Supplier<String> annotationNameProvider) {
 		return issueReporter.createReportingCondition(ModifierSupport::isNotPrivate, method -> {
 			String message = String.format(
 				"@%s method '%s' should not be private. This will be disallowed in a future release.",
-				annotationType.getSimpleName(), method.toGenericString());
+				annotationNameProvider.get(), method.toGenericString());
 			return createIssue(Severity.DEPRECATION, message, method);
 		});
 	}
 
-	private static Condition<Method> returnsPrimitiveVoid(Class<? extends Annotation> annotationType,
-			DiscoveryIssueReporter issueReporter) {
+	private static Condition<Method> returnsPrimitiveVoid(DiscoveryIssueReporter issueReporter,
+			Function<Method, String> annotationNameProvider) {
 		return issueReporter.createReportingCondition(ReflectionUtils::returnsPrimitiveVoid, method -> {
-			String message = String.format("@%s method '%s' must not return a value.", annotationType.getSimpleName(),
-				method.toGenericString());
+			String message = String.format("@%s method '%s' must not return a value.",
+				annotationNameProvider.apply(method), method.toGenericString());
 			return createIssue(Severity.ERROR, message, method);
 		});
 	}
 
+	private static String classTemplateInvocationLifecycleMethodAnnotationName(Method method) {
+		return AnnotationSupport.findAnnotation(method, ClassTemplateInvocationLifecycleMethod.class) //
+				.map(ClassTemplateInvocationLifecycleMethod::value).map(Class::getSimpleName) //
+				.orElseGet(ClassTemplateInvocationLifecycleMethod.class::getSimpleName);
+	}
+
 	private static DiscoveryIssue createIssue(Severity severity, String message, Method method) {
 		return DiscoveryIssue.builder(severity, message).source(MethodSource.from(method)).build();
 	}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java
index a97c62e6a..112347a0b 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/AfterParameterizedClassInvocation.java
@@ -19,6 +19,7 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ClassTemplateInvocationLifecycleMethod;
 import org.junit.jupiter.params.aggregator.AggregateWith;
 import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 
@@ -157,6 +158,7 @@ import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @API(status = EXPERIMENTAL, since = "5.13")
+@ClassTemplateInvocationLifecycleMethod(AfterParameterizedClassInvocation.class)
 public @interface AfterParameterizedClassInvocation {
 
 	/**
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java
index c6b23587e..0ede11363 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/BeforeParameterizedClassInvocation.java
@@ -19,6 +19,7 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ClassTemplateInvocationLifecycleMethod;
 import org.junit.jupiter.params.aggregator.AggregateWith;
 import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 
@@ -158,6 +159,7 @@ import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
 @Retention(RetentionPolicy.RUNTIME)
 @Documented
 @API(status = EXPERIMENTAL, since = "5.13")
+@ClassTemplateInvocationLifecycleMethod(BeforeParameterizedClassInvocation.class)
 public @interface BeforeParameterizedClassInvocation {
 
 	/**
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java
index 31528072b..f73fff4e1 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedClassContext.java
@@ -12,15 +12,15 @@ package org.junit.jupiter.params;
 
 import static java.util.Collections.emptyList;
 import static java.util.Collections.reverse;
-import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD;
 import static org.junit.platform.commons.support.AnnotationSupport.findAnnotatedMethods;
+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;
 import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
 import static org.junit.platform.commons.support.HierarchyTraversalMode.BOTTOM_UP;
 import static org.junit.platform.commons.support.HierarchyTraversalMode.TOP_DOWN;
 import static org.junit.platform.commons.support.ReflectionSupport.findFields;
 import static org.junit.platform.commons.util.CollectionUtils.toUnmodifiableList;
 import static org.junit.platform.commons.util.ReflectionUtils.isRecordClass;
-import static org.junit.platform.commons.util.ReflectionUtils.returnsPrimitiveVoid;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
@@ -33,7 +33,6 @@ import org.junit.jupiter.api.TestInstance;
 import org.junit.jupiter.api.extension.ClassTemplateInvocationContext;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.platform.commons.JUnitException;
-import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.support.HierarchyTraversalMode;
 import org.junit.platform.commons.support.ModifierSupport;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -153,14 +152,12 @@ class ParameterizedClassContext implements ParameterizedDeclarationContext<Class
 			Class<?> testClass, TestInstance.Lifecycle testInstanceLifecycle, HierarchyTraversalMode traversalMode,
 			Class<A> annotationType, Predicate<A> injectArgumentsPredicate, ResolverFacade resolverFacade) {
 
-		List<Method> methods = findMethodsAndCheckVoidReturnTypeAndNonPrivate(testClass, annotationType, traversalMode);
+		List<Method> methods = findAnnotatedMethods(testClass, annotationType, traversalMode);
 
 		return methods.stream() //
-				.peek(method -> {
-					if (testInstanceLifecycle != PER_CLASS) {
-						assertStatic(annotationType, method);
-					}
-				}) //
+				.filter(ModifierSupport::isNotPrivate) //
+				.filter(testInstanceLifecycle == PER_METHOD ? ModifierSupport::isStatic : __ -> true) //
+				.filter(ReflectionUtils::returnsPrimitiveVoid) //
 				.map(method -> {
 					A annotation = getAnnotation(method, annotationType);
 					if (injectArgumentsPredicate.test(annotation)) {
@@ -173,43 +170,10 @@ class ParameterizedClassContext implements ParameterizedDeclarationContext<Class
 	}
 
 	private static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {
-		return AnnotationSupport.findAnnotation(method, annotationType) //
+		return findAnnotation(method, annotationType) //
 				.orElseThrow(() -> new JUnitException("Method not annotated with @" + annotationType.getSimpleName()));
 	}
 
-	private static List<Method> findMethodsAndCheckVoidReturnTypeAndNonPrivate(Class<?> testClass,
-			Class<? extends Annotation> annotationType, HierarchyTraversalMode traversalMode) {
-
-		List<Method> methods = findAnnotatedMethods(testClass, annotationType, traversalMode);
-		methods.forEach(method -> {
-			assertVoid(annotationType, method);
-			assertNonPrivate(annotationType, method);
-		});
-		return methods;
-	}
-
-	private static void assertStatic(Class<? extends Annotation> annotationType, Method method) {
-		if (ModifierSupport.isNotStatic(method)) {
-			throw new JUnitException(String.format(
-				"@%s method '%s' must be static unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS).",
-				annotationType.getSimpleName(), method.toGenericString()));
-		}
-	}
-
-	private static void assertVoid(Class<? extends Annotation> annotationType, Method method) {
-		if (!returnsPrimitiveVoid(method)) {
-			throw new JUnitException(String.format("@%s method '%s' must not return a value.",
-				annotationType.getSimpleName(), method.toGenericString()));
-		}
-	}
-
-	private static void assertNonPrivate(Class<? extends Annotation> annotationType, Method method) {
-		if (ModifierSupport.isPrivate(method)) {
-			throw new JUnitException(String.format("@%s method '%s' must not be private.",
-				annotationType.getSimpleName(), method.toGenericString()));
-		}
-	}
-
 	enum InjectionType {
 		CONSTRUCTOR, FIELDS
 	}
