diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index 8ec2b707..cfc92c5f 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -79,11 +79,6 @@ final class BehaviorCall<T> implements Call<T> {
           if (delaySleep()) {
             callback.onFailure(BehaviorCall.this, behavior.failureException());
           }
-        } else if (behavior.calculateIsError()) {
-          if (delaySleep()) {
-            //noinspection unchecked An error response has no body.
-            callback.onResponse(BehaviorCall.this, (Response<T>) behavior.createErrorResponse());
-          }
         } else {
           delegate.enqueue(new Callback<T>() {
             @Override public void onResponse(Call<T> call, Response<T> response) {
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 4a4721e6..49b490ae 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -16,8 +16,6 @@
 package retrofit2.mock;
 
 import java.io.IOException;
-import java.util.concurrent.Callable;
-import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -25,146 +23,75 @@ import retrofit2.Response;
 
 /** Factory methods for creating {@link Call} instances which immediately respond or fail. */
 public final class Calls {
-  /**
-   * Invokes {@code callable} once for the returned {@link Call} and once for each instance that is
-   * obtained from {@linkplain Call#clone() cloning} the returned {@link Call}.
-   */
-  public static <T> Call<T> defer(Callable<Call<T>> callable) {
-    return new DeferredCall<>(callable);
-  }
-
   public static <T> Call<T> response(T successValue) {
-    return new FakeCall<>(Response.success(successValue), null);
-  }
-
-  public static <T> Call<T> response(Response<T> response) {
-    return new FakeCall<>(response, null);
+    return response(Response.success(successValue));
   }
 
-  public static <T> Call<T> failure(IOException failure) {
-    return new FakeCall<>(null, failure);
-  }
-
-  private Calls() {
-    throw new AssertionError("No instances.");
-  }
-
-  static final class FakeCall<T> implements Call<T> {
-    private final Response<T> response;
-    private final IOException error;
-    private final AtomicBoolean canceled = new AtomicBoolean();
-    private final AtomicBoolean executed = new AtomicBoolean();
-
-    FakeCall(Response<T> response, IOException error) {
-      if ((response == null) == (error == null)) {
-        throw new AssertionError("Only one of response or error can be set.");
-      }
-      this.response = response;
-      this.error = error;
-    }
-
-    @Override public Response<T> execute() throws IOException {
-      if (!executed.compareAndSet(false, true)) {
-        throw new IllegalStateException("Already executed");
-      }
-      if (canceled.get()) {
-        throw new IOException("canceled");
-      }
-      if (response != null) {
+  public static <T> Call<T> response(final Response<T> response) {
+    return new Call<T>() {
+      @Override public Response<T> execute() throws IOException {
         return response;
       }
-      throw error;
-    }
 
-    @Override public void enqueue(Callback<T> callback) {
-      if (callback == null) {
-        throw new NullPointerException("callback == null");
-      }
-      if (!executed.compareAndSet(false, true)) {
-        throw new IllegalStateException("Already executed");
-      }
-      if (canceled.get()) {
-        callback.onFailure(this, new IOException("canceled"));
-      } else if (response != null) {
+      @Override public void enqueue(Callback<T> callback) {
         callback.onResponse(this, response);
-      } else {
-        callback.onFailure(this, error);
       }
-    }
 
-    @Override public boolean isExecuted() {
-      return executed.get();
-    }
+      @Override public boolean isExecuted() {
+        return false;
+      }
 
-    @Override public void cancel() {
-      canceled.set(true);
-    }
+      @Override public void cancel() {
+      }
 
-    @Override public boolean isCanceled() {
-      return canceled.get();
-    }
+      @Override public boolean isCanceled() {
+        return false;
+      }
 
-    @Override public Call<T> clone() {
-      return new FakeCall<>(response, error);
-    }
+      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+      @Override public Call<T> clone() {
+        return this;
+      }
 
-    @Override public Request request() {
-      if (response != null) {
+      @Override public Request request() {
         return response.raw().request();
       }
-      return new Request.Builder().url("http://localhost").build();
-    }
+    };
   }
 
-  static final class DeferredCall<T> implements Call<T> {
-    private final Callable<Call<T>> callable;
-    private Call<T> delegate;
-
-    DeferredCall(Callable<Call<T>> callable) {
-      this.callable = callable;
-    }
-
-    private synchronized Call<T> getDelegate() {
-      Call<T> delegate = this.delegate;
-      if (delegate == null) {
-        try {
-          delegate = callable.call();
-        } catch (IOException e) {
-          delegate = failure(e);
-        } catch (Exception e) {
-          throw new IllegalStateException("Callable threw unrecoverable exception", e);
-        }
-        this.delegate = delegate;
+  public static <T> Call<T> failure(final IOException failure) {
+    return new Call<T>() {
+      @Override public Response<T> execute() throws IOException {
+        throw failure;
       }
-      return delegate;
-    }
 
-    @Override public Response<T> execute() throws IOException {
-      return getDelegate().execute();
-    }
+      @Override public void enqueue(Callback<T> callback) {
+        callback.onFailure(this, failure);
+      }
 
-    @Override public void enqueue(Callback<T> callback) {
-      getDelegate().enqueue(callback);
-    }
+      @Override public boolean isExecuted() {
+        return false;
+      }
 
-    @Override public boolean isExecuted() {
-      return getDelegate().isExecuted();
-    }
+      @Override public void cancel() {
+      }
 
-    @Override public void cancel() {
-      getDelegate().cancel();
-    }
+      @Override public boolean isCanceled() {
+        return false;
+      }
 
-    @Override public boolean isCanceled() {
-      return getDelegate().isCanceled();
-    }
+      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
+      @Override public Call<T> clone() {
+        return this;
+      }
 
-    @Override public Call<T> clone() {
-      return new DeferredCall<>(callable);
-    }
+      @Override public Request request() {
+        return new Request.Builder().url("http://localhost").build();
+      }
+    };
+  }
 
-    @Override public Request request() {
-      return getDelegate().request();
-    }
+  private Calls() {
+    throw new AssertionError("No instances.");
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index 7cf521d4..8108c1d6 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -17,10 +17,7 @@ package retrofit2.mock;
 
 import java.io.IOException;
 import java.util.Random;
-import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
-import okhttp3.ResponseBody;
-import retrofit2.Response;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
@@ -43,7 +40,15 @@ public final class NetworkBehavior {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by Â±40%.
   private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
-  private static final int DEFAULT_ERROR_PERCENT = 0; // 0% of network calls will return errors.
+
+  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
+  public interface Adapter<T> {
+    /**
+     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
+     * traits when interacted with.
+     */
+    T applyBehavior(NetworkBehavior behavior, T value);
+  }
 
   /** Create an instance with default behavior. */
   public static NetworkBehavior create() {
@@ -65,12 +70,6 @@ public final class NetworkBehavior {
   private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
   private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
   private volatile Throwable failureException;
-  private volatile int errorPercent = DEFAULT_ERROR_PERCENT;
-  private volatile Callable<Response<?>> errorFactory = new Callable<Response<?>>() {
-    @Override public Response<?> call() {
-      return Response.error(500, ResponseBody.create(null, new byte[0]));
-    }
-  };
 
   private NetworkBehavior(Random random) {
     this.random = random;
@@ -121,14 +120,14 @@ public final class NetworkBehavior {
   /**
    * Set the exception to be used when a failure is triggered.
    * <p>
-   * It is a best practice to remove the stack trace from {@code exception} since it can
-   * misleadingly point to code unrelated to this class.
+   * It is a best practice to remove the stack trace from {@code t} since it can misleadingly
+   * point to code unrelated to this class.
    */
-  public void setFailureException(Throwable exception) {
-    if (exception == null) {
-      throw new NullPointerException("exception == null");
+  public void setFailureException(Throwable t) {
+    if (t == null) {
+      throw new NullPointerException("t == null");
     }
-    this.failureException = exception;
+    this.failureException = t;
   }
 
   /** The exception to be used when a failure is triggered. */
@@ -136,61 +135,13 @@ public final class NetworkBehavior {
     return failureException;
   }
 
-  /** The percentage of calls to {@link #calculateIsError()} that return {@code true}. */
-  public int errorPercent() {
-    return errorPercent;
-  }
-
-  /** Set the percentage of calls to {@link #calculateIsError()} that return {@code true}. */
-  public void setErrorPercent(int errorPercent) {
-    if (errorPercent < 0 || errorPercent > 100) {
-      throw new IllegalArgumentException("Error percentage must be between 0 and 100.");
-    }
-    this.errorPercent = errorPercent;
-  }
-
-  /**
-   * Set the error response factory to be used when an error is triggered. This factory may only
-   * return responses for which {@link Response#isSuccessful()} returns false.
-   */
-  public void setErrorFactory(Callable<Response<?>> errorFactory) {
-    if (errorFactory == null) {
-      throw new NullPointerException("errorFactory == null");
-    }
-    this.errorFactory = errorFactory;
-  }
-
-  /** The HTTP error to be used when an error is triggered. */
-  public Response<?> createErrorResponse() {
-    Response<?> call;
-    try {
-      call = errorFactory.call();
-    } catch (Exception e) {
-      throw new IllegalStateException("Error factory threw an exception.", e);
-    }
-    if (call == null) {
-      throw new IllegalStateException("Error factory returned null.");
-    }
-    if (call.isSuccessful()) {
-      throw new IllegalStateException("Error factory returned successful response.");
-    }
-    return call;
-  }
-
   /**
    * Randomly determine whether this call should result in a network failure in accordance with
    * configured behavior. When true, {@link #failureException()} should be thrown.
    */
   public boolean calculateIsFailure() {
-    return random.nextInt(100) < failurePercent;
-  }
-
-  /**
-   * Randomly determine whether this call should result in an HTTP error in accordance with
-   * configured behavior. When true, {@link #createErrorResponse()} should be returned.
-   */
-  public boolean calculateIsError() {
-    return random.nextInt(100) < errorPercent;
+    int randomValue = random.nextInt(100);
+    return randomValue < failurePercent;
   }
 
   /**
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index c332fad5..f0aa001d 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -110,6 +110,21 @@ abstract class ParameterHandler<T> {
     }
   }
 
+  static final class QueryName<T> extends ParameterHandler<T> {
+    private final Converter<T, String> nameConverter;
+    private final boolean encoded;
+
+    QueryName(Converter<T, String> nameConverter, boolean encoded) {
+      this.nameConverter = nameConverter;
+      this.encoded = encoded;
+    }
+
+    @Override void apply(RequestBuilder builder, T value) throws IOException {
+      if (value == null) return; // Skip null values.
+      builder.addQueryParam(nameConverter.convert(value), null, encoded);
+    }
+  }
+
   static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index 7765aba0..a32f8101 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -53,6 +53,7 @@ import retrofit2.http.PartMap;
 import retrofit2.http.Path;
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
+import retrofit2.http.QueryName;
 import retrofit2.http.Url;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
@@ -429,6 +430,35 @@ final class ServiceMethod<R, T> {
           return new ParameterHandler.Query<>(name, converter, encoded);
         }
 
+      } else if (annotation instanceof QueryName) {
+        QueryName query = (QueryName) annotation;
+        boolean encoded = query.encoded();
+
+        Class<?> rawParameterType = Utils.getRawType(type);
+        gotQuery = true;
+        if (Iterable.class.isAssignableFrom(rawParameterType)) {
+          if (!(type instanceof ParameterizedType)) {
+            throw parameterError(p, rawParameterType.getSimpleName()
+                + " must include generic type (e.g., "
+                + rawParameterType.getSimpleName()
+                + "<String>)");
+          }
+          ParameterizedType parameterizedType = (ParameterizedType) type;
+          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
+          Converter<?, String> converter =
+              retrofit.stringConverter(iterableType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
+        } else if (rawParameterType.isArray()) {
+          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
+          Converter<?, String> converter =
+              retrofit.stringConverter(arrayComponentType, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded).array();
+        } else {
+          Converter<?, String> converter =
+              retrofit.stringConverter(type, annotations);
+          return new ParameterHandler.QueryName<>(converter, encoded);
+        }
+
       } else if (annotation instanceof QueryMap) {
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 01d294f3..61479500 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -31,35 +31,36 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * <p>
  * Simple Example:
  * <pre><code>
- * &#64;GET("/list")
- * Call&lt;ResponseBody&gt; list(@Query("page") int page);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("page") int page);
  * </code></pre>
- * Calling with {@code foo.list(1)} yields {@code /list?page=1}.
+ * Calling with {@code foo.friends(1)} yields {@code /friends?page=1}.
  * <p>
  * Example with {@code null}:
  * <pre><code>
- * &#64;GET("/list")
- * Call&lt;ResponseBody&gt; list(@Query("category") String category);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String group);
  * </code></pre>
- * Calling with {@code foo.list(null)} yields {@code /list}.
+ * Calling with {@code foo.friends(null)} yields {@code /friends}.
  * <p>
  * Array/Varargs Example:
  * <pre><code>
- * &#64;GET("/list")
- * Call&lt;ResponseBody&gt; list(@Query("category") String... categories);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query("group") String... groups);
  * </code></pre>
- * Calling with {@code foo.list("bar", "baz")} yields
- * {@code /list?category=bar&category=baz}.
+ * Calling with {@code foo.friends("coworker", "bowling")} yields
+ * {@code /friends?group=coworker&group=bowling}.
  * <p>
  * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
  * to change this behavior.
  * <pre><code>
- * &#64;GET("/search")
- * Call&lt;ResponseBody&gt; list(@Query(value="foo", encoded=true) String foo);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@Query(value="group", encoded=true) String group);
  * </code></pre>
- * Calling with {@code foo.list("foo+bar"))} yields {@code /search?foo=foo+bar}.
+ * Calling with {@code foo.friends("foo+bar"))} yields {@code /friends?group=foo+bar}.
  *
  * @see QueryMap
+ * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 27e6ae83..119a5938 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -29,24 +29,25 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * <p>
  * Simple Example:
  * <pre><code>
- * &#64;GET("/search")
- * Call&lt;ResponseBody&gt; list(@QueryMap Map&lt;String, String&gt; filters);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap Map&lt;String, String&gt; filters);
  * </code></pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
- * {@code /search?foo=bar&kit=kat}.
+ * Calling with {@code foo.friends(ImmutableMap.of("group", "coworker", "age", "42"))} yields
+ * {@code /friends?group=coworker&age=42}.
  * <p>
  * Map keys and values representing parameter values are URL encoded by default. Specify
  * {@link #encoded() encoded=true} to change this behavior.
  * <pre><code>
- * &#64;GET("/search")
- * Call&lt;ResponseBody&gt; list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
  * </code></pre>
- * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+bar"))} yields
- * {@code /search?foo=foo+bar}.
+ * Calling with {@code foo.list(ImmutableMap.of("group", "coworker+bowling"))} yields
+ * {@code /search?group=coworker+bowling}.
  * <p>
  * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Query
+ * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryName.java b/retrofit/src/main/java/retrofit2/http/QueryName.java
new file mode 100644
index 00000000..5d6f0e94
--- /dev/null
+++ b/retrofit/src/main/java/retrofit2/http/QueryName.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.http;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.PARAMETER;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+/**
+ * Query parameter appended to the URL that has no value.
+ * <p>
+ * Passing a {@link java.util.List List} or array will result in a query parameter for each
+ * non-{@code null} item.
+ * <p>
+ * Simple Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)")} yields {@code /friends?contains(Bob)}.
+ * <p>
+ * Array/Varargs Example:
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName String... filters);
+ * </code></pre>
+ * Calling with {@code foo.friends("contains(Bob)", "age(42)")} yields
+ * {@code /friends?contains(Bob)&age(42)}.
+ * <p>
+ * Parameter names are URL encoded by default. Specify {@link #encoded() encoded=true} to change
+ * this behavior.
+ * <pre><code>
+ * &#64;GET("/friends")
+ * Call&lt;ResponseBody&gt; friends(@QueryName(encoded=true) String filter);
+ * </code></pre>
+ * Calling with {@code foo.friends("name+age"))} yields {@code /friends?name+age}.
+ *
+ * @see Query
+ * @see QueryMap
+ */
+@Documented
+@Target(PARAMETER)
+@Retention(RUNTIME)
+public @interface QueryName {
+  /**
+   * Specifies whether the parameter is already URL encoded.
+   */
+  boolean encoded() default false;
+}
