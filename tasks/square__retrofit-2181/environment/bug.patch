diff --git a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
index cfc92c5f..8ec2b707 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/BehaviorCall.java
@@ -79,6 +79,11 @@ final class BehaviorCall<T> implements Call<T> {
           if (delaySleep()) {
             callback.onFailure(BehaviorCall.this, behavior.failureException());
           }
+        } else if (behavior.calculateIsError()) {
+          if (delaySleep()) {
+            //noinspection unchecked An error response has no body.
+            callback.onResponse(BehaviorCall.this, (Response<T>) behavior.createErrorResponse());
+          }
         } else {
           delegate.enqueue(new Callback<T>() {
             @Override public void onResponse(Call<T> call, Response<T> response) {
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
index 49b490ae..4a4721e6 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/Calls.java
@@ -16,6 +16,8 @@
 package retrofit2.mock;
 
 import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicBoolean;
 import okhttp3.Request;
 import retrofit2.Call;
 import retrofit2.Callback;
@@ -23,75 +25,146 @@ import retrofit2.Response;
 
 /** Factory methods for creating {@link Call} instances which immediately respond or fail. */
 public final class Calls {
+  /**
+   * Invokes {@code callable} once for the returned {@link Call} and once for each instance that is
+   * obtained from {@linkplain Call#clone() cloning} the returned {@link Call}.
+   */
+  public static <T> Call<T> defer(Callable<Call<T>> callable) {
+    return new DeferredCall<>(callable);
+  }
+
   public static <T> Call<T> response(T successValue) {
-    return response(Response.success(successValue));
+    return new FakeCall<>(Response.success(successValue), null);
+  }
+
+  public static <T> Call<T> response(Response<T> response) {
+    return new FakeCall<>(response, null);
   }
 
-  public static <T> Call<T> response(final Response<T> response) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
+  public static <T> Call<T> failure(IOException failure) {
+    return new FakeCall<>(null, failure);
+  }
+
+  private Calls() {
+    throw new AssertionError("No instances.");
+  }
+
+  static final class FakeCall<T> implements Call<T> {
+    private final Response<T> response;
+    private final IOException error;
+    private final AtomicBoolean canceled = new AtomicBoolean();
+    private final AtomicBoolean executed = new AtomicBoolean();
+
+    FakeCall(Response<T> response, IOException error) {
+      if ((response == null) == (error == null)) {
+        throw new AssertionError("Only one of response or error can be set.");
+      }
+      this.response = response;
+      this.error = error;
+    }
+
+    @Override public Response<T> execute() throws IOException {
+      if (!executed.compareAndSet(false, true)) {
+        throw new IllegalStateException("Already executed");
+      }
+      if (canceled.get()) {
+        throw new IOException("canceled");
+      }
+      if (response != null) {
         return response;
       }
+      throw error;
+    }
 
-      @Override public void enqueue(Callback<T> callback) {
+    @Override public void enqueue(Callback<T> callback) {
+      if (callback == null) {
+        throw new NullPointerException("callback == null");
+      }
+      if (!executed.compareAndSet(false, true)) {
+        throw new IllegalStateException("Already executed");
+      }
+      if (canceled.get()) {
+        callback.onFailure(this, new IOException("canceled"));
+      } else if (response != null) {
         callback.onResponse(this, response);
+      } else {
+        callback.onFailure(this, error);
       }
+    }
 
-      @Override public boolean isExecuted() {
-        return false;
-      }
+    @Override public boolean isExecuted() {
+      return executed.get();
+    }
 
-      @Override public void cancel() {
-      }
+    @Override public void cancel() {
+      canceled.set(true);
+    }
 
-      @Override public boolean isCanceled() {
-        return false;
-      }
+    @Override public boolean isCanceled() {
+      return canceled.get();
+    }
 
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
+    @Override public Call<T> clone() {
+      return new FakeCall<>(response, error);
+    }
 
-      @Override public Request request() {
+    @Override public Request request() {
+      if (response != null) {
         return response.raw().request();
       }
-    };
+      return new Request.Builder().url("http://localhost").build();
+    }
   }
 
-  public static <T> Call<T> failure(final IOException failure) {
-    return new Call<T>() {
-      @Override public Response<T> execute() throws IOException {
-        throw failure;
+  static final class DeferredCall<T> implements Call<T> {
+    private final Callable<Call<T>> callable;
+    private Call<T> delegate;
+
+    DeferredCall(Callable<Call<T>> callable) {
+      this.callable = callable;
+    }
+
+    private synchronized Call<T> getDelegate() {
+      Call<T> delegate = this.delegate;
+      if (delegate == null) {
+        try {
+          delegate = callable.call();
+        } catch (IOException e) {
+          delegate = failure(e);
+        } catch (Exception e) {
+          throw new IllegalStateException("Callable threw unrecoverable exception", e);
+        }
+        this.delegate = delegate;
       }
+      return delegate;
+    }
 
-      @Override public void enqueue(Callback<T> callback) {
-        callback.onFailure(this, failure);
-      }
+    @Override public Response<T> execute() throws IOException {
+      return getDelegate().execute();
+    }
 
-      @Override public boolean isExecuted() {
-        return false;
-      }
+    @Override public void enqueue(Callback<T> callback) {
+      getDelegate().enqueue(callback);
+    }
 
-      @Override public void cancel() {
-      }
+    @Override public boolean isExecuted() {
+      return getDelegate().isExecuted();
+    }
 
-      @Override public boolean isCanceled() {
-        return false;
-      }
+    @Override public void cancel() {
+      getDelegate().cancel();
+    }
 
-      @SuppressWarnings("CloneDoesntCallSuperClone") // Immutable object.
-      @Override public Call<T> clone() {
-        return this;
-      }
+    @Override public boolean isCanceled() {
+      return getDelegate().isCanceled();
+    }
 
-      @Override public Request request() {
-        return new Request.Builder().url("http://localhost").build();
-      }
-    };
-  }
+    @Override public Call<T> clone() {
+      return new DeferredCall<>(callable);
+    }
 
-  private Calls() {
-    throw new AssertionError("No instances.");
+    @Override public Request request() {
+      return getDelegate().request();
+    }
   }
 }
diff --git a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
index 8108c1d6..7cf521d4 100644
--- a/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
+++ b/retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java
@@ -17,7 +17,10 @@ package retrofit2.mock;
 
 import java.io.IOException;
 import java.util.Random;
+import java.util.concurrent.Callable;
 import java.util.concurrent.TimeUnit;
+import okhttp3.ResponseBody;
+import retrofit2.Response;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 
@@ -40,15 +43,7 @@ public final class NetworkBehavior {
   private static final int DEFAULT_DELAY_MS = 2000; // Network calls will take 2 seconds.
   private static final int DEFAULT_VARIANCE_PERCENT = 40; // Network delay varies by Â±40%.
   private static final int DEFAULT_FAILURE_PERCENT = 3; // 3% of network calls will fail.
-
-  /** Applies {@link NetworkBehavior} to instances of {@code T}. */
-  public interface Adapter<T> {
-    /**
-     * Apply {@code behavior} to {@code value} so that it exhibits the configured network behavior
-     * traits when interacted with.
-     */
-    T applyBehavior(NetworkBehavior behavior, T value);
-  }
+  private static final int DEFAULT_ERROR_PERCENT = 0; // 0% of network calls will return errors.
 
   /** Create an instance with default behavior. */
   public static NetworkBehavior create() {
@@ -70,6 +65,12 @@ public final class NetworkBehavior {
   private volatile int variancePercent = DEFAULT_VARIANCE_PERCENT;
   private volatile int failurePercent = DEFAULT_FAILURE_PERCENT;
   private volatile Throwable failureException;
+  private volatile int errorPercent = DEFAULT_ERROR_PERCENT;
+  private volatile Callable<Response<?>> errorFactory = new Callable<Response<?>>() {
+    @Override public Response<?> call() {
+      return Response.error(500, ResponseBody.create(null, new byte[0]));
+    }
+  };
 
   private NetworkBehavior(Random random) {
     this.random = random;
@@ -120,14 +121,14 @@ public final class NetworkBehavior {
   /**
    * Set the exception to be used when a failure is triggered.
    * <p>
-   * It is a best practice to remove the stack trace from {@code t} since it can misleadingly
-   * point to code unrelated to this class.
+   * It is a best practice to remove the stack trace from {@code exception} since it can
+   * misleadingly point to code unrelated to this class.
    */
-  public void setFailureException(Throwable t) {
-    if (t == null) {
-      throw new NullPointerException("t == null");
+  public void setFailureException(Throwable exception) {
+    if (exception == null) {
+      throw new NullPointerException("exception == null");
     }
-    this.failureException = t;
+    this.failureException = exception;
   }
 
   /** The exception to be used when a failure is triggered. */
@@ -135,13 +136,61 @@ public final class NetworkBehavior {
     return failureException;
   }
 
+  /** The percentage of calls to {@link #calculateIsError()} that return {@code true}. */
+  public int errorPercent() {
+    return errorPercent;
+  }
+
+  /** Set the percentage of calls to {@link #calculateIsError()} that return {@code true}. */
+  public void setErrorPercent(int errorPercent) {
+    if (errorPercent < 0 || errorPercent > 100) {
+      throw new IllegalArgumentException("Error percentage must be between 0 and 100.");
+    }
+    this.errorPercent = errorPercent;
+  }
+
+  /**
+   * Set the error response factory to be used when an error is triggered. This factory may only
+   * return responses for which {@link Response#isSuccessful()} returns false.
+   */
+  public void setErrorFactory(Callable<Response<?>> errorFactory) {
+    if (errorFactory == null) {
+      throw new NullPointerException("errorFactory == null");
+    }
+    this.errorFactory = errorFactory;
+  }
+
+  /** The HTTP error to be used when an error is triggered. */
+  public Response<?> createErrorResponse() {
+    Response<?> call;
+    try {
+      call = errorFactory.call();
+    } catch (Exception e) {
+      throw new IllegalStateException("Error factory threw an exception.", e);
+    }
+    if (call == null) {
+      throw new IllegalStateException("Error factory returned null.");
+    }
+    if (call.isSuccessful()) {
+      throw new IllegalStateException("Error factory returned successful response.");
+    }
+    return call;
+  }
+
   /**
    * Randomly determine whether this call should result in a network failure in accordance with
    * configured behavior. When true, {@link #failureException()} should be thrown.
    */
   public boolean calculateIsFailure() {
-    int randomValue = random.nextInt(100);
-    return randomValue < failurePercent;
+    return random.nextInt(100) < failurePercent;
+  }
+
+  /**
+   * Randomly determine whether this call should result in an HTTP error in accordance with
+   * configured behavior. When true, {@link #createErrorResponse()} should be returned.
+   */
+  public boolean calculateIsError() {
+    return random.nextInt(100) < errorPercent;
   }
 
   /**
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
new file mode 100644
index 00000000..f32f4c4e
--- /dev/null
+++ b/retrofit-mock/src/test/java/retrofit2/mock/CallsTest.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit2.mock;
+
+import java.io.IOException;
+import java.util.concurrent.Callable;
+import java.util.concurrent.atomic.AtomicReference;
+import org.junit.Test;
+import retrofit2.Call;
+import retrofit2.Callback;
+import retrofit2.Response;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class CallsTest {
+  @Test public void bodyExecute() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    assertEquals("Taco", taco.execute().body());
+  }
+
+  @Test public void bodyEnqueue() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        fail();
+      }
+    });
+    assertThat(responseRef.get().body()).isEqualTo("Taco");
+  }
+
+  @Test public void responseExecute() throws IOException {
+    Response<String> response = Response.success("Taco");
+    Call<String> taco = Calls.response(response);
+    assertFalse(taco.isExecuted());
+    assertSame(response, taco.execute());
+    assertTrue(taco.isExecuted());
+    try {
+      taco.execute();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Already executed");
+    }
+  }
+
+  @Test public void responseEnqueue() {
+    Response<String> response = Response.success("Taco");
+    Call<String> taco = Calls.response(response);
+    assertFalse(taco.isExecuted());
+
+    final AtomicReference<Response<String>> responseRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        fail();
+      }
+    });
+    assertSame(response, responseRef.get());
+    assertTrue(taco.isExecuted());
+
+    try {
+      taco.enqueue(new Callback<String>() {
+        @Override public void onResponse(Call<String> call, Response<String> response) {
+          fail();
+        }
+
+        @Override public void onFailure(Call<String> call, Throwable t) {
+          fail();
+        }
+      });
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Already executed");
+    }
+  }
+
+  @Test public void enqueueNullThrows() {
+    Call<String> taco = Calls.response("Taco");
+    try {
+      taco.enqueue(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("callback == null");
+    }
+  }
+
+  @Test public void responseCancelExecute() {
+    Call<String> taco = Calls.response(Response.success("Taco"));
+    assertFalse(taco.isCanceled());
+    taco.cancel();
+    assertTrue(taco.isCanceled());
+
+    try {
+      taco.execute();
+      fail();
+    } catch (IOException e) {
+      assertThat(e).hasMessage("canceled");
+    }
+  }
+
+  @Test public void responseCancelEnqueue() throws IOException {
+    Call<String> taco = Calls.response(Response.success("Taco"));
+    assertFalse(taco.isCanceled());
+    taco.cancel();
+    assertTrue(taco.isCanceled());
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    taco.enqueue(new Callback<String>() {
+      @Override public void onResponse(Call<String> call, Response<String> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<String> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertThat(failureRef.get()).isInstanceOf(IOException.class).hasMessage("canceled");
+  }
+
+  @Test public void failureExecute() {
+    IOException failure = new IOException("Hey");
+    Call<Object> taco = Calls.failure(failure);
+    assertFalse(taco.isExecuted());
+    try {
+      taco.execute();
+      fail();
+    } catch (IOException e) {
+      assertSame(failure, e);
+    }
+    assertTrue(taco.isExecuted());
+  }
+
+  @Test public void failureEnqueue() {
+    IOException failure = new IOException("Hey");
+    Call<Object> taco = Calls.failure(failure);
+    assertFalse(taco.isExecuted());
+
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    taco.enqueue(new Callback<Object>() {
+      @Override public void onResponse(Call<Object> call, Response<Object> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<Object> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertSame(failure, failureRef.get());
+    assertTrue(taco.isExecuted());
+  }
+
+  @Test public void cloneHasOwnState() throws IOException {
+    Call<String> taco = Calls.response("Taco");
+    assertEquals("Taco", taco.execute().body());
+    Call<String> anotherTaco = taco.clone();
+    assertFalse(anotherTaco.isExecuted());
+    assertEquals("Taco", anotherTaco.execute().body());
+    assertTrue(anotherTaco.isExecuted());
+  }
+
+  @Test public void deferredReturnExecute() throws IOException {
+    Call<Integer> counts = Calls.defer(new Callable<Call<Integer>>() {
+      private int count = 0;
+
+      @Override public Call<Integer> call() throws Exception {
+        return Calls.response(++count);
+      }
+    });
+    Call<Integer> a = counts.clone();
+    Call<Integer> b = counts.clone();
+
+    assertEquals(1, b.execute().body().intValue());
+    assertEquals(2, a.execute().body().intValue());
+  }
+
+  @Test public void deferredReturnEnqueue() {
+    Call<Integer> counts = Calls.defer(new Callable<Call<Integer>>() {
+      private int count = 0;
+
+      @Override public Call<Integer> call() throws Exception {
+        return Calls.response(++count);
+      }
+    });
+    Call<Integer> a = counts.clone();
+    Call<Integer> b = counts.clone();
+
+    final AtomicReference<Response<Integer>> responseRef = new AtomicReference<>();
+    Callback<Integer> callback = new Callback<Integer>() {
+      @Override public void onResponse(Call<Integer> call, Response<Integer> response) {
+        responseRef.set(response);
+      }
+
+      @Override public void onFailure(Call<Integer> call, Throwable t) {
+        fail();
+      }
+    };
+    b.enqueue(callback);
+    assertEquals(1, responseRef.get().body().intValue());
+
+    a.enqueue(callback);
+    assertEquals(2, responseRef.get().body().intValue());
+  }
+
+  @Test public void deferredThrowExecute() throws IOException {
+    final IOException failure = new IOException("Hey");
+    Call<Object> failing = Calls.defer(new Callable<Call<Object>>() {
+      @Override public Call<Object> call() throws Exception {
+        throw failure;
+      }
+    });
+    try {
+      failing.execute();
+      fail();
+    } catch (IOException e) {
+      assertSame(failure, e);
+    }
+  }
+
+  @Test public void deferredThrowEnqueue() {
+    final IOException failure = new IOException("Hey");
+    Call<Object> failing = Calls.defer(new Callable<Call<Object>>() {
+      @Override public Call<Object> call() throws Exception {
+        throw failure;
+      }
+    });
+    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
+    failing.enqueue(new Callback<Object>() {
+      @Override public void onResponse(Call<Object> call, Response<Object> response) {
+        fail();
+      }
+
+      @Override public void onFailure(Call<Object> call, Throwable t) {
+        failureRef.set(t);
+      }
+    });
+    assertSame(failure, failureRef.get());
+  }
+}
diff --git a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
index 18073782..300d5713 100644
--- a/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
+++ b/retrofit-mock/src/test/java/retrofit2/mock/NetworkBehaviorTest.java
@@ -17,11 +17,15 @@ package retrofit2.mock;
 
 import java.io.IOException;
 import java.util.Random;
+import java.util.concurrent.Callable;
+import okhttp3.ResponseBody;
 import org.junit.Test;
+import retrofit2.Response;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class NetworkBehaviorTest {
@@ -72,6 +76,97 @@ public final class NetworkBehaviorTest {
     }
   }
 
+  @Test public void failureExceptionIsNotNull() {
+    try {
+      behavior.setFailureException(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("exception == null");
+    }
+  }
+
+  @Test public void errorRestrictsRange() {
+    try {
+      behavior.setErrorPercent(-13);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+    try {
+      behavior.setErrorPercent(174);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("Error percentage must be between 0 and 100.");
+    }
+  }
+
+  @Test public void errorFactoryIsNotNull() {
+    try {
+      behavior.setErrorFactory(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessage("errorFactory == null");
+    }
+  }
+
+  @Test public void errorFactoryCannotReturnNull() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        return null;
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory returned null.");
+    }
+  }
+
+  @Test public void errorFactoryCannotThrow() {
+    final RuntimeException broken = new RuntimeException("Broken");
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        throw broken;
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory threw an exception.");
+      assertThat(e.getCause()).isSameAs(broken);
+    }
+  }
+
+  @Test public void errorFactoryCannotReturnSuccess() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      @Override public Response<?> call() throws Exception {
+        return Response.success("Taco");
+      }
+    });
+    try {
+      behavior.createErrorResponse();
+      fail();
+    } catch (IllegalStateException e) {
+      assertThat(e).hasMessage("Error factory returned successful response.");
+    }
+  }
+
+  @Test public void errorFactoryCalledEachTime() {
+    behavior.setErrorFactory(new Callable<Response<?>>() {
+      private int code = 500;
+
+      @Override public Response<?> call() throws Exception {
+        return Response.error(code++, ResponseBody.create(null, new byte[0]));
+      }
+    });
+
+    assertEquals(500, behavior.createErrorResponse().code());
+    assertEquals(501, behavior.createErrorResponse().code());
+    assertEquals(502, behavior.createErrorResponse().code());
+  }
+
   @Test public void failurePercentageIsAccurate() {
     behavior.setFailurePercent(0);
     for (int i = 0; i < 10000; i++) {
@@ -88,6 +183,22 @@ public final class NetworkBehaviorTest {
     assertThat(failures).isEqualTo(2964); // ~3% of 100k
   }
 
+  @Test public void errorPercentageIsAccurate() {
+    behavior.setErrorPercent(0);
+    for (int i = 0; i < 10000; i++) {
+      assertThat(behavior.calculateIsError()).isFalse();
+    }
+
+    behavior.setErrorPercent(3);
+    int errors = 0;
+    for (int i = 0; i < 100000; i++) {
+      if (behavior.calculateIsError()) {
+        errors += 1;
+      }
+    }
+    assertThat(errors).isEqualTo(2964); // ~3% of 100k
+  }
+
   @Test public void delayVarianceIsAccurate() {
     behavior.setDelay(2, SECONDS);
 
diff --git a/retrofit/src/main/java/retrofit2/ParameterHandler.java b/retrofit/src/main/java/retrofit2/ParameterHandler.java
index f0aa001d..c332fad5 100644
--- a/retrofit/src/main/java/retrofit2/ParameterHandler.java
+++ b/retrofit/src/main/java/retrofit2/ParameterHandler.java
@@ -110,21 +110,6 @@ abstract class ParameterHandler<T> {
     }
   }
 
-  static final class QueryName<T> extends ParameterHandler<T> {
-    private final Converter<T, String> nameConverter;
-    private final boolean encoded;
-
-    QueryName(Converter<T, String> nameConverter, boolean encoded) {
-      this.nameConverter = nameConverter;
-      this.encoded = encoded;
-    }
-
-    @Override void apply(RequestBuilder builder, T value) throws IOException {
-      if (value == null) return; // Skip null values.
-      builder.addQueryParam(nameConverter.convert(value), null, encoded);
-    }
-  }
-
   static final class QueryMap<T> extends ParameterHandler<Map<String, T>> {
     private final Converter<T, String> valueConverter;
     private final boolean encoded;
diff --git a/retrofit/src/main/java/retrofit2/ServiceMethod.java b/retrofit/src/main/java/retrofit2/ServiceMethod.java
index a32f8101..7765aba0 100644
--- a/retrofit/src/main/java/retrofit2/ServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/ServiceMethod.java
@@ -53,7 +53,6 @@ import retrofit2.http.PartMap;
 import retrofit2.http.Path;
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
-import retrofit2.http.QueryName;
 import retrofit2.http.Url;
 
 /** Adapts an invocation of an interface method into an HTTP call. */
@@ -430,35 +429,6 @@ final class ServiceMethod<R, T> {
           return new ParameterHandler.Query<>(name, converter, encoded);
         }
 
-      } else if (annotation instanceof QueryName) {
-        QueryName query = (QueryName) annotation;
-        boolean encoded = query.encoded();
-
-        Class<?> rawParameterType = Utils.getRawType(type);
-        gotQuery = true;
-        if (Iterable.class.isAssignableFrom(rawParameterType)) {
-          if (!(type instanceof ParameterizedType)) {
-            throw parameterError(p, rawParameterType.getSimpleName()
-                + " must include generic type (e.g., "
-                + rawParameterType.getSimpleName()
-                + "<String>)");
-          }
-          ParameterizedType parameterizedType = (ParameterizedType) type;
-          Type iterableType = Utils.getParameterUpperBound(0, parameterizedType);
-          Converter<?, String> converter =
-              retrofit.stringConverter(iterableType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).iterable();
-        } else if (rawParameterType.isArray()) {
-          Class<?> arrayComponentType = boxIfPrimitive(rawParameterType.getComponentType());
-          Converter<?, String> converter =
-              retrofit.stringConverter(arrayComponentType, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded).array();
-        } else {
-          Converter<?, String> converter =
-              retrofit.stringConverter(type, annotations);
-          return new ParameterHandler.QueryName<>(converter, encoded);
-        }
-
       } else if (annotation instanceof QueryMap) {
         Class<?> rawParameterType = Utils.getRawType(type);
         if (!Map.class.isAssignableFrom(rawParameterType)) {
diff --git a/retrofit/src/main/java/retrofit2/http/Query.java b/retrofit/src/main/java/retrofit2/http/Query.java
index 61479500..01d294f3 100644
--- a/retrofit/src/main/java/retrofit2/http/Query.java
+++ b/retrofit/src/main/java/retrofit2/http/Query.java
@@ -31,36 +31,35 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * <p>
  * Simple Example:
  * <pre><code>
- * &#64;GET("/friends")
- * Call&lt;ResponseBody&gt; friends(@Query("page") int page);
+ * &#64;GET("/list")
+ * Call&lt;ResponseBody&gt; list(@Query("page") int page);
  * </code></pre>
- * Calling with {@code foo.friends(1)} yields {@code /friends?page=1}.
+ * Calling with {@code foo.list(1)} yields {@code /list?page=1}.
  * <p>
  * Example with {@code null}:
  * <pre><code>
- * &#64;GET("/friends")
- * Call&lt;ResponseBody&gt; friends(@Query("group") String group);
+ * &#64;GET("/list")
+ * Call&lt;ResponseBody&gt; list(@Query("category") String category);
  * </code></pre>
- * Calling with {@code foo.friends(null)} yields {@code /friends}.
+ * Calling with {@code foo.list(null)} yields {@code /list}.
  * <p>
  * Array/Varargs Example:
  * <pre><code>
- * &#64;GET("/friends")
- * Call&lt;ResponseBody&gt; friends(@Query("group") String... groups);
+ * &#64;GET("/list")
+ * Call&lt;ResponseBody&gt; list(@Query("category") String... categories);
  * </code></pre>
- * Calling with {@code foo.friends("coworker", "bowling")} yields
- * {@code /friends?group=coworker&group=bowling}.
+ * Calling with {@code foo.list("bar", "baz")} yields
+ * {@code /list?category=bar&category=baz}.
  * <p>
  * Parameter names and values are URL encoded by default. Specify {@link #encoded() encoded=true}
  * to change this behavior.
  * <pre><code>
- * &#64;GET("/friends")
- * Call&lt;ResponseBody&gt; friends(@Query(value="group", encoded=true) String group);
+ * &#64;GET("/search")
+ * Call&lt;ResponseBody&gt; list(@Query(value="foo", encoded=true) String foo);
  * </code></pre>
- * Calling with {@code foo.friends("foo+bar"))} yields {@code /friends?group=foo+bar}.
+ * Calling with {@code foo.list("foo+bar"))} yields {@code /search?foo=foo+bar}.
  *
  * @see QueryMap
- * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryMap.java b/retrofit/src/main/java/retrofit2/http/QueryMap.java
index 119a5938..27e6ae83 100644
--- a/retrofit/src/main/java/retrofit2/http/QueryMap.java
+++ b/retrofit/src/main/java/retrofit2/http/QueryMap.java
@@ -29,25 +29,24 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
  * <p>
  * Simple Example:
  * <pre><code>
- * &#64;GET("/friends")
- * Call&lt;ResponseBody&gt; friends(@QueryMap Map&lt;String, String&gt; filters);
+ * &#64;GET("/search")
+ * Call&lt;ResponseBody&gt; list(@QueryMap Map&lt;String, String&gt; filters);
  * </code></pre>
- * Calling with {@code foo.friends(ImmutableMap.of("group", "coworker", "age", "42"))} yields
- * {@code /friends?group=coworker&age=42}.
+ * Calling with {@code foo.list(ImmutableMap.of("foo", "bar", "kit", "kat"))} yields
+ * {@code /search?foo=bar&kit=kat}.
  * <p>
  * Map keys and values representing parameter values are URL encoded by default. Specify
  * {@link #encoded() encoded=true} to change this behavior.
  * <pre><code>
- * &#64;GET("/friends")
- * Call&lt;ResponseBody&gt; friends(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
+ * &#64;GET("/search")
+ * Call&lt;ResponseBody&gt; list(@QueryMap(encoded=true) Map&lt;String, String&gt; filters);
  * </code></pre>
- * Calling with {@code foo.list(ImmutableMap.of("group", "coworker+bowling"))} yields
- * {@code /search?group=coworker+bowling}.
+ * Calling with {@code foo.list(ImmutableMap.of("foo", "foo+bar"))} yields
+ * {@code /search?foo=foo+bar}.
  * <p>
  * A {@code null} value for the map, as a key, or as a value is not allowed.
  *
  * @see Query
- * @see QueryName
  */
 @Documented
 @Target(PARAMETER)
diff --git a/retrofit/src/main/java/retrofit2/http/QueryName.java b/retrofit/src/main/java/retrofit2/http/QueryName.java
deleted file mode 100644
index 5d6f0e94..00000000
--- a/retrofit/src/main/java/retrofit2/http/QueryName.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package retrofit2.http;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-import static java.lang.annotation.ElementType.PARAMETER;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-/**
- * Query parameter appended to the URL that has no value.
- * <p>
- * Passing a {@link java.util.List List} or array will result in a query parameter for each
- * non-{@code null} item.
- * <p>
- * Simple Example:
- * <pre><code>
- * &#64;GET("/friends")
- * Call&lt;ResponseBody&gt; friends(@QueryName String filter);
- * </code></pre>
- * Calling with {@code foo.friends("contains(Bob)")} yields {@code /friends?contains(Bob)}.
- * <p>
- * Array/Varargs Example:
- * <pre><code>
- * &#64;GET("/friends")
- * Call&lt;ResponseBody&gt; friends(@QueryName String... filters);
- * </code></pre>
- * Calling with {@code foo.friends("contains(Bob)", "age(42)")} yields
- * {@code /friends?contains(Bob)&age(42)}.
- * <p>
- * Parameter names are URL encoded by default. Specify {@link #encoded() encoded=true} to change
- * this behavior.
- * <pre><code>
- * &#64;GET("/friends")
- * Call&lt;ResponseBody&gt; friends(@QueryName(encoded=true) String filter);
- * </code></pre>
- * Calling with {@code foo.friends("name+age"))} yields {@code /friends?name+age}.
- *
- * @see Query
- * @see QueryMap
- */
-@Documented
-@Target(PARAMETER)
-@Retention(RUNTIME)
-public @interface QueryName {
-  /**
-   * Specifies whether the parameter is already URL encoded.
-   */
-  boolean encoded() default false;
-}
diff --git a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
index a2ef1376..0f3b5ebe 100644
--- a/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
+++ b/retrofit/src/test/java/retrofit2/RequestBuilderTest.java
@@ -57,7 +57,6 @@ import retrofit2.http.PartMap;
 import retrofit2.http.Path;
 import retrofit2.http.Query;
 import retrofit2.http.QueryMap;
-import retrofit2.http.QueryName;
 import retrofit2.http.Url;
 
 import static org.assertj.core.api.Assertions.assertThat;
@@ -1060,11 +1059,11 @@ public final class RequestBuilderTest {
       }
     }
 
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three", "1");
+    List<Object> values = Arrays.<Object>asList(1, 2, null, "three");
     Request request = buildRequest(Example.class, values);
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three&key=1");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
     assertThat(request.body()).isNull();
   }
 
@@ -1076,11 +1075,11 @@ public final class RequestBuilderTest {
       }
     }
 
-    Object[] values = { 1, 2, null, "three", "1" };
+    Object[] values = { 1, 2, null, "three" };
     Request request = buildRequest(Example.class, new Object[] { values });
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three&key=1");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=three");
     assertThat(request.body()).isNull();
   }
 
@@ -1092,98 +1091,11 @@ public final class RequestBuilderTest {
       }
     }
 
-    int[] values = { 1, 2, 3, 1 };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3&key=1");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryNameParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryName String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "pong");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?pong");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithEncodedQueryNameParam() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryName(encoded = true) String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, "p%20o%20n%20g");
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?p%20o%20n%20g");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void queryNameParamOptionalOmitsQuery() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryName String ping) {
-        return null;
-      }
-    }
-    Request request = buildRequest(Example.class, new Object[] { null });
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/");
-  }
-
-  @Test public void getWithQueryNameParamList() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryName List<Object> keys) {
-        return null;
-      }
-    }
-
-    List<Object> values = Arrays.<Object>asList(1, 2, null, "three", "1");
-    Request request = buildRequest(Example.class, values);
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&three&1");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryNameParamArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryName Object[] keys) {
-        return null;
-      }
-    }
-
-    Object[] values = { 1, 2, null, "three", "1" };
-    Request request = buildRequest(Example.class, new Object[] { values });
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&three&1");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void getWithQueryNameParamPrimitiveArray() {
-    class Example {
-      @GET("/foo/bar/") //
-      Call<ResponseBody> method(@QueryName int[] keys) {
-        return null;
-      }
-    }
-
-    int[] values = { 1, 2, 3, 1 };
+    int[] values = { 1, 2, 3 };
     Request request = buildRequest(Example.class, new Object[] { values });
     assertThat(request.method()).isEqualTo("GET");
     assertThat(request.headers().size()).isZero();
-    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?1&2&3&1");
+    assertThat(request.url().toString()).isEqualTo("http://example.com/foo/bar/?key=1&key=2&key=3");
     assertThat(request.body()).isNull();
   }
 
