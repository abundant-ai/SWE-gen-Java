diff --git a/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java b/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java
index b3bd07442..73dab853d 100644
--- a/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java
+++ b/src/main/java/org/mockito/internal/stubbing/BaseStubbing.java
@@ -7,10 +7,11 @@ package org.mockito.internal.stubbing;
 import static org.mockito.internal.exceptions.Reporter.notAnException;
 import static org.mockito.internal.progress.ThreadSafeMockingProgress.mockingProgress;
 
+import org.mockito.creation.instance.Instantiator;
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.stubbing.answers.CallsRealMethods;
 import org.mockito.internal.stubbing.answers.Returns;
 import org.mockito.internal.stubbing.answers.ThrowsException;
-import org.mockito.internal.stubbing.answers.ThrowsExceptionForClassType;
 import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.OngoingStubbing;
 
@@ -74,7 +75,8 @@ public abstract class BaseStubbing<T> implements OngoingStubbing<T> {
             mockingProgress().reset();
             throw notAnException();
         }
-        return thenAnswer(new ThrowsExceptionForClassType(throwableType));
+        Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(null);
+        return thenThrow(instantiator.newInstance(throwableType));
     }
 
     @Override
diff --git a/src/main/java/org/mockito/internal/stubbing/StubberImpl.java b/src/main/java/org/mockito/internal/stubbing/StubberImpl.java
index 3f37af64b..d707cf8b3 100644
--- a/src/main/java/org/mockito/internal/stubbing/StubberImpl.java
+++ b/src/main/java/org/mockito/internal/stubbing/StubberImpl.java
@@ -14,10 +14,10 @@ import static org.mockito.internal.util.MockUtil.isMock;
 import java.util.LinkedList;
 import java.util.List;
 
+import org.mockito.internal.configuration.plugins.Plugins;
 import org.mockito.internal.stubbing.answers.CallsRealMethods;
 import org.mockito.internal.stubbing.answers.Returns;
 import org.mockito.internal.stubbing.answers.ThrowsException;
-import org.mockito.internal.stubbing.answers.ThrowsExceptionForClassType;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.quality.Strictness;
 import org.mockito.stubbing.Answer;
@@ -89,7 +89,18 @@ public class StubberImpl implements Stubber {
             mockingProgress().reset();
             throw notAnException();
         }
-        return doAnswer(new ThrowsExceptionForClassType(toBeThrown));
+        Throwable e = null;
+        try {
+            e = Plugins.getInstantiatorProvider().getInstantiator(null).newInstance(toBeThrown);
+        } finally {
+            if (e == null) {
+                //this means that an exception or error was thrown when trying to create new instance
+                //we don't want 'catch' statement here because we want the exception to be thrown to the user
+                //however, we do want to clean up state (e.g. "stubbing started").
+                mockingProgress().reset();
+            }
+        }
+        return doThrow(e);
     }
 
     @Override
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/AbstractThrowsException.java b/src/main/java/org/mockito/internal/stubbing/answers/AbstractThrowsException.java
deleted file mode 100644
index 47bf6d669..000000000
--- a/src/main/java/org/mockito/internal/stubbing/answers/AbstractThrowsException.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2020 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.stubbing.answers;
-
-import static org.mockito.internal.exceptions.Reporter.cannotStubWithNullThrowable;
-import static org.mockito.internal.exceptions.Reporter.checkedExceptionInvalid;
-
-import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
-import org.mockito.internal.util.MockUtil;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-import org.mockito.stubbing.ValidableAnswer;
-
-public abstract class AbstractThrowsException implements Answer<Object>, ValidableAnswer {
-
-    private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
-
-    protected abstract Throwable getThrowable();
-
-    public Object answer(InvocationOnMock invocation) throws Throwable {
-        Throwable throwable = getThrowable();
-        if (throwable == null) {
-            throw new IllegalStateException("throwable is null: " +
-                "you shall not call #answer if #validateFor fails!");
-        }
-        if (MockUtil.isMock(throwable)) {
-            throw throwable;
-        }
-        Throwable t = throwable.fillInStackTrace();
-
-        if (t == null) {
-            //Custom exceptions sometimes return null, see #866
-            throw throwable;
-        }
-        filter.filter(t);
-        throw t;
-    }
-
-    @Override
-    public void validateFor(InvocationOnMock invocation) {
-        Throwable throwable = getThrowable();
-        if (throwable == null) {
-            throw cannotStubWithNullThrowable();
-        }
-
-        if (throwable instanceof RuntimeException || throwable instanceof Error) {
-            return;
-        }
-
-        if (!new InvocationInfo(invocation).isValidException(throwable)) {
-            throw checkedExceptionInvalid(throwable);
-        }
-    }
-}
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/ThrowsException.java b/src/main/java/org/mockito/internal/stubbing/answers/ThrowsException.java
index 1250a8888..bc1b987f3 100644
--- a/src/main/java/org/mockito/internal/stubbing/answers/ThrowsException.java
+++ b/src/main/java/org/mockito/internal/stubbing/answers/ThrowsException.java
@@ -4,19 +4,25 @@
  */
 package org.mockito.internal.stubbing.answers;
 
+import static org.mockito.internal.exceptions.Reporter.cannotStubWithNullThrowable;
+import static org.mockito.internal.exceptions.Reporter.checkedExceptionInvalid;
 
 import java.io.Serializable;
 
+import org.mockito.internal.exceptions.stacktrace.ConditionalStackTraceFilter;
+import org.mockito.internal.util.MockUtil;
 import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
 import org.mockito.stubbing.ValidableAnswer;
 
 /**
  * An answer that always throws the same throwable.
  */
-public class ThrowsException extends AbstractThrowsException implements Serializable {
+public class ThrowsException implements Answer<Object>, ValidableAnswer, Serializable {
 
     private static final long serialVersionUID = 1128820328555183980L;
     private final Throwable throwable;
+    private final ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();
 
     /**
      * Creates a new answer always throwing the given throwable. If it is null,
@@ -27,9 +33,36 @@ public class ThrowsException extends AbstractThrowsException implements Serializ
         this.throwable = throwable;
     }
 
-    @Override
-    protected Throwable getThrowable() {
-        return throwable;
+    public Object answer(InvocationOnMock invocation) throws Throwable {
+        if (throwable == null) {
+            throw new IllegalStateException("throwable is null: " +
+                "you shall not call #answer if #validateFor fails!");
+        }
+        if (MockUtil.isMock(throwable)) {
+            throw throwable;
+        }
+        Throwable t = throwable.fillInStackTrace();
+
+        if (t == null) {
+            //Custom exceptions sometimes return null, see #866
+            throw throwable;
+        }
+        filter.filter(t);
+        throw t;
     }
 
+    @Override
+    public void validateFor(InvocationOnMock invocation) {
+        if (throwable == null) {
+            throw cannotStubWithNullThrowable();
+        }
+
+        if (throwable instanceof RuntimeException || throwable instanceof Error) {
+            return;
+        }
+
+        if (!new InvocationInfo(invocation).isValidException(throwable)) {
+            throw checkedExceptionInvalid(throwable);
+        }
+    }
 }
diff --git a/src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassType.java b/src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassType.java
deleted file mode 100644
index 2c3d92395..000000000
--- a/src/main/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassType.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (c) 2020 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.stubbing.answers;
-
-import java.io.Serializable;
-
-import org.mockito.creation.instance.Instantiator;
-import org.mockito.internal.configuration.plugins.Plugins;
-
-public class ThrowsExceptionForClassType extends AbstractThrowsException implements Serializable {
-
-    private final Class<? extends Throwable> throwableClass;
-
-    public ThrowsExceptionForClassType(Class<? extends Throwable> throwableClass) {
-        this.throwableClass = throwableClass;
-    }
-
-    @Override
-    protected Throwable getThrowable() {
-        Instantiator instantiator = Plugins.getInstantiatorProvider().getInstantiator(null);
-        return instantiator.newInstance(throwableClass);
-    }
-}
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/AbstractThrowsExceptionTest.java b/src/test/java/org/mockito/internal/stubbing/answers/AbstractThrowsExceptionTest.java
deleted file mode 100644
index 8fa4d86f5..000000000
--- a/src/test/java/org/mockito/internal/stubbing/answers/AbstractThrowsExceptionTest.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (c) 2020 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.stubbing.answers;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
-import static org.mockito.Mockito.mock;
-import static org.mockito.internal.exceptions.Reporter.cannotStubWithNullThrowable;
-import static org.mockito.internal.exceptions.Reporter.checkedExceptionInvalid;
-
-import java.io.IOException;
-import java.nio.charset.CharacterCodingException;
-
-import org.assertj.core.api.Assertions;
-import org.junit.Test;
-import org.mockito.exceptions.base.MockitoException;
-import org.mockito.internal.invocation.InvocationBuilder;
-import org.mockito.invocation.Invocation;
-
-public class AbstractThrowsExceptionTest {
-
-    @Test
-    public void should_raise_wanted_throwable() {
-        Throwable expected = new Exception();
-        AbstractThrowsException ate = instantiateFixture(expected);
-
-        Throwable throwable = Assertions.catchThrowable(() -> ate.answer(createMethodInvocation()));
-        assertNotNull("Should have raised an exception.", throwable);
-        assertSame(expected, throwable);
-    }
-
-    @Test
-    public void should_throw_mock_exception_without_stacktrace() {
-        AbstractThrowsException ate = instantiateFixture(mock(Exception.class));
-
-        Throwable throwable = Assertions.catchThrowable(() -> ate.answer(createMethodInvocation()));
-        assertNotNull("Should have raised an exception.", throwable);
-        assertThat(throwable.getStackTrace()).describedAs("no stack trace, it's mock").isNull();
-    }
-
-    @Test
-    public void should_fill_in_exception_stacktrace() {
-        AbstractThrowsException ate = instantiateFixture(new Exception());
-
-        Throwable throwable = Assertions.catchThrowable(() -> ate.answer(createMethodInvocation()));
-        assertNotNull("Should have raised an exception.", throwable);
-        assertThat(throwable.getStackTrace()[0].getClassName()).isEqualTo(AbstractThrowsException.class.getName());
-        assertThat(throwable.getStackTrace()[0].getMethodName()).isEqualTo("answer");
-    }
-
-    @Test
-    public void should_invalidate_null_throwable() {
-        AbstractThrowsException ate = instantiateFixture(null);
-
-        Throwable throwable = Assertions.catchThrowableOfType(() -> ate.validateFor(createMethodInvocation()),
-                                                              MockitoException.class);
-        assertNotNull("Should have raised a MockitoException.", throwable);
-        assertEquals(cannotStubWithNullThrowable().getMessage(), throwable.getMessage());
-    }
-
-    @Test
-    public void should_throw_illegal_state_exception_if_null_answer() {
-        AbstractThrowsException ate = instantiateFixture(null);
-
-        Throwable throwable = Assertions.catchThrowableOfType(() -> ate.answer(createMethodInvocation()),
-                                                              IllegalStateException.class);
-        assertNotNull("Should have raised a IllegalStateException.", throwable);
-        assertEquals("throwable is null: you shall not call #answer if #validateFor fails!", throwable.getMessage());
-    }
-
-    @Test
-    public void should_pass_proper_checked_exception() {
-        instantiateFixture(new CharacterCodingException()).validateFor(createMethodInvocation());
-    }
-
-    @Test
-    public void should_fail_invalid_checked_exception() {
-        AbstractThrowsException ate = instantiateFixture(new IOException());
-        Throwable comparison = ate.getThrowable();
-
-        Throwable throwable = Assertions.catchThrowableOfType(() -> ate.validateFor(createMethodInvocation()),
-                                                              MockitoException.class);
-        assertNotNull("Should have raised a MockitoException.", throwable);
-        assertEquals(checkedExceptionInvalid(comparison).getMessage(), throwable.getMessage());
-    }
-
-    @Test
-    public void should_pass_RuntimeException() {
-        instantiateFixture(new RuntimeException()).validateFor(createMethodInvocation());
-    }
-
-    @Test
-    public void should_pass_Error() {
-        instantiateFixture(new Error()).validateFor(createMethodInvocation());
-    }
-
-    /** Creates a fixture for AbstractThrowsException that returns the given Throwable. */
-    private static AbstractThrowsException instantiateFixture(Throwable throwable) {
-        return new AbstractThrowsException() {
-            @Override
-            protected Throwable getThrowable() {
-                return throwable;
-            }
-        };
-    }
-
-    /** Creates Invocation of a "canThrowException" method call. */
-    private static Invocation createMethodInvocation() {
-        return new InvocationBuilder()
-            .method("canThrowException")
-            .toInvocation();
-    }
-
-    @Test
-    public void fixture_should_return_expected_throwable() {
-        Throwable expected = new RuntimeException();
-        AbstractThrowsException ate = instantiateFixture(expected);
-
-        assertSame(expected, ate.getThrowable());
-    }
-}
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassTypeTest.java b/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassTypeTest.java
deleted file mode 100644
index 9aa67d098..000000000
--- a/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionForClassTypeTest.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 2020 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
-package org.mockito.internal.stubbing.answers;
-
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-
-import org.junit.Test;
-
-public class ThrowsExceptionForClassTypeTest {
-    @Test
-    public void should_return_throwable_of_expected_class() {
-        ThrowsExceptionForClassType throwsExceptionForClassType = new ThrowsExceptionForClassType(Exception.class);
-
-        assertSame(Exception.class, throwsExceptionForClassType.getThrowable().getClass());
-    }
-
-    @Test
-    public void should_return_different_throwables() {
-        ThrowsExceptionForClassType throwsExceptionForClassType = new ThrowsExceptionForClassType(Exception.class);
-
-        Throwable first = throwsExceptionForClassType.getThrowable();
-        Throwable second = throwsExceptionForClassType.getThrowable();
-        assertNotSame(first, second);
-    }
-}
diff --git a/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionTest.java b/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionTest.java
index 2da1e0459..694024499 100644
--- a/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionTest.java
+++ b/src/test/java/org/mockito/internal/stubbing/answers/ThrowsExceptionTest.java
@@ -6,7 +6,6 @@ package org.mockito.internal.stubbing.answers;
 
 import static junit.framework.TestCase.fail;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertSame;
 import static org.mockito.Mockito.mock;
 
 import java.io.IOException;
@@ -55,7 +54,7 @@ public class ThrowsExceptionTest {
         } catch (Throwable throwable) {
             // then
             throwable.printStackTrace();
-            assertThat(throwableToRaise.getStackTrace()[0].getClassName()).isEqualTo(AbstractThrowsException.class.getName());
+            assertThat(throwableToRaise.getStackTrace()[0].getClassName()).isEqualTo(ThrowsException.class.getName());
             assertThat(throwableToRaise.getStackTrace()[0].getMethodName()).isEqualTo("answer");
         }
     }
@@ -95,23 +94,6 @@ public class ThrowsExceptionTest {
         new ThrowsException(new RuntimeException()).validateFor(createMethodInvocation());
     }
 
-    @Test
-    public void should_return_expected_throwable() {
-        Throwable expected = new Exception();
-        ThrowsException throwsException = new ThrowsException(expected);
-
-        assertSame(expected, throwsException.getThrowable());
-    }
-
-    @Test
-    public void should_return_same_throwable() {
-        ThrowsException throwsException = new ThrowsException(new Exception());
-
-        Throwable first = throwsException.getThrowable();
-        Throwable second = throwsException.getThrowable();
-        assertSame(first, second);
-    }
-
     /** Creates Invocation of a "canThrowException" method call. */
     private static Invocation createMethodInvocation() {
         return new InvocationBuilder()
diff --git a/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java b/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
index 3b93f3c7d..3798ca735 100644
--- a/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
+++ b/src/test/java/org/mockitousage/stubbing/StubbingWithThrowablesTest.java
@@ -6,7 +6,6 @@ package org.mockitousage.stubbing;
 
 import static org.hamcrest.CoreMatchers.sameInstance;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -93,30 +92,6 @@ public class StubbingWithThrowablesTest extends TestBase {
         }).isInstanceOf(ExceptionOne.class);
     }
 
-    @Test
-    public void throws_new_exception_consecutively_from_class() {
-        when(mock.add(null)).thenThrow(NaughtyException.class);
-
-        NaughtyException first =  Assertions.catchThrowableOfType(() -> mock.add(null),
-                                                                  NaughtyException.class);
-        NaughtyException second = Assertions.catchThrowableOfType(() -> mock.add(null),
-                                                                  NaughtyException.class);
-
-        assertNotSame(first, second);
-    }
-
-    @Test
-    public void throws_new_exception_consecutively_from_class_with_doThrow() {
-        doThrow(NaughtyException.class).when(mock).add(null);
-
-        NaughtyException first =  Assertions.catchThrowableOfType(() -> mock.add(null),
-                                                                  NaughtyException.class);
-        NaughtyException second = Assertions.catchThrowableOfType(() -> mock.add(null),
-                                                                  NaughtyException.class);
-
-        assertNotSame(first, second);
-    }
-
     @Test
     public void shouldStubWithThrowable() throws Exception {
         IllegalArgumentException expected = new IllegalArgumentException("thrown by mock");
diff --git a/subprojects/junit-jupiter/src/test/java/org/mockitousage/UninstantiableThrowableTest.java b/subprojects/junit-jupiter/src/test/java/org/mockitousage/UninstantiableThrowableTest.java
new file mode 100644
index 000000000..2ef312801
--- /dev/null
+++ b/subprojects/junit-jupiter/src/test/java/org/mockitousage/UninstantiableThrowableTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2018 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
+package org.mockitousage;
+
+import org.assertj.core.api.Assertions;
+import org.junit.jupiter.api.RepeatedTest;
+import org.junit.jupiter.api.RepetitionInfo;
+import org.mockito.Mockito;
+
+import java.util.List;
+
+//issue 1514
+class UninstantiableThrowableTest {
+
+    @RepeatedTest(2)
+    void should_behave_consistently(RepetitionInfo i) {
+        List mock = Mockito.mock(List.class);
+        if (i.getCurrentRepetition() == 1) {
+            Assertions.assertThatThrownBy(
+                () -> Mockito.doThrow(UninstantiableException.class).when(mock).clear())
+                .isInstanceOf(InstantiationError.class);
+        }
+
+        // The following operation results in "UnfinishedStubbing"
+        Mockito.doThrow(RuntimeException.class).when(mock).clear();
+    }
+
+    abstract static class UninstantiableException extends RuntimeException { }
+}
