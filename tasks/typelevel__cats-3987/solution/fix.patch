diff --git a/free/src/main/scala/cats/free/ContravariantCoyoneda.scala b/free/src/main/scala/cats/free/ContravariantCoyoneda.scala
index 57760f08a..b862facb4 100644
--- a/free/src/main/scala/cats/free/ContravariantCoyoneda.scala
+++ b/free/src/main/scala/cats/free/ContravariantCoyoneda.scala
@@ -1,13 +1,15 @@
 package cats
 package free
 
+import cats.data.AndThen
+
 /**
  * The free contravariant functor on `F`. This is isomorphic to `F` as long as `F` itself is a
  * contravariant functor. The function from `F[A]` to `ContravariantCoyoneda[F,A]` exists even when
  * `F` is not a contravariant functor. Implemented using a List of functions for stack-safety.
  */
 sealed abstract class ContravariantCoyoneda[F[_], A] extends Serializable { self =>
-  import ContravariantCoyoneda.{unsafeApply, Aux}
+  import ContravariantCoyoneda.Aux
 
   /**
    * The pivot between `fi` and `k`, usually existential.
@@ -19,15 +21,10 @@ sealed abstract class ContravariantCoyoneda[F[_], A] extends Serializable { self
    */
   val fi: F[Pivot]
 
-  /**
-   * The list of transformer functions, to be composed and lifted into `F` by `run`.
-   */
-  private[cats] val ks: List[Any => Any]
-
   /**
    * The composed transformer function, to be lifted into `F` by `run`.
    */
-  final def k: A => Pivot = Function.chain(ks)(_).asInstanceOf[Pivot]
+  def k: A => Pivot
 
   /**
    * Converts to `F[A]` given that `F` is a contravariant functor
@@ -44,13 +41,13 @@ sealed abstract class ContravariantCoyoneda[F[_], A] extends Serializable { self
    * Simple function composition. Allows contramap fusion without touching the underlying `F`.
    */
   final def contramap[B](f: B => A): Aux[F, B, Pivot] =
-    unsafeApply(fi)(f.asInstanceOf[Any => Any] :: ks)
+    ContravariantCoyoneda(fi)(AndThen(k).compose(f))
 
   /**
    * Modify the context `F` using transformation `f`.
    */
   final def mapK[G[_]](f: F ~> G): Aux[G, A, Pivot] =
-    unsafeApply(f(fi))(ks)
+    ContravariantCoyoneda(f(fi))(k)
 
 }
 
@@ -65,23 +62,16 @@ object ContravariantCoyoneda {
   /**
    * `F[A]` converts to `ContravariantCoyoneda[F,A]` for any `F`
    */
-  def lift[F[_], A](fa: F[A]): ContravariantCoyoneda[F, A] =
+  def lift[F[_], A](fa: F[A]): Aux[F, A, A] =
     apply(fa)(identity[A])
 
   /**
    * Like `lift(fa).contramap(k0)`.
    */
   def apply[F[_], A, B](fa: F[A])(k0: B => A): Aux[F, B, A] =
-    unsafeApply(fa)(k0.asInstanceOf[Any => Any] :: Nil)
-
-  /**
-   * Creates a `ContravariantCoyoneda[F, A]` for any `F`, taking an `F[A]` and a list of
-   * [[Contravariant.contramap]]ped functions to apply later
-   */
-  private[cats] def unsafeApply[F[_], A, B](fa: F[A])(ks0: List[Any => Any]): Aux[F, B, A] =
     new ContravariantCoyoneda[F, B] {
       type Pivot = A
-      val ks = ks0
+      val k = k0
       val fi = fa
     }
 
diff --git a/free/src/main/scala/cats/free/Coyoneda.scala b/free/src/main/scala/cats/free/Coyoneda.scala
index 7f40ab83a..1645ae828 100644
--- a/free/src/main/scala/cats/free/Coyoneda.scala
+++ b/free/src/main/scala/cats/free/Coyoneda.scala
@@ -2,6 +2,7 @@ package cats
 package free
 
 import cats.arrow.FunctionK
+import cats.data.AndThen
 
 /**
  * The dual view of the Yoneda lemma. The free functor on `F`.
@@ -22,17 +23,12 @@ sealed abstract class Coyoneda[F[_], A] extends Serializable { self =>
    */
   val fi: F[Pivot]
 
-  /**
-   * The list of transformer functions, to be composed and lifted into `F` by `run`.
-   */
-  private[cats] val ks: List[Any => Any]
-
   /**
    * The list of transformer functions composed into a single function, to be lifted into `F` by `run`.
    */
-  final def k: Pivot => A = Function.chain(ks.reverse)(_).asInstanceOf[A]
+  def k: Pivot => A
 
-  import Coyoneda.{unsafeApply, Aux}
+  import Coyoneda.Aux
 
   /**
    * Converts to `F[A]` given that `F` is a functor
@@ -58,13 +54,13 @@ sealed abstract class Coyoneda[F[_], A] extends Serializable { self =>
    * the underlying `F`.
    */
   final def map[B](f: A => B): Aux[F, B, Pivot] =
-    unsafeApply(fi)(f.asInstanceOf[Any => Any] :: ks)
+    Coyoneda(fi)(AndThen(k).andThen(f))
 
   /**
    * Modify the context `F` using transformation `f`.
    */
   final def mapK[G[_]](f: F ~> G): Aux[G, A, Pivot] =
-    unsafeApply(f(fi))(ks)
+    Coyoneda(f(fi))(k)
 
   @deprecated("Use mapK", "1.0.0-RC2")
   final private[free] def transform[G[_]](f: FunctionK[F, G]): Aux[G, A, Pivot] =
@@ -83,22 +79,15 @@ object Coyoneda {
   /**
    * `F[A]` converts to `Coyoneda[F,A]` for any `F`
    */
-  def lift[F[_], A](fa: F[A]): Coyoneda[F, A] = apply(fa)(identity[A])
+  def lift[F[_], A](fa: F[A]): Aux[F, A, A] = apply(fa)(identity[A])
 
   /**
    * Like `lift(fa).map(k0)`.
    */
   def apply[F[_], A, B](fa: F[A])(k0: A => B): Aux[F, B, A] =
-    unsafeApply(fa)(k0.asInstanceOf[Any => Any] :: Nil)
-
-  /**
-   * Creates a `Coyoneda[F, A]` for any `F`, taking an `F[A]`
-   * and a list of [[Functor.map]]ped functions to apply later
-   */
-  private[cats] def unsafeApply[F[_], A, B](fa: F[A])(ks0: List[Any => Any]): Aux[F, B, A] =
     new Coyoneda[F, B] {
       type Pivot = A
-      val ks = ks0
+      val k = k0
       val fi = fa
     }
 
diff --git a/free/src/main/scala/cats/free/InvariantCoyoneda.scala b/free/src/main/scala/cats/free/InvariantCoyoneda.scala
new file mode 100644
index 000000000..fc76efae9
--- /dev/null
+++ b/free/src/main/scala/cats/free/InvariantCoyoneda.scala
@@ -0,0 +1,93 @@
+package cats
+package free
+
+import cats.data.AndThen
+
+/**
+ * The free invariant functor on `F`. This is isomorphic to `F` as long as `F` itself is a
+ * invariant functor. The function from `F[A]` to `InvariantCoyoneda[F,A]` exists even when
+ * `F` is not an invariant functor. Implemented using a List of functions for stack-safety.
+ */
+sealed abstract class InvariantCoyoneda[F[_], A] extends Serializable { self =>
+  import InvariantCoyoneda.Aux
+
+  /**
+   * The pivot between `fi` and `k`, usually existential.
+   */
+  type Pivot
+
+  /**
+   * The underlying value.
+   */
+  val fi: F[Pivot]
+
+  /**
+   * Half of the composed transformer function, to be lifted into `F` by `run`.
+   */
+  def k0: Pivot => A
+
+  /**
+   * The other half of the composed transformer function, to be lifted into `F` by `run`.
+   */
+  def k1: A => Pivot
+
+  /**
+   * Converts to `F[A]` given that `F` is a invariant functor
+   */
+  final def run(implicit F: Invariant[F]): F[A] = F.imap(fi)(k0)(k1)
+
+  /**
+   * Converts to `G[A]` given that `G` is a invariant functor
+   */
+  final def foldMap[G[_]](trans: F ~> G)(implicit G: Invariant[G]): G[A] =
+    G.imap(trans(fi))(k0)(k1)
+
+  /**
+   * Simple function composition. Allows imap fusion without touching the underlying `F`.
+   */
+  final def imap[B](f: A => B)(g: B => A): Aux[F, B, Pivot] =
+    InvariantCoyoneda(fi)(AndThen(k0).andThen(f))(AndThen(k1).compose(g))
+
+  /**
+   * Modify the context `F` using transformation `f`.
+   */
+  final def mapK[G[_]](f: F ~> G): Aux[G, A, Pivot] =
+    InvariantCoyoneda(f(fi))(k0)(k1)
+
+}
+
+object InvariantCoyoneda {
+
+  /**
+   * Lift the `Pivot` type member to a parameter. It is usually more convenient to use `Aux` than
+   * a refinment type.
+   */
+  type Aux[F[_], A, B] = InvariantCoyoneda[F, A] { type Pivot = B }
+
+  /**
+   * `F[A]` converts to `InvariantCoyoneda[F,A]` for any `F`
+   */
+  def lift[F[_], A](fa: F[A]): Aux[F, A, A] =
+    apply(fa)(identity[A])(identity[A])
+
+  /**
+   * Like `lift(fa).imap(k0)`.
+   */
+  def apply[F[_], A, B](fa: F[A])(f: A => B)(g: B => A): Aux[F, B, A] =
+    new InvariantCoyoneda[F, B] {
+      type Pivot = A
+      val k0 = f
+      val k1 = g
+      val fi = fa
+    }
+
+  /**
+   * `InvariantCoyoneda[F, *]` provides a invariant functor for any `F`.
+   */
+  implicit def catsFreeInvariantFunctorForInvariantCoyoneda[F[_]]: Invariant[InvariantCoyoneda[F, *]] =
+    new Invariant[InvariantCoyoneda[F, *]] {
+      def imap[A, B](cfa: InvariantCoyoneda[F, A])(f: A => B)(g: B => A): InvariantCoyoneda[F, B] =
+        cfa.imap(f)(g)
+    }
+
+}
