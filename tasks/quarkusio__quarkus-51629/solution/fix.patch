diff --git a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfigPersistenceUnit.java b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfigPersistenceUnit.java
index c442ad16f30..c5eff089250 100644
--- a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfigPersistenceUnit.java
+++ b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmConfigPersistenceUnit.java
@@ -9,7 +9,8 @@
 import java.util.OptionalLong;
 import java.util.Set;
 
-import org.hibernate.annotations.TimeZoneStorageType;
+import org.hibernate.annotations.TimeZoneColumn;
+import org.hibernate.dialect.Dialect;
 import org.hibernate.id.enhanced.StandardOptimizerDescriptor;
 
 import io.quarkus.runtime.annotations.ConfigDocDefault;
@@ -414,40 +415,10 @@ interface Timezone {
              *
              * NOTE: Properties of type `OffsetTime` are https://hibernate.atlassian.net/browse/HHH-16287[not affected by this
              * setting].
-             *
-             * `default`::
-             * Equivalent to `native` if supported, `normalize-utc` otherwise.
-             * `auto`::
-             * Equivalent to `native` if supported, `column` otherwise.
-             * `native`::
-             * Stores the timestamp and timezone in a column of type `timestamp with time zone`.
-             * +
-             * Only available on some databases/dialects;
-             * if not supported, an exception will be thrown during static initialization.
-             * `column`::
-             * Stores the timezone in a separate column next to the timestamp column.
-             * +
-             * Use `@TimeZoneColumn` on the relevant entity property to customize the timezone column.
-             * `normalize-utc`::
-             * Does not store the timezone, and loses timezone information upon persisting.
-             * +
-             * Instead, normalizes the value to a timestamp in the UTC timezone.
-             * `normalize`::
-             * Does not store the timezone, and loses timezone information upon persisting.
-             * +
-             * Instead, normalizes the value:
-             * * upon persisting to the database, to a timestamp in the JDBC timezone
-             * set through `quarkus.hibernate-orm.jdbc.timezone`,
-             * or the JVM default timezone if not set.
-             * * upon reading back from the database, to the JVM default timezone.
-             * +
-             * Use this to get the legacy behavior of Quarkus 2 / Hibernate ORM 5 or older.
-             *
-             * @asciidoclet
              */
             @WithName("default-storage")
             @ConfigDocDefault("default")
-            Optional<TimeZoneStorageType> timeZoneDefaultStorage();
+            Optional<HibernateTimeZoneStorageType> timeZoneDefaultStorage();
         }
 
         @ConfigGroup
@@ -512,6 +483,60 @@ default boolean isAnyPropertySet() {
 
     }
 
+    enum HibernateTimeZoneStorageType {
+        /**
+         * Stores the timestamp and timezone in a column of type `timestamp with time zone`.
+         * +
+         * Only available on some databases/dialects;
+         * if not supported, an exception will be thrown during static initialization.
+         *
+         * @asciidoclet
+         */
+        NATIVE,
+        /**
+         * Does not store the timezone, and loses timezone information upon persisting.
+         * +
+         * Instead, normalizes the value:
+         * * upon persisting to the database, to a timestamp in the JDBC timezone
+         * set through `quarkus.hibernate-orm.jdbc.timezone`,
+         * or the JVM default timezone if not set.
+         * * upon reading back from the database, to the JVM default timezone.
+         * +
+         * Use this to get the legacy behavior of Quarkus 2 / Hibernate ORM 5 or older.
+         *
+         * @asciidoclet
+         */
+        NORMALIZE,
+        /**
+         * Does not store the timezone, and loses timezone information upon persisting.
+         * +
+         * Instead, normalizes the value to a timestamp in the UTC timezone.
+         *
+         * @asciidoclet
+         */
+        NORMALIZE_UTC,
+        /**
+         * Stores the timezone in a separate column next to the timestamp column.
+         * +
+         * Use `@TimeZoneColumn` on the relevant entity property to customize the timezone column.
+         *
+         * @asciidoclet
+         */
+        COLUMN,
+        /**
+         * Equivalent to `native` if supported, `column` otherwise.
+         *
+         * @asciidoclet
+         */
+        AUTO,
+        /**
+         * Equivalent to `native` if supported, `normalize-utc` otherwise.
+         *
+         * @asciidoclet
+         */
+        DEFAULT;
+    }
+
     enum IdOptimizerType {
         /**
          * Assumes the value retrieved from the table/sequence is the lower end of the pool.
@@ -557,8 +582,23 @@ interface HibernateOrmConfigPersistenceUnitQuery {
         int DEFAULT_QUERY_PLAN_CACHE_MAX_SIZE = 2048;
 
         enum NullOrdering {
+            /**
+             * Null precedence not specified.
+             *
+             * @asciidoclet
+             */
             NONE,
+            /**
+             * Null values occur at the beginning of the ORDER BY clause.
+             *
+             * @asciidoclet
+             */
             FIRST,
+            /**
+             * Null values occur at the end of the ORDER BY clause.
+             *
+             * @asciidoclet
+             */
             LAST
         }
 
@@ -756,9 +796,29 @@ default boolean isAnyPropertySet() {
     }
 
     enum IdentifierQuotingStrategy {
+        /**
+         * Identifiers are not quoted.
+         *
+         * @asciidoclet
+         */
         NONE,
+        /**
+         * All identifiers are quoted.
+         *
+         * @asciidoclet
+         */
         ALL,
+        /**
+         * All identifiers, except column definitions, are quoted.
+         *
+         * @asciidoclet
+         */
         ALL_EXCEPT_COLUMN_DEFINITIONS,
+        /**
+         * Only keywords will be quoted.
+         *
+         * @asciidoclet
+         */
         ONLY_KEYWORDS
     }
 
@@ -782,20 +842,28 @@ interface HibernateOrmConfigPersistenceValidation {
 
         enum ValidationMode {
             /**
-             * If a Bean Validation provider is present then behaves as if both {@link ValidationMode#CALLBACK} and
-             * {@link ValidationMode#DDL} modes are configured. Otherwise, same as {@link ValidationMode#NONE}.
+             * If a Bean Validation provider is present then behaves as if both `ValidationMode#CALLBACK` and
+             * `ValidationMode#DDL` modes are configured. Otherwise, same as `ValidationMode#NONE`.
+             *
+             * @asciidoclet
              */
             AUTO,
             /**
              * Bean Validation will perform the lifecycle event validation.
+             *
+             * @asciidoclet
              */
             CALLBACK,
             /**
              * Bean Validation constraints will be considered for the DDL operations.
+             *
+             * @asciidoclet
              */
             DDL,
             /**
              * Bean Validation integration will be disabled.
+             *
+             * @asciidoclet
              */
             NONE
         }
diff --git a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/FastBootHibernatePersistenceProvider.java b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/FastBootHibernatePersistenceProvider.java
index 4e5a882bede..543cfc27dfb 100644
--- a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/FastBootHibernatePersistenceProvider.java
+++ b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/FastBootHibernatePersistenceProvider.java
@@ -1,5 +1,7 @@
 package io.quarkus.hibernate.orm.runtime;
 
+import static io.quarkus.hibernate.orm.runtime.HibernateOrmRuntimeConfigPersistenceUnit.HibernateGenerationStrategy.getString;
+
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
@@ -477,8 +479,10 @@ private static void injectDataSource(String persistenceUnitName, String dataSour
     private static void injectRuntimeConfiguration(HibernateOrmRuntimeConfigPersistenceUnit persistenceUnitConfig,
             Builder runtimeSettingsBuilder) {
 
-        String generationStrategy = persistenceUnitConfig.schemaManagement().strategy();
-        if (!"none".equals(generationStrategy) && persistenceUnitConfig.database().startOffline()) {
+        HibernateOrmRuntimeConfigPersistenceUnit.HibernateGenerationStrategy generationStrategy = persistenceUnitConfig
+                .schemaManagement().strategy();
+        if (!HibernateOrmRuntimeConfigPersistenceUnit.HibernateGenerationStrategy.NONE.equals(generationStrategy)
+                && persistenceUnitConfig.database().startOffline()) {
             throw new PersistenceException(
                     "When using offline mode with `quarkus.hibernate-orm.database.start-offline=true`, the schema management strategy `quarkus.hibernate-orm.schema-management.strategy` must be unset or set to `none`");
         }
@@ -491,8 +495,8 @@ private static void injectRuntimeConfiguration(HibernateOrmRuntimeConfigPersiste
         }
 
         runtimeSettingsBuilder.put(AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,
-                persistenceUnitConfig.database().generation().generation()
-                        .orElse(generationStrategy));
+                getString(persistenceUnitConfig.database().generation().generation()
+                        .orElse(generationStrategy)));
 
         runtimeSettingsBuilder.put(AvailableSettings.JAKARTA_HBM2DDL_CREATE_SCHEMAS,
                 String.valueOf(persistenceUnitConfig.database().generation().createSchemas()
@@ -507,7 +511,7 @@ private static void injectRuntimeConfiguration(HibernateOrmRuntimeConfigPersiste
         runtimeSettingsBuilder.put(AvailableSettings.HBM2DDL_SCRIPTS_CREATE_APPEND, "false");
 
         runtimeSettingsBuilder.put(AvailableSettings.JAKARTA_HBM2DDL_SCRIPTS_ACTION,
-                persistenceUnitConfig.scripts().generation().generation());
+                getString(persistenceUnitConfig.scripts().generation().generation()));
 
         if (persistenceUnitConfig.scripts().generation().createTarget().isPresent()) {
             runtimeSettingsBuilder.put(AvailableSettings.JAKARTA_HBM2DDL_SCRIPTS_CREATE_TARGET,
@@ -549,7 +553,7 @@ private static void injectRuntimeConfiguration(HibernateOrmRuntimeConfigPersiste
         }
 
         runtimeSettingsBuilder.put(HibernateHints.HINT_FLUSH_MODE,
-                persistenceUnitConfig.flush().mode());
+                persistenceUnitConfig.flush().mode().getHibernateFlushMode());
     }
 
 }
diff --git a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/HibernateOrmRecorder.java b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/HibernateOrmRecorder.java
index a0906c7e047..76e2119195f 100644
--- a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/HibernateOrmRecorder.java
+++ b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/HibernateOrmRecorder.java
@@ -287,13 +287,15 @@ private SessionFactory getSessionFactoryFromContext(SyntheticCreationalContext<?
     public void doValidation(String puName) {
         HibernateOrmRuntimeConfigPersistenceUnit hibernateOrmRuntimeConfigPersistenceUnit = runtimeConfig.getValue()
                 .persistenceUnits().get(puName);
-        String schemaManagementStrategy = hibernateOrmRuntimeConfigPersistenceUnit.database().generation().generation()
+        HibernateOrmRuntimeConfigPersistenceUnit.HibernateGenerationStrategy schemaManagementStrategy = hibernateOrmRuntimeConfigPersistenceUnit
+                .database().generation().generation()
                 .orElse(hibernateOrmRuntimeConfigPersistenceUnit.schemaManagement().strategy());
 
         boolean startsOffline = hibernateOrmRuntimeConfigPersistenceUnit.database().startOffline();
 
         //if hibernate is already managing the schema or if we're in offline mode we don't do this
-        if (!"none".equals(schemaManagementStrategy) || startsOffline) {
+        if (!HibernateOrmRuntimeConfigPersistenceUnit.HibernateGenerationStrategy.NONE.equals(schemaManagementStrategy)
+                || startsOffline) {
             return;
         }
         new Thread(new Runnable() {
diff --git a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/HibernateOrmRuntimeConfigPersistenceUnit.java b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/HibernateOrmRuntimeConfigPersistenceUnit.java
index 6d34c2d5898..8fd948f5121 100644
--- a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/HibernateOrmRuntimeConfigPersistenceUnit.java
+++ b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/HibernateOrmRuntimeConfigPersistenceUnit.java
@@ -3,6 +3,8 @@
 import java.util.Map;
 import java.util.Optional;
 
+import jakarta.persistence.FlushModeType;
+
 import org.hibernate.FlushMode;
 
 import io.quarkus.runtime.annotations.ConfigDocDefault;
@@ -157,9 +159,8 @@ interface HibernateOrmConfigPersistenceUnitSchemaManagement {
          *
          * @asciidoclet
          */
-        @WithConverter(TrimmedStringConverter.class)
         @WithDefault("none")
-        String strategy();
+        HibernateGenerationStrategy strategy();
 
         /**
          * If Hibernate ORM should create the schemas automatically (for databases supporting them).
@@ -188,6 +189,60 @@ interface HibernateOrmConfigPersistenceUnitSchemaManagement {
         Optional<@WithConverter(TrimmedStringConverter.class) String> extraPhysicalTableTypes();
     }
 
+    enum HibernateGenerationStrategy {
+        /**
+         * No schema action.
+         *
+         * @asciidoclet
+         */
+        NONE("none"),
+        /**
+         * Create the schema.
+         *
+         * @asciidoclet
+         */
+        CREATE("create"),
+        /**
+         * Drop and then recreate the schema.
+         *
+         * @asciidoclet
+         */
+        DROP_AND_CREATE("drop-and-create"),
+        /**
+         * Drop the schema.
+         *
+         * @asciidoclet
+         */
+        DROP("drop"),
+        /**
+         * Update (alter) the database schema.
+         *
+         * @asciidoclet
+         */
+        UPDATE("update"),
+        /**
+         * Validate the database schema.
+         *
+         * @asciidoclet
+         */
+        VALIDATE("validate");
+
+        private final String schemaGenerationString;
+
+        HibernateGenerationStrategy(String schemaGenerationString) {
+            this.schemaGenerationString = schemaGenerationString;
+        }
+
+        public static String getString(HibernateGenerationStrategy strategy) {
+            return strategy.toString();
+        }
+
+        @Override
+        public String toString() {
+            return schemaGenerationString;
+        }
+    }
+
     @ConfigGroup
     @Deprecated(forRemoval = true, since = "3.22")
     interface HibernateOrmConfigPersistenceUnitDatabaseGeneration {
@@ -204,7 +259,7 @@ interface HibernateOrmConfigPersistenceUnitDatabaseGeneration {
          */
         @WithParentName
         @Deprecated(forRemoval = true, since = "3.22")
-        Optional<@WithConverter(TrimmedStringConverter.class) String> generation();
+        Optional<HibernateGenerationStrategy> generation();
 
         /**
          * If Hibernate ORM should create the schemas automatically (for databases supporting them).
@@ -229,8 +284,7 @@ interface HibernateOrmConfigPersistenceUnitScriptGeneration {
          */
         @WithParentName
         @WithDefault("none")
-        @WithConverter(TrimmedStringConverter.class)
-        String generation();
+        HibernateGenerationStrategy generation();
 
         /**
          * Filename or URL where the database create DDL file should be generated.
@@ -294,7 +348,48 @@ interface HibernateOrmConfigPersistenceUnitFlush {
          * @asciidoclet
          */
         @WithDefault("auto")
-        FlushMode mode();
+        HibernateFlushMode mode();
     }
 
+    enum HibernateFlushMode {
+        /**
+         * The `org.hibernate.Session` is only flushed when `org.hibernate.Session#flush()`
+         * is called explicitly. This mode is very efficient for read-only
+         * transactions.
+         *
+         * @asciidoclet
+         */
+        MANUAL,
+        /**
+         * The `org.hibernate.Session` is flushed when `org.hibernate.Transaction#commit()`
+         * is called. It is never automatically flushed before query
+         * execution.
+         *
+         * @see FlushModeType#COMMIT
+         * @asciidoclet
+         */
+        COMMIT,
+        /**
+         * The `org.hibernate.Session` is flushed when `org.hibernate.Transaction#commit()`
+         * is called, and is sometimes flushed before query execution in
+         * order to ensure that queries never return stale state. This is
+         * the default flush mode.
+         *
+         * @see FlushModeType#AUTO
+         * @asciidoclet
+         */
+        AUTO,
+        /**
+         * The `org.hibernate.Session` is flushed when `org.hibernate.Transaction#commit()`
+         * is called and before every query. This is usually unnecessary and
+         * inefficient.
+         *
+         * @asciidoclet
+         */
+        ALWAYS;
+
+        public FlushMode getHibernateFlushMode() {
+            return FlushMode.valueOf(name());
+        }
+    }
 }
diff --git a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/customized/BuiltinFormatMapperBehaviour.java b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/customized/BuiltinFormatMapperBehaviour.java
index 953aae78aef..c51d0b24924 100644
--- a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/customized/BuiltinFormatMapperBehaviour.java
+++ b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/customized/BuiltinFormatMapperBehaviour.java
@@ -17,6 +17,8 @@ public enum BuiltinFormatMapperBehaviour {
     /**
      * The Quarkus preconfigured mappers are ignored and if there is no user provided one,
      * Hibernate ORM will create a mapper according to its own rules.
+     *
+     * @asciidoclet
      */
     IGNORE {
         @Override
@@ -26,6 +28,8 @@ protected void action(String puName, String type, List<String> causes) {
     /**
      * Uses a Quarkus preconfigured format mappers. If a format mapper operation is invoked a
      * warning is logged.
+     *
+     * @asciidoclet
      */
     WARN {
         @Override
@@ -35,6 +39,8 @@ protected void action(String puName, String type, List<String> causes) {
     },
     /**
      * Currently the default one. If there is no user provided format mapper, a Quarkus preconfigured one will fail at runtime.
+     *
+     * @asciidoclet
      */
     FAIL {
         @Override
diff --git a/extensions/hibernate-reactive/runtime/src/main/java/io/quarkus/hibernate/reactive/runtime/FastBootHibernateReactivePersistenceProvider.java b/extensions/hibernate-reactive/runtime/src/main/java/io/quarkus/hibernate/reactive/runtime/FastBootHibernateReactivePersistenceProvider.java
index 7403404f594..966e749a962 100644
--- a/extensions/hibernate-reactive/runtime/src/main/java/io/quarkus/hibernate/reactive/runtime/FastBootHibernateReactivePersistenceProvider.java
+++ b/extensions/hibernate-reactive/runtime/src/main/java/io/quarkus/hibernate/reactive/runtime/FastBootHibernateReactivePersistenceProvider.java
@@ -1,6 +1,7 @@
 package io.quarkus.hibernate.reactive.runtime;
 
 import static io.quarkus.hibernate.orm.runtime.FastBootHibernatePersistenceProvider.isPostgresOrDB2;
+import static io.quarkus.hibernate.orm.runtime.HibernateOrmRuntimeConfigPersistenceUnit.HibernateGenerationStrategy.getString;
 
 import java.util.Collections;
 import java.util.HashMap;
@@ -386,8 +387,10 @@ private void registerVertxAndPool(String persistenceUnitName,
     private static void injectRuntimeConfiguration(HibernateOrmRuntimeConfigPersistenceUnit persistenceUnitConfig,
             Builder runtimeSettingsBuilder) {
 
-        String generationStrategy = persistenceUnitConfig.schemaManagement().strategy();
-        if (!"none".equals(generationStrategy) && persistenceUnitConfig.database().startOffline()) {
+        HibernateOrmRuntimeConfigPersistenceUnit.HibernateGenerationStrategy generationStrategy = persistenceUnitConfig
+                .schemaManagement().strategy();
+        if (!HibernateOrmRuntimeConfigPersistenceUnit.HibernateGenerationStrategy.NONE.equals(generationStrategy)
+                && persistenceUnitConfig.database().startOffline()) {
             throw new PersistenceException(
                     "When using offline mode with `quarkus.hibernate-orm.database.start-offline=true`, the schema management strategy `quarkus.hibernate-orm.schema-management.strategy` must be unset or set to `none`");
         }
@@ -401,8 +404,8 @@ private static void injectRuntimeConfiguration(HibernateOrmRuntimeConfigPersiste
 
         // Database
         runtimeSettingsBuilder.put(AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,
-                persistenceUnitConfig.database().generation().generation()
-                        .orElse(generationStrategy));
+                getString(persistenceUnitConfig.database().generation().generation()
+                        .orElse(generationStrategy)));
 
         runtimeSettingsBuilder.put(AvailableSettings.JAKARTA_HBM2DDL_CREATE_SCHEMAS,
                 String.valueOf(persistenceUnitConfig.database().generation().createSchemas()
@@ -417,7 +420,7 @@ private static void injectRuntimeConfiguration(HibernateOrmRuntimeConfigPersiste
         runtimeSettingsBuilder.put(AvailableSettings.HBM2DDL_SCRIPTS_CREATE_APPEND, "false");
 
         runtimeSettingsBuilder.put(AvailableSettings.JAKARTA_HBM2DDL_SCRIPTS_ACTION,
-                persistenceUnitConfig.scripts().generation().generation());
+                getString(persistenceUnitConfig.scripts().generation().generation()));
 
         if (persistenceUnitConfig.scripts().generation().createTarget().isPresent()) {
             runtimeSettingsBuilder.put(AvailableSettings.JAKARTA_HBM2DDL_SCRIPTS_CREATE_TARGET,
@@ -459,7 +462,7 @@ private static void injectRuntimeConfiguration(HibernateOrmRuntimeConfigPersiste
         }
 
         runtimeSettingsBuilder.put(HibernateHints.HINT_FLUSH_MODE,
-                persistenceUnitConfig.flush().mode());
+                persistenceUnitConfig.flush().mode().getHibernateFlushMode());
     }
 
     @Override
