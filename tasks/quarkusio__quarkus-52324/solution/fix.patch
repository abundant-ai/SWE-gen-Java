diff --git a/core/deployment/src/main/java/io/quarkus/deployment/builditem/DevServicesRegistryBuildItem.java b/core/deployment/src/main/java/io/quarkus/deployment/builditem/DevServicesRegistryBuildItem.java
index 656d0d38ead..272561256bb 100644
--- a/core/deployment/src/main/java/io/quarkus/deployment/builditem/DevServicesRegistryBuildItem.java
+++ b/core/deployment/src/main/java/io/quarkus/deployment/builditem/DevServicesRegistryBuildItem.java
@@ -84,22 +84,25 @@ public Map<String, String> getConfigForAllRunningServices() {
 
     public void startAll(Collection<DevServicesResultBuildItem> services,
             List<DevServicesCustomizerBuildItem> customizers,
+            List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems,
             ClassLoader augmentClassLoader) {
         closeRemainingRunningServices(services);
         Map<String, String> config = new ConcurrentHashMap<>();
-        startSelectedServices(services, customizers, augmentClassLoader, dr -> !dr.hasDependencies(), config);
+        startSelectedServices(services, customizers, additionalConfigBuildItems, augmentClassLoader,
+                dr -> !dr.hasDependencies(), config);
 
         // Now start everything with a dependency
         // This won't handle the case where the dependencies also have dependencies, but that can be a follow-on work item if people ask for it
         // I think we could implement it by getting the actual dependencies and seeing if any of them are also in the list of things we're starting, and then recursing
-        startSelectedServices(services, customizers, augmentClassLoader,
+        startSelectedServices(services, customizers, additionalConfigBuildItems, augmentClassLoader,
                 DevServicesResultBuildItem::hasDependencies, config);
 
     }
 
     private void startSelectedServices(Collection<DevServicesResultBuildItem> services,
-            List<DevServicesCustomizerBuildItem> customizers, ClassLoader augmentClassLoader,
-            Predicate<? super DevServicesResultBuildItem> filter, Map<String, String> config) {
+            List<DevServicesCustomizerBuildItem> customizers,
+            List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems,
+            ClassLoader augmentClassLoader, Predicate<? super DevServicesResultBuildItem> filter, Map<String, String> config) {
         // TODO Note that this does not handle chained dependencies; dependencies can only be one level deep for now
         // It would be easy to fix that, but let's wait until we need to
         CompletableFuture.allOf(services.stream()
@@ -112,13 +115,13 @@ private void startSelectedServices(Collection<DevServicesResultBuildItem> servic
                     } else {
                         Thread.currentThread().setContextClassLoader(serv.getClass().getClassLoader());
                     }
-                    this.start(serv, customizers, config);
+                    this.start(serv, customizers, additionalConfigBuildItems, config);
                 }))
                 .toArray(CompletableFuture[]::new)).join();
     }
 
     public void start(DevServicesResultBuildItem request, List<DevServicesCustomizerBuildItem> customizers,
-            Map<String, String> config) {
+            List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems, Map<String, String> config) {
         // RunningService class is loaded on parent classloader
         RunningService matchedDevService = this.getRunningServices(request.getName(), request.getServiceName(),
                 request.getServiceConfig());
@@ -128,12 +131,12 @@ public void start(DevServicesResultBuildItem request, List<DevServicesCustomizer
             // Let's get all the running dev services associated with this feature (+ launch mode plus named section), so we can close them
             closeAllRunningServices(request.getName(), request.getServiceName());
 
-            reallyStart(request, customizers, config);
+            reallyStart(request, customizers, additionalConfigBuildItems, config);
         }
     }
 
     private void reallyStart(DevServicesResultBuildItem request, List<DevServicesCustomizerBuildItem> customizers,
-            Map<String, String> configs) {
+            List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems, Map<String, String> configs) {
         StartupLogCompressor compressor = new StartupLogCompressor("Dev Services Startup", null, null);
         try {
             Supplier<Startable> startableSupplier = request.getStartableSupplier();
@@ -173,18 +176,23 @@ private void reallyStart(DevServicesResultBuildItem request, List<DevServicesCus
             }
 
             if (missingDependency == null) {
-
                 startable.start();
-
-                Map<String, String> config = request.getConfig(startable);
-                Map<String, String> overrideConfig = request.getOverrideConfig(startable);
-                configs.putAll(config);
-                configs.putAll(overrideConfig);
-
+                // We do not "copy" the config map here since it is created within the request.getConfig:
+                Map<String, String> combinedConfig = request.getConfig(startable);
+                // Some extensions may rely on adding/overriding config properties
+                //  depending on the results of the started dev services,
+                //  e.g. Hibernate Search/ORM may change the default schema management
+                //  if it detects that it runs over a dev service datasource/Elasticsearch distribution.
+                for (DevServicesAdditionalConfigBuildItem additionalConfigBuildItem : additionalConfigBuildItems) {
+                    Map<String, String> extraFromBuildItem = additionalConfigBuildItem.getConfigProvider()
+                            .provide(combinedConfig);
+                    if (!extraFromBuildItem.isEmpty()) {
+                        combinedConfig.putAll(extraFromBuildItem);
+                    }
+                }
                 RunningService service = new RunningService(request.getName(), request.getDescription(),
-                        config, overrideConfig, startable.getContainerId(), startable);
+                        combinedConfig, request.getOverrideConfig(startable), startable.getContainerId(), startable);
                 this.addRunningService(request.getName(), request.getServiceName(), request.getServiceConfig(), service);
-
                 compressor.close();
 
                 Consumer<Startable> postStartAction = request.getPostStartAction();
diff --git a/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java b/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java
index 3cf46a9d272..910447b0842 100644
--- a/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java
+++ b/core/deployment/src/main/java/io/quarkus/runner/bootstrap/StartupActionImpl.java
@@ -31,6 +31,7 @@
 import io.quarkus.bootstrap.logging.InitialConfigurator;
 import io.quarkus.builder.BuildResult;
 import io.quarkus.deployment.builditem.ApplicationClassNameBuildItem;
+import io.quarkus.deployment.builditem.DevServicesAdditionalConfigBuildItem;
 import io.quarkus.deployment.builditem.DevServicesCustomizerBuildItem;
 import io.quarkus.deployment.builditem.DevServicesLauncherConfigResultBuildItem;
 import io.quarkus.deployment.builditem.DevServicesNetworkIdBuildItem;
@@ -62,6 +63,7 @@ public class StartupActionImpl implements StartupAction {
     private volatile boolean devServicesStarted = false;
     private final List<DevServicesResultBuildItem> devServicesResults;
     private final List<DevServicesCustomizerBuildItem> devServicesCustomizers;
+    private final List<DevServicesAdditionalConfigBuildItem> additionalConfigBuildItems;
     private final String devServicesNetworkId;
     private final List<RuntimeApplicationShutdownBuildItem> runtimeApplicationShutdownBuildItems;
     private final List<Closeable> runtimeCloseTasks = new ArrayList<>();
@@ -81,6 +83,7 @@ public StartupActionImpl(CuratedApplication curatedApplication, BuildResult buil
         devServicesResults = buildResult.consumeMulti(DevServicesResultBuildItem.class);
         devServicesRegistry = buildResult.consumeOptional(DevServicesRegistryBuildItem.class);
         devServicesCustomizers = buildResult.consumeMulti(DevServicesCustomizerBuildItem.class);
+        additionalConfigBuildItems = buildResult.consumeMulti(DevServicesAdditionalConfigBuildItem.class);
 
         Map<String, byte[]> transformedClasses = extractTransformedClasses(buildResult);
         QuarkusClassLoader baseClassLoader = curatedApplication.getOrCreateBaseRuntimeClassLoader();
@@ -306,7 +309,8 @@ private void ensureDevServicesStarted() {
             if (augmentClassLoader == null) {
                 throw new IllegalStateException("Dev services cannot be started without an augmentation class loader.");
             }
-            devServicesRegistry.startAll(devServicesResults, devServicesCustomizers, augmentClassLoader);
+            devServicesRegistry.startAll(devServicesResults, devServicesCustomizers, additionalConfigBuildItems,
+                    augmentClassLoader);
 
             devServicesProperties.putAll(devServicesRegistry.getConfigForAllRunningServices());
         }
