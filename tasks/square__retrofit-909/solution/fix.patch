diff --git a/retrofit/src/main/java/retrofit/MethodInfo.java b/retrofit/src/main/java/retrofit/MethodInfo.java
index 1f583dda..2792856a 100644
--- a/retrofit/src/main/java/retrofit/MethodInfo.java
+++ b/retrofit/src/main/java/retrofit/MethodInfo.java
@@ -65,6 +65,7 @@ final class MethodInfo {
 
   // Method-level details
   CallAdapter<?> adapter;
+  Converter<?> responseConverter;
 
   Type requestType;
   BodyEncoding bodyEncoding = BodyEncoding.NONE;
@@ -85,8 +86,8 @@ final class MethodInfo {
     this.method = method;
     this.adapterFactory = adapterFactory;
     this.converterFactory = converterFactory;
-    parseResponseType();
     parseMethodAnnotations();
+    parseResponseType();
     parseParameters();
   }
 
@@ -211,7 +212,7 @@ final class MethodInfo {
     return builder.build();
   }
 
-  /** Loads {@link #adapter}. */
+  /** Loads {@link #adapter} and {@link #responseConverter}. */
   private void parseResponseType() {
     Type returnType = method.getGenericReturnType();
     if (Utils.hasUnresolvableType(returnType)) {
@@ -223,21 +224,26 @@ final class MethodInfo {
       throw methodError("Service methods cannot return void.");
     }
 
-    //noinspection ForLoopReplaceableByForEach
     CallAdapter adapter = adapterFactory.get(returnType);
     if (adapter == null) {
       throw methodError(
           "Registered call adapter factory was unable to handle return type " + returnType);
     }
+    this.adapter = adapter;
+
     Type responseType = adapter.responseType();
-    if (converterFactory == null && responseType != ResponseBody.class) {
-      throw methodError("Method response type is "
-          + responseType
-          + " but no converter registered. "
-          + "Either add a converter to the Retrofit instance or use ResponseBody.");
-    }
+    if (responseType == ResponseBody.class) {
+      responseConverter = new OkHttpResponseBodyConverter(isStreaming);
+    } else {
+      if (converterFactory == null) {
+        throw methodError("Method response type is "
+            + responseType
+            + " but no converter registered. "
+            + "Either add a converter to the Retrofit instance or use ResponseBody.");
+      }
 
-    this.adapter = adapter;
+      responseConverter = converterFactory.get(responseType);
+    }
   }
 
   /**
diff --git a/retrofit/src/main/java/retrofit/OkHttpCall.java b/retrofit/src/main/java/retrofit/OkHttpCall.java
index f529c3f3..ff9d0f82 100644
--- a/retrofit/src/main/java/retrofit/OkHttpCall.java
+++ b/retrofit/src/main/java/retrofit/OkHttpCall.java
@@ -20,32 +20,31 @@ import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
-import java.lang.reflect.Type;
 
 import static retrofit.Utils.closeQueitly;
 
 final class OkHttpCall<T> implements Call<T> {
-  private final Endpoint endpoint;
-  private final Converter.Factory converterFactory;
   private final OkHttpClient client;
+  private final Endpoint endpoint;
+  private final Converter<T> responseConverter;
   private final MethodInfo methodInfo;
   private final Object[] args;
 
   private volatile com.squareup.okhttp.Call rawCall;
   private boolean executed; // Guarded by this.
 
-  OkHttpCall(Endpoint endpoint, Converter.Factory converterFactory, OkHttpClient client,
+  OkHttpCall(OkHttpClient client, Endpoint endpoint, Converter<T> responseConverter,
       MethodInfo methodInfo, Object[] args) {
-    this.endpoint = endpoint;
-    this.converterFactory = converterFactory;
     this.client = client;
+    this.endpoint = endpoint;
+    this.responseConverter = responseConverter;
     this.methodInfo = methodInfo;
     this.args = args;
   }
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public OkHttpCall<T> clone() {
-    return new OkHttpCall<>(endpoint, converterFactory, client, methodInfo, args);
+    return new OkHttpCall<>(client, endpoint, responseConverter, methodInfo, args);
   }
 
   public void enqueue(final Callback<T> callback) {
@@ -111,7 +110,7 @@ final class OkHttpCall<T> implements Call<T> {
 
   private com.squareup.okhttp.Call createRawCall() {
     HttpUrl url = endpoint.url();
-    RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo, converterFactory);
+    RequestBuilder requestBuilder = new RequestBuilder(url, methodInfo);
     requestBuilder.setArguments(args);
     Request request = requestBuilder.build();
 
@@ -141,36 +140,15 @@ final class OkHttpCall<T> implements Call<T> {
       return Response.success(null, rawResponse);
     }
 
-    Type responseType = methodInfo.adapter.responseType();
-    if (responseType == ResponseBody.class) {
-      if (methodInfo.isStreaming) {
-        // Use the raw body from the request. The caller is responsible for closing.
-        //noinspection unchecked
-        return Response.success((T) rawBody, rawResponse);
-      }
-
-      try {
-        // Buffer the entire body to avoid future I/O.
-        ResponseBody bufferedBody = Utils.readBodyToBytesIfNecessary(rawBody);
-        //noinspection unchecked
-        return Response.success((T) bufferedBody, rawResponse);
-      } finally {
-        closeQueitly(rawBody);
-      }
-    }
-
     ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody);
     try {
-      //noinspection unchecked
-      T body = (T) converterFactory.get(responseType).fromBody(catchingBody);
+      T body = responseConverter.fromBody(catchingBody);
       return Response.success(body, rawResponse);
     } catch (RuntimeException e) {
       // If the underlying source threw an exception, propagate that rather than indicating it was
       // a runtime exception.
       catchingBody.throwIfCaught();
       throw e;
-    } finally {
-      closeQueitly(rawBody);
     }
   }
 
diff --git a/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java b/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
new file mode 100644
index 00000000..039a464c
--- /dev/null
+++ b/retrofit/src/main/java/retrofit/OkHttpResponseBodyConverter.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package retrofit;
+
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.ResponseBody;
+import java.io.IOException;
+
+import static retrofit.Utils.closeQueitly;
+
+final class OkHttpResponseBodyConverter implements Converter<ResponseBody> {
+  private final boolean isStreaming;
+
+  OkHttpResponseBodyConverter(boolean isStreaming) {
+    this.isStreaming = isStreaming;
+  }
+
+  @Override public ResponseBody fromBody(ResponseBody body) throws IOException {
+    if (isStreaming) {
+      return body;
+    }
+
+    // Buffer the entire body to avoid future I/O.
+    try {
+      return Utils.readBodyToBytesIfNecessary(body);
+    } finally {
+      closeQueitly(body);
+    }
+  }
+
+  @Override public RequestBody toBody(ResponseBody value) {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/retrofit/src/main/java/retrofit/RequestBuilder.java b/retrofit/src/main/java/retrofit/RequestBuilder.java
index ddd3b136..f9991422 100644
--- a/retrofit/src/main/java/retrofit/RequestBuilder.java
+++ b/retrofit/src/main/java/retrofit/RequestBuilder.java
@@ -59,8 +59,8 @@ final class RequestBuilder {
   private Headers.Builder headers;
   private String contentTypeHeader;
 
-  RequestBuilder(HttpUrl url, MethodInfo methodInfo, Converter.Factory converterFactory) {
-    this.converterFactory = converterFactory;
+  RequestBuilder(HttpUrl url, MethodInfo methodInfo) {
+    converterFactory = methodInfo.converterFactory;
 
     paramAnnotations = methodInfo.requestParamAnnotations;
     requestMethod = methodInfo.requestMethod;
diff --git a/retrofit/src/main/java/retrofit/Retrofit.java b/retrofit/src/main/java/retrofit/Retrofit.java
index 764594ed..0c79f145 100644
--- a/retrofit/src/main/java/retrofit/Retrofit.java
+++ b/retrofit/src/main/java/retrofit/Retrofit.java
@@ -120,7 +120,8 @@ public final class Retrofit {
   // Package-private avoids synthetic accessor method from InvocationHandler. Also for testing.
   Object invokeMethod(Method method, Object... args) {
     MethodInfo methodInfo = loadMethodInfo(method);
-    Call call = new OkHttpCall(endpoint, converterFactory, client, methodInfo, args);
+    Converter<?> responseConverter = methodInfo.responseConverter;
+    Call call = new OkHttpCall<>(client, endpoint, responseConverter, methodInfo, args);
     return methodInfo.adapter.adapt(call);
   }
 
