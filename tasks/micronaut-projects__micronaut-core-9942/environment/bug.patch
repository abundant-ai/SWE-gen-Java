diff --git a/core-processor/src/main/java/io/micronaut/inject/annotation/AbstractAnnotationMetadataBuilder.java b/core-processor/src/main/java/io/micronaut/inject/annotation/AbstractAnnotationMetadataBuilder.java
index 6864c1f670..6b852ca32e 100644
--- a/core-processor/src/main/java/io/micronaut/inject/annotation/AbstractAnnotationMetadataBuilder.java
+++ b/core-processor/src/main/java/io/micronaut/inject/annotation/AbstractAnnotationMetadataBuilder.java
@@ -25,12 +25,11 @@ import io.micronaut.core.annotation.AnnotationMetadata;
 import io.micronaut.core.annotation.AnnotationMetadataDelegate;
 import io.micronaut.core.annotation.AnnotationUtil;
 import io.micronaut.core.annotation.AnnotationValue;
-import io.micronaut.core.annotation.AnnotationValueBuilder;
+import io.micronaut.core.expressions.EvaluatedExpressionReference;
 import io.micronaut.core.annotation.InstantiatedMember;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.expressions.EvaluatedExpressionReference;
 import io.micronaut.core.io.service.SoftServiceLoader;
 import io.micronaut.core.naming.NameUtils;
 import io.micronaut.core.util.CollectionUtils;
@@ -53,7 +52,6 @@ import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.function.Consumer;
-import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 
@@ -928,8 +926,7 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
         } else {
             Map<? extends T, ?> annotationDefaultValues = readAnnotationDefaultValues(annotationName, annotationType);
             defaultValues = getAnnotationDefaults(annotationType, annotationName, annotationDefaultValues, new HashMap<>());
-            if (defaultValues != null && !defaultValues.isEmpty()) {
-                // Don't cache empty values is it can be invalid annotation type provided by KSP or Groovy
+            if (defaultValues != null) {
                 // Add the default for any retention type annotation
                 ANNOTATION_DEFAULTS.put(annotationName, new LinkedHashMap<>(defaultValues));
             } else {
@@ -1049,20 +1046,13 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
         if (AnnotationUtil.INTERNAL_ANNOTATION_NAMES.contains(annotationValue.getAnnotationName()) || context.isProcessed(annotationValue)) {
             return Stream.empty();
         }
-        // Add annotation default values
-        processedAnnotation = addDefaults(processedAnnotation);
-        // Check if the annotation has the stereotypes set manually, before adding alias stereotypes
-        boolean stereotypesProvided = annotationValue.getStereotypes() != null;
-        // First we need to process aliases, those contribute stereotypes with higher priority
-        processedAnnotation = processAliases(context, processedAnnotation);
-
-        // The next invocation will invoke current method recursively till the stereotypes are processed.
+        // The method is invoked recursively till the stereotypes are set.
         // That will build an annotation value tree with annotations and it's stereotypes.
-        processedAnnotation = addStereotypes(context, processedAnnotation, stereotypesProvided);
-        // Next step is transforming, starting from the stereotypes moving up in the hierarchy.
-        return transform(context, processedAnnotation)
+        // After that we start transforming, starting from the stereotypes moving up in the hierarchy.
+        ProcessedAnnotation annotationWithStereotypes = addStereotypes(context, processedAnnotation);
+        return transform(context, annotationWithStereotypes)
                 .flatMap(this::flattenRepeatable)
-                .map(this::addDefaults);
+                .map(ann -> processAliases(context, ann));
     }
 
     @NonNull
@@ -1072,13 +1062,14 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
         List<ProcessedAnnotation> introducedAliasForAnnotations = new ArrayList<>();
         ProcessedAnnotation newAnn = processAliases(processedAnnotation, introducedAliasForAnnotations);
         if (!introducedAliasForAnnotations.isEmpty()) {
-            newAnn = newAnn.mutateAnnotationValue(builder ->
-                    builder.stereotypes(
+            newAnn = newAnn.withAnnotationValue(
+                    newAnn.getAnnotationValue().mutate()
+                            .stereotypes(
                                     introducedAliasForAnnotations.stream()
                                             .flatMap(a -> processAnnotation(context, a))
                                             .<AnnotationValue<?>>map(ProcessedAnnotation::getAnnotationValue)
                                             .toList()
-                            )
+                            ).build()
             );
         }
         return newAnn;
@@ -1086,75 +1077,56 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
 
     @NonNull
     private ProcessedAnnotation addStereotypes(@NonNull ProcessingContext context,
-                                               @NonNull ProcessedAnnotation processedAnnotation,
-                                               boolean stereotypesProvided) {
-        List<ProcessedAnnotation> stereotypes = Collections.emptyList();
-        if (processedAnnotation.getAnnotationValue().getStereotypes() != null) {
-            stereotypes = processedAnnotation.getAnnotationValue().getStereotypes().stream()
-                .map(this::toProcessedAnnotation)
-                .flatMap(this::flattenRepeatable)
-                .map(this::addDefaults)
-                .toList();
-        }
-        if (!stereotypesProvided) {
-            // The annotation doesn't have the stereotypes set manually
-            // In this case `stereotypes` are aliases
-            List<ProcessedAnnotation> extractedStereotypes = extractStereotypes(context, processedAnnotation);
-            stereotypes = Stream.concat(
-                // Some implementation like KSP and Groovy cannot extract proper compiler annotation type from an annotation name (@AliasFor(annotationName))
-                // That prevents us to properly extract the annotation defaults
-                // To fix it for the aliases we will try to set the annotation type and the defaults from the stereotype of the same annotation if present
-                stereotypes.stream().map(annotation -> {
-                    for (ProcessedAnnotation extractedStereotype : extractedStereotypes) {
-                        if (extractedStereotype.getAnnotationValue().getAnnotationName().equals(annotation.getAnnotationValue().getAnnotationName())) {
-                            return annotation
-                                .withAnnotationType(extractedStereotype.annotationType)
-                                .mutateAnnotationValue(builder -> builder.defaultValues(extractedStereotype.annotationValue.getDefaultValues()));
-                        }
-                    }
-                    return annotation;
-                }),
-                extractedStereotypes.stream()
-            ).toList();
+                                               @NonNull ProcessedAnnotation processedAnnotation) {
+        AnnotationValue<?> annotationValue = processedAnnotation.getAnnotationValue();
+        if (processedAnnotation.annotationType != null && annotationValue.getDefaultValues() == null) {
+            Map<CharSequence, Object> annotationDefaults = getCachedAnnotationDefaults(
+                    annotationValue.getAnnotationName(),
+                    processedAnnotation.annotationType
+            );
+            processedAnnotation = processedAnnotation.withAnnotationValue(
+                    annotationValue.mutate().defaultValues(annotationDefaults).build()
+            );
         }
+        List<ProcessedAnnotation> stereotypes = getStereotypes(context, processedAnnotation);
         List<ProcessedAnnotation> addedStereotypes = getAddedStereotypes(context, processedAnnotation.annotationType);
         if (!addedStereotypes.isEmpty()) {
             stereotypes = CollectionUtils.concat(stereotypes, addedStereotypes);
         }
-        List<ProcessedAnnotation> finalStereotypes = stereotypes;
-        return processedAnnotation.mutateAnnotationValue(builder ->
-            builder.replaceStereotypes(finalStereotypes.stream().<AnnotationValue<?>>map(ProcessedAnnotation::getAnnotationValue).toList())
-        );
-    }
 
-    private ProcessedAnnotation addDefaults(ProcessedAnnotation processedAnnotation) {
-        if (processedAnnotation.getAnnotationValue().getDefaultValues() != null) {
-            return processedAnnotation;
-        }
-        if (processedAnnotation.annotationType != null) {
-            Map<CharSequence, Object> annotationDefaults = getCachedAnnotationDefaults(
-                    processedAnnotation.getAnnotationValue().getAnnotationName(),
-                    processedAnnotation.annotationType
-            );
-            processedAnnotation = processedAnnotation.mutateAnnotationValue(builder -> builder.defaultValues(annotationDefaults));
-        } else {
-            processedAnnotation = processedAnnotation.mutateAnnotationValue(builder -> builder.defaultValues(Collections.emptyMap()));
-        }
-        return processedAnnotation;
+        return processedAnnotation.withStereotypes(
+                stereotypes
+        );
     }
 
     @NonNull
-    private List<ProcessedAnnotation> extractStereotypes(@NonNull ProcessingContext context,
-                                                         @NonNull ProcessedAnnotation processedAnnotation) {
+    private List<ProcessedAnnotation> getStereotypes(@NonNull ProcessingContext context,
+                                                     @NonNull ProcessedAnnotation processedAnnotation) {
         AnnotationValue<?> annotationValue = processedAnnotation.getAnnotationValue();
         ProcessingContext newContext = context.withParent(processedAnnotation.annotationValue);
 
+        if (annotationValue.getStereotypes() != null) {
+            // The annotation has the stereotypes set manually
+            // Let's flatten repeatable
+            return annotationValue.getStereotypes().stream()
+                    .map(this::toProcessedAnnotation)
+                    .flatMap(this::flattenRepeatable)
+                    .toList();
+        }
+
         if (processedAnnotation.annotationType == null) {
             // The annotation is not on the classpath
             // We set an empty collection to mark that stereotypes are processed
             return Collections.emptyList();
+        } else if (annotationValue.getDefaultValues() == null) {
+            Map<CharSequence, Object> annotationDefaults = getCachedAnnotationDefaults(
+                    annotationValue.getAnnotationName(),
+                    processedAnnotation.annotationType
+            );
+            processedAnnotation = processedAnnotation.withAnnotationValue(
+                    annotationValue.mutate().defaultValues(annotationDefaults).build()
+            );
         }
-
         List<? extends A> nativeStereotypes = getAnnotationsForType(processedAnnotation.annotationType);
         if (nativeStereotypes.isEmpty()) {
             // We set an empty collection to mark that stereotypes are processed
@@ -1254,7 +1226,9 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
         if (newValues.equals(annotationValue.getValues())) {
             return processedAnnotation;
         }
-        return processedAnnotation.mutateAnnotationValue(builder -> builder.members(newValues));
+        return processedAnnotation.withAnnotationValue(
+                annotationValue.mutate().members(newValues).build()
+        );
     }
 
     private void addAnnotation(@NonNull MutableAnnotationMetadata mutableAnnotationMetadata,
@@ -1267,8 +1241,6 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
         Map<CharSequence, Object> annotationDefaults = annotationValue.getDefaultValues();
         if (annotationDefaults != null) {
             mutableAnnotationMetadata.addDefaultAnnotationValues(annotationName, annotationDefaults, annotationValue.getRetentionPolicy());
-        } else {
-            throw new IllegalStateException("Annotation should contain default values and an empty list " + annotationValue.getAnnotationName());
         }
 
         T annotationMirror = getAnnotationMirror(annotationName).orElse(null);
@@ -1302,7 +1274,7 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
                             annotationValue.getAnnotationName(),
                             annotationValue.getValues(),
                             annotationValue.getRetentionPolicy()
-                        );
+                    );
                 }
             }
         } else {
@@ -1431,8 +1403,7 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
         }
         AnnotationRemapper annotationRemapper = remappers.next();
         ProcessingContext newContext = context.withProcessedVisitor(annotationRemapper.getClass());
-        List<AnnotationValue<?>> annotationValues = annotationRemapper.remap(annotationValue, context.visitorContext);
-        return annotationValues.stream().flatMap(newAnnotationValue -> {
+        return annotationRemapper.remap(annotationValue, context.visitorContext).stream().flatMap(newAnnotationValue -> {
             if (newAnnotationValue == annotationValue) {
                 // Value didn't change, continue with other remappers
                 return remapAnnotation(newContext, processedAnnotation, annotationValue, remappers);
@@ -1467,8 +1438,7 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
         }
         AnnotationTransformer<K> annotationTransformer = transformers.next();
         ProcessingContext newContext = context.withProcessedVisitor(annotationTransformer.getClass());
-        List<AnnotationValue<?>> transform = annotationTransformer.transform(annotationValue, context.visitorContext);
-        return transform.stream().flatMap(newAnnotationValue -> {
+        return annotationTransformer.transform(annotationValue, context.visitorContext).stream().flatMap(newAnnotationValue -> {
             if (newAnnotationValue == annotationValue) {
                 // Value didn't change, continue with other transformers
                 return transformAnnotation(newContext, processedAnnotation, annotationValue, transformers);
@@ -1574,7 +1544,7 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
         return modify(annotationMetadata, metadata -> {
             addAnnotations(
                     metadata,
-                    Stream.of(toProcessedAnnotation(annotationValue)).map(this::addDefaults),
+                    Stream.of(toProcessedAnnotation(annotationValue)),
                     true,
                     false
             );
@@ -1731,12 +1701,12 @@ public abstract class AbstractAnnotationMetadataBuilder<T, A> {
             return new ProcessedAnnotation(annotationType, annotationValue);
         }
 
-        public ProcessedAnnotation withAnnotationType(T annotationType) {
-            return new ProcessedAnnotation(annotationType, annotationValue);
-        }
-
-        public ProcessedAnnotation mutateAnnotationValue(Function<AnnotationValueBuilder<?>, AnnotationValueBuilder<?>> fn) {
-            return new ProcessedAnnotation(annotationType, fn.apply(annotationValue.mutate()).build());
+        public ProcessedAnnotation withStereotypes(List<ProcessedAnnotation> stereotypes) {
+            return new ProcessedAnnotation(annotationType,
+                    annotationValue.mutate()
+                            .replaceStereotypes(stereotypes.stream().<AnnotationValue<?>>map(ProcessedAnnotation::getAnnotationValue).toList())
+                            .build()
+            );
         }
 
         @Nullable
diff --git a/core-processor/src/main/java/io/micronaut/inject/ast/PropertyElementQuery.java b/core-processor/src/main/java/io/micronaut/inject/ast/PropertyElementQuery.java
index f004c53a92..9024b6235b 100644
--- a/core-processor/src/main/java/io/micronaut/inject/ast/PropertyElementQuery.java
+++ b/core-processor/src/main/java/io/micronaut/inject/ast/PropertyElementQuery.java
@@ -16,6 +16,8 @@
 package io.micronaut.inject.ast;
 
 import io.micronaut.context.annotation.BeanProperties;
+import io.micronaut.context.annotation.ConfigurationBuilder;
+import io.micronaut.context.annotation.ConfigurationProperties;
 import io.micronaut.core.annotation.AccessorsStyle;
 import io.micronaut.core.annotation.AnnotationMetadata;
 import io.micronaut.core.annotation.AnnotationValue;
@@ -24,8 +26,10 @@ import io.micronaut.core.annotation.Nullable;
 import io.micronaut.core.util.ArrayUtils;
 import io.micronaut.core.util.CollectionUtils;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.EnumSet;
+import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
 
@@ -63,6 +67,8 @@ public final class PropertyElementQuery {
      */
     public static @NonNull PropertyElementQuery of(@NonNull AnnotationMetadata annotationMetadata) {
         PropertyElementQuery conf = new PropertyElementQuery();
+        Set<String> includes = new HashSet<>();
+        Set<String> excludes = new HashSet<>();
 
         AnnotationValue<BeanProperties> annotation = annotationMetadata.getAnnotation(BeanProperties.class);
         if (annotation != null) {
@@ -78,12 +84,22 @@ public final class PropertyElementQuery {
             annotation.booleanValue(BeanProperties.MEMBER_ALLOW_WRITE_WITH_MULTIPLE_ARGS)
                 .ifPresent(conf::allowSetterWithMultipleArgs);
 
-            conf.includes(CollectionUtils.setOf(annotation.stringValues(BeanProperties.MEMBER_INCLUDES)));
-            conf.excludes(CollectionUtils.setOf(annotation.stringValues(BeanProperties.MEMBER_EXCLUDES)));
+            includes.addAll(Arrays.asList(annotation.stringValues(BeanProperties.MEMBER_INCLUDES)));
+            excludes.addAll(Arrays.asList(annotation.stringValues(BeanProperties.MEMBER_EXCLUDES)));
 
             conf.excludedAnnotations(CollectionUtils.setOf(annotation.stringValues(BeanProperties.MEMBER_EXCLUDED_ANNOTATIONS)));
         }
 
+        // TODO: investigate why aliases aren't propagated
+        includes.addAll(Arrays.asList(annotationMetadata.stringValues(ConfigurationProperties.class, BeanProperties.MEMBER_INCLUDES)));
+        excludes.addAll(Arrays.asList(annotationMetadata.stringValues(ConfigurationProperties.class, BeanProperties.MEMBER_EXCLUDES)));
+
+        includes.addAll(Arrays.asList(annotationMetadata.stringValues(ConfigurationBuilder.class, BeanProperties.MEMBER_INCLUDES)));
+        excludes.addAll(Arrays.asList(annotationMetadata.stringValues(ConfigurationBuilder.class, BeanProperties.MEMBER_EXCLUDES)));
+
+        conf.includes(includes);
+        conf.excludes(excludes);
+
         String[] readPrefixes = annotationMetadata.stringValues(AccessorsStyle.class, "readPrefixes");
         if (ArrayUtils.isNotEmpty(readPrefixes)) {
             conf.readPrefixes(readPrefixes);
diff --git a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedToBeanPropertiesTransformer.java b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedToBeanPropertiesTransformer.java
index 1b7ca34993..c79e76f521 100644
--- a/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedToBeanPropertiesTransformer.java
+++ b/core-processor/src/main/java/io/micronaut/inject/beans/visitor/IntrospectedToBeanPropertiesTransformer.java
@@ -17,19 +17,18 @@ package io.micronaut.inject.beans.visitor;
 
 import io.micronaut.context.annotation.BeanProperties;
 import io.micronaut.core.annotation.AnnotationValue;
-import io.micronaut.core.annotation.AnnotationValueBuilder;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.Introspected;
+import io.micronaut.core.util.ArrayUtils;
 import io.micronaut.inject.annotation.TypedAnnotationTransformer;
 import io.micronaut.inject.visitor.VisitorContext;
 
-import java.lang.annotation.Annotation;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Arrays;
 import java.util.List;
 
 /**
- * Map values of {@link Introspected} to {@link BeanProperties}, because {@link Introspected} module doesn't depend on the inject module.
+ * Map values of {@link Introspected} to {@link BeanProperties}.
  *
  * @author Denis Stepanov
  * @since 4.0.0
@@ -39,30 +38,25 @@ public final class IntrospectedToBeanPropertiesTransformer implements TypedAnnot
 
     @Override
     public List<AnnotationValue<?>> transform(AnnotationValue<Introspected> annotation, VisitorContext visitorContext) {
-        // Mapping bellow should only set the members when the value is different then the default one
+        // We need to use AnnotationTransformer instead of AnnotationMapper
+        // Somehow it doesn't work when the annotation is added
         Introspected.AccessKind[] accessKinds = annotation.enumValues(BeanProperties.MEMBER_ACCESS_KIND, Introspected.AccessKind.class);
-        AnnotationValueBuilder<Annotation> beanPropertiesBuilder = AnnotationValue.builder(BeanProperties.class.getName(), RetentionPolicy.CLASS);
-        if (accessKinds.length != 0 && !Arrays.equals(accessKinds, Introspected.DEFAULT_ACCESS_KIND)) {
-            beanPropertiesBuilder = beanPropertiesBuilder.member(BeanProperties.MEMBER_ACCESS_KIND, Arrays.stream(accessKinds).map(Enum::name).toArray(String[]::new));
-        }
         Introspected.Visibility[] visibilities = annotation.enumValues(BeanProperties.MEMBER_VISIBILITY, Introspected.Visibility.class);
-        if (visibilities.length != 0 && !Arrays.equals(visibilities, Introspected.DEFAULT_VISIBILITY)) {
-            beanPropertiesBuilder = beanPropertiesBuilder.member(BeanProperties.MEMBER_VISIBILITY, Arrays.stream(visibilities).map(Enum::name).toArray(String[]::new));
-        }
-        String[] includes = annotation.stringValues(BeanProperties.MEMBER_INCLUDES);
-        if (includes.length > 0) {
-            beanPropertiesBuilder = beanPropertiesBuilder.member(BeanProperties.MEMBER_INCLUDES, includes);
-        }
-        String[] excludes = annotation.stringValues(BeanProperties.MEMBER_EXCLUDES);
-        if (excludes.length > 0) {
-            beanPropertiesBuilder = beanPropertiesBuilder.member(BeanProperties.MEMBER_EXCLUDES, excludes);
+        if (ArrayUtils.isEmpty(accessKinds)) {
+            accessKinds = Introspected.DEFAULT_ACCESS_KIND;
         }
-        String[] excludedAnnotations = annotation.stringValues(BeanProperties.MEMBER_EXCLUDED_ANNOTATIONS);
-        if (excludedAnnotations.length > 0) {
-            beanPropertiesBuilder = beanPropertiesBuilder.member(BeanProperties.MEMBER_EXCLUDED_ANNOTATIONS, excludedAnnotations);
+        if (ArrayUtils.isEmpty(visibilities)) {
+            visibilities = Introspected.DEFAULT_VISIBILITY;
         }
-        return List.of(
-                annotation.mutate().stereotype(beanPropertiesBuilder.build()).build()
+        return Arrays.asList(
+            annotation,
+            AnnotationValue.builder(BeanProperties.class.getName(), RetentionPolicy.CLASS)
+                .member(BeanProperties.MEMBER_ACCESS_KIND, accessKinds)
+                .member(BeanProperties.MEMBER_VISIBILITY, visibilities)
+                .member(BeanProperties.MEMBER_INCLUDES, annotation.stringValues(BeanProperties.MEMBER_INCLUDES))
+                .member(BeanProperties.MEMBER_EXCLUDES, annotation.stringValues(BeanProperties.MEMBER_EXCLUDES))
+                .member(BeanProperties.MEMBER_EXCLUDED_ANNOTATIONS, annotation.stringValues(BeanProperties.MEMBER_EXCLUDED_ANNOTATIONS))
+                .build()
         );
     }
 
diff --git a/core-processor/src/main/resources/META-INF/services/io.micronaut.inject.annotation.AnnotationTransformer b/core-processor/src/main/resources/META-INF/services/io.micronaut.inject.annotation.AnnotationTransformer
index 9ec16b9c39..bcc8fee159 100644
--- a/core-processor/src/main/resources/META-INF/services/io.micronaut.inject.annotation.AnnotationTransformer
+++ b/core-processor/src/main/resources/META-INF/services/io.micronaut.inject.annotation.AnnotationTransformer
@@ -9,6 +9,7 @@ io.micronaut.inject.annotation.internal.JavaxNullableTransformer
 io.micronaut.inject.annotation.internal.JavaxNonnullTransformer
 io.micronaut.inject.beans.visitor.IntrospectedToBeanPropertiesTransformer
 io.micronaut.inject.annotation.internal.AndroidxNullableTransformer
+io.micronaut.inject.annotation.internal.JakartaNullableTransformer
 io.micronaut.inject.annotation.internal.JdtNullableTransformer
 io.micronaut.inject.annotation.internal.JspecifyNullableTransformer
 io.micronaut.inject.annotation.internal.ReactivexNullableTransformer
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/configproperties/ConfigurationPropertiesBuilderSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/configproperties/ConfigurationPropertiesBuilderSpec.groovy
index 9a24c02f82..a0f8574e57 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/configproperties/ConfigurationPropertiesBuilderSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/configproperties/ConfigurationPropertiesBuilderSpec.groovy
@@ -543,80 +543,5 @@ class DefaultConnectionPool implements ConnectionPool {
         testPropBean.builder.build().getMaxConcurrency() == 123
     }
 
-    void "test configuration builder with both getters and setters and no prefixes"() {
-        given:
-        ApplicationContext ctx = buildContext('''
-package cpbtest11
-
-import io.micronaut.context.annotation.*
-
-@ConfigurationProperties("pool")
-final class PoolConfig {
-
-    @ConfigurationBuilder(prefixes = [""])
-    public ConnectionPool.Builder builder = DefaultConnectionPool.builder()
-
-}
-
-interface ConnectionPool {
-
-    interface Builder {
-        Integer maxConcurrency()
-        Builder maxConcurrency(Integer maxConcurrency)
-        ConnectionPool build()
-    }
-
-    int getMaxConcurrency()
-}
-
-class DefaultConnectionPool implements ConnectionPool {
-    private final int maxConcurrency
-
-    DefaultConnectionPool(int maxConcurrency) {
-        this.maxConcurrency = maxConcurrency
-    }
 
-    static ConnectionPool.Builder builder() {
-        return new DefaultBuilder()
-    }
-
-    @Override
-    int getMaxConcurrency() {
-        return maxConcurrency
-    }
-
-    private static class DefaultBuilder implements ConnectionPool.Builder {
-
-        private int maxConcurrency
-
-        private DefaultBuilder() {
-        }
-
-        @Override
-        ConnectionPool.Builder maxConcurrency(Integer maxConcurrency) {
-            this.maxConcurrency = maxConcurrency
-            return this
-        }
-
-        @Override
-        Integer maxConcurrency() {
-            return maxConcurrency
-        }
-
-        ConnectionPool build() {
-            return new DefaultConnectionPool(maxConcurrency)
-        }
-    }
-}
-''')
-        ctx.getEnvironment().addPropertySource(PropertySource.of(["pool.max-concurrency": 123]))
-
-        when:
-        Class<?> testProps = ctx.classLoader.loadClass("cpbtest11.PoolConfig")
-        def testPropBean = ctx.getBean(testProps)
-
-        then:
-        noExceptionThrown()
-        testPropBean.builder.build().getMaxConcurrency() == 123
-    }
 }
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/configproperties/InheritedConfigurationReaderPrefixSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/configproperties/InheritedConfigurationReaderPrefixSpec.groovy
index 02bb6edd76..538a963150 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/configproperties/InheritedConfigurationReaderPrefixSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/configproperties/InheritedConfigurationReaderPrefixSpec.groovy
@@ -34,11 +34,10 @@ class MyBean  {
 """)
 
         expect:
-        // NOTE: This is unsupported scenario, this test is only for tracking the current output.
         beanDefinition.getInjectedMethods()[0].name == 'setMyValue'
         def metadata = beanDefinition.getInjectedMethods()[0].getAnnotationMetadata()
         metadata.hasAnnotation(Property)
-        metadata.getValue(Property, "name", String).get() == 'simple.my-value'
+        metadata.getValue(Property, "name", String).get() == 'endpoints.my-value'
     }
 
     void "property path is overriding the existing one without base prefix"() {
@@ -57,7 +56,7 @@ class MyBean  {
         beanDefinition.getInjectedMethods()[0].name == 'setMyValue'
         def metadata = beanDefinition.getInjectedMethods()[0].getAnnotationMetadata()
         metadata.hasAnnotation(Property)
-        metadata.getValue(Property, "name", String).get() == 'simple.my-value'
+        metadata.getValue(Property, "name", String).get() == 'endpoints.my-value'
     }
 
     void "property path is broken because alias is pointing to another alias 2"() {
@@ -73,7 +72,6 @@ class MyBean  {
 """)
 
         expect:
-            // NOTE: This is unsupported scenario, this test is only for tracking the current output.
             beanDefinition.getInjectedMethods()[0].name == 'setMyValue'
             def metadata = beanDefinition.getInjectedMethods()[0].getAnnotationMetadata()
             metadata.hasAnnotation(Property)
diff --git a/inject-groovy/src/test/groovy/io/micronaut/inject/visitor/PropertyElementSpec.groovy b/inject-groovy/src/test/groovy/io/micronaut/inject/visitor/PropertyElementSpec.groovy
index 0f36e14bd2..f0a2746c78 100644
--- a/inject-groovy/src/test/groovy/io/micronaut/inject/visitor/PropertyElementSpec.groovy
+++ b/inject-groovy/src/test/groovy/io/micronaut/inject/visitor/PropertyElementSpec.groovy
@@ -226,15 +226,19 @@ class Parameters {
 
             def beanProperty = parameter.type.beanProperties.get(0)
             beanProperty.type.annotationNames.sort() == [
+                    'io.micronaut.context.annotation.BeanProperties',
                     'io.micronaut.core.annotation.Introspected'
             ]
             beanProperty.field.get().type.annotationNames.sort() == [
+                    'io.micronaut.context.annotation.BeanProperties',
                     'io.micronaut.core.annotation.Introspected'
             ]
             beanProperty.readMethod.get().returnType.annotationNames.sort() == [
+                    'io.micronaut.context.annotation.BeanProperties',
                     'io.micronaut.core.annotation.Introspected'
             ]
             beanProperty.writeMethod.get().parameters[0].type.annotationNames.sort() == [
+                    'io.micronaut.context.annotation.BeanProperties',
                     'io.micronaut.core.annotation.Introspected'
             ]
     }
@@ -302,12 +306,15 @@ class Parameters {
 
             def beanProperty = parameter.type.beanProperties.get(0)
             beanProperty.type.annotationNames.sort() == [
+                    'io.micronaut.context.annotation.BeanProperties',
                     'io.micronaut.core.annotation.Introspected'
             ]
             beanProperty.field.get().type.annotationNames.sort() == [
+                    'io.micronaut.context.annotation.BeanProperties',
                     'io.micronaut.core.annotation.Introspected'
             ]
             beanProperty.field.get().genericType.annotationNames.sort() == [
+                    'io.micronaut.context.annotation.BeanProperties',
                     'io.micronaut.core.annotation.Introspected'
             ]
     }
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/annotation/JavaAnnotationMetadataBuilderSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/annotation/JavaAnnotationMetadataBuilderSpec.groovy
index 10de453ac3..4473bdda39 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/annotation/JavaAnnotationMetadataBuilderSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/annotation/JavaAnnotationMetadataBuilderSpec.groovy
@@ -210,23 +210,6 @@ class Test {
         metadata.getValue(ConfigurationReader, String).get() == 'test'
     }
 
-    void "test alias for has correct value for aliased member with default value"() {
-        given:
-        AnnotationMetadata metadata = buildTypeAnnotationMetadata('''\
-package test;
-
-import io.micronaut.inject.annotation.*;
-
-@MyStereotypeWithDefaultValue("test")
-class Test {
-}
-''')
-        expect:
-        metadata != null
-        metadata.hasDeclaredStereotype(ConfigurationReader)
-        metadata.getValue(ConfigurationReader, String).get() == 'test'
-    }
-
     void "test read annotation with annotation value"() {
         given:
         AnnotationMetadata metadata = buildTypeAnnotationMetadata('''\
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/annotation/MyStereotypeWithDefaultValue.java b/inject-java/src/test/groovy/io/micronaut/inject/annotation/MyStereotypeWithDefaultValue.java
deleted file mode 100644
index e66f074bf6..0000000000
--- a/inject-java/src/test/groovy/io/micronaut/inject/annotation/MyStereotypeWithDefaultValue.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2017-2020 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.inject.annotation;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import io.micronaut.aop.Introduction;
-import io.micronaut.aop.introduction.StubIntroducer;
-import io.micronaut.context.annotation.AliasFor;
-import io.micronaut.context.annotation.ConfigurationReader;
-import io.micronaut.context.annotation.Type;
-import io.micronaut.retry.annotation.Recoverable;
-import jakarta.inject.Scope;
-import java.lang.annotation.Documented;
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-
-@Recoverable
-@Introduction
-@Scope
-@Documented
-@Retention(RUNTIME)
-@Target({ElementType.TYPE})
-@Type(StubIntroducer.class)
-@ConfigurationReader("default")
-public @interface MyStereotypeWithDefaultValue {
-    /**
-     * @return The prefix to use to resolve the properties
-     */
-    @AliasFor(annotation = ConfigurationReader.class, member = "value")
-    String value() default "default";
-
-}
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/configproperties/ConfigurationPropertiesBuilderSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/configproperties/ConfigurationPropertiesBuilderSpec.groovy
index 848477b3a5..c778618c33 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/configproperties/ConfigurationPropertiesBuilderSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/configproperties/ConfigurationPropertiesBuilderSpec.groovy
@@ -255,55 +255,6 @@ class Test {
         test.baz == null //deprecated properties not settable
     }
 
-    void "test with setters without arguments and do not allow zero args"() {
-        given:
-        BeanDefinition beanDefinition = buildBeanDefinition('test.MyProperties', '''
-package test;
-
-import io.micronaut.context.annotation.*;
-import java.lang.Deprecated;
-
-@ConfigurationProperties("test")
-class MyProperties {
-
-    @ConfigurationBuilder
-    Test test = new Test();
-
-
-}
-
-class Test {
-    private Boolean foo;
-    private Boolean bar;
-
-    public void setFoo() { this.foo = true;}
-    public Boolean getFoo() { return this.foo; }
-
-    public void setBar(Boolean bar) { this.bar = bar;}
-    public Boolean getBar() { return this.bar; }
-}
-''')
-
-        when:
-        InstantiatableBeanDefinition factory = beanDefinition
-        ApplicationContext applicationContext = ApplicationContext.run(
-                'test.foo':'true',
-                'test.bar':'true',
-        )
-        def bean = factory.instantiate(applicationContext)
-
-        then:
-        bean != null
-        bean.test != null
-
-        when:
-        def test = bean.test
-
-        then:
-        test.foo == null
-        test.bar == true
-    }
-
     void "test different inject types for config properties"() {
         when:
         BeanDefinition beanDefinition = buildBeanDefinition('test.Neo4jProperties', '''
diff --git a/inject-java/src/test/groovy/io/micronaut/inject/configproperties/InheritedConfigurationReaderPrefixSpec.groovy b/inject-java/src/test/groovy/io/micronaut/inject/configproperties/InheritedConfigurationReaderPrefixSpec.groovy
index cb0429aa88..c7bd57d83b 100644
--- a/inject-java/src/test/groovy/io/micronaut/inject/configproperties/InheritedConfigurationReaderPrefixSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/inject/configproperties/InheritedConfigurationReaderPrefixSpec.groovy
@@ -42,11 +42,10 @@ class MyBean  {
 """)
 
         expect:
-            // NOTE: This is unsupported scenario, this test is only for tracking the current output.
             beanDefinition.getInjectedMethods()[0].name == 'setMyValue'
             def metadata = beanDefinition.getInjectedMethods()[0].getAnnotationMetadata()
             metadata.hasAnnotation(Property)
-            metadata.getValue(Property, "name", String).get() == 'simple.my-value'
+            metadata.getValue(Property, "name", String).get() == 'endpoints.my-value'
     }
 
     void "property path is overriding the existing one without base prefix"() {
@@ -73,7 +72,7 @@ class MyBean  {
             beanDefinition.getInjectedMethods()[0].name == 'setMyValue'
             def metadata = beanDefinition.getInjectedMethods()[0].getAnnotationMetadata()
             metadata.hasAnnotation(Property)
-            metadata.getValue(Property, "name", String).get() == 'simple.my-value'
+            metadata.getValue(Property, "name", String).get() == 'endpoints.my-value'
     }
 
     void "property path is broken because alias is pointing to another alias 2"() {
@@ -97,7 +96,6 @@ class MyBean  {
 """)
 
         expect:
-            // NOTE: This is unsupported scenario, this test is only for tracking the current output.
             beanDefinition.getInjectedMethods()[0].name == 'setMyValue'
             def metadata = beanDefinition.getInjectedMethods()[0].getAnnotationMetadata()
             metadata.hasAnnotation(Property)
diff --git a/inject-java/src/test/groovy/io/micronaut/visitors/PropertyElementSpec.groovy b/inject-java/src/test/groovy/io/micronaut/visitors/PropertyElementSpec.groovy
index 408ab98026..9bc9956fcb 100644
--- a/inject-java/src/test/groovy/io/micronaut/visitors/PropertyElementSpec.groovy
+++ b/inject-java/src/test/groovy/io/micronaut/visitors/PropertyElementSpec.groovy
@@ -278,15 +278,19 @@ class Parameters {
 
         def beanProperty = parameter.type.beanProperties.get(0)
         beanProperty.type.annotationNames.sort() == [
+                'io.micronaut.context.annotation.BeanProperties',
                 'io.micronaut.core.annotation.Introspected'
         ]
         beanProperty.field.get().type.annotationNames.sort() == [
+                'io.micronaut.context.annotation.BeanProperties',
                 'io.micronaut.core.annotation.Introspected'
         ]
         beanProperty.readMethod.get().returnType.annotationNames.sort() == [
+                'io.micronaut.context.annotation.BeanProperties',
                 'io.micronaut.core.annotation.Introspected'
         ]
         beanProperty.writeMethod.get().parameters[0].type.annotationNames.sort() == [
+                'io.micronaut.context.annotation.BeanProperties',
                 'io.micronaut.core.annotation.Introspected'
         ]
     }
@@ -354,12 +358,15 @@ class Parameters {
 
         def beanProperty = parameter.type.beanProperties.get(0)
         beanProperty.type.annotationNames.sort() == [
+                'io.micronaut.context.annotation.BeanProperties',
                 'io.micronaut.core.annotation.Introspected'
         ]
         beanProperty.field.get().type.annotationNames.sort() == [
+                'io.micronaut.context.annotation.BeanProperties',
                 'io.micronaut.core.annotation.Introspected'
         ]
         beanProperty.field.get().genericType.annotationNames.sort() == [
+                'io.micronaut.context.annotation.BeanProperties',
                 'io.micronaut.core.annotation.Introspected'
         ]
     }
diff --git a/inject/src/main/java/io/micronaut/context/annotation/ConfigurationBuilder.java b/inject/src/main/java/io/micronaut/context/annotation/ConfigurationBuilder.java
index 145f71aa40..9bd98dd465 100644
--- a/inject/src/main/java/io/micronaut/context/annotation/ConfigurationBuilder.java
+++ b/inject/src/main/java/io/micronaut/context/annotation/ConfigurationBuilder.java
@@ -34,7 +34,7 @@ import static java.lang.annotation.RetentionPolicy.RUNTIME;
 @Documented
 @Retention(RUNTIME)
 @Target({ElementType.FIELD, ElementType.METHOD})
-@BeanProperties(accessKind = BeanProperties.AccessKind.METHOD, visibility = BeanProperties.Visibility.DEFAULT, allowWriteWithMultipleArgs = true)
+@BeanProperties(accessKind = BeanProperties.AccessKind.METHOD, visibility = BeanProperties.Visibility.DEFAULT, allowWriteWithMultipleArgs = true, allowWriteWithZeroArgs = true)
 public @interface ConfigurationBuilder {
 
     /**
diff --git a/inject/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataSupport.java b/inject/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataSupport.java
index 08882507aa..a52554576b 100644
--- a/inject/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataSupport.java
+++ b/inject/src/main/java/io/micronaut/inject/annotation/AnnotationMetadataSupport.java
@@ -66,7 +66,6 @@ import io.micronaut.core.convert.format.ReadableBytes;
 import io.micronaut.core.reflect.ClassUtils;
 import io.micronaut.core.reflect.InstantiationUtils;
 import io.micronaut.core.reflect.ReflectionUtils;
-import io.micronaut.core.util.CollectionUtils;
 import io.micronaut.core.util.StringUtils;
 import jakarta.annotation.Nonnull;
 import jakarta.annotation.PostConstruct;
@@ -402,7 +401,7 @@ public final class AnnotationMetadataSupport {
      * @param defaultValues The default values
      */
     static void registerDefaultValues(String annotation, Map<CharSequence, Object> defaultValues) {
-        if (StringUtils.isNotEmpty(annotation) && CollectionUtils.isNotEmpty(defaultValues)) {
+        if (StringUtils.isNotEmpty(annotation)) {
             ANNOTATION_DEFAULTS.put(annotation, defaultValues);
         }
     }
diff --git a/test-suite-kotlin-ksp/build.gradle b/test-suite-kotlin-ksp/build.gradle
index 71ba20e436..59c8635812 100644
--- a/test-suite-kotlin-ksp/build.gradle
+++ b/test-suite-kotlin-ksp/build.gradle
@@ -80,10 +80,6 @@ configurations.testRuntimeClasspath {
     }
 }
 
-//kotlin {
-//    kotlinDaemonJvmArgs = ["-Xdebug","-Xrunjdwp:transport=dt_socket,address=5005,server=y,suspend=y"]
-//}
-
 tasks.named("compileTestKotlin") {
     kotlinOptions.jvmTarget = "17"
 }
