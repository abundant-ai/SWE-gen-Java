diff --git a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
index fcd3d4fc8..0a7a27920 100644
--- a/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
+++ b/mockwebserver/src/main/kotlin/mockwebserver3/MockWebServer.kt
@@ -819,17 +819,6 @@ public class MockWebServer : Closeable {
         .protocol(Protocol.HTTP_1_1)
         .build()
 
-    val streams =
-      object : RealWebSocket.Streams(false, socket.source, socket.sink) {
-        override fun close() {
-          socket.source.closeQuietly()
-          socket.sink.closeQuietly()
-        }
-
-        override fun cancel() {
-          socket.cancel()
-        }
-      }
     val webSocket =
       RealWebSocket(
         taskRunner = taskRunner,
@@ -843,15 +832,19 @@ public class MockWebServer : Closeable {
         webSocketCloseTimeout = RealWebSocket.CANCEL_AFTER_CLOSE_MILLIS,
       )
     val name = "MockWebServer WebSocket ${request.url.encodedPath}"
-    webSocket.initReaderAndWriter(name, streams)
-    try {
-      webSocket.loopReader(fancyResponse)
 
-      // Even if messages are no longer being read we need to wait for the connection close signal.
-      socket.awaitClosed()
-    } finally {
-      socket.source.closeQuietly()
-    }
+    webSocket.initReaderAndWriter(
+      name = name,
+      socket = socket,
+      socketSource = socket.source,
+      socketSink = socket.sink,
+      client = false,
+    )
+
+    webSocket.loopReader(fancyResponse)
+
+    // Even if messages are no longer being read we need to wait for the connection close signal.
+    socket.awaitClosed()
   }
 
   @Throws(IOException::class)
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt
index 68a644767..39ee4a629 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/Exchange.kt
@@ -17,7 +17,6 @@ package okhttp3.internal.connection
 
 import java.io.IOException
 import java.net.ProtocolException
-import java.net.SocketException
 import okhttp3.EventListener
 import okhttp3.Headers
 import okhttp3.Request
@@ -25,7 +24,6 @@ import okhttp3.Response
 import okhttp3.ResponseBody
 import okhttp3.internal.http.ExchangeCodec
 import okhttp3.internal.http.RealResponseBody
-import okhttp3.internal.ws.RealWebSocket
 import okio.Buffer
 import okio.ForwardingSink
 import okio.ForwardingSource
@@ -144,20 +142,6 @@ class Exchange(
   @Throws(IOException::class)
   fun peekTrailers(): Headers? = codec.peekTrailers()
 
-  @Throws(SocketException::class)
-  fun newWebSocketStreams(): RealWebSocket.Streams {
-    call.timeoutEarlyExit()
-    return (codec.carrier as RealConnection).newWebSocketStreams(this)
-  }
-
-  fun webSocketUpgradeFailed() {
-    bodyComplete(
-      responseDone = true,
-      requestDone = true,
-      e = null,
-    )
-  }
-
   fun upgradeToSocket(): Socket {
     call.timeoutEarlyExit()
     (codec.carrier as RealConnection).useAsSocket()
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
index 9156c6452..c2dcc523c 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealCall.kt
@@ -189,7 +189,7 @@ class RealCall(
     if (!forWebSocket) {
       interceptors += client.networkInterceptors
     }
-    interceptors += CallServerInterceptor(forWebSocket)
+    interceptors += CallServerInterceptor
 
     val chain =
       RealInterceptorChain(
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealConnection.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealConnection.kt
index 83a50683f..520a617f0 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealConnection.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/connection/RealConnection.kt
@@ -51,7 +51,6 @@ import okhttp3.internal.http2.Settings
 import okhttp3.internal.http2.StreamResetException
 import okhttp3.internal.isHealthy
 import okhttp3.internal.tls.OkHostnameVerifier
-import okhttp3.internal.ws.RealWebSocket
 import okio.Buffer
 import okio.BufferedSink
 import okio.BufferedSource
@@ -293,25 +292,6 @@ class RealConnection internal constructor(
     }
   }
 
-  @Throws(SocketException::class)
-  internal fun newWebSocketStreams(exchange: Exchange): RealWebSocket.Streams {
-    useAsSocket()
-    return object : RealWebSocket.Streams(true, source, sink) {
-      override fun close() {
-        exchange.bodyComplete(
-          bytesRead = -1L,
-          responseDone = true,
-          requestDone = true,
-          e = null,
-        )
-      }
-
-      override fun cancel() {
-        exchange.cancel()
-      }
-    }
-  }
-
   internal fun useAsSocket() {
     socket.soTimeout = 0
     noNewExchanges()
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
index 4822d77d4..da5a00adc 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/http/CallServerInterceptor.kt
@@ -22,15 +22,12 @@ import okhttp3.Interceptor
 import okhttp3.Response
 import okhttp3.TrailersSource
 import okhttp3.internal.UnreadableResponseBody
-import okhttp3.internal.connection.Exchange
 import okhttp3.internal.http2.ConnectionShutdownException
 import okhttp3.internal.skipAll
 import okio.buffer
 
 /** This is the last interceptor in the chain. It makes a network call to the server. */
-class CallServerInterceptor(
-  private val forWebSocket: Boolean,
-) : Interceptor {
+object CallServerInterceptor : Interceptor {
   @Throws(IOException::class)
   override fun intercept(chain: Interceptor.Chain): Response {
     val realChain = chain as RealInterceptorChain
@@ -114,7 +111,7 @@ class CallServerInterceptor(
           .build()
       var code = response.code
 
-      while (shouldIgnoreAndWaitForRealResponse(code, exchange)) {
+      while (shouldIgnoreAndWaitForRealResponse(code)) {
         responseBuilder = exchange.readResponseHeaders(expectContinue = false)!!
         if (invokeStartEvent) {
           exchange.responseHeadersStart()
@@ -151,11 +148,8 @@ class CallServerInterceptor(
                   response.body.contentType(),
                   response.body.contentLength(),
                 ),
-              ).apply {
-                if (!forWebSocket) {
-                  socket(exchange.upgradeToSocket())
-                }
-              }.build()
+              ).socket(exchange.upgradeToSocket())
+              .build()
           }
 
           // This is not an upgrade response.
@@ -202,10 +196,7 @@ class CallServerInterceptor(
     }
   }
 
-  private fun shouldIgnoreAndWaitForRealResponse(
-    code: Int,
-    exchange: Exchange,
-  ): Boolean =
+  private fun shouldIgnoreAndWaitForRealResponse(code: Int): Boolean =
     when {
       // Server sent a 100-continue even though we did not request one. Try again to read the
       // actual response status.
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/RealWebSocket.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/RealWebSocket.kt
index 4d5cccdff..1674f8b85 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/RealWebSocket.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/RealWebSocket.kt
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.ws
 
-import java.io.Closeable
 import java.io.IOException
 import java.net.ProtocolException
 import java.net.SocketTimeoutException
@@ -37,7 +36,6 @@ import okhttp3.internal.concurrent.Lockable
 import okhttp3.internal.concurrent.Task
 import okhttp3.internal.concurrent.TaskRunner
 import okhttp3.internal.concurrent.assertLockHeld
-import okhttp3.internal.connection.Exchange
 import okhttp3.internal.connection.RealCall
 import okhttp3.internal.okHttpName
 import okhttp3.internal.ws.WebSocketProtocol.CLOSE_CLIENT_GOING_AWAY
@@ -50,6 +48,8 @@ import okio.BufferedSource
 import okio.ByteString
 import okio.ByteString.Companion.encodeUtf8
 import okio.ByteString.Companion.toByteString
+import okio.Socket
+import okio.buffer
 
 class RealWebSocket(
   taskRunner: TaskRunner,
@@ -60,7 +60,7 @@ class RealWebSocket(
   private val pingIntervalMillis: Long,
   /**
    * For clients this is initially null, and will be assigned to the agreed-upon extensions. For
-   * servers it should be the agreed-upon extensions immediately.
+   * servers, it should be the agreed-upon extensions immediately.
    */
   private var extensions: WebSocketExtensions?,
   /** If compression is negotiated, outbound messages of this size and larger will be compressed. */
@@ -91,8 +91,8 @@ class RealWebSocket(
   /** Names this web socket for observability and debugging. */
   private var name: String? = null
 
-  /** The streams held by this web socket. This is closed when both reader and writer are closed. */
-  private var streams: Streams? = null
+  /** The socket that carries this web socket. This is canceled when the web socket fails. */
+  private var socket: Socket? = null
 
   /** Outgoing pongs in the order they should be written. */
   private val pongQueue = ArrayDeque<ByteString>()
@@ -171,17 +171,16 @@ class RealWebSocket(
           call: Call,
           response: Response,
         ) {
-          val exchange = response.exchange
-          val streams: Streams
-          try {
-            checkUpgradeSuccess(response, exchange)
-            streams = exchange!!.newWebSocketStreams()
-          } catch (e: IOException) {
-            failWebSocket(e, response)
-            response.closeQuietly()
-            exchange?.webSocketUpgradeFailed()
-            return
-          }
+          val socket =
+            try {
+              checkUpgradeSuccess(response)
+            } catch (e: IOException) {
+              failWebSocket(e, response)
+              response.closeQuietly()
+              response.socket?.sink?.closeQuietly()
+              response.socket?.source?.closeQuietly()
+              return
+            }
 
           // Apply the extensions. If they're unacceptable initiate a graceful shut down.
           // TODO(jwilson): Listeners should get onFailure() instead of onClosing() + onClosed(1010).
@@ -196,7 +195,13 @@ class RealWebSocket(
 
           // Process all web socket messages.
           val name = "$okHttpName WebSocket ${request.url.redact()}"
-          initReaderAndWriter(name, streams)
+          initReaderAndWriter(
+            name = name,
+            socket = socket,
+            socketSource = socket.source.buffer(),
+            socketSink = socket.sink.buffer(),
+            client = true,
+          )
           loopReader(response)
         }
 
@@ -225,10 +230,7 @@ class RealWebSocket(
   }
 
   @Throws(IOException::class)
-  internal fun checkUpgradeSuccess(
-    response: Response,
-    exchange: Exchange?,
-  ) {
+  internal fun checkUpgradeSuccess(response: Response): Socket {
     if (response.code != 101) {
       throw ProtocolException(
         "Expected HTTP 101 response but was '${response.code} ${response.message}'",
@@ -257,26 +259,32 @@ class RealWebSocket(
       )
     }
 
-    if (exchange == null) {
-      throw ProtocolException("Web Socket exchange missing: bad interceptor?")
-    }
+    return response.socket
+      ?: throw ProtocolException("Web Socket socket missing: bad interceptor?")
   }
 
+  /**
+   * This accepts a [BufferedSource] instead of using [Socket.source], just in case we've already
+   * received data from the peer. This accepts a [BufferedSink] for symmetry with the source.
+   */
   fun initReaderAndWriter(
     name: String,
-    streams: Streams,
+    socket: Socket,
+    socketSource: BufferedSource,
+    socketSink: BufferedSink,
+    client: Boolean,
   ) {
     val extensions = this.extensions!!
     synchronized(this) {
       this.name = name
-      this.streams = streams
+      this.socket = socket
       this.writer =
         WebSocketWriter(
-          isClient = streams.client,
-          sink = streams.sink,
+          isClient = client,
+          sink = socketSink,
           random = random,
           perMessageDeflate = extensions.perMessageDeflate,
-          noContextTakeover = extensions.noContextTakeover(streams.client),
+          noContextTakeover = extensions.noContextTakeover(client),
           minimumDeflateSize = minimumDeflateSize,
         )
       this.writerTask = WriterTask()
@@ -294,11 +302,11 @@ class RealWebSocket(
 
     reader =
       WebSocketReader(
-        isClient = streams.client,
-        source = streams.source,
+        isClient = client,
+        source = socketSource,
         frameCallback = this,
         perMessageDeflate = extensions.perMessageDeflate,
-        noContextTakeover = extensions.noContextTakeover(!streams.client),
+        noContextTakeover = extensions.noContextTakeover(!client),
       )
   }
 
@@ -337,13 +345,11 @@ class RealWebSocket(
    * thread.
    */
   fun finishReader() {
-    val failed: Boolean
     val code: Int
     val reason: String?
-    var streamsToClose: Streams?
+    val sendOnClosed: Boolean
     var readerToClose: WebSocketReader?
     synchronized(this) {
-      failed = this.failed
       code = receivedCloseCode
       reason = receivedCloseReason
 
@@ -363,19 +369,14 @@ class RealWebSocket(
         this.taskQueue.shutdown()
       }
 
-      streamsToClose =
-        when {
-          writer == null -> streams
-          else -> null
-        }
+      sendOnClosed = !failed && writer == null && receivedCloseCode != -1
     }
 
-    if (!failed && streamsToClose != null && receivedCloseCode != -1) {
+    if (sendOnClosed) {
       listener.onClosed(this, code, reason!!)
     }
 
     readerToClose?.closeQuietly()
-    streamsToClose?.closeQuietly()
   }
 
   /** For testing: force this web socket to release its threads. */
@@ -508,12 +509,12 @@ class RealWebSocket(
 
   /**
    * Attempts to remove a single frame from a queue and send it. This prefers to write urgent pongs
-   * before less urgent messages and close frames. For example it's possible that a caller will
+   * before less urgent messages and close frames. For example, it's possible that a caller will
    * enqueue messages followed by pongs, but this sends pongs followed by messages. Pongs are always
    * written in the order they were enqueued.
    *
    * If a frame cannot be sent - because there are none enqueued or because the web socket is not
-   * connected - this does nothing and returns false. Otherwise this returns true and the caller
+   * connected - this does nothing and returns false. Otherwise, this returns true and the caller
    * should immediately invoke this method again until it returns false.
    *
    * This method may only be invoked by the writer thread. There may be only thread invoking this
@@ -526,7 +527,7 @@ class RealWebSocket(
     var messageOrClose: Any? = null
     var receivedCloseCode = -1
     var receivedCloseReason: String? = null
-    var streamsToClose: Streams? = null
+    var sendOnClosed = false
     var writerToClose: WebSocketWriter? = null
 
     synchronized(this@RealWebSocket) {
@@ -544,15 +545,11 @@ class RealWebSocket(
           if (receivedCloseCode != -1) {
             writerToClose = this.writer
             this.writer = null
-            streamsToClose =
-              when {
-                writerToClose != null && reader == null -> this.streams
-                else -> null
-              }
+            sendOnClosed = writerToClose != null && reader == null
             this.taskQueue.shutdown()
           } else {
             // When we request a graceful close also schedule a cancel of the web socket.
-            val cancelAfterCloseMillis = (messageOrClose as Close).cancelAfterCloseMillis
+            val cancelAfterCloseMillis = messageOrClose.cancelAfterCloseMillis
             taskQueue.execute("$name cancel", MILLISECONDS.toNanos(cancelAfterCloseMillis)) {
               cancel()
             }
@@ -567,17 +564,17 @@ class RealWebSocket(
       if (pong != null) {
         writer!!.writePong(pong)
       } else if (messageOrClose is Message) {
-        val message = messageOrClose as Message
+        val message = messageOrClose
         writer!!.writeMessageFrame(message.formatOpcode, message.data)
         synchronized(this) {
           queueSize -= message.data.size.toLong()
         }
       } else if (messageOrClose is Close) {
-        val close = messageOrClose as Close
+        val close = messageOrClose
         writer!!.writeClose(close.code, close.reason)
 
         // We closed the writer: now both reader and writer are closed.
-        if (streamsToClose != null) {
+        if (sendOnClosed) {
           listener.onClosed(this, receivedCloseCode, receivedCloseReason!!)
         }
       } else {
@@ -587,7 +584,6 @@ class RealWebSocket(
       return true
     } finally {
       writerToClose?.closeQuietly()
-      streamsToClose?.closeQuietly()
     }
   }
 
@@ -626,29 +622,21 @@ class RealWebSocket(
     response: Response? = null,
     isWriter: Boolean = false,
   ) {
-    val streamsToCancel: Streams?
-    val streamsToClose: Streams?
+    val socketToCancel: Socket?
     val writerToClose: WebSocketWriter?
     synchronized(this) {
       if (failed) return // Already failed.
       failed = true
 
-      streamsToCancel = this.streams
+      socketToCancel = this.socket
 
       writerToClose = this.writer
       this.writer = null
 
-      streamsToClose =
-        when {
-          writerToClose != null && reader == null -> this.streams
-          else -> null
-        }
-
       if (!isWriter && writerToClose != null) {
         // If the caller isn't the writer thread, get that thread to close the writer.
         taskQueue.execute("$name writer close", cancelable = false) {
           writerToClose.closeQuietly()
-          streamsToClose?.closeQuietly()
         }
       }
 
@@ -658,12 +646,11 @@ class RealWebSocket(
     try {
       listener.onFailure(this, e, response)
     } finally {
-      streamsToCancel?.cancel()
+      socketToCancel?.cancel()
 
       // If the caller is the writer thread, close it on this thread.
       if (isWriter) {
         writerToClose?.closeQuietly()
-        streamsToClose?.closeQuietly()
       }
     }
   }
@@ -679,14 +666,6 @@ class RealWebSocket(
     val cancelAfterCloseMillis: Long,
   )
 
-  abstract class Streams(
-    val client: Boolean,
-    val source: BufferedSource,
-    val sink: BufferedSink,
-  ) : Closeable {
-    abstract fun cancel()
-  }
-
   private inner class WriterTask : Task("$name writer") {
     override fun runOnce(): Long {
       try {
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/WebSocketReader.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/WebSocketReader.kt
index 42fa7d803..ae0faf593 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/WebSocketReader.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/WebSocketReader.kt
@@ -20,6 +20,7 @@ import java.io.IOException
 import java.net.ProtocolException
 import java.util.concurrent.TimeUnit
 import okhttp3.internal.and
+import okhttp3.internal.closeQuietly
 import okhttp3.internal.toHexString
 import okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN
 import okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV1
@@ -302,6 +303,7 @@ class WebSocketReader(
 
   @Throws(IOException::class)
   override fun close() {
-    messageInflater?.close()
+    messageInflater?.closeQuietly()
+    source.closeQuietly()
   }
 }
diff --git a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/WebSocketWriter.kt b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/WebSocketWriter.kt
index 29a3b501f..f6c594045 100644
--- a/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/WebSocketWriter.kt
+++ b/okhttp/src/commonJvmAndroid/kotlin/okhttp3/internal/ws/WebSocketWriter.kt
@@ -18,6 +18,7 @@ package okhttp3.internal.ws
 import java.io.Closeable
 import java.io.IOException
 import java.util.Random
+import okhttp3.internal.closeQuietly
 import okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_FIN
 import okhttp3.internal.ws.WebSocketProtocol.B0_FLAG_RSV1
 import okhttp3.internal.ws.WebSocketProtocol.B1_FLAG_MASK
@@ -207,6 +208,7 @@ class WebSocketWriter(
   }
 
   override fun close() {
-    messageDeflater?.close()
+    messageDeflater?.closeQuietly()
+    sink.closeQuietly()
   }
 }
