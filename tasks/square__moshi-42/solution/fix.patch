diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
new file mode 100644
index 00000000..80e88d01
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.io.IOException;
+import java.lang.reflect.AnnotatedElement;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Type;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
+// TODO: support qualifier annotations.
+// TODO: support @Nullable
+// TODO: path in JsonWriter.
+
+final class AdapterMethodsFactory implements JsonAdapter.Factory {
+  private final Map<Type, ToAdapter> toAdapters;
+  private final Map<Type, FromAdapter> fromAdapters;
+
+  AdapterMethodsFactory(Map<Type, ToAdapter> toAdapters, Map<Type, FromAdapter> fromAdapters) {
+    this.toAdapters = toAdapters;
+    this.fromAdapters = fromAdapters;
+  }
+
+  @Override public JsonAdapter<?> create(Type type, AnnotatedElement annotations, final Moshi moshi) {
+    final ToAdapter toAdapter = toAdapters.get(type);
+    final FromAdapter fromAdapter = fromAdapters.get(type);
+    if (toAdapter == null && fromAdapter == null) return null;
+
+    final JsonAdapter<Object> delegate = toAdapter == null || fromAdapter == null
+        ? moshi.nextAdapter(this, type, annotations)
+        : null;
+
+    return new JsonAdapter<Object>() {
+      @Override public void toJson(JsonWriter writer, Object value) throws IOException {
+        if (toAdapter == null) {
+          delegate.toJson(writer, value);
+        } else {
+          try {
+            toAdapter.toJson(moshi, writer, value);
+          } catch (IllegalAccessException e) {
+            throw new AssertionError();
+          } catch (InvocationTargetException e) {
+            if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
+            throw new JsonDataException(e.getCause().getMessage()); // TODO: more context?
+          }
+        }
+      }
+
+      @Override public Object fromJson(JsonReader reader) throws IOException {
+        if (fromAdapter == null) {
+          return delegate.fromJson(reader);
+        } else {
+          try {
+            return fromAdapter.fromJson(moshi, reader);
+          } catch (IllegalAccessException e) {
+            throw new AssertionError();
+          } catch (InvocationTargetException e) {
+            if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
+            throw new JsonDataException(e.getCause().getMessage()); // TODO: more context?
+          }
+        }
+      }
+    };
+  }
+
+  public static AdapterMethodsFactory get(Object adapter) {
+    Map<Type, ToAdapter> toAdapters = new LinkedHashMap<>();
+    Map<Type, FromAdapter> fromAdapters = new LinkedHashMap<>();
+
+    for (Class<?> c = adapter.getClass(); c != Object.class; c = c.getSuperclass()) {
+      for (Method m : c.getDeclaredMethods()) {
+        if (m.isAnnotationPresent(ToJson.class)) {
+          ToAdapter toAdapter = toAdapter(adapter, m);
+          ToAdapter replaced = toAdapters.put(toAdapter.type, toAdapter);
+          if (replaced != null) {
+            throw new IllegalArgumentException("Conflicting @ToJson methods:\n"
+                + "    " + replaced.method + "\n"
+                + "    " + toAdapter.method);
+          }
+        }
+
+        if (m.isAnnotationPresent(FromJson.class)) {
+          FromAdapter fromAdapter = fromAdapter(adapter, m);
+          FromAdapter replaced = fromAdapters.put(fromAdapter.type, fromAdapter);
+          if (replaced != null) {
+            throw new IllegalArgumentException("Conflicting @FromJson methods:\n"
+                + "    " + replaced.method + "\n"
+                + "    " + fromAdapter.method);
+          }
+        }
+      }
+    }
+
+    if (toAdapters.isEmpty() && fromAdapters.isEmpty()) {
+      throw new IllegalArgumentException("Expected at least one @ToJson or @FromJson method on "
+          + adapter.getClass().getName());
+    }
+
+    return new AdapterMethodsFactory(toAdapters, fromAdapters);
+  }
+
+  /**
+   * Returns an object that calls a {@code method} method on {@code adapter} in service of
+   * converting an object to JSON.
+   */
+  static ToAdapter toAdapter(Object adapter, Method method) {
+    method.setAccessible(true);
+    Type[] parameterTypes = method.getGenericParameterTypes();
+    final Type returnType = method.getGenericReturnType();
+
+    if (parameterTypes.length == 2
+        && parameterTypes[0] == JsonWriter.class
+        && returnType == void.class) {
+      return new ToAdapter(parameterTypes[1], adapter, method) {
+        @Override public void toJson(Moshi moshi, JsonWriter writer, Object value)
+            throws IOException, InvocationTargetException, IllegalAccessException {
+          method.invoke(adapter, writer, value);
+        }
+      };
+
+    } else if (parameterTypes.length == 1 && returnType != void.class) {
+      return new ToAdapter(parameterTypes[0], adapter, method) {
+        @Override public void toJson(Moshi moshi, JsonWriter writer, Object value)
+            throws IOException, InvocationTargetException, IllegalAccessException {
+          JsonAdapter<Object> delegate = moshi.adapter(returnType, method);
+          Object intermediate = method.invoke(adapter, value);
+          delegate.toJson(writer, intermediate);
+        }
+      };
+
+    } else {
+      throw new IllegalArgumentException("Unexpected signature for " + method + ".\n"
+          + "@ToJson method signatures may have one of the following structures:\n"
+          + "    <any access modifier> void toJson(JsonWriter writer, T value) throws <any>;\n"
+          + "    <any access modifier> R toJson(T value) throws <any>;\n");
+    }
+  }
+
+  static abstract class ToAdapter {
+    final Type type;
+    final Object adapter;
+    final Method method;
+
+    public ToAdapter(Type type, Object adapter, Method method) {
+      this.type = type;
+      this.adapter = adapter;
+      this.method = method;
+    }
+
+    public abstract void toJson(Moshi moshi, JsonWriter writer, Object value)
+        throws IOException, IllegalAccessException, InvocationTargetException;
+  }
+
+  /**
+   * Returns an object that calls a {@code method} method on {@code adapter} in service of
+   * converting an object from JSON.
+   */
+  static FromAdapter fromAdapter(Object adapter, Method method) {
+    method.setAccessible(true);
+    final Type[] parameterTypes = method.getGenericParameterTypes();
+    final Type returnType = method.getGenericReturnType();
+
+    if (parameterTypes.length == 1
+        && parameterTypes[0] == JsonReader.class
+        && returnType != void.class) {
+      // public Point pointFromJson(JsonReader jsonReader) throws Exception {
+      return new FromAdapter(returnType, adapter, method) {
+        @Override public Object fromJson(Moshi moshi, JsonReader reader)
+            throws IOException, IllegalAccessException, InvocationTargetException {
+          return method.invoke(adapter, reader);
+        }
+      };
+
+    } else if (parameterTypes.length == 1 && returnType != void.class) {
+      // public Point pointFromJson(List<Integer> o) throws Exception {
+      return new FromAdapter(returnType, adapter, method) {
+        @Override public Object fromJson(Moshi moshi, JsonReader reader)
+            throws IOException, IllegalAccessException, InvocationTargetException {
+          JsonAdapter<Object> delegate = moshi.adapter(parameterTypes[0]);
+          Object intermediate = delegate.fromJson(reader);
+          return method.invoke(adapter, intermediate);
+        }
+      };
+
+    } else {
+      throw new IllegalArgumentException("Unexpected signature for " + method + ".\n"
+          + "@ToJson method signatures may have one of the following structures:\n"
+          + "    <any access modifier> void toJson(JsonWriter writer, T value) throws <any>;\n"
+          + "    <any access modifier> R toJson(T value) throws <any>;\n");
+    }
+  }
+
+  static abstract class FromAdapter {
+    final Type type;
+    final Object adapter;
+    final Method method;
+
+    public FromAdapter(Type type, Object adapter, Method method) {
+      this.type = type;
+      this.adapter = adapter;
+      this.method = method;
+    }
+
+    public abstract Object fromJson(Moshi moshi, JsonReader reader)
+        throws IOException, IllegalAccessException, InvocationTargetException;
+  }
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/FromJson.java b/moshi/src/main/java/com/squareup/moshi/FromJson.java
new file mode 100644
index 00000000..960c6126
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/FromJson.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface FromJson {
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
index dec374f4..1d7edda4 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
@@ -19,8 +19,8 @@ import java.io.IOException;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Type;
 import okio.Buffer;
-import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.Sink;
 
 /**
  * Converts Java values to JSON, and JSON values to Java.
@@ -38,9 +38,10 @@ public abstract class JsonAdapter<T> {
 
   public abstract void toJson(JsonWriter writer, T value) throws IOException;
 
-  public final void toJson(BufferedSink sink, T value) throws IOException {
+  public final void toJson(Sink sink, T value) throws IOException {
     JsonWriter writer = new JsonWriter(sink);
     toJson(writer, value);
+    writer.flush();
   }
 
   public final String toJson(T value) throws IOException {
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonDataException.java b/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
new file mode 100644
index 00000000..093fb72f
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+/** Thrown when a JSON document doesn't match the expected format. */
+public final class JsonDataException extends RuntimeException {
+  public JsonDataException(String message) {
+    super(message);
+  }
+
+  public JsonDataException(Throwable cause) {
+    super(cause);
+  }
+
+  public JsonDataException(String message, Throwable cause) {
+    super(message, cause);
+  }
+}
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index a8483c81..7f91ef30 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -19,6 +19,7 @@ import java.io.Closeable;
 import java.io.Flushable;
 import java.io.IOException;
 import okio.BufferedSink;
+import okio.Okio;
 import okio.Sink;
 
 import static com.squareup.moshi.JsonScope.DANGLING_NAME;
@@ -180,11 +181,11 @@ public final class JsonWriter implements Closeable, Flushable {
   /**
    * Creates a new instance that writes a JSON-encoded stream to {@code sink}.
    */
-  public JsonWriter(BufferedSink sink) {
+  public JsonWriter(Sink sink) {
     if (sink == null) {
       throw new NullPointerException("sink == null");
     }
-    this.sink = sink;
+    this.sink = Okio.buffer(sink);
   }
 
   /**
@@ -517,13 +518,13 @@ public final class JsonWriter implements Closeable, Flushable {
         continue;
       }
       if (last < i) {
-        sink.writeUtf8(value, last, i);
+        sink.writeUtf8(value.substring(last, i));
       }
       sink.writeUtf8(replacement);
       last = i + 1;
     }
     if (last < length) {
-      sink.writeUtf8(value, last, length);
+      sink.writeUtf8(value.substring(last, length));
     }
     sink.writeByte('"');
   }
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 2973883c..895cb5e5 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -131,6 +131,10 @@ public final class Moshi {
       return this;
     }
 
+    public Builder add(Object adapter) {
+      return add(AdapterMethodsFactory.get(adapter));
+    }
+
     public Moshi build() {
       return new Moshi(this);
     }
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index 8c645fc8..ad759578 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -18,7 +18,6 @@ package com.squareup.moshi;
 import java.io.IOException;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Type;
-import java.util.Arrays;
 
 final class StandardJsonAdapters {
   public static final JsonAdapter.Factory FACTORY = new JsonAdapter.Factory() {
@@ -40,12 +39,6 @@ final class StandardJsonAdapters {
       if (type == Long.class) return LONG_JSON_ADAPTER.nullSafe();
       if (type == Short.class) return SHORT_JSON_ADAPTER.nullSafe();
       if (type == String.class) return STRING_JSON_ADAPTER.nullSafe();
-
-      Class<?> rawType = Types.getRawType(type);
-      if (rawType.isEnum()) {
-        //noinspection unchecked
-        return enumAdapter((Class<? extends Enum>) rawType).nullSafe();
-      }
       return null;
     }
   };
@@ -167,23 +160,4 @@ final class StandardJsonAdapters {
       writer.value(value);
     }
   };
-
-  static <T extends Enum<T>> JsonAdapter<T> enumAdapter(final Class<T> enumType) {
-    return new JsonAdapter<T>() {
-      @Override public T fromJson(JsonReader reader) throws IOException {
-        String name = reader.nextString();
-        try {
-          return Enum.valueOf(enumType, name);
-        } catch (IllegalArgumentException e) {
-          throw new IllegalStateException("Expected one of "
-              + Arrays.toString(enumType.getEnumConstants()) + " but was " + name + " at path "
-              + reader.getPath());
-        }
-      }
-
-      @Override public void toJson(JsonWriter writer, T value) throws IOException {
-        writer.value(value.name());
-      }
-    };
-  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/ToJson.java b/moshi/src/main/java/com/squareup/moshi/ToJson.java
new file mode 100644
index 00000000..1d8d6e48
--- /dev/null
+++ b/moshi/src/main/java/com/squareup/moshi/ToJson.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.moshi;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.METHOD)
+public @interface ToJson {
+}
diff --git a/pom.xml b/pom.xml
index 202fc13c..85059c77 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
     <java.version>1.7</java.version>
 
     <!-- Dependencies -->
-    <okio.version>1.4.0</okio.version>
+    <okio.version>1.1.0</okio.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
