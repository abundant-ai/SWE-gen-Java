diff --git a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java b/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
deleted file mode 100644
index 80e88d01..00000000
--- a/moshi/src/main/java/com/squareup/moshi/AdapterMethodsFactory.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.io.IOException;
-import java.lang.reflect.AnnotatedElement;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Type;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-// TODO: support qualifier annotations.
-// TODO: support @Nullable
-// TODO: path in JsonWriter.
-
-final class AdapterMethodsFactory implements JsonAdapter.Factory {
-  private final Map<Type, ToAdapter> toAdapters;
-  private final Map<Type, FromAdapter> fromAdapters;
-
-  AdapterMethodsFactory(Map<Type, ToAdapter> toAdapters, Map<Type, FromAdapter> fromAdapters) {
-    this.toAdapters = toAdapters;
-    this.fromAdapters = fromAdapters;
-  }
-
-  @Override public JsonAdapter<?> create(Type type, AnnotatedElement annotations, final Moshi moshi) {
-    final ToAdapter toAdapter = toAdapters.get(type);
-    final FromAdapter fromAdapter = fromAdapters.get(type);
-    if (toAdapter == null && fromAdapter == null) return null;
-
-    final JsonAdapter<Object> delegate = toAdapter == null || fromAdapter == null
-        ? moshi.nextAdapter(this, type, annotations)
-        : null;
-
-    return new JsonAdapter<Object>() {
-      @Override public void toJson(JsonWriter writer, Object value) throws IOException {
-        if (toAdapter == null) {
-          delegate.toJson(writer, value);
-        } else {
-          try {
-            toAdapter.toJson(moshi, writer, value);
-          } catch (IllegalAccessException e) {
-            throw new AssertionError();
-          } catch (InvocationTargetException e) {
-            if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause().getMessage()); // TODO: more context?
-          }
-        }
-      }
-
-      @Override public Object fromJson(JsonReader reader) throws IOException {
-        if (fromAdapter == null) {
-          return delegate.fromJson(reader);
-        } else {
-          try {
-            return fromAdapter.fromJson(moshi, reader);
-          } catch (IllegalAccessException e) {
-            throw new AssertionError();
-          } catch (InvocationTargetException e) {
-            if (e.getCause() instanceof IOException) throw (IOException) e.getCause();
-            throw new JsonDataException(e.getCause().getMessage()); // TODO: more context?
-          }
-        }
-      }
-    };
-  }
-
-  public static AdapterMethodsFactory get(Object adapter) {
-    Map<Type, ToAdapter> toAdapters = new LinkedHashMap<>();
-    Map<Type, FromAdapter> fromAdapters = new LinkedHashMap<>();
-
-    for (Class<?> c = adapter.getClass(); c != Object.class; c = c.getSuperclass()) {
-      for (Method m : c.getDeclaredMethods()) {
-        if (m.isAnnotationPresent(ToJson.class)) {
-          ToAdapter toAdapter = toAdapter(adapter, m);
-          ToAdapter replaced = toAdapters.put(toAdapter.type, toAdapter);
-          if (replaced != null) {
-            throw new IllegalArgumentException("Conflicting @ToJson methods:\n"
-                + "    " + replaced.method + "\n"
-                + "    " + toAdapter.method);
-          }
-        }
-
-        if (m.isAnnotationPresent(FromJson.class)) {
-          FromAdapter fromAdapter = fromAdapter(adapter, m);
-          FromAdapter replaced = fromAdapters.put(fromAdapter.type, fromAdapter);
-          if (replaced != null) {
-            throw new IllegalArgumentException("Conflicting @FromJson methods:\n"
-                + "    " + replaced.method + "\n"
-                + "    " + fromAdapter.method);
-          }
-        }
-      }
-    }
-
-    if (toAdapters.isEmpty() && fromAdapters.isEmpty()) {
-      throw new IllegalArgumentException("Expected at least one @ToJson or @FromJson method on "
-          + adapter.getClass().getName());
-    }
-
-    return new AdapterMethodsFactory(toAdapters, fromAdapters);
-  }
-
-  /**
-   * Returns an object that calls a {@code method} method on {@code adapter} in service of
-   * converting an object to JSON.
-   */
-  static ToAdapter toAdapter(Object adapter, Method method) {
-    method.setAccessible(true);
-    Type[] parameterTypes = method.getGenericParameterTypes();
-    final Type returnType = method.getGenericReturnType();
-
-    if (parameterTypes.length == 2
-        && parameterTypes[0] == JsonWriter.class
-        && returnType == void.class) {
-      return new ToAdapter(parameterTypes[1], adapter, method) {
-        @Override public void toJson(Moshi moshi, JsonWriter writer, Object value)
-            throws IOException, InvocationTargetException, IllegalAccessException {
-          method.invoke(adapter, writer, value);
-        }
-      };
-
-    } else if (parameterTypes.length == 1 && returnType != void.class) {
-      return new ToAdapter(parameterTypes[0], adapter, method) {
-        @Override public void toJson(Moshi moshi, JsonWriter writer, Object value)
-            throws IOException, InvocationTargetException, IllegalAccessException {
-          JsonAdapter<Object> delegate = moshi.adapter(returnType, method);
-          Object intermediate = method.invoke(adapter, value);
-          delegate.toJson(writer, intermediate);
-        }
-      };
-
-    } else {
-      throw new IllegalArgumentException("Unexpected signature for " + method + ".\n"
-          + "@ToJson method signatures may have one of the following structures:\n"
-          + "    <any access modifier> void toJson(JsonWriter writer, T value) throws <any>;\n"
-          + "    <any access modifier> R toJson(T value) throws <any>;\n");
-    }
-  }
-
-  static abstract class ToAdapter {
-    final Type type;
-    final Object adapter;
-    final Method method;
-
-    public ToAdapter(Type type, Object adapter, Method method) {
-      this.type = type;
-      this.adapter = adapter;
-      this.method = method;
-    }
-
-    public abstract void toJson(Moshi moshi, JsonWriter writer, Object value)
-        throws IOException, IllegalAccessException, InvocationTargetException;
-  }
-
-  /**
-   * Returns an object that calls a {@code method} method on {@code adapter} in service of
-   * converting an object from JSON.
-   */
-  static FromAdapter fromAdapter(Object adapter, Method method) {
-    method.setAccessible(true);
-    final Type[] parameterTypes = method.getGenericParameterTypes();
-    final Type returnType = method.getGenericReturnType();
-
-    if (parameterTypes.length == 1
-        && parameterTypes[0] == JsonReader.class
-        && returnType != void.class) {
-      // public Point pointFromJson(JsonReader jsonReader) throws Exception {
-      return new FromAdapter(returnType, adapter, method) {
-        @Override public Object fromJson(Moshi moshi, JsonReader reader)
-            throws IOException, IllegalAccessException, InvocationTargetException {
-          return method.invoke(adapter, reader);
-        }
-      };
-
-    } else if (parameterTypes.length == 1 && returnType != void.class) {
-      // public Point pointFromJson(List<Integer> o) throws Exception {
-      return new FromAdapter(returnType, adapter, method) {
-        @Override public Object fromJson(Moshi moshi, JsonReader reader)
-            throws IOException, IllegalAccessException, InvocationTargetException {
-          JsonAdapter<Object> delegate = moshi.adapter(parameterTypes[0]);
-          Object intermediate = delegate.fromJson(reader);
-          return method.invoke(adapter, intermediate);
-        }
-      };
-
-    } else {
-      throw new IllegalArgumentException("Unexpected signature for " + method + ".\n"
-          + "@ToJson method signatures may have one of the following structures:\n"
-          + "    <any access modifier> void toJson(JsonWriter writer, T value) throws <any>;\n"
-          + "    <any access modifier> R toJson(T value) throws <any>;\n");
-    }
-  }
-
-  static abstract class FromAdapter {
-    final Type type;
-    final Object adapter;
-    final Method method;
-
-    public FromAdapter(Type type, Object adapter, Method method) {
-      this.type = type;
-      this.adapter = adapter;
-      this.method = method;
-    }
-
-    public abstract Object fromJson(Moshi moshi, JsonReader reader)
-        throws IOException, IllegalAccessException, InvocationTargetException;
-  }
-}
diff --git a/moshi/src/main/java/com/squareup/moshi/FromJson.java b/moshi/src/main/java/com/squareup/moshi/FromJson.java
deleted file mode 100644
index 960c6126..00000000
--- a/moshi/src/main/java/com/squareup/moshi/FromJson.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.METHOD)
-public @interface FromJson {
-}
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
index 1d7edda4..dec374f4 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonAdapter.java
@@ -19,8 +19,8 @@ import java.io.IOException;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Type;
 import okio.Buffer;
+import okio.BufferedSink;
 import okio.BufferedSource;
-import okio.Sink;
 
 /**
  * Converts Java values to JSON, and JSON values to Java.
@@ -38,10 +38,9 @@ public abstract class JsonAdapter<T> {
 
   public abstract void toJson(JsonWriter writer, T value) throws IOException;
 
-  public final void toJson(Sink sink, T value) throws IOException {
+  public final void toJson(BufferedSink sink, T value) throws IOException {
     JsonWriter writer = new JsonWriter(sink);
     toJson(writer, value);
-    writer.flush();
   }
 
   public final String toJson(T value) throws IOException {
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonDataException.java b/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
deleted file mode 100644
index 093fb72f..00000000
--- a/moshi/src/main/java/com/squareup/moshi/JsonDataException.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-/** Thrown when a JSON document doesn't match the expected format. */
-public final class JsonDataException extends RuntimeException {
-  public JsonDataException(String message) {
-    super(message);
-  }
-
-  public JsonDataException(Throwable cause) {
-    super(cause);
-  }
-
-  public JsonDataException(String message, Throwable cause) {
-    super(message, cause);
-  }
-}
diff --git a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
index 7f91ef30..a8483c81 100644
--- a/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
+++ b/moshi/src/main/java/com/squareup/moshi/JsonWriter.java
@@ -19,7 +19,6 @@ import java.io.Closeable;
 import java.io.Flushable;
 import java.io.IOException;
 import okio.BufferedSink;
-import okio.Okio;
 import okio.Sink;
 
 import static com.squareup.moshi.JsonScope.DANGLING_NAME;
@@ -181,11 +180,11 @@ public final class JsonWriter implements Closeable, Flushable {
   /**
    * Creates a new instance that writes a JSON-encoded stream to {@code sink}.
    */
-  public JsonWriter(Sink sink) {
+  public JsonWriter(BufferedSink sink) {
     if (sink == null) {
       throw new NullPointerException("sink == null");
     }
-    this.sink = Okio.buffer(sink);
+    this.sink = sink;
   }
 
   /**
@@ -518,13 +517,13 @@ public final class JsonWriter implements Closeable, Flushable {
         continue;
       }
       if (last < i) {
-        sink.writeUtf8(value.substring(last, i));
+        sink.writeUtf8(value, last, i);
       }
       sink.writeUtf8(replacement);
       last = i + 1;
     }
     if (last < length) {
-      sink.writeUtf8(value.substring(last, length));
+      sink.writeUtf8(value, last, length);
     }
     sink.writeByte('"');
   }
diff --git a/moshi/src/main/java/com/squareup/moshi/Moshi.java b/moshi/src/main/java/com/squareup/moshi/Moshi.java
index 895cb5e5..2973883c 100644
--- a/moshi/src/main/java/com/squareup/moshi/Moshi.java
+++ b/moshi/src/main/java/com/squareup/moshi/Moshi.java
@@ -131,10 +131,6 @@ public final class Moshi {
       return this;
     }
 
-    public Builder add(Object adapter) {
-      return add(AdapterMethodsFactory.get(adapter));
-    }
-
     public Moshi build() {
       return new Moshi(this);
     }
diff --git a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
index ad759578..8c645fc8 100644
--- a/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
+++ b/moshi/src/main/java/com/squareup/moshi/StandardJsonAdapters.java
@@ -18,6 +18,7 @@ package com.squareup.moshi;
 import java.io.IOException;
 import java.lang.reflect.AnnotatedElement;
 import java.lang.reflect.Type;
+import java.util.Arrays;
 
 final class StandardJsonAdapters {
   public static final JsonAdapter.Factory FACTORY = new JsonAdapter.Factory() {
@@ -39,6 +40,12 @@ final class StandardJsonAdapters {
       if (type == Long.class) return LONG_JSON_ADAPTER.nullSafe();
       if (type == Short.class) return SHORT_JSON_ADAPTER.nullSafe();
       if (type == String.class) return STRING_JSON_ADAPTER.nullSafe();
+
+      Class<?> rawType = Types.getRawType(type);
+      if (rawType.isEnum()) {
+        //noinspection unchecked
+        return enumAdapter((Class<? extends Enum>) rawType).nullSafe();
+      }
       return null;
     }
   };
@@ -160,4 +167,23 @@ final class StandardJsonAdapters {
       writer.value(value);
     }
   };
+
+  static <T extends Enum<T>> JsonAdapter<T> enumAdapter(final Class<T> enumType) {
+    return new JsonAdapter<T>() {
+      @Override public T fromJson(JsonReader reader) throws IOException {
+        String name = reader.nextString();
+        try {
+          return Enum.valueOf(enumType, name);
+        } catch (IllegalArgumentException e) {
+          throw new IllegalStateException("Expected one of "
+              + Arrays.toString(enumType.getEnumConstants()) + " but was " + name + " at path "
+              + reader.getPath());
+        }
+      }
+
+      @Override public void toJson(JsonWriter writer, T value) throws IOException {
+        writer.value(value.name());
+      }
+    };
+  }
 }
diff --git a/moshi/src/main/java/com/squareup/moshi/ToJson.java b/moshi/src/main/java/com/squareup/moshi/ToJson.java
deleted file mode 100644
index 1d8d6e48..00000000
--- a/moshi/src/main/java/com/squareup/moshi/ToJson.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-@Retention(RetentionPolicy.RUNTIME)
-@Target(ElementType.METHOD)
-public @interface ToJson {
-}
diff --git a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java b/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
deleted file mode 100644
index c6fb9845..00000000
--- a/moshi/src/test/java/com/squareup/moshi/AdapterMethodsTest.java
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.moshi;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class AdapterMethodsTest {
-  @Test public void toAndFromJsonViaListOfIntegers() throws Exception {
-    Moshi moshi = new Moshi.Builder()
-        .add(new PointAsListOfIntegersJsonAdapter())
-        .build();
-    JsonAdapter<Point> pointAdapter = moshi.adapter(Point.class);
-    assertThat(pointAdapter.toJson(new Point(5, 8))).isEqualTo("[5,8]");
-    assertThat(pointAdapter.fromJson("[5,8]")).isEqualTo(new Point(5, 8));
-  }
-
-  static class PointAsListOfIntegersJsonAdapter {
-    @ToJson List<Integer> pointToJson(Point point) {
-      return Arrays.asList(point.x, point.y);
-    }
-
-    @FromJson Point pointFromJson(List<Integer> o) throws Exception {
-      if (o.size() != 2) throw new Exception("Expected 2 elements but was " + o);
-      return new Point(o.get(0), o.get(1));
-    }
-  }
-
-  @Test public void toAndFromJsonWithWriterAndReader() throws Exception {
-    Moshi moshi = new Moshi.Builder()
-        .add(new PointWriterAndReaderJsonAdapter())
-        .build();
-    JsonAdapter<Point> pointAdapter = moshi.adapter(Point.class);
-    assertThat(pointAdapter.toJson(new Point(5, 8))).isEqualTo("[5,8]");
-    assertThat(pointAdapter.fromJson("[5,8]")).isEqualTo(new Point(5, 8));
-  }
-
-  static class PointWriterAndReaderJsonAdapter {
-    @ToJson void pointToJson(JsonWriter writer, Point point) throws IOException {
-      writer.beginArray();
-      writer.value(point.x);
-      writer.value(point.y);
-      writer.endArray();
-    }
-
-    @FromJson Point pointFromJson(JsonReader reader) throws Exception {
-      reader.beginArray();
-      int x = reader.nextInt();
-      int y = reader.nextInt();
-      reader.endArray();
-      return new Point(x, y);
-    }
-  }
-
-  @Test public void toJsonOnly() throws Exception {
-    Moshi moshi = new Moshi.Builder()
-        .add(new PointAsListOfIntegersToAdapter())
-        .build();
-    JsonAdapter<Point> pointAdapter = moshi.adapter(Point.class);
-    assertThat(pointAdapter.toJson(new Point(5, 8))).isEqualTo("[5,8]");
-    assertThat(pointAdapter.fromJson("{\"x\":5,\"y\":8}")).isEqualTo(new Point(5, 8));
-  }
-
-  static class PointAsListOfIntegersToAdapter {
-    @ToJson List<Integer> pointToJson(Point point) {
-      return Arrays.asList(point.x, point.y);
-    }
-  }
-
-  @Test public void fromJsonOnly() throws Exception {
-    Moshi moshi = new Moshi.Builder()
-        .add(new PointAsListOfIntegersFromAdapter())
-        .build();
-    JsonAdapter<Point> pointAdapter = moshi.adapter(Point.class);
-    assertThat(pointAdapter.toJson(new Point(5, 8))).isEqualTo("{\"x\":5,\"y\":8}");
-    assertThat(pointAdapter.fromJson("[5,8]")).isEqualTo(new Point(5, 8));
-  }
-
-  static class PointAsListOfIntegersFromAdapter {
-    @FromJson Point pointFromJson(List<Integer> o) throws Exception {
-      if (o.size() != 2) throw new Exception("Expected 2 elements but was " + o);
-      return new Point(o.get(0), o.get(1));
-    }
-  }
-
-  @Test public void multipleLayersOfAdapters() throws Exception {
-    Moshi moshi = new Moshi.Builder()
-        .add(new MultipleLayersJsonAdapter())
-        .build();
-    JsonAdapter<Point> pointAdapter = moshi.adapter(Point.class).lenient();
-    assertThat(pointAdapter.toJson(new Point(5, 8))).isEqualTo("\"5 8\"");
-    assertThat(pointAdapter.fromJson("\"5 8\"")).isEqualTo(new Point(5, 8));
-  }
-
-  static class MultipleLayersJsonAdapter {
-    @ToJson List<Integer> pointToJson(Point point) {
-      return Arrays.asList(point.x, point.y);
-    }
-
-    @ToJson String integerListToJson(List<Integer> list) {
-      StringBuilder result = new StringBuilder();
-      for (Integer i : list) {
-        if (result.length() != 0) result.append(" ");
-        result.append(i.intValue());
-      }
-      return result.toString();
-    }
-
-    @FromJson Point pointFromJson(List<Integer> o) throws Exception {
-      if (o.size() != 2) throw new Exception("Expected 2 elements but was " + o);
-      return new Point(o.get(0), o.get(1));
-    }
-
-    @FromJson List<Integer> listOfIntegersFromJson(String list) throws Exception {
-      List<Integer> result = new ArrayList<>();
-      for (String part : list.split(" ")) {
-        result.add(Integer.parseInt(part));
-      }
-      return result;
-    }
-  }
-
-  @Test public void conflictingToAdapters() throws Exception {
-    Moshi.Builder builder = new Moshi.Builder();
-    try {
-      builder.add(new ConflictingsToJsonAdapter());
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).contains(
-          "Conflicting @ToJson methods:", "pointToJson1", "pointToJson2");
-    }
-  }
-
-  static class ConflictingsToJsonAdapter {
-    @ToJson List<Integer> pointToJson1(Point point) {
-      throw new AssertionError();
-    }
-
-    @ToJson String pointToJson2(Point point) {
-      throw new AssertionError();
-    }
-  }
-
-  @Test public void conflictingFromAdapters() throws Exception {
-    Moshi.Builder builder = new Moshi.Builder();
-    try {
-      builder.add(new ConflictingsFromJsonAdapter());
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).contains(
-          "Conflicting @FromJson methods:", "pointFromJson1", "pointFromJson2");
-    }
-  }
-
-  static class ConflictingsFromJsonAdapter {
-    @FromJson Point pointFromJson1(List<Integer> point) {
-      throw new AssertionError();
-    }
-
-    @FromJson Point pointFromJson2(String point) {
-      throw new AssertionError();
-    }
-  }
-
-  static class Point {
-    final int x;
-    final int y;
-
-    public Point(int x, int y) {
-      this.x = x;
-      this.y = y;
-    }
-
-    @Override public boolean equals(Object o) {
-      return o instanceof Point && ((Point) o).x == x && ((Point) o).y == y;
-    }
-
-    @Override public int hashCode() {
-      return x * 37 + y;
-    }
-  }
-}
diff --git a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
index 42eb2ef7..b589383c 100644
--- a/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
+++ b/moshi/src/test/java/com/squareup/moshi/MoshiTest.java
@@ -658,6 +658,32 @@ public final class MoshiTest {
     assertThat(adapter.fromJson("[2,3]")).containsExactly(2, 3);
   }
 
+  @Test public void enumAdapter() throws Exception {
+    Moshi moshi = new Moshi.Builder().build();
+    JsonAdapter<Roshambo> adapter = moshi.adapter(Roshambo.class).lenient();
+    assertThat(adapter.fromJson("\"ROCK\"")).isEqualTo(Roshambo.ROCK);
+    assertThat(adapter.toJson(Roshambo.PAPER)).isEqualTo("\"PAPER\"");
+  }
+
+  @Test public void invalidEnum() throws Exception {
+    Moshi moshi = new Moshi.Builder().build();
+    JsonAdapter<Roshambo> adapter = moshi.adapter(Roshambo.class).lenient();
+    try {
+      adapter.fromJson("\"SPOCK\"");
+      fail();
+    } catch (IllegalStateException expected) {
+      assertThat(expected.getMessage())
+          .isEqualTo("Expected one of [ROCK, PAPER, SCISSORS] but was SPOCK at path $");
+    }
+  }
+
+  @Test public void nullEnum() throws Exception {
+    Moshi moshi = new Moshi.Builder().build();
+    JsonAdapter<Roshambo> adapter = moshi.adapter(Roshambo.class).lenient();
+    assertThat(adapter.fromJson("null")).isNull();
+    assertThat(adapter.toJson(null)).isEqualTo("null");
+  }
+
   static class Pizza {
     final int diameter;
     final boolean extraCheese;
@@ -774,4 +800,10 @@ public final class MoshiTest {
       };
     }
   }
+
+  enum Roshambo {
+    ROCK,
+    PAPER,
+    SCISSORS
+  }
 }
diff --git a/pom.xml b/pom.xml
index 85059c77..202fc13c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -26,7 +26,7 @@
     <java.version>1.7</java.version>
 
     <!-- Dependencies -->
-    <okio.version>1.1.0</okio.version>
+    <okio.version>1.4.0</okio.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
