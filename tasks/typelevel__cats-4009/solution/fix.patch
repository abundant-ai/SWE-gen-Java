diff --git a/core/src/main/scala/cats/FlatMap.scala b/core/src/main/scala/cats/FlatMap.scala
index fe087077d..9bb64722c 100644
--- a/core/src/main/scala/cats/FlatMap.scala
+++ b/core/src/main/scala/cats/FlatMap.scala
@@ -36,7 +36,7 @@ package cats
  *
  * Must obey the laws defined in cats.laws.FlatMapLaws.
  */
-trait FlatMap[F[_]] extends Apply[F] {
+trait FlatMap[F[_]] extends Apply[F] with FlatMapArityFunctions[F] {
   def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]
 
   /**
diff --git a/project/Boilerplate.scala b/project/Boilerplate.scala
index 992924108..06348ce07 100644
--- a/project/Boilerplate.scala
+++ b/project/Boilerplate.scala
@@ -27,6 +27,7 @@ object Boilerplate {
     GenSemigroupalBuilders,
     GenSemigroupalArityFunctions,
     GenApplyArityFunctions,
+    GenFlatMapArityFunctions,
     GenTupleSemigroupalSyntax,
     GenParallelArityFunctions,
     GenParallelArityFunctions2,
@@ -285,6 +286,36 @@ object Boilerplate {
     }
   }
 
+  object GenFlatMapArityFunctions extends Template {
+    def filename(root: File) = root / "cats" / "FlatMapArityFunctions.scala"
+    override def range = 2 to maxArity
+    def content(tv: TemplateVals) = {
+      import tv._
+
+      val tpes = synTypes.map { tpe =>
+        s"F[$tpe]"
+      }
+      val fargs = (0 until arity).map("f" + _)
+      val fparams = fargs.zip(tpes).map { case (v, t) => s"$v:$t" }.mkString(", ")
+
+      block"""
+      |package cats
+      |
+      |/**
+      | * @groupprio Ungrouped 0
+      | *
+      | * @groupname FlatMapArity flatMap arity
+      | * @groupdesc FlatMapArity Higher-arity flatMap methods
+      | * @groupprio FlatMapArity 999
+      | */
+      |trait FlatMapArityFunctions[F[_]] { self: FlatMap[F] =>
+        -  /** @group FlatMapArity */
+        -  def flatMap$arity[${`A..N`}, Z]($fparams)(f: (${`A..N`}) => F[Z]): F[Z] = self.flatten(self.map$arity($fparams)(f))
+      |}
+      """
+    }
+  }
+
   final case class ParallelNestedExpansions(arity: Int) {
     val products = (0 until (arity - 2))
       .foldRight(s"Parallel.parProduct(m${arity - 2}, m${arity - 1})")((i, acc) => s"Parallel.parProduct(m$i, $acc)")
@@ -516,6 +547,12 @@ object Boilerplate {
         else
           s"def traverseN[G[_]: Applicative, Z](f: (${`A..N`}) => G[Z])(implicit traverse: Traverse[F], semigroupal: Semigroupal[F]): G[F[Z]] = Semigroupal.traverse$arity($tupleArgs)(f)"
 
+      val flatMap =
+        if (arity == 1)
+          s"def flatMap[Z](f: (${`A..N`}) => F[Z])(implicit flatMap: FlatMap[F]): F[Z] = flatMap.flatMap($tupleArgs)(f)"
+        else
+          s"def flatMapN[Z](f: (${`A..N`}) => F[Z])(implicit flatMap: FlatMap[F]): F[Z] = flatMap.flatMap$arity($tupleArgs)(f)"
+
       block"""
       |package cats
       |package syntax
@@ -528,6 +565,7 @@ object Boilerplate {
         -  $map
         -  $contramap
         -  $imap
+        -  $flatMap
         -  $tupled
         -  $traverse
         -  def apWith[Z](f: F[(${`A..N`}) => Z])(implicit apply: Apply[F]): F[Z] = apply.ap$n(f)($tupleArgs)
