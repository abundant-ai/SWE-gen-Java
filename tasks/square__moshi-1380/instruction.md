Some “code cleanup” changes inadvertently broke intentional behaviors in Moshi’s Kotlin-related APIs. These regressions show up in multiple areas: Kotlin extension utilities, adapter registration inference, and Kotlin JSON adapter/codegen behavior.

One regression is in the Kotlin extension that iterates through qualifier annotations. Given a set of qualifier annotations on a type (annotations marked with `@JsonQualifier`), calling `nextAnnotations<T>()` is expected to return the subset of qualifiers that come *after* the qualifier of type `T` in the iteration order, preserving the intended chaining behavior. For example, if both `@TestAnnotation1` and `@TestAnnotation2` (both `@JsonQualifier`) are present and you call `nextAnnotations<TestAnnotation2>()`, the result must be a non-null set containing exactly `@TestAnnotation1`. Currently, the cleanup changes cause this to return the wrong set (wrong size/order) or null.

Another regression affects Kotlin type utilities for arrays. Converting a Kotlin `KClass` or `KType` to an array `Type` via `asArrayType()` should produce a `java.lang.reflect.Type` representing an array whose generic component type matches the original type. This must work both for simple classes (e.g., `String::class.asArrayType()` should have `genericComponentType == String::class.java`) and for parameterized types (e.g., converting `typeOf<List<String>>().asArrayType()` should equal `Types.arrayOf(Types.newParameterizedType(List::class.java, String::class.java))`). The cleanup introduced incorrect type construction or loss of generic information.

A further regression affects Kotlin-friendly adapter registration on `Moshi.Builder`. When a caller passes a `JsonAdapter<T>` instance to `Moshi.Builder.addAdapter(...)`, Moshi should infer the adapter’s target type `T` from the adapter instance’s generic type and register it correctly. This should work for both non-parameterized adapters (e.g., a `JsonAdapter<Int>` registered via `addAdapter(customIntAdapter)` must be picked up by `moshi.adapter<Int>()`) and parameterized adapters (e.g., a `JsonAdapter<List<Int>>` registered via `addAdapter(customIntListAdapter)` must be picked up by `moshi.adapter<List<Int>>()`). Currently, Moshi fails to infer/register these adapters correctly, causing the default adapters to be used instead of the custom ones.

Finally, the Kotlin codegen/reflect integration must continue to enforce visibility rules and error reporting for generated adapters. For example, attempting to generate an adapter for a `@JsonClass(generateAdapter = true)` type with a private constructor must fail compilation with an error message containing `constructor is not internal or public`. Similarly, a `@JsonClass(generateAdapter = true)` type with a private constructor parameter/property must fail with an error message containing `property a is not visible`. The cleanup changes altered behavior such that these cases may no longer produce the expected failures/messages.

Fix these regressions so that:
- `nextAnnotations<T>()` returns the correct remaining qualifier annotations set as described above.
- `asArrayType()` preserves generic component types and matches expected `Types.arrayOf(...)` output for both raw and parameterized Kotlin types.
- `Moshi.Builder.addAdapter(adapter: JsonAdapter<T>)` correctly infers and registers the adapter for both simple and parameterized `T`.
- Kotlin codegen continues to reject unsupported visibility cases with the expected error messages.