diff --git a/core/src/main/scala/cats/Apply.scala b/core/src/main/scala/cats/Apply.scala
index 20780da9a..a4a661c2f 100644
--- a/core/src/main/scala/cats/Apply.scala
+++ b/core/src/main/scala/cats/Apply.scala
@@ -72,7 +72,7 @@ trait Apply[F[_]] extends Functor[F] with InvariantSemigroupal[F] with ApplyArit
    *
    */
   def productR[A, B](fa: F[A])(fb: F[B]): F[B] =
-    map2(fa, fb)((_, b) => b)
+    ap(map(fa)(_ => (b: B) => b))(fb)
 
   /**
    * Compose two actions, discarding any value produced by the second.
diff --git a/core/src/main/scala/cats/syntax/monadError.scala b/core/src/main/scala/cats/syntax/monadError.scala
index 9301bb371..1cae06f2e 100644
--- a/core/src/main/scala/cats/syntax/monadError.scala
+++ b/core/src/main/scala/cats/syntax/monadError.scala
@@ -24,7 +24,7 @@ final class MonadErrorOps[F[_], E, A](private val fa: F[A]) extends AnyVal {
    */
   def reject(pf: PartialFunction[A, E])(implicit F: MonadError[F, E]): F[A] =
     F.flatMap(fa) { a =>
-      pf.andThen(F.raiseError[A]).applyOrElse(a, (_: A) => fa)
+      pf.andThen(F.raiseError[A] _).applyOrElse(a, F.pure)
     }
 
   def adaptError(pf: PartialFunction[E, E])(implicit F: MonadError[F, E]): F[A] =
diff --git a/kernel/src/main/scala-2.12-/cats/kernel/compat/WrappedMutableMapBase.scala b/kernel/src/main/scala-2.12-/cats/kernel/compat/WrappedMutableMapBase.scala
index 216a84bd0..df8330d7c 100644
--- a/kernel/src/main/scala-2.12-/cats/kernel/compat/WrappedMutableMapBase.scala
+++ b/kernel/src/main/scala-2.12-/cats/kernel/compat/WrappedMutableMapBase.scala
@@ -3,7 +3,7 @@ package compat
 
 import scala.collection.mutable
 
-abstract private[kernel] class WrappedMutableMapBase[K, V](m: mutable.Map[K, V]) extends Map[K, V] {
+abstract private[kernel] class WrappedMutableMapBase[K, V](m: mutable.Map[K, V]) extends Map[K, V] with Serializable {
   def +[V2 >: V](kv: (K, V2)): Map[K, V2] = m.toMap + kv
   def -(key: K): Map[K, V] = m.toMap - key
 }
diff --git a/kernel/src/main/scala-2.13+/cats/kernel/compat/WrappedMutableMapBase.scala b/kernel/src/main/scala-2.13+/cats/kernel/compat/WrappedMutableMapBase.scala
index f72cb6238..9a810b285 100644
--- a/kernel/src/main/scala-2.13+/cats/kernel/compat/WrappedMutableMapBase.scala
+++ b/kernel/src/main/scala-2.13+/cats/kernel/compat/WrappedMutableMapBase.scala
@@ -3,7 +3,7 @@ package compat
 
 import scala.collection.mutable
 
-abstract private[kernel] class WrappedMutableMapBase[K, V](m: mutable.Map[K, V]) extends Map[K, V] {
+abstract private[kernel] class WrappedMutableMapBase[K, V](m: mutable.Map[K, V]) extends Map[K, V] with Serializable {
   def updated[V2 >: V](key: K, value: V2): Map[K, V2] = m.toMap + ((key, value))
   def remove(key: K): Map[K, V] = m.toMap - key
 }
diff --git a/kernel/src/main/scala/cats/kernel/Order.scala b/kernel/src/main/scala/cats/kernel/Order.scala
index 8563a5625..64cefa7ae 100644
--- a/kernel/src/main/scala/cats/kernel/Order.scala
+++ b/kernel/src/main/scala/cats/kernel/Order.scala
@@ -38,12 +38,12 @@ trait Order[@sp A] extends Any with PartialOrder[A] { self =>
   def partialCompare(x: A, y: A): Double = compare(x, y).toDouble
 
   /**
-   * If x <= y, return x, else return y.
+   * If x < y, return x, else return y.
    */
   def min(x: A, y: A): A = if (lt(x, y)) x else y
 
   /**
-   * If x >= y, return x, else return y.
+   * If x > y, return x, else return y.
    */
   def max(x: A, y: A): A = if (gt(x, y)) x else y
 
