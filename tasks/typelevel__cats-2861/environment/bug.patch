diff --git a/core/src/main/scala/cats/Apply.scala b/core/src/main/scala/cats/Apply.scala
index a4a661c2f..20780da9a 100644
--- a/core/src/main/scala/cats/Apply.scala
+++ b/core/src/main/scala/cats/Apply.scala
@@ -72,7 +72,7 @@ trait Apply[F[_]] extends Functor[F] with InvariantSemigroupal[F] with ApplyArit
    *
    */
   def productR[A, B](fa: F[A])(fb: F[B]): F[B] =
-    ap(map(fa)(_ => (b: B) => b))(fb)
+    map2(fa, fb)((_, b) => b)
 
   /**
    * Compose two actions, discarding any value produced by the second.
diff --git a/core/src/main/scala/cats/syntax/monadError.scala b/core/src/main/scala/cats/syntax/monadError.scala
index 1cae06f2e..9301bb371 100644
--- a/core/src/main/scala/cats/syntax/monadError.scala
+++ b/core/src/main/scala/cats/syntax/monadError.scala
@@ -24,7 +24,7 @@ final class MonadErrorOps[F[_], E, A](private val fa: F[A]) extends AnyVal {
    */
   def reject(pf: PartialFunction[A, E])(implicit F: MonadError[F, E]): F[A] =
     F.flatMap(fa) { a =>
-      pf.andThen(F.raiseError[A] _).applyOrElse(a, F.pure)
+      pf.andThen(F.raiseError[A]).applyOrElse(a, (_: A) => fa)
     }
 
   def adaptError(pf: PartialFunction[E, E])(implicit F: MonadError[F, E]): F[A] =
diff --git a/kernel/src/main/scala-2.12-/cats/kernel/compat/WrappedMutableMapBase.scala b/kernel/src/main/scala-2.12-/cats/kernel/compat/WrappedMutableMapBase.scala
index df8330d7c..216a84bd0 100644
--- a/kernel/src/main/scala-2.12-/cats/kernel/compat/WrappedMutableMapBase.scala
+++ b/kernel/src/main/scala-2.12-/cats/kernel/compat/WrappedMutableMapBase.scala
@@ -3,7 +3,7 @@ package compat
 
 import scala.collection.mutable
 
-abstract private[kernel] class WrappedMutableMapBase[K, V](m: mutable.Map[K, V]) extends Map[K, V] with Serializable {
+abstract private[kernel] class WrappedMutableMapBase[K, V](m: mutable.Map[K, V]) extends Map[K, V] {
   def +[V2 >: V](kv: (K, V2)): Map[K, V2] = m.toMap + kv
   def -(key: K): Map[K, V] = m.toMap - key
 }
diff --git a/kernel/src/main/scala-2.13+/cats/kernel/compat/WrappedMutableMapBase.scala b/kernel/src/main/scala-2.13+/cats/kernel/compat/WrappedMutableMapBase.scala
index 9a810b285..f72cb6238 100644
--- a/kernel/src/main/scala-2.13+/cats/kernel/compat/WrappedMutableMapBase.scala
+++ b/kernel/src/main/scala-2.13+/cats/kernel/compat/WrappedMutableMapBase.scala
@@ -3,7 +3,7 @@ package compat
 
 import scala.collection.mutable
 
-abstract private[kernel] class WrappedMutableMapBase[K, V](m: mutable.Map[K, V]) extends Map[K, V] with Serializable {
+abstract private[kernel] class WrappedMutableMapBase[K, V](m: mutable.Map[K, V]) extends Map[K, V] {
   def updated[V2 >: V](key: K, value: V2): Map[K, V2] = m.toMap + ((key, value))
   def remove(key: K): Map[K, V] = m.toMap - key
 }
diff --git a/kernel/src/main/scala/cats/kernel/Order.scala b/kernel/src/main/scala/cats/kernel/Order.scala
index 64cefa7ae..8563a5625 100644
--- a/kernel/src/main/scala/cats/kernel/Order.scala
+++ b/kernel/src/main/scala/cats/kernel/Order.scala
@@ -38,12 +38,12 @@ trait Order[@sp A] extends Any with PartialOrder[A] { self =>
   def partialCompare(x: A, y: A): Double = compare(x, y).toDouble
 
   /**
-   * If x < y, return x, else return y.
+   * If x <= y, return x, else return y.
    */
   def min(x: A, y: A): A = if (lt(x, y)) x else y
 
   /**
-   * If x > y, return x, else return y.
+   * If x >= y, return x, else return y.
    */
   def max(x: A, y: A): A = if (gt(x, y)) x else y
 
diff --git a/tests/src/test/scala/cats/tests/MapSuite.scala b/tests/src/test/scala/cats/tests/MapSuite.scala
index f84f8e6c3..efa600c56 100644
--- a/tests/src/test/scala/cats/tests/MapSuite.scala
+++ b/tests/src/test/scala/cats/tests/MapSuite.scala
@@ -11,7 +11,6 @@ import cats.laws.discipline.{
 }
 import cats.laws.discipline.arbitrary._
 import cats.arrow.Compose
-import cats.kernel.instances.StaticMethods.wrapMutableMap
 
 class MapSuite extends CatsSuite {
   implicit val iso = SemigroupalTests.Isomorphisms.invariant[Map[Int, ?]]
@@ -39,9 +38,4 @@ class MapSuite extends CatsSuite {
       map.show should ===(implicitly[Show[Map[Int, String]]].show(map))
     }
   }
-
-  {
-    val m = wrapMutableMap(scala.collection.mutable.Map(1 -> "one", 2 -> "two"))
-    checkAll("WrappedMutableMap", SerializableTests.serializable(m))
-  }
 }
diff --git a/tests/src/test/scala/cats/tests/RegressionSuite.scala b/tests/src/test/scala/cats/tests/RegressionSuite.scala
index a04d5f08c..261b1f513 100644
--- a/tests/src/test/scala/cats/tests/RegressionSuite.scala
+++ b/tests/src/test/scala/cats/tests/RegressionSuite.scala
@@ -1,7 +1,7 @@
 package cats
 package tests
 
-import cats.data.{Const, NonEmptyList, StateT}
+import cats.data.{Const, NonEmptyList}
 import scala.collection.mutable
 import scala.collection.immutable.SortedMap
 class RegressionSuite extends CatsSuite {
@@ -157,8 +157,4 @@ class RegressionSuite extends CatsSuite {
 
   }
 
-  test("#2809 MonadErrorOps.reject runs effects only once") {
-    val program = StateT.modify[Either[Throwable, ?], Int](_ + 1).reject { case _ if false => new Throwable }
-    program.runS(0).right.get should ===(1)
-  }
 }
