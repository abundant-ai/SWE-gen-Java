diff --git a/core/src/main/java/io/micronaut/core/util/NativeImageUtils.java b/core/src/main/java/io/micronaut/core/util/NativeImageUtils.java
index 616c1e4782..9c5f98f191 100644
--- a/core/src/main/java/io/micronaut/core/util/NativeImageUtils.java
+++ b/core/src/main/java/io/micronaut/core/util/NativeImageUtils.java
@@ -48,12 +48,6 @@ public final class NativeImageUtils {
      */
     public static final String PROPERTY_IMAGE_CODE_VALUE_RUNTIME = "runtime";
 
-    /**
-     * Native image produces an error at runtime if a JFR event class is initialized, even if that
-     * event is not enabled. This flag guards class initialization of any JFR events.
-     */
-    public static final boolean JFR_AVAILABLE = !inImageCode();
-
     private NativeImageUtils() {
     }
 
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index 3c3dc8495f..a2142a9421 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -65,7 +65,6 @@ wiremock = "2.33.2"
 mimepull = "1.10.0"
 micronaut-sourcegen = "1.6.2"
 icu4j = "76.1"
-jfrunit = "1.0.0.Alpha2"
 
 #
 # Versions which start with managed- are managed by Micronaut in the sense
@@ -304,8 +303,6 @@ mimepull = { module = "org.jvnet.mimepull:mimepull", version.ref = "mimepull" }
 
 wiremock = { module = "com.github.tomakehurst:wiremock-jre8", version.ref = "wiremock" }
 
-jfrunit-core = { module = "org.moditect.jfrunit:jfrunit-core", version.ref = "jfrunit" }
-
 [plugins]
 managed-kotlin-allopen = { id = "org.jetbrains.kotlin.plugin.allopen", version.ref = "managed-kotlin" }
 managed-kotlin-noarg = { id = "org.jetbrains.kotlin.plugin.noarg", version.ref = "managed-kotlin" }
diff --git a/http-server-netty/build.gradle.kts b/http-server-netty/build.gradle.kts
index bb2a3e43c5..03500980c2 100644
--- a/http-server-netty/build.gradle.kts
+++ b/http-server-netty/build.gradle.kts
@@ -77,7 +77,6 @@ dependencies {
     testImplementation(libs.httpcomponents.client)
     testImplementation(libs.httpcomponents.mime)
     testImplementation(libs.jetty.alpn.openjdk8.client)
-    testImplementation(libs.jfrunit.core)
 
     testImplementation(libs.managed.groovy.json)
     testImplementation(libs.managed.groovy.templates)
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http1RequestEvent.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http1RequestEvent.java
deleted file mode 100644
index 3d6af82be7..0000000000
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http1RequestEvent.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.server.netty.handler;
-
-import io.micronaut.core.annotation.Internal;
-import jdk.jfr.Description;
-
-/**
- * JFR event that tracks HTTP/1.x request lifetime.
- *
- * @since 4.9.0
- * @author Jonas Konrad
- */
-@Internal
-@Description("JFR event that tracks HTTP/1.x request lifetime.")
-final class Http1RequestEvent extends HttpRequestEvent {
-    private static final Http1RequestEvent EVENT = new Http1RequestEvent();
-
-    static boolean isTurnedOn() {
-        return EVENT.isEnabled();
-    }
-}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2RequestEvent.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2RequestEvent.java
deleted file mode 100644
index 3d0789cffb..0000000000
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2RequestEvent.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.server.netty.handler;
-
-import io.micronaut.core.annotation.Internal;
-import jdk.jfr.Description;
-
-/**
- * JFR event that tracks HTTP/2 request lifetime.
- *
- * @since 4.9.0
- * @author Jonas Konrad
- */
-@Internal
-@Description("JFR event that tracks HTTP/2 request lifetime.")
-final class Http2RequestEvent extends HttpRequestEvent {
-    private static final Http2RequestEvent EVENT = new Http2RequestEvent();
-
-    int streamId;
-
-    static boolean isTurnedOn() {
-        return EVENT.isEnabled();
-    }
-}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
index ebb4d155b2..0e88d3c5c4 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
@@ -346,7 +346,6 @@ public final class Http2ServerHandler extends MultiplexedServerHandler implement
         private boolean closeInput = false;
 
         Http2Stream(io.netty.handler.codec.http2.Http2Stream stream) {
-            super(stream.id());
             this.stream = stream;
         }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/HttpRequestEvent.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/HttpRequestEvent.java
deleted file mode 100644
index 72c334bfae..0000000000
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/HttpRequestEvent.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright 2017-2025 original authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package io.micronaut.http.server.netty.handler;
-
-import io.micronaut.core.annotation.Internal;
-import io.netty.channel.Channel;
-import io.netty.handler.codec.http.HttpRequest;
-import io.netty.handler.codec.http.HttpResponse;
-import jdk.jfr.Enabled;
-import jdk.jfr.Event;
-import jdk.jfr.StackTrace;
-
-/**
- * JFR event that tracks HTTP request lifetime.
- *
- * @since 4.9.0
- * @author Jonas Konrad
- */
-@Internal
-@StackTrace(false)
-@Enabled(false)
-abstract sealed class HttpRequestEvent extends Event permits Http1RequestEvent, Http2RequestEvent {
-    String channelId;
-    String method;
-    String uri;
-    int status;
-
-    void populateChannel(Channel channel) {
-        channelId = channel.id().asLongText();
-    }
-
-    void populateRequest(HttpRequest request) {
-        method = request.method().name();
-        uri = request.uri();
-    }
-
-    void populateResponse(HttpResponse response) {
-        status = response.status().code();
-    }
-}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
index 63491f0851..2416210503 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
@@ -18,7 +18,6 @@ package io.micronaut.http.server.netty.handler;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.util.NativeImageUtils;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.body.stream.BodySizeLimits;
 import io.micronaut.http.body.stream.BufferConsumer;
@@ -81,7 +80,6 @@ abstract class MultiplexedServerHandler {
      * An HTTP/2 or HTTP/3 stream.
      */
     abstract class MultiplexedStream implements OutboundAccess {
-        private final Http2RequestEvent jfrEvent;
         private HttpRequest request;
 
         private List<ByteBuf> bufferedContent;
@@ -94,15 +92,6 @@ abstract class MultiplexedServerHandler {
         private boolean responseDone;
         private Compressor.Session compressionSession;
 
-        MultiplexedStream(int streamId) {
-            if (NativeImageUtils.JFR_AVAILABLE && Http2RequestEvent.isTurnedOn()) {
-                jfrEvent = new Http2RequestEvent();
-                jfrEvent.streamId = streamId;
-            } else {
-                jfrEvent = null;
-            }
-        }
-
         /**
          * Called when the controller consumes some HTTP request data.
          *
@@ -305,7 +294,7 @@ abstract class MultiplexedServerHandler {
 
                     private void complete0() {
                         if (!responseDone) {
-                            writeData(Unpooled.EMPTY_BUFFER, true, endPromise(response));
+                            writeData(Unpooled.EMPTY_BUFFER, true, ctx.voidPromise());
                             if (finish()) {
                                 flush();
                             }
@@ -384,10 +373,10 @@ abstract class MultiplexedServerHandler {
                 empty = content == null;
             }
 
-            writeHeaders(response, empty, empty ? endPromise(response) : ctx.voidPromise());
+            writeHeaders(response, empty, ctx.voidPromise());
             if (!empty) {
                 // bypass writeDataCompressing
-                writeData0(content, true, endPromise(response));
+                writeData0(content, true, ctx.voidPromise());
             } else if (content != null) {
                 content.release();
             }
@@ -397,21 +386,6 @@ abstract class MultiplexedServerHandler {
             flush();
         }
 
-        private ChannelPromise endPromise(@NonNull HttpResponse response) {
-            if (jfrEvent == null) {
-                return ctx.voidPromise();
-            }
-            return ctx.newPromise().addListener((ChannelFutureListener) future -> {
-                jfrEvent.end();
-                if (jfrEvent.shouldCommit()) {
-                    jfrEvent.populateChannel(ctx.channel());
-                    jfrEvent.populateRequest(request);
-                    jfrEvent.populateResponse(response);
-                    jfrEvent.commit();
-                }
-            }).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
-        }
-
         private void logStreamWriteFailure(Throwable cause) {
             if (cause instanceof Http2Exception h2e) {
                 if (LOG.isDebugEnabled()) {
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
index d4544319da..7ddc2267cc 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
@@ -18,7 +18,6 @@ package io.micronaut.http.server.netty.handler;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
-import io.micronaut.core.util.NativeImageUtils;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.body.stream.BodySizeLimits;
 import io.micronaut.http.body.stream.BufferConsumer;
@@ -33,11 +32,9 @@ import io.micronaut.http.server.netty.HttpCompressionStrategy;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.CompositeByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
-import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoop;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.compression.Brotli;
@@ -265,26 +262,20 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
      * @param flush   {@code true} iff we should flush after this message
      * @param close   {@code true} iff the channel should be closed after this message
      */
-    private ChannelFuture write(Object message, boolean flush, boolean close, boolean needsPromise) {
+    private void write(Object message, boolean flush, boolean close) {
         if (close) {
-            return ctx.writeAndFlush(message)
-                .addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE)
-                .addListener(ChannelFutureListener.CLOSE);
+            ctx.writeAndFlush(message).addListener(ChannelFutureListener.CLOSE);
         } else {
-            ChannelPromise promise = needsPromise ?
-                ctx.newPromise().addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE) :
-                ctx.voidPromise();
             if (flush) {
                 // delay flush until readComplete if possible
                 if (reading) {
-                    ctx.write(message, promise);
+                    ctx.write(message, ctx.voidPromise());
                     flushPending = true;
-                    return promise;
                 } else {
-                    return ctx.writeAndFlush(message, promise);
+                    ctx.writeAndFlush(message, ctx.voidPromise());
                 }
             } else {
-                return ctx.write(message, promise);
+                ctx.write(message, ctx.voidPromise());
             }
         }
     }
@@ -750,7 +741,6 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
          * The request that caused this response. This is used for compression decisions.
          */
         private final HttpRequest request;
-        private final Http1RequestEvent jfrEvent;
         /**
          * The handler that will perform the actual write operation.
          */
@@ -760,12 +750,6 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
 
         private OutboundAccessImpl(HttpRequest request) {
             this.request = request;
-            if (NativeImageUtils.JFR_AVAILABLE && Http1RequestEvent.isTurnedOn()) {
-                this.jfrEvent = new Http1RequestEvent();
-                jfrEvent.begin();
-            } else {
-                this.jfrEvent = null;
-            }
         }
 
         /**
@@ -824,10 +808,6 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
                 HttpUtil.setKeepAlive(message, false);
                 closeAfterWrite();
             }
-
-            if (jfrEvent != null) {
-                jfrEvent.populateResponse(message);
-            }
         }
 
         /**
@@ -959,28 +939,13 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
 
         protected final void writeCompressing(HttpContent content, @SuppressWarnings("SameParameterValue") boolean flush, boolean close) {
             if (this.compressionSession == null) {
-                writePotentialEnd(content, flush, close);
+                write(content, flush, close);
             } else {
                 // slow path
                 writeCompressing0(content, flush, close);
             }
         }
 
-        void writePotentialEnd(Object content, boolean flush, boolean close) {
-            boolean record = outboundAccess.jfrEvent != null && content instanceof LastHttpContent;
-            ChannelFuture future = write(content, flush, close, record);
-            if (record) {
-                future.addListener((ChannelFutureListener) f -> {
-                    outboundAccess.jfrEvent.end();
-                    if (outboundAccess.jfrEvent.shouldCommit()) {
-                        outboundAccess.jfrEvent.populateChannel(ctx.channel());
-                        outboundAccess.jfrEvent.populateRequest(outboundAccess.request);
-                        outboundAccess.jfrEvent.commit();
-                    }
-                });
-            }
-        }
-
         private void writeCompressing0(HttpContent content, boolean flush, boolean close) {
             Compressor.Session compressionSession = this.compressionSession;
             compressionSession.push(content.content());
@@ -994,23 +959,23 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
                 compressionSession.fixContentLength(hr);
 
                 // this can happen in FullHttpResponse, just send the full body.
-                write(new DefaultHttpResponse(hr.protocolVersion(), hr.status(), hr.headers()), false, false, false);
+                write(new DefaultHttpResponse(hr.protocolVersion(), hr.status(), hr.headers()), false, false);
             }
             ByteBuf toSend = compressionSession.poll();
             // send the compressed buffer with the flags.
             if (toSend == null) {
                 if (last) {
                     HttpHeaders trailingHeaders = ((LastHttpContent) content).trailingHeaders();
-                    writePotentialEnd(trailingHeaders.isEmpty() ? LastHttpContent.EMPTY_LAST_CONTENT : new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, trailingHeaders), flush, close);
+                    write(trailingHeaders.isEmpty() ? LastHttpContent.EMPTY_LAST_CONTENT : new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, trailingHeaders), flush, close);
                 } else if (flush || close) {
                     // not sure if this can actually happen, but we need to forward a flush/close
-                    write(new DefaultHttpContent(Unpooled.EMPTY_BUFFER), flush, close, false);
+                    write(new DefaultHttpContent(Unpooled.EMPTY_BUFFER), flush, close);
                 } // else just don't send anything
             } else {
                 if (last) {
-                    writePotentialEnd(new DefaultLastHttpContent(toSend, ((LastHttpContent) content).trailingHeaders()), flush, close);
+                    write(new DefaultLastHttpContent(toSend, ((LastHttpContent) content).trailingHeaders()), flush, close);
                 } else {
-                    write(new DefaultHttpContent(toSend), flush, close, false);
+                    write(new DefaultHttpContent(toSend), flush, close);
                 }
             }
         }
@@ -1050,7 +1015,7 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
         @Override
         void writeSome() {
             if (!written) {
-                write(outboundAccess.request.protocolVersion().equals(HttpVersion.HTTP_1_0) ? CONTINUE_10 : CONTINUE_11, true, false, false);
+                write(outboundAccess.request.protocolVersion().equals(HttpVersion.HTTP_1_0) ? CONTINUE_10 : CONTINUE_11, true, false);
                 written = true;
             }
             if (next != null) {
@@ -1122,7 +1087,7 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
         @Override
         void writeSome() {
             if (initialMessage != null) {
-                write(initialMessage, false, false, false);
+                write(initialMessage, false, false);
                 initialMessage = null;
                 upstream.start();
             }
@@ -1202,7 +1167,7 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
             outboundHandler = null;
             if (!removed) {
                 if (initialMessage != null) {
-                    writePotentialEnd(initialMessage, false, false);
+                    write(initialMessage, false, false);
                     initialMessage = null;
                 }
 
diff --git a/http-server-netty/src/test/java/io/micronaut/http/server/netty/handler/Http1RequestEventTest.java b/http-server-netty/src/test/java/io/micronaut/http/server/netty/handler/Http1RequestEventTest.java
deleted file mode 100644
index 6f908b5232..0000000000
--- a/http-server-netty/src/test/java/io/micronaut/http/server/netty/handler/Http1RequestEventTest.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package io.micronaut.http.server.netty.handler;
-
-import io.micronaut.context.annotation.Property;
-import io.micronaut.http.client.HttpClient;
-import io.micronaut.http.client.annotation.Client;
-import io.micronaut.test.extensions.junit5.annotation.MicronautTest;
-import org.junit.jupiter.api.Test;
-import org.moditect.jfrunit.EnableEvent;
-import org.moditect.jfrunit.ExpectedEvent;
-import org.moditect.jfrunit.JfrEventTest;
-import org.moditect.jfrunit.JfrEventsAssert;
-
-@JfrEventTest
-@MicronautTest
-@Property(name = "spec.name", value = "HttpRequestEventTest")
-public class Http1RequestEventTest extends HttpRequestEventTest {
-    @Override
-    @EnableEvent("io.micronaut.http.server.netty.handler.Http1RequestEvent")
-    @Test
-    void test(@Client("/") HttpClient httpClient) {
-        super.test(httpClient);
-
-        JfrEventsAssert.assertThat(jfrEvents).contains(ExpectedEvent.event(Http1RequestEvent.class.getName())
-            .with("method", "GET")
-            .with("uri", "/foo")
-            .with("status", 234)
-        );
-    }
-}
diff --git a/http-server-netty/src/test/java/io/micronaut/http/server/netty/handler/Http2RequestEventTest.java b/http-server-netty/src/test/java/io/micronaut/http/server/netty/handler/Http2RequestEventTest.java
deleted file mode 100644
index 110fae16e0..0000000000
--- a/http-server-netty/src/test/java/io/micronaut/http/server/netty/handler/Http2RequestEventTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package io.micronaut.http.server.netty.handler;
-
-import io.micronaut.context.annotation.Property;
-import io.micronaut.http.client.HttpClient;
-import io.micronaut.http.client.annotation.Client;
-import io.micronaut.test.extensions.junit5.annotation.MicronautTest;
-import org.junit.jupiter.api.Test;
-import org.moditect.jfrunit.EnableEvent;
-import org.moditect.jfrunit.ExpectedEvent;
-import org.moditect.jfrunit.JfrEventTest;
-import org.moditect.jfrunit.JfrEventsAssert;
-
-@JfrEventTest
-@MicronautTest
-@Property(name = "micronaut.server.ssl.enabled", value = "true")
-@Property(name = "micronaut.server.ssl.buildSelfSigned", value = "true")
-@Property(name = "micronaut.server.ssl.port", value = "-1")
-@Property(name = "micronaut.server.http-version", value = "2.0")
-@Property(name = "micronaut.http.client.ssl.insecure-trust-all-certificates", value = "true")
-@Property(name = "spec.name", value = "HttpRequestEventTest")
-public class Http2RequestEventTest extends HttpRequestEventTest {
-    @Override
-    @EnableEvent("io.micronaut.http.server.netty.handler.Http2RequestEvent")
-    @Test
-    void test(@Client("/") HttpClient httpClient) {
-        super.test(httpClient);
-
-        JfrEventsAssert.assertThat(jfrEvents).contains(ExpectedEvent.event(Http2RequestEvent.class.getName())
-            .with("method", "GET")
-            .with("uri", "/foo")
-            .with("status", 234)
-            .with("streamId", 3)
-        );
-    }
-}
diff --git a/http-server-netty/src/test/java/io/micronaut/http/server/netty/handler/HttpRequestEventTest.java b/http-server-netty/src/test/java/io/micronaut/http/server/netty/handler/HttpRequestEventTest.java
deleted file mode 100644
index c7313993bd..0000000000
--- a/http-server-netty/src/test/java/io/micronaut/http/server/netty/handler/HttpRequestEventTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package io.micronaut.http.server.netty.handler;
-
-import io.micronaut.context.annotation.Requires;
-import io.micronaut.http.HttpResponse;
-import io.micronaut.http.annotation.Controller;
-import io.micronaut.http.annotation.Get;
-import io.micronaut.http.client.HttpClient;
-import org.junit.jupiter.api.Assertions;
-import org.moditect.jfrunit.JfrEvents;
-
-public class HttpRequestEventTest {
-    public JfrEvents jfrEvents = new JfrEvents();
-
-    void test(HttpClient httpClient) {
-        Assertions.assertEquals("bar", httpClient.toBlocking().retrieve("/foo"));
-    }
-
-    @Controller
-    @Requires(property = "spec.name", value = "HttpRequestEventTest")
-    static final class MyController {
-        @Get("/foo")
-        public HttpResponse<?> foo() {
-            return HttpResponse.status(234, "bla").body("bar");
-        }
-    }
-}
