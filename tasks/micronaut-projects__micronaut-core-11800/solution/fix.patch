diff --git a/core/src/main/java/io/micronaut/core/util/NativeImageUtils.java b/core/src/main/java/io/micronaut/core/util/NativeImageUtils.java
index 9c5f98f191..616c1e4782 100644
--- a/core/src/main/java/io/micronaut/core/util/NativeImageUtils.java
+++ b/core/src/main/java/io/micronaut/core/util/NativeImageUtils.java
@@ -48,6 +48,12 @@ public final class NativeImageUtils {
      */
     public static final String PROPERTY_IMAGE_CODE_VALUE_RUNTIME = "runtime";
 
+    /**
+     * Native image produces an error at runtime if a JFR event class is initialized, even if that
+     * event is not enabled. This flag guards class initialization of any JFR events.
+     */
+    public static final boolean JFR_AVAILABLE = !inImageCode();
+
     private NativeImageUtils() {
     }
 
diff --git a/gradle/libs.versions.toml b/gradle/libs.versions.toml
index a2142a9421..3c3dc8495f 100644
--- a/gradle/libs.versions.toml
+++ b/gradle/libs.versions.toml
@@ -65,6 +65,7 @@ wiremock = "2.33.2"
 mimepull = "1.10.0"
 micronaut-sourcegen = "1.6.2"
 icu4j = "76.1"
+jfrunit = "1.0.0.Alpha2"
 
 #
 # Versions which start with managed- are managed by Micronaut in the sense
@@ -303,6 +304,8 @@ mimepull = { module = "org.jvnet.mimepull:mimepull", version.ref = "mimepull" }
 
 wiremock = { module = "com.github.tomakehurst:wiremock-jre8", version.ref = "wiremock" }
 
+jfrunit-core = { module = "org.moditect.jfrunit:jfrunit-core", version.ref = "jfrunit" }
+
 [plugins]
 managed-kotlin-allopen = { id = "org.jetbrains.kotlin.plugin.allopen", version.ref = "managed-kotlin" }
 managed-kotlin-noarg = { id = "org.jetbrains.kotlin.plugin.noarg", version.ref = "managed-kotlin" }
diff --git a/http-server-netty/build.gradle.kts b/http-server-netty/build.gradle.kts
index 03500980c2..bb2a3e43c5 100644
--- a/http-server-netty/build.gradle.kts
+++ b/http-server-netty/build.gradle.kts
@@ -77,6 +77,7 @@ dependencies {
     testImplementation(libs.httpcomponents.client)
     testImplementation(libs.httpcomponents.mime)
     testImplementation(libs.jetty.alpn.openjdk8.client)
+    testImplementation(libs.jfrunit.core)
 
     testImplementation(libs.managed.groovy.json)
     testImplementation(libs.managed.groovy.templates)
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http1RequestEvent.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http1RequestEvent.java
new file mode 100644
index 0000000000..3d6af82be7
--- /dev/null
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http1RequestEvent.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2017-2025 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.netty.handler;
+
+import io.micronaut.core.annotation.Internal;
+import jdk.jfr.Description;
+
+/**
+ * JFR event that tracks HTTP/1.x request lifetime.
+ *
+ * @since 4.9.0
+ * @author Jonas Konrad
+ */
+@Internal
+@Description("JFR event that tracks HTTP/1.x request lifetime.")
+final class Http1RequestEvent extends HttpRequestEvent {
+    private static final Http1RequestEvent EVENT = new Http1RequestEvent();
+
+    static boolean isTurnedOn() {
+        return EVENT.isEnabled();
+    }
+}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2RequestEvent.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2RequestEvent.java
new file mode 100644
index 0000000000..3d0789cffb
--- /dev/null
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2RequestEvent.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2017-2025 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.netty.handler;
+
+import io.micronaut.core.annotation.Internal;
+import jdk.jfr.Description;
+
+/**
+ * JFR event that tracks HTTP/2 request lifetime.
+ *
+ * @since 4.9.0
+ * @author Jonas Konrad
+ */
+@Internal
+@Description("JFR event that tracks HTTP/2 request lifetime.")
+final class Http2RequestEvent extends HttpRequestEvent {
+    private static final Http2RequestEvent EVENT = new Http2RequestEvent();
+
+    int streamId;
+
+    static boolean isTurnedOn() {
+        return EVENT.isEnabled();
+    }
+}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
index 0e88d3c5c4..ebb4d155b2 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/Http2ServerHandler.java
@@ -346,6 +346,7 @@ public final class Http2ServerHandler extends MultiplexedServerHandler implement
         private boolean closeInput = false;
 
         Http2Stream(io.netty.handler.codec.http2.Http2Stream stream) {
+            super(stream.id());
             this.stream = stream;
         }
 
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/HttpRequestEvent.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/HttpRequestEvent.java
new file mode 100644
index 0000000000..72c334bfae
--- /dev/null
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/HttpRequestEvent.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2017-2025 original authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package io.micronaut.http.server.netty.handler;
+
+import io.micronaut.core.annotation.Internal;
+import io.netty.channel.Channel;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import jdk.jfr.Enabled;
+import jdk.jfr.Event;
+import jdk.jfr.StackTrace;
+
+/**
+ * JFR event that tracks HTTP request lifetime.
+ *
+ * @since 4.9.0
+ * @author Jonas Konrad
+ */
+@Internal
+@StackTrace(false)
+@Enabled(false)
+abstract sealed class HttpRequestEvent extends Event permits Http1RequestEvent, Http2RequestEvent {
+    String channelId;
+    String method;
+    String uri;
+    int status;
+
+    void populateChannel(Channel channel) {
+        channelId = channel.id().asLongText();
+    }
+
+    void populateRequest(HttpRequest request) {
+        method = request.method().name();
+        uri = request.uri();
+    }
+
+    void populateResponse(HttpResponse response) {
+        status = response.status().code();
+    }
+}
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
index 2416210503..63491f0851 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/MultiplexedServerHandler.java
@@ -18,6 +18,7 @@ package io.micronaut.http.server.netty.handler;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.util.NativeImageUtils;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.body.stream.BodySizeLimits;
 import io.micronaut.http.body.stream.BufferConsumer;
@@ -80,6 +81,7 @@ abstract class MultiplexedServerHandler {
      * An HTTP/2 or HTTP/3 stream.
      */
     abstract class MultiplexedStream implements OutboundAccess {
+        private final Http2RequestEvent jfrEvent;
         private HttpRequest request;
 
         private List<ByteBuf> bufferedContent;
@@ -92,6 +94,15 @@ abstract class MultiplexedServerHandler {
         private boolean responseDone;
         private Compressor.Session compressionSession;
 
+        MultiplexedStream(int streamId) {
+            if (NativeImageUtils.JFR_AVAILABLE && Http2RequestEvent.isTurnedOn()) {
+                jfrEvent = new Http2RequestEvent();
+                jfrEvent.streamId = streamId;
+            } else {
+                jfrEvent = null;
+            }
+        }
+
         /**
          * Called when the controller consumes some HTTP request data.
          *
@@ -294,7 +305,7 @@ abstract class MultiplexedServerHandler {
 
                     private void complete0() {
                         if (!responseDone) {
-                            writeData(Unpooled.EMPTY_BUFFER, true, ctx.voidPromise());
+                            writeData(Unpooled.EMPTY_BUFFER, true, endPromise(response));
                             if (finish()) {
                                 flush();
                             }
@@ -373,10 +384,10 @@ abstract class MultiplexedServerHandler {
                 empty = content == null;
             }
 
-            writeHeaders(response, empty, ctx.voidPromise());
+            writeHeaders(response, empty, empty ? endPromise(response) : ctx.voidPromise());
             if (!empty) {
                 // bypass writeDataCompressing
-                writeData0(content, true, ctx.voidPromise());
+                writeData0(content, true, endPromise(response));
             } else if (content != null) {
                 content.release();
             }
@@ -386,6 +397,21 @@ abstract class MultiplexedServerHandler {
             flush();
         }
 
+        private ChannelPromise endPromise(@NonNull HttpResponse response) {
+            if (jfrEvent == null) {
+                return ctx.voidPromise();
+            }
+            return ctx.newPromise().addListener((ChannelFutureListener) future -> {
+                jfrEvent.end();
+                if (jfrEvent.shouldCommit()) {
+                    jfrEvent.populateChannel(ctx.channel());
+                    jfrEvent.populateRequest(request);
+                    jfrEvent.populateResponse(response);
+                    jfrEvent.commit();
+                }
+            }).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+        }
+
         private void logStreamWriteFailure(Throwable cause) {
             if (cause instanceof Http2Exception h2e) {
                 if (LOG.isDebugEnabled()) {
diff --git a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
index 7ddc2267cc..d4544319da 100644
--- a/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
+++ b/http-server-netty/src/main/java/io/micronaut/http/server/netty/handler/PipeliningServerHandler.java
@@ -18,6 +18,7 @@ package io.micronaut.http.server.netty.handler;
 import io.micronaut.core.annotation.Internal;
 import io.micronaut.core.annotation.NonNull;
 import io.micronaut.core.annotation.Nullable;
+import io.micronaut.core.util.NativeImageUtils;
 import io.micronaut.http.body.ByteBody;
 import io.micronaut.http.body.stream.BodySizeLimits;
 import io.micronaut.http.body.stream.BufferConsumer;
@@ -32,9 +33,11 @@ import io.micronaut.http.server.netty.HttpCompressionStrategy;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.CompositeByteBuf;
 import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoop;
 import io.netty.channel.embedded.EmbeddedChannel;
 import io.netty.handler.codec.compression.Brotli;
@@ -262,20 +265,26 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
      * @param flush   {@code true} iff we should flush after this message
      * @param close   {@code true} iff the channel should be closed after this message
      */
-    private void write(Object message, boolean flush, boolean close) {
+    private ChannelFuture write(Object message, boolean flush, boolean close, boolean needsPromise) {
         if (close) {
-            ctx.writeAndFlush(message).addListener(ChannelFutureListener.CLOSE);
+            return ctx.writeAndFlush(message)
+                .addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE)
+                .addListener(ChannelFutureListener.CLOSE);
         } else {
+            ChannelPromise promise = needsPromise ?
+                ctx.newPromise().addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE) :
+                ctx.voidPromise();
             if (flush) {
                 // delay flush until readComplete if possible
                 if (reading) {
-                    ctx.write(message, ctx.voidPromise());
+                    ctx.write(message, promise);
                     flushPending = true;
+                    return promise;
                 } else {
-                    ctx.writeAndFlush(message, ctx.voidPromise());
+                    return ctx.writeAndFlush(message, promise);
                 }
             } else {
-                ctx.write(message, ctx.voidPromise());
+                return ctx.write(message, promise);
             }
         }
     }
@@ -741,6 +750,7 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
          * The request that caused this response. This is used for compression decisions.
          */
         private final HttpRequest request;
+        private final Http1RequestEvent jfrEvent;
         /**
          * The handler that will perform the actual write operation.
          */
@@ -750,6 +760,12 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
 
         private OutboundAccessImpl(HttpRequest request) {
             this.request = request;
+            if (NativeImageUtils.JFR_AVAILABLE && Http1RequestEvent.isTurnedOn()) {
+                this.jfrEvent = new Http1RequestEvent();
+                jfrEvent.begin();
+            } else {
+                this.jfrEvent = null;
+            }
         }
 
         /**
@@ -808,6 +824,10 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
                 HttpUtil.setKeepAlive(message, false);
                 closeAfterWrite();
             }
+
+            if (jfrEvent != null) {
+                jfrEvent.populateResponse(message);
+            }
         }
 
         /**
@@ -939,13 +959,28 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
 
         protected final void writeCompressing(HttpContent content, @SuppressWarnings("SameParameterValue") boolean flush, boolean close) {
             if (this.compressionSession == null) {
-                write(content, flush, close);
+                writePotentialEnd(content, flush, close);
             } else {
                 // slow path
                 writeCompressing0(content, flush, close);
             }
         }
 
+        void writePotentialEnd(Object content, boolean flush, boolean close) {
+            boolean record = outboundAccess.jfrEvent != null && content instanceof LastHttpContent;
+            ChannelFuture future = write(content, flush, close, record);
+            if (record) {
+                future.addListener((ChannelFutureListener) f -> {
+                    outboundAccess.jfrEvent.end();
+                    if (outboundAccess.jfrEvent.shouldCommit()) {
+                        outboundAccess.jfrEvent.populateChannel(ctx.channel());
+                        outboundAccess.jfrEvent.populateRequest(outboundAccess.request);
+                        outboundAccess.jfrEvent.commit();
+                    }
+                });
+            }
+        }
+
         private void writeCompressing0(HttpContent content, boolean flush, boolean close) {
             Compressor.Session compressionSession = this.compressionSession;
             compressionSession.push(content.content());
@@ -959,23 +994,23 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
                 compressionSession.fixContentLength(hr);
 
                 // this can happen in FullHttpResponse, just send the full body.
-                write(new DefaultHttpResponse(hr.protocolVersion(), hr.status(), hr.headers()), false, false);
+                write(new DefaultHttpResponse(hr.protocolVersion(), hr.status(), hr.headers()), false, false, false);
             }
             ByteBuf toSend = compressionSession.poll();
             // send the compressed buffer with the flags.
             if (toSend == null) {
                 if (last) {
                     HttpHeaders trailingHeaders = ((LastHttpContent) content).trailingHeaders();
-                    write(trailingHeaders.isEmpty() ? LastHttpContent.EMPTY_LAST_CONTENT : new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, trailingHeaders), flush, close);
+                    writePotentialEnd(trailingHeaders.isEmpty() ? LastHttpContent.EMPTY_LAST_CONTENT : new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, trailingHeaders), flush, close);
                 } else if (flush || close) {
                     // not sure if this can actually happen, but we need to forward a flush/close
-                    write(new DefaultHttpContent(Unpooled.EMPTY_BUFFER), flush, close);
+                    write(new DefaultHttpContent(Unpooled.EMPTY_BUFFER), flush, close, false);
                 } // else just don't send anything
             } else {
                 if (last) {
-                    write(new DefaultLastHttpContent(toSend, ((LastHttpContent) content).trailingHeaders()), flush, close);
+                    writePotentialEnd(new DefaultLastHttpContent(toSend, ((LastHttpContent) content).trailingHeaders()), flush, close);
                 } else {
-                    write(new DefaultHttpContent(toSend), flush, close);
+                    write(new DefaultHttpContent(toSend), flush, close, false);
                 }
             }
         }
@@ -1015,7 +1050,7 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
         @Override
         void writeSome() {
             if (!written) {
-                write(outboundAccess.request.protocolVersion().equals(HttpVersion.HTTP_1_0) ? CONTINUE_10 : CONTINUE_11, true, false);
+                write(outboundAccess.request.protocolVersion().equals(HttpVersion.HTTP_1_0) ? CONTINUE_10 : CONTINUE_11, true, false, false);
                 written = true;
             }
             if (next != null) {
@@ -1087,7 +1122,7 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
         @Override
         void writeSome() {
             if (initialMessage != null) {
-                write(initialMessage, false, false);
+                write(initialMessage, false, false, false);
                 initialMessage = null;
                 upstream.start();
             }
@@ -1167,7 +1202,7 @@ public final class PipeliningServerHandler extends ChannelInboundHandlerAdapter
             outboundHandler = null;
             if (!removed) {
                 if (initialMessage != null) {
-                    write(initialMessage, false, false);
+                    writePotentialEnd(initialMessage, false, false);
                     initialMessage = null;
                 }
 
