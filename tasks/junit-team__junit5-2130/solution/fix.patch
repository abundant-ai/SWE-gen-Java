diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
index 1b0a2bcc6..b30b39551 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
@@ -31,6 +31,8 @@ on GitHub.
 ==== New Features and Improvements
 
 * `TestExecutionSummary.Failure` is now serializable.
+* Running all tests with any tags or without any tags at all is now supported
+  by using the special expressions `any()` and `none()`.
 * `ReflectionSupport.findNestedClasses(...)` now detects cycles within inner class
   hierarchies. Consult the Javadoc for details.
 * `ThrowableCollector.toTestExecutionResult()` is now public.
diff --git a/documentation/src/docs/asciidoc/user-guide/running-tests.adoc b/documentation/src/docs/asciidoc/user-guide/running-tests.adoc
index 67d7a06db..8884da336 100644
--- a/documentation/src/docs/asciidoc/user-guide/running-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/running-tests.adoc
@@ -734,6 +734,10 @@ those supplied via the configuration file.
 Tag expressions are boolean expressions with the operators `!`, `&` and `|`. In addition,
 `(` and `)` can be used to adjust for operator precedence.
 
+Two special expressions are supported, `any()` and `none()`, which select all tests _with_
+any tags at all, and all tests _without_ any tags, respectively.
+These special expressions may be combined with other expressions just like normal tags.
+
 .Operators (in descending order of precedence)
 |===
 | Operator | Meaning | Associativity
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/ShuntingYard.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/ShuntingYard.java
index 36ce24574..a94c35c2b 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/ShuntingYard.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/ShuntingYard.java
@@ -16,6 +16,8 @@ import static org.junit.platform.launcher.tagexpression.ParseStatus.emptyTagExpr
 import static org.junit.platform.launcher.tagexpression.ParseStatus.missingClosingParenthesis;
 import static org.junit.platform.launcher.tagexpression.ParseStatus.missingOpeningParenthesis;
 import static org.junit.platform.launcher.tagexpression.ParseStatus.success;
+import static org.junit.platform.launcher.tagexpression.TagExpressions.any;
+import static org.junit.platform.launcher.tagexpression.TagExpressions.none;
 import static org.junit.platform.launcher.tagexpression.TagExpressions.tag;
 
 import java.util.List;
@@ -65,21 +67,32 @@ class ShuntingYard {
 	}
 
 	private ParseStatus process(Token token) {
-		if (LeftParenthesis.represents(token.string())) {
+		String trimmed = token.string();
+		if (LeftParenthesis.represents(trimmed)) {
 			pushOperatorAt(token, LeftParenthesis);
 			return success();
 		}
-		if (RightParenthesis.represents(token.string())) {
+		if (RightParenthesis.represents(trimmed)) {
 			return findMatchingLeftParenthesis(token);
 		}
-		if (validOperators.isOperator(token.string())) {
-			Operator operator = validOperators.operatorFor(token.string());
+		if (validOperators.isOperator(trimmed)) {
+			Operator operator = validOperators.operatorFor(trimmed);
 			return findOperands(token, operator);
 		}
-		pushExpressionAt(token, tag(token.string()));
+		pushExpressionAt(token, convertLeafTokenToExpression(trimmed));
 		return success();
 	}
 
+	private TagExpression convertLeafTokenToExpression(String trimmed) {
+		if ("any()".equalsIgnoreCase(trimmed)) {
+			return any();
+		}
+		if ("none()".equalsIgnoreCase(trimmed)) {
+			return none();
+		}
+		return tag(trimmed);
+	}
+
 	private ParseStatus findMatchingLeftParenthesis(Token token) {
 		while (!operators.isEmpty()) {
 			TokenWith<Operator> tokenWithWithOperator = operators.pop();
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/TagExpressions.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/TagExpressions.java
index a3e652620..657741594 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/TagExpressions.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/TagExpressions.java
@@ -34,6 +34,34 @@ class TagExpressions {
 		};
 	}
 
+	static TagExpression none() {
+		return new TagExpression() {
+			@Override
+			public boolean evaluate(Collection<TestTag> tags) {
+				return tags.isEmpty();
+			}
+
+			@Override
+			public String toString() {
+				return "none()";
+			}
+		};
+	}
+
+	static TagExpression any() {
+		return new TagExpression() {
+			@Override
+			public boolean evaluate(Collection<TestTag> tags) {
+				return !tags.isEmpty();
+			}
+
+			@Override
+			public String toString() {
+				return "any()";
+			}
+		};
+	}
+
 	static TagExpression not(TagExpression toNegate) {
 		return new TagExpression() {
 			@Override
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/Tokenizer.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/Tokenizer.java
index 6ef33ca82..e5820633b 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/Tokenizer.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/tagexpression/Tokenizer.java
@@ -10,47 +10,32 @@
 
 package org.junit.platform.launcher.tagexpression;
 
-import static java.util.Arrays.stream;
 import static java.util.Collections.emptyList;
+import static java.util.regex.Pattern.CASE_INSENSITIVE;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.stream.Collectors;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
 
 /**
  * @since 1.1
  */
 class Tokenizer {
 
+	private static final Pattern PATTERN = Pattern.compile("\\s*(?:(?:(?:any|none)\\(\\))|[()!|&]|(?:[^\\s()!|&]+))",
+		CASE_INSENSITIVE);
+
 	List<Token> tokenize(String infixTagExpression) {
 		if (infixTagExpression == null) {
 			return emptyList();
 		}
-
-		return deriveTokensFrom(infixTagExpression, trimmedTokenStringsFrom(infixTagExpression));
-	}
-
-	private List<String> trimmedTokenStringsFrom(String infixTagExpression) {
-		String[] parts = infixTagExpression.replaceAll("([()!|&])", " $1 ").split("\\s");
-		return stream(parts).filter(part -> !part.isEmpty()).collect(Collectors.toList());
-	}
-
-	private List<Token> deriveTokensFrom(String infixTagExpression, List<String> trimmedTokens) {
-		int startIndex = 0;
-		List<Token> tokens = new ArrayList<>(trimmedTokens.size());
-		for (String trimmedToken : trimmedTokens) {
-			Token token = extractTokenStartingAt(infixTagExpression, startIndex, trimmedToken);
-			startIndex = token.endIndexExclusive();
-			tokens.add(token);
+		List<Token> parts = new ArrayList<>();
+		Matcher matcher = PATTERN.matcher(infixTagExpression);
+		while (matcher.find()) {
+			parts.add(new Token(matcher.start(), matcher.group()));
 		}
-		return tokens;
-	}
-
-	private Token extractTokenStartingAt(String infixTagExpression, int startIndex, String trimmedToken) {
-		int foundAt = infixTagExpression.indexOf(trimmedToken, startIndex);
-		int endIndex = foundAt + trimmedToken.length();
-		String rawToken = infixTagExpression.substring(startIndex, endIndex);
-		return new Token(startIndex, rawToken);
+		return parts;
 	}
 
 }
