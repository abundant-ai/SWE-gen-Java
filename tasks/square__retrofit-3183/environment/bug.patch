diff --git a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
index e79205ab..bc8bdf81 100644
--- a/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
+++ b/retrofit/src/main/java/retrofit2/HttpServiceMethod.java
@@ -186,22 +186,9 @@ abstract class HttpServiceMethod<ResponseT, ReturnT> extends ServiceMethod<Retur
 
       //noinspection unchecked Checked by reflection inside RequestFactory.
       Continuation<ResponseT> continuation = (Continuation<ResponseT>) args[args.length - 1];
-
-      // Calls to OkHttp Call.enqueue() like those inside await and awaitNullable can sometimes
-      // invoke the supplied callback with an exception before the invoking stack frame can return.
-      // Coroutines will intercept the subsequent invocation of the Continuation and throw the
-      // exception synchronously. A Java Proxy cannot throw checked exceptions without them being
-      // declared on the interface method. To avoid the synchronous checked exception being wrapped
-      // in an UndeclaredThrowableException, it is intercepted and supplied to a helper which will
-      // force suspension to occur so that it can be instead delivered to the continuation to
-      // bypass this restriction.
-      try {
-        return isNullable
-            ? KotlinExtensions.awaitNullable(call, continuation)
-            : KotlinExtensions.await(call, continuation);
-      } catch (Exception e) {
-        return KotlinExtensions.yieldAndThrow(e, continuation);
-      }
+      return isNullable
+          ? KotlinExtensions.awaitNullable(call, continuation)
+          : KotlinExtensions.await(call, continuation);
     }
   }
 }
diff --git a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
index 7137ac92..b24212e0 100644
--- a/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
+++ b/retrofit/src/main/java/retrofit2/KotlinExtensions.kt
@@ -19,7 +19,6 @@
 package retrofit2
 
 import kotlinx.coroutines.suspendCancellableCoroutine
-import kotlinx.coroutines.yield
 import kotlin.coroutines.resume
 import kotlin.coroutines.resumeWithException
 
@@ -96,8 +95,3 @@ suspend fun <T : Any> Call<T>.awaitResponse(): Response<T> {
     })
   }
 }
-
-internal suspend fun Exception.yieldAndThrow(): Nothing {
-  yield()
-  throw this
-}
diff --git a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
index e3c005e8..629b0262 100644
--- a/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
+++ b/retrofit/src/test/java/retrofit2/KotlinSuspendTest.kt
@@ -273,26 +273,4 @@ class KotlinSuspendTest {
     val body = runBlocking { example.body() }
     assertThat(body).isEqualTo("HiHiHiHiHi")
   }
-
-  @Test fun checkedExceptionsAreNotSynchronouslyThrown() = runBlocking {
-    val retrofit = Retrofit.Builder()
-        .baseUrl("https://unresolved-host.com/")
-        .addConverterFactory(ToStringConverterFactory())
-        .build()
-    val example = retrofit.create(Service::class.java)
-
-    server.shutdown()
-
-    // The problematic behavior of the UnknownHostException being synchronously thrown is
-    // probabilistic based on thread preemption. Running a thousand times will almost always
-    // trigger it, so we run an order of magnitude more to be safe.
-    repeat(10000) {
-      try {
-        example.body()
-        fail()
-      } catch (_: IOException) {
-        // We expect IOException, the bad behavior will wrap this in UndeclaredThrowableException.
-      }
-    }
-  }
 }
