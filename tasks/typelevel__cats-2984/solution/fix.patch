diff --git a/.scalafmt.conf b/.scalafmt.conf
index 303be4032..4fe86abb5 100644
--- a/.scalafmt.conf
+++ b/.scalafmt.conf
@@ -1,4 +1,4 @@
-version=2.0.1
+version=2.0.0
 align.openParenCallSite = true
 align.openParenDefnSite = true
 maxColumn = 120
diff --git a/core/src/main/scala/cats/data/Chain.scala b/core/src/main/scala/cats/data/Chain.scala
index a09d27c52..03b0a2aaa 100644
--- a/core/src/main/scala/cats/data/Chain.scala
+++ b/core/src/main/scala/cats/data/Chain.scala
@@ -531,14 +531,6 @@ object Chain extends ChainInstances {
       false // b/c `fromSeq` constructor doesn't allow either branch to be empty
   }
 
-  def unapplySeq[A](chain: Chain[A]): Option[Seq[A]] =
-    Some(chain.toList)
-
-  object ==: {
-    def unapply[T](c: Chain[T]): Option[(T, Chain[T])] =
-      c.uncons
-  }
-
   /** Empty Chain. */
   val nil: Chain[Nothing] = Empty
 
diff --git a/core/src/main/scala/cats/data/EitherT.scala b/core/src/main/scala/cats/data/EitherT.scala
index a267f9684..61e462ca4 100644
--- a/core/src/main/scala/cats/data/EitherT.scala
+++ b/core/src/main/scala/cats/data/EitherT.scala
@@ -49,7 +49,7 @@ final case class EitherT[F[_], A, B](value: F[Either[A, B]]) {
   /**
    * Inverse of `MonadError#attemptT`
    */
-  def rethrowT(implicit F: MonadError[F, A]): F[B] =
+  def rethrowT(implicit F: MonadError[F, _ >: A]): F[B] =
     F.rethrow(value)
 
   def valueOr[BB >: B](f: A => BB)(implicit F: Functor[F]): F[BB] = fold(f, identity)
diff --git a/core/src/main/scala/cats/data/NonEmptyMapImpl.scala b/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
index 3195c8869..aae059c1c 100644
--- a/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
+++ b/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
@@ -265,7 +265,7 @@ sealed class NonEmptyMapOps[K, A](val value: NonEmptyMap[K, A]) {
   def toNel: NonEmptyList[(K, A)] = NonEmptyList.fromListUnsafe(toSortedMap.toList)
 }
 
-sealed abstract private[data] class NonEmptyMapInstances extends NonEmptyMapInstances0 {
+sealed abstract private[data] class NonEmptyMapInstances {
 
   implicit def catsDataInstancesForNonEmptyMap[K: Order]
     : SemigroupK[NonEmptyMap[K, *]] with NonEmptyTraverse[NonEmptyMap[K, *]] =
@@ -318,8 +318,10 @@ sealed abstract private[data] class NonEmptyMapInstances extends NonEmptyMapInst
         NonEmptyList(fa.head._2, fa.tail.toList.map(_._2))
     }
 
-  implicit def catsDataHashForNonEmptyMap[K: Hash: Order, A: Hash]: Hash[NonEmptyMap[K, A]] =
-    Hash[SortedMap[K, A]].asInstanceOf[Hash[NonEmptyMap[K, A]]]
+  implicit def catsDataEqForNonEmptyMap[K: Order, A: Eq]: Eq[NonEmptyMap[K, A]] =
+    new Eq[NonEmptyMap[K, A]] {
+      def eqv(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): Boolean = x === y
+    }
 
   implicit def catsDataShowForNonEmptyMap[K: Show, A: Show]: Show[NonEmptyMap[K, A]] =
     Show.show[NonEmptyMap[K, A]](_.show)
@@ -328,10 +330,3 @@ sealed abstract private[data] class NonEmptyMapInstances extends NonEmptyMapInst
     def combine(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): NonEmptyMap[K, A] = x ++ y
   }
 }
-
-sealed abstract private[data] class NonEmptyMapInstances0 {
-  implicit def catsDataEqForNonEmptyMap[K: Order, A: Eq]: Eq[NonEmptyMap[K, A]] =
-    new Eq[NonEmptyMap[K, A]] {
-      def eqv(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): Boolean = x === y
-    }
-}
diff --git a/core/src/main/scala/cats/syntax/either.scala b/core/src/main/scala/cats/syntax/either.scala
index bca66e12d..c63cf5268 100644
--- a/core/src/main/scala/cats/syntax/either.scala
+++ b/core/src/main/scala/cats/syntax/either.scala
@@ -276,6 +276,7 @@ final class EitherOps[A, B](private val eab: Either[A, B]) extends AnyVal {
 
   def toEitherNel[AA >: A]: EitherNel[AA, B] = leftMap(NonEmptyList.one)
 
+  @deprecated("use liftTo instead", "2.0.0")
   def raiseOrPure[F[_]](implicit ev: ApplicativeError[F, A]): F[B] =
     ev.fromEither(eab)
 
diff --git a/core/src/main/scala/cats/syntax/validated.scala b/core/src/main/scala/cats/syntax/validated.scala
index 6e76c52cf..547011cf6 100644
--- a/core/src/main/scala/cats/syntax/validated.scala
+++ b/core/src/main/scala/cats/syntax/validated.scala
@@ -20,7 +20,7 @@ trait ValidatedExtensionSyntax {
 }
 
 final class ValidatedExtension[E, A](private val self: Validated[E, A]) extends AnyVal {
-  def liftTo[F[_]](implicit F: ApplicativeError[F, E]): F[A] =
+  def liftTo[F[_]](implicit F: ApplicativeError[F, _ >: E]): F[A] =
     new ApplicativeErrorExtensionOps(F).fromValidated(self)
 }
 
diff --git a/docs/src/main/tut/typeclasses/comonad.md b/docs/src/main/tut/typeclasses/comonad.md
index c81f09a8b..09ca14760 100644
--- a/docs/src/main/tut/typeclasses/comonad.md
+++ b/docs/src/main/tut/typeclasses/comonad.md
@@ -22,7 +22,7 @@ able to implement extract we must have a type of which we are certain
 we can get an `A` from an `F[A]`. For example we cannot always get an `A` 
 from a `List[A]` because if the list is empty there is nothing to get.
 
-For the same reason, `Option` doesn't have a `Comonad` instance, because we 
+For the same reason, `Option` doesn't have a Comand instance, because we 
 cannot always get an `A` from an Option, it may be empty too.
 
 Some examples that we can implement `Comonad` for include `OneAnd`, `Tuple2` 
