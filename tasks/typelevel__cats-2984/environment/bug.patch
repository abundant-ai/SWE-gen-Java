diff --git a/.scalafmt.conf b/.scalafmt.conf
index 4fe86abb5..303be4032 100644
--- a/.scalafmt.conf
+++ b/.scalafmt.conf
@@ -1,4 +1,4 @@
-version=2.0.0
+version=2.0.1
 align.openParenCallSite = true
 align.openParenDefnSite = true
 maxColumn = 120
diff --git a/core/src/main/scala/cats/data/Chain.scala b/core/src/main/scala/cats/data/Chain.scala
index 03b0a2aaa..a09d27c52 100644
--- a/core/src/main/scala/cats/data/Chain.scala
+++ b/core/src/main/scala/cats/data/Chain.scala
@@ -531,6 +531,14 @@ object Chain extends ChainInstances {
       false // b/c `fromSeq` constructor doesn't allow either branch to be empty
   }
 
+  def unapplySeq[A](chain: Chain[A]): Option[Seq[A]] =
+    Some(chain.toList)
+
+  object ==: {
+    def unapply[T](c: Chain[T]): Option[(T, Chain[T])] =
+      c.uncons
+  }
+
   /** Empty Chain. */
   val nil: Chain[Nothing] = Empty
 
diff --git a/core/src/main/scala/cats/data/EitherT.scala b/core/src/main/scala/cats/data/EitherT.scala
index 61e462ca4..a267f9684 100644
--- a/core/src/main/scala/cats/data/EitherT.scala
+++ b/core/src/main/scala/cats/data/EitherT.scala
@@ -49,7 +49,7 @@ final case class EitherT[F[_], A, B](value: F[Either[A, B]]) {
   /**
    * Inverse of `MonadError#attemptT`
    */
-  def rethrowT(implicit F: MonadError[F, _ >: A]): F[B] =
+  def rethrowT(implicit F: MonadError[F, A]): F[B] =
     F.rethrow(value)
 
   def valueOr[BB >: B](f: A => BB)(implicit F: Functor[F]): F[BB] = fold(f, identity)
diff --git a/core/src/main/scala/cats/data/NonEmptyMapImpl.scala b/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
index aae059c1c..3195c8869 100644
--- a/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
+++ b/core/src/main/scala/cats/data/NonEmptyMapImpl.scala
@@ -265,7 +265,7 @@ sealed class NonEmptyMapOps[K, A](val value: NonEmptyMap[K, A]) {
   def toNel: NonEmptyList[(K, A)] = NonEmptyList.fromListUnsafe(toSortedMap.toList)
 }
 
-sealed abstract private[data] class NonEmptyMapInstances {
+sealed abstract private[data] class NonEmptyMapInstances extends NonEmptyMapInstances0 {
 
   implicit def catsDataInstancesForNonEmptyMap[K: Order]
     : SemigroupK[NonEmptyMap[K, *]] with NonEmptyTraverse[NonEmptyMap[K, *]] =
@@ -318,10 +318,8 @@ sealed abstract private[data] class NonEmptyMapInstances {
         NonEmptyList(fa.head._2, fa.tail.toList.map(_._2))
     }
 
-  implicit def catsDataEqForNonEmptyMap[K: Order, A: Eq]: Eq[NonEmptyMap[K, A]] =
-    new Eq[NonEmptyMap[K, A]] {
-      def eqv(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): Boolean = x === y
-    }
+  implicit def catsDataHashForNonEmptyMap[K: Hash: Order, A: Hash]: Hash[NonEmptyMap[K, A]] =
+    Hash[SortedMap[K, A]].asInstanceOf[Hash[NonEmptyMap[K, A]]]
 
   implicit def catsDataShowForNonEmptyMap[K: Show, A: Show]: Show[NonEmptyMap[K, A]] =
     Show.show[NonEmptyMap[K, A]](_.show)
@@ -330,3 +328,10 @@ sealed abstract private[data] class NonEmptyMapInstances {
     def combine(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): NonEmptyMap[K, A] = x ++ y
   }
 }
+
+sealed abstract private[data] class NonEmptyMapInstances0 {
+  implicit def catsDataEqForNonEmptyMap[K: Order, A: Eq]: Eq[NonEmptyMap[K, A]] =
+    new Eq[NonEmptyMap[K, A]] {
+      def eqv(x: NonEmptyMap[K, A], y: NonEmptyMap[K, A]): Boolean = x === y
+    }
+}
diff --git a/core/src/main/scala/cats/syntax/either.scala b/core/src/main/scala/cats/syntax/either.scala
index c63cf5268..bca66e12d 100644
--- a/core/src/main/scala/cats/syntax/either.scala
+++ b/core/src/main/scala/cats/syntax/either.scala
@@ -276,7 +276,6 @@ final class EitherOps[A, B](private val eab: Either[A, B]) extends AnyVal {
 
   def toEitherNel[AA >: A]: EitherNel[AA, B] = leftMap(NonEmptyList.one)
 
-  @deprecated("use liftTo instead", "2.0.0")
   def raiseOrPure[F[_]](implicit ev: ApplicativeError[F, A]): F[B] =
     ev.fromEither(eab)
 
diff --git a/core/src/main/scala/cats/syntax/validated.scala b/core/src/main/scala/cats/syntax/validated.scala
index 547011cf6..6e76c52cf 100644
--- a/core/src/main/scala/cats/syntax/validated.scala
+++ b/core/src/main/scala/cats/syntax/validated.scala
@@ -20,7 +20,7 @@ trait ValidatedExtensionSyntax {
 }
 
 final class ValidatedExtension[E, A](private val self: Validated[E, A]) extends AnyVal {
-  def liftTo[F[_]](implicit F: ApplicativeError[F, _ >: E]): F[A] =
+  def liftTo[F[_]](implicit F: ApplicativeError[F, E]): F[A] =
     new ApplicativeErrorExtensionOps(F).fromValidated(self)
 }
 
diff --git a/docs/src/main/tut/typeclasses/comonad.md b/docs/src/main/tut/typeclasses/comonad.md
index 09ca14760..c81f09a8b 100644
--- a/docs/src/main/tut/typeclasses/comonad.md
+++ b/docs/src/main/tut/typeclasses/comonad.md
@@ -22,7 +22,7 @@ able to implement extract we must have a type of which we are certain
 we can get an `A` from an `F[A]`. For example we cannot always get an `A` 
 from a `List[A]` because if the list is empty there is nothing to get.
 
-For the same reason, `Option` doesn't have a Comand instance, because we 
+For the same reason, `Option` doesn't have a `Comonad` instance, because we 
 cannot always get an `A` from an Option, it may be empty too.
 
 Some examples that we can implement `Comonad` for include `OneAnd`, `Tuple2` 
diff --git a/tests/src/test/scala/cats/tests/ChainSuite.scala b/tests/src/test/scala/cats/tests/ChainSuite.scala
index 042a8a86c..ca22f1700 100644
--- a/tests/src/test/scala/cats/tests/ChainSuite.scala
+++ b/tests/src/test/scala/cats/tests/ChainSuite.scala
@@ -2,6 +2,7 @@ package cats
 package tests
 
 import cats.data.Chain
+import cats.data.Chain.==:
 import cats.laws.discipline.{
   AlternativeTests,
   CoflatMapTests,
@@ -74,6 +75,17 @@ class ChainSuite extends CatsSuite {
     }
   }
 
+  test("list-like pattern match") {
+    Chain(1, 2, 3) match {
+      case Chain(a, b, c) => (a, b, c) should ===((1, 2, 3))
+    }
+
+    Chain(1, 2, 3) match {
+      case h ==: t => (h, t) should ===(1 -> Chain(2, 3))
+    }
+
+  }
+
   test("size is consistent with toList.size") {
     forAll { (ci: Chain[Int]) =>
       ci.size.toInt should ===(ci.toList.size)
diff --git a/tests/src/test/scala/cats/tests/EitherTSuite.scala b/tests/src/test/scala/cats/tests/EitherTSuite.scala
index ce9886058..0e637b285 100644
--- a/tests/src/test/scala/cats/tests/EitherTSuite.scala
+++ b/tests/src/test/scala/cats/tests/EitherTSuite.scala
@@ -285,15 +285,6 @@ class EitherTSuite extends CatsSuite {
     failed.attemptT.rethrowT should ===(failed)
   }
 
-  test("rethrowT works with specialized failures") {
-    implicit val eqThrow: Eq[Throwable] = Eq.fromUniversalEquals
-    val failed: Try[Int] = Failure(new IllegalArgumentException("error"))
-
-    val t: EitherT[Try, IllegalArgumentException, Int] =
-      failed.attemptT.leftMap(_.asInstanceOf[IllegalArgumentException])
-    t.rethrowT should ===(failed)
-  }
-
   test("transform consistent with value.map") {
     forAll { (eithert: EitherT[List, String, Int], f: Either[String, Int] => Either[Long, Double]) =>
       eithert.transform(f) should ===(EitherT(eithert.value.map(f)))
diff --git a/tests/src/test/scala/cats/tests/NonEmptyMapSuite.scala b/tests/src/test/scala/cats/tests/NonEmptyMapSuite.scala
index 244706e46..2b61a76f0 100644
--- a/tests/src/test/scala/cats/tests/NonEmptyMapSuite.scala
+++ b/tests/src/test/scala/cats/tests/NonEmptyMapSuite.scala
@@ -33,6 +33,7 @@ class NonEmptyMapSuite extends CatsSuite {
   )
   checkAll("NonEmptyMap[String, Int]", BandTests[NonEmptyMap[String, Int]].band)
   checkAll("NonEmptyMap[String, Int]", EqTests[NonEmptyMap[String, Int]].eqv)
+  checkAll("NonEmptyMap[String, Int]", HashTests[NonEmptyMap[String, Int]].hash)
 
   test("Show is not empty and is formatted as expected") {
     forAll { (nem: NonEmptyMap[String, Int]) =>
diff --git a/tests/src/test/scala/cats/tests/ValidatedSuite.scala b/tests/src/test/scala/cats/tests/ValidatedSuite.scala
index a7bc31cb2..faf6fb70f 100644
--- a/tests/src/test/scala/cats/tests/ValidatedSuite.scala
+++ b/tests/src/test/scala/cats/tests/ValidatedSuite.scala
@@ -314,13 +314,4 @@ class ValidatedSuite extends CatsSuite {
       v.liftTo[Option] shouldBe v.toOption
     }
   }
-
-  test("liftTo works with specialized errors") {
-    implicit val eqThrow: Eq[Throwable] = Eq.fromUniversalEquals
-    val ex: IllegalArgumentException = new IllegalArgumentException()
-    val validated: Validated[IllegalArgumentException, Int] = Validated.Invalid(ex)
-    val lifted: Either[Throwable, Int] = validated.liftTo[Either[Throwable, *]]
-
-    lifted should ===(Left[Throwable, Int](ex))
-  }
 }
