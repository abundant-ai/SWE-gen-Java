diff --git a/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java b/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
index ec1fcba17..37cc45182 100644
--- a/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
+++ b/src/main/java/org/mockito/internal/invocation/InterceptedInvocation.java
@@ -4,7 +4,6 @@
  */
 package org.mockito.internal.invocation;
 
-import org.mockito.ArgumentMatcher;
 import org.mockito.internal.invocation.mockref.MockReference;
 import org.mockito.internal.exceptions.VerificationAwareInvocation;
 import org.mockito.internal.reporting.PrintSettings;
@@ -14,10 +13,8 @@ import org.mockito.invocation.StubInfo;
 
 import java.lang.reflect.Method;
 import java.util.Arrays;
-import java.util.List;
 
 import static org.mockito.internal.exceptions.Reporter.cannotCallAbstractRealMethod;
-import static org.mockito.internal.invocation.ArgumentsProcessor.argumentsToMatchers;
 
 public class InterceptedInvocation implements Invocation, VerificationAwareInvocation {
 
@@ -122,23 +119,6 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
         return (T) arguments[index];
     }
 
-    public MockReference<Object> getMockRef() {
-        return mockRef;
-    }
-
-    public MockitoMethod getMockitoMethod() {
-        return mockitoMethod;
-    }
-
-    public RealMethod getRealMethod() {
-        return realMethod;
-    }
-
-    @Override
-    public List<ArgumentMatcher> getArgumentsAsMatchers() {
-        return argumentsToMatchers(getArguments());
-    }
-
     @Override
     public <T> T getArgument(int index, Class<T> clazz) {
         return clazz.cast(arguments[index]);
@@ -174,7 +154,7 @@ public class InterceptedInvocation implements Invocation, VerificationAwareInvoc
     }
 
     public String toString() {
-        return new PrintSettings().print(getArgumentsAsMatchers(), this);
+        return new PrintSettings().print(ArgumentsProcessor.argumentsToMatchers(getArguments()), this);
     }
 
     public final static RealMethod NO_OP = new RealMethod() {
diff --git a/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java b/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
index bc14300a3..83a28ff9d 100644
--- a/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
+++ b/src/main/java/org/mockito/internal/invocation/InvocationMatcher.java
@@ -5,6 +5,7 @@
 
 package org.mockito.internal.invocation;
 
+import static org.mockito.internal.invocation.ArgumentsProcessor.argumentsToMatchers;
 import static org.mockito.internal.invocation.MatcherApplicationStrategy.getMatcherApplicationStrategyFor;
 import static org.mockito.internal.invocation.TypeSafeMatching.matchesTypeSafe;
 
@@ -35,7 +36,7 @@ public class InvocationMatcher implements MatchableInvocation, DescribedInvocati
     public InvocationMatcher(Invocation invocation, List<ArgumentMatcher> matchers) {
         this.invocation = invocation;
         if (matchers.isEmpty()) {
-            this.matchers = (List) invocation.getArgumentsAsMatchers();
+            this.matchers = (List) argumentsToMatchers(invocation.getArguments());
         } else {
             this.matchers = (List) matchers;
         }
diff --git a/src/main/java/org/mockito/internal/reporting/PrintSettings.java b/src/main/java/org/mockito/internal/reporting/PrintSettings.java
index 4fc59926e..7986c35ce 100644
--- a/src/main/java/org/mockito/internal/reporting/PrintSettings.java
+++ b/src/main/java/org/mockito/internal/reporting/PrintSettings.java
@@ -5,6 +5,7 @@
 package org.mockito.internal.reporting;
 
 import org.mockito.ArgumentMatcher;
+import org.mockito.internal.invocation.ArgumentsProcessor;
 import org.mockito.internal.matchers.text.MatchersPrinter;
 import org.mockito.internal.util.MockUtil;
 import org.mockito.invocation.Invocation;
@@ -54,7 +55,7 @@ public class PrintSettings {
     }
 
     public String print(Invocation invocation) {
-        return print(invocation.getArgumentsAsMatchers(), invocation);
+        return print(ArgumentsProcessor.argumentsToMatchers(invocation.getArguments()), invocation);
     }
 
     public String print(MatchableInvocation invocation) {
diff --git a/src/main/java/org/mockito/invocation/Invocation.java b/src/main/java/org/mockito/invocation/Invocation.java
index fa2e32411..131db8441 100644
--- a/src/main/java/org/mockito/invocation/Invocation.java
+++ b/src/main/java/org/mockito/invocation/Invocation.java
@@ -4,11 +4,8 @@
  */
 package org.mockito.invocation;
 
-import org.mockito.ArgumentMatcher;
 import org.mockito.NotExtensible;
 
-import java.util.List;
-
 /**
  * A method call on a mock object. Contains all information and state needed for the Mockito framework to operate.
  * This API might be useful for developers who extend Mockito.
@@ -50,16 +47,6 @@ public interface Invocation extends InvocationOnMock, DescribedInvocation {
      */
     Object[] getRawArguments();
 
-    /**
-     * Wraps each argument using {@link org.mockito.ArgumentMatchers#eq(Object)} or
-     * {@link org.mockito.AdditionalMatchers#aryEq(Object[])}
-     * Used internally for the purposes of human-readable invocation printing.
-     *
-     * @return a list of {@link ArgumentMatcher} wrapping each of this invocation arguments
-     * @since 2.25.6
-     */
-    List<ArgumentMatcher> getArgumentsAsMatchers();
-
     /**
      * Returns unprocessed arguments whereas {@link #getArguments()} returns
      * arguments already processed (e.g. varargs expended, etc.).
diff --git a/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java b/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
index 4e0153502..4fc5cb1c1 100644
--- a/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
+++ b/src/test/java/org/mockito/internal/invocation/InvocationBuilder.java
@@ -6,7 +6,6 @@
 package org.mockito.internal.invocation;
 
 import org.mockito.Mockito;
-import org.mockito.internal.invocation.mockref.MockReference;
 import org.mockito.internal.invocation.mockref.MockStrongReference;
 import org.mockito.internal.debugging.LocationImpl;
 import org.mockito.invocation.Invocation;
@@ -62,7 +61,7 @@ public class InvocationBuilder {
             }
         }
 
-        Invocation i = createInvocation(new MockStrongReference<Object>(mock, false),
+        Invocation i = new InterceptedInvocation(new MockStrongReference<Object>(mock, false),
             new SerializableMethod(method),
             args,
             NO_OP,
@@ -74,11 +73,6 @@ public class InvocationBuilder {
         return i;
     }
 
-    protected Invocation createInvocation(MockReference<Object> mockRef, MockitoMethod mockitoMethod, Object[] arguments,
-                                          RealMethod realMethod, Location location, int sequenceNumber) {
-        return new InterceptedInvocation(mockRef, mockitoMethod, arguments, realMethod, location, sequenceNumber);
-    }
-
     public InvocationBuilder method(String methodName) {
         this.methodName = methodName;
         return this;
diff --git a/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java b/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java
index 107f5ce8f..15a57b96d 100644
--- a/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java
+++ b/src/test/java/org/mockito/internal/verification/checkers/MissingInvocationCheckerTest.java
@@ -5,125 +5,78 @@
 
 package org.mockito.internal.verification.checkers;
 
+import static java.util.Arrays.asList;
+
+import java.util.List;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
-import org.mockito.ArgumentMatcher;
 import org.mockito.Mock;
-import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
 import org.mockito.exceptions.verification.WantedButNotInvoked;
-import org.mockito.internal.invocation.*;
-import org.mockito.internal.invocation.mockref.MockReference;
+import org.mockito.exceptions.verification.opentest4j.ArgumentsAreDifferent;
+import org.mockito.internal.invocation.InvocationBuilder;
+import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.invocation.Invocation;
-import org.mockito.invocation.Location;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import java.util.ArrayList;
-import java.util.List;
+public class MissingInvocationCheckerTest extends TestBase {
 
-import static java.util.Arrays.asList;
-import static java.util.Collections.singletonList;
+	private InvocationMatcher wanted;
+	private List<Invocation> invocations;
 
-public class MissingInvocationCheckerTest extends TestBase {
+	@Mock
+	private IMethods mock;
+
+	@Rule
+	public ExpectedException exception = ExpectedException.none();
+
+	@Test
+	public void shouldPassBecauseActualInvocationFound() {
+		wanted = buildSimpleMethod().toInvocationMatcher();
+		invocations = asList(buildSimpleMethod().toInvocation());
+
+		MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
+	}
+
+	@Test
+	public void shouldReportWantedButNotInvoked() {
+		wanted = buildSimpleMethod().toInvocationMatcher();
+		invocations = asList(buildDifferentMethod().toInvocation());
+
+		exception.expect(WantedButNotInvoked.class);
+		exception.expectMessage("Wanted but not invoked:");
+		exception.expectMessage("mock.simpleMethod()");
+		exception.expectMessage("However, there was exactly 1 interaction with this mock:");
+		exception.expectMessage("mock.differentMethod();");
+
+		MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
+	}
+
+	@Test
+	public void shouldReportWantedInvocationDiffersFromActual() {
+		wanted = buildIntArgMethod().arg(2222).toInvocationMatcher();
+		invocations = asList(buildIntArgMethod().arg(1111).toInvocation());
+
+		exception.expect(ArgumentsAreDifferent.class);
+
+		exception.expectMessage("Argument(s) are different! Wanted:");
+		exception.expectMessage("mock.intArgumentMethod(2222);");
+		exception.expectMessage("Actual invocation has different arguments:");
+		exception.expectMessage("mock.intArgumentMethod(1111);");
+
+		MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
+	}
+
+	private InvocationBuilder buildIntArgMethod() {
+		return new InvocationBuilder().mock(mock).method("intArgumentMethod").argTypes(int.class);
+	}
+
+	private InvocationBuilder buildSimpleMethod() {
+		return new InvocationBuilder().mock(mock).simpleMethod();
+	}
 
-    private InvocationMatcher wanted;
-    private List<Invocation> invocations;
-
-    @Mock
-    private IMethods mock;
-
-    @Rule
-    public ExpectedException exception = ExpectedException.none();
-
-    @Test
-    public void shouldPassBecauseActualInvocationFound() {
-        wanted = buildSimpleMethod().toInvocationMatcher();
-        invocations = asList(buildSimpleMethod().toInvocation());
-
-        MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
-    }
-
-    @Test
-    public void shouldReportWantedButNotInvoked() {
-        wanted = buildSimpleMethod().toInvocationMatcher();
-        invocations = asList(buildDifferentMethod().toInvocation());
-
-        exception.expect(WantedButNotInvoked.class);
-        exception.expectMessage("Wanted but not invoked:");
-        exception.expectMessage("mock.simpleMethod()");
-        exception.expectMessage("However, there was exactly 1 interaction with this mock:");
-        exception.expectMessage("mock.differentMethod();");
-
-        MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
-    }
-
-    @Test
-    public void shouldReportWantedInvocationDiffersFromActual() {
-        wanted = buildIntArgMethod(new InvocationBuilder()).arg(2222).toInvocationMatcher();
-        invocations = asList(buildIntArgMethod(new InvocationBuilder()).arg(1111).toInvocation());
-
-        exception.expect(ArgumentsAreDifferent.class);
-
-        exception.expectMessage("Argument(s) are different! Wanted:");
-        exception.expectMessage("mock.intArgumentMethod(2222);");
-        exception.expectMessage("Actual invocation has different arguments:");
-        exception.expectMessage("mock.intArgumentMethod(1111);");
-
-        MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
-    }
-
-    @Test
-    public void shouldReportUsingInvocationDescription() {
-        wanted = buildIntArgMethod(new CustomInvocationBuilder()).arg(2222).toInvocationMatcher();
-        invocations = singletonList(buildIntArgMethod(new CustomInvocationBuilder()).arg(1111).toInvocation());
-
-        exception.expect(ArgumentsAreDifferent.class);
-
-        exception.expectMessage("Argument(s) are different! Wanted:");
-        exception.expectMessage("mock.intArgumentMethod(MyCoolPrint(2222));");
-        exception.expectMessage("Actual invocation has different arguments:");
-        exception.expectMessage("mock.intArgumentMethod(MyCoolPrint(1111));");
-
-        MissingInvocationChecker.checkMissingInvocation(invocations, wanted);
-    }
-
-    private InvocationBuilder buildIntArgMethod(InvocationBuilder invocationBuilder) {
-        return invocationBuilder.mock(mock).method("intArgumentMethod").argTypes(int.class);
-    }
-
-    private InvocationBuilder buildSimpleMethod() {
-        return new InvocationBuilder().mock(mock).simpleMethod();
-    }
-
-    private InvocationBuilder buildDifferentMethod() {
-        return new InvocationBuilder().mock(mock).differentMethod();
-    }
-
-    static class CustomInvocationBuilder extends InvocationBuilder {
-        @Override
-        protected Invocation createInvocation(MockReference<Object> mockRef, MockitoMethod mockitoMethod, final Object[] arguments,
-                                              RealMethod realMethod, Location location, int sequenceNumber) {
-            return new InterceptedInvocation(mockRef, mockitoMethod, arguments, realMethod, location, sequenceNumber) {
-                @Override
-                public List<ArgumentMatcher> getArgumentsAsMatchers() {
-                    List<ArgumentMatcher> matchers = new ArrayList<ArgumentMatcher>();
-                    for (final Object argument : getRawArguments()) {
-                        matchers.add(new ArgumentMatcher() {
-                            @Override
-                            public boolean matches(Object a) {
-                                return a == argument;
-                            }
-
-                            @Override
-                            public String toString() {
-                                return "MyCoolPrint(" + argument + ")";
-                            }
-                        });
-                    }
-                    return matchers;
-                }
-            };
-        }
-    }
+	private InvocationBuilder buildDifferentMethod() {
+		return new InvocationBuilder().mock(mock).differentMethod();
+	}
 }
