diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 48842b845..9201a39cb 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -41,7 +41,15 @@ Things we pay attention in a PR :
 * On pull requests, please document the change, what it brings, what is the benefit. If the issue exists on the old issue tracker on [Google Code](https://code.google.com/p/mockito/issues/list), please add cross links. But don't create a new one there.
 * **Clean commit history** in the topic branch in your fork of the repository, even during review. That means that commits are _rebased_ and _squashed_ if necessary, so that each commit clearly changes one things and there are no extraneous fix-ups.
 
-  For that matter it's possible to commit [_semantic_ changes](http://lemike-de.tumblr.com/post/79041908218/semantic-commits) (like starting with `Fixes #issue_id`). _Tests are an asset, so is history_.
+  For that matter it's possible to commit [_semantic_ changes](http://lemike-de.tumblr.com/post/79041908218/semantic-commits). _Tests are an asset, so is history_.
+  
+  _Exemple gratia_:
+  
+  ```
+  Fixes #73 : The new feature
+  Fixes #73 : Refactors this part of Mockito to make feature possible
+  ```
+  
 * In the code, always test your feature / change, in unit tests and in our `acceptance test suite` located in `org.mockitousage`. Older tests will be migrated when a test is modified.
 * New test methods should follow a snake case convention (`ensure_that_stuff_is_doing_that`), this allows the test name to be fully expressive on intent while still readable.
 * When reporting errors to the users, if it's a user report report it gently and explain how a user should deal with it, see the `Reporter` class. However not all errors should go there, some unlikely technical errors don't need to be in the `Reporter` class.
diff --git a/doc/release-notes/official.md b/doc/release-notes/official.md
index 3eb11c5c7..4fa93f594 100644
--- a/doc/release-notes/official.md
+++ b/doc/release-notes/official.md
@@ -1,3 +1,15 @@
+### 2.0.6-beta (2015-04-17 09:55 UTC)
+
+* Authors: 3
+* Commits: 9
+  * 7: Brice Dutheil
+  * 1: bruce
+  * 1: Hans Joachim Desserud
+* Improvements: 3
+  * Fixes #200 : ArgumentCaptor.forClass is more friendly with generic types [(#201)](https://github.com/mockito/mockito/pull/201)
+  * ArgumentCaptor.fromClass's return type should match a parameterized type [(#200)](https://github.com/mockito/mockito/issues/200)
+  * Fixes typo [(#184)](https://github.com/mockito/mockito/pull/184)
+
 ### 2.0.5-beta (2015-02-26 22:31 UTC)
 
 * Authors: 2
diff --git a/src/org/mockito/ArgumentCaptor.java b/src/org/mockito/ArgumentCaptor.java
index 0efe061cf..78c41c89f 100644
--- a/src/org/mockito/ArgumentCaptor.java
+++ b/src/org/mockito/ArgumentCaptor.java
@@ -65,7 +65,7 @@ public class ArgumentCaptor<T> {
     HandyReturnValues handyReturnValues = new HandyReturnValues();
 
     private final CapturingMatcher<T> capturingMatcher = new CapturingMatcher<T>();
-    private final Class<T> clazz;
+    private final Class<? extends T> clazz;
 
     /**
      * @deprecated
@@ -87,7 +87,7 @@ public class ArgumentCaptor<T> {
         this.clazz = null;
     }
 
-    ArgumentCaptor(Class<T> clazz) {
+    private ArgumentCaptor(Class<? extends T> clazz) {
         this.clazz = clazz;
     }
 
@@ -163,10 +163,11 @@ public class ArgumentCaptor<T> {
      * future major release.
      *
      * @param clazz Type matching the parameter to be captured.
-     * @param <T> Type of clazz
+     * @param <S> Type of clazz
+     * @param <U> Type of object captured by the newly built ArgumentCaptor
      * @return A new ArgumentCaptor
      */
-    public static <T> ArgumentCaptor<T> forClass(Class<T> clazz) {
-        return new ArgumentCaptor<T>(clazz);
+    public static <U,S extends U> ArgumentCaptor<U> forClass(Class<S> clazz) {
+        return new ArgumentCaptor<U>(clazz);
     }
 }
\ No newline at end of file
diff --git a/src/org/mockito/exceptions/Reporter.java b/src/org/mockito/exceptions/Reporter.java
index e0b1105da..7ae75886c 100644
--- a/src/org/mockito/exceptions/Reporter.java
+++ b/src/org/mockito/exceptions/Reporter.java
@@ -8,13 +8,7 @@ package org.mockito.exceptions;
 import org.mockito.exceptions.base.MockitoAssertionError;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.misusing.*;
-import org.mockito.exceptions.verification.NeverWantedButInvoked;
-import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockito.exceptions.verification.SmartNullPointerException;
-import org.mockito.exceptions.verification.TooLittleActualInvocations;
-import org.mockito.exceptions.verification.TooManyActualInvocations;
-import org.mockito.exceptions.verification.VerificationInOrderFailure;
-import org.mockito.exceptions.verification.WantedButNotInvoked;
+import org.mockito.exceptions.verification.*;
 import org.mockito.internal.debugging.LocationImpl;
 import org.mockito.internal.exceptions.MockitoLimitations;
 import org.mockito.internal.exceptions.VerificationAwareInvocation;
@@ -28,7 +22,6 @@ import org.mockito.invocation.Invocation;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.invocation.Location;
 import org.mockito.listeners.InvocationListener;
-import org.mockito.mock.MockName;
 import org.mockito.mock.SerializableMode;
 
 import java.lang.reflect.Field;
@@ -238,7 +231,7 @@ public class Reporter {
     public void invalidUseOfMatchers(int expectedMatchersCount, List<LocalizedMatcher> recordedMatchers) {
         throw new InvalidUseOfMatchersException(join(
                 "Invalid use of argument matchers!",
-                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() + " recorded:" +
+                expectedMatchersCount + " matchers expected, " + recordedMatchers.size()+ " recorded:" +
                         locationsOf(recordedMatchers),
                 "",
                 "This exception may occur if matchers are combined with raw values:",
@@ -394,7 +387,7 @@ public class Reporter {
     private String createTooLittleInvocationsMessage(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted,
                                                      Location lastActualInvocation) {
         String ending =
-                (lastActualInvocation != null) ? lastActualInvocation + "\n" : "\n";
+                (lastActualInvocation != null)? lastActualInvocation + "\n" : "\n";
 
         String message = join(
                 wanted.toString(),
@@ -427,7 +420,7 @@ public class Reporter {
         throw new NoInteractionsWanted(join(
                 "No interactions wanted here:",
                 new LocationImpl(),
-                "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",
+                "But found this interaction on mock '" + undesired.getMock() + "':",
                 undesired.getLocation(),
                 scenario
         ));
@@ -437,7 +430,7 @@ public class Reporter {
         throw new VerificationInOrderFailure(join(
                 "No interactions wanted here:",
                 new LocationImpl(),
-                "But found this interaction on mock '" + safelyGetMockName(undesired.getMock()) + "':",
+                "But found this interaction on mock '" + undesired.getMock() + "':",
                 undesired.getLocation()
         ));
     }
@@ -496,18 +489,6 @@ public class Reporter {
         ));
     }
 
-    public void wrongTypeReturnedByDefaultAnswer(Object mock, String expectedType, String actualType, String methodName) {
-        throw new WrongTypeOfReturnValue(join(
-                "Default answer returned a result with the wrong type:",
-                actualType + " cannot be returned by " + methodName + "()",
-                methodName + "() should return " + expectedType,
-                "",
-                "The default answer of " + safelyGetMockName(mock) + " that was configured on the mock is probably incorrectly implemented.",
-                ""
-        ));
-    }
-
-
     public void wantedAtMostX(int maxNumberOfInvocations, int foundSize) {
         throw new MockitoAssertionError(join("Wanted at most " + pluralize(maxNumberOfInvocations) + " but was " + foundSize));
     }
@@ -660,7 +641,7 @@ public class Reporter {
 
     public void fieldInitialisationThrewException(Field field, Throwable details) {
         throw new MockitoException(join(
-                "Cannot instantiate @InjectMocks field named '" + field.getName() + "' of type '" + field.getType() + "'.",
+                "Cannot instantiate @InjectMocks field named '" + field.getName() + "' of type '" + field.getType() +  "'.",
                 "You haven't provided the instance at field declaration so I tried to construct the instance.",
                 "However the constructor or the initialization block threw an exception : " + details.getMessage(),
                 ""), details);
@@ -683,21 +664,14 @@ public class Reporter {
 
     public void cannotInjectDependency(Field field, Object matchingMock, Exception details) {
         throw new MockitoException(join(
-                "Mockito couldn't inject mock dependency '" + safelyGetMockName(matchingMock) + "' on field ",
+                "Mockito couldn't inject mock dependency '" + new MockUtil().getMockName(matchingMock) + "' on field ",
                 "'" + field + "'",
                 "whose type '" + field.getDeclaringClass().getCanonicalName() + "' was annotated by @InjectMocks in your test.",
-                "Also I failed because: " + exceptionCauseMessageIfAvailable(details),
+                "Also I failed because: " + details.getCause().getMessage(),
                 ""
         ), details);
     }
 
-    private String exceptionCauseMessageIfAvailable(Exception details) {
-        if (details.getCause() == null) {
-            return details.getMessage();
-        }
-        return details.getCause().getMessage();
-    }
-
     public void mockedTypeIsInconsistentWithDelegatedInstanceType(Class mockedType, Object delegatedInstance) {
         throw new MockitoException(join(
                 "Mocked type must be the same as the type of your delegated instance.",
@@ -712,7 +686,7 @@ public class Reporter {
     public void spyAndDelegateAreMutuallyExclusive() {
         throw new MockitoException(join(
                 "Settings should not define a spy instance and a delegated instance at the same time."
-        ));
+        )) ;
     }
 
     public void invalidArgumentRangeAtIdentityAnswerCreationTime() {
@@ -725,7 +699,7 @@ public class Reporter {
     public int invalidArgumentPositionRangeAtInvocationTime(InvocationOnMock invocation, boolean willReturnLastParameter, int argumentIndex) {
         throw new MockitoException(
                 join("Invalid argument index for the current invocation of method : ",
-                        " -> " + safelyGetMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
+                        " -> " + new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
                         "",
                         (willReturnLastParameter ?
                                 "Last parameter wanted" :
@@ -758,7 +732,7 @@ public class Reporter {
         throw new WrongTypeOfReturnValue(join(
                 "The argument of type '" + actualType.getSimpleName() + "' cannot be returned because the following ",
                 "method should return the type '" + expectedType + "'",
-                " -> " + safelyGetMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
+                " -> " + new MockUtil().getMockName(invocation.getMock()) + "." + invocation.getMethod().getName() + "()",
                 "",
                 "The reason for this error can be :",
                 "1. The wanted argument position is incorrect.",
@@ -791,32 +765,28 @@ public class Reporter {
                 ""
         ));
     }
-
+    
     public void delegatedMethodHasWrongReturnType(Method mockMethod, Method delegateMethod, Object mock, Object delegate) {
-        throw new MockitoException(join(
-                "Methods called on delegated instance must have compatible return types with the mock.",
-                "When calling: " + mockMethod + " on mock: " + safelyGetMockName(mock),
-                "return type should be: " + mockMethod.getReturnType().getSimpleName() + ", but was: " + delegateMethod.getReturnType().getSimpleName(),
-                "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
-                "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
-        ));
-    }
-
-    public void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {
-        throw new MockitoException(join(
-                "Methods called on mock must exist in delegated instance.",
-                "When calling: " + mockMethod + " on mock: " + safelyGetMockName(mock),
-                "no such method was found.",
-                "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
-                "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
-        ));
-    }
+    	throw new MockitoException(join(
+    	        "Methods called on delegated instance must have compatible return types with the mock.",
+    	        "When calling: " + mockMethod + " on mock: " + new MockUtil().getMockName(mock),
+    	        "return type should be: " + mockMethod.getReturnType().getSimpleName() + ", but was: " + delegateMethod.getReturnType().getSimpleName(),
+    	        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
+    	        "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
+    	));
+    }
+
+	public void delegatedMethodDoesNotExistOnDelegate(Method mockMethod, Object mock, Object delegate) {
+		throw new MockitoException(join(
+    	        "Methods called on mock must exist in delegated instance.",
+    	        "When calling: " + mockMethod + " on mock: " + new MockUtil().getMockName(mock),
+    	        "no such method was found.",
+    	        "Check that the instance passed to delegatesTo() is of the correct type or contains compatible methods",
+    	        "(delegate instance had type: " + delegate.getClass().getSimpleName() + ")"
+    	));
+	}
 
     public void usingConstructorWithFancySerializable(SerializableMode mode) {
         throw new MockitoException("Mocks instantiated with constructor cannot be combined with " + mode + " serialization mode.");
     }
-
-    private MockName safelyGetMockName(Object mock) {
-        return new MockUtil().getMockName(mock);
-    }
 }
diff --git a/src/org/mockito/internal/handler/MockHandlerImpl.java b/src/org/mockito/internal/handler/MockHandlerImpl.java
index 00766a0d0..a49c1a98b 100644
--- a/src/org/mockito/internal/handler/MockHandlerImpl.java
+++ b/src/org/mockito/internal/handler/MockHandlerImpl.java
@@ -10,12 +10,7 @@ import org.mockito.internal.invocation.InvocationMatcher;
 import org.mockito.internal.invocation.MatchersBinder;
 import org.mockito.internal.progress.MockingProgress;
 import org.mockito.internal.progress.ThreadSafeMockingProgress;
-import org.mockito.internal.stubbing.InvocationContainer;
-import org.mockito.internal.stubbing.InvocationContainerImpl;
-import org.mockito.internal.stubbing.OngoingStubbingImpl;
-import org.mockito.internal.stubbing.StubbedInvocationMatcher;
-import org.mockito.internal.stubbing.VoidMethodStubbableImpl;
-import org.mockito.internal.stubbing.answers.AnswersValidator;
+import org.mockito.internal.stubbing.*;
 import org.mockito.internal.verification.MockAwareVerificationMode;
 import org.mockito.internal.verification.VerificationDataImpl;
 import org.mockito.invocation.Invocation;
@@ -28,8 +23,9 @@ import java.util.List;
 
 /**
  * Invocation handler set on mock objects.
- *
- * @param <T> type of mock object to handle
+ * 
+ * @param <T>
+ *            type of mock object to handle
  */
 class MockHandlerImpl<T> implements InternalMockHandler<T> {
 
@@ -49,7 +45,7 @@ class MockHandlerImpl<T> implements InternalMockHandler<T> {
     }
 
     public Object handle(Invocation invocation) throws Throwable {
-        if (invocationContainerImpl.hasAnswersForStubbing()) {
+		if (invocationContainerImpl.hasAnswersForStubbing()) {
             // stubbing voids with stubVoid() or doAnswer() style
             InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(
                     mockingProgress.getArgumentMatcherStorage(),
@@ -94,8 +90,7 @@ class MockHandlerImpl<T> implements InternalMockHandler<T> {
             stubbedInvocation.captureArgumentsFrom(invocation);
             return stubbedInvocation.answer(invocation);
         } else {
-            Object ret = mockSettings.getDefaultAnswer().answer(invocation);
-            new AnswersValidator().validateDefaultAnswerReturnedValue(invocation, ret);
+             Object ret = mockSettings.getDefaultAnswer().answer(invocation);
 
             // redo setting invocation for potential stubbing in case of partial
             // mocks / spies.
@@ -105,7 +100,7 @@ class MockHandlerImpl<T> implements InternalMockHandler<T> {
             invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);
             return ret;
         }
-    }
+	}
 
     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {
         return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);
diff --git a/src/org/mockito/internal/invocation/InvocationImpl.java b/src/org/mockito/internal/invocation/InvocationImpl.java
index dc77a57e2..19193fa16 100644
--- a/src/org/mockito/internal/invocation/InvocationImpl.java
+++ b/src/org/mockito/internal/invocation/InvocationImpl.java
@@ -105,10 +105,6 @@ public class InvocationImpl implements Invocation, VerificationAwareInvocation {
         return this.rawArguments;
     }
 
-    public Class<?> getRawReturnType() {
-        return method.getReturnType();
-    }
-
     public Object callRealMethod() throws Throwable {
         if (method.isAbstract()) {
             new Reporter().cannotCallAbstractRealMethod();
@@ -135,4 +131,4 @@ public class InvocationImpl implements Invocation, VerificationAwareInvocation {
     public void ignoreForVerification() {
         isIgnoredForVerification = true;
     }
-}
+}
\ No newline at end of file
diff --git a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java
index 66bbf54c5..57adb3881 100644
--- a/src/org/mockito/internal/stubbing/answers/AnswersValidator.java
+++ b/src/org/mockito/internal/stubbing/answers/AnswersValidator.java
@@ -11,21 +11,21 @@ import org.mockito.stubbing.Answer;
 public class AnswersValidator {
 
     private final Reporter reporter = new Reporter();
-
+    
     public void validate(Answer<?> answer, Invocation invocation) {
         MethodInfo methodInfo = new MethodInfo(invocation);
         if (answer instanceof ThrowsException) {
             validateException((ThrowsException) answer, methodInfo);
         }
-
+        
         if (answer instanceof Returns) {
             validateReturnValue((Returns) answer, methodInfo);
         }
-
+        
         if (answer instanceof DoesNothing) {
             validateDoNothing((DoesNothing) answer, methodInfo);
         }
-
+        
         if (answer instanceof CallsRealMethods) {
             validateMockingConcreteClass((CallsRealMethods) answer, methodInfo);
         }
@@ -42,8 +42,8 @@ public class AnswersValidator {
         MethodInfo methodInfo = new MethodInfo(invocation);
         if (!methodInfo.isValidReturnType(returnsArgumentAt.returnedTypeOnSignature(invocation))) {
             new Reporter().wrongTypeOfArgumentToReturn(invocation, methodInfo.printMethodReturnType(),
-                    returnsArgumentAt.returnedTypeOnSignature(invocation),
-                    returnsArgumentAt.wantedArgumentPosition());
+                                                       returnsArgumentAt.returnedTypeOnSignature(invocation),
+                                                       returnsArgumentAt.wantedArgumentPosition());
         }
 
     }
@@ -64,10 +64,10 @@ public class AnswersValidator {
         if (methodInfo.isVoid()) {
             reporter.cannotStubVoidMethodWithAReturnValue(methodInfo.getMethodName());
         }
-
+        
         if (answer.returnsNull() && methodInfo.returnsPrimitive()) {
             reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), "null", methodInfo.getMethodName());
-        }
+        } 
 
         if (!answer.returnsNull() && !methodInfo.isValidReturnType(answer.getReturnType())) {
             reporter.wrongTypeOfReturnValue(methodInfo.printMethodReturnType(), answer.printReturnType(), methodInfo.getMethodName());
@@ -79,24 +79,13 @@ public class AnswersValidator {
         if (throwable == null) {
             reporter.cannotStubWithNullThrowable();
         }
-
+        
         if (throwable instanceof RuntimeException || throwable instanceof Error) {
             return;
         }
-
+        
         if (!methodInfo.isValidException(throwable)) {
             reporter.checkedExceptionInvalid(throwable);
         }
     }
-
-    public void validateDefaultAnswerReturnedValue(Invocation invocation, Object returnedValue) {
-        MethodInfo methodInfo = new MethodInfo(invocation);
-        if (returnedValue != null && !methodInfo.isValidReturnType(returnedValue.getClass())) {
-            reporter.wrongTypeReturnedByDefaultAnswer(
-                    invocation.getMock(),
-                    methodInfo.printMethodReturnType(),
-                    returnedValue.getClass().getSimpleName(),
-                    methodInfo.getMethodName());
-        }
-    }
-}
+}
\ No newline at end of file
diff --git a/src/org/mockito/invocation/Invocation.java b/src/org/mockito/invocation/Invocation.java
index 7c1bdd557..014669730 100644
--- a/src/org/mockito/invocation/Invocation.java
+++ b/src/org/mockito/invocation/Invocation.java
@@ -41,14 +41,6 @@ public interface Invocation extends InvocationOnMock, DescribedInvocation {
      */
     Object[] getRawArguments();
 
-    /**
-     * Returns unprocessed arguments whereas {@link #getArguments()} returns
-     * arguments already processed (e.g. varargs expended, etc.).
-     *
-     * @return unprocessed arguments, exactly as provided to this invocation.
-     */
-    Class getRawReturnType();
-
     /**
      * Marks this invocation as verified so that it will not cause verification error at
      * {@link org.mockito.Mockito#verifyNoMoreInteractions(Object...)}
diff --git a/test/org/mockito/exceptions/ReporterTest.java b/test/org/mockito/exceptions/ReporterTest.java
index 3253ad819..e00685278 100644
--- a/test/org/mockito/exceptions/ReporterTest.java
+++ b/test/org/mockito/exceptions/ReporterTest.java
@@ -6,81 +6,21 @@
 package org.mockito.exceptions;
 
 import org.junit.Test;
-import org.mockito.Mockito;
 import org.mockito.exceptions.base.MockitoException;
-import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.TooLittleActualInvocations;
-import org.mockito.exceptions.verification.VerificationInOrderFailure;
-import org.mockito.internal.exceptions.VerificationAwareInvocation;
 import org.mockito.internal.invocation.InvocationBuilder;
-import org.mockito.internal.stubbing.answers.Returns;
-import org.mockito.invocation.Invocation;
-import org.mockitousage.IMethods;
+import org.mockito.internal.reporting.*;
 import org.mockitoutil.TestBase;
 
-import java.lang.reflect.Field;
-import java.util.Collections;
-
-import static org.mockito.Mockito.mock;
-
 public class ReporterTest extends TestBase {
 
-    @Test(expected = TooLittleActualInvocations.class)
-    public void should_let_passing_null_last_actual_stack_trace() throws Exception {
+    @Test(expected=TooLittleActualInvocations.class)
+    public void shouldLetPassingNullLastActualStackTrace() throws Exception {
         new Reporter().tooLittleActualInvocations(new org.mockito.internal.reporting.Discrepancy(1, 2), new InvocationBuilder().toInvocation(), null);
     }
-
-    @Test(expected = MockitoException.class)
-    public void should_throw_correct_exception_for_null_invocation_listener() throws Exception {
-        new Reporter().invocationListenerDoesNotAcceptNullParameters();
-    }
-
-    @Test(expected = NoInteractionsWanted.class)
-    public void can_use_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted() throws Exception {
-        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
-        new Reporter().noMoreInteractionsWanted(invocation_with_bogus_default_answer, Collections.<VerificationAwareInvocation>emptyList());
-    }
-
-    @Test(expected = VerificationInOrderFailure.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted_in_order() throws Exception {
-        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
-        new Reporter().noMoreInteractionsWantedInOrder(invocation_with_bogus_default_answer);
-    }
-
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_invalid_argument_position() throws Exception {
-        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
-        new Reporter().invalidArgumentPositionRangeAtInvocationTime(invocation_with_bogus_default_answer, true, 0);
-    }
-
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_wrong_argument_to_return() throws Exception {
-        Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();
-        new Reporter().wrongTypeOfArgumentToReturn(invocation_with_bogus_default_answer, "", String.class, 0);
-    }
-
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_dont_exists() throws Exception {
-        Invocation dumb_invocation = new InvocationBuilder().toInvocation();
-        IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));
-        new Reporter().delegatedMethodDoesNotExistOnDelegate(dumb_invocation.getMethod(), mock_with_bogus_default_answer, String.class);
-    }
-
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_has_wrong_return_type() throws Exception {
-        Invocation dumb_invocation = new InvocationBuilder().toInvocation();
-        IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));
-        new Reporter().delegatedMethodHasWrongReturnType(dumb_invocation.getMethod(), dumb_invocation.getMethod(), mock_with_bogus_default_answer, String.class);
+    
+    @Test(expected=MockitoException.class)
+    public void shouldThrowCorrectExceptionForNullInvocationListener() throws Exception {
+    	new Reporter().invocationListenerDoesNotAcceptNullParameters();
     }
-
-    @Test(expected = MockitoException.class)
-    public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_injection_failure() throws Exception {
-        IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));
-        new Reporter().cannotInjectDependency(someField(), mock_with_bogus_default_answer, new Exception());
-    }
-
-    private Field someField() {
-        return Mockito.class.getDeclaredFields()[0];
-    }
-
 }
diff --git a/test/org/mockito/internal/handler/MockHandlerImplTest.java b/test/org/mockito/internal/handler/MockHandlerImplTest.java
index 104c4be6b..8999fb4e5 100644
--- a/test/org/mockito/internal/handler/MockHandlerImplTest.java
+++ b/test/org/mockito/internal/handler/MockHandlerImplTest.java
@@ -8,7 +8,6 @@ package org.mockito.internal.handler;
 import org.junit.Test;
 import org.mockito.exceptions.base.MockitoException;
 import org.mockito.exceptions.misusing.InvalidUseOfMatchersException;
-import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
 import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.InvocationBuilder;
 import org.mockito.internal.invocation.InvocationImpl;
@@ -17,7 +16,6 @@ import org.mockito.internal.invocation.MatchersBinder;
 import org.mockito.internal.progress.ArgumentMatcherStorage;
 import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.stubbing.StubbedInvocationMatcher;
-import org.mockito.internal.stubbing.answers.Returns;
 import org.mockito.internal.verification.VerificationModeFactory;
 import org.mockito.invocation.Invocation;
 import org.mockito.listeners.InvocationListener;
@@ -31,88 +29,79 @@ import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doThrow;
 import static org.mockito.Mockito.mock;
 
-@SuppressWarnings({"unchecked", "serial"})
+@SuppressWarnings({ "unchecked", "serial" })
 public class MockHandlerImplTest extends TestBase {
 
-    private StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);
-    private Invocation invocation = mock(InvocationImpl.class);
+	private StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);
+	private Invocation invocation = mock(InvocationImpl.class);
 
 
-    @Test
-    public void should_remove_verification_mode_even_when_invalid_matchers() throws Throwable {
-        // given
-        Invocation invocation = new InvocationBuilder().toInvocation();
-        @SuppressWarnings("rawtypes")
+	@Test
+	public void shouldRemoveVerificationModeEvenWhenInvalidMatchers() throws Throwable {
+		// given
+		Invocation invocation = new InvocationBuilder().toInvocation();
+		@SuppressWarnings("rawtypes")
         MockHandlerImpl<?> handler = new MockHandlerImpl(new MockSettingsImpl());
-        handler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());
-        handler.matchersBinder = new MatchersBinder() {
-            public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
-                throw new InvalidUseOfMatchersException();
-            }
-        };
-
-        try {
-            // when
-            handler.handle(invocation);
-
-            // then
-            fail();
-        } catch (InvalidUseOfMatchersException ignored) {
-        }
-
-        assertNull(handler.mockingProgress.pullVerificationMode());
-    }
-
-
-    @Test(expected = MockitoException.class)
-    public void should_throw_mockito_exception_when_invocation_handler_throws_anything() throws Throwable {
-        // given
-        InvocationListener throwingListener = mock(InvocationListener.class);
-        doThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));
-        MockHandlerImpl<?> handler = create_correctly_stubbed_handler(throwingListener);
-
-        // when
-        handler.handle(invocation);
-    }
-
-    @Test(expected = WrongTypeOfReturnValue.class)
-    public void should_report_bogus_default_answer() throws Throwable {
-        MockSettingsImpl mockSettings = mock(MockSettingsImpl.class);
-        MockHandlerImpl<?> handler = new MockHandlerImpl(mockSettings);
-        given(mockSettings.getDefaultAnswer()).willReturn(new Returns(AWrongType.WRONG_TYPE));
-
-        @SuppressWarnings("unused") // otherwise cast is not done
-        String there_should_not_be_a_CCE_here = (String) handler.handle(
-                new InvocationBuilder().method(Object.class.getDeclaredMethod("toString")).toInvocation()
-        );
-    }
-
-    private MockHandlerImpl<?> create_correctly_stubbed_handler(InvocationListener throwingListener) {
-        MockHandlerImpl<?> handler = create_handler_with_listeners(throwingListener);
-        stub_ordinary_invocation_with_given_return_value(handler);
-        return handler;
-    }
-
-    private void stub_ordinary_invocation_with_given_return_value(MockHandlerImpl<?> handler) {
-        stub_ordinary_invocation_with_invocation_matcher(handler, stubbedInvocationMatcher);
-    }
-
-
-    private void stub_ordinary_invocation_with_invocation_matcher(MockHandlerImpl<?> handler, StubbedInvocationMatcher value) {
-        handler.invocationContainerImpl = mock(InvocationContainerImpl.class);
-        given(handler.invocationContainerImpl.findAnswerFor(any(InvocationImpl.class))).willReturn(value);
-    }
-
-
-    private MockHandlerImpl<?> create_handler_with_listeners(InvocationListener... listener) {
-        @SuppressWarnings("rawtypes")
+		handler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());
+		handler.matchersBinder = new MatchersBinder() {
+			public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {
+				throw new InvalidUseOfMatchersException();
+			}
+		};
+
+		try {
+			// when
+			handler.handle(invocation);
+
+			// then
+			fail();
+		} catch (InvalidUseOfMatchersException e) {
+		}
+
+		assertNull(handler.mockingProgress.pullVerificationMode());
+	}
+
+
+
+
+	@Test(expected = MockitoException.class)
+	public void shouldThrowMockitoExceptionWhenInvocationHandlerThrowsAnything() throws Throwable {
+		// given
+		InvocationListener throwingListener = mock(InvocationListener.class);
+		doThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));
+		MockHandlerImpl<?> handler = createCorrectlyStubbedHandler(throwingListener);
+
+		// when
+		handler.handle(invocation);
+	}
+
+
+
+	private MockHandlerImpl<?> createCorrectlyStubbedHandler(InvocationListener throwingListener) {
+		MockHandlerImpl<?> handler = createHandlerWithListeners(throwingListener);
+		stubOrdinaryInvocationWithGivenReturnValue(handler);
+		return handler;
+	}
+
+	private void stubOrdinaryInvocationWithGivenReturnValue(MockHandlerImpl<?> handler) {
+		stubOrdinaryInvocationWithInvocationMatcher(handler, stubbedInvocationMatcher);
+	}
+
+
+
+	private void stubOrdinaryInvocationWithInvocationMatcher(MockHandlerImpl<?> handler, StubbedInvocationMatcher value) {
+		handler.invocationContainerImpl = mock(InvocationContainerImpl.class);
+		given(handler.invocationContainerImpl.findAnswerFor(any(InvocationImpl.class))).willReturn(value);
+	}
+
+
+
+
+	private MockHandlerImpl<?> createHandlerWithListeners(InvocationListener... listener) {
+		@SuppressWarnings("rawtypes")
         MockHandlerImpl<?> handler = new MockHandlerImpl(mock(MockSettingsImpl.class));
-        handler.matchersBinder = mock(MatchersBinder.class);
-        given(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));
-        return handler;
-    }
-
-    private static class AWrongType {
-        public static final AWrongType WRONG_TYPE = new AWrongType();
-    }
+		handler.matchersBinder = mock(MatchersBinder.class);
+		given(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));
+		return handler;
+	}
 }
diff --git a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java
index 04b591757..914535fbb 100644
--- a/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java
+++ b/test/org/mockito/internal/stubbing/answers/AnswersValidatorTest.java
@@ -1,7 +1,7 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
 package org.mockito.internal.stubbing.answers;
 
 import org.junit.Test;
@@ -30,7 +30,7 @@ public class AnswersValidatorTest {
         try {
             validator.validate(new ThrowsException(null), new InvocationBuilder().toInvocation());
             fail();
-        } catch (MockitoException expected) {}
+        } catch (MockitoException e) {}
     }
 
     @Test
@@ -42,28 +42,28 @@ public class AnswersValidatorTest {
     public void should_fail_invalid_checked_exception() throws Throwable {
         validator.validate(new ThrowsException(new IOException()), invocation);
     }
-
+    
     @Test
     public void should_pass_RuntimeExceptions() throws Throwable {
         validator.validate(new ThrowsException(new Error()), invocation);
         validator.validate(new ThrowsException(new RuntimeException()), invocation);
     }
-
+    
     @Test(expected = MockitoException.class)
     public void should_fail_when_return_Value_is_set_for_void_method() throws Throwable {
         validator.validate(new Returns("one"), new InvocationBuilder().method("voidMethod").toInvocation());
     }
-
+    
     @Test(expected = MockitoException.class)
     public void should_fail_when_non_void_method_does_nothing() throws Throwable {
         validator.validate(new DoesNothing(), new InvocationBuilder().simpleMethod().toInvocation());
     }
-
+    
     @Test
     public void should_allow_void_return_for_void_method() throws Throwable {
         validator.validate(new DoesNothing(), new InvocationBuilder().method("voidMethod").toInvocation());
     }
-
+    
     @Test
     public void should_allow_correct_type_of_return_value() throws Throwable {
         validator.validate(new Returns("one"), new InvocationBuilder().simpleMethod().toInvocation());
@@ -75,12 +75,12 @@ public class AnswersValidatorTest {
         validator.validate(new Returns(null), new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());
         validator.validate(new Returns(1), new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());
     }
-
+    
     @Test(expected = MockitoException.class)
     public void should_fail_on_return_type_mismatch() throws Throwable {
         validator.validate(new Returns("String"), new InvocationBuilder().method("booleanReturningMethod").toInvocation());
     }
-
+    
     @Test(expected = MockitoException.class)
     public void should_fail_on_wrong_primitive() throws Throwable {
         validator.validate(new Returns(1), new InvocationBuilder().method("doubleReturningMethod").toInvocation());
@@ -90,7 +90,7 @@ public class AnswersValidatorTest {
     public void should_fail_on_null_with_primitive() throws Throwable {
         validator.validate(new Returns(null), new InvocationBuilder().method("booleanReturningMethod").toInvocation());
     }
-
+    
     @Test
     public void should_fail_when_calling_real_method_on_interface() throws Throwable {
         //given
@@ -100,9 +100,9 @@ public class AnswersValidatorTest {
             validator.validate(new CallsRealMethods(), invocationOnInterface);
             //then
             fail();
-        } catch (MockitoException expected) {}
+        } catch (MockitoException e) {}
     }
-
+            
     @Test
     public void should_be_OK_when_calling_real_method_on_concrete_class() throws Throwable {
         //given
@@ -194,31 +194,4 @@ public class AnswersValidatorTest {
         }
     }
 
-    @Test
-    public void should_fail_if_returned_value_of_answer_is_incompatible_with_return_type() throws Throwable {
-        try {
-            validator.validateDefaultAnswerReturnedValue(
-                    new InvocationBuilder().method("toString").toInvocation(),
-                    AWrongType.WRONG_TYPE
-            );
-            fail();
-        } catch (WrongTypeOfReturnValue e) {
-            assertThat(e.getMessage())
-                    .containsIgnoringCase("Default answer returned a result with the wrong type")
-                    .containsIgnoringCase("AWrongType cannot be returned by toString()")
-                    .containsIgnoringCase("toString() should return String");
-        }
-    }
-
-    @Test
-    public void should_not_fail_if_returned_value_of_answer_is_null() throws Throwable {
-        validator.validateDefaultAnswerReturnedValue(
-                new InvocationBuilder().method("toString").toInvocation(),
-                null
-        );
-    }
-
-    private static class AWrongType {
-        public static final AWrongType WRONG_TYPE = new AWrongType();
-    }
-}
+}
\ No newline at end of file
diff --git a/test/org/mockito/internal/verification/NoMoreInteractionsTest.java b/test/org/mockito/internal/verification/NoMoreInteractionsTest.java
index e8c930307..4b52575d6 100644
--- a/test/org/mockito/internal/verification/NoMoreInteractionsTest.java
+++ b/test/org/mockito/internal/verification/NoMoreInteractionsTest.java
@@ -1,37 +1,35 @@
-/*
- * Copyright (c) 2007 Mockito contributors
- * This program is made available under the terms of the MIT License.
- */
+/*
+ * Copyright (c) 2007 Mockito contributors
+ * This program is made available under the terms of the MIT License.
+ */
 package org.mockito.internal.verification;
 
-import org.fest.assertions.Assertions;
+import static java.util.Arrays.*;
+
+import org.fest.assertions.Assertions;
 import org.junit.Test;
-import org.mockito.exceptions.verification.NoInteractionsWanted;
+import org.mockito.exceptions.verification.NoInteractionsWanted;
 import org.mockito.exceptions.verification.VerificationInOrderFailure;
-import org.mockito.internal.creation.MockSettingsImpl;
+import org.mockito.internal.creation.MockSettingsImpl;
 import org.mockito.internal.invocation.InvocationBuilder;
-import org.mockito.internal.invocation.InvocationMatcher;
-import org.mockito.internal.progress.ThreadSafeMockingProgress;
-import org.mockito.internal.stubbing.InvocationContainerImpl;
+import org.mockito.internal.invocation.InvocationMatcher;
+import org.mockito.internal.progress.ThreadSafeMockingProgress;
+import org.mockito.internal.stubbing.InvocationContainerImpl;
 import org.mockito.internal.verification.api.VerificationDataInOrderImpl;
 import org.mockito.invocation.Invocation;
-import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
-import static java.util.Arrays.asList;
-import static org.mockito.Mockito.mock;
-
 public class NoMoreInteractionsTest extends TestBase {
 
     InOrderContextImpl context = new InOrderContextImpl();
-
+    
     @Test
     public void shouldVerifyInOrder() {
         //given
         NoMoreInteractions n = new NoMoreInteractions();
         Invocation i = new InvocationBuilder().toInvocation();
         assertFalse(context.isVerified(i));
-
+        
         try {
             //when
             n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));
@@ -39,7 +37,7 @@ public class NoMoreInteractionsTest extends TestBase {
             fail();
         } catch(VerificationInOrderFailure e) {}
     }
-
+    
     @Test
     public void shouldVerifyInOrderAndPass() {
         //given
@@ -47,12 +45,12 @@ public class NoMoreInteractionsTest extends TestBase {
         Invocation i = new InvocationBuilder().toInvocation();
         context.markVerified(i);
         assertTrue(context.isVerified(i));
-
+        
         //when
         n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));
         //then no exception is thrown
     }
-
+    
     @Test
     public void shouldVerifyInOrderMultipleInvoctions() {
         //given
@@ -79,43 +77,43 @@ public class NoMoreInteractionsTest extends TestBase {
             n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i, i2), null));
             fail();
         } catch (VerificationInOrderFailure e) {}
+    }
+
+    @Test
+    public void noMoreInteractionsExceptionMessageShouldDescribeMock() {
+        //given
+        NoMoreInteractions n = new NoMoreInteractions();
+        String mock = "a mock";
+        InvocationMatcher i = new InvocationBuilder().mock(mock).toInvocationMatcher();
+
+        InvocationContainerImpl invocations =
+            new InvocationContainerImpl(new ThreadSafeMockingProgress(), new MockSettingsImpl());
+        invocations.setInvocationForPotentialStubbing(i);
+
+        try {
+            //when
+            n.verify(new VerificationDataImpl(invocations, null));
+            //then
+            fail();
+        } catch (NoInteractionsWanted e) {
+            Assertions.assertThat(e.toString()).contains(mock.toString());
+        }
+    }
+
+    @Test
+    public void noMoreInteractionsInOrderExceptionMessageShouldDescribeMock() {
+        //given
+        NoMoreInteractions n = new NoMoreInteractions();
+        String mock = "a mock";
+        Invocation i = new InvocationBuilder().mock(mock).toInvocation();
+
+        try {
+            //when
+            n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));
+            //then
+            fail();
+        } catch (VerificationInOrderFailure e) {
+            Assertions.assertThat(e.toString()).contains(mock.toString());
+        }
     }
-
-    @Test
-    public void noMoreInteractionsExceptionMessageShouldDescribeMock() {
-        //given
-        NoMoreInteractions n = new NoMoreInteractions();
-        IMethods mock = mock(IMethods.class, "a mock");
-        InvocationMatcher i = new InvocationBuilder().mock(mock).toInvocationMatcher();
-
-        InvocationContainerImpl invocations =
-            new InvocationContainerImpl(new ThreadSafeMockingProgress(), new MockSettingsImpl());
-        invocations.setInvocationForPotentialStubbing(i);
-
-        try {
-            //when
-            n.verify(new VerificationDataImpl(invocations, null));
-            //then
-            fail();
-        } catch (NoInteractionsWanted e) {
-            Assertions.assertThat(e.toString()).contains(mock.toString());
-        }
-    }
-
-    @Test
-    public void noMoreInteractionsInOrderExceptionMessageShouldDescribeMock() {
-        //given
-        NoMoreInteractions n = new NoMoreInteractions();
-        IMethods mock = mock(IMethods.class, "a mock");
-        Invocation i = new InvocationBuilder().mock(mock).toInvocation();
-
-        try {
-            //when
-            n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));
-            //then
-            fail();
-        } catch (VerificationInOrderFailure e) {
-            Assertions.assertThat(e.toString()).contains(mock.toString());
-        }
-    }
-}
+}
\ No newline at end of file
diff --git a/test/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java b/test/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java
deleted file mode 100644
index 6b6cc8539..000000000
--- a/test/org/mockitousage/bugs/ClassCastExOnVerifyZeroInteractionsTest.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package org.mockitousage.bugs;
-
-import org.junit.Test;
-import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;
-import org.mockito.exceptions.verification.NoInteractionsWanted;
-import org.mockito.invocation.InvocationOnMock;
-import org.mockito.stubbing.Answer;
-
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verifyZeroInteractions;
-
-public class ClassCastExOnVerifyZeroInteractionsTest {
-    public interface TestMock {
-        boolean m1();
-    }
-
-    @Test(expected = NoInteractionsWanted.class)
-    public void should_not_throw_ClassCastException_when_mock_verification_fails() {
-        TestMock test = mock(TestMock.class, new Answer() {
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                return false;
-            }
-        });
-        test.m1();
-        verifyZeroInteractions(test);
-    }
-
-    @Test(expected = WrongTypeOfReturnValue.class)
-    public void should_report_bogus_default_answer() throws Exception {
-        TestMock test = mock(TestMock.class, new Answer() {
-            public Object answer(InvocationOnMock invocation) throws Throwable {
-                return false;
-            }
-        });
-
-        test.toString();
-    }
-}
diff --git a/test/org/mockitousage/matchers/CapturingArgumentsTest.java b/test/org/mockitousage/matchers/CapturingArgumentsTest.java
index 44c8d87b5..d833e681e 100644
--- a/test/org/mockitousage/matchers/CapturingArgumentsTest.java
+++ b/test/org/mockitousage/matchers/CapturingArgumentsTest.java
@@ -14,6 +14,7 @@ import org.mockito.exceptions.verification.WantedButNotInvoked;
 import org.mockitousage.IMethods;
 import org.mockitoutil.TestBase;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import static org.mockito.Matchers.any;
@@ -124,6 +125,18 @@ public class CapturingArgumentsTest extends TestBase {
         verify(emailService).sendEmailTo(argument.capture());
         assertEquals(null, argument.getValue());
     }
+
+    @Test
+    public void should_allow_construction_of_captor_for_parameterized_type_in_a_convenient_way()  {
+        //the test passes if this expression compiles
+        ArgumentCaptor<List<Person>> argument = ArgumentCaptor.forClass(List.class);
+    }
+
+    @Test
+    public void should_allow_construction_of_captor_for_a_more_specific_type()  {
+        //the test passes if this expression compiles
+        ArgumentCaptor<List> argument = ArgumentCaptor.forClass(ArrayList.class);
+    }
     
     @Test
     public void should_allow_capturing_for_stubbing() {
diff --git a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java
index f30540edb..44a074ef5 100644
--- a/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java
+++ b/test/org/mockitousage/verification/DescriptiveMessagesWhenVerificationFailsTest.java
@@ -33,7 +33,7 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
 
     @Before
     public void setup() {
-        mock = Mockito.mock(IMethods.class, "iMethods");
+        mock = Mockito.mock(IMethods.class);
     }
 
     @Test
@@ -85,8 +85,8 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
                     "iMethods.varargs(1, 1000);";
 
             assertContains(wanted, e.getMessage());
-
-            String actual =
+            
+            String actual = 
                     "\n" +
                     "Actual invocation has different arguments:" +
                     "\n" +
@@ -95,7 +95,7 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             assertContains(actual, e.getMessage());
         }
     }
-
+    
     @Test
     public void should_print_actual_and_wanted_in_multiple_lines() {
         mock.varargs("this is very long string", "this is another very long string");
@@ -296,11 +296,11 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             assertContains("simpleMethod(null, null);", e.getMessage());
         }
     }
-
+    
     @Test
     public void should_say_never_wanted_but_invoked() throws Exception {
         mock.simpleMethod(1);
-
+    
         verify(mock, never()).simpleMethod(2);
         try {
             verify(mock, never()).simpleMethod(1);
@@ -310,12 +310,12 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             assertContains("But invoked here:", e.getMessage());
         }
     }
-
+    
     @Test
     public void should_show_right_actual_method() throws Exception {
         mock.simpleMethod(9191);
         mock.simpleMethod("foo");
-
+    
         try {
             verify(mock).simpleMethod("bar");
             fail();
@@ -326,11 +326,11 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
     }
 
     @Mock private IMethods iHavefunkyName;
-
+    
     @Test
     public void should_print_field_name_when_annotations_used() throws Exception {
         iHavefunkyName.simpleMethod(10);
-
+    
         try {
             verify(iHavefunkyName).simpleMethod(20);
             fail();
@@ -339,12 +339,12 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
             assertContains("iHavefunkyName.simpleMethod(10)", e.getMessage());
         }
     }
-
+    
     @Test
     public void should_print_interactions_on_mock_when_ordinary_verification_fail() throws Exception {
         mock.otherMethod();
         mock.booleanReturningMethod();
-
+        
         try {
             verify(mock).simpleMethod();
             fail();
@@ -353,8 +353,8 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
         }
     }
 
-    @Mock private IMethods veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock;
-
+    @Mock private IMethods veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock; 
+    
     @Test
     public void should_never_break_method_string_when_no_args_in_method() throws Exception {
         try {
@@ -430,4 +430,5 @@ public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {
     public interface AnInterface {
         void foo(int i);
     }
-}
+    
+}
\ No newline at end of file
diff --git a/version.properties b/version.properties
index d00805e8b..a5746b61b 100644
--- a/version.properties
+++ b/version.properties
@@ -1,2 +1,2 @@
-version=2.0.6-beta
+version=2.0.7-beta
 mockito.testng.version=1.0
\ No newline at end of file
